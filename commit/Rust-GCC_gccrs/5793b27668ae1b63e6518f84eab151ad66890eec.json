{"sha": "5793b27668ae1b63e6518f84eab151ad66890eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5M2IyNzY2OGFlMWI2M2U2NTE4Zjg0ZWFiMTUxYWQ2Njg5MGVlYw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-03-01T14:31:21Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-03-01T14:31:21Z"}, "message": "Makefile.in (C_AND_OBJC_OBJS, [...]): Update.\n\n\t* Makefile.in (C_AND_OBJC_OBJS, c-incpath.o, c-lex.o, LIBCPP_OBJS,\n\tcppinit.o, cppdefault.o, fix-header): Update.\n\t* c-incpath.c: New file.\n\t* c-incpath.h: New file.\n\t* c-lex.c: Include c-incpath.h.\n\t(init_c_lex): Register path simplifier.\n\t* c-opts.c: Include cppdefault.h and c-incpath.h.\n\t(TARGET_SYSTEM_ROOT, verbose, iprefix, sysroot, std_inc,\n\tstd_cxx_inc, quote_chain_split, add_prefixed_path): New.\n\t(COMMAND_LINE_OPTIONS): Add more options from cpplib.\n\t(missing_arg, c_common_decode_option): Handle them.\n\t(c_common_post_options): Register include chains.\n\t(print_help): Update.\n\t* cppdefault.h (struct default include): Update.\n\tMove some macros to ...\n\t* cppdefault.c: ... here.\n\t(cpp_include_defaults): Add extra field add_sysroot.\n\t* cppfiles.c (include_file, search_from, find_or_create_entry,\n\tcpp_included, find_include_file, remap_filename): Update for\n\trenaming of search_path to cpp_path, and of the chain headers.\n\t(remove_component_p, _cpp_simplify_pathname): Move to c-incpath.c.\n\t* cpphash.h (struct search_path): Move to cpplib.h.\n\t(struct cpp_buffer, struct cpp_reader): Update.\n\t(_cpp_simplify_pathname): Remove.\n\t* cppinit.c: Don't include prefix.h and cppdefault.h.\n\t(INO_T_EQ, INO_T_COPY, path_include, append_include_chain,\n\tremove_dup_dir, remove_dup_nonsys_dirs, remove_dup_dirs,\n\tinit_standard_includes, BRACKET, SYSTEM, AFTER, no_dir,\n\tno_pth, cpp_handle_options): Remove.\n\t(struct pending_option): Remove chain members.\n\t(cpp_destroy, cpp_read_main_file, COMMAND_LINE_OPTIONS,\n\tcpp_handle_option): Update.\n\t* cpplib.h (struct cpp_path, cpp_set_include_chains): New.\n\t(struct cpp_options): Remove quote_include, bracket_include,\n\tinclude_prefix, include_prefix_len, verbose, ignore_srcdir,\n\tno_standard_includes, no_standard_cplusplus_includes.\n\t(struct cpp_callbacks): Add simplify_path.\n\t(cpp_handle_options): Remove.\n\t* fix-header.c: Include c-incpath.h.\n\t(read_scan_file): Update to use c-incpath functionality.\n\t* doc/passes.texi: Update.\ncp:\n\t* Make-lang.in (CXX_C_OBJS): Update.\n\nFrom-SVN: r63612", "tree": {"sha": "a780e502dea6f5dd1bc734c51de06a64223427b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a780e502dea6f5dd1bc734c51de06a64223427b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5793b27668ae1b63e6518f84eab151ad66890eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5793b27668ae1b63e6518f84eab151ad66890eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5793b27668ae1b63e6518f84eab151ad66890eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5793b27668ae1b63e6518f84eab151ad66890eec/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6620997bdc9419cd243613ecb7b958788ab082cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6620997bdc9419cd243613ecb7b958788ab082cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6620997bdc9419cd243613ecb7b958788ab082cc"}], "stats": {"total": 1644, "additions": 841, "deletions": 803}, "files": [{"sha": "ed7f0ef3ea4ad0c4dc324687979def17f3df5c8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,3 +1,47 @@\n+2003-03-01  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in (C_AND_OBJC_OBJS, c-incpath.o, c-lex.o, LIBCPP_OBJS,\n+\tcppinit.o, cppdefault.o, fix-header): Update.\n+\t* c-incpath.c: New file.\n+\t* c-incpath.h: New file.\n+\t* c-lex.c: Include c-incpath.h.\n+\t(init_c_lex): Register path simplifier.\n+\t* c-opts.c: Include cppdefault.h and c-incpath.h.\n+\t(TARGET_SYSTEM_ROOT, verbose, iprefix, sysroot, std_inc,\n+\tstd_cxx_inc, quote_chain_split, add_prefixed_path): New.\n+\t(COMMAND_LINE_OPTIONS): Add more options from cpplib.\n+\t(missing_arg, c_common_decode_option): Handle them.\n+\t(c_common_post_options): Register include chains.\n+\t(print_help): Update.\n+\t* cppdefault.h (struct default include): Update.\n+\tMove some macros to ...\n+\t* cppdefault.c: ... here.\n+\t(cpp_include_defaults): Add extra field add_sysroot.\n+\t* cppfiles.c (include_file, search_from, find_or_create_entry,\n+\tcpp_included, find_include_file, remap_filename): Update for\n+\trenaming of search_path to cpp_path, and of the chain headers.\n+\t(remove_component_p, _cpp_simplify_pathname): Move to c-incpath.c.\n+\t* cpphash.h (struct search_path): Move to cpplib.h.\n+\t(struct cpp_buffer, struct cpp_reader): Update.\n+\t(_cpp_simplify_pathname): Remove.\n+\t* cppinit.c: Don't include prefix.h and cppdefault.h.\n+\t(INO_T_EQ, INO_T_COPY, path_include, append_include_chain,\n+\tremove_dup_dir, remove_dup_nonsys_dirs, remove_dup_dirs,\n+\tinit_standard_includes, BRACKET, SYSTEM, AFTER, no_dir,\n+\tno_pth, cpp_handle_options): Remove.\n+\t(struct pending_option): Remove chain members.\n+\t(cpp_destroy, cpp_read_main_file, COMMAND_LINE_OPTIONS,\n+\tcpp_handle_option): Update.\n+\t* cpplib.h (struct cpp_path, cpp_set_include_chains): New.\n+\t(struct cpp_options): Remove quote_include, bracket_include,\n+\tinclude_prefix, include_prefix_len, verbose, ignore_srcdir,\n+\tno_standard_includes, no_standard_cplusplus_includes.\n+\t(struct cpp_callbacks): Add simplify_path.\n+\t(cpp_handle_options): Remove.\n+\t* fix-header.c: Include c-incpath.h.\n+\t(read_scan_file): Update to use c-incpath functionality.\n+\t* doc/passes.texi: Update.\n+\n 2003-03-01  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.c (bit_operand): Accept MEM only if it"}, {"sha": "22c1fe5d25d481866e146a4cbf66961612aeaaec", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -759,6 +759,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n+  c-incpath.o cppdefault.o \\\n   c-objc-common.o c-dump.o c-pch.o libcpp.a $(C_TARGET_OBJS)\n \n # Language-specific object files for C.\n@@ -1218,6 +1219,9 @@ $(parsedir)/c-parse.y: c-parse.in\n \t  $(srcdir)/c-parse.in >>tmp-c-parse.y\n \t$(SHELL) $(srcdir)/move-if-change tmp-c-parse.y $(parsedir)/c-parse.y\n \n+c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n+\t\tintl.h prefix.h coretypes.h $(TM_H) cppdefault.h\n+\n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n     $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h $(EXPR_H) \\\n     debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h \\\n@@ -1226,8 +1230,8 @@ c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(GGC_H) langhooks.h $(LANGHOOKS_DEF_H) c-common.h gtype-c.h\n-c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n-    debug.h $(C_TREE_H) c-common.h real.h \\\n+c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+    $(RTL_H) debug.h $(C_TREE_H) c-common.h real.h c-incpath.h cppdefault.h \\\n     c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n     mbchar.h $(CPPLIB_H) $(EXPR_H) $(TM_P_H)\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -2271,7 +2275,7 @@ PREPROCESSOR_DEFINES = \\\n   @TARGET_SYSTEM_ROOT_DEFINE@\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n-\t\tcpphash.o cpperror.o cppinit.o cppdefault.o cppmain.o \\\n+\t\tcpphash.o cpperror.o cppinit.o cppmain.o \\\n \t\thashtable.o line-map.o mkdeps.o prefix.o mbchar.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n@@ -2294,11 +2298,11 @@ cpplib.o:   cpplib.c   $(LIBCPP_DEPS)\n cpphash.o:  cpphash.c  $(LIBCPP_DEPS)\n cpptrad.o:  cpptrad.c  $(LIBCPP_DEPS)\n cppfiles.o: cppfiles.c $(LIBCPP_DEPS) $(SPLAY_TREE_H) mkdeps.h\n-cppinit.o:  cppinit.c  $(LIBCPP_DEPS) cppdefault.h mkdeps.h prefix.h\n+cppinit.o:  cppinit.c  $(LIBCPP_DEPS) mkdeps.h prefix.h\n cpppch.o:   cpppch.c   $(LIBCPP_DEPS) mkdeps.h\n \n-cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) cppdefault.h \\\n-\tMakefile\n+cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+\tcppdefault.h Makefile\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t  $(PREPROCESSOR_DEFINES) \\\n \t  -c $(srcdir)/cppdefault.c $(OUTPUT_OPTION)\n@@ -2512,9 +2516,9 @@ xsys-protos.h: $(GCC_PASSES) $(srcdir)/sys-protos.h deduced.h gen-protos$(build_\n # This is nominally a 'build' program, but it's run only when host==build,\n # so we can (indeed, must) use $(LIBDEPS) and $(LIBS).\n fix-header$(build_exeext): fix-header.o scan-decls.o scan.o xsys-protos.h \\\n-           $(LIBDEPS) libcpp.a\n+           c-incpath.o cppdefault.o $(LIBDEPS) libcpp.a\n \t$(BUILD_CC) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ fix-header.o \\\n-\t   scan-decls.o scan.o libcpp.a $(LIBS)\n+\t   c-incpath.o cppdefault.o scan-decls.o scan.o libcpp.a $(LIBS)\n \n fix-header.o: fix-header.c $(OBSTACK_H) scan.h \\\n \txsys-protos.h $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(CPPLIB_H)"}, {"sha": "96bf69d7e28c1e0ac77a7eae521486e6294913ff", "filename": "gcc/c-incpath.c", "status": "added", "additions": 510, "deletions": 0, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -0,0 +1,510 @@\n+/* Set up combined include path chain for the preprocessor.\n+   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+\n+   Broken out of cppinit.c and cppfiles.c and rewritten Mar 2003.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"cpplib.h\"\n+#include \"prefix.h\"\n+#include \"intl.h\"\n+#include \"c-incpath.h\"\n+#include \"cppdefault.h\"\n+\n+/* Windows does not natively support inodes, and neither does MSDOS.\n+   Cygwin's emulation can generate non-unique inodes, so don't use it.\n+   VMS has non-numeric inodes.  */\n+#ifdef VMS\n+# define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))\n+# define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))\n+#else\n+# if (defined _WIN32 && ! defined (_UWIN)) || defined __MSDOS__\n+#  define INO_T_EQ(A, B) 0\n+# else\n+#  define INO_T_EQ(A, B) ((A) == (B))\n+# endif\n+# define INO_T_COPY(DEST, SRC) (DEST) = (SRC)\n+#endif\n+\n+static void add_env_var_paths PARAMS ((const char *, int));\n+static void add_standard_paths PARAMS ((const char *, const char *, int));\n+static void free_path PARAMS ((struct cpp_path *, int));\n+static void merge_include_chains PARAMS ((cpp_reader *, int));\n+static int remove_component_p PARAMS ((const char *));\n+static struct cpp_path *\n+  remove_duplicates PARAMS ((cpp_reader *, struct cpp_path *,\n+\t\t\t     struct cpp_path *, struct cpp_path *, int));\n+\n+/* Include chains heads and tails.  */\n+static struct cpp_path *heads[4];\n+static struct cpp_path *tails[4];\n+static bool quote_ignores_source_dir;\n+enum { REASON_QUIET = 0, REASON_NOENT, REASON_DUP, REASON_DUP_SYS };\n+\n+/* Free an element of the include chain, possibly giving a reason.  */\n+static void\n+free_path (path, reason)\n+     struct cpp_path *path;\n+     int reason;\n+{\n+  switch (reason)\n+    {\n+    case REASON_DUP:\n+    case REASON_DUP_SYS:\n+      fprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"), path->name);\n+      if (reason == REASON_DUP_SYS)\n+\tfprintf (stderr,\n+ _(\"  as it is a non-system directory that duplicates a system directory\\n\"));\n+      break;\n+\n+    case REASON_NOENT:\n+      fprintf (stderr, _(\"ignoring nonexistent directory \\\"%s\\\"\\n\"),\n+\t       path->name);\n+      break;\n+\n+    case REASON_QUIET:\n+    default:\n+      break;\n+    }\n+\n+  free ((PTR) path->name);\n+  free (path);\n+}\n+\n+/* Read ENV_VAR for a PATH_SEPARATOR-separated list of file names; and\n+   append all the names to the search path CHAIN.  */\n+static void\n+add_env_var_paths (env_var, chain)\n+     const char *env_var;\n+     int chain;\n+{\n+  char *p, *q, *path;\n+\n+  GET_ENVIRONMENT (q, env_var);\n+\n+  if (!q)\n+    return;\n+\n+  for (p = q; *q; p = q + 1)\n+    {\n+      q = p;\n+      while (*q != 0 && *q != PATH_SEPARATOR)\n+\tq++;\n+\n+      if (p == q)\n+\tpath = xstrdup (\".\");\n+      else\n+\t{\n+\t  path = xmalloc (q - p + 1);\n+\t  memcpy (path, p, q - p);\n+\t  path[q - p] = '\\0';\n+\t}\n+\n+      add_path (path, chain, chain == SYSTEM);\n+    }\n+}\n+\n+/* Append the standard include chain defined in cppdefault.c.  */\n+static void\n+add_standard_paths (sysroot, iprefix, cxx_stdinc)\n+     const char *sysroot, *iprefix;\n+     int cxx_stdinc;\n+{\n+  const struct default_include *p;\n+  size_t len = 0;\n+\n+  if (iprefix)\n+    len = cpp_GCC_INCLUDE_DIR_len;\n+\n+  for (p = cpp_include_defaults; p->fname; p++)\n+    {\n+      if (!p->cplusplus || cxx_stdinc)\n+\t{\n+\t  char *str;\n+\n+\t  /* Should this directory start with the sysroot?  */\n+\t  if (sysroot && p->add_sysroot)\n+\t    str = concat (sysroot, p->fname, NULL);\n+\t  /* Does this directory start with the prefix?  If so, search\n+\t     \"translated\" versions of GNU directories.  These have\n+\t     /usr/local/lib/gcc... replaced by iprefix.  */\n+\t  else if (len && !strncmp (p->fname, cpp_GCC_INCLUDE_DIR, len))\n+\t    str = concat (iprefix, p->fname + len, NULL);\n+\t  else\n+\t    str = update_path (p->fname, p->component);\n+\n+\t  add_path (str, SYSTEM, p->cxx_aware);\n+\t}\n+    }\n+}\n+\n+/* For each duplicate path in chain HEAD, keep just the first one.\n+   Remove each path in chain HEAD that also exists in chain SYSTEM.\n+   Set the NEXT pointer of the last path in the resulting chain to\n+   JOIN, unless it duplicates JOIN in which case the last path is\n+   removed.  Return the head of the resulting chain.  Any of HEAD,\n+   JOIN and SYSTEM can be NULL.  */\n+static struct cpp_path *\n+remove_duplicates (pfile, head, system, join, verbose)\n+     cpp_reader *pfile;\n+     struct cpp_path *head;\n+     struct cpp_path *system;\n+     struct cpp_path *join;\n+     int verbose;\n+{\n+  struct cpp_path **pcur, *tmp, *cur;\n+  struct stat st;\n+\n+  for (pcur = &head; *pcur; )\n+    {\n+      int reason = REASON_QUIET;\n+\n+      cur = *pcur;\n+      simplify_path (cur->name);\n+\n+      if (stat (cur->name, &st))\n+\t{\n+\t  /* Dirs that don't exist are silently ignored, unless verbose.  */\n+\t  if (errno != ENOENT)\n+\t    cpp_errno (pfile, DL_ERROR, cur->name);\n+\t  else\n+\t    reason = REASON_NOENT;\n+\t}\n+      else if (!S_ISDIR (st.st_mode))\n+\tcpp_error_with_line (pfile, DL_ERROR, 0, 0,\n+\t\t\t     \"%s: not a directory\", cur->name);\n+      else\n+\t{\n+\t  INO_T_COPY (cur->ino, st.st_ino);\n+\t  cur->dev  = st.st_dev;\n+\n+\t  /* Remove this one if it is in the system chain.  */\n+\t  reason = REASON_DUP_SYS;\n+\t  for (tmp = system; tmp; tmp = tmp->next)\n+\t    if (INO_T_EQ (tmp->ino, cur->ino) && tmp->dev == cur->dev)\n+\t      break;\n+\n+\t  if (!tmp)\n+\t    {\n+\t      /* Dupicate of something earlier in the same chain?  */\n+\t      reason = REASON_DUP;\n+\t      for (tmp = head; tmp != cur; tmp = tmp->next)\n+\t\tif (INO_T_EQ (cur->ino, tmp->ino) && cur->dev == tmp->dev)\n+\t\t  break;\n+\n+\t      if (tmp == cur\n+\t\t  /* Last in the chain and duplicate of JOIN?  */\n+\t\t  && !(cur->next == NULL && join\n+\t\t       && INO_T_EQ (cur->ino, join->ino)\n+\t\t       && cur->dev == join->dev))\n+\t\t{\n+\t\t  /* Unique, so keep this directory.  */\n+\t\t  pcur = &cur->next;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Remove this entry from the chain.  */\n+      *pcur = cur->next;\n+      free_path (cur, verbose ? reason: REASON_QUIET);\n+    }\n+\n+  *pcur = join;\n+  return head;\n+}\n+\n+/* Merge the four include chains together in the order quote, bracket,\n+   system, after.  Remove duplicate dirs (as determined by\n+   INO_T_EQ()).\n+\n+   We can't just merge the lists and then uniquify them because then\n+   we may lose directories from the <> search path that should be\n+   there; consider -Ifoo -Ibar -I- -Ifoo -Iquux.  It is however safe\n+   to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written -Ibar -I- -Ifoo\n+   -Iquux.  */\n+static void\n+merge_include_chains (pfile, verbose)\n+     cpp_reader *pfile;\n+     int verbose;\n+{\n+  /* Join the SYSTEM and AFTER chains.  Remove duplicates in the\n+     resulting SYSTEM chain.  */\n+  if (heads[SYSTEM])\n+    tails[SYSTEM]->next = heads[AFTER];\n+  else\n+    heads[SYSTEM] = heads[AFTER];\n+  heads[SYSTEM] = remove_duplicates (pfile, heads[SYSTEM], 0, 0, verbose);\n+\n+  /* Remove duplicates from BRACKET that are in itself or SYSTEM, and\n+     join it to SYSTEM.  */\n+  heads[BRACKET] = remove_duplicates (pfile, heads[BRACKET], heads[SYSTEM],\n+\t\t\t\t      heads[SYSTEM], verbose);\n+\n+  /* Remove duplicates from QUOTE that are in itself or SYSTEM, and\n+     join it to BRACKET.  */\n+  heads[QUOTE] = remove_duplicates (pfile, heads[QUOTE], heads[SYSTEM],\n+\t\t\t\t    heads[BRACKET], verbose);\n+\n+  /* If verbose, print the list of dirs to search.  */\n+  if (verbose)\n+    {\n+      struct cpp_path *p;\n+\n+      fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n+      for (p = heads[QUOTE];; p = p->next)\n+\t{\n+\t  if (p == heads[BRACKET])\n+\t    fprintf (stderr, _(\"#include <...> search starts here:\\n\"));\n+\t  if (!p)\n+\t    break;\n+\t  fprintf (stderr, \" %s\\n\", p->name);\n+\t}\n+      fprintf (stderr, _(\"End of search list.\\n\"));\n+    }\n+}\n+\n+/* Use given -I paths for #include \"...\" but not #include <...>, and\n+   don't search the directory of the present file for #include \"...\".\n+   (Note that -I. -I- is not the same as the default setup; -I. uses\n+   the compiler's working dir.)  */\n+void\n+split_quote_chain ()\n+{\n+  heads[QUOTE] = heads[BRACKET];\n+  tails[QUOTE] = tails[BRACKET];\n+  heads[BRACKET] = NULL;\n+  tails[BRACKET] = NULL;\n+  /* This is NOT redundant.  */\n+  quote_ignores_source_dir = true;\n+}\n+\n+/* Add PATH to the include chain CHAIN. PATH must be malloc-ed and\n+   NUL-terminated.  */\n+void\n+add_path (path, chain, cxx_aware)\n+     char *path;\n+     int chain;\n+     int cxx_aware;\n+{\n+  struct cpp_path *p;\n+\n+  p = (struct cpp_path *) xmalloc (sizeof (struct cpp_path));\n+  p->next = NULL;\n+  p->name = path;\n+  if (chain == SYSTEM || chain == AFTER)\n+    p->sysp = 1 + (cxx_aware != 0);\n+  else\n+    p->sysp = 0;\n+\n+  if (tails[chain])\n+    tails[chain]->next = p;\n+  else\n+    heads[chain] = p;\n+  tails[chain] = p;\n+}\n+\n+/* Exported function to handle include chain merging, duplicate\n+   removal, and registration with cpplib.  */\n+void\n+register_include_chains (pfile, sysroot, iprefix,\n+\t\t\t stdinc, cxx_stdinc, verbose)\n+     cpp_reader *pfile;\n+     const char *sysroot, *iprefix;\n+     int stdinc, cxx_stdinc, verbose;\n+{\n+  static const char *const lang_env_vars[] =\n+    { \"C_INCLUDE_PATH\", \"CPLUS_INCLUDE_PATH\",\n+      \"OBJC_INCLUDE_PATH\", \"OBJCPLUS_INCLUDE_PATH\" };\n+  cpp_options *cpp_opts = cpp_get_options (pfile);\n+  size_t idx = (cpp_opts->objc ? 2: 0);\n+\n+  if (cpp_opts->cplusplus)\n+    idx++;\n+  else\n+    cxx_stdinc = false;\n+\n+  /* CPATH and language-dependent environment variables may add to the\n+     include chain.  */\n+  add_env_var_paths (\"CPATH\", BRACKET);\n+  add_env_var_paths (lang_env_vars[idx], SYSTEM);\n+\n+  /* Finally chain on the standard directories.  */\n+  if (stdinc)\n+    add_standard_paths (sysroot, iprefix, cxx_stdinc);\n+\n+  merge_include_chains (pfile, verbose);\n+\n+  cpp_set_include_chains (pfile, heads[QUOTE], heads[BRACKET],\n+\t\t\t  quote_ignores_source_dir);\n+}\n+\n+/* Returns true if it is safe to remove the final component of path,\n+   when it is followed by a \"..\" component.  We use lstat to avoid\n+   symlinks if we have it.  If not, we can still catch errors with\n+   stat ().  */\n+static int\n+remove_component_p (path)\n+     const char *path;\n+{\n+  struct stat s;\n+  int result;\n+\n+#ifdef HAVE_LSTAT\n+  result = lstat (path, &s);\n+#else\n+  result = stat (path, &s);\n+#endif\n+\n+  /* There's no guarantee that errno will be unchanged, even on\n+     success.  Cygwin's lstat(), for example, will often set errno to\n+     ENOSYS.  In case of success, reset errno to zero.  */\n+  if (result == 0)\n+    errno = 0;\n+\n+  return result == 0 && S_ISDIR (s.st_mode);\n+}\n+\n+/* Simplify a path name in place, deleting redundant components.  This\n+   reduces OS overhead and guarantees that equivalent paths compare\n+   the same (modulo symlinks).\n+\n+   Transforms made:\n+   foo/bar/../quux\tfoo/quux\n+   foo/./bar\t\tfoo/bar\n+   foo//bar\t\tfoo/bar\n+   /../quux\t\t/quux\n+   //quux\t\t//quux  (POSIX allows leading // as a namespace escape)\n+\n+   Guarantees no trailing slashes.  All transforms reduce the length\n+   of the string.  Returns PATH.  errno is 0 if no error occurred;\n+   nonzero if an error occurred when using stat () or lstat ().  */\n+void\n+simplify_path (path)\n+     char *path ATTRIBUTE_UNUSED;\n+{\n+#ifndef VMS\n+  char *from, *to;\n+  char *base, *orig_base;\n+  int absolute = 0;\n+\n+  errno = 0;\n+  /* Don't overflow the empty path by putting a '.' in it below.  */\n+  if (*path == '\\0')\n+    return;\n+\n+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n+  /* Convert all backslashes to slashes.  */\n+  for (from = path; *from; from++)\n+    if (*from == '\\\\') *from = '/';\n+\n+  /* Skip over leading drive letter if present.  */\n+  if (ISALPHA (path[0]) && path[1] == ':')\n+    from = to = &path[2];\n+  else\n+    from = to = path;\n+#else\n+  from = to = path;\n+#endif\n+\n+  /* Remove redundant leading /s.  */\n+  if (*from == '/')\n+    {\n+      absolute = 1;\n+      to++;\n+      from++;\n+      if (*from == '/')\n+\t{\n+\t  if (*++from == '/')\n+\t    /* 3 or more initial /s are equivalent to 1 /.  */\n+\t    while (*++from == '/');\n+\t  else\n+\t    /* On some hosts // differs from /; Posix allows this.  */\n+\t    to++;\n+\t}\n+    }\n+\n+  base = orig_base = to;\n+  for (;;)\n+    {\n+      int move_base = 0;\n+\n+      while (*from == '/')\n+\tfrom++;\n+\n+      if (*from == '\\0')\n+\tbreak;\n+\n+      if (*from == '.')\n+\t{\n+\t  if (from[1] == '\\0')\n+\t    break;\n+\t  if (from[1] == '/')\n+\t    {\n+\t      from += 2;\n+\t      continue;\n+\t    }\n+\t  else if (from[1] == '.' && (from[2] == '/' || from[2] == '\\0'))\n+\t    {\n+\t      /* Don't simplify if there was no previous component.  */\n+\t      if (absolute && orig_base == to)\n+\t\t{\n+\t\t  from += 2;\n+\t\t  continue;\n+\t\t}\n+\t      /* Don't simplify if the previous component was \"../\",\n+\t\t or if an error has already occurred with (l)stat.  */\n+\t      if (base != to && errno == 0)\n+\t\t{\n+\t\t  /* We don't back up if it's a symlink.  */\n+\t\t  *to = '\\0';\n+\t\t  if (remove_component_p (path))\n+\t\t    {\n+\t\t      while (to > base && *to != '/')\n+\t\t\tto--;\n+\t\t      from += 2;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      move_base = 1;\n+\t    }\n+\t}\n+\n+      /* Add the component separator.  */\n+      if (to > orig_base)\n+\t*to++ = '/';\n+\n+      /* Copy this component until the trailing null or '/'.  */\n+      while (*from != '\\0' && *from != '/')\n+\t*to++ = *from++;\n+\n+      if (move_base)\n+\tbase = to;\n+    }\n+\n+  /* Change the empty string to \".\" so that it is not treated as stdin.\n+     Null terminate.  */\n+  if (to == path)\n+    *to++ = '.';\n+  *to = '\\0';\n+#else  /* VMS */\n+  errno = 0;\n+#endif /* !VMS  */\n+}"}, {"sha": "860ea3cdc95cda8a6bbfe09ba741f543ab978c7a", "filename": "gcc/c-incpath.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-incpath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-incpath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.h?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -0,0 +1,24 @@\n+/* Set up combined include path for the preprocessor.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n+\n+extern void split_quote_chain\tPARAMS ((void));\n+extern void add_path\t\tPARAMS ((char *, int, int));\n+extern void register_include_chains PARAMS ((cpp_reader *, const char *,\n+\t\t\t\t\t     const char *, int, int, int));\n+extern void simplify_path\tPARAMS ((char *));\n+\n+enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };"}, {"sha": "e0617bd142d07f4c3953521dc676de7bfdd14a52", "filename": "gcc/c-lex.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,6 +1,6 @@\n /* Mainly the interface between cpplib and the C front ends.\n    Copyright (C) 1987, 1988, 1989, 1992, 1994, 1995, 1996, 1997\n-   1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -41,6 +41,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"splay-tree.h\"\n #include \"debug.h\"\n+#include \"c-incpath.h\"\n \n #ifdef MULTIBYTE_CHARS\n #include \"mbchar.h\"\n@@ -124,6 +125,7 @@ init_c_lex (filename)\n   cb->ident = cb_ident;\n   cb->file_change = cb_file_change;\n   cb->def_pragma = cb_def_pragma;\n+  cb->simplify_path = simplify_path;\n   cb->valid_pch = c_common_valid_pch;\n   cb->read_pch = c_common_read_pch;\n "}, {"sha": "c5f25c9938469711aadd359b40635ff80ca7176c", "filename": "gcc/c-opts.c", "status": "modified", "additions": 99, "deletions": 7, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,5 +1,5 @@\n /* C/ObjC/C++ command line option handling.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n This file is part of GCC.\n@@ -32,6 +32,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-inline.h\"\n #include \"diagnostic.h\"\n #include \"intl.h\"\n+#include \"cppdefault.h\"\n+#include \"c-incpath.h\"\n+\n+#ifndef TARGET_SYSTEM_ROOT\n+# define TARGET_SYSTEM_ROOT NULL\n+#endif\n \n /* CPP's options.  */\n static cpp_options *cpp_opts;\n@@ -49,9 +55,27 @@ static bool deps_append;\n /* If dependency switches (-MF etc.) have been given.  */\n static bool deps_seen;\n \n+/* If -v seen.  */\n+static bool verbose;\n+\n /* Dependency output file.  */\n static const char *deps_file;\n \n+/* The prefix given by -iprefix, if any.  */\n+static const char *iprefix;\n+\n+/* The system root, if any.  Overridden by -isysroot.  */\n+static const char *sysroot = TARGET_SYSTEM_ROOT;\n+\n+/* Zero disables all standard directories for headers.  */\n+static bool std_inc = true;\n+\n+/* Zero disables the C++-specific standard directories for headers.  */\n+static bool std_cxx_inc = true;\n+\n+/* If the quote chain has been split by -I-.  */\n+static bool quote_chain_split;\n+\n /* Number of deferred options, deferred options array size.  */\n static size_t deferred_count, deferred_size;\n \n@@ -69,6 +93,7 @@ static void check_deps_environment_vars PARAMS ((void));\n static void preprocess_file PARAMS ((void));\n static void handle_deferred_opts PARAMS ((void));\n static void sanitize_cpp_opts PARAMS ((void));\n+static void add_prefixed_path PARAMS ((const char *, size_t));\n \n #ifndef STDC_0_IN_SYSTEM_HEADERS\n #define STDC_0_IN_SYSTEM_HEADERS 0\n@@ -117,6 +142,7 @@ static void sanitize_cpp_opts PARAMS ((void));\n   OPT(\"CC\",                     CL_ALL,   OPT_CC)\t\t\t     \\\n   OPT(\"E\",\t\t\tCL_ALL,   OPT_E)\t\t\t     \\\n   OPT(\"H\",                      CL_ALL,   OPT_H)\t\t\t     \\\n+  OPT(\"I\",                      CL_ALL | CL_ARG, OPT_I)\t\t\t     \\\n   OPT(\"M\",                      CL_ALL,   OPT_M)\t\t\t     \\\n   OPT(\"MD\",                     CL_ALL | CL_SEPARATE, OPT_MD)\t\t     \\\n   OPT(\"MF\",                     CL_ALL | CL_ARG, OPT_MF)\t\t     \\\n@@ -260,6 +286,12 @@ static void sanitize_cpp_opts PARAMS ((void));\n   OPT(\"fweak\",\t\t\tCL_CXX,   OPT_fweak)\t\t\t     \\\n   OPT(\"fxref\",\t\t\tCL_CXX,   OPT_fxref)\t\t\t     \\\n   OPT(\"gen-decls\",\t\tCL_OBJC,  OPT_gen_decls)\t\t     \\\n+  OPT(\"idirafter\",              CL_ALL | CL_ARG, OPT_idirafter)              \\\n+  OPT(\"iprefix\",\t\tCL_ALL | CL_ARG, OPT_iprefix)\t\t     \\\n+  OPT(\"isysroot\",               CL_ALL | CL_ARG, OPT_isysroot)               \\\n+  OPT(\"isystem\",                CL_ALL | CL_ARG, OPT_isystem)                \\\n+  OPT(\"iwithprefix\",            CL_ALL | CL_ARG, OPT_iwithprefix)            \\\n+  OPT(\"iwithprefixbefore\",      CL_ALL | CL_ARG, OPT_iwithprefixbefore)\t     \\\n   OPT(\"lang-asm\",\t\tCL_C_ONLY, OPT_lang_asm)\t\t     \\\n   OPT(\"lang-objc\",              CL_ALL,   OPT_lang_objc)\t\t     \\\n   OPT(\"nostdinc\",               CL_ALL,   OPT_nostdinc)\t\t\t     \\\n@@ -357,6 +389,9 @@ missing_arg (opt_index)\n     case OPT_fname_mangling:\n     case OPT_ftabstop:\n     case OPT_ftemplate_depth:\n+    case OPT_iprefix:\n+    case OPT_iwithprefix:\n+    case OPT_iwithprefixbefore:\n     default:\n       error (\"missing argument to \\\"-%s\\\"\", opt_text);\n       break;\n@@ -365,6 +400,13 @@ missing_arg (opt_index)\n       error (\"no class name specified with \\\"-%s\\\"\", opt_text);\n       break;\n \n+    case OPT_I:\n+    case OPT_idirafter:\n+    case OPT_isysroot:\n+    case OPT_isystem:\n+      error (\"missing path after \\\"-%s\\\"\", opt_text);\n+      break;\n+\n     case OPT_MF:\n     case OPT_MD:\n     case OPT_MMD:\n@@ -654,6 +696,18 @@ c_common_decode_option (argc, argv)\n       cpp_opts->print_include_names = 1;\n       break;\n \n+    case OPT_I:\n+      if (strcmp (arg, \"-\"))\n+\tadd_path (xstrdup (arg), BRACKET, 0);\n+      else\n+\t{\n+\t  if (quote_chain_split)\n+\t    error (\"-I- specified twice\");\n+\t  quote_chain_split = true;\n+\t  split_quote_chain ();\n+\t}\n+      break;\n+\n     case OPT_M:\n     case OPT_MM:\n       /* When doing dependencies with -M or -MM, suppress normal\n@@ -1264,6 +1318,30 @@ c_common_decode_option (argc, argv)\n       flag_gen_declaration = 1;\n       break;\n \n+    case OPT_idirafter:\n+      add_path (xstrdup (arg), AFTER, 0);\n+      break;\n+\n+    case OPT_iprefix:\n+      iprefix = arg;\n+      break;\n+\n+    case OPT_isysroot:\n+      sysroot = arg;\n+      break;\n+\n+    case OPT_isystem:\n+      add_path (xstrdup (arg), SYSTEM, 0);\n+      break;\n+\n+    case OPT_iwithprefix:\n+      add_prefixed_path (arg, SYSTEM);\n+      break;\n+\n+    case OPT_iwithprefixbefore:\n+      add_prefixed_path (arg, BRACKET);\n+      break;\n+\n     case OPT_lang_asm:\n       cpp_set_lang (parse_in, CLK_ASM);\n       break;\n@@ -1273,14 +1351,11 @@ c_common_decode_option (argc, argv)\n       break;\n \n     case OPT_nostdinc:\n-      /* No default include directories.  You must specify all\n-\t include-file directories with -I.  */\n-      cpp_opts->no_standard_includes = 1;\n+      std_inc = false;\n       break;\n \n     case OPT_nostdincplusplus:\n-      /* No default C++-specific include directories.  */\n-      cpp_opts->no_standard_cplusplus_includes = 1;\n+      std_cxx_inc = false;\n       break;\n \n     case OPT_o:\n@@ -1356,7 +1431,7 @@ c_common_decode_option (argc, argv)\n       break;\n \n     case OPT_v:\n-      cpp_opts->verbose = 1;\n+      verbose = true;\n       break;\n     }\n \n@@ -1384,6 +1459,10 @@ c_common_post_options ()\n \n   sanitize_cpp_opts ();\n \n+  register_include_chains (parse_in, sysroot, iprefix,\n+\t\t\t   std_inc, std_cxx_inc && c_language == clk_cplusplus,\n+\t\t\t   verbose);\n+\n   flag_inline_trees = 1;\n \n   /* Use tree inlining if possible.  Function instrumentation is only\n@@ -1607,6 +1686,18 @@ sanitize_cpp_opts ()\n     = warn_long_long && ((!flag_isoc99 && pedantic) || warn_traditional);\n }\n \n+/* Add include path with a prefix at the front of its name.  */\n+static void\n+add_prefixed_path (suffix, chain)\n+     const char *suffix;\n+     size_t chain;\n+{\n+  const char *prefix;\n+\n+  prefix = iprefix ? iprefix: cpp_GCC_INCLUDE_DIR;\n+  add_path (concat (prefix, suffix), chain, 0);\n+}\n+\n /* Set the C 89 standard (with 1994 amendments if C94, without GNU\n    extensions if ISO).  There is no concept of gnu94.  */\n static void\n@@ -1808,6 +1899,7 @@ Switches:\\n\\\n   fputs (_(\"\\\n   -f[no-]preprocessed       Treat the input file as already preprocessed\\n\\\n   -ftabstop=<number>        Distance between tab stops for column reporting\\n\\\n+  -isysroot <dir>           Set <dir> to be the system root directory\\n\\\n   -P                        Do not generate #line directives\\n\\\n   -remap                    Remap file names when including files\\n\\\n   --help                    Display this information\\n\\"}, {"sha": "c5db4812b0112d8db919d6e538ba405bc4cb2d69", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,3 +1,7 @@\n+2003-03-01  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Update.\n+\n 2003-02-28  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9892"}, {"sha": "da874b900e4d72ddb051407d6a1b312bc3759b08", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -79,7 +79,8 @@ g++-cross$(exeext): g++$(exeext)\n # The compiler itself.\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n-\tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o\n+\tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \\\n+\tc-incpath.o cppdefault.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\"}, {"sha": "cc96da7f6db3254504954afe67188d1084612edb", "filename": "gcc/cppdefault.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppdefault.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppdefault.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppdefault.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,6 +1,6 @@\n /* CPP Library.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -19,15 +19,28 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n-/* This file contains data definitions shared between cpplib and\n-   tradcpp.  */\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"cppdefault.h\"\n \n+#ifndef STANDARD_INCLUDE_DIR\n+#define STANDARD_INCLUDE_DIR \"/usr/include\"\n+#endif\n+\n+#ifndef STANDARD_INCLUDE_COMPONENT\n+#define STANDARD_INCLUDE_COMPONENT 0\n+#endif\n+\n+#if defined (CROSS_COMPILE) && !defined (TARGET_SYSTEM_ROOT)\n+# undef LOCAL_INCLUDE_DIR\n+# undef SYSTEM_INCLUDE_DIR\n+# undef STANDARD_INCLUDE_DIR\n+#else\n+# undef CROSS_INCLUDE_DIR\n+#endif\n+\n const struct default_include cpp_include_defaults[]\n #ifdef INCLUDE_DEFAULTS\n = INCLUDE_DEFAULTS;"}, {"sha": "368e082c79d9cd3756773a8db7d8df2e8ffb0749", "filename": "gcc/cppdefault.h", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppdefault.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppdefault.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppdefault.h?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,6 +1,6 @@\n /* CPP Library.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -22,26 +22,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #ifndef GCC_CPPDEFAULT_H\n #define GCC_CPPDEFAULT_H\n \n-/* This header contains declarations and/or #defines for all the\n-   hard-wired defaults in cpp.  Note it's used by both cpplib and\n-   tradcpp.  */\n-\n-#ifndef STANDARD_INCLUDE_DIR\n-#define STANDARD_INCLUDE_DIR \"/usr/include\"\n-#endif\n-\n-#ifndef STANDARD_INCLUDE_COMPONENT\n-#define STANDARD_INCLUDE_COMPONENT 0\n-#endif\n-\n-#if defined (CROSS_COMPILE) && !defined (TARGET_SYSTEM_ROOT)\n-# undef LOCAL_INCLUDE_DIR\n-# undef SYSTEM_INCLUDE_DIR\n-# undef STANDARD_INCLUDE_DIR\n-#else\n-# undef CROSS_INCLUDE_DIR\n-#endif\n-\n /* This is the default list of directories to search for include files.\n    It may be overridden by the various -I and -ixxx options.\n \n@@ -57,11 +37,11 @@ struct default_include\n   const char *const fname;\t/* The name of the directory.  */\n   const char *const component;\t/* The component containing the directory\n \t\t\t\t   (see update_path in prefix.c) */\n-  const int cplusplus;\t\t/* Only look here if we're compiling C++.  */\n-  const int cxx_aware;\t\t/* Includes in this directory don't need to\n+  const char cplusplus;\t\t/* Only look here if we're compiling C++.  */\n+  const char cxx_aware;\t\t/* Includes in this directory don't need to\n \t\t\t\t   be wrapped in extern \"C\" when compiling\n \t\t\t\t   C++.  */\n-  const int add_sysroot;\t/* FNAME should be prefixed by\n+  const char add_sysroot;\t/* FNAME should be prefixed by\n \t\t\t\t   cpp_SYSROOT.  */\n };\n "}, {"sha": "502e8a2e161cbf674e5362b6abd4ec17a511b5f2", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 51, "deletions": 173, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,6 +1,6 @@\n /* Part of CPP library.  (include file handling)\n-   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998, 2003,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1998,\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Written by Per Bothner, 1994.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -90,7 +90,7 @@ struct include_file {\n   const char *name;\t\t/* actual path name of file */\n   const char *header_name;\t/* the original header found */\n   const cpp_hashnode *cmacro;\t/* macro, if any, preventing reinclusion.  */\n-  const struct search_path *foundhere;\n+  const struct cpp_path *foundhere;\n \t\t\t\t/* location in search path where file was\n \t\t\t\t   found, for #include_next and sysp.  */\n   const unsigned char *buffer;\t/* pointer to cached file contents */\n@@ -133,8 +133,8 @@ static struct file_name_map *read_name_map\n \t\t\t\tPARAMS ((cpp_reader *, const char *));\n static char *read_filename_string PARAMS ((int, FILE *));\n static char *remap_filename \tPARAMS ((cpp_reader *, char *,\n-\t\t\t\t\t struct search_path *));\n-static struct search_path *search_from PARAMS ((cpp_reader *,\n+\t\t\t\t\t struct cpp_path *));\n+static struct cpp_path *search_from PARAMS ((cpp_reader *,\n \t\t\t\t\t\tenum include_type));\n static struct include_file *\n \tfind_include_file PARAMS ((cpp_reader *, const cpp_token *,\n@@ -153,15 +153,14 @@ static int report_missing_guard\t\tPARAMS ((splay_tree_node, void *));\n static splay_tree_node find_or_create_entry PARAMS ((cpp_reader *,\n \t\t\t\t\t\t     const char *));\n static void handle_missing_header PARAMS ((cpp_reader *, const char *, int));\n-static int remove_component_p\tPARAMS ((const char *));\n \n /* Set up the splay tree we use to store information about all the\n    file names seen in this compilation.  We also have entries for each\n    file we tried to open but failed; this saves system calls since we\n    don't try to open it again in future.\n \n    The key of each node is the file name, after processing by\n-   _cpp_simplify_pathname.  The path name may or may not be absolute.\n+   simplify_path.  The path name may or may not be absolute.\n    The path string has been malloced, as is automatically freed by\n    registering free () as the splay tree key deletion function.\n \n@@ -208,8 +207,7 @@ _cpp_never_reread (file)\n }\n \n /* Lookup a filename, which is simplified after making a copy, and\n-   create an entry if none exists.  errno is nonzero iff a (reported)\n-   stat() error occurred during simplification.  */\n+   create an entry if none exists.  */\n static splay_tree_node\n find_or_create_entry (pfile, fname)\n      cpp_reader *pfile;\n@@ -218,8 +216,15 @@ find_or_create_entry (pfile, fname)\n   splay_tree_node node;\n   struct include_file *file;\n   char *name = xstrdup (fname);\n+  int saved_errno = 0;\n+\n+  if (pfile->cb.simplify_path)\n+    {\n+      errno = 0;\n+      (pfile->cb.simplify_path) (name);\n+      saved_errno = errno;\n+    }\n \n-  _cpp_simplify_pathname (name);\n   node = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) name);\n   if (node)\n     free (name);\n@@ -228,7 +233,7 @@ find_or_create_entry (pfile, fname)\n       file = xcnew (struct include_file);\n       file->name = name;\n       file->header_name = name;\n-      file->err_no = errno;\n+      file->err_no = saved_errno;\n       node = splay_tree_insert (pfile->all_include_files,\n \t\t\t\t(splay_tree_key) file->name,\n \t\t\t\t(splay_tree_value) file);\n@@ -337,7 +342,9 @@ validate_pch (pfile, filename, pchname)\n     file->pch = pfile->cb.valid_pch (pfile, pchname, file->fd);\n   if (INCLUDE_PCH_P (file))\n     {\n-      file->header_name = _cpp_simplify_pathname (xstrdup (filename));\n+      char *f = xstrdup (filename);\n+      (pfile->cb.simplify_path) (f);\n+      file->header_name = f;\n       return file;\n     }\n   close (file->fd);\n@@ -640,7 +647,7 @@ cpp_included (pfile, fname)\n      cpp_reader *pfile;\n      const char *fname;\n {\n-  struct search_path *path;\n+  struct cpp_path *path;\n   char *name, *n;\n   splay_tree_node nd;\n \n@@ -653,7 +660,7 @@ cpp_included (pfile, fname)\n \n   /* Search directory path for the file.  */\n   name = (char *) alloca (strlen (fname) + pfile->max_include_len + 2);\n-  for (path = CPP_OPTION (pfile, quote_include); path; path = path->next)\n+  for (path = pfile->quote_include; path; path = path->next)\n     {\n       memcpy (name, path->name, path->len);\n       name[path->len] = '/';\n@@ -682,7 +689,7 @@ find_include_file (pfile, header, type)\n      enum include_type type;\n {\n   const char *fname = (const char *) header->val.str.text;\n-  struct search_path *path;\n+  struct cpp_path *path;\n   struct include_file *file;\n   char *name, *n;\n \n@@ -695,7 +702,7 @@ find_include_file (pfile, header, type)\n   if (type == IT_INCLUDE_NEXT && pfile->buffer->inc->foundhere)\n     path = pfile->buffer->inc->foundhere->next;\n   else if (header->type == CPP_HEADER_NAME)\n-    path = CPP_OPTION (pfile, bracket_include);\n+    path = pfile->bracket_include;\n   else\n     path = search_from (pfile, type);\n \n@@ -905,7 +912,7 @@ _cpp_pop_file_buffer (pfile, inc)\n \n    If we're handling -include or -imacros, use the \"\" chain, but with\n    the preprocessor's cwd prepended.  */\n-static struct search_path *\n+static struct cpp_path *\n search_from (pfile, type)\n      cpp_reader *pfile;\n      enum include_type type;\n@@ -917,9 +924,9 @@ search_from (pfile, type)\n   if (type == IT_CMDLINE)\n     goto use_cwd;\n \n-  /* Ignore the current file's directory if -I- was given.  */\n-  if (CPP_OPTION (pfile, ignore_srcdir))\n-    return CPP_OPTION (pfile, quote_include);\n+  /* Ignore the current file's directory?  */\n+  if (pfile->quote_ignores_source_dir)\n+    return pfile->quote_include;\n \n   if (! buffer->search_cached)\n     {\n@@ -931,22 +938,22 @@ search_from (pfile, type)\n \t{\n \t  /* We don't guarantee NAME is null-terminated.  This saves\n \t     allocating and freeing memory.  Drop a trailing '/'.  */\n-\t  buffer->dir.name = buffer->inc->name;\n+\t  buffer->dir.name = (char *) buffer->inc->name;\n \t  if (dlen > 1)\n \t    dlen--;\n \t}\n       else\n \t{\n \tuse_cwd:\n-\t  buffer->dir.name = \".\";\n+\t  buffer->dir.name = (char *) \".\";\n \t  dlen = 1;\n \t}\n \n       if (dlen > pfile->max_include_len)\n \tpfile->max_include_len = dlen;\n \n       buffer->dir.len = dlen;\n-      buffer->dir.next = CPP_OPTION (pfile, quote_include);\n+      buffer->dir.next = pfile->quote_include;\n       buffer->dir.sysp = pfile->map->sysp;\n     }\n \n@@ -1089,7 +1096,7 @@ static char *\n remap_filename (pfile, name, loc)\n      cpp_reader *pfile;\n      char *name;\n-     struct search_path *loc;\n+     struct cpp_path *loc;\n {\n   struct file_name_map *map;\n   const char *from, *p;\n@@ -1138,158 +1145,29 @@ remap_filename (pfile, name, loc)\n   return name;\n }\n \n-/* Returns true if it is safe to remove the final component of path,\n-   when it is followed by a \"..\" component.  We use lstat to avoid\n-   symlinks if we have it.  If not, we can still catch errors with\n-   stat ().  */\n-static int\n-remove_component_p (path)\n-     const char *path;\n-{\n-  struct stat s;\n-  int result;\n-\n-#ifdef HAVE_LSTAT\n-  result = lstat (path, &s);\n-#else\n-  result = stat (path, &s);\n-#endif\n-\n-  /* There's no guarantee that errno will be unchanged, even on\n-     success.  Cygwin's lstat(), for example, will often set errno to\n-     ENOSYS.  In case of success, reset errno to zero.  */\n-  if (result == 0)\n-    errno = 0;\n-\n-  return result == 0 && S_ISDIR (s.st_mode);\n-}\n+/* Set the include chain for \"\" to QUOTE, for <> to BRACKET.  If\n+   QUOTE_IGNORES_SOURCE_DIR, then \"\" includes do not look in the\n+   directory of the including file.\n \n-/* Simplify a path name in place, deleting redundant components.  This\n-   reduces OS overhead and guarantees that equivalent paths compare\n-   the same (modulo symlinks).\n-\n-   Transforms made:\n-   foo/bar/../quux\tfoo/quux\n-   foo/./bar\t\tfoo/bar\n-   foo//bar\t\tfoo/bar\n-   /../quux\t\t/quux\n-   //quux\t\t//quux  (POSIX allows leading // as a namespace escape)\n-\n-   Guarantees no trailing slashes.  All transforms reduce the length\n-   of the string.  Returns PATH.  errno is 0 if no error occurred;\n-   nonzero if an error occurred when using stat () or lstat ().  */\n-char *\n-_cpp_simplify_pathname (path)\n-     char *path;\n+   If BRACKET does not lie in the QUOTE chain, it is set to QUOTE.  */\n+void\n+cpp_set_include_chains (pfile, quote, bracket, quote_ignores_source_dir)\n+     cpp_reader *pfile;\n+     cpp_path *quote, *bracket;\n+     int quote_ignores_source_dir;\n {\n-#ifndef VMS\n-  char *from, *to;\n-  char *base, *orig_base;\n-  int absolute = 0;\n-\n-  errno = 0;\n-  /* Don't overflow the empty path by putting a '.' in it below.  */\n-  if (*path == '\\0')\n-    return path;\n-\n-#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n-  /* Convert all backslashes to slashes.  */\n-  for (from = path; *from; from++)\n-    if (*from == '\\\\') *from = '/';\n-\n-  /* Skip over leading drive letter if present.  */\n-  if (ISALPHA (path[0]) && path[1] == ':')\n-    from = to = &path[2];\n-  else\n-    from = to = path;\n-#else\n-  from = to = path;\n-#endif\n+  pfile->quote_include = quote;\n+  pfile->bracket_include = quote;\n+  pfile->quote_ignores_source_dir = quote_ignores_source_dir;\n+  pfile->max_include_len = 0;\n \n-  /* Remove redundant leading /s.  */\n-  if (*from == '/')\n+  for (; quote; quote = quote->next)\n     {\n-      absolute = 1;\n-      to++;\n-      from++;\n-      if (*from == '/')\n-\t{\n-\t  if (*++from == '/')\n-\t    /* 3 or more initial /s are equivalent to 1 /.  */\n-\t    while (*++from == '/');\n-\t  else\n-\t    /* On some hosts // differs from /; Posix allows this.  */\n-\t    to++;\n-\t}\n+      quote->name_map = NULL;\n+      quote->len = strlen (quote->name);\n+      if (quote->len > pfile->max_include_len)\n+\tpfile->max_include_len = quote->len;\n+      if (quote == bracket)\n+\tpfile->bracket_include = bracket;\n     }\n-\n-  base = orig_base = to;\n-  for (;;)\n-    {\n-      int move_base = 0;\n-\n-      while (*from == '/')\n-\tfrom++;\n-\n-      if (*from == '\\0')\n-\tbreak;\n-\n-      if (*from == '.')\n-\t{\n-\t  if (from[1] == '\\0')\n-\t    break;\n-\t  if (from[1] == '/')\n-\t    {\n-\t      from += 2;\n-\t      continue;\n-\t    }\n-\t  else if (from[1] == '.' && (from[2] == '/' || from[2] == '\\0'))\n-\t    {\n-\t      /* Don't simplify if there was no previous component.  */\n-\t      if (absolute && orig_base == to)\n-\t\t{\n-\t\t  from += 2;\n-\t\t  continue;\n-\t\t}\n-\t      /* Don't simplify if the previous component was \"../\",\n-\t\t or if an error has already occurred with (l)stat.  */\n-\t      if (base != to && errno == 0)\n-\t\t{\n-\t\t  /* We don't back up if it's a symlink.  */\n-\t\t  *to = '\\0';\n-\t\t  if (remove_component_p (path))\n-\t\t    {\n-\t\t      while (to > base && *to != '/')\n-\t\t\tto--;\n-\t\t      from += 2;\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      move_base = 1;\n-\t    }\n-\t}\n-\n-      /* Add the component separator.  */\n-      if (to > orig_base)\n-\t*to++ = '/';\n-\n-      /* Copy this component until the trailing null or '/'.  */\n-      while (*from != '\\0' && *from != '/')\n-\t*to++ = *from++;\n-\n-      if (move_base)\n-\tbase = to;\n-    }\n-\n-  /* Change the empty string to \".\" so that it is not treated as stdin.\n-     Null terminate.  */\n-  if (to == path)\n-    *to++ = '.';\n-  *to = '\\0';\n-\n-  return path;\n-#else /* VMS  */\n-  errno = 0;\n-  return path;\n-#endif /* !VMS  */\n }"}, {"sha": "16aba087b889169883282330c34d4fb45dec40d7", "filename": "gcc/cpphash.h", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,5 +1,5 @@\n /* Part of CPP library.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n    Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n@@ -130,26 +130,6 @@ extern unsigned char *_cpp_unaligned_alloc PARAMS ((cpp_reader *, size_t));\n #define BUFF_FRONT(BUFF) ((BUFF)->cur)\n #define BUFF_LIMIT(BUFF) ((BUFF)->limit)\n \n-/* List of directories to look for include files in.  */\n-struct search_path\n-{\n-  struct search_path *next;\n-\n-  /* NOTE: NAME may not be null terminated for the case of the current\n-     file's directory!  */\n-  const char *name;\n-  unsigned int len;\n-  /* We use these to tell if the directory mentioned here is a duplicate\n-     of an earlier directory on the search path.  */\n-  ino_t ino;\n-  dev_t dev;\n-  /* Nonzero if it is a system include directory.  */\n-  int sysp;\n-  /* Mapping of file names for this directory.  Only used on MS-DOS\n-     and related platforms.  */\n-  struct file_name_map *name_map;\n-};\n-\n /* #include types.  */\n enum include_type {IT_INCLUDE, IT_INCLUDE_NEXT, IT_IMPORT, IT_CMDLINE};\n \n@@ -324,7 +304,7 @@ struct cpp_buffer\n \n   /* The directory of the this buffer's file.  Its NAME member is not\n      allocated, so we don't need to worry about freeing it.  */\n-  struct search_path dir;\n+  struct cpp_path dir;\n \n   /* Used for buffer overlays by cpptrad.c.  */\n   const uchar *saved_cur, *saved_rlimit;\n@@ -369,6 +349,10 @@ struct cpp_reader\n      _cpp_maybe_push_include_file has yet to restore the line map.  */\n   struct pending_option **next_include_file;\n \n+  /* Search paths for include files.  */\n+  struct cpp_path *quote_include;\t/* \"\" */\n+  struct cpp_path *bracket_include;\t/* <> */\n+\n   /* Multiple include optimisation.  */\n   const cpp_hashnode *mi_cmacro;\n   const cpp_hashnode *mi_ind_cmacro;\n@@ -441,6 +425,10 @@ struct cpp_reader\n   /* Used when doing preprocessed output.  */\n   struct printer print;\n \n+  /* Nonzero means don't look for #include \"foo\" the source-file\n+     directory.  */\n+  unsigned char quote_ignores_source_dir;\n+\n   /* Whether cpplib owns the hashtable.  */\n   unsigned char our_hashtable;\n \n@@ -521,7 +509,6 @@ extern void _cpp_destroy_hashtable\tPARAMS ((cpp_reader *));\n /* In cppfiles.c */\n extern void _cpp_fake_include\t\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_never_reread\t\tPARAMS ((struct include_file *));\n-extern char *_cpp_simplify_pathname\tPARAMS ((char *));\n extern bool _cpp_read_file\t\tPARAMS ((cpp_reader *, const char *));\n extern bool _cpp_execute_include\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const cpp_token *,"}, {"sha": "2068ba1d675a50edddcf6cfaebea20bc00d89107", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 528, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,6 +1,6 @@\n /* CPP Library.\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -25,25 +25,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"tm.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n-#include \"prefix.h\"\n #include \"intl.h\"\n #include \"mkdeps.h\"\n-#include \"cppdefault.h\"\n-\n-/* Windows does not natively support inodes, and neither does MSDOS.\n-   Cygwin's emulation can generate non-unique inodes, so don't use it.\n-   VMS has non-numeric inodes.  */\n-#ifdef VMS\n-# define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))\n-# define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))\n-#else\n-# if (defined _WIN32 && ! defined (_UWIN)) || defined __MSDOS__\n-#  define INO_T_EQ(A, B) 0\n-# else\n-#  define INO_T_EQ(A, B) ((A) == (B))\n-# endif\n-# define INO_T_COPY(DEST, SRC) (DEST) = (SRC)\n-#endif\n \n /* Internal structures and prototypes.  */\n \n@@ -64,12 +47,6 @@ struct pending_option\n struct cpp_pending\n {\n   struct pending_option *directive_head, *directive_tail;\n-\n-  struct search_path *quote_head, *quote_tail;\n-  struct search_path *brack_head, *brack_tail;\n-  struct search_path *systm_head, *systm_tail;\n-  struct search_path *after_head, *after_tail;\n-\n   struct pending_option *imacros_head, *imacros_tail;\n   struct pending_option *include_head, *include_tail;\n };\n@@ -88,37 +65,19 @@ struct cpp_pending\n   } while (0)\n #endif\n \n-static void path_include\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const char *, int));\n static void init_library\t\tPARAMS ((void));\n static void init_builtins\t\tPARAMS ((cpp_reader *));\n static void mark_named_operators\tPARAMS ((cpp_reader *));\n-static void append_include_chain\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t char *, int, int));\n-static struct search_path * remove_dup_dir\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct search_path *,\n-\t\t\t\t\t\t struct search_path **));\n-static struct search_path * remove_dup_nonsys_dirs PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct search_path **,\n-\t\t\t\t\t\t struct search_path *));\n-static struct search_path * remove_dup_dirs PARAMS ((cpp_reader *,\n-\t\t\t\t\t\t struct search_path **));\n-static void merge_include_chains\tPARAMS ((cpp_reader *));\n static bool push_include\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t struct pending_option *));\n static void free_chain\t\t\tPARAMS ((struct pending_option *));\n-static void init_standard_includes\tPARAMS ((cpp_reader *));\n static void read_original_filename\tPARAMS ((cpp_reader *));\n static void new_pending_directive\tPARAMS ((struct cpp_pending *,\n \t\t\t\t\t\t const char *,\n \t\t\t\t\t\t cl_directive_handler));\n static int parse_option\t\t\tPARAMS ((const char *));\n static void post_options\t\tPARAMS ((cpp_reader *));\n \n-/* Fourth argument to append_include_chain: chain to use.\n-   Note it's never asked to append to the quote chain.  */\n-enum { BRACKET = 0, SYSTEM, AFTER };\n-\n /* If we have designated initializers (GCC >2.7) these tables can be\n    initialized, constant data.  Otherwise, they have to be filled in at\n    runtime.  */\n@@ -152,277 +111,6 @@ END\n #undef END\n #undef TRIGRAPH_MAP\n \n-/* Read ENV_VAR for a colon-separated list of file names; and\n-   add all the names to the search path for include files.  */\n-static void\n-path_include (pfile, env_var, path)\n-     cpp_reader *pfile;\n-     const char *env_var;\n-     int path;\n-{\n-  char *p, *q, *name;\n-\n-  GET_ENVIRONMENT (q, env_var);\n-  if (!q)\n-    return;\n-\n-  for (p = q; *q; p = q + 1)\n-    {\n-      /* Find the end of this name.  */\n-      q = p;\n-      while (*q != 0 && *q != PATH_SEPARATOR) q++;\n-      if (q == p)\n-\t{\n-\t  /* An empty name in the path stands for the current directory.  */\n-\t  name = (char *) xmalloc (2);\n-\t  name[0] = '.';\n-\t  name[1] = 0;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise use the directory that is named.  */\n-\t  name = (char *) xmalloc (q - p + 1);\n-\t  memcpy (name, p, q - p);\n-\t  name[q - p] = 0;\n-\t}\n-\n-      append_include_chain (pfile, name, path, path == SYSTEM);\n-    }\n-}\n-\n-/* Append DIR to include path PATH.  DIR must be allocated on the\n-   heap; this routine takes responsibility for freeing it.  CXX_AWARE\n-   is nonzero if the header contains extern \"C\" guards for C++,\n-   otherwise it is zero.  */\n-static void\n-append_include_chain (pfile, dir, path, cxx_aware)\n-     cpp_reader *pfile;\n-     char *dir;\n-     int path;\n-     int cxx_aware;\n-{\n-  struct cpp_pending *pend = CPP_OPTION (pfile, pending);\n-  struct search_path *new;\n-  struct stat st;\n-  unsigned int len;\n-\n-  if (*dir == '\\0')\n-    {\n-      free (dir);\n-      dir = xstrdup (\".\");\n-    }\n-  _cpp_simplify_pathname (dir);\n-\n-  if (stat (dir, &st))\n-    {\n-      /* Dirs that don't exist are silently ignored.  */\n-      if (errno != ENOENT)\n-\tcpp_errno (pfile, DL_ERROR, dir);\n-      else if (CPP_OPTION (pfile, verbose))\n-\tfprintf (stderr, _(\"ignoring nonexistent directory \\\"%s\\\"\\n\"), dir);\n-      free (dir);\n-      return;\n-    }\n-\n-  if (!S_ISDIR (st.st_mode))\n-    {\n-      cpp_error_with_line (pfile, DL_ERROR, 0, 0, \"%s: Not a directory\", dir);\n-      free (dir);\n-      return;\n-    }\n-\n-  len = strlen (dir);\n-  if (len > pfile->max_include_len)\n-    pfile->max_include_len = len;\n-\n-  new = (struct search_path *) xmalloc (sizeof (struct search_path));\n-  new->name = dir;\n-  new->len = len;\n-  INO_T_COPY (new->ino, st.st_ino);\n-  new->dev  = st.st_dev;\n-  /* Both systm and after include file lists should be treated as system\n-     include files since these two lists are really just a concatenation\n-     of one \"system\" list.  */\n-  if (path == SYSTEM || path == AFTER)\n-    new->sysp = cxx_aware ? 1 : 2;\n-  else\n-    new->sysp = 0;\n-  new->name_map = NULL;\n-  new->next = NULL;\n-\n-  switch (path)\n-    {\n-    case BRACKET:\tAPPEND (pend, brack, new); break;\n-    case SYSTEM:\tAPPEND (pend, systm, new); break;\n-    case AFTER:\t\tAPPEND (pend, after, new); break;\n-    }\n-}\n-\n-/* Handle a duplicated include path.  PREV is the link in the chain\n-   before the duplicate, or NULL if the duplicate is at the head of\n-   the chain.  The duplicate is removed from the chain and freed.\n-   Returns PREV.  */\n-static struct search_path *\n-remove_dup_dir (pfile, prev, head_ptr)\n-     cpp_reader *pfile;\n-     struct search_path *prev;\n-     struct search_path **head_ptr;\n-{\n-  struct search_path *cur;\n-\n-  if (prev != NULL)\n-    {\n-      cur = prev->next;\n-      prev->next = cur->next;\n-    }\n-  else\n-    {\n-      cur = *head_ptr;\n-      *head_ptr = cur->next;\n-    }\n-\n-  if (CPP_OPTION (pfile, verbose))\n-    fprintf (stderr, _(\"ignoring duplicate directory \\\"%s\\\"\\n\"), cur->name);\n-\n-  free ((PTR) cur->name);\n-  free (cur);\n-\n-  return prev;\n-}\n-\n-/* Remove duplicate non-system directories for which there is an equivalent\n-   system directory latter in the chain.  The range for removal is between\n-   *HEAD_PTR and END.  Returns the directory before END, or NULL if none.\n-   This algorithm is quadratic in the number system directories, which is\n-   acceptable since there aren't usually that many of them.  */\n-static struct search_path *\n-remove_dup_nonsys_dirs (pfile, head_ptr, end)\n-     cpp_reader *pfile;\n-     struct search_path **head_ptr;\n-     struct search_path *end;\n-{\n-  int sysdir = 0;\n-  struct search_path *prev = NULL, *cur, *other;\n-\n-  for (cur = *head_ptr; cur; cur = cur->next)\n-    {\n-      if (cur->sysp)\n-\t{\n-\t  sysdir = 1;\n-\t  for (other = *head_ptr, prev = NULL;\n-\t       other != end;\n-\t       other = other ? other->next : *head_ptr)\n-\t    {\n-\t      if (!other->sysp\n-\t\t  && INO_T_EQ (cur->ino, other->ino)\n-\t\t  && cur->dev == other->dev)\n-\t\t{\n-\t\t  other = remove_dup_dir (pfile, prev, head_ptr);\n-\t\t  if (CPP_OPTION (pfile, verbose))\n-\t\t    fprintf (stderr,\n-  _(\"  as it is a non-system directory that duplicates a system directory\\n\"));\n-\t\t}\n-\t      prev = other;\n-\t    }\n-\t}\n-    }\n-\n-  if (!sysdir)\n-    for (cur = *head_ptr; cur != end; cur = cur->next)\n-      prev = cur;\n-\n-  return prev;\n-}\n-\n-/* Remove duplicate directories from a chain.  Returns the tail of the\n-   chain, or NULL if the chain is empty.  This algorithm is quadratic\n-   in the number of -I switches, which is acceptable since there\n-   aren't usually that many of them.  */\n-static struct search_path *\n-remove_dup_dirs (pfile, head_ptr)\n-     cpp_reader *pfile;\n-     struct search_path **head_ptr;\n-{\n-  struct search_path *prev = NULL, *cur, *other;\n-\n-  for (cur = *head_ptr; cur; cur = cur->next)\n-    {\n-      for (other = *head_ptr; other != cur; other = other->next)\n-\tif (INO_T_EQ (cur->ino, other->ino) && cur->dev == other->dev)\n-\t  {\n-\t    cur = remove_dup_dir (pfile, prev, head_ptr);\n-\t    break;\n-\t  }\n-      prev = cur;\n-    }\n-\n-  return prev;\n-}\n-\n-/* Merge the four include chains together in the order quote, bracket,\n-   system, after.  Remove duplicate dirs (as determined by\n-   INO_T_EQ()).  The system_include and after_include chains are never\n-   referred to again after this function; all access is through the\n-   bracket_include path.  */\n-static void\n-merge_include_chains (pfile)\n-     cpp_reader *pfile;\n-{\n-  struct search_path *quote, *brack, *systm, *qtail;\n-\n-  struct cpp_pending *pend = CPP_OPTION (pfile, pending);\n-\n-  quote = pend->quote_head;\n-  brack = pend->brack_head;\n-  systm = pend->systm_head;\n-  qtail = pend->quote_tail;\n-\n-  /* Paste together bracket, system, and after include chains.  */\n-  if (systm)\n-    pend->systm_tail->next = pend->after_head;\n-  else\n-    systm = pend->after_head;\n-\n-  if (brack)\n-    pend->brack_tail->next = systm;\n-  else\n-    brack = systm;\n-\n-  /* This is a bit tricky.  First we drop non-system dupes of system\n-     directories from the merged bracket-include list.  Next we drop\n-     dupes from the bracket and quote include lists.  Then we drop\n-     non-system dupes from the merged quote-include list.  Finally,\n-     if qtail and brack are the same directory, we cut out brack and\n-     move brack up to point to qtail.\n-\n-     We can't just merge the lists and then uniquify them because\n-     then we may lose directories from the <> search path that should\n-     be there; consider -Ifoo -Ibar -I- -Ifoo -Iquux.  It is however\n-     safe to treat -Ibar -Ifoo -I- -Ifoo -Iquux as if written\n-     -Ibar -I- -Ifoo -Iquux.  */\n-\n-  remove_dup_nonsys_dirs (pfile, &brack, systm);\n-  remove_dup_dirs (pfile, &brack);\n-\n-  if (quote)\n-    {\n-      qtail = remove_dup_dirs (pfile, &quote);\n-      qtail->next = brack;\n-\n-      qtail = remove_dup_nonsys_dirs (pfile, &quote, brack);\n-\n-      /* If brack == qtail, remove brack as it's simpler.  */\n-      if (qtail && brack && INO_T_EQ (qtail->ino, brack->ino)\n-\t  && qtail->dev == brack->dev)\n-\tbrack = remove_dup_dir (pfile, qtail, &quote);\n-    }\n-  else\n-    quote = brack;\n-\n-  CPP_OPTION (pfile, quote_include) = quote;\n-  CPP_OPTION (pfile, bracket_include) = brack;\n-}\n-\n /* A set of booleans indicating what CPP features each source language\n    requires.  */\n struct lang_flags\n@@ -529,7 +217,6 @@ cpp_create_reader (lang)\n   CPP_OPTION (pfile, warn_endif_labels) = 1;\n   CPP_OPTION (pfile, warn_deprecated) = 1;\n   CPP_OPTION (pfile, warn_long_long) = !CPP_OPTION (pfile, c99);\n-  CPP_OPTION (pfile, sysroot) = cpp_SYSROOT;\n \n   CPP_OPTION (pfile, pending) =\n     (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n@@ -588,7 +275,6 @@ void\n cpp_destroy (pfile)\n      cpp_reader *pfile;\n {\n-  struct search_path *dir, *dirn;\n   cpp_context *context, *contextn;\n   tokenrun *run, *runn;\n \n@@ -628,13 +314,6 @@ cpp_destroy (pfile)\n \tfree (run);\n     }\n \n-  for (dir = CPP_OPTION (pfile, quote_include); dir; dir = dirn)\n-    {\n-      dirn = dir->next;\n-      free ((PTR) dir->name);\n-      free (dir);\n-    }\n-\n   for (context = pfile->base_context.next; context; context = contextn)\n     {\n       contextn = context->next;\n@@ -751,69 +430,6 @@ init_builtins (pfile)\n     (*pfile->cb.register_builtins) (pfile);\n }\n \n-/* And another subroutine.  This one sets up the standard include path.  */\n-static void\n-init_standard_includes (pfile)\n-     cpp_reader *pfile;\n-{\n-  const struct default_include *p;\n-  const char *specd_prefix = CPP_OPTION (pfile, include_prefix);\n-  int default_len, specd_len;\n-  char *default_prefix;\n-\n-  /* Search \"translated\" versions of GNU directories.\n-     These have /usr/local/lib/gcc... replaced by specd_prefix.  */\n-  default_len = 0;\n-  specd_len = 0;\n-  default_prefix = NULL;\n-  if (specd_prefix != 0 && cpp_GCC_INCLUDE_DIR_len)\n-    {\n-      /* Remove the `include' from /usr/local/lib/gcc.../include.\n-\t GCC_INCLUDE_DIR will always end in /include.  */\n-      default_len = cpp_GCC_INCLUDE_DIR_len;\n-      default_prefix = (char *) alloca (default_len + 1);\n-      specd_len = strlen (specd_prefix);\n-\n-      memcpy (default_prefix, cpp_GCC_INCLUDE_DIR, default_len);\n-      default_prefix[default_len] = '\\0';\n-    }\n-\n-  for (p = cpp_include_defaults; p->fname; p++)\n-    {\n-      /* Some standard dirs are only for C++.  */\n-      if (!p->cplusplus\n-\t  || (CPP_OPTION (pfile, cplusplus)\n-\t      && !CPP_OPTION (pfile, no_standard_cplusplus_includes)))\n-\t{\n-\t  char *str;\n-\n-\t  /* Should this dir start with the sysroot?  */\n-\t  if (p->add_sysroot && CPP_OPTION (pfile, sysroot))\n-\t    str = concat (CPP_OPTION (pfile, sysroot), p->fname, NULL);\n-\n-\t  /* Does this dir start with the prefix?  */\n-\t  else if (default_len\n-\t\t   && !strncmp (p->fname, default_prefix, default_len))\n-\t    {\n-\t      /* Yes; change prefix and add to search list.  */\n-\t      int flen = strlen (p->fname);\n-\t      int this_len = specd_len + flen - default_len;\n-\n-\t      str = (char *) xmalloc (this_len + 1);\n-\t      memcpy (str, specd_prefix, specd_len);\n-\t      memcpy (str + specd_len,\n-\t\t      p->fname + default_len,\n-\t\t      flen - default_len + 1);\n-\t    }\n-\n-\t  else\n-\t    str = update_path (p->fname, p->component);\n-\n-\t  append_include_chain (pfile, str, SYSTEM, p->cxx_aware);\n-\t}\n-    }\n-}\n-\n /* Pushes a command line -imacro and -include file indicated by P onto\n    the buffer stack.  Returns nonzero if successful.  */\n static bool\n@@ -925,11 +541,6 @@ cpp_read_main_file (pfile, fname, table)\n      const char *fname;\n      hash_table *table;\n {\n-  static const char *const lang_env_vars[] =\n-    { \"C_INCLUDE_PATH\", \"CPLUS_INCLUDE_PATH\",\n-      \"OBJC_INCLUDE_PATH\", \"OBJCPLUS_INCLUDE_PATH\" };\n-  size_t lang;\n-\n   sanity_checks (pfile);\n \n   post_options (pfile);\n@@ -939,35 +550,6 @@ cpp_read_main_file (pfile, fname, table)\n      hashtable is deferred until now.  */\n   _cpp_init_hashtable (pfile, table);\n \n-  /* Several environment variables may add to the include search path.\n-     CPATH specifies an additional list of directories to be searched\n-     as if specified with -I, while C_INCLUDE_PATH, CPLUS_INCLUDE_PATH,\n-     etc. specify an additional list of directories to be searched as\n-     if specified with -isystem, for the language indicated.  */\n-  path_include (pfile, \"CPATH\", BRACKET);\n-  lang = (CPP_OPTION (pfile, objc) << 1) + CPP_OPTION (pfile, cplusplus);\n-  path_include (pfile, lang_env_vars[lang], SYSTEM);\n-\n-  /* Set up the include search path now.  */\n-  if (! CPP_OPTION (pfile, no_standard_includes))\n-    init_standard_includes (pfile);\n-\n-  merge_include_chains (pfile);\n-\n-  /* With -v, print the list of dirs to search.  */\n-  if (CPP_OPTION (pfile, verbose))\n-    {\n-      struct search_path *l;\n-      fprintf (stderr, _(\"#include \\\"...\\\" search starts here:\\n\"));\n-      for (l = CPP_OPTION (pfile, quote_include); l; l = l->next)\n-\t{\n-\t  if (l == CPP_OPTION (pfile, bracket_include))\n-\t    fprintf (stderr, _(\"#include <...> search starts here:\\n\"));\n-\t  fprintf (stderr, \" %s\\n\", l->name);\n-\t}\n-      fprintf (stderr, _(\"End of search list.\\n\"));\n-    }\n-\n   if (CPP_OPTION (pfile, deps.style) != DEPS_NONE)\n     {\n       if (!pfile->deps)\n@@ -1149,26 +731,17 @@ new_pending_directive (pend, text, handler)\n    I.e. a const string initializer with parens around it.  That is\n    what N_(\"string\") resolves to, so we make no_* be macros instead.  */\n #define no_ass N_(\"assertion missing after %s\")\n-#define no_dir N_(\"directory name missing after %s\")\n #define no_fil N_(\"file name missing after %s\")\n #define no_mac N_(\"macro name missing after %s\")\n-#define no_pth N_(\"path name missing after %s\")\n \n /* This is the list of all command line options, with the leading\n    \"-\" removed.  It must be sorted in ASCII collating order.  */\n #define COMMAND_LINE_OPTIONS                                                  \\\n   DEF_OPT(\"A\",                        no_ass, OPT_A)                          \\\n   DEF_OPT(\"D\",                        no_mac, OPT_D)                          \\\n-  DEF_OPT(\"I\",                        no_dir, OPT_I)                          \\\n   DEF_OPT(\"U\",                        no_mac, OPT_U)                          \\\n-  DEF_OPT(\"idirafter\",                no_dir, OPT_idirafter)                  \\\n   DEF_OPT(\"imacros\",                  no_fil, OPT_imacros)                    \\\n-  DEF_OPT(\"include\",                  no_fil, OPT_include)                    \\\n-  DEF_OPT(\"iprefix\",                  no_pth, OPT_iprefix)                    \\\n-  DEF_OPT(\"isysroot\",                 no_dir, OPT_isysroot)                   \\\n-  DEF_OPT(\"isystem\",                  no_dir, OPT_isystem)                    \\\n-  DEF_OPT(\"iwithprefix\",              no_dir, OPT_iwithprefix)                \\\n-  DEF_OPT(\"iwithprefixbefore\",        no_dir, OPT_iwithprefixbefore)\n+  DEF_OPT(\"include\",                  no_fil, OPT_include)\n \n #define DEF_OPT(text, msg, code) code,\n enum opt_code\n@@ -1305,14 +878,6 @@ cpp_handle_option (pfile, argc, argv)\n \tcase OPT_D:\n \t  new_pending_directive (pend, arg, cpp_define);\n \t  break;\n-\tcase OPT_iprefix:\n-\t  CPP_OPTION (pfile, include_prefix) = arg;\n-\t  CPP_OPTION (pfile, include_prefix_len) = strlen (arg);\n-\t  break;\n-\n-\tcase OPT_isysroot:\n-\t  CPP_OPTION (pfile, sysroot) = arg;\n-\t  break;\n \n \tcase OPT_A:\n \t  if (arg[0] == '-')\n@@ -1340,37 +905,6 @@ cpp_handle_option (pfile, argc, argv)\n \tcase OPT_U:\n \t  new_pending_directive (pend, arg, cpp_undef);\n \t  break;\n-\tcase OPT_I:           /* Add directory to path for includes.  */\n-\t  if (!strcmp (arg, \"-\"))\n-\t    {\n-\t      /* -I- means:\n-\t\t Use the preceding -I directories for #include \"...\"\n-\t\t but not #include <...>.\n-\t\t Don't search the directory of the present file\n-\t\t for #include \"...\".  (Note that -I. -I- is not the same as\n-\t\t the default setup; -I. uses the compiler's working dir.)  */\n-\t      if (! CPP_OPTION (pfile, ignore_srcdir))\n-\t\t{\n-\t\t  pend->quote_head = pend->brack_head;\n-\t\t  pend->quote_tail = pend->brack_tail;\n-\t\t  pend->brack_head = 0;\n-\t\t  pend->brack_tail = 0;\n-\t\t  CPP_OPTION (pfile, ignore_srcdir) = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  cpp_error (pfile, DL_ERROR, \"-I- specified twice\");\n-\t\t  return argc;\n-\t\t}\n-\t    }\n-\t  else\n-\t    append_include_chain (pfile, xstrdup (arg), BRACKET, 0);\n-\t  break;\n-\tcase OPT_isystem:\n-\t  /* Add directory to beginning of system include path, as a system\n-\t     include directory.  */\n-\t  append_include_chain (pfile, xstrdup (arg), SYSTEM, 0);\n-\t  break;\n \tcase OPT_include:\n \tcase OPT_imacros:\n \t  {\n@@ -1385,71 +919,11 @@ cpp_handle_option (pfile, argc, argv)\n \t      APPEND (pend, imacros, o);\n \t  }\n \t  break;\n-\tcase OPT_iwithprefix:\n-\t  /* Add directory to end of path for includes,\n-\t     with the default prefix at the front of its name.  */\n-\t  /* fall through */\n-\tcase OPT_iwithprefixbefore:\n-\t  /* Add directory to main path for includes,\n-\t     with the default prefix at the front of its name.  */\n-\t  {\n-\t    char *fname;\n-\t    int len;\n-\n-\t    len = strlen (arg);\n-\n-\t    if (CPP_OPTION (pfile, include_prefix) != 0)\n-\t      {\n-\t\tsize_t ipl = CPP_OPTION (pfile, include_prefix_len);\n-\t\tfname = xmalloc (ipl + len + 1);\n-\t\tmemcpy (fname, CPP_OPTION (pfile, include_prefix), ipl);\n-\t\tmemcpy (fname + ipl, arg, len + 1);\n-\t      }\n-\t    else if (cpp_GCC_INCLUDE_DIR_len)\n-\t      {\n-\t\tfname = xmalloc (cpp_GCC_INCLUDE_DIR_len + len + 1);\n-\t\tmemcpy (fname, cpp_GCC_INCLUDE_DIR, cpp_GCC_INCLUDE_DIR_len);\n-\t\tmemcpy (fname + cpp_GCC_INCLUDE_DIR_len, arg, len + 1);\n-\t      }\n-\t    else\n-\t      fname = xstrdup (arg);\n-\n-\t    append_include_chain (pfile, fname,\n-\t\t\t  opt_code == OPT_iwithprefix ? SYSTEM: BRACKET, 0);\n-\t  }\n-\t  break;\n-\tcase OPT_idirafter:\n-\t  /* Add directory to end of path for includes.  */\n-\t  append_include_chain (pfile, xstrdup (arg), AFTER, 0);\n-\t  break;\n \t}\n     }\n   return i + 1;\n }\n \n-/* Handle command-line options in (argc, argv).\n-   Can be called multiple times, to handle multiple sets of options.\n-   Returns if an unrecognized option is seen.\n-   Returns number of strings consumed.  */\n-int\n-cpp_handle_options (pfile, argc, argv)\n-     cpp_reader *pfile;\n-     int argc;\n-     char **argv;\n-{\n-  int i;\n-  int strings_processed;\n-\n-  for (i = 0; i < argc; i += strings_processed)\n-    {\n-      strings_processed = cpp_handle_option (pfile, argc - i, argv + i);\n-      if (strings_processed == 0)\n-\tbreak;\n-    }\n-\n-  return i;\n-}\n-\n static void\n post_options (pfile)\n      cpp_reader *pfile;"}, {"sha": "384dd209ac2f061c1cdf33dbe8a318cd5aa36b93", "filename": "gcc/cpplib.h", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -39,6 +39,7 @@ typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n typedef struct cpp_macro cpp_macro;\n typedef struct cpp_callbacks cpp_callbacks;\n+typedef struct cpp_path cpp_path;\n \n struct answer;\n struct file_name_map_list;\n@@ -224,29 +225,13 @@ struct cpp_options\n   /* Pending options - -D, -U, -A, -I, -ixxx.  */\n   struct cpp_pending *pending;\n \n-  /* Search paths for include files.  */\n-  struct search_path *quote_include;\t/* \"\" */\n-  struct search_path *bracket_include;  /* <> */\n-\n   /* Map between header names and file names, used only on DOS where\n      file names are limited in length.  */\n   struct file_name_map_list *map_list;\n \n-  /* Directory prefix that should replace `/usr/lib/gcc-lib/TARGET/VERSION'\n-     in the standard include file directories.  */\n-  const char *include_prefix;\n-  unsigned int include_prefix_len;\n-\n-  /* Directory prefix for system include directories in the standard search\n-     path.  */\n-  const char *sysroot;\n-\n   /* The language we're preprocessing.  */\n   enum c_lang lang;\n \n-  /* Non-0 means -v, so print the full set of include dirs.  */\n-  unsigned char verbose;\n-\n   /* Nonzero means use extra default include directories for C++.  */\n   unsigned char cplusplus;\n \n@@ -332,10 +317,6 @@ struct cpp_options\n   /* Nonzero means don't output line number information.  */\n   unsigned char no_line_commands;\n \n-  /* Nonzero means -I- has been seen, so don't look for #include \"foo\"\n-     the source-file directory.  */\n-  unsigned char ignore_srcdir;\n-\n   /* Zero means dollar signs are punctuation.  */\n   unsigned char dollars_in_ident;\n \n@@ -358,12 +339,6 @@ struct cpp_options\n      bother trying to do macro expansion and whatnot.  */\n   unsigned char preprocessed;\n \n-  /* Nonzero disables all the standard directories for headers.  */\n-  unsigned char no_standard_includes;\n-\n-  /* Nonzero disables the C++-specific standard directories for headers.  */\n-  unsigned char no_standard_cplusplus_includes;\n-\n   /* Nonzero means dump macros in some fashion - see above.  */\n   unsigned char dump_macros;\n \n@@ -427,13 +402,38 @@ struct cpp_callbacks\n   void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n   void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));\n   void (*def_pragma) PARAMS ((cpp_reader *, unsigned int));\n+  void (*simplify_path) PARAMS ((char *));\n   /* Called when the client has a chance to properly register\n      built-ins with cpp_define() and cpp_assert().  */\n   void (*register_builtins) PARAMS ((cpp_reader *));\n   int (*valid_pch) PARAMS ((cpp_reader *, const char *, int));\n   void (*read_pch) PARAMS ((cpp_reader *, const char *, int, const char *));\n };\n \n+/* Chain of directories to look for include files in.  */\n+struct cpp_path\n+{\n+  /* NULL-terminated singly-linked list.  */\n+  struct cpp_path *next;\n+\n+  /* NAME need not be NUL-terminated once inside cpplib.  */\n+  char *name;\n+  unsigned int len;\n+\n+  /* One if a system header, two if a system header that has extern\n+     \"C\" guards for C++.  */\n+  unsigned char sysp;\n+\n+  /* Mapping of file names for this directory for MS-DOS and\n+     related platforms.  */\n+  struct file_name_map *name_map;\n+    \n+  /* The C front end uses these to recognize duplicated\n+     directories in the search path.  */\n+  ino_t ino;\n+  dev_t dev;\n+};\n+\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n@@ -526,6 +526,10 @@ extern void cpp_add_dependency_target PARAMS ((cpp_reader *,\n \t\t\t\t\t       const char * target,\n \t\t\t\t\t       int quote));\n \n+/* Set the include paths.  */\n+extern void cpp_set_include_chains PARAMS ((cpp_reader *, cpp_path *,\n+\t\t\t\t\t    cpp_path *, int));\n+\n /* Call these to get pointers to the options and callback structures\n    for a given reader.  These pointers are good until you call\n    cpp_finish on that reader.  You can either edit the callbacks\n@@ -536,12 +540,9 @@ extern const struct line_maps *cpp_get_line_maps PARAMS ((cpp_reader *));\n extern cpp_callbacks *cpp_get_callbacks PARAMS ((cpp_reader *));\n extern void cpp_set_callbacks PARAMS ((cpp_reader *, cpp_callbacks *));\n \n-/* Now call cpp_handle_option[s] to handle 1[or more] switches.  The\n-   return value is the number of arguments used.  If\n-   cpp_handle_options returns without using all arguments, it couldn't\n-   understand the next switch.  Options processing is not completed\n+/* Now call cpp_handle_option to handle 1 switch.  The return value is\n+   the number of arguments used.  Options processing is not completed\n    until you call cpp_finish_options.  */\n-extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n \n /* This function reads the file, but does not start preprocessing.  It"}, {"sha": "107fe5d2437167b66bae908211b382339da34b0d", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -82,8 +82,10 @@ the other C-like languages: @file{c-common.c},\n @file{c-pragma.c},\n @file{c-semantics.c},\n @file{c-lex.c},\n+@file{c-incpath.c}\n @file{c-common.h},\n @file{c-dump.h},\n+@file{c-incpath.h}\n and\n @file{c-pragma.h},\n "}, {"sha": "305a86852221bb5f9c9efae3ca656a4f4c86ce85", "filename": "gcc/fix-header.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5793b27668ae1b63e6518f84eab151ad66890eec/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=5793b27668ae1b63e6518f84eab151ad66890eec", "patch": "@@ -1,6 +1,6 @@\n /* fix-header.c - Make C header file suitable for C++.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -78,6 +78,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"scan.h\"\n #include \"cpplib.h\"\n+#include \"c-incpath.h\"\n \n static void v_fatal PARAMS ((const char *, va_list)) ATTRIBUTE_PRINTF (1,0) ATTRIBUTE_NORETURN;\n static void fatal PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n@@ -616,27 +617,48 @@ read_scan_file (in_fname, argc, argv)\n   cpp_callbacks *cb;\n   cpp_options *options;\n   struct fn_decl *fn;\n-  int i;\n+  int i, strings_processed;\n   struct symbol_list *cur_symbols;\n \n   obstack_init (&scan_file_obstack);\n \n   scan_in = cpp_create_reader (CLK_GNUC89);\n   cb = cpp_get_callbacks (scan_in);\n   cb->file_change = cb_file_change;\n+  cb->simplify_path = simplify_path;\n \n   /* We are going to be scanning a header file out of its proper context,\n      so ignore warnings and errors.  */\n   options = cpp_get_options (scan_in);\n   options->inhibit_warnings = 1;\n   options->inhibit_errors = 1;\n \n-  i = cpp_handle_options (scan_in, argc, argv);\n+  for (i = 0; i < argc; i += strings_processed)\n+    {\n+      if (argv[i][0] == 'I')\n+\t{\n+\t  if (argv[i][1] != '\\0')\n+\t    strings_processed = 1, add_path (argv[i] + 1, BRACKET, false);\n+\t  else if (i + 1 == argc)\n+\t    strings_processed = 0;\n+\t  else\n+\t    strings_processed = 2, add_path (argv[i + 1], BRACKET, false);\n+\t}\n+      else\n+\tstrings_processed = cpp_handle_option (scan_in, argc - i, argv + i);\n+\n+      if (strings_processed == 0)\n+\tbreak;\n+    }\n+\n   if (i < argc)\n     cpp_error (scan_in, DL_ERROR, \"invalid option `%s'\", argv[i]);\n   if (cpp_errors (scan_in))\n     exit (FATAL_EXIT_CODE);\n \n+  register_include_chains (scan_in, NULL /* sysroot */, NULL /* iprefix */,\n+\t\t\t   true /* stdinc */, false /* cxx_stdinc */,\n+\t\t\t   false /* verbose */);\n   if (! cpp_read_main_file (scan_in, in_fname, NULL))\n     exit (FATAL_EXIT_CODE);\n "}]}