{"sha": "424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI0ZTcxM2NkMWJiMmQyN2UzYmNiMTNjZTg3N2JkMGQyMmMzYmYwOQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-01-20T08:59:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-01-20T08:59:50Z"}, "message": "Remove more bytecode stuff.\n\nFrom-SVN: r17434", "tree": {"sha": "47194abf6d133fa255386db44c65f42023a58cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47194abf6d133fa255386db44c65f42023a58cd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09/comments", "author": null, "committer": null, "parents": [{"sha": "ab29e466d5b931d11857238e87fc1655b2820ab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab29e466d5b931d11857238e87fc1655b2820ab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab29e466d5b931d11857238e87fc1655b2820ab3"}], "stats": {"total": 155, "additions": 2, "deletions": 153}, "files": [{"sha": "348854298cd62cf90e7e61b619d0f57b1753a647", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09", "patch": "@@ -6,7 +6,8 @@ Tue Jan 20 09:29:09 1998  Jeffrey A Law  (law@cygnus.com)\n \t* expr.c, expr.h function.c, integrate.c: Likewise.\n \t* output.h, regclass.c, rtl.h, stmt.c, toplev.c: Likewise.\n \t* tree.h, varasm.c: Likewise.\n-\t* bi-*, bc-*: Delete bytecode related files.\n+\t* config/m68k/m68k.h: Likewise.\n+\t* bi-*, bc-*, bytecode*: Delete bytecode related files.\n \t\n \n Tue Jan 20 09:02:31 1998  Gavin Koch  (gavin@cygnus.com)"}, {"sha": "31d67ac73245e7460398350f466530aae4a774fb", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=424e713cd1bb2d27e3bcb13ce877bd0d22c3bf09", "patch": "@@ -2082,158 +2082,6 @@ do { long l;\t\t\t\t\t\t\\\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n-\n-/* Definitions for generating bytecode */\n-\n-/* Just so it's known this target is supported by the bytecode generator.\n-   If this define isn't found anywhere in the target config files, then\n-   dummy stubs are supplied by bytecode.h, and any attempt to use\n-   -fbytecode will result in an error message. */\n-\n-#define TARGET_SUPPORTS_BYTECODE\n-\n-/* Minimal segment alignment within sections is 8 units. */\n-#define MACHINE_SEG_ALIGN 3\n-\n-/* Integer alignment is two units. */\n-#define INT_ALIGN 2\n-\n-/* Pointer alignment is eight units. */\n-#define PTR_ALIGN 3\n-\n-/* Global symbols begin with `_' */\n-#define NAMES_HAVE_UNDERSCORES\n-\n-/* BC_xxx below are similar to their ASM_xxx counterparts above. */\n-#define BC_GLOBALIZE_LABEL(FP, NAME) bc_globalize_label(NAME)\n-\n-#define BC_OUTPUT_COMMON(FP, NAME, SIZE, ROUNDED) \\\n-  do { bc_emit_common(NAME, ROUNDED); bc_globalize_label(NAME); } while (0)\n-\n-#define BC_OUTPUT_BSS(FP, NAME, SIZE, ROUNDED) \\\n-  do { bc_data (); bc_emit_labeldef(NAME); bc_emit_skip (SIZE); } while (0)\n-\n-#define BC_OUTPUT_LOCAL(FP, NAME, SIZE, ROUNDED) \\\n-  bc_emit_common(NAME, ROUNDED)\n-\n-#define BC_OUTPUT_ALIGN(FP, ALIGN) bc_align(ALIGN)\n-\n-#define BC_OUTPUT_LABEL(FP, NAME) bc_emit_labeldef(NAME)\n-\n-#define BC_OUTPUT_SKIP(FP, SIZE) bc_emit_skip(SIZE)\n-\n-#define BC_OUTPUT_LABELREF(FP, NAME)\t\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    char *foo = (char *) xmalloc(strlen(NAME) + 2);\t\t\t      \\\n-    strcpy(foo, \"_\");\t\t\t\t\t\t\t      \\\n-    strcat(foo, NAME);\t\t\t\t\t\t\t      \\\n-    bc_emit_labelref (foo);\t\t\t\t\t\t      \\\n-    free (foo);\t\t\t\t\t\t\t\t      \\\n-  } while (0)\n-\n-#define BC_OUTPUT_FLOAT(FP, VAL)\t\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    float F = VAL;\t\t\t\t\t\t\t      \\\n-    bc_emit ((char *) &F, sizeof F);\t\t\t\t\t      \\\n-  } while (0)\n-\n-#define BC_OUTPUT_DOUBLE(FP, VAL)\t\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    double D = VAL;\t\t\t\t\t\t\t      \\\n-    bc_emit ((char *) &D, sizeof D);\t\t\t\t\t      \\\n-  } while (0)\n-\n-#define BC_OUTPUT_BYTE(FP, VAL)\t\t\t\t\t      \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    char C = VAL;\t\t\t\t\t\t\t      \\\n-    bc_emit (&C, 1);\t\t\t\t\t\t\t      \\\n-  } while (0)\n-\n-\n-#define BC_OUTPUT_FILE ASM_OUTPUT_FILE\n-#define BC_OUTPUT_ASCII ASM_OUTPUT_ASCII\n-#define BC_OUTPUT_IDENT ASM_OUTPUT_IDENT\n-\n-/* Same as XSTR, but for bytecode */\n-#define BCXSTR(RTX)  ((RTX)->bc_label)\n-\n-\n-/* Flush bytecode buffer onto file */\n-#define BC_WRITE_FILE(FP) \\\n-{ \\\n-  fprintf (FP, \".text\\n\"); \\\n-  bc_seg_write (bc_text_seg, FP); \\\n-  fprintf(FP, \"\\n.data\\n\"); \\\n-  bc_seg_write (bc_data_seg, FP); \\\n-  bc_sym_write (FP);  /* do .globl, .bss, etc. */ \\\n-}\n-\n-/* Write one symbol */\n-#define BC_WRITE_SEGSYM(SEGSYM, FP) \\\n-{ \\\n-  prsym (FP, (SEGSYM)->sym->name); \\\n-  fprintf (FP, \":\\n\"); \\\n-}\n-\n-\n-/* Write one reloc entry */\n-#define BC_WRITE_RELOC_ENTRY(SEGRELOC, FP, OFFSET) \\\n-{ \\\n-  fprintf (FP, \"\\t.long \"); \\\n-  prsym (FP, (SEGRELOC)->sym->name); \\\n-  fprintf (FP, \" + %d\\n\", OFFSET); \\\n-}\n-\n-/* Start new line of bytecodes */\n-#define BC_START_BYTECODE_LINE(FP) \\\n-{ \\\n-  fprintf (FP, \"\\t.byte\"); \\\n-}\n-\n-/* Write one bytecode */\n-#define BC_WRITE_BYTECODE(SEP, VAL, FP) \\\n-{ \\\n-  fprintf (FP, \"%c0x%02X\", (SEP), (VAL) & 0xff); \\\n-}\n-\n-/* Write one bytecode RTL entry */\n-#define BC_WRITE_RTL(R, FP) \\\n-{ \\\n-  fprintf (FP, \"%s+%d/0x%08X\\n\", (R)->label, (R)->offset, (R)->bc_label); \\\n-}\n-\n-\n-/* Emit function entry trampoline */\n-#define BC_EMIT_TRAMPOLINE(TRAMPSEG, CALLINFO) \\\n-{ \\\n-  short insn; \\\n- \\\n-  /* Push a reference to the callinfo structure.  */ \\\n-  insn = 0x4879;\t\t/* pea xxx.L */ \\\n-  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n-  seg_refsym (TRAMPSEG, CALLINFO, 0); \\\n- \\\n-  /* Call __interp, pop arguments, and return.  */ \\\n-  insn = 0x4eb9;\t\t/* jsr xxx.L  */ \\\n-  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n-  seg_refsym (TRAMPSEG, \"__callint\", 0); \\\n-  insn = 0x588f;\t\t/* addql #4, sp */ \\\n-  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n-  insn = 0x4e75;\t\t/* rts */ \\\n-  seg_data (TRAMPSEG, (char *) &insn, sizeof insn); \\\n-}\n-\n-\n-\n-#if 0\n-#define VALIDATE_STACK()  if (stack_depth < 0) abort ();\n-#else\n-#if 0\n-#define VALIDATE_STACK() \\\n-  fprintf (stderr, \" %%%d%%\", stack_depth);\n-#endif\n-#endif\n-\n /* Define functions defined in aux-output.c and used in templates.  */\n \n extern char *output_move_const_into_data_reg ();"}]}