{"sha": "89e6b70242b405c0df144abbe4a822fc376840fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllNmI3MDI0MmI0MDVjMGRmMTQ0YWJiZTRhODIyZmMzNzY4NDBmYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-17T08:49:53Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-17T08:49:53Z"}, "message": "rtl.h (SYMBOL_FLAG_MACH_DEP_SHIFT): New.\n\n        * rtl.h (SYMBOL_FLAG_MACH_DEP_SHIFT): New.\n\n        * config/m32r/m32r.c (SYMBOL_FLAG_MODEL_SHIFT): New.\n        (SYMBOL_REF_MODEL): New.\n        (LIT_NAME_P): Move from m32r.h.\n        (m32r_select_section): Remove.\n        (m32r_encode_section_info): Use SYMBOL_REF_FLAGS.\n        (m32r_strip_name_encoding): Remove.\n        (m32r_in_small_data_p): New.\n        (small_data_operand): Use SYMBOL_REF_SMALL_P.\n        (addr24_operand): Use SYMBOL_REF_MODEL.\n        (call26_operand): Likewise.\n        (addr32_operand): Tidy.\n        (m32r_print_operand): Use HOST_WIDE_INT_PRINT_HEX.\n        * config/m32r/m32r.h (RODATA_SECTION_ASM_OP): Remove.\n        (SDATA_SECTION_ASM_OP, SBSS_SECTION_ASM_OP): Remove.\n        (READONLY_DATA_SECTION_ASM_OP): Remove.\n        (EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS): Remove.\n        (SDATA_SECTION_FUNCTION, SBSS_SECTION_FUNCTION): Remove.\n        (TARGET_ASM_SELECT_SECTION): Remove.\n        (SDATA_FLAG_CHAR, MEDIUM_FLAG_CHAR, LARGE_FLAG_CHAR): Remove.\n        (SDATA_NAME_P, SMALL_NAME_P, MEDIUM_NAME_P): Remove.\n        (LARGE_NAME_P, ENCODED_NAME_P): Remove.\n        (ASM_OUTPUT_LABELREF): Remove.\n\nFrom-SVN: r65731", "tree": {"sha": "ecd9689a21085bbcee6181d066498ccd73d3bceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecd9689a21085bbcee6181d066498ccd73d3bceb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e6b70242b405c0df144abbe4a822fc376840fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e6b70242b405c0df144abbe4a822fc376840fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e6b70242b405c0df144abbe4a822fc376840fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e6b70242b405c0df144abbe4a822fc376840fa/comments", "author": null, "committer": null, "parents": [{"sha": "ec94fc00037519b0c7ac971396de8366216e3c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec94fc00037519b0c7ac971396de8366216e3c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec94fc00037519b0c7ac971396de8366216e3c36"}], "stats": {"total": 422, "additions": 142, "deletions": 280}, "files": [{"sha": "a2dfb444910d769183bba96ec5d97a86dcbcd61e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89e6b70242b405c0df144abbe4a822fc376840fa", "patch": "@@ -1,3 +1,30 @@\n+2003-04-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* rtl.h (SYMBOL_FLAG_MACH_DEP_SHIFT): New.\n+\n+\t* config/m32r/m32r.c (SYMBOL_FLAG_MODEL_SHIFT): New.\n+\t(SYMBOL_REF_MODEL): New.\n+\t(LIT_NAME_P): Move from m32r.h.\n+\t(m32r_select_section): Remove.\n+\t(m32r_encode_section_info): Use SYMBOL_REF_FLAGS.\n+\t(m32r_strip_name_encoding): Remove.\n+\t(m32r_in_small_data_p): New.\n+\t(small_data_operand): Use SYMBOL_REF_SMALL_P.\n+\t(addr24_operand): Use SYMBOL_REF_MODEL.\n+\t(call26_operand): Likewise.\n+\t(addr32_operand): Tidy.\n+\t(m32r_print_operand): Use HOST_WIDE_INT_PRINT_HEX.\n+\t* config/m32r/m32r.h (RODATA_SECTION_ASM_OP): Remove.\n+\t(SDATA_SECTION_ASM_OP, SBSS_SECTION_ASM_OP): Remove.\n+\t(READONLY_DATA_SECTION_ASM_OP): Remove.\n+\t(EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS): Remove.\n+\t(SDATA_SECTION_FUNCTION, SBSS_SECTION_FUNCTION): Remove.\n+\t(TARGET_ASM_SELECT_SECTION): Remove.\n+\t(SDATA_FLAG_CHAR, MEDIUM_FLAG_CHAR, LARGE_FLAG_CHAR): Remove.\n+\t(SDATA_NAME_P, SMALL_NAME_P, MEDIUM_NAME_P): Remove.\n+\t(LARGE_NAME_P, ENCODED_NAME_P): Remove.\n+\t(ASM_OUTPUT_LABELREF): Remove.\n+\n 2003-04-17  Richard Henderson  <rth@redhat.com>\n \n \t* config/ip2k/ip2k.c (is_regfile_address): Use SYMBOL_REF_FUNCTION_P."}, {"sha": "0170f4d54e8d39f5183ad1b89c80d1c84cdf9270", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 113, "deletions": 190, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=89e6b70242b405c0df144abbe4a822fc376840fa", "patch": "@@ -60,6 +60,14 @@ enum m32r_sdata m32r_sdata;\n /* Scheduler support */\n static int m32r_sched_odd_word_p;\n \n+/* Machine-specific symbol_ref flags.  */\n+#define SYMBOL_FLAG_MODEL_SHIFT\t\tSYMBOL_FLAG_MACH_DEP_SHIFT\n+#define SYMBOL_REF_MODEL(X) \\\n+  ((enum m32r_model) ((SYMBOL_REF_FLAGS (X) >> SYMBOL_FLAG_MODEL_SHIFT) & 3))\n+\n+/* For string literals, etc.  */\n+#define LIT_NAME_P(NAME) ((NAME)[0] == '*' && (NAME)[1] == '.')\n+\n /* Forward declaration.  */\n static void  init_reg_tables\t\t\tPARAMS ((void));\n static void  block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n@@ -76,9 +84,8 @@ static int    m32r_sched_reorder   PARAMS ((FILE *, int, rtx *, int *, int));\n static int    m32r_variable_issue  PARAMS ((FILE *, int, rtx, int));\n static int    m32r_issue_rate\t   PARAMS ((void));\n \n-static void m32r_select_section PARAMS ((tree, int, unsigned HOST_WIDE_INT));\n static void m32r_encode_section_info PARAMS ((tree, int));\n-static const char *m32r_strip_name_encoding PARAMS ((const char *));\n+static bool m32r_in_small_data_p PARAMS ((tree));\n static void init_idents PARAMS ((void));\n static bool m32r_rtx_costs PARAMS ((rtx, int, int, int *));\n \f\n@@ -111,8 +118,8 @@ static bool m32r_rtx_costs PARAMS ((rtx, int, int, int *));\n \n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO m32r_encode_section_info\n-#undef TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING m32r_strip_name_encoding\n+#undef TARGET_IN_SMALL_DATA_P\n+#define TARGET_IN_SMALL_DATA_P m32r_in_small_data_p\n \n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS m32r_rtx_costs\n@@ -332,180 +339,105 @@ m32r_handle_model_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \f\n-/* A C statement or statements to switch to the appropriate\n-   section for output of DECL.  DECL is either a `VAR_DECL' node\n-   or a constant of some sort.  RELOC indicates whether forming\n-   the initial value of DECL requires link-time relocations.  */\n-\n-static void\n-m32r_select_section (decl, reloc, align)\n-     tree decl;\n-     int reloc;\n-     unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED;\n-{\n-  if (TREE_CODE (decl) == STRING_CST)\n-    {\n-      if (! flag_writable_strings)\n-\treadonly_data_section ();\n-      else\n-\tdata_section ();\n-    }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n-    {\n-      if (SDATA_NAME_P (XSTR (XEXP (DECL_RTL (decl), 0), 0)))\n-\tsdata_section ();\n-      else if ((flag_pic && reloc)\n-\t       || !TREE_READONLY (decl)\n-\t       || TREE_SIDE_EFFECTS (decl)\n-\t       || !DECL_INITIAL (decl)\n-\t       || (DECL_INITIAL (decl) != error_mark_node\n-\t\t   && !TREE_CONSTANT (DECL_INITIAL (decl))))\n-\tdata_section ();\n-      else\n-\treadonly_data_section ();\n-    }\n-  else\n-    readonly_data_section ();\n-}\n-\n /* Encode section information of DECL, which is either a VAR_DECL,\n    FUNCTION_DECL, STRING_CST, CONSTRUCTOR, or ???.\n \n    For the M32R we want to record:\n \n    - whether the object lives in .sdata/.sbss.\n-     objects living in .sdata/.sbss are prefixed with SDATA_FLAG_CHAR\n-\n    - what code model should be used to access the object\n-     small: recorded with no flag - for space efficiency since they'll\n-            be the most common\n-     medium: prefixed with MEDIUM_FLAG_CHAR\n-     large: prefixed with LARGE_FLAG_CHAR\n */\n \n static void\n m32r_encode_section_info (decl, first)\n      tree decl;\n      int first;\n {\n-  char prefix = 0;\n-  tree model = 0;\n+  int extra_flags = 0;\n+  tree model_attr;\n+  enum m32r_model model;\n+\n+  default_encode_section_info (decl, first);\n \n-  if (!first)\n+  if (!DECL_P (decl))\n     return;\n \n-  switch (TREE_CODE (decl))\n+  model_attr = lookup_attribute (\"model\", DECL_ATTRIBUTES (decl));\n+  if (model_attr)\n     {\n-    case VAR_DECL :\n-    case FUNCTION_DECL :\n-      model = lookup_attribute (\"model\", DECL_ATTRIBUTES (decl));\n-      break;\n-    case STRING_CST :\n-    case CONSTRUCTOR :\n-      /* ??? document all others that can appear here */\n-    default :\n-      return;\n-    }\n+      tree id;\n \n-  /* Only mark the object as being small data area addressable if\n-     it hasn't been explicitly marked with a code model.\n+      init_idents ();\n \n-     The user can explicitly put an object in the small data area with the\n-     section attribute.  If the object is in sdata/sbss and marked with a\n-     code model do both [put the object in .sdata and mark it as being\n-     addressed with a specific code model - don't mark it as being addressed\n-     with an SDA reloc though].  This is ok and might be useful at times.  If\n-     the object doesn't fit the linker will give an error.  */\n+      id = TREE_VALUE (TREE_VALUE (model_attr));\n \n-  if (! model)\n+      if (id == small_ident1 || id == small_ident2)\n+\tmodel = M32R_MODEL_SMALL;\n+      else if (id == medium_ident1 || id == medium_ident2)\n+\tmodel = M32R_MODEL_MEDIUM;\n+      else if (id == large_ident1 || id == large_ident2)\n+\tmodel = M32R_MODEL_LARGE;\n+      else\n+\tabort (); /* shouldn't happen */\n+    }\n+  else\n     {\n-      if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd'\n-\t  && DECL_SECTION_NAME (decl) != NULL_TREE)\n-\t{\n-\t  char *name = (char *) TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n-\t  if (! strcmp (name, \".sdata\") || ! strcmp (name, \".sbss\"))\n-\t    {\n-#if 0 /* ??? There's no reason to disallow this, is there?  */\n-\t      if (TREE_READONLY (decl))\n-\t\terror_with_decl (decl, \"const objects cannot go in .sdata/.sbss\");\n-#endif\n-\t      prefix = SDATA_FLAG_CHAR;\n-\t    }\n-\t}\n+      if (TARGET_MODEL_SMALL)\n+\tmodel = M32R_MODEL_SMALL;\n+      else if (TARGET_MODEL_MEDIUM)\n+\tmodel = M32R_MODEL_MEDIUM;\n+      else if (TARGET_MODEL_LARGE)\n+\tmodel = M32R_MODEL_LARGE;\n       else\n-\t{\n-\t  if (TREE_CODE (decl) == VAR_DECL\n-\t      && ! TREE_READONLY (decl)\n-\t      && ! TARGET_SDATA_NONE)\n-\t    {\n-\t      int size = int_size_in_bytes (TREE_TYPE (decl));\n-\n-\t      if (size > 0 && size <= g_switch_value)\n-\t\tprefix = SDATA_FLAG_CHAR;\n-\t    }\n-\t}\n+\tabort (); /* shouldn't happen */\n     }\n+  extra_flags |= model << SYMBOL_FLAG_MODEL_SHIFT;\n \n-  /* If data area not decided yet, check for a code model.  */\n-  if (prefix == 0)\n-    {\n-      if (model)\n-\t{\n-\t  tree id;\n-\t  \n-\t  init_idents ();\n+  if (extra_flags)\n+    SYMBOL_REF_FLAGS (XEXP (DECL_RTL (decl), 0)) |= extra_flags;\n+}\n \n-\t  id = TREE_VALUE (TREE_VALUE (model));\n+/* Only mark the object as being small data area addressable if\n+   it hasn't been explicitly marked with a code model.\n \n-\t  if (id == small_ident1 || id == small_ident2)\n-\t    ; /* don't mark the symbol specially */\n-\t  else if (id == medium_ident1 || id == medium_ident2)\n-\t    prefix = MEDIUM_FLAG_CHAR;\n-\t  else if (id == large_ident1 || id == large_ident2)\n-\t    prefix = LARGE_FLAG_CHAR;\n-\t  else\n-\t    abort (); /* shouldn't happen */\n-\t}\n-      else\n-\t{\n-\t  if (TARGET_MODEL_SMALL)\n-\t    ; /* don't mark the symbol specially */\n-\t  else if (TARGET_MODEL_MEDIUM)\n-\t    prefix = MEDIUM_FLAG_CHAR;\n-\t  else if (TARGET_MODEL_LARGE)\n-\t    prefix = LARGE_FLAG_CHAR;\n-\t  else\n-\t    abort (); /* shouldn't happen */\n-\t}\n-    }\n+   The user can explicitly put an object in the small data area with the\n+   section attribute.  If the object is in sdata/sbss and marked with a\n+   code model do both [put the object in .sdata and mark it as being\n+   addressed with a specific code model - don't mark it as being addressed\n+   with an SDA reloc though].  This is ok and might be useful at times.  If\n+   the object doesn't fit the linker will give an error.  */\n+\n+static bool\n+m32r_in_small_data_p (decl)\n+     tree decl;\n+{\n+  tree section;\n \n-  if (prefix != 0)\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+\n+  if (lookup_attribute (\"model\", DECL_ATTRIBUTES (decl)))\n+    return false;\n+\n+  section = DECL_SECTION_NAME (decl);\n+  if (section)\n     {\n-      rtx rtl = (TREE_CODE_CLASS (TREE_CODE (decl)) != 'd'\n-                 ? TREE_CST_RTL (decl) : DECL_RTL (decl));\n-      const char *str = XSTR (XEXP (rtl, 0), 0);\n-      int len = strlen (str);\n-      char *newstr = ggc_alloc (len + 2);\n-\n-      strcpy (newstr + 1, str);\n-      *newstr = prefix;\n-      /* Note - we cannot leave the string in the ggc_alloc'ed space.\n-         It must reside in the stringtable's domain.  */\n-      newstr = (char *) ggc_alloc_string (newstr, len + 2);\n-\n-      XSTR (XEXP (rtl, 0), 0) = newstr;\n+      char *name = (char *) TREE_STRING_POINTER (section);\n+      if (strcmp (name, \".sdata\") == 0 || strcmp (name, \".sbss\") == 0)\n+\treturn true;\n     }\n-}\n+  else\n+    {\n+      if (! TREE_READONLY (decl) && ! TARGET_SDATA_NONE)\n+\t{\n+\t  int size = int_size_in_bytes (TREE_TYPE (decl));\n \n-/* Undo the effects of the above.  */\n+\t  if (size > 0 && size <= g_switch_value)\n+\t    return true;\n+\t}\n+    }\n \n-static const char *\n-m32r_strip_name_encoding (str)\n-     const char *str;\n-{\n-  str += ENCODED_NAME_P (str);\n-  str += *str == '*';\n-  return str;\n+  return false;\n }\n \n /* Do anything needed before RTL is emitted for each function.  */\n@@ -571,14 +503,14 @@ small_data_operand (op, mode)\n     return 0;\n \n   if (GET_CODE (op) == SYMBOL_REF)\n-    return SDATA_NAME_P (XSTR (op, 0));\n+    return SYMBOL_REF_SMALL_P (op);\n \n   if (GET_CODE (op) == CONST\n       && GET_CODE (XEXP (op, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n       && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n       && INT16_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n-    return SDATA_NAME_P (XSTR (XEXP (XEXP (op, 0), 0), 0));\n+    return SYMBOL_REF_SMALL_P (XEXP (XEXP (op, 0), 0));\n \n   return 0;\n }\n@@ -590,27 +522,29 @@ addr24_operand (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n+  rtx sym;\n+\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR24;\n \n   if (GET_CODE (op) == SYMBOL_REF)\n-    return (SMALL_NAME_P (XSTR (op, 0))\n-\t    || (TARGET_ADDR24\n-\t\t&& (CONSTANT_POOL_ADDRESS_P (op)\n-\t\t    || LIT_NAME_P (XSTR (op, 0)))));\n+    sym = op;\n+  else if (GET_CODE (op) == CONST\n+\t   && GET_CODE (XEXP (op, 0)) == PLUS\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+\t   && UINT24_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n+    sym = XEXP (XEXP (op, 0), 0);\n+  else\n+    return 0;\n \n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n-      && UINT24_P (INTVAL (XEXP (XEXP (op, 0), 1))))\n-    {\n-      rtx sym = XEXP (XEXP (op, 0), 0);\n-      return (SMALL_NAME_P (XSTR (sym, 0))\n-\t      || (TARGET_ADDR24\n-\t\t  && (CONSTANT_POOL_ADDRESS_P (sym)\n-\t\t      || LIT_NAME_P (XSTR (sym, 0)))));\n-    }\n+  if (SYMBOL_REF_MODEL (sym) == M32R_MODEL_SMALL)\n+    return 1;\n+\n+  if (TARGET_ADDR24\n+      && (CONSTANT_POOL_ADDRESS_P (sym)\n+\t  || LIT_NAME_P (XSTR (sym, 0))))\n+    return 1;\n \n   return 0;\n }\n@@ -622,23 +556,23 @@ addr32_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n+  rtx sym;\n+\n   if (GET_CODE (op) == LABEL_REF)\n     return TARGET_ADDR32;\n \n   if (GET_CODE (op) == SYMBOL_REF)\n-    return (! addr24_operand (op, mode)\n-\t    && ! small_data_operand (op, mode));\n-\n-  if (GET_CODE (op) == CONST\n-      && GET_CODE (XEXP (op, 0)) == PLUS\n-      && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n-    {\n-      return (! addr24_operand (op, mode)\n-\t      && ! small_data_operand (op, mode));\n-    }\n+    sym = op;\n+  else if (GET_CODE (op) == CONST\n+\t   && GET_CODE (XEXP (op, 0)) == PLUS\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT)\n+    sym = XEXP (XEXP (op, 0), 0);\n+  else\n+    return 0;\n \n-  return 0;\n+  return (! addr24_operand (sym, mode)\n+\t  && ! small_data_operand (sym, mode));\n }\n \n /* Return 1 if OP is a function that can be called with the `bl' insn.  */\n@@ -649,7 +583,7 @@ call26_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) == SYMBOL_REF)\n-    return ! LARGE_NAME_P (XSTR (op, 0));\n+    return SYMBOL_REF_MODEL (op) != M32R_MODEL_LARGE;\n \n   return TARGET_CALL26;\n }\n@@ -2384,12 +2318,7 @@ m32r_print_operand (file, x, code)\n \n \t    split_double (x, &first, &second);\n \t    x = WORDS_BIG_ENDIAN ? second : first;\n-\t    fprintf (file,\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t     \"0x%x\",\n-#else\n-\t\t     \"0x%lx\",\n-#endif\n+\t    fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n \t\t     (code == 'B'\n \t\t      ? INTVAL (x) & 0xffff\n \t\t      : (INTVAL (x) >> 16) & 0xffff));\n@@ -2441,13 +2370,7 @@ m32r_print_operand (file, x, code)\n     case 'X' :\n       /* Print a const_int in hex.  Used in comments.  */\n       if (GET_CODE (x) == CONST_INT)\n-\tfprintf (file,\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t \"0x%x\",\n-#else\n-\t\t \"0x%lx\",\n-#endif\n-\t\t INTVAL (x));\n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n       return;\n \n     case '#' :"}, {"sha": "0ce5737bd9314d40771ed52f7daa8a8f3adcd6f1", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=89e6b70242b405c0df144abbe4a822fc376840fa", "patch": "@@ -1468,96 +1468,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define TEXT_SECTION_ASM_OP\t\"\\t.section .text\"\n #define DATA_SECTION_ASM_OP\t\"\\t.section .data\"\n-#define RODATA_SECTION_ASM_OP\t\"\\t.section .rodata\"\n #define BSS_SECTION_ASM_OP\t\"\\t.section .bss\"\n-#define SDATA_SECTION_ASM_OP\t\"\\t.section .sdata\"\n-#define SBSS_SECTION_ASM_OP\t\"\\t.section .sbss\"\n-/* This one is for svr4.h.  */\n-#undef  READONLY_DATA_SECTION_ASM_OP\n-#define READONLY_DATA_SECTION_ASM_OP\t\"\\t.section .rodata\"\n-\n-/* A list of names for sections other than the standard two, which are\n-   `in_text' and `in_data'.  You need not define this macro\n-   on a system with no other sections (that GCC needs to use).  */\n-#undef  EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_sdata, in_sbss\n-\n-/* One or more functions to be defined in \"varasm.c\".  These\n-   functions should do jobs analogous to those of `text_section' and\n-   `data_section', for your additional sections.  Do not define this\n-   macro if you do not define `EXTRA_SECTIONS'.  */\n-#undef  EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS\t\\\n-  SDATA_SECTION_FUNCTION\t\\\n-  SBSS_SECTION_FUNCTION\n-\n-#define SDATA_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-sdata_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_sdata)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", SDATA_SECTION_ASM_OP);\t\t\\\n-      in_section = in_sdata;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\n-#define SBSS_SECTION_FUNCTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\t\\\n-sbss_section ()\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_sbss)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", SBSS_SECTION_ASM_OP);\t\t\\\n-      in_section = in_sbss;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-\n-#undef  TARGET_ASM_SELECT_SECTION\n-#define TARGET_ASM_SELECT_SECTION  m32r_select_section\n \n /* Define this macro if jump tables (for tablejump insns) should be\n    output in the text section, along with the assembler instructions.\n    Otherwise, the readonly data section is used.\n    This macro is irrelevant if there is no separate readonly data section.  */\n /*#define JUMP_TABLES_IN_TEXT_SECTION*/\n-\n-/* Define this macro if references to a symbol must be treated\n-   differently depending on something about the variable or\n-   function named by the symbol (such as what section it is in).\n-\n-   The macro definition, if any, is executed immediately after the\n-   rtl for DECL or other node is created.\n-   The value of the rtl will be a `mem' whose address is a\n-   `symbol_ref'.\n-\n-   The usual thing for this macro to do is to store a flag in the\n-   `symbol_ref' (such as `SYMBOL_REF_FLAG') or to store a modified\n-   name string in the `symbol_ref' (if one bit is not enough\n-   information).  */\n-\n-#define SDATA_FLAG_CHAR '@'\n-/* Small objects are recorded with no prefix for space efficiency since\n-   they'll be the most common.  This isn't the case if the user passes\n-   -mmodel={medium|large} and one could choose to not mark symbols that\n-   are the default, but that complicates things.  */\n-/*#define SMALL_FLAG_CHAR '#'*/\n-#define MEDIUM_FLAG_CHAR '%'\n-#define LARGE_FLAG_CHAR '&'\n-\n-#define SDATA_NAME_P(NAME) (*(NAME) == SDATA_FLAG_CHAR)\n-/*#define SMALL_NAME_P(NAME) (*(NAME) == SMALL_FLAG_CHAR)*/\n-#define SMALL_NAME_P(NAME) (! ENCODED_NAME_P (NAME) && ! LIT_NAME_P (NAME))\n-#define MEDIUM_NAME_P(NAME) (*(NAME) == MEDIUM_FLAG_CHAR)\n-#define LARGE_NAME_P(NAME) (*(NAME) == LARGE_FLAG_CHAR)\n-/* For string literals, etc.  */\n-#define LIT_NAME_P(NAME) ((NAME)[0] == '*' && (NAME)[1] == '.')\n-\n-#define ENCODED_NAME_P(SYMBOL_NAME) \\\n-(SDATA_NAME_P (SYMBOL_NAME) \\\n- /*|| SMALL_NAME_P (SYMBOL_NAME)*/ \\\n- || MEDIUM_NAME_P (SYMBOL_NAME) \\\n- || LARGE_NAME_P (SYMBOL_NAME))\n \f\n /* PIC */\n \n@@ -1622,12 +1539,6 @@ sbss_section ()\t\t\t\t\t\t\t\t\\\n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.global\\t\"\n \n-/* This is how to output a reference to a user-level label named NAME.\n-   `assemble_name' uses this.  */\n-#undef  ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n-  asm_fprintf (FILE, \"%U%s\", (*targetm.strip_name_encoding) (NAME))\n-\n /* If -Os, don't force line number labels to begin at the beginning of\n    the word; we still want the assembler to try to put things in parallel,\n    should that be possible."}, {"sha": "eb78ba6d1764154ae647ea5541f8617c9878629b", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e6b70242b405c0df144abbe4a822fc376840fa/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=89e6b70242b405c0df144abbe4a822fc376840fa", "patch": "@@ -1280,7 +1280,8 @@ do {\t\t\t\t\t\t\\\n   ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_EXTERNAL) != 0)\n \n /* Subsequent bits are available for the target to use.  */\n-#define SYMBOL_FLAG_MACH_DEP\t(1 << 7)\n+#define SYMBOL_FLAG_MACH_DEP_SHIFT\t7\n+#define SYMBOL_FLAG_MACH_DEP\t\t(1 << SYMBOL_FLAG_MACH_DEP_SHIFT)\n \n /* Define a macro to look for REG_INC notes,\n    but save time on machines where they never exist.  */"}]}