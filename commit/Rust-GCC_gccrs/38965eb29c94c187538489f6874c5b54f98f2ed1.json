{"sha": "38965eb29c94c187538489f6874c5b54f98f2ed1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg5NjVlYjI5Yzk0YzE4NzUzODQ4OWY2ODc0YzViNTRmOThmMmVkMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-05-17T19:55:53Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-05-17T19:55:53Z"}, "message": "tree-cfg.c (tree_can_merge_blocks_p): Allow phi nodes in the merged block.\n\n\t* tree-cfg.c (tree_can_merge_blocks_p): Allow phi nodes in the\n\tmerged block.\n\t(replace_uses_by): New function.\n\t(tree_merge_blocks): Eliminate the phi nodes in the merged block.\n\t* tree-flow.h (fold_stmt_inplace): Declare.\n\t* tree-ssa-ccp.c (fold_stmt_inplace): New function.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Update dominance\n\tinfo after cfg cleanup.\n\nFrom-SVN: r99850", "tree": {"sha": "d5471dc3f0c17a518b2a28a858669d705b2a853d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5471dc3f0c17a518b2a28a858669d705b2a853d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38965eb29c94c187538489f6874c5b54f98f2ed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38965eb29c94c187538489f6874c5b54f98f2ed1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38965eb29c94c187538489f6874c5b54f98f2ed1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38965eb29c94c187538489f6874c5b54f98f2ed1/comments", "author": null, "committer": null, "parents": [{"sha": "6c878b231db4f5886d79c187083f0e0b65c8cf8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c878b231db4f5886d79c187083f0e0b65c8cf8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c878b231db4f5886d79c187083f0e0b65c8cf8c"}], "stats": {"total": 135, "additions": 132, "deletions": 3}, "files": [{"sha": "141be32fece47d5538b4800ab8fa63ffcd84f47c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38965eb29c94c187538489f6874c5b54f98f2ed1", "patch": "@@ -1,3 +1,14 @@\n+2005-05-17  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-cfg.c (tree_can_merge_blocks_p): Allow phi nodes in the\n+\tmerged block.\n+\t(replace_uses_by): New function.\n+\t(tree_merge_blocks): Eliminate the phi nodes in the merged block.\n+\t* tree-flow.h (fold_stmt_inplace): Declare.\n+\t* tree-ssa-ccp.c (fold_stmt_inplace): New function.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Update dominance\n+\tinfo after cfg cleanup.\n+\n 2005-05-17  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* cfgloop.h (just_once_each_iteration_p): Declaration changed."}, {"sha": "4beb0e74290b7708c7e4cce741e6bf41a3fe5569", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=38965eb29c94c187538489f6874c5b54f98f2ed1", "patch": "@@ -1261,6 +1261,7 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n {\n   tree stmt;\n   block_stmt_iterator bsi;\n+  tree phi;\n \n   if (!single_succ_p (a))\n     return false;\n@@ -1288,9 +1289,19 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n       && DECL_NONLOCAL (LABEL_EXPR_LABEL (stmt)))\n     return false;\n \n-  /* There may be no PHI nodes at the start of B.  */\n-  if (phi_nodes (b))\n-    return false;\n+  /* It must be possible to eliminate all phi nodes in B.  If ssa form\n+     is not up-to-date, we cannot eliminate any phis.  */\n+  phi = phi_nodes (b);\n+  if (phi)\n+    {\n+      if (need_ssa_update_p ())\n+\treturn false;\n+\n+      for (; phi; phi = PHI_CHAIN (phi))\n+\tif (!is_gimple_reg (PHI_RESULT (phi))\n+\t    && !may_propagate_copy (PHI_RESULT (phi), PHI_ARG_DEF (phi, 0)))\n+\t  return false;\n+    }\n \n   /* Do not remove user labels.  */\n   for (bsi = bsi_start (b); !bsi_end_p (bsi); bsi_next (&bsi))\n@@ -1310,6 +1321,55 @@ tree_can_merge_blocks_p (basic_block a, basic_block b)\n   return true;\n }\n \n+/* Replaces all uses of NAME by VAL.  */\n+\n+static void\n+replace_uses_by (tree name, tree val)\n+{\n+  imm_use_iterator imm_iter;\n+  use_operand_p use;\n+  tree stmt;\n+  edge e;\n+  unsigned i;\n+  VEC(tree,heap) *stmts = VEC_alloc (tree, heap, 20);\n+\n+  FOR_EACH_IMM_USE_SAFE (use, imm_iter, name)\n+    {\n+      stmt = USE_STMT (use);\n+\n+      SET_USE (use, val);\n+\n+      if (TREE_CODE (stmt) == PHI_NODE)\n+\t{\n+\t  e = PHI_ARG_EDGE (stmt, PHI_ARG_INDEX_FROM_USE (use));\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    {\n+\t      /* This can only occur for virtual operands, since\n+\t\t for the real ones SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n+\t\t would prevent replacement.  */\n+\t      gcc_assert (!is_gimple_reg (name));\n+\t      SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val) = 1;\n+\t    }\n+\t}\n+      else\n+\tVEC_safe_push (tree, heap, stmts, stmt);\n+    }\n+ \n+  /* We do not update the statements in the loop above.  Consider\n+     x = w * w;\n+\n+     If we performed the update in the first loop, the statement\n+     would be rescanned after first occurence of w is replaced,\n+     the new uses would be placed to the beginning of the list,\n+     and we would never process them.  */\n+  for (i = 0; VEC_iterate (tree, stmts, i, stmt); i++)\n+    {\n+      fold_stmt_inplace (stmt);\n+      update_stmt (stmt);\n+    }\n+\n+  VEC_free (tree, heap, stmts);\n+}\n \n /* Merge block B into block A.  */\n \n@@ -1318,10 +1378,40 @@ tree_merge_blocks (basic_block a, basic_block b)\n {\n   block_stmt_iterator bsi;\n   tree_stmt_iterator last;\n+  tree phi;\n \n   if (dump_file)\n     fprintf (dump_file, \"Merging blocks %d and %d\\n\", a->index, b->index);\n \n+  /* Remove the phi nodes.  */\n+  bsi = bsi_last (a);\n+  for (phi = phi_nodes (b); phi; phi = phi_nodes (b))\n+    {\n+      tree def = PHI_RESULT (phi), use = PHI_ARG_DEF (phi, 0);\n+      tree copy;\n+      \n+      if (!may_propagate_copy (def, use)\n+\t  /* Propagating pointers might cause the set of vops for statements\n+\t     to be changed, and thus require ssa form update.  */\n+\t  || (is_gimple_reg (def)\n+\t      && POINTER_TYPE_P (TREE_TYPE (def))))\n+\t{\n+\t  gcc_assert (is_gimple_reg (def));\n+\n+\t  /* Note that just emiting the copies is fine -- there is no problem\n+\t     with ordering of phi nodes.  This is because A is the single\n+\t     predecessor of B, therefore results of the phi nodes cannot\n+\t     appear as arguments of the phi nodes.  */\n+\t  copy = build2 (MODIFY_EXPR, void_type_node, def, use);\n+\t  bsi_insert_after (&bsi, copy, BSI_NEW_STMT);\n+\t  SET_PHI_RESULT (phi, NULL_TREE);\n+\t  SSA_NAME_DEF_STMT (def) = copy;\n+\t}\n+      else\n+\treplace_uses_by (def, use);\n+      remove_phi_node (phi, NULL);\n+    }\n+\n   /* Ensure that B follows A.  */\n   move_block_after (b, a);\n "}, {"sha": "90bef3763f97d38d0cc8b3ee03f27d56b83886f3", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=38965eb29c94c187538489f6874c5b54f98f2ed1", "patch": "@@ -630,6 +630,7 @@ void set_current_def (tree, tree);\n \n /* In tree-ssa-ccp.c  */\n bool fold_stmt (tree *);\n+bool fold_stmt_inplace (tree);\n tree widen_bitfield (tree, tree, tree);\n \n /* In tree-vrp.c  */"}, {"sha": "45472f402ab55f28d4614e34808136ff58681f2e", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=38965eb29c94c187538489f6874c5b54f98f2ed1", "patch": "@@ -2308,6 +2308,32 @@ fold_stmt (tree *stmt_p)\n   return changed;\n }\n \n+/* Perform the minimal folding on statement STMT.  Only operations like\n+   *&x created by constant propagation are handled.  The statement cannot\n+   be replaced with a new one.  */\n+\n+bool\n+fold_stmt_inplace (tree stmt)\n+{\n+  tree old_stmt = stmt, rhs, new_rhs;\n+  bool changed = false;\n+\n+  walk_tree (&stmt, fold_stmt_r, &changed, NULL);\n+  gcc_assert (stmt == old_stmt);\n+\n+  rhs = get_rhs (stmt);\n+  if (!rhs || rhs == stmt)\n+    return changed;\n+\n+  new_rhs = fold (rhs);\n+  if (new_rhs == rhs)\n+    return changed;\n+\n+  changed |= set_rhs (&stmt, new_rhs);\n+  gcc_assert (stmt == old_stmt);\n+\n+  return changed;\n+}\n \f\n /* Convert EXPR into a GIMPLE value suitable for substitution on the\n    RHS of an assignment.  Insert the necessary statements before"}, {"sha": "692dd705b2f3868fd88aaa73e677f722b5e2bac6", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38965eb29c94c187538489f6874c5b54f98f2ed1/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=38965eb29c94c187538489f6874c5b54f98f2ed1", "patch": "@@ -404,6 +404,7 @@ tree_ssa_dominator_optimize (void)\n   /* Clean up the CFG so that any forwarder blocks created by loop\n      canonicalization are removed.  */\n   cleanup_tree_cfg ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   /* If we prove certain blocks are unreachable, then we want to\n      repeat the dominator optimization process as PHI nodes may"}]}