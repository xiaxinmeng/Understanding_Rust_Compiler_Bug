{"sha": "06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlYjUyY2FiNWM5OWFiY2RiM2FkY2JkZmJhOGNmNzVkMzg3MDVjNA==", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2011-04-12T04:42:55Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@gcc.gnu.org", "date": "2011-04-12T04:42:55Z"}, "message": "re PR target/48250 (ICE in reload_cse_simplify_operands, at postreload.c:403)\n\n2011-04-11  Chung-Lin Tang  <cltang@codesourcery.com>\n\t    Richard Earnshaw  <rearnsha@arm.com>\n\n\tPR target/48250\n\t* config/arm/arm.c (arm_legitimize_reload_address): Update cases\n\tto use sign-magnitude offsets. Reject unsupported unaligned\n\tcases. Add detailed description in comments.\n\t* config/arm/arm.md (reload_outdf): Disable for ARM mode; change\n\tcondition from TARGET_32BIT to TARGET_ARM.\n\nCo-Authored-By: Richard Earnshaw <rearnsha@arm.com>\n\nFrom-SVN: r172297", "tree": {"sha": "999a5a3a59b79d9159bdd635c1346920b604f223", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/999a5a3a59b79d9159bdd635c1346920b604f223"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "648a616b30ab2be76103519a3ed4f7f77a00c947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/648a616b30ab2be76103519a3ed4f7f77a00c947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/648a616b30ab2be76103519a3ed4f7f77a00c947"}], "stats": {"total": 149, "additions": 131, "deletions": 18}, "files": [{"sha": "bf897c9b80e8ac0c75f1836e7db8b850c0ef4b67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "patch": "@@ -1,3 +1,13 @@\n+2011-04-11  Chung-Lin Tang  <cltang@codesourcery.com>\n+\t    Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/48250\n+\t* config/arm/arm.c (arm_legitimize_reload_address): Update cases\n+\tto use sign-magnitude offsets. Reject unsupported unaligned\n+\tcases. Add detailed description in comments.\n+\t* config/arm/arm.md (reload_outdf): Disable for ARM mode; change\n+\tcondition from TARGET_32BIT to TARGET_ARM.\n+\n 2011-04-11  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.h (struct typed_tree): New."}, {"sha": "3dc2fdda2002c7263ecd42a11b806043c944d234", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 120, "deletions": 17, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "patch": "@@ -6262,23 +6262,126 @@ arm_legitimize_reload_address (rtx *p,\n       HOST_WIDE_INT val = INTVAL (XEXP (*p, 1));\n       HOST_WIDE_INT low, high;\n \n-      if (mode == DImode || (mode == DFmode && TARGET_SOFT_FLOAT))\n-\tlow = ((val & 0xf) ^ 0x8) - 0x8;\n-      else if (TARGET_MAVERICK && TARGET_HARD_FLOAT)\n-\t/* Need to be careful, -256 is not a valid offset.  */\n-\tlow = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\n-      else if (mode == SImode\n-\t       || (mode == SFmode && TARGET_SOFT_FLOAT)\n-\t       || ((mode == HImode || mode == QImode) && ! arm_arch4))\n-\t/* Need to be careful, -4096 is not a valid offset.  */\n-\tlow = val >= 0 ? (val & 0xfff) : -((-val) & 0xfff);\n-      else if ((mode == HImode || mode == QImode) && arm_arch4)\n-\t/* Need to be careful, -256 is not a valid offset.  */\n-\tlow = val >= 0 ? (val & 0xff) : -((-val) & 0xff);\n-      else if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t       && TARGET_HARD_FLOAT && TARGET_FPA)\n-\t/* Need to be careful, -1024 is not a valid offset.  */\n-\tlow = val >= 0 ? (val & 0x3ff) : -((-val) & 0x3ff);\n+      /* Detect coprocessor load/stores.  */\n+      bool coproc_p = ((TARGET_HARD_FLOAT\n+\t\t\t&& (TARGET_VFP || TARGET_FPA || TARGET_MAVERICK)\n+\t\t\t&& (mode == SFmode || mode == DFmode\n+\t\t\t    || (mode == DImode && TARGET_MAVERICK)))\n+\t\t       || (TARGET_REALLY_IWMMXT\n+\t\t\t   && VALID_IWMMXT_REG_MODE (mode))\n+\t\t       || (TARGET_NEON\n+\t\t\t   && (VALID_NEON_DREG_MODE (mode)\n+\t\t\t       || VALID_NEON_QREG_MODE (mode))));\n+\n+      /* For some conditions, bail out when lower two bits are unaligned.  */\n+      if ((val & 0x3) != 0\n+\t  /* Coprocessor load/store indexes are 8-bits + '00' appended.  */\n+\t  && (coproc_p\n+\t      /* For DI, and DF under soft-float: */\n+\t      || ((mode == DImode || mode == DFmode)\n+\t\t  /* Without ldrd, we use stm/ldm, which does not\n+\t\t     fair well with unaligned bits.  */\n+\t\t  && (! TARGET_LDRD\n+\t\t      /* Thumb-2 ldrd/strd is [-1020,+1020] in steps of 4.  */\n+\t\t      || TARGET_THUMB2))))\n+\treturn false;\n+\n+      /* When breaking down a [reg+index] reload address into [(reg+high)+low],\n+\t of which the (reg+high) gets turned into a reload add insn,\n+\t we try to decompose the index into high/low values that can often\n+\t also lead to better reload CSE.\n+\t For example:\n+\t         ldr r0, [r2, #4100]  // Offset too large\n+\t\t ldr r1, [r2, #4104]  // Offset too large\n+\n+\t is best reloaded as:\n+\t         add t1, r2, #4096\n+\t\t ldr r0, [t1, #4]\n+\t\t add t2, r2, #4096\n+\t\t ldr r1, [t2, #8]\n+\n+\t which post-reload CSE can simplify in most cases to eliminate the\n+\t second add instruction:\n+\t         add t1, r2, #4096\n+\t\t ldr r0, [t1, #4]\n+\t\t ldr r1, [t1, #8]\n+\n+\t The idea here is that we want to split out the bits of the constant\n+\t as a mask, rather than as subtracting the maximum offset that the\n+\t respective type of load/store used can handle.\n+\n+\t When encountering negative offsets, we can still utilize it even if\n+\t the overall offset is positive; sometimes this may lead to an immediate\n+\t that can be constructed with fewer instructions.\n+\t For example:\n+\t         ldr r0, [r2, #0x3FFFFC]\n+\n+\t This is best reloaded as:\n+\t         add t1, r2, #0x400000\n+\t\t ldr r0, [t1, #-4]\n+\n+\t The trick for spotting this for a load insn with N bits of offset\n+\t (i.e. bits N-1:0) is to look at bit N; if it is set, then chose a\n+\t negative offset that is going to make bit N and all the bits below\n+\t it become zero in the remainder part.\n+\n+\t The SIGN_MAG_LOW_ADDR_BITS macro below implements this, with respect\n+\t to sign-magnitude addressing (i.e. separate +- bit, or 1's complement),\n+\t used in most cases of ARM load/store instructions.  */\n+\n+#define SIGN_MAG_LOW_ADDR_BITS(VAL, N)\t\t\t\t\t\\\n+      (((VAL) & ((1 << (N)) - 1))\t\t\t\t\t\\\n+       ? (((VAL) & ((1 << ((N) + 1)) - 1)) ^ (1 << (N))) - (1 << (N))\t\\\n+       : 0)\n+\n+      if (coproc_p)\n+\tlow = SIGN_MAG_LOW_ADDR_BITS (val, 10);\n+      else if (GET_MODE_SIZE (mode) == 8)\n+\t{\n+\t  if (TARGET_LDRD)\n+\t    low = (TARGET_THUMB2\n+\t\t   ? SIGN_MAG_LOW_ADDR_BITS (val, 10)\n+\t\t   : SIGN_MAG_LOW_ADDR_BITS (val, 8));\n+\t  else\n+\t    /* For pre-ARMv5TE (without ldrd), we use ldm/stm(db/da/ib)\n+\t       to access doublewords. The supported load/store offsets are\n+\t       -8, -4, and 4, which we try to produce here.  */\n+\t    low = ((val & 0xf) ^ 0x8) - 0x8;\n+\t}\n+      else if (GET_MODE_SIZE (mode) < 8)\n+\t{\n+\t  /* NEON element load/stores do not have an offset.  */\n+\t  if (TARGET_NEON_FP16 && mode == HFmode)\n+\t    return false;\n+\n+\t  if (TARGET_THUMB2)\n+\t    {\n+\t      /* Thumb-2 has an asymmetrical index range of (-256,4096).\n+\t\t Try the wider 12-bit range first, and re-try if the result\n+\t\t is out of range.  */\n+\t      low = SIGN_MAG_LOW_ADDR_BITS (val, 12);\n+\t      if (low < -255)\n+\t\tlow = SIGN_MAG_LOW_ADDR_BITS (val, 8);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (mode == HImode || mode == HFmode)\n+\t\t{\n+\t\t  if (arm_arch4)\n+\t\t    low = SIGN_MAG_LOW_ADDR_BITS (val, 8);\n+\t\t  else\n+\t\t    {\n+\t\t      /* The storehi/movhi_bytes fallbacks can use only\n+\t\t\t [-4094,+4094] of the full ldrb/strb index range.  */\n+\t\t      low = SIGN_MAG_LOW_ADDR_BITS (val, 12);\n+\t\t      if (low == 4095 || low == -4095)\n+\t\t\treturn false;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tlow = SIGN_MAG_LOW_ADDR_BITS (val, 12);\n+\t    }\n+\t}\n       else\n \treturn false;\n "}, {"sha": "e703a73fba07526c4852e3220b498d65928fb232", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06eb52cab5c99abcdb3adcbdfba8cf75d38705c4/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=06eb52cab5c99abcdb3adcbdfba8cf75d38705c4", "patch": "@@ -6188,7 +6188,7 @@\n   [(match_operand:DF 0 \"arm_reload_memory_operand\" \"=o\")\n    (match_operand:DF 1 \"s_register_operand\" \"r\")\n    (match_operand:SI 2 \"s_register_operand\" \"=&r\")]\n-  \"TARGET_32BIT\"\n+  \"TARGET_THUMB2\"\n   \"\n   {\n     enum rtx_code code = GET_CODE (XEXP (operands[0], 0));"}]}