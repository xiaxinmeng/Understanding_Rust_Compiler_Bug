{"sha": "3cf2a9e047d5621a834c8333313a5f7ef700956d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmMmE5ZTA0N2Q1NjIxYTgzNGM4MzMzMzEzYTVmN2VmNzAwOTU2ZA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-05-31T18:20:43Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-05-31T18:32:01Z"}, "message": "coroutines: Remove up some unused values.\n\nThe build_new_method_call allows us to inspect the\nfunction decl used.  In most cases, this is not used\nand we can just set the parm to NULL.\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (build_co_await): Remove unused\n\tvariable.\n\t(finish_co_await_expr): Likewise.\n\t(finish_co_yield_expr): Likewise; revise comment.", "tree": {"sha": "f19d9380e6d83eeb3e2e6b83e8ad5edcb3ed1ce3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f19d9380e6d83eeb3e2e6b83e8ad5edcb3ed1ce3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cf2a9e047d5621a834c8333313a5f7ef700956d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf2a9e047d5621a834c8333313a5f7ef700956d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cf2a9e047d5621a834c8333313a5f7ef700956d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cf2a9e047d5621a834c8333313a5f7ef700956d/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c25d0fa4d76cbc46078624d101ac019ff3df1142", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25d0fa4d76cbc46078624d101ac019ff3df1142", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25d0fa4d76cbc46078624d101ac019ff3df1142"}], "stats": {"total": 28, "additions": 13, "deletions": 15}, "files": [{"sha": "f3cf242b4f1b8c2d9550618a6a2e6eab16cfb97f", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cf2a9e047d5621a834c8333313a5f7ef700956d/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cf2a9e047d5621a834c8333313a5f7ef700956d/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=3cf2a9e047d5621a834c8333313a5f7ef700956d", "patch": "@@ -696,9 +696,8 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)\n   tree o;\n   if (MAYBE_CLASS_TYPE_P (TREE_TYPE (a)))\n     {\n-      tree overload = NULL_TREE;\n       o = build_new_op (loc, CO_AWAIT_EXPR, LOOKUP_NORMAL, a, NULL_TREE,\n-\t\t\tNULL_TREE, &overload, tf_warning_or_error);\n+\t\t\tNULL_TREE, NULL, tf_warning_or_error);\n       /* If no viable functions are found, o is a.  */\n       if (!o || o == error_mark_node)\n \to = a;\n@@ -873,19 +872,18 @@ finish_co_await_expr (location_t kw, tree expr)\n   if (at_meth)\n     {\n       /* try to build a = p.await_transform (e). */\n-      tree at_fn = NULL_TREE;\n       vec<tree, va_gc> *args = make_tree_vector_single (expr);\n       a = build_new_method_call (get_coroutine_promise_proxy (\n \t\t\t\t   current_function_decl),\n \t\t\t\t at_meth, &args, NULL_TREE, LOOKUP_NORMAL,\n-\t\t\t\t &at_fn, tf_warning_or_error);\n+\t\t\t\t NULL, tf_warning_or_error);\n \n       /* As I read the section.\n \t We saw an await_transform method, so it's mandatory that we replace\n \t expr with p.await_transform (expr), therefore if the method call fails\n \t (presumably, we don't have suitable arguments) then this part of the\n \t process fails.  */\n-      if (!at_fn || a == error_mark_node)\n+      if (a == error_mark_node)\n \treturn error_mark_node;\n     }\n \n@@ -945,19 +943,19 @@ finish_co_yield_expr (location_t kw, tree expr)\n   if (!y_meth || y_meth == error_mark_node)\n     return error_mark_node;\n \n-  tree yield_fn = NULL_TREE;\n+  /* [expr.yield] / 1\n+     Let e be the operand of the yield-expression and p be an lvalue naming\n+     the promise object of the enclosing coroutine, then the yield-expression\n+     is equivalent to the expression co_await p.yield_value(e).\n+     build p.yield_value(e):  */\n   vec<tree, va_gc> *args = make_tree_vector_single (expr);\n-  tree yield_call = build_new_method_call (\n-    get_coroutine_promise_proxy (current_function_decl), y_meth, &args,\n-    NULL_TREE, LOOKUP_NORMAL, &yield_fn, tf_warning_or_error);\n-\n-  if (!yield_fn || yield_call == error_mark_node)\n-    return error_mark_node;\n+  tree yield_call = build_new_method_call\n+    (get_coroutine_promise_proxy (current_function_decl), y_meth, &args,\n+     NULL_TREE, LOOKUP_NORMAL, NULL, tf_warning_or_error);\n \n-  /* So now we have the type of p.yield_value (e).\n-     Now we want to build co_await p.yield_value (e).\n+  /* Now build co_await p.yield_value (e).\n      Noting that for co_yield, there is no evaluation of any potential\n-     promise transform_await().  */\n+     promise transform_await(), so we call build_co_await directly.  */\n \n   tree op = build_co_await (kw, yield_call, CO_YIELD_SUSPEND_POINT);\n   if (op != error_mark_node)"}]}