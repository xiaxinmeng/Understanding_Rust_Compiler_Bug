{"sha": "0a9530a9d7cf389493916027f9980fcbf028b602", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE5NTMwYTlkN2NmMzg5NDkzOTE2MDI3Zjk5ODBmY2JmMDI4YjYwMg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-07-03T21:38:55Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-07-03T21:38:55Z"}, "message": "real.c (real_trunc, [...]): New functions to implement trunc, floor and ceil respectively.\n\n\n\t* real.c (real_trunc, real_floor, real_ceil): New functions\n\tto implement trunc, floor and ceil respectively.\n\t* real.h (real_trunc, real_floor, real_ceil): Prototype here.\n\t* builtins.c (integer_valued_real_p): New function to test if\n\ta floating point expression has an integer valued result.\n\t(fold_trunc_transparent_mathfn): Optimize foo(foo(x)) as\n\tfoo(x) where foo is an integer rounding function.  Similarly,\n\toptimize foo(bar(x)) as bar(x), and foo((double)(int)x) as\n\t(double)(int)x when both foo and bar are integer rounding\n\tfunctions and we don't need to honor errno.\n\t(fold_builtin_trunc, fold_builtin_floor, fold_builtin_ceil):\n\tNew functions to fold trunc, floor and ceil.\n\t(fold_builtin): Use fold_builtin_trunc to fold BUILT_IN_TRUNC*,\n\tfold_builtin_floor to fold BUILT_IN_FLOOR* and fold_builtin_ceil\n\tto fold BUILT_IN_CEIL*.\n\t* fold-const.c (tree_expr_nonnegative_p): Handle FLOAT_EXPR and\n\tthe remaining integer rounding functions.\n\n\t* gcc.dg/builtins-25.c: New testcase.\n\t* gcc.dg/builtins-26.c: New testcase.\n\nFrom-SVN: r68903", "tree": {"sha": "6f8671ee7d010f3f877a3ed92690c0d270f47544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f8671ee7d010f3f877a3ed92690c0d270f47544"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a9530a9d7cf389493916027f9980fcbf028b602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a9530a9d7cf389493916027f9980fcbf028b602", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a9530a9d7cf389493916027f9980fcbf028b602", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a9530a9d7cf389493916027f9980fcbf028b602/comments", "author": null, "committer": null, "parents": [{"sha": "7516d73631a96bcc28178f057bee4e713022b7d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7516d73631a96bcc28178f057bee4e713022b7d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7516d73631a96bcc28178f057bee4e713022b7d5"}], "stats": {"total": 592, "additions": 589, "deletions": 3}, "files": [{"sha": "2d9c8294307d13eda15b5ba62f93704ad59627ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -1,3 +1,23 @@\n+2003-07-03  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* real.c (real_trunc, real_floor, real_ceil): New functions\n+\tto implement trunc, floor and ceil respectively.\n+\t* real.h (real_trunc, real_floor, real_ceil): Prototype here.\n+\t* builtins.c (integer_valued_real_p): New function to test if\n+\ta floating point expression has an integer valued result.\n+\t(fold_trunc_transparent_mathfn): Optimize foo(foo(x)) as\n+\tfoo(x) where foo is an integer rounding function.  Similarly,\n+\toptimize foo(bar(x)) as bar(x), and foo((double)(int)x) as\n+\t(double)(int)x when both foo and bar are integer rounding\n+\tfunctions and we don't need to honor errno.\n+\t(fold_builtin_trunc, fold_builtin_floor, fold_builtin_ceil):\n+\tNew functions to fold trunc, floor and ceil.\n+\t(fold_builtin): Use fold_builtin_trunc to fold BUILT_IN_TRUNC*,\n+\tfold_builtin_floor to fold BUILT_IN_FLOOR* and fold_builtin_ceil\n+\tto fold BUILT_IN_CEIL*.\n+\t* fold-const.c (tree_expr_nonnegative_p): Handle FLOAT_EXPR and\n+\tthe remaining integer rounding functions.\n+\n 2003-07-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* config/sparc/sparc.c (function_arg_partial_nregs): Use"}, {"sha": "94712150ad1f1d78754eaca9faaddaa1385e073c", "filename": "gcc/builtins.c", "status": "modified", "additions": 203, "deletions": 3, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -149,12 +149,16 @@ static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_inf (tree, int);\n static tree fold_builtin_nan (tree, tree, int);\n static int validate_arglist (tree, ...);\n+static bool integer_valued_real_p (tree);\n static tree fold_trunc_transparent_mathfn (tree);\n static bool readonly_data_expr (tree);\n static rtx expand_builtin_fabs (tree, rtx, rtx);\n static rtx expand_builtin_cabs (tree, rtx);\n static void init_builtin_dconsts (void);\n static tree fold_builtin_cabs (tree, tree, tree);\n+static tree fold_builtin_trunc (tree);\n+static tree fold_builtin_floor (tree);\n+static tree fold_builtin_ceil (tree);\n \n /* Initialize mathematical constants for constant folding builtins.\n    These constants need to be given to at least 160 bits precision.  */\n@@ -5347,19 +5351,118 @@ fold_builtin_nan (tree arglist, tree type, int quiet)\n   return build_real (type, real);\n }\n \n-/* EXP is assumed to me builtin call where truncation can be propagated\n+/* Return true if the floating point expression T has an integer value.\n+   We also allow +Inf, -Inf and NaN to be considered integer values.  */\n+\n+static bool\n+integer_valued_real_p (tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case FLOAT_EXPR:\n+      return true;\n+\n+    case ABS_EXPR:\n+    case SAVE_EXPR:\n+    case NON_LVALUE_EXPR:\n+      return integer_valued_real_p (TREE_OPERAND (t, 0));\n+\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case BIND_EXPR:\n+      return integer_valued_real_p (TREE_OPERAND (t, 1));\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+      return integer_valued_real_p (TREE_OPERAND (t, 0))\n+\t     && integer_valued_real_p (TREE_OPERAND (t, 1));\n+\n+    case COND_EXPR:\n+      return integer_valued_real_p (TREE_OPERAND (t, 1))\n+\t     && integer_valued_real_p (TREE_OPERAND (t, 2));\n+\n+    case REAL_CST:\n+      if (! TREE_CONSTANT_OVERFLOW (t))\n+      {\n+        REAL_VALUE_TYPE c, cint;\n+\n+\tc = TREE_REAL_CST (t);\n+\treal_trunc (&cint, TYPE_MODE (TREE_TYPE (t)), &c);\n+\treturn real_identical (&c, &cint);\n+      }\n+\n+    case NOP_EXPR:\n+      {\n+\ttree type = TREE_TYPE (TREE_OPERAND (t, 0));\n+\tif (TREE_CODE (type) == INTEGER_TYPE)\n+\t  return true;\n+\tif (TREE_CODE (type) == REAL_TYPE)\n+\t  return integer_valued_real_p (TREE_OPERAND (t, 0));\n+\tbreak;\n+      }\n+\n+    case CALL_EXPR:\n+      switch (builtin_mathfn_code (t))\n+\t{\n+\tcase BUILT_IN_CEIL:\n+\tcase BUILT_IN_CEILF:\n+\tcase BUILT_IN_CEILL:\n+\tcase BUILT_IN_FLOOR:\n+\tcase BUILT_IN_FLOORF:\n+\tcase BUILT_IN_FLOORL:\n+\tcase BUILT_IN_NEARBYINT:\n+\tcase BUILT_IN_NEARBYINTF:\n+\tcase BUILT_IN_NEARBYINTL:\n+\tcase BUILT_IN_ROUND:\n+\tcase BUILT_IN_ROUNDF:\n+\tcase BUILT_IN_ROUNDL:\n+\tcase BUILT_IN_TRUNC:\n+\tcase BUILT_IN_TRUNCF:\n+\tcase BUILT_IN_TRUNCL:\n+\t  return true;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* EXP is assumed to be builtin call where truncation can be propagated\n    across (for instance floor((double)f) == (double)floorf (f).\n    Do the transformation.  */\n+\n static tree\n fold_trunc_transparent_mathfn (tree exp)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arg;\n+\n+  if (! validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n \n-  if (optimize && validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+  arg = TREE_VALUE (arglist);\n+  /* Integer rounding functions are idempotent.  */\n+  if (fcode == builtin_mathfn_code (arg))\n+    return arg;\n+\n+  /* If argument is already integer valued, and we don't need to worry\n+     about setting errno, there's no need to perform rounding.  */\n+  if (! flag_errno_math && integer_valued_real_p (arg))\n+    return arg;\n+\n+  if (optimize)\n     {\n-      tree arg0 = strip_float_extensions (TREE_VALUE (arglist));\n+      tree arg0 = strip_float_extensions (arg);\n       tree ftype = TREE_TYPE (exp);\n       tree newtype = TREE_TYPE (arg0);\n       tree decl;\n@@ -5461,6 +5564,97 @@ fold_builtin_cabs (tree fndecl, tree arglist, tree type)\n   return NULL_TREE;\n }\n \n+/* Fold function call to builtin trunc, truncf or truncl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_trunc (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg;\n+\n+  if (! validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  /* Optimize trunc of constant value.  */\n+  arg = TREE_VALUE (arglist);\n+  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+    {\n+      REAL_VALUE_TYPE r, x;\n+      tree type = TREE_TYPE (exp);\n+\n+      x = TREE_REAL_CST (arg);\n+      real_trunc (&r, TYPE_MODE (type), &x);\n+      return build_real (type, r);\n+    }\n+\n+  return fold_trunc_transparent_mathfn (exp);\n+}\n+\n+/* Fold function call to builtin floor, floorf or floorl.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_floor (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg;\n+\n+  if (! validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  /* Optimize floor of constant value.  */\n+  arg = TREE_VALUE (arglist);\n+  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+    {\n+      REAL_VALUE_TYPE x;\n+\n+      x = TREE_REAL_CST (arg);\n+      if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n+\t{\n+\t  tree type = TREE_TYPE (exp);\n+\t  REAL_VALUE_TYPE r;\n+\n+\t  real_floor (&r, TYPE_MODE (type), &x);\n+\t  return build_real (type, r);\n+\t}\n+    }\n+\n+  return fold_trunc_transparent_mathfn (exp);\n+}\n+\n+/* Fold function call to builtin ceil, ceilf or ceill.  Return\n+   NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_ceil (tree exp)\n+{\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg;\n+\n+  if (! validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  /* Optimize ceil of constant value.  */\n+  arg = TREE_VALUE (arglist);\n+  if (TREE_CODE (arg) == REAL_CST && ! TREE_CONSTANT_OVERFLOW (arg))\n+    {\n+      REAL_VALUE_TYPE x;\n+\n+      x = TREE_REAL_CST (arg);\n+      if (! REAL_VALUE_ISNAN (x) || ! flag_errno_math)\n+\t{\n+\t  tree type = TREE_TYPE (exp);\n+\t  REAL_VALUE_TYPE r;\n+\n+\t  real_ceil (&r, TYPE_MODE (type), &x);\n+\t  return build_real (type, r);\n+\t}\n+    }\n+\n+  return fold_trunc_transparent_mathfn (exp);\n+}\n+\n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n@@ -5918,12 +6112,18 @@ fold_builtin (tree exp)\n     case BUILT_IN_FLOOR:\n     case BUILT_IN_FLOORF:\n     case BUILT_IN_FLOORL:\n+      return fold_builtin_floor (exp);\n+\n     case BUILT_IN_CEIL:\n     case BUILT_IN_CEILF:\n     case BUILT_IN_CEILL:\n+      return fold_builtin_ceil (exp);\n+\n     case BUILT_IN_TRUNC:\n     case BUILT_IN_TRUNCF:\n     case BUILT_IN_TRUNCL:\n+      return fold_builtin_trunc (exp);\n+\n     case BUILT_IN_ROUND:\n     case BUILT_IN_ROUNDF:\n     case BUILT_IN_ROUNDL:"}, {"sha": "0524e1dc16e2bb4f393e11de2f8248b0966a0473", "filename": "gcc/fold-const.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -8105,6 +8105,8 @@ tree_expr_nonnegative_p (tree t)\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n     case NON_LVALUE_EXPR:\n       return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+    case FLOAT_EXPR:\n+      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n     case RTL_EXPR:\n       return rtl_expr_nonnegative_p (RTL_EXPR_RTL (t));\n \n@@ -8141,6 +8143,15 @@ tree_expr_nonnegative_p (tree t)\n \t      case BUILT_IN_FLOOR:\n \t      case BUILT_IN_FLOORF:\n \t      case BUILT_IN_FLOORL:\n+\t      case BUILT_IN_NEARBYINT:\n+\t      case BUILT_IN_NEARBYINTF:\n+\t      case BUILT_IN_NEARBYINTL:\n+\t      case BUILT_IN_ROUND:\n+\t      case BUILT_IN_ROUNDF:\n+\t      case BUILT_IN_ROUNDL:\n+\t      case BUILT_IN_TRUNC:\n+\t      case BUILT_IN_TRUNCF:\n+\t      case BUILT_IN_TRUNCL:\n \t\treturn tree_expr_nonnegative_p (TREE_VALUE (arglist));\n \n \t      case BUILT_IN_POW:"}, {"sha": "6bc4d52fabc7380fff6cda548d75006ecff972e6", "filename": "gcc/real.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -4748,3 +4748,49 @@ real_powi (r, mode, x, n)\n   return inexact;\n }\n \n+/* Round X to the nearest integer not larger in absolute value, i.e.\n+   towards zero, placing the result in R in mode MODE.  */\n+\n+void\n+real_trunc (r, mode, x)\n+     REAL_VALUE_TYPE *r;\n+     enum machine_mode mode;\n+     const REAL_VALUE_TYPE *x;\n+{\n+  do_fix_trunc (r, x);\n+  if (mode != VOIDmode)\n+    real_convert (r, mode, r);\n+}\n+\n+/* Round X to the largest integer not greater in value, i.e. round\n+   down, placing the result in R in mode MODE.  */\n+\n+void\n+real_floor (r, mode, x)\n+     REAL_VALUE_TYPE *r;\n+     enum machine_mode mode;\n+     const REAL_VALUE_TYPE *x;\n+{\n+  do_fix_trunc (r, x);\n+  if (! real_identical (r, x) && r->sign)\n+    do_add (r, r, &dconstm1, 0);\n+  if (mode != VOIDmode)\n+    real_convert (r, mode, r);\n+}\n+\n+/* Round X to the smallest integer not less then argument, i.e. round\n+   up, placing the result in R in mode MODE.  */\n+\n+void\n+real_ceil (r, mode, x)\n+     REAL_VALUE_TYPE *r;\n+     enum machine_mode mode;\n+     const REAL_VALUE_TYPE *x;\n+{\n+  do_fix_trunc (r, x);\n+  if (! real_identical (r, x) && ! r->sign)\n+    do_add (r, r, &dconst1, 0);\n+  if (mode != VOIDmode)\n+    real_convert (r, mode, r);\n+}\n+"}, {"sha": "fcd7ae7f15593e798440f4a112132d585be02392", "filename": "gcc/real.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -375,4 +375,15 @@ extern bool real_powi\t\t\tPARAMS ((REAL_VALUE_TYPE *,\n \t\t\t\t\t\t const REAL_VALUE_TYPE *,\n \t\t\t\t\t\t HOST_WIDE_INT));\n \n+/* Standard round to integer value functions.  */\n+extern void real_trunc\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t enum machine_mode,\n+\t\t\t\t const REAL_VALUE_TYPE *));\n+extern void real_floor\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t enum machine_mode,\n+\t\t\t\t const REAL_VALUE_TYPE *));\n+extern void real_ceil\tPARAMS ((REAL_VALUE_TYPE *,\n+\t\t\t\t enum machine_mode,\n+\t\t\t\t const REAL_VALUE_TYPE *));\n+\n #endif /* ! GCC_REAL_H */"}, {"sha": "b2db902de721baa020840ac03ed302355a258dd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -1,3 +1,8 @@\n+2003-07-03  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-25.c: New testcase.\n+\t* gcc.dg/builtins-26.c: New testcase.\n+\n 2003-07-03  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.dg/compat/vector-defs.h: New file."}, {"sha": "495056615cab43d0e97aefc7532efc10451c97bd", "filename": "gcc/testsuite/gcc.dg/builtins-25.c", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-25.c?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -0,0 +1,188 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that constant folding of built-in math functions doesn't\n+   break anything and produces the expected results.\n+\n+   Written by Roger Sayle, 28th June 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void link_error(void);\n+\n+extern double trunc(double);\n+extern double floor(double);\n+extern double ceil(double);\n+\n+extern float truncf(float);\n+extern float floorf(float);\n+extern float ceilf(float);\n+\n+extern long double truncl(long double);\n+extern long double floorl(long double);\n+extern long double ceill(long double);\n+\n+void test()\n+{\n+  if (trunc (0.0) != 0.0)\n+    link_error ();\n+  if (floor (0.0) != 0.0)\n+    link_error ();\n+  if (ceil (0.0) != 0.0)\n+    link_error ();\n+\n+  if (trunc (6.0) != 6.0)\n+    link_error ();\n+  if (floor (6.0) != 6.0)\n+    link_error ();\n+  if (ceil (6.0) != 6.0)\n+    link_error ();\n+\n+  if (trunc (-8.0) != -8.0)\n+    link_error ();\n+  if (floor (-8.0) != -8.0)\n+    link_error ();\n+  if (ceil (-8.0) != -8.0)\n+    link_error ();\n+\n+  if (trunc (3.2) != 3.0)\n+    link_error ();\n+  if (floor (3.2) != 3.0)\n+    link_error ();\n+  if (ceil (3.2) != 4.0)\n+    link_error ();\n+\n+  if (trunc (-2.8) != -2.0)\n+    link_error ();\n+  if (floor (-2.8) != -3.0)\n+    link_error ();\n+  if (ceil (-2.8) != -2.0)\n+    link_error ();\n+\n+  if (trunc (0.01) != 0.0)\n+    link_error ();\n+  if (floor (0.01) != 0.0)\n+    link_error ();\n+  if (ceil (0.01) != 1.0)\n+    link_error ();\n+\n+  if (trunc (-0.7) != 0.0)\n+    link_error ();\n+  if (floor (-0.7) != -1.0)\n+    link_error ();\n+  if (ceil (-0.7) != 0.0)\n+    link_error ();\n+}\n+\n+void testf()\n+{\n+  if (truncf (0.0f) != 0.0f)\n+    link_error ();\n+  if (floorf (0.0f) != 0.0f)\n+    link_error ();\n+  if (ceilf (0.0f) != 0.0f)\n+    link_error ();\n+\n+  if (truncf (6.0f) != 6.0f)\n+    link_error ();\n+  if (floorf (6.0f) != 6.0f)\n+    link_error ();\n+  if (ceilf (6.0f) != 6.0f)\n+    link_error ();\n+\n+  if (truncf (-8.0f) != -8.0f)\n+    link_error ();\n+  if (floorf (-8.0f) != -8.0f)\n+    link_error ();\n+  if (ceilf (-8.0f) != -8.0f)\n+    link_error ();\n+\n+  if (truncf (3.2f) != 3.0f)\n+    link_error ();\n+  if (floorf (3.2f) != 3.0f)\n+    link_error ();\n+  if (ceilf (3.2f) != 4.0f)\n+    link_error ();\n+\n+  if (truncf (-2.8f) != -2.0f)\n+    link_error ();\n+  if (floorf (-2.8f) != -3.0f)\n+    link_error ();\n+  if (ceilf (-2.8f) != -2.0f)\n+    link_error ();\n+\n+  if (truncf (0.01f) != 0.0f)\n+    link_error ();\n+  if (floorf (0.01f) != 0.0f)\n+    link_error ();\n+  if (ceilf (0.01f) != 1.0f)\n+    link_error ();\n+\n+  if (truncf (-0.7f) != 0.0f)\n+    link_error ();\n+  if (floorf (-0.7f) != -1.0f)\n+    link_error ();\n+  if (ceilf (-0.7f) != 0.0f)\n+    link_error ();\n+}\n+\n+void testl()\n+{\n+  if (truncl (0.0l) != 0.0l)\n+    link_error ();\n+  if (floorl (0.0l) != 0.0l)\n+    link_error ();\n+  if (ceill (0.0l) != 0.0l)\n+    link_error ();\n+\n+  if (truncl (6.0l) != 6.0l)\n+    link_error ();\n+  if (floorl (6.0l) != 6.0l)\n+    link_error ();\n+  if (ceill (6.0l) != 6.0l)\n+    link_error ();\n+\n+  if (truncl (-8.0l) != -8.0l)\n+    link_error ();\n+  if (floorl (-8.0l) != -8.0l)\n+    link_error ();\n+  if (ceill (-8.0l) != -8.0l)\n+    link_error ();\n+\n+  if (truncl (3.2l) != 3.0l)\n+    link_error ();\n+  if (floorl (3.2l) != 3.0l)\n+    link_error ();\n+  if (ceill (3.2l) != 4.0l)\n+    link_error ();\n+\n+  if (truncl (-2.8l) != -2.0l)\n+    link_error ();\n+  if (floorl (-2.8l) != -3.0l)\n+    link_error ();\n+  if (ceill (-2.8l) != -2.0l)\n+    link_error ();\n+\n+  if (truncl (0.01l) != 0.0l)\n+    link_error ();\n+  if (floorl (0.01l) != 0.0l)\n+    link_error ();\n+  if (ceill (0.01l) != 1.0l)\n+    link_error ();\n+\n+  if (truncl (-0.7l) != 0.0l)\n+    link_error ();\n+  if (floorl (-0.7l) != -1.0l)\n+    link_error ();\n+  if (ceill (-0.7l) != 0.0l)\n+    link_error ();\n+}\n+\n+int main()\n+{\n+  test ();\n+  testf ();\n+  testl ();\n+  return 0;\n+}\n+"}, {"sha": "c4d03cd7da6618b4413f5608f8bbe51c69559c24", "filename": "gcc/testsuite/gcc.dg/builtins-26.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a9530a9d7cf389493916027f9980fcbf028b602/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-26.c?ref=0a9530a9d7cf389493916027f9980fcbf028b602", "patch": "@@ -0,0 +1,105 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that constant folding of built-in math functions doesn't\n+   break anything and produces the expected results.\n+\n+   Written by Roger Sayle, 28th June 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern void link_error(void);\n+\n+extern double trunc(double);\n+extern double floor(double);\n+extern double ceil(double);\n+\n+extern float truncf(float);\n+extern float floorf(float);\n+extern float ceilf(float);\n+\n+extern long double truncl(long double);\n+extern long double floorl(long double);\n+extern long double ceill(long double);\n+\n+void test(double x)\n+{\n+  if (trunc (trunc (x)) != trunc (x))\n+    link_error ();\n+  if (trunc (floor (x)) != floor (x))\n+    link_error ();\n+  if (trunc (ceil (x)) != ceil (x))\n+    link_error ();\n+\n+  if (floor (trunc (x)) != trunc (x))\n+    link_error ();\n+  if (floor (floor (x)) != floor (x))\n+    link_error ();\n+  if (floor (ceil (x)) != ceil (x))\n+    link_error ();\n+\n+  if (ceil (trunc (x)) != trunc (x))\n+    link_error ();\n+  if (ceil (floor (x)) != floor (x))\n+    link_error ();\n+  if (ceil (ceil (x)) != ceil (x))\n+    link_error ();\n+}\n+\n+void testf(float x)\n+{\n+  if (truncf (truncf (x)) != truncf (x))\n+    link_error ();\n+  if (truncf (floorf (x)) != floorf (x))\n+    link_error ();\n+  if (truncf (ceilf (x)) != ceilf (x))\n+    link_error ();\n+\n+  if (floorf (truncf (x)) != truncf (x))\n+    link_error ();\n+  if (floorf (floorf (x)) != floorf (x))\n+    link_error ();\n+  if (floorf (ceilf (x)) != ceilf (x))\n+    link_error ();\n+\n+  if (ceilf (truncf (x)) != truncf (x))\n+    link_error ();\n+  if (ceilf (floorf (x)) != floorf (x))\n+    link_error ();\n+  if (ceilf (ceilf (x)) != ceilf (x))\n+    link_error ();\n+}\n+\n+void testl(long double x)\n+{\n+  if (truncl (truncl (x)) != truncl (x))\n+    link_error ();\n+  if (truncl (floorl (x)) != floorl (x))\n+    link_error ();\n+  if (truncl (ceill (x)) != ceill (x))\n+    link_error ();\n+\n+  if (floorl (truncl (x)) != truncl (x))\n+    link_error ();\n+  if (floorl (floorl (x)) != floorl (x))\n+    link_error ();\n+  if (floorl (ceill (x)) != ceill (x))\n+    link_error ();\n+\n+  if (ceill (truncl (x)) != truncl (x))\n+    link_error ();\n+  if (ceill (floorl (x)) != floorl (x))\n+    link_error ();\n+  if (ceill (ceill (x)) != ceill (x))\n+    link_error ();\n+}\n+\n+\n+int main()\n+{\n+  test (3.2);\n+  testf (3.2f);\n+  testl (3.2l);\n+  return 0;\n+}\n+"}]}