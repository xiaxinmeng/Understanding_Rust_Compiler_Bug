{"sha": "9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJhYjZjOTAzNTZiZDRmZmUzZGI1ZDg1MWZjN2RiYjY0YTE3NDdmNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-12T20:46:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-12T20:46:28Z"}, "message": "class.c (vcall_offset_data_s): Add last_init and fns.\n\n\t* class.c (vcall_offset_data_s): Add last_init and fns.\n\t(overrides): Rename to same_signature_p.\n\t(dfs_find_final_overrider): Adjust accordingly.\n\t(mark_overriders): Likewise.\n\t(warn_hidden): Likewise.\n\t(build_vtbl_initializer): Reorganize machinery for building things\n\tat negative offsets.\n\t(build_vcall_and_vbase_vtbl_entries): Likewise.\n\t(build_vbase_offset_vtbl_entries): Likewise.\n\t(dfs_build_vcall_offset_vtbl_entries): Correct order of vcall\n\toffset entries.  Do not create two entries for functions with the\n\tsame signature.\n\t(build_vcall_offset_vtbl_entries): Initialize vod->fns.\n\t(build_rtti_vtbl_entries): Reorganize machinery for building things\n\tat negative offsets.\n\nFrom-SVN: r34503", "tree": {"sha": "36f07f4544366a1f7930292cebeee4893b84379f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36f07f4544366a1f7930292cebeee4893b84379f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5/comments", "author": null, "committer": null, "parents": [{"sha": "f6bf7de2b9e0bd59913451e1fb33acf1ddaead19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6bf7de2b9e0bd59913451e1fb33acf1ddaead19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6bf7de2b9e0bd59913451e1fb33acf1ddaead19"}], "stats": {"total": 192, "additions": 106, "deletions": 86}, "files": [{"sha": "5920a04ffd3f479138aadefdc9da82acdbc1c065", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5", "patch": "@@ -1,5 +1,21 @@\n 2000-06-12  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (vcall_offset_data_s): Add last_init and fns.\n+\t(overrides): Rename to same_signature_p.\n+\t(dfs_find_final_overrider): Adjust accordingly.\n+\t(mark_overriders): Likewise.\n+\t(warn_hidden): Likewise.\n+\t(build_vtbl_initializer): Reorganize machinery for building things\n+\tat negative offsets.\n+\t(build_vcall_and_vbase_vtbl_entries): Likewise.\n+\t(build_vbase_offset_vtbl_entries): Likewise.\n+\t(dfs_build_vcall_offset_vtbl_entries): Correct order of vcall\n+\toffset entries.  Do not create two entries for functions with the\n+\tsame signature.\n+\t(build_vcall_offset_vtbl_entries): Initialize vod->fns.\n+\t(build_rtti_vtbl_entries): Reorganize machinery for building things\n+\tat negative offsets.\n+\n \t* optimize.c (expand_call_inline): Don't recurse into the code\n \tused to initialize the parameters more than once.\n "}, {"sha": "4d9d3991e32deb218f8265bc64588c49e5427dac", "filename": "gcc/cp/class.c", "status": "modified", "additions": 90, "deletions": 86, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9bab6c90356bd4ffe3db5d851fc7dbb64a1747f5", "patch": "@@ -66,11 +66,17 @@ typedef struct vcall_offset_data_s\n {\n   /* The binfo for the most-derived type.  */\n   tree derived;\n+  /* The negative-index vtable initializers built up so far.  These\n+     are in order from least negative index to most negative index.  */\n+  tree inits;\n+  /* The last (i.e., most negative entry in INITS.  */\n+  tree* last_init;\n   /* The binfo for the virtual base for which we're building\n      initializers.  */\n   tree vbase;\n-  /* The vcall offset initializers built up so far.  */\n-  tree inits;\n+  /* The functions in vbase for which we have already provided vcall\n+     offsets.  */\n+  varray_type fns;\n   /* The vtable index of the next vcall or vbase offset.  */\n   tree index;\n   /* Nonzero if we are building the initializer for the primary\n@@ -107,7 +113,7 @@ static void delete_duplicate_fields PARAMS ((tree));\n static void finish_struct_bits PARAMS ((tree));\n static int alter_access PARAMS ((tree, tree, tree));\n static void handle_using_decl PARAMS ((tree, tree));\n-static int overrides PARAMS ((tree, tree));\n+static int same_signature_p PARAMS ((tree, tree));\n static int strictly_overrides PARAMS ((tree, tree));\n static void mark_overriders PARAMS ((tree, tree));\n static void check_for_override PARAMS ((tree, tree));\n@@ -174,7 +180,7 @@ static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n static void layout_empty_base PARAMS ((tree, tree, varray_type));\n static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static void set_vindex PARAMS ((tree, tree, int *));\n-static tree build_rtti_vtbl_entries PARAMS ((tree, tree));\n+static void build_rtti_vtbl_entries PARAMS ((tree, tree, vcall_offset_data *));\n static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n \t\t\t\t\t\t\tvcall_offset_data *));\n static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n@@ -2383,11 +2389,11 @@ layout_vtable_decl (binfo, n)\n     }\n }\n \n-/* True if we should override the given BASE_FNDECL with the given\n-   FNDECL.  */\n+/* True iff FNDECL and BASE_FNDECL (both non-static member functions)\n+   have the same signature.  */\n \n static int\n-overrides (fndecl, base_fndecl)\n+same_signature_p (fndecl, base_fndecl)\n      tree fndecl, base_fndecl;\n {\n   /* One destructor overrides another if they are the same kind of\n@@ -2455,7 +2461,8 @@ dfs_find_final_overrider (binfo, data)\n \t  for (method = TYPE_METHODS (BINFO_TYPE (TREE_VALUE (path)));\n \t       method;\n \t       method = TREE_CHAIN (method))\n-\t    if (DECL_VIRTUAL_P (method) && overrides (method, ffod->fn))\n+\t    if (DECL_VIRTUAL_P (method) \n+\t\t&& same_signature_p (method, ffod->fn))\n \t      break;\n \n \t  if (method)\n@@ -2826,10 +2833,8 @@ mark_overriders (fndecl, base_fndecls)\n      tree fndecl, base_fndecls;\n {\n   for (; base_fndecls; base_fndecls = TREE_CHAIN (base_fndecls))\n-    {\n-      if (overrides (fndecl, TREE_VALUE (base_fndecls)))\n-\tTREE_PURPOSE (base_fndecls) = fndecl;\n-    }\n+    if (same_signature_p (fndecl, TREE_VALUE (base_fndecls)))\n+      TREE_PURPOSE (base_fndecls) = fndecl;\n }\n \n /* If this declaration supersedes the declaration of\n@@ -2955,15 +2960,13 @@ warn_hidden (t)\n       /* Now give a warning for all base functions without overriders,\n \t as they are hidden.  */\n       for (; base_fndecls; base_fndecls = TREE_CHAIN (base_fndecls))\n-\t{\n-\t  if (! overrides (TREE_PURPOSE (base_fndecls),\n-\t\t\t   TREE_VALUE (base_fndecls)))\n-\t    {\n-\t      /* Here we know it is a hider, and no overrider exists.  */\n-\t      cp_warning_at (\"`%D' was hidden\", TREE_VALUE (base_fndecls));\n-\t      cp_warning_at (\"  by `%D'\", TREE_PURPOSE (base_fndecls));\n-\t    }\n-\t}\n+\tif (!same_signature_p (TREE_PURPOSE (base_fndecls),\n+\t\t\t       TREE_VALUE (base_fndecls)))\n+\t  {\n+\t    /* Here we know it is a hider, and no overrider exists.  */\n+\t    cp_warning_at (\"`%D' was hidden\", TREE_VALUE (base_fndecls));\n+\t    cp_warning_at (\"  by `%D'\", TREE_PURPOSE (base_fndecls));\n+\t  }\n     }\n }\n \n@@ -6938,33 +6941,32 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n      int *non_fn_entries_p;\n {\n   tree v;\n-  tree inits;\n-  tree vfun_inits;\n+   tree vfun_inits;\n   tree vbase;\n   vcall_offset_data vod;\n \n   /* Initialize those parts of VOD that matter.  */\n   vod.derived = t;\n   vod.inits = NULL_TREE;\n+  vod.last_init = &vod.inits;\n   vod.primary_p = (binfo == TYPE_BINFO (t));\n   /* The first vbase or vcall offset is at index -3 in the vtable.  */\n   vod.index = build_int_2 (-3, -1);\n \n+  /* Add entries to the vtable for RTTI.  */\n+  build_rtti_vtbl_entries (binfo, rtti_binfo, &vod);\n+\n   /* Add the vcall and vbase offset entries.  */\n   build_vcall_and_vbase_vtbl_entries (binfo, &vod);\n-  inits = vod.inits;\n-  /* Clear BINFO_VTABLE_PAATH_MARKED; it's set by\n+   /* Clear BINFO_VTABLE_PAATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n   for (vbase = CLASSTYPE_VBASECLASSES (t); \n        vbase; \n        vbase = TREE_CHAIN (vbase))\n     CLEAR_BINFO_VTABLE_PATH_MARKED (TREE_VALUE (vbase));\n \n-  /* Add entries to the vtable for RTTI.  */\n-  inits = chainon (inits, build_rtti_vtbl_entries (binfo, rtti_binfo));\n-\n   if (non_fn_entries_p)\n-    *non_fn_entries_p = list_length (inits);\n+    *non_fn_entries_p = list_length (vod.inits);\n \n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n@@ -7005,9 +7007,11 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n      order; straighten them out now.  */\n   vfun_inits = nreverse (vfun_inits);\n   \n-  /* The complete initializer is the INITS, followed by the\n-     VFUN_INITS.  */\n-  return chainon (inits, vfun_inits);\n+  /* The negative offset initializers are also in reverse order.  */\n+  vod.inits = nreverse (vod.inits);\n+\n+  /* Chain the two together.  */\n+  return chainon (vod.inits, vfun_inits);\n }\n \n /* Sets vod->inits to be the initializers for the vbase and vcall\n@@ -7019,14 +7023,9 @@ build_vcall_and_vbase_vtbl_entries (binfo, vod)\n      vcall_offset_data *vod;\n {\n   tree b;\n-  tree inits;\n \n   /* If this is a derived class, we must first create entries\n-     corresponding to the base class.  These entries must go closer to\n-     the vptr, so we save them up and add them to the end of the list\n-     later.  */\n-  inits = vod->inits;\n-  vod->inits = NULL_TREE;\n+     corresponding to the primary base class.  */\n   b = BINFO_PRIMARY_BINFO (binfo);\n   if (b)\n     build_vcall_and_vbase_vtbl_entries (b, vod);\n@@ -7035,8 +7034,6 @@ build_vcall_and_vbase_vtbl_entries (binfo, vod)\n   build_vbase_offset_vtbl_entries (binfo, vod);\n   /* Add the vcall entries for this base.  */\n   build_vcall_offset_vtbl_entries (binfo, vod);\n-\n-  vod->inits = chainon (vod->inits, inits);\n }\n \n /* Returns the initializers for the vbase offset entries in the vtable\n@@ -7116,11 +7113,12 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \t we are walking in inheritance graph order so these end up in\n \t the right order.  */\n       delta = size_diffop (BINFO_OFFSET (b), BINFO_OFFSET (binfo));\n-      vod->inits = tree_cons (NULL_TREE, \n-\t\t\t      fold (build1 (NOP_EXPR, \n-\t\t\t\t\t    vtable_entry_type,\n-\t\t\t\t\t    delta)),\n-\t\t\t      vod->inits);\n+      *vod->last_init \n+\t= build_tree_list (NULL_TREE,\n+\t\t\t   fold (build1 (NOP_EXPR, \n+\t\t\t\t\t vtable_entry_type,\n+\t\t\t\t\t delta)));\n+      vod->last_init = &TREE_CHAIN (*vod->last_init);\n     }\n }\n \n@@ -7162,22 +7160,48 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n       }\n \n   /* Make entries for the rest of the virtuals.  */\n-  while (base_virtuals)\n+  for (; base_virtuals;\n+       derived_virtuals = TREE_CHAIN (derived_virtuals),\n+\t base_virtuals = TREE_CHAIN (base_virtuals))\n     {\n       /* Figure out what function we're looking at.  */\n       tree fn = TREE_VALUE (derived_virtuals);\n-      tree base = DECL_CONTEXT (fn);\n+      tree base;\n+      tree base_binfo;\n+      size_t i;\n+\n+      /* If there is already an entry for a function with the same\n+\t signature as FN, then we do not need a second vcall offset.\n+\t Check the list of functions already present in the derived\n+\t class vtable.  */\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (vod->fns); ++i) \n+\t{\n+\t  tree derived_entry;\n+\n+\t  derived_entry = VARRAY_TREE (vod->fns, i);\n+\t  if (same_signature_p (TREE_VALUE (derived_entry), fn))\n+\t    {\n+\t      BV_VCALL_INDEX (derived_virtuals) \n+\t\t= BV_VCALL_INDEX (derived_entry);\n+\t      break;\n+\t    }\n+\t}\n+      if (i != VARRAY_ACTIVE_SIZE (vod->fns))\n+\tcontinue;\n+\n       /* The FN comes from BASE.  So, we must caculate the adjustment\n \t from the virtual base that derived from BINFO to BASE.  */\n-      tree base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n+      base = DECL_CONTEXT (fn);\n+      base_binfo = get_binfo (base, vod->derived, /*protect=*/0);\n \n       /* Compute the vcall offset.  */\n-      binfo_inits\n-\t= tree_cons (NULL_TREE,\n-\t\t     fold (build1 (NOP_EXPR, vtable_entry_type,\n-\t\t\t\t   size_diffop (BINFO_OFFSET (base_binfo),\n-\t\t\t\t\t\tBINFO_OFFSET (vod->vbase)))),\n-\t\t     binfo_inits);\n+      *vod->last_init \n+\t= (build_tree_list \n+\t   (NULL_TREE,\n+\t    fold (build1 (NOP_EXPR, vtable_entry_type,\n+\t\t\t  size_diffop (BINFO_OFFSET (base_binfo),\n+\t\t\t\t       BINFO_OFFSET (vod->vbase))))));\n+      vod->last_init = &TREE_CHAIN (*vod->last_init);\n \n       /* If there is already a vcall index, then we are processing a\n \t construction vtable.  The index should be the same as it was\n@@ -7197,24 +7221,8 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n       vod->index = fold (build (MINUS_EXPR, integer_type_node,\n \t\t\t\tvod->index, integer_one_node));\n \n-      /* Go to the next entries in the list.  */\n-      derived_virtuals = TREE_CHAIN (derived_virtuals);\n-      base_virtuals = TREE_CHAIN (base_virtuals);\n-    }\n-\n-  /* The offests are built up in reverse order, so we straighten them\n-     here.  We simultaneously add them to VOD->INITS; we're walking\n-     the bases in inheritance graph order, and the initializers are\n-     supposed to appear in reverse inheritance order, so that's\n-     correct.  */\n-  while (binfo_inits)\n-    {\n-      tree next;\n-\n-      next = TREE_CHAIN (binfo_inits);\n-      TREE_CHAIN (binfo_inits) = vod->inits;\n-      vod->inits = binfo_inits;\n-      binfo_inits = next;\n+      /* Keep track of this function.  */\n+      VARRAY_PUSH_TREE (vod->fns, derived_virtuals);\n     }\n \n   return NULL_TREE;\n@@ -7229,8 +7237,6 @@ build_vcall_offset_vtbl_entries (binfo, vod)\n      tree binfo;\n      vcall_offset_data *vod;\n {\n-  tree inits;\n-\n   /* Under the old ABI, the adjustments to the `this' pointer were made\n      elsewhere.  */\n   if (!vcall_offsets_in_vtable_p ())\n@@ -7263,40 +7269,38 @@ build_vcall_offset_vtbl_entries (binfo, vod)\n      appear in the same order as in the base; but the bases themselves\n      appear in reverse depth-first, left-to-right order.  */\n   vod->vbase = binfo;\n-  inits = vod->inits;\n-  vod->inits = NULL_TREE;\n+  VARRAY_TREE_INIT (vod->fns, 32, \"fns\");\n   dfs_walk_real (binfo,\n \t\t dfs_build_vcall_offset_vtbl_entries,\n \t\t NULL,\n \t\t dfs_skip_vbases,\n \t\t vod);\n-  vod->inits = chainon (vod->inits, inits);\n+  VARRAY_FREE (vod->fns);\n }\n \n /* Return vtbl initializers for the RTTI entries coresponding to the\n    BINFO's vtable.  The RTTI entries should indicate the object given\n    by RTTI_BINFO.  */\n \n-static tree\n-build_rtti_vtbl_entries (binfo, rtti_binfo)\n+static void\n+build_rtti_vtbl_entries (binfo, rtti_binfo, vod)\n      tree binfo;\n      tree rtti_binfo;\n+     vcall_offset_data *vod;\n {\n   tree b;\n   tree t;\n   tree basetype;\n   tree offset;\n   tree decl;\n   tree init;\n-  tree inits;\n \n   basetype = BINFO_TYPE (binfo);\n-  inits = NULL_TREE;\n   t = BINFO_TYPE (rtti_binfo);\n \n   /* For a COM object there is no RTTI entry.  */\n   if (CLASSTYPE_COM_INTERFACE (basetype))\n-    return inits;\n+    return;\n \n   /* To find the complete object, we will first convert to our most\n      primary base, and then add the offset in the vtbl to that value.  */\n@@ -7340,7 +7344,8 @@ build_rtti_vtbl_entries (binfo, rtti_binfo)\n       TREE_CONSTANT (init) = 1;\n       init = build_vtable_entry (offset, integer_zero_node, init);\n     }\n-  inits = tree_cons (NULL_TREE, init, inits);\n+  *vod->last_init = build_tree_list (NULL_TREE, init);\n+  vod->last_init = &TREE_CHAIN (*vod->last_init);\n \n   /* Add the offset-to-top entry.  It comes earlier in the vtable that\n      the the typeinfo entry.  */\n@@ -7350,10 +7355,9 @@ build_rtti_vtbl_entries (binfo, rtti_binfo)\n \t we can put it in the vtable.  */\n       init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n       TREE_CONSTANT (init) = 1;\n-      inits = tree_cons (NULL_TREE, init, inits);\n+      *vod->last_init = build_tree_list (NULL_TREE, init);\n+      vod->last_init = &TREE_CHAIN (*vod->last_init);\n     }\n-\n-  return inits;\n }\n \n /* Build an entry in the virtual function table.  DELTA is the offset"}]}