{"sha": "10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxMTZlYzFjMTQ3YTc2NTIyY2FmYmE2YjZhNWI0ZWQxY2IzN2I3Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-14T14:55:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-14T14:55:12Z"}, "message": "Pass the data vector mode to get_mask_mode\n\nThis patch passes the data vector mode to get_mask_mode, rather than its\nsize and nunits.  This is a bit simpler and allows targets to distinguish\nbetween modes that happen to have the same size and number of elements.\n\n2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (get_mask_mode): Take a vector mode itself as argument,\n\tinstead of properties about the vector mode.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_get_mask_mode): Update to reflect new\n\tget_mode_mask interface.\n\t* targhooks.c (default_get_mask_mode): Likewise.  Use\n\trelated_int_vector_mode.\n\t* optabs-query.c (can_vec_mask_load_store_p): Update call\n\tto get_mask_mode.\n\t* tree-vect-stmts.c (check_load_store_masking): Likewise, checking\n\tfirst that the original mode really is a vector.\n\t* tree.c (build_truth_vector_type_for): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_get_mask_mode): Update for new\n\tget_mode_mask interface.\n\t(aarch64_expand_sve_vcond): Update call accordingly.\n\t* config/gcn/gcn.c (gcn_vectorize_get_mask_mode): Update for new\n\tget_mode_mask interface.\n\t* config/i386/i386.c (ix86_get_mask_mode): Likewise.\n\nFrom-SVN: r278233", "tree": {"sha": "776dc1f9e2372ad4300b7120c178f4dfc3c7121a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/776dc1f9e2372ad4300b7120c178f4dfc3c7121a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8738f4e9686203451fd11f05b268b8a31b95ebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8738f4e9686203451fd11f05b268b8a31b95ebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8738f4e9686203451fd11f05b268b8a31b95ebd"}], "stats": {"total": 122, "additions": 62, "deletions": 60}, "files": [{"sha": "48f5f37ee0de6d6dada89e414a72e5140b0ef08d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -1,3 +1,24 @@\n+2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (get_mask_mode): Take a vector mode itself as argument,\n+\tinstead of properties about the vector mode.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_get_mask_mode): Update to reflect new\n+\tget_mode_mask interface.\n+\t* targhooks.c (default_get_mask_mode): Likewise.  Use\n+\trelated_int_vector_mode.\n+\t* optabs-query.c (can_vec_mask_load_store_p): Update call\n+\tto get_mask_mode.\n+\t* tree-vect-stmts.c (check_load_store_masking): Likewise, checking\n+\tfirst that the original mode really is a vector.\n+\t* tree.c (build_truth_vector_type_for): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_get_mask_mode): Update for new\n+\tget_mode_mask interface.\n+\t(aarch64_expand_sve_vcond): Update call accordingly.\n+\t* config/gcn/gcn.c (gcn_vectorize_get_mask_mode): Update for new\n+\tget_mode_mask interface.\n+\t* config/i386/i386.c (ix86_get_mask_mode): Likewise.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree.h (build_truth_vector_type): Delete."}, {"sha": "0870d2c069fff30887eefd3013ac5de11f649ff3", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -1776,17 +1776,13 @@ aarch64_sve_pred_mode (unsigned int elem_nbytes)\n /* Implement TARGET_VECTORIZE_GET_MASK_MODE.  */\n \n static opt_machine_mode\n-aarch64_get_mask_mode (poly_uint64 nunits, poly_uint64 nbytes)\n+aarch64_get_mask_mode (machine_mode mode)\n {\n-  if (TARGET_SVE && known_eq (nbytes, BYTES_PER_SVE_VECTOR))\n-    {\n-      unsigned int elem_nbytes = vector_element_size (nbytes, nunits);\n-      machine_mode pred_mode;\n-      if (aarch64_sve_pred_mode (elem_nbytes).exists (&pred_mode))\n-\treturn pred_mode;\n-    }\n+  unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+  if (vec_flags & VEC_SVE_DATA)\n+    return aarch64_sve_pred_mode (GET_MODE_UNIT_SIZE (mode));\n \n-  return default_get_mask_mode (nunits, nbytes);\n+  return default_get_mask_mode (mode);\n }\n \n /* Return the SVE vector mode that has NUNITS elements of mode INNER_MODE.  */\n@@ -19434,9 +19430,7 @@ void\n aarch64_expand_sve_vcond (machine_mode data_mode, machine_mode cmp_mode,\n \t\t\t  rtx *ops)\n {\n-  machine_mode pred_mode\n-    = aarch64_get_mask_mode (GET_MODE_NUNITS (cmp_mode),\n-\t\t\t     GET_MODE_SIZE (cmp_mode)).require ();\n+  machine_mode pred_mode = aarch64_get_mask_mode (cmp_mode).require ();\n   rtx pred = gen_reg_rtx (pred_mode);\n   if (FLOAT_MODE_P (cmp_mode))\n     {"}, {"sha": "20534a2fbe67898df8e1b4e0b4fbddbc99354f37", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -3816,8 +3816,7 @@ gcn_expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n    a vector.  */\n \n opt_machine_mode\n-gcn_vectorize_get_mask_mode (poly_uint64 ARG_UNUSED (nunits),\n-\t\t\t     poly_uint64 ARG_UNUSED (length))\n+gcn_vectorize_get_mask_mode (machine_mode)\n {\n   /* GCN uses a DImode bit-mask.  */\n   return DImode;"}, {"sha": "69c827882c33394a00273abe5a7cf83f903346ad", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -21419,8 +21419,10 @@ ix86_autovectorize_vector_sizes (vector_sizes *sizes, bool all)\n /* Implemenation of targetm.vectorize.get_mask_mode.  */\n \n static opt_machine_mode\n-ix86_get_mask_mode (poly_uint64 nunits, poly_uint64 vector_size)\n+ix86_get_mask_mode (machine_mode data_mode)\n {\n+  unsigned vector_size = GET_MODE_SIZE (data_mode);\n+  unsigned nunits = GET_MODE_NUNITS (data_mode);\n   unsigned elem_size = vector_size / nunits;\n \n   /* Scalar mask case.  */"}, {"sha": "3da1d65607a576ba8ee45fa5773de190fa28f0cc", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -6045,16 +6045,16 @@ requested mode, returning a mode with the same size as @var{vector_mode}\n when @var{nunits} is zero.  This is the correct behavior for most targets.\n @end deftypefn\n \n-@deftypefn {Target Hook} opt_machine_mode TARGET_VECTORIZE_GET_MASK_MODE (poly_uint64 @var{nunits}, poly_uint64 @var{length})\n-A vector mask is a value that holds one boolean result for every element\n-in a vector.  This hook returns the machine mode that should be used to\n-represent such a mask when the vector in question is @var{length} bytes\n-long and contains @var{nunits} elements.  The hook returns an empty\n-@code{opt_machine_mode} if no such mode exists.\n-\n-The default implementation returns the mode of an integer vector that\n-is @var{length} bytes long and that contains @var{nunits} elements,\n-if such a mode exists.\n+@deftypefn {Target Hook} opt_machine_mode TARGET_VECTORIZE_GET_MASK_MODE (machine_mode @var{mode})\n+Return the mode to use for a vector mask that holds one boolean\n+result for each element of vector mode @var{mode}.  The returned mask mode\n+can be a vector of integers (class @code{MODE_VECTOR_INT}), a vector of\n+booleans (class @code{MODE_VECTOR_BOOL}) or a scalar integer (class\n+@code{MODE_INT}).  Return an empty @code{opt_machine_mode} if no such\n+mask mode exists.\n+\n+The default implementation returns a @code{MODE_VECTOR_INT} with the\n+same size and number of elements as @var{mode}, if such a mode exists.\n @end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE (unsigned @var{ifn})"}, {"sha": "d59e116118d93dbddda73d79fb8a453a48f57b46", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -585,8 +585,7 @@ can_vec_mask_load_store_p (machine_mode mode,\n   if (!VECTOR_MODE_P (vmode))\n     return false;\n \n-  if ((targetm.vectorize.get_mask_mode\n-       (GET_MODE_NUNITS (vmode), GET_MODE_SIZE (vmode)).exists (&mask_mode))\n+  if (targetm.vectorize.get_mask_mode (vmode).exists (&mask_mode)\n       && convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n     return true;\n \n@@ -600,7 +599,7 @@ can_vec_mask_load_store_p (machine_mode mode,\n \tcontinue;\n       if (mode_for_vector (smode, nunits).exists (&vmode)\n \t  && VECTOR_MODE_P (vmode)\n-\t  && targetm.vectorize.get_mask_mode (nunits, cur).exists (&mask_mode)\n+\t  && targetm.vectorize.get_mask_mode (vmode).exists (&mask_mode)\n \t  && convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n \treturn true;\n     }"}, {"sha": "51bc9a7d95b60af9cc265e82c6c33aa573dd8b35", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -1954,17 +1954,17 @@ when @var{nunits} is zero.  This is the correct behavior for most targets.\",\n /* Function to get a target mode for a vector mask.  */\n DEFHOOK\n (get_mask_mode,\n- \"A vector mask is a value that holds one boolean result for every element\\n\\\n-in a vector.  This hook returns the machine mode that should be used to\\n\\\n-represent such a mask when the vector in question is @var{length} bytes\\n\\\n-long and contains @var{nunits} elements.  The hook returns an empty\\n\\\n-@code{opt_machine_mode} if no such mode exists.\\n\\\n-\\n\\\n-The default implementation returns the mode of an integer vector that\\n\\\n-is @var{length} bytes long and that contains @var{nunits} elements,\\n\\\n-if such a mode exists.\",\n+ \"Return the mode to use for a vector mask that holds one boolean\\n\\\n+result for each element of vector mode @var{mode}.  The returned mask mode\\n\\\n+can be a vector of integers (class @code{MODE_VECTOR_INT}), a vector of\\n\\\n+booleans (class @code{MODE_VECTOR_BOOL}) or a scalar integer (class\\n\\\n+@code{MODE_INT}).  Return an empty @code{opt_machine_mode} if no such\\n\\\n+mask mode exists.\\n\\\n+\\n\\\n+The default implementation returns a @code{MODE_VECTOR_INT} with the\\n\\\n+same size and number of elements as @var{mode}, if such a mode exists.\",\n  opt_machine_mode,\n- (poly_uint64 nunits, poly_uint64 length),\n+ (machine_mode mode),\n  default_get_mask_mode)\n \n /* Function to say whether a masked operation is expensive when the"}, {"sha": "f6c7a0c867689b9bf6e439098ff30414de06927a", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -1328,21 +1328,9 @@ default_vectorize_related_mode (machine_mode vector_mode,\n /* By default a vector of integers is used as a mask.  */\n \n opt_machine_mode\n-default_get_mask_mode (poly_uint64 nunits, poly_uint64 vector_size)\n+default_get_mask_mode (machine_mode mode)\n {\n-  unsigned int elem_size = vector_element_size (vector_size, nunits);\n-  scalar_int_mode elem_mode\n-    = smallest_int_mode_for_size (elem_size * BITS_PER_UNIT);\n-  machine_mode vector_mode;\n-\n-  gcc_assert (known_eq (elem_size * nunits, vector_size));\n-\n-  if (mode_for_vector (elem_mode, nunits).exists (&vector_mode)\n-      && VECTOR_MODE_P (vector_mode)\n-      && targetm.vector_mode_supported_p (vector_mode))\n-    return vector_mode;\n-\n-  return opt_machine_mode ();\n+  return related_int_vector_mode (mode);\n }\n \n /* By default consider masked stores to be expensive.  */"}, {"sha": "57b83a3e8a8429f27bc37e1a0beed8e5a977609f", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -117,7 +117,7 @@ extern void default_autovectorize_vector_sizes (vector_sizes *, bool);\n extern opt_machine_mode default_vectorize_related_mode (machine_mode,\n \t\t\t\t\t\t\tscalar_mode,\n \t\t\t\t\t\t\tpoly_uint64);\n-extern opt_machine_mode default_get_mask_mode (poly_uint64, poly_uint64);\n+extern opt_machine_mode default_get_mask_mode (machine_mode);\n extern bool default_empty_mask_is_expensive (unsigned);\n extern void *default_init_cost (class loop *);\n extern unsigned default_add_stmt_cost (void *, int, enum vect_cost_for_stmt,"}, {"sha": "71c635c57b99196943ec1b0f0343b5791e89f6d9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -1943,9 +1943,8 @@ check_load_store_masking (loop_vec_info loop_vinfo, tree vectype,\n     }\n \n   machine_mode mask_mode;\n-  if (!(targetm.vectorize.get_mask_mode\n-\t(GET_MODE_NUNITS (vecmode),\n-\t GET_MODE_SIZE (vecmode)).exists (&mask_mode))\n+  if (!VECTOR_MODE_P (vecmode)\n+      || !targetm.vectorize.get_mask_mode (vecmode).exists (&mask_mode)\n       || !can_vec_mask_load_store_p (vecmode, mask_mode, is_load))\n     {\n       if (dump_enabled_p ())"}, {"sha": "4db3fa8ee6c9135e5250341a1dc6e8c9783c4368", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10116ec1c147a76522cafba6b6a5b4ed1cb37b77/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=10116ec1c147a76522cafba6b6a5b4ed1cb37b77", "patch": "@@ -10894,15 +10894,15 @@ build_truth_vector_type_for_mode (poly_uint64 nunits, machine_mode mask_mode)\n static tree\n build_truth_vector_type_for (tree vectype)\n {\n+  machine_mode vector_mode = TYPE_MODE (vectype);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  poly_uint64 vector_size = tree_to_poly_uint64 (TYPE_SIZE_UNIT (vectype));\n \n   machine_mode mask_mode;\n-  if (targetm.vectorize.get_mask_mode (nunits,\n-\t\t\t\t       vector_size).exists (&mask_mode))\n+  if (VECTOR_MODE_P (vector_mode)\n+      && targetm.vectorize.get_mask_mode (vector_mode).exists (&mask_mode))\n     return build_truth_vector_type_for_mode (nunits, mask_mode);\n \n-  poly_uint64 vsize = vector_size * BITS_PER_UNIT;\n+  poly_uint64 vsize = tree_to_poly_uint64 (TYPE_SIZE (vectype));\n   unsigned HOST_WIDE_INT esize = vector_element_size (vsize, nunits);\n   tree bool_type = build_nonstandard_boolean_type (esize);\n "}]}