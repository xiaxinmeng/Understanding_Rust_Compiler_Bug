{"sha": "66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZjMGZhMmNjOWEyZGJlNjJkYjViZWQ0ZmU1MzEwZDJlNTkxMmJhZg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-05-21T14:49:52Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-21T14:49:52Z"}, "message": "[Ada] Premature secondary stack reclamation\n\nThis patch modifies the creation of transient scopes to eliminate potential\npremature secondary stack reclamations when there is no suitable transient\ncontext and the scope was intended to manage the secondary stack. Instead,\nthe logic was changed to accommodate a special case where an assignment with\nsuppressed controlled actions that appears within a type initialization\nprocedure requires secondary stack reclamation.\n\nThe patch also corrects the handling of function calls which utilize the\nsecondary stack in loop parameter specifications. Previously the predicate\nwhich determined whether the function will utilize the secondary stack was\nnot accurate enough, and in certain cases could lead to leaks.\n\n------------\n-- Source --\n------------\n\n--  iterators.ads\n\npackage Iterators is\n   type Iterator is limited interface;\n   type Iterator_Access is access all Iterator'Class;\n\n   function Next\n     (I       : in out Iterator;\n      Element : out Character) return Boolean is abstract;\n\n   procedure Iterate\n     (I    : in out Iterator'Class;\n      Proc : access procedure (Element : Character));\nend Iterators;\n\n--  iterators.adb\n\npackage body Iterators is\n   procedure Iterate\n     (I    : in out Iterator'Class;\n      Proc : access procedure (Element : Character))\n   is\n      Element : Character;\n   begin\n      while I.Next (Element) loop\n         Proc (Element);\n      end loop;\n   end Iterate;\nend Iterators;\n\n--  base.ads\n\nwith Iterators; use Iterators;\n\npackage Base is\n   type String_Access is access all String;\n   type Node is tagged record\n      S : String_Access;\n   end record;\n\n   type Node_Access is access all Node'Class;\n   type Node_Array is array (Positive range <>) of Node_Access;\n\n   function As_Array (N : Node_Access) return Node_Array;\n   function Get_String (C : Character) return String;\n\n   type Node_Iterator is limited new Iterator with record\n      Node : Node_Access;\n      I    : Positive;\n   end record;\n\n   overriding function Next\n     (It      : in out Node_Iterator;\n      Element : out Character) return Boolean;\n\n   function Constructor_1 (N : Node_Access) return Node_Iterator;\n   function Constructor_2 (N : Node_Access) return Node_Iterator;\nend Base;\n\n--  base.adb\n\npackage body Base is\n   function As_Array (N : Node_Access) return Node_Array is\n   begin\n      return (1 => N);\n   end As_Array;\n\n   function Get_String (C : Character) return String is\n   begin\n      return (1 .. 40 => C);\n   end Get_String;\n\n   function Next\n     (It      : in out Node_Iterator;\n      Element : out Character) return Boolean\n   is\n   begin\n      if It.I > It.Node.S'Last then\n         return False;\n      else\n         It.I := It.I + 1;\n         Element := It.Node.S (It.I - 1);\n         return True;\n      end if;\n   end Next;\n\n   function Constructor_1 (N : Node_Access) return Node_Iterator is\n   begin\n      return Node_Iterator'(N, 1);\n   end Constructor_1;\n\n   function Constructor_2 (N : Node_Access) return Node_Iterator is\n   begin\n      return Constructor_1 (As_Array (N) (1));\n   end Constructor_2;\nend Base;\n\n--  main.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Base;        use Base;\nwith Iterators;   use Iterators;\n\nprocedure Main is\n   N : constant Node_Access := new Node'(S => new String'(\"hello world\"));\n\n   procedure Process (C : Character) is\n   begin\n      Put_Line (Get_String (C));\n   end Process;\n\n   C : Iterator'Class := Constructor_2 (N);\n\nbegin\n   C.Iterate (Process'Access);\nend Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q main.adb\n$ ./main\nhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\neeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\nllllllllllllllllllllllllllllllllllllllll\nllllllllllllllllllllllllllllllllllllllll\noooooooooooooooooooooooooooooooooooooooo\n\nwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\noooooooooooooooooooooooooooooooooooooooo\nrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr\nllllllllllllllllllllllllllllllllllllllll\ndddddddddddddddddddddddddddddddddddddddd\n\n2018-05-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch7.adb (Establish_Transient_Scope): Code cleanup. Do not\n\tdelegate the secondary stack management when there is no suitable\n\ttransient context, and the transient scope was intended to manage the\n\tsecondary stack because this causes premature reclamation. Change the\n\ttransient scope creation logic by special casing assignment statements\n\tof controlled components for type initialization procedures.\n\t(Find_Node_To_Be_Wrapped): Renamed to Find_Transient_Context. Update\n\tthe comment on usage.\n\t(Find_Transient_Context): Change the initinte loop into a while loop.\n\tIterations schemes and iterator specifications are not valid transient\n\tcontexts because they rely on special processing. Assignment statements\n\tare now treated as a normal transient context, special cases are\n\thandled by the caller. Add special processing for pragma Check.\n\t(Is_OK_Construct): Removed. Its functionality has been merged in\n\troutine Find_Transient_Context.\n\t* sem_ch5.adb (Check_Call): Reimplemented. Add code to properly\n\tretrieve the subprogram being invoked. Use a more accurate predicate\n\t(Requires_Transient_Scope) to determine that the function will emply\n\tthe secondary stack.\n\nFrom-SVN: r260443", "tree": {"sha": "61aca7f8c17ef32e5181606e88f16255c0dd5157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61aca7f8c17ef32e5181606e88f16255c0dd5157"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8016e5676bfde592826b45bc297da0750c15d6e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8016e5676bfde592826b45bc297da0750c15d6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8016e5676bfde592826b45bc297da0750c15d6e3"}], "stats": {"total": 247, "additions": 136, "deletions": 111}, "files": [{"sha": "e729f1851fe01cdbf75074ac67c177200dbc0e6f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "patch": "@@ -1,3 +1,25 @@\n+2018-04-04  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Establish_Transient_Scope): Code cleanup. Do not\n+\tdelegate the secondary stack management when there is no suitable\n+\ttransient context, and the transient scope was intended to manage the\n+\tsecondary stack because this causes premature reclamation. Change the\n+\ttransient scope creation logic by special casing assignment statements\n+\tof controlled components for type initialization procedures.\n+\t(Find_Node_To_Be_Wrapped): Renamed to Find_Transient_Context. Update\n+\tthe comment on usage.\n+\t(Find_Transient_Context): Change the initinte loop into a while loop.\n+\tIterations schemes and iterator specifications are not valid transient\n+\tcontexts because they rely on special processing. Assignment statements\n+\tare now treated as a normal transient context, special cases are\n+\thandled by the caller. Add special processing for pragma Check.\n+\t(Is_OK_Construct): Removed. Its functionality has been merged in\n+\troutine Find_Transient_Context.\n+\t* sem_ch5.adb (Check_Call): Reimplemented. Add code to properly\n+\tretrieve the subprogram being invoked. Use a more accurate predicate\n+\t(Requires_Transient_Scope) to determine that the function will emply\n+\tthe secondary stack.\n+\n 2018-04-04  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* ada_get_targ.adb: Fix subprogram body headers."}, {"sha": "9d1919ab6440ffc5781971a13d76215177004a71", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 98, "deletions": 90, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "patch": "@@ -125,10 +125,10 @@ package body Exp_Ch7 is\n    -- Transient Blocks and Finalization Management --\n    --------------------------------------------------\n \n-   function Find_Node_To_Be_Wrapped (N : Node_Id) return Node_Id;\n-   --  N is a node which may generate a transient scope. Loop over the parent\n-   --  pointers of N until we find the appropriate node to wrap. If it returns\n-   --  Empty, it means that no transient scope is needed in this context.\n+   function Find_Transient_Context (N : Node_Id) return Node_Id;\n+   --  Locate a suitable context for arbitrary node N which may need to be\n+   --  serviced by a transient scope. Return Empty if no suitable context is\n+   --  available.\n \n    procedure Insert_Actions_In_Scope_Around\n      (N         : Node_Id;\n@@ -4082,10 +4082,6 @@ package body Exp_Ch7 is\n       --  Examine the scope stack looking for the nearest enclosing transient\n       --  scope. Return Empty if no such scope exists.\n \n-      function Is_OK_Construct (Constr : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node Constr is a suitable construct which\n-      --  requires handling by a transient scope.\n-\n       function Is_Package_Or_Subprogram (Id : Entity_Id) return Boolean;\n       --  Determine whether arbitrary Id denotes a package or subprogram [body]\n \n@@ -4224,40 +4220,6 @@ package body Exp_Ch7 is\n          return Empty;\n       end Find_Enclosing_Transient_Scope;\n \n-      ---------------------\n-      -- Is_OK_Construct --\n-      ---------------------\n-\n-      function Is_OK_Construct (Constr : Node_Id) return Boolean is\n-      begin\n-         --  Nothing to do when there is no construct to consider\n-\n-         if No (Constr) then\n-            return False;\n-\n-         --  Nothing to do when the construct is an iteration scheme or an Ada\n-         --  2012 iterator because the expression is one of the bounds, and the\n-         --  expansion will create an explicit declaration for it (see routine\n-         --  Analyze_Iteration_Scheme).\n-\n-         elsif Nkind_In (Constr, N_Iteration_Scheme,\n-                                 N_Iterator_Specification)\n-         then\n-            return False;\n-\n-         --  Nothing to do in formal verification mode when the construct is\n-         --  pragma Check, because the pragma remains unexpanded.\n-\n-         elsif GNATprove_Mode\n-           and then Nkind (Constr) = N_Pragma\n-           and then Get_Pragma_Id (Constr) = Pragma_Check\n-         then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end Is_OK_Construct;\n-\n       ------------------------------\n       -- Is_Package_Or_Subprogram --\n       ------------------------------\n@@ -4274,22 +4236,22 @@ package body Exp_Ch7 is\n \n       --  Local variables\n \n-      Scop_Id : constant Entity_Id := Find_Enclosing_Transient_Scope;\n-      Constr  : Node_Id;\n+      Trans_Id : constant Entity_Id := Find_Enclosing_Transient_Scope;\n+      Context  : Node_Id;\n \n    --  Start of processing for Establish_Transient_Scope\n \n    begin\n       --  Do not create a new transient scope if there is an existing transient\n       --  scope on the stack.\n \n-      if Present (Scop_Id) then\n+      if Present (Trans_Id) then\n \n          --  If the transient scope was requested for purposes of managing the\n          --  secondary stack, then the existing scope must perform this task.\n \n          if Manage_Sec_Stack then\n-            Set_Uses_Sec_Stack (Scop_Id);\n+            Set_Uses_Sec_Stack (Trans_Id);\n          end if;\n \n          return;\n@@ -4299,18 +4261,41 @@ package body Exp_Ch7 is\n       --  scopes. Locate the proper construct which must be serviced by a new\n       --  transient scope.\n \n-      Constr := Find_Node_To_Be_Wrapped (N);\n+      Context := Find_Transient_Context (N);\n \n-      if Is_OK_Construct (Constr) then\n-         Create_Transient_Scope (Constr);\n+      if Present (Context) then\n+         if Nkind (Context) = N_Assignment_Statement then\n \n-      --  Otherwise there is no suitable construct which requires handling by\n-      --  a transient scope. If the transient scope was requested for purposes\n-      --  of managing the secondary stack, delegate the work to an enclosing\n-      --  scope.\n+            --  An assignment statement with suppressed controlled semantics\n+            --  does not need a transient scope because finalization is not\n+            --  desirable at this point. Note that No_Ctrl_Actions is also\n+            --  set for non-controlled assignments to suppress dispatching\n+            --  _assign.\n \n-      elsif Manage_Sec_Stack then\n-         Delegate_Sec_Stack_Management;\n+            if No_Ctrl_Actions (Context)\n+              and then Needs_Finalization (Etype (Name (Context)))\n+            then\n+               --  When a controlled component is initialized by a function\n+               --  call, the result on the secondary stack is always assigned\n+               --  to the component. Signal the nearest suitable scope that it\n+               --  is safe to manage the secondary stack.\n+\n+               if Manage_Sec_Stack and then Within_Init_Proc then\n+                  Delegate_Sec_Stack_Management;\n+               end if;\n+\n+            --  Otherwise the assignment is a normal transient context and thus\n+            --  requires a transient scope.\n+\n+            else\n+               Create_Transient_Scope (Context);\n+            end if;\n+\n+         --  General case\n+\n+         else\n+            Create_Transient_Scope (Context);\n+         end if;\n       end if;\n    end Establish_Transient_Scope;\n \n@@ -4815,18 +4800,18 @@ package body Exp_Ch7 is\n       end if;\n    end Expand_N_Package_Declaration;\n \n-   -----------------------------\n-   -- Find_Node_To_Be_Wrapped --\n-   -----------------------------\n+   ----------------------------\n+   -- Find_Transient_Context --\n+   ----------------------------\n \n-   function Find_Node_To_Be_Wrapped (N : Node_Id) return Node_Id is\n+   function Find_Transient_Context (N : Node_Id) return Node_Id is\n       Curr : Node_Id;\n       Prev : Node_Id;\n \n    begin\n       Curr := N;\n       Prev := Empty;\n-      loop\n+      while Present (Curr) loop\n          case Nkind (Curr) is\n \n             --  Declarations\n@@ -4858,58 +4843,66 @@ package body Exp_Ch7 is\n                | N_Entry_Body_Formal_Part\n                | N_Exit_Statement\n                | N_If_Statement\n-               | N_Iteration_Scheme\n                | N_Terminate_Alternative\n             =>\n                pragma Assert (Present (Prev));\n                return Prev;\n \n-            --  Assignment statements are usually wrapped in a transient block\n-            --  except when they are generated as part of controlled aggregate\n-            --  where the wrapping should take place more globally. Note that\n-            --  No_Ctrl_Actions is set also for non-controlled assignments, in\n-            --  order to disable the use of dispatching _assign, thus the test\n-            --  for a controlled type.\n-\n             when N_Assignment_Statement =>\n-               if No_Ctrl_Actions (Curr)\n-                 and then Needs_Finalization (Etype (Name (Curr)))\n-               then\n-                  return Empty;\n-               else\n-                  return Curr;\n-               end if;\n-\n-            --  An entry of procedure call is usually wrapped except when it\n-            --  acts as the alternative of a conditional or timed entry call.\n-            --  In that case wrap the context of the alternative.\n+               return Curr;\n \n             when N_Entry_Call_Statement\n                | N_Procedure_Call_Statement\n             =>\n+               --  When an entry or procedure call acts as the alternative of a\n+               --  conditional or timed entry call, the proper context is that\n+               --  of the alternative.\n+\n                if Nkind (Parent (Curr)) = N_Entry_Call_Alternative\n                  and then Nkind_In (Parent (Parent (Curr)),\n                                     N_Conditional_Entry_Call,\n                                     N_Timed_Entry_Call)\n                then\n                   return Parent (Parent (Curr));\n+\n+               --  General case for entry or procedure calls\n+\n                else\n                   return Curr;\n                end if;\n \n-            when N_Pragma\n-               | N_Raise_Statement\n-            =>\n-               return Curr;\n+            when N_Pragma =>\n+\n+               --  Pragma Check is not a valid transient context in GNATprove\n+               --  mode because the pragma must remain unchanged.\n+\n+               if GNATprove_Mode\n+                 and then Get_Pragma_Id (Curr) = Pragma_Check\n+               then\n+                  return Empty;\n+\n+               --  General case for pragmas\n+\n+               else\n+                  return Curr;\n+               end if;\n \n-            --  A return statement is not wrapped when the associated function\n-            --  would require wrapping.\n+            when N_Raise_Statement =>\n+               return Curr;\n \n             when N_Simple_Return_Statement =>\n+\n+               --  A return statement is not a valid transient context when the\n+               --  function itself requires transient scope management because\n+               --  the result will be reclaimed too early.\n+\n                if Requires_Transient_Scope (Etype\n                     (Return_Applies_To (Return_Statement_Entity (Curr))))\n                then\n                   return Empty;\n+\n+               --  General case for return statements\n+\n                else\n                   return Curr;\n                end if;\n@@ -4921,12 +4914,25 @@ package body Exp_Ch7 is\n                   return Curr;\n                end if;\n \n-            --  If the construct is within the iteration scheme of a loop, it\n-            --  requires a declaration followed by an assignment, in order to\n-            --  have a usable statement to wrap.\n+            --  An iteration scheme or an Ada 2012 iterator specification is\n+            --  not a valid context because Analyze_Iteration_Scheme already\n+            --  employs special processing for them.\n+\n+            when N_Iteration_Scheme\n+               | N_Iterator_Specification\n+            =>\n+               return Empty;\n \n             when N_Loop_Parameter_Specification =>\n-               return Parent (Curr);\n+\n+               --  An iteration scheme is not a valid context because routine\n+               --  Analyze_Iteration_Scheme already employs special processing.\n+\n+               if Nkind (Parent (Curr)) = N_Iteration_Scheme then\n+                  return Empty;\n+               else\n+                  return Parent (Curr);\n+               end if;\n \n             --  Termination\n \n@@ -4963,7 +4969,9 @@ package body Exp_Ch7 is\n          Prev := Curr;\n          Curr := Parent (Curr);\n       end loop;\n-   end Find_Node_To_Be_Wrapped;\n+\n+      return Empty;\n+   end Find_Transient_Context;\n \n    ----------------------------------\n    -- Has_New_Controlled_Component --"}, {"sha": "2a3b1ff0437070a8551a921d1fccb2de6d4fe391", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=66c0fa2cc9a2dbe62db5bed4fe5310d2e5912baf", "patch": "@@ -2779,7 +2779,6 @@ package body Sem_Ch5 is\n       ------------------------------------\n \n       function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean is\n-\n          function Check_Call (N : Node_Id) return Traverse_Result;\n          --  Check if N is a function call which uses the secondary stack\n \n@@ -2788,36 +2787,32 @@ package body Sem_Ch5 is\n          ----------------\n \n          function Check_Call (N : Node_Id) return Traverse_Result is\n-            Nam        : Node_Id;\n-            Subp       : Entity_Id;\n-            Return_Typ : Entity_Id;\n+            Nam  : Node_Id;\n+            Subp : Entity_Id;\n+            Typ  : Entity_Id;\n \n          begin\n             if Nkind (N) = N_Function_Call then\n                Nam := Name (N);\n \n-               --  Call using access to subprogram with explicit dereference\n-\n-               if Nkind (Nam) = N_Explicit_Dereference then\n-                  Subp := Etype (Nam);\n-\n-               --  Call using a selected component notation or Ada 2005 object\n-               --  operation notation\n+               --  Obtain the subprogram being invoked\n \n-               elsif Nkind (Nam) = N_Selected_Component then\n-                  Subp := Entity (Selector_Name (Nam));\n+               loop\n+                  if Nkind (Nam) = N_Explicit_Dereference then\n+                     Nam := Prefix (Nam);\n \n-               --  Common case\n+                  elsif Nkind (Nam) = N_Selected_Component then\n+                     Nam := Selector_Name (Nam);\n \n-               else\n-                  Subp := Entity (Nam);\n-               end if;\n+                  else\n+                     exit;\n+                  end if;\n+               end loop;\n \n-               Return_Typ := Etype (Subp);\n+               Subp := Entity (Nam);\n+               Typ  := Etype (Subp);\n \n-               if Is_Composite_Type (Return_Typ)\n-                 and then not Is_Constrained (Return_Typ)\n-               then\n+               if Requires_Transient_Scope (Typ) then\n                   return Abandon;\n \n                elsif Sec_Stack_Needed_For_Return (Subp) then"}]}