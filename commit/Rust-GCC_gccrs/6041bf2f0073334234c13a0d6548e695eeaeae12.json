{"sha": "6041bf2f0073334234c13a0d6548e695eeaeae12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0MWJmMmYwMDczMzM0MjM0YzEzYTBkNjU0OGU2OTVlZWFlYWUxMg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2002-01-15T07:23:19Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-01-15T07:23:19Z"}, "message": "rs6000.c (rs6000_output_function_epilogue): Do not emit optional traceback table if optimize_size or TARGET_ELF.\n\n        * config/rs6000/rs6000.c (rs6000_output_function_epilogue): Do not\n        emit optional traceback table if optimize_size or TARGET_ELF.\n        * config/rs6000/rs6000.md (prefetch): New.\n\nFrom-SVN: r48865", "tree": {"sha": "ab2df8fa722c63a35425dceb8b8fdeabcb073428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab2df8fa722c63a35425dceb8b8fdeabcb073428"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6041bf2f0073334234c13a0d6548e695eeaeae12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6041bf2f0073334234c13a0d6548e695eeaeae12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6041bf2f0073334234c13a0d6548e695eeaeae12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6041bf2f0073334234c13a0d6548e695eeaeae12/comments", "author": null, "committer": null, "parents": [{"sha": "8559c8c0435032e4aceb4fe0f773c11bbe5a6a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8559c8c0435032e4aceb4fe0f773c11bbe5a6a38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8559c8c0435032e4aceb4fe0f773c11bbe5a6a38"}], "stats": {"total": 146, "additions": 96, "deletions": 50}, "files": [{"sha": "e95daea8cdf06843418974dcb9e53265d634bc3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041bf2f0073334234c13a0d6548e695eeaeae12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041bf2f0073334234c13a0d6548e695eeaeae12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6041bf2f0073334234c13a0d6548e695eeaeae12", "patch": "@@ -1,3 +1,9 @@\n+2002-01-15  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* config/rs6000/rs6000.c (rs6000_output_function_epilogue): Do not\n+\temit optional traceback table if optimize_size or TARGET_ELF.\n+\t* config/rs6000/rs6000.md (prefetch): New.\n+\n 2002-01-15  Andreas Jaeger  <aj@suse.de>\n \n \t* config.gcc (x86_64-*-*): Install mmintrin.h and xmmintrin.h."}, {"sha": "f8375a43a367539cc2985f7fcbfa1ae6561baac3", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041bf2f0073334234c13a0d6548e695eeaeae12/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041bf2f0073334234c13a0d6548e695eeaeae12/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6041bf2f0073334234c13a0d6548e695eeaeae12", "patch": "@@ -9053,6 +9053,7 @@ rs6000_output_function_epilogue (file, size)\n      HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n {\n   rs6000_stack_t *info = rs6000_stack_info ();\n+  int optional_tbtab = (optimize_size || TARGET_ELF) ? 0 : 1;\n \n   if (! HAVE_epilogue)\n     {\n@@ -9098,7 +9099,7 @@ rs6000_output_function_epilogue (file, size)\n     {\n       const char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n       const char *language_string = lang_hooks.name;\n-      int fixed_parms, float_parms, parm_info;\n+      int fixed_parms = 0, float_parms = 0, parm_info = 0;\n       int i;\n \n       while (*fname == '.')\t/* V.4 encodes . in the name */\n@@ -9158,7 +9159,8 @@ rs6000_output_function_epilogue (file, size)\n \t has controlled storage, function has no toc, function uses fp,\n \t function logs/aborts fp operations.  */\n       /* Assume that fp operations are used if any fp reg must be saved.  */\n-      fprintf (file, \"%d,\", (1 << 5) | ((info->first_fp_reg_save != 64) << 1));\n+      fprintf (file, \"%d,\",\n+\t       (optional_tbtab << 5) | ((info->first_fp_reg_save != 64) << 1));\n \n       /* 6 bitfields: function is interrupt handler, name present in\n \t proc table, function calls alloca, on condition directives\n@@ -9167,64 +9169,62 @@ rs6000_output_function_epilogue (file, size)\n       /* The `function calls alloca' bit seems to be set whenever reg 31 is\n \t set up as a frame pointer, even when there is no alloca call.  */\n       fprintf (file, \"%d,\",\n-\t       ((1 << 6) | (frame_pointer_needed << 5)\n-\t\t| (info->cr_save_p << 1) | (info->lr_save_p)));\n+\t       ((optional_tbtab << 6)\n+\t\t| ((optional_tbtab & frame_pointer_needed) << 5)\n+\t\t| (info->cr_save_p << 1)\n+\t\t| (info->lr_save_p)));\n \n-      /* 3 bitfields: saves backchain, spare bit, number of fpr saved\n+      /* 3 bitfields: saves backchain, fixup code, number of fpr saved\n \t (6 bits).  */\n       fprintf (file, \"%d,\",\n \t       (info->push_p << 7) | (64 - info->first_fp_reg_save));\n \n       /* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */\n       fprintf (file, \"%d,\", (32 - first_reg_to_save ()));\n \n-      {\n-\t/* Compute the parameter info from the function decl argument\n-\t   list.  */\n-\ttree decl;\n-\tint next_parm_info_bit;\n-\n-\tnext_parm_info_bit = 31;\n-\tparm_info = 0;\n-\tfixed_parms = 0;\n-\tfloat_parms = 0;\n-\n-\tfor (decl = DECL_ARGUMENTS (current_function_decl);\n-\t     decl; decl = TREE_CHAIN (decl))\n-\t  {\n-\t    rtx parameter = DECL_INCOMING_RTL (decl);\n-\t    enum machine_mode mode = GET_MODE (parameter);\n-\n-\t    if (GET_CODE (parameter) == REG)\n-\t      {\n-\t\tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t\t  {\n-\t\t    int bits;\n-\n-\t\t    float_parms++;\n+      if (optional_tbtab)\n+\t{\n+\t  /* Compute the parameter info from the function decl argument\n+\t     list.  */\n+\t  tree decl;\n+\t  int next_parm_info_bit = 31;\n \n-\t\t    if (mode == SFmode)\n-\t\t      bits = 0x2;\n-\t\t    else if (mode == DFmode)\n-\t\t      bits = 0x3;\n-\t\t    else\n-\t\t      abort ();\n+\t  for (decl = DECL_ARGUMENTS (current_function_decl);\n+\t       decl; decl = TREE_CHAIN (decl))\n+\t    {\n+\t      rtx parameter = DECL_INCOMING_RTL (decl);\n+\t      enum machine_mode mode = GET_MODE (parameter);\n \n-\t\t    /* If only one bit will fit, don't or in this entry.  */\n-\t\t    if (next_parm_info_bit > 0)\n-\t\t      parm_info |= (bits << (next_parm_info_bit - 1));\n-\t\t    next_parm_info_bit -= 2;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    fixed_parms += ((GET_MODE_SIZE (mode)\n-\t\t\t\t     + (UNITS_PER_WORD - 1))\n-\t\t\t\t    / UNITS_PER_WORD);\n-\t\t    next_parm_info_bit -= 1;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n+\t      if (GET_CODE (parameter) == REG)\n+\t\t{\n+\t\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t\t    {\n+\t\t      int bits;\n+\n+\t\t      float_parms++;\n+\n+\t\t      if (mode == SFmode)\n+\t\t\tbits = 0x2;\n+\t\t      else if (mode == DFmode)\n+\t\t\tbits = 0x3;\n+\t\t      else\n+\t\t\tabort ();\n+\n+\t\t      /* If only one bit will fit, don't or in this entry.  */\n+\t\t      if (next_parm_info_bit > 0)\n+\t\t\tparm_info |= (bits << (next_parm_info_bit - 1));\n+\t\t      next_parm_info_bit -= 2;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      fixed_parms += ((GET_MODE_SIZE (mode)\n+\t\t\t\t       + (UNITS_PER_WORD - 1))\n+\t\t\t\t      / UNITS_PER_WORD);\n+\t\t      next_parm_info_bit -= 1;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n \n       /* Number of fixed point parameters.  */\n       /* This is actually the number of words of fixed point parameters; thus\n@@ -9240,6 +9240,9 @@ rs6000_output_function_epilogue (file, size)\n \t seems to set the bit when not optimizing.  */\n       fprintf (file, \"%d\\n\", ((float_parms << 1) | (! optimize)));\n \n+      if (! optional_tbtab)\n+\treturn;\n+\n       /* Optional fields follow.  Some are variable length.  */\n \n       /* Parameter types, left adjusted bit fields: 0 fixed, 10 single float,\n@@ -9289,6 +9292,7 @@ rs6000_output_function_epilogue (file, size)\n       if (frame_pointer_needed)\n \tfputs (\"\\t.byte 31\\n\", file);\n     }\n+  return;\n }\n \f\n /* A C compound statement that outputs the assembler code for a thunk"}, {"sha": "3dbc203398582b4de80f38b6d920b7c18a09da77", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6041bf2f0073334234c13a0d6548e695eeaeae12/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6041bf2f0073334234c13a0d6548e695eeaeae12/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6041bf2f0073334234c13a0d6548e695eeaeae12", "patch": "@@ -13846,6 +13846,42 @@\n   DONE;\n }\")\n \n+(define_expand \"prefetch\"\n+  [(prefetch (match_operand 0 \"address_operand\" \"p\")\n+\t     (match_operand 1 \"const_int_operand\" \"n\")\n+\t     (match_operand 2 \"const_int_operand\" \"n\"))]\n+  \"TARGET_POWERPC\"\n+  \"\n+{\n+  if (TARGET_32BIT)\n+    emit_insn (gen_prefetchsi (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_prefetchdi (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"prefetchsi\"\n+  [(prefetch (match_operand:SI 0 \"address_operand\" \"r\")\n+\t     (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))]\n+  \"TARGET_POWERPC && TARGET_32BIT\"\n+  \"*\n+{\n+  return INTVAL (operands[1]) ? \\\"dcbtst 0,%0\\\" : \\\"dcbt 0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"prefetchdi\"\n+  [(prefetch (match_operand:DI 0 \"address_operand\" \"r\")\n+\t     (match_operand:DI 1 \"const_int_operand\" \"n\")\n+\t     (match_operand:DI 2 \"const_int_operand\" \"n\"))]\n+  \"TARGET_POWERPC && TARGET_64BIT\"\n+  \"*\n+{\n+  return INTVAL (operands[1]) ? \\\"dcbtst 0,%0\\\" : \\\"dcbt 0,%0\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")])\n+\f\n ;; AltiVec patterns\n \n ;; Generic LVX load instruction."}]}