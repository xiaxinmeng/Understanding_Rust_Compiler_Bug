{"sha": "51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFkNDIxMmFlOWQ0NjBjNDFmNWRmZTJkNDdlNDM1MGE5ODBjNDljNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2016-03-14T20:48:15Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2016-03-14T20:48:15Z"}, "message": "re PR tree-optimization/68714 (less folding of vector comparison)\n\nPR tree-opt/68714\n\n  * tree-ssa-reassoc.c (ovce_extract_ops, optimize_vec_cond_expr): New.\n  (can_reassociate_p): Allow ANY_INTEGRAL_TYPE_P.\n  (reassociate_bb): Use optimize_vec_cond_expr; avoid\n  optimize_range_tests, attempt_builtin_copysign and attempt_builtin_powi\n  on vectors.\n\nFrom-SVN: r234196", "tree": {"sha": "9e66d592578a568f4060ec49ae3ffaf3056f0295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e66d592578a568f4060ec49ae3ffaf3056f0295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/comments", "author": null, "committer": null, "parents": [{"sha": "598a208cc0442bf7109ee545fa82d6c0607b9adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/598a208cc0442bf7109ee545fa82d6c0607b9adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/598a208cc0442bf7109ee545fa82d6c0607b9adf"}], "stats": {"total": 181, "additions": 173, "deletions": 8}, "files": [{"sha": "b9fba23890a9b82212db69b0a80a58a1b9bc3584", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "patch": "@@ -1,3 +1,12 @@\n+2016-03-14  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/68714\n+\t* tree-ssa-reassoc.c (ovce_extract_ops, optimize_vec_cond_expr): New.\n+\t(can_reassociate_p): Allow ANY_INTEGRAL_TYPE_P.\n+\t(reassociate_bb): Use optimize_vec_cond_expr; avoid\n+\toptimize_range_tests, attempt_builtin_copysign and attempt_builtin_powi\n+\ton vectors.\n+\n 2016-03-14  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR target/70083"}, {"sha": "741d3113c05816dfaaded5d2c67af4878a52c2b9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68714.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68714.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68714.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68714.c?ref=51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+typedef int vec __attribute__((vector_size(16)));\n+vec f(vec x,vec y){\n+  return x<y|x==y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" <= \" 1 \"optimized\" } } */"}, {"sha": "0340df249301050690c6463db7ee633407a4fe11", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 155, "deletions": 8, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51d4212ae9d460c41f5dfe2d47e4350a980c49c7/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=51d4212ae9d460c41f5dfe2d47e4350a980c49c7", "patch": "@@ -2769,6 +2769,146 @@ optimize_range_tests (enum tree_code opcode,\n   return any_changes;\n }\n \n+/* A subroutine of optimize_vec_cond_expr to extract and canonicalize\n+   the operands of the VEC_COND_EXPR.  Returns ERROR_MARK on failure,\n+   otherwise the comparison code.  */\n+\n+static tree_code\n+ovce_extract_ops (tree var, gassign **rets, bool *reti)\n+{\n+  if (TREE_CODE (var) != SSA_NAME)\n+    return ERROR_MARK;\n+\n+  gassign *stmt = dyn_cast <gassign *> (SSA_NAME_DEF_STMT (var));\n+  if (stmt == NULL)\n+    return ERROR_MARK;\n+\n+  /* ??? If we start creating more COND_EXPR, we could perform\n+     this same optimization with them.\tFor now, simplify.  */\n+  if (gimple_assign_rhs_code (stmt) != VEC_COND_EXPR)\n+    return ERROR_MARK;\n+\n+  tree cond = gimple_assign_rhs1 (stmt);\n+  tree_code cmp = TREE_CODE (cond);\n+  if (TREE_CODE_CLASS (cmp) != tcc_comparison)\n+    return ERROR_MARK;\n+\n+  /* ??? For now, allow only canonical true and false result vectors.\n+     We could expand this to other constants should the need arise,\n+     but at the moment we don't create them.  */\n+  tree t = gimple_assign_rhs2 (stmt);\n+  tree f = gimple_assign_rhs3 (stmt);\n+  bool inv;\n+  if (integer_all_onesp (t))\n+    inv = false;\n+  else if (integer_all_onesp (f))\n+    {\n+      cmp = invert_tree_comparison (cmp, false);\n+      inv = true;\n+    }\n+  else\n+    return ERROR_MARK;\n+  if (!integer_zerop (f))\n+    return ERROR_MARK;\n+\n+  /* Success!  */\n+  if (rets)\n+    *rets = stmt;\n+  if (reti)\n+    *reti = inv;\n+  return cmp;\n+}\n+\n+/* Optimize the condition of VEC_COND_EXPRs which have been combined\n+   with OPCODE (either BIT_AND_EXPR or BIT_IOR_EXPR).  */\n+\n+static bool\n+optimize_vec_cond_expr (tree_code opcode, vec<operand_entry *> *ops)\n+{\n+  unsigned int length = ops->length (), i, j;\n+  bool any_changes = false;\n+\n+  if (length == 1)\n+    return false;\n+\n+  for (i = 0; i < length; ++i)\n+    {\n+      tree elt0 = (*ops)[i]->op;\n+\n+      gassign *stmt0;\n+      bool invert;\n+      tree_code cmp0 = ovce_extract_ops (elt0, &stmt0, &invert);\n+      if (cmp0 == ERROR_MARK)\n+\tcontinue;\n+\n+      for (j = i + 1; j < length; ++j)\n+\t{\n+\t  tree &elt1 = (*ops)[j]->op;\n+\n+\t  gassign *stmt1;\n+\t  tree_code cmp1 = ovce_extract_ops (elt1, &stmt1, NULL);\n+\t  if (cmp1 == ERROR_MARK)\n+\t    continue;\n+\n+\t  tree cond0 = gimple_assign_rhs1 (stmt0);\n+\t  tree x0 = TREE_OPERAND (cond0, 0);\n+\t  tree y0 = TREE_OPERAND (cond0, 1);\n+\n+\t  tree cond1 = gimple_assign_rhs1 (stmt1);\n+\t  tree x1 = TREE_OPERAND (cond1, 0);\n+\t  tree y1 = TREE_OPERAND (cond1, 1);\n+\n+\t  tree comb;\n+\t  if (opcode == BIT_AND_EXPR)\n+\t    comb = maybe_fold_and_comparisons (cmp0, x0, y0, cmp1, x1, y1);\n+\t  else if (opcode == BIT_IOR_EXPR)\n+\t    comb = maybe_fold_or_comparisons (cmp0, x0, y0, cmp1, x1, y1);\n+\t  else\n+\t    gcc_unreachable ();\n+\t  if (comb == NULL)\n+\t    continue;\n+\n+\t  /* Success! */\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Transforming \");\n+\t      print_generic_expr (dump_file, cond0, 0);\n+\t      fprintf (dump_file, \" %c \", opcode == BIT_AND_EXPR ? '&' : '|');\n+\t      print_generic_expr (dump_file, cond1, 0);\n+\t      fprintf (dump_file, \" into \");\n+\t      print_generic_expr (dump_file, comb, 0);\n+\t      fputc ('\\n', dump_file);\n+\t    }\n+\n+\t  gimple_assign_set_rhs1 (stmt0, comb);\n+\t  if (invert)\n+\t    std::swap (*gimple_assign_rhs2_ptr (stmt0),\n+\t\t       *gimple_assign_rhs3_ptr (stmt0));\n+\t  update_stmt (stmt0);\n+\n+\t  elt1 = error_mark_node;\n+\t  any_changes = true;\n+\t}\n+    }\n+\n+  if (any_changes)\n+    {\n+      operand_entry *oe;\n+      j = 0;\n+      FOR_EACH_VEC_ELT (*ops, i, oe)\n+\t{\n+\t  if (oe->op == error_mark_node)\n+\t    continue;\n+\t  else if (i != j)\n+\t    (*ops)[j] = oe;\n+\t  j++;\n+\t}\n+      ops->truncate (j);\n+    }\n+\n+  return any_changes;\n+}\n+\n /* Return true if STMT is a cast like:\n    <bb N>:\n    ...\n@@ -4326,7 +4466,7 @@ static bool\n can_reassociate_p (tree op)\n {\n   tree type = TREE_TYPE (op);\n-  if ((INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_WRAPS (type))\n+  if ((ANY_INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_WRAPS (type))\n       || NON_SAT_FIXED_POINT_TYPE_P (type)\n       || (flag_associative_math && FLOAT_TYPE_P (type)))\n     return true;\n@@ -4952,6 +5092,7 @@ reassociate_bb (basic_block bb)\n \t    {\n \t      auto_vec<operand_entry *> ops;\n \t      tree powi_result = NULL_TREE;\n+\t      bool is_vector = VECTOR_TYPE_P (TREE_TYPE (lhs));\n \n \t      /* There may be no immediate uses left by the time we\n \t\t get here because we may have eliminated them all.  */\n@@ -4970,15 +5111,21 @@ reassociate_bb (basic_block bb)\n \t\t}\n \n \t      if (rhs_code == BIT_IOR_EXPR || rhs_code == BIT_AND_EXPR)\n-\t\toptimize_range_tests (rhs_code, &ops);\n+\t\t{\n+\t\t  if (is_vector)\n+\t\t    optimize_vec_cond_expr (rhs_code, &ops);\n+\t\t  else\n+\t\t    optimize_range_tests (rhs_code, &ops);\n+\t        }\n \n-\t      if (rhs_code == MULT_EXPR)\n-\t\tattempt_builtin_copysign (&ops);\n+\t      if (rhs_code == MULT_EXPR && !is_vector)\n+\t        {\n+\t\t  attempt_builtin_copysign (&ops);\n \n-\t      if (reassoc_insert_powi_p\n-\t\t  && rhs_code == MULT_EXPR\n-\t\t  && flag_unsafe_math_optimizations)\n-\t\tpowi_result = attempt_builtin_powi (stmt, &ops);\n+\t\t  if (reassoc_insert_powi_p\n+\t\t      && flag_unsafe_math_optimizations)\n+\t\t    powi_result = attempt_builtin_powi (stmt, &ops);\n+\t\t}\n \n \t      /* If the operand vector is now empty, all operands were \n \t\t consumed by the __builtin_powi optimization.  */"}]}