{"sha": "b3bf132d2c543fe8c52b31e4139435895c63142f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiZjEzMmQyYzU0M2ZlOGM1MmIzMWU0MTM5NDM1ODk1YzYzMTQyZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-25T21:21:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-05-25T21:21:34Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1084", "tree": {"sha": "e66810fc8ff1c04ed1c2fa7f5e4ef19230a13ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e66810fc8ff1c04ed1c2fa7f5e4ef19230a13ed0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3bf132d2c543fe8c52b31e4139435895c63142f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bf132d2c543fe8c52b31e4139435895c63142f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3bf132d2c543fe8c52b31e4139435895c63142f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bf132d2c543fe8c52b31e4139435895c63142f/comments", "author": null, "committer": null, "parents": [{"sha": "bc56fd1d0948edbdfb22e864e3283ac5d032545d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc56fd1d0948edbdfb22e864e3283ac5d032545d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc56fd1d0948edbdfb22e864e3283ac5d032545d"}], "stats": {"total": 23, "additions": 19, "deletions": 4}, "files": [{"sha": "6de03151295a349c3382265c19d51737571d0d87", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3bf132d2c543fe8c52b31e4139435895c63142f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3bf132d2c543fe8c52b31e4139435895c63142f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b3bf132d2c543fe8c52b31e4139435895c63142f", "patch": "@@ -565,8 +565,9 @@ gen_lowpart_common (mode, x)\n      value.  If the machine-parameters allow it, simulate that union here\n      and return the result.  */\n \n-  else if (HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t   && HOST_BITS_PER_INT == BITS_PER_WORD\n+  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t    || flag_pretend_float)\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n \t   && GET_MODE (x) == VOIDmode\n@@ -589,13 +590,27 @@ gen_lowpart_common (mode, x)\n       return immed_real_const_1 (u.d, mode);\n     }\n \n+  /* Similarly, if this is converting a floating-point value into a\n+     single-word integer.  Only do this is the host and target parameters are\n+     compatible.  */\n+\n+  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t    || flag_pretend_float)\n+\t   && GET_MODE_CLASS (mode) == MODE_INT\n+\t   && GET_CODE (x) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n+\t   && GET_MODE_BITSIZE (mode) == BITS_PER_WORD)\n+    return operand_subword (x, 0, 0, GET_MODE (x));\n+\n   /* Similarly, if this is converting a floating-point value into a\n      two-word integer, we can do this one word at a time and make an\n      integer.  Only do this is the host and target parameters are\n      compatible.  */\n \n-  else if (HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t   && HOST_BITS_PER_INT == BITS_PER_WORD\n+  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+\t     && HOST_BITS_PER_INT == BITS_PER_WORD)\n+\t    || flag_pretend_float)\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && GET_CODE (x) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT"}]}