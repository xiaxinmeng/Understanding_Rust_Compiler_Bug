{"sha": "d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIxOGQwZTY2ZDExNDRlMWE3MjdjMTNmYjA1ODZjODJiNGZjM2Q4Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-29T04:51:32Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-08-29T04:51:32Z"}, "message": "re PR fortran/28788 (ICE on valid code)\n\n2006-08-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28788\n\tREGRESSION FIX\n\t* symbol.c (gfc_use_derived): Never eliminate the symbol,\n\tfollowing reassociation of use associated derived types.\n\n2006-08-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/28788\n\t* gfortran.dg/used_types_5.f90: New test.\n\t* gfortran.dg/used_types_6.f90: New test.\n\nFrom-SVN: r116552", "tree": {"sha": "3e08d5448036b39d4836ec041f5f02403a2e6231", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e08d5448036b39d4836ec041f5f02403a2e6231"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/comments", "author": null, "committer": null, "parents": [{"sha": "bb6e56215c46410b8e3422dd10d2eab27df148bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6e56215c46410b8e3422dd10d2eab27df148bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6e56215c46410b8e3422dd10d2eab27df148bd"}], "stats": {"total": 129, "additions": 117, "deletions": 12}, "files": [{"sha": "a922dff8964820a5b2526b8d527d52b934310929", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "patch": "@@ -1,3 +1,10 @@\n+2006-08-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/28788\n+\tREGRESSION FIX\n+\t* symbol.c (gfc_use_derived): Never eliminate the symbol,\n+\tfollowing reassociation of use associated derived types.\n+\n 2006-08-26  Steven G. Kargl  <kargls@comcast.net>\n \n \t* arith.h: Update Copyright dates.  Fix whitespace."}, {"sha": "450f7cf3523d69576f94857de556ca41e6c9cf90", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "patch": "@@ -1495,16 +1495,10 @@ gfc_use_derived (gfc_symbol * sym)\n \n   if (s == NULL || s->attr.flavor != FL_DERIVED)\n     {\n-      /* Check to see if type has been renamed in parent namespace.\n-\t Leave cleanup of local symbols until the end of the\n-\t compilation because doing it here is complicated by\n-\t multiple association with the same type.  */\n+      /* Check to see if type has been renamed in parent namespace.  */\n       s = find_renamed_type (sym, sym->ns->parent->sym_root);\n       if (s != NULL)\n-\t{\n-\t  switch_types (sym->ns->sym_root, sym, s);\n-\t  return s;\n-\t}\n+\tgoto return_use_assoc;\n \n       /* See if sym is identical to renamed, use-associated derived\n \t types in sibling namespaces.  */\n@@ -1521,10 +1515,7 @@ gfc_use_derived (gfc_symbol * sym)\n \t      s = find_renamed_type (sym, ns->sym_root);\n \n \t      if (s != NULL)\n-\t\t{\n-\t\t  switch_types (sym->ns->sym_root, sym, s);\n-\t\t  return s;\n-\t\t}\n+\t\tgoto return_use_assoc;\n \t    }\n \t}\n \n@@ -1557,6 +1548,9 @@ gfc_use_derived (gfc_symbol * sym)\n \tt->derived = s;\n     }\n \n+  if (sym->attr.use_assoc)\n+    goto return_use_assoc;\n+\n   st = gfc_find_symtree (sym->ns->sym_root, sym->name);\n   st->n.sym = s;\n \n@@ -1573,6 +1567,14 @@ gfc_use_derived (gfc_symbol * sym)\n \n   return s;\n \n+return_use_assoc:\n+  /* Use associated types are not freed at this stage because some\n+     references remain to 'sym'.  We retain the symbol and leave it\n+     to be cleaned up by gfc_free_namespace, at the end of the\n+     compilation.  */\n+  switch_types (sym->ns->sym_root, sym, s);\n+  return s;\n+\n bad:\n   gfc_error (\"Derived type '%s' at %C is being used before it is defined\",\n \t     sym->name);"}, {"sha": "427ede1efae493b490c6395d043702d5d6385c6f", "filename": "gcc/testsuite/gfortran.dg/used_types_5.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_5.f90?ref=d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do compile }\n+! Tests the fix for a further regression caused by the\n+! fix for PR28788, as noted in reply #9 in the Bugzilla\n+! entry by Martin Reinecke <martin@mpa-garching.mpg.de>.\n+! The problem was caused by certain types of references\n+! that point to a deleted derived type symbol, after the\n+! type has been associated to another namespace. An\n+! example of this is the specification expression for x\n+! in subroutine foo below.  At the same time, this tests\n+! the correct association of typeaa between a module\n+! procedure and a new definition of the type in MAIN.\n+!\n+module types\n+\n+  type :: typea\n+    sequence\n+    integer :: i\n+  end type typea\n+\n+  type :: typeaa\n+    sequence\n+    integer :: i\n+  end type typeaa\n+\n+  type(typea) :: it = typea(2)\n+\n+end module types\n+!------------------------------\n+module global\n+\n+  use types, only: typea, it\n+\n+contains\n+\n+  subroutine foo (x)\n+    use types\n+    type(typeaa) :: ca\n+    real :: x(it%i)\n+    common /c/ ca\n+    x = 42.0\n+    ca%i = 99\n+  end subroutine foo\n+\n+end module global\n+!------------------------------\n+  use global, only: typea, foo\n+  type :: typeaa\n+    sequence\n+    integer :: i\n+  end type typeaa\n+  type(typeaa) :: cam\n+  real :: x(4)\n+  common /c/ cam\n+  x = -42.0\n+  call foo(x)\n+  if (any (x .ne. (/42.0, 42.0, -42.0, -42.0/))) call abort ()\n+  if (cam%i .ne. 99) call abort ()\n+end\n+! { dg-final { cleanup-modules \"types global\" } }"}, {"sha": "52fa55460df7d6cab94ba103e8df884180f76bb0", "filename": "gcc/testsuite/gfortran.dg/used_types_6.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d218d0e66d1144e1a727c13fb0586c82b4fc3d87/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_types_6.f90?ref=d218d0e66d1144e1a727c13fb0586c82b4fc3d87", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! Tests the fix for a further regression caused by the\n+! fix for PR28788, as noted in reply #13 in the Bugzilla\n+! entry by Martin Tee  <aovb94@dsl.pipex.com>.\n+! The problem was caused by contained, use associated\n+! derived types with pointer components of a derived type\n+! use associated in a sibling procedure, where both are\n+! associated by an ONLY clause. This is the reporter's\n+! test case.\n+!\n+MODULE type_mod\n+  TYPE a\n+    INTEGER  :: n(10)\n+  END TYPE a\n+\n+  TYPE b\n+    TYPE (a), POINTER :: m(:) => NULL ()\n+  END TYPE b\n+END MODULE type_mod\n+\n+MODULE seg_mod\n+CONTAINS\n+  SUBROUTINE foo (x)\n+    USE type_mod, ONLY : a     ! failed\n+    IMPLICIT NONE\n+    TYPE (a)  :: x\n+    RETURN\n+  END SUBROUTINE foo\n+\n+  SUBROUTINE bar (x)\n+    USE type_mod, ONLY : b     ! failed\n+    IMPLICIT NONE\n+    TYPE (b)  :: x\n+    RETURN\n+  END SUBROUTINE bar\n+END MODULE seg_mod\n+! { dg-final { cleanup-modules \"type_mod seg_mod\" } }"}]}