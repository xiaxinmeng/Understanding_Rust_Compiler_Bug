{"sha": "a42220f0164eeb11b5e1ab87ce5b8f448141ba60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyMjIwZjAxNjRlZWIxMWI1ZTFhYjg3Y2U1YjhmNDQ4MTQxYmE2MA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2021-05-09T19:56:15Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2021-05-26T19:50:17Z"}, "message": "libstdc++: [_GLIBCXX_DEBUG] Enhance rendering of assert message\n\nAvoid building an intermediate buffer to print to stderr, push directly to stderr.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/debug/formatter.h\n\t(_Error_formatter::_Parameter::_Named): New.\n\t(_Error_formatter::_Parameter::_Type): Inherit latter.\n\t(_Error_formatter::_Parameter::_M_integer): Likewise.\n\t(_Error_formatter::_Parameter::_M_string): Likewise.\n\t* src/c++11/debug.cc: Include <cstring>.\n\t(_Print_func_t): New.\n\t(print_raw(PrintContext&, const char*, ptrdiff_t)): New.\n\t(print_word): Use '%.*s' format in fprintf to render only expected number of chars.\n\t(pretty_print(PrintContext&, const char*, _Print_func_t)): New.\n\t(print_type): Rename in...\n\t(print_type_info): ...this. Use pretty_print.\n\t(print_address, print_integer): New.\n\t(print_named_name, print_iterator_constness, print_iterator_state): New.\n\t(print_iterator_seq_type): New.\n\t(print_named_field, print_type_field, print_instance_field, print_iterator_field): New.\n\t(print_field): Use latters.\n\t(print_quoted_named_name, print_type_type, print_type, print_instance): New.\n\t(print_string(PrintContext&, const char*, const _Parameter*, size_t)):\n\tChange signature to...\n\t(print_string(PrintContext&, const char*, ptrdiff_t, const _Parameter*, size_t)):\n\t...this and adapt. Remove intermediate buffer to render input string.\n\t(print_string(PrintContext&, const char*, ptrdiff_t)): New.", "tree": {"sha": "63f6dd5ea15a5331a7933efe4b2e240e5f3e93d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63f6dd5ea15a5331a7933efe4b2e240e5f3e93d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a42220f0164eeb11b5e1ab87ce5b8f448141ba60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42220f0164eeb11b5e1ab87ce5b8f448141ba60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42220f0164eeb11b5e1ab87ce5b8f448141ba60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42220f0164eeb11b5e1ab87ce5b8f448141ba60/comments", "author": null, "committer": null, "parents": [{"sha": "af66d0af87cf36d923d4663935a2b7a682753a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af66d0af87cf36d923d4663935a2b7a682753a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af66d0af87cf36d923d4663935a2b7a682753a24"}], "stats": {"total": 495, "additions": 263, "deletions": 232}, "files": [{"sha": "a83d33a4cb86fc7c68c56897459489e91724dec7", "filename": "libstdc++-v3/include/debug/formatter.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42220f0164eeb11b5e1ab87ce5b8f448141ba60/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42220f0164eeb11b5e1ab87ce5b8f448141ba60/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h?ref=a42220f0164eeb11b5e1ab87ce5b8f448141ba60", "patch": "@@ -202,9 +202,13 @@ namespace __gnu_debug\n \t__iterator_value_type\n       } _M_kind;\n \n-      struct _Type\n+      struct _Named\n       {\n \tconst char*\t\t_M_name;\n+      };\n+\n+      struct _Type : _Named\n+      {\n \tconst type_info*\t_M_type;\n       };\n \n@@ -228,16 +232,14 @@ namespace __gnu_debug\n \t_Instance _M_sequence;\n \n \t// When _M_kind == __integer\n-\tstruct\n+\tstruct : _Named\n \t{\n-\t  const char*\t\t_M_name;\n \t  long\t\t\t_M_value;\n \t} _M_integer;\n \n \t// When _M_kind == __string\n-\tstruct\n+\tstruct : _Named\n \t{\n-\t  const char*\t\t_M_name;\n \t  const char*\t\t_M_value;\n \t} _M_string;\n "}, {"sha": "33d76bfcaab879a42d8f6ba7c61f25795f5247b1", "filename": "libstdc++-v3/src/c++11/debug.cc", "status": "modified", "additions": 256, "deletions": 227, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42220f0164eeb11b5e1ab87ce5b8f448141ba60/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42220f0164eeb11b5e1ab87ce5b8f448141ba60/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc?ref=a42220f0164eeb11b5e1ab87ce5b8f448141ba60", "patch": "@@ -34,16 +34,12 @@\n \n #include <cassert>\n #include <cstdio>\n-#include <cctype> // for std::isspace\n+#include <cctype>\t// for std::isspace.\n+#include <cstring>\t// for std::strstr.\n \n-#include <algorithm> // for std::min\n+#include <algorithm>\t// for std::min.\n \n-#include <cxxabi.h> // for __cxa_demangle\n-\n-// libstdc++/85768\n-#if 0 // defined _GLIBCXX_HAVE_EXECINFO_H\n-# include <execinfo.h> // for backtrace\n-#endif\n+#include <cxxabi.h>\t// for __cxa_demangle.\n \n #include \"mutex_pool.h\"\n \n@@ -574,7 +570,7 @@ namespace\n   struct PrintContext\n   {\n     PrintContext()\n-      : _M_max_length(78), _M_column(1), _M_first_line(true), _M_wordwrap(false)\n+    : _M_max_length(78), _M_column(1), _M_first_line(true), _M_wordwrap(false)\n     { get_max_length(_M_max_length); }\n \n     std::size_t\t_M_max_length;\n@@ -584,16 +580,26 @@ namespace\n     bool\t_M_wordwrap;\n   };\n \n+  using _Print_func_t = void (PrintContext&, const char*, ptrdiff_t);\n+\n   template<size_t Length>\n     void\n     print_literal(PrintContext& ctx, const char(&word)[Length])\n     { print_word(ctx, word, Length - 1); }\n \n   void\n-  print_word(PrintContext& ctx, const char* word,\n-\t     std::ptrdiff_t count = -1)\n+  print_raw(PrintContext& ctx, const char* str, ptrdiff_t nbc = -1)\n   {\n-    size_t length = count >= 0 ? count : __builtin_strlen(word);\n+    if (nbc >= 0)\n+      ctx._M_column += fprintf(stderr, \"%.*s\", (int)nbc, str);\n+    else\n+      ctx._M_column += fprintf(stderr, \"%s\", str);\n+  }\n+\n+  void\n+  print_word(PrintContext& ctx, const char* word, ptrdiff_t nbc = -1)\n+  {\n+    size_t length = nbc >= 0 ? nbc : __builtin_strlen(word);\n     if (length == 0)\n       return;\n \n@@ -610,7 +616,7 @@ namespace\n       }\n \n     size_t visual_length\n-      = isspace(word[length - 1]) ? length - 1 : length;\n+      = isspace((unsigned char)word[length - 1]) ? length - 1 : length;\n     if (visual_length == 0\n \t|| !ctx._M_wordwrap\n \t|| (ctx._M_column + visual_length < ctx._M_max_length)\n@@ -619,15 +625,11 @@ namespace\n \t// If this isn't the first line, indent\n \tif (ctx._M_column == 1 && !ctx._M_first_line)\n \t  {\n-\t    char spacing[ctx._M_indent + 1];\n-\t    for (int i = 0; i < ctx._M_indent; ++i)\n-\t      spacing[i] = ' ';\n-\t    spacing[ctx._M_indent] = '\\0';\n-\t    fprintf(stderr, \"%s\", spacing);\n-\t    ctx._M_column += ctx._M_indent;\n+\t    const char spacing[ctx._M_indent + 1] = \"    \";\n+\t    print_raw(ctx, spacing, ctx._M_indent);\n \t  }\n \n-\tint written = fprintf(stderr, \"%s\", word);\n+\tint written = fprintf(stderr, \"%.*s\", (int)length, word);\n \n \tif (word[length - 1] == '\\n')\n \t  {\n@@ -640,15 +642,40 @@ namespace\n     else\n       {\n \tprint_literal(ctx, \"\\n\");\n-\tprint_word(ctx, word, count);\n+\tprint_word(ctx, word, nbc);\n+      }\n+  }\n+\n+  void\n+  pretty_print(PrintContext& ctx, const char* str, _Print_func_t print_func)\n+  {\n+    const char cxx1998[] = \"cxx1998::\";\n+    for (;;)\n+      {\n+\tif (auto pos = strstr(str, \"__\"))\n+\t  {\n+\t    if (pos != str)\n+\t      print_func(ctx, str, pos - str);\n+\n+\t    pos += 2; // advance past \"__\"\n+\t    if (memcmp(pos, cxx1998, 9) == 0)\n+\t      pos += 9; // advance part \"cxx1998::\"\n+\n+\t    str = pos;\n+\t  }\n+\telse\n+\t  {\n+\t    print_func(ctx, str, -1);\n+\t    break;\n+\t  }\n       }\n   }\n \n   template<size_t Length>\n     void\n-    print_type(PrintContext& ctx,\n-\t       const type_info* info,\n-\t       const char(&unknown_name)[Length])\n+    print_type_info(PrintContext& ctx,\n+\t\t    const type_info* info,\n+\t\t    const char(&unknown_name)[Length])\n     {\n       if (!info)\n \tprint_literal(ctx, unknown_name);\n@@ -657,135 +684,179 @@ namespace\n \t  int status;\n \t  char* demangled_name =\n \t    __cxxabiv1::__cxa_demangle(info->name(), NULL, NULL, &status);\n-\t  print_word(ctx, status == 0 ? demangled_name : info->name());\n+\t  if (status == 0)\n+\t    pretty_print(ctx, demangled_name, &print_word);\n+\t  else\n+\t    print_word(ctx, info->name());\n \t  free(demangled_name);\n \t}\n     }\n \n+  void\n+  print_address(PrintContext& ctx, const char* fmt, const void* address)\n+  {\n+    char buf[128];\n+    int written = __builtin_sprintf(buf, fmt, address);\n+    print_word(ctx, buf, written);\n+  }\n+\n+  void\n+  print_address(PrintContext& ctx, const void* address)\n+  { print_address(ctx, \"%p\", address); }\n+\n+  void\n+  print_integer(PrintContext& ctx, long integer)\n+  {\n+    char buf[64];\n+    int written = __builtin_sprintf(buf, \"%ld\", integer);\n+    print_word(ctx, buf, written);\n+  }\n+\n+  void\n+  print_named_name(PrintContext& ctx, const _Parameter::_Named& named)\n+  {\n+    assert(named._M_name);\n+    pretty_print(ctx, named._M_name, print_word);\n+  }\n+\n+  template<typename _Iterator>\n+    void\n+    print_iterator_constness(PrintContext& ctx, const _Iterator& iterator)\n+    {\n+      static const char*\n+\tconstness_names[_Error_formatter::__last_constness] =\n+\t{\n+\t \"<unknown constness>\",\n+\t \"constant\",\n+\t \"mutable\"\n+\t};\n+      print_word(ctx, constness_names[iterator._M_constness]);\n+    }\n+\n+  template<typename _Iterator>\n+    void\n+    print_iterator_state(PrintContext& ctx, const _Iterator& iterator)\n+    {\n+      static const char*\n+\tstate_names[_Error_formatter::__last_state] =\n+\t{\n+\t \"<unknown state>\",\n+\t \"singular\",\n+\t \"dereferenceable (start-of-sequence)\",\n+\t \"dereferenceable\",\n+\t \"past-the-end\",\n+\t \"before-begin\",\n+\t \"dereferenceable (start-of-reverse-sequence)\",\n+\t \"dereferenceable (reverse)\",\n+\t \"past-the-reverse-end\"\n+\t};\n+      print_word(ctx, state_names[iterator._M_state]);\n+    }\n+\n+  template<typename _Iterator>\n+    void\n+    print_iterator_seq_type(PrintContext& ctx, const _Iterator& iterator)\n+    { print_type_info(ctx, iterator._M_seq_type, \"<unknown seq_type>\"); }\n+\n   bool\n-  print_field(PrintContext& ctx,\n-\t      const char* name, const _Parameter::_Type& type)\n+  print_named_field(PrintContext& ctx,\n+\t\t    const char* fname, const _Parameter::_Named& named)\n   {\n-    if (__builtin_strcmp(name, \"name\") == 0)\n-      {\n-\tassert(type._M_name);\n-\tprint_word(ctx, type._M_name);\n-      }\n-    else if (__builtin_strcmp(name, \"type\") == 0)\n-      print_type(ctx, type._M_type, \"<unknown type>\");\n+    if (__builtin_strcmp(fname, \"name\") == 0)\n+      print_named_name(ctx, named);\n     else\n       return false;\n \n     return true;\n   }\n \n   bool\n-  print_field(PrintContext& ctx,\n-\t      const char* name, const _Parameter::_Instance& inst)\n+  print_type_field(PrintContext& ctx,\n+\t\t   const char* fname, const _Parameter::_Type& type)\n   {\n-    const _Parameter::_Type& type = inst;\n-    if (print_field(ctx, name, type))\n+    if (print_named_field(ctx, fname, type))\n       { }\n-    else if (__builtin_strcmp(name, \"address\") == 0)\n-      {\n-\tchar buf[64];\n-\tint ret = __builtin_sprintf(buf, \"%p\", inst._M_address);\n-\tprint_word(ctx, buf, ret);\n-      }\n+    else if (__builtin_strcmp(fname, \"type\") == 0)\n+      print_type_info(ctx, type._M_type, \"<unknown type>\");\n+    else\n+      return false;\n+\n+    return true;\n+  }\n+\n+  bool\n+  print_instance_field(PrintContext& ctx,\n+\t\t       const char* fname, const _Parameter::_Instance& inst)\n+  {\n+    if (print_type_field(ctx, fname, inst))\n+      { }\n+    else if (__builtin_strcmp(fname, \"address\") == 0)\n+      print_address(ctx, inst._M_address);\n     else\n       return false;\n \n     return true;\n   }\n \n+  template<typename _Iterator>\n+    bool\n+    print_iterator_field(PrintContext& ctx,\n+\t\t\t const char* fname, const _Iterator& iterator)\n+    {\n+      if (print_instance_field(ctx, fname, iterator))\n+\t{ }\n+      else if (__builtin_strcmp(fname, \"constness\") == 0)\n+\tprint_iterator_constness(ctx, iterator);\n+      else if (__builtin_strcmp(fname, \"state\") == 0)\n+\tprint_iterator_state(ctx, iterator);\n+      else if (__builtin_strcmp(fname, \"sequence\") == 0)\n+\t{\n+\t  assert(iterator._M_sequence);\n+\t  print_address(ctx, iterator._M_sequence);\n+\t}\n+      else if (__builtin_strcmp(fname, \"seq_type\") == 0)\n+\tprint_iterator_seq_type(ctx, iterator);\n+      else\n+\treturn false;\n+\n+      return true;\n+    }\n+\n   void\n-  print_field(PrintContext& ctx, const _Parameter& param, const char* name)\n+  print_field(PrintContext& ctx, const _Parameter& param, const char* fname)\n   {\n     assert(param._M_kind != _Parameter::__unused_param);\n-    const int bufsize = 64;\n-    char buf[bufsize];\n \n     const auto& variant = param._M_variant;\n     switch (param._M_kind)\n     {\n     case _Parameter::__iterator:\n-      {\n-\tconst auto& iterator = variant._M_iterator;\n-\tif (print_field(ctx, name, iterator))\n-\t  { }\n-\telse if (__builtin_strcmp(name, \"constness\") == 0)\n-\t  {\n-\t    static const char*\n-\t      constness_names[_Error_formatter::__last_constness] =\n-\t      {\n-\t\t\"<unknown constness>\",\n-\t\t\"constant\",\n-\t\t\"mutable\"\n-\t      };\n-\t    print_word(ctx, constness_names[iterator._M_constness]);\n-\t  }\n-\telse if (__builtin_strcmp(name, \"state\") == 0)\n-\t  {\n-\t    static const char*\n-\t      state_names[_Error_formatter::__last_state] =\n-\t      {\n-\t\t\"<unknown state>\",\n-\t\t\"singular\",\n-\t\t\"dereferenceable (start-of-sequence)\",\n-\t\t\"dereferenceable\",\n-\t\t\"past-the-end\",\n-\t\t\"before-begin\",\n-\t\t\"dereferenceable (start-of-reverse-sequence)\",\n-\t\t\"dereferenceable (reverse)\",\n-\t\t\"past-the-reverse-end\"\n-\t      };\n-\t    print_word(ctx, state_names[iterator._M_state]);\n-\t  }\n-\telse if (__builtin_strcmp(name, \"sequence\") == 0)\n-\t  {\n-\t    assert(iterator._M_sequence);\n-\t    int written = __builtin_sprintf(buf, \"%p\", iterator._M_sequence);\n-\t    print_word(ctx, buf, written);\n-\t  }\n-\telse if (__builtin_strcmp(name, \"seq_type\") == 0)\n-\t  print_type(ctx, iterator._M_seq_type, \"<unknown seq_type>\");\n-\telse\n-\t  assert(false);\n-      }\n+      if (!print_iterator_field(ctx, fname, variant._M_iterator))\n+\tassert(false);\n       break;\n \n     case _Parameter::__sequence:\n-      if (!print_field(ctx, name, variant._M_sequence))\n+      if (!print_instance_field(ctx, fname, variant._M_sequence))\n \tassert(false);\n       break;\n \n     case _Parameter::__integer:\n-      if (__builtin_strcmp(name, \"name\") == 0)\n-\t{\n-\t  assert(variant._M_integer._M_name);\n-\t  print_word(ctx, variant._M_integer._M_name);\n-\t}\n-      else\n+      if (!print_named_field(ctx, fname, variant._M_integer))\n \tassert(false);\n       break;\n \n     case _Parameter::__string:\n-      if (__builtin_strcmp(name, \"name\") == 0)\n-\t{\n-\t  assert(variant._M_string._M_name);\n-\t  print_word(ctx, variant._M_string._M_name);\n-\t}\n-      else\n+      if (!print_named_field(ctx, fname, variant._M_string))\n \tassert(false);\n       break;\n \n     case _Parameter::__instance:\n-      if (!print_field(ctx, name, variant._M_instance))\n+      if (!print_instance_field(ctx, fname, variant._M_instance))\n \tassert(false);\n       break;\n \n     case _Parameter::__iterator_value_type:\n-      if (!print_field(ctx, name, variant._M_iterator_value_type))\n+      if (!print_type_field(ctx, fname, variant._M_iterator_value_type))\n \tassert(false);\n       break;\n \n@@ -796,55 +867,53 @@ namespace\n   }\n \n   void\n-  print_description(PrintContext& ctx, const _Parameter::_Type& type)\n+  print_quoted_named_name(PrintContext& ctx, const _Parameter::_Named& named)\n   {\n-    if (type._M_name)\n+    if (named._M_name)\n       {\n \tprint_literal(ctx, \"\\\"\");\n-\tprint_word(ctx, type._M_name);\n-\tprint_literal(ctx, \"\\\"\");\n+\tprint_named_name(ctx, named);\n+\tprint_literal(ctx, \"\\\" \");\n       }\n+  }\n \n-    print_literal(ctx, \" {\\n\");\n-\n+  void\n+  print_type_type(PrintContext& ctx, const _Parameter::_Type& type,\n+\t\t  bool close_desc = true)\n+  {\n     if (type._M_type)\n       {\n \tprint_literal(ctx, \"  type = \");\n-\tprint_type(ctx, type._M_type, \"<unknown type>\");\n-\tprint_literal(ctx, \";\\n\");\n+\tprint_type_info(ctx, type._M_type, \"<unknown type>\");\n+\tif (close_desc)\n+\t  print_literal(ctx, \";\\n\");\n       }\n   }\n \n   void\n-  print_description(PrintContext& ctx, const _Parameter::_Instance& inst)\n+  print_type(PrintContext& ctx, const _Parameter::_Type& type)\n   {\n-    const int bufsize = 64;\n-    char buf[bufsize];\n-\n-    if (inst._M_name)\n-      {\n-\tprint_literal(ctx, \"\\\"\");\n-\tprint_word(ctx, inst._M_name);\n-\tprint_literal(ctx, \"\\\" \");\n-      }\n+    print_quoted_named_name(ctx, type);\n+    print_literal(ctx, \" {\\n\");\n+    print_type_type(ctx, type);\n+    print_literal(ctx, \"}\\n\");\n+  }\n \n-    int written\n-      = __builtin_sprintf(buf, \"@ 0x%p {\\n\", inst._M_address);\n-    print_word(ctx, buf, written);\n+  void\n+  print_instance(PrintContext& ctx, const _Parameter::_Instance& inst,\n+\t\t bool close_desc = true)\n+  {\n+    print_quoted_named_name(ctx, inst);\n+    print_address(ctx, \"@ %p {\\n\", inst._M_address);\n+    print_type_type(ctx, inst, close_desc);\n \n-    if (inst._M_type)\n-      {\n-\tprint_literal(ctx, \"  type = \");\n-\tprint_type(ctx, inst._M_type, \"<unknown type>\");\n-      }\n+    if (close_desc)\n+      print_literal(ctx, \"}\\n\");\n   }\n \n   void\n   print_description(PrintContext& ctx, const _Parameter& param)\n   {\n-    const int bufsize = 128;\n-    char buf[bufsize];\n-\n     const auto& variant = param._M_variant;\n     switch (param._M_kind)\n       {\n@@ -853,14 +922,14 @@ namespace\n \t  const auto& ite = variant._M_iterator;\n \n \t  print_literal(ctx, \"iterator \");\n-\t  print_description(ctx, ite);\n+\t  print_instance(ctx, ite, false);\n \n \t  if (ite._M_type)\n \t    {\n \t      if (ite._M_constness != _Error_formatter::__unknown_constness)\n \t\t{\n \t\t  print_literal(ctx, \" (\");\n-\t\t  print_field(ctx, param, \"constness\");\n+\t\t  print_iterator_constness(ctx, ite);\n \t\t  print_literal(ctx, \" iterator)\");\n \t\t}\n \n@@ -870,7 +939,7 @@ namespace\n \t  if (ite._M_state != _Error_formatter::__unknown_state)\n \t    {\n \t      print_literal(ctx, \"  state = \");\n-\t      print_field(ctx, param, \"state\");\n+\t      print_iterator_state(ctx, ite);\n \t      print_literal(ctx, \";\\n\");\n \t    }\n \n@@ -880,13 +949,11 @@ namespace\n \t      if (ite._M_seq_type)\n \t\t{\n \t\t  print_literal(ctx, \"with type '\");\n-\t\t  print_field(ctx, param, \"seq_type\");\n+\t\t  print_iterator_seq_type(ctx, ite);\n \t\t  print_literal(ctx, \"' \");\n \t\t}\n \n-\t      int written\n-\t\t= __builtin_sprintf(buf, \"@ 0x%p\\n\", ite._M_sequence);\n-\t      print_word(ctx, buf, written);\n+\t      print_address(ctx, \"@ %p\\n\", ite._M_sequence);\n \t    }\n \n \t  print_literal(ctx, \"}\\n\");\n@@ -895,28 +962,17 @@ namespace\n \n       case _Parameter::__sequence:\n \tprint_literal(ctx, \"sequence \");\n-\tprint_description(ctx, variant._M_sequence);\n-\n-\tif (variant._M_sequence._M_type)\n-\t  print_literal(ctx, \";\\n\");\n-\n-\tprint_literal(ctx, \"}\\n\");\n+\tprint_instance(ctx, variant._M_sequence);\n \tbreak;\n \n       case _Parameter::__instance:\n \tprint_literal(ctx, \"instance \");\n-\tprint_description(ctx, variant._M_instance);\n-\n-\tif (variant._M_instance._M_type)\n-\t  print_literal(ctx, \";\\n\");\n-\n-\tprint_literal(ctx, \"}\\n\");\n+\tprint_instance(ctx, variant._M_instance);\n \tbreak;\n \n       case _Parameter::__iterator_value_type:\n \tprint_literal(ctx, \"iterator::value_type \");\n-\tprint_description(ctx, variant._M_iterator_value_type);\n-\tprint_literal(ctx, \"}\\n\");\n+\tprint_type(ctx, variant._M_iterator_value_type);\n \tbreak;\n \n       default:\n@@ -925,98 +981,96 @@ namespace\n   }\n \n   void\n-  print_string(PrintContext& ctx, const char* string,\n+  print_string(PrintContext& ctx, const char* str, ptrdiff_t nbc,\n \t       const _Parameter* parameters, std::size_t num_parameters)\n   {\n-    const char* start = string;\n-    const int bufsize = 128;\n-    char buf[bufsize];\n-    int bufindex = 0;\n+    const char* start = str;\n+    const char* end = nbc >= 0 ? start + nbc : nullptr;\n \n-    while (*start)\n+    while ((end && str != end) || (!end && *str))\n       {\n-\tif (isspace(*start))\n+\tif (isspace((unsigned char)*str))\n \t  {\n-\t    buf[bufindex++] = *start++;\n-\t    buf[bufindex] = '\\0';\n-\t    print_word(ctx, buf, bufindex);\n-\t    bufindex = 0;\n+\t    ++str;\n+\t    print_word(ctx, start, str - start);\n+\t    start = str;\n \t    continue;\n \t  }\n \n-\tif (!num_parameters || *start != '%')\n+\tif (!parameters || *str != '%')\n \t  {\n \t    // Normal char or no parameter to look for.\n-\t    buf[bufindex++] = *start++;\n+\t    ++str;\n \t    continue;\n \t  }\n \n-\tif (*++start == '%')\n+\tif (*++str == '%')\n \t  {\n \t    // Escaped '%'\n-\t    buf[bufindex++] = *start++;\n+\t    print_word(ctx, start, str - start);\n+\t    ++str;\n+\t    start = str;\n \t    continue;\n \t  }\n \n \t// We are on a parameter property reference, we need to flush buffer\n \t// first.\n-\tif (bufindex != 0)\n+\tif (str != start)\n \t  {\n-\t    buf[bufindex] = '\\0';\n-\t    print_word(ctx, buf, bufindex);\n-\t    bufindex = 0;\n+\t    // Avoid printing the '%'.\n+\t    if (str - start > 1)\n+\t      print_word(ctx, start, str - start - 1);\n+\t    start = str;\n \t  }\n \n \t// Get the parameter number\n-\tassert(*start >= '1' && *start <= '9');\n-\tsize_t param_index = *start - '0' - 1;\n+\tassert(*str >= '1' && *str <= '9');\n+\tsize_t param_index = *str - '0' - 1;\n \tassert(param_index < num_parameters);\n \tconst auto& param = parameters[param_index];\n \n \t// '.' separates the parameter number from the field\n \t// name, if there is one.\n-\t++start;\n-\tif (*start != '.')\n+\t++str;\n+\tif (*str != '.')\n \t  {\n-\t    assert(*start == ';');\n-\t    ++start;\n+\t    assert(*str == ';');\n+\t    ++str;\n \t    if (param._M_kind == _Parameter::__integer)\n-\t      {\n-\t\tint written\n-\t\t  = __builtin_sprintf(buf, \"%ld\",\n-\t\t\t\t      param._M_variant._M_integer._M_value);\n-\t\tprint_word(ctx, buf, written);\n-\t      }\n+\t      print_integer(ctx, param._M_variant._M_integer._M_value);\n \t    else if (param._M_kind == _Parameter::__string)\n-\t      print_string(ctx, param._M_variant._M_string._M_value,\n+\t      print_string(ctx, param._M_variant._M_string._M_value, -1,\n \t\t\t   parameters, num_parameters);\n+\t    start = str;\n \t    continue;\n \t  }\n \n \t// Extract the field name we want\n \tconst int max_field_len = 16;\n \tchar field[max_field_len];\n \tint field_idx = 0;\n-\t++start;\n-\twhile (*start != ';')\n+\t++str;\n+\twhile (*str != ';')\n \t  {\n-\t    assert(*start);\n+\t    assert(*str);\n \t    assert(field_idx < max_field_len - 1);\n-\t    field[field_idx++] = *start++;\n+\t    field[field_idx++] = *str++;\n \t  }\n-\t++start;\n+\t++str;\n \tfield[field_idx] = '\\0';\n \n \tprint_field(ctx, param, field);\n+\tstart = str;\n       }\n \n     // Might need to flush.\n-    if (bufindex)\n-      {\n-\tbuf[bufindex] = '\\0';\n-\tprint_word(ctx, buf, bufindex);\n-      }\n+    if (str != start)\n+      print_word(ctx, start, str - start);\n   }\n+\n+  void\n+  print_string(PrintContext& ctx, const char* str, ptrdiff_t nbc)\n+  { print_string(ctx, str, nbc, nullptr, 0); }\n }\n \n namespace __gnu_debug\n@@ -1036,16 +1090,15 @@ namespace __gnu_debug\n     PrintContext ctx;\n     if (_M_file)\n       {\n-\tprint_word(ctx, _M_file);\n+\tprint_raw(ctx, _M_file);\n \tprint_literal(ctx, \":\");\n \tgo_to_next_line = true;\n       }\n \n     if (_M_line > 0)\n       {\n-\tchar buf[64];\n-\tint written = __builtin_sprintf(buf, \"%u:\", _M_line);\n-\tprint_word(ctx, buf, written);\n+\tctx._M_column += fprintf(stderr, \"%u\", _M_line);\n+\tprint_literal(ctx, \":\");\n \tgo_to_next_line = true;\n       }\n \n@@ -1058,41 +1111,17 @@ namespace __gnu_debug\n     if (_M_function)\n       {\n \tprint_literal(ctx, \"In function:\\n\");\n-\tprint_string(ctx, _M_function, nullptr, 0);\n+\tpretty_print(ctx, _M_function, &print_string);\n \tprint_literal(ctx, \"\\n\");\n \tctx._M_first_line = true;\n \tprint_literal(ctx, \"\\n\");\n       }\n \n-// libstdc++/85768\n-#if 0 //defined _GLIBCXX_HAVE_EXECINFO_H\n-    {\n-      void* stack[32];\n-      int nb = backtrace(stack, 32);\n-\n-      // Note that we skip current method symbol.\n-      if (nb > 1)\n-\t{\n-\t  print_literal(ctx, \"Backtrace:\\n\");\n-\t  auto symbols = backtrace_symbols(stack, nb);\n-\t  for (int i = 1; i < nb; ++i)\n-\t    {\n-\t      print_word(ctx, symbols[i]);\n-\t      print_literal(ctx, \"\\n\");\n-\t    }\n-\n-\t  free(symbols);\n-\t  ctx._M_first_line = true;\n-\t  print_literal(ctx, \"\\n\");\n-\t}\n-    }\n-#endif\n-\n     print_literal(ctx, \"Error: \");\n \n     // Print the error message\n     assert(_M_text);\n-    print_string(ctx, _M_text, _M_parameters, _M_num_parameters);\n+    print_string(ctx, _M_text, -1, _M_parameters, _M_num_parameters);\n     print_literal(ctx, \".\\n\");\n \n     // Emit descriptions of the objects involved in the operation"}]}