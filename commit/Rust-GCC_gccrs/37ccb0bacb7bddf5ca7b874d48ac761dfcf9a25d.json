{"sha": "37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdjY2IwYmFjYjdiZGRmNWNhN2I4NzRkNDhhYzc2MWRmY2Y5YTI1ZA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2016-07-12T13:32:04Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-07-12T13:32:04Z"}, "message": "re PR tree-optimization/23286 (Missed code hoisting optimization)\n\n2016-07-12  Steven Bosscher  <steven@gcc.gnu.org>\n\tRichard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/23286\n\tPR tree-optimization/70159\n\t* doc/invoke.texi: Document -fcode-hoisting.\n\t* common.opt (fcode-hoisting): New flag.\n\t* opts.c (default_options_table): Enable -fcode-hoisting at -O2+.\n\t* tree-ssa-pre.c (pre_stats): Add hoist_insert.\n\t(do_regular_insertion): Rename to ...\n\t(do_pre_regular_insertion): ... this and amend general comments\n\ton insertion strathegy.\n\t(do_partial_partial_insertion): Rename to ...\n\t(do_pre_partial_partial_insertion): ... this.\n\t(do_hoist_insertion): New function.\n\t(insert_aux): Take flags on whether to do PRE and/or hoist insertion\n\tand call do_hoist_insertion properly.\n\t(insert): Adjust.\n\t(pass_pre::gate): Enable also if -fcode-hoisting is enabled.\n\t(pass_pre::execute): Register hoist_insert stats.\n\n\t* gcc.dg/tree-ssa/ssa-pre-11.c: Disable code hosting.\n\t* gcc.dg/tree-ssa/ssa-pre-27.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-28.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-pre-2.c: Likewise.\n\t* gcc.dg/tree-ssa/pr35286.c: Likewise.\n\t* gcc.dg/tree-ssa/pr35287.c: Likewise.\n\t* gcc.dg/hoist-register-pressure-1.c: Likewise.\n\t* gcc.dg/hoist-register-pressure-2.c: Likewise.\n\t* gcc.dg/hoist-register-pressure-3.c: Likewise.\n\t* gcc.dg/pr51879-12.c: Likewise.\n\t* gcc.dg/strlenopt-9.c: Likewise.\n\t* gcc.dg/tree-ssa/pr47392.c: Likewise.\n\t* gcc.dg/tree-ssa/pr68619-4.c: Likewise.\n\t* gcc.dg/tree-ssa/split-path-5.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-35.c: Likewise.\n\t* gcc.dg/tree-ssa/slsr-36.c: Likewise.\n\t* gcc.dg/tree-ssa/loadpre3.c: Adjust so hosting doesn't apply.\n\t* gcc.dg/tree-ssa/pr43491.c: Scan optimized dump for desired result.\n\t* gcc.dg/tree-ssa/ssa-pre-31.c: Adjust expected outcome for hoisting.\n\t* gcc.dg/tree-ssa/ssa-hoist-1.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-hoist-2.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-hoist-3.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-hoist-4.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-hoist-5.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-hoist-6.c: New testcase.\n\t* gfortran.dg/pr43984.f90: Adjust expected outcome.\n\nCo-Authored-By: Richard Biener <rguenther@suse.de>\n\nFrom-SVN: r238242", "tree": {"sha": "6abcd421d94eda4e2087e401999ef351607df2c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6abcd421d94eda4e2087e401999ef351607df2c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/comments", "author": null, "committer": null, "parents": [{"sha": "1de3c940d8782eae7739a6c6f7327e99eee63cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de3c940d8782eae7739a6c6f7327e99eee63cce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de3c940d8782eae7739a6c6f7327e99eee63cce"}], "stats": {"total": 495, "additions": 447, "deletions": 48}, "files": [{"sha": "8776f744ce5a5e79c2b12350efd8a129b2195af4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,3 +1,24 @@\n+2016-07-12  Steven Bosscher  <steven@gcc.gnu.org>\n+\tRichard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/23286\n+\tPR tree-optimization/70159\n+\t* doc/invoke.texi: Document -fcode-hoisting.\n+\t* common.opt (fcode-hoisting): New flag.\n+\t* opts.c (default_options_table): Enable -fcode-hoisting at -O2+.\n+\t* tree-ssa-pre.c (pre_stats): Add hoist_insert.\n+\t(do_regular_insertion): Rename to ...\n+\t(do_pre_regular_insertion): ... this and amend general comments\n+\ton insertion strathegy.\n+\t(do_partial_partial_insertion): Rename to ...\n+\t(do_pre_partial_partial_insertion): ... this.\n+\t(do_hoist_insertion): New function.\n+\t(insert_aux): Take flags on whether to do PRE and/or hoist insertion\n+\tand call do_hoist_insertion properly.\n+\t(insert): Adjust.\n+\t(pass_pre::gate): Enable also if -fcode-hoisting is enabled.\n+\t(pass_pre::execute): Register hoist_insert stats.\n+\n 2016-07-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/71716"}, {"sha": "2b68fa7bdee090b1ff4737b815079c789d752c61", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1038,6 +1038,10 @@ fchecking=\n Common Joined RejectNegative UInteger Var(flag_checking)\n Perform internal consistency checkings.\n \n+fcode-hoisting\n+Common Report Var(flag_code_hoisting) Optimization\n+Enable code hoisting.\n+\n fcombine-stack-adjustments\n Common Report Var(flag_combine_stack_adjustments) Optimization\n Looks for opportunities to reduce stack adjustments and stack references."}, {"sha": "997faa15b6e4e8dc938bad5b8b249f3870598990", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -404,7 +404,7 @@ Objective-C and Objective-C++ Dialects}.\n -fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol\n -ftree-builtin-call-dce -ftree-ccp -ftree-ch @gol\n -ftree-coalesce-vars -ftree-copy-prop -ftree-dce -ftree-dominator-opts @gol\n--ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol\n+-ftree-dse -ftree-forwprop -ftree-fre -fcode-hoisting -ftree-loop-if-convert @gol\n -ftree-loop-if-convert-stores -ftree-loop-im @gol\n -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol\n -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol\n@@ -6380,6 +6380,7 @@ also turns on the following optimization flags:\n -fstrict-aliasing -fstrict-overflow @gol\n -ftree-builtin-call-dce @gol\n -ftree-switch-conversion -ftree-tail-merge @gol\n+-fcode-hoisting @gol\n -ftree-pre @gol\n -ftree-vrp @gol\n -fipa-ra}\n@@ -7273,6 +7274,14 @@ and the @option{large-stack-frame-growth} parameter to 400.\n Perform reassociation on trees.  This flag is enabled by default\n at @option{-O} and higher.\n \n+@item -fcode-hoisting\n+@opindex fcode-hoisting\n+Perform code hoisting.  Code hoisting tries to move the\n+evaluation of expressions executed on all paths to the function exit\n+as early as possible.  This is especially useful as a code size\n+optimization, but it often helps for code speed as well.\n+This flag is enabled by defailt at @option{-O2} and higher.\n+\n @item -ftree-pre\n @opindex ftree-pre\n Perform partial redundancy elimination (PRE) on trees.  This flag is\n@@ -12230,8 +12239,8 @@ Dump each function after STORE-CCP@.  The file name is made by appending\n \n @item pre\n @opindex fdump-tree-pre\n-Dump trees after partial redundancy elimination.  The file name is made\n-by appending @file{.pre} to the source file name.\n+Dump trees after partial redundancy elimination and/or code hoisting.\n+The file name is made by appending @file{.pre} to the source file name.\n \n @item fre\n @opindex fdump-tree-fre"}, {"sha": "4053fb1db0a9a814a5623e0604619fbe068b37ab", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -500,6 +500,7 @@ static const struct default_options default_options_table[] =\n       REORDER_BLOCKS_ALGORITHM_STC },\n     { OPT_LEVELS_2_PLUS, OPT_freorder_functions, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_vrp, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fcode_hoisting, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_pre, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_switch_conversion, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_cp, NULL, 1 },"}, {"sha": "7dd3c92c4fc8e17ddf9d0a42a130a7336d0d4a1b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,3 +1,35 @@\n+2016-07-12  Steven Bosscher  <steven@gcc.gnu.org>\n+\tRichard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/23286\n+\tPR tree-optimization/70159\n+\t* gcc.dg/tree-ssa/ssa-pre-11.c: Disable code hosting.\n+\t* gcc.dg/tree-ssa/ssa-pre-27.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-28.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-pre-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr35286.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr35287.c: Likewise.\n+\t* gcc.dg/hoist-register-pressure-1.c: Likewise.\n+\t* gcc.dg/hoist-register-pressure-2.c: Likewise.\n+\t* gcc.dg/hoist-register-pressure-3.c: Likewise.\n+\t* gcc.dg/pr51879-12.c: Likewise.\n+\t* gcc.dg/strlenopt-9.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr47392.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr68619-4.c: Likewise.\n+\t* gcc.dg/tree-ssa/split-path-5.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-35.c: Likewise.\n+\t* gcc.dg/tree-ssa/slsr-36.c: Likewise.\n+\t* gcc.dg/tree-ssa/loadpre3.c: Adjust so hosting doesn't apply.\n+\t* gcc.dg/tree-ssa/pr43491.c: Scan optimized dump for desired result.\n+\t* gcc.dg/tree-ssa/ssa-pre-31.c: Adjust expected outcome for hoisting.\n+\t* gcc.dg/tree-ssa/ssa-hoist-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-hoist-2.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-hoist-3.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-hoist-4.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-hoist-5.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-hoist-6.c: New testcase.\n+\t* gfortran.dg/pr43984.f90: Adjust expected outcome.\n+\n 2016-07-12  Richard Biener  <rguenther@suse.de>\n \n \tPR rtl-optimization/68961"}, {"sha": "6e566da4dba4ba78a57f2cf4a014611323994f48", "filename": "gcc/testsuite/gcc.dg/hoist-register-pressure-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-1.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-Os -fdump-rtl-hoist\" }  */\n+/* { dg-options \"-Os -fdump-rtl-hoist -fno-code-hoisting\" }  */\n /* The rtl hoist pass requires that the expression to be hoisted can\n    be assigned without clobbering cc.  For a PLUS rtx on S/390 this\n    requires a load address instruction which is fine on 64 bit but"}, {"sha": "05ffd8d93f0abcb21ac192e2b6308a53069acced", "filename": "gcc/testsuite/gcc.dg/hoist-register-pressure-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-2.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-Os -fdump-rtl-hoist\" }  */\n+/* { dg-options \"-Os -fdump-rtl-hoist -fno-code-hoisting\" }  */\n /* The rtl hoist pass requires that the expression to be hoisted can\n    be assigned without clobbering cc.  For a PLUS rtx on S/390 this\n    requires a load address instruction which is fine on 64 bit but"}, {"sha": "f274fa133454467c34b6f9e1e294a524941a231e", "filename": "gcc/testsuite/gcc.dg/hoist-register-pressure-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fhoist-register-pressure-3.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-options \"-Os -fdump-rtl-hoist\" }  */\n+/* { dg-options \"-Os -fdump-rtl-hoist -fno-code-hoisting\" }  */\n /* The rtl hoist pass requires that the expression to be hoisted can\n    be assigned without clobbering cc.  For a PLUS rtx on S/390 this\n    requires a load address instruction which is fine on 64 bit but"}, {"sha": "1aa490791bc224cbf25beeb44c5e7864d331c5d1", "filename": "gcc/testsuite/gcc.dg/pr51879-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr51879-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr51879-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr51879-12.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -ftree-tail-merge -fdump-tree-pre\" } */\n+/* { dg-options \"-O2 -ftree-tail-merge -fdump-tree-pre -fno-code-hoisting\" } */\n \n __attribute__((pure)) int bar (int);\n __attribute__((pure)) int bar2 (int);"}, {"sha": "f78defe6287cee9e9ed4779c70675e91c6541d40", "filename": "gcc/testsuite/gcc.dg/strlenopt-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-9.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fdump-tree-strlen -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-strlen -fdump-tree-optimized\" } */\n \n #include \"strlenopt.h\"\n "}, {"sha": "1fff6486423275aa119094bdaa5b7c988dd09415", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre3.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre3.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+extern void spoil (void);\n+\n int foo(int **a,int argc)\n {\n   int b;\n@@ -11,7 +14,8 @@ int foo(int **a,int argc)\n     }\n   else\n     {\n-\n+      /* Spoil *a and *(*a) to avoid hoisting it before the \"if (...)\".  */\n+      spoil ();\n     }\n   /* Should be able to eliminate one of the *(*a)'s along the if path\n      by pushing it into the else path. We will also eliminate"}, {"sha": "8f683fbd1623e8e7e6136da155a48e5ca6655dea", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr35286.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35286.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35286.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35286.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-pre-stats\" } */\n int g2;\n struct A {\n     int a; int b;"}, {"sha": "b091ba85cc384610842e1ee91a2951dc94230d0c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr35287.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35287.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35287.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr35287.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-pre-stats\" } */\n int *gp;\n int foo(int p)\n {"}, {"sha": "6effb77e20e5ea3decf8dd39f8bf1e7f8cc07740", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr43491.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr43491.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr43491.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr43491.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n \n #define REGISTER register\n \n@@ -35,7 +35,11 @@ long foo(long data, long v)\n \tu = i;\n \treturn v * t * u;\n }\n+\n /* We should not eliminate global register variable when it is the RHS of\n-   a single assignment.  */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\" { target { arm*-*-* i?86-*-* mips*-*-* x86_64-*-* } } } } */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 3\" 1 \"pre\" { target { ! { arm*-*-* i?86-*-* mips*-*-* x86_64-*-* } } } } } */\n+   a single assignment.  So the number of loads from data_0 has to match\n+   that of the number of adds (we hoist data_0 + data_3 above the\n+   if (data) and eliminate the useless copy).  */\n+\n+/* { dg-final { scan-tree-dump-times \"= data_0;\" 1 \"optimized\" { target { arm*-*-* i?86-*-* mips*-*-* x86_64-*-* } } } } */\n+/* { dg-final { scan-tree-dump-times \" \\\\+ \" 1 \"optimized\" { target { ! { arm*-*-* i?86-*-* mips*-*-* x86_64-*-* } } } } } */"}, {"sha": "60a78a4609c922b148fd56f0c579d7e812cd916c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr47392.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr47392.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr47392.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr47392.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run } */\n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-pre-stats\" } */\n \n struct A\n {"}, {"sha": "8ce7ad1c5cb0f244718ad56a16acb77221882558", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68619-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68619-4.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized -w\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-optimized -w\" } */\n \n typedef struct rtx_def *rtx;\n enum rtx_code"}, {"sha": "9a7d8d5d253791601efd1c20f5aa91f2b6b96673", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-35.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-35.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -3,7 +3,7 @@\n    phi has an argument which is a parameter.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O3 -fno-code-hoisting -fdump-tree-optimized\" } */\n \n int\n f (int c, int i)"}, {"sha": "1ab357d11c04868eb846d3cdf6ac4add7c0e0e89", "filename": "gcc/testsuite/gcc.dg/tree-ssa/slsr-36.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fslsr-36.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -3,7 +3,7 @@\n    phi has an argument which is a parameter.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O3 -fno-code-hoisting -fdump-tree-optimized\" } */\n \n int\n f (int s, int c, int i)"}, {"sha": "dec64165eb1436dfe3fd2f8f52b9e22b3cfcec36", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-1.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre\" } */\n+\n+unsigned short f(unsigned short a)\n+{\n+  if (a & 0x8000)\n+    a <<= 1, a = a ^ 0x1021;\n+  else\n+    a <<= 1;\n+\n+  return a;\n+}\n+\n+/* We should hoist and CSE the shift.  */\n+\n+/* { dg-final { scan-tree-dump-times \" << 1;\" 1 \"pre\" } } */"}, {"sha": "0baec081418a0cd44a172e9d05e3b1647f4e5efb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-2.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre\" } */\n+\n+int f(int i)\n+{\n+  if (i < 0)\n+    return i/10+ i;\n+  return i/10 + i;\n+}\n+\n+/* Hoisting of i/10 + i should make the code straight-line\n+   with one division.  */\n+\n+/* { dg-final { scan-tree-dump-times \"goto\" 0 \"pre\" } } */\n+/* { dg-final { scan-tree-dump-times \" / 10;\" 1 \"pre\" } } */"}, {"sha": "51ba59c9ab6b39430177c91a779228a5154c46ce", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-3.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+int test (int a, int b, int c, int g)\n+{\n+  int d, e;\n+  if (a)\n+    d = b * c;\n+  else\n+    d = b - c;\n+  e = b * c + g;\n+  return d + e;\n+}\n+\n+/* We should hoist and CSE only the multiplication.  */\n+\n+/* { dg-final { scan-tree-dump-times \" \\\\* \" 1 \"pre\" } } */\n+/* { dg-final { scan-tree-dump \"Insertions: 1\" \"pre\" } } */"}, {"sha": "fa206e67357a258d4ee4bceb1521f32834bc4f96", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-4.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+/* From PR21485.  */\n+\n+long\n+NumSift (long *array, int b, unsigned long k)\n+{\n+  if (b)\n+    if (array[k] < array[k + 1L])\n+      ++k;\n+  return array[k];\n+}\n+\n+/* There should be only two loads left.  And the final value in the\n+   if (b) arm should be if-converted:\n+     tem1 = array[k];\n+     if (b)\n+       tem1 = MAX (array[k+1], tem1)\n+     return tem1;  */\n+\n+/* { dg-final { scan-tree-dump-times \"= \\\\*\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"= PHI\" 1 \"optimized\" } } */"}, {"sha": "0ddaa0d87fdd0e9d0ad55dd0ac807592be260106", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-hoist-6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-hoist-6.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+\n+int a[1024];\n+int b[1024], c[1024];\n+void foo ()\n+{\n+  for (int j = 0; j < 1024; ++j)\n+    {\n+      for (int i = 0; i < 1024; ++i)\n+\ta[i] = j;\n+      b[j] = c[j];\n+    }\n+}\n+\n+/* We should not hoist/PRE the outer loop IV increment or the load\n+   from c across the inner loop.  */\n+\n+/* { dg-final { scan-tree-dump-not \"HOIST inserted\" \"pre\" } } */"}, {"sha": "5483ac4e0228cab59f0b17b0a9ded33d70d2851a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-11.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-pre-stats\" } */\n double cos (double);\n double f(double a)\n {"}, {"sha": "a8f9d817fa801b380dbe928f915ac3b33bb8bc18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-2.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+/* { dg-options \"-O2 -fno-code-hoisting -fdump-tree-pre-stats\" } */\n int motion_test1(int data, int data_0, int data_3, int v)\n {\n \tint i;"}, {"sha": "2882419a998bb9fea97da3a881326bba0c7481bf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-27.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-27.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-pre\" } */\n+/* { dg-options \"-O2 -fdump-tree-pre -fno-code-hoisting\" } */\n \n int foo (int i, int j, int b)\n {"}, {"sha": "aad3f3969d1a5dfba80a4492ee975507491a816b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-28.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-28.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,6 +1,6 @@\n /* PR37997 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-pre-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-pre-details -fno-code-hoisting\" } */\n \n int foo (int i, int b, int result)\n {\n@@ -16,5 +16,7 @@ int foo (int i, int b, int result)\n \n /* We should insert i + 1 into the if (b) path as well as the simplified\n    i + 1 & -2 expression.  And do replacement with two PHI temps.  */\n+/* With hoisting enabled we'd hoist i + 1 to before the if, retaining\n+   only one PHI node.  */\n \n /* { dg-final { scan-tree-dump-times \"with prephitmp\" 2 \"pre\" } } */"}, {"sha": "0dface557bec41bd150accf81efe524e6287d17a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-31.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-31.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -43,4 +43,4 @@ int foo (S1 *root, int N)\n   return 0;\n } \n \n-/* { dg-final { scan-tree-dump-times \"key\" 4 \"pre\" } } */\n+/* { dg-final { scan-tree-dump-times \"key\" 3 \"pre\" } } */"}, {"sha": "130d114462c75d33455c20f759e0ba2fbd8a7360", "filename": "gcc/testsuite/gfortran.dg/pr43984.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43984.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43984.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr43984.f90?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -50,6 +50,6 @@ subroutine make_esss(self,esss)\n \n end\n \n-! There should be three loads from iyz.data, not four.\n+! There should be two loads from iyz.data, not four.\n \n-! { dg-final { scan-tree-dump-times \"= iyz.data\" 3 \"pre\" } }\n+! { dg-final { scan-tree-dump-times \"= iyz.data\" 2 \"pre\" } }"}, {"sha": "a5f3f712da1a69111024f7290a954469efc2dfaf", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 252, "deletions": 22, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=37ccb0bacb7bddf5ca7b874d48ac761dfcf9a25d", "patch": "@@ -1,4 +1,4 @@\n-/* SSA-PRE for trees.\n+/* Full and partial redundancy elimination and code hoisting on SSA GIMPLE.\n    Copyright (C) 2001-2016 Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@dberlin.org> and Steven Bosscher\n    <stevenb@suse.de>\n@@ -55,11 +55,32 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"alias.h\"\n \n+/* Even though this file is called tree-ssa-pre.c, we actually\n+   implement a bit more than just PRE here.  All of them piggy-back\n+   on GVN which is implemented in tree-ssa-sccvn.c.\n+\n+     1. Full Redundancy Elimination (FRE)\n+\tThis is the elimination phase of GVN.\n+\n+     2. Partial Redundancy Elimination (PRE)\n+\tThis is adds computation of AVAIL_OUT and ANTIC_IN and\n+\tdoing expression insertion to form GVN-PRE.\n+\n+     3. Code hoisting\n+\tThis optimization uses the ANTIC_IN sets computed for PRE\n+\tto move expressions further up than PRE would do, to make\n+\tmultiple computations of the same value fully redundant.\n+\tThis pass is explained below (after the explanation of the\n+\tbasic algorithm for PRE).\n+*/\n+\n /* TODO:\n \n    1. Avail sets can be shared by making an avail_find_leader that\n       walks up the dominator tree and looks in those avail sets.\n       This might affect code optimality, it's unclear right now.\n+      Currently the AVAIL_OUT sets are the remaining quadraticness in\n+      memory of GVN-PRE.\n    2. Strength reduction can be performed by anticipating expressions\n       we can repair later on.\n    3. We can do back-substitution or smarter value numbering to catch\n@@ -71,7 +92,7 @@ along with GCC; see the file COPYING3.  If not see\n    represent the actual statement containing the expressions we care about,\n    and we cache the value number by putting it in the expression.  */\n \n-/* Basic algorithm\n+/* Basic algorithm for Partial Redundancy Elimination:\n \n    First we walk the statements to generate the AVAIL sets, the\n    EXP_GEN sets, and the tmp_gen sets.  EXP_GEN sets represent the\n@@ -111,17 +132,75 @@ along with GCC; see the file COPYING3.  If not see\n    In order to make it fully redundant, we insert the expression into\n    the predecessors where it is not available, but is ANTIC.\n \n+   When optimizing for size, we only eliminate the partial redundancy\n+   if we need to insert in only one predecessor.  This avoids almost\n+   completely the code size increase that PRE usually causes.\n+\n    For the partial anticipation case, we only perform insertion if it\n    is partially anticipated in some block, and fully available in all\n    of the predecessors.\n \n-   insert/insert_aux/do_regular_insertion/do_partial_partial_insertion\n-   performs these steps.\n+   do_pre_regular_insertion/do_pre_partial_partial_insertion\n+   performs these steps, driven by insert/insert_aux.\n \n    Fourth, we eliminate fully redundant expressions.\n    This is a simple statement walk that replaces redundant\n    calculations with the now available values.  */\n \n+/* Basic algorithm for Code Hoisting:\n+\n+   Code hoisting is: Moving value computations up in the control flow\n+   graph to make multiple copies redundant.  Typically this is a size\n+   optimization, but there are cases where it also is helpful for speed.\n+\n+   A simple code hoisting algorithm is implemented that piggy-backs on\n+   the PRE infrastructure.  For code hoisting, we have to know ANTIC_OUT\n+   which is effectively ANTIC_IN - AVAIL_OUT.  The latter two have to be\n+   computed for PRE, and we can use them to perform a limited version of\n+   code hoisting, too.\n+\n+   For the purpose of this implementation, a value is hoistable to a basic\n+   block B if the following properties are met:\n+\n+   1. The value is in ANTIC_IN(B) -- the value will be computed on all\n+      paths from B to function exit and it can be computed in B);\n+\n+   2. The value is not in AVAIL_OUT(B) -- there would be no need to\n+      compute the value again and make it available twice;\n+\n+   3. All successors of B are dominated by B -- makes sure that inserting\n+      a computation of the value in B will make the remaining\n+      computations fully redundant;\n+\n+   4. At least one successor has the value in AVAIL_OUT -- to avoid\n+      hoisting values up too far;\n+\n+   5. There are at least two successors of B -- hoisting in straight\n+      line code is pointless.\n+\n+   The third condition is not strictly necessary, but it would complicate\n+   the hoisting pass a lot.  In fact, I don't know of any code hoisting\n+   algorithm that does not have this requirement.  Fortunately, experiments\n+   have show that most candidate hoistable values are in regions that meet\n+   this condition (e.g. diamond-shape regions).\n+\n+   The forth condition is necessary to avoid hoisting things up too far\n+   away from the uses of the value.  Nothing else limits the algorithm\n+   from hoisting everything up as far as ANTIC_IN allows.  Experiments\n+   with SPEC and CSiBE have shown that hoisting up too far results in more\n+   spilling, less benefits for code size, and worse benchmark scores.\n+   Fortunately, in practice most of the interesting hoisting opportunities\n+   are caught despite this limitation.\n+\n+   For hoistable values that meet all conditions, expressions are inserted\n+   to make the calculation of the hoistable value fully redundant.  We\n+   perform code hoisting insertions after each round of PRE insertions,\n+   because code hoisting never exposes new PRE opportunities, but PRE can\n+   create new code hoisting opportunities.\n+\n+   The code hoisting algorithm is implemented in do_hoist_insert, driven\n+   by insert/insert_aux.  */\n+\n /* Representations of value numbers:\n \n    Value numbers are represented by a representative SSA_NAME.  We\n@@ -446,6 +525,9 @@ static struct\n   /* The number of inserts found due to partial anticipation  */\n   int pa_insert;\n \n+  /* The number of inserts made for code hoisting.  */\n+  int hoist_insert;\n+\n   /* The number of new PHI nodes added by PRE.  */\n   int phis;\n } pre_stats;\n@@ -455,6 +537,7 @@ static pre_expr bitmap_find_leader (bitmap_set_t, unsigned int);\n static void bitmap_value_insert_into_set (bitmap_set_t, pre_expr);\n static void bitmap_value_replace_in_set (bitmap_set_t, pre_expr);\n static void bitmap_set_copy (bitmap_set_t, bitmap_set_t);\n+static void bitmap_set_and (bitmap_set_t, bitmap_set_t);\n static bool bitmap_set_contains_value (bitmap_set_t, unsigned int);\n static void bitmap_insert_into_set (bitmap_set_t, pre_expr);\n static void bitmap_insert_into_set_1 (bitmap_set_t, pre_expr,\n@@ -3104,7 +3187,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \n \n \n-/* Perform insertion of partially redundant values.\n+/* Perform insertion of partially redundant or hoistable values.\n    For BLOCK, do the following:\n    1.  Propagate the NEW_SETS of the dominator into the current block.\n    If the block has multiple predecessors,\n@@ -3115,15 +3198,20 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n        2c. Insert a new PHI merging the values of the predecessors.\n        2d. Insert the new PHI, and the new expressions, into the\n \t   NEW_SETS set.\n-   3. Recursively call ourselves on the dominator children of BLOCK.\n-\n-   Steps 1, 2a, and 3 are done by insert_aux. 2b, 2c and 2d are done by\n-   do_regular_insertion and do_partial_insertion.\n-\n+   If the block has multiple successors,\n+       3a. Iterate over the ANTIC values for the block to see if\n+\t   any of them are good candidates for hoisting.\n+       3b. If so, insert expressions computing the values in BLOCK,\n+\t   and add the new expressions into the NEW_SETS set.\n+   4. Recursively call ourselves on the dominator children of BLOCK.\n+\n+   Steps 1, 2a, and 4 are done by insert_aux. 2b, 2c and 2d are done by\n+   do_pre_regular_insertion and do_partial_insertion.  3a and 3b are\n+   done in do_hoist_insertion.\n */\n \n static bool\n-do_regular_insertion (basic_block block, basic_block dom)\n+do_pre_regular_insertion (basic_block block, basic_block dom)\n {\n   bool new_stuff = false;\n   vec<pre_expr> exprs;\n@@ -3292,9 +3380,8 @@ do_regular_insertion (basic_block block, basic_block dom)\n    In this case, we know that putting it earlier will enable us to\n    remove the later computation.  */\n \n-\n static bool\n-do_partial_partial_insertion (basic_block block, basic_block dom)\n+do_pre_partial_partial_insertion (basic_block block, basic_block dom)\n {\n   bool new_stuff = false;\n   vec<pre_expr> exprs;\n@@ -3423,8 +3510,138 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n   return new_stuff;\n }\n \n+/* Insert expressions in BLOCK to compute hoistable values up.\n+   Return TRUE if something was inserted, otherwise return FALSE.\n+   The caller has to make sure that BLOCK has at least two successors.  */\n+\n+static bool\n+do_hoist_insertion (basic_block block)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  bool new_stuff = false;\n+  unsigned i;\n+  gimple_stmt_iterator last;\n+\n+  /* At least two successors, or else...  */\n+  gcc_assert (EDGE_COUNT (block->succs) >= 2);\n+\n+  /* Check that all successors of BLOCK are dominated by block.\n+     We could use dominated_by_p() for this, but actually there is a much\n+     quicker check: any successor that is dominated by BLOCK can't have\n+     more than one predecessor edge.  */\n+  FOR_EACH_EDGE (e, ei, block->succs)\n+    if (! single_pred_p (e->dest))\n+      return false;\n+\n+  /* Determine the insertion point.  If we cannot safely insert before\n+     the last stmt if we'd have to, bail out.  */\n+  last = gsi_last_bb (block);\n+  if (!gsi_end_p (last)\n+      && !is_ctrl_stmt (gsi_stmt (last))\n+      && stmt_ends_bb_p (gsi_stmt (last)))\n+    return false;\n+\n+  /* Compute the set of hoistable expressions from ANTIC_IN.  First compute\n+     hoistable values.  */\n+  bitmap_set hoistable_set;\n+\n+  /* A hoistable value must be in ANTIC_IN(block)\n+     but not in AVAIL_OUT(BLOCK).  */\n+  bitmap_initialize (&hoistable_set.values, &grand_bitmap_obstack);\n+  bitmap_and_compl (&hoistable_set.values,\n+\t\t    &ANTIC_IN (block)->values, &AVAIL_OUT (block)->values);\n+\n+  /* Short-cut for a common case: hoistable_set is empty.  */\n+  if (bitmap_empty_p (&hoistable_set.values))\n+    return false;\n+\n+  /* Compute which of the hoistable values is in AVAIL_OUT of\n+     at least one of the successors of BLOCK.  */\n+  bitmap_head availout_in_some;\n+  bitmap_initialize (&availout_in_some, &grand_bitmap_obstack);\n+  FOR_EACH_EDGE (e, ei, block->succs)\n+    /* Do not consider expressions solely because their availability\n+       on loop exits.  They'd be ANTIC-IN throughout the whole loop\n+       and thus effectively hoisted across loops by combination of\n+       PRE and hoisting.  */\n+    if (! loop_exit_edge_p (block->loop_father, e))\n+      bitmap_ior_and_into (&availout_in_some, &hoistable_set.values,\n+\t\t\t   &AVAIL_OUT (e->dest)->values);\n+  bitmap_clear (&hoistable_set.values);\n+\n+  /* Short-cut for a common case: availout_in_some is empty.  */\n+  if (bitmap_empty_p (&availout_in_some))\n+    return false;\n+\n+  /* Hack hoitable_set in-place so we can use sorted_array_from_bitmap_set.  */\n+  hoistable_set.values = availout_in_some;\n+  hoistable_set.expressions = ANTIC_IN (block)->expressions;\n+\n+  /* Now finally construct the topological-ordered expression set.  */\n+  vec<pre_expr> exprs = sorted_array_from_bitmap_set (&hoistable_set);\n+\n+  bitmap_clear (&hoistable_set.values);\n+\n+  /* If there are candidate values for hoisting, insert expressions\n+     strategically to make the hoistable expressions fully redundant.  */\n+  pre_expr expr;\n+  FOR_EACH_VEC_ELT (exprs, i, expr)\n+    {\n+      /* While we try to sort expressions topologically above the\n+         sorting doesn't work out perfectly.  Catch expressions we\n+\t already inserted.  */\n+      unsigned int value_id = get_expr_value_id (expr);\n+      if (bitmap_set_contains_value (AVAIL_OUT (block), value_id))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"Already inserted expression for \");\n+\t      print_pre_expr (dump_file, expr);\n+\t      fprintf (dump_file, \" (%04d)\\n\", value_id);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* OK, we should hoist this value.  Perform the transformation.  */\n+      pre_stats.hoist_insert++;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file,\n+\t\t   \"Inserting expression in block %d for code hoisting: \",\n+\t\t   block->index);\n+\t  print_pre_expr (dump_file, expr);\n+\t  fprintf (dump_file, \" (%04d)\\n\", value_id);\n+\t}\n+\n+      gimple_seq stmts = NULL;\n+      tree res = create_expression_by_pieces (block, expr, &stmts,\n+\t\t\t\t\t      get_expr_type (expr));\n+      if (gsi_end_p (last) || is_ctrl_stmt (gsi_stmt (last)))\n+\tgsi_insert_seq_before (&last, stmts, GSI_SAME_STMT);\n+      else\n+\tgsi_insert_seq_after (&last, stmts, GSI_NEW_STMT);\n+\n+      /* Make sure to not return true if expression creation ultimately\n+         failed but also make sure to insert any stmts produced as they\n+\t are tracked in inserted_exprs.  */\n+      if (! res)\n+\tcontinue;\n+\n+      new_stuff = true;\n+    }\n+\n+  exprs.release ();\n+\n+  return new_stuff;\n+}\n+\n+/* Do a dominator walk on the control flow graph, and insert computations\n+   of values as necessary for PRE and hoisting.  */\n+\n static bool\n-insert_aux (basic_block block)\n+insert_aux (basic_block block, bool do_pre, bool do_hoist)\n {\n   basic_block son;\n   bool new_stuff = false;\n@@ -3437,7 +3654,11 @@ insert_aux (basic_block block)\n \t{\n \t  unsigned i;\n \t  bitmap_iterator bi;\n-\t  bitmap_set_t newset = NEW_SETS (dom);\n+\t  bitmap_set_t newset;\n+\n+\t  /* First, update the AVAIL_OUT set with anything we may have\n+\t     inserted higher up in the dominator tree.  */\n+\t  newset = NEW_SETS (dom);\n \t  if (newset)\n \t    {\n \t      /* Note that we need to value_replace both NEW_SETS, and\n@@ -3451,25 +3672,31 @@ insert_aux (basic_block block)\n \t\t  bitmap_value_replace_in_set (AVAIL_OUT (block), expr);\n \t\t}\n \t    }\n-\t  if (!single_pred_p (block))\n+\n+\t  /* Insert expressions for partial redundancies.  */\n+\t  if (do_pre && !single_pred_p (block))\n \t    {\n-\t      new_stuff |= do_regular_insertion (block, dom);\n+\t      new_stuff |= do_pre_regular_insertion (block, dom);\n \t      if (do_partial_partial)\n-\t\tnew_stuff |= do_partial_partial_insertion (block, dom);\n+\t\tnew_stuff |= do_pre_partial_partial_insertion (block, dom);\n \t    }\n+\n+\t  /* Insert expressions for hoisting.  */\n+\t  if (do_hoist && EDGE_COUNT (block->succs) >= 2)\n+\t    new_stuff |= do_hoist_insertion (block);\n \t}\n     }\n   for (son = first_dom_son (CDI_DOMINATORS, block);\n        son;\n        son = next_dom_son (CDI_DOMINATORS, son))\n     {\n-      new_stuff |= insert_aux (son);\n+      new_stuff |= insert_aux (son, do_pre, do_hoist);\n     }\n \n   return new_stuff;\n }\n \n-/* Perform insertion of partially redundant values.  */\n+/* Perform insertion of partially redundant and hoistable values.  */\n \n static void\n insert (void)\n@@ -3486,7 +3713,8 @@ insert (void)\n       num_iterations++;\n       if (dump_file && dump_flags & TDF_DETAILS)\n \tfprintf (dump_file, \"Starting insert iteration %d\\n\", num_iterations);\n-      new_stuff = insert_aux (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+      new_stuff = insert_aux (ENTRY_BLOCK_PTR_FOR_FN (cfun), flag_tree_pre,\n+\t\t\t      flag_code_hoisting);\n \n       /* Clear the NEW sets before the next iteration.  We have already\n          fully propagated its contents.  */\n@@ -4813,7 +5041,8 @@ class pass_pre : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_tree_pre != 0; }\n+  virtual bool gate (function *)\n+    { return flag_tree_pre != 0 || flag_code_hoisting != 0; }\n   virtual unsigned int execute (function *);\n \n }; // class pass_pre\n@@ -4868,6 +5097,7 @@ pass_pre::execute (function *fun)\n \n   statistics_counter_event (fun, \"Insertions\", pre_stats.insertions);\n   statistics_counter_event (fun, \"PA inserted\", pre_stats.pa_insert);\n+  statistics_counter_event (fun, \"HOIST inserted\", pre_stats.hoist_insert);\n   statistics_counter_event (fun, \"New PHIs\", pre_stats.phis);\n   statistics_counter_event (fun, \"Eliminated\", pre_stats.eliminations);\n "}]}