{"sha": "0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjZjA5ZjljYzFlZTljNGMyZGFhOTFkMmYyYTg0NDAxM2Y4MWNkYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-30T20:30:23Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-30T20:30:23Z"}, "message": "i386.c (ix86_output_main_function_alignment_hack): New function.\n\n\t* i386.c (ix86_output_main_function_alignment_hack): New function.\n\t(TARGET_ASM_FUNCTION_PROLOGUE): Default to it.\n\n\t* flow.c (mark_dfs_back_edges): Move from loop_p ; mark back\n\tedges by EDGE_DFS_BACK flag.\n\t(dump_edge_info): Add dfs_back flag.\n\t* basic-block.h (EDGE_DFS_BACK): New constant.\n\t(mark_dfs_back_edges): Declare.\n\t* alias.c (loop_p): Remove.\n\t(mark_constant_function): Use mark_dfs_back_edges.\n\n\t* reg-stack.c (block_info_def): Add predecesors counter and stack_out.\n\t(reg_to_stack): Call mark_dfs_back_edges; count the predecesors.\n\t(compensate_edge): Break out from ...\n\t(convert_regs_1): ... here; do smart choosing of stack_out to copy.\n\t(convert_regs_2): Set block_done once block is really done;\n\tDo updating of the predecesors counts.\n\n\t* toplev.c (rest_of_compilation): Recompute block_for_insn\n\tbefore post-reload cfg_cleanup.\n\t* function.c (thread_prologue_epilogue_insns):\n\tCall set_block_for_new_insns when emitting prologue directly.\n\nFrom-SVN: r44486", "tree": {"sha": "df492d486710873b66c3b9b278a0eac02a7df6c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df492d486710873b66c3b9b278a0eac02a7df6c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/comments", "author": null, "committer": null, "parents": [{"sha": "1490f39253ed06e99aec28d0c265154039fa9b2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1490f39253ed06e99aec28d0c265154039fa9b2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1490f39253ed06e99aec28d0c265154039fa9b2b"}], "stats": {"total": 612, "additions": 382, "deletions": 230}, "files": [{"sha": "c2e831aa8f8e54448fbe22ecc326e98c1ad57de4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -1,3 +1,28 @@\n+Mon Jul 30 22:16:08 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (ix86_output_main_function_alignment_hack): New function.\n+\t(TARGET_ASM_FUNCTION_PROLOGUE): Default to it.\n+\n+\t* flow.c (mark_dfs_back_edges): Move from loop_p ; mark back\n+\tedges by EDGE_DFS_BACK flag.\n+\t(dump_edge_info): Add dfs_back flag.\n+\t* basic-block.h (EDGE_DFS_BACK): New constant.\n+\t(mark_dfs_back_edges): Declare.\n+\t* alias.c (loop_p): Remove.\n+\t(mark_constant_function): Use mark_dfs_back_edges.\n+\n+\t* reg-stack.c (block_info_def): Add predecesors counter and stack_out.\n+\t(reg_to_stack): Call mark_dfs_back_edges; count the predecesors.\n+\t(compensate_edge): Break out from ...\n+\t(convert_regs_1): ... here; do smart choosing of stack_out to copy.\n+\t(convert_regs_2): Set block_done once block is really done;\n+\tDo updating of the predecesors counts.\n+\n+\t* toplev.c (rest_of_compilation): Recompute block_for_insn\n+\tbefore post-reload cfg_cleanup.\n+\t* function.c (thread_prologue_epilogue_insns):\n+\tCall set_block_for_new_insns when emitting prologue directly.\n+\n 2001-07-30  Andreas Jaeger  <aj@suse.de>\n \n         * jump.c: Add prototype for mark_modified_reg."}, {"sha": "bbde59b6440615cd7a095b5ea17b8741108330a7", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -107,8 +107,6 @@ static int aliases_everything_p         PARAMS ((rtx));\n static int write_dependence_p           PARAMS ((rtx, rtx, int));\n static int nonlocal_mentioned_p         PARAMS ((rtx));\n \n-static int loop_p                       PARAMS ((void));\n-\n /* Set up all info needed to perform alias analysis on memory references.  */\n \n /* Returns the size in bytes of the mode of X.  */\n@@ -2051,96 +2049,6 @@ nonlocal_mentioned_p (x)\n   return 0;\n }\n \n-/* Return non-zero if a loop (natural or otherwise) is present.\n-   Inspired by Depth_First_Search_PP described in:\n-\n-     Advanced Compiler Design and Implementation\n-     Steven Muchnick\n-     Morgan Kaufmann, 1997\n-\n-   and heavily borrowed from flow_depth_first_order_compute.  */\n-\n-static int\n-loop_p ()\n-{\n-  edge *stack;\n-  int *pre;\n-  int *post;\n-  int sp;\n-  int prenum = 1;\n-  int postnum = 1;\n-  sbitmap visited;\n-\n-  /* Allocate the preorder and postorder number arrays.  */\n-  pre = (int *) xcalloc (n_basic_blocks, sizeof (int));\n-  post = (int *) xcalloc (n_basic_blocks, sizeof (int));\n-\n-  /* Allocate stack for back-tracking up CFG.  */\n-  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n-  sp = 0;\n-\n-  /* Allocate bitmap to track nodes that have been visited.  */\n-  visited = sbitmap_alloc (n_basic_blocks);\n-\n-  /* None of the nodes in the CFG have been visited yet.  */\n-  sbitmap_zero (visited);\n-\n-  /* Push the first edge on to the stack.  */\n-  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n-\n-  while (sp)\n-    {\n-      edge e;\n-      basic_block src;\n-      basic_block dest;\n-\n-      /* Look at the edge on the top of the stack.  */\n-      e = stack[sp - 1];\n-      src = e->src;\n-      dest = e->dest;\n-\n-      /* Check if the edge destination has been visited yet.  */\n-      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n-\t{\n-\t  /* Mark that we have visited the destination.  */\n-\t  SET_BIT (visited, dest->index);\n-\n-\t  pre[dest->index] = prenum++;\n-\n-\t  if (dest->succ)\n-\t    {\n-\t      /* Since the DEST node has been visited for the first\n-\t\t time, check its successors.  */\n-\t      stack[sp++] = dest->succ;\n-\t    }\n-\t  else\n-\t    post[dest->index] = postnum++;\n-\t}\n-      else\n-\t{\n-\t  if (dest != EXIT_BLOCK_PTR && src != ENTRY_BLOCK_PTR\n-\t      && pre[src->index] >= pre[dest->index]\n-\t      && post[dest->index] == 0)\n-\t    break;\n-\n-\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n-\t    post[src->index] = postnum++;\n-\n-\t  if (e->succ_next)\n-\t    stack[sp - 1] = e->succ_next;\n-\t  else\n-\t    sp--;\n-\t}\n-    }\n-\n-  free (pre);\n-  free (post);\n-  free (stack);\n-  sbitmap_free (visited);\n-\n-  return sp;\n-}\n-\n /* Mark the function if it is constant.  */\n \n void\n@@ -2157,7 +2065,7 @@ mark_constant_function ()\n     return;\n \n   /* A loop might not return which counts as a side effect.  */\n-  if (loop_p ())\n+  if (mark_dfs_back_edges ())\n     return;\n \n   nonlocal_mentioned = 0;"}, {"sha": "d7893a58b06d2093e5873390699fff677c7d599b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -145,6 +145,7 @@ typedef struct edge_def {\n #define EDGE_ABNORMAL_CALL\t8\n #define EDGE_EH\t\t\t16\n #define EDGE_FAKE\t\t32\n+#define EDGE_DFS_BACK\t\t64\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n@@ -650,6 +651,7 @@ extern void conflict_graph_print        PARAMS ((conflict_graph, FILE*));\n extern conflict_graph conflict_graph_compute \n                                         PARAMS ((regset,\n \t\t\t\t\t\t partition));\n+extern bool mark_dfs_back_edges\t\tPARAMS ((void));\n \n /* In dominance.c */\n "}, {"sha": "9017207e292e6da02aa1093c77a9ae8b5d170558", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -574,6 +574,7 @@ static HOST_WIDE_INT ix86_GOT_alias_set PARAMS ((void));\n static void ix86_adjust_counter PARAMS ((rtx, HOST_WIDE_INT));\n static rtx ix86_expand_aligntest PARAMS ((rtx, int));\n static void ix86_expand_strlensi_unroll_1 PARAMS ((rtx, rtx));\n+static void ix86_output_main_function_alignment_hack PARAMS ((FILE *f, int));\n \n struct ix86_address\n {\n@@ -634,6 +635,10 @@ static int ix86_comp_type_attributes PARAMS ((tree, tree));\n \t\t\t\t\t\t\t  HOST_WIDE_INT));\n #  undef TARGET_ASM_FUNCTION_PROLOGUE\n #  define TARGET_ASM_FUNCTION_PROLOGUE ix86_osf_output_function_prologue\n+#else\n+#  undef TARGET_ASM_FUNCTION_PROLOGUE\n+#  define TARGET_ASM_FUNCTION_PROLOGUE \\\n+   ix86_output_main_function_alignment_hack\n #endif\n \n #undef TARGET_ASM_OPEN_PAREN\n@@ -10775,3 +10780,45 @@ ix86_memory_move_cost (mode, class, in)\n \t\t* (int) GET_MODE_SIZE (mode) / 4);\n     }\n }\n+\n+/* Most of current runtimes (Jul 2001) do not align stack properly when\n+   entering main, so emit an wrapper to align stack before the real main\n+   code is called.\n+  \n+   This can eventually go if we manage to fix the runtimes or teach gcc\n+   to dynamically align stack in main automatically.\n+\n+   Adding check to configure is probably not good idea, as binarry can move\n+   from one shared library to older.  */\n+\n+static void\n+ix86_output_main_function_alignment_hack (file, size)\n+     FILE *file;\n+     int size ATTRIBUTE_UNUSED;\n+{\n+  rtx label;\n+  char buf[256];\n+  /* Check that we see main function with maximally 8 bytes of arguments.\n+     if so, emit the hack to align stack for runtimes, where this constraint\n+     is broken.  */\n+  if (strcmp (cfun->name, \"main\"))\n+    return;\n+  if (cfun->pops_args || cfun->args_size > 12)\n+    return;\n+  if (PREFERRED_STACK_BOUNDARY <= 2)\n+    return;\n+  label = gen_label_rtx ();\n+  fprintf (file, \"\\tpushl\\t%%ebp\\n\");\n+  fprintf (file, \"\\tmovl\\t%%esp, %%ebp\\n\");\n+  fprintf (file, \"\\tandl\\t$0xfffffff0, %%esp\\n\");\n+  fprintf (file, \"\\tpushl\\t%%ebp\\n\");\n+  fprintf (file, \"\\tpushl\\t16(%%ebp)\\n\");\n+  fprintf (file, \"\\tpushl\\t12(%%ebp)\\n\");\n+  fprintf (file, \"\\tpushl\\t8(%%ebp)\\n\");\n+  fprintf (file, \"\\tcall\\t\");\n+  ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", CODE_LABEL_NUMBER (label));\n+  assemble_name (file, buf);\n+  fprintf (file, \"\\n\\tleave\\n\");\n+  fprintf (file, \"\\tret\\n\");\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (label));\n+}"}, {"sha": "b13591f044cb00274c518b208100dbf797a4dbb6", "filename": "gcc/flow.c", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -1528,6 +1528,99 @@ mark_critical_edges ()\n     }\n }\n \f\n+/* Mark the back edges in DFS traversal.\n+   Return non-zero if a loop (natural or otherwise) is present.\n+   Inspired by Depth_First_Search_PP described in:\n+\n+     Advanced Compiler Design and Implementation\n+     Steven Muchnick\n+     Morgan Kaufmann, 1997\n+\n+   and heavily borrowed from flow_depth_first_order_compute.  */\n+\n+bool\n+mark_dfs_back_edges ()\n+{\n+  edge *stack;\n+  int *pre;\n+  int *post;\n+  int sp;\n+  int prenum = 1;\n+  int postnum = 1;\n+  sbitmap visited;\n+  bool found = false;\n+\n+  /* Allocate the preorder and postorder number arrays.  */\n+  pre = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+  post = (int *) xcalloc (n_basic_blocks, sizeof (int));\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = (edge *) xmalloc ((n_basic_blocks + 1) * sizeof (edge));\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = sbitmap_alloc (n_basic_blocks);\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (visited);\n+\n+  /* Push the first edge on to the stack.  */\n+  stack[sp++] = ENTRY_BLOCK_PTR->succ;\n+\n+  while (sp)\n+    {\n+      edge e;\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      e = stack[sp - 1];\n+      src = e->src;\n+      dest = e->dest;\n+      e->flags &= ~EDGE_DFS_BACK;\n+\n+      /* Check if the edge destination has been visited yet.  */\n+      if (dest != EXIT_BLOCK_PTR && ! TEST_BIT (visited, dest->index))\n+\t{\n+\t  /* Mark that we have visited the destination.  */\n+\t  SET_BIT (visited, dest->index);\n+\n+\t  pre[dest->index] = prenum++;\n+\n+\t  if (dest->succ)\n+\t    {\n+\t      /* Since the DEST node has been visited for the first\n+\t\t time, check its successors.  */\n+\t      stack[sp++] = dest->succ;\n+\t    }\n+\t  else\n+\t    post[dest->index] = postnum++;\n+\t}\n+      else\n+\t{\n+\t  if (dest != EXIT_BLOCK_PTR && src != ENTRY_BLOCK_PTR\n+\t      && pre[src->index] >= pre[dest->index]\n+\t      && post[dest->index] == 0)\n+\t    e->flags |= EDGE_DFS_BACK, found = true;\n+\n+\t  if (! e->succ_next && src != ENTRY_BLOCK_PTR)\n+\t    post[src->index] = postnum++;\n+\n+\t  if (e->succ_next)\n+\t    stack[sp - 1] = e->succ_next;\n+\t  else\n+\t    sp--;\n+\t}\n+    }\n+\n+  free (pre);\n+  free (post);\n+  free (stack);\n+  sbitmap_free (visited);\n+\n+  return found;\n+}\n+\f\n /* Split a block BB after insn INSN creating a new fallthru edge.\n    Return the new edge.  Note that to keep other parts of the compiler happy,\n    this function renumbers all the basic blocks so that the new\n@@ -7779,7 +7872,7 @@ dump_edge_info (file, e, do_succ)\n   if (e->flags)\n     {\n       static const char * const bitnames[] = {\n-\t\"fallthru\", \"crit\", \"ab\", \"abcall\", \"eh\", \"fake\"\n+\t\"fallthru\", \"crit\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\"\n       };\n       int comma = 0;\n       int i, flags = e->flags;"}, {"sha": "a2284a0d12a524b14a19b1559fba8b609fdd15fe", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -7226,7 +7226,8 @@ thread_prologue_and_epilogue_insns (f)\n \t  inserted = 1;\n \t}\n       else\n-\temit_insn_after (seq, f);\n+\tset_block_for_new_insns (emit_insn_after (seq, f),\n+\t\t       \t\t ENTRY_BLOCK_PTR->succ);\n     }\n #endif\n "}, {"sha": "342477cb3295bab84ac28027690578615a166523", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 208, "deletions": 132, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -194,8 +194,11 @@ typedef struct stack_def\n typedef struct block_info_def\n {\n   struct stack_def stack_in;\t/* Input stack configuration.  */\n+  struct stack_def stack_out;\t/* Output stack configuration.  */\n   HARD_REG_SET out_reg_set;\t/* Stack regs live on output.  */\n   int done;\t\t\t/* True if block already converted.  */\n+  int predecesors;\t\t/* Number of predecesors that needs\n+\t\t\t\t   to be visited.  */\n } *block_info;\n \n #define BLOCK_INFO(B)\t((block_info) (B)->aux)\n@@ -263,6 +266,7 @@ static int convert_regs\t\t\tPARAMS ((FILE *));\n static void print_stack \t\tPARAMS ((FILE *, stack));\n static rtx next_flags_user \t\tPARAMS ((rtx));\n static void record_label_references\tPARAMS ((rtx, rtx));\n+static bool compensate_edge\t\tPARAMS ((edge, FILE *));\n \f\n /* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n \n@@ -443,11 +447,20 @@ reg_to_stack (first, file)\n     find_basic_blocks (first, max_reg_num (), file);\n   count_or_remove_death_notes (NULL, 1);\n   life_analysis (first, file, PROP_DEATH_NOTES);\n+  mark_dfs_back_edges ();\n \n   /* Set up block info for each basic block.  */\n   bi = (block_info) xcalloc ((n_basic_blocks + 1), sizeof (*bi));\n   for (i = n_basic_blocks - 1; i >= 0; --i)\n-    BASIC_BLOCK (i)->aux = bi + i;\n+    {\n+      edge e;\n+      basic_block bb = BASIC_BLOCK (i);\n+      bb->aux = bi + i;\n+      for (e = bb->pred; e; e=e->pred_next)\n+\tif (!(e->flags & EDGE_DFS_BACK)\n+\t    && e->src != ENTRY_BLOCK_PTR)\n+\t  BLOCK_INFO (bb)->predecesors++;\n+    }\n   EXIT_BLOCK_PTR->aux = bi + n_basic_blocks;\n \n   /* Create the replacement registers up front.  */\n@@ -2452,21 +2465,192 @@ convert_regs_exit ()\n     }\n }\n \n+/* Adjust the stack of this block on exit to match the stack of the\n+   target block, or copy stack info into the stack of the successor\n+   of the successor hasn't been processed yet.  */\n+static bool\n+compensate_edge (e, file)\n+    edge e;\n+    FILE *file;\n+{\n+  basic_block block = e->src, target = e->dest;\n+  block_info bi = BLOCK_INFO (block);\n+  struct stack_def regstack, tmpstack;\n+  stack target_stack = &BLOCK_INFO (target)->stack_in;\n+  int reg;\n+\n+  current_block = block;\n+  regstack = bi->stack_out;\n+  if (file)\n+    fprintf (file, \"Edge %d->%d: \", block->index, target->index);\n+\n+  if (target_stack->top == -2)\n+    {\n+      /* The target block hasn't had a stack order selected.\n+         We need merely ensure that no pops are needed.  */\n+      for (reg = regstack.top; reg >= 0; --reg)\n+\tif (!TEST_HARD_REG_BIT (target_stack->reg_set, regstack.reg[reg]))\n+\t  break;\n+\n+      if (reg == -1)\n+\t{\n+\t  if (file)\n+\t    fprintf (file, \"new block; copying stack position\\n\");\n+\n+\t  /* change_stack kills values in regstack.  */\n+\t  tmpstack = regstack;\n+\n+\t  change_stack (block->end, &tmpstack, target_stack, EMIT_AFTER);\n+          return false;\n+\t}\n+\n+      if (file)\n+\tfprintf (file, \"new block; pops needed\\n\");\n+    }\n+  else\n+    {\n+      if (target_stack->top == regstack.top)\n+\t{\n+\t  for (reg = target_stack->top; reg >= 0; --reg)\n+\t    if (target_stack->reg[reg] != regstack.reg[reg])\n+\t      break;\n+\n+\t  if (reg == -1)\n+\t    {\n+\t      if (file)\n+\t\tfprintf (file, \"no changes needed\\n\");\n+\t      return false;\n+\t    }\n+\t}\n+\n+      if (file)\n+\t{\n+\t  fprintf (file, \"correcting stack to \");\n+\t  print_stack (file, target_stack);\n+\t}\n+    }\n+\n+  /* Care for non-call EH edges specially.  The normal return path have\n+     values in registers.  These will be popped en masse by the unwind\n+     library.  */\n+  if ((e->flags & (EDGE_EH | EDGE_ABNORMAL_CALL)) == EDGE_EH)\n+    target_stack->top = -1;\n+\n+  /* Other calls may appear to have values live in st(0), but the\n+     abnormal return path will not have actually loaded the values.  */\n+  else if (e->flags & EDGE_ABNORMAL_CALL)\n+    {\n+      /* Assert that the lifetimes are as we expect -- one value\n+         live at st(0) on the end of the source block, and no\n+         values live at the beginning of the destination block.  */\n+      HARD_REG_SET tmp;\n+\n+      CLEAR_HARD_REG_SET (tmp);\n+      GO_IF_HARD_REG_EQUAL (target_stack->reg_set, tmp, eh1);\n+      abort ();\n+    eh1:\n+\n+      SET_HARD_REG_BIT (tmp, FIRST_STACK_REG);\n+      GO_IF_HARD_REG_EQUAL (regstack.reg_set, tmp, eh2);\n+      abort ();\n+    eh2:\n+\n+      target_stack->top = -1;\n+    }\n+\n+  /* It is better to output directly to the end of the block\n+     instead of to the edge, because emit_swap can do minimal\n+     insn scheduling.  We can do this when there is only one\n+     edge out, and it is not abnormal.  */\n+  else if (block->succ->succ_next == NULL && !(e->flags & EDGE_ABNORMAL))\n+    {\n+      /* change_stack kills values in regstack.  */\n+      tmpstack = regstack;\n+\n+      change_stack (block->end, &tmpstack, target_stack,\n+\t\t    (GET_CODE (block->end) == JUMP_INSN\n+\t\t     ? EMIT_BEFORE : EMIT_AFTER));\n+    }\n+  else\n+    {\n+      rtx seq, after;\n+\n+      /* We don't support abnormal edges.  Global takes care to\n+         avoid any live register across them, so we should never\n+         have to insert instructions on such edges.  */\n+      if (e->flags & EDGE_ABNORMAL)\n+\tabort ();\n+\n+      current_block = NULL;\n+      start_sequence ();\n+\n+      /* ??? change_stack needs some point to emit insns after. \n+         Also needed to keep gen_sequence from returning a \n+         pattern as opposed to a sequence, which would lose\n+         REG_DEAD notes.  */\n+      after = emit_note (NULL, NOTE_INSN_DELETED);\n+\n+      tmpstack = regstack;\n+      change_stack (after, &tmpstack, target_stack, EMIT_BEFORE);\n+\n+      seq = gen_sequence ();\n+      end_sequence ();\n+\n+      insert_insn_on_edge (seq, e);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Convert stack register references in one block.  */\n \n static int\n convert_regs_1 (file, block)\n      FILE *file;\n      basic_block block;\n {\n-  struct stack_def regstack, tmpstack;\n+  struct stack_def regstack;\n   block_info bi = BLOCK_INFO (block);\n   int inserted, reg;\n   rtx insn, next;\n-  edge e;\n+  edge e, beste = NULL;\n \n-  current_block = block;\n+  inserted = 0;\n+\n+  /* Find the edge we will copy stack from.  It should be the most frequent\n+     one as it will get cheapest after compensation code is generated,\n+     if multiple such exists, take one with largest count, preffer critical\n+     one (as splitting critical edges is more expensive), or one with lowest\n+     index, to avoid random changes with different orders of the edges.  */\n+  for (e = block->pred; e ; e = e->pred_next)\n+    {\n+      if (e->flags & EDGE_DFS_BACK)\n+\t;\n+      else if (! beste)\n+\tbeste = e;\n+      else if (EDGE_FREQUENCY (beste) < EDGE_FREQUENCY (e))\n+\tbeste = e;\n+      else if (beste->count < e->count)\n+\tbeste = e;\n+      else if (beste->count > e->count)\n+\t;\n+      else if ((e->flags & EDGE_CRITICAL) != (beste->flags & EDGE_CRITICAL))\n+\t{\n+\t  if (e->flags & EDGE_CRITICAL)\n+\t    beste = e;\n+\t}\n+      else if (e->src->index < beste->src->index)\n+\tbeste = e;\n+    }\n+\n+  /* Entry block does have stack already initialized.  */\n+  if (bi->stack_in.top == -2)\n+    inserted |= compensate_edge (beste, file);\n+  else\n+    beste = NULL;\n   \n+  current_block = block;\n+\n   if (file)\n     {\n       fprintf (file, \"\\nBasic block %d\\nInput stack: \", block->index);\n@@ -2546,137 +2730,28 @@ convert_regs_1 (file, block)\n   GO_IF_HARD_REG_EQUAL (regstack.reg_set, bi->out_reg_set, win);\n   abort ();\n  win:\n+  bi->stack_out = regstack;\n \n-  /* Adjust the stack of this block on exit to match the stack of the\n-     target block, or copy stack info into the stack of the successor\n-     of the successor hasn't been processed yet.  */\n-  inserted = 0;\n+  /* Compensate the back edges, as those wasn't visited yet.  */\n   for (e = block->succ; e ; e = e->succ_next)\n     {\n-      basic_block target = e->dest;\n-      stack target_stack = &BLOCK_INFO (target)->stack_in;\n-\n-      if (file)\n-\tfprintf (file, \"Edge to block %d: \", target->index);\n-\n-      if (target_stack->top == -2)\n-\t{\n-\t  /* The target block hasn't had a stack order selected.\n-\t     We need merely ensure that no pops are needed.  */\n-\t  for (reg = regstack.top; reg >= 0; --reg)\n-\t    if (! TEST_HARD_REG_BIT (target_stack->reg_set,\n-\t\t\t\t     regstack.reg[reg]))\n-\t      break;\n-\n-\t  if (reg == -1)\n-\t    {\n-\t      if (file)\n-\t\tfprintf (file, \"new block; copying stack position\\n\");\n-\n-\t      /* change_stack kills values in regstack.  */\n-\t      tmpstack = regstack;\n-\n-\t      change_stack (block->end, &tmpstack,\n-\t\t\t    target_stack, EMIT_AFTER);\n-\t      continue;\n-\t    }\n-\n-\t  if (file)\n-\t    fprintf (file, \"new block; pops needed\\n\");\n-\t}\n-      else\n+      if (e->flags & EDGE_DFS_BACK\n+\t  || (e->dest == EXIT_BLOCK_PTR))\n \t{\n-\t  if (target_stack->top == regstack.top)\n-\t    {\n-\t      for (reg = target_stack->top; reg >= 0; --reg)\n-\t\tif (target_stack->reg[reg] != regstack.reg[reg])\n-\t\t  break;\n-\n-\t      if (reg == -1)\n-\t\t{\n-\t\t  if (file)\n-\t\t    fprintf (file, \"no changes needed\\n\");\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\n-\t  if (file)\n-\t    {\n-\t      fprintf (file, \"correcting stack to \");\n-\t      print_stack (file, target_stack);\n-\t    }\n-\t}\n-\n-      /* Care for non-call EH edges specially.  The normal return path have\n-\t values in registers.  These will be popped en masse by the unwind\n-\t library.  */\n-      if ((e->flags & (EDGE_EH | EDGE_ABNORMAL_CALL)) == EDGE_EH)\n-\ttarget_stack->top = -1;\n-\n-      /* Other calls may appear to have values live in st(0), but the\n-\t abnormal return path will not have actually loaded the values.  */\n-      else if (e->flags & EDGE_ABNORMAL_CALL)\n-\t{\n-\t  /* Assert that the lifetimes are as we expect -- one value\n-\t     live at st(0) on the end of the source block, and no\n-\t     values live at the beginning of the destination block.  */\n-\t  HARD_REG_SET tmp;\n-\n-\t  CLEAR_HARD_REG_SET (tmp);\n-\t  GO_IF_HARD_REG_EQUAL (target_stack->reg_set, tmp, eh1);\n-\t  abort();\n-\teh1:\n-\n-\t  SET_HARD_REG_BIT (tmp, FIRST_STACK_REG);\n-\t  GO_IF_HARD_REG_EQUAL (regstack.reg_set, tmp, eh2);\n-\t  abort();\n-\teh2:\n-\n-\t  target_stack->top = -1;\n-\t}\n-\n-      /* It is better to output directly to the end of the block\n-\t instead of to the edge, because emit_swap can do minimal\n-\t insn scheduling.  We can do this when there is only one\n-\t edge out, and it is not abnormal.  */\n-      else if (block->succ->succ_next == NULL\n-\t       && ! (e->flags & EDGE_ABNORMAL))\n-\t{\n-\t  /* change_stack kills values in regstack.  */\n-\t  tmpstack = regstack;\n-\n-\t  change_stack (block->end, &tmpstack, target_stack,\n-\t\t\t(GET_CODE (block->end) == JUMP_INSN\n-\t\t\t ? EMIT_BEFORE : EMIT_AFTER));\n+\t  if (!BLOCK_INFO (e->dest)->done\n+\t      && e->dest != block)\n+\t    abort ();\n+          inserted |= compensate_edge (e, file);\n \t}\n-      else\n+    }\n+  for (e = block->pred; e ; e = e->pred_next)\n+    {\n+      if (e != beste && !(e->flags & EDGE_DFS_BACK)\n+\t  && e->src != ENTRY_BLOCK_PTR)\n \t{\n-\t  rtx seq, after;\n-\n-\t  /* We don't support abnormal edges.  Global takes care to\n-\t     avoid any live register across them, so we should never\n-\t     have to insert instructions on such edges.  */\n-\t  if (e->flags & EDGE_ABNORMAL)\n+\t  if (!BLOCK_INFO (e->src)->done)\n \t    abort ();\n-\n-\t  current_block = NULL;\n-\t  start_sequence ();\n-\t\t  \n-\t  /* ??? change_stack needs some point to emit insns after. \n-\t     Also needed to keep gen_sequence from returning a \n-\t     pattern as opposed to a sequence, which would lose\n-\t     REG_DEAD notes.  */\n-\t  after = emit_note (NULL, NOTE_INSN_DELETED);\n-\n-\t  tmpstack = regstack;\n-\t  change_stack (after, &tmpstack, target_stack, EMIT_BEFORE);\n-\n-\t  seq = gen_sequence ();\n-\t  end_sequence ();\n-\n-\t  insert_insn_on_edge (seq, e);\n-\t  inserted = 1;\n-\t  current_block = block;\n+          inserted |= compensate_edge (e, file);\n \t}\n     }\n \n@@ -2697,7 +2772,6 @@ convert_regs_2 (file, block)\n   sp = stack;\n \n   *sp++ = block;\n-  BLOCK_INFO (block)->done = 1;\n \n   inserted = 0;\n   do\n@@ -2706,12 +2780,14 @@ convert_regs_2 (file, block)\n \n       block = *--sp;\n       inserted |= convert_regs_1 (file, block);\n+      BLOCK_INFO (block)->done = 1;\n \n       for (e = block->succ; e ; e = e->succ_next)\n-\tif (! BLOCK_INFO (e->dest)->done)\n+\tif (! (e->flags & EDGE_DFS_BACK))\n \t  {\n-\t    *sp++ = e->dest;\n-\t    BLOCK_INFO (e->dest)->done = 1;\n+\t    BLOCK_INFO (e->dest)->predecesors--;\n+\t    if (!BLOCK_INFO (e->dest)->predecesors)\n+\t       *sp++ = e->dest;\n \t  }\n     }\n   while (sp != stack);"}, {"sha": "f3b50d14025a847515530e08df4f35018c6caee5", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0ecf09f9cc1ee9c4c2daa91d2f2a844013f81cdb", "patch": "@@ -3473,20 +3473,20 @@ rest_of_compilation (decl)\n   verify_flow_info ();\n #endif\n \n+  compute_bb_for_insn (get_max_uid ());\n+\n   /* If optimizing, then go ahead and split insns now.  */\n   if (optimize > 0)\n     split_all_insns (0);\n \n-  cleanup_cfg (0);\n+  cleanup_cfg (optimize ? CLEANUP_EXPENSIVE : 0);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,\n      can be represented as RTL.  Doing so lets us schedule insns between\n      it and the rest of the code and also allows delayed branch\n      scheduling to operate in the epilogue.  */\n   thread_prologue_and_epilogue_insns (insns);\n \n-  compute_bb_for_insn (get_max_uid ());\n-\n   if (optimize)\n     {\n       cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_CROSSJUMP);"}]}