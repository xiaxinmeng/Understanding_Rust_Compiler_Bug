{"sha": "9589f23ea556ef4d3b083a83e49156780b6b9cde", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU4OWYyM2VhNTU2ZWY0ZDNiMDgzYTgzZTQ5MTU2NzgwYjZiOWNkZQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-06-28T18:23:16Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-06-28T18:23:16Z"}, "message": "double-int.h (force_fit_type_double): Remove declaration.\n\n\t* double-int.h (force_fit_type_double): Remove declaration.\n\t* double-int.c (force_fit_type_double): Move to tree.c.\n\t* tree.h (force_fit_type_double): Declare.\n\t* tree.h (force_fit_type_double): Moved from double-int.c. Use\n\tdouble_int type for 'cst' argument. Use double_int_fits_to_tree_p and\n\tdouble_int_to_tree instead of fit_double_type and build_int_cst_wide.\n\t* convert.c (convert_to_pointer): Adjust call to\n\tforce_fit_type_double.\n\t* tree-vrp.c (extract_range_from_assert,\n\textract_range_from_unary_expr): Adjust call to force_fit_type_double.\n\t* fold-const.c: Update comment.\n\t(int_const_binop, fold_convert_const_int_from_int,\n\tfold_convert_const_int_from_real, fold_convert_const_int_from_fixed,\n\textract_muldiv_1, fold_div_compare, fold_sign_changed_comparison,\n\tfold_unary_loc, fold_negate_const, fold_abs_const, fold_not_const,\n\tround_up_loc): Adjust call to force_fit_type_double.\n\t\n/c-family\n\t* c-common.c (shorten_compare): Adjust call to force_fit_type_double.\n\nFrom-SVN: r161509", "tree": {"sha": "4667776860379c311babeb25f863259e7d46dbc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4667776860379c311babeb25f863259e7d46dbc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9589f23ea556ef4d3b083a83e49156780b6b9cde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9589f23ea556ef4d3b083a83e49156780b6b9cde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9589f23ea556ef4d3b083a83e49156780b6b9cde", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9589f23ea556ef4d3b083a83e49156780b6b9cde/comments", "author": null, "committer": null, "parents": [{"sha": "dfecaf599b25b0335a01a640821046564d0fa3f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfecaf599b25b0335a01a640821046564d0fa3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfecaf599b25b0335a01a640821046564d0fa3f3"}], "stats": {"total": 268, "additions": 134, "deletions": 134}, "files": [{"sha": "188a5ef838d9462dd4f0e39c4c1846d9710128e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -1,3 +1,22 @@\n+2010-06-28  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* double-int.h (force_fit_type_double): Remove declaration.\n+\t* double-int.c (force_fit_type_double): Move to tree.c.\n+\t* tree.h (force_fit_type_double): Declare.\n+\t* tree.h (force_fit_type_double): Moved from double-int.c. Use\n+\tdouble_int type for 'cst' argument. Use double_int_fits_to_tree_p and\n+\tdouble_int_to_tree instead of fit_double_type and build_int_cst_wide.\n+\t* convert.c (convert_to_pointer): Adjust call to\n+\tforce_fit_type_double.\n+\t* tree-vrp.c (extract_range_from_assert,\n+\textract_range_from_unary_expr): Adjust call to force_fit_type_double.\n+\t* fold-const.c: Update comment.\n+\t(int_const_binop, fold_convert_const_int_from_int,\n+\tfold_convert_const_int_from_real, fold_convert_const_int_from_fixed,\n+\textract_muldiv_1, fold_div_compare, fold_sign_changed_comparison,\n+\tfold_unary_loc, fold_negate_const, fold_abs_const, fold_not_const,\n+\tround_up_loc): Adjust call to force_fit_type_double.\n+\n 2010-06-28  Philipp Tomsich <philipp.tomsich@theobroma-systems.com>\n \n \t* config/rs6000/rs6000.h (PROCESSOR_TITAN): Declare."}, {"sha": "276b49e86501e054002a62d1e5e9d1c036e2964f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -1,3 +1,7 @@\n+2010-06-28  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* c-common.c (shorten_compare): Adjust call to force_fit_type_double.\n+\n 2010-06-28  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* c-cppbuiltin.c: Do not include except.h."}, {"sha": "3393093cc9e4b7c326e1b957e8e2045e7e562f91", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -3361,9 +3361,8 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t  /* Convert primop1 to target type, but do not introduce\n \t     additional overflow.  We know primop1 is an int_cst.  */\n \t  primop1 = force_fit_type_double (*restype_ptr,\n-\t\t\t\t\t   TREE_INT_CST_LOW (primop1),\n-\t\t\t\t\t   TREE_INT_CST_HIGH (primop1), 0,\n-\t\t\t\t\t   TREE_OVERFLOW (primop1));\n+\t\t\t\t\t   tree_to_double_int (primop1),\n+\t\t\t\t\t   0, TREE_OVERFLOW (primop1));\n \t}\n       if (type != *restype_ptr)\n \t{"}, {"sha": "f54b6d9adfe51b221ab5ecbf1035f8fdd4e04416", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -46,7 +46,8 @@ convert_to_pointer (tree type, tree expr)\n \n   /* Propagate overflow to the NULL pointer.  */\n   if (integer_zerop (expr))\n-    return force_fit_type_double (type, 0, 0, 0, TREE_OVERFLOW (expr));\n+    return force_fit_type_double (type, double_int_zero, 0,\n+\t\t\t\t  TREE_OVERFLOW (expr));\n \n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {"}, {"sha": "aa175e89d41410cd4518b31809594cb9d3349b80", "filename": "gcc/double-int.c", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -134,56 +134,6 @@ fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n   return l1 != low0 || h1 != high0;\n }\n \n-/* We force the double-int HIGH:LOW to the range of the type TYPE by\n-   sign or zero extending it.\n-   OVERFLOWABLE indicates if we are interested\n-   in overflow of the value, when >0 we are only interested in signed\n-   overflow, for <0 we are interested in any overflow.  OVERFLOWED\n-   indicates whether overflow has already occurred.  CONST_OVERFLOWED\n-   indicates whether constant overflow has already occurred.  We force\n-   T's value to be within range of T's type (by setting to 0 or 1 all\n-   the bits outside the type's range).  We set TREE_OVERFLOWED if,\n-  \tOVERFLOWED is nonzero,\n-\tor OVERFLOWABLE is >0 and signed overflow occurs\n-\tor OVERFLOWABLE is <0 and any overflow occurs\n-   We return a new tree node for the extended double-int.  The node\n-   is shared if no overflow flags are set.  */\n-\n-tree\n-force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n-\t\t       HOST_WIDE_INT high, int overflowable,\n-\t\t       bool overflowed)\n-{\n-  int sign_extended_type;\n-  bool overflow;\n-\n-  /* Size types *are* sign extended.  */\n-  sign_extended_type = (!TYPE_UNSIGNED (type)\n-\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t    && TYPE_IS_SIZETYPE (type)));\n-\n-  overflow = fit_double_type (low, high, &low, &high, type);\n-\n-  /* If we need to set overflow flags, return a new unshared node.  */\n-  if (overflowed || overflow)\n-    {\n-      if (overflowed\n-\t  || overflowable < 0\n-\t  || (overflowable > 0 && sign_extended_type))\n-\t{\n-          tree t = make_node (INTEGER_CST);\n-          TREE_INT_CST_LOW (t) = low;\n-          TREE_INT_CST_HIGH (t) = high;\n-          TREE_TYPE (t) = type;\n-\t  TREE_OVERFLOW (t) = 1;\n-\t  return t;\n-\t}\n-    }\n-\n-  /* Else build a shared node.  */\n-  return build_int_cst_wide (type, low, high);\n-}\n-\n /* Add two doubleword integers with doubleword result.\n    Return nonzero if the operation overflows according to UNSIGNED_P.\n    Each argument is given as two `HOST_WIDE_INT' pieces."}, {"sha": "6af0757990c5b37952542d2db51dff26b6b44c64", "filename": "gcc/double-int.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -269,8 +269,6 @@ double_int_equal_p (double_int cst1, double_int cst2)\n \n /* Legacy interface with decomposed high/low parts.  */\n \n-extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t   int, bool);\n extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n \t\t\t    const_tree);"}, {"sha": "e2b30f90e8d1e7be03226e88f606fc171e8afe2f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 52, "deletions": 70, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -27,8 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n   @@ This would also make life easier when this technology is used\n   @@ for cross-compilers.  */\n \n-/* The entry points in this file are fold, size_int_wide, size_binop\n-   and force_fit_type_double.\n+/* The entry points in this file are fold, size_int_wide and size_binop.\n \n    fold takes a tree as argument and returns a simplified tree.\n \n@@ -39,10 +38,6 @@ along with GCC; see the file COPYING3.  If not see\n    size_int takes an integer value, and creates a tree constant\n    with type from `sizetype'.\n \n-   force_fit_type_double takes a constant, an overflowable flag and a\n-   prior overflow indicator.  It forces the value to fit the type and\n-   sets TREE_OVERFLOW.\n-\n    Note: Since the folders get called on non-gimple code as well as\n    gimple code, we need to handle GIMPLE tuples as well as their\n    corresponding tree equivalents.  */\n@@ -141,7 +136,7 @@ static tree fold_inf_compare (location_t, enum tree_code, tree, tree, tree);\n static tree fold_div_compare (location_t, enum tree_code, tree, tree, tree);\n static bool reorder_operands_p (const_tree, const_tree);\n static tree fold_negate_const (tree, tree);\n-static tree fold_not_const (tree, tree);\n+static tree fold_not_const (const_tree, tree);\n static tree fold_relational_const (enum tree_code, tree, tree, tree);\n static tree fold_convert_const (enum tree_code, tree, tree);\n \n@@ -1077,7 +1072,7 @@ int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2, int notr\n \t}\n     }\n   else\n-    t = force_fit_type_double (TREE_TYPE (arg1), res.low, res.high, 1,\n+    t = force_fit_type_double (TREE_TYPE (arg1), res, 1,\n \t\t\t       ((!uns || is_sizetype) && overflow)\n \t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n \n@@ -1510,8 +1505,7 @@ fold_convert_const_int_from_int (tree type, const_tree arg1)\n \n   /* Given an integer constant, make new constant with new type,\n      appropriately sign-extended or truncated.  */\n-  t = force_fit_type_double (type, TREE_INT_CST_LOW (arg1),\n-\t\t\t     TREE_INT_CST_HIGH (arg1),\n+  t = force_fit_type_double (type, tree_to_double_int (arg1),\n \t\t\t     !POINTER_TYPE_P (TREE_TYPE (arg1)),\n \t\t\t     (TREE_INT_CST_HIGH (arg1) < 0\n \t\t \t      && (TYPE_UNSIGNED (type)\n@@ -1591,8 +1585,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n   if (! overflow)\n     real_to_integer2 ((HOST_WIDE_INT *) &val.low, &val.high, &r);\n \n-  t = force_fit_type_double (type, val.low, val.high, -1,\n-\t\t\t     overflow | TREE_OVERFLOW (arg1));\n+  t = force_fit_type_double (type, val, -1, overflow | TREE_OVERFLOW (arg1));\n   return t;\n }\n \n@@ -1635,7 +1628,7 @@ fold_convert_const_int_from_fixed (tree type, const_tree arg1)\n \n   /* Given a fixed-point constant, make new constant with new type,\n      appropriately sign-extended or truncated.  */\n-  t = force_fit_type_double (type, temp.low, temp.high, -1,\n+  t = force_fit_type_double (type, temp, -1,\n \t\t\t     (double_int_negative_p (temp)\n \t\t \t      && (TYPE_UNSIGNED (type)\n \t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n@@ -5947,8 +5940,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t  && 0 != (t1 = int_const_binop (MULT_EXPR,\n \t\t\t\t\t fold_convert (ctype, op1),\n \t\t\t\t\t fold_convert (ctype, c), 1))\n-\t  && 0 != (t1 = force_fit_type_double (ctype, TREE_INT_CST_LOW (t1),\n-\t\t\t\t\t       TREE_INT_CST_HIGH (t1),\n+\t  && 0 != (t1 = force_fit_type_double (ctype, tree_to_double_int (t1),\n \t\t\t\t\t       (TYPE_UNSIGNED (ctype)\n \t\t\t\t\t        && tcode != MULT_EXPR) ? -1 : 1,\n \t\t\t\t\t       TREE_OVERFLOW (t1)))\n@@ -6352,8 +6344,7 @@ fold_div_compare (location_t loc,\n   tree prod, tmp, hi, lo;\n   tree arg00 = TREE_OPERAND (arg0, 0);\n   tree arg01 = TREE_OPERAND (arg0, 1);\n-  unsigned HOST_WIDE_INT lpart;\n-  HOST_WIDE_INT hpart;\n+  double_int val;\n   bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (arg0));\n   bool neg_overflow;\n   int overflow;\n@@ -6364,9 +6355,8 @@ fold_div_compare (location_t loc,\n \t\t\t\t   TREE_INT_CST_HIGH (arg01),\n \t\t\t\t   TREE_INT_CST_LOW (arg1),\n \t\t\t\t   TREE_INT_CST_HIGH (arg1),\n-\t\t\t\t   &lpart, &hpart, unsigned_p);\n-  prod = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n-\t\t\t\t-1, overflow);\n+\t\t\t\t   &val.low, &val.high, unsigned_p);\n+  prod = force_fit_type_double (TREE_TYPE (arg00), val, -1, overflow);\n   neg_overflow = false;\n \n   if (unsigned_p)\n@@ -6380,8 +6370,8 @@ fold_div_compare (location_t loc,\n \t\t\t\t       TREE_INT_CST_HIGH (prod),\n \t\t\t\t       TREE_INT_CST_LOW (tmp),\n \t\t\t\t       TREE_INT_CST_HIGH (tmp),\n-\t\t\t\t       &lpart, &hpart, unsigned_p);\n-      hi = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n+\t\t\t\t       &val.low, &val.high, unsigned_p);\n+      hi = force_fit_type_double (TREE_TYPE (arg00), val,\n \t\t\t\t  -1, overflow | TREE_OVERFLOW (prod));\n     }\n   else if (tree_int_cst_sgn (arg01) >= 0)\n@@ -6834,9 +6824,8 @@ fold_sign_changed_comparison (location_t loc, enum tree_code code, tree type,\n     return NULL_TREE;\n \n   if (TREE_CODE (arg1) == INTEGER_CST)\n-    arg1 = force_fit_type_double (inner_type, TREE_INT_CST_LOW (arg1),\n-\t\t\t\t  TREE_INT_CST_HIGH (arg1), 0,\n-\t\t\t\t  TREE_OVERFLOW (arg1));\n+    arg1 = force_fit_type_double (inner_type, tree_to_double_int (arg1),\n+\t\t\t\t  0, TREE_OVERFLOW (arg1));\n   else\n     arg1 = fold_convert_loc (loc, inner_type, arg1);\n \n@@ -7941,9 +7930,8 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n \t    }\n \t  if (change)\n \t    {\n-\t      tem = force_fit_type_double (type, TREE_INT_CST_LOW (and1),\n-\t\t\t\t\t   TREE_INT_CST_HIGH (and1), 0,\n-\t\t\t\t\t   TREE_OVERFLOW (and1));\n+\t      tem = force_fit_type_double (type, tree_to_double_int (and1),\n+\t\t\t\t\t   0, TREE_OVERFLOW (and1));\n \t      return fold_build2_loc (loc, BIT_AND_EXPR, type,\n \t\t\t\t  fold_convert_loc (loc, type, and0), tem);\n \t    }\n@@ -15139,12 +15127,10 @@ fold_negate_const (tree arg0, tree type)\n     {\n     case INTEGER_CST:\n       {\n-\tunsigned HOST_WIDE_INT low;\n-\tHOST_WIDE_INT high;\n-\tint overflow = neg_double (TREE_INT_CST_LOW (arg0),\n-\t\t\t\t   TREE_INT_CST_HIGH (arg0),\n-\t\t\t\t   &low, &high);\n-\tt = force_fit_type_double (type, low, high, 1,\n+\tdouble_int val = tree_to_double_int (arg0);\n+\tint overflow = neg_double (val.low, val.high, &val.low, &val.high);\n+\n+\tt = force_fit_type_double (type, val, 1,\n \t\t\t\t   (overflow | TREE_OVERFLOW (arg0))\n \t\t\t\t   && !TYPE_UNSIGNED (type));\n \tbreak;\n@@ -15187,25 +15173,26 @@ fold_abs_const (tree arg0, tree type)\n   switch (TREE_CODE (arg0))\n     {\n     case INTEGER_CST:\n-      /* If the value is unsigned, then the absolute value is\n-\t the same as the ordinary value.  */\n-      if (TYPE_UNSIGNED (type))\n-\tt = arg0;\n-      /* Similarly, if the value is non-negative.  */\n-      else if (INT_CST_LT (integer_minus_one_node, arg0))\n-\tt = arg0;\n-      /* If the value is negative, then the absolute value is\n-\t its negation.  */\n-      else\n-\t{\n-\t  unsigned HOST_WIDE_INT low;\n-\t  HOST_WIDE_INT high;\n-\t  int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n-\t\t\t\t     TREE_INT_CST_HIGH (arg0),\n-\t\t\t\t     &low, &high);\n-\t  t = force_fit_type_double (type, low, high, -1,\n-\t\t\t\t     overflow | TREE_OVERFLOW (arg0));\n-\t}\n+      {\n+\tdouble_int val = tree_to_double_int (arg0);\n+\n+        /* If the value is unsigned or non-negative, then the absolute value\n+\t   is the same as the ordinary value.  */\n+\tif (TYPE_UNSIGNED (type)\n+\t    || !double_int_negative_p (val))\n+\t  t = arg0;\n+\n+\t/* If the value is negative, then the absolute value is\n+\t   its negation.  */\n+\telse\n+\t  {\n+\t    int overflow;\n+\n+\t    overflow = neg_double (val.low, val.high, &val.low, &val.high);\n+\t    t = force_fit_type_double (type, val, -1,\n+\t\t\t\t       overflow | TREE_OVERFLOW (arg0));\n+\t  }\n+      }\n       break;\n \n     case REAL_CST:\n@@ -15226,17 +15213,14 @@ fold_abs_const (tree arg0, tree type)\n    constant.  TYPE is the type of the result.  */\n \n static tree\n-fold_not_const (tree arg0, tree type)\n+fold_not_const (const_tree arg0, tree type)\n {\n-  tree t = NULL_TREE;\n+  double_int val;  \n \n   gcc_assert (TREE_CODE (arg0) == INTEGER_CST);\n \n-  t = force_fit_type_double (type, ~TREE_INT_CST_LOW (arg0),\n-\t\t\t     ~TREE_INT_CST_HIGH (arg0), 0,\n-\t\t\t     TREE_OVERFLOW (arg0));\n-\n-  return t;\n+  val = double_int_not (tree_to_double_int (arg0));\n+  return force_fit_type_double (type, val, 0, TREE_OVERFLOW (arg0));\n }\n \n /* Given CODE, a relational operator, the target type, TYPE and two\n@@ -15634,25 +15618,23 @@ round_up_loc (location_t loc, tree value, int divisor)\n     {\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n-\t  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (value);\n-\t  unsigned HOST_WIDE_INT high;\n+\t  double_int val = tree_to_double_int (value);\n \t  bool overflow_p;\n \n-\t  if ((low & (divisor - 1)) == 0)\n+\t  if ((val.low & (divisor - 1)) == 0)\n \t    return value;\n \n \t  overflow_p = TREE_OVERFLOW (value);\n-\t  high = TREE_INT_CST_HIGH (value);\n-\t  low &= ~(divisor - 1);\n-\t  low += divisor;\n-\t  if (low == 0)\n+\t  val.low &= ~(divisor - 1);\n+\t  val.low += divisor;\n+\t  if (val.low == 0)\n \t    {\n-\t      high++;\n-\t      if (high == 0)\n+\t      val.high++;\n+\t      if (val.high == 0)\n \t\toverflow_p = true;\n \t    }\n \n-\t  return force_fit_type_double (TREE_TYPE (value), low, high,\n+\t  return force_fit_type_double (TREE_TYPE (value), val,\n \t\t\t\t\t-1, overflow_p);\n \t}\n       else"}, {"sha": "590fa74efc84d0e3564aa0f4fe7abf214822b6f5", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -1511,10 +1511,10 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n       /* Make sure to not set TREE_OVERFLOW on the final type\n \t conversion.  We are willingly interpreting large positive\n \t unsigned values as negative singed values here.  */\n-      min = force_fit_type_double (TREE_TYPE (var), TREE_INT_CST_LOW (min),\n-\t\t\t\t   TREE_INT_CST_HIGH (min), 0, false);\n-      max = force_fit_type_double (TREE_TYPE (var), TREE_INT_CST_LOW (max),\n-\t\t\t\t   TREE_INT_CST_HIGH (max), 0, false);\n+      min = force_fit_type_double (TREE_TYPE (var), tree_to_double_int (min),\n+\t\t\t\t   0, false);\n+      max = force_fit_type_double (TREE_TYPE (var), tree_to_double_int (max),\n+\t\t\t\t   0, false);\n \n       /* We can transform a max, min range to an anti-range or\n          vice-versa.  Use set_and_canonicalize_value_range which does\n@@ -2787,11 +2787,11 @@ extract_range_from_unary_expr (value_range_t *vr, enum tree_code code,\n \t{\n \t  tree new_min, new_max;\n \t  new_min = force_fit_type_double (outer_type,\n-\t\t\t\t\t   TREE_INT_CST_LOW (vr0.min),\n-\t\t\t\t\t   TREE_INT_CST_HIGH (vr0.min), 0, 0);\n+\t\t\t\t\t   tree_to_double_int (vr0.min),\n+\t\t\t\t\t   0, false);\n \t  new_max = force_fit_type_double (outer_type,\n-\t\t\t\t\t   TREE_INT_CST_LOW (vr0.max),\n-\t\t\t\t\t   TREE_INT_CST_HIGH (vr0.max), 0, 0);\n+\t\t\t\t\t   tree_to_double_int (vr0.max),\n+\t\t\t\t\t   0, false);\n \t  if (is_overflow_infinity (vr0.min))\n \t    new_min = negative_overflow_infinity (outer_type);\n \t  if (is_overflow_infinity (vr0.max))"}, {"sha": "de83e64cea1a7b123484ba090a2641efda70e32c", "filename": "gcc/tree.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -1092,6 +1092,52 @@ double_int_fits_to_tree_p (const_tree type, double_int cst)\n   return double_int_equal_p (cst, ext);\n }\n \n+/* We force the double_int CST to the range of the type TYPE by sign or\n+   zero extending it.  OVERFLOWABLE indicates if we are interested in\n+   overflow of the value, when >0 we are only interested in signed\n+   overflow, for <0 we are interested in any overflow.  OVERFLOWED\n+   indicates whether overflow has already occurred.  CONST_OVERFLOWED\n+   indicates whether constant overflow has already occurred.  We force\n+   T's value to be within range of T's type (by setting to 0 or 1 all\n+   the bits outside the type's range).  We set TREE_OVERFLOWED if,\n+        OVERFLOWED is nonzero,\n+        or OVERFLOWABLE is >0 and signed overflow occurs\n+        or OVERFLOWABLE is <0 and any overflow occurs\n+   We return a new tree node for the extended double_int.  The node\n+   is shared if no overflow flags are set.  */\n+\n+\n+tree\n+force_fit_type_double (tree type, double_int cst, int overflowable,\n+\t\t       bool overflowed)\n+{\n+  bool sign_extended_type;\n+\n+  /* Size types *are* sign extended.  */\n+  sign_extended_type = (!TYPE_UNSIGNED (type)\n+                        || (TREE_CODE (type) == INTEGER_TYPE\n+                            && TYPE_IS_SIZETYPE (type)));\n+\n+  /* If we need to set overflow flags, return a new unshared node.  */\n+  if (overflowed || !double_int_fits_to_tree_p(type, cst))\n+    {\n+      if (overflowed\n+\t  || overflowable < 0\n+\t  || (overflowable > 0 && sign_extended_type))\n+\t{\n+\t  tree t = make_node (INTEGER_CST);\n+\t  TREE_INT_CST (t) = double_int_ext (cst, TYPE_PRECISION (type),\n+\t\t\t\t\t     !sign_extended_type);\n+\t  TREE_TYPE (t) = type;\n+\t  TREE_OVERFLOW (t) = 1;\n+\t  return t;\n+\t}\n+    }\n+\n+  /* Else build a shared node.  */\n+  return double_int_to_tree (type, cst);\n+}\n+\n /* These are the hash table functions for the hash table of INTEGER_CST\n    nodes of a sizetype.  */\n "}, {"sha": "b3ba5493fd4221323b3ddf1ddca56676977226ab", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9589f23ea556ef4d3b083a83e49156780b6b9cde/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9589f23ea556ef4d3b083a83e49156780b6b9cde", "patch": "@@ -4014,6 +4014,7 @@ tree_to_double_int (const_tree cst)\n \n extern tree double_int_to_tree (tree, double_int);\n extern bool double_int_fits_to_tree_p (const_tree, double_int);\n+extern tree force_fit_type_double (tree, double_int, int, bool);\n \n /* Create an INT_CST node with a CST value zero extended.  */\n "}]}