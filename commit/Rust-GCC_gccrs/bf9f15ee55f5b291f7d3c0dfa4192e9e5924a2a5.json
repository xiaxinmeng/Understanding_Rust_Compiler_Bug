{"sha": "bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY5ZjE1ZWU1NWY1YjI5MWY3ZDNjMGRmYTQxOTJlOWU1OTI0YTJhNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-25T20:37:05Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-10-25T20:37:05Z"}, "message": "re PR fortran/45516 ([F08] allocatable compontents of recursive type)\n\n2016-10-25  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/45516\n\t* class.c (gfc_find_derived_vtab): Detect recursive allocatable\n\tderived type components. If present, add '_deallocate' field to\n\tthe vtable and build the '__deallocate' function.\n\t* decl.c (build_struct): Allow recursive allocatable derived\n\ttype components for -std=f2008 or more.\n\t(gfc_match_data_decl): Accept these derived types.\n\t* expr.c (gfc_has_default_initializer): Ditto.\n\t* resolve.c (resolve_component): Make sure that the vtable is\n\tbuilt for these derived types.\n\t* trans-array.c(structure_alloc_comps) : Use the '__deallocate'\n\tfunction for the automatic deallocation of these types.\n\t* trans-expr.c : Generate the deallocate accessor.\n\t* trans.h : Add its prototype.\n\t* trans-types.c (gfc_get_derived_type): Treat the recursive\n\tallocatable components in the same way as the corresponding\n\tpointer components.\n\n2016-10-25  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/45516\n\t* gfortran.dg/class_2.f03: Set -std=f2003.\n\t* gfortran.dg/finalize_21.f90: Modify tree-dump.\n\t* gfortran.dg/recursive_alloc_comp_1.f08: New test.\n\t* gfortran.dg/recursive_alloc_comp_2.f08: New test.\n\t* gfortran.dg/recursive_alloc_comp_3.f08: New test.\n\t* gfortran.dg/recursive_alloc_comp_4.f08: New test.\n\nFrom-SVN: r241539", "tree": {"sha": "33e3819d2249321176e33000909dc5e9aa0125fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33e3819d2249321176e33000909dc5e9aa0125fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/comments", "author": null, "committer": null, "parents": [{"sha": "7c7dae654283dec6c03cd689ce3a5182b47fc5a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c7dae654283dec6c03cd689ce3a5182b47fc5a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c7dae654283dec6c03cd689ce3a5182b47fc5a0"}], "stats": {"total": 482, "additions": 464, "deletions": 18}, "files": [{"sha": "400c22abaf5795976f793043ea76a6d55860e358", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -1347,6 +1347,8 @@ finalizer_insert_packed_call (gfc_code *block, gfc_finalizer *fini,\n   block->next->resolved_sym = fini->proc_tree->n.sym;\n   block->next->ext.actual = gfc_get_actual_arglist ();\n   block->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+  block->next->ext.actual->next = gfc_get_actual_arglist ();\n+  block->next->ext.actual->next->expr = gfc_copy_expr (size_expr);\n \n   /* ELSE.  */\n \n@@ -2191,6 +2193,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   gfc_symbol *vtab = NULL, *vtype = NULL, *found_sym = NULL, *def_init = NULL;\n   gfc_symbol *copy = NULL, *src = NULL, *dst = NULL;\n   gfc_gsymbol *gsym = NULL;\n+  gfc_symbol *dealloc = NULL, *arg = NULL;\n \n   /* Find the top-level namespace.  */\n   for (ns = gfc_current_ns; ns; ns = ns->parent)\n@@ -2255,6 +2258,20 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t    {\n \t      gfc_component *c;\n \t      gfc_symbol *parent = NULL, *parent_vtab = NULL;\n+\t      bool rdt = false;\n+\n+\t      /* Is this a derived type with recursive allocatable\n+\t\t components?  */\n+\t      c = (derived->attr.unlimited_polymorphic\n+\t\t   || derived->attr.abstract) ?\n+\t\t  NULL : derived->components;\n+\t      for (; c; c= c->next)\n+\t\tif (c->ts.type == BT_DERIVED\n+\t\t    && c->ts.u.derived == derived)\n+\t\t  {\n+\t\t    rdt = true;\n+\t\t    break;\n+\t\t  }\n \n \t      gfc_get_symbol (name, ns, &vtype);\n \t      if (!gfc_add_flavor (&vtype->attr, FL_DERIVED, NULL,\n@@ -2427,6 +2444,66 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      c->tb->ppc = 1;\n \t      generate_finalization_wrapper (derived, ns, tname, c);\n \n+\t      /* Add component _deallocate.  */\n+\t      if (!gfc_add_component (vtype, \"_deallocate\", &c))\n+\t\tgoto cleanup;\n+\t      c->attr.proc_pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->tb = XCNEW (gfc_typebound_proc);\n+\t      c->tb->ppc = 1;\n+\t      if (derived->attr.unlimited_polymorphic\n+\t\t  || derived->attr.abstract\n+\t\t  || !rdt)\n+\t\tc->initializer = gfc_get_null_expr (NULL);\n+\t      else\n+\t\t{\n+\t\t  /* Set up namespace.  */\n+\t\t  gfc_namespace *sub_ns = gfc_get_namespace (ns, 0);\n+\n+\t\t  sub_ns->sibling = ns->contained;\n+\t\t  ns->contained = sub_ns;\n+\t\t  sub_ns->resolved = 1;\n+\t\t  /* Set up procedure symbol.  */\n+\t\t  sprintf (name, \"__deallocate_%s\", tname);\n+\t\t  gfc_get_symbol (name, sub_ns, &dealloc);\n+\t\t  sub_ns->proc_name = dealloc;\n+\t\t  dealloc->attr.flavor = FL_PROCEDURE;\n+\t\t  dealloc->attr.subroutine = 1;\n+\t\t  dealloc->attr.pure = 1;\n+\t\t  dealloc->attr.artificial = 1;\n+\t\t  dealloc->attr.if_source = IFSRC_DECL;\n+\n+\t\t  if (ns->proc_name->attr.flavor == FL_MODULE)\n+\t\t    dealloc->module = ns->proc_name->name;\n+\t\t  gfc_set_sym_referenced (dealloc);\n+\t\t  /* Set up formal argument.  */\n+\t\t  gfc_get_symbol (\"arg\", sub_ns, &arg);\n+\t\t  arg->ts.type = BT_DERIVED;\n+\t\t  arg->ts.u.derived = derived;\n+\t\t  arg->attr.flavor = FL_VARIABLE;\n+\t\t  arg->attr.dummy = 1;\n+\t\t  arg->attr.artificial = 1;\n+\t\t  arg->attr.intent = INTENT_INOUT;\n+\t\t  arg->attr.dimension = 1;\n+\t\t  arg->attr.allocatable = 1;\n+\t\t  arg->as = gfc_get_array_spec();\n+\t\t  arg->as->type = AS_ASSUMED_SHAPE;\n+\t\t  arg->as->rank = 1;\n+\t\t  arg->as->lower[0] = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t\t\t\tNULL, 1);\n+\t\t  gfc_set_sym_referenced (arg);\n+\t\t  dealloc->formal = gfc_get_formal_arglist ();\n+\t\t  dealloc->formal->sym = arg;\n+\t\t  /* Set up code.  */\n+\t\t  sub_ns->code = gfc_get_code (EXEC_DEALLOCATE);\n+\t\t  sub_ns->code->ext.alloc.list = gfc_get_alloc ();\n+\t\t  sub_ns->code->ext.alloc.list->expr\n+\t\t\t\t= gfc_lval_expr_from_sym (arg);\n+\t\t  /* Set initializer.  */\n+\t\t  c->initializer = gfc_lval_expr_from_sym (dealloc);\n+\t\t  c->ts.interface = dealloc;\n+\t\t}\n+\n \t      /* Add procedure pointers for type-bound procedures.  */\n \t      if (!derived->attr.unlimited_polymorphic)\n \t\tadd_procs_to_declared_vtab (derived, vtype);\n@@ -2456,6 +2533,10 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \tgfc_commit_symbol (src);\n       if (dst)\n \tgfc_commit_symbol (dst);\n+      if (dealloc)\n+\tgfc_commit_symbol (dealloc);\n+      if (arg)\n+\tgfc_commit_symbol (arg);\n     }\n   else\n     gfc_undo_symbols ();"}, {"sha": "f18eb41bc50f6aa51e58a870819297b216804f92", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -1858,9 +1858,18 @@ build_struct (const char *name, gfc_charlen *cl, gfc_expr **init,\n       && current_ts.u.derived == gfc_current_block ()\n       && current_attr.pointer == 0)\n     {\n+      if (current_attr.allocatable\n+\t  && !gfc_notify_std(GFC_STD_F2008, \"Component at %C \"\n+\t\t\t     \"must have the POINTER attribute\"))\n+\t{\n+\t  return false;\n+\t}\n+      else if (current_attr.allocatable == 0)\n+\t{\n       gfc_error (\"Component at %C must have the POINTER attribute\");\n       return false;\n     }\n+    }\n \n   if (gfc_current_block ()->attr.pointer && (*as)->rank != 0)\n     {\n@@ -4844,6 +4853,10 @@ gfc_match_data_decl (void)\n       if (current_attr.pointer && gfc_comp_struct (gfc_current_state ()))\n \tgoto ok;\n \n+      if (current_attr.allocatable && gfc_current_state () == COMP_DERIVED\n+\t  && current_ts.u.derived == gfc_current_block ())\n+\tgoto ok;\n+\n       gfc_find_symbol (current_ts.u.derived->name,\n \t\t       current_ts.u.derived->ns, 1, &sym);\n "}, {"sha": "ed639a7a7e4d7a6c88c15c8c4d818432d314f224", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -3249,7 +3249,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform,\n   if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER\n       && lvalue->symtree->n.sym->attr.data\n       && !gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L used to \"\n-\t\t\t  \"initialize non-integer variable %qs\", \n+\t\t\t  \"initialize non-integer variable %qs\",\n \t\t\t  &rvalue->where, lvalue->symtree->n.sym->name))\n     return false;\n   else if (rvalue->is_boz && !lvalue->symtree->n.sym->attr.data\n@@ -3378,7 +3378,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t    }\n \n \t  if (!gfc_notify_std (GFC_STD_F2003, \"Bounds specification \"\n-\t\t\t       \"for %qs in pointer assignment at %L\", \n+\t\t\t       \"for %qs in pointer assignment at %L\",\n \t\t\t       lvalue->symtree->n.sym->name, &lvalue->where))\n \t    return false;\n \n@@ -4144,6 +4144,7 @@ gfc_has_default_initializer (gfc_symbol *der)\n     if (gfc_bt_struct (c->ts.type))\n       {\n         if (!c->attr.pointer && !c->attr.proc_pointer\n+\t     && !(c->attr.allocatable && der == c->ts.u.derived)\n \t     && gfc_has_default_initializer (c->ts.u.derived))\n \t  return true;\n \tif (c->attr.pointer && c->initializer)\n@@ -4196,7 +4197,7 @@ gfc_default_initializer (gfc_typespec *ts)\n }\n \n \n-/* Get or generate an expression for a default initializer of a derived type. \n+/* Get or generate an expression for a default initializer of a derived type.\n    If -finit-derived is specified, generate default initialization expressions\n    for components that lack them when generate is set.  */\n \n@@ -5318,21 +5319,21 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t\t{\n \t\t  gfc_constructor *c, *n;\n \t\t  gfc_expr *ec, *en;\n-\t\t  \n+\n \t\t  for (c = gfc_constructor_first (arr->value.constructor);\n \t\t       c != NULL; c = gfc_constructor_next (c))\n \t\t    {\n \t\t      if (c == NULL || c->iterator != NULL)\n \t\t\tcontinue;\n-\t\t      \n+\n \t\t      ec = c->expr;\n \n \t\t      for (n = gfc_constructor_next (c); n != NULL;\n \t\t\t   n = gfc_constructor_next (n))\n \t\t\t{\n \t\t\t  if (n->iterator != NULL)\n \t\t\t    continue;\n-\t\t\t  \n+\n \t\t\t  en = n->expr;\n \t\t\t  if (gfc_dep_compare_expr (ec, en) == 0)\n \t\t\t    {\n@@ -5349,6 +5350,6 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t\t    }\n \t\t}\n \t    }\n-  \n+\n   return true;\n }"}, {"sha": "785203b4dc271cc3d7f28e5b605d830d61678ee6", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -13598,6 +13598,13 @@ resolve_component (gfc_component *c, gfc_symbol *sym)\n       return false;\n     }\n \n+  /* If an allocatable component derived type is of the same type as\n+     the enclosing derived type, we need a vtable generating so that\n+     the __deallocate procedure is created.  */\n+  if ((c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+       && c->ts.u.derived == sym && c->attr.allocatable == 1)\n+    gfc_find_vtab (&c->ts);\n+\n   /* Ensure that all the derived type components are put on the\n      derived type list; even in formal namespaces, where derived type\n      pointer components might not have been declared.  */"}, {"sha": "74935b181f68a22074d99cf6e72f0d2276edb2aa", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 95, "deletions": 7, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -8004,7 +8004,9 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n   tree vref, dref;\n   tree null_cond = NULL_TREE;\n   tree add_when_allocated;\n+  tree dealloc_fndecl;\n   bool called_dealloc_with_status;\n+  gfc_symbol *vtab;\n \n   gfc_init_block (&fnblock);\n \n@@ -8109,6 +8111,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       bool cmp_has_alloc_comps = (c->ts.type == BT_DERIVED\n \t\t\t\t  || c->ts.type == BT_CLASS)\n \t\t\t\t    && c->ts.u.derived->attr.alloc_comp;\n+      bool same_type = c->ts.type == BT_DERIVED && der_type == c->ts.u.derived;\n+\n       cdecl = c->backend_decl;\n       ctype = TREE_TYPE (cdecl);\n \n@@ -8140,15 +8144,16 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  if (c->attr.allocatable && !c->attr.proc_pointer\n \t      && (c->attr.dimension\n \t\t  || (c->attr.codimension\n-\t\t      && purpose != DEALLOCATE_ALLOC_COMP_NO_CAF)))\n+\t\t      && purpose != DEALLOCATE_ALLOC_COMP_NO_CAF))\n+\t      && !same_type)\n \t    {\n \t      if (comp == NULL_TREE)\n \t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t\tdecl, cdecl, NULL_TREE);\n \t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension, NULL);\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n-\t  else if (c->attr.allocatable && !c->attr.codimension)\n+\t  else if (c->attr.allocatable && !c->attr.codimension && !same_type)\n \t    {\n \t      /* Allocatable scalar components.  */\n \t      if (comp == NULL_TREE)\n@@ -8165,6 +8170,89 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t     build_int_cst (TREE_TYPE (comp), 0));\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n+\t  else if (c->attr.allocatable && !c->attr.codimension)\n+\t    {\n+\t      /* Case of recursive allocatable derived types.  */\n+\t      tree is_allocated;\n+\t      tree ubound;\n+\t      tree cdesc;\n+\t      tree zero = build_int_cst (gfc_array_index_type, 0);\n+\t      tree unity = build_int_cst (gfc_array_index_type, 1);\n+\t      tree data;\n+\t      stmtblock_t dealloc_block;\n+\n+\t      gfc_init_block (&dealloc_block);\n+\n+\t      /* Convert the component into a rank 1 descriptor type.  */\n+\t      if (comp == NULL_TREE)\n+\t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t\tdecl, cdecl, NULL_TREE);\n+\n+\t      if (c->attr.dimension)\n+\t\t{\n+\t\t  tmp = gfc_get_element_type (TREE_TYPE (comp));\n+\t\t  ubound = gfc_full_array_size (&dealloc_block, comp, c->as->rank);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tmp = TREE_TYPE (comp);\n+\t\t  ubound = build_int_cst (gfc_array_index_type, 1);\n+\t\t}\n+\n+\t      cdesc = gfc_get_array_type_bounds (tmp, 1, 0,\n+\t\t\t\t\t\t &unity, &ubound, 1,\n+\t\t\t\t\t\t GFC_ARRAY_ALLOCATABLE, false);\n+\n+\t      cdesc = gfc_create_var (cdesc, \"cdesc\");\n+\t      DECL_ARTIFICIAL (cdesc) = 1;\n+\n+\t      gfc_add_modify (&dealloc_block, gfc_conv_descriptor_dtype (cdesc),\n+\t\t\t      gfc_get_dtype_rank_type (1, tmp));\n+\t      gfc_conv_descriptor_lbound_set (&dealloc_block, cdesc,\n+\t\t\t\t\t      zero, unity);\n+\t      gfc_conv_descriptor_stride_set (&dealloc_block, cdesc,\n+\t\t\t\t\t      zero, unity);\n+\t      gfc_conv_descriptor_ubound_set (&dealloc_block, cdesc,\n+\t\t\t\t\t      zero, ubound);\n+\n+\t      if (c->attr.dimension)\n+\t\tdata = gfc_conv_descriptor_data_get (comp);\n+\t      else\n+\t\tdata = comp;\n+\n+\t      gfc_conv_descriptor_data_set (&dealloc_block, cdesc, data);\n+\n+\t      /* Now call the deallocator.  */\n+\t      vtab = gfc_find_vtab (&c->ts);\n+\t      if (vtab->backend_decl == NULL)\n+\t\tgfc_get_symbol_decl (vtab);\n+\t      tmp = gfc_build_addr_expr (NULL_TREE, vtab->backend_decl);\n+\t      dealloc_fndecl = gfc_vptr_deallocate_get (tmp);\n+\t      dealloc_fndecl = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t    dealloc_fndecl);\n+\t      tmp = build_int_cst (TREE_TYPE (data), 0);\n+\t      is_allocated = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t      boolean_type_node, tmp,\n+\t\t\t\t\t      data);\n+\t      cdesc = gfc_build_addr_expr (NULL_TREE, cdesc);\n+\n+\t      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t\t dealloc_fndecl, 1,\n+\t\t\t\t\t cdesc);\n+\t      gfc_add_expr_to_block (&dealloc_block, tmp);\n+\n+\t      tmp = gfc_finish_block (&dealloc_block);\n+\n+\t      tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node, is_allocated, tmp,\n+\t\t\t\t     build_empty_stmt (input_location));\n+\n+\t      gfc_add_expr_to_block (&tmpblock, tmp);\n+\n+\t      gfc_add_modify (&tmpblock, data,\n+\t\t\t      build_int_cst (TREE_TYPE (data), 0));\n+\t    }\n+\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable\n \t\t   && (!CLASS_DATA (c)->attr.codimension\n \t\t       || purpose != DEALLOCATE_ALLOC_COMP_NO_CAF))\n@@ -8227,6 +8315,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  if (cmp_has_alloc_comps\n \t\t&& !c->attr.pointer && !c->attr.proc_pointer\n+\t\t&& !same_type\n \t\t&& !called_dealloc_with_status)\n \t    {\n \t      /* Do not deallocate the components of ultimate pointer\n@@ -8414,8 +8503,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t     components that are really allocated, the deep copy code has to\n \t     be generated first and then added to the if-block in\n \t     gfc_duplicate_allocatable ().  */\n-\t  if (cmp_has_alloc_comps\n-\t      && !c->attr.proc_pointer)\n+\t  if (cmp_has_alloc_comps && !c->attr.proc_pointer\n+\t      && !same_type)\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = fold_convert (TREE_TYPE (dcmp), comp);\n@@ -8448,9 +8537,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t   false, false, size, NULL_TREE);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n-\t  else if (c->attr.allocatable && !c->attr.proc_pointer\n-\t\t   && (!(cmp_has_alloc_comps && c->as)\n-\t\t       || c->attr.codimension))\n+\t  else if (c->attr.allocatable && !c->attr.proc_pointer && !same_type\n+\t\t   && (!(cmp_has_alloc_comps && c->as) || c->attr.codimension))\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      if (c->attr.codimension)"}, {"sha": "689ea7e4ef351dff7d6499a42058b91df32edc27", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -158,6 +158,7 @@ gfc_get_ultimate_alloc_ptr_comps_caf_token (gfc_se *outerse, gfc_expr *expr)\n #define VTABLE_DEF_INIT_FIELD 3\n #define VTABLE_COPY_FIELD 4\n #define VTABLE_FINAL_FIELD 5\n+#define VTABLE_DEALLOCATE_FIELD 6\n \n \n tree\n@@ -300,6 +301,7 @@ VTAB_GET_FIELD_GEN (extends, VTABLE_EXTENDS_FIELD)\n VTAB_GET_FIELD_GEN (def_init, VTABLE_DEF_INIT_FIELD)\n VTAB_GET_FIELD_GEN (copy, VTABLE_COPY_FIELD)\n VTAB_GET_FIELD_GEN (final, VTABLE_FINAL_FIELD)\n+VTAB_GET_FIELD_GEN (deallocate, VTABLE_DEALLOCATE_FIELD)\n \n \n /* The size field is returned as an array index type.  Therefore treat"}, {"sha": "eda0351119acaa8cba60c5af25ef14fd69cbc64a", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -2524,7 +2524,11 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n \t     non-procedure pointer components have no backend_decl.  */\n \t  for (c = derived->components; c; c = c->next)\n \t    {\n-\t      if (!c->attr.proc_pointer && c->backend_decl == NULL)\n+\t      bool same_alloc_type = c->attr.allocatable\n+\t\t\t\t     && derived == c->ts.u.derived;\n+\t      if (!c->attr.proc_pointer\n+\t\t  && !same_alloc_type\n+\t\t  && c->backend_decl == NULL)\n \t\tbreak;\n \t      else if (c->next == NULL)\n \t\treturn derived->backend_decl;\n@@ -2556,13 +2560,17 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n      will be built and so we can return the type.  */\n   for (c = derived->components; c; c = c->next)\n     {\n+      bool same_alloc_type = c->attr.allocatable\n+\t\t\t     && derived == c->ts.u.derived;\n+\n       if (c->ts.type == BT_UNION && c->ts.u.derived->backend_decl == NULL)\n         c->ts.u.derived->backend_decl = gfc_get_union_type (c->ts.u.derived);\n \n       if (c->ts.type != BT_DERIVED && c->ts.type != BT_CLASS)\n \tcontinue;\n \n-      if ((!c->attr.pointer && !c->attr.proc_pointer)\n+      if ((!c->attr.pointer && !c->attr.proc_pointer\n+\t  && !same_alloc_type)\n \t  || c->ts.u.derived->backend_decl == NULL)\n \tc->ts.u.derived->backend_decl = gfc_get_derived_type (c->ts.u.derived,\n \t\t\t\t\t\t\t      in_coarray\n@@ -2596,6 +2604,8 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n      types are built as part of gfc_get_union_type.  */\n   for (c = derived->components; c; c = c->next)\n     {\n+      bool same_alloc_type = c->attr.allocatable\n+\t\t\t     && derived == c->ts.u.derived;\n       /* Prevent infinite recursion, when the procedure pointer type is\n \t the same as derived, by forcing the procedure pointer component to\n \t be built as if the explicit interface does not exist.  */\n@@ -2656,7 +2666,7 @@ gfc_get_derived_type (gfc_symbol * derived, bool in_coarray)\n \t       && !(unlimited_entity && c == derived->components))\n \tfield_type = build_pointer_type (field_type);\n \n-      if (c->attr.pointer)\n+      if (c->attr.pointer || same_alloc_type)\n \tfield_type = gfc_nonrestricted_type (field_type);\n \n       /* vtype fields can point to different types to the base type.  */"}, {"sha": "4306200eb03bb72ea0d5ead6ac29dc6431275c73", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -403,6 +403,7 @@ tree gfc_vptr_extends_get (tree);\n tree gfc_vptr_def_init_get (tree);\n tree gfc_vptr_copy_get (tree);\n tree gfc_vptr_final_get (tree);\n+tree gfc_vptr_deallocate_get (tree);\n void gfc_reset_vptr (stmtblock_t *, gfc_expr *);\n void gfc_reset_len (stmtblock_t *, gfc_expr *);\n tree gfc_get_vptr_from_expr (tree);"}, {"sha": "58b0b4ad572af1c027d2f4d8bdf9c4435baf12af", "filename": "gcc/testsuite/gfortran.dg/class_2.f03", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_2.f03?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n !\n ! PR 40940: CLASS statement\n !"}, {"sha": "5a8fec3d1399c3a85bf2b908370e722d8ccbfe9e", "filename": "gcc/testsuite/gfortran.dg/finalize_21.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_21.f90?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -8,4 +8,4 @@\n class(*), allocatable :: var\n end\n \n-! { dg-final { scan-tree-dump \"static struct __vtype__STAR __vtab__STAR = {._hash=0, ._size=., ._extends=0B, ._def_init=0B, ._copy=0B, ._final=0B};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"static struct __vtype__STAR __vtab__STAR = {._hash=0, ._size=., ._extends=0B, ._def_init=0B, ._copy=0B, ._final=0B, ._deallocate=0B};\" \"original\" } }"}, {"sha": "383eff49106b0e563ffe53a88529c94fb2039573", "filename": "gcc/testsuite/gfortran.dg/recursive_alloc_comp_1.f08", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_1.f08?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -0,0 +1,70 @@\n+! { dg-do run }\n+!\n+! Tests functionality of recursive allocatable derived types.\n+!\n+  type :: recurses\n+    type(recurses), allocatable :: c\n+    integer, allocatable :: ia\n+  end type\n+\n+  type(recurses), allocatable, target :: a, d\n+  type(recurses), pointer :: b\n+\n+  integer :: total = 0\n+\n+! Check chained allocation.\n+  allocate(a)\n+  a%ia = 1\n+  allocate (a%c)\n+  a%c%ia = 2\n+\n+! Check move_alloc.\n+  allocate (d)\n+  d%ia = 3\n+  call move_alloc (d, a%c%c)\n+\n+  if (a%ia .ne. 1)  call abort\n+  if (a%c%ia .ne. 2)  call abort\n+  if (a%c%c%ia .ne. 3)  call abort\n+\n+! Check that we can point anywhere in the chain\n+  b => a%c%c\n+  if (b%ia .ne. 3) call abort\n+  b => a%c\n+  if (b%ia .ne. 2) call abort\n+\n+! Check that the pointer can be used as if it were an element in the chain.\n+  if (.not.allocated (b%c)) call abort\n+  b => a%c%c\n+  if (.not.allocated (b%c)) allocate (b%c)\n+  b%c%ia = 4\n+  if (a%c%c%c%ia .ne. 4) call abort\n+\n+! A rudimentary iterator.\n+  b => a\n+  do while (associated (b))\n+    total = total + b%ia\n+    b => b%c\n+  end do\n+  if (total .ne. 10) call abort\n+\n+! Take one element out of the chain.\n+  call move_alloc (a%c%c, d)\n+  call move_alloc (d%c, a%c%c)\n+  if (d%ia .ne. 3) call abort\n+  deallocate (d)\n+\n+! Checkcount of remaining chain.\n+  total = 0\n+  b => a\n+  do while (associated (b))\n+    total = total + b%ia\n+    b => b%c\n+  end do\n+  if (total .ne. 7) call abort\n+\n+! Deallocate to check that there are no memory leaks.\n+  deallocate (a%c%c)\n+  deallocate (a%c)\n+  deallocate (a)\n+end"}, {"sha": "85ab14b9a48a6b3be2050b3a0895f2cd367f9fed", "filename": "gcc/testsuite/gfortran.dg/recursive_alloc_comp_2.f08", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_2.f08?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+!\n+! Tests functionality of recursive allocatable derived types.\n+!\n+module m\n+  type :: recurses\n+    type(recurses), allocatable :: left\n+    type(recurses), allocatable :: right\n+    integer, allocatable :: ia\n+  end type\n+contains\n+! Obtain checksum from \"keys\".\n+  recursive function foo (this) result (res)\n+    type(recurses) :: this\n+    integer :: res\n+    res = this%ia\n+    if (allocated (this%left)) res = res + foo (this%left)\n+    if (allocated (this%right)) res = res + foo (this%right)\n+  end function\n+! Return pointer to member of binary tree matching \"key\", null otherwise.\n+  recursive function bar (this, key) result (res)\n+    type(recurses), target :: this\n+    type(recurses), pointer :: res\n+    integer :: key\n+    if (key .eq. this%ia) then\n+      res => this\n+      return\n+    else\n+      res => NULL ()\n+    end if\n+    if (allocated (this%left)) res => bar (this%left, key)\n+    if (associated (res)) return\n+    if (allocated (this%right)) res => bar (this%right, key)\n+  end function\n+end module\n+\n+  use m\n+  type(recurses), allocatable, target :: a\n+  type(recurses), pointer :: b => NULL ()\n+\n+! Check chained allocation.\n+  allocate(a)\n+  a%ia = 1\n+  allocate (a%left)\n+  a%left%ia = 2\n+  allocate (a%left%left)\n+  a%left%left%ia = 3\n+  allocate (a%left%right)\n+  a%left%right%ia = 4\n+  allocate (a%right)\n+  a%right%ia = 5\n+\n+! Checksum OK?\n+  if (foo(a) .ne. 15) call abort\n+\n+! Return pointer to tree item that is present.\n+  b => bar (a, 3)\n+  if (.not.associated (b) .or. (b%ia .ne. 3)) call abort\n+! Return NULL to tree item that is not present.\n+  b => bar (a, 6)\n+  if (associated (b)) call abort\n+\n+! Deallocate to check that there are no memory leaks.\n+  deallocate (a)\n+end"}, {"sha": "d7f8f6622be884ca085aa975b2086cb2169a3b4d", "filename": "gcc/testsuite/gfortran.dg/recursive_alloc_comp_3.f08", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_3.f08?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+!\n+! Tests functionality of recursive allocatable derived types.\n+!\n+module m\n+  type :: stack\n+    integer :: value\n+    integer :: index\n+    type(stack), allocatable :: next\n+  end type stack\n+end module\n+\n+  use m\n+! Here is how to add a new entry at the top of the stack:\n+  type (stack), allocatable :: top, temp, dum\n+\n+  call poke (1)\n+  call poke (2)\n+  call poke (3)\n+  if (top%index .ne. 3) call abort\n+  call output (top)\n+  call pop\n+  if (top%index .ne. 2) call abort\n+  call output (top)\n+  deallocate (top)\n+contains\n+  subroutine output (arg)\n+    type(stack), target, allocatable :: arg\n+    type(stack), pointer :: ptr\n+\n+    if (.not.allocated (arg)) then\n+      print *, \"empty stack\"\n+      return\n+    end if\n+\n+    print *, \"        idx           value\"\n+    ptr => arg\n+    do while (associated (ptr))\n+      print *, ptr%index, \"   \", ptr%value\n+      ptr => ptr%next\n+    end do\n+  end subroutine\n+  subroutine poke(arg)\n+    integer :: arg\n+    integer :: idx\n+    if (allocated (top)) then\n+      idx = top%index + 1\n+    else\n+      idx = 1\n+    end if\n+    allocate (temp)\n+    temp%value = arg\n+    temp%index = idx\n+    call move_alloc(top,temp%next)\n+    call move_alloc(temp,top)\n+  end subroutine\n+  subroutine pop\n+    call move_alloc(top%next,temp)\n+    call move_alloc(temp,top)\n+  end subroutine\n+end"}, {"sha": "75fd8b0d368ee60ef96419008abaabbd7ad31f8f", "filename": "gcc/testsuite/gfortran.dg/recursive_alloc_comp_4.f08", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_alloc_comp_4.f08?ref=bf9f15ee55f5b291f7d3c0dfa4192e9e5924a2a5", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+!\n+! Tests functionality of recursive allocatable derived types.\n+! Here the recursive components are arrays, unlike the first three testcases.\n+! Notice that array components are fiendishly difficult to use :-(\n+!\n+module m\n+  type :: recurses\n+    type(recurses), allocatable :: c(:)\n+    integer, allocatable :: ia\n+  end type\n+end module\n+\n+  use m\n+  type(recurses), allocatable, target :: a, d(:)\n+  type(recurses), pointer :: b1\n+\n+  integer :: total = 0\n+\n+! Check chained allocation.\n+  allocate(a)\n+  a%ia = 1\n+  allocate (a%c(2))\n+  b1 => a%c(1)\n+  b1%ia = 2\n+\n+! Check move_alloc.\n+  allocate (d(2))\n+  d(1)%ia = 3\n+  d(2)%ia = 4\n+  b1 => d(2)\n+  allocate (b1%c(1))\n+  b1  => b1%c(1)\n+  b1%ia = 5\n+  call move_alloc (d, a%c(2)%c)\n+\n+  if (a%ia .ne. 1) call abort\n+  if (a%c(1)%ia .ne. 2) call abort\n+  if (a%c(2)%c(1)%ia .ne. 3) call abort\n+  if (a%c(2)%c(2)%ia .ne. 4) call abort\n+  if (a%c(2)%c(2)%c(1)%ia .ne. 5) call abort\n+\n+  if (allocated (a)) deallocate (a)\n+  if (allocated (d)) deallocate (d)\n+\n+end"}]}