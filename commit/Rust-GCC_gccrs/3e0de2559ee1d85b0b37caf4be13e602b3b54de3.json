{"sha": "3e0de2559ee1d85b0b37caf4be13e602b3b54de3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UwZGUyNTU5ZWUxZDg1YjBiMzdjYWY0YmUxM2U2MDJiM2I1NGRlMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-10-15T14:49:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-10-15T14:49:55Z"}, "message": "fold-const.c (extract_array_ref): Remove.\n\n2007-10-15  Richard Guenther  <rguenther@suse.de>\n\n\t* fold-const.c (extract_array_ref): Remove.\n\t(fold_comparison): Handle POINTER_PLUS_EXPR with the\n\tgeneric address expression comparison folding.  Remove\n\tthe folding that used extract_array_ref.\n\nFrom-SVN: r129347", "tree": {"sha": "0c9d6236480184c56c0e7a9812cdd2724203adb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c9d6236480184c56c0e7a9812cdd2724203adb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e0de2559ee1d85b0b37caf4be13e602b3b54de3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0de2559ee1d85b0b37caf4be13e602b3b54de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0de2559ee1d85b0b37caf4be13e602b3b54de3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0de2559ee1d85b0b37caf4be13e602b3b54de3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb64c8e52fb187e24ad8d9789ee22cdf1ae69f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb64c8e52fb187e24ad8d9789ee22cdf1ae69f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb64c8e52fb187e24ad8d9789ee22cdf1ae69f12"}], "stats": {"total": 136, "additions": 22, "deletions": 114}, "files": [{"sha": "12452b5bfa9c4d427e08ff94275dcb1e1b7da4cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e0de2559ee1d85b0b37caf4be13e602b3b54de3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e0de2559ee1d85b0b37caf4be13e602b3b54de3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e0de2559ee1d85b0b37caf4be13e602b3b54de3", "patch": "@@ -1,3 +1,10 @@\n+2007-10-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* fold-const.c (extract_array_ref): Remove.\n+\t(fold_comparison): Handle POINTER_PLUS_EXPR with the\n+\tgeneric address expression comparison folding.  Remove\n+\tthe folding that used extract_array_ref.\n+\n 2007-10-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \tPR target/33133"}, {"sha": "fd5a7085e91307ecde12774abee04bb7de100656", "filename": "gcc/fold-const.c", "status": "modified", "additions": 15, "deletions": 114, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e0de2559ee1d85b0b37caf4be13e602b3b54de3/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e0de2559ee1d85b0b37caf4be13e602b3b54de3/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3e0de2559ee1d85b0b37caf4be13e602b3b54de3", "patch": "@@ -6322,76 +6322,6 @@ constant_boolean_node (int value, tree type)\n }\n \n \n-/* Return true if expr looks like an ARRAY_REF and set base and\n-   offset to the appropriate trees.  If there is no offset,\n-   offset is set to NULL_TREE.  Base will be canonicalized to\n-   something you can get the element type from using\n-   TREE_TYPE (TREE_TYPE (base)).  Offset will be the offset\n-   in bytes to the base in sizetype.  */\n-\n-static bool\n-extract_array_ref (tree expr, tree *base, tree *offset)\n-{\n-  /* One canonical form is a PLUS_EXPR with the first\n-     argument being an ADDR_EXPR with a possible NOP_EXPR\n-     attached.  */\n-  if (TREE_CODE (expr) == POINTER_PLUS_EXPR)\n-    {\n-      tree op0 = TREE_OPERAND (expr, 0);\n-      tree inner_base, dummy1;\n-      /* Strip NOP_EXPRs here because the C frontends and/or\n-\t folders present us (int *)&x.a p+ 4 possibly.  */\n-      STRIP_NOPS (op0);\n-      if (extract_array_ref (op0, &inner_base, &dummy1))\n-\t{\n-\t  *base = inner_base;\n-\t  *offset = fold_convert (sizetype, TREE_OPERAND (expr, 1));\n-\t  if (dummy1 != NULL_TREE)\n-\t    *offset = fold_build2 (PLUS_EXPR, sizetype,\n-\t\t\t\t   dummy1, *offset);\n-\t  return true;\n-\t}\n-    }\n-  /* Other canonical form is an ADDR_EXPR of an ARRAY_REF,\n-     which we transform into an ADDR_EXPR with appropriate\n-     offset.  For other arguments to the ADDR_EXPR we assume\n-     zero offset and as such do not care about the ADDR_EXPR\n-     type and strip possible nops from it.  */\n-  else if (TREE_CODE (expr) == ADDR_EXPR)\n-    {\n-      tree op0 = TREE_OPERAND (expr, 0);\n-      if (TREE_CODE (op0) == ARRAY_REF)\n-\t{\n-\t  tree idx = TREE_OPERAND (op0, 1);\n-\t  *base = TREE_OPERAND (op0, 0);\n-\t  *offset = fold_build2 (MULT_EXPR, TREE_TYPE (idx), idx,\n-\t\t\t\t array_ref_element_size (op0)); \n-\t  *offset = fold_convert (sizetype, *offset);\n-\t}\n-      else\n-\t{\n-\t  /* Handle array-to-pointer decay as &a.  */\n-\t  if (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE)\n-\t    *base = TREE_OPERAND (expr, 0);\n-\t  else\n-\t    *base = expr;\n-\t  *offset = NULL_TREE;\n-\t}\n-      return true;\n-    }\n-  /* The next canonical form is a VAR_DECL with POINTER_TYPE.  */\n-  else if (SSA_VAR_P (expr)\n-\t   && TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n-    {\n-      *base = expr;\n-      *offset = NULL_TREE;\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-\n /* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.\n    Transform, `a + (x < y)' into `(x < y) ? (a + 1) : (a + 0)'.  Here\n    CODE corresponds to the `+', COND to the `(b ? x : y)' or `(x < y)'\n@@ -8802,11 +8732,13 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \n   /* For comparisons of pointers we can decompose it to a compile time\n      comparison of the base objects and the offsets into the object.\n-     This requires at least one operand being an ADDR_EXPR to do more\n-     than the operand_equal_p test below.  */\n+     This requires at least one operand being an ADDR_EXPR or a\n+     POINTER_PLUS_EXPR to do more than the operand_equal_p test below.  */\n   if (POINTER_TYPE_P (TREE_TYPE (arg0))\n       && (TREE_CODE (arg0) == ADDR_EXPR\n-\t  || TREE_CODE (arg1) == ADDR_EXPR))\n+\t  || TREE_CODE (arg1) == ADDR_EXPR\n+\t  || TREE_CODE (arg0) == POINTER_PLUS_EXPR\n+\t  || TREE_CODE (arg1) == POINTER_PLUS_EXPR))\n     {\n       tree base0, base1, offset0 = NULL_TREE, offset1 = NULL_TREE;\n       HOST_WIDE_INT bitsize, bitpos0 = 0, bitpos1 = 0;\n@@ -8828,6 +8760,11 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t  else\n \t    indirect_base0 = true;\n \t}\n+      else if (TREE_CODE (arg0) == POINTER_PLUS_EXPR)\n+\t{\n+\t  base0 = TREE_OPERAND (arg0, 0);\n+\t  offset0 = TREE_OPERAND (arg0, 1);\n+\t}\n \n       base1 = arg1;\n       if (TREE_CODE (arg1) == ADDR_EXPR)\n@@ -8843,6 +8780,11 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t  else if (!indirect_base0)\n \t    base1 = NULL_TREE;\n \t}\n+      else if (TREE_CODE (arg1) == POINTER_PLUS_EXPR)\n+\t{\n+\t  base1 = TREE_OPERAND (arg1, 0);\n+\t  offset1 = TREE_OPERAND (arg1, 1);\n+\t}\n       else if (indirect_base0)\n \tbase1 = NULL_TREE;\n \n@@ -8904,47 +8846,6 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t}\n     }\n \n-  /* If this is a comparison of two exprs that look like an ARRAY_REF of the\n-     same object, then we can fold this to a comparison of the two offsets in\n-     signed size type.  This is possible because pointer arithmetic is\n-     restricted to retain within an object and overflow on pointer differences\n-     is undefined as of 6.5.6/8 and /9 with respect to the signed ptrdiff_t.\n-\n-     We check flag_wrapv directly because pointers types are unsigned,\n-     and therefore TYPE_OVERFLOW_WRAPS returns true for them.  That is\n-     normally what we want to avoid certain odd overflow cases, but\n-     not here.  */\n-  if (POINTER_TYPE_P (TREE_TYPE (arg0))\n-      && !flag_wrapv\n-      && !TYPE_OVERFLOW_TRAPS (TREE_TYPE (arg0)))\n-    {\n-      tree base0, offset0, base1, offset1;\n-\n-      if (extract_array_ref (arg0, &base0, &offset0)\n-\t  && extract_array_ref (arg1, &base1, &offset1)\n-\t  && operand_equal_p (base0, base1, 0))\n-        {\n-\t  tree signed_size_type_node;\n-\t  signed_size_type_node = signed_type_for (size_type_node);\n-\n-\t  /* By converting to signed size type we cover middle-end pointer\n-\t     arithmetic which operates on unsigned pointer types of size\n-\t     type size and ARRAY_REF offsets which are properly sign or\n-\t     zero extended from their type in case it is narrower than\n-\t     size type.  */\n-\t  if (offset0 == NULL_TREE)\n-\t    offset0 = build_int_cst (signed_size_type_node, 0);\n-\t  else\n-\t    offset0 = fold_convert (signed_size_type_node, offset0);\n-\t  if (offset1 == NULL_TREE)\n-\t    offset1 = build_int_cst (signed_size_type_node, 0);\n-\t  else\n-\t    offset1 = fold_convert (signed_size_type_node, offset1);\n-\n-\t  return fold_build2 (code, type, offset0, offset1);\n-\t}\n-    }\n-\n   /* Transform comparisons of the form X +- C1 CMP Y +- C2 to\n      X CMP Y +- C2 +- C1 for signed X, Y.  This is valid if\n      the resulting offset is smaller in absolute value than the"}]}