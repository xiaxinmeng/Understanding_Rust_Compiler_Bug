{"sha": "2298018014e5c94bb4de93a2da576d5bde88e1d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI5ODAxODAxNGU1Yzk0YmI0ZGU5M2EyZGE1NzZkNWJkZTg4ZTFkMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-03-23T01:36:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-03-23T01:36:22Z"}, "message": "gc_locks.h [IA64]: Include ia64intrin.h.\n\n        * include/private/gc_locks.h [IA64]: Include ia64intrin.h.\n        (GC_test_and_set): Use __sync_lock_test_and_set.\n        (GC_clear): Use volatile assignment.\n        (GC_compare_and_exchange): Use __sync_bool_compare_and_swap.\n        (GC_memory_write_barrier): Use __sync_synchronize.\n\nFrom-SVN: r64736", "tree": {"sha": "324ada7c1baba88f8948d16ca4ff31c12b710017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/324ada7c1baba88f8948d16ca4ff31c12b710017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2298018014e5c94bb4de93a2da576d5bde88e1d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2298018014e5c94bb4de93a2da576d5bde88e1d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2298018014e5c94bb4de93a2da576d5bde88e1d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2298018014e5c94bb4de93a2da576d5bde88e1d0/comments", "author": null, "committer": null, "parents": [{"sha": "086bfb7a463e8c2ec5dc158630b436cdfe497f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/086bfb7a463e8c2ec5dc158630b436cdfe497f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/086bfb7a463e8c2ec5dc158630b436cdfe497f0e"}], "stats": {"total": 29, "additions": 15, "deletions": 14}, "files": [{"sha": "fc5cbe746a9050c9540f7939919bc04acf7acd5c", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2298018014e5c94bb4de93a2da576d5bde88e1d0/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2298018014e5c94bb4de93a2da576d5bde88e1d0/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=2298018014e5c94bb4de93a2da576d5bde88e1d0", "patch": "@@ -1,3 +1,11 @@\n+2003-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* include/private/gc_locks.h [IA64]: Include ia64intrin.h.\n+\t(GC_test_and_set): Use __sync_lock_test_and_set.\n+\t(GC_clear): Use volatile assignment.\n+\t(GC_compare_and_exchange): Use __sync_bool_compare_and_swap.\n+\t(GC_memory_write_barrier): Use __sync_synchronize.\n+\n 2003-03-12  Andreas Schwab  <schwab@suse.de>\n \n \t* configure.in: Avoid trailing /. in toolexeclibdir."}, {"sha": "9b91ada917a5ca0f6e7cf487c0ff9932d7bfded1", "filename": "boehm-gc/include/private/gc_locks.h", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2298018014e5c94bb4de93a2da576d5bde88e1d0/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2298018014e5c94bb4de93a2da576d5bde88e1d0/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=2298018014e5c94bb4de93a2da576d5bde88e1d0", "patch": "@@ -100,17 +100,13 @@\n #      define GC_TEST_AND_SET_DEFINED\n #    endif\n #    if defined(IA64)\n+#     include <ia64intrin.h>\n        inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t  long oldval, n = 1;\n-\t  __asm__ __volatile__(\"xchg4 %0=%1,%2\"\n-\t\t: \"=r\"(oldval), \"=m\"(*addr)\n-\t\t: \"r\"(n), \"1\"(*addr) : \"memory\");\n-\t  return oldval;\n+\t  return __sync_lock_test_and_set(addr, 1);\n        }\n #      define GC_TEST_AND_SET_DEFINED\n-       /* Should this handle post-increment addressing?? */\n        inline static void GC_clear(volatile unsigned int *addr) {\n-\t __asm__ __volatile__(\"st4.rel %0=r0\" : \"=m\" (*addr) : : \"memory\");\n+\t  *addr = 0;\n        }\n #      define GC_CLEAR_DEFINED\n #    endif\n@@ -326,20 +322,17 @@\n #     if defined(IA64)\n #      if !defined(GENERIC_COMPARE_AND_SWAP)\n          inline static GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n-\t\t\t\t\t\t       GC_word old, GC_word new_val) \n+\t\t\t\t\t\t       GC_word old,\n+\t\t\t\t\t\t       GC_word new_val) \n \t {\n-\t  unsigned long oldval;\n-\t  __asm__ __volatile__(\"mov ar.ccv=%4 ;; cmpxchg8.rel %0=%1,%2,ar.ccv\"\n-\t\t: \"=r\"(oldval), \"=m\"(*addr)\n-\t\t: \"r\"(new_val), \"1\"(*addr), \"r\"(old) : \"memory\");\n-\t  return (oldval == old);\n+\t   return __sync_bool_compare_and_swap (addr, old, new_val);\n          }\n #      endif /* !GENERIC_COMPARE_AND_SWAP */\n #      if 0\n \t/* Shouldn't be needed; we use volatile stores instead. */\n         inline static void GC_memory_write_barrier()\n         {\n-          __asm__ __volatile__(\"mf\" : : : \"memory\");\n+          __sync_synchronize ();\n         }\n #      endif /* 0 */\n #     endif /* IA64 */"}]}