{"sha": "65a9ca823e1aa1996badc22db84b8641d1487e61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVhOWNhODIzZTFhYTE5OTZiYWRjMjJkYjg0Yjg2NDFkMTQ4N2U2MQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-09-03T19:41:11Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-09-03T19:41:11Z"}, "message": "re PR fortran/45186 (Gfortran 4.5.0 emits wrong linenumbers)\n\n2010-09-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45186\n        * trans-intrinsic.c (gfc_conv_intrinsic_sign,\n        gfc_conv_intrinsic_leadz): Use build_call_expr_loc instead\n        of build_call_expr.\n        * trans-expr.c (gfc_conv_expr_present, gfc_conv_missing_dummy,\n        gfc_conv_string_length, gfc_conv_substring,\n        gfc_conv_component_ref, gfc_conv_unary_op, gfc_conv_powi,\n        gfc_conv_cst_int_power, gfc_conv_string_tmp, gfc_conv_concat_op,\n        gfc_conv_expr_op, gfc_build_compare_string,\n        gfc_set_interface_mapping_bounds, gfc_conv_subref_array_arg,\n        gfc_conv_derived_to_class, conv_isocbinding_procedure,\n        gfc_conv_procedure_call, fill_with_spaces,\n        gfc_trans_string_copy, gfc_trans_alloc_subarray_assign,\n        gfc_trans_structure_assign, gfc_trans_pointer_assignment,\n        gfc_trans_scalar_assign, gfc_trans_zero_assign,\n        gfc_trans_array_copy, gfc_trans_array_constructor_copy): Change\n        fold_build[0-9] to fold_build[0-9]_loc.\n        * trans-io.c (set_parameter_const, set_parameter_value,\n        set_parameter_ref, gfc_convert_array_to_string, set_string,\n        set_internal_unit, io_result, set_error_locus,\n        nml_get_addr_expr, build_dt): Ditto.\n        * trans-openmp.c (gfc_omp_clause_default_ctor,\n        gfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n        gfc_trans_omp_array_reduction, gfc_trans_omp_atomic,\n        gfc_trans_omp_do): Ditto.\n        * trans.c (gfc_add_modify, gfc_build_addr_expr,\n        gfc_build_array_ref, gfc_trans_runtime_error_vararg,\n        gfc_trans_runtime_check, gfc_call_malloc,\n        gfc_allocate_with_status, gfc_allocate_array_with_status,\n        gfc_call_free, gfc_deallocate_with_status,\n        gfc_call_realloc): Ditto.\n\nFrom-SVN: r163838", "tree": {"sha": "d6fb9f3d998506e57cc1eca0b909f93dda31d37e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6fb9f3d998506e57cc1eca0b909f93dda31d37e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65a9ca823e1aa1996badc22db84b8641d1487e61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a9ca823e1aa1996badc22db84b8641d1487e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65a9ca823e1aa1996badc22db84b8641d1487e61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a9ca823e1aa1996badc22db84b8641d1487e61/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d78301422a49df7a588e9b6a3c037ddb4c55e153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d78301422a49df7a588e9b6a3c037ddb4c55e153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d78301422a49df7a588e9b6a3c037ddb4c55e153"}], "stats": {"total": 937, "additions": 539, "deletions": 398}, "files": [{"sha": "517ca841f0e823102aead35a8422742314eb6d2b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=65a9ca823e1aa1996badc22db84b8641d1487e61", "patch": "@@ -1,3 +1,37 @@\n+2010-09-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45186\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_sign,\n+\tgfc_conv_intrinsic_leadz): Use build_call_expr_loc instead\n+\tof build_call_expr.\n+\t* trans-expr.c (gfc_conv_expr_present, gfc_conv_missing_dummy,\n+\tgfc_conv_string_length, gfc_conv_substring,\n+\tgfc_conv_component_ref, gfc_conv_unary_op, gfc_conv_powi,\n+\tgfc_conv_cst_int_power, gfc_conv_string_tmp, gfc_conv_concat_op,\n+\tgfc_conv_expr_op, gfc_build_compare_string,\n+\tgfc_set_interface_mapping_bounds, gfc_conv_subref_array_arg,\n+\tgfc_conv_derived_to_class, conv_isocbinding_procedure,\n+\tgfc_conv_procedure_call, fill_with_spaces,\n+\tgfc_trans_string_copy, gfc_trans_alloc_subarray_assign,\n+\tgfc_trans_structure_assign, gfc_trans_pointer_assignment,\n+\tgfc_trans_scalar_assign, gfc_trans_zero_assign,\n+\tgfc_trans_array_copy, gfc_trans_array_constructor_copy): Change\n+\tfold_build[0-9] to fold_build[0-9]_loc.\n+\t* trans-io.c (set_parameter_const, set_parameter_value,\n+\tset_parameter_ref, gfc_convert_array_to_string, set_string,\n+\tset_internal_unit, io_result, set_error_locus,\n+\tnml_get_addr_expr, build_dt): Ditto.\n+\t* trans-openmp.c (gfc_omp_clause_default_ctor,\n+\tgfc_omp_clause_copy_ctor, gfc_omp_clause_assign_op,\n+\tgfc_trans_omp_array_reduction, gfc_trans_omp_atomic,\n+\tgfc_trans_omp_do): Ditto.\n+\t* trans.c (gfc_add_modify, gfc_build_addr_expr,\n+\tgfc_build_array_ref, gfc_trans_runtime_error_vararg,\n+\tgfc_trans_runtime_check, gfc_call_malloc,\n+\tgfc_allocate_with_status, gfc_allocate_array_with_status,\n+\tgfc_call_free, gfc_deallocate_with_status,\n+\tgfc_call_realloc): Ditto.\n+\n 2010-09-03  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/45159"}, {"sha": "8f1bddc5e591cff20eee7cc2d899eb9bae5e352b", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 232, "deletions": 184, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=65a9ca823e1aa1996badc22db84b8641d1487e61", "patch": "@@ -137,8 +137,8 @@ gfc_conv_expr_present (gfc_symbol * sym)\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n \n-  cond = fold_build2 (NE_EXPR, boolean_type_node, decl,\n-\t\t      fold_convert (TREE_TYPE (decl), null_pointer_node));\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, decl,\n+\t\t\t  fold_convert (TREE_TYPE (decl), null_pointer_node));\n \n   /* Fortran 2008 allows to pass null pointers and non-associated pointers\n      as actual argument to denote absent dummies. For array descriptors,\n@@ -150,9 +150,10 @@ gfc_conv_expr_present (gfc_symbol * sym)\n       tree tmp;\n       tmp = build_fold_indirect_ref_loc (input_location, decl);\n       tmp = gfc_conv_array_data (tmp);\n-      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n-\t\t\t fold_convert (TREE_TYPE (tmp), null_pointer_node));\n-      cond = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node, cond, tmp);\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t\t\t     fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+      cond = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t      boolean_type_node, cond, tmp);\n     }\n \n   return cond;\n@@ -193,8 +194,8 @@ gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n   if (ts.type == BT_CHARACTER)\n     {\n       tmp = build_int_cst (gfc_charlen_type_node, 0);\n-      tmp = fold_build3 (COND_EXPR, gfc_charlen_type_node,\n-\t\t\t present, se->string_length, tmp);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, gfc_charlen_type_node,\n+\t\t\t     present, se->string_length, tmp);\n       tmp = gfc_evaluate_now (tmp, &se->pre);\n       se->string_length = tmp;\n     }\n@@ -358,8 +359,8 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n   gcc_assert (cl->length);\n \n   gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n-  se.expr = fold_build2 (MAX_EXPR, gfc_charlen_type_node, se.expr,\n-\t\t\t build_int_cst (gfc_charlen_type_node, 0));\n+  se.expr = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n+\t\t\t     se.expr, build_int_cst (gfc_charlen_type_node, 0));\n   gfc_add_block_to_block (pblock, &se.pre);\n \n   if (cl->backend_decl)\n@@ -423,14 +424,16 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n     {\n-      tree nonempty = fold_build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t   start.expr, end.expr);\n+      tree nonempty = fold_build2_loc (input_location, LE_EXPR,\n+\t\t\t\t       boolean_type_node, start.expr,\n+\t\t\t\t       end.expr);\n \n       /* Check lower bound.  */\n-      fault = fold_build2 (LT_EXPR, boolean_type_node, start.expr,\n-                           build_int_cst (gfc_charlen_type_node, 1));\n-      fault = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t\t   nonempty, fault);\n+      fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t       start.expr,\n+\t\t\t       build_int_cst (gfc_charlen_type_node, 1));\n+      fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t       boolean_type_node, nonempty, fault);\n       if (name)\n \tasprintf (&msg, \"Substring out of bounds: lower bound (%%ld) of '%s' \"\n \t\t  \"is less than one\", name);\n@@ -443,10 +446,10 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       gfc_free (msg);\n \n       /* Check upper bound.  */\n-      fault = fold_build2 (GT_EXPR, boolean_type_node, end.expr,\n-                           se->string_length);\n-      fault = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t\t   nonempty, fault);\n+      fault = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t       end.expr, se->string_length);\n+      fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n+\t\t\t       boolean_type_node, nonempty, fault);\n       if (name)\n \tasprintf (&msg, \"Substring out of bounds: upper bound (%%ld) of '%s' \"\n \t\t  \"exceeds string length (%%ld)\", name);\n@@ -460,12 +463,12 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       gfc_free (msg);\n     }\n \n-  tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node,\n-\t\t     end.expr, start.expr);\n-  tmp = fold_build2 (PLUS_EXPR, gfc_charlen_type_node,\n-\t\t     build_int_cst (gfc_charlen_type_node, 1), tmp);\n-  tmp = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tmp,\n-\t\t     build_int_cst (gfc_charlen_type_node, 0));\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_charlen_type_node,\n+\t\t\t end.expr, start.expr);\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_charlen_type_node,\n+\t\t\t build_int_cst (gfc_charlen_type_node, 1), tmp);\n+  tmp = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node, tmp,\n+\t\t\t build_int_cst (gfc_charlen_type_node, 0));\n   se->string_length = tmp;\n }\n \n@@ -487,7 +490,8 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   field = c->backend_decl;\n   gcc_assert (TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t decl, field, NULL_TREE);\n \n   se->expr = tmp;\n \n@@ -769,10 +773,10 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n      We must convert it to a compare to 0 (e.g. EQ_EXPR (op1, 0)).\n      All other unary operators have an equivalent GIMPLE unary operator.  */\n   if (code == TRUTH_NOT_EXPR)\n-    se->expr = fold_build2 (EQ_EXPR, type, operand.expr,\n-\t\t\t    build_int_cst (type, 0));\n+    se->expr = fold_build2_loc (input_location, EQ_EXPR, type, operand.expr,\n+\t\t\t\tbuild_int_cst (type, 0));\n   else\n-    se->expr = fold_build1 (code, type, operand.expr);\n+    se->expr = fold_build1_loc (input_location, code, type, operand.expr);\n \n }\n \n@@ -859,7 +863,7 @@ gfc_conv_powi (gfc_se * se, unsigned HOST_WIDE_INT n, tree * tmpvar)\n       op1 = op0;\n     }\n \n-  tmp = fold_build2 (MULT_EXPR, TREE_TYPE (op0), op0, op1);\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (op0), op0, op1);\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n \n   if (n < POWI_TABLE_SIZE)\n@@ -910,27 +914,29 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   /* If rhs < 0 and lhs is an integer, the result is -1, 0 or 1.  */\n   if ((sgn == -1) && (TREE_CODE (type) == INTEGER_TYPE))\n     {\n-      tmp = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t lhs, build_int_cst (TREE_TYPE (lhs), -1));\n-      cond = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t  lhs, build_int_cst (TREE_TYPE (lhs), 1));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t     lhs, build_int_cst (TREE_TYPE (lhs), -1));\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t      lhs, build_int_cst (TREE_TYPE (lhs), 1));\n \n       /* If rhs is even,\n \t result = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n       if ((n & 1) == 0)\n         {\n-\t  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, tmp, cond);\n-\t  se->expr = fold_build3 (COND_EXPR, type,\n-\t\t\t\t  tmp, build_int_cst (type, 1),\n-\t\t\t\t  build_int_cst (type, 0));\n+\t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t boolean_type_node, tmp, cond);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR, type,\n+\t\t\t\t      tmp, build_int_cst (type, 1),\n+\t\t\t\t      build_int_cst (type, 0));\n \t  return 1;\n \t}\n       /* If rhs is odd,\n \t result = (lhs == 1) ? 1 : (lhs == -1) ? -1 : 0.  */\n-      tmp = fold_build3 (COND_EXPR, type, tmp, build_int_cst (type, -1),\n-\t\t\t build_int_cst (type, 0));\n-      se->expr = fold_build3 (COND_EXPR, type,\n-\t\t\t      cond, build_int_cst (type, 1), tmp);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, type, tmp,\n+\t\t\t     build_int_cst (type, -1),\n+\t\t\t     build_int_cst (type, 0));\n+      se->expr = fold_build3_loc (input_location, COND_EXPR, type,\n+\t\t\t\t  cond, build_int_cst (type, 1), tmp);\n       return 1;\n     }\n \n@@ -939,7 +945,8 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   if (sgn == -1)\n     {\n       tmp = gfc_build_const (type, integer_one_node);\n-      vartmp[1] = fold_build2 (RDIV_EXPR, type, tmp, vartmp[1]);\n+      vartmp[1] = fold_build2_loc (input_location, RDIV_EXPR, type, tmp,\n+\t\t\t\t   vartmp[1]);\n     }\n \n   se->expr = gfc_conv_powi (se, n, vartmp);\n@@ -1115,8 +1122,9 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n   if (gfc_can_put_var_on_stack (len))\n     {\n       /* Create a temporary variable to hold the result.  */\n-      tmp = fold_build2 (MINUS_EXPR, gfc_charlen_type_node, len,\n-\t\t\t build_int_cst (gfc_charlen_type_node, 1));\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t     gfc_charlen_type_node, len,\n+\t\t\t     build_int_cst (gfc_charlen_type_node, 1));\n       tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n \n       if (TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n@@ -1132,9 +1140,10 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n       /* Allocate a temporary to hold the result.  */\n       var = gfc_create_var (type, \"pstr\");\n       tmp = gfc_call_malloc (&se->pre, type,\n-\t\t\t     fold_build2 (MULT_EXPR, TREE_TYPE (len), len,\n-\t\t\t\t\t  fold_convert (TREE_TYPE (len),\n-\t\t\t\t\t\t\tTYPE_SIZE (type))));\n+\t\t\t     fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t      TREE_TYPE (len), len,\n+\t\t\t\t\t      fold_convert (TREE_TYPE (len),\n+\t\t\t\t\t\t\t    TYPE_SIZE (type))));\n       gfc_add_modify (&se->pre, var, tmp);\n \n       /* Free the temporary afterwards.  */\n@@ -1173,8 +1182,9 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   len = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n   if (len == NULL_TREE)\n     {\n-      len = fold_build2 (PLUS_EXPR, TREE_TYPE (lse.string_length),\n-\t\t\t lse.string_length, rse.string_length);\n+      len = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t     TREE_TYPE (lse.string_length),\n+\t\t\t     lse.string_length, rse.string_length);\n     }\n \n   type = build_pointer_type (type);\n@@ -1377,11 +1387,12 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n   if (lop)\n     {\n       /* The result of logical ops is always boolean_type_node.  */\n-      tmp = fold_build2 (code, boolean_type_node, lse.expr, rse.expr);\n+      tmp = fold_build2_loc (input_location, code, boolean_type_node,\n+\t\t\t     lse.expr, rse.expr);\n       se->expr = convert (type, tmp);\n     }\n   else\n-    se->expr = fold_build2 (code, type, lse.expr, rse.expr);\n+    se->expr = fold_build2_loc (input_location, code, type, lse.expr, rse.expr);\n \n   /* Add the post blocks.  */\n   gfc_add_block_to_block (&se->post, &rse.post);\n@@ -1553,7 +1564,8 @@ gfc_build_compare_string (tree len1, tree str1, tree len2, tree str2, int kind,\n       /* Deal with single character specially.  */\n       sc1 = fold_convert (integer_type_node, sc1);\n       sc2 = fold_convert (integer_type_node, sc2);\n-      return fold_build2 (MINUS_EXPR, integer_type_node, sc1, sc2);\n+      return fold_build2_loc (input_location, MINUS_EXPR, integer_type_node,\n+\t\t\t      sc1, sc2);\n     }\n \n   if ((code == EQ_EXPR || code == NE_EXPR)\n@@ -1750,19 +1762,21 @@ gfc_set_interface_mapping_bounds (stmtblock_t * block, tree type, tree desc)\n \t}\n       else if (GFC_TYPE_ARRAY_UBOUND (type, n) == NULL_TREE)\n \t{\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     gfc_conv_descriptor_ubound_get (desc, dim),\n-\t\t\t     gfc_conv_descriptor_lbound_get (desc, dim));\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     GFC_TYPE_ARRAY_LBOUND (type, n),\n-\t\t\t     tmp);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t gfc_conv_descriptor_ubound_get (desc, dim),\n+\t\t\t\t gfc_conv_descriptor_lbound_get (desc, dim));\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t GFC_TYPE_ARRAY_LBOUND (type, n), tmp);\n \t  tmp = gfc_evaluate_now (tmp, block);\n \t  GFC_TYPE_ARRAY_UBOUND (type, n) = tmp;\n \t}\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t GFC_TYPE_ARRAY_LBOUND (type, n),\n-\t\t\t GFC_TYPE_ARRAY_STRIDE (type, n));\n-      offset = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp);\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t     GFC_TYPE_ARRAY_LBOUND (type, n),\n+\t\t\t     GFC_TYPE_ARRAY_STRIDE (type, n));\n+      offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tgfc_array_index_type, offset, tmp);\n     }\n   offset = gfc_evaluate_now (offset, block);\n   GFC_TYPE_ARRAY_OFFSET (type) = offset;\n@@ -2400,26 +2414,30 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n     {\n       tree tmp_str;\n       tmp = rse.loop->loopvar[n];\n-      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t tmp, rse.loop->from[n]);\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t tmp, tmp_index);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, rse.loop->from[n]);\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     tmp, tmp_index);\n \n-      tmp_str = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     rse.loop->to[n-1], rse.loop->from[n-1]);\n-      tmp_str = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp_str, gfc_index_one_node);\n+      tmp_str = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t rse.loop->to[n-1], rse.loop->from[n-1]);\n+      tmp_str = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t tmp_str, gfc_index_one_node);\n \n-      tmp_index = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t       tmp, tmp_str);\n+      tmp_index = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t   gfc_array_index_type, tmp, tmp_str);\n     }\n \n-  tmp_index = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-  \t\t\t   tmp_index, rse.loop->from[0]);\n+  tmp_index = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       gfc_array_index_type,\n+\t\t\t       tmp_index, rse.loop->from[0]);\n   gfc_add_modify (&rse.loop->code[0], offset, tmp_index);\n \n-  tmp_index = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t   rse.loop->loopvar[0], offset);\n+  tmp_index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       gfc_array_index_type,\n+\t\t\t       rse.loop->loopvar[0], offset);\n \n   /* Now use the offset for the reference.  */\n   tmp = build_fold_indirect_ref_loc (input_location,\n@@ -2467,8 +2485,9 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n \t{\n \t  tmp = gfc_conv_descriptor_ubound_get (parmse->expr,\n \t\t\t\t\t\tgfc_rank_cst[n]);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, gfc_index_one_node);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp,\n+\t\t\t\t gfc_index_one_node);\n \t  gfc_conv_descriptor_ubound_set (&parmse->pre,\n \t\t\t\t\t  parmse->expr,\n \t\t\t\t\t  gfc_rank_cst[n],\n@@ -2478,15 +2497,18 @@ gfc_conv_subref_array_arg (gfc_se * parmse, gfc_expr * expr, int g77,\n \t\t\t\t\t  gfc_rank_cst[n],\n \t\t\t\t\t  gfc_index_one_node);\n \t  size = gfc_evaluate_now (size, &parmse->pre);\n-\t  offset = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\toffset, size);\n+\t  offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t    gfc_array_index_type,\n+\t\t\t\t    offset, size);\n \t  offset = gfc_evaluate_now (offset, &parmse->pre);\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     rse.loop->to[n], rse.loop->from[n]);\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, gfc_index_one_node);\n-\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t      size, tmp);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t rse.loop->to[n], rse.loop->from[n]);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t tmp, gfc_index_one_node);\n+\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t  gfc_array_index_type, size, tmp);\n \t}\n \n       gfc_conv_descriptor_offset_set (&parmse->pre, parmse->expr,\n@@ -2548,8 +2570,9 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \n   /* Set the vptr.  */\n   cmp = gfc_find_component (declared, \"$vptr\", true, true);\n-  ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n-\t\t       var, cmp->backend_decl, NULL_TREE);\n+  ctree = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   TREE_TYPE (cmp->backend_decl),\n+\t\t\t   var, cmp->backend_decl, NULL_TREE);\n \n   /* Remember the vtab corresponds to the derived type\n      not to the class declared type.  */\n@@ -2561,8 +2584,9 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \n   /* Now set the data field.  */\n   cmp = gfc_find_component (declared, \"$data\", true, true);\n-  ctree = fold_build3 (COMPONENT_REF, TREE_TYPE (cmp->backend_decl),\n-\t\t       var, cmp->backend_decl, NULL_TREE);\n+  ctree = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   TREE_TYPE (cmp->backend_decl),\n+\t\t\t   var, cmp->backend_decl, NULL_TREE);\n   ss = gfc_walk_expr (e);\n   if (ss == gfc_ss_terminator)\n     {\n@@ -2668,10 +2692,11 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \tfptrse.expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t   fptrse.expr);\n       \n-      se->expr = fold_build2 (MODIFY_EXPR, TREE_TYPE (fptrse.expr),\n-\t\t\t      fptrse.expr,\n-\t\t\t      fold_convert (TREE_TYPE (fptrse.expr),\n-\t\t\t\t\t    cptrse.expr));\n+      se->expr = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t  TREE_TYPE (fptrse.expr),\n+\t\t\t\t  fptrse.expr,\n+\t\t\t\t  fold_convert (TREE_TYPE (fptrse.expr),\n+\t\t\t\t\t\tcptrse.expr));\n \n       return 1;\n     }\n@@ -2692,9 +2717,10 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n       if (arg->next == NULL)\n \t/* Only given one arg so generate a null and do a\n \t   not-equal comparison against the first arg.  */\n-\tse->expr = fold_build2 (NE_EXPR, boolean_type_node, arg1se.expr,\n-\t\t\t\tfold_convert (TREE_TYPE (arg1se.expr),\n-\t\t\t\t\t      null_pointer_node));\n+\tse->expr = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t    arg1se.expr,\n+\t\t\t\t    fold_convert (TREE_TYPE (arg1se.expr),\n+\t\t\t\t\t\t  null_pointer_node));\n       else\n \t{\n \t  tree eq_expr;\n@@ -2707,16 +2733,18 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \t  gfc_add_block_to_block (&se->post, &arg2se.post);\n \n \t  /* Generate test to compare that the two args are equal.  */\n-\t  eq_expr = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t\t arg1se.expr, arg2se.expr);\n+\t  eq_expr = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t     arg1se.expr, arg2se.expr);\n \t  /* Generate test to ensure that the first arg is not null.  */\n-\t  not_null_expr = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t       arg1se.expr, null_pointer_node);\n+\t  not_null_expr = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   arg1se.expr, null_pointer_node);\n \n \t  /* Finally, the generated test must check that both arg1 is not\n \t     NULL and that it is equal to the second arg.  */\n-\t  se->expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t  not_null_expr, eq_expr);\n+\t  se->expr = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\t      boolean_type_node,\n+\t\t\t\t      not_null_expr, eq_expr);\n \t}\n \n       return 1;\n@@ -2947,15 +2975,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      tmp = gfc_deallocate_with_status (parmse.expr, NULL_TREE,\n \t\t\t\t\t\t\ttrue, NULL);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n-\t\t      tmp = fold_build2 (MODIFY_EXPR, void_type_node,\n-\t\t\t\t\t parmse.expr, null_pointer_node);\n+\t\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t\t     void_type_node, parmse.expr,\n+\t\t\t\t\t     null_pointer_node);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n \n \t\t      if (fsym->attr.optional\n \t\t\t  && e->expr_type == EXPR_VARIABLE\n \t\t\t  && e->symtree->n.sym->attr.optional)\n \t\t\t{\n-\t\t\t  tmp = fold_build3 (COND_EXPR, void_type_node,\n+\t\t\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node,\n \t\t\t\t     gfc_conv_expr_present (e->symtree->n.sym),\n \t\t\t\t\t    gfc_finish_block (&block),\n \t\t\t\t\t    build_empty_stmt (input_location));\n@@ -3025,7 +3055,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  if (fsym->attr.optional\n \t\t      && e->expr_type == EXPR_VARIABLE\n \t\t      && e->symtree->n.sym->attr.optional)\n-\t\t    tmp = fold_build3 (COND_EXPR, void_type_node,\n+\t\t    tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t     void_type_node,\n \t\t\t\t     gfc_conv_expr_present (e->symtree->n.sym),\n \t\t\t\t       tmp, build_empty_stmt (input_location));\n \t\t  gfc_add_expr_to_block (&se->pre, tmp);\n@@ -3177,13 +3208,17 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t      present = gfc_conv_expr_present (e->symtree->n.sym);\n \t      type = TREE_TYPE (present);\n-\t      present = fold_build2 (EQ_EXPR, boolean_type_node, present,\n-\t\t\t\t     fold_convert (type, null_pointer_node));\n+\t      present = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t\t boolean_type_node, present,\n+\t\t\t\t\t fold_convert (type,\n+\t\t\t\t\t\t       null_pointer_node));\n \t      type = TREE_TYPE (parmse.expr);\n-\t      null_ptr = fold_build2 (EQ_EXPR, boolean_type_node, parmse.expr,\n-\t\t\t\t      fold_convert (type, null_pointer_node));\n-\t      cond = fold_build2 (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t\t\t  present, null_ptr);\n+\t      null_ptr = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t\t  boolean_type_node, parmse.expr,\n+\t\t\t\t\t  fold_convert (type,\n+\t\t\t\t\t\t\tnull_pointer_node));\n+\t      cond = fold_build2_loc (input_location, TRUTH_ORIF_EXPR,\n+\t\t\t\t      boolean_type_node, present, null_ptr);\n \t    }\n           else\n \t    {\n@@ -3203,9 +3238,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgoto end_pointer_check;\n \n \n-\t      cond = fold_build2 (EQ_EXPR, boolean_type_node, parmse.expr,\n-\t\t\t\t  fold_convert (TREE_TYPE (parmse.expr),\n-\t\t\t\t\t\tnull_pointer_node));\n+\t      cond = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t      boolean_type_node, parmse.expr,\n+\t\t\t\t      fold_convert (TREE_TYPE (parmse.expr),\n+\t\t\t\t\t\t    null_pointer_node));\n \t    }\n  \n \t  gfc_trans_runtime_check (true, false, cond, &se->pre, &e->where,\n@@ -3265,8 +3301,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n \t  \n \t  tmp = fold_convert (gfc_charlen_type_node, parmse.expr);\n-\t  tmp = fold_build2 (MAX_EXPR, gfc_charlen_type_node, tmp,\n-\t\t\t     build_int_cst (gfc_charlen_type_node, 0));\n+\t  tmp = fold_build2_loc (input_location, MAX_EXPR,\n+\t\t\t\t gfc_charlen_type_node, tmp,\n+\t\t\t\t build_int_cst (gfc_charlen_type_node, 0));\n \t  cl.backend_decl = tmp;\n \t}\n \n@@ -3470,8 +3507,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  /* Check the data pointer hasn't been modified.  This would\n \t\t     happen in a function returning a pointer.  */\n \t\t  tmp = gfc_conv_descriptor_data_get (info->descriptor);\n-\t\t  tmp = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t     tmp, info->data);\n+\t\t  tmp = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t boolean_type_node,\n+\t\t\t\t\t tmp, info->data);\n \t\t  gfc_trans_runtime_check (true, false, tmp, &se->pre, NULL,\n \t\t\t\t\t   gfc_msg_fault);\n \t\t}\n@@ -3572,24 +3610,25 @@ fill_with_spaces (tree start, tree type, tree size)\n   gfc_init_block (&loop);\n \n   /* Exit condition.  */\n-  cond = fold_build2 (LE_EXPR, boolean_type_node, i,\n-\t\t      fold_convert (sizetype, integer_zero_node));\n+  cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, i,\n+\t\t\t  fold_convert (sizetype, integer_zero_node));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n-\t\t     build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&loop, tmp);\n \n   /* Assignment.  */\n-  gfc_add_modify (&loop, fold_build1 (INDIRECT_REF, type, el),\n-\t\t       build_int_cst (type,\n-\t\t\t\t      lang_hooks.to_target_charset (' ')));\n+  gfc_add_modify (&loop,\n+\t\t  fold_build1_loc (input_location, INDIRECT_REF, type, el),\n+\t\t  build_int_cst (type, lang_hooks.to_target_charset (' ')));\n \n   /* Increment loop variables.  */\n-  gfc_add_modify (&loop, i, fold_build2 (MINUS_EXPR, sizetype, i,\n-\t\t\t\t\t      TYPE_SIZE_UNIT (type)));\n-  gfc_add_modify (&loop, el, fold_build2 (POINTER_PLUS_EXPR,\n-\t\t\t\t\t       TREE_TYPE (el), el,\n-\t\t\t\t\t       TYPE_SIZE_UNIT (type)));\n+  gfc_add_modify (&loop, i,\n+\t\t  fold_build2_loc (input_location, MINUS_EXPR, sizetype, i,\n+\t\t\t\t   TYPE_SIZE_UNIT (type)));\n+  gfc_add_modify (&loop, el,\n+\t\t  fold_build2_loc (input_location, POINTER_PLUS_EXPR,\n+\t\t\t\t   TREE_TYPE (el), el, TYPE_SIZE_UNIT (type)));\n \n   /* Making the loop... actually loop!  */\n   tmp = gfc_finish_block (&loop);\n@@ -3655,8 +3694,8 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n     }\n \n   /* Do nothing if the destination length is zero.  */\n-  cond = fold_build2 (GT_EXPR, boolean_type_node, dlen,\n-\t\t      build_int_cst (size_type_node, 0));\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, dlen,\n+\t\t\t  build_int_cst (size_type_node, 0));\n \n   /* The following code was previously in _gfortran_copy_string:\n \n@@ -3684,12 +3723,14 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   /* For non-default character kinds, we have to multiply the string\n      length by the base type size.  */\n   chartype = gfc_get_char_type (dkind);\n-  slen = fold_build2 (MULT_EXPR, size_type_node,\n-\t\t      fold_convert (size_type_node, slen),\n-\t\t      fold_convert (size_type_node, TYPE_SIZE_UNIT (chartype)));\n-  dlen = fold_build2 (MULT_EXPR, size_type_node,\n-\t\t      fold_convert (size_type_node, dlen),\n-\t\t      fold_convert (size_type_node, TYPE_SIZE_UNIT (chartype)));\n+  slen = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t  fold_convert (size_type_node, slen),\n+\t\t\t  fold_convert (size_type_node,\n+\t\t\t\t\tTYPE_SIZE_UNIT (chartype)));\n+  dlen = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t  fold_convert (size_type_node, dlen),\n+\t\t\t  fold_convert (size_type_node,\n+\t\t\t\t\tTYPE_SIZE_UNIT (chartype)));\n \n   if (dlength)\n     dest = fold_convert (pvoid_type_node, dest);\n@@ -3702,7 +3743,8 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n     src = gfc_build_addr_expr (pvoid_type_node, src);\n \n   /* Truncate string if source is too long.  */\n-  cond2 = fold_build2 (GE_EXPR, boolean_type_node, slen, dlen);\n+  cond2 = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, slen,\n+\t\t\t   dlen);\n   tmp2 = build_call_expr_loc (input_location,\n \t\t\t  built_in_decls[BUILT_IN_MEMMOVE],\n \t\t\t  3, dest, src, dlen);\n@@ -3712,21 +3754,22 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \t\t\t  built_in_decls[BUILT_IN_MEMMOVE],\n \t\t\t  3, dest, src, slen);\n \n-  tmp4 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dest), dest,\n-\t\t      fold_convert (sizetype, slen));\n+  tmp4 = fold_build2_loc (input_location, POINTER_PLUS_EXPR, TREE_TYPE (dest),\n+\t\t\t  dest, fold_convert (sizetype, slen));\n   tmp4 = fill_with_spaces (tmp4, chartype,\n-\t\t\t   fold_build2 (MINUS_EXPR, TREE_TYPE(dlen),\n-\t\t\t\t\tdlen, slen));\n+\t\t\t   fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t    TREE_TYPE(dlen), dlen, slen));\n \n   gfc_init_block (&tempblock);\n   gfc_add_expr_to_block (&tempblock, tmp3);\n   gfc_add_expr_to_block (&tempblock, tmp4);\n   tmp3 = gfc_finish_block (&tempblock);\n \n   /* The whole copy_string function is there.  */\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond2, tmp2, tmp3);\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n-\t\t     build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond2,\n+\t\t\t tmp2, tmp3);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n }\n \n@@ -4200,21 +4243,23 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n \n       /* Shift the bounds and set the offset accordingly.  */\n       tmp = gfc_conv_descriptor_ubound_get (dest, gfc_rank_cst[n]);\n-      span = fold_build2 (MINUS_EXPR, gfc_array_index_type, tmp,\n-\t\tgfc_conv_descriptor_lbound_get (dest, gfc_rank_cst[n]));\n-      tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, span, lbound);\n+      span = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\ttmp, gfc_conv_descriptor_lbound_get (dest, gfc_rank_cst[n]));\n+      tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     span, lbound);\n       gfc_conv_descriptor_ubound_set (&block, dest,\n \t\t\t\t      gfc_rank_cst[n], tmp);\n       gfc_conv_descriptor_lbound_set (&block, dest,\n \t\t\t\t      gfc_rank_cst[n], lbound);\n \n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+      tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t gfc_conv_descriptor_lbound_get (dest,\n \t\t\t\t\t\t\t gfc_rank_cst[n]),\n \t\t\t gfc_conv_descriptor_stride_get (dest,\n \t\t\t\t\t\t\t gfc_rank_cst[n]));\n       gfc_add_modify (&block, tmp2, tmp);\n-      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp2);\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     offset, tmp2);\n       gfc_conv_descriptor_offset_set (&block, dest, tmp);\n     }\n \n@@ -4369,18 +4414,19 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n       if (c && c->expr && c->expr->ts.is_iso_c)\n \t{\n \t  field = cm->backend_decl;\n-\t  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t     dest, field, NULL_TREE);\n-\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (tmp), tmp,\n-\t\t\t     fold_convert (TREE_TYPE (tmp),\n-\t\t\t\t\t   null_pointer_node));\n+\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t TREE_TYPE (field),\n+\t\t\t\t dest, field, NULL_TREE);\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t tmp, fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t    null_pointer_node));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t  continue;\n \t}\n \n       field = cm->backend_decl;\n-      tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t dest, field, NULL_TREE);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     dest, field, NULL_TREE);\n       tmp = gfc_trans_subcomponent_assign (tmp, cm, c->expr);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n@@ -4864,10 +4910,10 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t\t\t\t\t\t\t   gfc_rank_cst[dim]);\n \t\t  lbound = gfc_conv_descriptor_lbound_get (rse.expr,\n \t\t\t\t\t\t\t   gfc_rank_cst[dim]);\n-\t\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t     stride, lbound);\n-\t\t  offs = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      offs, tmp);\n+\t\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t gfc_array_index_type, stride, lbound);\n+\t\t  offs = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, offs, tmp);\n \t\t}\n \t      gfc_conv_descriptor_offset_set (&block, desc, offs);\n \n@@ -4913,17 +4959,17 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n \t\t  /* Update offset.  */\n \t\t  offs = gfc_conv_descriptor_offset_get (desc);\n-\t\t  tmp = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t     lbound, stride);\n-\t\t  offs = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      offs, tmp);\n+\t\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t gfc_array_index_type, lbound, stride);\n+\t\t  offs = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t\t  gfc_array_index_type, offs, tmp);\n \t\t  offs = gfc_evaluate_now (offs, &block);\n \t\t  gfc_conv_descriptor_offset_set (&block, desc, offs);\n \n \t\t  /* Update stride.  */\n \t\t  tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n-\t\t  stride = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t\tstride, tmp);\n+\t\t  stride = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t    gfc_array_index_type, stride, tmp);\n \t\t}\n \t    }\n \t  else\n@@ -4972,7 +5018,8 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \n \t  lsize = gfc_evaluate_now (lsize, &block);\n \t  rsize = gfc_evaluate_now (rsize, &block);\n-\t  fault = fold_build2 (LT_EXPR, boolean_type_node, rsize, lsize);\n+\t  fault = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t   rsize, lsize);\n \n \t  msg = _(\"Target of rank remapping is too small (%ld < %ld)\");\n \t  gfc_trans_runtime_check (true, false, fault, &block, &expr2->where,\n@@ -5069,9 +5116,9 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       /* Are the rhs and the lhs the same?  */\n       if (r_is_var)\n \t{\n-\t  cond = fold_build2 (EQ_EXPR, boolean_type_node,\n-\t\t\t      gfc_build_addr_expr (NULL_TREE, lse->expr),\n-\t\t\t      gfc_build_addr_expr (NULL_TREE, rse->expr));\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, lse->expr),\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, rse->expr));\n \t  cond = gfc_evaluate_now (cond, &lse->pre);\n \t}\n \n@@ -5109,7 +5156,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n     {\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n-      tmp = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (lse->expr), rse->expr);\n+      tmp = fold_build1_loc (input_location, VIEW_CONVERT_EXPR,\n+\t\t\t     TREE_TYPE (lse->expr), rse->expr);\n       gfc_add_modify (&block, lse->expr, tmp);\n     }\n   else\n@@ -5322,8 +5370,8 @@ gfc_trans_zero_assign (gfc_expr * expr)\n     return NULL_TREE;\n \n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  len = fold_build2 (MULT_EXPR, gfc_array_index_type, len,\n-\t\t     fold_convert (gfc_array_index_type, tmp));\n+  len = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type, len,\n+\t\t\t fold_convert (gfc_array_index_type, tmp));\n \n   /* If we are zeroing a local array avoid taking its address by emitting\n      a = {} instead.  */\n@@ -5401,15 +5449,15 @@ gfc_trans_array_copy (gfc_expr * expr1, gfc_expr * expr2)\n   if (!dlen || TREE_CODE (dlen) != INTEGER_CST)\n     return NULL_TREE;\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (dtype));\n-  dlen = fold_build2 (MULT_EXPR, gfc_array_index_type, dlen,\n-\t\t      fold_convert (gfc_array_index_type, tmp));\n+  dlen = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  dlen, fold_convert (gfc_array_index_type, tmp));\n \n   slen = GFC_TYPE_ARRAY_SIZE (stype);\n   if (!slen || TREE_CODE (slen) != INTEGER_CST)\n     return NULL_TREE;\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (stype));\n-  slen = fold_build2 (MULT_EXPR, gfc_array_index_type, slen,\n-\t\t      fold_convert (gfc_array_index_type, tmp));\n+  slen = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  slen, fold_convert (gfc_array_index_type, tmp));\n \n   /* Sanity check that they are the same.  This should always be\n      the case, as we should already have checked for conformance.  */\n@@ -5454,8 +5502,8 @@ gfc_trans_array_constructor_copy (gfc_expr * expr1, gfc_expr * expr2)\n     return NULL_TREE;\n \n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (dtype));\n-  len = fold_build2 (MULT_EXPR, gfc_array_index_type, len,\n-\t\t     fold_convert (gfc_array_index_type, tmp));\n+  len = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type, len,\n+\t\t\t fold_convert (gfc_array_index_type, tmp));\n \n   stype = gfc_typenode_for_spec (&expr2->ts);\n   src = gfc_build_constant_array_constructor (expr2, stype);"}, {"sha": "55a3b2f9b335dc3c3eff0d1d4a943ca67003e94f", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=65a9ca823e1aa1996badc22db84b8641d1487e61", "patch": "@@ -1306,8 +1306,10 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \t  zero = build_real_from_int_cst (TREE_TYPE (args[1]), integer_zero_node);\n \t  cond = fold_build2 (EQ_EXPR, boolean_type_node, args[1], zero);\n \t  se->expr = fold_build3 (COND_EXPR, TREE_TYPE (args[0]), cond,\n-\t\t\t\t  build_call_expr (abs, 1, args[0]),\n-\t\t\t\t  build_call_expr (tmp, 2, args[0], args[1]));\n+\t\t\t\t  build_call_expr_loc (input_location, abs, 1,\n+\t\t\t\t\t\t       args[0]),\n+\t\t\t\t  build_call_expr_loc (input_location, tmp, 2,\n+\t\t\t\t\t\t       args[0], args[1]));\n \t}\n       else\n         se->expr = build_call_expr_loc (input_location, tmp, 2,\n@@ -3412,7 +3414,8 @@ gfc_conv_intrinsic_leadz (gfc_se * se, gfc_expr * expr)\n \n   /* Compute LEADZ for the case i .ne. 0.  */\n   s = TYPE_PRECISION (arg_type) - argsize;\n-  tmp = fold_convert (result_type, build_call_expr (func, 1, arg));\n+  tmp = fold_convert (result_type, build_call_expr_loc (input_location, func,\n+\t\t\t\t\t\t\t1, arg));\n   leadz = fold_build2 (MINUS_EXPR, result_type,\n \t\t       tmp, build_int_cst (result_type, s));\n "}, {"sha": "6d4cba237e74de92821e5e7de788ee906c3bc993", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 76, "deletions": 59, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=65a9ca823e1aa1996badc22db84b8641d1487e61", "patch": "@@ -428,10 +428,11 @@ set_parameter_const (stmtblock_t *block, tree var, enum iofield type,\n   gfc_st_parameter_field *p = &st_parameter_field[type];\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field), var, p->field,\n-\t\t     NULL_TREE);\n+    var = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   st_parameter[IOPARM_ptype_common].type,\n+\t\t\t   var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\t var, p->field, NULL_TREE);\n   gfc_add_modify (block, tmp, build_int_cst (TREE_TYPE (p->field), val));\n   return p->mask;\n }\n@@ -464,16 +465,18 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n       /* UNIT numbers should be greater than the min.  */\n       i = gfc_validate_kind (BT_INTEGER, 4, false);\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].pedantic_min_int, 4);\n-      cond = fold_build2 (LT_EXPR, boolean_type_node, se.expr,\n-\t\t\t  fold_convert (TREE_TYPE (se.expr), val));\n+      cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t      se.expr,\n+\t\t\t      fold_convert (TREE_TYPE (se.expr), val));\n       gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n \t\t\t       \"Unit number in I/O statement too small\",\n \t\t\t       &se.pre);\n     \n       /* UNIT numbers should be less than the max.  */\n       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);\n-      cond = fold_build2 (GT_EXPR, boolean_type_node, se.expr,\n-\t\t\t  fold_convert (TREE_TYPE (se.expr), val));\n+      cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t      se.expr,\n+\t\t\t      fold_convert (TREE_TYPE (se.expr), val));\n       gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n \t\t\t       \"Unit number in I/O statement too large\",\n \t\t\t       &se.pre);\n@@ -484,10 +487,12 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n   gfc_add_block_to_block (block, &se.pre);\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+    var = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   st_parameter[IOPARM_ptype_common].type,\n+\t\t\t   var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n \n-  tmp = fold_build3 (COMPONENT_REF, dest_type, var, p->field, NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, dest_type, var,\n+\t\t\t p->field, NULL_TREE);\n   gfc_add_modify (block, tmp, se.expr);\n   return p->mask;\n }\n@@ -542,10 +547,11 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n      }\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t     var, p->field, NULL_TREE);\n+    var = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   st_parameter[IOPARM_ptype_common].type,\n+\t\t\t   var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\t var, p->field, NULL_TREE);\n   gfc_add_modify (block, tmp, addr);\n   return p->mask;\n }\n@@ -583,21 +589,26 @@ gfc_convert_array_to_string (gfc_se * se, gfc_expr * e)\n \t{\n \t  gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n \t  size = gfc_conv_array_stride (array, rank);\n-\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     gfc_conv_array_ubound (array, rank),\n-\t\t\t     gfc_conv_array_lbound (array, rank));\n-\t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     gfc_index_one_node);\n-\t  size = fold_build2 (MULT_EXPR, gfc_array_index_type, tmp, size);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type,\n+\t\t\t\t gfc_conv_array_ubound (array, rank),\n+\t\t\t\t gfc_conv_array_lbound (array, rank));\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, tmp,\n+\t\t\t\t gfc_index_one_node);\n+\t  size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t  gfc_array_index_type, tmp, size);\n \t}\n       gcc_assert (size);\n \n-      size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t\t  TREE_OPERAND (se->expr, 1));\n+      size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t      gfc_array_index_type, size,\n+\t\t\t      TREE_OPERAND (se->expr, 1));\n       se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n       tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\t  fold_convert (gfc_array_index_type, tmp));\n+      size = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t      gfc_array_index_type, size,\n+\t\t\t      fold_convert (gfc_array_index_type, tmp));\n       se->string_length = fold_convert (gfc_charlen_type_node, size);\n       return;\n     }\n@@ -623,12 +634,14 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n   gfc_init_se (&se, NULL);\n \n   if (p->param_type == IOPARM_ptype_common)\n-    var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t       var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  io = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n+    var = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t   st_parameter[IOPARM_ptype_common].type,\n+\t\t\t   var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  io = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n \t\t    var, p->field, NULL_TREE);\n-  len = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field_len),\n-\t\t     var, p->field_len, NULL_TREE);\n+  len = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t TREE_TYPE (p->field_len),\n+\t\t\t var, p->field_len, NULL_TREE);\n \n   /* Integer variable assigned a format label.  */\n   if (e->ts.type == BT_INTEGER\n@@ -640,8 +653,8 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \n       gfc_conv_label_variable (&se, e);\n       tmp = GFC_DECL_STRING_LEN (se.expr);\n-      cond = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp), 0));\n+      cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t      tmp, build_int_cst (TREE_TYPE (tmp), 0));\n \n       asprintf(&msg, \"Label assigned to variable '%s' (%%ld) is not a format \"\n \t       \"label\", e->symtree->name);\n@@ -694,13 +707,13 @@ set_internal_unit (stmtblock_t * block, stmtblock_t * post_block,\n \n   p = &st_parameter_field[IOPARM_dt_internal_unit];\n   mask = p->mask;\n-  io = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t    var, p->field, NULL_TREE);\n-  len = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field_len),\n-\t\t     var, p->field_len,\tNULL_TREE);\n+  io = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\tvar, p->field, NULL_TREE);\n+  len = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field_len),\n+\t\t\t var, p->field_len,\tNULL_TREE);\n   p = &st_parameter_field[IOPARM_dt_internal_unit_desc];\n-  desc = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t      var, p->field, NULL_TREE);\n+  desc = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\t  var, p->field, NULL_TREE);\n \n   gcc_assert (e->ts.type == BT_CHARACTER);\n \n@@ -809,13 +822,14 @@ io_result (stmtblock_t * block, tree var, gfc_st_label * err_label,\n \n   tmp = gfc_finish_block (&body);\n \n-  var = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t     var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  rc = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t    var, p->field, NULL_TREE);\n-  rc = fold_build2 (BIT_AND_EXPR, TREE_TYPE (rc),\n-\t\t    rc, build_int_cst (TREE_TYPE (rc),\n-\t\t\t\t       IOPARM_common_libreturn_mask));\n+  var = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t st_parameter[IOPARM_ptype_common].type,\n+\t\t\t var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  rc = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (p->field),\n+\t\t\tvar, p->field, NULL_TREE);\n+  rc = fold_build2_loc (input_location, BIT_AND_EXPR, TREE_TYPE (rc),\n+\t\t\trc, build_int_cst (TREE_TYPE (rc),\n+\t\t\t\t\t   IOPARM_common_libreturn_mask));\n \n   tmp = build3_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n \n@@ -834,11 +848,12 @@ set_error_locus (stmtblock_t * block, tree var, locus * where)\n   int line;\n   gfc_st_parameter_field *p = &st_parameter_field[IOPARM_common_filename];\n \n-  locus_file = fold_build3 (COMPONENT_REF,\n-\t\t\t    st_parameter[IOPARM_ptype_common].type,\n-\t\t\t    var, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n-  locus_file = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t\t    locus_file, p->field, NULL_TREE);\n+  locus_file = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\tst_parameter[IOPARM_ptype_common].type,\n+\t\t\t\tvar, TYPE_FIELDS (TREE_TYPE (var)), NULL_TREE);\n+  locus_file = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\tTREE_TYPE (p->field), locus_file,\n+\t\t\t\tp->field, NULL_TREE);\n   f = where->lb->file;\n   str = gfc_build_cstring_const (f->filename);\n \n@@ -1448,8 +1463,8 @@ nml_get_addr_expr (gfc_symbol * sym, gfc_component * c,\n      the derived type.  */\n \n   if (TREE_CODE (decl) == FIELD_DECL)\n-    tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n-\t\t       base_addr, tmp, NULL_TREE);\n+    tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t   base_addr, tmp, NULL_TREE);\n \n   /* If we have a derived type component, a reference to the first\n      element of the array is built.  This is done so that base_addr,\n@@ -1786,13 +1801,15 @@ build_dt (tree function, gfc_code * code)\n     {\n       gfc_st_parameter_field *p = &st_parameter_field[IOPARM_common_flags];\n \n-      tmp = fold_build3 (COMPONENT_REF, st_parameter[IOPARM_ptype_common].type,\n-\t\t\t dt_parm, TYPE_FIELDS (TREE_TYPE (dt_parm)), NULL_TREE);\n-      tmp = fold_build3 (COMPONENT_REF, TREE_TYPE (p->field),\n-\t\t\t  tmp, p->field, NULL_TREE);\n-      tmp = fold_build2 (BIT_AND_EXPR, TREE_TYPE (tmp),\n-\t\t\t  tmp, build_int_cst (TREE_TYPE (tmp),\n-\t\t\t  IOPARM_common_libreturn_mask));\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t     st_parameter[IOPARM_ptype_common].type,\n+\t\t\t     dt_parm, TYPE_FIELDS (TREE_TYPE (dt_parm)),\n+\t\t\t     NULL_TREE);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t     TREE_TYPE (p->field), tmp, p->field, NULL_TREE);\n+      tmp = fold_build2_loc (input_location, BIT_AND_EXPR, TREE_TYPE (tmp),\n+\t\t\t     tmp, build_int_cst (TREE_TYPE (tmp),\n+\t\t\t     IOPARM_common_libreturn_mask));\n     }\n   else /* IOLENGTH */\n     tmp = NULL_TREE;"}, {"sha": "d1638b68fc3631a43e912922341c6466f4381e63", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=65a9ca823e1aa1996badc22db84b8641d1487e61", "patch": "@@ -176,16 +176,17 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n   gfc_add_modify (&cond_block, decl, outer);\n   rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n   size = gfc_conv_descriptor_ubound_get (decl, rank);\n-  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t      gfc_conv_descriptor_lbound_get (decl, rank));\n-  size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n-\t\t      gfc_index_one_node);\n+  size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  size, gfc_conv_descriptor_lbound_get (decl, rank));\n+  size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  size, gfc_index_one_node);\n   if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\tgfc_conv_descriptor_stride_get (decl, rank));\n+    size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t    size, gfc_conv_descriptor_stride_get (decl, rank));\n   esize = fold_convert (gfc_array_index_type,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &cond_block);\n   ptr = gfc_allocate_array_with_status (&cond_block,\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n@@ -197,10 +198,10 @@ gfc_omp_clause_default_ctor (tree clause, tree decl, tree outer)\n   gfc_conv_descriptor_data_set (&cond_block, decl, null_pointer_node);\n   else_b = gfc_finish_block (&cond_block);\n \n-  cond = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t      fold_convert (pvoid_type_node,\n-\t\t\t\t    gfc_conv_descriptor_data_get (outer)),\n-\t\t      null_pointer_node);\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t  fold_convert (pvoid_type_node,\n+\t\t\t\t\tgfc_conv_descriptor_data_get (outer)),\n+\t\t\t  null_pointer_node);\n   gfc_add_expr_to_block (&block, build3 (COND_EXPR, void_type_node,\n \t\t\t cond, then_b, else_b));\n \n@@ -228,16 +229,17 @@ gfc_omp_clause_copy_ctor (tree clause, tree dest, tree src)\n   gfc_add_modify (&block, dest, src);\n   rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n   size = gfc_conv_descriptor_ubound_get (dest, rank);\n-  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t      gfc_conv_descriptor_lbound_get (dest, rank));\n-  size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n-\t\t      gfc_index_one_node);\n+  size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  size, gfc_conv_descriptor_lbound_get (dest, rank));\n+  size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  size, gfc_index_one_node);\n   if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\tgfc_conv_descriptor_stride_get (dest, rank));\n+    size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t    size, gfc_conv_descriptor_stride_get (dest, rank));\n   esize = fold_convert (gfc_array_index_type,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n   ptr = gfc_allocate_array_with_status (&block,\n \t\t\t\t\tbuild_int_cst (pvoid_type_node, 0),\n@@ -270,16 +272,17 @@ gfc_omp_clause_assign_op (tree clause ATTRIBUTE_UNUSED, tree dest, tree src)\n \n   rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n   size = gfc_conv_descriptor_ubound_get (dest, rank);\n-  size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t      gfc_conv_descriptor_lbound_get (dest, rank));\n-  size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n-\t\t      gfc_index_one_node);\n+  size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t  size, gfc_conv_descriptor_lbound_get (dest, rank));\n+  size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  size, gfc_index_one_node);\n   if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-    size = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\tgfc_conv_descriptor_stride_get (dest, rank));\n+    size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t    size, gfc_conv_descriptor_stride_get (dest, rank));\n   esize = fold_convert (gfc_array_index_type,\n \t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-  size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+  size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t  size, esize);\n   size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n   call = build_call_expr_loc (input_location,\n \t\t\t  built_in_decls[BUILT_IN_MEMCPY], 3,\n@@ -634,16 +637,19 @@ gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n       gfc_add_modify (&block, decl, outer_sym.backend_decl);\n       rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n       size = gfc_conv_descriptor_ubound_get (decl, rank);\n-      size = fold_build2 (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t\t  gfc_conv_descriptor_lbound_get (decl, rank));\n-      size = fold_build2 (PLUS_EXPR, gfc_array_index_type, size,\n-\t\t\t  gfc_index_one_node);\n+      size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t      gfc_array_index_type, size,\n+\t\t\t      gfc_conv_descriptor_lbound_get (decl, rank));\n+      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_one_node);\n       if (GFC_TYPE_ARRAY_RANK (type) > 1)\n-\tsize = fold_build2 (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\t    gfc_conv_descriptor_stride_get (decl, rank));\n+\tsize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, size,\n+\t\t\t\tgfc_conv_descriptor_stride_get (decl, rank));\n       esize = fold_convert (gfc_array_index_type,\n \t\t\t    TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n-      size = fold_build2 (MULT_EXPR, gfc_array_index_type, size, esize);\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      size, esize);\n       size = gfc_evaluate_now (fold_convert (size_type_node, size), &block);\n       ptr = gfc_allocate_array_with_status (&block,\n \t\t\t\t\t    build_int_cst (pvoid_type_node, 0),\n@@ -1100,7 +1106,8 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t      gfc_init_block (&rse.pre);\n \t      gfc_conv_expr (&rse, arg->expr);\n \t      gfc_add_block_to_block (&block, &rse.pre);\n-\t      x = fold_build2 (op, TREE_TYPE (accum), accum, rse.expr);\n+\t      x = fold_build2_loc (input_location, op, TREE_TYPE (accum),\n+\t\t\t\t   accum, rse.expr);\n \t      gfc_add_modify (&block, accum, x);\n \t    }\n \n@@ -1116,13 +1123,14 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t\t\t\t\t\t\t lhsaddr));\n \n   if (var_on_left)\n-    x = fold_build2 (op, TREE_TYPE (rhs), x, rhs);\n+    x = fold_build2_loc (input_location, op, TREE_TYPE (rhs), x, rhs);\n   else\n-    x = fold_build2 (op, TREE_TYPE (rhs), rhs, x);\n+    x = fold_build2_loc (input_location, op, TREE_TYPE (rhs), rhs, x);\n \n   if (TREE_CODE (TREE_TYPE (rhs)) == COMPLEX_TYPE\n       && TREE_CODE (type) != COMPLEX_TYPE)\n-    x = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (rhs)), x);\n+    x = fold_build1_loc (input_location, REALPART_EXPR,\n+\t\t\t TREE_TYPE (TREE_TYPE (rhs)), x);\n \n   x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n   gfc_add_expr_to_block (&block, x);\n@@ -1254,11 +1262,16 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n       if (simple)\n \t{\n \t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, dovar, from);\n-\t  TREE_VEC_ELT (cond, i) = fold_build2 (simple > 0 ? LE_EXPR : GE_EXPR,\n-\t\t\t\t\t\tboolean_type_node, dovar, to);\n-\t  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, dovar, step);\n-\t  TREE_VEC_ELT (incr, i) = fold_build2 (MODIFY_EXPR, type, dovar,\n-\t\t\t\t\t\tTREE_VEC_ELT (incr, i));\n+\t  TREE_VEC_ELT (cond, i) = fold_build2_loc (input_location, simple > 0\n+\t\t\t\t\t\t    ? LE_EXPR : GE_EXPR,\n+\t\t\t\t\t\t    boolean_type_node, dovar,\n+\t\t\t\t\t\t    to);\n+\t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t\t    type, dovar, step);\n+\t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n+\t\t\t\t\t\t    MODIFY_EXPR,\n+\t\t\t\t\t\t    type, dovar,\n+\t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n \t}\n       else\n \t{\n@@ -1269,23 +1282,27 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t\t body;\n \t       cycle_label:;\n \t       }  */\n-\t  tmp = fold_build2 (MINUS_EXPR, type, step, from);\n-\t  tmp = fold_build2 (PLUS_EXPR, type, to, tmp);\n-\t  tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, type, step, from);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, to, tmp);\n+\t  tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, type, tmp,\n+\t\t\t\t step);\n \t  tmp = gfc_evaluate_now (tmp, pblock);\n \t  count = gfc_create_var (type, \"count\");\n \t  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, count,\n \t\t\t\t\t     build_int_cst (type, 0));\n-\t  TREE_VEC_ELT (cond, i) = fold_build2 (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t\tcount, tmp);\n-\t  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, count,\n-\t\t\t\t\t\tbuild_int_cst (type, 1));\n-\t  TREE_VEC_ELT (incr, i) = fold_build2 (MODIFY_EXPR, type,\n-\t\t\t\t\t\tcount, TREE_VEC_ELT (incr, i));\n+\t  TREE_VEC_ELT (cond, i) = fold_build2_loc (input_location, LT_EXPR,\n+\t\t\t\t\t\t    boolean_type_node,\n+\t\t\t\t\t\t    count, tmp);\n+\t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t\t\t    type, count,\n+\t\t\t\t\t\t    build_int_cst (type, 1));\n+\t  TREE_VEC_ELT (incr, i) = fold_build2_loc (input_location,\n+\t\t\t\t\t\t    MODIFY_EXPR, type, count,\n+\t\t\t\t\t\t    TREE_VEC_ELT (incr, i));\n \n \t  /* Initialize DOVAR.  */\n-\t  tmp = fold_build2 (MULT_EXPR, type, count, step);\n-\t  tmp = fold_build2 (PLUS_EXPR, type, from, tmp);\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, count, step);\n+\t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, from, tmp);\n \t  di = VEC_safe_push (dovar_init, heap, inits, NULL);\n \t  di->var = dovar;\n \t  di->init = tmp;\n@@ -1310,8 +1327,10 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t\t will have the value on entry of the last loop, rather\n \t\t than value after iterator increment.  */\n \t      tmp = gfc_evaluate_now (step, pblock);\n-\t      tmp = fold_build2 (PLUS_EXPR, type, dovar, tmp);\n-\t      tmp = fold_build2 (MODIFY_EXPR, type, dovar, tmp);\n+\t      tmp = fold_build2_loc (input_location, PLUS_EXPR, type, dovar,\n+\t\t\t\t     tmp);\n+\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR, type,\n+\t\t\t\t     dovar, tmp);\n \t      for (c = omp_clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n \t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t\t    && OMP_CLAUSE_DECL (c) == dovar_decl)"}, {"sha": "708b5d12620e761b7ad88c2729449881b8548e2f", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 118, "deletions": 98, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a9ca823e1aa1996badc22db84b8641d1487e61/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=65a9ca823e1aa1996badc22db84b8641d1487e61", "patch": "@@ -167,7 +167,8 @@ gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs)\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n-  tmp = fold_build2 (MODIFY_EXPR, void_type_node, lhs, rhs);\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, lhs,\n+\t\t\t rhs);\n   gfc_add_expr_to_block (pblock, tmp);\n }\n \n@@ -296,7 +297,7 @@ gfc_build_addr_expr (tree type, tree t)\n       tree base = get_base_address (t);\n       if (base && DECL_P (base))\n         TREE_ADDRESSABLE (base) = 1;\n-      t = fold_build1 (ADDR_EXPR, natural_type, t);\n+      t = fold_build1_loc (input_location, ADDR_EXPR, natural_type, t);\n     }\n \n   if (type && natural_type != type)\n@@ -332,11 +333,13 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n \t&& GFC_DECL_SUBREF_ARRAY_P (decl)\n \t&& !integer_zerop (GFC_DECL_SPAN(decl)))\n     {\n-      offset = fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t    offset, GFC_DECL_SPAN(decl));\n+      offset = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type,\n+\t\t\t\toffset, GFC_DECL_SPAN(decl));\n       tmp = gfc_build_addr_expr (pvoid_type_node, base);\n-      tmp = fold_build2 (POINTER_PLUS_EXPR, pvoid_type_node,\n-\t\t\t tmp, fold_convert (sizetype, offset));\n+      tmp = fold_build2_loc (input_location, POINTER_PLUS_EXPR,\n+\t\t\t     pvoid_type_node, tmp,\n+\t\t\t     fold_convert (sizetype, offset));\n       tmp = fold_convert (build_pointer_type (type), tmp);\n       if (!TYPE_STRING_FLAG (type))\n \ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n@@ -421,11 +424,11 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n     fntype = TREE_TYPE (gfor_fndecl_runtime_warning_at);\n \n   tmp = fold_builtin_call_array (input_location, TREE_TYPE (fntype),\n-\t\t\t\t fold_build1 (ADDR_EXPR,\n-\t\t\t\t\t      build_pointer_type (fntype),\n-\t\t\t\t\t      error\n-\t\t\t\t\t      ? gfor_fndecl_runtime_error_at\n-\t\t\t\t\t      : gfor_fndecl_runtime_warning_at),\n+\t\t\t\t fold_build1_loc (input_location, ADDR_EXPR,\n+\t\t\t\t\t     build_pointer_type (fntype),\n+\t\t\t\t\t     error\n+\t\t\t\t\t     ? gfor_fndecl_runtime_error_at\n+\t\t\t\t\t     : gfor_fndecl_runtime_warning_at),\n \t\t\t\t nargs + 2, argarray);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -477,8 +480,8 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n     {\n       /* Tell the compiler that this isn't likely.  */\n       if (once)\n-\tcond = fold_build2 (TRUTH_AND_EXPR, long_integer_type_node, tmpvar,\n-\t\t\t    cond);\n+\tcond = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\t\t\t\tlong_integer_type_node, tmpvar, cond);\n       else\n \tcond = fold_convert (long_integer_type_node, cond);\n \n@@ -513,8 +516,8 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   /* Call malloc.  */\n   gfc_start_block (&block2);\n \n-  size = fold_build2 (MAX_EXPR, size_type_node, size,\n-\t\t      build_int_cst (size_type_node, 1));\n+  size = fold_build2_loc (input_location, MAX_EXPR, size_type_node, size,\n+\t\t\t  build_int_cst (size_type_node, 1));\n \n   gfc_add_modify (&block2, res,\n \t\t  fold_convert (prvoid_type_node,\n@@ -524,11 +527,13 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   /* Optionally check whether malloc was successful.  */\n   if (gfc_option.rtcheck & GFC_RTCHECK_MEM)\n     {\n-      null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n-\t\t\t\t build_int_cst (pvoid_type_node, 0));\n+      null_result = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t     boolean_type_node, res,\n+\t\t\t\t     build_int_cst (pvoid_type_node, 0));\n       msg = gfc_build_addr_expr (pchar_type_node,\n \t      gfc_build_localized_cstring_const (\"Memory allocation failed\"));\n-      tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     null_result,\n \t      build_call_expr_loc (input_location,\n \t\t\t\t   gfor_fndecl_os_error, 1, msg),\n \t\t\t\t   build_empty_stmt (input_location));\n@@ -601,13 +606,15 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n   /* Set the optional status variable to zero.  */\n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n-      tmp = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n-\t\t\t build_int_cst (status_type, 0));\n-      tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t fold_build2 (NE_EXPR, boolean_type_node, status,\n-\t\t\t\t      build_int_cst (TREE_TYPE (status), 0)),\n-\t\t\t tmp, build_empty_stmt (input_location));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t      status_type, status),\n+\t\t\t     build_int_cst (status_type, 0));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\tboolean_type_node, status,\n+\t\t\t\t\tbuild_int_cst (TREE_TYPE (status), 0)),\n+\t\t\t     tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n@@ -625,15 +632,16 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \n       gfc_start_block (&set_status_block);\n       gfc_add_modify (&set_status_block,\n-\t\t      fold_build1 (INDIRECT_REF, status_type, status),\n+\t\t      fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t       status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n       gfc_add_modify (&set_status_block, res,\n \t\t\t   build_int_cst (prvoid_type_node, 0));\n \n-      tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n-\t\t\t build_int_cst (TREE_TYPE (status), 0));\n-      error = fold_build3 (COND_EXPR, void_type_node, tmp, error,\n-\t\t\t   gfc_finish_block (&set_status_block));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t     status, build_int_cst (TREE_TYPE (status), 0));\n+      error = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+\t\t\t       error, gfc_finish_block (&set_status_block));\n     }\n \n   /* The allocation itself.  */\n@@ -642,9 +650,10 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \t\t  fold_convert (prvoid_type_node,\n \t\t\t\tbuild_call_expr_loc (input_location,\n \t\t\t\t   built_in_decls[BUILT_IN_MALLOC], 1,\n-\t\t\t\t\tfold_build2 (MAX_EXPR, size_type_node,\n-\t\t\t\t\t\t     size,\n-\t\t\t\t\t\t     build_int_cst (size_type_node, 1)))));\n+\t\t\t\t\tfold_build2_loc (input_location,\n+\t\t\t\t\t    MAX_EXPR, size_type_node, size,\n+\t\t\t\t\t    build_int_cst (size_type_node,\n+\t\t\t\t\t\t\t   1)))));\n \n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t\t\t\t(\"Out of memory\"));\n@@ -656,25 +665,27 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n       /* Set the status variable if it's present.  */\n       tree tmp2;\n \n-      cond = fold_build2 (EQ_EXPR, boolean_type_node, status,\n-\t\t\t  build_int_cst (TREE_TYPE (status), 0));\n-      tmp2 = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t  fold_build1 (INDIRECT_REF, status_type, status),\n-\t\t\t  build_int_cst (status_type, LIBERROR_ALLOCATION));\n-      tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n-\t\t\t tmp2);\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t      status, build_int_cst (TREE_TYPE (status), 0));\n+      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t      fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t       status_type, status),\n+\t\t\t      build_int_cst (status_type, LIBERROR_ALLOCATION));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t     tmp, tmp2);\n     }\n \n-  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     fold_build2 (EQ_EXPR, boolean_type_node, res,\n-\t\t\t\t  build_int_cst (prvoid_type_node, 0)),\n-\t\t     tmp, build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t\t\t  boolean_type_node, res,\n+\t\t\t\t\t  build_int_cst (prvoid_type_node, 0)),\n+\t\t\t tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&alloc_block, tmp);\n \n-  cond = fold_build2 (LT_EXPR, boolean_type_node, size,\n-\t\t      build_int_cst (TREE_TYPE (size), 0));\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, error,\n-\t\t     gfc_finish_block (&alloc_block));\n+  cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, size,\n+\t\t\t  build_int_cst (TREE_TYPE (size), 0));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, error,\n+\t\t\t gfc_finish_block (&alloc_block));\n   gfc_add_expr_to_block (block, tmp);\n \n   return res;\n@@ -721,8 +732,8 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n \n   /* Create a variable to hold the result.  */\n   res = gfc_create_var (type, NULL);\n-  null_mem = fold_build2 (EQ_EXPR, boolean_type_node, mem,\n-\t\t\t  build_int_cst (type, 0));\n+  null_mem = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, mem,\n+\t\t\t      build_int_cst (type, 0));\n \n   /* If mem is NULL, we call gfc_allocate_with_status.  */\n   gfc_start_block (&alloc_block);\n@@ -764,16 +775,18 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n       gfc_add_modify (&set_status_block, res, fold_convert (type, tmp));\n \n       gfc_add_modify (&set_status_block,\n-\t\t\t   fold_build1 (INDIRECT_REF, status_type, status),\n+\t\t\t   fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t    status_type, status),\n \t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n \n-      tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n-\t\t\t build_int_cst (status_type, 0));\n-      error = fold_build3 (COND_EXPR, void_type_node, tmp, error,\n-\t\t\t   gfc_finish_block (&set_status_block));\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t     status, build_int_cst (status_type, 0));\n+      error = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+\t\t\t       error, gfc_finish_block (&set_status_block));\n     }\n \n-  tmp = fold_build3 (COND_EXPR, void_type_node, null_mem, alloc, error);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, null_mem,\n+\t\t\t alloc, error);\n   gfc_add_expr_to_block (block, tmp);\n \n   return res;\n@@ -792,12 +805,12 @@ gfc_call_free (tree var)\n \n   gfc_start_block (&block);\n   var = gfc_evaluate_now (var, &block);\n-  cond = fold_build2 (NE_EXPR, boolean_type_node, var,\n-\t\t      build_int_cst (pvoid_type_node, 0));\n+  cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, var,\n+\t\t\t  build_int_cst (pvoid_type_node, 0));\n   call = build_call_expr_loc (input_location,\n-\t\t\t  built_in_decls[BUILT_IN_FREE], 1, var);\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, call,\n-\t\t     build_empty_stmt (input_location));\n+\t\t\t      built_in_decls[BUILT_IN_FREE], 1, var);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, call,\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -841,8 +854,8 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n   stmtblock_t null, non_null;\n   tree cond, tmp, error;\n \n-  cond = fold_build2 (EQ_EXPR, boolean_type_node, pointer,\n-\t\t      build_int_cst (TREE_TYPE (pointer), 0));\n+  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n+\t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n \n   /* When POINTER is NULL, we set STATUS to 1 if it's present, otherwise\n      we emit a runtime error.  */\n@@ -868,12 +881,14 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n       tree status_type = TREE_TYPE (TREE_TYPE (status));\n       tree cond2;\n \n-      cond2 = fold_build2 (NE_EXPR, boolean_type_node, status,\n-\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n-      tmp = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n-\t\t\t build_int_cst (status_type, 1));\n-      error = fold_build3 (COND_EXPR, void_type_node, cond2, tmp, error);\n+      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t      status_type, status),\n+\t\t\t     build_int_cst (status_type, 1));\n+      error = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t       cond2, tmp, error);\n     }\n \n   gfc_add_expr_to_block (&null, error);\n@@ -891,18 +906,20 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n       tree status_type = TREE_TYPE (TREE_TYPE (status));\n       tree cond2;\n \n-      cond2 = fold_build2 (NE_EXPR, boolean_type_node, status,\n-\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n-      tmp = fold_build2 (MODIFY_EXPR, status_type,\n-\t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n-\t\t\t build_int_cst (status_type, 0));\n-      tmp = fold_build3 (COND_EXPR, void_type_node, cond2, tmp,\n-\t\t\t build_empty_stmt (input_location));\n+      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t      status_type, status),\n+\t\t\t     build_int_cst (status_type, 0));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond2,\n+\t\t\t     tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n \n-  return fold_build3 (COND_EXPR, void_type_node, cond,\n-\t\t      gfc_finish_block (&null), gfc_finish_block (&non_null));\n+  return fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n+\t\t\t  gfc_finish_block (&null),\n+\t\t\t  gfc_finish_block (&non_null));\n }\n \n \n@@ -938,40 +955,43 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n   res = gfc_create_var (type, NULL);\n \n   /* size < 0 ?  */\n-  negative = fold_build2 (LT_EXPR, boolean_type_node, size,\n-\t\t\t  build_int_cst (size_type_node, 0));\n+  negative = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, size,\n+\t\t\t      build_int_cst (size_type_node, 0));\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n       (\"Attempt to allocate a negative amount of memory.\"));\n-  tmp = fold_build3 (COND_EXPR, void_type_node, negative,\n-\t\t     build_call_expr_loc (input_location,\n-\t\t\t\t      gfor_fndecl_runtime_error, 1, msg),\n-\t\t     build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, negative,\n+\t\t\t build_call_expr_loc (input_location,\n+\t\t\t\t\t    gfor_fndecl_runtime_error, 1, msg),\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Call realloc and check the result.  */\n   tmp = build_call_expr_loc (input_location,\n \t\t\t built_in_decls[BUILT_IN_REALLOC], 2,\n \t\t\t fold_convert (pvoid_type_node, mem), size);\n   gfc_add_modify (block, res, fold_convert (type, tmp));\n-  null_result = fold_build2 (EQ_EXPR, boolean_type_node, res,\n-\t\t\t     build_int_cst (pvoid_type_node, 0));\n-  nonzero = fold_build2 (NE_EXPR, boolean_type_node, size,\n-\t\t\t build_int_cst (size_type_node, 0));\n-  null_result = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, null_result,\n-\t\t\t     nonzero);\n+  null_result = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t res, build_int_cst (pvoid_type_node, 0));\n+  nonzero = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, size,\n+\t\t\t     build_int_cst (size_type_node, 0));\n+  null_result = fold_build2_loc (input_location, TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t null_result, nonzero);\n   msg = gfc_build_addr_expr (pchar_type_node, gfc_build_localized_cstring_const\n \t\t\t\t\t\t(\"Out of memory\"));\n-  tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n-\t\t     build_call_expr_loc (input_location,\n-\t\t\t\t      gfor_fndecl_os_error, 1, msg),\n-\t\t     build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t null_result,\n+\t\t\t build_call_expr_loc (input_location,\n+\t\t\t\t\t      gfor_fndecl_os_error, 1, msg),\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* if (size == 0) then the result is NULL.  */\n-  tmp = fold_build2 (MODIFY_EXPR, type, res, build_int_cst (type, 0));\n-  zero = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, nonzero);\n-  tmp = fold_build3 (COND_EXPR, void_type_node, zero, tmp,\n-\t\t     build_empty_stmt (input_location));\n+  tmp = fold_build2_loc (input_location, MODIFY_EXPR, type, res,\n+\t\t\t build_int_cst (type, 0));\n+  zero = fold_build1_loc (input_location, TRUTH_NOT_EXPR, boolean_type_node,\n+\t\t\t  nonzero);\n+  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, zero, tmp,\n+\t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   return res;"}]}