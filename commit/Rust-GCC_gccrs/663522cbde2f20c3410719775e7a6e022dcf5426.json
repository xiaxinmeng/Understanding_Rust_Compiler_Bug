{"sha": "663522cbde2f20c3410719775e7a6e022dcf5426", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYzNTIyY2JkZTJmMjBjMzQxMDcxOTc3NWU3YTZlMDIyZGNmNTQyNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-01T03:11:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-01T03:11:55Z"}, "message": "* combine.c: Fix formatting.\n\nFrom-SVN: r35398", "tree": {"sha": "526ba1dd263d0be581bb7126a3a0b42ff7b41b7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/526ba1dd263d0be581bb7126a3a0b42ff7b41b7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/663522cbde2f20c3410719775e7a6e022dcf5426", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/663522cbde2f20c3410719775e7a6e022dcf5426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/663522cbde2f20c3410719775e7a6e022dcf5426", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/663522cbde2f20c3410719775e7a6e022dcf5426/comments", "author": null, "committer": null, "parents": [{"sha": "c127c1274ff15e01fa10b3221a68522a644e0bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c127c1274ff15e01fa10b3221a68522a644e0bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c127c1274ff15e01fa10b3221a68522a644e0bfa"}], "stats": {"total": 647, "additions": 323, "deletions": 324}, "files": [{"sha": "1c243fff86097c97fe253494875a3f3c354574f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/663522cbde2f20c3410719775e7a6e022dcf5426/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/663522cbde2f20c3410719775e7a6e022dcf5426/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=663522cbde2f20c3410719775e7a6e022dcf5426", "patch": "@@ -130,6 +130,8 @@\n \n 2000-07-31  Kazu Hirata  <kazu@hxi.com>\n \n+\t* combine.c: Fix formatting.\n+\n \t* h8300.md: Fix formatting.\n \n \t* local-alloc.c: Fix formatting."}, {"sha": "9f1c59ef698a5144df235ae0e66df3e93b43818e", "filename": "gcc/combine.c", "status": "modified", "additions": 321, "deletions": 324, "changes": 645, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/663522cbde2f20c3410719775e7a6e022dcf5426/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/663522cbde2f20c3410719775e7a6e022dcf5426/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=663522cbde2f20c3410719775e7a6e022dcf5426", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This module is essentially the \"combiner\" phase of the U. of Arizona\n    Portable Optimizer, but redone to work on our list-structured\n    representation for RTL instead of their string representation.\n@@ -59,7 +58,7 @@ Boston, MA 02111-1307, USA.  */\n    - there are extremely rare cases (see distribute_regnotes) when a\n      REG_DEAD note is lost\n    - a LOG_LINKS entry that refers to an insn with multiple SETs may be\n-     removed because there is no way to know which register it was \n+     removed because there is no way to know which register it was\n      linking\n \n    To simplify substitution, we combine only when the earlier insn(s)\n@@ -212,8 +211,8 @@ static rtx added_links_insn;\n /* Basic block number of the block in which we are performing combines.  */\n static int this_basic_block;\n \n-/* A bitmap indicating which blocks had registers go dead at entry.  \n-   After combine, we'll need to re-do global life analysis with \n+/* A bitmap indicating which blocks had registers go dead at entry.\n+   After combine, we'll need to re-do global life analysis with\n    those blocks as starting points.  */\n static sbitmap refresh_blocks;\n static int need_refresh;\n@@ -443,7 +442,7 @@ static void record_promoted_value PARAMS ((rtx, rtx));\n    the undo table.  */\n \n static void\n-do_SUBST(into, newval)\n+do_SUBST (into, newval)\n      rtx *into, newval;\n {\n   struct undo *buf;\n@@ -472,7 +471,7 @@ do_SUBST(into, newval)\n    not safe.  */\n \n static void\n-do_SUBST_INT(into, newval)\n+do_SUBST_INT (into, newval)\n      int *into, newval;\n {\n   struct undo *buf;\n@@ -497,7 +496,7 @@ do_SUBST_INT(into, newval)\n #define SUBST_INT(INTO, NEWVAL)  do_SUBST_INT(&(INTO), (NEWVAL))\n \f\n /* Main entry point for combiner.  F is the first insn of the function.\n-   NREGS is the first unused pseudo-reg number. \n+   NREGS is the first unused pseudo-reg number.\n \n    Return non-zero if the combiner has turned an indirect jump\n    instruction into a direct jump.  */\n@@ -522,7 +521,7 @@ combine_instructions (f, nregs)\n \n   combine_max_regno = nregs;\n \n-  reg_nonzero_bits = ((unsigned HOST_WIDE_INT *) \n+  reg_nonzero_bits = ((unsigned HOST_WIDE_INT *)\n \t\t      xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT)));\n   reg_sign_bit_copies\n     = (unsigned char *) xcalloc (nregs, sizeof (unsigned char));\n@@ -562,7 +561,7 @@ combine_instructions (f, nregs)\n \n   /* Compute the mapping from uids to cuids.\n      Cuids are numbers assigned to insns, like uids,\n-     except that cuids increase monotonically through the code. \n+     except that cuids increase monotonically through the code.\n \n      Scan all SETs and see if we can deduce anything about what\n      bits are known to be zero for some registers and how many copies\n@@ -591,7 +590,7 @@ combine_instructions (f, nregs)\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies, \n+\t  note_stores (PATTERN (insn), set_nonzero_bits_and_sign_copies,\n \t\t       NULL);\n \t  record_dead_and_set_regs (insn);\n \n@@ -639,7 +638,7 @@ combine_instructions (f, nregs)\n \t  /* Try this insn with each insn it links back to.  */\n \n \t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n-\t    if ((next = try_combine (insn, XEXP (links, 0), \n+\t    if ((next = try_combine (insn, XEXP (links, 0),\n \t\t\t\t     NULL_RTX, &new_direct_jump_p)) != 0)\n \t      goto retry;\n \n@@ -676,7 +675,7 @@ combine_instructions (f, nregs)\n \t      && GET_CODE (prev) == INSN\n \t      && sets_cc0_p (PATTERN (prev)))\n \t    {\n-\t      if ((next = try_combine (insn, prev, \n+\t      if ((next = try_combine (insn, prev,\n \t\t\t\t       NULL_RTX, &new_direct_jump_p)) != 0)\n \t\tgoto retry;\n \n@@ -696,7 +695,7 @@ combine_instructions (f, nregs)\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (insn))))\n \t    {\n-\t      if ((next = try_combine (insn, prev, \n+\t      if ((next = try_combine (insn, prev,\n \t\t\t\t       NULL_RTX, &new_direct_jump_p)) != 0)\n \t\tgoto retry;\n \n@@ -718,7 +717,7 @@ combine_instructions (f, nregs)\n \t\t&& (prev = prev_nonnote_insn (XEXP (links, 0))) != 0\n \t\t&& GET_CODE (prev) == INSN\n \t\t&& sets_cc0_p (PATTERN (prev))\n-\t\t&& (next = try_combine (insn, XEXP (links, 0), \n+\t\t&& (next = try_combine (insn, XEXP (links, 0),\n \t\t\t\t\tprev, &new_direct_jump_p)) != 0)\n \t      goto retry;\n #endif\n@@ -745,7 +744,7 @@ combine_instructions (f, nregs)\n     {\n       compute_bb_for_insn (get_max_uid ());\n       update_life_info (refresh_blocks, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t        PROP_DEATH_NOTES);\n+\t\t\tPROP_DEATH_NOTES);\n     }\n \n   /* Clean up.  */\n@@ -843,7 +842,7 @@ setup_incoming_promotions ()\n    be happening.\n \n    Similarly, set how many bits of X are known to be copies of the sign bit\n-   at all locations in the function.  This is the smallest number implied \n+   at all locations in the function.  This is the smallest number implied\n    by any set of X.  */\n \n static void\n@@ -888,7 +887,7 @@ set_nonzero_bits_and_sign_copies (x, set, data)\n \t     constant that would appear negative in the mode of X,\n \t     sign-extend it for use in reg_nonzero_bits because some\n \t     machines (maybe most) will actually do the sign-extension\n-\t     and this is the conservative approach. \n+\t     and this is the conservative approach.\n \n \t     ??? For 2.5, try to tighten up the MD files in this regard\n \t     instead of this kludge.  */\n@@ -925,7 +924,7 @@ set_nonzero_bits_and_sign_copies (x, set, data)\n \n    Return 0 if the combination is not allowed for any reason.\n \n-   If the combination is allowed, *PDEST will be set to the single \n+   If the combination is allowed, *PDEST will be set to the single\n    destination of INSN and *PSRC to the single source, and this function\n    will return 1.  */\n \n@@ -948,20 +947,20 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t\t      : next_active_insn (insn) == i3);\n \n   /* Can combine only if previous insn is a SET of a REG, a SUBREG or CC0.\n-     or a PARALLEL consisting of such a SET and CLOBBERs. \n+     or a PARALLEL consisting of such a SET and CLOBBERs.\n \n      If INSN has CLOBBER parallel parts, ignore them for our processing.\n      By definition, these happen during the execution of the insn.  When it\n      is merged with another insn, all bets are off.  If they are, in fact,\n      needed and aren't also supplied in I3, they may be added by\n-     recog_for_combine.  Otherwise, it won't match. \n+     recog_for_combine.  Otherwise, it won't match.\n \n      We can also ignore a SET whose SET_DEST is mentioned in a REG_UNUSED\n      note.\n \n-     Get the source and destination of INSN.  If more than one, can't \n+     Get the source and destination of INSN.  If more than one, can't\n      combine.  */\n-     \n+\n   if (GET_CODE (PATTERN (insn)) == SET)\n     set = PATTERN (insn);\n   else if (GET_CODE (PATTERN (insn)) == PARALLEL\n@@ -1165,7 +1164,7 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n       /* Make sure succ doesn't contain a volatile reference.  */\n       if (succ != 0 && volatile_refs_p (PATTERN (succ)))\n         return 0;\n-  \n+\n       for (p = NEXT_INSN (insn); p != i3; p = NEXT_INSN (p))\n         if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n   \t  && p != succ && volatile_refs_p (PATTERN (p)))\n@@ -1285,7 +1284,7 @@ sets_function_arg_p (pat)\n \t \t    (set (reg:DI 101) (reg:DI 100))])\n \n    Not only does this modify 100 (in which case it might still be valid\n-   if 100 were dead in I2), it sets 101 to the ORIGINAL value of 100. \n+   if 100 were dead in I2), it sets 101 to the ORIGINAL value of 100.\n \n    We can also run into a problem if I2 sets a register that I1\n    uses and I1 gets directly substituted into I3 (not via I2).  In that\n@@ -1325,7 +1324,7 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n       rtx dest = SET_DEST (set);\n       rtx src = SET_SRC (set);\n       rtx inner_dest = dest;\n- \n+\n #if 0\n       rtx inner_src = src;\n #endif\n@@ -1377,7 +1376,7 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n \t     something that might need a spill could clobber a previous\n \t     function argument; the all_adjacent test in can_combine_p also\n \t     checks this; here, we do a more specific test for this case.  */\n-\t     \n+\n \t  || (GET_CODE (inner_dest) == REG\n \t      && REGNO (inner_dest) < FIRST_PSEUDO_REGISTER\n \t      && (! HARD_REGNO_MODE_OK (REGNO (inner_dest),\n@@ -1392,7 +1391,7 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n \treturn 0;\n \n       /* If DEST is used in I3, it is being killed in this insn,\n-\t so record that for later. \n+\t so record that for later.\n \t Never add REG_DEAD notes for the FRAME_POINTER_REGNUM or the\n \t STACK_POINTER_REGNUM, since these are always considered to be\n \t live.  Similarly for ARG_POINTER_REGNUM if it is fixed.  */\n@@ -1462,16 +1461,16 @@ contains_muldiv (x)\n /* Try to combine the insns I1 and I2 into I3.\n    Here I1 and I2 appear earlier than I3.\n    I1 can be zero; then we combine just I2 into I3.\n- \n+\n    It we are combining three insns and the resulting insn is not recognized,\n    try splitting it into two insns.  If that happens, I2 and I3 are retained\n    and I1 is pseudo-deleted by turning it into a NOTE.  Otherwise, I1 and I2\n    are pseudo-deleted.\n \n-   Return 0 if the combination does not work.  Then nothing is changed. \n+   Return 0 if the combination does not work.  Then nothing is changed.\n    If we did the combination, return the insn at which combine should\n-   resume scanning.  \n-   \n+   resume scanning.\n+\n    Set NEW_DIRECT_JUMP_P to a non-zero value if try_combine creates a\n    new direct jump instruction.  */\n \n@@ -1527,7 +1526,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t pass after flow uses REG_LIBCALL/REG_RETVAL notes.  */\n       || find_reg_note (i3, REG_LIBCALL, NULL_RTX)\n #endif\n-)\n+      )\n     return 0;\n \n   combine_attempts++;\n@@ -1616,7 +1615,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t      /* Replace the dest in I2 with our dest and make the resulting\n \t\t insn the new pattern for I3.  Then skip to where we\n \t\t validate the pattern.  Everything was set up above.  */\n-\t      SUBST (SET_DEST (XVECEXP (p2, 0, i)), \n+\t      SUBST (SET_DEST (XVECEXP (p2, 0, i)),\n \t\t     SET_DEST (PATTERN (i3)));\n \n \t      newpat = p2;\n@@ -1697,7 +1696,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n       && rtx_equal_p (XEXP (SET_SRC (XVECEXP (PATTERN (i2), 0, 0)), 0),\n \t\t      SET_SRC (XVECEXP (PATTERN (i2), 0, 1))))\n     {\n-      for (i =  XVECLEN (PATTERN (i2), 0) - 1; i >= 2; i--)\n+      for (i = XVECLEN (PATTERN (i2), 0) - 1; i >= 2; i--)\n \tif (GET_CODE (XVECEXP (PATTERN (i2), 0, i)) != CLOBBER)\n \t  break;\n \n@@ -1914,7 +1913,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t  else\n \t    undobuf.other_insn = 0;\n \t}\n-#endif\t  \n+#endif\n     }\n   else\n #endif\n@@ -2068,7 +2067,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \n   /* If we were combining three insns and the result is a simple SET\n      with no ASM_OPERANDS that wasn't recognized, try to split it into two\n-     insns.  There are two ways to do this.  It can be split using a \n+     insns.  There are two ways to do this.  It can be split using a\n      machine-specific method (like when you have an addition of a large\n      constant) or by combine in the function find_split_point.  */\n \n@@ -2337,7 +2336,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t    }\n \t}\n     }\n-\t    \n+\n   /* Similarly, check for a case where we have a PARALLEL of two independent\n      SETs but we started with three insns.  In this case, we can do the sets\n      as two separate insns.  This case occurs when some SET allows two\n@@ -2441,19 +2440,20 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t\t\tundobuf.other_insn, NULL_RTX, NULL_RTX, NULL_RTX);\n     }\n #ifdef HAVE_cc0\n-  /* If I2 is the setter CC0 and I3 is the user CC0 then check whether \n+  /* If I2 is the setter CC0 and I3 is the user CC0 then check whether\n      they are adjacent to each other or not. */\n   {\n     rtx p = prev_nonnote_insn (i3);\n-    if (p && p != i2 && GET_CODE (p) == INSN && newi2pat && sets_cc0_p (newi2pat))\n+    if (p && p != i2 && GET_CODE (p) == INSN && newi2pat\n+\t&& sets_cc0_p (newi2pat))\n       {\n-        undo_all ();\n-        return 0;\n+\tundo_all ();\n+\treturn 0;\n       }\n-    }\n-#endif \n+  }\n+#endif\n \n-  /* We now know that we can do this combination.  Merge the insns and \n+  /* We now know that we can do this combination.  Merge the insns and\n      update the status of registers and LOG_LINKS.  */\n \n   {\n@@ -2570,7 +2570,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n       }\n \n     /* Get death notes for everything that is now used in either I3 or\n-       I2 and used to die in a previous insn.  If we built two new \n+       I2 and used to die in a previous insn.  If we built two new\n        patterns, move from I1 to I2 then I2 to I3 so that we get the\n        proper movement on registers that I2 modifies.  */\n \n@@ -2599,15 +2599,15 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \n     /* Distribute any notes added to I2 or I3 by recog_for_combine.  We\n        know these are REG_UNUSED and want them to go to the desired insn,\n-       so we always pass it as i3.  We have not counted the notes in \n+       so we always pass it as i3.  We have not counted the notes in\n        reg_n_deaths yet, so we need to do so now.  */\n \n     if (newi2pat && new_i2_notes)\n       {\n \tfor (temp = new_i2_notes; temp; temp = XEXP (temp, 1))\n \t  if (GET_CODE (XEXP (temp, 0)) == REG)\n \t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n-\t\n+\n \tdistribute_notes (new_i2_notes, i2, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n@@ -2616,7 +2616,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \tfor (temp = new_i3_notes; temp; temp = XEXP (temp, 1))\n \t  if (GET_CODE (XEXP (temp, 0)) == REG)\n \t    REG_N_DEATHS (REGNO (XEXP (temp, 0)))++;\n-\t\n+\n \tdistribute_notes (new_i3_notes, i3, i3, NULL_RTX, NULL_RTX, NULL_RTX);\n       }\n \n@@ -2682,7 +2682,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \n \t/* The insn that used to set this register doesn't exist, and\n \t   this life of the register may not exist either.  See if one of\n-\t   I3's links points to an insn that sets I2DEST.  If it does, \n+\t   I3's links points to an insn that sets I2DEST.  If it does,\n \t   that is now the last known value for I2DEST. If we don't update\n \t   this and I2 set the register to a value that depended on its old\n \t   contents, we will get confused.  If this insn is used, thing\n@@ -2724,7 +2724,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n       }\n \n     /* Update reg_nonzero_bits et al for any changes that may have been made\n-       to this insn.  The order of set_nonzero_bits_and_sign_copies() is \n+       to this insn.  The order of set_nonzero_bits_and_sign_copies() is\n        important.  Because newi2pat can affect nonzero_bits of newpat */\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n@@ -2733,10 +2733,10 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n     /* Set new_direct_jump_p if a new return or simple jump instruction\n        has been created.\n \n-       If I3 is now an unconditional jump, ensure that it has a \n+       If I3 is now an unconditional jump, ensure that it has a\n        BARRIER following it since it may have initially been a\n        conditional jump.  It may also be the last nonnote insn.  */\n-    \n+\n     if (GET_CODE (newpat) == RETURN || any_uncondjump_p (i3))\n       {\n \t*new_direct_jump_p = 1;\n@@ -2906,7 +2906,7 @@ find_split_point (loc, insn)\n \t\t  return split;\n \t\t}\n \t    }\n-\t  \n+\n \t  /* If that didn't work, perhaps the first operand is complex and\n \t     needs to be computed separately, so make a split point there.\n \t     This will occur on machines that just support REG + CONST\n@@ -2975,8 +2975,8 @@ find_split_point (loc, insn)\n \t  else\n \t    SUBST (SET_SRC (x),\n \t\t   gen_binary (IOR, mode,\n-\t\t\t       gen_binary (AND, mode, dest, \n-\t\t\t\t\t   GEN_INT (~ (mask << pos)\n+\t\t\t       gen_binary (AND, mode, dest,\n+\t\t\t\t\t   GEN_INT (~(mask << pos)\n \t\t\t\t\t\t    & GET_MODE_MASK (mode))),\n \t\t\t       GEN_INT (src << pos)));\n \n@@ -3224,7 +3224,7 @@ find_split_point (loc, insn)\n    the caller can tell whether the result is valid.\n \n    `n_occurrences' is incremented each time FROM is replaced.\n-   \n+\n    IN_DEST is non-zero if we are processing the SET_DEST of a SET.\n \n    UNIQUE_COPY is non-zero if each substitution must be unique.  We do this\n@@ -3258,7 +3258,7 @@ subst (x, from, to, in_dest, unique_copy)\n     }\n \n   /* If X and FROM are the same register but different modes, they will\n-     not have been seen as equal above.  However, flow.c will make a \n+     not have been seen as equal above.  However, flow.c will make a\n      LOG_LINKS entry for that case.  If we do nothing, we will try to\n      rerecognize our original insn and, when it succeeds, we will\n      delete the feeding insn, which is incorrect.\n@@ -3307,7 +3307,7 @@ subst (x, from, to, in_dest, unique_copy)\n       for (i = XVECLEN (x, 0) - 1; i >= 1; i--)\n \t{\n \t  rtx dest = SET_DEST (XVECEXP (x, 0, i));\n-\t  \n+\n \t  if (GET_CODE (dest) != REG\n \t      && GET_CODE (dest) != CC0\n \t      && GET_CODE (dest) != PC)\n@@ -3420,7 +3420,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t   have gone inside a MEM, in which case we want to\n \t\t   simplify the address.  We assume here that things that\n \t\t   are actually part of the destination have their inner\n-\t\t   parts in the first expression.  This is true for SUBREG, \n+\t\t   parts in the first expression.  This is true for SUBREG,\n \t\t   STRICT_LOW_PART, and ZERO_EXTRACT, which are the only\n \t\t   things aside from REG and MEM that should appear in a\n \t\t   SET_DEST.  */\n@@ -3545,7 +3545,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       SUBST (XEXP (x, 0), gen_binary (PLUS, mode, new, temp));\n     }\n \n-  /* If this is a simple operation applied to an IF_THEN_ELSE, try \n+  /* If this is a simple operation applied to an IF_THEN_ELSE, try\n      applying it to the arms of the IF_THEN_ELSE.  This often simplifies\n      things.  Check for cases where both arms are testing the same\n      condition.\n@@ -3584,7 +3584,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (cond_code == NE && GET_RTX_CLASS (GET_CODE (cond)) == '<')\n \t    return x;\n \n-\t  /* Simplify the alternative arms; this may collapse the true and \n+\t  /* Simplify the alternative arms; this may collapse the true and\n \t     false arms to store-flag values.  */\n \t  true = subst (true, pc_rtx, pc_rtx, 0, 0);\n \t  false = subst (false, pc_rtx, pc_rtx, 0, 0);\n@@ -3616,7 +3616,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t       && INTVAL (false) == - STORE_FLAG_VALUE\n \t\t       && true == const0_rtx)\n \t\tx = gen_unary (NEG, mode, mode,\n-\t\t\t       gen_binary (reverse_condition (cond_code), \n+\t\t\t       gen_binary (reverse_condition (cond_code),\n \t\t\t\t\t   mode, cond, cop1));\n \t      else\n \t\treturn gen_rtx_IF_THEN_ELSE (mode,\n@@ -3693,7 +3693,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  rtx inner_op0 = XEXP (XEXP (x, 0), 1);\n \t  rtx inner_op1 = XEXP (x, 1);\n \t  rtx inner;\n-\t  \n+\n \t  /* Make sure we pass the constant operand if any as the second\n \t     one if this is a commutative operation.  */\n \t  if (CONSTANT_P (inner_op0) && GET_RTX_CLASS (code) == 'c')\n@@ -3824,7 +3824,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (temp)\n \t    return temp;\n \t}\n-\t\n+\n       /* If we want a subreg of a constant, at offset 0,\n \t take the low bits.  On a little-endian machine, that's\n \t always valid.  On a big-endian machine, it's valid\n@@ -3871,14 +3871,14 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \treturn gen_rtx_combine (PLUS, mode, XEXP (XEXP (x, 0), 0),\n \t\t\t\tconstm1_rtx);\n \n-      /* (not (xor X C)) for C constant is (xor X D) with D = ~ C.  */\n+      /* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */\n       if (GET_CODE (XEXP (x, 0)) == XOR\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && (temp = simplify_unary_operation (NOT, mode,\n \t\t\t\t\t       XEXP (XEXP (x, 0), 1),\n \t\t\t\t\t       mode)) != 0)\n \treturn gen_binary (XOR, mode, XEXP (XEXP (x, 0), 0), temp);\n-\t      \n+\n       /* (not (ashift 1 X)) is (rotate ~1 X).  We used to do this for operands\n \t other than 1, but that is not valid.  We could do a similar\n \t simplification for (not (lshiftrt C X)) where C is just the sign bit,\n@@ -3887,7 +3887,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && XEXP (XEXP (x, 0), 0) == const1_rtx)\n \treturn gen_rtx_ROTATE (mode, gen_unary (NOT, mode, mode, const1_rtx),\n \t\t\t       XEXP (XEXP (x, 0), 1));\n-\t\t\t\t\t    \n+\n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t  && subreg_lowpart_p (XEXP (x, 0))\n \t  && (GET_MODE_SIZE (GET_MODE (XEXP (x, 0)))\n@@ -3903,7 +3903,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t      XEXP (SUBREG_REG (XEXP (x, 0)), 1));\n \t  return gen_lowpart_for_combine (mode, x);\n \t}\n-\t\t\t\t\t    \n+\n       /* If STORE_FLAG_VALUE is -1, (not (comparison foo bar)) can be done by\n \t reversing the comparison code if valid.  */\n       if (STORE_FLAG_VALUE == -1\n@@ -3931,30 +3931,30 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n       if (GET_CODE (XEXP (x, 0)) == IOR || GET_CODE (XEXP (x, 0)) == AND)\n  \t{\n- \t rtx in1 = XEXP (XEXP (x, 0), 0), in2 = XEXP (XEXP (x, 0), 1);\n-\n-\t if (GET_CODE (in1) == NOT)\n-\t   in1 = XEXP (in1, 0);\n- \t else\n-\t   in1 = gen_rtx_combine (NOT, GET_MODE (in1), in1);\n-\n-\t if (GET_CODE (in2) == NOT)\n-\t   in2 = XEXP (in2, 0);\n- \t else if (GET_CODE (in2) == CONST_INT\n-\t\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-\t   in2 = GEN_INT (GET_MODE_MASK (mode) & ~ INTVAL (in2));\n-\t else\n-\t   in2 = gen_rtx_combine (NOT, GET_MODE (in2), in2);\n+\t  rtx in1 = XEXP (XEXP (x, 0), 0), in2 = XEXP (XEXP (x, 0), 1);\n \n-\t if (GET_CODE (in2) == NOT)\n-\t   {\n-\t     rtx tem = in2;\n-\t     in2 = in1; in1 = tem;\n-\t   }\n+\t  if (GET_CODE (in1) == NOT)\n+\t    in1 = XEXP (in1, 0);\n+\t  else\n+\t    in1 = gen_rtx_combine (NOT, GET_MODE (in1), in1);\n \n-\t return gen_rtx_combine (GET_CODE (XEXP (x, 0)) == IOR ? AND : IOR,\n-\t\t\t\t mode, in1, in2);\n-       } \n+\t  if (GET_CODE (in2) == NOT)\n+\t    in2 = XEXP (in2, 0);\n+\t  else if (GET_CODE (in2) == CONST_INT\n+\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t    in2 = GEN_INT (GET_MODE_MASK (mode) & ~INTVAL (in2));\n+\t  else\n+\t    in2 = gen_rtx_combine (NOT, GET_MODE (in2), in2);\n+\n+\t  if (GET_CODE (in2) == NOT)\n+\t    {\n+\t      rtx tem = in2;\n+\t      in2 = in1; in1 = tem;\n+\t    }\n+\n+\t  return gen_rtx_combine (GET_CODE (XEXP (x, 0)) == IOR ? AND : IOR,\n+\t\t\t\t  mode, in1, in2);\n+\t}\n       break;\n \n     case NEG:\n@@ -4092,14 +4092,14 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n          than HOST_BITS_PER_WIDE_INT.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n-\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE &~ GET_MODE_MASK (mode)) == 0)\n+\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0)\n \treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n \n       /* Similarly, a truncate of a register whose value is a\n          comparison can be replaced with a subreg if STORE_FLAG_VALUE\n          permits.  */\n       if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE &~ GET_MODE_MASK (mode)) == 0\n+\t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE & ~GET_MODE_MASK (mode)) == 0\n \t  && (temp = get_last_value (XEXP (x, 0)))\n \t  && GET_RTX_CLASS (GET_CODE (temp)) == '<')\n \treturn gen_lowpart_for_combine (mode, XEXP (x, 0));\n@@ -4110,7 +4110,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       /* (float_truncate:SF (float_extend:DF foo:SF)) = foo:SF.  */\n       if (GET_CODE (XEXP (x, 0)) == FLOAT_EXTEND\n \t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == mode)\n- \treturn XEXP (XEXP (x, 0), 0);\n+\treturn XEXP (XEXP (x, 0), 0);\n \n       /* (float_truncate:SF (OP:DF (float_extend:DF foo:sf))) is\n \t (OP:SF foo:SF) if OP is NEG or ABS.  */\n@@ -4127,7 +4127,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && subreg_lowpart_p (XEXP (x, 0))\n \t  && GET_CODE (SUBREG_REG (XEXP (x, 0))) == FLOAT_TRUNCATE)\n \treturn SUBREG_REG (XEXP (x, 0));\n-      break;  \n+      break;\n \n #ifdef HAVE_cc0\n     case COMPARE:\n@@ -4185,7 +4185,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       if (GET_CODE (XEXP (x, 0)) == XOR\n \t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n-\t  && INTVAL (XEXP (x, 1)) == - INTVAL (XEXP (XEXP (x, 0), 1))\n+\t  && INTVAL (XEXP (x, 1)) == -INTVAL (XEXP (XEXP (x, 0), 1))\n \t  && ((i = exact_log2 (INTVAL (XEXP (XEXP (x, 0), 1)))) >= 0\n \t      || (i = exact_log2 (INTVAL (XEXP (x, 1)))) >= 0)\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n@@ -4261,18 +4261,18 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && XEXP (x, 0) == const1_rtx\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) == '<'\n \t  && reversible_comparison_p (XEXP (x, 1)))\n-\treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 1))),\n-\t\t\t   mode, XEXP (XEXP (x, 1), 0),\n-\t\t\t\tXEXP (XEXP (x, 1), 1));\n+\treturn gen_binary (reverse_condition (GET_CODE (XEXP (x, 1))), mode,\n+\t\t\t   XEXP (XEXP (x, 1), 0),\n+\t\t\t   XEXP (XEXP (x, 1), 1));\n \n       /* (minus <foo> (and <foo> (const_int -pow2))) becomes\n \t (and <foo> (const_int pow2-1))  */\n       if (GET_CODE (XEXP (x, 1)) == AND\n \t  && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n-\t  && exact_log2 (- INTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n+\t  && exact_log2 (-INTVAL (XEXP (XEXP (x, 1), 1))) >= 0\n \t  && rtx_equal_p (XEXP (XEXP (x, 1), 0), XEXP (x, 0)))\n \treturn simplify_and_const_int (NULL_RTX, mode, XEXP (x, 0),\n-\t\t\t\t       - INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n+\t\t\t\t       -INTVAL (XEXP (XEXP (x, 1), 1)) - 1);\n \n       /* Canonicalize (minus A (plus B C)) to (minus (minus A B) C) for\n \t integers.  */\n@@ -4326,7 +4326,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n #ifdef HAVE_cc0\n \t      && XEXP (x, 0) != cc0_rtx\n #endif\n-\t       ))\n+\t      ))\n \t{\n \t  rtx op0 = XEXP (x, 0);\n \t  rtx op1 = XEXP (x, 1);\n@@ -4455,13 +4455,13 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (new_code != code)\n \t    return gen_rtx_combine (new_code, mode, op0, op1);\n \n-\t  /* Otherwise, keep this operation, but maybe change its operands.  \n+\t  /* Otherwise, keep this operation, but maybe change its operands.\n \t     This also converts (ne (compare FOO BAR) 0) to (ne FOO BAR).  */\n \t  SUBST (XEXP (x, 0), op0);\n \t  SUBST (XEXP (x, 1), op1);\n \t}\n       break;\n-\t  \n+\n     case IF_THEN_ELSE:\n       return simplify_if_then_else (x);\n \n@@ -4483,7 +4483,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n     case XOR:\n       return simplify_logical (x, last);\n \n-    case ABS:      \n+    case ABS:\n       /* (abs (neg <foo>)) -> (abs <foo>) */\n       if (GET_CODE (XEXP (x, 0)) == NEG)\n \tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n@@ -4503,7 +4503,6 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t  == 0)))\n \treturn XEXP (x, 0);\n \n-\n       /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n       if (num_sign_bit_copies (XEXP (x, 0), mode) == GET_MODE_BITSIZE (mode))\n \treturn gen_rtx_combine (NEG, mode, XEXP (x, 0));\n@@ -4530,14 +4529,14 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n     case ROTATERT:\n       /* If this is a shift by a constant amount, simplify it.  */\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\treturn simplify_shift_const (x, code, mode, XEXP (x, 0), \n+\treturn simplify_shift_const (x, code, mode, XEXP (x, 0),\n \t\t\t\t     INTVAL (XEXP (x, 1)));\n \n #ifdef SHIFT_COUNT_TRUNCATED\n       else if (SHIFT_COUNT_TRUNCATED && GET_CODE (XEXP (x, 1)) != REG)\n \tSUBST (XEXP (x, 1),\n \t       force_to_mode (XEXP (x, 1), GET_MODE (x),\n-\t\t\t      ((HOST_WIDE_INT) 1 \n+\t\t\t      ((HOST_WIDE_INT) 1\n \t\t\t       << exact_log2 (GET_MODE_BITSIZE (GET_MODE (x))))\n \t\t\t      - 1,\n \t\t\t      NULL_RTX, 0));\n@@ -4570,7 +4569,7 @@ simplify_if_then_else (x)\n   /* Simplify storing of the truth value.  */\n   if (comparison_p && true == const_true_rtx && false == const0_rtx)\n     return gen_binary (true_code, mode, XEXP (cond, 0), XEXP (cond, 1));\n-      \n+\n   /* Also when the truth value has to be reversed.  */\n   if (comparison_p && reversible_comparison_p (cond)\n       && true == const0_rtx && false == const_true_rtx)\n@@ -4636,7 +4635,7 @@ simplify_if_then_else (x)\n      the false arm is more complicated than the true arm.  */\n \n   if (comparison_p && reversible_comparison_p (cond)\n-      && (true == pc_rtx \n+      && (true == pc_rtx\n \t  || (CONSTANT_P (true)\n \t      && GET_CODE (false) != CONST_INT && false != pc_rtx)\n \t  || true == const0_rtx\n@@ -4722,7 +4721,7 @@ simplify_if_then_else (x)\n       default:\n \tbreak;\n       }\n-  \n+\n   /* If we have (if_then_else COND (OP Z C1) Z) and OP is an identity when its\n      second operand is zero, this can be done as (OP Z (mult COND C2)) where\n      C2 = C1 * STORE_FLAG_VALUE. Similarly if OP has an outer ZERO_EXTEND or\n@@ -4801,7 +4800,7 @@ simplify_if_then_else (x)\n \t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 0))\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 0)), f)\n \t       && ((nonzero_bits (f, GET_MODE (f))\n-\t\t    & ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 0))))\n+\t\t    & ~GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 0))))\n \t\t   == 0))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 1); z = f; op = GET_CODE (XEXP (t, 0));\n@@ -4817,14 +4816,14 @@ simplify_if_then_else (x)\n \t       && subreg_lowpart_p (XEXP (XEXP (t, 0), 1))\n \t       && rtx_equal_p (SUBREG_REG (XEXP (XEXP (t, 0), 1)), f)\n \t       && ((nonzero_bits (f, GET_MODE (f))\n-\t\t    & ~ GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 1))))\n+\t\t    & ~GET_MODE_MASK (GET_MODE (XEXP (XEXP (t, 0), 1))))\n \t\t   == 0))\n \t{\n \t  c1 = XEXP (XEXP (t, 0), 0); z = f; op = GET_CODE (XEXP (t, 0));\n \t  extend_op = ZERO_EXTEND;\n \t  m = GET_MODE (XEXP (t, 0));\n \t}\n-      \n+\n       if (z)\n \t{\n \t  temp = subst (gen_binary (true_code, m, cond_op0, cond_op1),\n@@ -4852,7 +4851,7 @@ simplify_if_then_else (x)\n \t   && (i = exact_log2 (INTVAL (true))) >= 0)\n \t  || ((num_sign_bit_copies (XEXP (cond, 0), mode)\n \t       == GET_MODE_BITSIZE (mode))\n-\t      && (i = exact_log2 (- INTVAL (true))) >= 0)))\n+\t      && (i = exact_log2 (-INTVAL (true))) >= 0)))\n     return\n       simplify_shift_const (NULL_RTX, ASHIFT, mode,\n \t\t\t    gen_lowpart_for_combine (mode, XEXP (cond, 0)), i);\n@@ -5021,7 +5020,7 @@ simplify_set (x)\n \n   /* If we have (set x (subreg:m1 (op:m2 ...) 0)) with OP being some operation,\n      and X being a REG or (subreg (reg)), we may be able to convert this to\n-     (set (subreg:m2 x) (op)). \n+     (set (subreg:m2 x) (op)).\n \n      We can always do this if M1 is narrower than M2 because that means that\n      we only care about the low bits of the result.\n@@ -5030,7 +5029,7 @@ simplify_set (x)\n      perform a narrower operation than requested since the high-order bits will\n      be undefined.  On machine where it is defined, this transformation is safe\n      as long as M1 and M2 have the same number of words.  */\n- \n+\n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n       && GET_RTX_CLASS (GET_CODE (SUBREG_REG (src))) != 'o'\n       && (((GET_MODE_SIZE (GET_MODE (src)) + (UNITS_PER_WORD - 1))\n@@ -5048,7 +5047,7 @@ simplify_set (x)\n \t\t REGNO (dest)))\n \t    && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (src),\n \t\t\t\t\t   GET_MODE (SUBREG_REG (src))))\n-#endif\t\t\t\t  \n+#endif\n       && (GET_CODE (dest) == REG\n \t  || (GET_CODE (dest) == SUBREG\n \t      && GET_CODE (SUBREG_REG (dest)) == REG)))\n@@ -5221,7 +5220,7 @@ simplify_logical (x, last)\n   switch (GET_CODE (x))\n     {\n     case AND:\n-      /* Convert (A ^ B) & A to A & (~ B) since the latter is often a single\n+      /* Convert (A ^ B) & A to A & (~B) since the latter is often a single\n \t insn (and may simplify more).  */\n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 0), op1)\n@@ -5235,7 +5234,7 @@ simplify_logical (x, last)\n \tx = gen_binary (AND, mode,\n \t\t\tgen_unary (NOT, mode, mode, XEXP (op0, 0)), op1);\n \n-      /* Similarly for (~ (A ^ B)) & A.  */\n+      /* Similarly for (~(A ^ B)) & A.  */\n       if (GET_CODE (op0) == NOT\n \t  && GET_CODE (XEXP (op0, 0)) == XOR\n \t  && rtx_equal_p (XEXP (XEXP (op0, 0), 0), op1)\n@@ -5267,12 +5266,12 @@ simplify_logical (x, last)\n \t    return gen_binary (IOR, mode,\n \t\t\t       gen_binary (AND, mode, XEXP (op0, 0),\n \t\t\t\t\t   GEN_INT (INTVAL (XEXP (op0, 1))\n-\t\t\t\t\t\t    & ~ INTVAL (op1))), op1);\n+\t\t\t\t\t\t    & ~INTVAL (op1))), op1);\n \n \t  if (GET_CODE (x) != AND)\n \t    return x;\n \n-\t  if (GET_RTX_CLASS (GET_CODE (x)) == 'c' \n+\t  if (GET_RTX_CLASS (GET_CODE (x)) == 'c'\n \t      || GET_RTX_CLASS (GET_CODE (x)) == '2')\n \t    op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n \t}\n@@ -5295,7 +5294,7 @@ simplify_logical (x, last)\n \t For example, (and (ior A B) (not B)) can occur as the result of\n \t expanding a bit field assignment.  When we apply the distributive\n \t law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n-\t which then simplifies to (and (A (not B))). \n+\t which then simplifies to (and (A (not B))).\n \n \t If we have (and (ior A B) C), apply the distributive law and then\n \t the inverse distributive law to see if things simplify.  */\n@@ -5327,7 +5326,7 @@ simplify_logical (x, last)\n \t\t       gen_binary (IOR, mode, XEXP (op0, 0), XEXP (op1, 0)),\n \t\t       gen_binary (IOR, mode, copy_rtx (XEXP (op0, 0)),\n \t\t\t\t   XEXP (op1, 1))));\n-\t\t\t\t\t\t\t    \n+\n       else if (GET_CODE (op1) == NOT && GET_CODE (op0) == XOR)\n \treturn apply_distributive_law\n \t  (gen_binary (XOR, mode,\n@@ -5339,7 +5338,7 @@ simplify_logical (x, last)\n       /* (ior A C) is C if all bits of A that might be nonzero are on in C.  */\n       if (GET_CODE (op1) == CONST_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero_bits (op0, mode) & ~ INTVAL (op1)) == 0)\n+\t  && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n \treturn op1;\n \n       /* Convert (A & B) | A to A.  */\n@@ -5509,7 +5508,7 @@ simplify_logical (x, last)\n    an AND operation, which is simpler, though only one operation.\n \n    The function expand_compound_operation is called with an rtx expression\n-   and will convert it to the appropriate shifts and AND operations, \n+   and will convert it to the appropriate shifts and AND operations,\n    simplifying at each stage.\n \n    The function make_compound_operation is called to convert an expression\n@@ -5549,7 +5548,7 @@ expand_compound_operation (x)\n \t Reject MODEs bigger than a word, because we might not be able\n \t to reference a two-register group starting with an arbitrary register\n \t (and currently gen_lowpart might crash for a SUBREG).  */\n-  \n+\n       if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) > UNITS_PER_WORD)\n \treturn x;\n \n@@ -5597,7 +5596,7 @@ expand_compound_operation (x)\n   if (GET_CODE (x) == SIGN_EXTEND\n       && (GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n \t  && ((nonzero_bits (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n-\t\t& ~ (((unsigned HOST_WIDE_INT)\n+\t\t& ~(((unsigned HOST_WIDE_INT)\n \t\t      GET_MODE_MASK (GET_MODE (XEXP (x, 0))))\n \t\t     >> 1))\n \t       == 0)))\n@@ -5616,7 +5615,7 @@ expand_compound_operation (x)\n \t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == GET_MODE (x)\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (XEXP (XEXP (x, 0), 0), GET_MODE (x))\n-\t      & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn XEXP (XEXP (x, 0), 0);\n \n       /* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */\n@@ -5625,7 +5624,7 @@ expand_compound_operation (x)\n \t  && subreg_lowpart_p (XEXP (x, 0))\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (SUBREG_REG (XEXP (x, 0)), GET_MODE (x))\n-\t      & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n       /* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI when foo\n@@ -5638,7 +5637,7 @@ expand_compound_operation (x)\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n  \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n-\t      & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn XEXP (XEXP (x, 0), 0);\n \n       /* Likewise for (zero_extend:DI (subreg:SI foo:DI 0)).  */\n@@ -5649,7 +5648,7 @@ expand_compound_operation (x)\n \t  && (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      <= HOST_BITS_PER_WIDE_INT)\n \t  && ((HOST_WIDE_INT) STORE_FLAG_VALUE\n-\t      & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t      & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n     }\n@@ -5665,7 +5664,7 @@ expand_compound_operation (x)\n      We must check for the case where the left shift would have a negative\n      count.  This can happen in a case like (x >> 31) & 255 on machines\n      that can't shift by a constant.  On those machines, we would first\n-     combine the shift with the AND to produce a variable-position \n+     combine the shift with the AND to produce a variable-position\n      extraction.  Then the constant of 31 would be substituted in to produce\n      a such a position.  */\n \n@@ -5688,7 +5687,6 @@ expand_compound_operation (x)\n   else\n     /* Any other cases we can't handle.  */\n     return x;\n-    \n \n   /* If we couldn't do this for some reason, return the original\n      expression.  */\n@@ -5841,7 +5839,7 @@ expand_field_assignment (x)\n    code that understands the USE is this routine.  If it is not removed,\n    it will cause the resulting insn not to match.\n \n-   UNSIGNEDP is non-zero for an unsigned reference and zero for a \n+   UNSIGNEDP is non-zero for an unsigned reference and zero for a\n    signed reference.\n \n    IN_DEST is non-zero if this is a reference in the destination of a\n@@ -5940,7 +5938,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n     {\n       /* If INNER is a MEM, make a new MEM that encompasses just the desired\n \t field.  If the original and current mode are the same, we need not\n-\t adjust the offset.  Otherwise, we do if bytes big endian.  \n+\t adjust the offset.  Otherwise, we do if bytes big endian.\n \n \t If INNER is not a MEM, get a piece consisting of just the field\n \t of interest (in this case POS % BITS_PER_WORD must be 0).  */\n@@ -5981,7 +5979,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t\t     : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n \t\t\t     NULL_RTX, 0);\n \n-      /* If this extraction is going into the destination of a SET, \n+      /* If this extraction is going into the destination of a SET,\n \t make a STRICT_LOW_PART unless we made a MEM.  */\n \n       if (in_dest)\n@@ -5999,9 +5997,9 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       if (flag_expensive_optimizations\n \t  && (GET_MODE_BITSIZE (tmode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((nonzero_bits (new, tmode)\n-\t\t   & ~ (((unsigned HOST_WIDE_INT)\n-\t\t\t GET_MODE_MASK (tmode))\n-\t\t\t>> 1))\n+\t\t   & ~(((unsigned HOST_WIDE_INT)\n+\t\t\tGET_MODE_MASK (tmode))\n+\t\t       >> 1))\n \t\t  == 0)))\n \t{\n \t  rtx temp = gen_rtx_ZERO_EXTEND (mode, new);\n@@ -6154,7 +6152,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       /* The computations below will be correct if the machine is big\n \t endian in both bits and bytes or little endian in bits and bytes.\n \t If it is mixed, we must adjust.  */\n-\t     \n+\n       /* If bytes are big endian and we had a paradoxical SUBREG, we must\n \t adjust OFFSET to compensate.  */\n       if (BYTES_BIG_ENDIAN\n@@ -6218,9 +6216,9 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       if (flag_expensive_optimizations\n \t  && (GET_MODE_BITSIZE (GET_MODE (pos_rtx)) <= HOST_BITS_PER_WIDE_INT\n \t      && ((nonzero_bits (pos_rtx, GET_MODE (pos_rtx))\n-\t\t   & ~ (((unsigned HOST_WIDE_INT)\n-\t\t\t GET_MODE_MASK (GET_MODE (pos_rtx)))\n-\t\t\t>> 1))\n+\t\t   & ~(((unsigned HOST_WIDE_INT)\n+\t\t\tGET_MODE_MASK (GET_MODE (pos_rtx)))\n+\t\t       >> 1))\n \t\t  == 0)))\n \t{\n \t  rtx temp1 = gen_rtx_SIGN_EXTEND (pos_mode, pos_rtx);\n@@ -6290,11 +6288,11 @@ extract_left_shift (x, count)\n       if (GET_CODE (XEXP (x,1)) == CONST_INT\n \t  && (INTVAL (XEXP (x, 1)) & ((((HOST_WIDE_INT) 1 << count)) - 1)) == 0\n \t  && (tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n-\treturn gen_binary (code, mode, tem, \n+\treturn gen_binary (code, mode, tem,\n \t\t\t   GEN_INT (INTVAL (XEXP (x, 1)) >> count));\n \n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -6505,7 +6503,7 @@ make_compound_operation (x, in_code)\n \t If so, try to merge the shifts into a SIGN_EXTEND.  We could\n \t also do this for some cases of SIGN_EXTRACT, but it doesn't\n \t seem worth the effort; the case checked for occurs on Alpha.  */\n-      \n+\n       if (GET_RTX_CLASS (GET_CODE (lhs)) != 'o'\n \t  && ! (GET_CODE (lhs) == SUBREG\n \t\t&& (GET_RTX_CLASS (GET_CODE (SUBREG_REG (lhs))) == 'o'))\n@@ -6515,7 +6513,7 @@ make_compound_operation (x, in_code)\n \tnew = make_extraction (mode, make_compound_operation (new, next_code),\n \t\t\t       0, NULL_RTX, mode_width - INTVAL (rhs),\n \t\t\t       code == LSHIFTRT, 0, in_code == COMPARE);\n-\t\n+\n       break;\n \n     case SUBREG:\n@@ -6556,7 +6554,7 @@ make_compound_operation (x, in_code)\n \t  return tem;\n \t}\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -6580,9 +6578,9 @@ make_compound_operation (x, in_code)\n }\n \f\n /* Given M see if it is a value that would select a field of bits\n-    within an item, but not the entire word.  Return -1 if not.\n-    Otherwise, return the starting position of the field, where 0 is the\n-    low-order bit.\n+   within an item, but not the entire word.  Return -1 if not.\n+   Otherwise, return the starting position of the field, where 0 is the\n+   low-order bit.\n \n    *PLEN is set to the length of the field.  */\n \n@@ -6592,7 +6590,7 @@ get_pos_from_mask (m, plen)\n      unsigned HOST_WIDE_INT *plen;\n {\n   /* Get the bit number of the first 1 bit from the right, -1 if none.  */\n-  int pos = exact_log2 (m & - m);\n+  int pos = exact_log2 (m & -m);\n   int len;\n \n   if (pos < 0)\n@@ -6618,7 +6616,7 @@ get_pos_from_mask (m, plen)\n    Return a possibly simplified expression, but always convert X to\n    MODE.  If X is a CONST_INT, AND the CONST_INT with MASK.\n \n-   Also, if REG is non-zero and X is a register equal in value to REG, \n+   Also, if REG is non-zero and X is a register equal in value to REG,\n    replace X with REG.\n \n    If JUST_SELECT is nonzero, don't optimize by noticing that bits in MASK\n@@ -6641,7 +6639,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \n   /* If this is a CALL or ASM_OPERANDS, don't do anything.  Some of the\n      code below will do the wrong thing since the mode of such an\n-     expression is VOIDmode. \n+     expression is VOIDmode.\n \n      Also do nothing if X is a CLOBBER; this can happen if X was\n      the return value from a call to gen_lowpart_for_combine.  */\n@@ -6676,7 +6674,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t   : (((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mask) + 1))\n \t\t      - 1));\n   else\n-    fuller_mask = ~ (HOST_WIDE_INT) 0;\n+    fuller_mask = ~(HOST_WIDE_INT) 0;\n \n   /* Determine what bits of X are guaranteed to be (non)zero.  */\n   nonzero = nonzero_bits (x, mode);\n@@ -6697,19 +6695,19 @@ force_to_mode (x, mode, mask, reg, just_select)\n       if (width > 0 && width < HOST_BITS_PER_WIDE_INT\n \t  && (cval & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n \tcval |= (HOST_WIDE_INT) -1 << width;\n-\t\n+\n       return GEN_INT (cval);\n     }\n \n   /* If X is narrower than MODE and we want all the bits in X's mode, just\n      get X in the proper mode.  */\n   if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode)\n-      && (GET_MODE_MASK (GET_MODE (x)) & ~ mask) == 0)\n+      && (GET_MODE_MASK (GET_MODE (x)) & ~mask) == 0)\n     return gen_lowpart_for_combine (mode, x);\n \n   /* If we aren't changing the mode, X is not a SUBREG, and all zero bits in\n      MASK are already known to be zero in X, we need not do anything.  */\n-  if (GET_MODE (x) == mode && code != SUBREG && (~ mask & nonzero) == 0)\n+  if (GET_MODE (x) == mode && code != SUBREG && (~mask & nonzero) == 0)\n     return x;\n \n   switch (code)\n@@ -6724,7 +6722,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t spanned the boundary of the MEM.  If we are now masking so it is\n \t within that boundary, we don't need the USE any more.  */\n       if (! BITS_BIG_ENDIAN\n-\t  && (mask & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n+\t  && (mask & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0)))) == 0)\n \treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n       break;\n \n@@ -6752,7 +6750,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \t      || (0 == (mask\n \t\t\t& GET_MODE_MASK (GET_MODE (x))\n-\t\t\t& ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))))\n+\t\t\t& ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))))\n \treturn force_to_mode (SUBREG_REG (x), mode, mask, reg, next_select);\n       break;\n \n@@ -6784,7 +6782,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t      && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      HOST_WIDE_INT cval = (INTVAL (XEXP (x, 1))\n-\t\t\t\t    | (GET_MODE_MASK (GET_MODE (x)) & ~ mask));\n+\t\t\t\t    | (GET_MODE_MASK (GET_MODE (x)) & ~mask));\n \t      int width = GET_MODE_BITSIZE (GET_MODE (x));\n \t      rtx y;\n \n@@ -6829,23 +6827,23 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t        && (XEXP (x, 0) == stack_pointer_rtx\n \t            || XEXP (x, 0) == frame_pointer_rtx))\n \t      {\n-                int sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n-                unsigned HOST_WIDE_INT sp_mask = GET_MODE_MASK (mode);\n-          \n-\t\tsp_mask &= ~ (sp_alignment - 1);\n-\t\tif ((sp_mask & ~ smask) == 0\n-\t\t    && ((INTVAL (XEXP (x, 1)) - STACK_BIAS) & ~ smask) != 0)\n+\t\tint sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n+\t\tunsigned HOST_WIDE_INT sp_mask = GET_MODE_MASK (mode);\n+\n+\t\tsp_mask &= ~(sp_alignment - 1);\n+\t\tif ((sp_mask & ~smask) == 0\n+\t\t    && ((INTVAL (XEXP (x, 1)) - STACK_BIAS) & ~smask) != 0)\n \t\t  return force_to_mode (plus_constant (XEXP (x, 0),\n-\t\t  \t\t\t\t       ((INTVAL (XEXP (x, 1)) -\n+\t\t\t\t\t\t       ((INTVAL (XEXP (x, 1)) -\n \t\t\t\t\t\t\t STACK_BIAS) & smask)\n \t\t\t\t\t\t       + STACK_BIAS),\n-\t\t \t\t\tmode, smask, reg, next_select);\n-              }\n+\t\t\t\t\tmode, smask, reg, next_select);\n+\t      }\n #endif\n-\t    if ((nonzero_bits (XEXP (x, 0), mode) & ~ smask) == 0\n-\t        && (INTVAL (XEXP (x, 1)) & ~ smask) != 0)\n+\t    if ((nonzero_bits (XEXP (x, 0), mode) & ~smask) == 0\n+\t\t&& (INTVAL (XEXP (x, 1)) & ~smask) != 0)\n \t      return force_to_mode (plus_constant (XEXP (x, 0),\n-\t\t\t\t\t           (INTVAL (XEXP (x, 1))\n+\t\t\t\t\t\t   (INTVAL (XEXP (x, 1))\n \t\t\t\t\t\t    & smask)),\n \t\t\t\t    mode, smask, reg, next_select);\n \t  }\n@@ -6873,7 +6871,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n       /* Similarly, if C contains every bit in the mask, then we may\n \t replace with (not Y).  */\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT\n-          && (INTVAL (XEXP (x, 0)) | mask) == INTVAL (XEXP (x, 0)))\n+\t  && (INTVAL (XEXP (x, 0)) | mask) == INTVAL (XEXP (x, 0)))\n \t{\n \t  x = gen_unary (NOT, GET_MODE (x), GET_MODE (x), XEXP (x, 1));\n \t  return force_to_mode (x, mode, mask, reg, next_select);\n@@ -6898,10 +6896,10 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t       + floor_log2 (INTVAL (XEXP (x, 1))))\n \t      < GET_MODE_BITSIZE (GET_MODE (x)))\n \t  && (INTVAL (XEXP (x, 1))\n-\t      & ~ nonzero_bits (XEXP (x, 0), GET_MODE (x))) == 0)\n+\t      & ~nonzero_bits (XEXP (x, 0), GET_MODE (x))) == 0)\n \t{\n \t  temp = GEN_INT ((INTVAL (XEXP (x, 1)) & mask)\n-\t\t\t      << INTVAL (XEXP (XEXP (x, 0), 1)));\n+\t\t\t  << INTVAL (XEXP (XEXP (x, 0), 1)));\n \t  temp = gen_binary (GET_CODE (x), GET_MODE (x),\n \t\t\t     XEXP (XEXP (x, 0), 0), temp);\n \t  x = gen_binary (LSHIFTRT, GET_MODE (x), temp,\n@@ -6927,7 +6925,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n       if (GET_CODE (op1) == CONST_INT && (code == IOR || code == XOR)\n \t  && (INTVAL (op1) & mask) != 0)\n \top1 = GEN_INT (INTVAL (op1) & mask);\n-\t \n+\n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n \tx = gen_binary (code, op_mode, op0, op1);\n       break;\n@@ -6946,7 +6944,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t&& (nonzero_bits (XEXP (x, 1), GET_MODE (XEXP (x, 1)))\n \t\t    < (unsigned HOST_WIDE_INT) GET_MODE_BITSIZE (mode))))\n \tbreak;\n-\t\n+\n       /* If the shift count is a constant and we can do arithmetic in\n \t the mode of the shift, refine which bits we need.  Otherwise, use the\n \t conservative form of the mask.  */\n@@ -6963,7 +6961,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t\t\t\t\t    mask, reg, next_select));\n \n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n-\tx =  gen_binary (code, op_mode, op0, XEXP (x, 1));\n+\tx = gen_binary (code, op_mode, op0, XEXP (x, 1));\n       break;\n \n     case LSHIFTRT:\n@@ -6985,7 +6983,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t     in the mode of the shift and INNER_MASK is no wider than the\n \t     width of OP_MODE.  */\n \t  if (GET_MODE_BITSIZE (op_mode) > HOST_BITS_PER_WIDE_INT\n-\t      || (inner_mask & ~ GET_MODE_MASK (op_mode)) != 0)\n+\t      || (inner_mask & ~GET_MODE_MASK (op_mode)) != 0)\n \t    op_mode = GET_MODE (x);\n \n \t  inner = force_to_mode (inner, op_mode, inner_mask, reg, next_select);\n@@ -7045,7 +7043,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) > HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      nonzero = ~ (HOST_WIDE_INT) 0;\n+\t      nonzero = ~(HOST_WIDE_INT) 0;\n \n \t      /* GET_MODE_BITSIZE (GET_MODE (x)) - INTVAL (XEXP (x, 1))\n \t\t is the number of bits a full-width mask would have set.\n@@ -7064,7 +7062,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t      nonzero >>= INTVAL (XEXP (x, 1));\n \t    }\n \n-\t  if ((mask & ~ nonzero) == 0\n+\t  if ((mask & ~nonzero) == 0\n \t      || (i = exact_log2 (mask)) >= 0)\n \t    {\n \t      x = simplify_shift_const\n@@ -7119,7 +7117,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t\t\t  INTVAL (temp), reg, next_select));\n \t}\n       break;\n-\t\n+\n     case NEG:\n       /* If we just want the low-order bit, the NEG isn't needed since it\n \t won't change the low-order bit.    */\n@@ -7167,7 +7165,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n       /* (and (ne FOO 0) CONST) can be (and FOO CONST) if CONST is included\n \t in STORE_FLAG_VALUE and FOO has a single bit that might be nonzero,\n \t which is equal to STORE_FLAG_VALUE.  */\n-      if ((mask & ~ STORE_FLAG_VALUE) == 0 && XEXP (x, 1) == const0_rtx\n+      if ((mask & ~STORE_FLAG_VALUE) == 0 && XEXP (x, 1) == const0_rtx\n \t  && exact_log2 (nonzero_bits (XEXP (x, 0), mode)) >= 0\n \t  && nonzero_bits (XEXP (x, 0), mode) == STORE_FLAG_VALUE)\n \treturn force_to_mode (XEXP (x, 0), mode, mask, reg, next_select);\n@@ -7187,7 +7185,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t\t\t      force_to_mode (XEXP (x, 2), mode,\n \t\t\t\t\t\t     mask, reg,next_select)));\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -7268,7 +7266,7 @@ if_then_else_cond (x, ptrue, pfalse)\n \n       if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \t  && (code == PLUS || code == IOR || code == XOR || code == MINUS\n-\t   || code == UMAX)\n+\t      || code == UMAX)\n \t  && GET_CODE (XEXP (x, 0)) == MULT && GET_CODE (XEXP (x, 1)) == MULT)\n \t{\n \t  rtx op0 = XEXP (XEXP (x, 0), 1);\n@@ -7290,8 +7288,8 @@ if_then_else_cond (x, ptrue, pfalse)\n \t      && ! side_effects_p (x))\n \t    {\n \t      *ptrue = gen_binary (MULT, mode, op0, const_true_rtx);\n-\t      *pfalse = gen_binary (MULT, mode, \n-\t\t\t\t    (code == MINUS \n+\t      *pfalse = gen_binary (MULT, mode,\n+\t\t\t\t    (code == MINUS\n \t\t\t\t     ? gen_unary (NEG, mode, mode, op1) : op1),\n \t\t\t\t    const_true_rtx);\n \t      return cond0;\n@@ -7373,7 +7371,7 @@ if_then_else_cond (x, ptrue, pfalse)\n \t   || ((cond0 = get_last_value (x)) != 0 && CONSTANT_P (cond0)))\n     ;\n \n-  /* If X is known to be either 0 or -1, those are the true and \n+  /* If X is known to be either 0 or -1, those are the true and\n      false values when testing X.  */\n   else if (x == constm1_rtx || x == const0_rtx\n \t   || (mode != VOIDmode\n@@ -7573,7 +7571,7 @@ make_field_assignment (x)\n \n   else if (GET_CODE (src) == AND && GET_CODE (XEXP (src, 0)) == SUBREG\n \t   && subreg_lowpart_p (XEXP (src, 0))\n-\t   && (GET_MODE_SIZE (GET_MODE (XEXP (src, 0))) \n+\t   && (GET_MODE_SIZE (GET_MODE (XEXP (src, 0)))\n \t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (src, 0)))))\n \t   && GET_CODE (SUBREG_REG (XEXP (src, 0))) == ROTATE\n \t   && INTVAL (XEXP (SUBREG_REG (XEXP (src, 0)), 0)) == -2\n@@ -7625,7 +7623,7 @@ make_field_assignment (x)\n   else\n     return x;\n \n-  pos = get_pos_from_mask ((~ c1) & GET_MODE_MASK (GET_MODE (dest)), &len);\n+  pos = get_pos_from_mask ((~c1) & GET_MODE_MASK (GET_MODE (dest)), &len);\n   if (pos < 0 || pos + len > GET_MODE_BITSIZE (GET_MODE (dest))\n       || GET_MODE_BITSIZE (GET_MODE (dest)) > HOST_BITS_PER_WIDE_INT\n       || (c1 & nonzero_bits (other, GET_MODE (dest))) != 0)\n@@ -7637,7 +7635,7 @@ make_field_assignment (x)\n \n   /* The mode to use for the source is the mode of the assignment, or of\n      what is inside a possible STRICT_LOW_PART.  */\n-  mode = (GET_CODE (assign) == STRICT_LOW_PART \n+  mode = (GET_CODE (assign) == STRICT_LOW_PART\n \t  ? GET_MODE (XEXP (assign, 0)) : GET_MODE (assign));\n \n   /* Shift OTHER right POS places and make it the source, restricting it\n@@ -7825,7 +7823,7 @@ simplify_and_const_int (x, mode, varop, constop)\n   if (GET_CODE (varop) == NEG && nonzero_bits (XEXP (varop, 0), mode) == 1\n       && (i = exact_log2 (constop)) >= 0)\n     return simplify_shift_const (NULL_RTX, ASHIFT, mode, XEXP (varop, 0), i);\n-\t\t\t\t \n+\n   /* If VAROP is an IOR or XOR, apply the AND to both branches of the IOR\n      or XOR, then try to apply the distributive law.  This may eliminate\n      operations if either branch can be simplified because of the AND.\n@@ -7919,7 +7917,7 @@ nonzero_bits (x, mode)\n \n #ifndef WORD_REGISTER_OPERATIONS\n   /* If MODE is wider than X, but both are a single word for both the host\n-     and target machines, we can compute this from which bits of the \n+     and target machines, we can compute this from which bits of the\n      object might be nonzero in its own mode, taking into account the fact\n      that on many CISC machines, accessing an object in a wider mode\n      causes the high-order bits to become undefined.  So they are\n@@ -7931,7 +7929,7 @@ nonzero_bits (x, mode)\n       && GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (GET_MODE (x)))\n     {\n       nonzero &= nonzero_bits (x, GET_MODE (x));\n-      nonzero |= GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x));\n+      nonzero |= GET_MODE_MASK (mode) & ~GET_MODE_MASK (GET_MODE (x));\n       return nonzero;\n     }\n #endif\n@@ -7966,7 +7964,7 @@ nonzero_bits (x, mode)\n \t       && REGNO (x) <= LAST_VIRTUAL_REGISTER))\n #ifdef STACK_BIAS\n \t  && !STACK_BIAS\n-#endif\t      \n+#endif\n \t      )\n \t{\n \t  int sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n@@ -7979,7 +7977,7 @@ nonzero_bits (x, mode)\n \t  /* We must return here, otherwise we may get a worse result from\n \t     one of the choices below.  There is nothing useful below as\n \t     far as the stack pointer is concerned.  */\n-\t  return nonzero &= ~ (sp_alignment - 1);\n+\t  return nonzero &= ~(sp_alignment - 1);\n \t}\n #endif\n \n@@ -7993,7 +7991,7 @@ nonzero_bits (x, mode)\n \t  && (reg_last_set_label[REGNO (x)] == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n-\t\t  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start, \n+\t\t  && ! REGNO_REG_SET_P (BASIC_BLOCK (0)->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n \treturn reg_last_set_nonzero_bits[REGNO (x)];\n@@ -8007,7 +8005,7 @@ nonzero_bits (x, mode)\n \t     constant that would appear negative in the mode of X,\n \t     sign-extend it for use in reg_nonzero_bits because some\n \t     machines (maybe most) will actually do the sign-extension\n-\t     and this is the conservative approach. \n+\t     and this is the conservative approach.\n \n \t     ??? For 2.5, try to tighten up the MD files in this regard\n \t     instead of this kludge.  */\n@@ -8074,7 +8072,7 @@ nonzero_bits (x, mode)\n #endif\n \n       if (GET_MODE_SIZE (GET_MODE (x)) < mode_width)\n-\tnonzero |= (GET_MODE_MASK (mode) & ~ GET_MODE_MASK (GET_MODE (x)));\n+\tnonzero |= (GET_MODE_MASK (mode) & ~GET_MODE_MASK (GET_MODE (x)));\n       break;\n \n     case ABS:\n@@ -8109,7 +8107,7 @@ nonzero_bits (x, mode)\n \t      & (((HOST_WIDE_INT) 1\n \t\t  << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1))))\n \t    inner_nz |= (GET_MODE_MASK (mode)\n-\t\t\t  & ~ GET_MODE_MASK (GET_MODE (XEXP (x, 0))));\n+\t\t\t & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0))));\n \t}\n \n       nonzero &= inner_nz;\n@@ -8153,20 +8151,20 @@ nonzero_bits (x, mode)\n \t  case PLUS:\n #ifdef STACK_BIAS\n \t    if (STACK_BIAS\n-\t        && (XEXP (x, 0) == stack_pointer_rtx\n-\t            || XEXP (x, 0) == frame_pointer_rtx)\n-\t        && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t\t&& (XEXP (x, 0) == stack_pointer_rtx\n+\t\t    || XEXP (x, 0) == frame_pointer_rtx)\n+\t\t&& GET_CODE (XEXP (x, 1)) == CONST_INT)\n \t      {\n \t\tint sp_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n \n-\t        nz0 = (GET_MODE_MASK (mode) & ~ (sp_alignment - 1));\n-\t        nz1 = INTVAL (XEXP (x, 1)) - STACK_BIAS;\n-\t        width0 = floor_log2 (nz0) + 1;\n-\t        width1 = floor_log2 (nz1) + 1;\n-\t        low0 = floor_log2 (nz0 & -nz0);\n-\t        low1 = floor_log2 (nz1 & -nz1);\n+\t\tnz0 = (GET_MODE_MASK (mode) & ~(sp_alignment - 1));\n+\t\tnz1 = INTVAL (XEXP (x, 1)) - STACK_BIAS;\n+\t\twidth0 = floor_log2 (nz0) + 1;\n+\t\twidth1 = floor_log2 (nz1) + 1;\n+\t\tlow0 = floor_log2 (nz0 & -nz0);\n+\t\tlow1 = floor_log2 (nz1 & -nz1);\n \t      }\n-#endif\t  \n+#endif\n \t    result_width = MAX (width0, width1) + 1;\n \t    result_low = MIN (low0, low1);\n \t    break;\n@@ -8201,7 +8199,7 @@ nonzero_bits (x, mode)\n \t  nonzero &= ((HOST_WIDE_INT) 1 << result_width) - 1;\n \n \tif (result_low > 0)\n-\t  nonzero &= ~ (((HOST_WIDE_INT) 1 << result_low) - 1);\n+\t  nonzero &= ~(((HOST_WIDE_INT) 1 << result_low) - 1);\n       }\n       break;\n \n@@ -8246,7 +8244,7 @@ nonzero_bits (x, mode)\n \t      if (GET_MODE_SIZE (GET_MODE (x))\n \t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \t\tnonzero |= (GET_MODE_MASK (GET_MODE (x))\n-\t\t\t    & ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x))));\n+\t\t\t    & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x))));\n \t    }\n \t}\n       break;\n@@ -8274,7 +8272,7 @@ nonzero_bits (x, mode)\n \t  unsigned HOST_WIDE_INT outer = 0;\n \n \t  if (mode_width > width)\n-\t    outer = (op_nonzero & nonzero & ~ mode_mask);\n+\t    outer = (op_nonzero & nonzero & ~mode_mask);\n \n \t  if (code == LSHIFTRT)\n \t    inner >>= count;\n@@ -8307,7 +8305,7 @@ nonzero_bits (x, mode)\n       nonzero &= (nonzero_bits (XEXP (x, 1), mode)\n \t\t  | nonzero_bits (XEXP (x, 2), mode));\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -8353,7 +8351,7 @@ num_sign_bit_copies (x, mode)\n       return MAX (1,\n \t\t  num0 - (int) (GET_MODE_BITSIZE (GET_MODE (x)) - bitwidth));\n     }\n-     \n+\n   if (GET_MODE (x) != VOIDmode && bitwidth > GET_MODE_BITSIZE (GET_MODE (x)))\n     {\n #ifndef WORD_REGISTER_OPERATIONS\n@@ -8396,7 +8394,7 @@ num_sign_bit_copies (x, mode)\n \t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n \treturn reg_last_set_sign_bit_copies[REGNO (x)];\n \n-      tem =  get_last_value (x);\n+      tem = get_last_value (x);\n       if (tem != 0)\n \treturn num_sign_bit_copies (tem, mode);\n \n@@ -8419,7 +8417,7 @@ num_sign_bit_copies (x, mode)\n       nonzero = INTVAL (x) & GET_MODE_MASK (mode);\n       if (bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n-\tnonzero = (~ nonzero) & GET_MODE_MASK (mode);\n+\tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n \n       return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n \n@@ -8435,7 +8433,7 @@ num_sign_bit_copies (x, mode)\n \t\t      - (int) GET_MODE_BITSIZE (GET_MODE (x)) + 1,\n \t\t      num0);\n \t}\n-\t\t \n+\n       /* For a smaller object, just ignore the high bits.  */\n       if (bitwidth <= GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))))\n \t{\n@@ -8470,7 +8468,7 @@ num_sign_bit_copies (x, mode)\n \treturn MAX (1, (int) bitwidth - INTVAL (XEXP (x, 1)));\n       break;\n \n-    case SIGN_EXTEND: \n+    case SIGN_EXTEND:\n       return (bitwidth - GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))\n \t      + num_sign_bit_copies (XEXP (x, 0), VOIDmode));\n \n@@ -8541,7 +8539,7 @@ num_sign_bit_copies (x, mode)\n       num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n       num1 = num_sign_bit_copies (XEXP (x, 1), mode);\n       return MAX (1, MIN (num0, num1) - 1);\n-      \n+\n     case MULT:\n       /* The number of bits of the product is the sum of the number of\n \t bits of both terms.  However, unless one of the terms if known\n@@ -8573,7 +8571,7 @@ num_sign_bit_copies (x, mode)\n \treturn 1;\n       else\n \treturn num_sign_bit_copies (XEXP (x, 0), mode);\n-\t\t\t\t    \n+\n     case UMOD:\n       /* The result must be <= the scond operand.  */\n       return num_sign_bit_copies (XEXP (x, 1), mode);\n@@ -8631,7 +8629,7 @@ num_sign_bit_copies (x, mode)\n       if (STORE_FLAG_VALUE == -1)\n \treturn bitwidth;\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -8684,7 +8682,7 @@ extended_count (x, mode, unsignedp)\n    (with *POP0 being done last).\n \n    Return 1 if we can do the operation and update *POP0 and *PCONST0 with\n-   the resulting operation.  *PCOMP_P is set to 1 if we would need to \n+   the resulting operation.  *PCOMP_P is set to 1 if we would need to\n    complement the innermost operand, otherwise it is unchanged.\n \n    MODE is the mode in which the operation will be done.  No bits outside\n@@ -8777,7 +8775,7 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n \t  op0 = AND, *pcomp_p = 1;\n \telse /* op1 == IOR */\n \t  /* (a | b) ^ b == a & ~b */\n-\t  op0 = AND, *pconst0 = ~ const0;\n+\t  op0 = AND, *pconst0 = ~const0;\n \tbreak;\n \n       case AND:\n@@ -8894,7 +8892,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t Since these shifts are being produced by the compiler by combining\n \t multiple operations, each of which are defined, we know what the\n \t result is supposed to be.  */\n-\t \n+\n       if (count > GET_MODE_BITSIZE (shift_mode) - 1)\n \t{\n \t  if (code == ASHIFTRT)\n@@ -8996,7 +8994,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      else\n \t\t{\n \t\t  new = copy_rtx (XEXP (varop, 0));\n-\t\t  SUBST (XEXP (new, 0), \n+\t\t  SUBST (XEXP (new, 0),\n \t\t\t plus_constant (XEXP (new, 0),\n \t\t\t\t\tcount / BITS_PER_UNIT));\n \t\t}\n@@ -9053,7 +9051,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t  break;\n \n \tcase ASHIFTRT:\n-\t  /* If we are extracting just the sign bit of an arithmetic right \n+\t  /* If we are extracting just the sign bit of an arithmetic right\n \t     shift, that shift is not needed.  */\n \t  if (code == LSHIFTRT && count == GET_MODE_BITSIZE (result_mode) - 1)\n \t    {\n@@ -9091,9 +9089,9 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\t      - GET_MODE_BITSIZE (GET_MODE (varop))) == count)\n \t\t{\n \t\t  /* C3 has the low-order C1 bits zero.  */\n-\t\t  \n+\n \t\t  mask = (GET_MODE_MASK (mode)\n-\t\t\t  & ~ (((HOST_WIDE_INT) 1 << first_count) - 1));\n+\t\t\t  & ~(((HOST_WIDE_INT) 1 << first_count) - 1));\n \n \t\t  varop = simplify_and_const_int (NULL_RTX, result_mode,\n \t\t\t\t\t\t  XEXP (varop, 0), mask);\n@@ -9103,11 +9101,11 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\t  code = ASHIFTRT;\n \t\t  continue;\n \t\t}\n-\t      \n+\n \t      /* If this was (ashiftrt (ashift foo C1) C2) and FOO has more\n \t\t than C1 high-order bits equal to the sign bit, we can convert\n \t\t this to either an ASHIFT or a ASHIFTRT depending on the\n-\t\t two counts. \n+\t\t two counts.\n \n \t\t We cannot do this if VAROP's mode is not SHIFT_MODE.  */\n \n@@ -9120,7 +9118,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \n \t\t  signed_count = count - first_count;\n \t\t  if (signed_count < 0)\n-\t\t    count = - signed_count, code = ASHIFT;\n+\t\t    count = -signed_count, code = ASHIFT;\n \t\t  else\n \t\t    count = signed_count;\n \n@@ -9164,15 +9162,15 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\tbreak;\n \n \t      /* To compute the mask to apply after the shift, shift the\n-\t\t nonzero bits of the inner shift the same way the \n+\t\t nonzero bits of the inner shift the same way the\n \t\t outer shift will.  */\n \n \t      mask_rtx = GEN_INT (nonzero_bits (varop, GET_MODE (varop)));\n \n \t      mask_rtx\n \t\t= simplify_binary_operation (code, result_mode, mask_rtx,\n \t\t\t\t\t     GEN_INT (count));\n-\t\t\t\t  \n+\n \t      /* Give up if we can't compute an outer operation to use.  */\n \t      if (mask_rtx == 0\n \t\t  || GET_CODE (mask_rtx) != CONST_INT\n@@ -9190,7 +9188,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      else\n \t\tsigned_count -= first_count;\n \n-\t      /* If COUNT is positive, the new shift is usually CODE, \n+\t      /* If COUNT is positive, the new shift is usually CODE,\n \t\t except for the two exceptions below, in which case it is\n \t\t FIRST_CODE.  If the count is negative, FIRST_CODE should\n \t\t always be used  */\n@@ -9199,7 +9197,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\t      || (first_code == ASHIFTRT && code == LSHIFTRT)))\n \t\tcode = first_code, count = signed_count;\n \t      else if (signed_count < 0)\n-\t\tcode = first_code, count = - signed_count;\n+\t\tcode = first_code, count = -signed_count;\n \t      else\n \t\tcount = signed_count;\n \n@@ -9267,7 +9265,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      && (new = simplify_binary_operation (code, result_mode,\n \t\t\t\t\t\t   XEXP (varop, 1),\n \t\t\t\t\t\t   GEN_INT (count))) != 0\n-\t      && GET_CODE(new) == CONST_INT\n+\t      && GET_CODE (new) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n \t    {\n@@ -9302,7 +9300,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      && count == GET_MODE_BITSIZE (result_mode) - 1\n \t      && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n \t      && ((STORE_FLAG_VALUE\n-\t\t   & ((HOST_WIDE_INT) 1 \n+\t\t   & ((HOST_WIDE_INT) 1\n \t\t      < (GET_MODE_BITSIZE (result_mode) - 1))))\n \t      && nonzero_bits (XEXP (varop, 0), result_mode) == 1\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n@@ -9447,7 +9445,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      continue;\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -9518,7 +9516,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n   if (orig_code == LSHIFTRT && result_mode != shift_mode)\n     x = simplify_and_const_int (NULL_RTX, shift_mode, x,\n \t\t\t\tGET_MODE_MASK (result_mode) >> orig_count);\n-      \n+\n   /* Do the remainder of the processing in RESULT_MODE.  */\n   x = gen_lowpart_for_combine (result_mode, x);\n \n@@ -9545,7 +9543,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n     }\n \n   return x;\n-}  \n+}\n \f\n /* Like recog, but we receive the address of a pointer to a new pattern.\n    We try to match the rtx that the pointer points to.\n@@ -9847,11 +9845,11 @@ gen_binary (code, mode, op0, op1)\n \t  || (CONSTANT_P (op0) && GET_CODE (op1) != CONST_INT)))\n     tem = op0, op0 = op1, op1 = tem;\n \n-  if (GET_RTX_CLASS (code) == '<') \n+  if (GET_RTX_CLASS (code) == '<')\n     {\n       enum machine_mode op_mode = GET_MODE (op0);\n \n-      /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get \n+      /* Strip the COMPARE from (REL_OP (compare X Y) 0) to get\n \t just (REL_OP X Y).  */\n       if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n \t{\n@@ -9884,7 +9882,7 @@ gen_binary (code, mode, op0, op1)\n      an AND.  */\n   else if (code == AND && GET_CODE (op1) == CONST_INT\n \t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t   && (nonzero_bits (op0, mode) & ~ INTVAL (op1)) == 0)\n+\t   && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n     return op0;\n \n   return gen_rtx_combine (code, mode, op0, op1);\n@@ -9984,8 +9982,8 @@ simplify_comparison (code, pop0, pop1)\n \t  else if (GET_CODE (op0) == ASHIFT)\n \t    mask = (mask & (mask << shift_count)) >> shift_count;\n \n-\t  if ((nonzero_bits (XEXP (op0, 0), mode) & ~ mask) == 0\n-\t      && (nonzero_bits (XEXP (op1, 0), mode) & ~ mask) == 0)\n+\t  if ((nonzero_bits (XEXP (op0, 0), mode) & ~mask) == 0\n+\t      && (nonzero_bits (XEXP (op1, 0), mode) & ~mask) == 0)\n \t    op0 = XEXP (op0, 0), op1 = XEXP (op1, 0);\n \t  else\n \t    break;\n@@ -10004,16 +10002,16 @@ simplify_comparison (code, pop0, pop1)\n \t operations from some narrower mode even though a SUBREG is not\n \t present.  */\n \n-      else if  (GET_CODE (op0) == AND && GET_CODE (op1) == AND\n-\t\t&& GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t\t&& GET_CODE (XEXP (op1, 1)) == CONST_INT)\n+      else if (GET_CODE (op0) == AND && GET_CODE (op1) == AND\n+\t       && GET_CODE (XEXP (op0, 1)) == CONST_INT\n+\t       && GET_CODE (XEXP (op1, 1)) == CONST_INT)\n \t{\n \t  rtx inner_op0 = XEXP (op0, 0);\n \t  rtx inner_op1 = XEXP (op1, 0);\n \t  HOST_WIDE_INT c0 = INTVAL (XEXP (op0, 1));\n \t  HOST_WIDE_INT c1 = INTVAL (XEXP (op1, 1));\n \t  int changed = 0;\n-\t\t\n+\n \t  if (GET_CODE (inner_op0) == SUBREG && GET_CODE (inner_op1) == SUBREG\n \t      && (GET_MODE_SIZE (GET_MODE (inner_op0))\n \t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner_op0))))\n@@ -10064,7 +10062,7 @@ simplify_comparison (code, pop0, pop1)\n       else\n \tbreak;\n     }\n-     \n+\n   /* If the first operand is a constant, swap the operands and adjust the\n      comparison code appropriately, but don't do this if the second operand\n      is already a constant integer.  */\n@@ -10132,7 +10130,7 @@ simplify_comparison (code, pop0, pop1)\n \t}\n \n       /* Do some canonicalizations based on the comparison code.  We prefer\n-\t comparisons against zero and then prefer equality comparisons.  \n+\t comparisons against zero and then prefer equality comparisons.\n \t If we can reduce the size of a constant, we will do that too.  */\n \n       switch (code)\n@@ -10180,7 +10178,7 @@ simplify_comparison (code, pop0, pop1)\n \t    break;\n \n \tcase GT:\n-\t  /* > C is equivalent to >= (C + 1); we do this for C < 0*/\n+\t  /* > C is equivalent to >= (C + 1); we do this for C < 0.  */\n \t  if (const_op < 0)\n \t    {\n \t      const_op += 1;\n@@ -10296,7 +10294,7 @@ simplify_comparison (code, pop0, pop1)\n \tcase ZERO_EXTRACT:\n \t  /* If we are extracting a single bit from a variable position in\n \t     a constant that has only a single bit set and are comparing it\n-\t     with zero, we can convert this into an equality comparison \n+\t     with zero, we can convert this into an equality comparison\n \t     between the position and the location of the single bit.  */\n \n \t  if (GET_CODE (XEXP (op0, 0)) == CONST_INT\n@@ -10312,7 +10310,7 @@ simplify_comparison (code, pop0, pop1)\n \t\t    mode = word_mode;\n \t\t  i = (GET_MODE_BITSIZE (mode) - 1 - i);\n #else\n-\t          i = BITS_PER_WORD - 1 - i;\n+\t\t  i = BITS_PER_WORD - 1 - i;\n #endif\n \t\t}\n \n@@ -10421,7 +10419,7 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \n-\t  /* ... fall through ...  */\n+\t  /* Fall through.  */\n \n \tcase ABS:\n \t  /* ABS is ignorable inside an equality comparison with zero.  */\n@@ -10431,11 +10429,10 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \t  break;\n-\t  \n \n \tcase SIGN_EXTEND:\n \t  /* Can simplify (compare (zero/sign_extend FOO) CONST)\n-\t     to (compare FOO CONST) if CONST fits in FOO's mode and we \n+\t     to (compare FOO CONST) if CONST fits in FOO's mode and we\n \t     are either testing inequality or have an unsigned comparison\n \t     with ZERO_EXTEND or a signed comparison with SIGN_EXTEND.  */\n \t  if (! unsigned_comparison_p\n@@ -10465,12 +10462,12 @@ simplify_comparison (code, pop0, pop1)\n \t      && GET_CODE (SUBREG_REG (op0)) == PLUS\n \t      && GET_CODE (XEXP (SUBREG_REG (op0), 1)) == CONST_INT\n \t      && INTVAL (XEXP (SUBREG_REG (op0), 1)) < 0\n-\t      && (- INTVAL (XEXP (SUBREG_REG (op0), 1))\n-\t\t  < (HOST_WIDE_INT)(GET_MODE_MASK (mode) / 2))\n+\t      && (-INTVAL (XEXP (SUBREG_REG (op0), 1))\n+\t\t  < (HOST_WIDE_INT) (GET_MODE_MASK (mode) / 2))\n \t      && (unsigned HOST_WIDE_INT) const_op < GET_MODE_MASK (mode) / 2\n \t      && (0 == (nonzero_bits (XEXP (SUBREG_REG (op0), 0),\n \t\t\t\t      GET_MODE (SUBREG_REG (op0)))\n-\t\t\t& ~ GET_MODE_MASK (mode))\n+\t\t\t& ~GET_MODE_MASK (mode))\n \t\t  || (num_sign_bit_copies (XEXP (SUBREG_REG (op0), 0),\n \t\t\t\t\t   GET_MODE (SUBREG_REG (op0)))\n \t\t      > (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n@@ -10657,7 +10654,7 @@ simplify_comparison (code, pop0, pop1)\n \t    {\n \t      mask = ((INTVAL (XEXP (op0, 1)) & GET_MODE_MASK (mode))\n \t\t      << INTVAL (XEXP (XEXP (op0, 0), 1)));\n-\t      if ((~ STORE_FLAG_VALUE & mask) == 0\n+\t      if ((~STORE_FLAG_VALUE & mask) == 0\n \t\t  && (GET_RTX_CLASS (GET_CODE (XEXP (XEXP (op0, 0), 0))) == '<'\n \t\t      || ((tem = get_last_value (XEXP (XEXP (op0, 0), 0))) != 0\n \t\t\t  && GET_RTX_CLASS (GET_CODE (tem)) == '<')))\n@@ -10728,13 +10725,13 @@ simplify_comparison (code, pop0, pop1)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n \t\t  <= HOST_BITS_PER_WIDE_INT)\n-\t      && (INTVAL (XEXP (op0, 1)) & ~ mask) == 0\n-\t      && 0 == (~ GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n+\t      && (INTVAL (XEXP (op0, 1)) & ~mask) == 0\n+\t      && 0 == (~GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n \t\t       & INTVAL (XEXP (op0, 1)))\n \t      && (unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1)) != mask\n \t      && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op0, 1))\n \t\t  != GET_MODE_MASK (GET_MODE (SUBREG_REG (XEXP (op0, 0))))))\n-\t\t       \n+\n \t    {\n \t      op0\n \t\t= gen_lowpart_for_combine\n@@ -10760,13 +10757,13 @@ simplify_comparison (code, pop0, pop1)\n \t\t   & (((HOST_WIDE_INT) 1 << INTVAL (XEXP (op0, 1))) - 1)) == 0)\n \t      && mode_width <= HOST_BITS_PER_WIDE_INT\n \t      && (nonzero_bits (XEXP (op0, 0), mode)\n-\t\t  & ~ (mask >> (INTVAL (XEXP (op0, 1))\n-\t\t\t\t+ ! equality_comparison_p))) == 0)\n+\t\t  & ~(mask >> (INTVAL (XEXP (op0, 1))\n+\t\t\t       + ! equality_comparison_p))) == 0)\n \t    {\n \t      /* We must perform a logical shift, not an arithmetic one,\n \t\t as we want the top N bits of C to be zero.  */\n \t      unsigned HOST_WIDE_INT temp = const_op & GET_MODE_MASK (mode);\n-\t      \n+\n \t      temp >>= INTVAL (XEXP (op0, 1));\n \t      op1 = GEN_INT (trunc_int_for_mode (temp, mode));\n \t      op0 = XEXP (op0, 0);\n@@ -10820,7 +10817,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n \t\t\t\t\t MODE_INT, 1)) != BLKmode\n \t      && ((unsigned HOST_WIDE_INT) const_op <= GET_MODE_MASK (tmode)\n-\t\t  || ((unsigned HOST_WIDE_INT) - const_op\n+\t\t  || ((unsigned HOST_WIDE_INT) -const_op\n \t\t      <= GET_MODE_MASK (tmode))))\n \t    {\n \t      op0 = gen_lowpart_for_combine (tmode, XEXP (XEXP (op0, 0), 0));\n@@ -10839,7 +10836,7 @@ simplify_comparison (code, pop0, pop1)\n \t      && (tmode = mode_for_size (mode_width - INTVAL (XEXP (op0, 1)),\n \t\t\t\t\t MODE_INT, 1)) != BLKmode\n \t      && ((unsigned HOST_WIDE_INT) const_op <= GET_MODE_MASK (tmode)\n-\t\t  || ((unsigned HOST_WIDE_INT) - const_op\n+\t\t  || ((unsigned HOST_WIDE_INT) -const_op\n \t\t      <= GET_MODE_MASK (tmode))))\n \t    {\n \t      rtx inner = XEXP (XEXP (XEXP (op0, 0), 0), 0);\n@@ -10887,7 +10884,7 @@ simplify_comparison (code, pop0, pop1)\n \t      continue;\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -10921,11 +10918,11 @@ simplify_comparison (code, pop0, pop1)\n \t   && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n \t       <= HOST_BITS_PER_WIDE_INT)\n \t   && (nonzero_bits (SUBREG_REG (op0), GET_MODE (SUBREG_REG (op0)))\n-\t       & ~ GET_MODE_MASK (GET_MODE (op0))) == 0\n+\t       & ~GET_MODE_MASK (GET_MODE (op0))) == 0\n \t   && (tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)),\n \t\t\t\t\t      op1),\n \t       (nonzero_bits (tem, GET_MODE (SUBREG_REG (op0)))\n-\t\t& ~ GET_MODE_MASK (GET_MODE (op0))) == 0))\n+\t\t& ~GET_MODE_MASK (GET_MODE (op0))) == 0))\n     op0 = SUBREG_REG (op0), op1 = tem;\n \n   /* We now do the opposite procedure: Some machines don't have compare\n@@ -10950,8 +10947,8 @@ simplify_comparison (code, pop0, pop1)\n \t     values, in which case it is true for all comparisons.  */\n \t  if (((code == EQ || code == NE\n \t\t|| code == GEU || code == GTU || code == LEU || code == LTU)\n-\t       && (nonzero_bits (op0, tmode) & ~ GET_MODE_MASK (mode)) == 0\n-\t       && (nonzero_bits (op1, tmode) & ~ GET_MODE_MASK (mode)) == 0)\n+\t       && (nonzero_bits (op0, tmode) & ~GET_MODE_MASK (mode)) == 0\n+\t       && (nonzero_bits (op1, tmode) & ~GET_MODE_MASK (mode)) == 0)\n \t      || ((num_sign_bit_copies (op0, tmode)\n \t\t   > GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))\n \t\t  && (num_sign_bit_copies (op1, tmode)\n@@ -11032,7 +11029,7 @@ reversible_comparison_p (x)\n       x = get_last_value (XEXP (x, 0));\n       return (x && GET_CODE (x) == COMPARE\n \t      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0))));\n-      \n+\n     default:\n       return 0;\n     }\n@@ -11063,7 +11060,7 @@ update_table_tick (x)\n \n       return;\n     }\n-  \n+\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     /* Note that we can't have an \"E\" in values stored; see\n        get_last_value_validate.  */\n@@ -11097,7 +11094,7 @@ record_value_for_reg (reg, insn, value)\n       /* Set things up so get_last_value is allowed to see anything set up to\n \t our insn.  */\n       subst_low_cuid = INSN_CUID (insn);\n-      tem = get_last_value (reg);      \n+      tem = get_last_value (reg);\n \n       /* If TEM is simply a binary operation with two CLOBBERs as operands,\n \t it isn't going to be useful and will take a lot of time to process,\n@@ -11280,8 +11277,8 @@ record_dead_and_set_regs (insn)\n \n static void\n record_promoted_value (insn, subreg)\n-    rtx insn;\n-    rtx subreg;\n+     rtx insn;\n+     rtx subreg;\n {\n   rtx links, set;\n   unsigned int regno = REGNO (SUBREG_REG (subreg));\n@@ -11290,7 +11287,7 @@ record_promoted_value (insn, subreg)\n   if (GET_MODE_BITSIZE (mode) > HOST_BITS_PER_WIDE_INT)\n     return;\n \n-  for (links = LOG_LINKS (insn); links; )\n+  for (links = LOG_LINKS (insn); links;)\n     {\n       insn = XEXP (links, 0);\n       set = single_set (insn);\n@@ -11303,11 +11300,11 @@ record_promoted_value (insn, subreg)\n \t  continue;\n \t}\n \n-      if (reg_last_set [regno] == insn)\n-        {\n+      if (reg_last_set[regno] == insn)\n+\t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg))\n-\t    reg_last_set_nonzero_bits [regno] &= GET_MODE_MASK (mode);\n-        }\n+\t    reg_last_set_nonzero_bits[regno] &= GET_MODE_MASK (mode);\n+\t}\n \n       if (GET_CODE (SET_SRC (set)) == REG)\n \t{\n@@ -11324,8 +11321,8 @@ record_promoted_value (insn, subreg)\n \n static void\n check_promoted_subreg (insn, x)\n-    rtx insn;\n-    rtx x;\n+     rtx insn;\n+     rtx x;\n {\n   if (GET_CODE (x) == SUBREG && SUBREG_PROMOTED_VAR_P (x)\n       && GET_CODE (SUBREG_REG (x)) == REG)\n@@ -11336,7 +11333,7 @@ check_promoted_subreg (insn, x)\n       int i, j;\n \n       for (i = 0; i < GET_RTX_LENGTH (GET_CODE (x)); i++)\n-\tswitch (format [i])\n+\tswitch (format[i])\n \t  {\n \t  case 'e':\n \t    check_promoted_subreg (insn, XEXP (x, i));\n@@ -11385,7 +11382,7 @@ get_last_value_validate (loc, insn, tick, replace)\n \tif (reg_last_set_invalid[j]\n \t    /* If this is a pseudo-register that was only set once and not\n \t       live at the beginning of the function, it is always valid.  */\n-\t    || (! (regno >= FIRST_PSEUDO_REGISTER \n+\t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n \t\t   && (! REGNO_REG_SET_P\n \t\t       (BASIC_BLOCK (0)->global_live_at_start, regno)))\n@@ -11449,9 +11446,9 @@ get_last_value (x)\n \n   /* If we don't have a value, or if it isn't for this basic block and\n      it's either a hard register, set more than once, or it's a live\n-     at the beginning of the function, return 0.  \n+     at the beginning of the function, return 0.\n \n-     Because if it's not live at the beginnning of the function then the reg \n+     Because if it's not live at the beginnning of the function then the reg\n      is always set before being used (is never used without being set).\n      And, if it's set only once, and it's always set before use, then all\n      uses must have the same last value, even if it's not from this basic\n@@ -11502,8 +11499,8 @@ use_crosses_set_p (x, from_cuid)\n     {\n       unsigned int regno = REGNO (x);\n       unsigned endreg = regno + (regno < FIRST_PSEUDO_REGISTER\n-\t\t\t    ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n-      \n+\t\t\t\t ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n+\n #ifdef PUSH_ROUNDING\n       /* Don't allow uses of the stack pointer to be moved,\n \t because we don't know whether the move crosses a push insn.  */\n@@ -11546,7 +11543,7 @@ static int reg_dead_flag;\n \n /* Function called via note_stores from reg_dead_at_p.\n \n-   If DEST is within [reg_dead_regno, reg_dead_endregno), set \n+   If DEST is within [reg_dead_regno, reg_dead_endregno), set\n    reg_dead_flag to 1 if X is a CLOBBER and to -1 it is a SET.  */\n \n static void\n@@ -11561,7 +11558,7 @@ reg_dead_at_p_1 (dest, x, data)\n     return;\n \n   regno = REGNO (dest);\n-  endregno = regno + (regno < FIRST_PSEUDO_REGISTER \n+  endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (dest)) : 1);\n \n   if (reg_dead_endregno > regno && reg_dead_regno < endregno)\n@@ -11725,19 +11722,18 @@ mark_used_regs_combine (x)\n \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n-        if (fmt[i] == 'e')\n+\tif (fmt[i] == 'e')\n \t  mark_used_regs_combine (XEXP (x, i));\n-        else if (fmt[i] == 'E')\n-          {\n-            register int j;\n+\telse if (fmt[i] == 'E')\n+\t  {\n+\t    register int j;\n \n-            for (j = 0; j < XVECLEN (x, i); j++)\n-              mark_used_regs_combine (XVECEXP (x, i, j));\n-          }\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      mark_used_regs_combine (XVECEXP (x, i, j));\n+\t  }\n       }\n   }\n }\n-\n \f\n /* Remove register number REGNO from the dead registers list of INSN.\n \n@@ -11762,7 +11758,7 @@ remove_death (regno, insn)\n /* For each register (hardware or pseudo) used within expression X, if its\n    death is in an instruction with cuid between FROM_CUID (inclusive) and\n    TO_INSN (exclusive), put a REG_DEAD note for that register in the\n-   list headed by PNOTES. \n+   list headed by PNOTES.\n \n    That said, don't move registers killed by maybe_kill_insn.\n \n@@ -11983,7 +11979,7 @@ reg_bitfield_target_p (x, body)\n \treturn 1;\n \n   return 0;\n-}      \n+}\n \f\n /* Given a chain of REG_NOTES originally from FROM_INSN, try to place them\n    as appropriate.  I3 and I2 are the insns resulting from the combination\n@@ -12031,7 +12027,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \tcase REG_EH_RETHROW:\n \t  /* These notes must remain with the call.  It should not be\n \t     possible for both I2 and I3 to be a call.  */\n-\t  if (GET_CODE (i3) == CALL_INSN) \n+\t  if (GET_CODE (i3) == CALL_INSN)\n \t    place = i3;\n \t  else if (i2 && GET_CODE (i2) == CALL_INSN)\n \t    place = i2;\n@@ -12130,7 +12126,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t  if (i2\n \t      && (reg_mentioned_p (XEXP (note, 0), PATTERN (i2))\n-\t          || ((tem = find_reg_note (i2, REG_EQUAL, NULL_RTX))\n+\t\t  || ((tem = find_reg_note (i2, REG_EQUAL, NULL_RTX))\n \t\t      && GET_CODE (XEXP (tem, 0)) == LABEL_REF\n \t\t      && XEXP (XEXP (tem, 0), 0) == XEXP (note, 0))))\n \t    {\n@@ -12191,7 +12187,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t  if (from_insn\n \t      && GET_CODE (from_insn) == CALL_INSN\n-              && find_reg_fusage (from_insn, USE, XEXP (note, 0)))\n+\t      && find_reg_fusage (from_insn, USE, XEXP (note, 0)))\n \t    place = from_insn;\n \t  else if (reg_referenced_p (XEXP (note, 0), PATTERN (i3)))\n \t    place = i3;\n@@ -12228,14 +12224,14 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t\t      if (set != 0)\n \t\t\tfor (inner_dest = SET_DEST (set);\n-\t\t\t     GET_CODE (inner_dest) == STRICT_LOW_PART\n-\t\t\t       || GET_CODE (inner_dest) == SUBREG\n-\t\t\t       || GET_CODE (inner_dest) == ZERO_EXTRACT;\n+\t\t\t     (GET_CODE (inner_dest) == STRICT_LOW_PART\n+\t\t\t      || GET_CODE (inner_dest) == SUBREG\n+\t\t\t      || GET_CODE (inner_dest) == ZERO_EXTRACT);\n \t\t\t     inner_dest = XEXP (inner_dest, 0))\n \t\t\t  ;\n \n \t\t      /* Verify that it was the set, and not a clobber that\n-\t\t\t modified the register. \n+\t\t\t modified the register.\n \n \t\t\t CC0 targets must be careful to maintain setter/user\n \t\t\t pairs.  If we cannot delete the setter due to side\n@@ -12252,7 +12248,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t  )\n \t\t\t{\n \t\t\t  /* Move the notes and links of TEM elsewhere.\n-\t\t\t     This might delete other dead insns recursively. \n+\t\t\t     This might delete other dead insns recursively.\n \t\t\t     First set the pattern to something that won't use\n \t\t\t     any register.  */\n \n@@ -12301,7 +12297,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t      else\n \t\t\t{\n \t\t\t  PUT_REG_NOTE_KIND (note, REG_UNUSED);\n-\t\t\t  \n+\n \t\t\t  /*  If there isn't already a REG_UNUSED note, put one\n \t\t\t      here.  */\n \t\t\t  if (! find_regno_note (tem, REG_UNUSED,\n@@ -12324,7 +12320,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t i2.  */\n \t\t      if (i2 && INSN_UID (place) <= max_uid_cuid\n \t\t\t  && INSN_CUID (place) > INSN_CUID (i2)\n-\t\t\t  && from_insn && INSN_CUID (from_insn) > INSN_CUID (i2)\n+\t\t\t  && from_insn\n+\t\t\t  && INSN_CUID (from_insn) > INSN_CUID (i2)\n \t\t\t  && reg_referenced_p (XEXP (note, 0), PATTERN (i2)))\n \t\t\t{\n \t\t\t  rtx links = LOG_LINKS (place);\n@@ -12337,7 +12334,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t  if (tem == bb->head)\n \t\t    break;\n \t\t}\n-\t      \n+\n \t      /* We haven't found an insn for the death note and it\n \t\t is still a REG_DEAD note, but we have hit the beginning\n \t\t of the block.  If the existing life info says the reg\n@@ -12434,10 +12431,10 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t  if (all_used)\n \t\t    for (i = regno; i < endregno; i++)\n \t\t      if (dead_or_set_regno_p (place, i))\n-\t\t\t  {\n-\t\t\t    all_used = 0;\n-\t\t\t    break;\n-\t\t\t  }\n+\t\t\t{\n+\t\t\t  all_used = 0;\n+\t\t\t  break;\n+\t\t\t}\n \n \t\t  if (! all_used)\n \t\t    {\n@@ -12516,7 +12513,7 @@ distribute_links (links)\n \n       /* If the insn that this link points to is a NOTE or isn't a single\n \t set, ignore it.  In the latter case, it isn't clear what we\n-\t can do other than ignore the link, since we can't tell which \n+\t can do other than ignore the link, since we can't tell which\n \t register it was for.  Such links wouldn't be used by combine\n \t anyway.\n \n@@ -12556,7 +12553,7 @@ distribute_links (links)\n \t    break;\n \t  }\n \telse if (GET_CODE (insn) == CALL_INSN\n-\t      && find_reg_fusage (insn, USE, reg))\n+\t\t && find_reg_fusage (insn, USE, reg))\n \t  {\n \t    place = insn;\n \t    break;\n@@ -12580,7 +12577,7 @@ distribute_links (links)\n \n \t      /* Set added_links_insn to the earliest insn we added a\n \t\t link to.  */\n-\t      if (added_links_insn == 0 \n+\t      if (added_links_insn == 0\n \t\t  || INSN_CUID (added_links_insn) > INSN_CUID (place))\n \t\tadded_links_insn = place;\n \t    }"}]}