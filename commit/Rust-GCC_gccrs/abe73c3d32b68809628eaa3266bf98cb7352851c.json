{"sha": "abe73c3d32b68809628eaa3266bf98cb7352851c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlNzNjM2QzMmI2ODgwOTYyOGVhYTMyNjZiZjk4Y2I3MzUyODUxYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-07T18:41:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-07T18:41:59Z"}, "message": "Make gimple_build_vector take a tree_vector_builder\n\nThis patch changes gimple_build_vector so that it takes a\ntree_vector_builder instead of a size and a vector of trees.\n\n2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* vector-builder.h (vector_builder::derived): New const overload.\n\t(vector_builder::elt): New function.\n\t* tree-vector-builder.h (tree_vector_builder::type): New function.\n\t(tree_vector_builder::apply_step): Declare.\n\t* tree-vector-builder.c (tree_vector_builder::apply_step): New\n\tfunction.\n\t* gimple-fold.h (tree_vector_builder): Declare.\n\t(gimple_build_vector): Take a tree_vector_builder instead of a\n\ttype and vector of elements.\n\t* gimple-fold.c (gimple_build_vector): Likewise.\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Update call\n\taccordingly.\n\t(get_initial_defs_for_reduction): Likewise.\n\t(vectorizable_induction): Likewise.\n\nFrom-SVN: r255478", "tree": {"sha": "f651282f43b411a678d09f3e8beca08fb288a564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f651282f43b411a678d09f3e8beca08fb288a564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe73c3d32b68809628eaa3266bf98cb7352851c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe73c3d32b68809628eaa3266bf98cb7352851c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe73c3d32b68809628eaa3266bf98cb7352851c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe73c3d32b68809628eaa3266bf98cb7352851c/comments", "author": null, "committer": null, "parents": [{"sha": "b3def403fa7ae89679468b8f986cab7361c1034d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3def403fa7ae89679468b8f986cab7361c1034d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3def403fa7ae89679468b8f986cab7361c1034d"}], "stats": {"total": 126, "additions": 99, "deletions": 27}, "files": [{"sha": "d7954ff8fc63cddef33f52692e42ae4907f83568", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -1,3 +1,20 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* vector-builder.h (vector_builder::derived): New const overload.\n+\t(vector_builder::elt): New function.\n+\t* tree-vector-builder.h (tree_vector_builder::type): New function.\n+\t(tree_vector_builder::apply_step): Declare.\n+\t* tree-vector-builder.c (tree_vector_builder::apply_step): New\n+\tfunction.\n+\t* gimple-fold.h (tree_vector_builder): Declare.\n+\t(gimple_build_vector): Take a tree_vector_builder instead of a\n+\ttype and vector of elements.\n+\t* gimple-fold.c (gimple_build_vector): Likewise.\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Update call\n+\taccordingly.\n+\t(get_initial_defs_for_reduction): Likewise.\n+\t(vectorizable_induction): Likewise.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vector-builder.h"}, {"sha": "24f7e76228b9000f6250e39365843982ba15b4c8", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -7178,23 +7178,30 @@ gimple_build_vector_from_val (gimple_seq *seq, location_t loc, tree type,\n   return res;\n }\n \n-/* Build a vector of type TYPE in which the elements have the values\n-   given by ELTS.  Return a gimple value for the result, appending any\n-   new instructions to SEQ.  */\n+/* Build a vector from BUILDER, handling the case in which some elements\n+   are non-constant.  Return a gimple value for the result, appending any\n+   new instructions to SEQ.\n+\n+   BUILDER must not have a stepped encoding on entry.  This is because\n+   the function is not geared up to handle the arithmetic that would\n+   be needed in the variable case, and any code building a vector that\n+   is known to be constant should use BUILDER->build () directly.  */\n \n tree\n-gimple_build_vector (gimple_seq *seq, location_t loc, tree type,\n-\t\t     vec<tree> elts)\n+gimple_build_vector (gimple_seq *seq, location_t loc,\n+\t\t     tree_vector_builder *builder)\n {\n-  unsigned int nelts = elts.length ();\n-  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n-  for (unsigned int i = 0; i < nelts; ++i)\n-    if (!TREE_CONSTANT (elts[i]))\n+  gcc_assert (builder->nelts_per_pattern () <= 2);\n+  unsigned int encoded_nelts = builder->encoded_nelts ();\n+  for (unsigned int i = 0; i < encoded_nelts; ++i)\n+    if (!TREE_CONSTANT ((*builder)[i]))\n       {\n+\ttree type = builder->type ();\n+\tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type);\n \tvec<constructor_elt, va_gc> *v;\n \tvec_alloc (v, nelts);\n \tfor (i = 0; i < nelts; ++i)\n-\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[i]);\n+\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, builder->elt (i));\n \n \ttree res;\n \tif (gimple_in_ssa_p (cfun))\n@@ -7206,7 +7213,7 @@ gimple_build_vector (gimple_seq *seq, location_t loc, tree type,\n \tgimple_seq_add_stmt_without_update (seq, stmt);\n \treturn res;\n       }\n-  return build_vector (type, elts);\n+  return builder->build ();\n }\n \n /* Return true if the result of assignment STMT is known to be non-negative."}, {"sha": "83babfa4fd531f7401511fd7a017d86366821109", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -135,11 +135,13 @@ gimple_build_vector_from_val (gimple_seq *seq, tree type, tree op)\n   return gimple_build_vector_from_val (seq, UNKNOWN_LOCATION, type, op);\n }\n \n-extern tree gimple_build_vector (gimple_seq *, location_t, tree, vec<tree>);\n+class tree_vector_builder;\n+extern tree gimple_build_vector (gimple_seq *, location_t,\n+\t\t\t\t tree_vector_builder *);\n inline tree\n-gimple_build_vector (gimple_seq *seq, tree type, vec<tree> elts)\n+gimple_build_vector (gimple_seq *seq, tree_vector_builder *builder)\n {\n-  return gimple_build_vector (seq, UNKNOWN_LOCATION, type, elts);\n+  return gimple_build_vector (seq, UNKNOWN_LOCATION, builder);\n }\n \n extern bool gimple_stmt_nonnegative_warnv_p (gimple *, bool *, int = 0);"}, {"sha": "1759655fd0728bdb6faf99b9be3a362df260da32", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -3978,19 +3978,16 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (init_val);\n   tree vectype = get_vectype_for_scalar_type (scalar_type);\n-  int nunits;\n   enum tree_code code = gimple_assign_rhs_code (stmt);\n   tree def_for_init;\n   tree init_def;\n-  int i;\n   bool nested_in_vect_loop = false;\n   REAL_VALUE_TYPE real_init_val = dconst0;\n   int int_init_val = 0;\n   gimple *def_stmt = NULL;\n   gimple_seq stmts = NULL;\n \n   gcc_assert (vectype);\n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   gcc_assert (POINTER_TYPE_P (scalar_type) || INTEGRAL_TYPE_P (scalar_type)\n \t      || SCALAR_FLOAT_TYPE_P (scalar_type));\n@@ -4063,11 +4060,10 @@ get_initial_def_for_reduction (gimple *stmt, tree init_val,\n \telse\n \t  {\n \t    /* Option2: the first element is INIT_VAL.  */\n-\t    auto_vec<tree, 32> elts (nunits);\n+\t    tree_vector_builder elts (vectype, 1, 2);\n \t    elts.quick_push (init_val);\n-\t    for (i = 1; i < nunits; ++i)\n-\t      elts.quick_push (def_for_init);\n-\t    init_def = gimple_build_vector (&stmts, vectype, elts);\n+\t    elts.quick_push (def_for_init);\n+\t    init_def = gimple_build_vector (&stmts, &elts);\n \t  }\n       }\n       break;\n@@ -4192,7 +4188,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n   number_of_copies = nunits * number_of_vectors / group_size;\n \n   number_of_places_left_in_vector = nunits;\n-  auto_vec<tree, 32> elts (nunits);\n+  tree_vector_builder elts (vector_type, nunits, 1);\n   elts.quick_grow (nunits);\n   for (j = 0; j < number_of_copies; j++)\n     {\n@@ -4215,12 +4211,14 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n           if (number_of_places_left_in_vector == 0)\n             {\n \t      gimple_seq ctor_seq = NULL;\n-\t      tree init = gimple_build_vector (&ctor_seq, vector_type, elts);\n+\t      tree init = gimple_build_vector (&ctor_seq, &elts);\n \t      if (ctor_seq != NULL)\n \t\tgsi_insert_seq_on_edge_immediate (pe, ctor_seq);\n \t      voprnds.quick_push (init);\n \n               number_of_places_left_in_vector = nunits;\n+\t      elts.new_vector (vector_type, nunits, 1);\n+\t      elts.quick_grow (nunits);\n             }\n         }\n     }\n@@ -6708,7 +6706,7 @@ vectorizable_induction (gimple *phi,\n       unsigned ivn;\n       for (ivn = 0; ivn < nivs; ++ivn)\n \t{\n-\t  auto_vec<tree, 32> elts (nunits);\n+\t  tree_vector_builder elts (vectype, nunits, 1);\n \t  stmts = NULL;\n \t  for (unsigned eltn = 0; eltn < nunits; ++eltn)\n \t    {\n@@ -6718,7 +6716,7 @@ vectorizable_induction (gimple *phi,\n \t\t\t\t    elt, step_expr);\n \t      elts.quick_push (elt);\n \t    }\n-\t  vec_init = gimple_build_vector (&stmts, vectype, elts);\n+\t  vec_init = gimple_build_vector (&stmts, &elts);\n \t  if (stmts)\n \t    {\n \t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n@@ -6825,7 +6823,7 @@ vectorizable_induction (gimple *phi,\n       stmts = NULL;\n       new_name = gimple_convert (&stmts, TREE_TYPE (vectype), init_expr);\n \n-      auto_vec<tree, 32> elts (nunits);\n+      tree_vector_builder elts (vectype, nunits, 1);\n       elts.quick_push (new_name);\n       for (i = 1; i < nunits; i++)\n \t{\n@@ -6836,7 +6834,7 @@ vectorizable_induction (gimple *phi,\n \t}\n       /* Create a vector from [new_name_0, new_name_1, ...,\n \t new_name_nunits-1]  */\n-      vec_init = gimple_build_vector (&stmts, vectype, elts);\n+      vec_init = gimple_build_vector (&stmts, &elts);\n       if (stmts)\n \t{\n \t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);"}, {"sha": "954dbcd721515ddc459ed931f59db95df1076e9d", "filename": "gcc/tree-vector-builder.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -96,6 +96,16 @@ tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n   return true;\n }\n \n+/* Return a vector element with the value BASE + FACTOR * STEP.  */\n+\n+tree\n+tree_vector_builder::apply_step (tree base, unsigned int factor,\n+\t\t\t\t const wide_int &step) const\n+{\n+  return wide_int_to_tree (TREE_TYPE (base),\n+\t\t\t   wi::to_wide (base) + factor * step);\n+}\n+\n /* Return a VECTOR_CST for the current constant.  */\n \n tree"}, {"sha": "1038be77c151392a9d3dd6292502ed2d680976e4", "filename": "gcc/tree-vector-builder.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Ftree-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Ftree-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.h?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -45,6 +45,7 @@ class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n   bool allow_steps_p () const;\n   bool integral_p (const_tree) const;\n   wide_int step (const_tree, const_tree) const;\n+  tree apply_step (tree, unsigned int, const wide_int &) const;\n   bool can_elide_p (const_tree) const;\n   void note_representative (tree *, tree);\n "}, {"sha": "0edd6f5c0927ba091c240ffb631ffc112c54974c", "filename": "gcc/vector-builder.h", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Fvector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe73c3d32b68809628eaa3266bf98cb7352851c/gcc%2Fvector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvector-builder.h?ref=abe73c3d32b68809628eaa3266bf98cb7352851c", "patch": "@@ -68,6 +68,10 @@ along with GCC; see the file COPYING3.  If not see\n \t  given integral_p (ELT1) && integral_p (ELT2).  There is no fixed\n \t  choice of StepType.\n \n+      T apply_step (T base, unsigned int factor, StepType step) const;\n+\n+\t  Return a vector element with the value BASE + FACTOR * STEP.\n+\n       bool can_elide_p (T elt) const;\n \n \t  Return true if we can drop element ELT, even if the retained\n@@ -91,6 +95,7 @@ class vector_builder : public auto_vec<T, 32>\n   unsigned int nelts_per_pattern () const { return m_nelts_per_pattern; }\n   unsigned int encoded_nelts () const;\n   bool encoded_full_vector_p () const;\n+  T elt (unsigned int) const;\n \n   void finalize ();\n \n@@ -163,6 +168,38 @@ vector_builder<T, Derived>::new_vector (unsigned int full_nelts,\n   this->truncate (0);\n }\n \n+/* Return the value of vector element I, which might or might not be\n+   encoded explicitly.  */\n+\n+template<typename T, typename Derived>\n+T\n+vector_builder<T, Derived>::elt (unsigned int i) const\n+{\n+  /* This only makes sense if the encoding has been fully populated.  */\n+  gcc_checking_assert (encoded_nelts () <= this->length ());\n+\n+  /* First handle elements that are already present in the underlying\n+     vector, regardless of whether they're part of the encoding or not.  */\n+  if (i < this->length ())\n+    return (*this)[i];\n+\n+  /* Identify the pattern that contains element I and work out the index of\n+     the last encoded element for that pattern.  */\n+  unsigned int pattern = i % m_npatterns;\n+  unsigned int count = i / m_npatterns;\n+  unsigned int final_i = encoded_nelts () - m_npatterns + pattern;\n+  T final = (*this)[final_i];\n+\n+  /* If there are no steps, the final encoded value is the right one.  */\n+  if (m_nelts_per_pattern <= 2)\n+    return final;\n+\n+  /* Otherwise work out the value from the last two encoded elements.  */\n+  T prev = (*this)[final_i - m_npatterns];\n+  return derived ()->apply_step (final, count - 2,\n+\t\t\t\t derived ()->step (prev, final));\n+}\n+\n /* Change the encoding to NPATTERNS patterns of NELTS_PER_PATTERN each,\n    but without changing the underlying vector.  */\n "}]}