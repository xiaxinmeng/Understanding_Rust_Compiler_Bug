{"sha": "174d7275dbcd1a3c00030f948fca4b83a5893cdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0ZDcyNzVkYmNkMWEzYzAwMDMwZjk0OGZjYTRiODNhNTg5M2NkZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-06-04T20:19:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-06-04T20:19:46Z"}, "message": "tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Do not check aux; dump reasons of decisions.\n\n\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Do not check\n\taux; dump reasons of decisions.\n\t(should_duplicate_loop_header_p): Likewise.\n\t(do_while_loop_p): Likewise.\n\t(ch_base::copy_headers): Dump asi num insns duplicated.\n\nFrom-SVN: r237092", "tree": {"sha": "500d9c446a2ef50fe2a4faf97b3e99dfcae87c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500d9c446a2ef50fe2a4faf97b3e99dfcae87c45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174d7275dbcd1a3c00030f948fca4b83a5893cdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174d7275dbcd1a3c00030f948fca4b83a5893cdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174d7275dbcd1a3c00030f948fca4b83a5893cdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174d7275dbcd1a3c00030f948fca4b83a5893cdf/comments", "author": null, "committer": null, "parents": [{"sha": "1927a96372b003fe6217c64241bb69d838a67dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1927a96372b003fe6217c64241bb69d838a67dc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1927a96372b003fe6217c64241bb69d838a67dc8"}], "stats": {"total": 99, "additions": 83, "deletions": 16}, "files": [{"sha": "7df6c67c761e2c04baea08808f760868ab3ffd08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174d7275dbcd1a3c00030f948fca4b83a5893cdf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174d7275dbcd1a3c00030f948fca4b83a5893cdf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=174d7275dbcd1a3c00030f948fca4b83a5893cdf", "patch": "@@ -1,3 +1,11 @@\n+2016-06-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Do not check\n+\taux; dump reasons of decisions.\n+\t(should_duplicate_loop_header_p): Likewise.\n+\t(do_while_loop_p): Likewise.\n+\t(ch_base::copy_headers): Dump asi num insns duplicated.\n+\n 2016-06-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/71405"}, {"sha": "3af09ece39eb747e4517a8b5e7bf31969c53a710", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 75, "deletions": 16, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174d7275dbcd1a3c00030f948fca4b83a5893cdf/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174d7275dbcd1a3c00030f948fca4b83a5893cdf/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=174d7275dbcd1a3c00030f948fca4b83a5893cdf", "patch": "@@ -50,33 +50,61 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n   gimple_stmt_iterator bsi;\n   gimple *last;\n \n-  /* Do not copy one block more than once (we do not really want to do\n-     loop peeling here).  */\n-  if (header->aux)\n-    return false;\n+  gcc_assert (!header->aux);\n \n   /* Loop header copying usually increases size of the code.  This used not to\n      be true, since quite often it is possible to verify that the condition is\n      satisfied in the first iteration and therefore to eliminate it.  Jump\n      threading handles these cases now.  */\n   if (optimize_loop_for_size_p (loop))\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Not duplicating bb %i: optimizing for size.\\n\",\n+\t\t header->index);\n+      return false;\n+    }\n \n   gcc_assert (EDGE_COUNT (header->succs) > 0);\n   if (single_succ_p (header))\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Not duplicating bb %i: it is single succ.\\n\",\n+\t\t header->index);\n+      return false;\n+    }\n+\n   if (flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 0)->dest)\n       && flow_bb_inside_loop_p (loop, EDGE_SUCC (header, 1)->dest))\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Not duplicating bb %i: both sucessors are in loop.\\n\",\n+\t\t loop->num);\n+      return false;\n+    }\n \n   /* If this is not the original loop header, we want it to have just\n      one predecessor in order to match the && pattern.  */\n   if (header != loop->header && !single_pred_p (header))\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Not duplicating bb %i: it has mutiple predecestors.\\n\",\n+\t\t header->index);\n+      return false;\n+    }\n \n   last = last_stmt (header);\n   if (gimple_code (last) != GIMPLE_COND)\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  Not duplicating bb %i: it does not end by conditional.\\n\",\n+\t\t header->index);\n+      return false;\n+    }\n \n   /* Approximately copy the conditions that used to be used in jump.c --\n      at most 20 insns and no calls.  */\n@@ -91,13 +119,26 @@ should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n \tcontinue;\n \n       if (is_gimple_call (last))\n-\treturn false;\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Not duplicating bb %i: it contains call.\\n\",\n+\t\t     header->index);\n+\t  return false;\n+\t}\n \n       *limit -= estimate_num_insns (last, &eni_size_weights);\n       if (*limit < 0)\n-\treturn false;\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"  Not duplicating bb %i contains too many insns.\\n\",\n+\t\t     header->index);\n+\t  return false;\n+\t}\n     }\n-\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"    Will duplicate bb %i\\n\", header->index); \n   return true;\n }\n \n@@ -111,13 +152,27 @@ do_while_loop_p (struct loop *loop)\n   /* If the latch of the loop is not empty, it is not a do-while loop.  */\n   if (stmt\n       && gimple_code (stmt) != GIMPLE_LABEL)\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Loop %i is not do-while loop: latch is not empty.\\n\",\n+\t\t loop->num);\n+      return false;\n+    }\n \n   /* If the header contains just a condition, it is not a do-while loop.  */\n   stmt = last_and_only_stmt (loop->header);\n   if (stmt\n       && gimple_code (stmt) == GIMPLE_COND)\n-    return false;\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Loop %i is not do-while loop: \"\n+\t\t \"header contains just condition.\\n\", loop->num);\n+      return false;\n+    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Loop %i is do-while loop\\n\", loop->num);\n \n   return true;\n }\n@@ -236,6 +291,9 @@ ch_base::copy_headers (function *fun)\n     {\n       /* Copy at most 20 insns.  */\n       int limit = 20;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Analyzing loop %i\\n\", loop->num);\n \n       header = loop->header;\n \n@@ -272,8 +330,9 @@ ch_base::copy_headers (function *fun)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"Duplicating header of the loop %d up to edge %d->%d.\\n\",\n-\t\t loop->num, exit->src->index, exit->dest->index);\n+\t\t \"Duplicating header of the loop %d up to edge %d->%d,\"\n+\t\t \" %i insns.\\n\",\n+\t\t loop->num, exit->src->index, exit->dest->index, 20 - limit);\n \n       /* Ensure that the header will have just the latch as a predecessor\n \t inside the loop.  */"}]}