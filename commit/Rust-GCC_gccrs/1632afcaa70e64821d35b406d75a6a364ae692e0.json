{"sha": "1632afcaa70e64821d35b406d75a6a364ae692e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTYzMmFmY2FhNzBlNjQ4MjFkMzViNDA2ZDc1YTZhMzY0YWU2OTJlMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T05:48:38Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-03-31T05:48:38Z"}, "message": "(operand_subword): Use REAL_VALUE_TO_TARGET_SINGLE to convert to target float.\n\nIf REAL_ARITHMETIC is defined, let real.c handle incompatible host\nand target floating point bit patterns.\n(init_emit_once): Add machine_mode argument to REAL_VALUE_ATOF.\n\nFrom-SVN: r3938", "tree": {"sha": "999380b88c6b4a995326d7dcfadb138649780e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/999380b88c6b4a995326d7dcfadb138649780e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1632afcaa70e64821d35b406d75a6a364ae692e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1632afcaa70e64821d35b406d75a6a364ae692e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1632afcaa70e64821d35b406d75a6a364ae692e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1632afcaa70e64821d35b406d75a6a364ae692e0/comments", "author": null, "committer": null, "parents": [{"sha": "4b438c9e617a7e48e49c10e4522ea7fddb1dfbab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b438c9e617a7e48e49c10e4522ea7fddb1dfbab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b438c9e617a7e48e49c10e4522ea7fddb1dfbab"}], "stats": {"total": 60, "additions": 45, "deletions": 15}, "files": [{"sha": "5f6ce1696fc35a1ccfef21c62b91924a2481fbbb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 45, "deletions": 15, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1632afcaa70e64821d35b406d75a6a364ae692e0/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1632afcaa70e64821d35b406d75a6a364ae692e0/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=1632afcaa70e64821d35b406d75a6a364ae692e0", "patch": "@@ -212,7 +212,7 @@ void init_emit ();\n **\tspecial machine mode associated with the rtx (if any) is specified\n **\tin <mode>.\n **\n-**\t    gen_rtx() can be invoked in a way which resembles the lisp-like\n+**\t    gen_rtx can be invoked in a way which resembles the lisp-like\n **\trtx it will generate.   For example, the following rtx structure:\n **\n **\t      (plus:QI (mem:QI (reg:SI 1))\n@@ -330,7 +330,7 @@ gen_rtx (va_alist)\n \t      break;\n \n \t    default:\n-\t      abort();\n+\t      abort ();\n \t    }\n \t}\n     }\n@@ -746,7 +746,7 @@ gen_highpart (mode, x)\n       && GET_MODE_SIZE (mode) != GET_MODE_UNIT_SIZE (GET_MODE (x)))\n     abort ();\n   if (GET_CODE (x) == CONST_DOUBLE\n-#if !(TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT || defined(REAL_IS_NOT_DOUBLE))\n+#if !(TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT || defined (REAL_IS_NOT_DOUBLE))\n       && GET_MODE_CLASS (GET_MODE (x)) != MODE_FLOAT\n #endif\n       )\n@@ -922,6 +922,20 @@ operand_subword (op, i, validate_address, mode)\n   /* The only remaining cases are when OP is a constant.  If the host and\n      target floating formats are the same, handling two-word floating\n      constants are easy.  */\n+#ifdef REAL_ARITHMETIC\n+  if ((HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n+      && GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n+      && GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      HOST_WIDE_INT k[2];\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_DOUBLE (rv, k);\n+      return GEN_INT (k[i]);\n+    }\n+#else /* no REAL_ARITHMETIC */\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n \t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n        || flag_pretend_float)\n@@ -941,10 +955,25 @@ operand_subword (op, i, validate_address, mode)\n \t\t      ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op));\n #endif\n     }\n+#endif /* no REAL_ARITHMETIC */\n \n   /* Single word float is a little harder, since single- and double-word\n      values often do not have the same high-order bits.  We have already\n      verified that we want the only defined word of the single-word value.  */\n+#ifdef REAL_ARITHMETIC\n+  if ((HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n+      && GET_MODE_CLASS (mode) == MODE_FLOAT\n+      && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n+      && GET_CODE (op) == CONST_DOUBLE)\n+    {\n+      HOST_WIDE_INT l;\n+      REAL_VALUE_TYPE rv;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n+      return GEN_INT (l);\n+    }\n+#else\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n \t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n        || flag_pretend_float)\n@@ -960,6 +989,7 @@ operand_subword (op, i, validate_address, mode)\n       u.f = d;\n       return GEN_INT (u.i);\n     }\n+#endif /* no REAL_ARITHMETIC */\n       \n   /* The only remaining cases that we can handle are integers.\n      Convert to proper endianness now since these cases need it.\n@@ -1840,13 +1870,13 @@ make_insn_raw (pattern)\n {\n   register rtx insn;\n \n-  insn = rtx_alloc(INSN);\n-  INSN_UID(insn) = cur_insn_uid++;\n+  insn = rtx_alloc (INSN);\n+  INSN_UID (insn) = cur_insn_uid++;\n \n   PATTERN (insn) = pattern;\n   INSN_CODE (insn) = -1;\n-  LOG_LINKS(insn) = NULL;\n-  REG_NOTES(insn) = NULL;\n+  LOG_LINKS (insn) = NULL;\n+  REG_NOTES (insn) = NULL;\n \n   return insn;\n }\n@@ -1860,13 +1890,13 @@ make_jump_insn_raw (pattern)\n   register rtx insn;\n \n   insn = rtx_alloc (JUMP_INSN);\n-  INSN_UID(insn) = cur_insn_uid++;\n+  INSN_UID (insn) = cur_insn_uid++;\n \n   PATTERN (insn) = pattern;\n   INSN_CODE (insn) = -1;\n-  LOG_LINKS(insn) = NULL;\n-  REG_NOTES(insn) = NULL;\n-  JUMP_LABEL(insn) = NULL;\n+  LOG_LINKS (insn) = NULL;\n+  REG_NOTES (insn) = NULL;\n+  JUMP_LABEL (insn) = NULL;\n \n   return insn;\n }\n@@ -2954,10 +2984,10 @@ init_emit_once (line_numbers)\n   /* This will usually be one of the above constants, but may be a new rtx.  */\n   const_true_rtx = GEN_INT (STORE_FLAG_VALUE);\n \n-  dconst0 = REAL_VALUE_ATOF (\"0\");\n-  dconst1 = REAL_VALUE_ATOF (\"1\");\n-  dconst2 = REAL_VALUE_ATOF (\"2\");\n-  dconstm1 = REAL_VALUE_ATOF (\"-1\");\n+  dconst0 = REAL_VALUE_ATOF (\"0\", DFmode);\n+  dconst1 = REAL_VALUE_ATOF (\"1\", DFmode);\n+  dconst2 = REAL_VALUE_ATOF (\"2\", DFmode);\n+  dconstm1 = REAL_VALUE_ATOF (\"-1\", DFmode);\n \n   for (i = 0; i <= 2; i++)\n     {"}]}