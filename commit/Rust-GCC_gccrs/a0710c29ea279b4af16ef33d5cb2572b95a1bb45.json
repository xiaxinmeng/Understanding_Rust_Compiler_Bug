{"sha": "a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA3MTBjMjllYTI3OWI0YWYxNmVmMzNkNWNiMjU3MmI5NWExYmI0NQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2008-01-18T23:46:04Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2008-01-18T23:46:04Z"}, "message": "re PR fortran/32616 (\"Too short actual argument\" for array element storage sequence)\n\n2008-01-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/32616\n        * interface.c (get_expr_storage_size): Return storage size\n        for array element designators.\n        (compare_actual_formal): Reject unequal string sizes for\n        assumed-shape dummy arguments. And fix error message for\n        array-sections with vector subscripts.\n\n2008-01-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/32616\n        * gfortran.dg/argument_checking_15.f90: New.\n        * gfortran.dg/argument_checking_5.f90: Change TODO into\n        dg-warning.\n\nFrom-SVN: r131643", "tree": {"sha": "c8ff6232e4474d365d8c9d652d5d680bb174e0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8ff6232e4474d365d8c9d652d5d680bb174e0b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7939be80229a0d2867b50d5240186c0a1dc84aac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7939be80229a0d2867b50d5240186c0a1dc84aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7939be80229a0d2867b50d5240186c0a1dc84aac"}], "stats": {"total": 175, "additions": 146, "deletions": 29}, "files": [{"sha": "736c67f131b4c0c83f84d0c25dd4057bf7951326", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "patch": "@@ -1,3 +1,12 @@\n+2008-01-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/32616\n+\t* interface.c (get_expr_storage_size): Return storage size\n+\tfor array element designators.\n+\t(compare_actual_formal): Reject unequal string sizes for\n+\tassumed-shape dummy arguments. And fix error message for\n+\tarray-sections with vector subscripts.\n+\n 2008-01-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/34556"}, {"sha": "8b1f5db21dc9acad6fccdd314c1add9bdf6b0aef", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 71, "deletions": 27, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "patch": "@@ -1639,6 +1639,7 @@ get_expr_storage_size (gfc_expr *e)\n   int i;\n   long int strlen, elements;\n   long int substrlen = 0;\n+  bool is_str_storage = false;\n   gfc_ref *ref;\n \n   if (e == NULL)\n@@ -1676,10 +1677,17 @@ get_expr_storage_size (gfc_expr *e)\n       if (ref->type == REF_SUBSTRING && ref->u.ss.start\n \t  && ref->u.ss.start->expr_type == EXPR_CONSTANT)\n \t{\n-\t  int len = strlen;\n-\t  if (ref->u.ss.end && ref->u.ss.end->expr_type == EXPR_CONSTANT)\n-\t    len = mpz_get_ui (ref->u.ss.end->value.integer);\n-\t  substrlen = len - mpz_get_ui (ref->u.ss.start->value.integer) + 1;\n+\t  if (is_str_storage)\n+\t    {\n+\t      /* The string length is the substring length.\n+\t\t Set now to full string length.  */\n+\t      if (ref->u.ss.length == NULL\n+\t\t  || ref->u.ss.length->length->expr_type != EXPR_CONSTANT)\n+\t\treturn 0;\n+\n+\t      strlen = mpz_get_ui (ref->u.ss.length->length->value.integer);\n+\t    }\n+\t  substrlen = strlen - mpz_get_ui (ref->u.ss.start->value.integer) + 1;\n \t  continue;\n \t}\n \n@@ -1741,21 +1749,46 @@ get_expr_storage_size (gfc_expr *e)\n \t      return 0;\n \t  }\n       else if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT\n-\t       && e->expr_type == EXPR_VARIABLE\n-\t       && (e->symtree->n.sym->as->type == AS_ASSUMED_SHAPE\n-                  || e->symtree->n.sym->attr.pointer))\n-\telements = 1;\n+\t       && e->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  if (e->symtree->n.sym->as->type == AS_ASSUMED_SHAPE\n+\t      || e->symtree->n.sym->attr.pointer)\n+\t    {\n+\t      elements = 1;\n+\t      continue;\n+\t    }\n+\n+\t  /* Determine the number of remaining elements in the element\n+\t     sequence for array element designators.  */\n+\t  is_str_storage = true;\n+\t  for (i = ref->u.ar.dimen - 1; i >= 0; i--)\n+\t    {\n+\t      if (ref->u.ar.start[i] == NULL\n+\t\t  || ref->u.ar.start[i]->expr_type != EXPR_CONSTANT\n+\t\t  || ref->u.ar.as->upper[i] == NULL\n+\t\t  || ref->u.ar.as->lower[i] == NULL\n+\t\t  || ref->u.ar.as->upper[i]->expr_type != EXPR_CONSTANT\n+\t\t  || ref->u.ar.as->lower[i]->expr_type != EXPR_CONSTANT)\n+\t\treturn 0;\n+\n+\t      elements\n+\t\t   = elements\n+\t\t     * (mpz_get_si (ref->u.ar.as->upper[i]->value.integer)\n+\t\t\t- mpz_get_si (ref->u.ar.as->lower[i]->value.integer)\n+\t\t\t+ 1L)\n+\t\t     - (mpz_get_si (ref->u.ar.start[i]->value.integer)\n+\t\t\t- mpz_get_si (ref->u.ar.as->lower[i]->value.integer));\n+\t    }\n+        }\n       else\n-        /* TODO: Determine the number of remaining elements in the element\n-           sequence for array element designators. See PR 32616.\n-           See also get_array_index in data.c.  */\n \treturn 0;\n     }\n \n   if (substrlen)\n-    return elements*substrlen;\n-\n-  return elements*strlen;\n+    return (is_str_storage) ? substrlen + (elements-1)*strlen\n+\t\t\t    : elements*strlen;\n+  else\n+    return elements*strlen;\n }\n \n \n@@ -1880,23 +1913,34 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t\t      is_elemental, where))\n \treturn 0;\n \n+      /* Special case for character arguments.  For allocatable, pointer\n+\t and assumed-shape dummies, the string length needs to match\n+\t exactly.  */\n       if (a->expr->ts.type == BT_CHARACTER\n \t   && a->expr->ts.cl && a->expr->ts.cl->length\n \t   && a->expr->ts.cl->length->expr_type == EXPR_CONSTANT\n \t   && f->sym->ts.cl && f->sym->ts.cl && f->sym->ts.cl->length\n-\t   && f->sym->ts.cl->length->expr_type == EXPR_CONSTANT)\n+\t   && f->sym->ts.cl->length->expr_type == EXPR_CONSTANT\n+\t   && (f->sym->attr.pointer || f->sym->attr.allocatable\n+\t       || (f->sym->as && f->sym->as->type == AS_ASSUMED_SHAPE))\n+\t   && (mpz_cmp (a->expr->ts.cl->length->value.integer,\n+\t\t\tf->sym->ts.cl->length->value.integer) != 0))\n \t {\n-\t   if ((f->sym->attr.pointer || f->sym->attr.allocatable)\n-\t       && (mpz_cmp (a->expr->ts.cl->length->value.integer,\n-\t\t\t   f->sym->ts.cl->length->value.integer) != 0))\n-\t     {\n-\t\tif (where)\n-\t\t  gfc_warning (\"Character length mismatch between actual \"\n-\t\t\t       \"argument and pointer or allocatable dummy \"\n-\t\t\t       \"argument '%s' at %L\",\n-\t\t\t       f->sym->name, &a->expr->where);\n-\t\treturn 0;\n-\t     }\n+\t   if (where && (f->sym->attr.pointer || f->sym->attr.allocatable))\n+\t     gfc_warning (\"Character length mismatch (%ld/%ld) between actual \"\n+\t\t\t  \"argument and pointer or allocatable dummy argument \"\n+\t\t\t  \"'%s' at %L\",\n+\t\t\t  mpz_get_si (a->expr->ts.cl->length->value.integer),\n+\t\t\t  mpz_get_si (f->sym->ts.cl->length->value.integer),\n+\t\t\t  f->sym->name, &a->expr->where);\n+\t   else if (where)\n+\t     gfc_warning (\"Character length mismatch (%ld/%ld) between actual \"\n+\t\t\t  \"argument and assumed-shape dummy argument '%s' \"\n+\t\t\t  \"at %L\",\n+\t\t\t  mpz_get_si (a->expr->ts.cl->length->value.integer),\n+\t\t\t  mpz_get_si (f->sym->ts.cl->length->value.integer),\n+\t\t\t  f->sym->name, &a->expr->where);\n+\t   return 0;\n \t }\n \n       actual_size = get_expr_storage_size (a->expr);\n@@ -2001,7 +2045,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Array-section actual argument with vector subscripts \"\n-\t\t       \"at %L is incompatible with INTENT(IN), INTENT(INOUT) \"\n+\t\t       \"at %L is incompatible with INTENT(OUT), INTENT(INOUT) \"\n \t\t       \"or VOLATILE attribute of the dummy argument '%s'\",\n \t\t       &a->expr->where, f->sym->name);\n \t  return 0;"}, {"sha": "b25f7f5c38a0f64aeaf895f095d552e624d7bec3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "patch": "@@ -1,3 +1,10 @@\n+2008-01-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/32616\n+\t* gfortran.dg/argument_checking_15.f90: New.\n+\t* gfortran.dg/argument_checking_5.f90: Change TODO into\n+\tdg-warning.\n+\n 2008-01-18  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/enum_4.f90: Replace dg-excess-errors by dg-error."}, {"sha": "90046bb9dac63c4dd6bad0f72c6ac0060d32f472", "filename": "gcc/testsuite/gfortran.dg/argument_checking_15.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_15.f90?ref=a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+!\n+! PR fortran/32616\n+!\n+! Check for to few elements of the actual argument\n+! and reject mismatching string lengths for assumed-shape dummies\n+!\n+implicit none\n+external test\n+integer :: i(10)\n+integer :: j(2,2)\n+character(len=4) :: str(2)\n+character(len=4) :: str2(2,2)\n+\n+call test()\n+\n+call foo(i(8)) ! { dg-warning \"too few elements for dummy argument 'a' .3/4.\" }\n+call foo(j(1,1))\n+call foo(j(2,1)) ! { dg-warning \"too few elements for dummy argument 'a' .3/4.\" }\n+call foo(j(1,2)) ! { dg-warning \"too few elements for dummy argument 'a' .2/4.\" }\n+\n+str = 'FORT'\n+str2 = 'fort'\n+call bar(str(:)(1:2)) ! { dg-warning \"too few elements for dummy argument 'c' .4/6.\" }\n+call bar(str(1:2)(1:1)) ! { dg-warning \"too few elements for dummy argument 'c' .2/6.\" }\n+call bar(str(2)) ! { dg-warning \"too few elements for dummy argument 'c' .4/6.\" }\n+call bar(str(1)(2:1)) ! OK\n+call bar(str2(2,1)(4:1)) ! OK\n+call bar(str2(1,2)(3:4)) ! OK\n+call bar(str2(1,2)(4:4)) ! { dg-warning \"too few elements for dummy argument 'c' .5/6.\" }\n+contains\n+  subroutine foo(a)\n+    integer :: a(4)\n+  end subroutine foo\n+  subroutine bar(c)\n+    character(len=2) :: c(3)\n+!    print '(3a)', ':',c(1),':'\n+!    print '(3a)', ':',c(2),':'\n+!    print '(3a)', ':',c(3),':'\n+  end subroutine bar\n+end\n+\n+\n+subroutine test()\n+implicit none\n+character(len=5), pointer :: c\n+character(len=5) :: str(5)\n+call foo(c) ! { dg-error \"Character length mismatch\" }\n+call bar(str) ! { dg-error \"Character length mismatch\" }\n+contains\n+  subroutine foo(a)\n+    character(len=3), pointer :: a\n+  end subroutine\n+  subroutine bar(a)\n+    character(len=3) :: a(:)\n+  end subroutine bar\n+end subroutine test"}, {"sha": "3715b30cf464227d701185f0946f6d64b6cf8717", "filename": "gcc/testsuite/gfortran.dg/argument_checking_5.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0710c29ea279b4af16ef33d5cb2572b95a1bb45/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fargument_checking_5.f90?ref=a0710c29ea279b4af16ef33d5cb2572b95a1bb45", "patch": "@@ -19,7 +19,7 @@ end subroutine arr\n call foobar(b(1:5))\n call foobar(b(1:5:2)) ! { dg-warning \"contains too few elements\" }\n call foobar(b(2))\n-call foobar(b(3)) ! TODO: contains too few elements\n+call foobar(b(3)) ! { dg-warning \"Actual argument contains too few elements\" }\n call foobar(reshape(a(1:3),[2,1])) ! { dg-warning \"contains too few elements\" }\n call foobar(reshape(b(2:5),[2,2]))\n \n@@ -29,7 +29,7 @@ end subroutine arr\n call arr(b(1:5))\n call arr(b(1:5:2)) ! { dg-warning \"contains too few elements\" }\n call arr(b(2))\n-call arr(b(3)) ! TODO: contains too few elements\n+call arr(b(3)) ! { dg-warning \"contains too few elements\" }\n call arr(reshape(a(1:3),[2,1])) ! { dg-warning \"contains too few elements\" }\n call arr(reshape(b(2:5),[2,2]))\n end program test"}]}