{"sha": "e90c74f59870d39e36eb2f390ea0d9b2bea10693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwYzc0ZjU5ODcwZDM5ZTM2ZWIyZjM5MGVhMGQ5YjJiZWExMDY5Mw==", "commit": {"author": {"name": "Tony Reix", "email": "tony.reix@atos.net", "date": "2017-09-29T16:37:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-29T16:37:39Z"}, "message": "xcoff.c: Initial support for DWARF debug sections in XCOFF.\n\n\t* xcoff.c: Initial support for DWARF debug sections in XCOFF.\n\t(STYP_DWARF, SSUBTYP_DW*): Define.\n\t(enum dwarf_section): Define.\n\t(struct dwsect_info): Define.\n\t(xcoff_add): Look for DWARF sections, pass them to\n\tbacktrace_dwarf_add.\n\nFrom-SVN: r253297", "tree": {"sha": "51c4d405c1de120b374d331b4de00ea3f56390d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51c4d405c1de120b374d331b4de00ea3f56390d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e90c74f59870d39e36eb2f390ea0d9b2bea10693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90c74f59870d39e36eb2f390ea0d9b2bea10693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90c74f59870d39e36eb2f390ea0d9b2bea10693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90c74f59870d39e36eb2f390ea0d9b2bea10693/comments", "author": {"login": "trex58", "id": 5690106, "node_id": "MDQ6VXNlcjU2OTAxMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5690106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trex58", "html_url": "https://github.com/trex58", "followers_url": "https://api.github.com/users/trex58/followers", "following_url": "https://api.github.com/users/trex58/following{/other_user}", "gists_url": "https://api.github.com/users/trex58/gists{/gist_id}", "starred_url": "https://api.github.com/users/trex58/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trex58/subscriptions", "organizations_url": "https://api.github.com/users/trex58/orgs", "repos_url": "https://api.github.com/users/trex58/repos", "events_url": "https://api.github.com/users/trex58/events{/privacy}", "received_events_url": "https://api.github.com/users/trex58/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a815fe44575d05c1aa427a93c3632e64bf8242f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a815fe44575d05c1aa427a93c3632e64bf8242f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a815fe44575d05c1aa427a93c3632e64bf8242f8"}], "stats": {"total": 153, "additions": 142, "deletions": 11}, "files": [{"sha": "9597a687581cd7b37037039f5bc0f30b6386a9c6", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90c74f59870d39e36eb2f390ea0d9b2bea10693/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90c74f59870d39e36eb2f390ea0d9b2bea10693/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=e90c74f59870d39e36eb2f390ea0d9b2bea10693", "patch": "@@ -1,3 +1,12 @@\n+2017-09-29  Tony Reix  <tony.reix@atos.net>\n+\n+\t* xcoff.c: Initial support for DWARF debug sections in XCOFF.\n+\t(STYP_DWARF, SSUBTYP_DW*): Define.\n+\t(enum dwarf_section): Define.\n+\t(struct dwsect_info): Define.\n+\t(xcoff_add): Look for DWARF sections, pass them to\n+\tbacktrace_dwarf_add.\n+\n 2017-09-28  Ian Lance Taylor  <iant@golang.org>\n \n \tPR other/67165"}, {"sha": "f84bf268e6c053dc1603c81e09081f1d4d9e25ab", "filename": "libbacktrace/xcoff.c", "status": "modified", "additions": 133, "deletions": 11, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e90c74f59870d39e36eb2f390ea0d9b2bea10693/libbacktrace%2Fxcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e90c74f59870d39e36eb2f390ea0d9b2bea10693/libbacktrace%2Fxcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fxcoff.c?ref=e90c74f59870d39e36eb2f390ea0d9b2bea10693", "patch": "@@ -124,9 +124,16 @@ typedef struct {\n \n #endif /* BACKTRACE_XCOFF_SIZE != 32 */\n \n+#define STYP_DWARF\t0x10\t/* DWARF debugging section.  */\n #define STYP_TEXT\t0x20\t/* Executable text (code) section.  */\n #define STYP_OVRFLO\t0x8000\t/* Line-number field overflow section.  */\n \n+#define SSUBTYP_DWINFO\t0x10000\t/* DWARF info section.  */\n+#define SSUBTYP_DWLINE\t0x20000\t/* DWARF line-number section.  */\n+#define SSUBTYP_DWARNGE\t0x50000\t/* DWARF aranges section.  */\n+#define SSUBTYP_DWABREV\t0x60000\t/* DWARF abbreviation section.  */\n+#define SSUBTYP_DWSTR\t0x70000\t/* DWARF strings section.  */\n+\n /* XCOFF symbol.  */\n \n #define SYMNMLEN\t8\n@@ -367,6 +374,29 @@ struct xcoff_fileline_data\n   struct xcoff_line_vector vec;\n };\n \n+/* An index of DWARF sections we care about.  */\n+\n+enum dwarf_section\n+{\n+  DWSECT_INFO,\n+  DWSECT_LINE,\n+  DWSECT_ABBREV,\n+  DWSECT_RANGES,\n+  DWSECT_STR,\n+  DWSECT_MAX\n+};\n+\n+/* Information we gather for the DWARF sections we care about.  */\n+\n+struct dwsect_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+  /* Section contents, after read from file.  */\n+  const unsigned char *data;\n+};\n \n /* A dummy callback function used when we can't find any debug info.  */\n \n@@ -1056,19 +1086,24 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n   struct backtrace_view linenos_view;\n   struct backtrace_view syms_view;\n   struct backtrace_view str_view;\n+  struct backtrace_view dwarf_view;\n   b_xcoff_filhdr fhdr;\n   const b_xcoff_scnhdr *sects;\n   const b_xcoff_scnhdr *stext;\n   uint64_t lnnoptr;\n   uint32_t nlnno;\n   off_t str_off;\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct dwsect_info dwsect[DWSECT_MAX];\n   size_t sects_size;\n   size_t syms_size;\n   int32_t str_size;\n   int sects_view_valid;\n   int linenos_view_valid;\n   int syms_view_valid;\n   int str_view_valid;\n+  int dwarf_view_valid;\n   int magic_ok;\n   int i;\n \n@@ -1078,6 +1113,9 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n   linenos_view_valid = 0;\n   syms_view_valid = 0;\n   str_view_valid = 0;\n+  dwarf_view_valid = 0;\n+\n+  str_size = 0;\n \n   /* Map the XCOFF file header.  */\n   if (!backtrace_get_view (state, descriptor, offset, sizeof (b_xcoff_filhdr),\n@@ -1092,7 +1130,7 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n   if (!magic_ok)\n     {\n       if (exe)\n-        error_callback (data, \"executable file is not XCOFF\", 0);\n+\terror_callback (data, \"executable file is not XCOFF\", 0);\n       goto fail;\n     }\n \n@@ -1114,8 +1152,8 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n \n   /* FIXME: assumes only one .text section.  */\n   for (i = 0; i < fhdr.f_nscns; ++i)\n-      if ((sects[i].s_flags & 0xffff) == STYP_TEXT)\n-\t  break;\n+    if ((sects[i].s_flags & 0xffff) == STYP_TEXT)\n+      break;\n   if (i == fhdr.f_nscns)\n     goto fail;\n \n@@ -1134,12 +1172,12 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n       /* Find the matching .ovrflo section.  */\n       for (i = 0; i < fhdr.f_nscns; ++i)\n \t{\n-\t    if (((sects[i].s_flags & 0xffff) == STYP_OVRFLO)\n-\t\t&& sects[i].s_nlnno == sntext)\n-\t      {\n-\t\tnlnno = sects[i].s_vaddr;\n-\t\tbreak;\n-\t      }\n+\t  if (((sects[i].s_flags & 0xffff) == STYP_OVRFLO)\n+\t      && sects[i].s_nlnno == sntext)\n+\t    {\n+\t      nlnno = sects[i].s_vaddr;\n+\t      break;\n+\t    }\n \t}\n     }\n #endif\n@@ -1194,9 +1232,91 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n       xcoff_add_syminfo_data (state, sdata);\n     }\n \n-  /* Read the line number entries.  */\n+  /* Read all the DWARF sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  memset (dwsect, 0, sizeof dwsect);\n+  for (i = 0; i < fhdr.f_nscns; ++i)\n+    {\n+      off_t end;\n+      int idx;\n+\n+      if ((sects[i].s_flags & 0xffff) != STYP_DWARF\n+\t  || sects[i].s_size == 0)\n+\tcontinue;\n+      /* Map DWARF section to array index.  */\n+      switch (sects[i].s_flags & 0xffff0000)\n+\t{\n+\t  case SSUBTYP_DWINFO:\n+\t    idx = DWSECT_INFO;\n+\t    break;\n+\t  case SSUBTYP_DWLINE:\n+\t    idx = DWSECT_LINE;\n+\t    break;\n+\t  case SSUBTYP_DWABREV:\n+\t    idx = DWSECT_ABBREV;\n+\t    break;\n+\t  case SSUBTYP_DWARNGE:\n+\t    idx = DWSECT_RANGES;\n+\t    break;\n+\t  case SSUBTYP_DWSTR:\n+\t    idx = DWSECT_STR;\n+\t    break;\n+\t  default:\n+\t    continue;\n+\t}\n+      if (min_offset == 0 || (off_t) sects[i].s_scnptr < min_offset)\n+\tmin_offset = sects[i].s_scnptr;\n+      end = sects[i].s_scnptr + sects[i].s_size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+      dwsect[idx].offset = sects[i].s_scnptr;\n+      dwsect[idx].size = sects[i].s_size;\n+    }\n+  if (min_offset != 0 && max_offset != 0)\n+    {\n+      if (!backtrace_get_view (state, descriptor, offset + min_offset,\n+\t\t\t       max_offset - min_offset,\n+\t\t\t       error_callback, data, &dwarf_view))\n+\tgoto fail;\n+      dwarf_view_valid = 1;\n+\n+      for (i = 0; i < (int) DWSECT_MAX; ++i)\n+\t{\n+\t  if (dwsect[i].offset == 0)\n+\t    dwsect[i].data = NULL;\n+\t  else\n+\t    dwsect[i].data = ((const unsigned char *) dwarf_view.data\n+\t\t\t      + (dwsect[i].offset - min_offset));\n+\t}\n+\n+      if (!backtrace_dwarf_add (state, 0,\n+\t\t\t\tdwsect[DWSECT_INFO].data,\n+\t\t\t\tdwsect[DWSECT_INFO].size,\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\t\t\t\t/* XXX workaround for broken lineoff */\n+\t\t\t\tdwsect[DWSECT_LINE].data - 4,\n+#else\n+\t\t\t\t/* XXX workaround for broken lineoff */\n+\t\t\t\tdwsect[DWSECT_LINE].data - 12,\n+#endif\n+\t\t\t\tdwsect[DWSECT_LINE].size,\n+\t\t\t\tdwsect[DWSECT_ABBREV].data,\n+\t\t\t\tdwsect[DWSECT_ABBREV].size,\n+\t\t\t\tdwsect[DWSECT_RANGES].data,\n+\t\t\t\tdwsect[DWSECT_RANGES].size,\n+\t\t\t\tdwsect[DWSECT_STR].data,\n+\t\t\t\tdwsect[DWSECT_STR].size,\n+\t\t\t\t1, /* big endian */\n+\t\t\t\terror_callback, data, fileline_fn))\n+\tgoto fail;\n+    }\n+\n+  /* Read the XCOFF line number entries if DWARF sections not found.  */\n \n-  if (fhdr.f_symptr != 0 && lnnoptr != 0)\n+  if (!dwarf_view_valid && fhdr.f_symptr != 0 && lnnoptr != 0)\n     {\n       size_t linenos_size = (size_t) nlnno * LINESZ;\n \n@@ -1239,6 +1359,8 @@ xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n     backtrace_release_view (state, &syms_view, error_callback, data);\n   if (linenos_view_valid)\n     backtrace_release_view (state, &linenos_view, error_callback, data);\n+  if (dwarf_view_valid)\n+    backtrace_release_view (state, &dwarf_view, error_callback, data);\n   if (descriptor != -1 && offset == 0)\n     backtrace_close (descriptor, error_callback, data);\n   return 0;"}]}