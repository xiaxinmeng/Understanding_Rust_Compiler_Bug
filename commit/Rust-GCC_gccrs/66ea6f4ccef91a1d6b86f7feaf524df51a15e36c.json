{"sha": "66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlYTZmNGNjZWY5MWExZDZiODZmN2ZlYWY1MjRkZjUxYTE1ZTM2Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-05-12T03:25:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-05-12T03:25:38Z"}, "message": "re PR c/10675 (Compile time increases quadratically with struct size)\n\n        PR c/10675\n        * c-decl.c: Include hashtab.h.\n        (detect_field_duplicates): New.\n        (finish_struct): Use it.\n        * Makefile.in (c-decl.o): Update.\n        * c-parse.in (structsp_attr): Nreverse component_decl_list results.\n        (component_decl_list, component_decl_list2,\n        components, components_notype): Build list in reverse order.\n        (enumlist): Clarify docs.  Use TREE_CHAIN not chainon.\n        * tree.c (chainon): Special case op2 null as well.\n        Reorg for clarity.\n\nFrom-SVN: r66710", "tree": {"sha": "d64fee370dcba52f3ebdc46db60f749bc198bad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d64fee370dcba52f3ebdc46db60f749bc198bad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/comments", "author": null, "committer": null, "parents": [{"sha": "358997e28a2aada18905dc8824252583116ed7df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/358997e28a2aada18905dc8824252583116ed7df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/358997e28a2aada18905dc8824252583116ed7df"}], "stats": {"total": 180, "additions": 121, "deletions": 59}, "files": [{"sha": "b8965263c022cddbfcc13306f6c6b201903d4b84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "patch": "@@ -1,3 +1,18 @@\n+2003-05-11  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/10675\n+\t* c-decl.c: Include hashtab.h.\n+\t(detect_field_duplicates): New.\n+\t(finish_struct): Use it.\n+\t* Makefile.in (c-decl.o): Update.\n+\t* c-parse.in (structsp_attr): Nreverse component_decl_list results.\n+\t(component_decl_list, component_decl_list2,\n+\tcomponents, components_notype): Build list in reverse order.\n+\t(enumlist): Clarify docs.  Use TREE_CHAIN not chainon.\n+\n+\t* tree.c (chainon): Special case op2 null as well. \n+\tReorg for clarity.\n+\n 2003-05-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.md (logsf2, logdf2, logxf2, logdf2): New patterns"}, {"sha": "38aa848d069f5183f31b45653ad9ef56ce782815", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "patch": "@@ -1257,10 +1257,10 @@ $(parsedir)/c-parse.y: c-parse.in\n c-incpath.o: c-incpath.c c-incpath.h $(CONFIG_H) $(SYSTEM_H) $(CPPLIB_H) \\\n \t\tintl.h prefix.h coretypes.h $(TM_H) cppdefault.h\n \n-c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n-    $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h $(EXPR_H) \\\n-    debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h \\\n-    gt-c-decl.h cgraph.h\n+c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+    $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h \\\n+    $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \\\n+    c-pragma.h gt-c-decl.h cgraph.h $(HASHTAB_H)\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\"}, {"sha": "b27ca06c79dacc74b8f5c39a28f17d7b931a7379", "filename": "gcc/c-decl.c", "status": "modified", "additions": 59, "deletions": 25, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"c-common.h\"\n #include \"c-pragma.h\"\n #include \"cgraph.h\"\n+#include \"hashtab.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -4883,6 +4884,63 @@ grokfield (filename, line, declarator, declspecs, width)\n   return value;\n }\n \f\n+/* Generate an error for any duplicate field names in FIELDLIST.  Munge\n+   the list such that this does not present a problem later.  */\n+\n+static void\n+detect_field_duplicates (tree fieldlist)\n+{\n+  tree x, y;\n+  int timeout = 10;\n+\n+  /* First, see if there are more than \"a few\" fields.\n+     This is trivially true if there are zero or one fields.  */\n+  if (!fieldlist)\n+    return;\n+  x = TREE_CHAIN (fieldlist);\n+  if (!x)\n+    return;\n+  do {\n+    timeout--;\n+    x = TREE_CHAIN (x);\n+  } while (timeout > 0 && x);\n+\n+  /* If there were \"few\" fields, avoid the overhead of allocating\n+     a hash table.  Instead just do the nested traversal thing.  */\n+  if (timeout > 0)\n+    {\n+      for (x = TREE_CHAIN (fieldlist); x ; x = TREE_CHAIN (x))\n+\tif (DECL_NAME (x))\n+\t  {\n+\t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n+\t      if (DECL_NAME (y) == DECL_NAME (x))\n+\t\t{\n+\t\t  error_with_decl (x, \"duplicate member `%s'\");\n+\t\t  DECL_NAME (x) = NULL_TREE;\n+\t\t}\n+\t  }\n+    }\n+  else\n+    {\n+      htab_t htab = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n+      void **slot;\n+\n+      for (x = fieldlist; x ; x = TREE_CHAIN (x))\n+\tif ((y = DECL_NAME (x)) != 0)\n+\t  {\n+\t    slot = htab_find_slot (htab, y, INSERT);\n+\t    if (*slot)\n+\t      {\n+\t\terror_with_decl (x, \"duplicate member `%s'\");\n+\t\tDECL_NAME (x) = NULL_TREE;\n+\t      }\n+\t    *slot = y;\n+\t  }\n+\n+      htab_delete (htab);\n+    }\n+}\n+\n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n    ATTRIBUTES are attributes to be applied to the structure.  */\n@@ -5062,31 +5120,7 @@ finish_struct (t, fieldlist, attributes)\n \tsaw_named_field = 1;\n     }\n \n-  /* Delete all duplicate fields from the fieldlist */\n-  for (x = fieldlist; x && TREE_CHAIN (x);)\n-    /* Anonymous fields aren't duplicates.  */\n-    if (DECL_NAME (TREE_CHAIN (x)) == 0)\n-      x = TREE_CHAIN (x);\n-    else\n-      {\n-\ttree y = fieldlist;\n-\n-\twhile (1)\n-\t  {\n-\t    if (DECL_NAME (y) == DECL_NAME (TREE_CHAIN (x)))\n-\t      break;\n-\t    if (y == x)\n-\t      break;\n-\t    y = TREE_CHAIN (y);\n-\t  }\n-\tif (DECL_NAME (y) == DECL_NAME (TREE_CHAIN (x)))\n-\t  {\n-\t    error_with_decl (TREE_CHAIN (x), \"duplicate member `%s'\");\n-\t    TREE_CHAIN (x) = TREE_CHAIN (TREE_CHAIN (x));\n-\t  }\n-\telse\n-\t  x = TREE_CHAIN (x);\n-      }\n+  detect_field_duplicates (fieldlist);\n \n   /* Now we have the nearly final fieldlist.  Record it,\n      then lay out the structure or union (including the fields).  */"}, {"sha": "a9400b39d8fc667922fc2752aa9f5306cdddcbe8", "filename": "gcc/c-parse.in", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "patch": "@@ -1,4 +1,4 @@\n- /* YACC parser for C syntax and for Objective C.  -*-c-*-\n+/* YACC parser for C syntax and for Objective C.  -*-c-*-\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996,\n    1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n@@ -1759,18 +1759,20 @@ structsp_attr:\n \t\t  /* Start scope of tag before parsing components.  */\n \t\t}\n \t  component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n+\t\t{ $$ = finish_struct ($<ttype>4, nreverse ($5),\n+\t\t\t\t      chainon ($1, $7)); }\n \t| struct_head '{' component_decl_list '}' maybe_attribute\n \t\t{ $$ = finish_struct (start_struct (RECORD_TYPE, NULL_TREE),\n-\t\t\t\t      $3, chainon ($1, $5));\n+\t\t\t\t      nreverse ($3), chainon ($1, $5));\n \t\t}\n \t| union_head identifier '{'\n \t\t{ $$ = start_struct (UNION_TYPE, $2); }\n \t  component_decl_list '}' maybe_attribute\n-\t\t{ $$ = finish_struct ($<ttype>4, $5, chainon ($1, $7)); }\n+\t\t{ $$ = finish_struct ($<ttype>4, nreverse ($5),\n+\t\t\t\t      chainon ($1, $7)); }\n \t| union_head '{' component_decl_list '}' maybe_attribute\n \t\t{ $$ = finish_struct (start_struct (UNION_TYPE, NULL_TREE),\n-\t\t\t\t      $3, chainon ($1, $5));\n+\t\t\t\t      nreverse ($3), chainon ($1, $5));\n \t\t}\n \t| enum_head identifier '{'\n \t\t{ $$ = start_enum ($2); }\n@@ -1809,18 +1811,30 @@ maybecomma_warn:\n \t\t    pedwarn (\"comma at end of enumerator list\"); }\n \t;\n \n+/* We chain the components in reverse order.  They are put in forward\n+   order in structsp_attr.\n+\n+   Note that component_declarator returns single decls, so components\n+   and components_notype can use TREE_CHAIN directly, wheras components\n+   and components_notype return lists (of comma separated decls), so\n+   component_decl_list and component_decl_list2 must use chainon.\n+\n+   The theory behind all this is that there will be more semicolon\n+   separated fields than comma separated fields, and so we'll be\n+   minimizing the number of node traversals required by chainon.  */\n+\n component_decl_list:\n \t  component_decl_list2\n \t\t{ $$ = $1; }\n \t| component_decl_list2 component_decl\n-\t\t{ $$ = chainon ($1, $2);\n+\t\t{ $$ = chainon ($2, $1);\n \t\t  pedwarn (\"no semicolon at end of struct or union\"); }\n \t;\n \n component_decl_list2:\t/* empty */\n \t\t{ $$ = NULL_TREE; }\n \t| component_decl_list2 component_decl ';'\n-\t\t{ $$ = chainon ($1, $2); }\n+\t\t{ $$ = chainon ($2, $1); }\n \t| component_decl_list2 ';'\n \t\t{ if (pedantic)\n \t\t    pedwarn (\"extra semicolon in struct or union specified\"); }\n@@ -1831,7 +1845,7 @@ ifobjc\n \t\t  tree interface = lookup_interface ($3);\n \n \t\t  if (interface)\n-\t\t    $$ = get_class_ivars (interface);\n+\t\t    $$ = nreverse (get_class_ivars (interface));\n \t\t  else\n \t\t    {\n \t\t      error (\"cannot find interface declaration for `%s'\",\n@@ -1874,13 +1888,13 @@ component_decl:\n components:\n \t  component_declarator\n \t| components ',' maybe_resetattrs component_declarator\n-\t\t{ $$ = chainon ($1, $4); }\n+\t\t{ TREE_CHAIN ($4) = $1; $$ = $4; }\n \t;\n \n components_notype:\n \t  component_notype_declarator\n \t| components_notype ',' maybe_resetattrs component_notype_declarator\n-\t\t{ $$ = chainon ($1, $4); }\n+\t\t{ TREE_CHAIN ($4) = $1; $$ = $4; }\n \t;\n \n component_declarator:\n@@ -1910,17 +1924,15 @@ component_notype_declarator:\n \t;\n \n /* We chain the enumerators in reverse order.\n-   They are put in forward order where enumlist is used.\n-   (The order used to be significant, but no longer is so.\n-   However, we still maintain the order, just to be clean.)  */\n+   They are put in forward order in structsp_attr.  */\n \n enumlist:\n \t  enumerator\n \t| enumlist ',' enumerator\n \t\t{ if ($1 == error_mark_node)\n \t\t    $$ = $1;\n \t\t  else\n-\t\t    $$ = chainon ($3, $1); }\n+\t\t    TREE_CHAIN ($3) = $1, $$ = $3; }\n \t| error\n \t\t{ $$ = error_mark_node; }\n \t;"}, {"sha": "64b605acdea2257ccdde41f624b61dffcf84e8fd", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "patch": "@@ -1031,26 +1031,27 @@ tree\n chainon (op1, op2)\n      tree op1, op2;\n {\n+  tree t1;\n \n-  if (op1)\n-    {\n-      tree t1;\n-#ifdef ENABLE_TREE_CHECKING\n-      tree t2;\n-#endif\n+  if (!op1)\n+    return op2;\n+  if (!op2)\n+    return op1;\n+\n+  for (t1 = op1; TREE_CHAIN (t1); t1 = TREE_CHAIN (t1))\n+    continue;\n+  TREE_CHAIN (t1) = op2;\n \n-      for (t1 = op1; TREE_CHAIN (t1); t1 = TREE_CHAIN (t1))\n-\t;\n-      TREE_CHAIN (t1) = op2;\n #ifdef ENABLE_TREE_CHECKING\n-      for (t2 = op2; t2; t2 = TREE_CHAIN (t2))\n-\tif (t2 == t1)\n-\t  abort ();  /* Circularity created.  */\n+  {\n+    tree t2;\n+    for (t2 = op2; t2; t2 = TREE_CHAIN (t2))\n+      if (t2 == t1)\n+\tabort ();  /* Circularity created.  */\n+  }\n #endif\n-      return op1;\n-    }\n-  else\n-    return op2;\n+\n+  return op1;\n }\n \n /* Return the last node in a chain of nodes (chained through TREE_CHAIN).  */"}]}