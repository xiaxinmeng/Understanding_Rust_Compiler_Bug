{"sha": "20a037d5f58c824cb402275fa47f241377a5fde5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhMDM3ZDVmNThjODI0Y2I0MDIyNzVmYTQ3ZjI0MTM3N2E1ZmRlNQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-31T07:51:47Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-31T07:51:47Z"}, "message": "re PR fortran/27900 ([4.1 only] ICE using intrinsics as arguments)\n\n2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/27900\n\t* resolve.c (resolve_actual_arglist): If all else fails and a\n\tprocedure actual argument has no type, see if a specific\n\tintrinsic matches.\n\n\tPR fortran/24325\n\t* resolve.c (resolve_function): If the function reference is\n\tFL_VARIABLE this is an error.\n\n2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/27900\n\t* gfortran.dg/intrinsic_actual_4.f90: New test.\n\n\tPR fortran/24325\n\t* gfortran.dg/func_decl_3.f90: New test.\n\nFrom-SVN: r120296", "tree": {"sha": "0a1668c69fc38755835c122fed653360618c6097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a1668c69fc38755835c122fed653360618c6097"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a037d5f58c824cb402275fa47f241377a5fde5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a037d5f58c824cb402275fa47f241377a5fde5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a037d5f58c824cb402275fa47f241377a5fde5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a037d5f58c824cb402275fa47f241377a5fde5/comments", "author": null, "committer": null, "parents": [{"sha": "7fcafa718da6cb8e072bcadde5eab440df5898d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcafa718da6cb8e072bcadde5eab440df5898d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fcafa718da6cb8e072bcadde5eab440df5898d0"}], "stats": {"total": 89, "additions": 89, "deletions": 0}, "files": [{"sha": "de32f26fd6c208a7a68a653e34dc90909eebbc5d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=20a037d5f58c824cb402275fa47f241377a5fde5", "patch": "@@ -1,3 +1,14 @@\n+2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/27900\n+\t* resolve.c (resolve_actual_arglist): If all else fails and a\n+\tprocedure actual argument has no type, see if a specific\n+\tintrinsic matches.\n+\n+\tPR fortran/24325\n+\t* resolve.c (resolve_function): If the function reference is\n+\tFL_VARIABLE this is an error.\n+\n 2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/23060"}, {"sha": "ba547f20c55ede96b399d0ebb020b97c5d448aa2", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=20a037d5f58c824cb402275fa47f241377a5fde5", "patch": "@@ -140,6 +140,21 @@ resolve_formal_arglist (gfc_symbol * proc)\n \t      continue;\n \t    }\n \n+\t  if (sym->attr.function\n+\t\t&& sym->ts.type == BT_UNKNOWN\n+\t\t&& sym->attr.intrinsic)\n+\t    {\n+\t      gfc_intrinsic_sym *isym;\n+\t      isym = gfc_find_function (sym->name);\n+\t      if (isym == NULL || !isym->specific)\n+\t\t{\n+\t\t  gfc_error (\"Unable to find a specific INTRINSIC procedure \"\n+\t\t\t     \"for the reference '%s' at %L\", sym->name,\n+\t\t\t     &sym->declared_at);\n+\t\t}\n+\t      sym->ts = isym->ts;\n+\t    }\n+\n \t  continue;\n \t}\n \n@@ -937,6 +952,21 @@ resolve_actual_arglist (gfc_actual_arglist * arg, procedure_type ptype)\n \t\t      && sym->ns->parent->proc_name == sym)))\n \t    goto got_variable;\n \n+\t  /* If all else fails, see if we have a specific intrinsic.  */\n+\t  if (sym->attr.function\n+\t\t&& sym->ts.type == BT_UNKNOWN\n+\t\t&& sym->attr.intrinsic)\n+\t    {\n+\t      gfc_intrinsic_sym *isym;\n+\t      isym = gfc_find_function (sym->name);\n+\t      if (isym == NULL || !isym->specific)\n+\t\t{\n+\t\t  gfc_error (\"Unable to find a specific INTRINSIC procedure \"\n+\t\t\t     \"for the reference '%s' at %L\", sym->name,\n+\t\t\t     &e->where);\n+\t\t}\n+\t      sym->ts = isym->ts;\n+\t    }\n \t  goto argument_list;\n \t}\n \n@@ -1512,6 +1542,13 @@ resolve_function (gfc_expr * expr)\n   if (expr->symtree)\n     sym = expr->symtree->n.sym;\n \n+  if (sym && sym->attr.flavor == FL_VARIABLE)\n+    {\n+      gfc_error (\"'%s' at %L is not a function\",\n+\t\t sym->name, &expr->where);\n+      return FAILURE;\n+    }\n+\n   /* If the procedure is not internal, a statement function or a module\n      procedure,it must be external and should be checked for usage.  */\n   if (sym && !sym->attr.dummy && !sym->attr.contained"}, {"sha": "564312da9348c3e5ce35293264367c1404dd7118", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20a037d5f58c824cb402275fa47f241377a5fde5", "patch": "@@ -1,3 +1,11 @@\n+2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/27900\n+\t* gfortran.dg/intrinsic_actual_4.f90: New test.\n+\n+\tPR fortran/24325\n+\t* gfortran.dg/func_decl_3.f90: New test.\n+\n 2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/23060"}, {"sha": "4e458f47d88e8120e9ad1fcbb6431d4b0549440d", "filename": "gcc/testsuite/gfortran.dg/func_decl_3.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunc_decl_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunc_decl_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunc_decl_3.f90?ref=20a037d5f58c824cb402275fa47f241377a5fde5", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! Tests the fix for PR24325 in which the lack of any declaration\n+! that foo is a function or even a procedure was not detected.\n+!\n+! Contributed by Jakub Jelinek <jakub@gcc.gnu.org>\n+!\n+  integer foo\n+  call test\n+contains\n+  subroutine test\n+    integer :: i\n+    i = foo () ! { dg-error \"is not a function\" }\n+  end subroutine test\n+end\n+"}, {"sha": "4ba4b79c72d09b3b1bfc2f094a2ef00384fb8fac", "filename": "gcc/testsuite/gfortran.dg/intrinsic_actual_4.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a037d5f58c824cb402275fa47f241377a5fde5/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_actual_4.f90?ref=20a037d5f58c824cb402275fa47f241377a5fde5", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do run }\n+! Tests the fix for PR27900, in which an ICE would be caused because\n+! the actual argument LEN had no type.\n+!\n+! Contributed by Klaus Ramst\ufffdck <klra67@freenet.de>\n+!\n+      subroutine sub (proc, chr)\n+      external proc\n+      integer proc\n+      character*(*) chr\n+      if (proc (chr) .ne. 6) call abort ()\n+      end subroutine sub\n+\n+      implicit none\n+      integer i\n+      i = len (\"123\")\n+      call sub (len, \"abcdef\")\n+      end"}]}