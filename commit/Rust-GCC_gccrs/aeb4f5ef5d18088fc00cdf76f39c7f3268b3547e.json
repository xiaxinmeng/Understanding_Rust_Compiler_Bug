{"sha": "aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWViNGY1ZWY1ZDE4MDg4ZmMwMGNkZjc2ZjM5YzdmMzI2OGIzNTQ3ZQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "2000-05-12T20:57:57Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-05-12T20:57:57Z"}, "message": "Add movdi pattern to FR30 port.\n\nFrom-SVN: r33885", "tree": {"sha": "a9a56077d9c82f3ad4842123aa94e39f047d3060", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9a56077d9c82f3ad4842123aa94e39f047d3060"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/comments", "author": null, "committer": null, "parents": [{"sha": "1d11bf189ecde134f3a50214185ebe23c21fcebd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d11bf189ecde134f3a50214185ebe23c21fcebd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d11bf189ecde134f3a50214185ebe23c21fcebd"}], "stats": {"total": 275, "additions": 262, "deletions": 13}, "files": [{"sha": "a8cdab984267354849317f501ac485fa422ef1bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "patch": "@@ -1,3 +1,22 @@\n+2000-05-12  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/fr30/fr30.c (fr30_move_double): New function:  Emit code\n+\tto move a double word value.\n+\t(di_operand): New function: Return true if the operand is suitbale\n+\tfor a double word move operation.\n+\t(nonimmediate_di_operand): New function: Return true if the\n+\toperand is a DImode register or MEM.\n+\n+\t* config/fr30/fr30.h (PREDICATE_CODES): Add di_operand and\n+\tnonimmediate_di_operand.\n+\n+\t* config/fr30/fr30-protos.h Add fr30_move_double, di_operand, and\n+\tnonimmediate_di_operand.\n+\n+\t* config/fr30/fr30.md (movdi): New pattern.  Required because\n+\tother patterns generate DImode results.\n+\t(movdi_insn): New pattern.\n+\n 2000-05-12  Richard Henderson  <rth@cygnus.com>\n \n \t* config/alpha/alpha.c (struct shadow_summary): Define"}, {"sha": "e6d313887670c5174442ce5c92239eccf89df22f", "filename": "gcc/config/fr30/fr30-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30-protos.h?ref=aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "patch": "@@ -26,6 +26,7 @@ extern unsigned int fr30_compute_frame_size PARAMS ((int, int));\n extern int   fr30_check_multiple_regs   PARAMS ((rtx *, int, int));\n extern void  fr30_print_operand         PARAMS ((FILE *, rtx, int));\n extern void  fr30_print_operand_address PARAMS ((FILE *, rtx));\n+extern rtx   fr30_move_double\t\tPARAMS ((rtx *));\n #ifdef TREE_CODE\n extern rtx   fr30_va_arg                PARAMS ((tree, tree));\n #endif /* TREE_CODE */\n@@ -36,6 +37,8 @@ extern int   add_immediate_operand      PARAMS ((rtx, Mmode));\n extern int   high_register_operand      PARAMS ((rtx, Mmode));\n extern int   low_register_operand       PARAMS ((rtx, Mmode));\n extern int   call_operand               PARAMS ((rtx, Mmode));\n+extern int   di_operand \t\tPARAMS ((rtx, Mmode));\n+extern int   nonimmediate_di_operand \tPARAMS ((rtx, Mmode));\n #undef Mmode\n #endif /* HAVE_MACHINE_MODES */\n #endif /* RTX_CODE */"}, {"sha": "68bae05ceac4050d8b77f9290c1625661fa2b4c3", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 197, "deletions": 10, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "patch": "@@ -24,10 +24,8 @@ Boston, MA 02111-1307, USA.  */\n /*}}}*/\n /*{{{  Includes */ \n \n-#include <stdio.h>\n-#include <ctype.h>\n-#include <sys/param.h> /* so that MIn and MAX are defined before machmode.h */\n #include \"config.h\"\n+#include \"system.h\"\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -44,7 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"except.h\"\n #include \"function.h\"\n-#include \"fr30-protos.h\"\n+#include \"tm_p.h\"\n \n /*}}}*/\n /*{{{  Function Prologues & Epilogues */ \n@@ -839,8 +837,7 @@ low_register_operand (operand, mode)\n {\n   return\n     (GET_CODE (operand) == REG\n-     && REGNO (operand) <= 7\n-     && REGNO (operand) >= 0);\n+     && REGNO (operand) <= 7);\n }\n \n /* Returns true if OPERAND is suitable for use in a CALL insn.  */\n@@ -854,6 +851,56 @@ call_operand (operand, mode)\n \t      || GET_CODE (XEXP (operand, 0)) == REG));\n }\n \n+/* Returns TRUE if OP is a valid operand of a DImode operation.  */\n+int\n+di_operand (op, mode)\n+     rtx op;\n+     Mmode mode;\n+{\n+  if (register_operand (op, mode))\n+    return TRUE;\n+\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && GET_MODE (op) != DImode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+      return TRUE;\n+\n+    case MEM:\n+      return memory_address_p (DImode, XEXP (op, 0));\n+\n+    default:\n+      return FALSE;\n+    }\n+}\n+\n+/* Returns TRUE if OP is a DImode register or MEM.  */\n+int\n+nonimmediate_di_operand (op, mode)\n+     rtx op;\n+     Mmode mode;\n+{\n+  if (register_operand (op, mode))\n+    return TRUE;\n+\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && GET_MODE (op) != DImode)\n+    return FALSE;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  if (GET_CODE (op) == MEM)\n+    return memory_address_p (DImode, XEXP (op, 0));\n+\n+  return FALSE;\n+}\n+\n /* Returns true iff all the registers in the operands array\n    are in descending or ascending order.  */\n int\n@@ -864,9 +911,9 @@ fr30_check_multiple_regs (operands, num_operands, descending)\n {\n   if (descending)\n     {\n-      int prev_regno = -1;\n+      unsigned int prev_regno = 0;\n       \n-      while (num_operands--)\n+      while (num_operands --)\n \t{\n \t  if (GET_CODE (operands [num_operands]) != REG)\n \t    return 0;\n@@ -879,9 +926,9 @@ fr30_check_multiple_regs (operands, num_operands, descending)\n     }\n   else\n     {\n-      int prev_regno = CONDITION_CODE_REGNUM;\n+      unsigned int prev_regno = CONDITION_CODE_REGNUM;\n       \n-      while (num_operands--)\n+      while (num_operands --)\n \t{\n \t  if (GET_CODE (operands [num_operands]) != REG)\n \t    return 0;\n@@ -896,6 +943,146 @@ fr30_check_multiple_regs (operands, num_operands, descending)\n   return 1;\n }\n \n+/*}}}*/\n+/*{{{  Instruction Output Routines  */\n+\n+/* Output a double word move.\n+   It must be REG<-REG, REG<-MEM, MEM<-REG or REG<-CONST.\n+   On the FR30 we are contrained by the fact that it does not\n+   support offsetable addresses, and so we have to load the\n+   address of the secnd word into the second destination register\n+   before we can use it.  */\n+\n+rtx\n+fr30_move_double (operands)\n+     rtx * operands;\n+{\n+  rtx src  = operands[1];\n+  rtx dest = operands[0];\n+  enum rtx_code src_code = GET_CODE (src);\n+  enum rtx_code dest_code = GET_CODE (dest);\n+  enum machine_mode mode = GET_MODE (dest);\n+  rtx val;\n+\n+  start_sequence ();\n+\n+  if (dest_code == REG)\n+    {\n+      if (src_code == REG)\n+\t{\n+\t  int reverse = (REGNO (dest) == REGNO (src) + 1);\n+\t  \n+\t  /* We normally copy the low-numbered register first.  However, if\n+\t     the first register of operand 0 is the same as the second register\n+\t     of operand 1, we must copy in the opposite order.  */\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, reverse, TRUE, mode),\n+\t\t\t\t  operand_subword (src,  reverse, TRUE, mode)));\n+\t  \n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      operand_subword (dest, !reverse, TRUE, mode),\n+\t\t\t      operand_subword (src,  !reverse, TRUE, mode)));\n+\t}\n+      else if (src_code == MEM)\n+\t{\n+\t  rtx addr = XEXP (src, 0);\n+\t  int dregno = REGNO (dest);\n+\t  rtx dest0;\n+\t  rtx dest1;\n+\t  rtx new_mem;\n+\t  \n+\t  /* If the high-address word is used in the address, we\n+\t     must load it last.  Otherwise, load it first.  */\n+\t  int reverse = (refers_to_regno_p (dregno, dregno + 1, addr, 0) != 0);\n+\n+\t  if (GET_CODE (addr) != REG)\n+\t    abort ();\n+\t  \n+\t  dest0 = operand_subword (dest, reverse, TRUE, mode);\n+\t  dest1 = operand_subword (dest, !reverse, TRUE, mode);\n+\n+\t  if (reverse)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest1, change_address (src, SImode, addr)));\n+\t      emit_insn (gen_rtx_SET (SImode, dest0, gen_rtx_REG (SImode, REGNO (addr))));\n+\t      emit_insn (gen_rtx_SET (SImode, dest0, plus_constant (dest0, UNITS_PER_WORD)));\n+\n+\t      new_mem = gen_rtx_MEM (SImode, dest0);\n+\t      MEM_COPY_ATTRIBUTES (new_mem, src);\n+\t      \n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest0, new_mem));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest0, change_address (src, SImode, addr)));\n+\t      emit_insn (gen_rtx_SET (SImode, dest1, gen_rtx_REG (SImode, REGNO (addr))));\n+\t      emit_insn (gen_rtx_SET (SImode, dest1, plus_constant (dest1, UNITS_PER_WORD)));\n+\n+\t      new_mem = gen_rtx_MEM (SImode, dest1);\n+\t      MEM_COPY_ATTRIBUTES (new_mem, src);\n+\t      \n+\t      emit_insn (gen_rtx_SET (VOIDmode, dest1, new_mem));\n+\t    }\n+\t}\n+      else if (src_code == CONST_INT || src_code == CONST_DOUBLE)\n+\t{\n+\t  rtx words[2];\n+\t  split_double (src, &words[0], &words[1]);\n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, 0, TRUE, mode),\n+\t\t\t\t  words[0]));\n+      \n+\t  emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t\t  operand_subword (dest, 1, TRUE, mode),\n+\t\t\t\t  words[1]));\n+\t}\n+    }\n+  else if (src_code == REG && dest_code == MEM)\n+    {\n+      rtx addr = XEXP (dest, 0);\n+      rtx src0;\n+      rtx src1;\n+\n+      if (GET_CODE (addr) != REG)\n+\tabort ();\n+      \n+      src0 = operand_subword (src, 0, TRUE, mode);\n+      src1 = operand_subword (src, 1, TRUE, mode);\n+      \n+      emit_insn (gen_rtx_SET (VOIDmode, change_address (dest, SImode, addr), src0));\n+\n+      if (REGNO (addr) == STACK_POINTER_REGNUM)\n+\temit_insn (gen_rtx_SET (VOIDmode, change_address (dest, SImode, plus_constant (stack_pointer_rtx, UNITS_PER_WORD)), src1));\n+      else if (REGNO (addr) == FRAME_POINTER_REGNUM)\n+\temit_insn (gen_rtx_SET (VOIDmode, change_address (dest, SImode, plus_constant (frame_pointer_rtx, UNITS_PER_WORD)), src1));\n+      else\n+\t{\n+\t  rtx new_mem;\n+\t  \n+\t  /* We need a scratch register to hold the value of 'address + 4'.\n+\t     We ought to allow gcc to find one for us, but for now, just\n+\t     push one of the source registers.  */\n+\t  emit_insn (gen_movsi_push (src0));\n+\t  emit_insn (gen_movsi_internal (src0, addr));\n+\t  emit_insn (gen_addsi_small_int (src0, src0, GEN_INT (UNITS_PER_WORD)));\n+\t  \n+\t  new_mem = gen_rtx_MEM (SImode, src0);\n+\t  MEM_COPY_ATTRIBUTES (new_mem, dest);\n+\t  \n+\t  emit_insn (gen_rtx_SET (VOIDmode, new_mem, src1));\n+\t  emit_insn (gen_movsi_pop (src0));\n+\t}\n+    }\n+  else\n+    /* This should have been prevented by the contraints on movdi_insn.  */\n+    abort ();\n+  \n+  val = gen_sequence ();\n+  end_sequence ();\n+\n+  return val;\n+}\n+\n /*}}}*/\n \n /* Local Variables: */"}, {"sha": "2bd1b6f3b52c1a112b4aecbf3954c563f853bf5e", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "patch": "@@ -84,7 +84,7 @@ extern int target_flags;\n   { \"small-model\",      TARGET_SMALL_MODEL_MASK, \"Assume small address space\" }, \\\n   { \"no-small-model\", - TARGET_SMALL_MODEL_MASK, \"\" },\t\t\t \t \\\n   { \"no-lsim\",          0, \"\" },\t\t\t\t\t \t \\\n-  { \"\",                 TARGET_DEFAULT }\t\t\t\t\t \\\n+  { \"\",                 TARGET_DEFAULT, \"\" }\t\t\t\t\t \\\n }\n \n #define TARGET_VERSION fprintf (stderr, \" (fr30)\");\n@@ -889,9 +889,10 @@ enum reg_class\n      into the stack)\n    - if the type is a structure or union. */\n \n-#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\t\\\n+#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\\\n    (((MODE) == BLKmode)\t\t\t\t\t\t\\\n-    || ((TYPE) != 0\t\t\t\t\t\t\\\n+    || ((TYPE) != NULL\t\t\t\t\t\t\\\n+         && TYPE_SIZE (TYPE) != NULL\t\t\t\t\\\n          && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\\\n \t     || TREE_CODE (TYPE) == RECORD_TYPE\t\t\t\\\n \t     || TREE_CODE (TYPE) == UNION_TYPE\t\t\t\\\n@@ -1763,6 +1764,8 @@ extern struct rtx_def * fr30_compare_op1;\n   { \"call_operand\",\t\t{ MEM }},\t\t\\\n   { \"fp_displacement_operand\",\t{ CONST_INT }},\t\t\\\n   { \"sp_displacement_operand\",\t{ CONST_INT }},\t\t\\\n+  { \"di_operand\",\t\t{ CONST_INT, CONST_DOUBLE, REG, MEM }},\t\\\n+  { \"nonimmediate_di_operand\",\t{ REG, MEM }},\t\t\\\n   { \"add_immediate_operand\",\t{ REG, CONST_INT }},\n \n /*}}}*/ \f"}, {"sha": "296cdb27eb25cb16806b3020cc27bb6693fb2715", "filename": "gcc/config/fr30/fr30.md", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e/gcc%2Fconfig%2Ffr30%2Ffr30.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.md?ref=aeb4f5ef5d18088fc00cdf76f39c7f3268b3547e", "patch": "@@ -367,6 +367,43 @@\n \t\t\t      (const_int 2)))]\n )\n \n+;;}}}\n+;;{{{ 8 Byte Moves\n+\n+;; Note - the FR30 does not have an 8 byte load/store instruction\n+;; but we have to support this pattern because some other patterns\n+;; (eg muldisi2) can produce a DImode result.\n+;; (This code is stolen from the M32R port.)\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+  /* Everything except mem = const or mem = mem can be done easily.  */\n+  \n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[1] = force_reg (DImode, operands[1]);\n+  \")\n+\n+;; We use an insn and a split so that we can generate\n+;; RTL rather than text from fr30_move_double().\n+\n+(define_insn \"*movdi_insn\"\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r,r,m,r\")\n+\t(match_operand:DI 1 \"di_operand\"               \"r,m,r,nF\"))]\n+  \"register_operand (operands[0], DImode) || register_operand (operands[1], DImode)\"\n+  \"#\"\n+  [(set_attr \"length\" \"4,8,12,12\")]\n+)\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"\")\n+\t(match_operand:DI 1 \"di_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(match_dup 2)]\n+  \"operands[2] = fr30_move_double (operands);\")\n+\n ;;}}}\n ;;{{{ Load & Store Multiple Registers \n "}]}