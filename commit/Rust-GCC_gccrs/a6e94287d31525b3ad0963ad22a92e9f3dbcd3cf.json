{"sha": "a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZlOTQyODdkMzE1MjViM2FkMDk2M2FkMjJhOTJlOWYzZGJjZDNjZg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T18:59:54Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-05-25T23:28:04Z"}, "message": "Remove the logical stmt cache for now.\n\nWith the depth limiting, we are not currently using the logical stmt cache.\n\n\t* gimple-range-gori.cc (class logical_stmt_cache): Delete\n\t(logical_stmt_cache::logical_stmt_cache ): Delete.\n\t(logical_stmt_cache::~logical_stmt_cache): Delete.\n\t(logical_stmt_cache::cache_entry::dump): Delete.\n\t(logical_stmt_cache::get_range): Delete.\n\t(logical_stmt_cache::cached_name ): Delete.\n\t(logical_stmt_cache::same_cached_name): Delete.\n\t(logical_stmt_cache::cacheable_p): Delete.\n\t(logical_stmt_cache::slot_diagnostics ): Delete.\n\t(logical_stmt_cache::dump): Delete.\n\t(gori_compute_cache::gori_compute_cache): Delete.\n\t(gori_compute_cache::~gori_compute_cache): Delete.\n\t(gori_compute_cache::compute_operand_range): Delete.\n\t(gori_compute_cache::cache_stmt): Delete.\n\t* gimple-range-gori.h (gori_compute::compute_operand_range): Remove\n\tvirtual.\n\t(class gori_compute_cache): Delete.", "tree": {"sha": "f90f231080e2cb5e7c7fe864fc26f7926b7a9713", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f90f231080e2cb5e7c7fe864fc26f7926b7a9713"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf/comments", "author": null, "committer": null, "parents": [{"sha": "f630797a1ed2f82faf965a47b43b5f995bc6623a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f630797a1ed2f82faf965a47b43b5f995bc6623a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f630797a1ed2f82faf965a47b43b5f995bc6623a"}], "stats": {"total": 342, "additions": 2, "deletions": 340}, "files": [{"sha": "a4c4bf507bada4bd133450f306a0af5a7c5ef3ba", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf", "patch": "@@ -1160,314 +1160,3 @@ gori_export_iterator::get_name ()\n     }\n   return NULL_TREE;\n }\n-\n-\n-// --------------------------------------------------------------------------\n-\n-// Cache for SSAs that appear on the RHS of a boolean assignment.\n-//\n-// Boolean assignments of logical expressions (i.e. LHS = j_5 > 999)\n-// have SSA operands whose range depend on the LHS of the assigment.\n-// That is, the range of j_5 when LHS is true is different than when\n-// LHS is false.\n-//\n-// This class caches the TRUE/FALSE ranges of such SSAs to avoid\n-// recomputing.\n-\n-class logical_stmt_cache\n-{\n-public:\n-  logical_stmt_cache ();\n-  ~logical_stmt_cache ();\n-  void set_range (tree lhs, tree name, const tf_range &);\n-  bool get_range (tf_range &r, tree lhs, tree name) const;\n-  bool cacheable_p (gimple *, const irange *lhs_range = NULL) const;\n-  void dump (FILE *, gimple *stmt) const;\n-  tree same_cached_name (tree lhs1, tree lh2) const;\n-private:\n-  tree cached_name (tree lhs) const;\n-  void slot_diagnostics (tree lhs, const tf_range &range) const;\n-  struct cache_entry\n-  {\n-    cache_entry (tree name, const irange &t_range, const irange &f_range);\n-    void dump (FILE *out) const;\n-    tree name;\n-    tf_range range;\n-  };\n-  vec<cache_entry *> m_ssa_cache;\n-};\n-\n-logical_stmt_cache::cache_entry::cache_entry (tree name,\n-\t\t\t\t\t      const irange &t_range,\n-\t\t\t\t\t      const irange &f_range)\n-  : name (name), range (t_range, f_range)\n-{\n-}\n-\n-logical_stmt_cache::logical_stmt_cache ()\n-{\n-  m_ssa_cache.create (num_ssa_names + num_ssa_names / 10);\n-  m_ssa_cache.safe_grow_cleared (num_ssa_names);\n-}\n-\n-logical_stmt_cache::~logical_stmt_cache ()\n-{\n-  for (unsigned i = 0; i < m_ssa_cache.length (); ++i)\n-    if (m_ssa_cache[i])\n-      delete m_ssa_cache[i];\n-  m_ssa_cache.release ();\n-}\n-\n-// Dump cache_entry to OUT.\n-\n-void\n-logical_stmt_cache::cache_entry::dump (FILE *out) const\n-{\n-  fprintf (out, \"name=\");\n-  print_generic_expr (out, name, TDF_SLIM);\n-  fprintf (out, \" \");\n-  range.true_range.dump (out);\n-  fprintf (out, \", \");\n-  range.false_range.dump (out);\n-  fprintf (out, \"\\n\");\n-}\n-\n-// Update range for cache entry of NAME as it appears in the defining\n-// statement of LHS.\n-\n-void\n-logical_stmt_cache::set_range (tree lhs, tree name, const tf_range &range)\n-{\n-  unsigned version = SSA_NAME_VERSION (lhs);\n-  if (version >= m_ssa_cache.length ())\n-    m_ssa_cache.safe_grow_cleared (num_ssa_names + num_ssa_names / 10);\n-\n-  cache_entry *slot = m_ssa_cache[version];\n-  slot_diagnostics (lhs, range);\n-  if (slot)\n-    {\n-      // The IL must have changed.  Update the carried SSA name for\n-      // consistency.  Testcase is libgomp.fortran/doacross1.f90.\n-      if (slot->name != name)\n-\tslot->name = name;\n-      return;\n-    }\n-  m_ssa_cache[version]\n-    = new cache_entry (name, range.true_range, range.false_range);\n-}\n-\n-// If there is a cached entry of NAME, set it in R and return TRUE,\n-// otherwise return FALSE.  LHS is the defining statement where NAME\n-// appeared.\n-\n-bool\n-logical_stmt_cache::get_range (tf_range &r, tree lhs, tree name) const\n-{\n-  gcc_checking_assert (cacheable_p (SSA_NAME_DEF_STMT (lhs)));\n-  if (cached_name (lhs) == name)\n-    {\n-      unsigned version = SSA_NAME_VERSION (lhs);\n-      if (m_ssa_cache[version])\n-\t{\n-\t  r = m_ssa_cache[version]->range;\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-// If the defining statement of LHS is in the cache, return the SSA\n-// operand being cached.  That is, return SSA for LHS = SSA .RELOP. OP2.\n-\n-tree\n-logical_stmt_cache::cached_name (tree lhs) const\n-{\n-  unsigned version = SSA_NAME_VERSION (lhs);\n-\n-  if (version >= m_ssa_cache.length ())\n-    return NULL;\n-\n-  if (m_ssa_cache[version])\n-    return m_ssa_cache[version]->name;\n-  return NULL;\n-}\n-\n-// Return TRUE if the cached name for LHS1 is the same as the\n-// cached name for LHS2.\n-\n-tree\n-logical_stmt_cache::same_cached_name (tree lhs1, tree lhs2) const\n-{\n-  tree name = cached_name (lhs1);\n-  if (name && name == cached_name (lhs2))\n-    return name;\n-  return NULL;\n-}\n-\n-// Return TRUE if STMT is a statement we are interested in caching.\n-// LHS_RANGE is any known range for the LHS of STMT.\n-\n-bool\n-logical_stmt_cache::cacheable_p (gimple *stmt, const irange *lhs_range) const\n-{\n-  if (gimple_code (stmt) == GIMPLE_ASSIGN\n-      && types_compatible_p (TREE_TYPE (gimple_assign_lhs (stmt)),\n-\t\t\t     boolean_type_node)\n-      && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n-    {\n-      switch (gimple_expr_code (stmt))\n-\t{\n-\tcase TRUTH_AND_EXPR:\n-\tcase BIT_AND_EXPR:\n-\tcase TRUTH_OR_EXPR:\n-\tcase BIT_IOR_EXPR:\n-\t  return !lhs_range || range_is_either_true_or_false (*lhs_range);\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-  return false;\n-}\n-\n-// Output debugging diagnostics for the cache entry for LHS.  RANGE is\n-// the new range that is being cached.\n-\n-void\n-logical_stmt_cache::slot_diagnostics (tree lhs, const tf_range &range) const\n-{\n-  gimple *stmt = SSA_NAME_DEF_STMT (lhs);\n-  unsigned version = SSA_NAME_VERSION (lhs);\n-  cache_entry *slot = m_ssa_cache[version];\n-\n-  if (!slot)\n-    {\n-      if (DEBUG_RANGE_CACHE)\n-\t{\n-\t  fprintf (dump_file ? dump_file : stderr, \"registering range for: \");\n-\t  dump (dump_file ? dump_file : stderr, stmt);\n-\t}\n-      return;\n-    }\n-  if (DEBUG_RANGE_CACHE)\n-    fprintf (dump_file ? dump_file : stderr,\n-\t     \"reusing range for SSA #%d\\n\", version);\n-  if (CHECKING_P && (slot->range.true_range != range.true_range\n-\t\t     || slot->range.false_range != range.false_range))\n-    {\n-      fprintf (stderr, \"FATAL: range altered for cached: \");\n-      dump (stderr, stmt);\n-      fprintf (stderr, \"Attempt to change to:\\n\");\n-      fprintf (stderr, \"TRUE=\");\n-      range.true_range.dump (stderr);\n-      fprintf (stderr, \", FALSE=\");\n-      range.false_range.dump (stderr);\n-      fprintf (stderr, \"\\n\");\n-      gcc_unreachable ();\n-    }\n-}\n-\n-// Dump the cache information for STMT.\n-\n-void\n-logical_stmt_cache::dump (FILE *out, gimple *stmt) const\n-{\n-  tree lhs = gimple_assign_lhs (stmt);\n-  cache_entry *entry = m_ssa_cache[SSA_NAME_VERSION (lhs)];\n-\n-  print_gimple_stmt (out, stmt, 0, TDF_SLIM);\n-  if (entry)\n-    {\n-      fprintf (out, \"\\tname = \");\n-      print_generic_expr (out, entry->name);\n-      fprintf (out, \" lhs(%d)= \", SSA_NAME_VERSION (lhs));\n-      print_generic_expr (out, lhs);\n-      fprintf (out, \"\\n\\tTRUE=\");\n-      entry->range.true_range.dump (out);\n-      fprintf (out, \", FALSE=\");\n-      entry->range.false_range.dump (out);\n-      fprintf (out, \"\\n\");\n-    }\n-  else\n-    fprintf (out, \"[EMPTY]\\n\");\n-}\n-\n-gori_compute_cache::gori_compute_cache ()\n-{\n-  m_cache = new logical_stmt_cache;\n-}\n-\n-gori_compute_cache::~gori_compute_cache ()\n-{\n-  delete m_cache;\n-}\n-\n-// Caching version of compute_operand_range.  If NAME, as it appears\n-// in STMT, has already been cached return it from the cache,\n-// otherwise compute the operand range as normal and cache it.\n-\n-bool\n-gori_compute_cache::compute_operand_range (irange &r, gimple *stmt,\n-\t\t\t\t\t   const irange &lhs_range, tree name)\n-{\n-  bool cacheable = m_cache->cacheable_p (stmt, &lhs_range);\n-  if (cacheable)\n-    {\n-      tree lhs = gimple_assign_lhs (stmt);\n-      tf_range range;\n-      if (m_cache->get_range (range, lhs, name))\n-\t{\n-\t  if (lhs_range.zero_p ())\n-\t    r = range.false_range;\n-\t  else\n-\t    r = range.true_range;\n-\t  return true;\n-\t}\n-    }\n-  if (super::compute_operand_range (r, stmt, lhs_range, name))\n-    {\n-      if (cacheable)\n-\tcache_stmt (stmt);\n-      return true;\n-    }\n-  return false;\n-}\n-\n-// Cache STMT if possible.\n-\n-void\n-gori_compute_cache::cache_stmt (gimple *stmt)\n-{\n-  gcc_checking_assert (m_cache->cacheable_p (stmt));\n-  enum tree_code code = gimple_expr_code (stmt);\n-  tree lhs = gimple_assign_lhs (stmt);\n-  tree op1 = gimple_range_operand1 (stmt);\n-  tree op2 = gimple_range_operand2 (stmt);\n-  int_range_max r_true_side, r_false_side;\n-\n-  // LHS = s_5 && 999.\n-  if (TREE_CODE (op2) == INTEGER_CST)\n-    {\n-      range_operator *handler = range_op_handler (code, TREE_TYPE (lhs));\n-      int_range_max op2_range;\n-      expr_range_at_stmt (op2_range, op2, stmt);\n-      tree type = TREE_TYPE (op1);\n-      handler->op1_range (r_true_side, type, m_bool_one, op2_range);\n-      handler->op1_range (r_false_side, type, m_bool_zero, op2_range);\n-      m_cache->set_range (lhs, op1, tf_range (r_true_side, r_false_side));\n-    }\n-  // LHS = s_5 && b_8.\n-  else if (tree cached_name = m_cache->same_cached_name (op1, op2))\n-    {\n-      tf_range op1_range, op2_range;\n-      bool ok = m_cache->get_range (op1_range, op1, cached_name);\n-      ok = ok && m_cache->get_range (op2_range, op2, cached_name);\n-      ok = ok && logical_combine (r_true_side, code, m_bool_one,\n-\t\t\t\t  op1_range, op2_range);\n-      ok = ok && logical_combine (r_false_side, code, m_bool_zero,\n-\t\t\t\t  op1_range, op2_range);\n-      gcc_checking_assert (ok);\n-      if (ok)\n-\tm_cache->set_range (lhs, cached_name,\n-\t\t\t    tf_range (r_true_side, r_false_side));\n-    }\n-}"}, {"sha": "f41dee3d8e54fc2ce5f2692c2daf73575a9b2066", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=a6e94287d31525b3ad0963ad22a92e9f3dbcd3cf", "patch": "@@ -158,8 +158,8 @@ class gori_compute : public gori_map\n   void dump (FILE *f);\n protected:\n   virtual void ssa_range_in_bb (irange &r, tree name, basic_block bb);\n-  virtual bool compute_operand_range (irange &r, gimple *stmt,\n-\t\t\t\t      const irange &lhs, tree name);\n+  bool compute_operand_range (irange &r, gimple *stmt,\n+\t\t\t      const irange &lhs, tree name);\n \n   void expr_range_at_stmt (irange &r, tree expr, gimple *s);\n   bool compute_logical_operands (irange &r, gimple *stmt,\n@@ -217,31 +217,4 @@ class gori_export_iterator {\n   unsigned y;\n };\n \n-// This class adds a cache to gori_computes for logical expressions.\n-//       bool result = x && y\n-// requires calcuation of both X and Y for both true and false results.\n-// There are 4 combinations [0,0][0,0] [0,0][1,1] [1,1][0,0] and [1,1][1,1].\n-// Note that each pair of possible results for X and Y are used twice, and\n-// the calcuation of those results are the same each time.\n-//\n-// The cache simply checks if a stmt is cachable, and if so, saves both the\n-// true and false results for the next time the query is made.\n-//\n-// This is used to speed up long chains of logical operations which\n-// quickly become exponential.\n-\n-class gori_compute_cache : public gori_compute\n-{\n-public:\n-  gori_compute_cache ();\n-  ~gori_compute_cache ();\n-protected:\n-  virtual bool compute_operand_range (irange &r, gimple *stmt,\n-\t\t\t\t      const irange &lhs, tree name);\n-private:\n-  void cache_stmt (gimple *);\n-  typedef gori_compute super;\n-  class logical_stmt_cache *m_cache;\n-};\n-\n #endif // GCC_GIMPLE_RANGE_GORI_H"}]}