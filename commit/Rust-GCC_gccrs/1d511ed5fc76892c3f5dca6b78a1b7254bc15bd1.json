{"sha": "1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1MTFlZDVmYzc2ODkyYzNmNWRjYTZiNzhhMWI3MjU0YmMxNWJkMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-07-08T12:54:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-07-08T12:54:53Z"}, "message": "re PR rtl-optimization/16199 (ICE while compiling apache 2.0.49)\n\n\tPR target/16199\n\t* config/sparc/sparc.c (sparc_emit_set_symbolic_const64): When\n\t'temp' is zero, generate new pseudos as needed and emit the\n\tsequence of insns in single-assignment form.  Resync comments\n\twith code.\n\t(sparc_emit_set_const64): Pass zero as 'temp' argument to above\n\tfunction before reload.\n\nFrom-SVN: r84285", "tree": {"sha": "6e6c41a66a7717ee71e1a684bb8ced0c9f769712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e6c41a66a7717ee71e1a684bb8ced0c9f769712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47293da3149269ec799f05bc446aeb7ca0133cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47293da3149269ec799f05bc446aeb7ca0133cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47293da3149269ec799f05bc446aeb7ca0133cb3"}], "stats": {"total": 276, "additions": 213, "deletions": 63}, "files": [{"sha": "d9cf1950f88e2c99c41a37f733e6d775e13d0c06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "patch": "@@ -1,3 +1,13 @@\n+2004-07-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tPR target/16199\n+\t* config/sparc/sparc.c (sparc_emit_set_symbolic_const64): When\n+\t'temp' is zero, generate new pseudos as needed and emit the\n+\tsequence of insns in single-assignment form.  Resync comments\n+\twith code.\n+\t(sparc_emit_set_const64): Pass zero as 'temp' argument to above\n+\tfunction before reload.\n+\n 2004-07-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* vec.c (vec_assert_fail): Remove duplicate 'function'."}, {"sha": "02a804013a64e394bae8e7d5b12e0a3e4d7dadf4", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 131, "deletions": 63, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "patch": "@@ -1437,18 +1437,25 @@ sparc_emit_set_const32 (rtx op0, rtx op1)\n }\n \n \f\n-/* SPARC-v9 code-model support.  */\n+/* Load OP1, a symbolic 64-bit constant, into OP0, a DImode register.\n+   If TEMP is non-zero, we are forbidden to use any other scratch\n+   registers.  Otherwise, we are allowed to generate them as needed.\n+\n+   Note that TEMP may have TImode if the code model is TARGET_CM_MEDANY\n+   or TARGET_CM_EMBMEDANY (see the reload_indi and reload_outdi patterns).  */\n void\n-sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp1)\n+sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp)\n {\n-  rtx ti_temp1 = 0;\n+  rtx temp1, temp2, temp3, temp4, temp5;\n+  rtx ti_temp = 0;\n \n-  if (temp1 && GET_MODE (temp1) == TImode)\n+  if (temp && GET_MODE (temp) == TImode)\n     {\n-      ti_temp1 = temp1;\n-      temp1 = gen_rtx_REG (DImode, REGNO (temp1));\n+      ti_temp = temp;\n+      temp = gen_rtx_REG (DImode, REGNO (temp));\n     }\n \n+  /* SPARC-V9 code-model support.  */\n   switch (sparc_cmodel)\n     {\n     case CM_MEDLOW:\n@@ -1460,8 +1467,13 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp1)\n \t The executable must be in the low 4TB of the virtual address\n \t space.\n \n-\t sethi\t%hi(symbol), %temp\n-\t or\t%temp, %lo(symbol), %reg  */\n+\t sethi\t%hi(symbol), %temp1\n+\t or\t%temp1, %lo(symbol), %reg  */\n+      if (temp)\n+\ttemp1 = temp;  /* op0 is allowed.  */\n+      else\n+\ttemp1 = gen_reg_rtx (DImode);\n+\n       emit_insn (gen_rtx_SET (VOIDmode, temp1, gen_rtx_HIGH (DImode, op1)));\n       emit_insn (gen_rtx_SET (VOIDmode, op0, gen_rtx_LO_SUM (DImode, temp1, op1)));\n       break;\n@@ -1479,11 +1491,24 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp1)\n \t or\t%temp1, %m44(symbol), %temp2\n \t sllx\t%temp2, 12, %temp3\n \t or\t%temp3, %l44(symbol), %reg  */\n-      emit_insn (gen_seth44 (op0, op1));\n-      emit_insn (gen_setm44 (op0, op0, op1));\n-      emit_insn (gen_rtx_SET (VOIDmode, temp1,\n-\t\t\t      gen_rtx_ASHIFT (DImode, op0, GEN_INT (12))));\n-      emit_insn (gen_setl44 (op0, temp1, op1));\n+      if (temp)\n+\t{\n+\t  temp1 = op0;\n+\t  temp2 = op0;\n+\t  temp3 = temp;  /* op0 is allowed.  */\n+\t}\n+      else\n+\t{\n+\t  temp1 = gen_reg_rtx (DImode);\n+\t  temp2 = gen_reg_rtx (DImode);\n+\t  temp3 = gen_reg_rtx (DImode);\n+\t}\n+\n+      emit_insn (gen_seth44 (temp1, op1));\n+      emit_insn (gen_setm44 (temp2, temp1, op1));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp3,\n+\t\t\t      gen_rtx_ASHIFT (DImode, temp2, GEN_INT (12))));\n+      emit_insn (gen_setl44 (op0, temp3, op1));\n       break;\n \n     case CM_MEDANY:\n@@ -1498,29 +1523,44 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp1)\n \t sethi\t%hh(symbol), %temp1\n \t sethi\t%lm(symbol), %temp2\n \t or\t%temp1, %hm(symbol), %temp3\n-\t or\t%temp2, %lo(symbol), %temp4\n-\t sllx\t%temp3, 32, %temp5\n-\t or\t%temp4, %temp5, %reg  */\n-\n-      /* It is possible that one of the registers we got for operands[2]\n-\t might coincide with that of operands[0] (which is why we made\n-\t it TImode).  Pick the other one to use as our scratch.  */\n-      if (rtx_equal_p (temp1, op0))\n+\t sllx\t%temp3, 32, %temp4\n+\t or\t%temp4, %temp2, %temp5\n+\t or\t%temp5, %lo(symbol), %reg  */\n+      if (temp)\n \t{\n-\t  if (ti_temp1)\n-\t    temp1 = gen_rtx_REG (DImode, REGNO (temp1) + 1);\n-\t  else\n-\t    abort();\n+\t  /* It is possible that one of the registers we got for operands[2]\n+\t     might coincide with that of operands[0] (which is why we made\n+\t     it TImode).  Pick the other one to use as our scratch.  */\n+\t  if (rtx_equal_p (temp, op0))\n+\t    {\n+\t      if (ti_temp)\n+\t\ttemp = gen_rtx_REG (DImode, REGNO (temp) + 1);\n+\t      else\n+\t\tabort();\n+\t    }\n+\t  temp1 = op0;\n+\t  temp2 = temp;  /* op0 is _not_ allowed, see above.  */\n+\t  temp3 = op0;\n+\t  temp4 = op0;\n+\t  temp5 = op0;\n+\t}\n+      else\n+\t{\n+\t  temp1 = gen_reg_rtx (DImode);\n+\t  temp2 = gen_reg_rtx (DImode);\n+\t  temp3 = gen_reg_rtx (DImode);\n+\t  temp4 = gen_reg_rtx (DImode);\n+\t  temp5 = gen_reg_rtx (DImode);\n \t}\n \n-      emit_insn (gen_sethh (op0, op1));\n-      emit_insn (gen_setlm (temp1, op1));\n-      emit_insn (gen_sethm (op0, op0, op1));\n-      emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t      gen_rtx_ASHIFT (DImode, op0, GEN_INT (32))));\n-      emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t      gen_rtx_PLUS (DImode, op0, temp1)));\n-      emit_insn (gen_setlo (op0, op0, op1));\n+      emit_insn (gen_sethh (temp1, op1));\n+      emit_insn (gen_setlm (temp2, op1));\n+      emit_insn (gen_sethm (temp3, temp1, op1));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp4,\n+\t\t\t      gen_rtx_ASHIFT (DImode, temp3, GEN_INT (32))));\n+      emit_insn (gen_rtx_SET (VOIDmode, temp5,\n+\t\t\t      gen_rtx_PLUS (DImode, temp4, temp2)));\n+      emit_insn (gen_setlo (op0, temp5, op1));\n       break;\n \n     case CM_EMBMEDANY:\n@@ -1532,42 +1572,69 @@ sparc_emit_set_symbolic_const64 (rtx op0, rtx op1, rtx temp1)\n \t look different.\n \n \t Data segment:\tsethi\t%hi(symbol), %temp1\n-\t\t\tor\t%temp1, %lo(symbol), %temp2\n-\t\t\tadd\t%temp2, EMBMEDANY_BASE_REG, %reg\n-\n-\t Text segment:\tsethi\t%uhi(symbol), %temp1\n-\t\t\tsethi\t%hi(symbol), %temp2\n-\t\t\tor\t%temp1, %ulo(symbol), %temp3\n-\t\t\tor\t%temp2, %lo(symbol), %temp4\n-\t\t\tsllx\t%temp3, 32, %temp5\n-\t\t\tor\t%temp4, %temp5, %reg  */\n+\t\t\tadd\t%temp1, EMBMEDANY_BASE_REG, %temp2\n+\t\t\tor\t%temp2, %lo(symbol), %reg  */\n       if (data_segment_operand (op1, GET_MODE (op1)))\n \t{\n+\t  if (temp)\n+\t    {\n+\t      temp1 = temp;  /* op0 is allowed.  */\n+\t      temp2 = op0;\n+\t    }\n+\t  else\n+\t    {\n+\t      temp1 = gen_reg_rtx (DImode);\n+\t      temp2 = gen_reg_rtx (DImode);\n+\t    }\n+\n \t  emit_insn (gen_embmedany_sethi (temp1, op1));\n-\t  emit_insn (gen_embmedany_brsum (op0, temp1));\n-\t  emit_insn (gen_embmedany_losum (op0, op0, op1));\n+\t  emit_insn (gen_embmedany_brsum (temp2, temp1));\n+\t  emit_insn (gen_embmedany_losum (op0, temp2, op1));\n \t}\n+\n+      /* Text segment:\tsethi\t%uhi(symbol), %temp1\n+\t\t\tsethi\t%hi(symbol), %temp2\n+\t\t\tor\t%temp1, %ulo(symbol), %temp3\n+\t\t\tsllx\t%temp3, 32, %temp4\n+\t\t\tor\t%temp4, %temp2, %temp5\n+\t\t\tor\t%temp5, %lo(symbol), %reg  */\n       else\n \t{\n-\t  /* It is possible that one of the registers we got for operands[2]\n-\t     might coincide with that of operands[0] (which is why we made\n-\t     it TImode).  Pick the other one to use as our scratch.  */\n-\t  if (rtx_equal_p (temp1, op0))\n+\t  if (temp)\n \t    {\n-\t      if (ti_temp1)\n-\t\ttemp1 = gen_rtx_REG (DImode, REGNO (temp1) + 1);\n-\t      else\n-\t\tabort();\n+\t      /* It is possible that one of the registers we got for operands[2]\n+\t\t might coincide with that of operands[0] (which is why we made\n+\t\t it TImode).  Pick the other one to use as our scratch.  */\n+\t      if (rtx_equal_p (temp, op0))\n+\t\t{\n+\t\t  if (ti_temp)\n+\t\t    temp = gen_rtx_REG (DImode, REGNO (temp) + 1);\n+\t\t  else\n+\t\t    abort();\n+\t\t}\n+\t      temp1 = op0;\n+\t      temp2 = temp;  /* op0 is _not_ allowed, see above.  */\n+\t      temp3 = op0;\n+\t      temp4 = op0;\n+\t      temp5 = op0;\n+\t    }\n+\t  else\n+\t    {\n+\t      temp1 = gen_reg_rtx (DImode);\n+\t      temp2 = gen_reg_rtx (DImode);\n+\t      temp3 = gen_reg_rtx (DImode);\n+\t      temp4 = gen_reg_rtx (DImode);\n+\t      temp5 = gen_reg_rtx (DImode);\n \t    }\n \n-\t  emit_insn (gen_embmedany_textuhi (op0, op1));\n-\t  emit_insn (gen_embmedany_texthi  (temp1, op1));\n-\t  emit_insn (gen_embmedany_textulo (op0, op0, op1));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t\t  gen_rtx_ASHIFT (DImode, op0, GEN_INT (32))));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, op0,\n-\t\t\t\t  gen_rtx_PLUS (DImode, op0, temp1)));\n-\t  emit_insn (gen_embmedany_textlo  (op0, op0, op1));\n+\t  emit_insn (gen_embmedany_textuhi (temp1, op1));\n+\t  emit_insn (gen_embmedany_texthi  (temp2, op1));\n+\t  emit_insn (gen_embmedany_textulo (temp3, temp1, op1));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp4,\n+\t\t\t\t  gen_rtx_ASHIFT (DImode, temp3, GEN_INT (32))));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, temp5,\n+\t\t\t\t  gen_rtx_PLUS (DImode, temp4, temp2)));\n+\t  emit_insn (gen_embmedany_textlo  (op0, temp5, op1));\n \t}\n       break;\n \n@@ -1947,7 +2014,7 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n   unsigned HOST_WIDE_INT high_bits, low_bits;\n   int lowest_bit_set, highest_bit_set;\n   int all_bits_between_are_set;\n-  rtx temp;\n+  rtx temp = 0;\n \n   /* Sanity check that we know what we are working with.  */\n   if (! TARGET_ARCH64)\n@@ -1963,8 +2030,6 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n \n   if (reload_in_progress || reload_completed)\n     temp = op0;\n-  else\n-    temp = gen_reg_rtx (DImode);\n \n   if (GET_CODE (op1) != CONST_DOUBLE\n       && GET_CODE (op1) != CONST_INT)\n@@ -1973,6 +2038,9 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n       return;\n     }\n \n+  if (! temp)\n+    temp = gen_reg_rtx (DImode);\n+\n   if (GET_CODE (op1) == CONST_DOUBLE)\n     {\n #if HOST_BITS_PER_WIDE_INT == 64"}, {"sha": "8c6514a918f9793ea44a4aa70ae492d668fe7993", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "patch": "@@ -1,3 +1,7 @@\n+2004-07-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* gcc.c-torture/compile/20040708-1.c: New test.\n+\n 2004-07-08  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/16169"}, {"sha": "4a553917e44525d58be02fabb2da954d4936c664", "filename": "gcc/testsuite/gcc.c-torture/compile/20040708-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040708-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040708-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20040708-1.c?ref=1d511ed5fc76892c3f5dca6b78a1b7254bc15bd1", "patch": "@@ -0,0 +1,68 @@\n+/* PR rtl-optimization/16199 */\n+/* Origin: Olaf Klein <oklein@smallo.ruhr.de> */\n+\n+typedef enum {\n+    APR_LOCK_FCNTL,\n+    APR_LOCK_FLOCK,\n+    APR_LOCK_SYSVSEM,\n+    APR_LOCK_PROC_PTHREAD,\n+    APR_LOCK_POSIXSEM,\n+    APR_LOCK_DEFAULT\n+} apr_lockmech_e;\n+\n+struct apr_proc_mutex_unix_lock_methods_t {\n+    unsigned int flags;\n+    const char *name;\n+};\n+\n+typedef struct apr_proc_mutex_unix_lock_methods_t apr_proc_mutex_unix_lock_methods_t;\n+\n+extern const apr_proc_mutex_unix_lock_methods_t apr_proc_mutex_unix_sysv_methods;\n+\n+struct apr_proc_mutex_t {\n+    const apr_proc_mutex_unix_lock_methods_t *inter_meth;\n+    int curr_locked;\n+    char *fname;\n+};\n+\n+typedef struct apr_proc_mutex_t apr_proc_mutex_t;\n+\n+extern const apr_proc_mutex_unix_lock_methods_t apr_proc_mutex_unix_proc_pthread_methods;\n+\n+extern const apr_proc_mutex_unix_lock_methods_t apr_proc_mutex_unix_fcntl_methods;\n+\n+static int proc_mutex_choose_method(apr_proc_mutex_t *new_mutex, apr_lockmech_e mech)\n+{\n+    switch (mech) {\n+    case APR_LOCK_FCNTL:\n+        new_mutex->inter_meth = &apr_proc_mutex_unix_fcntl_methods;\n+        break;\n+    case APR_LOCK_FLOCK:\n+        return ((20000 + 50000) + 23);\n+        break;\n+    case APR_LOCK_SYSVSEM:\n+        new_mutex->inter_meth = &apr_proc_mutex_unix_sysv_methods;\n+        break;\n+    case APR_LOCK_POSIXSEM:\n+        return ((20000 + 50000) + 23);\n+        break;\n+    case APR_LOCK_PROC_PTHREAD:\n+        new_mutex->inter_meth = &apr_proc_mutex_unix_proc_pthread_methods;\n+        break;\n+    case APR_LOCK_DEFAULT:\n+        new_mutex->inter_meth = &apr_proc_mutex_unix_proc_pthread_methods;\n+        break;\n+    default:\n+        return ((20000 + 50000) + 23);\n+    }\n+    return 0;\n+}\n+\n+const char* apr_proc_mutex_defname(void)\n+{\n+    apr_proc_mutex_t mutex;\n+\n+    if (proc_mutex_choose_method(&mutex, APR_LOCK_DEFAULT) != 0) {\n+        return \"unknown\";\n+    }\n+}"}]}