{"sha": "eff71ab0ab951b6711adf0adac40a0aca6b8e633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZmNzFhYjBhYjk1MWI2NzExYWRmMGFkYWM0MGEwYWNhNmI4ZTYzMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-06-01T18:25:34Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-06-01T18:25:34Z"}, "message": "cp-tree.h (TYPE_FOR_JAVA): New macro.\n\nd\n\t* cp-tree.h (TYPE_FOR_JAVA):  New macro.\n\t* decl.c, cp-tree.h (java_byte_type_node, java_short_type_node,\n\tjava_int_type_node, java_long_type_node, java_float_type_node,\n\tjava_double_type_node, java_char_type_node, java_boolean_type_node):\n\tNew \"primitive\" types, with predefined names __java_byte etc.\n\t(record_builtin_java_type):  New function.\n\t(init_decl_processing):  Make Java types with record_builtin_java_type.\n\t(pushtag, grokdeclarator):  Set TYPE_FOR_JAVA if in extern \"JAVA\".\n\t(xref_baseypes):  If base class was TYPE_FOR_JAVA, so is this class.\n\t(grokfndecl):  Call check_java_method for Java classes.\n\t* method.c (is_java_type):  Removed.  Replaced with TYPE_FOR_JAVA.\n\t(process_overload_item):  Match types against specific\n\tjava_XX_type_node types, rather than using is_java_type.\n\t* class.c (finish_struct_1):  Don't add default copy constructor\n\tor operator= if TYPE_FOR_JAVA.\n\t(pop_lang_conext):  Restore strict_prototyp proper if Java.\n\t* decl2.c (acceptable_java_type, check_java_method):  New functions.\n\t* pt.c (instantiate_class_template):  Copy TYPE_FOR_JAVA from pattern.\n\t(tsubst):  Move common statement after if statement.\n\t* typeck.c (comptypes):  If strict, TYPE_FOR_JAVA must match.\n\nFrom-SVN: r20174", "tree": {"sha": "ff9d047dfb4a9252df13cea5753e77ed9ccd700e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff9d047dfb4a9252df13cea5753e77ed9ccd700e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eff71ab0ab951b6711adf0adac40a0aca6b8e633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff71ab0ab951b6711adf0adac40a0aca6b8e633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff71ab0ab951b6711adf0adac40a0aca6b8e633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff71ab0ab951b6711adf0adac40a0aca6b8e633/comments", "author": null, "committer": null, "parents": [{"sha": "44ec7e59cc237149d055849fd2c15c0b3731a387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44ec7e59cc237149d055849fd2c15c0b3731a387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44ec7e59cc237149d055849fd2c15c0b3731a387"}], "stats": {"total": 128, "additions": 118, "deletions": 10}, "files": [{"sha": "900253d408cbb78e5ebe6e613b49063446fe8551", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=eff71ab0ab951b6711adf0adac40a0aca6b8e633", "patch": "@@ -3601,7 +3601,7 @@ finish_struct_1 (t, warn_anon)\n     }\n \n   /* Create default copy constructor, if needed.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! IS_SIGNATURE (t))\n+  if (! TYPE_HAS_INIT_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n     {\n       /* ARM 12.18: You get either X(X&) or X(const X&), but\n \t not both.  --Chip  */\n@@ -3616,7 +3616,7 @@ finish_struct_1 (t, warn_anon)\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n \n-  if (! TYPE_HAS_ASSIGN_REF (t) && ! IS_SIGNATURE (t))\n+  if (! TYPE_HAS_ASSIGN_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n     {\n       tree default_fn = cons_up_default_function (t, name,\n \t\t\t\t\t\t  5 + no_const_asn_ref);\n@@ -4915,7 +4915,8 @@ void\n pop_lang_context ()\n {\n   current_lang_name = *--current_lang_stack;\n-  if (current_lang_name == lang_name_cplusplus)\n+  if (current_lang_name == lang_name_cplusplus\n+      || current_lang_name == lang_name_java)\n     strict_prototype = strict_prototypes_lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n     strict_prototype = strict_prototypes_lang_c;"}, {"sha": "8e861b039ef5afb4bcd892f7319ed2a501db96ab", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eff71ab0ab951b6711adf0adac40a0aca6b8e633", "patch": "@@ -234,6 +234,15 @@ tree unsigned_intSI_type_node;\n tree unsigned_intDI_type_node;\n tree unsigned_intTI_type_node;\n \n+tree java_byte_type_node;\n+tree java_short_type_node;\n+tree java_int_type_node;\n+tree java_long_type_node;\n+tree java_float_type_node;\n+tree java_double_type_node;\n+tree java_char_type_node;\n+tree java_boolean_type_node;\n+\n /* A VOID_TYPE node, and the same, packaged in a TREE_LIST.  */\n \n tree void_type_node, void_list_node;\n@@ -2227,6 +2236,8 @@ pushtag (name, type, globalize)\n \t    {\n \t      newdecl = 1;\n \t      d = build_decl (TYPE_DECL, name, type);\n+\t      if (current_lang_name == lang_name_java)\n+\t\tTYPE_FOR_JAVA (type) = 1;\n \t      SET_DECL_ARTIFICIAL (d);\n \t      if (! in_class)\n \t\tset_identifier_type_value_with_scope (name, type, b);\n@@ -5055,6 +5066,37 @@ record_builtin_type (rid_index, name, type)\n     }\n }\n \n+/* Record one of the standard Java types.\n+ * Declare it as having the given NAME.\n+ * If SIZE > 0, it is the size of one of the integral types;\n+ * otherwise it is the negative of the size of one of the other types.  */\n+\n+static tree\n+record_builtin_java_type (name, size)\n+     char *name;\n+     int size;\n+{\n+  tree type, decl;\n+  if (size > 0)\n+    type = make_signed_type (size);\n+  else if (size > -32)\n+    { /* \"__java_char\" or \"\"__java_boolean\". */\n+      type = make_unsigned_type (-size);\n+      /*if (size == -1)\tTREE_SET_CODE (type, BOOLEAN_TYPE);*/\n+    }\n+  else\n+    { /* \"__java_float\" or \"\"__java_double\". */\n+      type = make_node (REAL_TYPE);\n+      TYPE_PRECISION (type) = - size;\n+      layout_type (type);\n+    }\n+  record_builtin_type (RID_MAX, name, type);\n+  decl = TYPE_NAME (type);\n+  DECL_IGNORED_P (decl) = 1;\n+  TYPE_FOR_JAVA (type) = 1;\n+  return type;\n+}\n+\n /* Push a type into the namespace so that the back-ends ignore it. */\n \n static void\n@@ -5329,6 +5371,15 @@ init_decl_processing ()\n   TREE_TYPE (complex_long_double_type_node) = long_double_type_node;\n   layout_type (complex_long_double_type_node);\n \n+  java_byte_type_node = record_builtin_java_type (\"__java_byte\", 8);\n+  java_short_type_node = record_builtin_java_type (\"__java_short\", 16);\n+  java_int_type_node = record_builtin_java_type (\"__java_int\", 32);\n+  java_long_type_node = record_builtin_java_type (\"__java_long\", 64);\n+  java_float_type_node = record_builtin_java_type (\"__java_float\", -32);\n+  java_double_type_node = record_builtin_java_type (\"__java_double\", -64);\n+  java_char_type_node = record_builtin_java_type (\"__java_char\", -16);\n+  java_boolean_type_node = record_builtin_java_type (\"__java_boolean\", -1);\n+\n   integer_zero_node = build_int_2 (0, 0);\n   TREE_TYPE (integer_zero_node) = integer_type_node;\n   integer_one_node = build_int_2 (1, 0);\n@@ -7617,7 +7668,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t\t\t\t    2 * (funcdef_flag != 0) + \n \t\t\t\t\t    4 * (friendp != 0));\n \n-      if (check)\n+      if ((! TYPE_FOR_JAVA (ctype) || check_java_method (ctype, decl))\n+\t  && check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n \n@@ -7662,8 +7714,9 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t\t\t\t\t    template_count, \n \t\t\t\t\t    2 * (funcdef_flag != 0) + \n \t\t\t\t\t    4 * (friendp != 0));\n-\n-      if (ctype != NULL_TREE && check)\n+      if (ctype != NULL_TREE\n+\t  && (! TYPE_FOR_JAVA (ctype) || check_java_method (ctype, decl))\n+\t  && check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n \n@@ -9572,6 +9625,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t in typenames, fields or parameters.  */\n       if (constp || volatilep)\n \ttype = cp_build_type_variant (type, constp, volatilep);\n+      if (current_lang_name == lang_name_java)\n+\tTYPE_FOR_JAVA (type) = 1;\n \n       if (decl_context == FIELD)\n \t{\n@@ -9582,8 +9637,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  if (IS_SIGNATURE (current_class_type) && opaque_typedef)\n \t    SIGNATURE_HAS_OPAQUE_TYPEDECLS (current_class_type) = 1;\n \t}\n-      else if (current_lang_name == lang_name_java)\n-\tdecl = build_lang_decl (TYPE_DECL, declarator, type);\n       else\n \t{\n \t  /* Make sure this typedef lives as long as its type,\n@@ -11249,6 +11302,10 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      continue;\n \t    }\n \n+\t  if (TYPE_FOR_JAVA (basetype)\n+\t      && current_lang_stack == current_lang_base)\n+\t    TYPE_FOR_JAVA (ref) = 1;\n+\n \t  /* Note that the BINFO records which describe individual\n \t     inheritances are *not* shared in the lattice!  They\n \t     cannot be shared because a given baseclass may be"}, {"sha": "77aaa2b7c0c563cf01e58fa1082d76b435b70192", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=eff71ab0ab951b6711adf0adac40a0aca6b8e633", "patch": "@@ -1375,6 +1375,56 @@ check_member_template (tmpl)\n     cp_error (\"template declaration of `%#D'\", decl);\n }\n \n+/* Return true iff TYPE is a valid Java parameter or return type. */\n+\n+int\n+acceptable_java_type (type)\n+     tree type;\n+{\n+  if (TREE_CODE (type) == VOID_TYPE || TYPE_FOR_JAVA (type))\n+    return 1;\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      type = TREE_TYPE (type);\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  complete_type (type);\n+\t  return TYPE_FOR_JAVA (type);\n+\t}\n+    }\n+  return 0;\n+}\n+\n+/* For a METHOD in a Java class CTYPE, return 1 if\n+   the parameter and return types are valid Java types.\n+   Otherwise, print appropriate error messages, and return 0.  */\n+\n+int\n+check_java_method (ctype, method)\n+     tree ctype, method;\n+{\n+  int jerr = 0;\n+  tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (method));\n+  tree ret_type = TREE_TYPE (TREE_TYPE (method));\n+  if (! acceptable_java_type (ret_type))\n+    {\n+      cp_error (\"Java method '%D' has non-Java return type `%T'\",\n+\t\tmethod, ret_type);\n+      jerr++;\n+    }\n+  for (; arg_types != NULL_TREE; arg_types = TREE_CHAIN (arg_types))\n+    {\n+      tree type = TREE_VALUE (arg_types);\n+      if (! acceptable_java_type (type))\n+\t{\n+\t  cp_error (\"Java method '%D' has non-Java parameter type `%T'\",\n+\t\t    method, type);\n+\t  jerr++;\n+\t}\n+    }\n+  return jerr ? 0 : 1;\n+}\n+\n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n    CNAME is the same here as it is for grokclassfn above.  */"}, {"sha": "765f8368c5fac729606dece1bd9488c9c156687d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eff71ab0ab951b6711adf0adac40a0aca6b8e633/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=eff71ab0ab951b6711adf0adac40a0aca6b8e633", "patch": "@@ -3749,6 +3749,7 @@ instantiate_class_template (type)\n     = TYPE_USES_VIRTUAL_BASECLASSES (pattern);\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);\n   TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n+  TYPE_FOR_JAVA (type) = TYPE_FOR_JAVA (pattern); /* For libjava's JArray<T> */\n \n   CLASSTYPE_LOCAL_TYPEDECLS (type) = CLASSTYPE_LOCAL_TYPEDECLS (pattern);\n \n@@ -4498,14 +4499,13 @@ tsubst (t, args, in_decl)\n \t    else\n \t      member = 1;\n \t    ctx = tsubst (DECL_CLASS_CONTEXT (t), args, t);\n-\t    type = tsubst (type, args, in_decl);\n \t  }\n \telse\n \t  {\n \t    member = 0;\n \t    ctx = NULL_TREE;\n-\t    type = tsubst (type, args, in_decl);\n \t  }\n+\ttype = tsubst (type, args, in_decl);\n \n \t/* If we are instantiating a specialization, get the other args.  */\n \tif (DECL_TEMPLATE_INFO (t) != NULL_TREE)"}]}