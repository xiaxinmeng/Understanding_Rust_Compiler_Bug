{"sha": "37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiODcxNWI1YmQ2N2UxZWU2OWVjMWI4YjFiZTAxNTNhMTEwNmNlZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-08-04T17:06:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-08-04T17:06:10Z"}, "message": "gcov.c (bb_file_time): New static variable.\n\n\t* gcov.c (bb_file_time): New static variable.\n\t(object_directory): May also be object file.\n\t(preserve_paths): New static variable.\n\t(print_usage): Adjust.\n\t(options): Adjust.\n\t(process_args): Adjust.\n\t(open_files): Simplify. Cope when OBJECT_DIRECTORY is an object\n\tfile. Find modification date on bb file.\n\t(read_profile): Don't rewind a NULL file.\n\t(format_hwint): New static function.\n\t(function_summary): Use format_hwint.\n\t(output_data): SOURCE_FILE_NAME is never relative to\n\tOBJECT_DIRECTORY. Use format_hwint. Adjust gcov file name\n\tmangling. Adjust output format to make it more machine readable.\n\t* doc/gcov.texi: Document & clarify semantics.\n\nFrom-SVN: r56028", "tree": {"sha": "72b01de3cc426fed85947ddbf231d59f0bb124a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72b01de3cc426fed85947ddbf231d59f0bb124a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/comments", "author": null, "committer": null, "parents": [{"sha": "d500c5d7d7aeb880cc8cc7eba3ee61e3b73951d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d500c5d7d7aeb880cc8cc7eba3ee61e3b73951d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d500c5d7d7aeb880cc8cc7eba3ee61e3b73951d8"}], "stats": {"total": 765, "additions": 441, "deletions": 324}, "files": [{"sha": "766d1bc51496be0deeded6219ac4504084307a59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "patch": "@@ -1,3 +1,21 @@\n+2002-08-04  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcov.c (bb_file_time): New static variable.\n+\t(object_directory): May also be object file.\n+\t(preserve_paths): New static variable.\n+\t(print_usage): Adjust.\n+\t(options): Adjust.\n+\t(process_args): Adjust.\n+\t(open_files): Simplify. Cope when OBJECT_DIRECTORY is an object\n+\tfile. Find modification date on bb file.\n+\t(read_profile): Don't rewind a NULL file.\n+\t(format_hwint): New static function.\n+\t(function_summary): Use format_hwint.\n+\t(output_data): SOURCE_FILE_NAME is never relative to\n+\tOBJECT_DIRECTORY. Use format_hwint. Adjust gcov file name\n+\tmangling. Adjust output format to make it more machine readable.\n+\t* doc/gcov.texi: Document & clarify semantics.\n+\t\n 2002-08-04  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/include/gcc-common.texi (version-GCC): Increase to 3.3."}, {"sha": "070a08cada730b0495a6c0895b984d80de69fc7e", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 121, "deletions": 67, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "patch": "@@ -1,10 +1,11 @@\n-@c Copyright (C) 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n+@c Copyright (C) 1996, 1997, 1999, 2000, 2001,\n+@c 2002 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n @ignore\n @c man begin COPYRIGHT\n-Copyright @copyright{} 1996, 1997, 1999, 2000, 2001 Free Software Foundation, Inc.\n+Copyright @copyright{} 1996, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n Permission is granted to copy, distribute and/or modify this document\n under the terms of the GNU Free Documentation License, Version 1.1 or\n@@ -47,12 +48,13 @@ test code coverage in your programs.\n @c man begin DESCRIPTION\n \n @command{gcov} is a test coverage program.  Use it in concert with GCC\n-to analyze your programs to help create more efficient, faster\n-running code.  You can use @command{gcov} as a profiling tool to help\n-discover where your optimization efforts will best affect your code.  You\n-can also use @command{gcov} along with the other profiling tool,\n-@command{gprof}, to assess which parts of your code use the greatest amount\n-of computing time.\n+to analyze your programs to help create more efficient, faster running\n+code and to discover untested parts of your program.  You can use\n+@command{gcov} as a profiling tool to help discover where your\n+optimization efforts will best affect your code.  You can also use\n+@command{gcov} along with the other profiling tool, @command{gprof}, to\n+assess which parts of your code use the greatest amount of computing\n+time.\n \n Profiling tools help you analyze your code's performance.  Using a\n profiler such as @command{gcov} or @command{gprof}, you can find out some\n@@ -117,10 +119,13 @@ gcov @r{[}@var{options}@r{]} @var{sourcefile}\n @ignore\n @c man begin SYNOPSIS\n gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n-     [@option{-b}|@option{--branch-probabilities}] [@option{-c}|@option{--branch-counts}]\n-     [@option{-n}|@option{--no-output}] [@option{-l}|@option{--long-file-names}]\n+     [@option{-b}|@option{--branch-probabilities}]\n+     [@option{-c}|@option{--branch-counts}]\n+     [@option{-n}|@option{--no-output}]\n+     [@option{-l}|@option{--long-file-names}]\n+     [@option{-p}|@option{--preserve-paths}]\n      [@option{-f}|@option{--function-summaries}]\n-     [@option{-o}|@option{--object-directory} @var{directory}] @var{sourcefile}\n+     [@option{-o}|@option{--object-directory} @var{directory|file}] @var{sourcefile}\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7), gcc(1) and the Info entry for @file{gcc}.\n@@ -159,31 +164,70 @@ Do not create the @command{gcov} output file.\n Create long file names for included source files.  For example, if the\n header file @file{x.h} contains code, and was included in the file\n @file{a.c}, then running @command{gcov} on the file @file{a.c} will produce\n-an output file called @file{a.c.x.h.gcov} instead of @file{x.h.gcov}.\n+an output file called @file{a.c##x.h.gcov} instead of @file{x.h.gcov}.\n This can be useful if @file{x.h} is included in multiple source files.\n \n+@item -p\n+@itemx --preserve-paths\n+Preserve complete path information in the names of generated\n+@file{.gcov} files. Without this option, just the filename component is\n+used. With this option, all directories are used, with '/' characters\n+translated to '#' characters, '.' directory components removed and '..'\n+components renamed to '^'. This is useful if sourcefiles are in several\n+different directories. It also affects the @samp{-l} option.\n+\n @item -f\n @itemx --function-summaries\n Output summaries for each function in addition to the file level summary.\n \n-@item -o @var{directory}\n+@item -o @var{directory|file}\n @itemx --object-directory @var{directory}\n-The directory where the object files live.  Gcov will search for @file{.bb},\n-@file{.bbg}, and @file{.da} files in this directory.\n+@itemx --object-file @var{file}\n+Specify either the directory containing the gcov data files, or the\n+object path name. The @file{.bb}, @file{.bbg}, and\n+@file{.da} data files are searched for using this option. If a directory\n+is specified, the data files are in that directory and named after the\n+source file name, without its extension. If a file is specified here,\n+the data files are named after that file, without its extension. If this\n+option is not supplied, it defaults to the current directory.\n+\n @end table\n \n-@need 3000\n+Gcov should be run with the current directory the same as that when you\n+invoked the compiler. Otherwise it will not be able to locate the source\n+files. Gcov produces files called @file{@var{mangledname}.gcov} in the\n+current directory. These contain the coverage information of the source\n+file they correspond to. One @file{.gcov} file is produced for each\n+source file containing code, which was compiled to produce the data\n+files. The @file{.gcov} files contain the ':' separated fields along\n+with program source code. The format is\n+\n+@smallexample\n+@var{execution_count}:@var{line_number}:@var{source line text}\n+@end smallexample\n+\n+Additional block information may succeed each line, when requested by\n+command line option. The @var{execution_count} is @samp{-} for lines\n+containing no code and @samp{#####} for lines which were never\n+executed. Some lines of information at the start have @var{line_number}\n+of zero.\n+\n+When printing percentages, 0% and 100% are only printed when the values\n+are @emph{exactly} 0% and 100% respectively. Other values which would\n+conventionally be rounded to 0% or 100% are instead printed as the\n+nearest non-boundary value.\n+\n When using @command{gcov}, you must first compile your program with two\n special GCC options: @samp{-fprofile-arcs -ftest-coverage}.\n This tells the compiler to generate additional information needed by\n gcov (basically a flow graph of the program) and also includes\n additional code in the object files for generating the extra profiling\n information needed by gcov.  These additional files are placed in the\n-directory where the source code is located.\n+directory where the object file is located.\n \n Running the program will cause profile output to be generated.  For each\n source file compiled with @option{-fprofile-arcs}, an accompanying @file{.da}\n-file will be placed in the source directory.\n+file will be placed in the object file directory.\n \n Running @command{gcov} with your program's source file names as arguments\n will now produce a listing of the code along with frequency of execution\n@@ -194,66 +238,76 @@ is what you see when you use the basic @command{gcov} facility:\n $ gcc -fprofile-arcs -ftest-coverage tmp.c\n $ a.out\n $ gcov tmp.c\n- 87.50% of 8 source lines executed in file tmp.c\n+90.00% of 10 source lines executed in file tmp.c\n Creating tmp.c.gcov.\n @end smallexample\n \n The file @file{tmp.c.gcov} contains output from @command{gcov}.\n Here is a sample:\n \n @smallexample\n-                main()\n-                @{\n-           1      int i, total;\n-\n-           1      total = 0;\n-\n-          11      for (i = 0; i < 10; i++)\n-          10        total += i;\n-\n-           1      if (total != 45)\n-      ######        printf (\"Failure\\n\");\n-                  else\n-           1        printf (\"Success\\n\");\n-           1    @}\n+        -:    0:Source:tmp.c\n+        -:    0:Object:tmp.bb\n+        -:    1:#include <stdio.h>\n+        -:    2:\n+        -:    3:int main (void)\n+        1:    4:@{\n+        1:    5:  int i, total;\n+        -:    6:  \n+        1:    7:  total = 0;\n+        -:    8:  \n+       11:    9:  for (i = 0; i < 10; i++)\n+       10:   10:    total += i;\n+        -:   11:  \n+        1:   12:  if (total != 45)\n+    #####:   13:    printf (\"Failure\\n\");\n+        -:   14:  else\n+        1:   15:    printf (\"Success\\n\");\n+        1:   16:  return 0;\n+        1:   17:@}\n @end smallexample\n \n @need 450\n When you use the @option{-b} option, your output looks like this:\n \n @smallexample\n $ gcov -b tmp.c\n- 87.50% of 8 source lines executed in file tmp.c\n- 80.00% of 5 branches executed in file tmp.c\n- 80.00% of 5 branches taken at least once in file tmp.c\n- 50.00% of 2 calls executed in file tmp.c\n+90.00% of 10 source lines executed in file tmp.c\n+80.00% of 5 branches executed in file tmp.c\n+80.00% of 5 branches taken at least once in file tmp.c\n+50.00% of 2 calls executed in file tmp.c\n Creating tmp.c.gcov.\n @end smallexample\n \n Here is a sample of a resulting @file{tmp.c.gcov} file:\n \n @smallexample\n-                main()\n-                @{\n-           1      int i, total;\n-\n-           1      total = 0;\n-\n-          11      for (i = 0; i < 10; i++)\n-branch 0 taken = 91%\n-branch 1 taken = 100%\n-branch 2 taken = 100%\n-          10        total += i;\n-\n-           1      if (total != 45)\n-branch 0 taken = 100%\n-      ######        printf (\"Failure\\n\");\n-call 0 never executed\n-branch 1 never executed\n-                  else\n-           1        printf (\"Success\\n\");\n-call 0 returns = 100%\n-           1    @}\n+        -:    0:Source:tmp.c\n+        -:    0:Object:tmp.bb\n+        -:    1:#include <stdio.h>\n+        -:    2:\n+        -:    3:int main (void)\n+        1:    4:@{\n+        1:    5:  int i, total;\n+        -:    6:  \n+        1:    7:  total = 0;\n+        -:    8:  \n+       11:    9:  for (i = 0; i < 10; i++)\n+branch  0: taken 90%\n+branch  1: taken 100%\n+branch  2: taken 100%\n+       10:   10:    total += i;\n+        -:   11:  \n+        1:   12:  if (total != 45)\n+branch  0: taken 100%\n+    #####:   13:    printf (\"Failure\\n\");\n+call    0: never executed\n+branch  1: never executed\n+        -:   14:  else\n+        1:   15:    printf (\"Success\\n\");\n+call    0: returns 100%\n+        1:   16:  return 0;\n+        1:   17:@}\n @end smallexample\n \n For each basic block, a line is printed after the last line of the basic\n@@ -286,11 +340,11 @@ provide more accurate long-term information over a large number of\n program runs.\n \n The data in the @file{.da} files is saved immediately before the program\n-exits.  For each source file compiled with @option{-fprofile-arcs}, the profiling\n-code first attempts to read in an existing @file{.da} file; if the file\n-doesn't match the executable (differing number of basic block counts) it\n-will ignore the contents of the file.  It then adds in the new execution\n-counts and finally writes the data to the file.\n+exits.  For each source file compiled with @option{-fprofile-arcs}, the\n+profiling code first attempts to read in an existing @file{.da} file; if\n+the file doesn't match the executable (differing number of basic block\n+counts) it will ignore the contents of the file.  It then adds in the\n+new execution counts and finally writes the data to the file.\n \n @node Gcov and Optimization\n @section Using @command{gcov} with GCC Optimization\n@@ -319,10 +373,10 @@ the @command{gcov} output looks like this if you compiled the program with\n optimization:\n \n @smallexample\n-      100  if (a != b)\n-      100    c = 1;\n-      100  else\n-      100    c = 0;\n+      100:   12:if (a != b)\n+      100:   13:  c = 1;\n+      100:   14:else\n+      100:   15:  c = 0;\n @end smallexample\n \n The output shows that this block of code, combined by optimization,"}, {"sha": "9925e95999bbbb97ebd5b5cf7568cf1cc930dd8a", "filename": "gcc/gcov.c", "status": "modified", "additions": 302, "deletions": 257, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37b8715b5bd67e1ee69ec1b8b1be0153a1106ced/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=37b8715b5bd67e1ee69ec1b8b1be0153a1106ced", "patch": "@@ -160,6 +160,10 @@ struct bb_info_list {\n \n static struct bb_info_list *bb_graph_list = 0;\n \n+/* Modification time of data files. */\n+\n+static time_t bb_file_time;\n+\n /* Name and file pointer of the input file for the basic block graph.  */\n \n static char *bbg_file_name;\n@@ -212,11 +216,15 @@ static int output_long_names = 0;\n \n static int output_function_summary = 0;\n \n-/* Object directory file prefix.  This is the directory where .bb and .bbg\n-   files are looked for, if non-zero.  */\n+/* Object directory file prefix.  This is the directory/file\n+   where .bb and .bbg files are looked for, if non-zero.  */\n \n static char *object_directory = 0;\n \n+/* Preserve all pathname components. Needed when object files and\n+   source files are in subdirectories.  */\n+static int preserve_paths = 0;\n+\n /* Output the number of times a branch was taken as opposed to the percentage\n    of times it was taken.  Turned on by the -c option */\n \n@@ -238,6 +246,7 @@ static void solve_program_flow_graph PARAMS ((struct bb_info_list *));\n static void calculate_branch_probs PARAMS ((struct bb_info_list *, int,\n \t\t\t\t\t    struct arcdata **, int));\n static void function_summary PARAMS ((void));\n+static const char *format_hwint PARAMS ((HOST_WIDEST_INT, HOST_WIDEST_INT, int));\n \n extern int main PARAMS ((int, char **));\n \n@@ -304,7 +313,8 @@ print_usage (error_p)\n   fnotice (file, \"  -l, --long-file-names           Use long output file names for included\\n\\\n                                     source files\\n\");\n   fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n-  fnotice (file, \"  -o, --object-directory OBJDIR   Search for object files in OBJDIR\\n\");\n+  fnotice (file, \"  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\\n\");\n+  fnotice (file, \"  -p, --preserve-paths            Preserve all pathname components\\n\");\n   fnotice (file, \"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n \t   GCCBUGURL);\n   exit (status);\n@@ -332,7 +342,9 @@ static const struct option options[] =\n   { \"no-output\",            no_argument,       NULL, 'n' },\n   { \"long-file-names\",      no_argument,       NULL, 'l' },\n   { \"function-summaries\",   no_argument,       NULL, 'f' },\n-  { \"object-directory\",     required_argument, NULL, 'o' }\n+  { \"preserve-paths\",       no_argument,       NULL, 'p' },\n+  { \"object-directory\",     required_argument, NULL, 'o' },\n+  { \"object-file\",          required_argument, NULL, 'o' },\n };\n \n /* Parse the command line.  */\n@@ -344,7 +356,7 @@ process_args (argc, argv)\n {\n   int opt;\n \n-  while ((opt = getopt_long (argc, argv, \"hvbclnfo:\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"hvbclnfo:p\", options, NULL)) != -1)\n     {\n       switch (opt)\n \t{\n@@ -372,6 +384,9 @@ process_args (argc, argv)\n \tcase 'o':\n \t  object_directory = optarg;\n \t  break;\n+\tcase 'p':\n+\t  preserve_paths = 1;\n+\t  break;\n \tdefault:\n \t  print_usage (true);\n \t  /* print_usage will exit.  */\n@@ -385,77 +400,66 @@ process_args (argc, argv)\n }\n \n \n-/* Find and open the .bb, .da, and .bbg files.  */\n+/* Find and open the .bb, .da, and .bbg files. If OBJECT_DIRECTORY is\n+   not specified, these are looked for in the current directory, and\n+   named from the basename of the input_file_name sans extension. If\n+   OBJECT_DIRECTORY is specified and is a directory, the files are in\n+   that directory, but named from the basename of the input_file_name,\n+   sans extension. Otherwise OBJECT_DIRECTORY is taken to be the name\n+   of the object *file*, and the data files are named from that.  */\n \n static void\n open_files ()\n {\n-  int count, objdir_count;\n   char *cptr;\n-\n-  /* Determine the names of the .bb, .bbg, and .da files.  Strip off the\n-     extension, if any, and append the new extensions.  */\n-  count = strlen (input_file_name);\n-  if (object_directory)\n-    objdir_count = strlen (object_directory);\n-  else\n-    objdir_count = 0;\n-\n-  da_file_name = xmalloc (count + objdir_count + 4);\n-  bb_file_name = xmalloc (count + objdir_count + 4);\n-  bbg_file_name = xmalloc (count + objdir_count + 5);\n-\n-  if (object_directory)\n+  char *name;\n+  int length = strlen (input_file_name);\n+  int base;\n+  \n+  if (object_directory && object_directory[0])\n     {\n-      strcpy (da_file_name, object_directory);\n-      strcpy (bb_file_name, object_directory);\n-      strcpy (bbg_file_name, object_directory);\n-\n-      if (object_directory[objdir_count - 1] != '/')\n-\t{\n-\t  strcat (da_file_name, \"/\");\n-\t  strcat (bb_file_name, \"/\");\n-\t  strcat (bbg_file_name, \"/\");\n-\t}\n-\n-      cptr = strrchr (input_file_name, '/');\n-      if (cptr)\n-\t{\n-\t  strcat (da_file_name, cptr + 1);\n-\t  strcat (bb_file_name, cptr + 1);\n-\t  strcat (bbg_file_name, cptr + 1);\n-\t}\n-      else\n-\t{\n-\t  strcat (da_file_name, input_file_name);\n-\t  strcat (bb_file_name, input_file_name);\n-\t  strcat (bbg_file_name, input_file_name);\n-\t}\n+      struct stat status;\n+\n+      length += strlen (object_directory) + 2;\n+      name = xmalloc (length);\n+      name[0] = 0;\n+      \n+      base = !stat (object_directory, &status) && S_ISDIR (status.st_mode);\n+      strcat (name, object_directory);\n+      if (base && name[strlen (name) - 1] != '/')\n+\tstrcat (name, \"/\");\n     }\n   else\n     {\n-      strcpy (da_file_name, input_file_name);\n-      strcpy (bb_file_name, input_file_name);\n-      strcpy (bbg_file_name, input_file_name);\n+      name = xmalloc (length + 1);\n+      name[0] = 0;\n+      base = 1;\n     }\n+  \n+  if (base)\n+    {\n+      /* Append source file name */\n+      cptr = strrchr (input_file_name, '/');\n+      cptr = cptr ? cptr + 1 : input_file_name;\n \n-  cptr = strrchr (bb_file_name, '.');\n-  if (cptr)\n-    strcpy (cptr, \".bb\");\n-  else\n-    strcat (bb_file_name, \".bb\");\n-\n-  cptr = strrchr (da_file_name, '.');\n-  if (cptr)\n-    strcpy (cptr, \".da\");\n-  else\n-    strcat (da_file_name, \".da\");\n-\n-  cptr = strrchr (bbg_file_name, '.');\n+      strcat (name, cptr);\n+    }\n+  /* Remove the extension. */\n+  cptr = strrchr (name, '.');\n   if (cptr)\n-    strcpy (cptr, \".bbg\");\n-  else\n-    strcat (bbg_file_name, \".bbg\");\n+    *cptr = 0;\n+  \n+  length = strlen (name);\n+  da_file_name = xmalloc (length + 4);\n+  bb_file_name = xmalloc (length + 4);\n+  bbg_file_name = xmalloc (length + 5);\n+\n+  strcpy (da_file_name, name);\n+  strcpy (bb_file_name, name);\n+  strcpy (bbg_file_name, name);\n+  strcpy (da_file_name + length, \".da\");\n+  strcpy (bb_file_name + length, \".bb\");\n+  strcpy (bbg_file_name + length, \".bbg\");\n \n   bb_file = fopen (bb_file_name, \"rb\");\n   if (bb_file == NULL)\n@@ -464,6 +468,21 @@ open_files ()\n       exit (FATAL_EXIT_CODE);\n     }\n \n+  bbg_file = fopen (bbg_file_name, \"rb\");\n+  if (bbg_file == NULL)\n+    {\n+      fnotice (stderr, \"Could not open program flow graph file %s.\\n\",\n+\t       bbg_file_name);\n+      exit (FATAL_EXIT_CODE);\n+    }\n+  \n+  {\n+    struct stat status;\n+\n+    if (!fstat (fileno (bb_file), &status))\n+      bb_file_time = status.st_mtime;\n+  }\n+  \n   /* If none of the functions in the file were executed, then there won't\n      be a .da file.  Just assume that all counts are zero in this case.  */\n   da_file = fopen (da_file_name, \"rb\");\n@@ -473,14 +492,6 @@ open_files ()\n       fnotice (stderr, \"Assuming that all execution counts are zero.\\n\");\n     }\n \n-  bbg_file = fopen (bbg_file_name, \"rb\");\n-  if (bbg_file == NULL)\n-    {\n-      fnotice (stderr, \"Could not open program flow graph file %s.\\n\",\n-\t       bbg_file_name);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-\n   /* Check for empty .bbg file.  This indicates that there is no executable\n      code in this source file.  */\n   /* Set the EOF condition if at the end of file.  */\n@@ -554,7 +565,6 @@ read_profile (function_name, cfg_checksum, instr_arcs)\n   int function_name_buffer_len;\n \n   profile = xmalloc (sizeof (gcov_type) * instr_arcs);\n-  rewind (da_file);\n   function_name_buffer_len = strlen (function_name) + 1;\n   function_name_buffer = xmalloc (function_name_buffer_len + 1);\n \n@@ -564,6 +574,7 @@ read_profile (function_name, cfg_checksum, instr_arcs)\n   if (!da_file)\n     return profile;\n \n+  rewind (da_file);\n   while (1)\n     {\n       long magic, extra_bytes;\n@@ -1100,15 +1111,64 @@ calculate_branch_probs (current_graph, block_num, branch_probs, last_line_num)\n     }\n }\n \n+/* Format a HOST_WIDE_INT as either a percent ratio, or absolute\n+   count.  If dp >= 0, format TOP/BOTTOM * 100 to DP decimal places.\n+   If DP is zero, no decimal point is printed. Only print 100% when\n+   TOP==BOTTOM and only print 0% when TOP=0.  If dp < 0, then simply\n+   format TOP.  Return pointer to a static string.  */\n+\n+static char const *\n+format_hwint (top, bottom, dp)\n+     HOST_WIDEST_INT top, bottom;\n+     int dp;\n+{\n+  static char buffer[20];\n+  \n+  if (dp >= 0)\n+    {\n+      float ratio = bottom ? (float)top / bottom : 0;\n+      int ix;\n+      unsigned limit = 100;\n+      unsigned percent;\n+  \n+      for (ix = dp; ix--; )\n+\tlimit *= 10;\n+      \n+      percent = (unsigned) (ratio * limit);\n+      if (!percent && top)\n+\tpercent = 1;\n+      else if (percent == limit && top != bottom)\n+\tpercent = limit - 1;\n+      ix = sprintf (buffer, \"%.*u%%\", dp + 1, percent);\n+      if (dp)\n+\t{\n+\t  dp++;\n+\t  do\n+\t    {\n+\t      buffer[ix+1] = buffer[ix];\n+\t      ix--;\n+\t    }\n+\t  while (dp--);\n+\t  buffer[ix + 1] = '.';\n+\t}\n+    }\n+  else\n+    sprintf (buffer, HOST_WIDEST_INT_PRINT_DEC, top);\n+  \n+  return buffer;\n+}\n+\n+\n /* Output summary info for a function.  */\n \n static void\n function_summary ()\n {\n   if (function_source_lines)\n-    fnotice (stdout, \"%6.2f%% of %d source lines executed in function %s\\n\",\n-\t     (((double) function_source_lines_executed / function_source_lines)\n-\t      * 100), function_source_lines, function_name);\n+    fnotice (stdout, \"%s of %d source lines executed in function %s\\n\",\n+\t     format_hwint (function_source_lines_executed,\n+\t\t\t   function_source_lines, 2),\n+\t     function_source_lines, function_name);\n   else\n     fnotice (stdout, \"No executable source lines in function %s\\n\",\n \t     function_name);\n@@ -1117,20 +1177,23 @@ function_summary ()\n     {\n       if (function_branches)\n \t{\n-\t  fnotice (stdout, \"%6.2f%% of %d branches executed in function %s\\n\",\n-\t\t   (((double) function_branches_executed / function_branches)\n-\t\t    * 100), function_branches, function_name);\n+\t  fnotice (stdout, \"%s of %d branches executed in function %s\\n\",\n+\t\t   format_hwint (function_branches_executed,\n+\t\t\t\t function_branches, 2),\n+\t\t   function_branches, function_name);\n \t  fnotice (stdout,\n-\t\t\"%6.2f%% of %d branches taken at least once in function %s\\n\",\n-\t\t   (((double) function_branches_taken / function_branches)\n-\t\t    * 100), function_branches, function_name);\n+\t\t\"%s of %d branches taken at least once in function %s\\n\",\n+\t\t   format_hwint (function_branches_taken,\n+\t\t\t\t function_branches, 2),\n+\t\t   function_branches, function_name);\n \t}\n       else\n \tfnotice (stdout, \"No branches in function %s\\n\", function_name);\n       if (function_calls)\n-\tfnotice (stdout, \"%6.2f%% of %d calls executed in function %s\\n\",\n-\t\t (((double) function_calls_executed / function_calls)\n-\t\t  * 100), function_calls, function_name);\n+\tfnotice (stdout, \"%s of %d calls executed in function %s\\n\",\n+\t\t format_hwint (function_calls_executed,\n+\t\t\t       function_calls, 2),\n+\t\t function_calls, function_name);\n       else\n \tfnotice (stdout, \"No calls in function %s\\n\", function_name);\n     }\n@@ -1185,21 +1248,7 @@ output_data ()\n \n   for (s_ptr = sources; s_ptr; s_ptr = s_ptr->next)\n     {\n-      /* If this is a relative file name, and an object directory has been\n-\t specified, then make it relative to the object directory name.  */\n-      if (! IS_ABSOLUTE_PATHNAME (s_ptr->name)\n-\t  && object_directory != 0\n-\t  && *object_directory != '\\0')\n-\t{\n-\t  int objdir_count = strlen (object_directory);\n-\t  source_file_name = xmalloc (objdir_count + strlen (s_ptr->name) + 2);\n-\t  strcpy (source_file_name, object_directory);\n-\t  if (object_directory[objdir_count - 1] != '/')\n-\t    source_file_name[objdir_count++] = '/';\n-\t  strcpy (source_file_name + objdir_count, s_ptr->name);\n-\t}\n-      else\n-\tsource_file_name = s_ptr->name;\n+      source_file_name = s_ptr->name;\n \n       line_counts = (gcov_type *) xcalloc (sizeof (gcov_type), s_ptr->maxlineno);\n       line_exists = xcalloc (1, s_ptr->maxlineno);\n@@ -1376,9 +1425,10 @@ output_data ()\n \n       if (total_source_lines)\n \tfnotice (stdout,\n-\t\t \"%6.2f%% of %d source lines executed in file %s\\n\",\n-\t\t (((double) total_source_lines_executed / total_source_lines)\n-\t\t  * 100), total_source_lines, source_file_name);\n+\t\t \"%s of %d source lines executed in file %s\\n\",\n+\t\t format_hwint (total_source_lines_executed,\n+\t\t\t       total_source_lines, 2),\n+\t\t total_source_lines, source_file_name);\n       else\n \tfnotice (stdout, \"No executable source lines in file %s\\n\",\n \t\t source_file_name);\n@@ -1387,20 +1437,22 @@ output_data ()\n \t{\n \t  if (total_branches)\n \t    {\n-\t      fnotice (stdout, \"%6.2f%% of %d branches executed in file %s\\n\",\n-\t\t       (((double) total_branches_executed / total_branches)\n-\t\t\t* 100), total_branches, source_file_name);\n+\t      fnotice (stdout, \"%s of %d branches executed in file %s\\n\",\n+\t\t       format_hwint (total_branches_executed,\n+\t\t\t\t     total_branches, 2),\n+\t\t       total_branches, source_file_name);\n \t      fnotice (stdout,\n-\t\t    \"%6.2f%% of %d branches taken at least once in file %s\\n\",\n-\t\t       (((double) total_branches_taken / total_branches)\n-\t\t\t* 100), total_branches, source_file_name);\n+\t\t       \"%s of %d branches taken at least once in file %s\\n\",\n+\t\t       format_hwint (total_branches_taken,\n+\t\t\t\t     total_branches, 2),\n+\t\t       total_branches, source_file_name);\n \t    }\n \t  else\n \t    fnotice (stdout, \"No branches in file %s\\n\", source_file_name);\n \t  if (total_calls)\n-\t    fnotice (stdout, \"%6.2f%% of %d calls executed in file %s\\n\",\n-\t\t     (((double) total_calls_executed / total_calls)\n-\t\t      * 100), total_calls, source_file_name);\n+\t    fnotice (stdout, \"%s of %d calls executed in file %s\\n\",\n+\t\t     format_hwint (total_calls_executed, total_calls, 2),\n+\t\t     total_calls, source_file_name);\n \t  else\n \t    fnotice (stdout, \"No calls in file %s\\n\", source_file_name);\n \t}\n@@ -1410,51 +1462,70 @@ output_data ()\n \t  /* Now the statistics are ready.  Read in the source file one line\n \t     at a time, and output that line to the gcov file preceded by\n \t     its execution count if non zero.  */\n-\n-\t  source_file = fopen (source_file_name, \"r\");\n-\t  if (source_file == NULL)\n+\t  char const *retval;\n+\n+\t  /* Generate an output file name. LONG_OUTPUT_NAMES and\n+\t     PRESERVE_PATHS affect name generation. With\n+\t     preserve_paths we create a filename from all path\n+\t     components of the source file, replacing '/' with '#',\n+\t     without it we simply take the basename component. With\n+\t     long_output_names we prepend the processed name of the\n+\t     input file to each output name (except when the current\n+\t     source file is the input file, so you don't get a double\n+\t     concatenation). The two components are separated by\n+\t     '##'. Also '.' filename components are removed and '..'\n+\t     components are renamed to '^'. */\n+\t  gcov_file_name = xmalloc (strlen (source_file_name)\n+\t\t\t\t    + strlen (input_file_name) + 10);\n+\t  gcov_file_name[0] = 0;\n+\t  if (output_long_names && strcmp (source_file_name, input_file_name))\n \t    {\n-\t      fnotice (stderr, \"Could not open source file %s.\\n\",\n-\t\t       source_file_name);\n-\t      free (line_counts);\n-\t      free (line_exists);\n-\t      continue;\n+\t      /* Generate the input filename part.  */\n+\t      cptr = preserve_paths ? NULL : strrchr (input_file_name, '/');\n+\t      cptr = cptr ? cptr + 1 : input_file_name;\n+\t      strcat (gcov_file_name, cptr);\n+\t      strcat (gcov_file_name, \"##\");\n \t    }\n+\t  /* Generate the source filename part. */\n+\t  cptr = preserve_paths ? NULL : strrchr (source_file_name, '/');\n+\t  cptr = cptr ? cptr + 1 : source_file_name;\n+\t  strcat (gcov_file_name, cptr);\n \n-\t  count = strlen (source_file_name);\n-\t  cptr = strrchr (s_ptr->name, '/');\n-\t  if (cptr)\n-\t    cptr = cptr + 1;\n-\t  else\n-\t    cptr = s_ptr->name;\n-\t  if (output_long_names && strcmp (cptr, input_file_name))\n-\t    {\n-\t      gcov_file_name = xmalloc (count + 7 + strlen (input_file_name));\n-\n-\t      cptr = strrchr (input_file_name, '/');\n-\t      if (cptr)\n-\t\tstrcpy (gcov_file_name, cptr + 1);\n-\t      else\n-\t\tstrcpy (gcov_file_name, input_file_name);\n-\n-\t      strcat (gcov_file_name, \".\");\n-\n-\t      cptr = strrchr (source_file_name, '/');\n-\t      if (cptr)\n-\t\tstrcat (gcov_file_name, cptr + 1);\n-\t      else\n-\t\tstrcat (gcov_file_name, source_file_name);\n-\t    }\n-\t  else\n+\t  if (preserve_paths)\n \t    {\n-\t      gcov_file_name = xmalloc (count + 6);\n-\t      cptr = strrchr (source_file_name, '/');\n-\t      if (cptr)\n-\t\tstrcpy (gcov_file_name, cptr + 1);\n-\t      else\n-\t\tstrcpy (gcov_file_name, source_file_name);\n+\t      /* Convert '/' to '#', remove '/./', convert '/../' to\n+\t\t '/^/' */\n+\t      char *prev;\n+\t      \n+\t      for (cptr = gcov_file_name;\n+\t\t   (cptr = strchr ((prev = cptr), '/'));)\n+\t\t{\n+\t\t  unsigned shift = 0;\n+\t\t  \n+\t\t  if (prev + 1 == cptr && prev[0] == '.')\n+\t\t    {\n+\t\t      /* Remove '.' */\n+\t\t      shift = 2;\n+\t\t    }\n+\t\t  else if (prev + 2 == cptr\n+\t\t\t   && prev[0] == '.' && prev[1] == '.')\n+\t\t    {\n+\t\t      /* Convert '..' */\n+\t\t      shift = 1;\n+\t\t      prev[1] = '^';\n+\t\t    }\n+\t\t  else\n+\t\t    *cptr++ = '#';\n+\t\t  if (shift)\n+\t\t    {\n+\t\t      cptr = prev;\n+\t\t      do\n+\t\t\tprev[0] = prev[shift];\n+\t\t      while (*prev++);\n+\t\t    }\n+\t\t}\n \t    }\n-\n+\t  \n \t  /* Don't strip off the ending for compatibility with tcov, since\n \t     this results in confusion if there is more than one file with\n \t     the same basename, e.g. tmp.c and tmp.h.  */\n@@ -1466,52 +1537,68 @@ output_data ()\n \t    {\n \t      fnotice (stderr, \"Could not open output file %s.\\n\",\n \t\t       gcov_file_name);\n-\t      fclose (source_file);\n \t      free (line_counts);\n \t      free (line_exists);\n \t      continue;\n \t    }\n \n \t  fnotice (stdout, \"Creating %s.\\n\", gcov_file_name);\n \n-\t  for (count = 1; count < s_ptr->maxlineno; count++)\n+\t  fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, source_file_name);\n+\t  fprintf (gcov_file, \"%9s:%5d:Object:%s\\n\", \"-\", 0, bb_file_name);\n+\t  \n+\t  source_file = fopen (source_file_name, \"r\");\n+\t  if (source_file == NULL)\n+\t    fnotice (stderr, \"Could not open source file %s.\\n\",\n+\t\t     source_file_name);\n+\t  else\n \t    {\n-\t      char *retval;\n-\t      int len;\n-\n-\t      retval = fgets (string, STRING_SIZE, source_file);\n+\t      struct stat status;\n \n-\t      /* For lines which don't exist in the .bb file, print nothing\n-\t\t before the source line.  For lines which exist but were never\n-\t\t executed, print ###### before the source line.  Otherwise,\n-\t\t print the execution count before the source line.  */\n+\t      if (!fstat (fileno (source_file), &status)\n+\t\t  && status.st_mtime > bb_file_time)\n+\t\t{\n+\t\t  fnotice (stderr, \"Warning: source file %s is newer than %s\\n\",\n+\t\t\t   source_file_name, bb_file_name);\n+\t\t  fprintf (gcov_file, \"%9s:%5d:Source is newer than compiler output\\n\", \"-\", 0);\n+\t\t}\n+\t    }\n+\t  \n+\t  for (retval = source_file ? \"\" : NULL, count = 1;\n+\t       count < s_ptr->maxlineno; count++)\n+\t    {\n+\t      /* For lines which don't exist in the .bb file, print\n+\t\t '-' before the source line.  For lines which exist\n+\t\t but were never executed, print '#####' before the source\n+\t\t line.  Otherwise, print the execution count before\n+\t\t the source line.  */\n+\t      \n \t      /* There are 16 spaces of indentation added before the source\n \t\t line so that tabs won't be messed up.  */\n-\t      if (line_exists[count])\n+\t      fprintf (gcov_file, \"%9s:%5ld:\",\n+\t\t       !line_exists[count] ? \"-\"\n+\t\t       : !line_counts[count] ? \"#####\"\n+\t\t       : format_hwint (line_counts[count], 0, -1), count);\n+\t      \n+\t      if (retval)\n \t\t{\n-\t\t  if (line_counts[count])\n+\t\t  do\n \t\t    {\n-\t\t      char c[20];\n-\t\t      sprintf (c, HOST_WIDEST_INT_PRINT_DEC, (HOST_WIDEST_INT)line_counts[count]);\n-\t\t      fprintf (gcov_file, \"%12s    %s\", c,\n-\t\t\t       string);\n+\t\t      retval = fgets (string, STRING_SIZE, source_file);\n+\t\t      if (!retval)\n+\t\t\t{\n+\t\t\t  fnotice (stderr,\n+\t\t\t\t   \"Unexpected EOF while reading source file %s.\\n\",\n+\t\t\t\t   source_file_name);\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      fputs (retval, gcov_file);\n \t\t    }\n-\t\t  else\n-\t\t    fprintf (gcov_file, \"      ######    %s\", string);\n-\t\t}\n-\t      else\n-\t\tfprintf (gcov_file, \"\\t\\t%s\", string);\n-\n-\t      /* In case the source file line is larger than our buffer, keep\n-\t\t reading and outputting lines until we get a newline.  */\n-\t      len = strlen (string);\n-\t      while ((len == 0 || string[strlen (string) - 1] != '\\n')\n-\t\t     && retval != NULL)\n-\t\t{\n-\t\t  retval = fgets (string, STRING_SIZE, source_file);\n-\t\t  fputs (string, gcov_file);\n+\t\t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n');\n \t\t}\n-\n+\t      if (!retval)\n+\t\tfputs (\"??\\n\", gcov_file);\n+\t      \n \t      if (output_branch_probs)\n \t\t{\n \t\t  for (i = 0, a_ptr = branch_probs[count]; a_ptr;\n@@ -1520,95 +1607,53 @@ output_data ()\n \t\t      if (a_ptr->call_insn)\n \t\t\t{\n \t\t\t  if (a_ptr->total == 0)\n-\t\t\t    fnotice (gcov_file, \"call %d never executed\\n\", i);\n-\t\t            else\n-\t\t\t      {\n-\t\t\t\tif (output_branch_counts)\n-\t\t\t\t  {\n-\t\t\t\t    char c[20];\n-\t\t\t\t    sprintf (c, HOST_WIDEST_INT_PRINT_DEC,\n-\t\t\t\t\t     a_ptr->total - a_ptr->hits);\n-\t\t\t\t    fnotice (gcov_file,\n-\t\t\t\t\t     \"call %d returns = %s\\n\", i, c);\n-\t\t\t\t  }\n-\t\t\t        else\n-\t\t\t\t  {\n-\t\t\t\t    char c[20];\n-\t\t\t\t    sprintf (c, HOST_WIDEST_INT_PRINT_DEC,\n-\t\t\t\t\t     100 - ((a_ptr->hits * 100)\n-\t\t\t\t\t\t    + (a_ptr->total >> 1))\n-\t\t\t\t\t     / a_ptr->total);\n-\t\t\t\t    fnotice (gcov_file,\n-\t\t\t\t\t     \"call %d returns = %s%%\\n\", i, c);\n-\t\t\t\t  }\n-\t\t\t      }\n+\t\t\t    fnotice (gcov_file, \"call   %2d: never executed\\n\", i);\n+\t\t\t  else\n+\t\t\t    fnotice\n+\t\t\t      (gcov_file, \"call   %2d: returns %s\\n\", i,\n+\t\t\t       format_hwint (a_ptr->total - a_ptr->hits,\n+\t\t\t\t\t     a_ptr->total,\n+\t\t\t\t\t     -output_branch_counts));\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  if (a_ptr->total == 0)\n-\t\t\t    fnotice (gcov_file, \"branch %d never executed\\n\",\n+\t\t\t    fnotice (gcov_file, \"branch %2d: never executed\\n\",\n \t\t\t\t     i);\n \t\t\t  else\n-\t\t\t    {\n-\t\t\t      if (output_branch_counts)\n-\t\t\t\t{\n-\t\t\t\t  char c[20];\n-\t\t\t\t  sprintf (c, HOST_WIDEST_INT_PRINT_DEC,\n-\t\t\t\t\t   a_ptr->hits);\n-\t\t\t\t  fnotice (gcov_file,\n-\t\t\t\t\t   \"branch %d taken = %s\\n\", i, c);\n-\t\t\t\t}\n-\t\t\t      else\n-\t\t\t\t{\n-\t\t\t\t  char c[20];\n-\t\t\t\t  sprintf (c, HOST_WIDEST_INT_PRINT_DEC,\n-\t\t\t\t\t   ((a_ptr->hits * 100)\n-\t\t\t\t\t    + (a_ptr->total >> 1))\n-\t\t\t\t\t   / a_ptr->total);\n-\t\t\t\t  fnotice (gcov_file,\n-\t\t\t\t\t   \"branch %d taken = %s%%\\n\", i, c);\n-\t\t\t\t}\n-\t\t\t    }\n+\t\t\t    fnotice\n+\t\t\t      (gcov_file, \"branch %2d: taken %s\\n\", i,\n+\t\t\t       format_hwint (a_ptr->hits, a_ptr->total,\n+\t\t\t\t\t     -output_branch_counts));\n \t\t\t}\n \t\t   }\n \t      }\n-\n-\t      /* Gracefully handle errors while reading the source file.  */\n-\t      if (retval == NULL)\n-\t\t{\n-\t\t  fnotice (stderr,\n-\t\t\t   \"Unexpected EOF while reading source file %s.\\n\",\n-\t\t\t   source_file_name);\n-\t\t  break;\n-\t\t}\n \t    }\n \n \t  /* Handle all remaining source lines.  There may be lines\n \t     after the last line of code.  */\n+\t  if (retval)\n+\t    {\n+\t      for (; (retval = fgets (string, STRING_SIZE, source_file));\n+\t\t   count++)\n+\t\t{\n+\t\t  fprintf (gcov_file, \"%9s:%5ld:%s\", \"-\", count, retval);\n \n-\t  {\n-\t    char *retval = fgets (string, STRING_SIZE, source_file);\n-\t    while (retval != NULL)\n-\t      {\n-\t\tint len;\n-\n-\t\tfprintf (gcov_file, \"\\t\\t%s\", string);\n-\n-\t\t/* In case the source file line is larger than our buffer, keep\n-\t\t   reading and outputting lines until we get a newline.  */\n-\t\tlen = strlen (string);\n-\t\twhile ((len == 0 || string[strlen (string) - 1] != '\\n')\n-\t\t       && retval != NULL)\n-\t\t  {\n-\t\t    retval = fgets (string, STRING_SIZE, source_file);\n-\t\t    fputs (string, gcov_file);\n-\t\t  }\n-\n-\t\tretval = fgets (string, STRING_SIZE, source_file);\n-\t      }\n-\t  }\n+\t\t  while (!retval[0] || retval[strlen (retval) - 1] != '\\n')\n+\t\t    {\n+\t\t      retval = fgets (string, STRING_SIZE, source_file);\n+\t\t      if (!retval)\n+\t\t\tbreak;\n+\t\t      fputs (retval, gcov_file);\n+\t\t    }\n+\t\t}\n+\t    }\n \n-\t  fclose (source_file);\n+\t  if (source_file)\n+\t    fclose (source_file);\n+\t  if (ferror (gcov_file))\n+\t    fnotice (stderr, \"Error writing output file %s.\\n\",\n+\t\t     gcov_file_name);\n \t  fclose (gcov_file);\n \t}\n "}]}