{"sha": "f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQzMDg1YWFhM2ZlZjgyNjNiNGFmYzFjMmI1Zjk3MjFkOWJkZDhiMg==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-10-13T16:12:24Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2009-10-13T16:12:24Z"}, "message": "re PR fortran/41581 ([OOP] Allocation of a CLASS with SOURCE=<class> does not work)\n\n2009-10-13  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41581\n\t* decl.c (encapsulate_class_symbol): Add new component '$size'.\n\t* resolve.c (resolve_allocate_expr): Move CLASS handling to\n\tgfc_trans_allocate.\n\t(resolve_class_assign): Replaced by gfc_trans_class_assign.\n\t(resolve_code): Remove calls to resolve_class_assign.\n\t* trans.c (gfc_trans_code): Use new function gfc_trans_class_assign.\n\t* trans-expr.c (get_proc_ptr_comp): Fix a memory leak.\n\t(gfc_conv_procedure_call): For CLASS dummies, set the\n\t$size component.\n\t(gfc_trans_class_assign): New function, replacing resolve_class_assign.\n\t* trans-stmt.h (gfc_trans_class_assign): New prototype.\n\t* trans-stmt.c (gfc_trans_allocate): Use correct size when allocating\n\tCLASS variables. Do proper initialization. Move some code here from\n\tresolve_allocate_expr.\n\n\n2009-10-13  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/41581\n\t* gfortran.dg/class_allocate_2.f03: Modified.\n\t* gfortran.dg/class_allocate_3.f03: New test case.\n\nFrom-SVN: r152715", "tree": {"sha": "0ad66bf731ba1ac3e83d8ded18791c03cb46d62a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ad66bf731ba1ac3e83d8ded18791c03cb46d62a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9e467a24acb203f5a087721a74943a3af67f16a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9e467a24acb203f5a087721a74943a3af67f16a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9e467a24acb203f5a087721a74943a3af67f16a"}], "stats": {"total": 389, "additions": 287, "deletions": 102}, "files": [{"sha": "7800cf20730c085f7799b9ac028005b777fe006f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -1,3 +1,21 @@\n+2009-10-13  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41581\n+\t* decl.c (encapsulate_class_symbol): Add new component '$size'.\n+\t* resolve.c (resolve_allocate_expr): Move CLASS handling to\n+\tgfc_trans_allocate.\n+\t(resolve_class_assign): Replaced by gfc_trans_class_assign.\n+\t(resolve_code): Remove calls to resolve_class_assign.\n+\t* trans.c (gfc_trans_code): Use new function gfc_trans_class_assign.\n+\t* trans-expr.c (get_proc_ptr_comp): Fix a memory leak.\n+\t(gfc_conv_procedure_call): For CLASS dummies, set the\n+\t$size component.\n+\t(gfc_trans_class_assign): New function, replacing resolve_class_assign.\n+\t* trans-stmt.h (gfc_trans_class_assign): New prototype.\n+\t* trans-stmt.c (gfc_trans_allocate): Use correct size when allocating\n+\tCLASS variables. Do proper initialization. Move some code here from\n+\tresolve_allocate_expr.\n+\n 2009-10-11 Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/38439"}, {"sha": "2627e60271ac2003ee79151119ae13cf63870dd5", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -1028,7 +1028,8 @@ verify_c_interop_param (gfc_symbol *sym)\n /* Build a polymorphic CLASS entity, using the symbol that comes from build_sym.\n    A CLASS entity is represented by an encapsulating type, which contains the\n    declared type as '$data' component, plus an integer component '$vindex'\n-   which determines the dynamic type.  */\n+   which determines the dynamic type, and another integer '$size', which\n+   contains the size of the dynamic type structure.  */\n \n static gfc_try\n encapsulate_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n@@ -1089,6 +1090,14 @@ encapsulate_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->ts.kind = 4;\n       c->attr.access = ACCESS_PRIVATE;\n       c->initializer = gfc_int_expr (0);\n+\n+      /* Add component '$size'.  */\n+      if (gfc_add_component (fclass, \"$size\", &c) == FAILURE)\n+   \treturn FAILURE;\n+      c->ts.type = BT_INTEGER;\n+      c->ts.kind = 4;\n+      c->attr.access = ACCESS_PRIVATE;\n+      c->initializer = gfc_int_expr (0);\n     }\n \n   fclass->attr.extension = 1;"}, {"sha": "9444fd10205d83ca777ce5c321f99eb6d13ce1f9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -5844,7 +5844,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   symbol_attribute attr;\n   gfc_ref *ref, *ref2;\n   gfc_array_ref *ar;\n-  gfc_code *init_st;\n   gfc_symbol *sym;\n   gfc_alloc *a;\n   gfc_component *c;\n@@ -5948,41 +5947,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       return FAILURE;\n     }\n \n-  if (e->ts.type == BT_CLASS)\n-    {\n-      /* Initialize VINDEX for CLASS objects.  */\n-      init_st = gfc_get_code ();\n-      init_st->loc = code->loc;\n-      init_st->expr1 = gfc_expr_to_initialize (e);\n-      init_st->op = EXEC_ASSIGN;\n-      gfc_add_component_ref (init_st->expr1, \"$vindex\");\n-      if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n-\t{\n-\t  /* vindex must be determined at run time.  */\n-\t  init_st->expr2 = gfc_copy_expr (code->expr3);\n-\t  gfc_add_component_ref (init_st->expr2, \"$vindex\");\n-\t}\n-      else\n-\t{\n-\t  /* vindex is fixed at compile time.  */\n-\t  int vindex;\n-\t  if (code->expr3)\n-\t    vindex = code->expr3->ts.u.derived->vindex;\n-\t  else if (code->ext.alloc.ts.type == BT_DERIVED)\n-\t    vindex = code->ext.alloc.ts.u.derived->vindex;\n-\t  else if (e->ts.type == BT_CLASS)\n-\t    vindex = e->ts.u.derived->components->ts.u.derived->vindex;\n-\t  else\n-\t    vindex = e->ts.u.derived->vindex;\n-\t  init_st->expr2 = gfc_int_expr (vindex);\n-\t}\n-      init_st->expr2->where = init_st->expr1->where = init_st->loc;\n-      init_st->next = code->next;\n-      code->next = init_st;\n-      /* Only allocate the DATA component.  */\n-      gfc_add_component_ref (e, \"$data\");\n-    }\n-\n   if (pointer || dimension == 0)\n     return SUCCESS;\n \n@@ -7567,44 +7531,6 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n }\n \n \n-/* Check an assignment to a CLASS object (pointer or ordinary assignment).  */\n-\n-static void\n-resolve_class_assign (gfc_code *code)\n-{\n-  gfc_code *assign_code = gfc_get_code ();\n-\n-  if (code->expr2->ts.type != BT_CLASS)\n-    {\n-      /* Insert an additional assignment which sets the vindex.  */\n-      assign_code->next = code->next;\n-      code->next = assign_code;\n-      assign_code->op = EXEC_ASSIGN;\n-      assign_code->expr1 = gfc_copy_expr (code->expr1);\n-      gfc_add_component_ref (assign_code->expr1, \"$vindex\");\n-      if (code->expr2->ts.type == BT_DERIVED)\n-\t/* vindex is constant, determined at compile time.  */\n-\tassign_code->expr2 = gfc_int_expr (code->expr2->ts.u.derived->vindex);\n-      else if (code->expr2->ts.type == BT_CLASS)\n-\t{\n-\t  /* vindex must be determined at run time.  */\n-\t  assign_code->expr2 = gfc_copy_expr (code->expr2);\n-\t  gfc_add_component_ref (assign_code->expr2, \"$vindex\");\n-\t}\n-      else if (code->expr2->expr_type == EXPR_NULL)\n-\tassign_code->expr2 = gfc_int_expr (0);\n-      else\n-\tgcc_unreachable ();\n-    }\n-\n-  /* Modify the actual pointer assignment.  */\n-  if (code->expr2->ts.type == BT_CLASS)\n-    code->op = EXEC_ASSIGN;\n-  else\n-    gfc_add_component_ref (code->expr1, \"$data\");\n-}\n-\n-\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -7734,10 +7660,6 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      else\n \t\tgoto call;\n \t    }\n-\n-\t  if (code->expr1->ts.type == BT_CLASS)\n-\t    resolve_class_assign (code);\n-\n \t  break;\n \n \tcase EXEC_LABEL_ASSIGN:\n@@ -7759,10 +7681,6 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t    break;\n \n \t  gfc_check_pointer_assign (code->expr1, code->expr2);\n-\n-\t  if (code->expr1->ts.type == BT_CLASS)\n-\t    resolve_class_assign (code);\n-\n \t  break;\n \n \tcase EXEC_ARITHMETIC_IF:"}, {"sha": "65f13ad8a8da9066e7eff52d527a33539505ebc6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -1519,6 +1519,7 @@ get_proc_ptr_comp (gfc_expr *e)\n   e2 = gfc_copy_expr (e);\n   e2->expr_type = EXPR_VARIABLE;\n   gfc_conv_expr (&comp_se, e2);\n+  gfc_free_expr (e2);\n   return build_fold_addr_expr_loc (input_location, comp_se.expr);\n }\n \n@@ -2775,6 +2776,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t{\n \t  tree data;\n \t  tree vindex;\n+\t  tree size;\n \n \t  /* The derived type needs to be converted to a temporary\n \t     CLASS object.  */\n@@ -2788,13 +2790,20 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t      var, tmp, NULL_TREE);\n \t  tmp = fsym->ts.u.derived->components->next->backend_decl;\n \t  vindex = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n+\t\t\t\tvar, tmp, NULL_TREE);\n+\t  tmp = fsym->ts.u.derived->components->next->next->backend_decl;\n+\t  size = fold_build3 (COMPONENT_REF, TREE_TYPE (tmp),\n \t\t\t      var, tmp, NULL_TREE);\n \n \t  /* Set the vindex.  */\n-\t  tmp = build_int_cst (TREE_TYPE (vindex),\n-\t\t\t       e->ts.u.derived->vindex);\n+\t  tmp = build_int_cst (TREE_TYPE (vindex), e->ts.u.derived->vindex);\n \t  gfc_add_modify (&parmse.pre, vindex, tmp);\n \n+\t  /* Set the size.  */\n+\t  tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&e->ts));\n+\t  gfc_add_modify (&parmse.pre, size,\n+\t\t\t  fold_convert (TREE_TYPE (size), tmp));\n+\n \t  /* Now set the data field.  */\n \t  argss = gfc_walk_expr (e);\n \t  if (argss == gfc_ss_terminator)\n@@ -5261,3 +5270,75 @@ gfc_trans_assign (gfc_code * code)\n {\n   return gfc_trans_assignment (code->expr1, code->expr2, false);\n }\n+\n+\n+/* Translate an assignment to a CLASS object\n+   (pointer or ordinary assignment).  */\n+\n+tree\n+gfc_trans_class_assign (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree tmp;\n+\n+  gfc_start_block (&block);\n+\n+  if (code->expr2->ts.type != BT_CLASS)\n+    {\n+      /* Insert an additional assignment which sets the '$vindex' field.  */\n+      gfc_expr *lhs,*rhs;\n+      lhs = gfc_copy_expr (code->expr1);\n+      gfc_add_component_ref (lhs, \"$vindex\");\n+      if (code->expr2->ts.type == BT_DERIVED)\n+\t/* vindex is constant, determined at compile time.  */\n+\trhs = gfc_int_expr (code->expr2->ts.u.derived->vindex);\n+      else if (code->expr2->expr_type == EXPR_NULL)\n+\trhs = gfc_int_expr (0);\n+      else\n+\tgcc_unreachable ();\n+      tmp = gfc_trans_assignment (lhs, rhs, false);\n+      gfc_add_expr_to_block (&block, tmp);\n+\n+      /* Insert another assignment which sets the '$size' field.  */\n+      lhs = gfc_copy_expr (code->expr1);\n+      gfc_add_component_ref (lhs, \"$size\");\n+      if (code->expr2->ts.type == BT_DERIVED)\n+\t{\n+\t  /* Size is fixed at compile time.  */\n+\t  gfc_se lse;\n+\t  gfc_init_se (&lse, NULL);\n+\t  gfc_conv_expr (&lse, lhs);\n+\t  tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr2->ts));\n+\t  gfc_add_modify (&block, lse.expr,\n+\t\t\t  fold_convert (TREE_TYPE (lse.expr), tmp));\n+\t}\n+      else if (code->expr2->expr_type == EXPR_NULL)\n+\t{\n+\t  rhs = gfc_int_expr (0);\n+\t  tmp = gfc_trans_assignment (lhs, rhs, false);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+      gfc_free_expr (lhs);\n+      gfc_free_expr (rhs);\n+    }\n+\n+  /* Do the actual CLASS assignment.  */\n+  if (code->expr2->ts.type == BT_CLASS)\n+    code->op = EXEC_ASSIGN;\n+  else\n+    gfc_add_component_ref (code->expr1, \"$data\");\n+\n+  if (code->op == EXEC_ASSIGN)\n+    tmp = gfc_trans_assign (code);\n+  else if (code->op == EXEC_POINTER_ASSIGN)\n+    tmp = gfc_trans_pointer_assign (code);\n+  else\n+    gcc_unreachable();\n+\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  return gfc_finish_block (&block);\n+}"}, {"sha": "7dc7405c67f32f66eef58844e63c266bd07591d8", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 121, "deletions": 14, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -3976,7 +3976,7 @@ tree\n gfc_trans_allocate (gfc_code * code)\n {\n   gfc_alloc *al;\n-  gfc_expr *expr, *init_e, *rhs;\n+  gfc_expr *expr, *init_e;\n   gfc_se se;\n   tree tmp;\n   tree parm;\n@@ -4006,7 +4006,10 @@ gfc_trans_allocate (gfc_code * code)\n \n   for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n-      expr = al->expr;\n+      expr = gfc_copy_expr (al->expr);\n+\n+      if (expr->ts.type == BT_CLASS)\n+\tgfc_add_component_ref (expr, \"$data\");\n \n       gfc_init_se (&se, NULL);\n       gfc_start_block (&se.pre);\n@@ -4022,13 +4025,14 @@ gfc_trans_allocate (gfc_code * code)\n \t  /* Determine allocate size.  */\n \t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n \t    {\n-\t      gfc_typespec *ts;\n-\t      /* TODO: Size must be determined at run time, since it must equal\n-\t\t the size of the dynamic type of SOURCE, not the declared type.  */\n-\t      gfc_error (\"Using SOURCE= with a class variable at %L not \"\n-\t\t\t \"supported yet\", &code->loc);\n-\t      ts = &code->expr3->ts.u.derived->components->ts;\n-\t      tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (ts));\n+\t      gfc_expr *sz;\n+\t      gfc_se se_sz;\n+\t      sz = gfc_copy_expr (code->expr3);\n+\t      gfc_add_component_ref (sz, \"$size\");\n+\t      gfc_init_se (&se_sz, NULL);\n+\t      gfc_conv_expr (&se_sz, sz);\n+\t      gfc_free_expr (sz);\n+\t      tmp = se_sz.expr;\n \t    }\n \t  else if (code->expr3 && code->expr3->ts.type != BT_CLASS)\n \t    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->expr3->ts));\n@@ -4070,17 +4074,120 @@ gfc_trans_allocate (gfc_code * code)\n       /* Initialization via SOURCE block.  */\n       if (code->expr3)\n \t{\n-\t  rhs = gfc_copy_expr (code->expr3);\n+\t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n \t  if (rhs->ts.type == BT_CLASS)\n-\t    gfc_add_component_ref (rhs, \"$data\");\n-\t  tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr), rhs, false);\n+\t    {\n+\t      gfc_se dst,src,len;\n+\t      gfc_expr *sz;\n+\t      gfc_add_component_ref (rhs, \"$data\");\n+\t      sz = gfc_copy_expr (code->expr3);\n+\t      gfc_add_component_ref (sz, \"$size\");\n+\t      gfc_init_se (&dst, NULL);\n+\t      gfc_init_se (&src, NULL);\n+\t      gfc_init_se (&len, NULL);\n+\t      gfc_conv_expr (&dst, expr);\n+\t      gfc_conv_expr (&src, rhs);\n+\t      gfc_conv_expr (&len, sz);\n+\t      gfc_free_expr (sz);\n+\t      tmp = gfc_build_memcpy_call (dst.expr, src.expr, len.expr);\n+\t    }\n+\t  else\n+\t    tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n+\t\t\t\t\trhs, false);\n+\t  gfc_free_expr (rhs);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+      /* Default initializer for CLASS variables.  */\n+      else if (al->expr->ts.type == BT_CLASS\n+\t       && code->ext.alloc.ts.type == BT_DERIVED\n+\t       && (init_e = gfc_default_initializer (&code->ext.alloc.ts)))\n+\t{\n+\t  gfc_se dst,src;\n+\t  gfc_init_se (&dst, NULL);\n+\t  gfc_init_se (&src, NULL);\n+\t  gfc_conv_expr (&dst, expr);\n+\t  gfc_conv_expr (&src, init_e);\n+\t  gfc_add_block_to_block (&block, &src.pre);\n+\t  tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&code->ext.alloc.ts));\n+\t  tmp = gfc_build_memcpy_call (dst.expr, src.expr, tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n       /* Add default initializer for those derived types that need them.  */\n-      else if (expr->ts.type == BT_DERIVED && (init_e = gfc_default_initializer (&expr->ts)))\n+      else if (expr->ts.type == BT_DERIVED\n+\t       && (init_e = gfc_default_initializer (&expr->ts)))\n+\t{\n+\t  tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n+\t\t\t\t      init_e, true);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n+\n+      /* Allocation of CLASS entities.  */\n+      gfc_free_expr (expr);\n+      expr = al->expr;\n+      if (expr->ts.type == BT_CLASS)\n \t{\n-\t  tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr), init_e, true);\n+\t  gfc_expr *lhs,*rhs;\n+\t  /* Initialize VINDEX for CLASS objects.  */\n+\t  lhs = gfc_expr_to_initialize (expr);\n+\t  gfc_add_component_ref (lhs, \"$vindex\");\n+\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n+\t    {\n+\t      /* vindex must be determined at run time.  */\n+\t      rhs = gfc_copy_expr (code->expr3);\n+\t      gfc_add_component_ref (rhs, \"$vindex\");\n+\t    }\n+\t  else\n+\t    {\n+\t      /* vindex is fixed at compile time.  */\n+\t      int vindex;\n+\t      if (code->expr3)\n+\t\tvindex = code->expr3->ts.u.derived->vindex;\n+\t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n+\t\tvindex = code->ext.alloc.ts.u.derived->vindex;\n+\t      else if (expr->ts.type == BT_CLASS)\n+\t\tvindex = expr->ts.u.derived->components->ts.u.derived->vindex;\n+\t      else\n+\t\tvindex = expr->ts.u.derived->vindex;\n+\t      rhs = gfc_int_expr (vindex);\n+\t    }\n+\t  tmp = gfc_trans_assignment (lhs, rhs, false);\n+\t  gfc_free_expr (lhs);\n+\t  gfc_free_expr (rhs);\n \t  gfc_add_expr_to_block (&block, tmp);\n+\n+\t  /* Initialize SIZE for CLASS objects.  */\n+\t  lhs = gfc_expr_to_initialize (expr);\n+\t  gfc_add_component_ref (lhs, \"$size\");\n+\t  rhs = NULL;\n+\t  if (code->expr3 && code->expr3->ts.type == BT_CLASS)\n+\t    {\n+\t      /* Size must be determined at run time.  */\n+\t      rhs = gfc_copy_expr (code->expr3);\n+\t      gfc_add_component_ref (rhs, \"$size\");\n+\t      tmp = gfc_trans_assignment (lhs, rhs, false);\n+\t      gfc_add_expr_to_block (&block, tmp);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Size is fixed at compile time.  */\n+\t      gfc_typespec *ts;\n+\t      gfc_se lse;\n+\t      gfc_init_se (&lse, NULL);\n+\t      gfc_conv_expr (&lse, lhs);\n+\t      if (code->expr3)\n+\t\tts = &code->expr3->ts;\n+\t      else if (code->ext.alloc.ts.type == BT_DERIVED)\n+\t\tts = &code->ext.alloc.ts;\n+\t      else if (expr->ts.type == BT_CLASS)\n+\t\tts = &expr->ts.u.derived->components->ts;\n+\t      else\n+\t\tts = &expr->ts;\n+\t      tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (ts));\n+\t      gfc_add_modify (&block, lse.expr,\n+\t\t\t      fold_convert (TREE_TYPE (lse.expr), tmp));\n+\t    }\n+\t  gfc_free_expr (lhs);\n+\t  gfc_free_expr (rhs);\n \t}\n \n     }"}, {"sha": "e6faacd0022524e1d549189c48bdeda8245588c6", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -29,6 +29,7 @@ tree gfc_trans_code (gfc_code *);\n tree gfc_trans_assign (gfc_code *);\n tree gfc_trans_pointer_assign (gfc_code *);\n tree gfc_trans_init_assign (gfc_code *);\n+tree gfc_trans_class_assign (gfc_code *code);\n \n /* trans-stmt.c */\n tree gfc_trans_cycle (gfc_code *);"}, {"sha": "22c3e07608590835c0214421c4a08ae4c5e5e14d", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -1079,15 +1079,21 @@ gfc_trans_code (gfc_code * code)\n \t  break;\n \n \tcase EXEC_ASSIGN:\n-\t  res = gfc_trans_assign (code);\n+\t  if (code->expr1->ts.type == BT_CLASS)\n+\t    res = gfc_trans_class_assign (code);\n+\t  else\n+\t    res = gfc_trans_assign (code);\n \t  break;\n \n         case EXEC_LABEL_ASSIGN:\n           res = gfc_trans_label_assign (code);\n           break;\n \n \tcase EXEC_POINTER_ASSIGN:\n-\t  res = gfc_trans_pointer_assign (code);\n+\t  if (code->expr1->ts.type == BT_CLASS)\n+\t    res = gfc_trans_class_assign (code);\n+\t  else\n+\t    res = gfc_trans_pointer_assign (code);\n \t  break;\n \n \tcase EXEC_INIT_ASSIGN:"}, {"sha": "7e2258950c79c320243e9dcf81f90de6320fb5e6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -1,3 +1,9 @@\n+2009-10-13  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/41581\n+\t* gfortran.dg/class_allocate_2.f03: Modified.\n+\t* gfortran.dg/class_allocate_3.f03: New test case.\n+\n 2009-10-13  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41668"}, {"sha": "754faa9a9f4183ecd758ccc152e408c44cd7fd06", "filename": "gcc/testsuite/gfortran.dg/class_allocate_2.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_2.f03?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -7,7 +7,7 @@ subroutine test()\n end type t\n class(t), allocatable :: c,d\n allocate(t :: d)\n-allocate(c,source=d) ! { dg-error \"not supported yet\" }\n+allocate(c,source=d)\n end\n \n type, abstract :: t"}, {"sha": "c6128a8ab515ea2e21c44a3a499f82af34d870c1", "filename": "gcc/testsuite/gfortran.dg/class_allocate_3.f03", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_allocate_3.f03?ref=f43085aaa3fef8263b4afc1c2b5f9721d9bdd8b2", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+!\n+! PR 41581: [OOP] Allocation of a CLASS with SOURCE=<class> does not work\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+\n+ type t\n+ end type t\n+\n+ type,extends(t) :: t2\n+   integer :: i = 54\n+   real :: r = 384.02\n+ end type t2\n+\n+ class(t), allocatable :: m1, m2\n+\n+ allocate(t2 :: m2)\n+ select type(m2)\n+ type is (t2)\n+   print *, m2%i, m2%r\n+   if (m2%i/=54) call abort()\n+   if (abs(m2%r-384.02)>1E-3) call abort()\n+   m2%i = 42\n+   m2%r = -4.0\n+ class default\n+   call abort()\n+ end select\n+\n+ allocate(m1, source=m2)\n+ select type(m1)\n+ type is (t2)\n+   print *, m1%i, m1%r\n+   if (m1%i/=42) call abort()\n+   if (abs(m1%r+4.0)>1E-3) call abort()\n+ class default\n+   call abort()\n+ end select\n+\n+end"}]}