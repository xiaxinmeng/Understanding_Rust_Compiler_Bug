{"sha": "527ed00b715bf4a945284722b7e766a4f763049f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI3ZWQwMGI3MTViZjRhOTQ1Mjg0NzIyYjdlNzY2YTRmNzYzMDQ5Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T20:44:39Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-09T20:44:39Z"}, "message": "Do not make a local copy of large aggregate\n\nThis prevents gigi from making a local copy of large aggregates.\n\n\t* gcc-interface/trans.c (lvalue_required_p) <N_Selected_Component>:\n\tMerge with N_Slice.\n\t<N_Allocator>: Move to...\n\t(lvalue_for_aggregate_p): ...here.  New function.\n\t(Identifier_to_gnu): For an identifier with aggregate type, also\n\tcall lvalue_for_aggregate_p if lvalue_required_p returned false\n\tbefore substituting the identifier with the constant.", "tree": {"sha": "d0aa44f1dfd8f91695a2eeb9bbd65a4ae69444b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0aa44f1dfd8f91695a2eeb9bbd65a4ae69444b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/527ed00b715bf4a945284722b7e766a4f763049f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527ed00b715bf4a945284722b7e766a4f763049f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/527ed00b715bf4a945284722b7e766a4f763049f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/527ed00b715bf4a945284722b7e766a4f763049f/comments", "author": null, "committer": null, "parents": [{"sha": "aff220748ca669d4338c5ac6f0b210a29f90bbab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aff220748ca669d4338c5ac6f0b210a29f90bbab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aff220748ca669d4338c5ac6f0b210a29f90bbab"}], "stats": {"total": 96, "additions": 83, "deletions": 13}, "files": [{"sha": "c118afd6c9ddb1f5a0bb9750eff0b98c7a1a720e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527ed00b715bf4a945284722b7e766a4f763049f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527ed00b715bf4a945284722b7e766a4f763049f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=527ed00b715bf4a945284722b7e766a4f763049f", "patch": "@@ -1,3 +1,13 @@\n+2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (lvalue_required_p) <N_Selected_Component>:\n+\tMerge with N_Slice.\n+\t<N_Allocator>: Move to...\n+\t(lvalue_for_aggregate_p): ...here.  New function.\n+\t(Identifier_to_gnu): For an identifier with aggregate type, also\n+\tcall lvalue_for_aggregate_p if lvalue_required_p returned false\n+\tbefore substituting the identifier with the constant.\n+\n 2020-05-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (gnat_to_gnu): Do not wrap boolean values if"}, {"sha": "a2f06d774d3bb2362dcd4bac88e74b4fec1913d4", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 73, "deletions": 13, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/527ed00b715bf4a945284722b7e766a4f763049f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/527ed00b715bf4a945284722b7e766a4f763049f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=527ed00b715bf4a945284722b7e766a4f763049f", "patch": "@@ -871,20 +871,16 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \n       /* ... fall through ... */\n \n+    case N_Selected_Component:\n     case N_Slice:\n-      /* Only the array expression can require an lvalue.  */\n+      /* Only the prefix expression can require an lvalue.  */\n       if (Prefix (gnat_parent) != gnat_node)\n \treturn 0;\n \n       return lvalue_required_p (gnat_parent,\n \t\t\t\tget_unpadded_type (Etype (gnat_parent)),\n \t\t\t\tconstant, address_of_constant);\n \n-    case N_Selected_Component:\n-      return lvalue_required_p (gnat_parent,\n-\t\t\t\tget_unpadded_type (Etype (gnat_parent)),\n-\t\t\t\tconstant, address_of_constant);\n-\n     case N_Object_Renaming_Declaration:\n       /* We need to preserve addresses through a renaming.  */\n       return 1;\n@@ -925,12 +921,6 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n \t\t\t       get_unpadded_type (Etype (gnat_parent)),\n \t\t\t       constant, address_of_constant);\n \n-    case N_Allocator:\n-      /* We should only reach here through the N_Qualified_Expression case.\n-\t Force an lvalue for composite types since a block-copy to the newly\n-\t allocated area of memory is made.  */\n-      return Is_Composite_Type (Underlying_Type (Etype (gnat_node)));\n-\n    case N_Explicit_Dereference:\n       /* We look through dereferences for address of constant because we need\n \t to handle the special cases listed above.  */\n@@ -948,6 +938,74 @@ lvalue_required_p (Node_Id gnat_node, tree gnu_type, bool constant,\n   gcc_unreachable ();\n }\n \n+/* Return true if an lvalue should be used for GNAT_NODE.  GNU_TYPE is the type\n+   that will be used for GNAT_NODE in the translated GNU tree and is assumed to\n+   be an aggregate type.\n+\n+   The function climbs up the GNAT tree starting from the node and returns true\n+   upon encountering a node that makes it doable to decide.  lvalue_required_p\n+   should have been previously invoked on the arguments and returned false.  */\n+\n+static bool\n+lvalue_for_aggregate_p (Node_Id gnat_node, tree gnu_type)\n+{\n+  Node_Id gnat_parent = Parent (gnat_node);\n+\n+  switch (Nkind (gnat_parent))\n+    {\n+    case N_Parameter_Association:\n+    case N_Function_Call:\n+    case N_Procedure_Call_Statement:\n+      /* Even if the parameter is by copy, prefer an lvalue.  */\n+      return true;\n+\n+    case N_Indexed_Component:\n+    case N_Selected_Component:\n+      /* If an elementary component is used, take it from the constant.  */\n+      if (!Is_Composite_Type (Underlying_Type (Etype (gnat_parent))))\n+\treturn false;\n+\n+      /* ... fall through ... */\n+\n+    case N_Slice:\n+      return lvalue_for_aggregate_p (gnat_parent,\n+\t\t\t\t     get_unpadded_type (Etype (gnat_parent)));\n+\n+    case N_Object_Declaration:\n+      /* For an aggregate object declaration, return the constant at top level\n+\t in order to avoid generating elaboration code.  */\n+      if (global_bindings_p ())\n+\treturn false;\n+\n+      /* ... fall through ... */\n+\n+    case N_Assignment_Statement:\n+      /* For an aggregate assignment, decide based on the size.  */\n+      {\n+\tconst HOST_WIDE_INT size = int_size_in_bytes (gnu_type);\n+\treturn size < 0 || size >= param_large_stack_frame / 4;\n+      }\n+\n+    case N_Unchecked_Type_Conversion:\n+    case N_Type_Conversion:\n+    case N_Qualified_Expression:\n+      return lvalue_for_aggregate_p (gnat_parent,\n+\t\t\t\t     get_unpadded_type (Etype (gnat_parent)));\n+\n+    case N_Allocator:\n+      /* We should only reach here through the N_Qualified_Expression case.\n+\t Force an lvalue for aggregate types since a block-copy to the newly\n+\t allocated area of memory is made.  */\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+\n /* Return true if T is a constant DECL node that can be safely replaced\n    by its initializer.  */\n \n@@ -1232,7 +1290,9 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       if ((!constant_only || address_of_constant) && require_lvalue < 0)\n \trequire_lvalue\n \t  = lvalue_required_p (gnat_node, gnu_result_type, true,\n-\t\t\t       address_of_constant);\n+\t\t\t       address_of_constant)\n+\t    || (AGGREGATE_TYPE_P (gnu_result_type)\n+\t\t&& lvalue_for_aggregate_p (gnat_node, gnu_result_type));\n \n       /* Finally retrieve the initializer if this is deemed valid.  */\n       if ((constant_only && !address_of_constant) || !require_lvalue)"}]}