{"sha": "51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiN2QwMDY5YTgyYThhNWYyZTljNmIxY2YzZGI0MDQxNzE2ZGZjZg==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2006-07-26T17:31:54Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2006-07-26T17:31:54Z"}, "message": "function.c (reorder_fix_fragments): Delete.\n\n\t* function.c (reorder_fix_fragments): Delete.\n\t(reorder_blocks): Don't call it.\n\t(reorder_blocks_1): Put all subblocks under the origin block.\n\nFrom-SVN: r115761", "tree": {"sha": "96870400aece14d2ac22bd3e64eeddefaf57884b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96870400aece14d2ac22bd3e64eeddefaf57884b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf/comments", "author": null, "committer": null, "parents": [{"sha": "e69e3d0e8b7ccc7ba990130dfd6ed909609ed971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69e3d0e8b7ccc7ba990130dfd6ed909609ed971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69e3d0e8b7ccc7ba990130dfd6ed909609ed971"}], "stats": {"total": 79, "additions": 15, "deletions": 64}, "files": [{"sha": "dad968fb4fd3fa7058862d7502e8b2a4c1108309", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf", "patch": "@@ -1,3 +1,9 @@\n+2006-07-26  Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* function.c (reorder_fix_fragments): Delete.\n+\t(reorder_blocks): Don't call it.\n+\t(reorder_blocks_1): Put all subblocks under the origin block.\n+\n 2006-07-26  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR rtl-optimization/27907"}, {"sha": "12e391abf24b5a227acb2dcc2a31e1a7cc218dd2", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 64, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=51b7d0069a82a8a5f2e9c6b1cf3db4041716dfcf", "patch": "@@ -195,7 +195,6 @@ static struct temp_slot *find_temp_slot_from_address (rtx);\n static void pad_to_arg_alignment (struct args_size *, int, struct args_size *);\n static void pad_below (struct args_size *, enum machine_mode, tree);\n static void reorder_blocks_1 (rtx, tree, VEC(tree,heap) **);\n-static void reorder_fix_fragments (tree);\n static int all_blocks (tree, tree *);\n static tree *get_block_vector (tree, int *);\n extern tree debug_find_var_in_block_tree (tree, tree);\n@@ -3584,9 +3583,6 @@ reorder_blocks (void)\n   reorder_blocks_1 (get_insns (), block, &block_stack);\n   BLOCK_SUBBLOCKS (block) = blocks_nreverse (BLOCK_SUBBLOCKS (block));\n \n-  /* Remove deleted blocks from the block fragment chains.  */\n-  reorder_fix_fragments (block);\n-\n   VEC_free (tree, heap, block_stack);\n }\n \n@@ -3615,17 +3611,18 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n \t    {\n \t      tree block = NOTE_BLOCK (insn);\n+\t      tree origin;\n+\n+\t      origin = (BLOCK_FRAGMENT_ORIGIN (block)\n+\t\t\t? BLOCK_FRAGMENT_ORIGIN (block)\n+\t\t\t: block);\n \n \t      /* If we have seen this block before, that means it now\n \t\t spans multiple address regions.  Create a new fragment.  */\n \t      if (TREE_ASM_WRITTEN (block))\n \t\t{\n \t\t  tree new_block = copy_node (block);\n-\t\t  tree origin;\n \n-\t\t  origin = (BLOCK_FRAGMENT_ORIGIN (block)\n-\t\t\t    ? BLOCK_FRAGMENT_ORIGIN (block)\n-\t\t\t    : block);\n \t\t  BLOCK_FRAGMENT_ORIGIN (new_block) = origin;\n \t\t  BLOCK_FRAGMENT_CHAIN (new_block)\n \t\t    = BLOCK_FRAGMENT_CHAIN (origin);\n@@ -3642,10 +3639,13 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n \t\t will cause infinite recursion.  */\n \t      if (block != current_block)\n \t\t{\n+\t\t  if (block != origin)\n+\t\t    gcc_assert (BLOCK_SUPERCONTEXT (origin) == current_block);\n+\n \t\t  BLOCK_SUPERCONTEXT (block) = current_block;\n \t\t  BLOCK_CHAIN (block) = BLOCK_SUBBLOCKS (current_block);\n \t\t  BLOCK_SUBBLOCKS (current_block) = block;\n-\t\t  current_block = block;\n+\t\t  current_block = origin;\n \t\t}\n \t      VEC_safe_push (tree, heap, *p_block_stack, block);\n \t    }\n@@ -3660,61 +3660,6 @@ reorder_blocks_1 (rtx insns, tree current_block, VEC(tree,heap) **p_block_stack)\n     }\n }\n \n-/* Rationalize BLOCK_FRAGMENT_ORIGIN.  If an origin block no longer\n-   appears in the block tree, select one of the fragments to become\n-   the new origin block.  */\n-\n-static void\n-reorder_fix_fragments (tree block)\n-{\n-  while (block)\n-    {\n-      tree dup_origin = BLOCK_FRAGMENT_ORIGIN (block);\n-      tree new_origin = NULL_TREE;\n-\n-      if (dup_origin)\n-\t{\n-\t  if (! TREE_ASM_WRITTEN (dup_origin))\n-\t    {\n-\t      new_origin = BLOCK_FRAGMENT_CHAIN (dup_origin);\n-\n-\t      /* Find the first of the remaining fragments.  There must\n-\t\t be at least one -- the current block.  */\n-\t      while (! TREE_ASM_WRITTEN (new_origin))\n-\t\tnew_origin = BLOCK_FRAGMENT_CHAIN (new_origin);\n-\t      BLOCK_FRAGMENT_ORIGIN (new_origin) = NULL_TREE;\n-\t    }\n-\t}\n-      else if (! dup_origin)\n-\tnew_origin = block;\n-\n-      /* Re-root the rest of the fragments to the new origin.  In the\n-\t case that DUP_ORIGIN was null, that means BLOCK was the origin\n-\t of a chain of fragments and we want to remove those fragments\n-\t that didn't make it to the output.  */\n-      if (new_origin)\n-\t{\n-\t  tree *pp = &BLOCK_FRAGMENT_CHAIN (new_origin);\n-\t  tree chain = *pp;\n-\n-\t  while (chain)\n-\t    {\n-\t      if (TREE_ASM_WRITTEN (chain))\n-\t\t{\n-\t\t  BLOCK_FRAGMENT_ORIGIN (chain) = new_origin;\n-\t\t  *pp = chain;\n-\t\t  pp = &BLOCK_FRAGMENT_CHAIN (chain);\n-\t\t}\n-\t      chain = BLOCK_FRAGMENT_CHAIN (chain);\n-\t    }\n-\t  *pp = NULL_TREE;\n-\t}\n-\n-      reorder_fix_fragments (BLOCK_SUBBLOCKS (block));\n-      block = BLOCK_CHAIN (block);\n-    }\n-}\n-\n /* Reverse the order of elements in the chain T of blocks,\n    and return the new head of the chain (old last element).  */\n "}]}