{"sha": "d5f274087565b02a4f56ed90daf7bb0d5b6d5634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVmMjc0MDg3NTY1YjAyYTRmNTZlZDkwZGFmN2JiMGQ1YjZkNTYzNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T22:53:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-11T22:53:34Z"}, "message": "(FLO_union_type): Remove bitfields to set sign...\n\n(FLO_union_type): Remove bitfields to set sign, exponent, and\nmantissa, and add value_raw field, which is an integer of the\nappropriate type.  If _DEBUG_BITFLOAT is defined, provide little and\nbig endian bitfields.  If the macro FLOAT_BIT_ORDER_MISMATCH is\ndefined, use explicit bitfields.\n(pack_d, unpack_d): Switch to use value_raw and explicit shifts and\nmasks so that we don't have to worry about whether the target is big\nor little endian unless FLOAT_BIT_ORDER_MISMATCH is defined.  If\nsingle precision floating point, rename to pack_f and unpack_f, so\nthere is no confusion in the debugger.\n\nFrom-SVN: r10313", "tree": {"sha": "3c8f1e6284f6e2a0110edfc94ca3e5c9aeab27ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c8f1e6284f6e2a0110edfc94ca3e5c9aeab27ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5f274087565b02a4f56ed90daf7bb0d5b6d5634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f274087565b02a4f56ed90daf7bb0d5b6d5634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5f274087565b02a4f56ed90daf7bb0d5b6d5634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5f274087565b02a4f56ed90daf7bb0d5b6d5634/comments", "author": null, "committer": null, "parents": [{"sha": "446c894728d5e93da730764a781454361002048a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446c894728d5e93da730764a781454361002048a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/446c894728d5e93da730764a781454361002048a"}], "stats": {"total": 33, "additions": 30, "deletions": 3}, "files": [{"sha": "6c7491e35b6844a7a4004dec2cb2c1854ab2c864", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5f274087565b02a4f56ed90daf7bb0d5b6d5634/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5f274087565b02a4f56ed90daf7bb0d5b6d5634/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=d5f274087565b02a4f56ed90daf7bb0d5b6d5634", "patch": "@@ -243,6 +243,16 @@ typedef union\n   FLO_type value;\n   fractype value_raw;\n \n+#ifdef FLOAT_WORD_ORDER_MISMATCH\n+  struct\n+    {\n+      fractype fraction:FRACBITS __attribute__ ((packed));\n+      unsigned int exp:EXPBITS __attribute__ ((packed));\n+      unsigned int sign:1 __attribute__ ((packed));\n+    }\n+  bits;\n+#endif\n+\n #ifdef _DEBUG_BITFLOAT\n   halffractype l[2];\n \n@@ -404,9 +414,16 @@ pack_d ( fp_number_type *  src)\n   /* We previously used bitfields to store the number, but this doesn't\n      handle little/big endian systems conviently, so use shifts and\n      masks */\n+#ifdef FLOAT_WORD_ORDER_MISMATCH\n+  dst.bits.fraction = fraction;\n+  dst.bits.exp = exp;\n+  dst.bits.sign = sign;\n+#else\n   dst.value_raw = fraction & ((((fractype)1) << FRACBITS) - (fractype)1);\n   dst.value_raw |= ((fractype) (exp & ((1 << EXPBITS) - 1))) << FRACBITS;\n   dst.value_raw |= ((fractype) (sign & 1)) << (FRACBITS | EXPBITS);\n+#endif\n+\n   return dst.value;\n }\n \n@@ -416,9 +433,19 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n   /* We previously used bitfields to store the number, but this doesn't\n      handle little/big endian systems conviently, so use shifts and\n      masks */\n-  fractype fraction = src->value_raw & ((((fractype)1) << FRACBITS) - (fractype)1);\n-  int exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);\n-  int sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;\n+  fractype fraction;\n+  int exp;\n+  int sign;\n+\n+#ifdef FLOAT_WORD_ORDER_MISMATCH\n+  fraction = src->bits.fraction;\n+  exp = src->bits.exp;\n+  sign = src->bits.sign;\n+#else\n+  fraction = src->value_raw & ((((fractype)1) << FRACBITS) - (fractype)1);\n+  exp = ((int)(src->value_raw >> FRACBITS)) & ((1 << EXPBITS) - 1);\n+  sign = ((int)(src->value_raw >> (FRACBITS + EXPBITS))) & 1;\n+#endif\n \n   dst->sign = sign;\n   if (exp == 0)"}]}