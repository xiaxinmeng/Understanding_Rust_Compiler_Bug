{"sha": "f75959a6a36a08908bfb66af87f67b00e056a4c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc1OTU5YTZhMzZhMDg5MDhiZmI2NmFmODdmNjdiMDBlMDU2YTRjNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-20T06:47:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-20T06:47:28Z"}, "message": "re PR target/19511 (ICE in in reload_cse_simplify_operands, at postreload.c:391)\n\n        PR target/19511\n        * config/i386/i386.c (ix86_preferred_reload_class): Return a proper\n        subclass of the input class.\n        (ix86_secondary_memory_needed): Always true for cross-MMX classes.\n        Always true for cross-SSE1 classes.  Rationalize conditionals.\n        * config/i386/i386.h (SSE_CLASS_P, MMX_CLASS_P): Use straight equality.\n        * config/i386/i386.md (movsi_1): Add MMX/SSE zeros.  Fix alternatives\n        for SSE1.  Don't check TARGET_INTER_UNIT_MOVES.\n        (movdi_2): Add MMX/SSE zeros.\n        (movdi_1_rex64): Likewise.  Don't check TARGET_INTER_UNIT_MOVES.\n        (movsf_1): Don't check TARGET_INTER_UNIT_MOVES.\n        (zero_extendsidi2_32, zero_extendsidi2_rex64): Likewise.\n        (movsi_1_nointernunit, movdi_1_rex64_nointerunit): Remove.\n        (movsf_1_nointerunit, zero_extendsidi2_32_1): Remove.\n        (zero_extendsidi2_rex64_1): Remove.\n        (MOV0 peephole): Check GENERAL_REG_P.\n\nFrom-SVN: r93948", "tree": {"sha": "78c8580bac2ffbd2c711f0a2f348e76472dc1e0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78c8580bac2ffbd2c711f0a2f348e76472dc1e0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f75959a6a36a08908bfb66af87f67b00e056a4c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75959a6a36a08908bfb66af87f67b00e056a4c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f75959a6a36a08908bfb66af87f67b00e056a4c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f75959a6a36a08908bfb66af87f67b00e056a4c4/comments", "author": null, "committer": null, "parents": [{"sha": "b100079f2f901d64b6a0f3f996ba3a6d96e508c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b100079f2f901d64b6a0f3f996ba3a6d96e508c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b100079f2f901d64b6a0f3f996ba3a6d96e508c6"}], "stats": {"total": 380, "additions": 133, "deletions": 247}, "files": [{"sha": "68d704dda5b667c534f2c700d35b2edcc00a33b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f75959a6a36a08908bfb66af87f67b00e056a4c4", "patch": "@@ -1,3 +1,22 @@\n+2005-01-19  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/19511\n+\t* config/i386/i386.c (ix86_preferred_reload_class): Return a proper\n+\tsubclass of the input class.\n+\t(ix86_secondary_memory_needed): Always true for cross-MMX classes.\n+\tAlways true for cross-SSE1 classes.  Rationalize conditionals.\n+\t* config/i386/i386.h (SSE_CLASS_P, MMX_CLASS_P): Use straight equality.\n+\t* config/i386/i386.md (movsi_1): Add MMX/SSE zeros.  Fix alternatives\n+\tfor SSE1.  Don't check TARGET_INTER_UNIT_MOVES.\n+\t(movdi_2): Add MMX/SSE zeros.\n+\t(movdi_1_rex64): Likewise.  Don't check TARGET_INTER_UNIT_MOVES.\n+\t(movsf_1): Don't check TARGET_INTER_UNIT_MOVES.\n+\t(zero_extendsidi2_32, zero_extendsidi2_rex64): Likewise.\n+\t(movsi_1_nointernunit, movdi_1_rex64_nointerunit): Remove.\n+\t(movsf_1_nointerunit, zero_extendsidi2_32_1): Remove.\n+\t(zero_extendsidi2_rex64_1): Remove.\n+\t(MOV0 peephole): Check GENERAL_REG_P.\n+\n 2005-01-19  Richard Henderson  <rth@redhat.com>\n \n \tPR target/19427"}, {"sha": "a4ed0f7b02b53493f9fd355db51f43f6baafae78", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f75959a6a36a08908bfb66af87f67b00e056a4c4", "patch": "@@ -14599,6 +14599,8 @@ ix86_free_from_memory (enum machine_mode mode)\n enum reg_class\n ix86_preferred_reload_class (rtx x, enum reg_class class)\n {\n+  if (class == NO_REGS)\n+    return NO_REGS;\n   if (GET_CODE (x) == CONST_VECTOR && x != CONST0_RTX (GET_MODE (x)))\n     return NO_REGS;\n   if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != VOIDmode)\n@@ -14618,7 +14620,7 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n \t}\n       /* General regs can load everything.  */\n       if (reg_class_subset_p (class, GENERAL_REGS))\n-\treturn GENERAL_REGS;\n+\treturn class;\n       /* In case we haven't resolved FLOAT or SSE yet, give up.  */\n       if (MAYBE_FLOAT_CLASS_P (class) || MAYBE_SSE_CLASS_P (class))\n \treturn NO_REGS;\n@@ -14640,6 +14642,7 @@ ix86_preferred_reload_class (rtx x, enum reg_class class)\n \n    When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not\n    enforce these sanity checks.  */\n+\n int\n ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n \t\t\t      enum machine_mode mode, int strict)\n@@ -14653,21 +14656,50 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n     {\n       if (strict)\n \tabort ();\n-      else\n-\treturn 1;\n+      return true;\n     }\n-  return (FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class2)\n-\t  || ((SSE_CLASS_P (class1) != SSE_CLASS_P (class2)\n-\t       || MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n-\t      && ((mode != SImode && (mode != DImode || !TARGET_64BIT))\n-\t\t  || (!TARGET_INTER_UNIT_MOVES && !optimize_size))));\n+\n+  if (FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class2))\n+    return true;\n+\n+  /* ??? This is a lie.  We do have moves between mmx/general, and for\n+     mmx/sse2.  But by saying we need secondary memory we discourage the\n+     register allocator from using the mmx registers unless needed.  */\n+  if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n+    return true;\n+\n+  if (SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n+    {\n+      /* SSE1 doesn't have any direct moves from other classes.  */\n+      if (!TARGET_SSE2)\n+\treturn true;\n+\n+      /* If the target says that inter-unit moves are more expensive \n+\t than moving through memory, then don't generate them.  */\n+      if (!TARGET_INTER_UNIT_MOVES && !optimize_size)\n+\treturn true;\n+\n+      /* Between SSE and general, we have moves no larger than word size.  */\n+      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+\treturn true;\n+\n+      /* ??? For the cost of one register reformat penalty, we could use\n+\t the same instructions to move SFmode and DFmode data, but the \n+\t relevant move patterns don't support those alternatives.  */\n+      if (mode == SFmode || mode == DFmode)\n+\treturn true;\n+    }\n+\n+  return false;\n }\n+\n /* Return the cost of moving data from a register in class CLASS1 to\n    one in class CLASS2.\n \n    It is not required that the cost always equal 2 when FROM is the same as TO;\n    on some machines it is expensive to move between registers if they are not\n    general registers.  */\n+\n int\n ix86_register_move_cost (enum machine_mode mode, enum reg_class class1,\n \t\t\t enum reg_class class2)"}, {"sha": "5168da8b12f6fbd3d7200798ebd6586b66dd9c6c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f75959a6a36a08908bfb66af87f67b00e056a4c4", "patch": "@@ -1307,9 +1307,9 @@ enum reg_class\n #define FLOAT_CLASS_P(CLASS) \\\n   reg_class_subset_p ((CLASS), FLOAT_REGS)\n #define SSE_CLASS_P(CLASS) \\\n-  reg_class_subset_p ((CLASS), SSE_REGS)\n+  ((CLASS) == SSE_REGS)\n #define MMX_CLASS_P(CLASS) \\\n-  reg_class_subset_p ((CLASS), MMX_REGS)\n+  ((CLASS) == MMX_REGS)\n #define MAYBE_INTEGER_CLASS_P(CLASS) \\\n   reg_classes_intersect_p ((CLASS), GENERAL_REGS)\n #define MAYBE_FLOAT_CLASS_P(CLASS) \\"}, {"sha": "380836e7a05b046bb69223810c84c391452ba201", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 72, "deletions": 237, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f75959a6a36a08908bfb66af87f67b00e056a4c4/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f75959a6a36a08908bfb66af87f67b00e056a4c4", "patch": "@@ -1126,59 +1126,35 @@\n \n (define_insn \"*movsi_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\"=r  ,m  ,!*y,!rm,!*y,!*x,!rm,!*x\")\n+\t\t\t\"=r  ,m  ,*y,*y,?rm,?*y,*x,*x,?r,m ,?*Y,*x\")\n \t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"rinm,rin,*y ,*y ,rm ,*x ,*x ,rm\"))]\n-  \"(TARGET_INTER_UNIT_MOVES || optimize_size)\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+\t\t\t\"rinm,rin,C ,*y,*y ,rm ,C ,*x,*Y,*x,r  ,m \"))]\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n     {\n-    case TYPE_SSEMOV:\n+    case TYPE_SSELOG1:\n       if (get_attr_mode (insn) == MODE_TI)\n-        return \"movdqa\\t{%1, %0|%0, %1}\";\n-      return \"movd\\t{%1, %0|%0, %1}\";\n+        return \"pxor\\t%0, %0\";\n+      return \"xorps\\t%0, %0\";\n \n-    case TYPE_MMXMOV:\n-      if (get_attr_mode (insn) == MODE_DI)\n-\treturn \"movq\\t{%1, %0|%0, %1}\";\n-      return \"movd\\t{%1, %0|%0, %1}\";\n-\n-    case TYPE_LEA:\n-      return \"lea{l}\\t{%1, %0|%0, %1}\";\n-\n-    default:\n-      if (flag_pic && !LEGITIMATE_PIC_OPERAND_P (operands[1]))\n-\tabort();\n-      return \"mov{l}\\t{%1, %0|%0, %1}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"2,3,4\")\n-\t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"5,6,7\")\n-\t      (const_string \"ssemov\")\n-\t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n-\t\t (match_operand:SI 1 \"symbolic_operand\" \"\"))\n-\t      (const_string \"lea\")\n-\t   ]\n-\t   (const_string \"imov\")))\n-   (set_attr \"mode\" \"SI,SI,DI,SI,SI,TI,SI,SI\")])\n-\n-(define_insn \"*movsi_1_nointernunit\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\"\n-\t\t\t\"=r  ,m  ,!*y,!m,!*y,!*x,!m,!*x\")\n-\t(match_operand:SI 1 \"general_operand\"\n-\t\t\t\"rinm,rin,*y ,*y,m  ,*x ,*x,m\"))]\n-  \"(!TARGET_INTER_UNIT_MOVES && !optimize_size)\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n     case TYPE_SSEMOV:\n-      if (get_attr_mode (insn) == MODE_TI)\n-        return \"movdqa\\t{%1, %0|%0, %1}\";\n-      return \"movd\\t{%1, %0|%0, %1}\";\n+      switch (get_attr_mode (insn))\n+\t{\n+\tcase MODE_TI:\n+\t  return \"movdqa\\t{%1, %0|%0, %1}\";\n+\tcase MODE_V4SF:\n+\t  return \"movaps\\t{%1, %0|%0, %1}\";\n+\tcase MODE_SI:\n+          return \"movd\\t{%1, %0|%0, %1}\";\n+\tcase MODE_SF:\n+          return \"movss\\t{%1, %0|%0, %1}\";\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+    case TYPE_MMXADD:\n+      return \"pxor\\t%0, %0\";\n \n     case TYPE_MMXMOV:\n       if (get_attr_mode (insn) == MODE_DI)\n@@ -1195,16 +1171,32 @@\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"2,3,4\")\n+     (cond [(eq_attr \"alternative\" \"2\")\n+\t      (const_string \"mmxadd\")\n+\t    (eq_attr \"alternative\" \"3,4,5\")\n \t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"5,6,7\")\n+\t    (eq_attr \"alternative\" \"6\")\n+\t      (const_string \"sselog1\")\n+\t    (eq_attr \"alternative\" \"7,8,9,10,11\")\n \t      (const_string \"ssemov\")\n \t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n \t\t (match_operand:SI 1 \"symbolic_operand\" \"\"))\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"mode\" \"SI,SI,DI,SI,SI,TI,SI,SI\")])\n+   (set (attr \"mode\")\n+     (cond [(eq_attr \"alternative\" \"2,3\")\n+\t      (const_string \"DI\")\n+\t    (eq_attr \"alternative\" \"6,7\")\n+\t      (if_then_else\n+\t        (eq (symbol_ref \"TARGET_SSE2\") (const_int 0))\n+\t        (const_string \"V4SF\")\n+\t        (const_string \"TI\"))\n+\t    (and (eq_attr \"alternative\" \"8,9,10,11\")\n+\t         (eq (symbol_ref \"TARGET_SSE2\") (const_int 0)))\n+\t      (const_string \"SF\")\n+\t   ]\n+\t   (const_string \"SI\")))])\n \n ;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -1903,24 +1895,26 @@\n \n (define_insn \"*movdi_2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t\t\t\"=r  ,o  ,m*y,*y,m ,*Y,*Y,m ,*x,*x\")\n+\t\t\t\t\"=r  ,o  ,*y,m*y,*y,*Y,m ,*Y,*Y,*x,m ,*x,*x\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\t\t\t\"riFo,riF,*y ,m ,*Y,*Y,m ,*x,*x,m \"))]\n-  \"!TARGET_64BIT\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+\t\t\t\t\"riFo,riF,C ,*y ,m ,C ,*Y,*Y,m ,C ,*x,*x,m \"))]\n+  \"!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n   \"@\n    #\n    #\n+   pxor\\t%0, %0\n    movq\\t{%1, %0|%0, %1}\n    movq\\t{%1, %0|%0, %1}\n+   pxor\\t%0, %0\n    movq\\t{%1, %0|%0, %1}\n    movdqa\\t{%1, %0|%0, %1}\n    movq\\t{%1, %0|%0, %1}\n+   xorps\\t%0, %0\n    movlps\\t{%1, %0|%0, %1}\n    movaps\\t{%1, %0|%0, %1}\n    movlps\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"*,*,mmx,mmx,ssemov,ssemov,ssemov,ssemov,ssemov,ssemov\")\n-   (set_attr \"mode\" \"DI,DI,DI,DI,DI,TI,DI,V2SF,V4SF,V2SF\")])\n+  [(set_attr \"type\" \"*,*,mmxadd,mmxmov,mmxmov,sselog1,ssemov,ssemov,ssemov,sselog1,ssemov,ssemov,ssemov\")\n+   (set_attr \"mode\" \"DI,DI,DI,DI,DI,TI,DI,TI,DI,V4SF,V2SF,V4SF,V2SF\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"push_operand\" \"\")\n@@ -1942,17 +1936,15 @@\n \n (define_insn \"*movdi_1_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\"=r,r  ,r,mr,!mr,!*y,!rm,!*y,!*x,!rm,!*x,!*x,!*y\")\n+\t\t\"=r,r  ,r,m ,!m,*y,*y,?rm,?*y,*x,*x,?rm,?*x,?*x,?*y\")\n \t(match_operand:DI 1 \"general_operand\"\n-\t\t\"Z ,rem,i,re,n  ,*y ,*y ,rm ,*x ,*x ,rm ,*y ,*x\"))]\n-  \"TARGET_64BIT\n-   && (TARGET_INTER_UNIT_MOVES || optimize_size)\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+\t\t\"Z ,rem,i,re,n ,C ,*y,*y ,rm ,C ,*x,*x ,rm ,*y ,*x\"))]\n+  \"TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_SSECVT:\n-      if (which_alternative == 11)\n+      if (which_alternative == 13)\n \treturn \"movq2dq\\t{%1, %0|%0, %1}\";\n       else\n \treturn \"movdq2q\\t{%1, %0|%0, %1}\";\n@@ -1966,6 +1958,9 @@\n       if (GENERAL_REG_P (operands[0]) || GENERAL_REG_P (operands[1]))\n \t  return \"movd\\t{%1, %0|%0, %1}\";\n       return \"movq\\t{%1, %0|%0, %1}\";\n+    case TYPE_SSELOG1:\n+    case TYPE_MMXADD:\n+      return \"pxor\\t%0, %0\";\n     case TYPE_MULTI:\n       return \"#\";\n     case TYPE_LEA:\n@@ -1982,11 +1977,15 @@\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"5,6,7\")\n+     (cond [(eq_attr \"alternative\" \"5\")\n+\t      (const_string \"mmxadd\")\n+\t    (eq_attr \"alternative\" \"6,7,8\")\n \t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"8,9,10\")\n+\t    (eq_attr \"alternative\" \"9\")\n+\t      (const_string \"sselog1\")\n+\t    (eq_attr \"alternative\" \"10,11,12\")\n \t      (const_string \"ssemov\")\n-\t    (eq_attr \"alternative\" \"11,12\")\n+\t    (eq_attr \"alternative\" \"13,14\")\n \t      (const_string \"ssecvt\")\n \t    (eq_attr \"alternative\" \"4\")\n \t      (const_string \"multi\")\n@@ -1995,57 +1994,9 @@\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI,DI,DI,DI\")])\n-\n-(define_insn \"*movdi_1_rex64_nointerunit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\"=r,r ,r,mr,!mr,!*y,!m,!*y,!*Y,!m,!*Y\")\n-\t(match_operand:DI 1 \"general_operand\"\n-\t\t\"Z,rem,i,re,n  ,*y ,*y,m  ,*Y ,*Y,m\"))]\n-  \"TARGET_64BIT\n-   && (!TARGET_INTER_UNIT_MOVES && !optimize_size)\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_SSEMOV:\n-      if (get_attr_mode (insn) == MODE_TI)\n-\t  return \"movdqa\\t{%1, %0|%0, %1}\";\n-      /* FALLTHRU */\n-    case TYPE_MMXMOV:\n-      return \"movq\\t{%1, %0|%0, %1}\";\n-    case TYPE_MULTI:\n-      return \"#\";\n-    case TYPE_LEA:\n-      return \"lea{q}\\t{%a1, %0|%0, %a1}\";\n-    default:\n-      if (flag_pic && !LEGITIMATE_PIC_OPERAND_P (operands[1]))\n-\tabort ();\n-      if (get_attr_mode (insn) == MODE_SI)\n-\treturn \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n-      else if (which_alternative == 2)\n-\treturn \"movabs{q}\\t{%1, %0|%0, %1}\";\n-      else\n-\treturn \"mov{q}\\t{%1, %0|%0, %1}\";\n-    }\n-}\n-  [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"5,6,7\")\n-\t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"8,9,10\")\n-\t      (const_string \"ssemov\")\n-\t    (eq_attr \"alternative\" \"4\")\n-\t      (const_string \"multi\")\n- \t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n-\t\t (match_operand:DI 1 \"symbolic_operand\" \"\"))\n-\t      (const_string \"lea\")\n-\t   ]\n-\t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*\")\n-   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI,DI\")])\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,DI,TI,TI,DI,DI,DI,DI\")])\n \n ;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -2305,98 +2256,7 @@\n \t  \"=f#xr,m   ,f#xr,r#xf  ,m    ,x#rf,x#rf,x#rf ,m   ,!*y,!rm,!*y\")\n \t(match_operand:SF 1 \"general_operand\"\n \t  \"fm#rx,f#rx,G   ,rmF#fx,Fr#fx,C   ,x   ,xm#rf,x#rf,rm ,*y ,*y\"))]\n-  \"(TARGET_INTER_UNIT_MOVES || optimize_size)\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n-   && (reload_in_progress || reload_completed\n-       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n-       || GET_CODE (operands[1]) != CONST_DOUBLE\n-       || memory_operand (operands[0], SFmode))\" \n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return output_387_reg_move (insn, operands);\n-\n-    case 1:\n-      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n-        return \"fstp%z0\\t%y0\";\n-      else\n-        return \"fst%z0\\t%y0\";\n-\n-    case 2:\n-      return standard_80387_constant_opcode (operands[1]);\n-\n-    case 3:\n-    case 4:\n-      return \"mov{l}\\t{%1, %0|%0, %1}\";\n-    case 5:\n-      if (get_attr_mode (insn) == MODE_TI)\n-\treturn \"pxor\\t%0, %0\";\n-      else\n-\treturn \"xorps\\t%0, %0\";\n-    case 6:\n-      if (get_attr_mode (insn) == MODE_V4SF)\n-\treturn \"movaps\\t{%1, %0|%0, %1}\";\n-      else\n-\treturn \"movss\\t{%1, %0|%0, %1}\";\n-    case 7:\n-    case 8:\n-      return \"movss\\t{%1, %0|%0, %1}\";\n-\n-    case 9:\n-    case 10:\n-      return \"movd\\t{%1, %0|%0, %1}\";\n-\n-    case 11:\n-      return \"movq\\t{%1, %0|%0, %1}\";\n-\n-    default:\n-      abort();\n-    }\n-}\n-  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,ssemov,ssemov,ssemov,ssemov,mmxmov,mmxmov,mmxmov\")\n-   (set (attr \"mode\")\n-        (cond [(eq_attr \"alternative\" \"3,4,9,10\")\n-\t\t (const_string \"SI\")\n-\t       (eq_attr \"alternative\" \"5\")\n-\t\t (if_then_else\n-\t\t   (and (and (ne (symbol_ref \"TARGET_SSE_LOAD0_BY_PXOR\")\n-\t\t\t    \t (const_int 0))\n-\t\t\t     (ne (symbol_ref \"TARGET_SSE2\")\n-\t\t\t\t (const_int 0)))\n-\t\t\t(eq (symbol_ref \"optimize_size\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_string \"TI\")\n-\t\t   (const_string \"V4SF\"))\n-\t       /* For architectures resolving dependencies on\n-\t\t  whole SSE registers use APS move to break dependency\n-\t\t  chains, otherwise use short move to avoid extra work. \n-\n-\t\t  Do the same for architectures resolving dependencies on\n-\t\t  the parts.  While in DF mode it is better to always handle\n-\t\t  just register parts, the SF mode is different due to lack\n-\t\t  of instructions to load just part of the register.  It is\n-\t\t  better to maintain the whole registers in single format\n-\t\t  to avoid problems on using packed logical operations.  */\n-\t       (eq_attr \"alternative\" \"6\")\n-\t\t (if_then_else\n-\t\t   (ior (ne (symbol_ref \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n-\t\t\t    (const_int 0))\n-\t\t\t(ne (symbol_ref \"TARGET_SSE_SPLIT_REGS\")\n-\t\t\t    (const_int 0)))\n-\t\t   (const_string \"V4SF\")\n-\t\t   (const_string \"SF\"))\n-\t       (eq_attr \"alternative\" \"11\")\n-\t\t (const_string \"DI\")]\n-\t       (const_string \"SF\")))])\n-\n-(define_insn \"*movsf_1_nointerunit\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\"\n-\t  \"=f#xr,m   ,f#xr,r#xf  ,m    ,x#rf,x#rf,x#rf ,m   ,!*y,!m,!*y\")\n-\t(match_operand:SF 1 \"general_operand\"\n-\t  \"fm#rx,f#rx,G   ,rmF#fx,Fr#fx,C   ,x   ,xm#rf,x#rf,m  ,*y,*y\"))]\n-  \"(!TARGET_INTER_UNIT_MOVES && !optimize_size)\n-   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+  \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE\n@@ -3273,24 +3133,10 @@\n   \")\n \n (define_insn \"zero_extendsidi2_32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o,!?y,!?Y\")\n-\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r,m,m\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && !TARGET_INTER_UNIT_MOVES\"\n-  \"@\n-   #\n-   #\n-   #\n-   movd\\t{%1, %0|%0, %1}\n-   movd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"mode\" \"SI,SI,SI,DI,TI\")\n-   (set_attr \"type\" \"multi,multi,multi,mmxmov,ssemov\")])\n-\n-(define_insn \"*zero_extendsidi2_32_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o,!?y,!?Y\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o,?*y,?*Y\")\n \t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r,rm,rm\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_INTER_UNIT_MOVES\"\n+  \"!TARGET_64BIT\"\n   \"@\n    #\n    #\n@@ -3301,21 +3147,9 @@\n    (set_attr \"type\" \"multi,multi,multi,mmxmov,ssemov\")])\n \n (define_insn \"zero_extendsidi2_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!?y,!?Y\")\n-     (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,m,m\")))]\n-  \"TARGET_64BIT && !TARGET_INTER_UNIT_MOVES\"\n-  \"@\n-   mov\\t{%k1, %k0|%k0, %k1}\n-   #\n-   movd\\t{%1, %0|%0, %1}\n-   movd\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"imovx,imov,mmxmov,ssemov\")\n-   (set_attr \"mode\" \"SI,DI,DI,TI\")])\n-\n-(define_insn \"*zero_extendsidi2_rex64_1\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!?y,!*?\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,?*y,?*Y\")\n      (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,rm,rm\")))]\n-  \"TARGET_64BIT && TARGET_INTER_UNIT_MOVES\"\n+  \"TARGET_64BIT\"\n   \"@\n    mov\\t{%k1, %k0|%k0, %k1}\n    #\n@@ -18534,6 +18368,7 @@\n     || GET_MODE (operands[0]) == SImode\n     || (GET_MODE (operands[0]) == DImode && TARGET_64BIT))\n    && (! TARGET_USE_MOV0 || optimize_size)\n+   && GENERAL_REG_P (operands[0])\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int 0))\n \t      (clobber (reg:CC FLAGS_REG))])]"}]}