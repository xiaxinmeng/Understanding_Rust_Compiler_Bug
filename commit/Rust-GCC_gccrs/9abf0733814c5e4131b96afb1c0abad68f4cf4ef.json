{"sha": "9abf0733814c5e4131b96afb1c0abad68f4cf4ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFiZjA3MzM4MTRjNWU0MTMxYjk2YWZiMWMwYWJhZDY4ZjRjZjRlZg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-02T19:27:37Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-03T10:38:13Z"}, "message": "Fix type resolution null pointer crash\n\nThis also enhance ArithmeticOrLogicalExpr rules and associated error\nhandling to propagate up the stack.", "tree": {"sha": "1f37be267944d69e0de385c57c16bd9d077525cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f37be267944d69e0de385c57c16bd9d077525cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9abf0733814c5e4131b96afb1c0abad68f4cf4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abf0733814c5e4131b96afb1c0abad68f4cf4ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abf0733814c5e4131b96afb1c0abad68f4cf4ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abf0733814c5e4131b96afb1c0abad68f4cf4ef/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "419677348e1c1e6092e74f55b3a7326a595d6114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419677348e1c1e6092e74f55b3a7326a595d6114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/419677348e1c1e6092e74f55b3a7326a595d6114"}], "stats": {"total": 142, "additions": 73, "deletions": 69}, "files": [{"sha": "82977e42a78dc0edf812c5b50c222808f0feeb76", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 64, "deletions": 69, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abf0733814c5e4131b96afb1c0abad68f4cf4ef/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abf0733814c5e4131b96afb1c0abad68f4cf4ef/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=9abf0733814c5e4131b96afb1c0abad68f4cf4ef", "patch": "@@ -37,12 +37,7 @@ class TypeCheckExpr : public TypeCheckBase\n     expr->accept_vis (resolver);\n \n     if (resolver.infered == nullptr)\n-      {\n-\trust_error_at (expr->get_locus_slow (),\n-\t\t       \"failed to resolve type for %s\\n\",\n-\t\t       expr->as_string ().c_str ());\n-\treturn nullptr;\n-      }\n+      return new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n \n     auto ref = expr->get_mappings ().get_hirid ();\n     resolver.infered->set_ref (ref);\n@@ -430,73 +425,19 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n-    auto combined = lhs->combine (rhs);\n \n-    // https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators\n-    switch (expr.get_expr_type ())\n+    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+    bool valid = valid_lhs && valid_rhs;\n+    if (!valid)\n       {\n-\t// integers or floats\n-      case HIR::ArithmeticOrLogicalExpr::ADD:\n-      case HIR::ArithmeticOrLogicalExpr::SUBTRACT:\n-      case HIR::ArithmeticOrLogicalExpr::MULTIPLY:\n-      case HIR::ArithmeticOrLogicalExpr::DIVIDE:\n-\tcase HIR::ArithmeticOrLogicalExpr::MODULUS: {\n-\t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::FLOAT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n-\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n-\t\t\t       == TyTy::InferType::INTEGRAL))\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n-\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n-\t\t\t       == TyTy::InferType::FLOAT));\n-\t  if (!valid)\n-\t    {\n-\t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n-\t\t\t     combined->as_string ().c_str ());\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\t// integers or bools\n-      case HIR::ArithmeticOrLogicalExpr::BITWISE_AND:\n-      case HIR::ArithmeticOrLogicalExpr::BITWISE_OR:\n-\tcase HIR::ArithmeticOrLogicalExpr::BITWISE_XOR: {\n-\t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::BOOL)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n-\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n-\t\t\t       == TyTy::InferType::INTEGRAL));\n-\t  if (!valid)\n-\t    {\n-\t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n-\t\t\t     combined->as_string ().c_str ());\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n-\n-\t// integers only\n-      case HIR::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n-\tcase HIR::ArithmeticOrLogicalExpr::RIGHT_SHIFT: {\n-\t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n-\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n-\t\t\t       == TyTy::InferType::INTEGRAL));\n-\t  if (!valid)\n-\t    {\n-\t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n-\t\t\t     combined->as_string ().c_str ());\n-\t      return;\n-\t    }\n-\t}\n-\tbreak;\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"cannot apply this operator to types %s and %s\",\n+\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+\treturn;\n       }\n \n-    infered = combined;\n+    infered = lhs->combine (rhs);\n     infered->append_reference (lhs->get_ref ());\n     infered->append_reference (rhs->get_ref ());\n   }\n@@ -596,7 +537,10 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tauto expected_ty = context->peek_return_type ();\n \tinfered = expected_ty->combine (blk_expr);\n+\treturn;\n       }\n+\n+    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::IfExprConseqElse &expr)\n@@ -635,7 +579,10 @@ class TypeCheckExpr : public TypeCheckBase\n \tauto else_blk_combined = expected_ty->combine (else_block_tyty);\n \n \tinfered = if_blk_combined->combine (else_blk_combined);\n+\treturn;\n       }\n+\n+    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::IfExprConseqIf &expr)\n@@ -651,7 +598,10 @@ class TypeCheckExpr : public TypeCheckBase\n \n \tinfered = expected_ty->combine (if_blk);\n \tinfered = infered->combine (elif_blk);\n+\treturn;\n       }\n+\n+    infered = new TyTy::UnitType (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::BlockExpr &expr);\n@@ -806,6 +756,51 @@ class TypeCheckExpr : public TypeCheckBase\n       is_final_expr (is_final_expr)\n   {}\n \n+  bool\n+  validate_arithmetic_type (TyTy::TyBase *type,\n+\t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type)\n+  {\n+    // https://doc.rust-lang.org/reference/expressions/operator-expr.html#arithmetic-and-logical-binary-operators\n+    // this will change later when traits are added\n+    switch (expr_type)\n+      {\n+      case HIR::ArithmeticOrLogicalExpr::ADD:\n+      case HIR::ArithmeticOrLogicalExpr::SUBTRACT:\n+      case HIR::ArithmeticOrLogicalExpr::MULTIPLY:\n+      case HIR::ArithmeticOrLogicalExpr::DIVIDE:\n+      case HIR::ArithmeticOrLogicalExpr::MODULUS:\n+\treturn (type->get_kind () == TyTy::TypeKind::INT)\n+\t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::FLOAT)\n+\t       || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n+\t\t       == TyTy::InferType::INTEGRAL))\n+\t       || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n+\t\t       == TyTy::InferType::FLOAT));\n+\n+\t// integers or bools\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_AND:\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_OR:\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_XOR:\n+\treturn (type->get_kind () == TyTy::TypeKind::INT)\n+\t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::BOOL)\n+\t       || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n+\t\t       == TyTy::InferType::INTEGRAL));\n+\n+\t// integers only\n+      case HIR::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n+      case HIR::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n+\treturn (type->get_kind () == TyTy::TypeKind::INT)\n+\t       || (type->get_kind () == TyTy::TypeKind::UINT)\n+\t       || (type->get_kind () == TyTy::TypeKind::INFER\n+\t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n+\t\t       == TyTy::InferType::INTEGRAL));\n+      }\n+  }\n+\n   TyTy::TyBase *infered;\n   TyTy::TyBase *infered_array_elems;\n "}, {"sha": "416cd893cf490d708bc5095db5ab12bdd07a6466", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abf0733814c5e4131b96afb1c0abad68f4cf4ef/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abf0733814c5e4131b96afb1c0abad68f4cf4ef/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=9abf0733814c5e4131b96afb1c0abad68f4cf4ef", "patch": "@@ -23,6 +23,9 @@\n #include \"rust-hir-type-check-expr.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n \n+extern bool\n+saw_errors (void);\n+\n namespace Rust {\n namespace Resolver {\n \n@@ -32,9 +35,15 @@ TypeResolution::Resolve (HIR::Crate &crate)\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     TypeCheckTopLevel::Resolve (it->get ());\n \n+  if (saw_errors ())\n+    return;\n+\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     TypeCheckItem::Resolve (it->get ());\n \n+  if (saw_errors ())\n+    return;\n+\n   auto mappings = Analysis::Mappings::get ();\n   auto context = TypeCheckContext::get ();\n "}]}