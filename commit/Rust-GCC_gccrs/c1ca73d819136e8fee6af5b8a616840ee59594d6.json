{"sha": "c1ca73d819136e8fee6af5b8a616840ee59594d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFjYTczZDgxOTEzNmU4ZmVlNmFmNWI4YTYxNjg0MGVlNTk1OTRkNg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2013-02-08T12:31:19Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2013-02-08T12:31:19Z"}, "message": "re PR tree-optimization/52448 (cselim broken with calls)\n\n\tPR tree-optimization/52448\n\n\t* tree-ssa-phiopt.c (struct name_to_bb): Add phase member.\n\t(nt_call_phase): New static.\n\t(add_or_mark_expr): Only mark accesses with newer phase than any\n\tcall seen.\n\t(nonfreeing_call_p): New.\n\t(nt_init_block): Update nt_call_phase, mark blocks as visited.\n\t(nt_fini_block): Keep blocks marked as visited.\n\t(get_non_trapping): Initialize nt_call_phase, and reset aux pointer.\n\ntestsuite/\n\tPR tree-optimization/52448\n\t* gcc.dg/pr52448.c: New test.\n\nFrom-SVN: r195883", "tree": {"sha": "99700408764ad5a20e6a73e2ec4fd9e31bc0b840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99700408764ad5a20e6a73e2ec4fd9e31bc0b840"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1ca73d819136e8fee6af5b8a616840ee59594d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ca73d819136e8fee6af5b8a616840ee59594d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ca73d819136e8fee6af5b8a616840ee59594d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ca73d819136e8fee6af5b8a616840ee59594d6/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57548aa2498bf086d23cdc30993a65c36993542b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57548aa2498bf086d23cdc30993a65c36993542b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57548aa2498bf086d23cdc30993a65c36993542b"}], "stats": {"total": 104, "additions": 98, "deletions": 6}, "files": [{"sha": "d54c1c0f6c662a0bbe579fcc833ce2a99bcd5cf4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1ca73d819136e8fee6af5b8a616840ee59594d6", "patch": "@@ -1,3 +1,15 @@\n+2013-02-08  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/52448\n+\t* tree-ssa-phiopt.c (struct name_to_bb): Add phase member.\n+\t(nt_call_phase): New static.\n+\t(add_or_mark_expr): Only mark accesses with newer phase than any\n+\tcall seen.\n+\t(nonfreeing_call_p): New.\n+\t(nt_init_block): Update nt_call_phase, mark blocks as visited.\n+\t(nt_fini_block): Keep blocks marked as visited.\n+\t(get_non_trapping): Initialize nt_call_phase, and reset aux pointer.\n+\n 2013-02-08  Richard Biener  <rguenther@suse.de>\n \n \t* ira.c (ira): Free broken dominator information."}, {"sha": "1209b9439e67d408e35f6f4d7cefa7e328577a61", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c1ca73d819136e8fee6af5b8a616840ee59594d6", "patch": "@@ -1,3 +1,8 @@\n+2013-02-08  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/52448\n+\t* gcc.dg/pr52448.c: New test.\n+\n 2013-02-08  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/56181"}, {"sha": "0aeb2130f2c9b3814455fa05b361ef12177a7fce", "filename": "gcc/testsuite/gcc.dg/pr52448.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52448.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52448.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52448.c?ref=c1ca73d819136e8fee6af5b8a616840ee59594d6", "patch": "@@ -0,0 +1,30 @@\n+/* PR tree-optimization/52448 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-cselim -fdump-tree-cselim-details\" } */\n+\n+extern void perhaps_free_something (void);\n+\n+void f1 (int *p, int a, int b, int cond, int cond2)\n+{\n+  *p = a;\n+  if (cond)\n+    perhaps_free_something ();\n+  if (cond2)\n+    *p = b;\n+}\n+\n+void f2 (int *p, int a, int b, int *cond, int *cond2)\n+{\n+  int i;\n+  *p = a;\n+  for (i = 0; cond[i]; i++)\n+    {\n+      if (cond2[i])\n+        *p = b;\n+      perhaps_free_something ();\n+    }\n+}\n+\n+/* None of the above conditional stores might be made unconditional.  */\n+/* { dg-final { scan-tree-dump-not \"cstore\" \"cselim\" } } */\n+/* { dg-final { cleanup-tree-dump \"cselim\" } } */"}, {"sha": "61199437dbe4c40031a47bde7543e2c7d2a026b9", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1ca73d819136e8fee6af5b8a616840ee59594d6/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c1ca73d819136e8fee6af5b8a616840ee59594d6", "patch": "@@ -1233,6 +1233,7 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n struct name_to_bb\n {\n   unsigned int ssa_name_ver;\n+  unsigned int phase;\n   bool store;\n   HOST_WIDE_INT offset, size;\n   basic_block bb;\n@@ -1241,6 +1242,10 @@ struct name_to_bb\n /* The hash table for remembering what we've seen.  */\n static htab_t seen_ssa_names;\n \n+/* Used for quick clearing of the hash-table when we see calls.\n+   Hash entries with phase < nt_call_phase are invalid.  */\n+static unsigned int nt_call_phase;\n+\n /* The set of MEM_REFs which can't trap.  */\n static struct pointer_set_t *nontrap_set;\n \n@@ -1291,20 +1296,21 @@ add_or_mark_expr (basic_block bb, tree exp,\n       /* Try to find the last seen MEM_REF through the same\n          SSA_NAME, which can trap.  */\n       map.ssa_name_ver = SSA_NAME_VERSION (name);\n+      map.phase = 0;\n       map.bb = 0;\n       map.store = store;\n       map.offset = tree_low_cst (TREE_OPERAND (exp, 1), 0);\n       map.size = size;\n \n       slot = htab_find_slot (seen_ssa_names, &map, INSERT);\n       n2bb = (struct name_to_bb *) *slot;\n-      if (n2bb)\n+      if (n2bb && n2bb->phase >= nt_call_phase)\n         found_bb = n2bb->bb;\n \n       /* If we've found a trapping MEM_REF, _and_ it dominates EXP\n          (it's in a basic block on the path from us to the dominator root)\n \t then we can't trap.  */\n-      if (found_bb && found_bb->aux == (void *)1)\n+      if (found_bb && (((size_t)found_bb->aux) & 1) == 1)\n \t{\n \t  pointer_set_insert (nontrap, exp);\n \t}\n@@ -1313,12 +1319,14 @@ add_or_mark_expr (basic_block bb, tree exp,\n \t  /* EXP might trap, so insert it into the hash table.  */\n \t  if (n2bb)\n \t    {\n+\t      n2bb->phase = nt_call_phase;\n \t      n2bb->bb = bb;\n \t    }\n \t  else\n \t    {\n \t      n2bb = XNEW (struct name_to_bb);\n \t      n2bb->ssa_name_ver = SSA_NAME_VERSION (name);\n+\t      n2bb->phase = nt_call_phase;\n \t      n2bb->bb = bb;\n \t      n2bb->store = store;\n \t      n2bb->offset = map.offset;\n@@ -1329,20 +1337,55 @@ add_or_mark_expr (basic_block bb, tree exp,\n     }\n }\n \n+/* Return true when CALL is a call stmt that definitely doesn't\n+   free any memory or makes it unavailable otherwise.  */\n+static bool\n+nonfreeing_call_p (gimple call)\n+{\n+  if (gimple_call_builtin_p (call, BUILT_IN_NORMAL)\n+      && gimple_call_flags (call) & ECF_LEAF)\n+    switch (DECL_FUNCTION_CODE (gimple_call_fndecl (call)))\n+      {\n+\t/* Just in case these become ECF_LEAF in the future.  */\n+\tcase BUILT_IN_FREE:\n+\tcase BUILT_IN_TM_FREE:\n+\tcase BUILT_IN_REALLOC:\n+\tcase BUILT_IN_STACK_RESTORE:\n+\t  return false;\n+\tdefault:\n+\t  return true;\n+      }\n+\n+  return false;\n+}\n+\n /* Called by walk_dominator_tree, when entering the block BB.  */\n static void\n nt_init_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n {\n+  edge e;\n+  edge_iterator ei;\n   gimple_stmt_iterator gsi;\n-  /* Mark this BB as being on the path to dominator root.  */\n-  bb->aux = (void*)1;\n+\n+  /* If we haven't seen all our predecessors, clear the hash-table.  */\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if ((((size_t)e->src->aux) & 2) == 0)\n+      {\n+\tnt_call_phase++;\n+\tbreak;\n+      }\n+\n+  /* Mark this BB as being on the path to dominator root and as visited.  */\n+  bb->aux = (void*)(1 | 2);\n \n   /* And walk the statements in order.  */\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n \n-      if (gimple_assign_single_p (stmt) && !gimple_has_volatile_ops (stmt))\n+      if (is_gimple_call (stmt) && !nonfreeing_call_p (stmt))\n+\tnt_call_phase++;\n+      else if (gimple_assign_single_p (stmt) && !gimple_has_volatile_ops (stmt))\n \t{\n \t  add_or_mark_expr (bb, gimple_assign_lhs (stmt), nontrap_set, true);\n \t  add_or_mark_expr (bb, gimple_assign_rhs1 (stmt), nontrap_set, false);\n@@ -1355,7 +1398,7 @@ static void\n nt_fini_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n {\n   /* This BB isn't on the path to dominator root anymore.  */\n-  bb->aux = NULL;\n+  bb->aux = (void*)2;\n }\n \n /* This is the entry point of gathering non trapping memory accesses.\n@@ -1368,6 +1411,7 @@ get_non_trapping (void)\n   struct pointer_set_t *nontrap;\n   struct dom_walk_data walk_data;\n \n+  nt_call_phase = 0;\n   nontrap = pointer_set_create ();\n   seen_ssa_names = htab_create (128, name_to_bb_hash, name_to_bb_eq,\n \t\t\t\tfree);\n@@ -1389,6 +1433,7 @@ get_non_trapping (void)\n   fini_walk_dominator_tree (&walk_data);\n   htab_delete (seen_ssa_names);\n \n+  clear_aux_for_blocks ();\n   return nontrap;\n }\n "}]}