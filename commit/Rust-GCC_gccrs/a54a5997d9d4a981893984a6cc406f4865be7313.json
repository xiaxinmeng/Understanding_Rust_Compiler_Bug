{"sha": "a54a5997d9d4a981893984a6cc406f4865be7313", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU0YTU5OTdkOWQ0YTk4MTg5Mzk4NGE2Y2M0MDZmNDg2NWJlNzMxMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-12-03T14:36:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-12-03T14:36:19Z"}, "message": "Documentation tweaks for internal-fn-related optabs\n\nAs Bernd requested, this patch adds \"This pattern cannot FAIL\" to the\ndocumentation of optabs that came to be mapped to interal functions.\nFor consistency I did the same for optabs that were already being\nused for internal functions.\n\nMany of the optabs weren't documented in the first place, so I added\nentries for the missing ones.  Also, there were some inaccuracies in\nthe documentation of the rounding optabs.  The bitcount optabs said\nthat operand 0 has mode @var{m} and that operand 1 is under target\ncontrol, whereas it should be the other way around.\n\nTested on x86_64-linux-gnu.\n\ngcc/\n\t* doc/md.texi (vec_load_lanes@var{m}@var{n}): Document that\n\tthe pattern cannot FAIL.\n\t(vec_store_lanes@var{m}@var{n}): Likewise.\n\t(maskload@var{m}@var{n}): Likewise.\n\t(maskstore@var{m}@var{n}): Likewise.  Fix a cut-&-paste error\n\tin the name of the pattern.\n\t(rsqrt@var{m}2): Document that mode m must be a scalar or vector\n\tfloating-point mode and that all operands have that mode.\n\t(fmin@var{m}3, fmax@var{m}3): Likewise.  Document that the\n\tpattern cannot FAIL.\n\t(sqrt@var{m}2): Document that mode m must be a scalar or vector\n\tfloating-point mode, that all operands have that mode, and that\n\tthe patterns cannot FAIL.  Remove previous documentation referring\n\tto @code{double} and @code{float}.\n\t(fmod@var{m}3, remainder@var{m}3, cos@var{m}2, sin@var{m}2)\n\t(sincos@var{m}3, log@var{m}2, pow@var{m}3, atan2@var{m}3)\n\t(copysign@var{m}3): Likewise.\n\t(exp@var{m}2): Likewise.  Explicitly state the base.\n\t(floor@var{m}2): As for sqrt@var{m}2, but also specify the operands.\n\t(btrunc@var{m}2, rint@var{m}2): Likewise.\n\t(round@var{m}2): Likewise.  Fix incorrect description of rounding\n\teffect.\n\t(ceil@var{m}2): As for round@var{m}2.\n\t(nearbyint@var{m}2): As for floor@var{m}2, but also mention that\n\tthe instruction must not raise an inexact condition.\n\t(scalb@var{m}3): Document previously-undocumented pattern\n\t(ldexp@var{m}3, tan@var{m}2, asin@var{m}2, acos@var{m}2)\n\t(atan@var{m}2, expm1@var{m}2, exp10@var{m}2, exp2@var{m}2)\n\t(log1p@var{m}2, log10@var{m}2, log2@var{m}2, logb@var{m}2)\n\t(significand@var{m}2): Likewise.\n\t(ffs@var{m}2): Fix the description of the modes, so that operand 1 has\n\tmode m and operand 0 is defined more freely.  Document that @var{m}\n\tcan be a scalar or vector integer mode and that the pattern is not\n\tallowed to FAIL.\n\t(clz@var{m}2, ctz@var{m}2, popcount@var{m}2, parity@var{m}2): Likewise.\n\t(clrsb@var{m}2): Likewise, except that the description of the\n\tmode was missing in this case.\n\nFrom-SVN: r231230", "tree": {"sha": "dcf65555de40712297021ac18c1d860105f8de0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcf65555de40712297021ac18c1d860105f8de0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a54a5997d9d4a981893984a6cc406f4865be7313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54a5997d9d4a981893984a6cc406f4865be7313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a54a5997d9d4a981893984a6cc406f4865be7313", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a54a5997d9d4a981893984a6cc406f4865be7313/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ee62a5a60299fdc12c884337dd36767fd2230ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee62a5a60299fdc12c884337dd36767fd2230ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee62a5a60299fdc12c884337dd36767fd2230ac0"}], "stats": {"total": 393, "additions": 286, "deletions": 107}, "files": [{"sha": "f764ba938f09b5d6a06ccb3bbb887bd34c90f04f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54a5997d9d4a981893984a6cc406f4865be7313/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54a5997d9d4a981893984a6cc406f4865be7313/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a54a5997d9d4a981893984a6cc406f4865be7313", "patch": "@@ -1,3 +1,43 @@\n+2015-12-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* doc/md.texi (vec_load_lanes@var{m}@var{n}): Document that\n+\tthe pattern cannot FAIL.\n+\t(vec_store_lanes@var{m}@var{n}): Likewise.\n+\t(maskload@var{m}@var{n}): Likewise.\n+\t(maskstore@var{m}@var{n}): Likewise.  Fix a cut-&-paste error\n+\tin the name of the pattern.\n+\t(rsqrt@var{m}2): Document that mode m must be a scalar or vector\n+\tfloating-point mode and that all operands have that mode.\n+\t(fmin@var{m}3, fmax@var{m}3): Likewise.  Document that the\n+\tpattern cannot FAIL.\n+\t(sqrt@var{m}2): Document that mode m must be a scalar or vector\n+\tfloating-point mode, that all operands have that mode, and that\n+\tthe patterns cannot FAIL.  Remove previous documentation referring\n+\tto @code{double} and @code{float}.\n+\t(fmod@var{m}3, remainder@var{m}3, cos@var{m}2, sin@var{m}2)\n+\t(sincos@var{m}3, log@var{m}2, pow@var{m}3, atan2@var{m}3)\n+\t(copysign@var{m}3): Likewise.\n+\t(exp@var{m}2): Likewise.  Explicitly state the base.\n+\t(floor@var{m}2): As for sqrt@var{m}2, but also specify the operands.\n+\t(btrunc@var{m}2, rint@var{m}2): Likewise.\n+\t(round@var{m}2): Likewise.  Fix incorrect description of rounding\n+\teffect.\n+\t(ceil@var{m}2): As for round@var{m}2.\n+\t(nearbyint@var{m}2): As for floor@var{m}2, but also mention that\n+\tthe instruction must not raise an inexact condition.\n+\t(scalb@var{m}3): Document previously-undocumented pattern\n+\t(ldexp@var{m}3, tan@var{m}2, asin@var{m}2, acos@var{m}2)\n+\t(atan@var{m}2, expm1@var{m}2, exp10@var{m}2, exp2@var{m}2)\n+\t(log1p@var{m}2, log10@var{m}2, log2@var{m}2, logb@var{m}2)\n+\t(significand@var{m}2): Likewise.\n+\t(ffs@var{m}2): Fix the description of the modes, so that operand 1 has\n+\tmode m and operand 0 is defined more freely.  Document that @var{m}\n+\tcan be a scalar or vector integer mode and that the pattern is not\n+\tallowed to FAIL.\n+\t(clz@var{m}2, ctz@var{m}2, popcount@var{m}2, parity@var{m}2): Likewise.\n+\t(clrsb@var{m}2): Likewise, except that the description of the\n+\tmode was missing in this case.\n+\n 2015-12-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* internal-fn.def (RSQRT): New function."}, {"sha": "4848e6498362aa614b4e343bcee97b811a8dc169", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 246, "deletions": 107, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a54a5997d9d4a981893984a6cc406f4865be7313/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a54a5997d9d4a981893984a6cc406f4865be7313/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=a54a5997d9d4a981893984a6cc406f4865be7313", "patch": "@@ -4753,6 +4753,8 @@ is true.  GCC assumes that, if a target supports this kind of\n instruction for some mode @var{n}, it also supports unaligned\n loads for vectors of mode @var{n}.\n \n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_store_lanes@var{m}@var{n}} instruction pattern\n @item @samp{vec_store_lanes@var{m}@var{n}}\n Equivalent to @samp{vec_load_lanes@var{m}@var{n}}, with the memory\n@@ -4768,6 +4770,8 @@ for (j = 0; j < GET_MODE_NUNITS (@var{n}); j++)\n \n for a memory operand 0 and register operand 1.\n \n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_set@var{m}} instruction pattern\n @item @samp{vec_set@var{m}}\n Set given field in the vector value.  Operand 0 is the vector to modify,\n@@ -4822,12 +4826,16 @@ Perform a masked load of vector from memory operand 1 of mode @var{m}\n into register operand 0.  Mask is provided in register operand 2 of\n mode @var{n}.\n \n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{maskstore@var{m}@var{n}} instruction pattern\n-@item @samp{maskload@var{m}@var{n}}\n+@item @samp{maskstore@var{m}@var{n}}\n Perform a masked store of vector from register operand 1 of mode @var{m}\n into memory operand 0.  Mask is provided in register operand 2 of\n mode @var{n}.\n \n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{vec_perm@var{m}} instruction pattern\n @item @samp{vec_perm@var{m}}\n Output a (variable) vector permutation.  Operand 0 is the destination\n@@ -4993,6 +5001,9 @@ IEEE-conformant minimum and maximum operations.  If one operand is a quiet\n signalling @code{NaN} (-fsignaling-nans) an invalid floating point exception is\n raised and a quiet @code{NaN} is returned.\n \n+All operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.  These patterns are not allowed to @code{FAIL}.\n+\n @cindex @code{reduc_smin_@var{m}} instruction pattern\n @cindex @code{reduc_smax_@var{m}} instruction pattern\n @item @samp{reduc_smin_@var{m}}, @samp{reduc_smax_@var{m}}\n@@ -5324,16 +5335,17 @@ Store the absolute value of operand 1 into operand 0.\n \n @cindex @code{sqrt@var{m}2} instruction pattern\n @item @samp{sqrt@var{m}2}\n-Store the square root of operand 1 into operand 0.\n+Store the square root of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{sqrt} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{sqrtf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{rsqrt@var{m}2} instruction pattern\n @item @samp{rsqrt@var{m}2}\n Store the reciprocal of the square root of operand 1 into operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n+\n On most architectures this pattern is only approximate, so either\n its C condition or the @code{TARGET_OPTAB_SUPPORTED_P} hook should\n check for the appropriate math flags.  (Using the C condition is\n@@ -5346,151 +5358,243 @@ This pattern is not allowed to @code{FAIL}.\n @cindex @code{fmod@var{m}3} instruction pattern\n @item @samp{fmod@var{m}3}\n Store the remainder of dividing operand 1 by operand 2 into\n-operand 0, rounded towards zero to an integer.\n+operand 0, rounded towards zero to an integer.  All operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{fmod} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{fmodf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{remainder@var{m}3} instruction pattern\n @item @samp{remainder@var{m}3}\n Store the remainder of dividing operand 1 by operand 2 into\n-operand 0, rounded to the nearest integer.\n+operand 0, rounded to the nearest integer.  All operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{scalb@var{m}3} instruction pattern\n+@item @samp{scalb@var{m}3}\n+Raise @code{FLT_RADIX} to the power of operand 2, multiply it by\n+operand 1, and store the result in operand 0.  All operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n-The @code{remainder} built-in function of C always uses the mode\n-which corresponds to the C data type @code{double} and the\n-@code{remainderf} built-in function uses the mode which corresponds\n-to the C data type @code{float}.\n+@cindex @code{ldexp@var{m}3} instruction pattern\n+@item @samp{ldexp@var{m}3}\n+Raise 2 to the power of operand 2, multiply it by operand 1, and store\n+the result in operand 0.  Operands 0 and 1 have mode @var{m}, which is\n+a scalar or vector floating-point mode.  Operand 2's mode has\n+the same number of elements as @var{m} and each element is wide\n+enough to store an @code{int}.  The integers are signed.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{cos@var{m}2} instruction pattern\n @item @samp{cos@var{m}2}\n-Store the cosine of operand 1 into operand 0.\n+Store the cosine of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{cos} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{cosf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{sin@var{m}2} instruction pattern\n @item @samp{sin@var{m}2}\n-Store the sine of operand 1 into operand 0.\n+Store the sine of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{sin} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{sinf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{sincos@var{m}3} instruction pattern\n @item @samp{sincos@var{m}3}\n Store the cosine of operand 2 into operand 0 and the sine of\n-operand 2 into operand 1.\n+operand 2 into operand 1.  All operands have mode @var{m},\n+which is a scalar or vector floating-point mode.\n \n-The @code{sin} and @code{cos} built-in functions of C always use the\n-mode which corresponds to the C data type @code{double} and the\n-@code{sinf} and @code{cosf} built-in function use the mode which\n-corresponds to the C data type @code{float}.\n Targets that can calculate the sine and cosine simultaneously can\n implement this pattern as opposed to implementing individual\n @code{sin@var{m}2} and @code{cos@var{m}2} patterns.  The @code{sin}\n and @code{cos} built-in functions will then be expanded to the\n @code{sincos@var{m}3} pattern, with one of the output values\n left unused.\n \n+@cindex @code{tan@var{m}2} instruction pattern\n+@item @samp{tan@var{m}2}\n+Store the tangent of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{asin@var{m}2} instruction pattern\n+@item @samp{asin@var{m}2}\n+Store the arc sine of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{acos@var{m}2} instruction pattern\n+@item @samp{acos@var{m}2}\n+Store the arc cosine of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{atan@var{m}2} instruction pattern\n+@item @samp{atan@var{m}2}\n+Store the arc tangent of operand 1 into operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{exp@var{m}2} instruction pattern\n @item @samp{exp@var{m}2}\n-Store the exponential of operand 1 into operand 0.\n+Raise e (the base of natural logarithms) to the power of operand 1\n+and store the result in operand 0.  Both operands have mode @var{m},\n+which is a scalar or vector floating-point mode.\n \n-The @code{exp} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{expf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{expm1@var{m}2} instruction pattern\n+@item @samp{expm1@var{m}2}\n+Raise e (the base of natural logarithms) to the power of operand 1,\n+subtract 1, and store the result in operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+For inputs close to zero, the pattern is expected to be more\n+accurate than a separate @code{exp@var{m}2} and @code{sub@var{m}3}\n+would be.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{exp10@var{m}2} instruction pattern\n+@item @samp{exp10@var{m}2}\n+Raise 10 to the power of operand 1 and store the result in operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{exp2@var{m}2} instruction pattern\n+@item @samp{exp2@var{m}2}\n+Raise 2 to the power of operand 1 and store the result in operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{log@var{m}2} instruction pattern\n @item @samp{log@var{m}2}\n-Store the natural logarithm of operand 1 into operand 0.\n+Store the natural logarithm of operand 1 into operand 0.  Both operands\n+have mode @var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{log} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{logf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{log1p@var{m}2} instruction pattern\n+@item @samp{log1p@var{m}2}\n+Add 1 to operand 1, compute the natural logarithm, and store\n+the result in operand 0.  Both operands have mode @var{m}, which is\n+a scalar or vector floating-point mode.\n+\n+For inputs close to zero, the pattern is expected to be more\n+accurate than a separate @code{add@var{m}3} and @code{log@var{m}2}\n+would be.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{log10@var{m}2} instruction pattern\n+@item @samp{log10@var{m}2}\n+Store the base-10 logarithm of operand 1 into operand 0.  Both operands\n+have mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{log2@var{m}2} instruction pattern\n+@item @samp{log2@var{m}2}\n+Store the base-2 logarithm of operand 1 into operand 0.  Both operands\n+have mode @var{m}, which is a scalar or vector floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{logb@var{m}2} instruction pattern\n+@item @samp{logb@var{m}2}\n+Store the base-@code{FLT_RADIX} logarithm of operand 1 into operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n+@cindex @code{significand@var{m}2} instruction pattern\n+@item @samp{significand@var{m}2}\n+Store the significand of floating-point operand 1 in operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{pow@var{m}3} instruction pattern\n @item @samp{pow@var{m}3}\n Store the value of operand 1 raised to the exponent operand 2\n-into operand 0.\n+into operand 0.  All operands have mode @var{m}, which is a scalar\n+or vector floating-point mode.\n \n-The @code{pow} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{powf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{atan2@var{m}3} instruction pattern\n @item @samp{atan2@var{m}3}\n Store the arc tangent (inverse tangent) of operand 1 divided by\n operand 2 into operand 0, using the signs of both arguments to\n-determine the quadrant of the result.\n+determine the quadrant of the result.  All operands have mode\n+@var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{atan2} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{atan2f}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{floor@var{m}2} instruction pattern\n @item @samp{floor@var{m}2}\n-Store the largest integral value not greater than argument.\n+Store the largest integral value not greater than operand 1 in operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n \n-The @code{floor} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{floorf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{btrunc@var{m}2} instruction pattern\n @item @samp{btrunc@var{m}2}\n-Store the argument rounded to integer towards zero.\n+Round operand 1 to an integer, towards zero, and store the result in\n+operand 0.  Both operands have mode @var{m}, which is a scalar or\n+vector floating-point mode.\n \n-The @code{trunc} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{truncf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{round@var{m}2} instruction pattern\n @item @samp{round@var{m}2}\n-Store the argument rounded to integer away from zero.\n+Round operand 1 to the nearest integer, rounding away from zero in the\n+event of a tie, and store the result in operand 0.  Both operands have\n+mode @var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{round} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{roundf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{ceil@var{m}2} instruction pattern\n @item @samp{ceil@var{m}2}\n-Store the argument rounded to integer away from zero.\n+Store the smallest integral value not less than operand 1 in operand 0.\n+Both operands have mode @var{m}, which is a scalar or vector\n+floating-point mode.\n \n-The @code{ceil} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{ceilf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{nearbyint@var{m}2} instruction pattern\n @item @samp{nearbyint@var{m}2}\n-Store the argument rounded according to the default rounding mode\n+Round operand 1 to an integer, using the current rounding mode, and\n+store the result in operand 0.  Do not raise an inexact condition when\n+the result is different from the argument.  Both operands have mode\n+@var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{nearbyint} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{nearbyintf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{rint@var{m}2} instruction pattern\n @item @samp{rint@var{m}2}\n-Store the argument rounded according to the default rounding mode and\n-raise the inexact exception when the result differs in value from\n-the argument\n+Round operand 1 to an integer, using the current rounding mode, and\n+store the result in operand 0.  Raise an inexact condition when\n+the result is different from the argument.  Both operands have mode\n+@var{m}, which is a scalar or vector floating-point mode.\n \n-The @code{rint} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{rintf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{lrint@var{m}@var{n}2}\n @item @samp{lrint@var{m}@var{n}2}\n@@ -5519,23 +5623,24 @@ operand 0 (which has mode @var{n}).\n @cindex @code{copysign@var{m}3} instruction pattern\n @item @samp{copysign@var{m}3}\n Store a value with the magnitude of operand 1 and the sign of operand\n-2 into operand 0.\n+2 into operand 0.  All operands have mode @var{m}, which is a scalar or\n+vector floating-point mode.\n \n-The @code{copysign} built-in function of C always uses the mode which\n-corresponds to the C data type @code{double} and the @code{copysignf}\n-built-in function uses the mode which corresponds to the C data\n-type @code{float}.\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{ffs@var{m}2} instruction pattern\n @item @samp{ffs@var{m}2}\n Store into operand 0 one plus the index of the least significant 1-bit\n-of operand 1.  If operand 1 is zero, store zero.  @var{m} is the mode\n-of operand 0; operand 1's mode is specified by the instruction\n-pattern, and the compiler will convert the operand to that mode before\n-generating the instruction.\n+of operand 1.  If operand 1 is zero, store zero.\n \n-The @code{ffs} built-in function of C always uses the mode which\n-corresponds to the C data type @code{int}.\n+@var{m} is either a scalar or vector integer mode.  When it is a scalar,\n+operand 1 has mode @var{m} but operand 0 can have whatever scalar\n+integer mode is suitable for the target.  The compiler will insert\n+conversion instructions as necessary (typically to convert the result\n+to the same width as @code{int}).  When @var{m} is a vector, both\n+operands must have mode @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{clrsb@var{m}2} instruction pattern\n @item @samp{clrsb@var{m}2}\n@@ -5545,39 +5650,73 @@ at the most significant bit position.\n A redundant sign bit is defined as any sign bit after the first. As such,\n this count will be one less than the count of leading sign bits.\n \n+@var{m} is either a scalar or vector integer mode.  When it is a scalar,\n+operand 1 has mode @var{m} but operand 0 can have whatever scalar\n+integer mode is suitable for the target.  The compiler will insert\n+conversion instructions as necessary (typically to convert the result\n+to the same width as @code{int}).  When @var{m} is a vector, both\n+operands must have mode @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n+\n @cindex @code{clz@var{m}2} instruction pattern\n @item @samp{clz@var{m}2}\n Store into operand 0 the number of leading 0-bits in operand 1, starting\n at the most significant bit position.  If operand 1 is 0, the\n @code{CLZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if\n the result is undefined or has a useful value.\n-@var{m} is the mode of operand 0; operand 1's mode is\n-specified by the instruction pattern, and the compiler will convert the\n-operand to that mode before generating the instruction.\n+\n+@var{m} is either a scalar or vector integer mode.  When it is a scalar,\n+operand 1 has mode @var{m} but operand 0 can have whatever scalar\n+integer mode is suitable for the target.  The compiler will insert\n+conversion instructions as necessary (typically to convert the result\n+to the same width as @code{int}).  When @var{m} is a vector, both\n+operands must have mode @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{ctz@var{m}2} instruction pattern\n @item @samp{ctz@var{m}2}\n Store into operand 0 the number of trailing 0-bits in operand 1, starting\n at the least significant bit position.  If operand 1 is 0, the\n @code{CTZ_DEFINED_VALUE_AT_ZERO} (@pxref{Misc}) macro defines if\n the result is undefined or has a useful value.\n-@var{m} is the mode of operand 0; operand 1's mode is\n-specified by the instruction pattern, and the compiler will convert the\n-operand to that mode before generating the instruction.\n+\n+@var{m} is either a scalar or vector integer mode.  When it is a scalar,\n+operand 1 has mode @var{m} but operand 0 can have whatever scalar\n+integer mode is suitable for the target.  The compiler will insert\n+conversion instructions as necessary (typically to convert the result\n+to the same width as @code{int}).  When @var{m} is a vector, both\n+operands must have mode @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{popcount@var{m}2} instruction pattern\n @item @samp{popcount@var{m}2}\n-Store into operand 0 the number of 1-bits in operand 1.  @var{m} is the\n-mode of operand 0; operand 1's mode is specified by the instruction\n-pattern, and the compiler will convert the operand to that mode before\n-generating the instruction.\n+Store into operand 0 the number of 1-bits in operand 1.\n+\n+@var{m} is either a scalar or vector integer mode.  When it is a scalar,\n+operand 1 has mode @var{m} but operand 0 can have whatever scalar\n+integer mode is suitable for the target.  The compiler will insert\n+conversion instructions as necessary (typically to convert the result\n+to the same width as @code{int}).  When @var{m} is a vector, both\n+operands must have mode @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{parity@var{m}2} instruction pattern\n @item @samp{parity@var{m}2}\n Store into operand 0 the parity of operand 1, i.e.@: the number of 1-bits\n-in operand 1 modulo 2.  @var{m} is the mode of operand 0; operand 1's mode\n-is specified by the instruction pattern, and the compiler will convert\n-the operand to that mode before generating the instruction.\n+in operand 1 modulo 2.\n+\n+@var{m} is either a scalar or vector integer mode.  When it is a scalar,\n+operand 1 has mode @var{m} but operand 0 can have whatever scalar\n+integer mode is suitable for the target.  The compiler will insert\n+conversion instructions as necessary (typically to convert the result\n+to the same width as @code{int}).  When @var{m} is a vector, both\n+operands must have mode @var{m}.\n+\n+This pattern is not allowed to @code{FAIL}.\n \n @cindex @code{one_cmpl@var{m}2} instruction pattern\n @item @samp{one_cmpl@var{m}2}"}]}