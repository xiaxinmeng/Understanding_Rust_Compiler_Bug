{"sha": "729f495ad78e2596d166707444941b382dbfc29a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5ZjQ5NWFkNzhlMjU5NmQxNjY3MDc0NDQ5NDFiMzgyZGJmYzI5YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T17:50:01Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T17:50:01Z"}, "message": "Improve canonicalisation of TARGET_MEM_REFs\n\nA general TARGET_MEM_REF is:\n\n    BASE + STEP * INDEX + INDEX2 + OFFSET\n\nAfter classifying the address in this way, the code that builds\nTARGET_MEM_REFs tries to simplify the address until it's valid\nfor the current target and for the mode of memory being addressed.\nIt does this in a fixed order:\n\n(1) add SYMBOL to BASE\n(2) add INDEX * STEP to the base, if STEP != 1\n(3) add OFFSET to INDEX or BASE (reverted if unsuccessful)\n(4) add INDEX to BASE\n(5) add OFFSET to BASE\n\nSo suppose we had an address:\n\n    &symbol + offset + index * 8\n\n(e.g. a[i + 1] for a global \"a\") on a target only allows an index or an\noffset, not both.  Following the steps above, we'd first create:\n\n    tmp = symbol\n    tmp2 = tmp + index * 8\n\nThen if the given offset value was valid for the mode being addressed,\nwe'd create:\n\n    MEM[base:tmp2, offset:offset]\n\nwhile if it was invalid we'd create:\n\n    tmp3 = tmp2 + offset\n    MEM[base:tmp3, offset:0]\n\nThe problem is that this could happen if ivopts had decided to use\na scaled index for an address that happens to have a constant base.\nThe old procedure failed to give an indexed TARGET_MEM_REF in that case,\nand adding the offset last prevented later passes from being able to\nfold the index back in.\n\nThe patch avoids this by checking at (2) whether the offset is the\nonly component that causes the address to be invalid, folding it\ninto the base if so.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-ssa-address.c (mem_ref_valid_without_offset_p): New function.\n\t(add_offset_to_base): New function, split out from...\n\t(create_mem_ref): ...here.  When handling a scale other than 1,\n\tcheck first whether the address is valid without the offset.\n\tAdd it into the base if so, leaving the index and scale as-is.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256609", "tree": {"sha": "1256fd0967af1cfab5a7885b74b6bbf4ce8cadb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1256fd0967af1cfab5a7885b74b6bbf4ce8cadb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/729f495ad78e2596d166707444941b382dbfc29a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729f495ad78e2596d166707444941b382dbfc29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/729f495ad78e2596d166707444941b382dbfc29a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/729f495ad78e2596d166707444941b382dbfc29a/comments", "author": null, "committer": null, "parents": [{"sha": "b4923738ef57a441f6f9248260848bde5af165fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4923738ef57a441f6f9248260848bde5af165fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4923738ef57a441f6f9248260848bde5af165fa"}], "stats": {"total": 60, "additions": 48, "deletions": 12}, "files": [{"sha": "561fd708dae5ab25fad58b67daee80de347d59c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729f495ad78e2596d166707444941b382dbfc29a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729f495ad78e2596d166707444941b382dbfc29a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=729f495ad78e2596d166707444941b382dbfc29a", "patch": "@@ -1,3 +1,13 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-ssa-address.c (mem_ref_valid_without_offset_p): New function.\n+\t(add_offset_to_base): New function, split out from...\n+\t(create_mem_ref): ...here.  When handling a scale other than 1,\n+\tcheck first whether the address is valid without the offset.\n+\tAdd it into the base if so, leaving the index and scale as-is.\n+\n 2018-01-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/83778"}, {"sha": "c8ff8514529ca00bf2d5cad55c07d71525bff358", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/729f495ad78e2596d166707444941b382dbfc29a/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/729f495ad78e2596d166707444941b382dbfc29a/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=729f495ad78e2596d166707444941b382dbfc29a", "patch": "@@ -746,6 +746,35 @@ gimplify_mem_ref_parts (gimple_stmt_iterator *gsi, struct mem_address *parts)\n \t\t\t\t\t     true, GSI_SAME_STMT);\n }\n \n+/* Return true if the OFFSET in PARTS is the only thing that is making\n+   it an invalid address for type TYPE.  */\n+\n+static bool\n+mem_ref_valid_without_offset_p (tree type, mem_address parts)\n+{\n+  if (!parts.base)\n+    parts.base = parts.offset;\n+  parts.offset = NULL_TREE;\n+  return valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), &parts);\n+}\n+\n+/* Fold PARTS->offset into PARTS->base, so that there is no longer\n+   a separate offset.  Emit any new instructions before GSI.  */\n+\n+static void\n+add_offset_to_base (gimple_stmt_iterator *gsi, mem_address *parts)\n+{\n+  tree tmp = parts->offset;\n+  if (parts->base)\n+    {\n+      tmp = fold_build_pointer_plus (parts->base, tmp);\n+      tmp = force_gimple_operand_gsi_1 (gsi, tmp, is_gimple_mem_ref_addr,\n+\t\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n+    }\n+  parts->base = tmp;\n+  parts->offset = NULL_TREE;\n+}\n+\n /* Creates and returns a TARGET_MEM_REF for address ADDR.  If necessary\n    computations are emitted in front of GSI.  TYPE is the mode\n    of created memory reference. IV_CAND is the selected iv candidate in ADDR,\n@@ -812,6 +841,14 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n   if (parts.step && !integer_onep (parts.step))\n     {\n       gcc_assert (parts.index);\n+      if (parts.offset && mem_ref_valid_without_offset_p (type, parts))\n+\t{\n+\t  add_offset_to_base (gsi, &parts);\n+\t  mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n+\t  gcc_assert (mem_ref);\n+\t  return mem_ref;\n+\t}\n+\n       parts.index = force_gimple_operand_gsi (gsi,\n \t\t\t\tfold_build2 (MULT_EXPR, sizetype,\n \t\t\t\t\t     parts.index, parts.step),\n@@ -906,18 +943,7 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n        [base'].  */\n   if (parts.offset && !integer_zerop (parts.offset))\n     {\n-      tmp = parts.offset;\n-      parts.offset = NULL_TREE;\n-      /* Add offset to base.  */\n-      if (parts.base)\n-\t{\n-\t  tmp = fold_build_pointer_plus (parts.base, tmp);\n-\t  tmp = force_gimple_operand_gsi_1 (gsi, tmp,\n-\t\t\t\t\t    is_gimple_mem_ref_addr,\n-\t\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n-\t}\n-      parts.base = tmp;\n-\n+      add_offset_to_base (gsi, &parts);\n       mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;"}]}