{"sha": "a776161b8bb455734cb3019976b5718bc208ba8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3NjE2MWI4YmI0NTU3MzRjYjMwMTk5NzZiNTcxOGJjMjA4YmE4Zg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-18T01:00:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-18T01:00:28Z"}, "message": "exception.c: New file.\n\n        * exception.c: New file.\n        * Makefile.in (exception.lo): New.\n        (OBJS): Add it.\n\nFrom-SVN: r83331", "tree": {"sha": "8c5018b02034ae423c3dcd9e0811b62a590ac41b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c5018b02034ae423c3dcd9e0811b62a590ac41b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a776161b8bb455734cb3019976b5718bc208ba8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a776161b8bb455734cb3019976b5718bc208ba8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a776161b8bb455734cb3019976b5718bc208ba8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a776161b8bb455734cb3019976b5718bc208ba8f/comments", "author": null, "committer": null, "parents": [{"sha": "ed2e7facb5baeca99a77e2c4efecdb5518890c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed2e7facb5baeca99a77e2c4efecdb5518890c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed2e7facb5baeca99a77e2c4efecdb5518890c27"}], "stats": {"total": 379, "additions": 378, "deletions": 1}, "files": [{"sha": "1c85986c7bd9117a252ea2f62524082ff2a02d19", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a776161b8bb455734cb3019976b5718bc208ba8f/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a776161b8bb455734cb3019976b5718bc208ba8f/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=a776161b8bb455734cb3019976b5718bc208ba8f", "patch": "@@ -1,3 +1,9 @@\n+2004-06-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* exception.c: New file.\n+\t* Makefile.in (exception.lo): New.\n+\t(OBJS): Add it.\n+\n 2004-06-14  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* linking.m (_objcInit): New empty function"}, {"sha": "95c94bf44e372ce9331993962b7675da084a27bf", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a776161b8bb455734cb3019976b5718bc208ba8f/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a776161b8bb455734cb3019976b5718bc208ba8f/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=a776161b8bb455734cb3019976b5718bc208ba8f", "patch": "@@ -145,7 +145,7 @@ OBJC_H = hash.h objc-list.h sarray.h objc.h objc-api.h \\\n OBJS =    archive.lo class.lo encoding.lo gc.lo hash.lo init.lo linking.lo \\\n \t  misc.lo nil_method.lo NXConstStr.lo Object.lo objects.lo \\\n \t  Protocol.lo sarray.lo selector.lo sendmsg.lo thr.lo \\\n-\t  $(OBJC_THREAD_FILE).lo\n+\t  $(OBJC_THREAD_FILE).lo exception.lo\n \n OBJS_GC = archive_gc.lo class_gc.lo encoding_gc.lo gc_gc.lo hash_gc.lo \\\n \t  init_gc.lo linking_gc.lo misc_gc.lo nil_method_gc.lo \\\n@@ -253,6 +253,10 @@ $(OBJC_THREAD_FILE)_gc.lo: $(OBJC_THREAD_FILE).c\n \t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n \t\t$(INCLUDES) $<\n \n+exception.lo: exception.c\n+\t$(LIBTOOL_COMPILE) $(CC) -c -o $@ $(ALL_CFLAGS) $(OBJC_GCFLAGS) \\\n+\t\t-fexceptions $(INCLUDES) $<\n+\n doc: info dvi html\n \n libobjc$(libext).la: $(OBJS)"}, {"sha": "d788c412ace0729beb41cc8e4b6bddba2a37126f", "filename": "libobjc/exception.c", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a776161b8bb455734cb3019976b5718bc208ba8f/libobjc%2Fexception.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a776161b8bb455734cb3019976b5718bc208ba8f/libobjc%2Fexception.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fexception.c?ref=a776161b8bb455734cb3019976b5718bc208ba8f", "patch": "@@ -0,0 +1,367 @@\n+/* The implementation of exception handling primitives for Objective-C.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled\n+   with GCC to produce an executable, this does not cause the resulting\n+   executable to be covered by the GNU General Public License.  This\n+   exception does not however invalidate any other reasons why the\n+   executable file might be covered by the GNU General Public License. */\n+\n+#include <stdlib.h>\n+#include \"objc/objc-api.h\"\n+#include \"unwind.h\"\n+#include \"unwind-pe.h\"\n+\n+\f\n+/* This is the exception class we report -- \"GNUCOBJC\".  */\n+#define __objc_exception_class\t\t\t\\\n+  ((((((((_Unwind_Exception_Class) 'G'\t\t\\\n+         << 8 | (_Unwind_Exception_Class) 'N')\t\\\n+        << 8 | (_Unwind_Exception_Class) 'U')\t\\\n+       << 8 | (_Unwind_Exception_Class) 'C')\t\\\n+      << 8 | (_Unwind_Exception_Class) 'O')\t\\\n+     << 8 | (_Unwind_Exception_Class) 'B')\t\\\n+    << 8 | (_Unwind_Exception_Class) 'J')\t\\\n+   << 8 | (_Unwind_Exception_Class) 'C')\n+\n+/* This is the object that is passed around by the Objective C runtime\n+   to represent the exception in flight.  */\n+\n+struct ObjcException\n+{\n+  /* This bit is needed in order to interact with the unwind runtime.  */\n+  struct _Unwind_Exception base;\n+\n+  /* The actual object we want to throw.  */\n+  id value;\n+\n+  /* Cache some internal unwind data between phase 1 and phase 2.  */\n+  _Unwind_Ptr landingPad;\n+  int handlerSwitchValue;\n+};\n+\n+\f\n+\n+struct lsda_header_info\n+{\n+  _Unwind_Ptr Start;\n+  _Unwind_Ptr LPStart;\n+  _Unwind_Ptr ttype_base;\n+  const unsigned char *TType;\n+  const unsigned char *action_table;\n+  unsigned char ttype_encoding;\n+  unsigned char call_site_encoding;\n+};\n+\n+static const unsigned char *\n+parse_lsda_header (struct _Unwind_Context *context, const unsigned char *p,\n+\t\t   struct lsda_header_info *info)\n+{\n+  _Unwind_Word tmp;\n+  unsigned char lpstart_encoding;\n+\n+  info->Start = (context ? _Unwind_GetRegionStart (context) : 0);\n+\n+  /* Find @LPStart, the base to which landing pad offsets are relative.  */\n+  lpstart_encoding = *p++;\n+  if (lpstart_encoding != DW_EH_PE_omit)\n+    p = read_encoded_value (context, lpstart_encoding, p, &info->LPStart);\n+  else\n+    info->LPStart = info->Start;\n+\n+  /* Find @TType, the base of the handler and exception spec type data.  */\n+  info->ttype_encoding = *p++;\n+  if (info->ttype_encoding != DW_EH_PE_omit)\n+    {\n+      p = read_uleb128 (p, &tmp);\n+      info->TType = p + tmp;\n+    }\n+  else\n+    info->TType = 0;\n+\n+  /* The encoding and length of the call-site table; the action table\n+     immediately follows.  */\n+  info->call_site_encoding = *p++;\n+  p = read_uleb128 (p, &tmp);\n+  info->action_table = p + tmp;\n+\n+  return p;\n+}\n+\n+static Class\n+get_ttype_entry (struct lsda_header_info *info, _Unwind_Word i)\n+{\n+  _Unwind_Ptr ptr;\n+\n+  i *= size_of_encoded_value (info->ttype_encoding);\n+  read_encoded_value_with_base (info->ttype_encoding, info->ttype_base,\n+\t\t\t\tinfo->TType - i, &ptr);\n+\n+  /* NULL ptr means catch-all.  */\n+  if (ptr)\n+    return objc_get_class ((const char *) ptr);\n+  else\n+    return 0;\n+}\n+\n+/* Like unto the method of the same name on Object, but takes an id.  */\n+/* ??? Does this bork the meta-type system?  Can/should we look up an\n+   isKindOf method on the id?  */\n+\n+static int\n+isKindOf (id value, Class target)\n+{\n+  Class c;\n+\n+  /* NULL target is catch-all.  */\n+  if (target == 0)\n+    return 1;\n+\n+  for (c = value->class_pointer; c; c = class_get_super_class (c))\n+    if (c == target)\n+      return 1;\n+  return 0;\n+}\n+\n+/* Using a different personality function name causes link failures\n+   when trying to mix code using different exception handling models.  */\n+#ifdef SJLJ_EXCEPTIONS\n+#define PERSONALITY_FUNCTION\t__gnu_objc_personality_sj0\n+#define __builtin_eh_return_data_regno(x) x\n+#else\n+#define PERSONALITY_FUNCTION\t__gnu_objc_personality_v0\n+#endif\n+\n+_Unwind_Reason_Code\n+PERSONALITY_FUNCTION (int version,\n+\t\t      _Unwind_Action actions,\n+\t\t      _Unwind_Exception_Class exception_class,\n+\t\t      struct _Unwind_Exception *ue_header,\n+\t\t      struct _Unwind_Context *context)\n+{\n+  struct ObjcException *xh = (struct ObjcException *) ue_header;\n+\n+  struct lsda_header_info info;\n+  const unsigned char *language_specific_data;\n+  const unsigned char *action_record;\n+  const unsigned char *p;\n+  _Unwind_Ptr landing_pad, ip;\n+  int handler_switch_value;\n+  int saw_cleanup, saw_handler;\n+\n+  /* Interface version check.  */\n+  if (version != 1)\n+    return _URC_FATAL_PHASE1_ERROR;\n+\n+  /* Shortcut for phase 2 found handler for domestic exception.  */\n+  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n+      && exception_class == __objc_exception_class)\n+    {\n+      handler_switch_value = xh->handlerSwitchValue;\n+      landing_pad = xh->landingPad;\n+      goto install_context;\n+    }\n+\n+  language_specific_data = (const unsigned char *)\n+    _Unwind_GetLanguageSpecificData (context);\n+\n+  /* If no LSDA, then there are no handlers or cleanups.  */\n+  if (! language_specific_data)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  /* Parse the LSDA header.  */\n+  p = parse_lsda_header (context, language_specific_data, &info);\n+  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);\n+  ip = _Unwind_GetIP (context) - 1;\n+  landing_pad = 0;\n+  action_record = 0;\n+  handler_switch_value = 0;\n+\n+#ifdef SJLJ_EXCEPTIONS\n+  /* The given \"IP\" is an index into the call-site table, with two\n+     exceptions -- -1 means no-action, and 0 means terminate.  But\n+     since we're using uleb128 values, we've not got random access\n+     to the array.  */\n+  if ((int) ip < 0)\n+    return _URC_CONTINUE_UNWIND;\n+  else\n+    {\n+      _Unwind_Word cs_lp, cs_action;\n+      do\n+\t{\n+\t  p = read_uleb128 (p, &cs_lp);\n+\t  p = read_uleb128 (p, &cs_action);\n+\t}\n+      while (--ip);\n+\n+      /* Can never have null landing pad for sjlj -- that would have\n+         been indicated by a -1 call site index.  */\n+      landing_pad = cs_lp + 1;\n+      if (cs_action)\n+\taction_record = info.action_table + cs_action - 1;\n+      goto found_something;\n+    }\n+#else\n+  /* Search the call-site table for the action associated with this IP.  */\n+  while (p < info.action_table)\n+    {\n+      _Unwind_Ptr cs_start, cs_len, cs_lp;\n+      _Unwind_Word cs_action;\n+\n+      /* Note that all call-site encodings are \"absolute\" displacements.  */\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_start);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_len);\n+      p = read_encoded_value (0, info.call_site_encoding, p, &cs_lp);\n+      p = read_uleb128 (p, &cs_action);\n+\n+      /* The table is sorted, so if we've passed the ip, stop.  */\n+      if (ip < info.Start + cs_start)\n+\tp = info.action_table;\n+      else if (ip < info.Start + cs_start + cs_len)\n+\t{\n+\t  if (cs_lp)\n+\t    landing_pad = info.LPStart + cs_lp;\n+\t  if (cs_action)\n+\t    action_record = info.action_table + cs_action - 1;\n+\t  goto found_something;\n+\t}\n+    }\n+#endif /* SJLJ_EXCEPTIONS  */\n+\n+  /* If ip is not present in the table, C++ would call terminate.  */\n+  /* ??? As with Java, it's perhaps better to tweek the LSDA to\n+     that no-action is mapped to no-entry.  */\n+  return _URC_CONTINUE_UNWIND;\n+\n+ found_something:\n+  saw_cleanup = 0;\n+  saw_handler = 0;\n+\n+  if (landing_pad == 0)\n+    {\n+      /* If ip is present, and has a null landing pad, there are\n+\t no cleanups or handlers to be run.  */\n+    }\n+  else if (action_record == 0)\n+    {\n+      /* If ip is present, has a non-null landing pad, and a null\n+         action table offset, then there are only cleanups present.\n+         Cleanups use a zero switch value, as set above.  */\n+      saw_cleanup = 1;\n+    }\n+  else\n+    {\n+      /* Otherwise we have a catch handler.  */\n+      _Unwind_Sword ar_filter, ar_disp;\n+\n+      while (1)\n+\t{\n+\t  p = action_record;\n+\t  p = read_sleb128 (p, &ar_filter);\n+\t  read_sleb128 (p, &ar_disp);\n+\n+\t  if (ar_filter == 0)\n+\t    {\n+\t      /* Zero filter values are cleanups.  */\n+\t      saw_cleanup = 1;\n+\t    }\n+\n+\t  /* During forced unwinding, we only run cleanups.  With a\n+\t     foreign exception class, we have no class info to match.  */\n+\t  else if ((actions & _UA_FORCE_UNWIND)\n+\t\t   || exception_class != __objc_exception_class)\n+\t    ;\n+\n+\t  else if (ar_filter > 0)\n+\t    {\n+\t      /* Positive filter values are handlers.  */\n+\n+\t      Class catch_type = get_ttype_entry (&info, ar_filter);\n+\n+\t      if (isKindOf (xh->value, catch_type))\n+\t\t{\n+\t\t  handler_switch_value = ar_filter;\n+\t\t  saw_handler = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Negative filter values are exception specifications,\n+\t         which Objective-C does not use.  */\n+\t      abort ();\n+\t    }\n+\n+\t  if (ar_disp == 0)\n+\t    break;\n+\t  action_record = p + ar_disp;\n+\t}\n+    }\n+\n+  if (! saw_handler && ! saw_cleanup)\n+    return _URC_CONTINUE_UNWIND;\n+\n+  if (actions & _UA_SEARCH_PHASE)\n+    {\n+      if (!saw_handler)\n+\treturn _URC_CONTINUE_UNWIND;\n+\n+      /* For domestic exceptions, we cache data from phase 1 for phase 2.  */\n+      if (exception_class == __objc_exception_class)\n+        {\n+          xh->handlerSwitchValue = handler_switch_value;\n+          xh->landingPad = landing_pad;\n+\t}\n+      return _URC_HANDLER_FOUND;\n+    }\n+\n+ install_context:\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n+\t\t __builtin_extend_pointer (xh->value));\n+  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n+\t\t handler_switch_value);\n+  _Unwind_SetIP (context, landing_pad);\n+  return _URC_INSTALL_CONTEXT;\n+}\n+\n+static void\n+__objc_exception_cleanup (_Unwind_Reason_Code code __attribute__((unused)),\n+\t\t\t  struct _Unwind_Exception *exc)\n+{\n+  free (exc);\n+}\n+\n+void\n+objc_exception_throw (id value)\n+{\n+  struct ObjcException *header = calloc (1, sizeof (*header));\n+  header->base.exception_class = __objc_exception_class;\n+  header->base.exception_cleanup = __objc_exception_cleanup;\n+  header->value = value;\n+\n+#ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n+  _Unwind_SjLj_RaiseException (&header->base);\n+#else\n+  _Unwind_RaiseException (&header->base);\n+#endif\n+\n+  /* Some sort of unwinding error.  */\n+  abort ();\n+}"}]}