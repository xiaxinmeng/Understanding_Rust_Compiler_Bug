{"sha": "4e64ba0091fe74dc3835d7d13eab011113840ab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2NGJhMDA5MWZlNzRkYzM4MzVkN2QxM2VhYjAxMTExMzg0MGFiNg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-04-17T18:22:03Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2017-04-17T18:22:03Z"}, "message": "re PR fortran/80440 (Slow compile when USEing modules)\n\n2017-04-17  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/80440\n\t* module.c (find_symtree_for_symbol): Delete.\n\t(read_module): Remove the call to the above.\n\nFrom-SVN: r246952", "tree": {"sha": "8f8c91fca83f542ab8f43778c8026cf10c76b5b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f8c91fca83f542ab8f43778c8026cf10c76b5b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e64ba0091fe74dc3835d7d13eab011113840ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e64ba0091fe74dc3835d7d13eab011113840ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e64ba0091fe74dc3835d7d13eab011113840ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e64ba0091fe74dc3835d7d13eab011113840ab6/comments", "author": null, "committer": null, "parents": [{"sha": "fb5e5621003312f08d6a50c5043cbc43aa6709d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb5e5621003312f08d6a50c5043cbc43aa6709d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb5e5621003312f08d6a50c5043cbc43aa6709d1"}], "stats": {"total": 47, "additions": 9, "deletions": 38}, "files": [{"sha": "58268d1bd3644a082b564eff539f7e3ee7b15ad5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e64ba0091fe74dc3835d7d13eab011113840ab6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e64ba0091fe74dc3835d7d13eab011113840ab6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4e64ba0091fe74dc3835d7d13eab011113840ab6", "patch": "@@ -1,13 +1,19 @@\n+2017-04-17  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/80440\n+\t* module.c (find_symtree_for_symbol): Delete.\n+\t(read_module): Remove the call to the above.\n+\n 2017-04-14  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/80361\n \t* class.c (generate_finalization_wrapper): Give the finalization wrapper\n \tthe recursive attribute.\n \n 2017-04-10  Nicolas Koenig  <koenigni@student.ethz.ch>\n-            Paul Thomas  <pault@gcc.gnu.org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n \n-\tPR fortran/69498 \n+\tPR fortran/69498\n \t* module.c (gfc_match_submodule): Add error\n \tif function is called in the wrong state.\n \n@@ -17,7 +23,7 @@\n \t* expr.c (gfc_check_pointer_assign): Check if procedure pointer\n \tcomponents in a pointer assignment need an explicit interface.\n \n-2017-03-18  Nicolas Koenig  <koenigni@student.ethz.ch> \n+2017-03-18  Nicolas Koenig  <koenigni@student.ethz.ch>\n \n \tPR fortran/69498\n \t* symbol.c (gfc_delete_symtree): If there is a period in the name, ignore"}, {"sha": "4d6afa55d3853b91b6c8d06e18fa4d2c95a3c0f8", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e64ba0091fe74dc3835d7d13eab011113840ab6/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e64ba0091fe74dc3835d7d13eab011113840ab6/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=4e64ba0091fe74dc3835d7d13eab011113840ab6", "patch": "@@ -4292,31 +4292,6 @@ mio_symbol (gfc_symbol *sym)\n \n /************************* Top level subroutines *************************/\n \n-/* Given a root symtree node and a symbol, try to find a symtree that\n-   references the symbol that is not a unique name.  */\n-\n-static gfc_symtree *\n-find_symtree_for_symbol (gfc_symtree *st, gfc_symbol *sym)\n-{\n-  gfc_symtree *s = NULL;\n-\n-  if (st == NULL)\n-    return s;\n-\n-  s = find_symtree_for_symbol (st->right, sym);\n-  if (s != NULL)\n-    return s;\n-  s = find_symtree_for_symbol (st->left, sym);\n-  if (s != NULL)\n-    return s;\n-\n-  if (st->n.sym == sym && !check_unique_name (st->name))\n-    return st;\n-\n-  return s;\n-}\n-\n-\n /* A recursive function to look for a specific symbol by name and by\n    module.  Whilst several symtrees might point to one symbol, its\n    is sufficient for the purposes here than one exist.  Note that\n@@ -5119,16 +5094,6 @@ read_module (void)\n \t  info->u.rsym.referenced = 1;\n \t  continue;\n \t}\n-\n-      /* If possible recycle the symtree that references the symbol.\n-\t If a symtree is not found and the module does not import one,\n-\t a unique-name symtree is found by read_cleanup.  */\n-      st = find_symtree_for_symbol (gfc_current_ns->sym_root, sym);\n-      if (st != NULL)\n-\t{\n-\t  info->u.rsym.symtree = st;\n-\t  info->u.rsym.referenced = 1;\n-\t}\n     }\n \n   mio_rparen ();"}]}