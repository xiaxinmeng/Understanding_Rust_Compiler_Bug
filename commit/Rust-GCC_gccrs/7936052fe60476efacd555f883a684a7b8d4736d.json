{"sha": "7936052fe60476efacd555f883a684a7b8d4736d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkzNjA1MmZlNjA0NzZlZmFjZDU1NWY4ODNhNjg0YTdiOGQ0NzM2ZA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-07-26T00:11:20Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-07-26T00:11:20Z"}, "message": "Initial revision\n\nFrom-SVN: r4986", "tree": {"sha": "d62b715f580e46dc24f6184c8c26da60ec50313d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d62b715f580e46dc24f6184c8c26da60ec50313d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7936052fe60476efacd555f883a684a7b8d4736d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7936052fe60476efacd555f883a684a7b8d4736d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7936052fe60476efacd555f883a684a7b8d4736d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7936052fe60476efacd555f883a684a7b8d4736d/comments", "author": null, "committer": null, "parents": [{"sha": "7afe1b4d48a3125c023e9e03b3e5611818ef9890", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7afe1b4d48a3125c023e9e03b3e5611818ef9890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7afe1b4d48a3125c023e9e03b3e5611818ef9890"}], "stats": {"total": 1334, "additions": 1334, "deletions": 0}, "files": [{"sha": "4d3dfefb549c8fe3cd87a3b5160f96178c837bdc", "filename": "gcc/fix-header.c", "status": "added", "additions": 674, "deletions": 0, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=7936052fe60476efacd555f883a684a7b8d4736d", "patch": "@@ -0,0 +1,674 @@\n+/* patch-header.c - Make C header file suitable for C++.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This program massages a system include file (such as stdio.h),\n+   into a form more conformant with ANSI/POSIX, and more suitable for C++:\n+\n+   * extern \"C\" { ... } braces are added (inside #ifndef __cplusplus),\n+   if they seem to be needed.  These prevcnt C++ compilers from name\n+   mangling the functions inside the braces.\n+\n+   * If an old-style incomplete function declaration is seen (without\n+   an argument list), and it is a \"standard\" function listed in\n+   the file sys-protos.h (and with a non-empty argument list), then\n+   the declaration is converted to a complete prototype by replacing\n+   the empty parameter list with the argument lust from sys-protos.h.\n+\n+   * The program can be given a list of (names of) required standard\n+   functions (such as fclose for stdio.h).  If a reqquired function\n+   is not seen in the input, then a prototype for it will be\n+   written to the output.\n+\n+   * If all of the non-comment code of the original file is protected\n+   against multiple inclusion:\n+\t#ifndef FOO\n+\t#define FOO\n+\t<body of include file>\n+\t#endif\n+   then extra matter added to the include file is placed inside the <body>.\n+\n+   * If the input file is OK (nothing needs to be done);\n+   the output file is not written (nor removed if it exists).\n+\n+   There are also some special actions that are done for certain\n+   well-known standard include files:\n+\n+   * If argv[1] is \"sys/stat.h\", the Posix.1 macros\n+   S_ISBLK, S_ISCHR, S_ISDIR, S_ISFIFO, S_ISLNK, S_ISREG are added if\n+   they were missing, and the corresponding \"traditional\" S_IFxxx\n+   macros were defined.\n+\n+   * If argv[1] is \"errno.h\", errno is declared if it was missing.\n+\n+   * TODO:  The input file should be read complete into memory, because:\n+   a) it needs to be scanned twice anyway, and\n+   b) it would be nice to allow update in place.\n+\n+   Usage:\n+\tpatch-header FOO.H INFILE.H OUTFILE.H REQUIRED_FUNCS <SCAN-FILE\n+   where:\n+   * FOO.H is the relative file name of the include file,\n+   as it would be #include'd by a C file.  (E.g. stdio.h)\n+   * INFILE.H is a full pathname for the input file (e.g. /usr/include/stdio.h)\n+   * OUTFILE.H is the full pathname for where to write the output file,\n+   if anything needs to be done.  (e.g. ./include/stdio.h)\n+   * SCAN-FILE is the output of the scan-decls program.\n+   * REQUIRED_FUNCS is a list of required function (e.g. fclose for stdio.h).\n+\n+   Written by Per Bothner <bothner@cygnus.com>, July 1993. */\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+#include \"obstack.h\"\n+#include \"scan.h\"\n+\n+extern char *strcpy();\n+sstring buf;\n+int verbose = 0;\n+int partial_count = 0;\n+int missing_extern_C_count = 0;\n+int missing_extra_stuff = 0;\n+\n+#include \"xsys-protos.h\"\n+\n+/* Certain standard files get extra treatment */\n+\n+enum special_file\n+{\n+  no_special,\n+  errno_special,\n+  sys_stat_special\n+};\n+\n+enum special_file special_file_handling = no_special;\n+\n+/* The following are only used when handling sys/stat.h */\n+/* They are set if the corresponding macro has been seen. */\n+int seen_S_IFBLK = 0, seen_S_ISBLK  = 0;\n+int seen_S_IFCHR = 0, seen_S_ISCHR  = 0;\n+int seen_S_IFDIR = 0, seen_S_ISDIR  = 0;\n+int seen_S_IFIFO = 0, seen_S_ISFIFO = 0;\n+int seen_S_IFLNK = 0, seen_S_ISLNK  = 0;\n+int seen_S_IFREG = 0, seen_S_ISREG  = 0;\n+\n+/* The following are only used when handling errno.h */\n+int seen_errno = 0;\n+\n+/* Wrapper around free, to avoid prototype clashes. */\n+\n+void xfree (ptr)\n+     char *ptr;\n+{\n+  free(ptr);\n+}\n+\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free xfree\n+struct obstack scan_file_obstack;\n+\n+/* NOTE:  If you edit this, also edit gen-protos.c !! */\n+struct fn_decl *\n+lookup_std_proto (name)\n+     char *name;\n+{\n+  int i = hash(name) % HASH_SIZE;\n+  int i0 = i;\n+  for (;;)\n+    {\n+      struct fn_decl *fn;\n+      if (hash_tab[i] == 0)\n+\treturn NULL;\n+      fn = &std_protos[hash_tab[i]];\n+      if (strcmp (fn->fname, name) == 0)\n+\treturn fn;\n+      i = (i+1) % HASH_SIZE;\n+      if (i == i0)\n+\tabort();\n+    }\n+}\n+\n+char *inc_filename;\n+int inc_filename_length;\n+char *progname = \"patch-header\";\n+FILE *outf;\n+sstring buf;\n+sstring line;\n+\n+int lbrac_line, rbrac_line;\n+\n+char **required_functions;\n+int required_unseen_count;\n+\n+int \n+write_lbrac ()\n+{\n+  fprintf (outf, \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\");\n+\n+  if (partial_count)\n+    {\n+      fprintf (outf, \"#ifndef _PARAMS\\n\");\n+      fprintf (outf, \"#if defined(__STDC__) || defined(__cplusplus)\\n\");\n+      fprintf (outf, \"#define _PARAMS(ARGS) ARGS\\n\");\n+      fprintf (outf, \"#else\\n\");\n+      fprintf (outf, \"#define _PARAMS(ARGS) ()\\n\");\n+      fprintf (outf, \"#endif\\n#endif /* _PARAMS */\\n\");\n+    }\n+}\n+\n+struct partial_proto\n+{\n+  struct partial_proto *next;\n+  char *fname;\t/* name of function */\n+  char *rtype;\t/* return type */\n+  struct fn_decl *fn;\n+  int line_seen;\n+};\n+\n+struct partial_proto *partial_proto_list = NULL;\n+\n+struct partial_proto required_dummy_proto;\n+#define REQUIRED(FN) ((FN)->partial == &required_dummy_proto)\n+#define SET_REQUIRED(FN) ((FN)->partial = &required_dummy_proto)\n+#define CLEAR_REQUIRED(FN) ((FN)->partial = 0)\n+\n+void\n+read_scan_file (scan_file)\n+     FILE *scan_file;\n+{\n+  char **rptr;\n+  int i;\n+  obstack_init(&scan_file_obstack); \n+\n+  for (;;)\n+    {\n+      struct partial_proto *partial;\n+      struct fn_decl *fn;\n+      int ch;\n+      char *ptr, *fname, *extern_C, *rtype, *args, *file_seen, *line_seen;\n+      line.ptr = line.base;\n+      ch = read_upto (scan_file, &line, '\\n');\n+      if (ch == EOF)\n+\tbreak;\n+\n+      fname = line.base;\n+      for (ptr = fname; *ptr != ';'; ) ptr++;\n+      *ptr = 0;\n+      extern_C = ptr + 1;\n+      for (ptr = extern_C; *ptr != ';'; ) ptr++;\n+      *ptr = 0;\n+\n+      if (*extern_C == 'X')\n+\t{\n+\t  switch (special_file_handling)\n+\t    {\n+\t    case errno_special:\n+\t      if (strcmp (fname, \"errno\") == 0) seen_errno++;\n+\t      break;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      if (*extern_C == 'M')\n+\t{\n+\t  /* The original include file defines fname as a macro. */\n+\t  fn = lookup_std_proto (fname);\n+\n+\t  /* Since fname is a macro, don't require a prototype for it. */\n+\t  if (fn && REQUIRED (fn))\n+\t    {\n+\t      CLEAR_REQUIRED(fn);\n+\t      required_unseen_count--;\n+\t    }\n+\n+\t  switch (special_file_handling)\n+\t    {\n+\t    case errno_special:\n+\t      if (strcmp (fname, \"errno\") == 0) seen_errno++;\n+\t      break;\n+\t    case sys_stat_special:\n+\t      if (fname[0] == 'S' && fname[1] == '_')\n+\t\t{\n+\t\t  if (strcmp (fname, \"S_IFBLK\") == 0) seen_S_IFBLK++;\n+\t\t  else if (strcmp (fname, \"S_ISBLK\") == 0) seen_S_ISBLK++;\n+\t\t  else if (strcmp (fname, \"S_IFCHR\") == 0) seen_S_IFCHR++;\n+\t\t  else if (strcmp (fname, \"S_ISCHR\") == 0) seen_S_ISCHR++;\n+\t\t  else if (strcmp (fname, \"S_IFDIR\") == 0) seen_S_IFDIR++;\n+\t\t  else if (strcmp (fname, \"S_ISDIR\") == 0) seen_S_ISDIR++;\n+\t\t  else if (strcmp (fname, \"S_IFIFO\") == 0) seen_S_IFIFO++;\n+\t\t  else if (strcmp (fname, \"S_ISFIFO\") == 0) seen_S_ISFIFO++;\n+\t\t  else if (strcmp (fname, \"S_IFLNK\") == 0) seen_S_IFLNK++;\n+\t\t  else if (strcmp (fname, \"S_ISLNK\") == 0) seen_S_ISLNK++;\n+\t\t  else if (strcmp (fname, \"S_IFREG\") == 0) seen_S_IFREG++;\n+\t\t  else if (strcmp (fname, \"S_ISREG\") == 0) seen_S_ISREG++;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  continue;\n+\t}\n+\n+      rtype = ptr + 1;\n+      for (ptr = rtype; *ptr != ';'; ) ptr++;\n+      *ptr = 0;\n+      args = ptr + 1;\n+      for (ptr = args; *ptr != ';'; ) ptr++;\n+      *ptr = 0;\n+      file_seen = ptr + 1;\n+      for (ptr = file_seen; *ptr != ';'; ) ptr++;\n+      *ptr = 0;\n+      line_seen = ptr + 1;\n+      for (ptr = line_seen; *ptr != ';'; ) ptr++;\n+      *ptr = 0;\n+\n+      if (extern_C[0] == 'f')\n+\tmissing_extern_C_count++;\n+\n+      fn = lookup_std_proto (fname);\n+\n+      /* Remove the function from the list of required function. */\n+      if (fn && REQUIRED (fn))\n+\t{\n+\t  CLEAR_REQUIRED(fn);\n+\t  required_unseen_count--;\n+\t}\n+\n+      /* If we have a full prototype, we're done. */\n+      if (args[0] != '\\0')\n+\tcontinue;\n+      \n+      /* If the partial prototype was included from some other file,\n+\t we don't need to patch it up (in this run). */\n+      i = strlen (file_seen);\n+      if (i < inc_filename_length\n+\t  || strcmp (inc_filename, file_seen + (i - inc_filename_length)) != 0)\n+\tcontinue;\n+\n+      if (fn == NULL)\n+\tcontinue;\n+      if (fn->fname[0] == '\\0' || strcmp(fn->fname, \"void\") == 0)\n+\tcontinue;\n+\n+      /* We only have a partial function declaration,\n+\t so remember that we have to add a complete prototype. */\n+      partial_count++;\n+      partial = (struct partial_proto*)\n+\tobstack_alloc (&scan_file_obstack, sizeof(struct partial_proto));\n+      partial->fname\n+\t= obstack_copy0 (&scan_file_obstack, fname, strlen (fname));\n+      partial->rtype\n+\t= obstack_copy0 (&scan_file_obstack, rtype, strlen (rtype));\n+      partial->line_seen = atoi(line_seen);\n+      partial->fn = fn;\n+      fn->partial = partial;\n+      partial->next = partial_proto_list;\n+      partial_proto_list = partial;\n+      if (verbose)\n+\t{\n+\t  fprintf (stderr, \"(%s: %s non-prototype function declaration.)\\n\",\n+\t\t   inc_filename, fname);\n+\t}\n+    }\n+\n+  if (missing_extern_C_count + required_unseen_count + partial_count\n+      + missing_extra_stuff == 0)\n+    {\n+      if (verbose)\n+\tfprintf (stderr, \"%s: OK, nothing needs to be done.\\n\", inc_filename);\n+      exit (0);\n+    }\n+  if (required_unseen_count)\n+    fprintf (stderr, \"%s: %d missing function declarations.\\n\",\n+\t     inc_filename, required_unseen_count);\n+  if (partial_count)\n+    fprintf (stderr, \"%s: %d non-prototype function declarations.\\n\",\n+\t     inc_filename, partial_count);\n+  if (missing_extern_C_count)\n+    fprintf (stderr, \"%s: %d declarations not protected by extern \\\"C\\\".\\n\",\n+\t     inc_filename, missing_extern_C_count);\n+}\n+\n+write_rbrac ()\n+{\n+  struct fn_decl *fn;\n+  char **rptr;\n+  register struct partial_proto *partial;\n+\n+  if (required_unseen_count)\n+    fprintf (outf, \"#if defined(__STDC__) || defined(__cplusplus)\\n\");\n+\n+  /* Now we print out prototypes for those functions that we haven't seen. */\n+  for (rptr = required_functions; *rptr; rptr++)\n+    {\n+      fn = lookup_std_proto (*rptr);\n+      if (fn == NULL || !REQUIRED (fn))\n+\tcontinue;\n+      fprintf (outf, \"extern %s %s (%s);\\n\",\n+\t       fn->rtype, fn->fname, fn->params);\n+    }\n+  if (required_unseen_count)\n+    fprintf (outf,\n+\t     \"#endif /* defined(__STDC__) || defined(__cplusplus) */\\n\");\n+\n+  switch (special_file_handling)\n+    {\n+    case errno_special:\n+      if (!seen_errno)\n+\tfprintf (outf, \"extern int errno;\\n\");\n+      break;\n+    case sys_stat_special:\n+      if (!seen_S_ISBLK && seen_S_IFBLK)\n+\tfprintf (outf,\n+\t\t \"#define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)\\n\");\n+      if (!seen_S_ISCHR && seen_S_IFCHR)\n+\tfprintf (outf,\n+\t\t \"#define S_ISCHR(mode) (((mode) & S_IFMT) == S_IFCHR)\\n\");\n+      if (!seen_S_ISDIR && seen_S_IFDIR)\n+\tfprintf (outf,\n+\t\t \"#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)\\n\");\n+      if (!seen_S_ISFIFO && seen_S_IFIFO)\n+\tfprintf (outf,\n+\t\t \"#define S_ISFIFO(mode) (((mode) & S_IFMT) == S_IFIFO)\\n\");\n+      if (!seen_S_ISLNK && seen_S_IFLNK)\n+\tfprintf (outf,\n+\t\t \"#define S_ISLNK(mode) (((mode) & S_IFMT) == S_IFLNK)\\n\");\n+      if (!seen_S_ISREG && seen_S_IFREG)\n+\tfprintf (outf,\n+\t\t \"#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)\\n\");\n+      break;\n+    }\n+\n+\n+  fprintf (outf, \"#ifdef __cplusplus\\n}\\n#endif\\n\");\n+}\n+\n+char *\n+strdup (str)\n+     char *str;\n+{\n+  return strcpy((char*)malloc (strlen (str) + 1), str);\n+}\n+\n+/* Returns 1 iff the file is properly protected from multiple inclusion:\n+   #ifndef PROTECT_NAME\n+   #define PROTECT_NAME\n+   #endif\n+\n+ */\n+\n+int\n+check_protection (inf, ifndef_line, endif_line)\n+     FILE *inf;\n+     int *ifndef_line, *endif_line;\n+{\n+  int c;\n+  int if_nesting = 1; /* Level of nesting of #if's */\n+  char *protect_name = NULL; /* Identifier following initial #ifndef */\n+  int define_seen = 0;\n+\n+  /* Skip initial white space (including comments). */\n+  for (;; lineno++)\n+    {\n+      c = skip_spaces (inf, ' ');\n+      if (c == EOF)\n+\treturn 0;\n+      if (c != '\\n')\n+\tbreak;\n+    }\n+  if (c != '#')\n+    return 0;\n+  c = scan_ident (inf, &buf, skip_spaces (inf, ' '));\n+  if (SSTRING_LENGTH(&buf) == 0 || strcmp (buf.base, \"ifndef\") != 0)\n+    return 0;\n+\n+  /* So far so good: We've seen an initial #ifndef. */\n+  *ifndef_line = lineno;\n+  c = scan_ident (inf, &buf, skip_spaces (inf, c));\n+  if (SSTRING_LENGTH(&buf) == 0 || c == EOF)\n+    return 0;\n+  protect_name = strdup (buf.base);\n+\n+  ungetc (c, inf);\n+  c = read_upto (inf, &buf, '\\n');\n+  if (c == EOF)\n+    return 0;\n+  lineno++;\n+\n+  for (;;)\n+    {\n+      c = skip_spaces(inf, ' ');\n+      if (c == EOF)\n+\treturn 0;\n+      if (c == '\\n')\n+\t{\n+\t  lineno++;\n+\t  continue;\n+\t}\n+      if (c != '#')\n+\tgoto skip_to_eol;\n+      c = scan_ident (inf, &buf, skip_spaces (inf, ' '));\n+      if (SSTRING_LENGTH(&buf) == 0)\n+\t;\n+      else if (!strcmp (buf.base, \"ifndef\")\n+\t  || !strcmp (buf.base, \"ifdef\") || !strcmp (buf.base, \"if\"))\n+\t{\n+\t  if_nesting++;\n+\t}\n+      else if (!strcmp (buf.base, \"endif\"))\n+\t{\n+\t  if_nesting--;\n+\t  if (if_nesting == 0)\n+\t    break;\n+\t}\n+      else if (!strcmp (buf.base, \"else\"))\n+\t{\n+\t  if (if_nesting == 1)\n+\t    return 0;\n+\t}\n+      else if (!strcmp (buf.base, \"define\"))\n+\t{\n+\t  if (if_nesting != 1)\n+\t    goto skip_to_eol;\n+\t  c = skip_spaces (inf, c);\n+\t  c = scan_ident (inf, &buf, c);\n+\t  if (buf.base[0] > 0 && strcmp(buf.base, protect_name) == 0)\n+\t    define_seen = 1;\n+\t}\n+    skip_to_eol:\n+      for (;;)\n+\t{\n+\t  if (c == '\\n' || c == EOF)\n+\t    break;\n+\t  c = getc (inf);\n+\t}\n+      if (c == EOF)\n+\treturn 0;\n+      lineno++;\n+    }\n+\n+  if (!define_seen)\n+     return 0;\n+  *endif_line = lineno;\n+  /* Skip final white space (including comments). */\n+  for (;;)\n+    {\n+      c = skip_spaces (inf, ' ');\n+      if (c == EOF)\n+\tbreak;\n+      if (c != '\\n')\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+int\n+main(argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  FILE *inf;\n+  int c;\n+  int i, done;\n+  char *cptr, *cptr0, **pptr;\n+  int ifndef_line;\n+  int endif_line;;\n+\n+\n+  if (argv[0] && argv[0][0])\n+    progname = argv[0];\n+\n+  if (argc < 4)\n+    {\n+      fprintf (stderr, \"%s: Usage: foo.h infile.h outfile.h req_funcs <scan-file-name\\n\",\n+\t       progname);\n+      exit (-1);\n+    }\n+\n+  inc_filename = argv[1];\n+  inc_filename_length = strlen (inc_filename);\n+  if (strcmp (inc_filename, \"sys/stat.h\") == 0)\n+    special_file_handling = sys_stat_special;\n+  else if (strcmp (inc_filename, \"errno.h\") == 0)\n+    special_file_handling = errno_special, missing_extra_stuff++;\n+\n+  /* Calculate an upper bound of the number of function names in argv[4] */\n+  for (i = 1, cptr = argv[4]; *cptr; cptr++)\n+    if (*cptr == ' ') i++;\n+  /* Find the list of prototypes required for this include file. */ \n+  required_functions = (char**)xmalloc((i+1) * sizeof(char*));\n+  for (cptr = argv[4], cptr0 = cptr, pptr = required_functions, done = 0; \n+       !done; cptr++)\n+    {\n+      done = *cptr == '\\0';\n+      if (*cptr == ' ' || done)\n+\t{\n+\t  *cptr = '\\0';\n+\t  if (cptr > cptr0)\n+\t    {\n+\t      struct fn_decl *fn = lookup_std_proto(cptr0);\n+\t      *pptr++ = cptr0;\n+\t      if (fn == NULL)\n+\t\tfprintf (stderr, \"Internal error:  No prototype for %s\\n\",\n+\t\t\t cptr0);\n+\t      else\n+\t\tSET_REQUIRED(fn);\n+\t    }\n+\t  cptr0 = cptr + 1;\n+\t}\n+    }\n+  required_unseen_count = pptr - required_functions;\n+  *pptr = 0;\n+\n+  read_scan_file (stdin);\n+\n+  inf = fopen (argv[2], \"r\");\n+  if (inf == NULL)\n+    {\n+      fprintf (stderr, \"%s: Cannot open '%s' for reading -\",\n+\t       progname, argv[2]);\n+      perror (NULL);\n+      exit (-1);\n+    }\n+\n+  outf = fopen (argv[3], \"w\");\n+  if (outf == NULL)\n+    {\n+      fprintf (stderr, \"%s: Cannot open '%s' for writing -\",\n+\t       progname, argv[3]);\n+      perror (NULL);\n+      exit (-1);\n+    }\n+\n+  if (check_protection (inf, &ifndef_line, &endif_line))\n+    {\n+#if 0\n+      fprintf(stderr, \"#ifndef %s on line %d; #endif on line %d\\n\",\n+\t     protect_name, ifndef_line, endif_line);\n+#endif\n+      lbrac_line = ifndef_line+1;\n+      rbrac_line = endif_line;\n+    }\n+  else\n+    {\n+      lbrac_line = 1;\n+      rbrac_line = -1;\n+    }\n+\n+  fseek(inf, 0, 0);\n+  lineno = 1;\n+\n+  for (;;)\n+    {\n+      if (lineno == lbrac_line)\n+\twrite_lbrac ();\n+      if (lineno == rbrac_line)\n+\twrite_rbrac ();\n+      for (;;)\n+\t{\n+\t  struct fn_decl *fn;\n+\t  c = getc (inf);\n+\t  if (c == EOF)\n+\t    break;\n+\t  if (isalpha (c) || c == '_')\n+\t    {\n+\t      struct partial_proto *partial;\n+\t      ungetc (c, inf);\n+\t      if (get_token (inf, &buf) != IDENTIFIER_TOKEN)\n+\t\tabort ();\n+\t      fputs (buf.base, outf);\n+\t      fn = lookup_std_proto (buf.base);\n+\t      /* We only want to edit the declaration matching the one\n+\t\t seen by scan-decls, as there can be multiple\n+\t\t declarations, selected by #ifdef __STDC__ or whatever. */\n+\t      if (fn && fn->partial && fn->partial->line_seen == lineno)\n+\t\t{\n+\t\t  c = skip_spaces (inf, ' ');\n+\t\t  if (c == EOF)\n+\t\t    break;\n+\t\t  if (c == '(')\n+\t\t    {\n+\t\t      c = skip_spaces (inf, ' ');\n+\t\t      if (c == ')')\n+\t\t\t{\n+\t\t\t  fprintf (outf, \" _PARAMS((%s))\", fn->params);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  putc ('(', outf);\n+\t\t\t  ungetc (c, inf);\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    putc (c, outf);\n+\t\t}\n+\t    }\n+\t  else\n+\t    putc (c, outf);\n+\t  if (c == '\\n')\n+\t    break;\n+\t}\n+      if (c == EOF)\n+\tbreak;\n+      lineno++;\n+    }\n+  if (rbrac_line < 0)\n+    write_rbrac ();\n+\n+  fclose (inf);\n+  fclose (outf);\n+\n+  return 0;\n+}"}, {"sha": "ace6d1267d8da3af54c0d6a5e47371dd43667551", "filename": "gcc/gen-protos.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=7936052fe60476efacd555f883a684a7b8d4736d", "patch": "@@ -0,0 +1,141 @@\n+/* gen-protos.c - massages a list of prototypes, for use by fixproto.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+#include \"scan.h\"\n+\n+#define HASH_SIZE 2503 /* a prime */\n+\n+int hash_tab[HASH_SIZE];\n+\n+sstring linebuf;\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char** argv;\n+{\n+  FILE *inf = stdin;\n+  FILE *outf = stdout;\n+  int next_index = 0;\n+  int i, i0;\n+\n+  fprintf (outf, \"struct fn_decl std_protos[] = {\\n\");\n+\n+  for (;;)\n+    {\n+      int c = skip_spaces (inf, ' ');\n+      int param_nesting = 1;\n+      char *param_start, *param_end, *decl_start,\n+      *name_start, *name_end;\n+      register char *ptr;\n+      if (c == EOF)\n+\tbreak;\n+      linebuf.ptr = linebuf.base;\n+      ungetc (c, inf);\n+      c = read_upto (inf, &linebuf, '\\n');\n+      if (linebuf.base[0] == '#') /* skip cpp command */\n+\tcontinue;\n+      if (linebuf.base[0] == '\\0') /* skip empty line */\n+\tcontinue;\n+\n+      ptr = linebuf.ptr - 1;\n+      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+      if (*ptr-- != ';')\n+\t{\n+\t  fprintf (stderr, \"Funny input line: %s\\n\", linebuf.base);\n+\t  continue;\n+\t}\n+      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+      if (*ptr != ')')\n+\t{\n+\t  fprintf (stderr, \"Funny input line: %s\\n\", linebuf.base);\n+\t  continue;\n+\t}\n+      param_end = ptr;\n+      for (;;)\n+\t{\n+\t  int c = *--ptr;\n+\t  if (c == '(' && --param_nesting == 0)\n+\t    break;\n+\t  else if (c == ')')\n+\t    param_nesting++;\n+\t}\n+      param_start = ptr+1;\n+\n+      ptr--;\n+      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+\n+      if (!isalnum (*ptr))\n+\t{\n+\t  fprintf (stderr, \"%s: Can't handle this complex prototype: %s\\n\",\n+\t\t   argv[0], linebuf.base);\n+\t  continue;\n+\t}\n+      name_end = ptr+1;\n+\n+      while (isalnum (*ptr) || *ptr == '_') --ptr;\n+      name_start = ptr+1;\n+      while (*ptr == ' ' || *ptr == '\\t') ptr--;\n+      ptr[1] = 0;\n+      *name_end = 0;\n+      *param_end = 0;\n+      *name_end = 0;\n+\n+      decl_start = linebuf.base;\n+      if (strncmp (decl_start, \"typedef \", 8) == 0)\n+\tcontinue;\n+      if (strncmp (decl_start, \"extern \", 7) == 0)\n+\tdecl_start += 7;\n+\n+\n+      /* NOTE:  If you edit this,\n+\t also edit lookup_std_proto in patch-header.c !! */\n+      i = hash(name_start) % HASH_SIZE;\n+      i0 = i;\n+      if (hash_tab[i] != 0)\n+\t{\n+\t  for (;;)\n+\t    {\n+\t      i = (i+1) % HASH_SIZE;\n+\t      if (i == i0)\n+\t\tabort();\n+\t      if (hash_tab[i] == 0)\n+\t\tbreak;\n+\t    }\n+\t}\n+      hash_tab[i] = next_index;\n+\n+      fprintf (outf, \"  {\\\"%s\\\", \\\"%s\\\", \\\"%s\\\" }, /* ix: %d, i0: %d */\\n\",\n+\t       name_start, decl_start, param_start, i, i0);\n+\n+      next_index++;\n+\n+      if (c == EOF)\n+\tbreak;\n+    }\n+  fprintf (outf, \"{0, 0, 0}\\n};\\n\");\n+\n+\n+  fprintf (outf, \"#define HASH_SIZE %d\\n\", HASH_SIZE);\n+  fprintf (outf, \"short hash_tab[HASH_SIZE] = {\\n\");\n+  for (i = 0; i < HASH_SIZE; i++)\n+    fprintf (outf, \"  %d,\\n\", hash_tab[i]);\n+  fprintf (outf, \"};\\n\");\n+\n+  return 0;\n+}"}, {"sha": "4e2f1943005fa583c87d5ac1b6cd604a79dad2bd", "filename": "gcc/scan-decls.c", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=7936052fe60476efacd555f883a684a7b8d4736d", "patch": "@@ -0,0 +1,170 @@\n+/* scan-decls.c - Extracts declarations from cpp output.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This filter scans a C source file (actually, the output of cpp).\n+   It looks for function declaration.  For each declaration, it prints:\n+\n+   \tNAME;C;RTYPE;ARGS;FILENAME;LINENO;\n+\n+   NAME is the function's name.\n+   C is \"F\" if the declaration is nested inside 'extern \"C\"' braces;\n+   otherwise \"f\".\n+   RTYPE is the function's return type.\n+   ARGS is the function's argument list.\n+   FILENAME and LINENO is where the declarations was seen\n+   (taking #-directives into account).\n+\n+   Also:\n+\n+\tNAME;M;\n+   indicates that the macro NAME was seen (when invoked from fixproto).\n+\tNAME;X;TYPE;\n+   indicates that 'extern TYPE NAME;' was seen.\n+\n+   Written by Per Bothner <bothner@cygnus.com>, July 1993.\n+   */\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+#include \"scan.h\"\n+\n+sstring buf;\n+sstring rtype;\n+\n+int brace_nesting = 0;\n+\n+/* The first extern_C_braces_length elements of extern_C_braces\n+   indicate the (brace nesting levels of) left braces that were\n+   prefixed by extern \"C\". */\n+int extern_C_braces_length = 0;\n+char extern_C_braces[20];\n+#define in_extern_C_brace (extern_C_braces_length>0)\n+\n+/* True if the function declaration currently being scanned is\n+   prefixed by extern \"C\". */\n+int current_extern_C = 0;\n+\n+int\n+main ()\n+{\n+  FILE *fp = stdin;\n+  int c;\n+  int saw_extern;\n+\n+ new_statement:\n+  c = get_token (fp, &buf);\n+ handle_statement:\n+  current_extern_C = 0;\n+  saw_extern = 0;\n+  if (c == '}')\n+    {\n+      /* pop an 'extern \"C\"' nesting level, if appropriate */\n+      if (extern_C_braces_length\n+\t  && extern_C_braces[extern_C_braces_length - 1] == brace_nesting)\n+\textern_C_braces_length--;\n+      brace_nesting--;\n+      goto new_statement;\n+    }\n+  if (c == '{')\n+    {\n+      brace_nesting++;\n+      goto new_statement;\n+    }\n+  if (c == EOF)\n+    return 0;\n+  if (c == ';')\n+    goto new_statement;\n+  if (c != IDENTIFIER_TOKEN)\n+    goto new_statement;\n+  rtype.ptr = rtype.base;\n+  if (SSTRING_LENGTH (&buf) > 16\n+      && strncmp (buf.base, \"__DEFINED_MACRO_\", 16) == 0)\n+    {\n+      fprintf (stdout, \"%s;M;\\n\", buf.base+16);\n+      goto new_statement;\n+    }\n+  if (strcmp (buf.base, \"extern\") == 0)\n+    {\n+      saw_extern = 1;\n+      c = get_token (fp, &buf);\n+      if (c == STRING_TOKEN && strcmp (buf.base, \"C\") == 0)\n+\t{\n+\t  current_extern_C = 1;\n+\t  c = get_token (fp, &buf);\n+\t  if (c == '{')\n+\t    {\n+\t      brace_nesting++;\n+\t      extern_C_braces[extern_C_braces_length++] = brace_nesting;\n+\t      goto new_statement;\n+\t    }\n+\t  c = get_token (fp, &buf);\n+\t}\n+    }\n+  for (;;)\n+    {\n+      int followingc = getc (fp); /* char following token in buf */\n+      if (c == IDENTIFIER_TOKEN)\n+\t{\n+\t  int nextc = skip_spaces (fp, followingc);\n+\t  if (nextc == '(')\n+\t    {\n+\t      int nesting = 1;\n+\n+\t      MAKE_SSTRING_SPACE(&rtype, 1);\n+\t      *rtype.ptr = 0;\n+\n+ \t      fprintf (stdout, \"%s;%s;%s;\",\n+\t\t       buf.base,\n+\t\t       in_extern_C_brace || current_extern_C ? \"F\" : \"f\",\n+\t\t       rtype.base);\n+\t      c = skip_spaces (fp, ' ');\n+\t      for (;;)\n+\t\t{\n+\t\t  if (c == '(')\n+\t\t    nesting++;\n+\t\t  else if (c == ')')\n+\t\t    if (--nesting == 0)\n+\t\t      break;\n+\t\t  if (c == EOF)\n+\t\t    break;\n+\t\t  if (c == '\\n')\n+\t\t    c = ' ';\n+\t\t  putc (c, stdout);\t\n+\t\t  c = getc (fp);\n+\t\t}\n+\t      fprintf (stdout, \";%s;%d;\\n\",\n+\t\t       source_filename.base, source_lineno);\n+\t      goto new_statement;\n+\t    }\n+\t  else if (nextc == ';' && saw_extern)\n+\t    {\n+ \t      fprintf (stdout, \"%s;X;%s;\\n\", buf.base, rtype.base);\n+\t      goto handle_statement;\n+\t    }\n+\t  else\n+\t    ungetc (nextc, fp);\n+\t}\n+      else if (followingc != EOF)\n+\tungetc (followingc, fp);\n+      if (c == ';' || c == '{' || c == '}' || c == EOF)\n+\tgoto handle_statement;\n+      sstring_append (&rtype, &buf);\n+      if (followingc == ' ' || followingc == '\\t' || followingc == '\\n')\n+\tSSTRING_PUT(&rtype, ' ');\n+      c = get_token (fp, &buf);\n+    }\n+}"}, {"sha": "a4980ea76f543967b1726ba96852cad045f2582d", "filename": "gcc/scan.c", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fscan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fscan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.c?ref=7936052fe60476efacd555f883a684a7b8d4736d", "patch": "@@ -0,0 +1,274 @@\n+/* scan.c - Utility functions for scan-decls and patch-header programs.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"scan.h\"\n+#include <ctype.h>\n+\n+int lineno = 1;\n+int source_lineno = 1;\n+sstring source_filename;\n+\n+void\n+make_sstring_space (str, count)\n+     sstring *str;\n+     int count;\n+{\n+  int cur_pos = str->ptr - str->base;\n+  int cur_size = str->limit - str->base;\n+  int new_size = cur_pos + count + 100;\n+\n+  if (new_size <= cur_size)\n+    return;\n+  \n+  if (str->base == NULL)\n+    str->base = xmalloc (new_size);\n+  else\n+    str->base = xrealloc (str->base, new_size);\n+  str->ptr = str->base + cur_size;\n+  str->limit = str->base + new_size;\n+}\n+\n+void\n+sstring_append (dst, src)\n+     sstring *dst;\n+     sstring *src;\n+{\n+  register char *d, *s;\n+  register count = SSTRING_LENGTH(src);\n+  MAKE_SSTRING_SPACE(dst, count + 1);\n+  d = dst->ptr;\n+  s = src->base;\n+  while (--count >= 0) *d++ = *s++;\n+  dst->ptr = d;\n+  *d = 0;  \n+}\n+\n+memory_full ()\n+{\n+  abort();\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *ptr = (char *) malloc (size);\n+  if (ptr != 0) return (ptr);\n+  memory_full ();\n+  /*NOTREACHED*/\n+  return 0;\n+}\n+\n+\n+char *\n+xrealloc (old, size)\n+     char *old;\n+     unsigned size;\n+{\n+  register char *ptr = (char *) realloc (old, size);\n+  if (ptr != 0) return (ptr);\n+  memory_full ();\n+  /*NOTREACHED*/\n+  return 0;\n+}\n+\n+int\n+scan_ident (fp, s, c)\n+     register FILE *fp;\n+     register sstring *s;\n+     int c;\n+{\n+  s->ptr = s->base;\n+  if (isalpha(c) || c == '_')\n+    {\n+      for (;;)\n+\t{\n+\t  SSTRING_PUT(s, c);\n+\t  c = getc (fp);\n+\t  if (c == EOF || !(isalnum(c) || c == '_'))\n+\t    break;\n+\t}\n+    }\n+  MAKE_SSTRING_SPACE(s, 1);\n+  *s->ptr = 0;\n+  return c;\n+}\n+\n+int scan_string (fp, s, init)\n+     register FILE *fp;\n+     register sstring *s;\n+{\n+  int c;\n+  for (;;)\n+    {\n+      c = getc (fp);\n+      if (c == EOF || c == '\\n')\n+\tbreak;\n+      if (c == init)\n+\t{\n+\t  c = getc (fp);\n+\t  break;\n+\t}\n+      if (c == '\\\\')\n+\t{\n+\t  c = getc (fp);\n+\t  if (c == EOF)\n+\t    break;\n+\t  if (c == '\\n')\n+\t    continue;\n+\t}\n+      SSTRING_PUT(s, c);\n+    }\n+  MAKE_SSTRING_SPACE(s, 1);\n+  *s->ptr = 0;\n+  return c;\n+}\n+\n+/* Skip horizontal white spaces (spaces, tabs, and C-style comments). */\n+\n+int skip_spaces (fp, c)\n+     register FILE *fp;\n+     int c;\n+{\n+  for (;;)\n+    {\n+      if (c == ' ' || c == '\\t')\n+\tc = getc (fp);\n+      else if (c == '/')\n+\t{\n+\t  c = getc (fp);\n+\t  if (c != '*')\n+\t    {\n+\t      ungetc (c, fp);\n+\t      return '/';\n+\t    }\n+\t  c = getc (fp);\n+\t  for (;;)\n+\t    {\n+\t      if (c == EOF)\n+\t\treturn EOF;\n+\t      else if (c != '*')\n+\t\t{\n+\t\t  if (c == '\\n')\n+\t\t    source_lineno++, lineno++;\n+\t\t  c = getc (fp);\n+\t\t}\n+\t      else if ((c = getc (fp)) == '/')\n+\t\treturn getc (fp);\n+\t    }\n+\t}\n+      else\n+\tbreak;\n+    }\n+  return c;\n+}\n+\n+int\n+read_upto (fp, str, delim)\n+     FILE *fp;\n+     sstring *str;\n+     int delim;\n+{\n+  int ch;\n+  for (;;)\n+    {\n+      ch = getc (fp);\n+      if (ch == EOF || ch == delim)\n+\tbreak;\n+      SSTRING_PUT(str, ch);\n+    }\n+  MAKE_SSTRING_SPACE(str, 1);\n+  *str->ptr = 0;\n+  return ch;\n+}\n+\n+int\n+get_token (fp, s)\n+     register FILE *fp;\n+     register sstring *s;\n+{\n+  int c;\n+  s->ptr = s->base;\n+ retry:\n+  c = ' ';\n+ again:\n+  c = skip_spaces (fp, c);\n+  if (c == '\\n')\n+    {\n+      source_lineno++;\n+      lineno++;\n+      goto retry;\n+    }\n+  if (c == '#')\n+    {\n+      c = get_token (fp, s);\n+      if (c == INT_TOKEN)\n+\t{\n+\t  source_lineno = atoi (s->base);\n+\t  get_token (fp, &source_filename);\n+\t}\n+      for (;;)\n+\t{\n+\t  c = getc (fp);\n+\t  if (c == EOF)\n+\t    return EOF;\n+\t  if (c == '\\n')\n+\t    goto retry;\n+\t}\n+    }\n+  if (c == EOF)\n+    return EOF;\n+  if (isdigit (c))\n+    {\n+      do\n+\t{\n+\t  SSTRING_PUT(s, c);\n+\t  c = getc (fp);\n+\t} while (c != EOF && isdigit(c));\n+      ungetc (c, fp);\n+      c = INT_TOKEN;\n+      goto done;\n+    }\n+  if (isalpha (c) || c == '_')\n+    {\n+      c = scan_ident (fp, s, c);\n+      ungetc (c, fp);\n+      return IDENTIFIER_TOKEN;\n+    }\n+  if (c == '\\'' || c == '\"')\n+    {\n+      int quote = c;\n+      c = scan_string (fp, s, c);\n+      ungetc (c, fp);\n+      return c == '\\'' ? CHAR_TOKEN : STRING_TOKEN;\n+    }\n+  SSTRING_PUT(s, c);\n+ done:\n+  MAKE_SSTRING_SPACE(s, 1);\n+  *s->ptr = 0;\n+  return c;\n+}\n+\n+unsigned long\n+hash (str)\n+     char *str;\n+{\n+  int h = 0;\n+  /* Replace this with something faster/better! FIXME! */\n+  while (*str) h = (h << 3) + *str++;\n+  return h & 0x7FFFFFFF;\n+}"}, {"sha": "7106eb0bf791c3f6c4cfb4957e522039ac4b4bc1", "filename": "gcc/scan.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7936052fe60476efacd555f883a684a7b8d4736d/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=7936052fe60476efacd555f883a684a7b8d4736d", "patch": "@@ -0,0 +1,75 @@\n+/* scan.h - Utility declarations for scan-decls and patch-header programs.\n+   Copyright (C) 1993 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include <stdio.h>\n+\n+typedef struct sstring\n+{\n+  char *base;\n+  char *ptr;\n+  char *limit;\n+} sstring;\n+\n+#define INIT_SSTRING(STR) ((STR)->base = 0, (STR)->ptr = 0, (STR)->limit = 0)\n+#define FREE_SSTRING(STR) do { if ((STR)->base) free (STR)->base; } while(0)\n+#define SSTRING_PUT(STR, C) do {\\\n+  if ((STR)->limit <= (STR)->ptr) make_sstring_space (STR, 1); \\\n+  *(STR)->ptr++ = (C); } while (0)\n+#define SSTRING_LENGTH(STR) ((STR)->ptr - (STR)->base)\n+#define MAKE_SSTRING_SPACE(STR, COUNT) \\\n+  if ((STR)->limit - (STR)->ptr < (COUNT)) make_sstring_space (STR, COUNT);\n+\n+#ifndef _PARAMS\n+#if defined(__STDC__) || defined(__cplusplus)\n+#define _PARAMS(args) args\n+#else\n+#define _PARAMS(args) ()\n+#endif\n+#endif\n+\n+struct partial_proto;\n+struct fn_decl\n+{\n+  char *fname;\n+  char *rtype;\n+  char *params;\n+  struct partial_proto *partial;\n+};\n+\n+extern int lineno;\n+extern void sstring_append _PARAMS((sstring*, sstring*));\n+extern void make_sstring_space _PARAMS((sstring*, int));\n+extern int skip_spaces _PARAMS((FILE*, int));\n+extern int scan_ident _PARAMS((FILE *, sstring *, int));\n+extern int scan_string _PARAMS((FILE*, sstring *, int));\n+extern int read_upto _PARAMS((FILE*, sstring*, int));\n+extern char *xmalloc _PARAMS((unsigned));\n+extern char *xrealloc _PARAMS((char *, unsigned));\n+extern unsigned long hash _PARAMS((char*));\n+\n+/* get_token is a simple C lexer. */\n+#define IDENTIFIER_TOKEN 300\n+#define CHAR_TOKEN 301\n+#define STRING_TOKEN 302\n+#define INT_TOKEN 303\n+extern int get_token _PARAMS ((FILE*, sstring*));\n+\n+/* Current file and line numer, taking #-directives into account */\n+extern int source_lineno;\n+extern sstring source_filename;\n+/* Current physical line number */\n+extern int lineno;"}]}