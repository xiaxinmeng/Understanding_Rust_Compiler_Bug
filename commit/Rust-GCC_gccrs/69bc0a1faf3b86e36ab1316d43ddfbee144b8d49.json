{"sha": "69bc0a1faf3b86e36ab1316d43ddfbee144b8d49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliYzBhMWZhZjNiODZlMzZhYjEzMTZkNDNkZGZiZWUxNDRiOGQ0OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-01-07T13:37:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-01-07T13:37:32Z"}, "message": "combine.c (combine_simplify_rtx): Recognize the unordered compares.\n\n\n\t* combine.c (combine_simplify_rtx): Recognize the unordered compares.\n\t(nonzero_bits): Likewise.\n\t(simplify_comparison): Likewise.\n\t(num_sign_bit_copies): Likewise; return more sane value depending\n\ton STORE_FLAG_VALUE.\n\t(known_cond): Do not assume EQ to be always true for equivalent\n\toperands.\n\nFrom-SVN: r38774", "tree": {"sha": "37c8451f6d92ee2aa6a5cf80f4a309fda5bf0ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37c8451f6d92ee2aa6a5cf80f4a309fda5bf0ca7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49/comments", "author": null, "committer": null, "parents": [{"sha": "fd13313fdb19c5dd5a5229b87fe856bda8a40166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd13313fdb19c5dd5a5229b87fe856bda8a40166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd13313fdb19c5dd5a5229b87fe856bda8a40166"}], "stats": {"total": 46, "additions": 37, "deletions": 9}, "files": [{"sha": "c1141eb8e4e1140f92f82a11bda5e1a937a6f01d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69bc0a1faf3b86e36ab1316d43ddfbee144b8d49", "patch": "@@ -1,3 +1,13 @@\n+Sun Jan  7 14:35:13 MET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* combine.c (combine_simplify_rtx): Recognize the unordered compares.\n+\t(nonzero_bits): Likewise.\n+\t(simplify_comparison): Likewise.\n+\t(num_sign_bit_copies): Likewise; return more sane value depending\n+\ton STORE_FLAG_VALUE.\n+\t(known_cond): Do not assume EQ to be always true for equivalent\n+\toperands.\n+\n Sun Jan  7 14:31:57 MET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* cse.c (fold_rtx): Handle unordered comparisons."}, {"sha": "b8a2e043ac057d4a4612c8a0ec3974eff8113990", "filename": "gcc/combine.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc0a1faf3b86e36ab1316d43ddfbee144b8d49/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=69bc0a1faf3b86e36ab1316d43ddfbee144b8d49", "patch": "@@ -4329,6 +4329,10 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n     case EQ:  case NE:\n     case GT:  case GTU:  case GE:  case GEU:\n     case LT:  case LTU:  case LE:  case LEU:\n+    case UNEQ:  case LTGT:\n+    case UNGT:  case UNGE:  \n+    case UNLT:  case UNLE:  \n+    case UNORDERED: case ORDERED:\n       /* If the first operand is a condition code, we can't do anything\n \t with it.  */\n       if (GET_CODE (XEXP (x, 0)) == COMPARE\n@@ -7488,7 +7492,9 @@ known_cond (x, cond, reg, val)\n   if (side_effects_p (x))\n     return x;\n \n-  if (cond == EQ && rtx_equal_p (x, reg))\n+  if (cond == EQ && rtx_equal_p (x, reg) && !FLOAT_MODE_P (cond))\n+    return val;\n+  if (cond == UNEQ && rtx_equal_p (x, reg))\n     return val;\n \n   /* If X is (abs REG) and we know something about REG's relationship\n@@ -8119,10 +8125,12 @@ nonzero_bits (x, mode)\n       break;\n \n     case EQ:  case NE:\n-    case GT:  case GTU:\n-    case LT:  case LTU:\n-    case GE:  case GEU:\n-    case LE:  case LEU:\n+    case UNEQ:  case LTGT:\n+    case GT:  case GTU:  case UNGT:\n+    case LT:  case LTU:  case UNLT:\n+    case GE:  case GEU:  case UNGE:\n+    case LE:  case LEU:  case UNLE:\n+    case UNORDERED: case ORDERED:\n \n       /* If this produces an integer result, we know which bits are set.\n \t Code here used to clear bits outside the mode of X, but that is\n@@ -8696,9 +8704,17 @@ num_sign_bit_copies (x, mode)\n       return MIN (num0, num1);\n \n     case EQ:  case NE:  case GE:  case GT:  case LE:  case LT:\n+    case UNEQ:  case LTGT:  case UNGE:  case UNGT:  case UNLE:  case UNLT:\n     case GEU: case GTU: case LEU: case LTU:\n-      if (STORE_FLAG_VALUE == -1)\n-\treturn bitwidth;\n+    case UNORDERED: case ORDERED:\n+      /* If the constant is negative, take its 1's complement and remask.\n+\t Then see how many zero bits we have.  */\n+      nonzero = STORE_FLAG_VALUE;\n+      if (bitwidth <= HOST_BITS_PER_WIDE_INT\n+\t  && (nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n+\n+      return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n       break;\n \n     default:\n@@ -10668,8 +10684,10 @@ simplify_comparison (code, pop0, pop1)\n \t  break;\n \n \tcase EQ:  case NE:\n-\tcase LT:  case LTU:  case LE:  case LEU:\n-\tcase GT:  case GTU:  case GE:  case GEU:\n+\tcase UNEQ:  case LTGT:\n+\tcase LT:  case LTU:  case UNLT:  case LE:  case LEU:  case UNLE:\n+\tcase GT:  case GTU:  case UNGT:  case GE:  case GEU:  case UNGE:\n+        case UNORDERED: case ORDERED:\n \t  /* We can't do anything if OP0 is a condition code value, rather\n \t     than an actual data value.  */\n \t  if (const_op != 0"}]}