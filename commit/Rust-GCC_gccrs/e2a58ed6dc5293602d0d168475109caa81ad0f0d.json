{"sha": "e2a58ed6dc5293602d0d168475109caa81ad0f0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJhNThlZDZkYzUyOTM2MDJkMGQxNjg0NzUxMDljYWE4MWFkMGYwZA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2021-03-02T12:20:11Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2021-08-09T12:47:42Z"}, "message": "openacc: Middle-end worker-partitioning support\n\nThis patch implements worker-partitioning support in the middle end,\nby rewriting gimple. The OpenACC execution model requires that code\ncan run in either \"worker single\" mode where only a single worker per\ngang is active, or \"worker partitioned\" mode, where multiple workers\nper gang are active. This means we need to do something equivalent\nto spawning additional workers when transitioning from worker-single\nto worker-partitioned mode. However, GPUs typically fix the number of\nthreads of invoked kernels at launch time, so we need to do something\nwith the \"extra\" threads when they are not wanted.\n\nThe scheme used is to conditionalise each basic block that executes\nin \"worker single\" mode for worker 0 only. Conditional branches\nare handled specially so \"idle\" (non-0) workers follow along with\nworker 0. On transitioning to \"worker partitioned\" mode, any variables\nmodified by worker 0 are propagated to the other workers via GPU shared\nmemory. Special care is taken for routine calls, writes through pointers,\nand so forth, as follows:\n\n  - There are two types of function calls to consider in worker-single\n    mode: \"normal\" calls to maths library routines, etc. are called from\n    worker 0 only. OpenACC routines may contain worker-partitioned loops\n    themselves, so are called from all workers, including \"idle\" ones.\n\n  - SSA names set in worker-single mode, but used in worker-partitioned\n    mode, are copied to shared memory in worker 0. Other workers retrieve\n    the value from the appropriate shared-memory location after a barrier,\n    and new phi nodes are introduced at the convergence point to resolve\n    the worker 0/other worker copies of the value.\n\n  - Local scalar variables (on the stack) also need special handling. We\n    broadcast any variables that are written in the current worker-single\n    block, and that are read in any worker-partitioned block.  (This is\n    believed to be safe, and is flow-insensitive to ease analysis.)\n\n  - Local aggregates (arrays and composites) on the stack are *not*\n    broadcast. Instead we force gimple stmts modifying elements/fields of\n    local aggregates into fully-partitioned mode. The RHS of the\n    assignment is a scalar, and is thus subject to broadcasting as above.\n\n  - Writes through pointers may affect any local variable that has\n    its address taken. We use points-to analysis to determine the set\n    of potentially-affected variables for a given pointer indirection.\n    We broadcast any such variable which is used in worker-partitioned\n    mode, on a per-block basis for any block containing a write through\n    a pointer.\n\nSome slides about the implementation (from 2018) are available at:\n\n  https://jtb20.github.io/gcnworkers.pdf\n\n\tgcc/\n\t* Makefile.in (OBJS): Add omp-oacc-neuter-broadcast.o.\n\t* doc/tm.texi.in (TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD):\n\tAdd documentation hook.\n\t* doc/tm.texi: Regenerate.\n\t* omp-oacc-neuter-broadcast.cc: New file.\n\t* omp-builtins.def (BUILT_IN_GOACC_BARRIER)\n\t(BUILT_IN_GOACC_SINGLE_START, BUILT_IN_GOACC_SINGLE_COPY_START)\n\t(BUILT_IN_GOACC_SINGLE_COPY_END): New builtins.\n\t* passes.def (pass_omp_oacc_neuter_broadcast): Add pass.\n\t* target.def (goacc.create_worker_broadcast_record): Add target\n\thook.\n\t* tree-pass.h (make_pass_omp_oacc_neuter_broadcast): Add\n\tprototype.\n\t* config/gcn/gcn-protos.h (gcn_goacc_adjust_propagation_record):\n\tRename prototype to...\n\t(gcn_goacc_create_worker_broadcast_record): ... this.\n\t* config/gcn/gcn-tree.c (gcn_goacc_adjust_propagation_record): Rename\n\tfunction to...\n\t(gcn_goacc_create_worker_broadcast_record): ... this.\n\t* config/gcn/gcn.c (TARGET_GOACC_ADJUST_PROPAGATION_RECORD):\n\tRename to...\n\t(TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD): ... this.\n\nCo-Authored-By: Nathan Sidwell <nathan@codesourcery.com> (via 'gcc/config/nvptx/nvptx.c' master)\nCo-Authored-By: Kwok Cheung Yeung <kcy@codesourcery.com>\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "a9b97eaab19148ad4b70da3a31fa63caf042f235", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b97eaab19148ad4b70da3a31fa63caf042f235"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2a58ed6dc5293602d0d168475109caa81ad0f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a58ed6dc5293602d0d168475109caa81ad0f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2a58ed6dc5293602d0d168475109caa81ad0f0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2a58ed6dc5293602d0d168475109caa81ad0f0d/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2e0b85c1e7cb53fd720df0d09278e3d485c733e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2e0b85c1e7cb53fd720df0d09278e3d485c733e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2e0b85c1e7cb53fd720df0d09278e3d485c733e"}], "stats": {"total": 1618, "additions": 1584, "deletions": 34}, "files": [{"sha": "6653e9e21427a23dfdce7126e9b7853d56793fc2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -1513,6 +1513,7 @@ OBJS = \\\n \tomp-general.o \\\n \tomp-low.o \\\n \tomp-oacc-kernels-decompose.o \\\n+\tomp-oacc-neuter-broadcast.o \\\n \tomp-simd-clone.o \\\n \topt-problem.o \\\n \toptabs.o \\"}, {"sha": "5d62a845bec030bae7a7d26511b6160e15dcdc5c", "filename": "gcc/config/gcn/gcn-protos.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -38,9 +38,10 @@ extern rtx gcn_full_exec ();\n extern rtx gcn_full_exec_reg ();\n extern rtx gcn_gen_undef (machine_mode);\n extern bool gcn_global_address_p (rtx);\n-extern tree gcn_goacc_adjust_propagation_record (tree record_type, bool sender,\n-\t\t\t\t\t\t const char *name);\n extern tree gcn_goacc_adjust_private_decl (location_t, tree var, int level);\n+extern tree gcn_goacc_create_worker_broadcast_record (tree record_type,\n+\t\t\t\t\t\t      bool sender,\n+\t\t\t\t\t\t      const char *name);\n extern void gcn_goacc_reduction (gcall *call);\n extern bool gcn_hard_regno_rename_ok (unsigned int from_reg,\n \t\t\t\t      unsigned int to_reg);"}, {"sha": "f722d2d3c4eba48a59ffef617c1150a8a9a4bb1f", "filename": "gcc/config/gcn/gcn-tree.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -548,35 +548,6 @@ gcn_goacc_reduction (gcall *call)\n     }\n }\n \n-/* Implement TARGET_GOACC_ADJUST_PROPAGATION_RECORD.\n- \n-   Tweak (worker) propagation record, e.g. to put it in shared memory.  */\n-\n-tree\n-gcn_goacc_adjust_propagation_record (tree record_type, bool sender,\n-\t\t\t\t     const char *name)\n-{\n-  tree type = record_type;\n-\n-  TYPE_ADDR_SPACE (type) = ADDR_SPACE_LDS;\n-\n-  if (!sender)\n-    type = build_pointer_type (type);\n-\n-  tree decl = create_tmp_var_raw (type, name);\n-\n-  if (sender)\n-    {\n-      DECL_CONTEXT (decl) = NULL_TREE;\n-      TREE_STATIC (decl) = 1;\n-    }\n-\n-  if (sender)\n-    varpool_node::finalize_decl (decl);\n-\n-  return decl;\n-}\n-\n tree\n gcn_goacc_adjust_private_decl (location_t, tree var, int level)\n {\n@@ -604,4 +575,33 @@ gcn_goacc_adjust_private_decl (location_t, tree var, int level)\n   return var;\n }\n \n+/* Implement TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD.\n+\n+   Create OpenACC worker state propagation record in shared memory.  */\n+\n+tree\n+gcn_goacc_create_worker_broadcast_record (tree record_type, bool sender,\n+\t\t\t\t\t  const char *name)\n+{\n+  tree type = record_type;\n+\n+  TYPE_ADDR_SPACE (type) = ADDR_SPACE_LDS;\n+\n+  if (!sender)\n+    type = build_pointer_type (type);\n+\n+  tree decl = create_tmp_var_raw (type, name);\n+\n+  if (sender)\n+    {\n+      DECL_CONTEXT (decl) = NULL_TREE;\n+      TREE_STATIC (decl) = 1;\n+    }\n+\n+  if (sender)\n+    varpool_node::finalize_decl (decl);\n+\n+  return decl;\n+}\n+\n /* }}}  */"}, {"sha": "87af5d18f420cba3de408c8d22aacaef6f6292bf", "filename": "gcc/config/gcn/gcn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -6513,11 +6513,11 @@ gcn_dwarf_register_span (rtx rtl)\n #define TARGET_GIMPLIFY_VA_ARG_EXPR gcn_gimplify_va_arg_expr\n #undef TARGET_OMP_DEVICE_KIND_ARCH_ISA\n #define TARGET_OMP_DEVICE_KIND_ARCH_ISA gcn_omp_device_kind_arch_isa\n-#undef  TARGET_GOACC_ADJUST_PROPAGATION_RECORD\n-#define TARGET_GOACC_ADJUST_PROPAGATION_RECORD \\\n-  gcn_goacc_adjust_propagation_record\n #undef  TARGET_GOACC_ADJUST_PRIVATE_DECL\n #define TARGET_GOACC_ADJUST_PRIVATE_DECL gcn_goacc_adjust_private_decl\n+#undef  TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD\n+#define TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD \\\n+  gcn_goacc_create_worker_broadcast_record\n #undef  TARGET_GOACC_FORK_JOIN\n #define TARGET_GOACC_FORK_JOIN gcn_fork_join\n #undef  TARGET_GOACC_REDUCTION"}, {"sha": "a30fdcbbf3d680c12dcb6a97af90dd018732de4a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -6409,6 +6409,15 @@ private variables at OpenACC device-lowering time using the\n @code{TARGET_GOACC_ADJUST_PRIVATE_DECL} target hook.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD (tree @var{rec}, bool @var{sender}, const char *@var{name})\n+Create a record used to propagate local-variable state from an active\n+worker to other workers.  A possible implementation might adjust the type\n+of REC to place the new variable in shared GPU memory.\n+\n+Presence of this target hook indicates that middle end neutering/broadcasting\n+be used.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "611fc500ac86c9621849f94a9e4b3a8d6e64e631", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -4223,6 +4223,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_GOACC_EXPAND_VAR_DECL\n \n+@hook TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "05b555c7fa03cacaf9e0f3d746040186e5924a50", "filename": "gcc/omp-builtins.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fomp-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fomp-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-builtins.def?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -59,6 +59,15 @@ DEF_GOACC_BUILTIN_ONLY (BUILT_IN_GOACC_PARLEVEL_ID, \"goacc_parlevel_id\",\n DEF_GOACC_BUILTIN_ONLY (BUILT_IN_GOACC_PARLEVEL_SIZE, \"goacc_parlevel_size\",\n \t\t\tBT_FN_INT_INT, ATTR_NOTHROW_LEAF_LIST)\n \n+DEF_GOACC_BUILTIN_ONLY (BUILT_IN_GOACC_BARRIER, \"GOACC_barrier\",\n+\t\t\tBT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOACC_BUILTIN_ONLY (BUILT_IN_GOACC_SINGLE_START, \"GOACC_single_start\",\n+\t\t\tBT_FN_BOOL, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOACC_BUILTIN_ONLY (BUILT_IN_GOACC_SINGLE_COPY_START, \"GOACC_single_copy_start\",\n+\t\t\tBT_FN_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_GOACC_BUILTIN_ONLY (BUILT_IN_GOACC_SINGLE_COPY_END, \"GOACC_single_copy_end\",\n+\t\t\tBT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_THREAD_NUM, \"omp_get_thread_num\",\n \t\t  BT_FN_INT, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GOMP_BUILTIN (BUILT_IN_OMP_GET_NUM_THREADS, \"omp_get_num_threads\","}, {"sha": "0f6ba885c6c25da350bcc1a45b1a5ca1c1f15c4c", "filename": "gcc/omp-oacc-neuter-broadcast.cc", "status": "added", "additions": 1515, "deletions": 0, "changes": 1515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fomp-oacc-neuter-broadcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fomp-oacc-neuter-broadcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-oacc-neuter-broadcast.cc?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -0,0 +1,1515 @@\n+/* OpenACC worker partitioning via middle end neutering/broadcasting scheme\n+\n+   Copyright (C) 2015-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"cgraph.h\"\n+#include \"pretty-print.h\"\n+#include \"fold-const.h\"\n+#include \"gimplify.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"tree-inline.h\"\n+#include \"langhooks.h\"\n+#include \"omp-general.h\"\n+#include \"omp-low.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"cfghooks.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"internal-fn.h\"\n+#include \"bitmap.h\"\n+#include \"tree-nested.h\"\n+#include \"stor-layout.h\"\n+#include \"tree-ssa-threadupdate.h\"\n+#include \"tree-into-ssa.h\"\n+#include \"splay-tree.h\"\n+#include \"target.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-cfg.h\"\n+#include \"omp-offload.h\"\n+#include \"attribs.h\"\n+\n+/* Loop structure of the function.  The entire function is described as\n+   a NULL loop.  */\n+\n+struct parallel_g\n+{\n+  /* Parent parallel.  */\n+  parallel_g *parent;\n+\n+  /* Next sibling parallel.  */\n+  parallel_g *next;\n+\n+  /* First child parallel.  */\n+  parallel_g *inner;\n+\n+  /* Partitioning mask of the parallel.  */\n+  unsigned mask;\n+\n+  /* Partitioning used within inner parallels. */\n+  unsigned inner_mask;\n+\n+  /* Location of parallel forked and join.  The forked is the first\n+     block in the parallel and the join is the first block after of\n+     the partition.  */\n+  basic_block forked_block;\n+  basic_block join_block;\n+\n+  gimple *forked_stmt;\n+  gimple *join_stmt;\n+\n+  gimple *fork_stmt;\n+  gimple *joining_stmt;\n+\n+  /* Basic blocks in this parallel, but not in child parallels.  The\n+     FORKED and JOINING blocks are in the partition.  The FORK and JOIN\n+     blocks are not.  */\n+  auto_vec<basic_block> blocks;\n+\n+  tree record_type;\n+  tree sender_decl;\n+  tree receiver_decl;\n+\n+public:\n+  parallel_g (parallel_g *parent, unsigned mode);\n+  ~parallel_g ();\n+};\n+\n+/* Constructor links the new parallel into it's parent's chain of\n+   children.  */\n+\n+parallel_g::parallel_g (parallel_g *parent_, unsigned mask_)\n+  :parent (parent_), next (0), inner (0), mask (mask_), inner_mask (0)\n+{\n+  forked_block = join_block = 0;\n+  forked_stmt = join_stmt = NULL;\n+  fork_stmt = joining_stmt = NULL;\n+\n+  record_type = NULL_TREE;\n+  sender_decl = NULL_TREE;\n+  receiver_decl = NULL_TREE;\n+\n+  if (parent)\n+    {\n+      next = parent->inner;\n+      parent->inner = this;\n+    }\n+}\n+\n+parallel_g::~parallel_g ()\n+{\n+  delete inner;\n+  delete next;\n+}\n+\n+static bool\n+local_var_based_p (tree decl)\n+{\n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL:\n+      return !is_global_var (decl);\n+\n+    case COMPONENT_REF:\n+    case BIT_FIELD_REF:\n+    case ARRAY_REF:\n+      return local_var_based_p (TREE_OPERAND (decl, 0));\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Map of basic blocks to gimple stmts.  */\n+typedef hash_map<basic_block, gimple *> bb_stmt_map_t;\n+\n+/* Calls to OpenACC routines are made by all workers/wavefronts/warps, since\n+   the routine likely contains partitioned loops (else will do its own\n+   neutering and variable propagation). Return TRUE if a function call CALL\n+   should be made in (worker) single mode instead, rather than redundant\n+   mode.  */\n+\n+static bool\n+omp_sese_active_worker_call (gcall *call)\n+{\n+#define GOMP_DIM_SEQ GOMP_DIM_MAX\n+  tree fndecl = gimple_call_fndecl (call);\n+\n+  if (!fndecl)\n+    return true;\n+\n+  tree attrs = oacc_get_fn_attrib (fndecl);\n+\n+  if (!attrs)\n+    return true;\n+\n+  int level = oacc_fn_attrib_level (attrs);\n+\n+  /* Neither regular functions nor \"seq\" routines should be run by all threads\n+     in worker-single mode.  */\n+  return level == -1 || level == GOMP_DIM_SEQ;\n+#undef GOMP_DIM_SEQ\n+}\n+\n+/* Split basic blocks such that each forked and join unspecs are at\n+   the start of their basic blocks.  Thus afterwards each block will\n+   have a single partitioning mode.  We also do the same for return\n+   insns, as they are executed by every thread.  Return the\n+   partitioning mode of the function as a whole.  Populate MAP with\n+   head and tail blocks.  We also clear the BB visited flag, which is\n+   used when finding partitions.  */\n+\n+static void\n+omp_sese_split_blocks (bb_stmt_map_t *map)\n+{\n+  auto_vec<gimple *> worklist;\n+  basic_block block;\n+\n+  /* Locate all the reorg instructions of interest.  */\n+  FOR_ALL_BB_FN (block, cfun)\n+    {\n+      /* Clear visited flag, for use by parallel locator  */\n+      block->flags &= ~BB_VISITED;\n+\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (gimple_call_internal_p (stmt, IFN_UNIQUE))\n+\t    {\n+\t      enum ifn_unique_kind k = ((enum ifn_unique_kind)\n+\t\tTREE_INT_CST_LOW (gimple_call_arg (stmt, 0)));\n+\n+\t      if (k == IFN_UNIQUE_OACC_JOIN)\n+\t\tworklist.safe_push (stmt);\n+\t      else if (k == IFN_UNIQUE_OACC_FORK)\n+\t\t{\n+\t\t  gcc_assert (gsi_one_before_end_p (gsi));\n+\t\t  basic_block forked_block = single_succ (block);\n+\t\t  gimple_stmt_iterator gsi2 = gsi_start_bb (forked_block);\n+\n+\t\t  /* We push a NOP as a placeholder for the \"forked\" stmt.\n+\t\t     This is then recognized in omp_sese_find_par.  */\n+\t\t  gimple *nop = gimple_build_nop ();\n+\t\t  gsi_insert_before (&gsi2, nop, GSI_SAME_STMT);\n+\n+\t\t  worklist.safe_push (nop);\n+\t\t}\n+\t    }\n+\t  else if (gimple_code (stmt) == GIMPLE_RETURN\n+\t\t   || gimple_code (stmt) == GIMPLE_COND\n+\t\t   || gimple_code (stmt) == GIMPLE_SWITCH\n+\t\t   || (gimple_code (stmt) == GIMPLE_CALL\n+\t\t       && !gimple_call_internal_p (stmt)\n+\t\t       && !omp_sese_active_worker_call (as_a <gcall *> (stmt))))\n+\t    worklist.safe_push (stmt);\n+\t  else if (is_gimple_assign (stmt))\n+\t    {\n+\t      tree lhs = gimple_assign_lhs (stmt);\n+\n+\t      /* Force assignments to components/fields/elements of local\n+\t\t aggregates into fully-partitioned (redundant) mode.  This\n+\t\t avoids having to broadcast the whole aggregate.  The RHS of\n+\t\t the assignment will be propagated using the normal\n+\t\t mechanism.  */\n+\n+\t      switch (TREE_CODE (lhs))\n+\t\t{\n+\t\tcase COMPONENT_REF:\n+\t\tcase BIT_FIELD_REF:\n+\t\tcase ARRAY_REF:\n+\t\t  {\n+\t\t    tree aggr = TREE_OPERAND (lhs, 0);\n+\n+\t\t    if (local_var_based_p (aggr))\n+\t\t      worklist.safe_push (stmt);\n+\t\t  }\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  ;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Split blocks on the worklist.  */\n+  unsigned ix;\n+  gimple *stmt;\n+\n+  for (ix = 0; worklist.iterate (ix, &stmt); ix++)\n+    {\n+      basic_block block = gimple_bb (stmt);\n+\n+      if (gimple_code (stmt) == GIMPLE_COND)\n+\t{\n+\t  gcond *orig_cond = as_a <gcond *> (stmt);\n+\t  tree_code code = gimple_expr_code (orig_cond);\n+\t  tree pred = make_ssa_name (boolean_type_node);\n+\t  gimple *asgn = gimple_build_assign (pred, code,\n+\t\t\t   gimple_cond_lhs (orig_cond),\n+\t\t\t   gimple_cond_rhs (orig_cond));\n+\t  gcond *new_cond\n+\t    = gimple_build_cond (NE_EXPR, pred, boolean_false_node,\n+\t\t\t\t gimple_cond_true_label (orig_cond),\n+\t\t\t\t gimple_cond_false_label (orig_cond));\n+\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t  gsi_insert_before (&gsi, asgn, GSI_SAME_STMT);\n+\t  gsi_replace (&gsi, new_cond, true);\n+\n+\t  edge e = split_block (block, asgn);\n+\t  block = e->dest;\n+\t  map->get_or_insert (block) = new_cond;\n+\t}\n+      else if ((gimple_code (stmt) == GIMPLE_CALL\n+\t\t&& !gimple_call_internal_p (stmt))\n+\t       || is_gimple_assign (stmt))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t  gsi_prev (&gsi);\n+\n+\t  edge call = split_block (block, gsi_stmt (gsi));\n+\n+\t  gimple *call_stmt = gsi_stmt (gsi_start_bb (call->dest));\n+\n+\t  edge call_to_ret = split_block (call->dest, call_stmt);\n+\n+\t  map->get_or_insert (call_to_ret->src) = call_stmt;\n+\t}\n+      else\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t  gsi_prev (&gsi);\n+\n+\t  if (gsi_end_p (gsi))\n+\t    map->get_or_insert (block) = stmt;\n+\t  else\n+\t    {\n+\t      /* Split block before insn. The insn is in the new block.  */\n+\t      edge e = split_block (block, gsi_stmt (gsi));\n+\n+\t      block = e->dest;\n+\t      map->get_or_insert (block) = stmt;\n+\t    }\n+\t}\n+    }\n+}\n+\n+static const char *\n+mask_name (unsigned mask)\n+{\n+  switch (mask)\n+    {\n+    case 0: return \"gang redundant\";\n+    case 1: return \"gang partitioned\";\n+    case 2: return \"worker partitioned\";\n+    case 3: return \"gang+worker partitioned\";\n+    case 4: return \"vector partitioned\";\n+    case 5: return \"gang+vector partitioned\";\n+    case 6: return \"worker+vector partitioned\";\n+    case 7: return \"fully partitioned\";\n+    default: return \"<illegal>\";\n+    }\n+}\n+\n+/* Dump this parallel and all its inner parallels.  */\n+\n+static void\n+omp_sese_dump_pars (parallel_g *par, unsigned depth)\n+{\n+  fprintf (dump_file, \"%u: mask %d (%s) head=%d, tail=%d\\n\",\n+\t   depth, par->mask, mask_name (par->mask),\n+\t   par->forked_block ? par->forked_block->index : -1,\n+\t   par->join_block ? par->join_block->index : -1);\n+\n+  fprintf (dump_file, \"    blocks:\");\n+\n+  basic_block block;\n+  for (unsigned ix = 0; par->blocks.iterate (ix, &block); ix++)\n+    fprintf (dump_file, \" %d\", block->index);\n+  fprintf (dump_file, \"\\n\");\n+  if (par->inner)\n+    omp_sese_dump_pars (par->inner, depth + 1);\n+\n+  if (par->next)\n+    omp_sese_dump_pars (par->next, depth);\n+}\n+\n+/* If BLOCK contains a fork/join marker, process it to create or\n+   terminate a loop structure.  Add this block to the current loop,\n+   and then walk successor blocks.   */\n+\n+static parallel_g *\n+omp_sese_find_par (bb_stmt_map_t *map, parallel_g *par, basic_block block)\n+{\n+  if (block->flags & BB_VISITED)\n+    return par;\n+  block->flags |= BB_VISITED;\n+\n+  if (gimple **stmtp = map->get (block))\n+    {\n+      gimple *stmt = *stmtp;\n+\n+      if (gimple_code (stmt) == GIMPLE_COND\n+\t  || gimple_code (stmt) == GIMPLE_SWITCH\n+\t  || gimple_code (stmt) == GIMPLE_RETURN\n+\t  || (gimple_code (stmt) == GIMPLE_CALL\n+\t      && !gimple_call_internal_p (stmt))\n+\t  || is_gimple_assign (stmt))\n+\t{\n+\t  /* A single block that is forced to be at the maximum partition\n+\t     level.  Make a singleton par for it.  */\n+\t  par = new parallel_g (par, GOMP_DIM_MASK (GOMP_DIM_GANG)\n+\t\t\t\t   | GOMP_DIM_MASK (GOMP_DIM_WORKER)\n+\t\t\t\t   | GOMP_DIM_MASK (GOMP_DIM_VECTOR));\n+\t  par->forked_block = block;\n+\t  par->forked_stmt = stmt;\n+\t  par->blocks.safe_push (block);\n+\t  par = par->parent;\n+\t  goto walk_successors;\n+\t}\n+      else if (gimple_nop_p (stmt))\n+\t{\n+\t  basic_block pred = single_pred (block);\n+\t  gcc_assert (pred);\n+\t  gimple_stmt_iterator gsi = gsi_last_bb (pred);\n+\t  gimple *final_stmt = gsi_stmt (gsi);\n+\n+\t  if (gimple_call_internal_p (final_stmt, IFN_UNIQUE))\n+\t    {\n+\t      gcall *call = as_a <gcall *> (final_stmt);\n+\t      enum ifn_unique_kind k = ((enum ifn_unique_kind)\n+\t\tTREE_INT_CST_LOW (gimple_call_arg (call, 0)));\n+\n+\t      if (k == IFN_UNIQUE_OACC_FORK)\n+\t\t{\n+\t\t  HOST_WIDE_INT dim\n+\t\t    = TREE_INT_CST_LOW (gimple_call_arg (call, 2));\n+\t\t  unsigned mask = (dim >= 0) ? GOMP_DIM_MASK (dim) : 0;\n+\n+\t\t  par = new parallel_g (par, mask);\n+\t\t  par->forked_block = block;\n+\t\t  par->forked_stmt = final_stmt;\n+\t\t  par->fork_stmt = stmt;\n+\t\t}\n+\t      else\n+\t\tgcc_unreachable ();\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+      else if (gimple_call_internal_p (stmt, IFN_UNIQUE))\n+\t{\n+\t  gcall *call = as_a <gcall *> (stmt);\n+\t  enum ifn_unique_kind k = ((enum ifn_unique_kind)\n+\t    TREE_INT_CST_LOW (gimple_call_arg (call, 0)));\n+\t  if (k == IFN_UNIQUE_OACC_JOIN)\n+\t    {\n+\t      HOST_WIDE_INT dim = TREE_INT_CST_LOW (gimple_call_arg (stmt, 2));\n+\t      unsigned mask = (dim >= 0) ? GOMP_DIM_MASK (dim) : 0;\n+\n+\t      gcc_assert (par->mask == mask);\n+\t      par->join_block = block;\n+\t      par->join_stmt = stmt;\n+\t      par = par->parent;\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  if (par)\n+    /* Add this block onto the current loop's list of blocks.  */\n+    par->blocks.safe_push (block);\n+  else\n+    /* This must be the entry block.  Create a NULL parallel.  */\n+    par = new parallel_g (0, 0);\n+\n+walk_successors:\n+  /* Walk successor blocks.  */\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, block->succs)\n+    omp_sese_find_par (map, par, e->dest);\n+\n+  return par;\n+}\n+\n+/* DFS walk the CFG looking for fork & join markers.  Construct\n+   loop structures as we go.  MAP is a mapping of basic blocks\n+   to head & tail markers, discovered when splitting blocks.  This\n+   speeds up the discovery.  We rely on the BB visited flag having\n+   been cleared when splitting blocks.  */\n+\n+static parallel_g *\n+omp_sese_discover_pars (bb_stmt_map_t *map)\n+{\n+  basic_block block;\n+\n+  /* Mark exit blocks as visited.  */\n+  block = EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  block->flags |= BB_VISITED;\n+\n+  /* And entry block as not.  */\n+  block = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  block->flags &= ~BB_VISITED;\n+\n+  parallel_g *par = omp_sese_find_par (map, 0, block);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\nLoops\\n\");\n+      omp_sese_dump_pars (par, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  return par;\n+}\n+\n+static void\n+populate_single_mode_bitmaps (parallel_g *par, bitmap worker_single,\n+\t\t\t      bitmap vector_single, unsigned outer_mask,\n+\t\t\t      int depth)\n+{\n+  unsigned mask = outer_mask | par->mask;\n+\n+  basic_block block;\n+\n+  for (unsigned i = 0; par->blocks.iterate (i, &block); i++)\n+    {\n+      if ((mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)) == 0)\n+\tbitmap_set_bit (worker_single, block->index);\n+\n+      if ((mask & GOMP_DIM_MASK (GOMP_DIM_VECTOR)) == 0)\n+\tbitmap_set_bit (vector_single, block->index);\n+    }\n+\n+  if (par->inner)\n+    populate_single_mode_bitmaps (par->inner, worker_single, vector_single,\n+\t\t\t\t  mask, depth + 1);\n+  if (par->next)\n+    populate_single_mode_bitmaps (par->next, worker_single, vector_single,\n+\t\t\t\t  outer_mask, depth);\n+}\n+\n+/* A map from SSA names or var decls to record fields.  */\n+\n+typedef hash_map<tree, tree> field_map_t;\n+\n+/* For each propagation record type, this is a map from SSA names or var decls\n+   to propagate, to the field in the record type that should be used for\n+   transmission and reception.  */\n+\n+typedef hash_map<tree, field_map_t *> record_field_map_t;\n+\n+static GTY(()) record_field_map_t *field_map;\n+\n+static void\n+install_var_field (tree var, tree record_type)\n+{\n+  field_map_t *fields = *field_map->get (record_type);\n+  tree name;\n+  char tmp[20];\n+\n+  if (TREE_CODE (var) == SSA_NAME)\n+    {\n+      name = SSA_NAME_IDENTIFIER (var);\n+      if (!name)\n+\t{\n+\t  sprintf (tmp, \"_%u\", (unsigned) SSA_NAME_VERSION (var));\n+\t  name = get_identifier (tmp);\n+\t}\n+    }\n+  else if (TREE_CODE (var) == VAR_DECL)\n+    {\n+      name = DECL_NAME (var);\n+      if (!name)\n+\t{\n+\t  sprintf (tmp, \"D_%u\", (unsigned) DECL_UID (var));\n+\t  name = get_identifier (tmp);\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  gcc_assert (!fields->get (var));\n+\n+  tree type = TREE_TYPE (var);\n+\n+  if (POINTER_TYPE_P (type)\n+      && TYPE_RESTRICT (type))\n+    type = build_qualified_type (type, TYPE_QUALS (type) & ~TYPE_QUAL_RESTRICT);\n+\n+  tree field = build_decl (BUILTINS_LOCATION, FIELD_DECL, name, type);\n+\n+  if (TREE_CODE (var) == VAR_DECL && type == TREE_TYPE (var))\n+    {\n+      SET_DECL_ALIGN (field, DECL_ALIGN (var));\n+      DECL_USER_ALIGN (field) = DECL_USER_ALIGN (var);\n+      TREE_THIS_VOLATILE (field) = TREE_THIS_VOLATILE (var);\n+    }\n+  else\n+    SET_DECL_ALIGN (field, TYPE_ALIGN (type));\n+\n+  fields->put (var, field);\n+\n+  insert_field_into_struct (record_type, field);\n+}\n+\n+/* Sets of SSA_NAMES or VAR_DECLs to propagate.  */\n+typedef hash_set<tree> propagation_set;\n+\n+static void\n+find_ssa_names_to_propagate (parallel_g *par, unsigned outer_mask,\n+\t\t\t     bitmap worker_single, bitmap vector_single,\n+\t\t\t     vec<propagation_set *> *prop_set)\n+{\n+  unsigned mask = outer_mask | par->mask;\n+\n+  if (par->inner)\n+    find_ssa_names_to_propagate (par->inner, mask, worker_single,\n+\t\t\t\t vector_single, prop_set);\n+  if (par->next)\n+    find_ssa_names_to_propagate (par->next, outer_mask, worker_single,\n+\t\t\t\t vector_single, prop_set);\n+\n+  if (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+    {\n+      basic_block block;\n+      int ix;\n+\n+      for (ix = 0; par->blocks.iterate (ix, &block); ix++)\n+\t{\n+\t  for (gphi_iterator psi = gsi_start_phis (block);\n+\t       !gsi_end_p (psi); gsi_next (&psi))\n+\t    {\n+\t      gphi *phi = psi.phi ();\n+\t      use_operand_p use;\n+\t      ssa_op_iter iter;\n+\n+\t      FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n+\t\t{\n+\t\t  tree var = USE_FROM_PTR (use);\n+\n+\t\t  if (TREE_CODE (var) != SSA_NAME)\n+\t\t    continue;\n+\n+\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+\t\t  if (gimple_nop_p (def_stmt))\n+\t\t    continue;\n+\n+\t\t  basic_block def_bb = gimple_bb (def_stmt);\n+\n+\t\t  if (bitmap_bit_p (worker_single, def_bb->index))\n+\t\t    {\n+\t\t      if (!(*prop_set)[def_bb->index])\n+\t\t\t(*prop_set)[def_bb->index] = new propagation_set;\n+\n+\t\t      propagation_set *ws_prop = (*prop_set)[def_bb->index];\n+\n+\t\t      ws_prop->add (var);\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      use_operand_p use;\n+\t      ssa_op_iter iter;\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\n+\t      FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\t\t{\n+\t\t  tree var = USE_FROM_PTR (use);\n+\n+\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+\t\t  if (gimple_nop_p (def_stmt))\n+\t\t    continue;\n+\n+\t\t  basic_block def_bb = gimple_bb (def_stmt);\n+\n+\t\t  if (bitmap_bit_p (worker_single, def_bb->index))\n+\t\t    {\n+\t\t      if (!(*prop_set)[def_bb->index])\n+\t\t\t(*prop_set)[def_bb->index] = new propagation_set;\n+\n+\t\t      propagation_set *ws_prop = (*prop_set)[def_bb->index];\n+\n+\t\t      ws_prop->add (var);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Callback for walk_gimple_stmt to find RHS VAR_DECLs (uses) in a\n+   statement.  */\n+\n+static tree\n+find_partitioned_var_uses_1 (tree *node, int *, void *data)\n+{\n+  walk_stmt_info *wi = (walk_stmt_info *) data;\n+  hash_set<tree> *partitioned_var_uses = (hash_set<tree> *) wi->info;\n+\n+  if (!wi->is_lhs && VAR_P (*node))\n+    partitioned_var_uses->add (*node);\n+\n+  return NULL_TREE;\n+}\n+\n+static void\n+find_partitioned_var_uses (parallel_g *par, unsigned outer_mask,\n+\t\t\t   hash_set<tree> *partitioned_var_uses)\n+{\n+  unsigned mask = outer_mask | par->mask;\n+\n+  if (par->inner)\n+    find_partitioned_var_uses (par->inner, mask, partitioned_var_uses);\n+  if (par->next)\n+    find_partitioned_var_uses (par->next, outer_mask, partitioned_var_uses);\n+\n+  if (mask & GOMP_DIM_MASK (GOMP_DIM_WORKER))\n+    {\n+      basic_block block;\n+      int ix;\n+\n+      for (ix = 0; par->blocks.iterate (ix, &block); ix++)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t     !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  {\n+\t    walk_stmt_info wi;\n+\t    memset (&wi, 0, sizeof (wi));\n+\t    wi.info = (void *) partitioned_var_uses;\n+\t    walk_gimple_stmt (&gsi, NULL, find_partitioned_var_uses_1, &wi);\n+\t  }\n+    }\n+}\n+\n+/* Gang-private variables (typically placed in a GPU's shared memory) do not\n+   need to be processed by the worker-propagation mechanism.  Populate the\n+   GANG_PRIVATE_VARS set with any such variables found in the current\n+   function.  */\n+\n+static void\n+find_gang_private_vars (hash_set<tree> *gang_private_vars)\n+{\n+  basic_block block;\n+\n+  FOR_EACH_BB_FN (block, cfun)\n+    {\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t   !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\n+\t  if (gimple_call_internal_p (stmt, IFN_UNIQUE))\n+\t    {\n+\t      enum ifn_unique_kind k = ((enum ifn_unique_kind)\n+\t\tTREE_INT_CST_LOW (gimple_call_arg (stmt, 0)));\n+\t      if (k == IFN_UNIQUE_OACC_PRIVATE)\n+\t\t{\n+\t\t  HOST_WIDE_INT level\n+\t\t    = TREE_INT_CST_LOW (gimple_call_arg (stmt, 2));\n+\t\t  if (level != GOMP_DIM_GANG)\n+\t\t    continue;\n+\t\t  for (unsigned i = 3; i < gimple_call_num_args (stmt); i++)\n+\t\t    {\n+\t\t      tree arg = gimple_call_arg (stmt, i);\n+\t\t      gcc_assert (TREE_CODE (arg) == ADDR_EXPR);\n+\t\t      tree decl = TREE_OPERAND (arg, 0);\n+\t\t      gang_private_vars->add (decl);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+static void\n+find_local_vars_to_propagate (parallel_g *par, unsigned outer_mask,\n+\t\t\t      hash_set<tree> *partitioned_var_uses,\n+\t\t\t      hash_set<tree> *gang_private_vars,\n+\t\t\t      vec<propagation_set *> *prop_set)\n+{\n+  unsigned mask = outer_mask | par->mask;\n+\n+  if (par->inner)\n+    find_local_vars_to_propagate (par->inner, mask, partitioned_var_uses,\n+\t\t\t\t  gang_private_vars, prop_set);\n+  if (par->next)\n+    find_local_vars_to_propagate (par->next, outer_mask, partitioned_var_uses,\n+\t\t\t\t  gang_private_vars, prop_set);\n+\n+  if (!(mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)))\n+    {\n+      basic_block block;\n+      int ix;\n+\n+      for (ix = 0; par->blocks.iterate (ix, &block); ix++)\n+\t{\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      tree var;\n+\t      unsigned i;\n+\n+\t      FOR_EACH_LOCAL_DECL (cfun, i, var)\n+\t\t{\n+\t\t  if (!VAR_P (var)\n+\t\t      || is_global_var (var)\n+\t\t      || AGGREGATE_TYPE_P (TREE_TYPE (var))\n+\t\t      || !partitioned_var_uses->contains (var)\n+\t\t      || gang_private_vars->contains (var))\n+\t\t    continue;\n+\n+\t\t  if (stmt_may_clobber_ref_p (stmt, var))\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\t{\n+\t\t\t  fprintf (dump_file, \"bb %u: local variable may be \"\n+\t\t\t\t   \"clobbered in %s mode: \", block->index,\n+\t\t\t\t   mask_name (mask));\n+\t\t\t  print_generic_expr (dump_file, var, TDF_SLIM);\n+\t\t\t  fprintf (dump_file, \"\\n\");\n+\t\t\t}\n+\n+\t\t      if (!(*prop_set)[block->index])\n+\t\t\t(*prop_set)[block->index] = new propagation_set;\n+\n+\t\t      propagation_set *ws_prop\n+\t\t\t= (*prop_set)[block->index];\n+\n+\t\t      ws_prop->add (var);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Transform basic blocks FROM, TO (which may be the same block) into:\n+   if (GOACC_single_start ())\n+     BLOCK;\n+   GOACC_barrier ();\n+\t\t\t      \\  |  /\n+\t\t\t      +----+\n+\t\t\t      |    |        (new) predicate block\n+\t\t\t      +----+--\n+   \\  |  /   \\  |  /\t        |t    \\\n+   +----+    +----+\t      +----+  |\n+   |\t|    |    |\t===>  |    |  | f   (old) from block\n+   +----+    +----+\t      +----+  |\n+     |       t/  \\f\t        |    /\n+\t\t\t      +----+/\n+  (split  (split before       |    |        skip block\n+  at end)   condition)\t      +----+\n+\t\t\t      t/  \\f\n+*/\n+\n+static void\n+worker_single_simple (basic_block from, basic_block to,\n+\t\t      hash_set<tree> *def_escapes_block)\n+{\n+  gimple *call, *cond;\n+  tree lhs, decl;\n+  basic_block skip_block;\n+\n+  gimple_stmt_iterator gsi = gsi_last_bb (to);\n+  if (EDGE_COUNT (to->succs) > 1)\n+    {\n+      gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_COND);\n+      gsi_prev (&gsi);\n+    }\n+  edge e = split_block (to, gsi_stmt (gsi));\n+  skip_block = e->dest;\n+\n+  gimple_stmt_iterator start = gsi_after_labels (from);\n+\n+  decl = builtin_decl_explicit (BUILT_IN_GOACC_SINGLE_START);\n+  lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)));\n+  call = gimple_build_call (decl, 0);\n+  gimple_call_set_lhs (call, lhs);\n+  gsi_insert_before (&start, call, GSI_NEW_STMT);\n+  update_stmt (call);\n+\n+  cond = gimple_build_cond (EQ_EXPR, lhs,\n+\t\t\t    fold_convert_loc (UNKNOWN_LOCATION,\n+\t\t\t\t\t      TREE_TYPE (lhs),\n+\t\t\t\t\t      boolean_true_node),\n+\t\t\t    NULL_TREE, NULL_TREE);\n+  gsi_insert_after (&start, cond, GSI_NEW_STMT);\n+  update_stmt (cond);\n+\n+  edge et = split_block (from, cond);\n+  et->flags &= ~EDGE_FALLTHRU;\n+  et->flags |= EDGE_TRUE_VALUE;\n+  /* Make the active worker the more probable path so we prefer fallthrough\n+     (letting the idle workers jump around more).  */\n+  et->probability = profile_probability::likely ();\n+\n+  edge ef = make_edge (from, skip_block, EDGE_FALSE_VALUE);\n+  ef->probability = et->probability.invert ();\n+\n+  basic_block neutered = split_edge (ef);\n+  gimple_stmt_iterator neut_gsi = gsi_last_bb (neutered);\n+\n+  for (gsi = gsi_start_bb (et->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      ssa_op_iter iter;\n+      tree var;\n+\n+      FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_DEF)\n+\t{\n+\t  if (def_escapes_block->contains (var))\n+\t    {\n+\t      gphi *join_phi = create_phi_node (NULL_TREE, skip_block);\n+\t      create_new_def_for (var, join_phi,\n+\t\t\t\t  gimple_phi_result_ptr (join_phi));\n+\t      add_phi_arg (join_phi, var, e, UNKNOWN_LOCATION);\n+\n+\t      tree neutered_def = copy_ssa_name (var, NULL);\n+\t      /* We really want \"don't care\" or some value representing\n+\t\t undefined here, but optimizers will probably get rid of the\n+\t\t zero-assignments anyway.  */\n+\t      gassign *zero = gimple_build_assign (neutered_def,\n+\t\t\t\tbuild_zero_cst (TREE_TYPE (neutered_def)));\n+\n+\t      gsi_insert_after (&neut_gsi, zero, GSI_CONTINUE_LINKING);\n+\t      update_stmt (zero);\n+\n+\t      add_phi_arg (join_phi, neutered_def, single_succ_edge (neutered),\n+\t\t\t   UNKNOWN_LOCATION);\n+\t      update_stmt (join_phi);\n+\t    }\n+\t}\n+    }\n+\n+  gsi = gsi_start_bb (skip_block);\n+\n+  decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n+  gimple *acc_bar = gimple_build_call (decl, 0);\n+\n+  gsi_insert_before (&gsi, acc_bar, GSI_SAME_STMT);\n+  update_stmt (acc_bar);\n+}\n+\n+/* This is a copied and renamed omp-low.c:omp_build_component_ref.  */\n+\n+static tree\n+oacc_build_component_ref (tree obj, tree field)\n+{\n+  tree field_type = TREE_TYPE (field);\n+  tree obj_type = TREE_TYPE (obj);\n+  if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (obj_type)))\n+    field_type = build_qualified_type\n+\t\t\t(field_type,\n+\t\t\t KEEP_QUAL_ADDR_SPACE (TYPE_QUALS (obj_type)));\n+\n+  tree ret = build3 (COMPONENT_REF, field_type, obj, field, NULL);\n+  if (TREE_THIS_VOLATILE (field))\n+    TREE_THIS_VOLATILE (ret) |= 1;\n+  if (TREE_READONLY (field))\n+    TREE_READONLY (ret) |= 1;\n+  return ret;\n+}\n+\n+static tree\n+build_receiver_ref (tree record_type, tree var, tree receiver_decl)\n+{\n+  field_map_t *fields = *field_map->get (record_type);\n+  tree x = build_simple_mem_ref (receiver_decl);\n+  tree field = *fields->get (var);\n+  TREE_THIS_NOTRAP (x) = 1;\n+  x = oacc_build_component_ref (x, field);\n+  return x;\n+}\n+\n+static tree\n+build_sender_ref (tree record_type, tree var, tree sender_decl)\n+{\n+  field_map_t *fields = *field_map->get (record_type);\n+  tree field = *fields->get (var);\n+  return oacc_build_component_ref (sender_decl, field);\n+}\n+\n+static int\n+sort_by_ssa_version_or_uid (const void *p1, const void *p2)\n+{\n+  const tree t1 = *(const tree *)p1;\n+  const tree t2 = *(const tree *)p2;\n+\n+  if (TREE_CODE (t1) == SSA_NAME && TREE_CODE (t2) == SSA_NAME)\n+    return SSA_NAME_VERSION (t1) - SSA_NAME_VERSION (t2);\n+  else if (TREE_CODE (t1) == SSA_NAME && TREE_CODE (t2) != SSA_NAME)\n+    return -1;\n+  else if (TREE_CODE (t1) != SSA_NAME && TREE_CODE (t2) == SSA_NAME)\n+    return 1;\n+  else\n+    return DECL_UID (t1) - DECL_UID (t2);\n+}\n+\n+static int\n+sort_by_size_then_ssa_version_or_uid (const void *p1, const void *p2)\n+{\n+  const tree t1 = *(const tree *)p1;\n+  const tree t2 = *(const tree *)p2;\n+  unsigned HOST_WIDE_INT s1 = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (t1)));\n+  unsigned HOST_WIDE_INT s2 = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (t2)));\n+  if (s1 != s2)\n+    return s2 - s1;\n+  else\n+    return sort_by_ssa_version_or_uid (p1, p2);\n+}\n+\n+static void\n+worker_single_copy (basic_block from, basic_block to,\n+\t\t    hash_set<tree> *def_escapes_block,\n+\t\t    hash_set<tree> *worker_partitioned_uses,\n+\t\t    tree record_type)\n+{\n+  /* If we only have virtual defs, we'll have no record type, but we still want\n+     to emit single_copy_start and (particularly) single_copy_end to act as\n+     a vdef source on the neutered edge representing memory writes on the\n+     non-neutered edge.  */\n+  if (!record_type)\n+    record_type = char_type_node;\n+\n+  tree sender_decl\n+    = targetm.goacc.create_worker_broadcast_record (record_type, true,\n+\t\t\t\t\t\t    \".oacc_worker_o\");\n+  tree receiver_decl\n+    = targetm.goacc.create_worker_broadcast_record (record_type, false,\n+\t\t\t\t\t\t    \".oacc_worker_i\");\n+\n+  gimple_stmt_iterator gsi = gsi_last_bb (to);\n+  if (EDGE_COUNT (to->succs) > 1)\n+    gsi_prev (&gsi);\n+  edge e = split_block (to, gsi_stmt (gsi));\n+  basic_block barrier_block = e->dest;\n+\n+  gimple_stmt_iterator start = gsi_after_labels (from);\n+\n+  tree decl = builtin_decl_explicit (BUILT_IN_GOACC_SINGLE_COPY_START);\n+\n+  tree lhs = create_tmp_var (TREE_TYPE (TREE_TYPE (decl)));\n+\n+  gimple *call = gimple_build_call (decl, 1,\n+\t\t\t\t    build_fold_addr_expr (sender_decl));\n+  gimple_call_set_lhs (call, lhs);\n+  gsi_insert_before (&start, call, GSI_NEW_STMT);\n+  update_stmt (call);\n+\n+  tree conv_tmp = make_ssa_name (TREE_TYPE (receiver_decl));\n+\n+  gimple *conv = gimple_build_assign (conv_tmp,\n+\t\t\t\t      fold_convert (TREE_TYPE (receiver_decl),\n+\t\t\t\t\t\t    lhs));\n+  update_stmt (conv);\n+  gsi_insert_after (&start, conv, GSI_NEW_STMT);\n+  gimple *asgn = gimple_build_assign (receiver_decl, conv_tmp);\n+  gsi_insert_after (&start, asgn, GSI_NEW_STMT);\n+  update_stmt (asgn);\n+\n+  tree zero_ptr = build_int_cst (TREE_TYPE (receiver_decl), 0);\n+\n+  tree recv_tmp = make_ssa_name (TREE_TYPE (receiver_decl));\n+  asgn = gimple_build_assign (recv_tmp, receiver_decl);\n+  gsi_insert_after (&start, asgn, GSI_NEW_STMT);\n+  update_stmt (asgn);\n+\n+  gimple *cond = gimple_build_cond (EQ_EXPR, recv_tmp, zero_ptr, NULL_TREE,\n+\t\t\t\t    NULL_TREE);\n+  update_stmt (cond);\n+\n+  gsi_insert_after (&start, cond, GSI_NEW_STMT);\n+\n+  edge et = split_block (from, cond);\n+  et->flags &= ~EDGE_FALLTHRU;\n+  et->flags |= EDGE_TRUE_VALUE;\n+  /* Make the active worker the more probable path so we prefer fallthrough\n+     (letting the idle workers jump around more).  */\n+  et->probability = profile_probability::likely ();\n+\n+  basic_block body = et->dest;\n+\n+  edge ef = make_edge (from, barrier_block, EDGE_FALSE_VALUE);\n+  ef->probability = et->probability.invert ();\n+\n+  decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n+  gimple *acc_bar = gimple_build_call (decl, 0);\n+\n+  gimple_stmt_iterator bar_gsi = gsi_start_bb (barrier_block);\n+  gsi_insert_before (&bar_gsi, acc_bar, GSI_NEW_STMT);\n+\n+  cond = gimple_build_cond (NE_EXPR, recv_tmp, zero_ptr, NULL_TREE, NULL_TREE);\n+  gsi_insert_after (&bar_gsi, cond, GSI_NEW_STMT);\n+\n+  edge et2 = split_block (barrier_block, cond);\n+  et2->flags &= ~EDGE_FALLTHRU;\n+  et2->flags |= EDGE_TRUE_VALUE;\n+  et2->probability = profile_probability::unlikely ();\n+\n+  basic_block exit_block = et2->dest;\n+\n+  basic_block copyout_block = split_edge (et2);\n+  edge ef2 = make_edge (barrier_block, exit_block, EDGE_FALSE_VALUE);\n+  ef2->probability = et2->probability.invert ();\n+\n+  gimple_stmt_iterator copyout_gsi = gsi_start_bb (copyout_block);\n+\n+  edge copyout_to_exit = single_succ_edge (copyout_block);\n+\n+  gimple_seq sender_seq = NULL;\n+\n+  /* Make sure we iterate over definitions in a stable order.  */\n+  auto_vec<tree> escape_vec (def_escapes_block->elements ());\n+  for (hash_set<tree>::iterator it = def_escapes_block->begin ();\n+       it != def_escapes_block->end (); ++it)\n+    escape_vec.quick_push (*it);\n+  escape_vec.qsort (sort_by_ssa_version_or_uid);\n+\n+  for (unsigned i = 0; i < escape_vec.length (); i++)\n+    {\n+      tree var = escape_vec[i];\n+\n+      if (TREE_CODE (var) == SSA_NAME && SSA_NAME_IS_VIRTUAL_OPERAND (var))\n+\tcontinue;\n+\n+      tree barrier_def = 0;\n+\n+      if (TREE_CODE (var) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+\t  if (gimple_nop_p (def_stmt))\n+\t    continue;\n+\n+\t  /* The barrier phi takes one result from the actual work of the\n+\t     block we're neutering, and the other result is constant zero of\n+\t     the same type.  */\n+\n+\t  gphi *barrier_phi = create_phi_node (NULL_TREE, barrier_block);\n+\t  barrier_def = create_new_def_for (var, barrier_phi,\n+\t\t\t  gimple_phi_result_ptr (barrier_phi));\n+\n+\t  add_phi_arg (barrier_phi, var, e, UNKNOWN_LOCATION);\n+\t  add_phi_arg (barrier_phi, build_zero_cst (TREE_TYPE (var)), ef,\n+\t\t       UNKNOWN_LOCATION);\n+\n+\t  update_stmt (barrier_phi);\n+\t}\n+      else\n+\tgcc_assert (TREE_CODE (var) == VAR_DECL);\n+\n+      /* If we had no record type, we will have no fields map.  */\n+      field_map_t **fields_p = field_map->get (record_type);\n+      field_map_t *fields = fields_p ? *fields_p : NULL;\n+\n+      if (worker_partitioned_uses->contains (var)\n+\t  && fields\n+\t  && fields->get (var))\n+\t{\n+\t  tree neutered_def = make_ssa_name (TREE_TYPE (var));\n+\n+\t  /* Receive definition from shared memory block.  */\n+\n+\t  tree receiver_ref = build_receiver_ref (record_type, var,\n+\t\t\t\t\t\t  receiver_decl);\n+\t  gassign *recv = gimple_build_assign (neutered_def,\n+\t\t\t\t\t       receiver_ref);\n+\t  gsi_insert_after (&copyout_gsi, recv, GSI_CONTINUE_LINKING);\n+\t  update_stmt (recv);\n+\n+\t  if (TREE_CODE (var) == VAR_DECL)\n+\t    {\n+\t      /* If it's a VAR_DECL, we only copied to an SSA temporary.  Copy\n+\t\t to the final location now.  */\n+\t      gassign *asgn = gimple_build_assign (var, neutered_def);\n+\t      gsi_insert_after (&copyout_gsi, asgn, GSI_CONTINUE_LINKING);\n+\t      update_stmt (asgn);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If it's an SSA name, create a new phi at the join node to\n+\t\t represent either the output from the active worker (the\n+\t\t barrier) or the inactive workers (the copyout block).  */\n+\t      gphi *join_phi = create_phi_node (NULL_TREE, exit_block);\n+\t      create_new_def_for (barrier_def, join_phi,\n+\t\t\t\t  gimple_phi_result_ptr (join_phi));\n+\t      add_phi_arg (join_phi, barrier_def, ef2, UNKNOWN_LOCATION);\n+\t      add_phi_arg (join_phi, neutered_def, copyout_to_exit,\n+\t\t\t   UNKNOWN_LOCATION);\n+\t      update_stmt (join_phi);\n+\t    }\n+\n+\t  /* Send definition to shared memory block.  */\n+\n+\t  tree sender_ref = build_sender_ref (record_type, var, sender_decl);\n+\n+\t  if (TREE_CODE (var) == SSA_NAME)\n+\t    {\n+\t      gassign *send = gimple_build_assign (sender_ref, var);\n+\t      gimple_seq_add_stmt (&sender_seq, send);\n+\t      update_stmt (send);\n+\t    }\n+\t  else if (TREE_CODE (var) == VAR_DECL)\n+\t    {\n+\t      tree tmp = make_ssa_name (TREE_TYPE (var));\n+\t      gassign *send = gimple_build_assign (tmp, var);\n+\t      gimple_seq_add_stmt (&sender_seq, send);\n+\t      update_stmt (send);\n+\t      send = gimple_build_assign (sender_ref, tmp);\n+\t      gimple_seq_add_stmt (&sender_seq, send);\n+\t      update_stmt (send);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+\n+  /* It's possible for the ET->DEST block (the work done by the active thread)\n+     to finish with a control-flow insn, e.g. a UNIQUE function call.  Split\n+     the block and add SENDER_SEQ in the latter part to avoid having control\n+     flow in the middle of a BB.  */\n+\n+  decl = builtin_decl_explicit (BUILT_IN_GOACC_SINGLE_COPY_END);\n+  call = gimple_build_call (decl, 1, build_fold_addr_expr (sender_decl));\n+  gimple_seq_add_stmt (&sender_seq, call);\n+\n+  gsi = gsi_last_bb (body);\n+  gimple *last = gsi_stmt (gsi);\n+  basic_block sender_block = split_block (body, last)->dest;\n+  gsi = gsi_last_bb (sender_block);\n+  gsi_insert_seq_after (&gsi, sender_seq, GSI_CONTINUE_LINKING);\n+}\n+\n+static void\n+neuter_worker_single (parallel_g *par, unsigned outer_mask,\n+\t\t      bitmap worker_single, bitmap vector_single,\n+\t\t      vec<propagation_set *> *prop_set,\n+\t\t      hash_set<tree> *partitioned_var_uses)\n+{\n+  unsigned mask = outer_mask | par->mask;\n+\n+  if ((mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)) == 0)\n+    {\n+      basic_block block;\n+\n+      for (unsigned i = 0; par->blocks.iterate (i, &block); i++)\n+\t{\n+\t  bool has_defs = false;\n+\t  hash_set<tree> def_escapes_block;\n+\t  hash_set<tree> worker_partitioned_uses;\n+\t  unsigned j;\n+\t  tree var;\n+\n+\t  FOR_EACH_SSA_NAME (j, var, cfun)\n+\t    {\n+\t      if (SSA_NAME_IS_VIRTUAL_OPERAND (var))\n+\t\t{\n+\t\t  has_defs = true;\n+\t\t  continue;\n+\t\t}\n+\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+\n+\t      if (gimple_nop_p (def_stmt))\n+\t\tcontinue;\n+\n+\t      if (gimple_bb (def_stmt)->index != block->index)\n+\t\tcontinue;\n+\n+\t      gimple *use_stmt;\n+\t      imm_use_iterator use_iter;\n+\t      bool uses_outside_block = false;\n+\t      bool worker_partitioned_use = false;\n+\n+\t      FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, var)\n+\t\t{\n+\t\t  int blocknum = gimple_bb (use_stmt)->index;\n+\n+\t\t  /* Don't propagate SSA names that are only used in the\n+\t\t     current block, unless the usage is in a phi node: that\n+\t\t     means the name left the block, then came back in at the\n+\t\t     top.  */\n+\t\t  if (blocknum != block->index\n+\t\t      || gimple_code (use_stmt) == GIMPLE_PHI)\n+\t\t    uses_outside_block = true;\n+\t\t  if (!bitmap_bit_p (worker_single, blocknum))\n+\t\t    worker_partitioned_use = true;\n+\t\t}\n+\n+\t      if (uses_outside_block)\n+\t\tdef_escapes_block.add (var);\n+\n+\t      if (worker_partitioned_use)\n+\t\t{\n+\t\t  worker_partitioned_uses.add (var);\n+\t\t  has_defs = true;\n+\t\t}\n+\t    }\n+\n+\t  propagation_set *ws_prop = (*prop_set)[block->index];\n+\n+\t  if (ws_prop)\n+\t    {\n+\t      for (propagation_set::iterator it = ws_prop->begin ();\n+\t\t   it != ws_prop->end ();\n+\t\t   ++it)\n+\t\t{\n+\t\t  tree var = *it;\n+\t\t  if (TREE_CODE (var) == VAR_DECL)\n+\t\t    {\n+\t\t      def_escapes_block.add (var);\n+\t\t      if (partitioned_var_uses->contains (var))\n+\t\t\t{\n+\t\t\t  worker_partitioned_uses.add (var);\n+\t\t\t  has_defs = true;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      delete ws_prop;\n+\t      (*prop_set)[block->index] = 0;\n+\t    }\n+\n+\t  tree record_type = (tree) block->aux;\n+\n+\t  if (has_defs)\n+\t    worker_single_copy (block, block, &def_escapes_block,\n+\t\t\t\t&worker_partitioned_uses, record_type);\n+\t  else\n+\t    worker_single_simple (block, block, &def_escapes_block);\n+\t}\n+    }\n+\n+  if ((outer_mask & GOMP_DIM_MASK (GOMP_DIM_WORKER)) == 0)\n+    {\n+      basic_block block;\n+\n+      for (unsigned i = 0; par->blocks.iterate (i, &block); i++)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (block);\n+\t     !gsi_end_p (gsi);\n+\t     gsi_next (&gsi))\n+\t  {\n+\t    gimple *stmt = gsi_stmt (gsi);\n+\n+\t    if (gimple_code (stmt) == GIMPLE_CALL\n+\t\t&& !gimple_call_internal_p (stmt)\n+\t\t&& !omp_sese_active_worker_call (as_a <gcall *> (stmt)))\n+\t      {\n+\t\t/* If we have an OpenACC routine call in worker-single mode,\n+\t\t   place barriers before and afterwards to prevent\n+\t\t   clobbering re-used shared memory regions (as are used\n+\t\t   for AMDGCN at present, for example).  */\n+\t\ttree decl = builtin_decl_explicit (BUILT_IN_GOACC_BARRIER);\n+\t\tgsi_insert_before (&gsi, gimple_build_call (decl, 0),\n+\t\t\t\t   GSI_SAME_STMT);\n+\t\tgsi_insert_after (&gsi, gimple_build_call (decl, 0),\n+\t\t\t\t  GSI_NEW_STMT);\n+\t      }\n+\t  }\n+    }\n+\n+  if (par->inner)\n+    neuter_worker_single (par->inner, mask, worker_single, vector_single,\n+\t\t\t  prop_set, partitioned_var_uses);\n+  if (par->next)\n+    neuter_worker_single (par->next, outer_mask, worker_single, vector_single,\n+\t\t\t  prop_set, partitioned_var_uses);\n+}\n+\n+static int\n+execute_omp_oacc_neuter_broadcast ()\n+{\n+  bb_stmt_map_t bb_stmt_map;\n+  auto_bitmap worker_single, vector_single;\n+\n+  omp_sese_split_blocks (&bb_stmt_map);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\\nAfter splitting:\\n\\n\");\n+      dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+    }\n+\n+  unsigned mask = 0;\n+\n+  /* If this is a routine, calculate MASK as if the outer levels are already\n+     partitioned.  */\n+  tree attr = oacc_get_fn_attrib (current_function_decl);\n+  if (attr)\n+    {\n+      tree dims = TREE_VALUE (attr);\n+      unsigned ix;\n+      for (ix = 0; ix != GOMP_DIM_MAX; ix++, dims = TREE_CHAIN (dims))\n+\t{\n+\t  tree allowed = TREE_PURPOSE (dims);\n+\t  if (allowed && integer_zerop (allowed))\n+\t    mask |= GOMP_DIM_MASK (ix);\n+\t}\n+    }\n+\n+  parallel_g *par = omp_sese_discover_pars (&bb_stmt_map);\n+  populate_single_mode_bitmaps (par, worker_single, vector_single, mask, 0);\n+\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    bb->aux = NULL;\n+\n+  field_map = record_field_map_t::create_ggc (40);\n+\n+  vec<propagation_set *> prop_set;\n+  prop_set.create (last_basic_block_for_fn (cfun));\n+\n+  for (int i = 0; i < last_basic_block_for_fn (cfun); i++)\n+    prop_set.quick_push (0);\n+\n+  find_ssa_names_to_propagate (par, mask, worker_single, vector_single,\n+\t\t\t       &prop_set);\n+\n+  hash_set<tree> partitioned_var_uses;\n+  hash_set<tree> gang_private_vars;\n+\n+  find_gang_private_vars (&gang_private_vars);\n+  find_partitioned_var_uses (par, mask, &partitioned_var_uses);\n+  find_local_vars_to_propagate (par, mask, &partitioned_var_uses,\n+\t\t\t\t&gang_private_vars, &prop_set);\n+\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      propagation_set *ws_prop = prop_set[bb->index];\n+      if (ws_prop)\n+\t{\n+\t  tree record_type = lang_hooks.types.make_type (RECORD_TYPE);\n+\t  tree name = create_tmp_var_name (\".oacc_ws_data_s\");\n+\t  name = build_decl (UNKNOWN_LOCATION, TYPE_DECL, name, record_type);\n+\t  DECL_ARTIFICIAL (name) = 1;\n+\t  DECL_NAMELESS (name) = 1;\n+\t  TYPE_NAME (record_type) = name;\n+\t  TYPE_ARTIFICIAL (record_type) = 1;\n+\n+\t  auto_vec<tree> field_vec (ws_prop->elements ());\n+\t  for (hash_set<tree>::iterator it = ws_prop->begin ();\n+\t       it != ws_prop->end (); ++it)\n+\t    field_vec.quick_push (*it);\n+\n+\t  field_vec.qsort (sort_by_size_then_ssa_version_or_uid);\n+\n+\t  field_map->put (record_type, field_map_t::create_ggc (17));\n+\n+\t  /* Insert var fields in reverse order, so the last inserted element\n+\t     is the first in the structure.  */\n+\t  for (int i = field_vec.length () - 1; i >= 0; i--)\n+\t    install_var_field (field_vec[i], record_type);\n+\n+\t  layout_type (record_type);\n+\n+\t  bb->aux = (tree) record_type;\n+\t}\n+    }\n+\n+  neuter_worker_single (par, mask, worker_single, vector_single, &prop_set,\n+\t\t\t&partitioned_var_uses);\n+\n+  prop_set.release ();\n+\n+  /* This doesn't seem to make a difference.  */\n+  loops_state_clear (LOOP_CLOSED_SSA);\n+\n+  /* Neutering worker-single neutered blocks will invalidate dominance info.\n+     It may be possible to incrementally update just the affected blocks, but\n+     obliterate everything for now.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\\nAfter neutering:\\n\\n\");\n+      dump_function_to_file (current_function_decl, dump_file, dump_flags);\n+    }\n+\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_omp_oacc_neuter_broadcast =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"omp_oacc_neuter_broadcast\", /* name */\n+  OPTGROUP_OMP, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_cfg, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa | TODO_cleanup_cfg, /* todo_flags_finish */\n+};\n+\n+class pass_omp_oacc_neuter_broadcast : public gimple_opt_pass\n+{\n+public:\n+  pass_omp_oacc_neuter_broadcast (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_omp_oacc_neuter_broadcast, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+  {\n+    return (flag_openacc\n+\t    && targetm.goacc.create_worker_broadcast_record);\n+  };\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return execute_omp_oacc_neuter_broadcast ();\n+    }\n+\n+}; // class pass_omp_oacc_neuter_broadcast\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_omp_oacc_neuter_broadcast (gcc::context *ctxt)\n+{\n+  return new pass_omp_oacc_neuter_broadcast (ctxt);\n+}"}, {"sha": "d7a1f8c97a676ff7f6e2dcaa009698a167044bf0", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -184,6 +184,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_fixup_cfg);\n   NEXT_PASS (pass_lower_eh_dispatch);\n   NEXT_PASS (pass_oacc_loop_designation);\n+  NEXT_PASS (pass_omp_oacc_neuter_broadcast);\n   NEXT_PASS (pass_oacc_device_lower);\n   NEXT_PASS (pass_omp_device_lower);\n   NEXT_PASS (pass_omp_target_link);"}, {"sha": "7676d5e626e372f00b537a4053ed1919d5f00f17", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -1756,6 +1756,17 @@ private variables at OpenACC device-lowering time using the\\n\\\n rtx, (tree var),\n NULL)\n \n+DEFHOOK\n+(create_worker_broadcast_record,\n+\"Create a record used to propagate local-variable state from an active\\n\\\n+worker to other workers.  A possible implementation might adjust the type\\n\\\n+of REC to place the new variable in shared GPU memory.\\n\\\n+\\n\\\n+Presence of this target hook indicates that middle end neutering/broadcasting\\n\\\n+be used.\",\n+tree, (tree rec, bool sender, const char *name),\n+NULL)\n+\n HOOK_VECTOR_END (goacc)\n \n /* Functions relating to vectorization.  */"}, {"sha": "83941bc0ceef0470b0df1a194dd4ab7e3b0b6d9e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2a58ed6dc5293602d0d168475109caa81ad0f0d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e2a58ed6dc5293602d0d168475109caa81ad0f0d", "patch": "@@ -425,6 +425,7 @@ extern gimple_opt_pass *make_pass_expand_omp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_expand_omp_ssa (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_omp_target_link (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_oacc_loop_designation (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_omp_oacc_neuter_broadcast (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_oacc_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_omp_device_lower (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);"}]}