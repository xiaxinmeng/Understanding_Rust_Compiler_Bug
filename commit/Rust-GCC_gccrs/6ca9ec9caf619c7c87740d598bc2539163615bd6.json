{"sha": "6ca9ec9caf619c7c87740d598bc2539163615bd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNhOWVjOWNhZjYxOWM3Yzg3NzQwZDU5OGJjMjUzOTE2MzYxNWJkNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T13:44:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-21T13:44:29Z"}, "message": "[multiple changes]\n\n2010-06-21  Robert Dewar  <dewar@adacore.com>\n\n\t* s-regpat.adb, s-tpoben.adb, sem_attr.adb, sem_util.adb, sem_util.ads,\n\tchecks.adb, sem_res.adb: Minor reformatting. Add comments.\n\n2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (New_Overloaded_Entity): If the new entity is a\n\trederivation associated with a full declaration in a private part, and\n\tthere is a partial view that derives the same parent subprogram, the\n\tnew entity does not become visible. This check must be applied to\n\tinterface operations as well.\n\nFrom-SVN: r161078", "tree": {"sha": "a120df388601052fb824b36969ea9c3d0636442c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a120df388601052fb824b36969ea9c3d0636442c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ca9ec9caf619c7c87740d598bc2539163615bd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca9ec9caf619c7c87740d598bc2539163615bd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca9ec9caf619c7c87740d598bc2539163615bd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca9ec9caf619c7c87740d598bc2539163615bd6/comments", "author": null, "committer": null, "parents": [{"sha": "a548f9ffabe114aa611bf69c6dfdb5afce20bbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a548f9ffabe114aa611bf69c6dfdb5afce20bbd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a548f9ffabe114aa611bf69c6dfdb5afce20bbd1"}], "stats": {"total": 215, "additions": 141, "deletions": 74}, "files": [{"sha": "0392b7344c23796cf823de151d16039d4fc3e111", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -1,3 +1,16 @@\n+2010-06-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-regpat.adb, s-tpoben.adb, sem_attr.adb, sem_util.adb, sem_util.ads,\n+\tchecks.adb, sem_res.adb: Minor reformatting. Add comments.\n+\n+2010-06-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (New_Overloaded_Entity): If the new entity is a\n+\trederivation associated with a full declaration in a private part, and\n+\tthere is a partial view that derives the same parent subprogram, the\n+\tnew entity does not become visible. This check must be applied to\n+\tinterface operations as well.\n+\n 2010-06-21  Thomas Quinot  <quinot@adacore.com>\n \n \t* checks.adb: Add comments."}, {"sha": "b6b1df415b31a04e30e05fadfed696cbf16b7e10", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -6256,6 +6256,7 @@ package body Checks is\n       --  Returns an attribute reference\n       --    E'First or E'Last\n       --  with a source location of Loc.\n+      --\n       --  Nam is Name_First or Name_Last, according to which attribute is\n       --  desired. If Indx is non-zero, it is passed as a literal in the\n       --  Expressions of the attribute reference (identifying the desired"}, {"sha": "8dc079ed24439ae75af620ac9431838a1ba52ec1", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 96, "deletions": 65, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -48,7 +48,9 @@ with Ada.Unchecked_Conversion;\n package body System.Regpat is\n \n    Debug : constant Boolean := False;\n-   --  Set to True to activate debug traces\n+   --  Set to True to activate debug traces. This is normally set to constant\n+   --  False to simply delete all the trace code. It is to be edited to True\n+   --  for internal debugging of the package.\n \n    ----------------------------\n    -- Implementation details --\n@@ -312,16 +314,16 @@ package body System.Regpat is\n       Till     : Pointer;\n       Indent   : Natural;\n       Do_Print : Boolean := True);\n-   --  Dump the program until the node Till (not included) is met.\n-   --  Every line is indented with Index spaces at the beginning\n-   --  Dumps till the end if Till is 0.\n+   --  Dump the program until the node Till (not included) is met. Every line\n+   --  is indented with Index spaces at the beginning Dumps till the end if\n+   --  Till is 0.\n \n    procedure Dump_Operation\n       (Program      : Program_Data;\n        Index        : Pointer;\n        Indent       : Natural);\n    --  Same as above, but only dumps a single operation, and compute its\n-   --  indentation from the program\n+   --  indentation from the program.\n \n    ---------\n    -- \"=\" --\n@@ -425,19 +427,19 @@ package body System.Regpat is\n         (Expr_Flags : out Expression_Flags;\n          IP         : out Pointer);\n       --  Parse_Atom is the lowest level parse procedure.\n-      --  Optimization:  gobbles an entire sequence of ordinary characters\n-      --  so that it can turn them into a single node, which is smaller to\n-      --  store and faster to run. Backslashed characters are exceptions,\n-      --  each becoming a separate node; the code is simpler that way and\n-      --  it's not worth fixing.\n+      --\n+      --  Optimization: Gobbles an entire sequence of ordinary characters so\n+      --  that it can turn them into a single node, which is smaller to store\n+      --  and faster to run. Backslashed characters are exceptions, each\n+      --  becoming a separate node; the code is simpler that way and it's\n+      --  not worth fixing.\n \n       procedure Insert_Operator\n         (Op       : Opcode;\n          Operand  : Pointer;\n          Greedy   : Boolean := True);\n-      --  Insert_Operator inserts an operator in front of an\n-      --  already-emitted operand and relocates the operand.\n-      --  This applies to PLUS and STAR.\n+      --  Insert_Operator inserts an operator in front of an already-emitted\n+      --  operand and relocates the operand. This applies to PLUS and STAR.\n       --  If Minmod is True, then the operator is non-greedy.\n \n       function Insert_Operator_Before\n@@ -446,10 +448,9 @@ package body System.Regpat is\n          Greedy  : Boolean;\n          Opsize  : Pointer) return Pointer;\n       --  Insert an operator before Operand (and move the latter forward in the\n-      --  program). Opsize is the size needed to represent the operator.\n-      --  This returns the position at which the operator was\n-      --  inserted, and moves Emit_Ptr after the new position of the\n-      --  operand.\n+      --  program). Opsize is the size needed to represent the operator. This\n+      --  returns the position at which the operator was inserted, and moves\n+      --  Emit_Ptr after the new position of the operand.\n \n       procedure Insert_Curly_Operator\n         (Op      : Opcode;\n@@ -543,6 +544,11 @@ package body System.Regpat is\n            (Character_Class, Program31);\n \n       begin\n+         --  What is the mysterious constant 31 here??? Can't it be expressed\n+         --  symbolically (size of integer - 1 or some such???). In any case\n+         --  it should be declared as a constant (and referenced presumably\n+         --  as this constant + 1 below.\n+\n          if Emit_Ptr + 31 <= PM.Size then\n             Program (Emit_Ptr .. Emit_Ptr + 31) := Convert (Bitmap);\n          end if;\n@@ -814,22 +820,21 @@ package body System.Regpat is\n       -- Parse --\n       -----------\n \n-      --  Combining parenthesis handling with the base level\n-      --  of regular expression is a trifle forced, but the\n-      --  need to tie the tails of the branches to what follows\n-      --  makes it hard to avoid.\n+      --  Combining parenthesis handling with the base level of regular\n+      --  expression is a trifle forced, but the need to tie the tails of the\n+      --  the branches to what follows makes it hard to avoid.\n \n       procedure Parse\n-        (Parenthesized  : Boolean;\n-         Flags          : out Expression_Flags;\n-         IP             : out Pointer)\n+         (Parenthesized  : Boolean;\n+          Flags          : out Expression_Flags;\n+          IP             : out Pointer)\n       is\n-         E              : String renames Expression;\n-         Br, Br2        : Pointer;\n-         Ender          : Pointer;\n-         Par_No         : Natural;\n-         New_Flags      : Expression_Flags;\n-         Have_Branch    : Boolean := False;\n+         E           : String renames Expression;\n+         Br, Br2     : Pointer;\n+         Ender       : Pointer;\n+         Par_No      : Natural;\n+         New_Flags   : Expression_Flags;\n+         Have_Branch : Boolean := False;\n \n       begin\n          Flags := (Has_Width => True, others => False);  -- Tentatively\n@@ -1982,10 +1987,11 @@ package body System.Regpat is\n      (Expression : String;\n       Flags      : Regexp_Flags := No_Flags) return Pattern_Matcher\n    is\n-      --  Assume the compiled regexp will fit in 1000 chars. If it does not\n-      --  we will have to compile a second time once the correct size is\n-      --  known. If it fits, we save a significant amount of time by avoiding\n-      --  the second compilation.\n+      --  Assume the compiled regexp will fit in 1000 chars. If it does not we\n+      --  will have to compile a second time once the correct size is known. If\n+      --  it fits, we save a significant amount of time by avoiding the second\n+      --  compilation.\n+\n       Dummy : Pattern_Matcher (1000);\n       Size  : Program_Size;\n \n@@ -2021,8 +2027,10 @@ package body System.Regpat is\n       Flags      : Regexp_Flags := No_Flags)\n    is\n       Size : Program_Size;\n+\n    begin\n       Compile (Matcher, Expression, Size, Flags);\n+\n       if Size > Matcher.Size then\n          raise Expression_Error with \"Pattern_Matcher is too small\";\n       end if;\n@@ -2033,9 +2041,9 @@ package body System.Regpat is\n    --------------------\n \n    procedure Dump_Operation\n-      (Program      : Program_Data;\n-       Index        : Pointer;\n-       Indent       : Natural)\n+      (Program : Program_Data;\n+       Index   : Pointer;\n+       Indent  : Natural)\n    is\n       Current : Pointer := Index;\n    begin\n@@ -2056,6 +2064,10 @@ package body System.Regpat is\n       function Image (S : String) return String;\n       --  Remove leading space\n \n+      -----------\n+      -- Image --\n+      -----------\n+\n       function Image (S : String) return String is\n       begin\n          if S (S'First) = ' ' then\n@@ -2065,11 +2077,15 @@ package body System.Regpat is\n          end if;\n       end Image;\n \n-      Op      : Opcode;\n-      Next    : Pointer;\n-      Length  : Pointer;\n+      --  Local variables\n+\n+      Op           : Opcode;\n+      Next         : Pointer;\n+      Length       : Pointer;\n       Local_Indent : Natural := Indent;\n \n+   --  Start of processing for Dump_Until\n+\n    begin\n       while Index < Till loop\n          Op   := Opcode'Val (Character'Pos ((Program (Index))));\n@@ -2087,8 +2103,8 @@ package body System.Regpat is\n             --  Print the parenthesis number\n \n             if Op = OPEN or else Op = CLOSE or else Op = REFF then\n-               Put\n-                 (Image (Natural'Image (Character'Pos (Program (Index + 3)))));\n+               Put (Image (Natural'Image\n+                            (Character'Pos (Program (Index + 3)))));\n             end if;\n \n             if Next = Index then\n@@ -2101,9 +2117,9 @@ package body System.Regpat is\n          case Op is\n             when ANYOF =>\n                declare\n-                  Bitmap  : Character_Class;\n-                  Last    : Character := ASCII.NUL;\n-                  Current : Natural := 0;\n+                  Bitmap       : Character_Class;\n+                  Last         : Character := ASCII.NUL;\n+                  Current      : Natural := 0;\n                   Current_Char : Character;\n \n                begin\n@@ -2155,8 +2171,8 @@ package body System.Regpat is\n                Length := String_Length (Program, Index);\n                if Do_Print then\n                   Put (\" (\" & Image (Program_Size'Image (Length + 1))\n-                         & \" chars) <\"\n-                         & String (Program (String_Operand (Index)\n+                          & \" chars) <\"\n+                          & String (Program (String_Operand (Index)\n                                               .. String_Operand (Index)\n                                               + Length)));\n                   Put_Line (\">\");\n@@ -2440,12 +2456,13 @@ package body System.Regpat is\n       -------------------\n \n       function Recurse_Match (IP : Pointer; From : Natural) return Boolean is\n-         L : constant Natural := Last_Paren;\n+         L     : constant Natural := Last_Paren;\n          Tmp_F : constant Match_Array :=\n                    Matches_Full (From + 1 .. Matches_Full'Last);\n          Start : constant Natural_Array :=\n                    Matches_Tmp (From + 1 .. Matches_Tmp'Last);\n          Input : constant Natural := Input_Pos;\n+\n          Dump_Indent_Save : constant Integer := Dump_Indent;\n \n       begin\n@@ -2467,7 +2484,8 @@ package body System.Regpat is\n \n       procedure Dump_Current (Scan : Pointer; Prefix : Boolean := True) is\n          Length : constant := 10;\n-         Pos : constant String := Integer'Image (Input_Pos);\n+         Pos    : constant String := Integer'Image (Input_Pos);\n+\n       begin\n          if Prefix then\n             Put ((1 .. 5 - Pos'Length => ' '));\n@@ -2476,9 +2494,11 @@ package body System.Regpat is\n                      .. Integer'Min (Last_In_Data, Input_Pos + Length - 1)));\n             Put ((1 .. Length - 1 - Last_In_Data + Input_Pos => ' '));\n             Put (\"> |\");\n+\n          else\n             Put (\"                    \");\n          end if;\n+\n          Dump_Operation (Program, Scan, Indent => Dump_Indent);\n       end Dump_Current;\n \n@@ -2514,8 +2534,8 @@ package body System.Regpat is\n \n             Op := Opcode'Val (Character'Pos (Program (Scan)));\n \n-            --  Calculate offset of next instruction.\n-            --  Second character is most significant in Program_Data.\n+            --  Calculate offset of next instruction. Second character is most\n+            --  significant in Program_Data.\n \n             Next := Get_Next (Program, Scan);\n \n@@ -2552,7 +2572,7 @@ package body System.Regpat is\n                when BOL =>\n                   exit State_Machine when Input_Pos /= BOL_Pos\n                     and then ((Self.Flags and Multiple_Lines) = 0\n-                      or else Data (Input_Pos - 1) /= ASCII.LF);\n+                               or else Data (Input_Pos - 1) /= ASCII.LF);\n \n                when MBOL =>\n                   exit State_Machine when Input_Pos /= BOL_Pos\n@@ -2564,7 +2584,7 @@ package body System.Regpat is\n                when EOL =>\n                   exit State_Machine when Input_Pos <= Data'Last\n                     and then ((Self.Flags and Multiple_Lines) = 0\n-                              or else Data (Input_Pos) /= ASCII.LF);\n+                               or else Data (Input_Pos) /= ASCII.LF);\n \n                when MEOL =>\n                   exit State_Machine when Input_Pos <= Data'Last\n@@ -2645,7 +2665,6 @@ package body System.Regpat is\n                   declare\n                      Opnd    : Pointer  := String_Operand (Scan);\n                      Current : Positive := Input_Pos;\n-\n                      Last    : constant Pointer :=\n                                  Opnd + String_Length (Program, Scan);\n \n@@ -2722,9 +2741,11 @@ package body System.Regpat is\n \n                      if Last_Paren < No then\n                         Dump_Indent := Dump_Indent - 1;\n+\n                         if Debug then\n                            Dump_Error (\"REFF: No match, backtracking\");\n                         end if;\n+\n                         return False;\n                      end if;\n \n@@ -2735,9 +2756,11 @@ package body System.Regpat is\n                           or else Data (Input_Pos) /= Data (Data_Pos)\n                         then\n                            Dump_Indent := Dump_Indent - 1;\n+\n                            if Debug then\n                               Dump_Error (\"REFF: No match, backtracking\");\n                            end if;\n+\n                            return False;\n                         end if;\n \n@@ -2796,20 +2819,24 @@ package body System.Regpat is\n \n                      Current_Curly := Cc.Old_Cc;\n                      Dump_Indent := Dump_Indent - 1;\n+\n                      if not Has_Match then\n                         if Debug then\n                            Dump_Error (\"CURLYX failed...\");\n                         end if;\n                      end if;\n+\n                      return Has_Match;\n                   end;\n \n                when WHILEM =>\n                   Result := Match_Whilem;\n                   Dump_Indent := Dump_Indent - 1;\n+\n                   if Debug and then not Result then\n                      Dump_Error (\"WHILEM: no match, backtracking\");\n                   end if;\n+\n                   return Result;\n             end case;\n \n@@ -2821,8 +2848,8 @@ package body System.Regpat is\n             Dump_Indent := Dump_Indent - 1;\n          end if;\n \n-         --  If we get here, there is no match.\n-         --  For successful matches when EOP is the terminating point.\n+         --  If we get here, there is no match. For successful matches when EOP\n+         --  is the terminating point.\n \n          return False;\n       end Match;\n@@ -2848,8 +2875,8 @@ package body System.Regpat is\n          Save            : constant Natural := Input_Pos;\n \n       begin\n-         --  Lookahead to avoid useless match attempts\n-         --  when we know what character comes next.\n+         --  Lookahead to avoid useless match attempts when we know what\n+         --  character comes next.\n \n          if Program (Next) = EXACT then\n             Next_Char := Program (String_Operand (Next));\n@@ -2885,10 +2912,12 @@ package body System.Regpat is\n \n             if Min /= 0 then\n                No := Repeat (Operand_Code, Min);\n+\n                if No < Min then\n                   if Debug then\n                      Dump_Error (\"failed... matched\" & No'Img & \" times\");\n                   end if;\n+\n                   return False;\n                end if;\n             end if;\n@@ -2898,6 +2927,7 @@ package body System.Regpat is\n             --  Find the place where 'next' could work\n \n             if Next_Char_Known then\n+\n                --  Last position to check\n \n                if Max = Natural'Last then\n@@ -2929,8 +2959,8 @@ package body System.Regpat is\n                      return False;\n                   end if;\n \n-                  --  Check that we still match if we stop\n-                  --  at the position we just found.\n+                  --  Check that we still match if we stop at the position we\n+                  --  just found.\n \n                   declare\n                      Num : constant Natural := Input_Pos - Old;\n@@ -2982,6 +3012,7 @@ package body System.Regpat is\n                      if Debug then\n                         Dump_Error (\"Non-greedy repeat failed...\");\n                      end if;\n+\n                      return False;\n                   end if;\n                end loop;\n@@ -2998,12 +3029,11 @@ package body System.Regpat is\n                Dump_Error (\"failed... matched\" & No'Img & \" times\");\n             end if;\n \n-            --  ??? Perl has some special code here in case the\n-            --  next instruction is of type EOL, since $ and \\Z\n-            --  can match before *and* after newline at the end.\n+            --  ??? Perl has some special code here in case the next\n+            --  instruction is of type EOL, since $ and \\Z can match before\n+            --  *and* after newline at the end.\n \n-            --  ??? Perl has some special code here in case (paren)\n-            --  is True.\n+            --  ??? Perl has some special code here in case (paren) is True\n \n             --  Else, if we don't have any parenthesis\n \n@@ -3039,6 +3069,7 @@ package body System.Regpat is\n \n       function Match_Whilem return Boolean is\n          Cc : constant Current_Curly_Access := Current_Curly;\n+\n          N  : constant Natural              := Cc.Cur + 1;\n          Ln : Natural                       := 0;\n "}, {"sha": "d27e5281cb54585ac13defd4163120d0f8bc0da1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -4906,17 +4906,18 @@ package body Sem_Attr is\n       -----------------------------------\n \n       procedure Check_Concurrent_Discriminant (Bound : Node_Id) is\n-         Tsk  : Entity_Id;\n+         Tsk : Entity_Id;\n          --  The concurrent (task or protected) type\n+\n       begin\n          if Nkind (Bound) = N_Identifier\n            and then Ekind (Entity (Bound)) = E_Discriminant\n            and then Is_Concurrent_Record_Type (Scope (Entity (Bound)))\n          then\n             Tsk := Corresponding_Concurrent_Type (Scope (Entity (Bound)));\n-            if In_Open_Scopes (Tsk)\n-                 and then Has_Completion (Tsk)\n-            then\n+\n+            if In_Open_Scopes (Tsk) and then Has_Completion (Tsk) then\n+\n                --  Find discriminant of original concurrent type, and use\n                --  its current discriminal, which is the renaming within\n                --  the task/protected body.\n@@ -6015,6 +6016,7 @@ package body Sem_Attr is\n             else\n                Fold_Uint  (N, Expr_Value (Lo_Bound), Static);\n             end if;\n+\n          else\n             Check_Concurrent_Discriminant (Lo_Bound);\n          end if;\n@@ -6205,6 +6207,7 @@ package body Sem_Attr is\n             else\n                Fold_Uint  (N, Expr_Value (Hi_Bound), Static);\n             end if;\n+\n          else\n             Check_Concurrent_Discriminant (Hi_Bound);\n          end if;"}, {"sha": "171cb0a267ed99e42f83c836cdc0c6b2b989fa62", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -7526,17 +7526,28 @@ package body Sem_Ch6 is\n       --  E exists and is overloadable\n \n       else\n-         --  Ada 2005 (AI-251): Derivation of abstract interface primitives\n-         --  need no check against the homonym chain. They are directly added\n-         --  to the list of primitive operations of Derived_Type.\n+         --  Ada 2005 (AI-251): Derivation of abstract interface primitives.\n+         --  They are directly added to the list of primitive operations of\n+         --  Derived_Type, unless this is a rederivation in the private part\n+         --  of an operation that was already derived in the visible part of\n+         --  the current package.\n \n          if Ada_Version >= Ada_05\n            and then Present (Derived_Type)\n            and then Is_Dispatching_Operation (Alias (S))\n            and then Present (Find_Dispatching_Type (Alias (S)))\n            and then Is_Interface (Find_Dispatching_Type (Alias (S)))\n          then\n-            goto Add_New_Entity;\n+            if Type_Conformant (E, S)\n+              and then Is_Package_Or_Generic_Package (Current_Scope)\n+              and then In_Private_Part (Current_Scope)\n+              and then Parent (E) /= Parent (S)\n+              and then Alias (E) = Alias (S)\n+            then\n+               Check_Operation_From_Private_View (S, E);\n+            else\n+               goto Add_New_Entity;\n+            end if;\n          end if;\n \n          Check_Synchronized_Overriding (S, Overridden_Subp);"}, {"sha": "03ab23f077d83ffa84db3d587d248ab77a34aaf3", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -5929,6 +5929,12 @@ package body Sem_Res is\n               and then In_Open_Scopes (Tsk)\n               and then Nkind (Parent (Entry_Name)) = N_Requeue_Statement\n             then\n+               --  Note: here Bound denotes a discriminant of the corresponding\n+               --  record type tskV, whose discriminal is a formal of the\n+               --  init-proc tskVIP. What we want is the body discriminal,\n+               --  which is associated to the discriminant of the original\n+               --  concurrent type tsk.\n+\n                return New_Occurrence_Of\n                         (Find_Body_Discriminal (Entity (Bound)), Loc);\n "}, {"sha": "583135eee54bda263eed519a600aeeb2ea6a9db8", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -3070,9 +3070,11 @@ package body Sem_Util is\n      (Spec_Discriminant : Entity_Id) return Entity_Id\n    is\n       pragma Assert (Is_Concurrent_Record_Type (Scope (Spec_Discriminant)));\n+\n       Tsk  : constant Entity_Id :=\n                Corresponding_Concurrent_Type (Scope (Spec_Discriminant));\n       Disc : Entity_Id;\n+\n    begin\n       --  Find discriminant of original concurrent type, and use its current\n       --  discriminal, which is the renaming within the task/protected body."}, {"sha": "08d128424560c15e56815d16620866e40ba86219", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ca9ec9caf619c7c87740d598bc2539163615bd6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=6ca9ec9caf619c7c87740d598bc2539163615bd6", "patch": "@@ -331,7 +331,7 @@ package Sem_Util is\n       Typ  : Entity_Id) return Entity_Id;\n    --  Because discriminants may have different names in a generic unit and in\n    --  an instance, they are resolved positionally when possible. A reference\n-   --  to a discriminant carries the discriminant that it denotes when\n+   --  to a discriminant carries the discriminant that it denotes when it is\n    --  analyzed. Subsequent uses of this id on a different type denotes the\n    --  discriminant at the same position in this new type.\n "}]}