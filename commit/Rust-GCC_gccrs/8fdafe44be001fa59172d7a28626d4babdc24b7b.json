{"sha": "8fdafe44be001fa59172d7a28626d4babdc24b7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkYWZlNDRiZTAwMWZhNTkxNzJkN2EyODYyNmQ0YmFiZGMyNGI3Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:39:57Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:39:57Z"}, "message": "[multiple changes]\n\n2014-01-27  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.adb: Minor reformatting.\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* opt.adb (SPARK_Mode): Default for library units is None rather\n\tthan Off.\n\t* opt.ads: Remove AUTO from SPARK_Mode_Type SPARK_Mode_Type is\n\tno longer ordered.\n\t* sem_prag.adb (Analyze_Pragma, case SPARK_Mode): Remove AUTO\n\tpossibility.\n\t* snames.ads-tmpl (Name_Auto): Removed, no longer used.\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch5.adb (P_Sequence_Of_Statements): Make entry in\n\tSuspicious_Labels table if we have identifier; followed by loop\n\tor block.\n\t* par-endh.adb (Evaluate_End_Entry): Search Suspicious_Labels table.\n\t* par.adb (Suspicious_Labels): New table.\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_aggr.adb (Check_Bounds): Reason is range check, not\n\tlength check.\n\n2014-01-27  Yannick Moy  <moy@adacore.com>\n\n\t* get_spark_xrefs.adb (Get_SPARK_Xrefs): Accept new type 'c' for\n\treference.\n\t* lib-xref-spark_specific.adb (Is_Global_Constant): Remove useless\n\tfunction now.\n\t(Add_SPARK_Xrefs): Include references to constants.\n\t* spark_xrefs.ads Document new character 'c' for references to\n\tconstants.\n\n2014-01-27  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_smem.adb (Add_Write_After): For a function call, insert write as\n\tan after action in a transient scope.\n\nFrom-SVN: r207140", "tree": {"sha": "691222cccf636cf338d10501185fedb34354d5fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/691222cccf636cf338d10501185fedb34354d5fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fdafe44be001fa59172d7a28626d4babdc24b7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdafe44be001fa59172d7a28626d4babdc24b7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fdafe44be001fa59172d7a28626d4babdc24b7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdafe44be001fa59172d7a28626d4babdc24b7b/comments", "author": null, "committer": null, "parents": [{"sha": "b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a699930b7b61d37753e8714929cd2d9c1fb6d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a699930b7b61d37753e8714929cd2d9c1fb6d8"}], "stats": {"total": 313, "additions": 223, "deletions": 90}, "files": [{"sha": "f50f691737683709cbf027ed3a3b850dae6578d7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -1,3 +1,45 @@\n+2014-01-27  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch7.adb: Minor reformatting.\n+\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* opt.adb (SPARK_Mode): Default for library units is None rather\n+\tthan Off.\n+\t* opt.ads: Remove AUTO from SPARK_Mode_Type SPARK_Mode_Type is\n+\tno longer ordered.\n+\t* sem_prag.adb (Analyze_Pragma, case SPARK_Mode): Remove AUTO\n+\tpossibility.\n+\t* snames.ads-tmpl (Name_Auto): Removed, no longer used.\n+\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch5.adb (P_Sequence_Of_Statements): Make entry in\n+\tSuspicious_Labels table if we have identifier; followed by loop\n+\tor block.\n+\t* par-endh.adb (Evaluate_End_Entry): Search Suspicious_Labels table.\n+\t* par.adb (Suspicious_Labels): New table.\n+\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_aggr.adb (Check_Bounds): Reason is range check, not\n+\tlength check.\n+\n+2014-01-27  Yannick Moy  <moy@adacore.com>\n+\n+\t* get_spark_xrefs.adb (Get_SPARK_Xrefs): Accept new type 'c' for\n+\treference.\n+\t* lib-xref-spark_specific.adb (Is_Global_Constant): Remove useless\n+\tfunction now.\n+\t(Add_SPARK_Xrefs): Include references to constants.\n+\t* spark_xrefs.ads Document new character 'c' for references to\n+\tconstants.\n+\n+2014-01-27  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_smem.adb (Add_Write_After): For a function call, insert write as\n+\tan after action in a transient scope.\n+\n 2014-01-27  Thomas Quinot  <quinot@adacore.com>\n \n \t* exp_smem.adb (Expand_Shared_Passive_Variable): For a reference"}, {"sha": "6518e5bb9505da4c0d04cdb7c97206d4df484009", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -4141,7 +4141,7 @@ package body Exp_Aggr is\n             Insert_Action (N,\n               Make_Raise_Constraint_Error (Loc,\n                 Condition => Cond,\n-                Reason    => CE_Length_Check_Failed));\n+                Reason    => CE_Range_Check_Failed));\n          end if;\n       end Check_Bounds;\n "}, {"sha": "ed3dc4c93fd25e26ddaee150f8daf60ec3fdc06a", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -3612,7 +3612,7 @@ package body Exp_Ch7 is\n    --  This procedure is called each time a transient block has to be inserted\n    --  that is to say for each call to a function with unconstrained or tagged\n    --  result. It creates a new scope on the stack scope in order to enclose\n-   --  all transient variables generated\n+   --  all transient variables generated.\n \n    procedure Establish_Transient_Scope (N : Node_Id; Sec_Stack : Boolean) is\n       Loc       : constant Source_Ptr := Sloc (N);"}, {"sha": "7fb40c44aae1a554b7cd5a9d7bcf9c017b59ca22", "filename": "gcc/ada/exp_smem.adb", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fexp_smem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fexp_smem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_smem.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -25,6 +25,7 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -58,8 +59,10 @@ package body Exp_Smem is\n    procedure Add_Write_After (N : Node_Id);\n    --  Insert a Shared_Var_WOpen call for variable after the node Insert_Node,\n    --  as recorded by On_Lhs_Of_Assignment (where it points to the assignment\n-   --  statement) or Is_Out_Actual (where it points to the procedure call\n-   --  statement).\n+   --  statement) or Is_Out_Actual (where it points to the subprogram call).\n+   --  When Insert_Node is a function call, establish a transient scope around\n+   --  the expression, and insert the write as an after-action of the transient\n+   --  scope.\n \n    procedure Build_Full_Name (E : Entity_Id; N : out String_Id);\n    --  Build the fully qualified string name of a shared variable\n@@ -191,12 +194,18 @@ package body Exp_Smem is\n \n    procedure Add_Write_After (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n-      Ent : constant Node_Id    := Entity (N);\n-\n+      Ent : constant Entity_Id  := Entity (N);\n+      Par : constant Node_Id := Insert_Node;\n    begin\n       if Present (Shared_Var_Procs_Instance (Ent)) then\n-         Insert_After_And_Analyze (Insert_Node,\n-           Build_Shared_Var_Proc_Call (Loc, Ent, Name_Write));\n+         if Nkind (Insert_Node) = N_Function_Call then\n+            Establish_Transient_Scope (Insert_Node, Sec_Stack => False);\n+            Store_After_Actions_In_Scope (New_List (\n+              Build_Shared_Var_Proc_Call (Loc, Ent, Name_Write)));\n+         else\n+            Insert_After_And_Analyze (Par,\n+              Build_Shared_Var_Proc_Call (Loc, Ent, Name_Write));\n+         end if;\n       end if;\n    end Add_Write_After;\n "}, {"sha": "ea1f1b45a0baa5ab3e74185b80bd67958d2a9737", "filename": "gcc/ada/get_spark_xrefs.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fget_spark_xrefs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fget_spark_xrefs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_spark_xrefs.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -455,6 +455,7 @@ begin\n \n                            pragma Assert\n                              (Rtype = 'r' or else\n+                              Rtype = 'c' or else\n                               Rtype = 'm' or else\n                               Rtype = 's');\n "}, {"sha": "0b32aada218b97f51ccb86418b0959cde2458103", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -334,10 +334,6 @@ package body SPARK_Specific is\n          S : Scope_Index) return Boolean;\n       --  Check whether entity E is in SPARK_Scope_Table at index S or higher\n \n-      function Is_Global_Constant (E : Entity_Id) return Boolean;\n-      --  Return True if E is a global constant for which we should ignore\n-      --  reads in SPARK.\n-\n       function Lt (Op1 : Natural; Op2 : Natural) return Boolean;\n       --  Comparison function for Sort call\n \n@@ -440,14 +436,6 @@ package body SPARK_Specific is\n          if Ekind (E) in Overloadable_Kind then\n             return Typ = 's';\n \n-         --  References to constant objects are not considered in SPARK\n-         --  section, as these will be translated as constants in the\n-         --  intermediate language for formal verification, and should\n-         --  therefore never appear in frame conditions.\n-\n-         elsif Is_Constant_Object (E) then\n-            return False;\n-\n          --  Objects of Task type or protected type are not SPARK references\n \n          elsif Present (Etype (E))\n@@ -526,16 +514,6 @@ package body SPARK_Specific is\n          return False;\n       end Is_Future_Scope_Entity;\n \n-      ------------------------\n-      -- Is_Global_Constant --\n-      ------------------------\n-\n-      function Is_Global_Constant (E : Entity_Id) return Boolean is\n-      begin\n-         return Ekind (E) = E_Constant\n-           and then Ekind_In (Scope (E), E_Package, E_Package_Body);\n-      end Is_Global_Constant;\n-\n       --------\n       -- Lt --\n       --------\n@@ -726,7 +704,6 @@ package body SPARK_Specific is\n               and then SPARK_References (Ref.Typ)\n               and then Is_SPARK_Scope (Ref.Ent_Scope)\n               and then Is_SPARK_Scope (Ref.Ref_Scope)\n-              and then not Is_Global_Constant (Ref.Ent)\n               and then Is_SPARK_Reference (Ref.Ent, Ref.Typ)\n \n               --  Discard references from unknown scopes, e.g. generic scopes\n@@ -805,6 +782,7 @@ package body SPARK_Specific is\n          declare\n             Ref_Entry : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n             Ref       : Xref_Key   renames Ref_Entry.Key;\n+            Typ       : Character;\n \n          begin\n             --  If this assertion fails, the scope which we are looking for is\n@@ -844,6 +822,17 @@ package body SPARK_Specific is\n                Col  := Int (Get_Column_Number (Ref_Entry.Def));\n             end if;\n \n+            --  References to constant objects are considered specially in\n+            --  SPARK section, because these will be translated as constants in\n+            --  the intermediate language for formal verification, and should\n+            --  therefore never appear in frame conditions.\n+\n+            if Is_Constant_Object (Ref.Ent) then\n+               Typ := 'c';\n+            else\n+               Typ := Ref.Typ;\n+            end if;\n+\n             SPARK_Xref_Table.Append (\n               (Entity_Name => Ref_Name,\n                Entity_Line => Line,\n@@ -852,7 +841,7 @@ package body SPARK_Specific is\n                File_Num    => Dependency_Num (Ref.Lun),\n                Scope_Num   => Get_Scope_Num (Ref.Ref_Scope),\n                Line        => Int (Get_Logical_Line_Number (Ref.Loc)),\n-               Rtype       => Ref.Typ,\n+               Rtype       => Typ,\n                Col         => Int (Get_Column_Number (Ref.Loc))));\n          end;\n       end loop;"}, {"sha": "30623ea5720fca5f553a4b501aa6fa3941a83955", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -186,7 +186,7 @@ package body Opt is\n             Assertions_Enabled       := False;\n             Assume_No_Invalid_Values := False;\n             Check_Policy_List        := Empty;\n-            SPARK_Mode               := Off;\n+            SPARK_Mode               := None;\n             SPARK_Mode_Pragma        := Empty;\n          end if;\n "}, {"sha": "344caaf63976fc6b4a4a9170e1bee01685f2a239", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -1264,9 +1264,9 @@ package Opt is\n    --  GNAT\n    --  Set True if a pragma Short_Descriptors applies to the current unit.\n \n-   type SPARK_Mode_Type is (None, Off, Auto, On);\n-   pragma Ordered (SPARK_Mode_Type);\n-   --  Possible legal modes that can be set by aspect/pragma SPARK_Mode\n+   type SPARK_Mode_Type is (None, Off, On);\n+   --  Possible legal modes that can be set by aspect/pragma SPARK_Mode, as\n+   --  well as the value None, which indicates no such pragma/aspect applies.\n \n    SPARK_Mode : SPARK_Mode_Type := None;\n    --  GNAT"}, {"sha": "8992f15a5a76d40dfa8653c2fa9199d1e55abcab", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -506,6 +506,24 @@ package body Ch5 is\n                      Scan; -- past semicolon\n                      Statement_Required := False;\n \n+                     --  Here is the special test for a suspicious label, more\n+                     --  accurately a suspicious name, which we think perhaps\n+                     --  should have been a label. If next token is one of\n+                     --  LOOP, FOR, WHILE, DECLARE, BEGIN, then make an entry\n+                     --  in the suspicious label table.\n+\n+                     if Token = Tok_Loop    or else\n+                        Token = Tok_For     or else\n+                        Token = Tok_While   or else\n+                        Token = Tok_Declare or else\n+                        Token = Tok_Begin\n+                     then\n+                        Suspicious_Labels.Append\n+                          ((Proc_Call     => Id_Node,\n+                            Semicolon_Loc => Prev_Token_Ptr,\n+                            Start_Token   => Token_Ptr));\n+                     end if;\n+\n                   --  Check for case of \"go to\" in place of \"goto\"\n \n                   elsif Token = Tok_Identifier"}, {"sha": "e41e7a31ba463b495a6457242689daf55a3470b6", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -711,17 +711,67 @@ package body Endh is\n    ------------------------\n \n    procedure Evaluate_End_Entry (SS_Index : Nat) is\n+      STE : Scope_Table_Entry renames Scope.Table (SS_Index);\n+\n    begin\n-      Column_OK := (End_Column = Scope.Table (SS_Index).Ecol);\n+      Column_OK := (End_Column = STE.Ecol);\n \n-      Token_OK  := (End_Type = Scope.Table (SS_Index).Etyp or else\n-                     (End_Type = E_Name and then\n-                       Scope.Table (SS_Index).Etyp >= E_Name));\n+      Token_OK  := (End_Type = STE.Etyp\n+                     or else (End_Type = E_Name and then STE.Etyp >= E_Name));\n \n       Label_OK := End_Labl_Present\n-                    and then\n-                      (Same_Label (End_Labl, Scope.Table (SS_Index).Labl)\n-                        or else Scope.Table (SS_Index).Labl = Error);\n+                    and then (Same_Label (End_Labl, STE.Labl)\n+                               or else STE.Labl = Error);\n+\n+      --  Special case to consider. Suppose we have the suspicious label case,\n+      --  e.g. a situation like:\n+\n+      --    My_Label;\n+      --    declare\n+      --       ...\n+      --    begin\n+      --       ...\n+      --    end My_Label;\n+\n+      --  This is the case where we want to use the entry in the suspicous\n+      --  label table to flag the semicolon saying it should be a colon.\n+\n+      --  Label_OK will be false because the label does not match (we have\n+      --  My_Label on the end line, and the generated name for the scope). Also\n+      --  End_Labl_Present will be True.\n+\n+      if not Label_OK\n+        and then End_Labl_Present\n+        and then not Comes_From_Source (Scope.Table (SS_Index).Labl)\n+      then\n+         --  Here is where we will search the suspicious labels table\n+\n+         for J in 1 .. Suspicious_Labels.Last loop\n+            declare\n+               SLE : Suspicious_Label_Entry renames\n+                       Suspicious_Labels.Table (J);\n+            begin\n+               --  See if character name of label matches\n+\n+               if Chars (Name (SLE.Proc_Call)) = Chars (End_Labl)\n+\n+                 --  And first token of loop/block identifies this entry\n+\n+                 and then SLE.Start_Token = STE.Sloc\n+               then\n+                  --  We have the special case, issue the error message\n+\n+                  Error_Msg -- CODEFIX\n+                    (\"\"\";\"\" should be \"\":\"\"\", SLE.Semicolon_Loc);\n+\n+                  --  And indicate we consider the Label OK after all\n+\n+                  Label_OK := True;\n+                  exit;\n+               end if;\n+            end;\n+         end loop;\n+      end if;\n \n       --  Compute setting of Syntax_OK. We definitely have a syntax error\n       --  if the Token does not match properly or if P_End_Scan detected"}, {"sha": "7e69166ddc05e3162836b673b112286590663ed8", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -535,6 +535,66 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n      Table_Increment      => 100,\n      Table_Name           => \"Scope\");\n \n+   ------------------------------------------\n+   -- Table for Handling Suspicious Labels --\n+   ------------------------------------------\n+\n+   --  This is a special data structure which is used to deal very spefifically\n+   --  with the following error case\n+\n+   --     label;\n+   --     loop\n+   --       ...\n+   --     end loop label;\n+\n+   --  Similar cases apply to FOR, WHILE, DECLARE, or BEGIN\n+\n+   --  In each case the opening line looks like a procedure call because of\n+   --  the semicolon. And the end line looks illegal because of an unexpected\n+   --  label. If we did nothing special, we would just diagnose the label on\n+   --  the end as unexpected. But that does not help point to the real error\n+   --  which is that the semicolon after label should be a colon.\n+\n+   --  To deal with this, we build an entry in the Suspicious_Labels table\n+   --  whenever we encounter an identifier followed by a semicolon, followed\n+   --  by one of LOOP, FOR, WHILE, DECLARE, BEGIN. Then this entry is used to\n+   --  issue the right message when we hit the END that confirms that this was\n+   --  a bad label.\n+\n+   type Suspicious_Label_Entry is record\n+      Proc_Call : Node_Id;\n+      --  Node for the procedure call statement built for the label; construct\n+\n+      Semicolon_Loc : Source_Ptr;\n+      --  Location of the possibly wrong semicolon\n+\n+      Start_Token : Source_Ptr;\n+      --  Source location of the LOOP, FOR, WHILE, DECLARE, BEGIN token\n+   end record;\n+\n+   package Suspicious_Labels is new Table.Table (\n+     Table_Component_Type => Suspicious_Label_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 50,\n+     Table_Increment      => 100,\n+     Table_Name           => \"Suspicious_Labels\");\n+\n+   --  Now when we are about to issue a message complaining about an END label\n+   --  that should not be there because it appears to end a construct that has\n+   --  no label, we first search the suspicious labels table entry, using the\n+   --  source location stored in the scope table as a key. If we find a match,\n+   --  then we check that the label on the end matches the name in the call,\n+   --  and if so, we issue a message saying the semicolon should be a colon.\n+\n+   --  Quite a bit of work, but really helpful in the case where it helps, and\n+   --  the need for this is based on actual experience with tracking down this\n+   --  kind of error (the eye often easily mistakes semicolon for colon!)\n+\n+   --  Note: we actually have enough information to patch up the tree, but\n+   --  this may not be worth the effort! Also we could deal with the same\n+   --  situation for EXIT with a label, but for now don't bother with that!\n+\n    ---------------------------------\n    -- Parsing Routines by Chapter --\n    ---------------------------------"}, {"sha": "1d0c96fe4d5431e9c298234169e8b32b21aa1f60", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -18587,7 +18587,7 @@ package body Sem_Prag is\n          -- SPARK_Mode --\n          ----------------\n \n-         --  pragma SPARK_Mode [(On | Off | Auto)];\n+         --  pragma SPARK_Mode [(On | Off)];\n \n          when Pragma_SPARK_Mode => Do_SPARK_Mode : declare\n             Body_Id : Entity_Id;\n@@ -18609,9 +18609,6 @@ package body Sem_Prag is\n             procedure Check_Library_Level_Entity (E : Entity_Id);\n             --  Verify that pragma is applied to library-level entity E\n \n-            function Get_SPARK_Mode_Name (Id : SPARK_Mode_Type) return Name_Id;\n-            --  Convert a value of type SPARK_Mode_Type to corresponding name\n-\n             ------------------------------\n             -- Check_Pragma_Conformance --\n             ------------------------------\n@@ -18623,15 +18620,13 @@ package body Sem_Prag is\n \n                   --  New mode less restrictive than the established mode\n \n-                  if Get_SPARK_Mode_From_Pragma (Old_Pragma) < Mode_Id then\n-                     Error_Msg_Name_1 := Mode;\n-                     Error_Msg_N (\"cannot define 'S'P'A'R'K mode %\", Arg1);\n-\n-                     Error_Msg_Name_1 := Get_SPARK_Mode_Name (SPARK_Mode);\n-                     Error_Msg_Sloc   := Sloc (SPARK_Mode_Pragma);\n+                  if Get_SPARK_Mode_From_Pragma (Old_Pragma) = Off\n+                    and then Mode_Id = On\n+                  then\n                      Error_Msg_N\n-                       (\"\\mode is less restrictive than mode \"\n-                        & \"% defined #\", Arg1);\n+                       (\"cannot change 'S'P'A'R'K_Mode from Off to On\", Arg1);\n+                     Error_Msg_Sloc := Sloc (SPARK_Mode_Pragma);\n+                     Error_Msg_N (\"\\'S'P'A'R'K_Mode was set to Off#\", Arg1);\n                      raise Pragma_Exit;\n                   end if;\n                end if;\n@@ -18665,28 +18660,6 @@ package body Sem_Prag is\n                end if;\n             end Check_Library_Level_Entity;\n \n-            -------------------------\n-            -- Get_SPARK_Mode_Name --\n-            -------------------------\n-\n-            function Get_SPARK_Mode_Name\n-              (Id : SPARK_Mode_Type) return Name_Id\n-            is\n-            begin\n-               if Id = On then\n-                  return Name_On;\n-               elsif Id = Off then\n-                  return Name_Off;\n-               elsif Id = Auto then\n-                  return Name_Auto;\n-\n-               --  Mode \"None\" should never be used in error message generation\n-\n-               else\n-                  raise Program_Error;\n-               end if;\n-            end Get_SPARK_Mode_Name;\n-\n          --  Start of processing for Do_SPARK_Mode\n \n          begin\n@@ -18697,7 +18670,7 @@ package body Sem_Prag is\n             --  Check the legality of the mode (no argument = ON)\n \n             if Arg_Count = 1 then\n-               Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off, Name_Auto);\n+               Check_Arg_Is_One_Of (Arg1, Name_On, Name_Off);\n                Mode := Chars (Get_Pragma_Arg (Arg1));\n             else\n                Mode := Name_On;\n@@ -18732,14 +18705,6 @@ package body Sem_Prag is\n             --  The pragma applies to a [library unit] subprogram or package\n \n             else\n-               --  Mode \"Auto\" can only be used in a configuration pragma\n-\n-               if Mode_Id = Auto then\n-                  Error_Pragma_Arg\n-                    (\"mode `Auto` is only allowed when pragma % appears as \"\n-                     & \"a configuration pragma\", Arg1);\n-               end if;\n-\n                --  Verify the placement of the pragma with respect to package\n                --  or subprogram declarations and detect duplicates.\n \n@@ -23513,8 +23478,6 @@ package body Sem_Prag is\n          return On;\n       elsif N = Name_Off then\n          return Off;\n-      elsif N = Name_Auto then\n-         return Auto;\n \n       --  Any other argument is erroneous\n "}, {"sha": "a018dc9aaa0a155e09a4ba75bbeefb362e540cc1", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -688,7 +688,6 @@ package Snames is\n    Name_Assertion                      : constant Name_Id := N + $;\n    Name_Assertions                     : constant Name_Id := N + $;\n    Name_Attribute_Name                 : constant Name_Id := N + $;\n-   Name_Auto                           : constant Name_Id := N + $;\n    Name_Body_File_Name                 : constant Name_Id := N + $;\n    Name_Boolean_Entry_Barriers         : constant Name_Id := N + $;\n    Name_By_Any                         : constant Name_Id := N + $;"}, {"sha": "b17d7996c6cd25642d8629a08e7d5b0da17e33f7", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdafe44be001fa59172d7a28626d4babdc24b7b/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=8fdafe44be001fa59172d7a28626d4babdc24b7b", "patch": "@@ -177,6 +177,7 @@ package SPARK_Xrefs is\n \n    --        m = modification\n    --        r = reference\n+   --        c = reference to constant object\n    --        s = subprogram reference in a static call\n \n    --  Special entries for reads and writes to memory reference a special\n@@ -229,6 +230,7 @@ package SPARK_Xrefs is\n       Rtype : Character;\n       --  Indicates type of reference, using code used in ALI file:\n       --    r = reference\n+      --    c = reference to constant object\n       --    m = modification\n       --    s = call\n "}]}