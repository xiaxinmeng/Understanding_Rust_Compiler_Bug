{"sha": "5be014d5b728cf754020b8ab4df1cd029f69922e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJlMDE0ZDViNzI4Y2Y3NTQwMjBiOGFiNGRmMWNkMDI5ZjY5OTIyZQ==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2007-06-16T05:42:36Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2007-06-16T05:42:36Z"}, "message": "[multiple changes]\n\n2007-06-15  Andrew Pinski <andrew_pinski@playstation.sony.com>\n            Zdenek Dvorak <dvorakz@suse.cz>\n            Richard Guenther  <rguenther@suse.de>\n            Kaz Kojima  <kkojima@gcc.gnu.org>\n\n\t* tree-vrp.c (compare_values_warnv): Convert val2 to\n\tthe type of val1.\n\t(extract_range_from_assert): Create\n\tPOINTER_PLUS_EXPR for pointer types.\n\t(extract_range_from_binary_expr): Handle\n\tonly POINTER_PLUS_EXPR, MIN_EXPR, and MAX_EXPR\n\tfor pointer types.\n\t* doc/c-tree.texi (POINTER_PLUS_EXPR): Document.\n\t* tree-ssa-loop-niter.c (split_to_var_and_offset): Handle\n\tPOINTER_PLUS_EXPR as PLUS_EXPR.\n\t(number_of_iterations_lt_to_ne):\n\tFor pointer types, use sizetype when\n\tcreating MINUS_EXPR/PLUS_EXPRs.\n\t(assert_loop_rolls_lt): For pointer types, use sizetype when\n\tcreating MINUS_EXPR/PLUS_EXPRs.\n\t(number_of_iterations_le): Likewise.\n\t(expand_simple_operations): POINTER_PLUS_EXPR are simple also.\n\t(derive_constant_upper_bound): Handle POINTER_PLUS_EXPR just\n\tlike PLUS_EXPR and MINUS_EXPR.\n\t* tree-pretty-print.c (dump_generic_node): Handle\n\tPOINTER_PLUS_EXPR.\n\t(op_prio): Likewise.\n\t(op_symbol_1): Likewise.\n\t* optabs.c (optab_for_tree_code): Likewise.\n\t* tree-ssa-loop-manip.c (create_iv): Handle pointer base\n\tspecially.\n\t* tree-tailcall.c (process_assignment): Mention\n\tPOINTER_PLUS_EXPR in a TODO comment.\n\t* tree.c (build2_stat): Assert when trying to use PLUS_EXPR or \n\tMINUS_EXPR with a pointer. Also assert for POINTER_PLUS_EXPR\n\tnot used with a pointer and an integer type.\n\t* tree-scalar-evolution.c (add_to_evolution_1): Convert the\n\tincrement using chrec_convert_rhs instead of chrec_convert.\n\t(follow_ssa_edge_in_rhs): Handle POINTER_PLUS_EXPR like\n\tPLUS_EXPR except for the right hand side's type will be\n\tsizetype.\n\t(interpret_rhs_modify_stmt): Handle POINTER_PLUS_EXPR.\n\t(fold_used_pointer_cast): Kill.\n\t(pointer_offset_p): Kill.\n\t(fold_used_pointer): Kill.\n\t(pointer_used_p): Kill.\n\t(analyze_scalar_evolution_1 <case GIMPLE_MODIFY_STMT>): Don't\n\tcall fold_used_pointer.\n\t(instantiate_parameters_1): Convert the increment\n\tusing chrec_convert_rhs instead of chrec_convert.\n\tHandle POINTER_PLUS_EXPR as PLUS_EXPR.\n\t* builtins.c (get_pointer_alignment): Handle POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR.\n\t(expand_builtin_strcat): Create a POINTER_PLUS_EXPR instead of\n\tPLUS_EXPR for pointers.\n\t(std_gimplify_va_arg_expr): Likewise.\n\t(fold_builtin_memory_op): Likewise.\n\t(fold_builtin_strstr): Likewise.\n\t(fold_builtin_strchr): Likewise.\n\t(fold_builtin_strrchr): Likewise.\n\t(fold_builtin_strpbrk): Likewise.\n\t(expand_builtin_memory_chk): Likewise.\n\t(fold_builtin_memory_chk): Likewise.\n\t(std_expand_builtin_va_start): Use\n\tsizetype for the call to make_tree and then convert\n\tto the pointer type.\n\t(fold_builtin_memchr): Use POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for adding to a pointer.\n\t(std_gimplify_va_arg_expr): Use fold_build2 for\n\tthe creating of POINTER_PLUS_EXPR.  For the BIT_AND_EXPR, cast\n\tthe operands to sizetype first and then cast the BIT_AND_EXPR\n\tback to the pointer type.\n\t* fold-const.c (build_range_check): Handle pointer types\n\tspecially.\n\t(extract_array_ref): Look for POINTER_PLUS_EXPR instead\n\tof PLUS_EXPR's. Make sure the offset is converted to\n\tsizetype.\n\t(try_move_mult_to_index): Strip the NOPs from the offset.\n\tRemove code argument and replace all uses with PLUS_EXPR.\n\t(fold_to_nonsharp_ineq_using_bound): Handle pointer types\n\tspecially. Don't use a pointer type for MINUS_EXPR.\n\t(fold_unary): Handle for (T1)(X op Y),\n\tonly p+ as that is the only as that can be handled for\n\tbinary operators now.\n\t(fold_binary <case POINTER_PLUS_EXPR>): Add folding of\n\tPOINTER_PLUS_EXPR.\n\t<case PLUS_EXPR>: Add folding of PTR+INT into\n\tPTR p+ INT.\n\tDon't call try_move_mult_to_index.\n\t<case MINUS_EXPR>: Fold (PTR0 p+ A) - (PTR1 p+ B)\n\tinto (PTR0 - PTR1) + (A - B). Fold (PTR0 p+ A) - PTR1 into\n\t(PTR0 - PTR1) + A iff (PTR0 - PTR1) simplifies.\n\tDon't call try_move_mult_to_index.\n\t(tree_expr_nonnegative_warnv_p): Handle POINTER_PLUS_EXPR.\n\t(tree_expr_nonzero_p): Likewise.\n\t(fold_indirect_ref_1): Look at POINTER_PLUS_EXPR instead\n\tof PLUS_EXPR for the complex expression folding.\n\t* tree-chrec.c (chrec_fold_plus_poly_poly): If the\n\tfirst chrec is a pointer type, then the second should\n\tbe sizetype and not the first's type.\n\tFor POINTER_PLUS_EXPR, use a different right hand side type.\n\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n\t(chrec_fold_plus_1): For POINTER_PLUS_EXPR, use a\n\tdifferent right hand side type.\n\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n\t(chrec_fold_plus): For pointer types, use POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR.\n\tWhen either operand is zero, convert the other operand.\n\t(chrec_apply): Use chrec_convert_rhs\n\ton the argument x instead of chrec_convert.\n\t(reset_evolution_in_loop): For pointer types, the new_evol\n\tshould be sizetype.\n\t(convert_affine_scev): For POINTER_PLUS_EXPR, use a\n\tdifferent right hand side type.\n\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n\t(chrec_convert_rhs): New function.\n\t(chrec_convert_aggressive): For POINTER_PLUS_EXPR, use a\n\tdifferent right hand side type.\n\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n\t* tree-chrec.h (chrec_convert_rhs): New prototype.\n\t(build_polynomial_chrec): For pointer types, the right hand\n\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Look for\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR's.\n\tRemove subtraction case as it is always addition now.\n\tMake sure the offset is converted to sizetype.\n\t(fold_stmt_r): Don't handle PLUS_EXPR/MINUS_EXPR specially.\n\tHandle POINTER_PLUS_EXPR like PLUS_EXPR was handled before.\n\t* tree-ssa-loop-ivopts.c (determine_base_object): Abort for \n\tPLUS_EXPR in pointer type.\n\tHandle POINTER_PLUS_EXPR.\n\t(tree_to_aff_combination): Likewise.\n\t(force_expr_to_var_cost): Likewise.\n\t(force_expr_to_var_cost): Likewise. Create a POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for pointers.\n\t* c-format.c (check_format_arg): Handle POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR of pointer types.\n\t* tree-stdarg.c (va_list_counter_bump): Handle POINTER_PLUS_EXPR\n\tas PLUS_EXPR.\n\t(check_va_list_escapes): Likewise.\n\t(check_all_va_list_escapes): Likewise.\n\t* dwarf2out.c (loc_descriptor_from_tree_1):\n\tHandle POINT_PLUS_EXPR as a PLUS_EXPR.\n\t* expr.c (expand_expr_real_1): Handle POINTER_PLUS_EXPR.\n\t(string_constant): Likewise.\n\t* tree-ssa-address.c (tree_mem_ref_addr): When adding\n\tthe offset to the base, use POINTER_PLUS_EXPR.\n\t(add_to_parts): Convert the index to sizetype.\n\t(create_mem_ref): Create A POINTER_PLUS_EXPR for the one case.\n\t* matrix-reorg.c (collect_data_for_malloc_call): Stmt\n\twill now only be either INDIRECT_REF and POINTER_PLUS_EXPR.\n\tOffset only holds something for PLUS_EXPR.\n\t(ssa_accessed_in_tree): Handle POINTER_PLUS_EXPR just as\n\ta PLUS_EXPR.\n\t(analyze_transpose): POINTER_PLUS_EXPR will only show up now\n\tand not PLUS_EXPR.\n\t(analyze_accesses_for_modify_stmt): Likewise.\n\tRemove comment about the type being integral type as it is\n\twrong now.\n\t(can_calculate_expr_before_stmt): Handle POINTER_PLUS_EXPR as\n\tPLUS_EXPR.\n\t(transform_access_sites): POINTER_PLUS_EXPR will only show up now\n\tand not PLUS_EXPR.\n\tCorrect the type which the artimentic is done in (is now\n\tsizetype).\n\tReindent one loop.\n\t* tree-data-ref.c (split_constant_offset): Handle\n\tPOINTER_PLUS_EXPR\n\t* tree-affine.c (tree_to_aff_combination): Likewise.\n\t* c-typeck.c (build_unary_op): For pointers create the increment\n\tas a sizetype. Create a POINTER_PLUS_EXPR instead of PLUS_EXPR\n\tfor pointers.\n\t* gimplify.c (gimplify_self_mod_expr): Create a\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n\t(gimplify_omp_atomic_fetch_op): Handle POINTER_PLUS_EXPR.\n\t* tree.def (POINTER_PLUS_EXPR): New tree code.\n\t* tree-predcom.c (ref_at_iteration): If we have a pointer\n\ttype do the multiplication in sizetype.\n\t* tree-mudflap.c (mf_xform_derefs_1): Create a\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n\t* tree-ssa-forwprop.c \n\t(forward_propagate_addr_into_variable_array_index):\n\tDon't expect there to be a cast for the index as that\n\tdoes not exist anymore.\n\t(forward_propagate_addr_expr_1): Check for POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR.\n\tDon't check for the first operand of the POINTER_PLUS_EXPR\n\twas the index as it cannot be.\n\tCall forward_propagate_addr_into_variable_array_index with\n\tthe SSA_NAME instead of the statement.\n\t* varasm.c (const_hash_1): Handle POINTER_PLUS_EXPR.\n\t(compare_constant): Likewise.\n\t(copy_constant): Likewise.\n\t(compute_reloc_for_constant): Likewise.\n\t(output_addressed_constants): Likewise.\n\t(initializer_constant_valid_p): Likewise.\n\t* tree-ssa.c (tree_ssa_useless_type_conversion_1):\n\tConvert the MIN/MAX of the inner type to the outer\n\ttype before comparing them.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref):  Handle\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.\n\t(issue_prefetch_ref): Create a POINTER_PLUS_EXPR instead\n\tof PLUS_EXPR for pointers.\n\t* tree-inline.c (estimate_num_insns_1): Handle\n\tPOINTER_PLUS_EXPR.\n\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref): \n\tCreate a POINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n\t(bump_vector_ptr): Create a POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for the pointer increment statement.\n\t(vect_update_ivs_after_vectorizer): For pointer types, create\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR and also create\n\tMULT_EXPR in sizetype.\n\t(vect_gen_niters_for_prolog_loop): Add a cast when creating\n\tbyte_misalign.\n\t* tree-object-size.c (plus_expr_object_size): Handle\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.  Removing all the extra\n\tcode which is trying to figure out which side is a pointer and \n\tis the index.\n\t(check_for_plus_in_loops_1): Likewise.\n\t(check_for_plus_in_loops): Likewise.\n\t* c-common.c (pointer_int_sum): Create a\n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n\t* tree-ssa-structalias.c (handle_ptr_arith): Handle\n\tonly POINTER_PLUS_EXPR.  Removing all the extra\n\tcode which is trying to figure out which side is a pointer and \n\tis the index.\n\t* tree-cfg.c (verify_expr): Add extra checking for pointers and\n\tPLUS_EXPR and MINUS_EXPR.\n\tAlso add checking to make sure the operands of POINTER_PLUS_EXPR\n\tare correct.\n\t* config/frv/frv.c (frv_expand_builtin_va_start): Use sizetype\n\twith make_tree, instead of a pointer type.\n\t* config/s390/s390.c (s390_va_start): Use POINTER_PLUS_EXPR\n\tfor pointers instead of PLUS_EXPR.\n\t(s390_gimplify_va_arg): Likewise.\n\t* config/spu/spu.c (spu_va_start): Create POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR when doing addition on pointer\n\ttypes.  Use sizetype for the second operand.\n\t(spu_gimplify_va_arg_expr): Likewise.\n\t* config/sparc/sparc.c (sparc_gimplify_va_arg): Use \n\tPOINTER_PLUS_EXPR instead of PLUS_EXPR when the operand was\n\ta pointer.  Don't create a BIT_AND_EXPR for pointer types.\n\t* config/i386/i386.c (ix86_va_start): Use POINTER_PLUS_EXPR\n\tfor the pointer addition and also use size_int/sizetype\n\tfor the offset.\n\t(ix86_gimplify_va_arg): Likewise.\n\tPerform BIT_AND_EXPR on sizetype arguments.\n\t* config/sh/sh.c (sh_va_start): Call make_tree with sizetype\n\tand convert its result to a pointer type.  Use POINTER_PLUS_EXPR\n\tfor the pointer additions and also use size_int for the offsets.\n\t(sh_gimplify_va_arg_expr): Use POINTER_PLUS_EXPR for the pointer\n\tadditions and also use size_int for the offsets.  Perform\n\tBIT_AND_EXPR on sizetype arguments.\n\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Use\n\tPOINTER_PLUS_EXPR for pointers and create the\n\tBIT_AND_EXPR in sizetype.\n\t* config/rs6000/rs6000.c (rs6000_va_start): Use POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for pointer addition.\n\t(rs6000_va_start): Likewise.\n\tAlso use sizetype for the offset.\n\t* config/pa/pa.c (reloc_needed): Handle POINTER_PLUS_EXPR\n\tas PLUS_EXPR/MINUS_EXPR.\n\t(hppa_gimplify_va_arg_expr): Don't create MINUS_EXPR or\n\tPLUS_EXPR for pointers, instead use POINTER_PLUS_EXPR.\n\tDon't use BIT_AND_EXPR on a pointer type, convert the\n\texpression to sizetype first.\n\t* config/mips/mips.c (mips_va_start): Use POINTER_PLUS_EXPR\n\tfor pointers.\n\t(mips_gimplify_va_arg_expr): Likewise.\n\tDon't create BIT_AND_EXPR in a pointer type.\n\n\n\n2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * trans-intrinsic.c (gfc_conv_intrinsic_repeat): Use\n        POINTER_PLUS_EXPR instead of PLUS_EXPR for pointer addition.\n        * trans-expr.c (gfc_trans_string_copy): Create\n        POINTER_PLUS_EXPR instead of a PLUS_EXPR\n        for pointer types.\n\n2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n\t* typeck.c (build_binary_op): For templates build the\n\texpression in pieces to avoid the assert in build2_stat.\n\t(get_member_function_from_ptrfunc):\n\tChange over to using POINTER_PLUS_EXPR and convert\n\tthe second operand to sizetype.\n\t* typeck2.c (build_m_component_ref):  Likewise.\n\t* init.c (expand_virtual_init): Create a POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for pointers.\n\t(build_new_1): Likewise.\n\t(build_vec_delete_1): Likewise.\n\t(build_vec_delete): Likewise.\n\t* class.c (build_base_path): Likewise.\n\t(build_base_path): Likewise.\n\t(convert_to_base_statically): Likewise.\n\t(fixed_type_or_null): Handle POINTER_PLUS_EXPR.\n\t(get_vtbl_decl_for_binfo): Handle POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR.\n\t(dfs_accumulate_vtbl_inits): Create a POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for pointers.\n\t* call.c (build_special_member_call): Likewise.\n\t* rtti.c (build_headof): Likewise.\n\tUse sizetype instead of ptrdiff_type_node.\n\t(tinfo_base_init): Create a POINTER_PLUS_EXPR\n\tinstead of PLUS_EXPR for pointers.\n\t* except.c (expand_start_catch_block):  Do a\n\tNEGATIVE and then a POINTER_PLUS_EXPR instead\n\tof a MINUS_EXPR.\n\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Convert\n\tPLUS_EXPR on pointer types over to use\n\tPOINTER_PLUS_EXPR and remove the conversion\n\tto the pointer types.\n\t* method.c (thunk_adjust): Use POINTER_PLUS_EXPR for\n\tadding to a pointer type. Use size_int instead of\n\tssize_int. Convert the index to sizetype before\n\tadding it to the pointer.\n\n\n\n2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * trans.c (Attribute_to_gnu): When subtracting an\n        offset from a pointer, use POINTER_PLUS_EXPR with\n        NEGATE_EXPR instead of MINUS_EXPR.\n        (gnat_to_gnu): Likewise.\n        * utils.c (convert): When converting between\n        thin pointers, use POINTER_PLUS_EXPR and sizetype\n        for the offset.\n        * utils2.c (known_alignment): POINTER_PLUS_EXPR\n        have the same semantics as PLUS_EXPR for alignment.\n        (build_binary_op): Add support for the semantics of\n        POINTER_PLUS_EXPR's operands.\n        When adding an offset to a pointer, use POINTER_PLUS_EXPR.\n\n\n\n2007-06-15 Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n        * class.c (make_class_data): Build the index in sizetype.\n        Use POINTER_PLUS_EXPR instead of PLUS_EXPR when\n        adding to a pointer type.\n        (build_symbol_entry): Likewise.\n        * expr.c (build_java_arrayaccess): Likewise.\n        (build_field_ref): Likewise.\n        (build_known_method_ref): Likewise.\n        (build_invokevirtual): Likewise.\n        * except.c (build_exception_object_ref): Do a\n        NEGATIVE and then a POINTER_PLUS_EXPR instead\n        of a MINUS_EXPR.\n\n\n2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n\n\tPR tree-opt/32225\n\t* gcc.c-torture/compile/20070605-1.c: New test.\n\n\t* gcc.c-torture/compile/20070603-1.c: New testcase.\n\t* gcc.c-torture/compile/20070603-2.c: New testcase.\n\n\t* gcc.c-torture/compile/20070531-1.c: New test.\n\n\tPR tree-opt/32167\n\t* gcc.c-torture/compile/20070531-2.c: New test.\n\n\tPR tree-opt/32144\n\t* gcc.c-torture/compile/20070529-1.c: New test.\n\n\tPR tree-opt/32145\n\t* gcc.c-torture/compile/20070529-2.c: New test.\n\n\tPR tree-opt/32015\n\t* gcc.c-torture/compile/20070520-1.c: New test.\n\n\t* g++.dg/ext/java-1.C: New test.\n\n\t* gcc.dg/vect/vect-106.c: We are now able to vectorize two\n\tloops instead of one. Remove the \"can't determine dependence\"\n\tcheck.\n\t* gcc.dg/tree-ssa/20030815-1.c: Remove testcase which is no longer\n\tneeded as the cast is gone in the first place.\n\t* gcc.dg/max-1.c: Change local variable a to be a global one.\n\t* gcc.dg/tree-ssa/ssa-pre-8.c: Update testcase since we don't\n\thave a cast which is PREd.\n\nFrom-SVN: r125755", "tree": {"sha": "a412e70be6f1d8732a8f791392c918ebc475f3e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a412e70be6f1d8732a8f791392c918ebc475f3e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5be014d5b728cf754020b8ab4df1cd029f69922e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be014d5b728cf754020b8ab4df1cd029f69922e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5be014d5b728cf754020b8ab4df1cd029f69922e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5be014d5b728cf754020b8ab4df1cd029f69922e/comments", "author": null, "committer": null, "parents": [{"sha": "1d2b1d91675ba5a26e4d04b209355047421adf92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2b1d91675ba5a26e4d04b209355047421adf92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2b1d91675ba5a26e4d04b209355047421adf92"}], "stats": {"total": 2801, "additions": 2011, "deletions": 790}, "files": [{"sha": "abe28d49f4574755c810420f9165614f03a498b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1,3 +1,273 @@\n+2007-06-15  Andrew Pinski <andrew_pinski@playstation.sony.com>\n+            Zdenek Dvorak <dvorakz@suse.cz>\n+            Richard Guenther  <rguenther@suse.de>\n+            Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* tree-vrp.c (compare_values_warnv): Convert val2 to\n+\tthe type of val1.\n+\t(extract_range_from_assert): Create\n+\tPOINTER_PLUS_EXPR for pointer types.\n+\t(extract_range_from_binary_expr): Handle\n+\tonly POINTER_PLUS_EXPR, MIN_EXPR, and MAX_EXPR\n+\tfor pointer types.\n+\t* doc/c-tree.texi (POINTER_PLUS_EXPR): Document.\n+\t* tree-ssa-loop-niter.c (split_to_var_and_offset): Handle\n+\tPOINTER_PLUS_EXPR as PLUS_EXPR.\n+\t(number_of_iterations_lt_to_ne):\n+\tFor pointer types, use sizetype when\n+\tcreating MINUS_EXPR/PLUS_EXPRs.\n+\t(assert_loop_rolls_lt): For pointer types, use sizetype when\n+\tcreating MINUS_EXPR/PLUS_EXPRs.\n+\t(number_of_iterations_le): Likewise.\n+\t(expand_simple_operations): POINTER_PLUS_EXPR are simple also.\n+\t(derive_constant_upper_bound): Handle POINTER_PLUS_EXPR just\n+\tlike PLUS_EXPR and MINUS_EXPR.\n+\t* tree-pretty-print.c (dump_generic_node): Handle\n+\tPOINTER_PLUS_EXPR.\n+\t(op_prio): Likewise.\n+\t(op_symbol_1): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t* tree-ssa-loop-manip.c (create_iv): Handle pointer base\n+\tspecially.\n+\t* tree-tailcall.c (process_assignment): Mention\n+\tPOINTER_PLUS_EXPR in a TODO comment.\n+\t* tree.c (build2_stat): Assert when trying to use PLUS_EXPR or \n+\tMINUS_EXPR with a pointer. Also assert for POINTER_PLUS_EXPR\n+\tnot used with a pointer and an integer type.\n+\t* tree-scalar-evolution.c (add_to_evolution_1): Convert the\n+\tincrement using chrec_convert_rhs instead of chrec_convert.\n+\t(follow_ssa_edge_in_rhs): Handle POINTER_PLUS_EXPR like\n+\tPLUS_EXPR except for the right hand side's type will be\n+\tsizetype.\n+\t(interpret_rhs_modify_stmt): Handle POINTER_PLUS_EXPR.\n+\t(fold_used_pointer_cast): Kill.\n+\t(pointer_offset_p): Kill.\n+\t(fold_used_pointer): Kill.\n+\t(pointer_used_p): Kill.\n+\t(analyze_scalar_evolution_1 <case GIMPLE_MODIFY_STMT>): Don't\n+\tcall fold_used_pointer.\n+\t(instantiate_parameters_1): Convert the increment\n+\tusing chrec_convert_rhs instead of chrec_convert.\n+\tHandle POINTER_PLUS_EXPR as PLUS_EXPR.\n+\t* builtins.c (get_pointer_alignment): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\t(expand_builtin_strcat): Create a POINTER_PLUS_EXPR instead of\n+\tPLUS_EXPR for pointers.\n+\t(std_gimplify_va_arg_expr): Likewise.\n+\t(fold_builtin_memory_op): Likewise.\n+\t(fold_builtin_strstr): Likewise.\n+\t(fold_builtin_strchr): Likewise.\n+\t(fold_builtin_strrchr): Likewise.\n+\t(fold_builtin_strpbrk): Likewise.\n+\t(expand_builtin_memory_chk): Likewise.\n+\t(fold_builtin_memory_chk): Likewise.\n+\t(std_expand_builtin_va_start): Use\n+\tsizetype for the call to make_tree and then convert\n+\tto the pointer type.\n+\t(fold_builtin_memchr): Use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for adding to a pointer.\n+\t(std_gimplify_va_arg_expr): Use fold_build2 for\n+\tthe creating of POINTER_PLUS_EXPR.  For the BIT_AND_EXPR, cast\n+\tthe operands to sizetype first and then cast the BIT_AND_EXPR\n+\tback to the pointer type.\n+\t* fold-const.c (build_range_check): Handle pointer types\n+\tspecially.\n+\t(extract_array_ref): Look for POINTER_PLUS_EXPR instead\n+\tof PLUS_EXPR's. Make sure the offset is converted to\n+\tsizetype.\n+\t(try_move_mult_to_index): Strip the NOPs from the offset.\n+\tRemove code argument and replace all uses with PLUS_EXPR.\n+\t(fold_to_nonsharp_ineq_using_bound): Handle pointer types\n+\tspecially. Don't use a pointer type for MINUS_EXPR.\n+\t(fold_unary): Handle for (T1)(X op Y),\n+\tonly p+ as that is the only as that can be handled for\n+\tbinary operators now.\n+\t(fold_binary <case POINTER_PLUS_EXPR>): Add folding of\n+\tPOINTER_PLUS_EXPR.\n+\t<case PLUS_EXPR>: Add folding of PTR+INT into\n+\tPTR p+ INT.\n+\tDon't call try_move_mult_to_index.\n+\t<case MINUS_EXPR>: Fold (PTR0 p+ A) - (PTR1 p+ B)\n+\tinto (PTR0 - PTR1) + (A - B). Fold (PTR0 p+ A) - PTR1 into\n+\t(PTR0 - PTR1) + A iff (PTR0 - PTR1) simplifies.\n+\tDon't call try_move_mult_to_index.\n+\t(tree_expr_nonnegative_warnv_p): Handle POINTER_PLUS_EXPR.\n+\t(tree_expr_nonzero_p): Likewise.\n+\t(fold_indirect_ref_1): Look at POINTER_PLUS_EXPR instead\n+\tof PLUS_EXPR for the complex expression folding.\n+\t* tree-chrec.c (chrec_fold_plus_poly_poly): If the\n+\tfirst chrec is a pointer type, then the second should\n+\tbe sizetype and not the first's type.\n+\tFor POINTER_PLUS_EXPR, use a different right hand side type.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n+\t(chrec_fold_plus_1): For POINTER_PLUS_EXPR, use a\n+\tdifferent right hand side type.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n+\t(chrec_fold_plus): For pointer types, use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\tWhen either operand is zero, convert the other operand.\n+\t(chrec_apply): Use chrec_convert_rhs\n+\ton the argument x instead of chrec_convert.\n+\t(reset_evolution_in_loop): For pointer types, the new_evol\n+\tshould be sizetype.\n+\t(convert_affine_scev): For POINTER_PLUS_EXPR, use a\n+\tdifferent right hand side type.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n+\t(chrec_convert_rhs): New function.\n+\t(chrec_convert_aggressive): For POINTER_PLUS_EXPR, use a\n+\tdifferent right hand side type.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n+\t* tree-chrec.h (chrec_convert_rhs): New prototype.\n+\t(build_polynomial_chrec): For pointer types, the right hand\n+\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Look for\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR's.\n+\tRemove subtraction case as it is always addition now.\n+\tMake sure the offset is converted to sizetype.\n+\t(fold_stmt_r): Don't handle PLUS_EXPR/MINUS_EXPR specially.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR was handled before.\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Abort for \n+\tPLUS_EXPR in pointer type.\n+\tHandle POINTER_PLUS_EXPR.\n+\t(tree_to_aff_combination): Likewise.\n+\t(force_expr_to_var_cost): Likewise.\n+\t(force_expr_to_var_cost): Likewise. Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t* c-format.c (check_format_arg): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR of pointer types.\n+\t* tree-stdarg.c (va_list_counter_bump): Handle POINTER_PLUS_EXPR\n+\tas PLUS_EXPR.\n+\t(check_va_list_escapes): Likewise.\n+\t(check_all_va_list_escapes): Likewise.\n+\t* dwarf2out.c (loc_descriptor_from_tree_1):\n+\tHandle POINT_PLUS_EXPR as a PLUS_EXPR.\n+\t* expr.c (expand_expr_real_1): Handle POINTER_PLUS_EXPR.\n+\t(string_constant): Likewise.\n+\t* tree-ssa-address.c (tree_mem_ref_addr): When adding\n+\tthe offset to the base, use POINTER_PLUS_EXPR.\n+\t(add_to_parts): Convert the index to sizetype.\n+\t(create_mem_ref): Create A POINTER_PLUS_EXPR for the one case.\n+\t* matrix-reorg.c (collect_data_for_malloc_call): Stmt\n+\twill now only be either INDIRECT_REF and POINTER_PLUS_EXPR.\n+\tOffset only holds something for PLUS_EXPR.\n+\t(ssa_accessed_in_tree): Handle POINTER_PLUS_EXPR just as\n+\ta PLUS_EXPR.\n+\t(analyze_transpose): POINTER_PLUS_EXPR will only show up now\n+\tand not PLUS_EXPR.\n+\t(analyze_accesses_for_modify_stmt): Likewise.\n+\tRemove comment about the type being integral type as it is\n+\twrong now.\n+\t(can_calculate_expr_before_stmt): Handle POINTER_PLUS_EXPR as\n+\tPLUS_EXPR.\n+\t(transform_access_sites): POINTER_PLUS_EXPR will only show up now\n+\tand not PLUS_EXPR.\n+\tCorrect the type which the artimentic is done in (is now\n+\tsizetype).\n+\tReindent one loop.\n+\t* tree-data-ref.c (split_constant_offset): Handle\n+\tPOINTER_PLUS_EXPR\n+\t* tree-affine.c (tree_to_aff_combination): Likewise.\n+\t* c-typeck.c (build_unary_op): For pointers create the increment\n+\tas a sizetype. Create a POINTER_PLUS_EXPR instead of PLUS_EXPR\n+\tfor pointers.\n+\t* gimplify.c (gimplify_self_mod_expr): Create a\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t(gimplify_omp_atomic_fetch_op): Handle POINTER_PLUS_EXPR.\n+\t* tree.def (POINTER_PLUS_EXPR): New tree code.\n+\t* tree-predcom.c (ref_at_iteration): If we have a pointer\n+\ttype do the multiplication in sizetype.\n+\t* tree-mudflap.c (mf_xform_derefs_1): Create a\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t* tree-ssa-forwprop.c \n+\t(forward_propagate_addr_into_variable_array_index):\n+\tDon't expect there to be a cast for the index as that\n+\tdoes not exist anymore.\n+\t(forward_propagate_addr_expr_1): Check for POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\tDon't check for the first operand of the POINTER_PLUS_EXPR\n+\twas the index as it cannot be.\n+\tCall forward_propagate_addr_into_variable_array_index with\n+\tthe SSA_NAME instead of the statement.\n+\t* varasm.c (const_hash_1): Handle POINTER_PLUS_EXPR.\n+\t(compare_constant): Likewise.\n+\t(copy_constant): Likewise.\n+\t(compute_reloc_for_constant): Likewise.\n+\t(output_addressed_constants): Likewise.\n+\t(initializer_constant_valid_p): Likewise.\n+\t* tree-ssa.c (tree_ssa_useless_type_conversion_1):\n+\tConvert the MIN/MAX of the inner type to the outer\n+\ttype before comparing them.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref):  Handle\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.\n+\t(issue_prefetch_ref): Create a POINTER_PLUS_EXPR instead\n+\tof PLUS_EXPR for pointers.\n+\t* tree-inline.c (estimate_num_insns_1): Handle\n+\tPOINTER_PLUS_EXPR.\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref): \n+\tCreate a POINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t(bump_vector_ptr): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for the pointer increment statement.\n+\t(vect_update_ivs_after_vectorizer): For pointer types, create\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR and also create\n+\tMULT_EXPR in sizetype.\n+\t(vect_gen_niters_for_prolog_loop): Add a cast when creating\n+\tbyte_misalign.\n+\t* tree-object-size.c (plus_expr_object_size): Handle\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.  Removing all the extra\n+\tcode which is trying to figure out which side is a pointer and \n+\tis the index.\n+\t(check_for_plus_in_loops_1): Likewise.\n+\t(check_for_plus_in_loops): Likewise.\n+\t* c-common.c (pointer_int_sum): Create a\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t* tree-ssa-structalias.c (handle_ptr_arith): Handle\n+\tonly POINTER_PLUS_EXPR.  Removing all the extra\n+\tcode which is trying to figure out which side is a pointer and \n+\tis the index.\n+\t* tree-cfg.c (verify_expr): Add extra checking for pointers and\n+\tPLUS_EXPR and MINUS_EXPR.\n+\tAlso add checking to make sure the operands of POINTER_PLUS_EXPR\n+\tare correct.\n+\t* config/frv/frv.c (frv_expand_builtin_va_start): Use sizetype\n+\twith make_tree, instead of a pointer type.\n+\t* config/s390/s390.c (s390_va_start): Use POINTER_PLUS_EXPR\n+\tfor pointers instead of PLUS_EXPR.\n+\t(s390_gimplify_va_arg): Likewise.\n+\t* config/spu/spu.c (spu_va_start): Create POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR when doing addition on pointer\n+\ttypes.  Use sizetype for the second operand.\n+\t(spu_gimplify_va_arg_expr): Likewise.\n+\t* config/sparc/sparc.c (sparc_gimplify_va_arg): Use \n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR when the operand was\n+\ta pointer.  Don't create a BIT_AND_EXPR for pointer types.\n+\t* config/i386/i386.c (ix86_va_start): Use POINTER_PLUS_EXPR\n+\tfor the pointer addition and also use size_int/sizetype\n+\tfor the offset.\n+\t(ix86_gimplify_va_arg): Likewise.\n+\tPerform BIT_AND_EXPR on sizetype arguments.\n+\t* config/sh/sh.c (sh_va_start): Call make_tree with sizetype\n+\tand convert its result to a pointer type.  Use POINTER_PLUS_EXPR\n+\tfor the pointer additions and also use size_int for the offsets.\n+\t(sh_gimplify_va_arg_expr): Use POINTER_PLUS_EXPR for the pointer\n+\tadditions and also use size_int for the offsets.  Perform\n+\tBIT_AND_EXPR on sizetype arguments.\n+\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Use\n+\tPOINTER_PLUS_EXPR for pointers and create the\n+\tBIT_AND_EXPR in sizetype.\n+\t* config/rs6000/rs6000.c (rs6000_va_start): Use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointer addition.\n+\t(rs6000_va_start): Likewise.\n+\tAlso use sizetype for the offset.\n+\t* config/pa/pa.c (reloc_needed): Handle POINTER_PLUS_EXPR\n+\tas PLUS_EXPR/MINUS_EXPR.\n+\t(hppa_gimplify_va_arg_expr): Don't create MINUS_EXPR or\n+\tPLUS_EXPR for pointers, instead use POINTER_PLUS_EXPR.\n+\tDon't use BIT_AND_EXPR on a pointer type, convert the\n+\texpression to sizetype first.\n+\t* config/mips/mips.c (mips_va_start): Use POINTER_PLUS_EXPR\n+\tfor pointers.\n+\t(mips_gimplify_va_arg_expr): Likewise.\n+\tDon't create BIT_AND_EXPR in a pointer type.\n+\n 2007-06-15  Eric Christopher  <echristo@apple.com>\n \n \t* config.gcc (i?86-*-darwin*): Add t-crtfm and t-crtpc."}, {"sha": "5c7380dc0ce09550df51d265d63f78e5de0ed5a9", "filename": "gcc/ChangeLog.ptr", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.ptr?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,539 @@\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 125733\n+\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-vrp.c (compare_values_warnv): Fix spelling/grammer\n+\tmistakes\n+\t(extract_range_from_binary_expr): Likewise.\n+\t* doc/c-tree.texi (POINTER_PLUS_EXPR): Likewise.\n+\t* tree-ssa-loop-niter.c (assert_loop_rolls_lt): Add vertical\n+\twhitespace.\n+\t* tree-pretty-print.c (op_symbol_code <case POINTER_PLUS_EXPR>):\n+\tChange print out to \"+\".\n+\t* tree-scalar-evolution.c (instantiate_parameters_1):\n+\tUse chrec_type instead of TREE_TYPE.\n+\t* builtins.c (expand_builtin_strcat): Fix vertical whitespace.\n+\t(std_expand_builtin_va_start): Fix whitespace.\n+\t(fold_builtin_strstr): Use size_int instead of build_int_cst (sizetype.\n+\t(fold_builtin_strchr): Likewise.\n+\t(fold_builtin_strrchr): Likewise.\n+\t(fold_builtin_strpbrk): Likewise.\n+\t* fold-const.c (try_move_mult_to_index): Fix spelling/grammer\n+\tmistakes.\n+\t(fold_to_nonsharp_ineq_using_bound): Merge the two ifs at the end.\n+\t(fold_binary): Fix spelling/grammer mistakes.\n+\t* tree-ssa-ccp.c (maybe_fold_stmt_addition): Assert that only\n+\ta POINTER_PLUS_EXPR is passed in.\n+\t* tree-ssa-loop-ivopts.c (determine_base_object):\n+\tFix spelling/grammer mistakes.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* tree-data-ref.c (split_constant_offset): Likewise.\n+\t* c-typeck.c (build_unary_op): Use fold_convert instead of convert\n+\tfor converting to sizetype.\n+\t* tree.def (POINTER_PLUS_EXPR): Fix comment.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1):\n+\tFix spelling/grammer mistakes.\n+\t(phiprop_insert_phi): Likewise.\n+\t* c-common.c (pointer_int_sum): Remove FIXME about\n+\tPOINTER_MINUS_EXPR.\n+\n+2007-06-13  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* expr.c (expand_expr_real_1 <case POINTER_PLUS_EXPR>): Remove assert\n+\tfor checking the modes of the operands are the same.\n+\n+2007-06-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/sparc/sparc.c (sparc_gimplify_va_arg): Use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR when the operand was a pointer.  Don't create a\n+\tBIT_AND_EXPR for pointer types.\n+\n+2007-06-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/mips/mips.c (mips_va_start): Use POINTER_PLUS_EXPR\n+\tfor pointers.\n+\t(mips_gimplify_va_arg_expr): Likewise.\n+\tDon't create BIT_AND_EXPR in a pointer type.\n+\n+2007-06-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 125658 \n+\n+2007-06-11  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 125611\n+\n+2007-06-07  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* matrix-reorg.c (collect_data_for_malloc_call): Stmt\n+\twill now only be either INDIRECT_REF and POINTER_PLUS_EXPR.\n+\tOffset only holds something for PLUS_EXPR.\n+\t(ssa_accessed_in_tree): Handle POINTER_PLUS_EXPR just as\n+\ta PLUS_EXPR.\n+\t(analyze_transpose): POINTER_PLUS_EXPR will only show up now\n+\tand not PLUS_EXPR.\n+\t(analyze_accesses_for_modify_stmt): Likewise.\n+\tRemove comment about the type being integral type as it is\n+\twrong now.\n+\t(analyze_matrix_accesses): Handle POINTER_PLUS_EXPR as\n+\tPLUS_EXPR.\n+\t(transform_access_sites): POINTER_PLUS_EXPR will only show up now\n+\tand not PLUS_EXPR.\n+\tCorrect the type which the artimentic is done in (is now\n+\tsizetype).\n+\tReindent one loop.\n+\n+2007-06-07  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Use\n+\tPOINTER_PLUS_EXPR for pointers and create the\n+\tBIT_AND_EXPR in sizetype.\n+\t* config/s390/s390.c (s390_va_start): Use POINTER_PLUS_EXPR\n+\tfor pointers instead of PLUS_EXPR.\n+\t(s390_gimplify_va_arg): Likewise.\n+\n+2007-06-07  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/frv/frv.c (frv_expand_builtin_va_start): Use sizetype\n+\twith make_tree, instead of a pointer type.\n+\t* config/pa/pa.c (reloc_needed): Handle POINTER_PLUS_EXPR\n+\tas PLUS_EXPR/MINUS_EXPR.\n+\t(hppa_gimplify_va_arg_expr): Don't create MINUS_EXPR or\n+\tPLUS_EXPR for pointers, instead use POINTER_PLUS_EXPR.\n+\tDon't use BIT_AND_EXPR on a pointer type, convert the\n+\texpression to sizetype first.\n+\n+2007-06-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-ssa-forwprop.c\n+\t(forward_propagate_addr_into_variable_array_index):\n+\tDon't expect a statement for the size 1 case.\n+\tUse the offset variable for the size 1 case.\n+\tLook through use-def chains to find the mutliply\n+\tfor the non size 1 case.\n+\t(forward_propagate_addr_expr_1): Call\n+\tforward_propagate_addr_into_variable_array_index with\n+\tthe SSA_NAME instead of the statement.\n+\n+2007-06-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/32225\n+\t* tree-scalar-evolution.c (follow_ssa_edge_in_rhs <case\n+\tPOINTER_PLUS_EXPR>): Do not change type_rhs.\n+\t(follow_ssa_edge_in_rhs <case POINTER_PLUS_EXPR, case PLUS_EXPR>):\n+\tUse the code of the orginal expression instead of just PLUS_EXPR.\n+\tAlso use type_rhs where TREE_TYPE (rhs) was used (reverting back\n+\tto the trunk).\n+\n+2007-06-03  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-predcom.c (ref_at_iteration): If we have a pointer\n+\ttype do the multiplication in sizetype.\n+\n+2007-06-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 125285\n+\n+2007-05-31  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-vrp.c (extract_range_from_binary_expr): Handle\n+\tMIN_EXPR/MAX_EXPR for pointers type.\n+\n+\tPR tree-opt/32167\n+\t* tree-chrec.c (chrec_fold_plus): When either\n+\toperand is zero, convert the other operand.\n+\n+2007-05-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* builtins.c (std_expand_builtin_va_start): Use\n+\tsizetype for the call to make_tree and then convert\n+\tto the pointer type.\n+\n+2007-05-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-op/32145\n+\t* tree-vrp.c (extract_range_from_assert): Create\n+\tPOINTER_PLUS_EXPR for pointer types.\n+\n+\tPR tree-opt/32144\n+\t* tree-chrec.c (chrec_fold_plus_poly_poly): If the\n+\tfirst chrec is a pointer type, then the second should\n+\tbe sizetype and not the first's type.\t\n+\n+2007-05-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* fold-const.c (try_move_mult_to_index):\n+\tSay why we strip the nops.\n+\t(fold_unary <case NOP_EXPR>): Remove\n+\tTODO as we cannot get that case.\n+\t* tree-chrec.c (chrec_fold_plus):\n+\tCleanup the code to chose which\n+\ttree code is used.\n+\t(chrec_convert_rhs): Add comment on\n+\twhy the increment is sizetype for\n+\tpointers.\n+\t* tree-mudflap.c (mf_xform_derefs_1):\n+\tUse size_int instead of build_int_cst.\n+\t* tree-ssa-loop-prefetch.c (issue_prefetch_ref): Likewise.\n+\n+2007-05-21  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/32015\n+\t* tree.c (build2_stat): Make sure that\n+\tMULT_EXPR is not used with pointers.\n+\t* tree-chrec.c (chrec_apply): Use chrec_convert_rhs\n+\ton the argument x instead of chrec_convert.\n+\n+2007-05-20  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (sh_va_start): Call make_tree with sizetype\n+\tand convert its result to a pointer type.  Use POINTER_PLUS_EXPR\n+\tfor the pointer additions and also use size_int for the offsets.\n+\t(sh_gimplify_va_arg_expr): Use POINTER_PLUS_EXPR for the pointer\n+\tadditions and also use size_int for the offsets.  Perform\n+\tBIT_AND_EXPR on sizetype arguments.\n+\n+2007-05-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-ssa-forwprop (forward_propagate_addr_into_variable_array_index):\n+\tDon't expect there to be a cast for the index as that\n+\tdoes not exist anymore.\n+\t(forward_propagate_addr_expr_1): Check for\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.\n+\tDon't check for the first operand of the\n+\tPOINTER_PLUS_EXPR was the index as it\n+\tcannot be.\n+\n+2007-05-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* config/i386/i386.c (ix86_gimplify_va_arg): Use POINTER_PLUS_EXPR,\n+\tperform BIT_AND_EXPR on sizetype arguments.\n+\n+2007-05-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_va_start): Use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointer addition.\n+\t(rs6000_va_start): Likewise.\n+\tAlso use sizetype for the offset.\n+\t* tree-stdarg.c (va_list_counter_bump): Check for PLUS_EXPR\n+\tand POINTER_PLUS_EXPR.\n+\t(check_va_list_escapes): Likewise.\n+\n+2007-05-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/i386/i386.c (ix86_va_start): Use POINTER_PLUS_EXPR\n+\tfor the pointer addition and also use size_int/sizetype\n+\tfor the offset.\n+\t(ix86_gimplify_va_arg): Likewise.\n+\n+2007-05-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 124657\n+\t* tree-data-ref.c (split_constant_offset): Handle\n+\tPOINTER_PLUS_EXPR\n+\texactly the same as PLUS_EXPR/MINUS_EXPR except for the offset\n+\tneeds to be calcuated using PLUS_EXPR instead of\n+\tPOINTER_PLUS_EXPR.\n+\t* builtins.c (fold_builtin_memchr): Use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for adding to a pointer.\n+\n+2006-05-15  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Abort for PLUS_EXPR\n+\tin pointer type.\n+\n+2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-ssa-address.c (tree_mem_ref_addr): When adding\n+\tthe offset to the base, use POINTER_PLUS_EXPR.\n+\n+2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* expr.c (expand_expr_addr_expr_1): Call expand_expr\n+\tfor the offset with the modifier as EXPAND_INITIALIZER\n+\tif the modifier is EXPAND_INITIALIZER.\n+\t(expand_expr_real_1 <case INTEGER_CST>): Don't force to\n+\ta register if we had an overflow.\n+\n+2007-05-10  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 124602.\n+\n+\t* fold-const.c  (extract_array_ref): Make sure the offset\n+\tis converted to sizetype.\n+\t(try_move_mult_to_index): Strip the NOPs from the offset.\n+\t(fold_binary <case POINTER_PLUS_EXPR>): Convert the second\n+\toperand to sizetype before calling try_move_mult_to_index.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne):\n+\tFor pointer types, use sizetype when\n+\tcreating MINUS_EXPR/PLUS_EXPRs.\n+\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Make sure\n+\tthe offset is converted to sizetype.\n+\n+2007-05-11  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* config/spu/spu.c (spu_va_start): Create POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR when doing addition on pointer\n+\ttypes.  Use sizetype for the second operand.\n+\t(spu_gimplify_va_arg_expr): Likewise.\n+\t* tree-ssa.c (tree_ssa_useless_type_conversion_1):\n+\tConvert the MIN/MAX of the inner type to the outer\n+\ttype before comparing them.\n+\n+2007-05-09  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\t    Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* fold-const.c  (fold_to_nonsharp_ineq_using_bound): Don't\n+\tuse a pointer type for MINUS_EXPR.\n+\t(fold_binary <case MINUS_EXPR>): Fold (PTR0 p+ A) - (PTR1 p+ B)\n+\tinto (PTR0 - PTR1) + (A - B). Fold (PTR0 p+ A) - PTR1 into\n+\t(PTR0 - PTR1) + A iff (PTR0 - PTR1) simplifies.\n+\t* tree-chrec.c (chrec_fold_plus_poly_poly): For\n+\tPOINTER_PLUS_EXPR, use a different right hand side type.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR.\n+\t(chrec_fold_plus_1): Likewise.\n+\t(convert_affine_scev): Likewise.\n+\t(chrec_convert_aggressive): Likewise.\n+\t(chrec_fold_plus): For pointer types, use POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\t(reset_evolution_in_loop): For pointer types, the new_evol\n+\tshould be sizetype.\n+\t(chrec_convert_rhs): New function.\n+\t* tree-chrec.h (chrec_convert_rhs): New prototype.\n+\t(build_polynomial_chrec): For pointer types, the right hand\n+\tside should be sizetype and not the same as the left hand side.\n+\t* tree-scalar-evolution.c (add_to_evolution_1): Convert the\n+\tincrement using chrec_convert_rhs instead of chrec_convert.\n+\t(follow_ssa_edge_in_rhs): Handle POINTER_PLUS_EXPR like\n+\tPLUS_EXPR except for the right hand side's type will be\n+\tsizetype.\n+\t(interpret_rhs_modify_stmt): Handle POINTER_PLUS_EXPR.\n+\t(fold_used_pointer_cast): Kill.\n+\t(pointer_offset_p): Kill.\n+\t(fold_used_pointer): Kill.\n+\t(pointer_used_p): Kill.\n+\t(analyze_scalar_evolution_1 <case GIMPLE_MODIFY_STMT>): Don't\n+\tcall fold_used_pointer.\n+\t(instantiate_parameters_1): Convert the increment\n+\tusing chrec_convert_rhs instead of chrec_convert.\n+\tHandle POINTER_PLUS_EXPR as PLUS_EXPR.\n+\t* tree-ssa-loop-niter.c (split_to_var_and_offset): Handle\n+\tPOINTER_PLUS_EXPR as PLUS_EXPR.\n+\t(assert_loop_rolls_lt): For pointer types, use sizetype when\n+\tcreating MINUS_EXPR/PLUS_EXPRs.\n+\t(number_of_iterations_le): Likewise.\n+\t(expand_simple_operations): POINTER_PLUS_EXPR are simple also.\n+\t(derive_constant_upper_bound): Handle POINTER_PLUS_EXPR just\n+\tlike PLUS_EXPR and MINUS_EXPR.\n+\t* tree-data-ref.c (analyze_offset_expr): Likewise.\n+\t(address_analysis): Handle POINTER_PLUS_EXPR as PLUS_EXPR.\n+\t(analyze_offset): Handle POINTER_PLUS_EXPR also.\n+\t(create_data_ref): Convert the increment\n+\tusing chrec_convert_rhs instead of chrec_convert.\n+\t* tree-vect-transform.c (vect_update_ivs_after_vectorizer):\n+\tFor pointer types, create POINTER_PLUS_EXPR instead of\n+\tPLUS_EXPR and also create MULT_EXPR in sizetype.\n+\n+2007-05-07  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* builtins.c (std_gimplify_va_arg_expr): Use fold_build2 for\n+\tthe creating of POINTER_PLUS_EXPR.  For the BIT_AND_EXPR, cast\n+\tthe operands to sizetype first and then cast the BIT_AND_EXPR\n+\tback to the pointer type.\n+\t* tree-ssa-address.c (create_mem_ref): Create A\n+\tPOINTER_PLUS_EXPR for one case.\n+\t* tree.c (const_hash_1): Handle POINTER_PLUS_EXPR same as\n+\tPLUS_EXPR.\n+\t(compare_constant): Likewise.\n+\t(copy_constant): Likewise.\n+\t(compute_reloc_for_constant): Likewise.\n+\t(output_addressed_constants): Likewise.\n+\n+2007-05-07  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree.def (POINTER_PLUS_EXPR): The second operand\n+\tis of type sizetype and not ssizetype.\n+\t* doc/c-tree.texi (POINTER_PLUS_EXPR): Document.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-mudflap.c (mf_xform_derefs_1 <case BIT_FIELD_REF>):\n+\tAdd a conversion of ofs to sizetype.\n+\t(mf_decl_eligible_p): Reformat for length issues.\n+\t(mf_xform_derefs_1): Likewise.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree.c (build2_stat): Check to make sure the\n+\tsecond operand is compatiable with sizetype.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-cfg.c (verify_expr): Change error\n+\tmessage about sizetype to be correct.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 124478.\n+\t* fold-const.c (fold_unary): Handle for (T1)(X op Y),\n+\tonly p+ as that is the only as that can be handled for\n+\tbinary operators now.  Add a TODO for non pointer type\n+\top's.\n+\t* gimplifier.c (gimplify_expr): Don't special case\n+\tPLUS_EXPR.  Special case POINTER_PLUS_EXPR instead,\n+\tremove check for pointer type as it will always be\n+\ta pointer type now.\n+\n+2007-05-04  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-vrp.c (extract_range_from_binary_expr): Handle\n+\tPOINTER_PLUS_EXPRs.  Assert POINTER_PLUS_EXPR is\n+\tthe only expression for pointer types.\n+\t* tree-vect-transform.c (vect_gen_niters_for_prolog_loop):\n+\tAdd a cast when creating byte_misalign.\n+\n+2007-05-04  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* fold-const.c (fold_binary <case POINTER_PLUS_EXPR>);\n+\tAdd comment on why you get INT +p INT.\n+\t(fold_binary <case PLUS_EXPR>): Add folding of PTR+INT into\n+\tPTR p+ INT.\n+\t* dwarf2out.c (loc_descriptor_from_tree_1):\n+\tHandle POINT_PLUS_EXPR as a PLUS_EXPR.\n+\n+2007-05-04  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree-vrp.c  (compare_values_warnv): Convert val2 to\n+\tthe type of val1.\n+\t* fold-const.c (extract_array_ref): Look for\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR's.\n+\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Likewise.\n+\n+2007-05-02  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* c-format.c (check_format_arg): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR of pointer types.\n+\n+2007-05-02  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* fold-const.c (try_move_mult_to_index): Remove code argument\n+\tand replace all uses with PLUS_EXPR.\n+\t(fold_binary <case POINTER_PLUS_EXR>): Remove code argument.\n+\t(fold_binary <case PLUS_EXPR>): Don't call try_move_mult_to_index.\n+\t(fold_binary <case MINUS_EXPR>): Likewise.\n+\t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Remove subtraction\n+\tcase as it is always addition now.\n+\t(fold_stmt_r): Don't handle PLUS_EXPR/MINUS_EXPR specially.\n+\tHandle POINTER_PLUS_EXPR like PLUS_EXPR was handled before.\n+\n+2007-05-01  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 124343.\n+\t* tree-vect-transform.c (bump_vector_ptr): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for the pointer increment statement.\n+\t* expr.c (expand_expr_real_1): Add FIXME/assert for the unhandle case\n+\twhere the modes of the two operands are different.\n+\n+2007-02-25  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tMerge mainline, revision 122323.\n+\n+2006-12-14  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tMerge mainline, revision 119860.\n+\n+2006-11-23  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* tree.def (POINTER_PLUS_EXPR): New tree code.\n+\t* tree-pretty-print.c (dump_generic_node): Handle\n+\tPOINTER_PLUS_EXPR.\n+\t(op_prio): Likewise.\n+\t(op_symbol_1): Likewise.\n+\t* optabs.c (optab_for_tree_code): Likewise.\n+\t* tree-ssa-loop-manip.c (create_iv): Handle pointer base\n+\tspecially.\n+\t* tree-tailcall.c (process_assignment): Mention\n+\tPOINTER_PLUS_EXPR in a TODO comment.\n+\t* tree.c (build2_stat): Assert when trying to use PLUS_EXPR or \n+\tMINUS_EXPR with a pointer. Also assert for POINTER_PLUS_EXPR\n+\tnot used with a pointer and an integer type.\n+\t*  tree-scalar-evolution.c (fold_used_pointer): Mention\n+\tPOINTER_PLUS_EXPR is what this needs to handle.\n+\t* builtins.c (get_pointer_alignment): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\t(expand_builtin_strcat): Create a POINTER_PLUS_EXPR instead of\n+\tPLUS_EXPR for pointers.\n+\t(std_gimplify_va_arg_expr): Likewise.\n+\t(fold_builtin_memory_op): Likewise.\n+\t(fold_builtin_strstr): Likewise.\n+\t(fold_builtin_strchr): Likewise.\n+\t(fold_builtin_strrchr): Likewise.\n+\t(fold_builtin_strpbrk): Likewise.\n+\t(expand_builtin_memory_chk): Likewise.\n+\t(fold_builtin_memory_chk): Likewise.\n+\t* fold-const.c (build_range_check): Handle pointer types\n+\tspecially.\n+\t(fold_to_nonsharp_ineq_using_bound): Likewise.\n+\t(fold_binary): Handle simple POINTER_PLUS_EXPR cases.\n+\t(tree_expr_nonnegative_p): Handle POINTER_PLUS_EXPR.\n+\t(tree_expr_nonzero_p): Likewise.\n+\t(fold_indirect_ref_1): Look at POINTER_PLUS_EXPR instead\n+\tof PLUS_EXPR for the complex expression folding.\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Handle\n+\tPOINTER_PLUS_EXPR.\n+\t(tree_to_aff_combination): Likewise.\n+\t(force_expr_to_var_cost): Likewise.\n+\t(force_expr_to_var_cost): Likewise. Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t* c-format.c (check_format_arg): Mention this should be handling\n+\tPOINTER_PLUS_EXPR.\n+\t* tree-stdarg.c (va_list_counter_bump): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\t(check_va_list_escapes): Likewise.\n+\t(check_all_va_list_escapes): Likewise.\n+\t* expr.c (expand_expr_real_1): Handle POINTER_PLUS_EXPR.\n+\t(string_constant): Likewise.\n+\t* tree-ssa-address.c (add_to_parts): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t(most_expensive_mult_to_index): Likewise.\n+\t(addr_to_parts): Use the correct type for the index.\n+\t* c-typeck.c (build_unary_op): For pointers create the increment\n+\tas a sizetype. Create a POINTER_PLUS_EXPR instead of PLUS_EXPR\n+\tfor pointers.\n+\t* gimplify.c (gimplify_self_mod_expr): Create a\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t(gimplify_omp_atomic_fetch_op): Handle POINTER_PLUS_EXPR.\n+\t* tree-mudflap.c (mf_xform_derefs_1): Create a\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Add a\n+\tnote this should be handling POINTER_PLUS_EXPR.\n+\t* varasm.c (initializer_constant_valid_p): Handle\n+\tPOINTER_PLUS_EXPR.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref):  Handle\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.\n+\t(issue_prefetch_ref): Create a POINTER_PLUS_EXPR instead\n+\tof PLUS_EXPR for pointers.\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref):\n+\tLikewise.\n+\t* tree-inline.c (estimate_num_insns_1): Handle\n+\tPOINTER_PLUS_EXPR.\n+\t* tree-object-size.c (plus_expr_object_size): Handle\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR.  Removing all the extra\n+\tcode which is trying to figure out which side is a pointer and \n+\tis the index.\n+\t(check_for_plus_in_loops_1): Likewise.\n+\t(check_for_plus_in_loops): Likewise.\n+\t* c-common.c (pointer_int_sum): Create a\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointers.\n+\t* tree-ssa-structalias.c (handle_ptr_arith): Handle\n+\tonly POINTER_PLUS_EXPR.  Removing all the extra\n+\tcode which is trying to figure out which side is a pointer and \n+\tis the index.\n+\t* tree-cfg.c (verify_expr): Add extra checking for pointers and\n+\tPLUS_EXPR and MINUS_EXPR.\n+\tAlso add checking to make sure the operands of POINTER_PLUS_EXPR\n+\tare correct.\n+\n+"}, {"sha": "8d8c3b782ee4256bca1ec1f3e114cc8982910925", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1,3 +1,18 @@\n+2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* trans.c (Attribute_to_gnu): When subtracting an\n+\toffset from a pointer, use POINTER_PLUS_EXPR with\n+\tNEGATE_EXPR instead of MINUS_EXPR.\n+\t(gnat_to_gnu): Likewise.\n+\t* utils.c (convert): When converting between\n+\tthin pointers, use POINTER_PLUS_EXPR and sizetype\n+\tfor the offset.\n+\t* utils2.c (known_alignment): POINTER_PLUS_EXPR\n+\thave the same semantics as PLUS_EXPR for alignment.\n+\t(build_binary_op): Add support for the semantics of\n+\tPOINTER_PLUS_EXPR's operands.\n+\tWhen adding an offset to a pointer, use POINTER_PLUS_EXPR.\n+\n 2007-06-11  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* trans.c (Attribute_to_gnu): Use signed_or_unsigned_type_for instead"}, {"sha": "26d8b6a5446a7fbebdb351b92994aa2147565685", "filename": "gcc/ada/ChangeLog.ptr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog.ptr?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,21 @@\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* trans.c (Attribute_to_gnu): Use fold_build1 instead\n+\tof build1 for NEGATE_EXPR.\n+\t(gnat_to_gnu): Likewise.\n+\n+2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* trans.c (Attribute_to_gnu): When subtracting an\n+\toffset from a pointer, use POINTER_PLUS_EXPR with\n+\tNEGATE_EXPR instead of MINUS_EXPR.\n+\t(gnat_to_gnu): Likewise.\n+\t* utils.c (convert): When converting between\n+\tthin pointers, use POINTER_PLUS_EXPR and sizetype\n+\tfor the offset.\n+\t* utils2.c (known_alignment): POINTER_PLUS_EXPR\n+\thave the same semantics as PLUS_EXPR for alignment.\n+\t(build_binary_op): Add support for the semantics of\n+\tPOINTER_PLUS_EXPR's operands.\n+\tWhen adding an offset to a pointer, use POINTER_PLUS_EXPR.\n+"}, {"sha": "052935cefee49231959b56c4f1a36b6f418a8185", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -829,11 +829,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    tree gnu_char_ptr_type = build_pointer_type (char_type_node);\n \t    tree gnu_pos = byte_position (TYPE_FIELDS (gnu_obj_type));\n \t    tree gnu_byte_offset\n-\t      = convert (gnu_char_ptr_type,\n+\t      = convert (sizetype,\n \t\t\t size_diffop (size_zero_node, gnu_pos));\n+\t    gnu_byte_offset = fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n \n \t    gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n-\t    gnu_ptr = build_binary_op (MINUS_EXPR, gnu_char_ptr_type,\n+\t    gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n \t\t\t\t       gnu_ptr, gnu_byte_offset);\n \t  }\n \n@@ -4571,11 +4572,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      tree gnu_char_ptr_type = build_pointer_type (char_type_node);\n \t      tree gnu_pos = byte_position (TYPE_FIELDS (gnu_obj_type));\n \t      tree gnu_byte_offset\n-\t\t= convert (gnu_char_ptr_type,\n+\t\t= convert (sizetype,\n \t\t\t   size_diffop (size_zero_node, gnu_pos));\n+\t      gnu_byte_offset = fold_build1 (NEGATE_EXPR, sizetype, gnu_byte_offset);\n \n \t      gnu_ptr = convert (gnu_char_ptr_type, gnu_ptr);\n-\t      gnu_ptr = build_binary_op (MINUS_EXPR, gnu_char_ptr_type,\n+\t      gnu_ptr = build_binary_op (POINTER_PLUS_EXPR, gnu_char_ptr_type,\n \t\t\t\t\t gnu_ptr, gnu_byte_offset);\n \t    }\n "}, {"sha": "8a8ee7f96e047df7bb4c5d510242c734286f54bb", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -3601,8 +3601,8 @@ convert (tree type, tree expr)\n \t  if (integer_zerop (byte_diff))\n \t    return expr;\n \n-\t  return build_binary_op (PLUS_EXPR, type, expr,\n-\t\t\t\t  fold (convert_to_pointer (type, byte_diff)));\n+\t  return build_binary_op (POINTER_PLUS_EXPR, type, expr,\n+\t\t\t\t  fold (convert (sizetype, byte_diff)));\n \t}\n \n       /* If converting to a thin pointer, handle specially.  */"}, {"sha": "29d8f0fbab52c2a3d84fd9b8637048e7e2b414d3", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -172,6 +172,7 @@ known_alignment (tree exp)\n       break;\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       /* If two address are added, the alignment of the result is the\n \t minimum of the two alignments.  */\n@@ -961,6 +962,13 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       modulus = NULL_TREE;\n       goto common;\n \n+    case POINTER_PLUS_EXPR:\n+      gcc_assert (operation_type == left_base_type\n+\t\t  && sizetype == right_base_type);\n+      left_operand = convert (operation_type, left_operand);\n+      right_operand = convert (sizetype, right_operand);\n+      break;\n+\n     default:\n     common:\n       /* The result type should be the same as the base types of the\n@@ -1116,8 +1124,7 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t\t type, if any.  */\n \t      inner = build_unary_op (ADDR_EXPR, NULL_TREE, inner);\n \t      inner = convert (ptr_void_type_node, inner);\n-\t      offset = convert (ptr_void_type_node, offset);\n-\t      result = build_binary_op (PLUS_EXPR, ptr_void_type_node,\n+\t      result = build_binary_op (POINTER_PLUS_EXPR, ptr_void_type_node,\n \t\t\t\t\tinner, offset);\n \t      result = convert (build_pointer_type (TREE_TYPE (operand)),\n \t\t\t\tresult);"}, {"sha": "6dff9b8f02f2b1337dcc2aaad6fcffda2e836528", "filename": "gcc/builtins.c", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -291,7 +291,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \t  align = MIN (inner, max_align);\n \t  break;\n \n-\tcase PLUS_EXPR:\n+\tcase POINTER_PLUS_EXPR:\n \t  /* If sum of pointer + int, restrict our maximum alignment to that\n \t     imposed by the integer.  If not, we can't do any better than\n \t     ALIGN.  */\n@@ -4433,10 +4433,9 @@ expand_builtin_strcat (tree fndecl, tree exp, rtx target, enum machine_mode mode\n \n \t  /* Create strlen (dst).  */\n \t  newdst = build_call_expr (strlen_fn, 1, dst);\n-\t  /* Create (dst + (cast) strlen (dst)).  */\n-\t  newdst = fold_convert (TREE_TYPE (dst), newdst);\n-\t  newdst = fold_build2 (PLUS_EXPR, TREE_TYPE (dst), dst, newdst);\n+\t  /* Create (dst p+ strlen (dst)).  */\n \n+\t  newdst = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dst), dst, newdst);\n \t  newdst = builtin_save_expr (newdst);\n \n \t  if (!expand_builtin_strcpy_args (fndecl, newdst, newsrc, target, mode))\n@@ -4650,9 +4649,10 @@ void\n std_expand_builtin_va_start (tree valist, rtx nextarg)\n {\n   tree t;\n+  t = make_tree (sizetype, nextarg);\n+  t = fold_convert (ptr_type_node, t);\n \n-  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist,\n-\t      make_tree (ptr_type_node, nextarg));\n+  t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n \n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4719,14 +4719,16 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n   if (boundary > align\n       && !integer_zerop (TYPE_SIZE (type)))\n     {\n-      t = fold_convert (TREE_TYPE (valist), size_int (boundary - 1));\n       t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp, t));\n+\t\t  fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (valist),\n+\t\t\t       valist_tmp, size_int (boundary - 1)));\n       gimplify_and_add (t, pre_p);\n \n-      t = fold_convert (TREE_TYPE (valist), size_int (-boundary));\n+      t = fold_convert (sizetype, valist_tmp);\n       t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist_tmp,\n-\t\t  build2 (BIT_AND_EXPR, TREE_TYPE (valist), valist_tmp, t));\n+\t\t  fold_convert (TREE_TYPE (valist),\n+\t\t\t\tfold_build2 (BIT_AND_EXPR, sizetype, t,\n+\t\t\t\t\t     size_int (-boundary))));\n       gimplify_and_add (t, pre_p);\n     }\n   else\n@@ -4757,13 +4759,11 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = fold_build2 (GT_EXPR, sizetype, rounded_size, size_int (align));\n       t = fold_build3 (COND_EXPR, sizetype, t, size_zero_node,\n \t\t       size_binop (MINUS_EXPR, rounded_size, type_size));\n-      t = fold_convert (TREE_TYPE (addr), t);\n-      addr = fold_build2 (PLUS_EXPR, TREE_TYPE (addr), addr, t);\n+      addr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (addr), addr, t);\n     }\n \n   /* Compute new value for AP.  */\n-  t = fold_convert (TREE_TYPE (valist), rounded_size);\n-  t = build2 (PLUS_EXPR, TREE_TYPE (valist), valist_tmp, t);\n+  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (valist), valist_tmp, rounded_size);\n   t = build2 (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n   gimplify_and_add (t, pre_p);\n \n@@ -8607,8 +8607,7 @@ fold_builtin_memory_op (tree dest, tree src, tree len, tree type, bool ignore, i\n     len = fold_build2 (MINUS_EXPR, TREE_TYPE (len), len,\n \t\t       ssize_int (1));\n \n-  len = fold_convert (TREE_TYPE (dest), len);\n-  dest = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n+  dest = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dest), dest, len);\n   dest = fold_convert (type, dest);\n   if (expr)\n     dest = omit_one_operand (type, dest, expr);\n@@ -8731,8 +8730,8 @@ fold_builtin_memchr (tree arg1, tree arg2, tree len, tree type)\n \t  if (r == NULL)\n \t    return build_int_cst (TREE_TYPE (arg1), 0);\n \n-\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (arg1), arg1,\n-\t\t\t     build_int_cst (TREE_TYPE (arg1), r - p1));\n+\t  tem = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (arg1), arg1,\n+\t\t\t     size_int (r - p1));\n \t  return fold_convert (type, tem);\n \t}\n       return NULL_TREE;\n@@ -10609,8 +10608,8 @@ fold_builtin_strstr (tree s1, tree s2, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n+\t  tem = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, size_int (r - p1));\n \t  return fold_convert (type, tem);\n \t}\n \n@@ -10679,8 +10678,8 @@ fold_builtin_strchr (tree s1, tree s2, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n+\t  tem = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, size_int (r - p1));\n \t  return fold_convert (type, tem);\n \t}\n       return NULL_TREE;\n@@ -10735,8 +10734,8 @@ fold_builtin_strrchr (tree s1, tree s2, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n+\t  tem = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, size_int (r - p1));\n \t  return fold_convert (type, tem);\n \t}\n \n@@ -10795,8 +10794,8 @@ fold_builtin_strpbrk (tree s1, tree s2, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n+\t  tem = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, size_int (r - p1));\n \t  return fold_convert (type, tem);\n \t}\n \n@@ -11382,8 +11381,7 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n \t      return expand_expr (dest, target, mode, EXPAND_NORMAL);\n \t    }\n \n-\t  len = fold_convert (TREE_TYPE (dest), len);\n-\t  expr = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n+\t  expr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dest), dest, len);\n \t  return expand_expr (expr, target, mode, EXPAND_NORMAL);\n \t}\n \n@@ -11630,8 +11628,7 @@ fold_builtin_memory_chk (tree fndecl,\n \treturn omit_one_operand (TREE_TYPE (TREE_TYPE (fndecl)), dest, len);\n       else\n \t{\n-\t  tree temp = fold_convert (TREE_TYPE (dest), len);\n-\t  temp = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, temp);\n+\t  tree temp = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (dest), dest, len);\n \t  return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), temp);\n \t}\n     }"}, {"sha": "9bad32d637a98bcb88299010155ba2ab9021e1f4", "filename": "gcc/c-common.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2700,12 +2700,16 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      Do this multiplication as signed, then convert to the appropriate\n      pointer type (actually unsigned integral).  */\n \n-  intop = convert (result_type,\n-\t\t   build_binary_op (MULT_EXPR, intop,\n-\t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n+  intop = build_binary_op (MULT_EXPR, intop,\n+\t\t\t   convert (TREE_TYPE (intop), size_exp), 1);\n+\n+  if (resultcode == MINUS_EXPR)\n+    intop = fold_build1 (NEGATE_EXPR, TREE_TYPE (intop), intop);\n+\n+  intop = convert (sizetype, intop);\n \n   /* Create the sum or difference.  */\n-  ret = fold_build2 (resultcode, result_type, ptrop, intop);\n+  ret = fold_build2 (POINTER_PLUS_EXPR, result_type, ptrop, intop);\n \n   fold_undefer_and_ignore_overflow_warnings ();\n "}, {"sha": "17f878c5ac950125fac41b63774010a5c01a7f15", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1313,7 +1313,7 @@ check_format_arg (void *ctx, tree format_tree,\n     }\n \n   offset = 0;\n-  if (TREE_CODE (format_tree) == PLUS_EXPR)\n+  if (TREE_CODE (format_tree) == POINTER_PLUS_EXPR)\n     {\n       tree arg0, arg1;\n \n@@ -1323,11 +1323,6 @@ check_format_arg (void *ctx, tree format_tree,\n       STRIP_NOPS (arg1);\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \tformat_tree = arg0;\n-      else if (TREE_CODE (arg0) == INTEGER_CST)\n-\t{\n-\t  format_tree = arg1;\n-\t  arg1 = arg0;\n-\t}\n       else\n \t{\n \t  res->number_non_literal++;"}, {"sha": "9811d873d3810781ec576336c7f1146227fdf9d3", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2959,11 +2959,13 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t      }\n \n \t    inc = c_size_in_bytes (TREE_TYPE (result_type));\n+\t    inc = fold_convert (sizetype, inc);\n \t  }\n \telse\n-\t  inc = integer_one_node;\n-\n-\tinc = convert (argtype, inc);\n+\t  {\n+\t    inc = integer_one_node;\n+\t    inc = convert (argtype, inc);\n+\t  }\n \n \t/* Complain about anything else that is not a true lvalue.  */\n \tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n@@ -3051,10 +3053,10 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       if (val && TREE_CODE (val) == INDIRECT_REF\n           && TREE_CONSTANT (TREE_OPERAND (val, 0)))\n \t{\n-\t  tree op0 = fold_convert (argtype, fold_offsetof (arg, val)), op1;\n+\t  tree op0 = fold_convert (sizetype, fold_offsetof (arg, val)), op1;\n \n \t  op1 = fold_convert (argtype, TREE_OPERAND (val, 0));\n-\t  return fold_build2 (PLUS_EXPR, argtype, op0, op1);\n+\t  return fold_build2 (POINTER_PLUS_EXPR, argtype, op1, op0);\n \t}\n \n       val = build1 (ADDR_EXPR, argtype, arg);"}, {"sha": "4b3e53e990890fd2c9250c38b6e21365c4231824", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2205,7 +2205,8 @@ frv_expand_builtin_va_start (tree valist, rtx nextarg)\n     }\n \n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist,\n-\t      make_tree (ptr_type_node, nextarg));\n+\t      fold_convert (TREE_TYPE (valist),\n+\t\t\t    make_tree (sizetype, nextarg)));\n   TREE_SIDE_EFFECTS (t) = 1;\n \n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);"}, {"sha": "f9e67aa4af336f27343b1d092a3cc0bea82a83f9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -4830,8 +4830,8 @@ ix86_va_start (tree valist, rtx nextarg)\n   type = TREE_TYPE (ovf);\n   t = make_tree (type, virtual_incoming_args_rtx);\n   if (words != 0)\n-    t = build2 (PLUS_EXPR, type, t,\n-\t        build_int_cst (type, words * UNITS_PER_WORD));\n+    t = build2 (POINTER_PLUS_EXPR, type, t,\n+\t        size_int (words * UNITS_PER_WORD));\n   t = build2 (GIMPLE_MODIFY_STMT, type, ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4977,16 +4977,16 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (needed_intregs)\n \t{\n \t  /* int_addr = gpr + sav; */\n-\t  t = fold_convert (ptr_type_node, fold_convert (size_type_node, gpr));\n-\t  t = build2 (PLUS_EXPR, ptr_type_node, sav, t);\n+\t  t = fold_convert (sizetype, gpr);\n+\t  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, t);\n \t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, int_addr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (needed_sseregs)\n \t{\n \t  /* sse_addr = fpr + sav; */\n-\t  t = fold_convert (ptr_type_node, fold_convert (size_type_node, fpr));\n-\t  t = build2 (PLUS_EXPR, ptr_type_node, sav, t);\n+\t  t = fold_convert (sizetype, fpr);\n+\t  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, t);\n \t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, sse_addr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n@@ -5022,12 +5022,12 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \t\t  src_offset = REGNO (reg) * 8;\n \t\t}\n \t      src_addr = fold_convert (addr_type, src_addr);\n-\t      src_addr = fold_build2 (PLUS_EXPR, addr_type, src_addr,\n+\t      src_addr = fold_build2 (POINTER_PLUS_EXPR, addr_type, src_addr,\n \t\t\t\t      build_int_cst (addr_type, src_offset));\n \t      src = build_va_arg_indirect_ref (src_addr);\n \n \t      dest_addr = fold_convert (addr_type, addr);\n-\t      dest_addr = fold_build2 (PLUS_EXPR, addr_type, dest_addr,\n+\t      dest_addr = fold_build2 (POINTER_PLUS_EXPR, addr_type, dest_addr,\n \t\t\t\t       build_int_cst (addr_type, INTVAL (XEXP (slot, 1))));\n \t      dest = build_va_arg_indirect_ref (dest_addr);\n \n@@ -5064,21 +5064,23 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   if (FUNCTION_ARG_BOUNDARY (VOIDmode, type) <= 64\n       || integer_zerop (TYPE_SIZE (type)))\n     t = ovf;\n-  else\n+ else\n     {\n       HOST_WIDE_INT align = FUNCTION_ARG_BOUNDARY (VOIDmode, type) / 8;\n-      t = build2 (PLUS_EXPR, TREE_TYPE (ovf), ovf,\n-\t\t  build_int_cst (TREE_TYPE (ovf), align - 1));\n+      t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovf), ovf,\n+\t\t  size_int (align - 1));\n+      t = fold_convert (sizetype, t);\n       t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t  build_int_cst (TREE_TYPE (t), -align));\n+\t\t  size_int (-align));\n+      t = fold_convert (TREE_TYPE (ovf), t);\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n   t2 = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (t2, pre_p);\n \n-  t = build2 (PLUS_EXPR, TREE_TYPE (t), t,\n-\t      build_int_cst (TREE_TYPE (t), rsize * UNITS_PER_WORD));\n+  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t,\n+\t      size_int (rsize * UNITS_PER_WORD));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n   gimplify_and_add (t, pre_p);\n "}, {"sha": "071baa29c843305061260670bc113d180727f290", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -4326,10 +4326,12 @@ ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   if ((TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == INTEGER_TYPE)\n       ? int_size_in_bytes (type) > 8 : TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n     {\n-      tree t = build2 (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t       build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1));\n+      tree t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (valist), valist,\n+\t\t       size_int (2 * UNITS_PER_WORD - 1));\n+      t = fold_convert (sizetype, t);\n       t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t  build_int_cst (NULL_TREE, -2 * UNITS_PER_WORD));\n+\t\t  size_int (-2 * UNITS_PER_WORD));\n+      t = fold_convert (TREE_TYPE (valist), t);\n       t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (valist), valist, t);\n       gimplify_and_add (t, pre_p);\n     }"}, {"sha": "a132f0ff4c9e7cb974d6e22fd093cf99fb93b17c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -4366,9 +4366,8 @@ mips_va_start (tree valist, rtx nextarg)\n \t words used by named arguments.  */\n       t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n       if (cum->stack_words > 0)\n-\tt = build2 (PLUS_EXPR, TREE_TYPE (ovfl), t,\n-\t\t    build_int_cst (NULL_TREE,\n-\t\t\t\t   cum->stack_words * UNITS_PER_WORD));\n+\tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovfl), t,\n+\t\t    size_int (cum->stack_words * UNITS_PER_WORD));\n       t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovfl), ovfl, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -4384,8 +4383,8 @@ mips_va_start (tree valist, rtx nextarg)\n       fpr_offset = gpr_save_area_size + UNITS_PER_FPVALUE - 1;\n       fpr_offset &= ~(UNITS_PER_FPVALUE - 1);\n       if (fpr_offset)\n-\tt = build2 (PLUS_EXPR, TREE_TYPE (ftop), t,\n-\t\t    build_int_cst (NULL_TREE, -fpr_offset));\n+\tt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ftop), t,\n+\t\t    size_int (-fpr_offset));\n       t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ftop), ftop, t);\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -4535,28 +4534,27 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = fold_convert (TREE_TYPE (off), build_int_cst (NULL_TREE, rsize));\n       t = build2 (POSTDECREMENT_EXPR, TREE_TYPE (off), off, t);\n       t = fold_convert (sizetype, t);\n-      t = fold_convert (TREE_TYPE (top), t);\n+      t = fold_build1 (NEGATE_EXPR, sizetype, t);\n \n       /* [4] Emit code for: addr_rtx = top - off.  On big endian machines,\n \t the argument has RSIZE - SIZE bytes of leading padding.  */\n-      t = build2 (MINUS_EXPR, TREE_TYPE (top), top, t);\n+      t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (top), top, t);\n       if (BYTES_BIG_ENDIAN && rsize > size)\n \t{\n-\t  u = fold_convert (TREE_TYPE (t), build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t  rsize - size));\n-\t  t = build2 (PLUS_EXPR, TREE_TYPE (t), t, u);\n+\t  u = size_int (rsize - size);\n+\t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n       COND_EXPR_THEN (addr) = t;\n \n       if (osize > UNITS_PER_WORD)\n \t{\n \t  /* [9] Emit: ovfl += ((intptr_t) ovfl + osize - 1) & -osize.  */\n-\t  u = fold_convert (TREE_TYPE (ovfl),\n-\t\t\t    build_int_cst (NULL_TREE, osize - 1));\n-\t  t = build2 (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, u);\n-\t  u = fold_convert (TREE_TYPE (ovfl),\n-\t\t\t    build_int_cst (NULL_TREE, -osize));\n-\t  t = build2 (BIT_AND_EXPR, TREE_TYPE (ovfl), t, u);\n+\t  u = size_int (osize - 1);\n+\t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovfl), ovfl, u);\n+\t  t = fold_convert (sizetype, t);\n+\t  u = size_int (-osize);\n+\t  t = build2 (BIT_AND_EXPR, sizetype, t, u);\n+\t  t = fold_convert (TREE_TYPE (ovfl), t);\n \t  align = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovfl), ovfl, t);\n \t}\n       else\n@@ -4570,9 +4568,8 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = build2 (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl, u);\n       if (BYTES_BIG_ENDIAN && osize > size)\n \t{\n-\t  u = fold_convert (TREE_TYPE (t),\n-\t\t\t    build_int_cst (NULL_TREE, osize - size));\n-\t  t = build2 (PLUS_EXPR, TREE_TYPE (t), t, u);\n+\t  u = size_int (osize - size);\n+\t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n \n       /* String [9] and [10,11] together.  */"}, {"sha": "f22f26310b73995a049526a0792a4f006f6d62f7", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2046,6 +2046,7 @@ reloc_needed (tree exp)\n     case ADDR_EXPR:\n       return 1;\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       reloc = reloc_needed (TREE_OPERAND (exp, 0));\n@@ -5922,21 +5923,24 @@ hppa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \n       /* Args grow down.  Not handled by generic routines.  */\n \n-      u = fold_convert (valist_type, size_in_bytes (type));\n-      t = build2 (MINUS_EXPR, valist_type, valist, u);\n+      u = fold_convert (sizetype, size_in_bytes (type));\n+      u = fold_build1 (NEGATE_EXPR, sizetype, u);\n+      t = build2 (POINTER_PLUS_EXPR, valist_type, valist, u);\n \n       /* Copied from va-pa.h, but we probably don't need to align to\n \t word size, since we generate and preserve that invariant.  */\n-      u = build_int_cst (valist_type, (size > 4 ? -8 : -4));\n-      t = build2 (BIT_AND_EXPR, valist_type, t, u);\n+      u = size_int (size > 4 ? -8 : -4);\n+      t = fold_convert (sizetype, t);\n+      t = build2 (BIT_AND_EXPR, sizetype, t, u);\n+      t = fold_convert (valist_type, t);\n \n       t = build2 (MODIFY_EXPR, valist_type, valist, t);\n \n       ofs = (8 - size) % 4;\n       if (ofs != 0)\n \t{\n-\t  u = fold_convert (valist_type, size_int (ofs));\n-\t  t = build2 (PLUS_EXPR, valist_type, t, u);\n+\t  u = size_int (ofs);\n+\t  t = build2 (POINTER_PLUS_EXPR, valist_type, t, u);\n \t}\n \n       t = fold_convert (ptr, t);"}, {"sha": "035d655e971601ab80a01a7b3607d5079712b3d4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -6210,8 +6210,8 @@ rs6000_va_start (tree valist, rtx nextarg)\n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n   if (words != 0)\n-    t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t,\n-\t        build_int_cst (NULL_TREE, words * UNITS_PER_WORD));\n+    t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovf), t,\n+\t        size_int (words * UNITS_PER_WORD));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6227,8 +6227,8 @@ rs6000_va_start (tree valist, rtx nextarg)\n   /* Find the register save area.  */\n   t = make_tree (TREE_TYPE (sav), virtual_stack_vars_rtx);\n   if (cfun->machine->varargs_save_offset)\n-    t = build2 (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t        build_int_cst (NULL_TREE, cfun->machine->varargs_save_offset));\n+    t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (sav), t,\n+\t        size_int (cfun->machine->varargs_save_offset));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6367,12 +6367,12 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n \n       t = sav;\n       if (sav_ofs)\n-\tt = build2 (PLUS_EXPR, ptr_type_node, sav, size_int (sav_ofs));\n+\tt = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, size_int (sav_ofs));\n \n       u = build2 (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, size_int (n_reg));\n-      u = build1 (CONVERT_EXPR, integer_type_node, u);\n-      u = build2 (MULT_EXPR, integer_type_node, u, size_int (sav_scale));\n-      t = build2 (PLUS_EXPR, ptr_type_node, t, u);\n+      u = fold_convert (sizetype, u);\n+      u = build2 (MULT_EXPR, sizetype, u, size_int (sav_scale));\n+      t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, u);\n \n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n       gimplify_and_add (t, pre_p);\n@@ -6398,16 +6398,18 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   t = ovf;\n   if (align != 1)\n     {\n-      t = build2 (PLUS_EXPR, TREE_TYPE (t), t, size_int (align - 1));\n+      t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, size_int (align - 1));\n+      t = fold_convert (sizetype, t);\n       t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t  build_int_cst (NULL_TREE, -align));\n+\t\t  size_int (-align));\n+      t = fold_convert (TREE_TYPE (ovf), t);\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n   u = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (u, pre_p);\n \n-  t = build2 (PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n+  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (t), t, size_int (size));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n   gimplify_and_add (t, pre_p);\n "}, {"sha": "b13415cb679e2c9e099b7fbc44ab483c5bcb1bff", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -8002,7 +8002,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \tfprintf (stderr, \"va_start: n_gpr = %d, n_fpr = %d off %d\\n\",\n \t\t (int)n_gpr, (int)n_fpr, off);\n \n-      t = build2 (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_cst (NULL_TREE, off));\n+      t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (ovf), t, size_int (off));\n \n       t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (ovf), ovf, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n@@ -8014,8 +8014,8 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n       || (cfun->va_list_fpr_size && n_fpr < FP_ARG_NUM_REG))\n     {\n       t = make_tree (TREE_TYPE (sav), return_address_pointer_rtx);\n-      t = build2 (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t          build_int_cst (NULL_TREE, -RETURN_REGNUM * UNITS_PER_WORD));\n+      t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (sav), t,\n+\t          size_int (-RETURN_REGNUM * UNITS_PER_WORD));\n   \n       t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (sav), sav, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n@@ -8144,11 +8144,11 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n   t = build3 (COND_EXPR, void_type_node, t, u, NULL_TREE);\n   gimplify_and_add (t, pre_p);\n \n-  t = build2 (PLUS_EXPR, ptr_type_node, sav, \n-\t      fold_convert (ptr_type_node, size_int (sav_ofs)));\n+  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, sav, \n+\t      size_int (sav_ofs));\n   u = build2 (MULT_EXPR, TREE_TYPE (reg), reg, \n \t      fold_convert (TREE_TYPE (reg), size_int (sav_scale)));\n-  t = build2 (PLUS_EXPR, ptr_type_node, t, fold_convert (ptr_type_node, u));\n+  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, fold_convert (sizetype, u));\n \n   t = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (t, pre_p);\n@@ -8164,16 +8164,16 @@ s390_gimplify_va_arg (tree valist, tree type, tree *pre_p,\n \n   t = ovf;\n   if (size < UNITS_PER_WORD)\n-    t = build2 (PLUS_EXPR, ptr_type_node, t, \n-\t\tfold_convert (ptr_type_node, size_int (UNITS_PER_WORD - size)));\n+    t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, \n+\t\tsize_int (UNITS_PER_WORD - size));\n \n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n   u = build2 (GIMPLE_MODIFY_STMT, void_type_node, addr, t);\n   gimplify_and_add (u, pre_p);\n \n-  t = build2 (PLUS_EXPR, ptr_type_node, t, \n-\t      fold_convert (ptr_type_node, size_int (size)));\n+  t = build2 (POINTER_PLUS_EXPR, ptr_type_node, t, \n+\t      size_int (size));\n   t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, ovf, t);\n   gimplify_and_add (t, pre_p);\n "}, {"sha": "9d327847fe43f672dd61601cf9fa2848ff1e2c8f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -7049,7 +7049,8 @@ sh_va_start (tree valist, rtx nextarg)\n \t\t       valist, f_next_stack, NULL_TREE);\n \n   /* Call __builtin_saveregs.  */\n-  u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n+  u = make_tree (sizetype, expand_builtin_saveregs ());\n+  u = fold_convert (ptr_type_node, u);\n   t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -7059,8 +7060,8 @@ sh_va_start (tree valist, rtx nextarg)\n     nfp = 8 - nfp;\n   else\n     nfp = 0;\n-  u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nfp));\n+  u = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, u,\n+\t\t   size_int (UNITS_PER_WORD * nfp));\n   t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_fp_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -7074,8 +7075,8 @@ sh_va_start (tree valist, rtx nextarg)\n     nint = 4 - nint;\n   else\n     nint = 0;\n-  u = fold_build2 (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nint));\n+  u = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, u,\n+\t\t   size_int (UNITS_PER_WORD * nint));\n   t = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, next_o_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -7208,8 +7209,8 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  gimplify_and_add (tmp, pre_p);\n \t  tmp = next_fp_limit;\n \t  if (size > 4 && !is_double)\n-\t    tmp = build2 (PLUS_EXPR, TREE_TYPE (tmp), tmp,\n-\t\t\t  fold_convert (TREE_TYPE (tmp), size_int (4 - size)));\n+\t    tmp = build2 (POINTER_PLUS_EXPR, TREE_TYPE (tmp), tmp,\n+\t\t\t  size_int (4 - size));\n \t  tmp = build2 (GE_EXPR, boolean_type_node, next_fp_tmp, tmp);\n \t  cmp = build3 (COND_EXPR, void_type_node, tmp,\n \t\t        build1 (GOTO_EXPR, void_type_node, lab_false),\n@@ -7220,9 +7221,11 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t  if (TYPE_ALIGN (eff_type) > BITS_PER_WORD\n \t      || (is_double || size == 16))\n \t    {\n-\t      tmp = fold_convert (ptr_type_node, size_int (UNITS_PER_WORD));\n-\t      tmp = build2 (BIT_AND_EXPR, ptr_type_node, next_fp_tmp, tmp);\n-\t      tmp = build2 (PLUS_EXPR, ptr_type_node, next_fp_tmp, tmp);\n+\t      tmp = fold_convert (sizetype, next_fp_tmp);\n+\t      tmp = build2 (BIT_AND_EXPR, sizetype, tmp,\n+\t\t\t    size_int (UNITS_PER_WORD));\n+\t      tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t    next_fp_tmp, tmp);\n \t      tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node,\n \t\t  \t    next_fp_tmp, tmp);\n \t      gimplify_and_add (tmp, pre_p);\n@@ -7268,8 +7271,8 @@ sh_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \t}\n       else\n \t{\n-\t  tmp = fold_convert (ptr_type_node, size_int (rsize));\n-\t  tmp = build2 (PLUS_EXPR, ptr_type_node, next_o, tmp);\n+\t  tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node, next_o,\n+\t\t\tsize_int (rsize));\n \t  tmp = build2 (GT_EXPR, boolean_type_node, tmp, next_o_limit);\n \t  tmp = build3 (COND_EXPR, void_type_node, tmp,\n \t\t        build1 (GOTO_EXPR, void_type_node, lab_false),"}, {"sha": "85b41cbbcf2e1c769c252091c27d566f394fbe7f", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -5716,18 +5716,20 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   incr = valist;\n   if (align)\n     {\n-      incr = fold_build2 (PLUS_EXPR, ptr_type_node, incr,\n-\t\t\t  ssize_int (align - 1));\n-      incr = fold_build2 (BIT_AND_EXPR, ptr_type_node, incr,\n-\t\t\t  ssize_int (-align));\n+      incr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, incr,\n+\t\t\t  size_int (align - 1));\n+      incr = fold_convert (sizetype, incr);\n+      incr = fold_build2 (BIT_AND_EXPR, sizetype, incr,\n+\t\t\t  size_int (-align));\n+      incr = fold_convert (ptr_type_node, incr);\n     }\n \n   gimplify_expr (&incr, pre_p, post_p, is_gimple_val, fb_rvalue);\n   addr = incr;\n \n   if (BYTES_BIG_ENDIAN && size < rsize)\n-    addr = fold_build2 (PLUS_EXPR, ptr_type_node, incr,\n-\t\t\tssize_int (rsize - size));\n+    addr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, incr,\n+\t\t\tsize_int (rsize - size));\n \n   if (indirect)\n     {\n@@ -5755,7 +5757,7 @@ sparc_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   else\n     addr = fold_convert (ptrtype, addr);\n \n-  incr = fold_build2 (PLUS_EXPR, ptr_type_node, incr, ssize_int (rsize));\n+  incr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, incr, size_int (rsize));\n   incr = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, valist, incr);\n   gimplify_and_add (incr, post_p);\n "}, {"sha": "9318e2442559a03e7df89f855a28f1f3f895cebc", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -3115,18 +3115,17 @@ spu_va_start (tree valist, rtx nextarg)\n   /* Find the __args area.  */\n   t = make_tree (TREE_TYPE (args), nextarg);\n   if (current_function_pretend_args_size > 0)\n-    t = build2 (PLUS_EXPR, TREE_TYPE (args), t,\n-\t\tbuild_int_cst (integer_type_node, -STACK_POINTER_OFFSET));\n+    t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (args), t,\n+\t\tsize_int (-STACK_POINTER_OFFSET));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the __skip area.  */\n   t = make_tree (TREE_TYPE (skip), virtual_incoming_args_rtx);\n-  t = build2 (PLUS_EXPR, TREE_TYPE (skip), t,\n-\t      build_int_cst (integer_type_node,\n-\t\t\t     (current_function_pretend_args_size\n-\t\t\t      - STACK_POINTER_OFFSET)));\n+  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (skip), t,\n+\t      size_int (current_function_pretend_args_size\n+\t\t\t - STACK_POINTER_OFFSET));\n   t = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (skip), skip, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -3182,21 +3181,21 @@ spu_gimplify_va_arg_expr (tree valist, tree type, tree * pre_p,\n \n   /* build conditional expression to calculate addr. The expression\n      will be gimplified later. */\n-  paddedsize = fold_convert (ptr_type_node, size_int (rsize));\n-  tmp = build2 (PLUS_EXPR, ptr_type_node, args, paddedsize);\n+  paddedsize = size_int (rsize);\n+  tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node, args, paddedsize);\n   tmp = build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\tbuild2 (GT_EXPR, boolean_type_node, tmp, skip),\n \t\tbuild2 (LE_EXPR, boolean_type_node, args, skip));\n \n   tmp = build3 (COND_EXPR, ptr_type_node, tmp,\n-\t\tbuild2 (PLUS_EXPR, ptr_type_node, skip,\n-\t\t\tfold_convert (ptr_type_node, size_int (32))), args);\n+\t\tbuild2 (POINTER_PLUS_EXPR, ptr_type_node, skip,\n+\t\t\tsize_int (32)), args);\n \n   tmp = build2 (GIMPLE_MODIFY_STMT, ptr_type_node, addr, tmp);\n   gimplify_and_add (tmp, pre_p);\n \n   /* update VALIST.__args */\n-  tmp = build2 (PLUS_EXPR, ptr_type_node, addr, paddedsize);\n+  tmp = build2 (POINTER_PLUS_EXPR, ptr_type_node, addr, paddedsize);\n   tmp = build2 (GIMPLE_MODIFY_STMT, TREE_TYPE (args), args, tmp);\n   gimplify_and_add (tmp, pre_p);\n "}, {"sha": "5360fce063f43bf399d63595d825968b5f1995f3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1,3 +1,41 @@\n+2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* typeck.c (build_binary_op): For templates build the\n+\texpression in pieces to avoid the assert in build2_stat.\n+\t(get_member_function_from_ptrfunc):\n+\tChange over to using POINTER_PLUS_EXPR and convert\n+\tthe second operand to sizetype.\n+\t* typeck2.c (build_m_component_ref):  Likewise.\n+\t* init.c (expand_virtual_init): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t(build_new_1): Likewise.\n+\t(build_vec_delete_1): Likewise.\n+\t(build_vec_delete): Likewise.\n+\t* class.c (build_base_path): Likewise.\n+\t(build_base_path): Likewise.\n+\t(convert_to_base_statically): Likewise.\n+\t(fixed_type_or_null): Handle POINTER_PLUS_EXPR.\n+\t(get_vtbl_decl_for_binfo): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\t(dfs_accumulate_vtbl_inits): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t* call.c (build_special_member_call): Likewise.\n+\t* rtti.c (build_headof): Likewise.\n+\tUse sizetype instead of ptrdiff_type_node.\n+\t(tinfo_base_init): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t* except.c (expand_start_catch_block):  Do a\n+\tNEGATIVE and then a POINTER_PLUS_EXPR instead\n+\tof a MINUS_EXPR.\n+\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Convert\n+\tPLUS_EXPR on pointer types over to use\n+\tPOINTER_PLUS_EXPR and remove the conversion\n+\tto the pointer types.\n+\t* method.c (thunk_adjust): Use POINTER_PLUS_EXPR for\n+\tadding to a pointer type. Use size_int instead of\n+\tssize_int. Convert the index to sizetype before\n+\tadding it to the pointer.\n+\n 2007-06-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (DECL_VAR_MARKED_P): Remove.\n@@ -109,7 +147,7 @@\n \t(copy_fn_p): Don't consider constructors taking rvalue references\n \tto be copy constructors.\n \t(move_fn_p): New.\n-        * call.c (conversion): New \"rvaluedness_matches_p\" member.\n+\t* call.c (conversion): New \"rvaluedness_matches_p\" member.\n \t(convert_class_to_reference): Require reference type as first\n \tparameter instead of base type.\n \t(reference_binding): Add logic to handle rvalue references.\n@@ -161,7 +199,7 @@\n \n 2007-05-28  Andrew Pinski  <Andrew_pinski@playstation.sony.com>\n \n-        PR c++/31339\n+\tPR c++/31339\n \t* typeck.c (build_unary_op <case PREINCREMENT_EXPR,\n \tcase POSTINCREMENT_EXPR, case PREDECREMENT_EXPR,\n \tcase POSTDECREMENT_EXPR>): Return the error_mark_node\n@@ -1072,7 +1110,7 @@\n \tPR C++/30158\n \t* semantics.c (finish_stmt_expr_expr): Set TREE_TYPE of the \n \tstatement expression if we had an error mark node.\n-\t        \n+\n 2007-02-15  Sandra Loosemore  <sandra@codesourcery.com>\n \t    Brooks Moses  <brooks.moses@codesourcery.com>\n \t    Lee Millward  <lee.millward@codesourcery.com>"}, {"sha": "7df0cad53e5aca546629c76021fbb9d2e329f79d", "filename": "gcc/cp/ChangeLog.ptr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog.ptr?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,68 @@\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* init.c (build_new_1): Use fold_build1 instead\n+\tof build1 for NEGATE_EXPR.\n+\t(build_vec_delete_1): Likewise.\n+\t* class.c (build_base_path): Likewise.\n+\t* except.c (expand_start_catch_block): Likewise.\n+\n+2007-05-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* typeck.c (build_binary_op): Add a comment on why creating\n+\tthe tree in pieces while processing templates.\n+\n+2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* except.c (expand_start_catch_block):  Do a\n+\tNEGATIVE and then a POINTER_PLUS_EXPR instead\n+\tof a MINUS_EXPR.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* cp-gimplify.c (cxx_omp_clause_apply_fn): Convert\n+\tPLUS_EXPR on pointer types over to use\n+\tPOINTER_PLUS_EXPR and remove the conversion\n+\tto the pointer types.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* typeck.c (build_unary_op): Remove code that used to\n+\thandle non lvalue increments/decrements as we now error\n+\tout all ways.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc):\n+\tChange over to using POINTER_PLUS_EXPR and convert\n+\tthe second operand to sizetype.\n+\t* typeck2.c (build_m_component_ref): Likewise.\n+\t* rtti.c (build_headof): Use sizetype instead of\n+\tptrdiff_type_node.\n+\n+2007-05-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* method.c (thunk_adjust): Use POINTER_PLUS_EXPR for\n+\tadding to a pointer type. Use size_int instead of\n+\tssize_int. Convert the index to sizetype before\n+\tadding it to the pointer.\n+\n+2006-11-23  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* typeck.c (build_binary_op): For templates build the\n+\texpression in pieces to avoid the assert in build2_stat.\n+\t* init.c (expand_virtual_init): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t(build_new_1): Likewise.\n+\t(build_vec_delete_1): Likewise.\n+\t(build_vec_delete): Likewise.\n+\t* class.c (build_base_path): Likewise.\n+\t(build_base_path): Likewise.\n+\t(convert_to_base_statically): Likewise.\n+\t(fixed_type_or_null): Handle POINTER_PLUS_EXPR.\n+\t(get_vtbl_decl_for_binfo): Handle POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR.\n+\t(dfs_accumulate_vtbl_inits): Create a POINTER_PLUS_EXPR\n+\tinstead of PLUS_EXPR for pointers.\n+\t* call.c (build_special_member_call): Likewise.\n+\t* rtti.c (build_headof): Likewise.\n+\t(tinfo_base_init): Likewise."}, {"sha": "86d5fbccd10c124f7d30dc0207aed418b35d5d75", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -5321,7 +5321,7 @@ build_special_member_call (tree instance, tree name, tree args,\n \t\t    current_vtt_parm,\n \t\t    vtt);\n       gcc_assert (BINFO_SUBVTT_INDEX (binfo));\n-      sub_vtt = build2 (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n+      sub_vtt = build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtt), vtt,\n \t\t\tBINFO_SUBVTT_INDEX (binfo));\n \n       args = tree_cons (NULL_TREE, sub_vtt, args);"}, {"sha": "67cf63db1bd025fa20c00e7824d882f6166afd23", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -367,8 +367,8 @@ build_base_path (enum tree_code code,\n \tv_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (expr)));\n \n-      v_offset = build2 (PLUS_EXPR, TREE_TYPE (v_offset),\n-\t\t\t v_offset,  BINFO_VPTR_FIELD (v_binfo));\n+      v_offset = build2 (POINTER_PLUS_EXPR, TREE_TYPE (v_offset),\n+\t\t\t v_offset, fold_convert (sizetype, BINFO_VPTR_FIELD (v_binfo)));\n       v_offset = build1 (NOP_EXPR,\n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n@@ -406,7 +406,12 @@ build_base_path (enum tree_code code,\n   expr = build1 (NOP_EXPR, ptr_target_type, expr);\n \n   if (!integer_zerop (offset))\n-    expr = build2 (code, ptr_target_type, expr, offset);\n+    {\n+      offset = fold_convert (sizetype, offset);\n+      if (code == MINUS_EXPR)\n+\toffset = fold_build1 (NEGATE_EXPR, sizetype, offset);\n+      expr = build2 (POINTER_PLUS_EXPR, ptr_target_type, expr, offset);\n+    }\n   else\n     null_test = NULL;\n \n@@ -539,8 +544,8 @@ convert_to_base_statically (tree expr, tree base)\n       gcc_assert (!processing_template_decl);\n       expr = build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1);\n       if (!integer_zerop (BINFO_OFFSET (base)))\n-        expr = fold_build2 (PLUS_EXPR, pointer_type, expr,\n-\t\t\t    fold_convert (pointer_type, BINFO_OFFSET (base)));\n+        expr = fold_build2 (POINTER_PLUS_EXPR, pointer_type, expr,\n+\t\t\t    fold_convert (sizetype, BINFO_OFFSET (base)));\n       expr = fold_convert (build_pointer_type (BINFO_TYPE (base)), expr);\n       expr = build_fold_indirect_ref (expr);\n     }\n@@ -5276,6 +5281,7 @@ fixed_type_or_null (tree instance, int *nonnull, int *cdtorp)\n \t}\n       return RECUR (TREE_OPERAND (instance, 0));\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       if (TREE_CODE (TREE_OPERAND (instance, 0)) == ADDR_EXPR)\n@@ -6340,7 +6346,7 @@ get_vtbl_decl_for_binfo (tree binfo)\n   tree decl;\n \n   decl = BINFO_VTABLE (binfo);\n-  if (decl && TREE_CODE (decl) == PLUS_EXPR)\n+  if (decl && TREE_CODE (decl) == POINTER_PLUS_EXPR)\n     {\n       gcc_assert (TREE_CODE (TREE_OPERAND (decl, 0)) == ADDR_EXPR);\n       decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n@@ -7126,7 +7132,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n       index = size_binop (MULT_EXPR,\n \t\t\t  TYPE_SIZE_UNIT (vtable_entry_type),\n \t\t\t  index);\n-      vtbl = build2 (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n+      vtbl = build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n     }\n \n   if (ctor_vtbl_p)"}, {"sha": "9d9cc4d388a0398c535ce588cc6fa5512ecac266", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -802,8 +802,7 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n \tstart2 = build_fold_addr_expr (start2);\n \n       end1 = TYPE_SIZE_UNIT (TREE_TYPE (arg1));\n-      end1 = fold_convert (TREE_TYPE (start1), end1);\n-      end1 = build2 (PLUS_EXPR, TREE_TYPE (start1), start1, end1);\n+      end1 = build2 (POINTER_PLUS_EXPR, TREE_TYPE (start1), start1, end1);\n \n       p1 = create_tmp_var (TREE_TYPE (start1), NULL);\n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p1, start1);\n@@ -830,15 +829,15 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n       t = build_call_a (fn, i, argarray);\n       append_to_statement_list (t, &ret);\n \n-      t = fold_convert (TREE_TYPE (p1), TYPE_SIZE_UNIT (inner_type));\n-      t = build2 (PLUS_EXPR, TREE_TYPE (p1), p1, t);\n+      t = TYPE_SIZE_UNIT (inner_type);\n+      t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (p1), p1, t);\n       t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p1, t);\n       append_to_statement_list (t, &ret);\n \n       if (arg2)\n \t{\n-\t  t = fold_convert (TREE_TYPE (p2), TYPE_SIZE_UNIT (inner_type));\n-\t  t = build2 (PLUS_EXPR, TREE_TYPE (p2), p2, t);\n+\t  t = TYPE_SIZE_UNIT (inner_type);\n+\t  t = build2 (POINTER_PLUS_EXPR, TREE_TYPE (p2), p2, t);\n \t  t = build2 (GIMPLE_MODIFY_STMT, void_type_node, p2, t);\n \t  append_to_statement_list (t, &ret);\n \t}"}, {"sha": "887b0f17ef0c680c29d9da1c2739a93b23215fe7", "filename": "gcc/cp/except.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -426,8 +426,9 @@ expand_start_catch_block (tree decl)\n \t generic exception header.  */\n       exp = build_exc_ptr ();\n       exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n-      exp = build2 (MINUS_EXPR, TREE_TYPE (exp), exp,\n-\t\t    TYPE_SIZE_UNIT (TREE_TYPE (exp)));\n+      exp = build2 (POINTER_PLUS_EXPR, TREE_TYPE (exp), exp,\n+\t\t    fold_build1 (NEGATE_EXPR, sizetype,\n+\t\t\t \t TYPE_SIZE_UNIT (TREE_TYPE (exp))));\n       exp = build_indirect_ref (exp, NULL);\n       initialize_handler_parm (decl, exp);\n       return type;"}, {"sha": "6ca072ca5d467ae3e1e8fcce544522d6397fc656", "filename": "gcc/cp/init.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -786,7 +786,7 @@ expand_virtual_init (tree binfo, tree decl)\n \n       /* Compute the value to use, when there's a VTT.  */\n       vtt_parm = current_vtt_parm;\n-      vtbl2 = build2 (PLUS_EXPR,\n+      vtbl2 = build2 (POINTER_PLUS_EXPR,\n \t\t      TREE_TYPE (vtt_parm),\n \t\t      vtt_parm,\n \t\t      vtt_index);\n@@ -1919,14 +1919,15 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       tree cookie_ptr;\n \n       /* Adjust so we're pointing to the start of the object.  */\n-      data_addr = get_target_expr (build2 (PLUS_EXPR, full_pointer_type,\n+      data_addr = get_target_expr (build2 (POINTER_PLUS_EXPR, full_pointer_type,\n \t\t\t\t\t   alloc_node, cookie_size));\n \n       /* Store the number of bytes allocated so that we can know how\n \t many elements to destroy later.  We use the last sizeof\n \t (size_t) bytes to store the number of elements.  */\n-      cookie_ptr = build2 (MINUS_EXPR, build_pointer_type (sizetype),\n-\t\t\t   data_addr, size_in_bytes (sizetype));\n+      cookie_ptr = fold_build1 (NEGATE_EXPR, sizetype, size_in_bytes (sizetype));\n+      cookie_ptr = build2 (POINTER_PLUS_EXPR, build_pointer_type (sizetype),\n+\t\t\t   data_addr, cookie_ptr);\n       cookie = build_indirect_ref (cookie_ptr, NULL);\n \n       cookie_expr = build2 (MODIFY_EXPR, sizetype, cookie, nelts);\n@@ -2301,6 +2302,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n      executing any other code in the loop.\n      This is also the containing expression returned by this function.  */\n   tree controller = NULL_TREE;\n+  tree tmp;\n \n   /* We should only have 1-D arrays here.  */\n   gcc_assert (TREE_CODE (type) != ARRAY_TYPE);\n@@ -2314,7 +2316,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   tbase = create_temporary_var (ptype);\n   tbase_init = build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t  fold_build2 (PLUS_EXPR, ptype,\n+\t\t\t\t  fold_build2 (POINTER_PLUS_EXPR, ptype,\n \t\t\t\t\t       base,\n \t\t\t\t\t       virtual_size));\n   DECL_REGISTER (tbase) = 1;\n@@ -2325,9 +2327,10 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   body = build1 (EXIT_EXPR, void_type_node,\n \t\t build2 (EQ_EXPR, boolean_type_node, tbase,\n \t\t\t fold_convert (ptype, base)));\n+  tmp = fold_build1 (NEGATE_EXPR, sizetype, size_exp);\n   body = build_compound_expr\n     (body, build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t      build2 (MINUS_EXPR, ptype, tbase, size_exp)));\n+\t\t\t      build2 (POINTER_PLUS_EXPR, ptype, tbase, tmp)));\n   body = build_compound_expr\n     (body, build_delete (ptype, tbase, sfk_complete_destructor,\n \t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1));\n@@ -3048,10 +3051,11 @@ build_vec_delete (tree base, tree maxindex,\n \t  base = TARGET_EXPR_SLOT (base_init);\n \t}\n       type = strip_array_types (TREE_TYPE (type));\n-      cookie_addr = build2 (MINUS_EXPR,\n+      cookie_addr = fold_build1 (NEGATE_EXPR, sizetype, TYPE_SIZE_UNIT (sizetype));\n+      cookie_addr = build2 (POINTER_PLUS_EXPR,\n \t\t\t    build_pointer_type (sizetype),\n \t\t\t    base,\n-\t\t\t    TYPE_SIZE_UNIT (sizetype));\n+\t\t\t    cookie_addr);\n       maxindex = build_indirect_ref (cookie_addr, NULL);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)"}, {"sha": "03f490884516958cb84b1b88c1ca44da7044bbfb", "filename": "gcc/cp/method.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -220,8 +220,8 @@ thunk_adjust (tree ptr, bool this_adjusting,\n {\n   if (this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t       ssize_int (fixed_offset));\n+    ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t       size_int (fixed_offset));\n \n   /* If there's a virtual offset, look up that value in the vtable and\n      adjust the pointer again.  */\n@@ -238,17 +238,19 @@ thunk_adjust (tree ptr, bool this_adjusting,\n       /* Form the vtable address.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Find the entry with the vcall offset.  */\n-      vtable = build2 (PLUS_EXPR, TREE_TYPE (vtable), vtable, virtual_offset);\n+      vtable = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtable), vtable,\n+\t\t       fold_convert (sizetype, virtual_offset));\n       /* Get the offset itself.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Adjust the `this' pointer.  */\n-      ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr, vtable);\n+      ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t\t fold_convert (sizetype, vtable));\n     }\n \n   if (!this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold_build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t       ssize_int (fixed_offset));\n+    ptr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t       size_int (fixed_offset));\n \n   return ptr;\n }"}, {"sha": "2870b9ff41525e1411375c36d1c75dd09fd1aed6", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -180,8 +180,8 @@ build_headof (tree exp)\n \n   type = build_qualified_type (ptr_type_node,\n \t\t\t       cp_type_quals (TREE_TYPE (exp)));\n-  return build2 (PLUS_EXPR, type, exp,\n-\t\t convert_to_integer (ptrdiff_type_node, offset));\n+  return build2 (POINTER_PLUS_EXPR, type, exp,\n+\t\t convert_to_integer (sizetype, offset));\n }\n \n /* Get a bad_cast node for the program to throw...\n@@ -856,7 +856,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \n       /* We need to point into the middle of the vtable.  */\n       vtable_ptr = build2\n-\t(PLUS_EXPR, TREE_TYPE (vtable_ptr), vtable_ptr,\n+\t(POINTER_PLUS_EXPR, TREE_TYPE (vtable_ptr), vtable_ptr,\n \t size_binop (MULT_EXPR,\n \t\t     size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),\n \t\t     TYPE_SIZE_UNIT (vtable_entry_type)));"}, {"sha": "7985d853ed19cf9a7192e51ef1ff56422308835d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2627,8 +2627,8 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \t    return error_mark_node;\n \t}\n       /* ...and then the delta in the PMF.  */\n-      instance_ptr = build2 (PLUS_EXPR, TREE_TYPE (instance_ptr),\n-\t\t\t     instance_ptr, delta);\n+      instance_ptr = build2 (POINTER_PLUS_EXPR, TREE_TYPE (instance_ptr),\n+\t\t\t     instance_ptr, fold_convert (sizetype, delta));\n \n       /* Hand back the adjusted 'this' argument to our caller.  */\n       *instance_ptrptr = instance_ptr;\n@@ -2639,7 +2639,8 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       vtbl = build_indirect_ref (vtbl, NULL);\n \n       /* Finally, extract the function pointer from the vtable.  */\n-      e2 = fold_build2 (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx);\n+      e2 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n+\t\t\tfold_convert (sizetype, idx));\n       e2 = build_indirect_ref (e2, NULL);\n       TREE_CONSTANT (e2) = 1;\n       TREE_INVARIANT (e2) = 1;\n@@ -3578,9 +3579,17 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* If we're in a template, the only thing we need to know is the\n      RESULT_TYPE.  */\n   if (processing_template_decl)\n-    return build2 (resultcode,\n-\t\t   build_type ? build_type : result_type,\n-\t\t   op0, op1);\n+    {\n+      /* Since the middle-end checks the type when doing a build2, we\n+\t need to build the tree in pieces.  This built tree will never\n+\t get out of the front-end as we replace it when instantiating\n+\t the template.  */\n+      tree tmp = build2 (resultcode,\n+\t\t\t build_type ? build_type : result_type,\n+\t\t\t NULL_TREE, op1);\n+      TREE_OPERAND (tmp, 0) = op0;\n+      return tmp;\n+    }\n \n   if (arithmetic_types_p)\n     {"}, {"sha": "66c8b9c4febc42bb4ac7bd76720c22bef7e31507", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1277,8 +1277,8 @@ build_m_component_ref (tree datum, tree component)\n \n       /* Build an expression for \"object + offset\" where offset is the\n \t value stored in the pointer-to-data-member.  */\n-      datum = build2 (PLUS_EXPR, build_pointer_type (type),\n-\t\t      datum, build_nop (ptrdiff_type_node, component));\n+      datum = build2 (POINTER_PLUS_EXPR, build_pointer_type (type),\n+\t\t      datum, build_nop (sizetype, component));\n       return build_indirect_ref (datum, 0);\n     }\n   else"}, {"sha": "4134007c24f9b1c063210b97a1b369c0b8024b24", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1918,6 +1918,7 @@ This macro returns the attributes on the type @var{type}.\n @tindex TRUTH_AND_EXPR\n @tindex TRUTH_OR_EXPR\n @tindex TRUTH_XOR_EXPR\n+@tindex POINTER_PLUS_EXPR\n @tindex PLUS_EXPR\n @tindex MINUS_EXPR\n @tindex MULT_EXPR\n@@ -2292,6 +2293,12 @@ generate these expressions anyhow, if it can tell that strictness does\n not matter.  The type of the operands and that of the result are\n always of @code{BOOLEAN_TYPE} or @code{INTEGER_TYPE}.\n \n+@itemx POINTER_PLUS_EXPR\n+This node represents pointer arithmetic.  The first operand is always\n+a pointer/reference type.  The second operand is always an unsigned\n+integer type compatible with sizetype.  This is the only binary\n+arithmetic operand that can operate on pointer types.\n+\n @itemx PLUS_EXPR\n @itemx MINUS_EXPR\n @itemx MULT_EXPR"}, {"sha": "9bd7235356e87557b6243539dfdec59b29acb53a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -9442,6 +9442,7 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       op = (TYPE_UNSIGNED (TREE_TYPE (loc)) ? DW_OP_shr : DW_OP_shra);\n       goto do_binop;\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (TREE_CODE (TREE_OPERAND (loc, 1)) == INTEGER_CST\n \t  && host_integerp (TREE_OPERAND (loc, 1), 0))"}, {"sha": "3f0caf117d53261d237e358180e11b3662c85aad", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -8036,7 +8036,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n       return op0;\n \n+    case POINTER_PLUS_EXPR: \n+      /* Even though the sizetype mode and the pointer's mode can be different\n+         expand is able to handle this correctly and get the correct result out \n+         of the PLUS_EXPR code.  */\n     case PLUS_EXPR:\n+\n       /* Check if this is a case for multiplication and addition.  */\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_OPERAND (exp, 0)) == MULT_EXPR)\n@@ -9255,7 +9260,7 @@ string_constant (tree arg, tree *ptr_offset)\n       else\n \treturn 0;\n     }\n-  else if (TREE_CODE (arg) == PLUS_EXPR)\n+  else if (TREE_CODE (arg) == PLUS_EXPR || TREE_CODE (arg) == POINTER_PLUS_EXPR)\n     {\n       tree arg0 = TREE_OPERAND (arg, 0);\n       tree arg1 = TREE_OPERAND (arg, 1);"}, {"sha": "9c6690ccfaaf2ee06a3279c542dde362344933a3", "filename": "gcc/fold-const.c", "status": "modified", "additions": 135, "deletions": 47, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -4439,6 +4439,20 @@ build_range_check (tree type, tree exp, int in_p, tree low, tree high)\n \n   value = const_binop (MINUS_EXPR, high, low, 0);\n \n+\n+  if (POINTER_TYPE_P (etype))\n+    {\n+      if (value != 0 && !TREE_OVERFLOW (value))\n+\t{\n+\t  low = fold_convert (sizetype, low);\n+\t  low = fold_build1 (NEGATE_EXPR, sizetype, low);\n+          return build_range_check (type,\n+\t\t\t     \t    fold_build2 (POINTER_PLUS_EXPR, etype, exp, low),\n+\t\t\t            1, build_int_cst (etype, 0), value);\n+\t}\n+      return 0;\n+    }\n+\n   if (value != 0 && !TREE_OVERFLOW (value))\n     return build_range_check (type,\n \t\t\t      fold_build2 (MINUS_EXPR, etype, exp, low),\n@@ -5992,29 +6006,28 @@ constant_boolean_node (int value, tree type)\n    offset is set to NULL_TREE.  Base will be canonicalized to\n    something you can get the element type from using\n    TREE_TYPE (TREE_TYPE (base)).  Offset will be the offset\n-   in bytes to the base.  */\n+   in bytes to the base in sizetype.  */\n \n static bool\n extract_array_ref (tree expr, tree *base, tree *offset)\n {\n   /* One canonical form is a PLUS_EXPR with the first\n      argument being an ADDR_EXPR with a possible NOP_EXPR\n      attached.  */\n-  if (TREE_CODE (expr) == PLUS_EXPR)\n+  if (TREE_CODE (expr) == POINTER_PLUS_EXPR)\n     {\n       tree op0 = TREE_OPERAND (expr, 0);\n       tree inner_base, dummy1;\n       /* Strip NOP_EXPRs here because the C frontends and/or\n-\t folders present us (int *)&x.a + 4B possibly.  */\n+\t folders present us (int *)&x.a p+ 4 possibly.  */\n       STRIP_NOPS (op0);\n       if (extract_array_ref (op0, &inner_base, &dummy1))\n \t{\n \t  *base = inner_base;\n-\t  if (dummy1 == NULL_TREE)\n-\t    *offset = TREE_OPERAND (expr, 1);\n-\t  else\n-\t    *offset = fold_build2 (PLUS_EXPR, TREE_TYPE (expr),\n-\t\t\t\t   dummy1, TREE_OPERAND (expr, 1));\n+\t  *offset = fold_convert (sizetype, TREE_OPERAND (expr, 1));\n+\t  if (dummy1 != NULL_TREE)\n+\t    *offset = fold_build2 (PLUS_EXPR, sizetype,\n+\t\t\t\t   dummy1, *offset);\n \t  return true;\n \t}\n     }\n@@ -6032,6 +6045,7 @@ extract_array_ref (tree expr, tree *base, tree *offset)\n \t  *base = TREE_OPERAND (op0, 0);\n \t  *offset = fold_build2 (MULT_EXPR, TREE_TYPE (idx), idx,\n \t\t\t\t array_ref_element_size (op0)); \n+\t  *offset = fold_convert (sizetype, *offset);\n \t}\n       else\n \t{\n@@ -6866,22 +6880,25 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n   return fold_build2 (code, type, arg0_inner, arg1);\n }\n \n-/* Tries to replace &a[idx] CODE s * delta with &a[idx CODE delta], if s is\n+/* Tries to replace &a[idx] p+ s * delta with &a[idx + delta], if s is\n    step of the array.  Reconstructs s and delta in the case of s * delta\n    being an integer constant (and thus already folded).\n    ADDR is the address. MULT is the multiplicative expression.\n    If the function succeeds, the new address expression is returned.  Otherwise\n    NULL_TREE is returned.  */\n \n static tree\n-try_move_mult_to_index (enum tree_code code, tree addr, tree op1)\n+try_move_mult_to_index (tree addr, tree op1)\n {\n   tree s, delta, step;\n   tree ref = TREE_OPERAND (addr, 0), pref;\n   tree ret, pos;\n   tree itype;\n   bool mdim = false;\n \n+  /*  Strip the nops that might be added when converting op1 to sizetype. */\n+  STRIP_NOPS (op1);\n+\n   /* Canonicalize op1 into a possibly non-constant delta\n      and an INTEGER_CST s.  */\n   if (TREE_CODE (op1) == MULT_EXPR)\n@@ -6958,7 +6975,7 @@ try_move_mult_to_index (enum tree_code code, tree addr, tree op1)\n \t\t  || TREE_CODE (TYPE_MAX_VALUE (itype)) != INTEGER_CST)\n \t\tcontinue;\n \n-\t      tmp = fold_binary (code, itype,\n+\t      tmp = fold_binary (PLUS_EXPR, itype,\n \t\t\t\t fold_convert (itype,\n \t\t\t\t\t       TREE_OPERAND (ref, 1)),\n \t\t\t\t fold_convert (itype, delta));\n@@ -6991,7 +7008,7 @@ try_move_mult_to_index (enum tree_code code, tree addr, tree op1)\n       pos = TREE_OPERAND (pos, 0);\n     }\n \n-  TREE_OPERAND (pos, 1) = fold_build2 (code, itype,\n+  TREE_OPERAND (pos, 1) = fold_build2 (PLUS_EXPR, itype,\n \t\t\t\t       fold_convert (itype,\n \t\t\t\t\t\t     TREE_OPERAND (pos, 1)),\n \t\t\t\t       fold_convert (itype, delta));\n@@ -7037,9 +7054,18 @@ fold_to_nonsharp_ineq_using_bound (tree ineq, tree bound)\n   if (TREE_TYPE (a1) != typea)\n     return NULL_TREE;\n \n-  diff = fold_build2 (MINUS_EXPR, typea, a1, a);\n-  if (!integer_onep (diff))\n-    return NULL_TREE;\n+  if (POINTER_TYPE_P (typea))\n+    {\n+      /* Convert the pointer types into integer before taking the difference.  */\n+      tree ta = fold_convert (ssizetype, a);\n+      tree ta1 = fold_convert (ssizetype, a1);\n+      diff = fold_binary (MINUS_EXPR, ssizetype, ta1, ta);\n+    }\n+  else\n+   diff = fold_binary (MINUS_EXPR, typea, a1, a);\n+\n+  if (!diff || !integer_onep (diff))\n+   return NULL_TREE;\n \n   return fold_build2 (GE_EXPR, type, a, y);\n }\n@@ -7830,11 +7856,11 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t    }\n \t}\n \n-      /* Convert (T1)(X op Y) into ((T1)X op (T1)Y), for pointer type,\n+      /* Convert (T1)(X p+ Y) into ((T1)X p+ Y), for pointer type,\n          when one of the new casts will fold away. Conservatively we assume\n-\t that this happens when X or Y is NOP_EXPR or Y is INTEGER_CST.  */\n-      if (POINTER_TYPE_P (type) && POINTER_TYPE_P (TREE_TYPE (arg0))\n-\t  && BINARY_CLASS_P (arg0)\n+\t that this happens when X or Y is NOP_EXPR or Y is INTEGER_CST. */\n+      if (POINTER_TYPE_P (type)\n+\t  && TREE_CODE (arg0) == POINTER_PLUS_EXPR\n \t  && (TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n \t      || TREE_CODE (TREE_OPERAND (arg0, 0)) == NOP_EXPR\n \t      || TREE_CODE (TREE_OPERAND (arg0, 1)) == NOP_EXPR))\n@@ -7843,7 +7869,7 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t  tree arg01 = TREE_OPERAND (arg0, 1);\n \n \t  return fold_build2 (TREE_CODE (arg0), type, fold_convert (type, arg00),\n-\t\t\t      fold_convert (type, arg01));\n+\t\t\t      fold_convert (sizetype, arg01));\n \t}\n \n       /* Convert (T1)(~(T2)X) into ~(T1)X if T1 and T2 are integral types\n@@ -9066,7 +9092,68 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n   switch (code)\n     {\n+    case POINTER_PLUS_EXPR:\n+      /* 0 +p index -> (type)index */\n+      if (integer_zerop (arg0))\n+\treturn non_lvalue (fold_convert (type, arg1));\n+\n+      /* PTR +p 0 -> PTR */\n+      if (integer_zerop (arg1))\n+\treturn non_lvalue (fold_convert (type, arg0));\n+\n+      /* INT +p INT -> (PTR)(INT + INT).  Stripping types allows for this. */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n+\t   && INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n+        return fold_convert (type, fold_build2 (PLUS_EXPR, sizetype,\n+\t\t\t\t\t\tfold_convert (sizetype, arg1),\n+\t\t\t\t\t\tfold_convert (sizetype, arg0)));\n+\n+      /* index +p PTR -> PTR +p index */\n+      if (POINTER_TYPE_P (TREE_TYPE (arg1))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n+        return fold_build2 (POINTER_PLUS_EXPR, type,\n+\t                    fold_convert (type, arg1), fold_convert (sizetype, arg0));\n+\n+      /* (PTR +p B) +p A -> PTR +p (B + A) */\n+      if (TREE_CODE (arg0) == POINTER_PLUS_EXPR)\n+\t{\n+\t  tree inner;\n+\t  tree arg01 = fold_convert (sizetype, TREE_OPERAND (arg0, 1));\n+\t  tree arg00 = TREE_OPERAND (arg0, 0);\n+\t  inner = fold_build2 (PLUS_EXPR, sizetype, arg01, fold_convert (sizetype, arg1));\n+\t  return fold_build2 (POINTER_PLUS_EXPR, type, arg00, inner);\n+\t}\n+\n+      /* PTR_CST +p CST -> CST1 */\n+      if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n+\treturn fold_build2 (PLUS_EXPR, type, arg0, fold_convert (type, arg1));\n+\n+     /* Try replacing &a[i1] +p c * i2 with &a[i1 + i2], if c is step\n+\tof the array.  Loop optimizer sometimes produce this type of\n+\texpressions.  */\n+      if (TREE_CODE (arg0) == ADDR_EXPR)\n+\t{\n+\t  tem = try_move_mult_to_index (arg0, fold_convert (sizetype, arg1));\n+\t  if (tem)\n+\t    return fold_convert (type, tem);\n+\t}\n+\n+      return NULL_TREE;\n     case PLUS_EXPR:\n+      /* PTR + INT -> (INT)(PTR p+ INT) */\n+      if (POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n+\treturn fold_convert (type, fold_build2 (POINTER_PLUS_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (arg0),\n+\t\t\t\t\t\targ0,\n+\t\t\t\t\t\tfold_convert (sizetype, arg1)));\n+      /* INT + PTR -> (INT)(PTR p+ INT) */\n+      if (POINTER_TYPE_P (TREE_TYPE (arg1))\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n+\treturn fold_convert (type, fold_build2 (POINTER_PLUS_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (arg1),\n+\t\t\t\t\t\targ1,\n+\t\t\t\t\t\tfold_convert (sizetype, arg0)));\n       /* A + (-B) -> A - B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold_build2 (MINUS_EXPR, type,\n@@ -9173,22 +9260,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t\t fold_convert (type,\n \t\t\t\t\t\t\t       parg1)));\n \t    }\n-\n-\t  /* Try replacing &a[i1] + c * i2 with &a[i1 + i2], if c is step\n-\t     of the array.  Loop optimizer sometimes produce this type of\n-\t     expressions.  */\n-\t  if (TREE_CODE (arg0) == ADDR_EXPR)\n-\t    {\n-\t      tem = try_move_mult_to_index (PLUS_EXPR, arg0, arg1);\n-\t      if (tem)\n-\t\treturn fold_convert (type, tem);\n-\t    }\n-\t  else if (TREE_CODE (arg1) == ADDR_EXPR)\n-\t    {\n-\t      tem = try_move_mult_to_index (PLUS_EXPR, arg1, arg0);\n-\t      if (tem)\n-\t\treturn fold_convert (type, tem);\n-\t    }\n \t}\n       else\n \t{\n@@ -9465,6 +9536,31 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       return NULL_TREE;\n \n     case MINUS_EXPR:\n+      /* Pointer simplifications for subtraction, simple reassociations. */\n+      if (POINTER_TYPE_P (TREE_TYPE (arg1)) && POINTER_TYPE_P (TREE_TYPE (arg0)))\n+\t{\n+\t  /* (PTR0 p+ A) - (PTR1 p+ B) -> (PTR0 - PTR1) + (A - B) */\n+\t  if (TREE_CODE (arg0) == POINTER_PLUS_EXPR\n+\t      && TREE_CODE (arg1) == POINTER_PLUS_EXPR)\n+\t    {\n+\t      tree arg00 = fold_convert (type, TREE_OPERAND (arg0, 0));\n+\t      tree arg01 = fold_convert (type, TREE_OPERAND (arg0, 1));\n+\t      tree arg10 = fold_convert (type, TREE_OPERAND (arg1, 0));\n+\t      tree arg11 = fold_convert (type, TREE_OPERAND (arg1, 1));\n+\t      return fold_build2 (PLUS_EXPR, type,\n+\t\t\t\t  fold_build2 (MINUS_EXPR, type, arg00, arg10),\n+\t\t\t\t  fold_build2 (MINUS_EXPR, type, arg01, arg11));\n+\t    }\n+\t  /* (PTR0 p+ A) - PTR1 -> (PTR0 - PTR1) + A, assuming PTR0 - PTR1 simplifies. */\n+\t  else if (TREE_CODE (arg0) == POINTER_PLUS_EXPR)\n+\t    {\n+\t      tree arg00 = fold_convert (type, TREE_OPERAND (arg0, 0));\n+\t      tree arg01 = fold_convert (type, TREE_OPERAND (arg0, 1));\n+\t      tree tmp = fold_binary (MINUS_EXPR, type, arg00, fold_convert (type, arg1));\n+\t      if (tmp)\n+\t        return fold_build2 (PLUS_EXPR, type, tmp, arg01);\n+\t    }\n+\t}\n       /* A - (-B) -> A + B */\n       if (TREE_CODE (arg1) == NEGATE_EXPR)\n \treturn fold_build2 (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0));\n@@ -9634,16 +9730,6 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \t}\n \n-      /* Try replacing &a[i1] - c * i2 with &a[i1 - i2], if c is step\n-\t of the array.  Loop optimizer sometimes produce this type of\n-\t expressions.  */\n-      if (TREE_CODE (arg0) == ADDR_EXPR)\n-\t{\n-\t  tem = try_move_mult_to_index (MINUS_EXPR, arg0, arg1);\n-\t  if (tem)\n-\t    return fold_convert (type, tem);\n-\t}\n-\n       if (flag_unsafe_math_optimizations\n \t  && (TREE_CODE (arg0) == RDIV_EXPR || TREE_CODE (arg0) == MULT_EXPR)\n \t  && (TREE_CODE (arg1) == RDIV_EXPR || TREE_CODE (arg1) == MULT_EXPR)\n@@ -13231,6 +13317,7 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n     case REAL_CST:\n       return ! REAL_VALUE_NEGATIVE (TREE_REAL_CST (t));\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (t)))\n \treturn (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n@@ -13586,6 +13673,7 @@ tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n     case INTEGER_CST:\n       return !integer_zerop (t);\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n@@ -14178,7 +14266,7 @@ fold_indirect_ref_1 (tree type, tree op0)\n     }\n \n   /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n-  if (TREE_CODE (sub) == PLUS_EXPR\n+  if (TREE_CODE (sub) == POINTER_PLUS_EXPR\n       && TREE_CODE (TREE_OPERAND (sub, 1)) == INTEGER_CST)\n     {\n       tree op00 = TREE_OPERAND (sub, 0);"}, {"sha": "932e004029b2930f2483df670f4b5cac18bc8b37", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1,3 +1,11 @@\n+2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_repeat): Use\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointer addition.\n+\t* trans-expr.c (gfc_trans_string_copy): Create\n+\tPOINTER_PLUS_EXPR instead of a PLUS_EXPR\n+\tfor pointer types.\n+\n 2007-06-14  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/32302"}, {"sha": "56bca5b3951f3ce6d64f45f2dbb5210d6e0d2ae2", "filename": "gcc/fortran/ChangeLog.ptr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog.ptr?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,11 @@\n+2007-05-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_repeat): Use\n+\tPOINTER_PLUS_EXPR instead of PLUS_EXPR for pointer addition.\n+\n+2007-05-07  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* trans-expr.c (gfc_trans_string_copy): Create\n+\tPOINTER_PLUS_EXPR instead of a PLUS_EXPR\n+\tfor pointer types.\n+"}, {"sha": "a46693587b341ae48156550a12a931db03692f27", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2571,8 +2571,8 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n   tmp3 = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE],\n \t\t\t  3, dest, src, slen);\n \n-  tmp4 = fold_build2 (PLUS_EXPR, pchar_type_node, dest,\n-\t\t      fold_convert (pchar_type_node, slen));\n+  tmp4 = fold_build2 (POINTER_PLUS_EXPR, pchar_type_node, dest,\n+\t\t      fold_convert (sizetype, slen));\n   tmp4 = build_call_expr (built_in_decls[BUILT_IN_MEMSET], 3,\n \t\t\t  tmp4, \n \t\t\t  build_int_cst (gfc_get_int_type (gfc_c_int_kind),"}, {"sha": "d1c371092fb33cf178e97c5099a5257799ac6169", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -3530,8 +3530,8 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   /* Call memmove (dest + (i*slen), src, slen).  */\n   tmp = fold_build2 (MULT_EXPR, gfc_charlen_type_node, slen,\n \t\t     fold_convert (gfc_charlen_type_node, count));\n-  tmp = fold_build2 (PLUS_EXPR, pchar_type_node, dest,\n-\t\t     fold_convert (pchar_type_node, tmp));\n+  tmp = fold_build2 (POINTER_PLUS_EXPR, pchar_type_node, dest,\n+\t\t     fold_convert (sizetype, tmp));\n   tmp = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE], 3,\n \t\t\t tmp, src, slen);\n   gfc_add_expr_to_block (&body, tmp);"}, {"sha": "774af9adbf81b8b6920d046212137d50b57f1824", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1960,6 +1960,15 @@ gimplify_self_mod_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \treturn ret;\n     }\n \n+  /* For POINTERs increment, use POINTER_PLUS_EXPR.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (lhs)))\n+    {\n+      rhs = fold_convert (sizetype, rhs);\n+      if (arith_code == MINUS_EXPR)\n+\trhs = fold_build1 (NEGATE_EXPR, TREE_TYPE (rhs), rhs);\n+      arith_code = POINTER_PLUS_EXPR;\n+    }\n+\n   t1 = build2 (arith_code, TREE_TYPE (*expr_p), lhs, rhs);\n   t1 = build_gimple_modify_stmt (lvalue, t1);\n \n@@ -5125,6 +5134,7 @@ gimplify_omp_atomic_fetch_op (tree *expr_p, tree addr, tree rhs, int index)\n   /* Check for one of the supported fetch-op operations.  */\n   switch (TREE_CODE (rhs))\n     {\n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       base = BUILT_IN_FETCH_AND_ADD_N;\n       optab = sync_add_optab;\n@@ -5875,12 +5885,11 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  ret = GS_ALL_DONE;\n \t  break;\n \n-\tcase PLUS_EXPR:\n+\tcase POINTER_PLUS_EXPR:\n           /* Convert ((type *)A)+offset into &A->field_of_type_and_offset.\n \t     The second is gimple immediate saving a need for extra statement.\n \t   */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (*expr_p))\n-\t      && TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n+\t  if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n \t      && (tmp = maybe_fold_offset_to_reference\n \t\t\t (TREE_OPERAND (*expr_p, 0), TREE_OPERAND (*expr_p, 1),\n \t\t   \t  TREE_TYPE (TREE_TYPE (*expr_p)))))\n@@ -5890,8 +5899,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t       break;\n \t     }\n \t  /* Convert (void *)&a + 4 into (void *)&a[1].  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (*expr_p))\n-\t      && TREE_CODE (TREE_OPERAND (*expr_p, 0)) == NOP_EXPR\n+\t  if (TREE_CODE (TREE_OPERAND (*expr_p, 0)) == NOP_EXPR\n \t      && TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n \t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p,\n \t\t\t\t\t\t\t\t\t0),0)))"}, {"sha": "493fe1ed839e43182a0f48fa137af6c03a48ca4e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1,3 +1,17 @@\n+2007-06-15 Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* class.c (make_class_data): Build the index in sizetype.\n+\tUse POINTER_PLUS_EXPR instead of PLUS_EXPR when\n+\tadding to a pointer type.\n+\t(build_symbol_entry): Likewise.\n+\t* expr.c (build_java_arrayaccess): Likewise.\n+\t(build_field_ref): Likewise.\n+\t(build_known_method_ref): Likewise.\n+\t(build_invokevirtual): Likewise.\n+\t* except.c (build_exception_object_ref): Do a\n+\tNEGATIVE and then a POINTER_PLUS_EXPR instead\n+\tof a MINUS_EXPR.\n+\n 2007-06-11  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* typeck.c (java_signed_type): Remove."}, {"sha": "eb2c9a92d94cc58aa724748dee117e36a00014d6", "filename": "gcc/java/ChangeLog.ptr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.ptr?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,19 @@\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* except.c (build_exception_object_ref):\n+\tUse fold_build1 instead of build1 for NEGATE_EXPR.\n+\n+2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* class.c (make_class_data): Build the index in sizetype.\n+\tUse POINTER_PLUS_EXPR instead of PLUS_EXPR when\n+\tadding to a pointer type.\n+\t(build_symbol_entry): Likewise.\n+\t* expr.c (build_java_arrayaccess): Likewise.\n+\t(build_field_ref): Likewise.\n+\t(build_known_method_ref): Likewise.\n+\t(build_invokevirtual): Likewise.\n+\t* except.c (build_exception_object_ref): Do a\n+\tNEGATIVE and then a POINTER_PLUS_EXPR instead\n+\tof a MINUS_EXPR.\n+"}, {"sha": "3d4372646ed3e4bf796da144b806cef9ea8f4f87", "filename": "gcc/java/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1669,8 +1669,7 @@ make_class_data (tree type)\n   tree id_class = get_identifier(\"java.lang.Class\");\n   /** Offset from start of virtual function table declaration\n       to where objects actually point at, following new g++ ABI. */\n-  tree dtable_start_offset = build_int_cst (NULL_TREE,\n-\t\t\t\t\t    2 * POINTER_SIZE / BITS_PER_UNIT);\n+  tree dtable_start_offset = size_int (2 * POINTER_SIZE / BITS_PER_UNIT);\n   VEC(int, heap) *field_indexes;\n   tree first_real_field;\n \n@@ -1957,7 +1956,7 @@ make_class_data (tree type)\n   PUSH_FIELD_VALUE (temp, \"vtable\",\n \t\t    (flag_indirect_classes \n \t\t     ? null_pointer_node\n-\t\t     : build2 (PLUS_EXPR, dtable_ptr_type,\n+\t\t     : build2 (POINTER_PLUS_EXPR, dtable_ptr_type,\n \t\t\t       build1 (ADDR_EXPR, dtable_ptr_type,\n \t\t\t\t       class_dtable_decl),\n \t\t\t       dtable_start_offset)));\n@@ -2005,7 +2004,7 @@ make_class_data (tree type)\n   else\n     PUSH_FIELD_VALUE (cons, \"vtable\",\n \t\t      dtable_decl == NULL_TREE ? null_pointer_node\n-\t\t      : build2 (PLUS_EXPR, dtable_ptr_type,\n+\t\t      : build2 (POINTER_PLUS_EXPR, dtable_ptr_type,\n \t\t\t\tbuild1 (ADDR_EXPR, dtable_ptr_type,\n \t\t\t\t\tdtable_decl),\n \t\t\t\tdtable_start_offset));\n@@ -2807,7 +2806,8 @@ build_symbol_entry (tree decl, tree special)\n      system that this is a \"special\" symbol, i.e. one that should\n      bypass access controls.  */\n   if (special != NULL_TREE)\n-    signature = build2 (PLUS_EXPR, TREE_TYPE (signature), signature, special);\n+    signature = build2 (POINTER_PLUS_EXPR, TREE_TYPE (signature), signature,\n+\t\t\tfold_convert (sizetype, special));\n       \n   START_RECORD_CONSTRUCTOR (sym, symbol_type);\n   PUSH_FIELD_VALUE (sym, \"clname\", clname);"}, {"sha": "01c8a58d384e758a63a566aa7427ab2ecda2cb34", "filename": "gcc/java/except.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -467,8 +467,9 @@ build_exception_object_ref (tree type)\n   /* Java only passes object via pointer and doesn't require adjusting.\n      The java object is immediately before the generic exception header.  */\n   obj = build0 (EXC_PTR_EXPR, build_pointer_type (type));\n-  obj = build2 (MINUS_EXPR, TREE_TYPE (obj), obj,\n-\t\tTYPE_SIZE_UNIT (TREE_TYPE (obj)));\n+  obj = build2 (POINTER_PLUS_EXPR, TREE_TYPE (obj), obj,\n+\t\tfold_build1 (NEGATE_EXPR, sizetype,\n+\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (obj))));\n   obj = build1 (INDIRECT_REF, type, obj);\n \n   return obj;"}, {"sha": "d446e490abb8e07ad91364b47bdd23fa4cc349ea", "filename": "gcc/java/expr.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -929,13 +929,12 @@ build_java_arrayaccess (tree array, tree type, tree index)\n \n   /* Multiply the index by the size of an element to obtain a byte\n      offset.  Convert the result to a pointer to the element type.  */\n-  index = fold_convert (TREE_TYPE (node),\n-\t\t\tbuild2 (MULT_EXPR, sizetype, \n-\t\t\t\tfold_convert (sizetype, index), \n-\t\t\t\tsize_exp));\n+  index = build2 (MULT_EXPR, sizetype, \n+\t\t  fold_convert (sizetype, index), \n+\t\t  size_exp);\n \n   /* Sum the byte offset and the address of the data field.  */\n-  node = fold_build2 (PLUS_EXPR, TREE_TYPE (node), node, index);\n+  node = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (node), node, index);\n \n   /* Finally, return\n \n@@ -1744,7 +1743,7 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \t  field_offset = fold (convert (sizetype, field_offset));\n \t  self_value = java_check_reference (self_value, check);\n \t  address \n-\t    = fold_build2 (PLUS_EXPR, \n+\t    = fold_build2 (POINTER_PLUS_EXPR, \n \t\t\t   build_pointer_type (TREE_TYPE (field_decl)),\n \t\t\t   self_value, field_offset);\n \t  return fold_build1 (INDIRECT_REF, TREE_TYPE (field_decl), address);\n@@ -2228,8 +2227,8 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t  method_index++;\n \t}\n       method_index *= int_size_in_bytes (method_type_node);\n-      ref = fold_build2 (PLUS_EXPR, method_ptr_type_node,\n-\t\t\t ref, build_int_cst (NULL_TREE, method_index));\n+      ref = fold_build2 (POINTER_PLUS_EXPR, method_ptr_type_node,\n+\t\t\t ref, size_int (method_index));\n       ref = build1 (INDIRECT_REF, method_type_node, ref);\n       func = build3 (COMPONENT_REF, nativecode_ptr_type_node,\n \t\t     ref, lookup_field (&method_type_node, ncode_ident),\n@@ -2333,8 +2332,8 @@ build_invokevirtual (tree dtable, tree method, tree special)\n \t\t\t\t   size_int (TARGET_VTABLE_USES_DESCRIPTORS));\n     }\n \n-  func = fold_build2 (PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n-\t\t      convert (nativecode_ptr_ptr_type_node, method_index));\n+  func = fold_build2 (POINTER_PLUS_EXPR, nativecode_ptr_ptr_type_node, dtable,\n+\t\t      convert (sizetype, method_index));\n \n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     func = build1 (NOP_EXPR, nativecode_ptr_type_node, func);"}, {"sha": "189073498d826e835c8074528000c6ec9fcaf1cd", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -224,10 +224,10 @@ collect_data_for_malloc_call (tree stmt, struct malloc_call_data *m_data)\n    initial address and index of each dimension.  */\n struct access_site_info\n {\n-  /* The statement (INDIRECT_REF or PLUS_EXPR).  */\n+  /* The statement (INDIRECT_REF or POINTER_PLUS_EXPR).  */\n   tree stmt;\n \n-  /* In case of PLUS_EXPR, what is the offset.  */\n+  /* In case of POINTER_PLUS_EXPR, what is the offset.  */\n   tree offset;\n \n   /* The index which created the offset.  */\n@@ -609,7 +609,7 @@ mark_min_matrix_escape_level (struct matrix_info *mi, int l, tree s)\n /* Find if the SSA variable is accessed inside the\n    tree and record the tree containing it.\n    The only relevant uses are the case of SSA_NAME, or SSA inside\n-   INDIRECT_REF, CALL_EXPR, PLUS_EXPR, MULT_EXPR.  */\n+   INDIRECT_REF, CALL_EXPR, PLUS_EXPR, POINTER_PLUS_EXPR, MULT_EXPR.  */\n static void\n ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n {\n@@ -644,6 +644,7 @@ ssa_accessed_in_tree (tree t, struct ssa_acc_in_tree *a)\n \t  }\n       }\n       break;\n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MULT_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n@@ -903,7 +904,7 @@ analyze_transpose (void **slot, void *data ATTRIBUTE_UNUSED)\n   for (i = 0; VEC_iterate (access_site_info_p, mi->access_l, i, acc_info);\n        i++)\n     {\n-      if (TREE_CODE (GIMPLE_STMT_OPERAND (acc_info->stmt, 1)) == PLUS_EXPR\n+      if (TREE_CODE (GIMPLE_STMT_OPERAND (acc_info->stmt, 1)) == POINTER_PLUS_EXPR\n \t  && acc_info->level < min_escape_l)\n \t{\n \t  loop = loop_containing_stmt (acc_info->stmt);\n@@ -1197,7 +1198,7 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n \t  return current_indirect_level;\n \t}\n       if (rhs_acc.t_code != INDIRECT_REF\n-\t  && rhs_acc.t_code != PLUS_EXPR && rhs_acc.t_code != SSA_NAME)\n+\t  && rhs_acc.t_code != POINTER_PLUS_EXPR && rhs_acc.t_code != SSA_NAME)\n \t{\n \t  mark_min_matrix_escape_level (mi, current_indirect_level, use_stmt);\n \t  return current_indirect_level;\n@@ -1212,11 +1213,8 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n \t\t\t\t\t   current_indirect_level, true);\n \t  current_indirect_level += 1;\n \t}\n-      else if (rhs_acc.t_code == PLUS_EXPR)\n+      else if (rhs_acc.t_code == POINTER_PLUS_EXPR)\n \t{\n-\t  /* ??? maybe we should check\n-\t     the type of the PLUS_EXP and make sure it's\n-\t     integral type.  */\n \t  gcc_assert (rhs_acc.second_op);\n \t  if (last_op)\n \t    /* Currently we support only one PLUS expression on the\n@@ -1286,7 +1284,7 @@ analyze_accesses_for_modify_stmt (struct matrix_info *mi, tree ssa_var,\n \t  /* We are placing it in an SSA, follow that SSA.  */\n \t  analyze_matrix_accesses (mi, lhs,\n \t\t\t\t   current_indirect_level,\n-\t\t\t\t   rhs_acc.t_code == PLUS_EXPR,\n+\t\t\t\t   rhs_acc.t_code == POINTER_PLUS_EXPR,\n \t\t\t\t   visited, record_accesses);\n \t}\n     }\n@@ -1321,7 +1319,7 @@ analyze_matrix_accesses (struct matrix_info *mi, tree ssa_var,\n \n /* Now go over the uses of the SSA_NAME and check how it is used in\n    each one of them.  We are mainly looking for the pattern INDIRECT_REF,\n-   then a PLUS_EXPR, then INDIRECT_REF etc.  while in between there could\n+   then a POINTER_PLUS_EXPR, then INDIRECT_REF etc.  while in between there could\n    be any number of copies and casts.  */\n   gcc_assert (TREE_CODE (ssa_var) == SSA_NAME);\n \n@@ -1405,6 +1403,7 @@ can_calculate_expr_before_stmt (tree expr, sbitmap visited)\n     case PARM_DECL:\n     case INTEGER_CST:\n       return expr;\n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n@@ -1798,7 +1797,7 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t    GIMPLE_STMT_OPERAND (orig, 0));\n \t  GIMPLE_STMT_OPERAND (acc_info->stmt, 1) = orig;\n \t}\n-      else if (TREE_CODE (orig) == PLUS_EXPR\n+      else if (TREE_CODE (orig) == POINTER_PLUS_EXPR\n \t       && acc_info->level < (min_escape_l))\n \t{\n \t  imm_use_iterator imm_iter;\n@@ -1822,11 +1821,8 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t\t  tree new_offset;\n \t\t  tree d_type_size, d_type_size_k;\n \n-\t\t  d_type_size =\n-\t\t    build_int_cst (type,\n-\t\t\t\t   mi->dimension_type_size[min_escape_l]);\n-\t\t  d_type_size_k =\n-\t\t    build_int_cst (type, mi->dimension_type_size[k + 1]);\n+\t\t  d_type_size = size_int (mi->dimension_type_size[min_escape_l]);\n+\t\t  d_type_size_k = size_int (mi->dimension_type_size[k + 1]);\n \n \t\t  new_offset =\n \t\t    compute_offset (mi->dimension_type_size[min_escape_l],\n@@ -1857,7 +1853,8 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \t    {\n \t      d_size = mi->dimension_size[mi->dim_map[k] + 1];\n \t      num_elements =\n-\t\tfold_build2 (MULT_EXPR, type, acc_info->index, d_size);\n+\t\tfold_build2 (MULT_EXPR, sizetype, fold_convert (sizetype, acc_info->index),\n+\t\t\t    fold_convert (sizetype, d_size));\n \t      tmp1 = force_gimple_operand (num_elements, &stmts, true, NULL);\n \t      add_referenced_var (d_size);\n \t      if (stmts)\n@@ -1880,8 +1877,8 @@ transform_access_sites (void **slot, void *data ATTRIBUTE_UNUSED)\n \n \t\t  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, offset)\n \t\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t\t    if (use_stmt == acc_info->stmt)\n-\t\t    SET_USE (use_p, tmp1);\n+\t\t      if (use_stmt == acc_info->stmt)\n+\t\t        SET_USE (use_p, tmp1);\n \t\t}\n \t      else\n \t\t{"}, {"sha": "dd146da8b6d3bfdde2483beee4155a60614d6535", "filename": "gcc/optabs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -372,6 +372,7 @@ optab_for_tree_code (enum tree_code code, tree type)\n   trapv = INTEGRAL_TYPE_P (type) && TYPE_OVERFLOW_TRAPS (type);\n   switch (code)\n     {\n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       return trapv ? addv_optab : add_optab;\n "}, {"sha": "ba4707a541b46d78edd82056a7f709b9175cbf1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1,3 +1,36 @@\n+2007-06-15  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/32225\n+\t* gcc.c-torture/compile/20070605-1.c: New test.\n+\n+\t* gcc.c-torture/compile/20070603-1.c: New testcase.\n+\t* gcc.c-torture/compile/20070603-2.c: New testcase.\n+\n+\t* gcc.c-torture/compile/20070531-1.c: New test.\n+\n+\tPR tree-opt/32167\n+\t* gcc.c-torture/compile/20070531-2.c: New test.\n+\n+\tPR tree-opt/32144\n+\t* gcc.c-torture/compile/20070529-1.c: New test.\n+\n+\tPR tree-opt/32145\n+\t* gcc.c-torture/compile/20070529-2.c: New test.\n+\n+\tPR tree-opt/32015\n+\t* gcc.c-torture/compile/20070520-1.c: New test.\n+\n+\t* g++.dg/ext/java-1.C: New test.\n+\n+\t* gcc.dg/vect/vect-106.c: We are now able to vectorize two\n+\tloops instead of one. Remove the \"can't determine dependence\"\n+\tcheck.\n+\t* gcc.dg/tree-ssa/20030815-1.c: Remove testcase which is no longer\n+\tneeded as the cast is gone in the first place.\n+\t* gcc.dg/max-1.c: Change local variable a to be a global one.\n+\t* gcc.dg/tree-ssa/ssa-pre-8.c: Update testcase since we don't\n+\thave a cast which is PREd.\n+\n 2007-06-15  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/lookup/anon6.C: New test."}, {"sha": "7bb79016f721b54ff98ae6eaff072ee4db3b1db9", "filename": "gcc/testsuite/ChangeLog.ptr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2FChangeLog.ptr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2FChangeLog.ptr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog.ptr?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,58 @@\n+2007-06-14  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.dg/max-1.c: Fix spelling/grammer mistakes.\n+\t* gcc.dg/vect/vect-106.c: Likewise.\n+\n+2007-06-06  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/32225\n+\t* gcc.c-torture/compile/20070605-1.c: New test.\n+\n+2007-06-03  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.c-torture/compile/20070603-1.c: New testcase.\n+\t* gcc.c-torture/compile/20070603-2.c: New testcase.\n+\n+2007-05-31  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.c-torture/compile/20070531-1.c: New test.\n+\n+\tPR tree-opt/32167\n+\t* gcc.c-torture/compile/20070531-2.c: New test.\n+\n+2007-05-28  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/32144\n+\t* gcc.c-torture/compile/20070529-1.c: New test.\n+\n+\tPR tree-opt/32145\n+\t* gcc.c-torture/compile/20070529-2.c: New test.\n+\n+2007-05-21  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\tPR tree-opt/32015\n+\t* gcc.c-torture/compile/20070520-1.c: New test.\n+\n+2007-05-12  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t * g++.dg/ext/java-1.C: New test.\n+\n+2007-05-09  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.dg/vect/vect-106.c: We are now able to vectorize two\n+\tloops instead of one. Remove the \"can't determine dependence\"\n+\tcheck.\n+\n+2007-05-04  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.dg/tree-ssa/20030815-1.c: Remove testcase which is no longer\n+\tneeded as the cast is gone in the first place.\n+\n+2007-05-04  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.dg/max-1.c: Change local variable a to be a global one.\n+\n+2006-11-23  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n+\n+\t* gcc.dg/tree-ssa/ssa-pre-8.c: Update testcase since we don't\n+\thave a cast which is PREd."}, {"sha": "3c1e4231db1d79dae16328bf9017c259b5f52e27", "filename": "gcc/testsuite/g++.dg/ext/java-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-1.C?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+// Test extern \"java\" and some throwing of the objects.\n+\n+extern \"Java\"\n+  namespace java\n+  {\n+    namespace lang\n+    {\n+      class Throwable;\n+      class Class;\n+  }\n+}\n+typedef class java::lang::Throwable* jthrowable;\n+typedef class java::lang::Class* jclass;\n+class java::lang::Throwable {\n+public:\n+  static jclass class$;\n+};\n+int\n+_Jv_FindClassFromSignature ( )\n+  try \n+    {\n+    }\n+  catch (java::lang::Throwable *ncdfe) {} \n+"}, {"sha": "fe9db97476efee857a7f5e122aaa3523123ea4fb", "filename": "gcc/testsuite/gcc.c-torture/compile/20070520-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070520-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070520-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070520-1.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,35 @@\n+typedef unsigned char uint8_t;\n+extern uint8_t ff_cropTbl[256 + 2 * 1024];\n+\n+void ff_pred8x8_plane_c(uint8_t *src, int stride){\n+  int j, k;\n+  int a;\n+  uint8_t *cm = ff_cropTbl + 1024;\n+  const uint8_t * const src0 = src+3-stride;\n+  const uint8_t *src1 = src+4*stride-1;\n+  const uint8_t *src2 = src1-2*stride;\n+  int H = src0[1] - src0[-1];\n+  int V = src1[0] - src2[ 0];\n+  for(k=2; k<=4; ++k) {\n+    src1 += stride; src2 -= stride;\n+    H += k*(src0[k] - src0[-k]);\n+    V += k*(src1[0] - src2[ 0]);\n+  }\n+  H = ( 17*H+16 ) >> 5;\n+  V = ( 17*V+16 ) >> 5;\n+\n+  a = 16*(src1[0] + src2[8]+1) - 3*(V+H);\n+  for(j=8; j>0; --j) {\n+    int b = a;\n+    a += V;\n+    src[0] = cm[ (b ) >> 5 ];\n+    src[1] = cm[ (b+ H) >> 5 ];\n+    src[2] = cm[ (b+2*H) >> 5 ];\n+    src[3] = cm[ (b+3*H) >> 5 ];\n+    src[4] = cm[ (b+4*H) >> 5 ];\n+    src[5] = cm[ (b+5*H) >> 5 ];\n+    src[6] = cm[ (b+6*H) >> 5 ];\n+    src[7] = cm[ (b+7*H) >> 5 ];\n+    src += stride;\n+  }\n+}"}, {"sha": "f34add2b6c5667fce3feff2596f6f99576cf7369", "filename": "gcc/testsuite/gcc.c-torture/compile/20070529-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070529-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070529-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070529-1.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,16 @@\n+/* ICE in chrec_fold_plus_poly_poly. */\n+\n+typedef unsigned short __u16;\n+typedef unsigned int u32;\n+typedef __u16 __be16;\n+struct hfs_extent {\n+ __be16 count;\n+};\n+int hfs_free_fork( int type)\n+{\n+ u32 total_blocks, blocks, start;\n+ struct hfs_extent *extent;\n+ int res, i;\n+ for (i = 0; i < 3; extent++, i++)\n+  blocks += __fswab16((( __u16)(__be16)(extent[i].count)));\n+}"}, {"sha": "cb38d20610aa3a3a1722e41312a141f2ca5eb847", "filename": "gcc/testsuite/gcc.c-torture/compile/20070529-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070529-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070529-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070529-2.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,11 @@\n+void xfs_dir2_grow_inode(void)\n+{\n+ int map;\n+ int *mapp;\n+ int nmap;\n+ mapp = &map;\n+ if (nmap == 0 )\n+  mapp = ((void *)0);\n+ if (mapp != &map)\n+  kmem_free(mapp);\n+}"}, {"sha": "90ecbb88dc288bb29a98d241c03705139cfcf0cb", "filename": "gcc/testsuite/gcc.c-torture/compile/20070531-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070531-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070531-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070531-1.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,11 @@\n+/* MIN_EXPR/MAX_EXPR caused an ICE in VRP. */\n+int *f(int *a, int *b)\n+{\n+ *a = 1;\n+ *b = 2;\n+ int *c = a < b ? a : b;\n+ if (c)\n+   return c;\n+ else\n+   return a;\n+}"}, {"sha": "967180e0d85bf08ed782c6f7956674c4084c2af7", "filename": "gcc/testsuite/gcc.c-torture/compile/20070531-2.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070531-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070531-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070531-2.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,6 @@\n+int f(void)\n+{\n+  int *a = 0;\n+  for(a = 0; a < (int*)32767;a++)\n+   ;\n+}"}, {"sha": "94e2baf138df64cb4c4d5ae6d1d4fb928b3c9344", "filename": "gcc/testsuite/gcc.c-torture/compile/20070603-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070603-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070603-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070603-1.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,9 @@\n+\n+int f(_Complex double *a, unsigned int n)\n+{\n+  unsigned int i;\n+  for(i = 0; i< n; i++)\n+    {\n+      a[i] = __real__ a[i+1] + __real__ a[i];\n+    }\n+}"}, {"sha": "7aaa8c2ae6d815418b3523f9ce2a347f7a584c8f", "filename": "gcc/testsuite/gcc.c-torture/compile/20070603-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070603-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070603-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070603-2.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,9 @@\n+typedef _Complex double ar[];\n+int f(ar *a, unsigned int n)\n+{\n+  unsigned int i;\n+  for(i = 0; i< n; i++)\n+    {\n+      (*a)[i*4] = __real__ (*a)[(i+1)*4] + __real__ (*a)[i*4];\n+    }\n+}"}, {"sha": "8bf53253cc798672103095361d5334a590147e88", "filename": "gcc/testsuite/gcc.c-torture/compile/20070605-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070605-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070605-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20070605-1.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -0,0 +1,10 @@\n+quantize_fs_dither (unsigned width, short *errorptr, int dir)\n+{\n+  short bpreverr;\n+  unsigned col;\n+  for (col = width; col > 0; col--) \n+    errorptr += dir;\n+  errorptr[0] = (short) bpreverr;\n+}\n+\n+"}, {"sha": "a5f16056c31edcfa737669efeaa508751178e635", "filename": "gcc/testsuite/gcc.dg/max-1.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.dg%2Fmax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.dg%2Fmax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmax-1.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -24,10 +24,13 @@ void f(long a, long b)\n    fff[i] = a;\n }\n \n+/* The variable a cannot be a local variable as we get better aliasing\n+   now and decide that the store to a is dead.  The better aliasing comes\n+   from better representation of pointer arithmetic. */\n+long a = 10;\n int main(void)\n {\n   int i;\n-  long a = 10;\n   f((long)(&a)-1,0);\n   for(i = 0;i<10;i++)\n    if (fff[i]!=10)"}, {"sha": "6e4180780194f40cea659c2e5ff29b5380904395", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030815-1.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d2b1d91675ba5a26e4d04b209355047421adf92/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030815-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d2b1d91675ba5a26e4d04b209355047421adf92/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030815-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030815-1.c?ref=1d2b1d91675ba5a26e4d04b209355047421adf92", "patch": "@@ -1,43 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-dom3\" } */\n-\n-extern void abort (void);\n-typedef unsigned int size_t;\n-struct rtx_def;\n-typedef struct rtx_def *rtx;\n-typedef union varray_data_tag\n-{\n-  struct reg_info_def *reg[1];\n-} varray_data;\n-struct varray_head_tag\n-{\n-  size_t num_elements;\n-  varray_data data;\n-};\n-typedef struct varray_head_tag *varray_type;\n-typedef struct reg_info_def\n-{\n-} reg_info;\n-extern varray_type reg_n_info;\n-static rtx *reg_base_value;\n-static rtx *new_reg_base_value;\n-\n-rtx\n-blah (unsigned int regno)\n-{\n-  if (new_reg_base_value[regno] && ((*(\n-\t\t\t\t\t{\n-\t\t\t\t\tif (regno >=\n-\t\t\t\t\t    reg_n_info->\n-\t\t\t\t\t    num_elements)\n-\t\t\t\t\tabort ();\n-\t\t\t\t\t&reg_n_info->data.reg[regno];}\n-\t\t\t\t     ))))\n-    return reg_base_value[regno];\n-}\n-\n-/* If we have more than 1 cast to a struct rtx_def * *, then we failed to\n-   eliminate some useless typecasting.  The first type cast is needed\n-   to convert the unsigned int regno parameter into a struct rtx_def **.  */\n-/* { dg-final { scan-tree-dump-times \"\\\\(struct rtx_def \\\\* \\\\*\\\\)\" 1 \"dom3\"} } */\n-/* { dg-final { cleanup-tree-dump \"dom3\" } } */"}, {"sha": "ae933bbccec6d1957525cd31f729cd7531fa837c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-8.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-8.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -16,6 +16,8 @@ foo (__SIZE_TYPE__ i, struct s *array)\n     }\n   return 0;\n }\n-/* We should eliminate two address calculations, one cast, and one load.  */\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 4\" 1 \"fre\"} } */\n+/* We should eliminate two address calculations, and one load.  */\n+/* We used to eliminate a cast but that was before POINTER_PLUS_EXPR\n+   was added.  */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 3\" 1 \"fre\"} } */\n /* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "891cd3155acef4c17a5ded91877b2efdb855fe1a", "filename": "gcc/testsuite/gcc.dg/vect/vect-106.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-106.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-106.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-106.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -17,9 +17,9 @@ int main1 () {\n \n   p1 = p; q1 = q;\n \n-  /* Not vectorizable: because of the redundant cast (caused by ponter\n-     arithmetics), alias analysis fails to distinguish between \n-     the pointers.  */\n+  /* Vectorizable, before pointer plus we would get a redundant cast\n+     (caused by pointer arithmetics), alias analysis fails to distinguish\n+     between the pointers.  */\n   for (i = 0; i < N; i++)\n     {\n       *(q + i) = a[i];\n@@ -67,7 +67,6 @@ int main (void)\n   return main1 ();\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"can't determine dependence\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */\n "}, {"sha": "de4cf4ad59f341d02c3c7ea1069bd39adc75a006", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -268,6 +268,13 @@ tree_to_aff_combination (tree expr, tree type, aff_tree *comb)\n       aff_combination_const (comb, type, tree_to_double_int (expr));\n       return;\n \n+    case POINTER_PLUS_EXPR:\n+      tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);\n+      tree_to_aff_combination (TREE_OPERAND (expr, 1), sizetype, &tmp);\n+      aff_combination_convert (&tmp, type);\n+      aff_combination_add (comb, &tmp);\n+      return;\n+\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       tree_to_aff_combination (TREE_OPERAND (expr, 0), type, comb);"}, {"sha": "3fd57720150a5fc86e0ea5d78218043ec2431a18", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -3265,7 +3265,36 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t}\n       *walk_subtrees = 0;\n       break;\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* PLUS_EXPR and MINUS_EXPR don't work on pointers, they should be done using\n+\t POINTER_PLUS_EXPR. */\n+      if (POINTER_TYPE_P (TREE_TYPE (t)))\n+\t{\n+\t  error (\"invalid operand to plus/minus, type is a pointer\");\n+\t  return t;\n+\t}\n+      CHECK_OP (0, \"invalid operand to binary operator\");\n+      CHECK_OP (1, \"invalid operand to binary operator\");\n+      break;\n \n+    case POINTER_PLUS_EXPR:\n+      /* Check to make sure the first operand is a pointer or reference type. */\n+      if (!POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (t, 0))))\n+\t{\n+\t  error (\"invalid operand to pointer plus, first operand is not a pointer\");\n+\t  return t;\n+\t}\n+      /* Check to make sure the second operand is an integer with type of\n+\t sizetype.  */\n+      if (!tree_ssa_useless_type_conversion_1 (sizetype,\n+\t\t\t\t\t       TREE_TYPE (TREE_OPERAND (t, 1))))\n+\t{\n+\t  error (\"invalid operand to pointer plus, second operand is not an \"\n+\t\t \"integer with type of sizetype.\");\n+\t  return t;\n+\t}\n+      /* FALLTHROUGH */\n     case LT_EXPR:\n     case LE_EXPR:\n     case GT_EXPR:\n@@ -3280,8 +3309,6 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n     case UNGE_EXPR:\n     case UNEQ_EXPR:\n     case LTGT_EXPR:\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:"}, {"sha": "303e9567bda43ab63de6aa5dfdfc65ba4d8d7f8a", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -101,12 +101,16 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n   tree left, right;\n   struct loop *loop0 = get_chrec_loop (poly0);\n   struct loop *loop1 = get_chrec_loop (poly1);\n+  tree rtype = code == POINTER_PLUS_EXPR ? sizetype : type;\n \n   gcc_assert (poly0);\n   gcc_assert (poly1);\n   gcc_assert (TREE_CODE (poly0) == POLYNOMIAL_CHREC);\n   gcc_assert (TREE_CODE (poly1) == POLYNOMIAL_CHREC);\n-  gcc_assert (chrec_type (poly0) == chrec_type (poly1));\n+  if (POINTER_TYPE_P (chrec_type (poly0)))\n+    gcc_assert (chrec_type (poly1) == sizetype);\n+  else\n+    gcc_assert (chrec_type (poly0) == chrec_type (poly1));\n   gcc_assert (type == chrec_type (poly0));\n   \n   /*\n@@ -115,7 +119,7 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n     {a, +, b}_x + {c, +, d}_x  ->  {a+c, +, b+d}_x.  */\n   if (flow_loop_nested_p (loop0, loop1))\n     {\n-      if (code == PLUS_EXPR)\n+      if (code == PLUS_EXPR || code == POINTER_PLUS_EXPR)\n \treturn build_polynomial_chrec \n \t  (CHREC_VARIABLE (poly1), \n \t   chrec_fold_plus (type, poly0, CHREC_LEFT (poly1)),\n@@ -132,7 +136,7 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n   \n   if (flow_loop_nested_p (loop1, loop0))\n     {\n-      if (code == PLUS_EXPR)\n+      if (code == PLUS_EXPR || code == POINTER_PLUS_EXPR)\n \treturn build_polynomial_chrec \n \t  (CHREC_VARIABLE (poly0), \n \t   chrec_fold_plus (type, CHREC_LEFT (poly0), poly1),\n@@ -148,12 +152,12 @@ chrec_fold_plus_poly_poly (enum tree_code code,\n      do not belong to the same loop nest.  */\n   gcc_assert (loop0 == loop1);\n \n-  if (code == PLUS_EXPR)\n+  if (code == PLUS_EXPR || code == POINTER_PLUS_EXPR)\n     {\n       left = chrec_fold_plus \n \t(type, CHREC_LEFT (poly0), CHREC_LEFT (poly1));\n       right = chrec_fold_plus \n-\t(type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1));\n+\t(rtype, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1));\n     }\n   else\n     {\n@@ -264,6 +268,8 @@ static tree\n chrec_fold_plus_1 (enum tree_code code, tree type, \n \t\t   tree op0, tree op1)\n {\n+  tree op1_type = code == POINTER_PLUS_EXPR ? sizetype : type;\n+\n   if (automatically_generated_chrec_p (op0)\n       || automatically_generated_chrec_p (op1))\n     return chrec_fold_automatically_generated_operands (op0, op1);\n@@ -277,7 +283,7 @@ chrec_fold_plus_1 (enum tree_code code, tree type,\n \t  return chrec_fold_plus_poly_poly (code, type, op0, op1);\n \n \tdefault:\n-\t  if (code == PLUS_EXPR)\n+\t  if (code == PLUS_EXPR || code == POINTER_PLUS_EXPR)\n \t    return build_polynomial_chrec \n \t      (CHREC_VARIABLE (op0), \n \t       chrec_fold_plus (type, CHREC_LEFT (op0), op1),\n@@ -293,7 +299,7 @@ chrec_fold_plus_1 (enum tree_code code, tree type,\n       switch (TREE_CODE (op1))\n \t{\n \tcase POLYNOMIAL_CHREC:\n-\t  if (code == PLUS_EXPR)\n+\t  if (code == PLUS_EXPR || code == POINTER_PLUS_EXPR)\n \t    return build_polynomial_chrec \n \t      (CHREC_VARIABLE (op1), \n \t       chrec_fold_plus (type, op0, CHREC_LEFT (op1)),\n@@ -317,7 +323,7 @@ chrec_fold_plus_1 (enum tree_code code, tree type,\n \t    else if (size < PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n \t      return fold_build2 (code, type,\n \t\t\t\t  fold_convert (type, op0),\n-\t\t\t\t  fold_convert (type, op1));\n+\t\t\t\t  fold_convert (op1_type, op1));\n \t    else\n \t      return chrec_dont_know;\n \t  }\n@@ -332,16 +338,22 @@ chrec_fold_plus (tree type,\n \t\t tree op0,\n \t\t tree op1)\n {\n+  enum tree_code code;\n   if (automatically_generated_chrec_p (op0)\n       || automatically_generated_chrec_p (op1))\n     return chrec_fold_automatically_generated_operands (op0, op1);\n \n   if (integer_zerop (op0))\n-    return op1;\n+    return chrec_convert (type, op1, NULL_TREE);\n   if (integer_zerop (op1))\n-    return op0;\n+    return chrec_convert (type, op0, NULL_TREE);\n+\n+  if (POINTER_TYPE_P (type))\n+    code = POINTER_PLUS_EXPR;\n+  else\n+    code = PLUS_EXPR;\n   \n-  return chrec_fold_plus_1 (PLUS_EXPR, type, op0, op1);\n+  return chrec_fold_plus_1 (code, type, op0, op1);\n }\n \n /* Fold the subtraction of two chrecs.  */\n@@ -566,8 +578,8 @@ chrec_apply (unsigned var,\n   if (evolution_function_is_affine_p (chrec))\n     {\n       /* \"{a, +, b} (x)\"  ->  \"a + b*x\".  */\n-      x = chrec_convert (type, x, NULL_TREE);\n-      res = chrec_fold_multiply (type, CHREC_RIGHT (chrec), x);\n+      x = chrec_convert_rhs (type, x, NULL_TREE);\n+      res = chrec_fold_multiply (TREE_TYPE (x), CHREC_RIGHT (chrec), x);\n       if (!integer_zerop (CHREC_LEFT (chrec)))\n \tres = chrec_fold_plus (type, CHREC_LEFT (chrec), res);\n     }\n@@ -767,7 +779,10 @@ reset_evolution_in_loop (unsigned loop_num,\n {\n   struct loop *loop = get_loop (loop_num);\n \n-  gcc_assert (chrec_type (chrec) == chrec_type (new_evol));\n+  if (POINTER_TYPE_P (chrec_type (chrec)))\n+    gcc_assert (sizetype == chrec_type (new_evol));\n+  else\n+    gcc_assert (chrec_type (chrec) == chrec_type (new_evol));\n \n   if (TREE_CODE (chrec) == POLYNOMIAL_CHREC\n       && flow_loop_nested_p (loop, get_chrec_loop (chrec)))\n@@ -1119,6 +1134,7 @@ convert_affine_scev (struct loop *loop, tree type,\n   bool enforce_overflow_semantics;\n   bool must_check_src_overflow, must_check_rslt_overflow;\n   tree new_base, new_step;\n+  tree step_type = POINTER_TYPE_P (type) ? sizetype : type;\n \n   /* If we cannot perform arithmetic in TYPE, avoid creating an scev.  */\n   if (avoid_arithmetics_in_type_p (type))\n@@ -1188,10 +1204,10 @@ convert_affine_scev (struct loop *loop, tree type,\n      [100, +, 255] with values 100, 355, ...; the sign-extension is \n      performed by default when CT is signed.  */\n   new_step = *step;\n-  if (TYPE_PRECISION (type) > TYPE_PRECISION (ct) && TYPE_UNSIGNED (ct))\n+  if (TYPE_PRECISION (step_type) > TYPE_PRECISION (ct) && TYPE_UNSIGNED (ct))\n     new_step = chrec_convert_1 (signed_type_for (ct), new_step, at_stmt,\n \t\t\t\tuse_overflow_semantics);\n-  new_step = chrec_convert_1 (type, new_step, at_stmt, use_overflow_semantics);\n+  new_step = chrec_convert_1 (step_type, new_step, at_stmt, use_overflow_semantics);\n \n   if (automatically_generated_chrec_p (new_base)\n       || automatically_generated_chrec_p (new_step))\n@@ -1209,6 +1225,16 @@ convert_affine_scev (struct loop *loop, tree type,\n }\n \f\n \n+/* Convert CHREC for the right hand side of a CREC.\n+   The increment for a pointer type is always sizetype.  */\n+tree \n+chrec_convert_rhs (tree type, tree chrec, tree at_stmt)\n+{\n+  if (POINTER_TYPE_P (type))\n+   type = sizetype;\n+  return chrec_convert (type, chrec, at_stmt);\n+}\n+\n /* Convert CHREC to TYPE.  When the analyzer knows the context in\n    which the CHREC is built, it sets AT_STMT to the statement that\n    contains the definition of the analyzed variable, otherwise the\n@@ -1306,7 +1332,7 @@ chrec_convert_1 (tree type, tree chrec, tree at_stmt,\n tree\n chrec_convert_aggressive (tree type, tree chrec)\n {\n-  tree inner_type, left, right, lc, rc;\n+  tree inner_type, left, right, lc, rc, rtype;\n \n   if (automatically_generated_chrec_p (chrec)\n       || TREE_CODE (chrec) != POLYNOMIAL_CHREC)\n@@ -1320,14 +1346,16 @@ chrec_convert_aggressive (tree type, tree chrec)\n   if (avoid_arithmetics_in_type_p (type))\n     return NULL_TREE;\n \n+  rtype = POINTER_TYPE_P (type) ? sizetype : type;\n+\n   left = CHREC_LEFT (chrec);\n   right = CHREC_RIGHT (chrec);\n   lc = chrec_convert_aggressive (type, left);\n   if (!lc)\n     lc = chrec_convert (type, left, NULL_TREE);\n-  rc = chrec_convert_aggressive (type, right);\n+  rc = chrec_convert_aggressive (rtype, right);\n   if (!rc)\n-    rc = chrec_convert (type, right, NULL_TREE);\n+    rc = chrec_convert (rtype, right, NULL_TREE);\n  \n   return build_polynomial_chrec (CHREC_VARIABLE (chrec), lc, rc);\n }"}, {"sha": "e6bea92eb3b59e5730a103628c8d18e5facbefc5", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -59,6 +59,7 @@ extern tree chrec_fold_plus (tree, tree, tree);\n extern tree chrec_fold_minus (tree, tree, tree);\n extern tree chrec_fold_multiply (tree, tree, tree);\n extern tree chrec_convert (tree, tree, tree);\n+extern tree chrec_convert_rhs (tree, tree, tree);\n extern tree chrec_convert_aggressive (tree, tree);\n \n /* Operations.  */\n@@ -108,7 +109,10 @@ build_polynomial_chrec (unsigned loop_num,\n       || right == chrec_dont_know)\n     return chrec_dont_know;\n \n-  gcc_assert (TREE_TYPE (left) == TREE_TYPE (right));\n+  if (POINTER_TYPE_P (TREE_TYPE (left)))\n+    gcc_assert (sizetype == TREE_TYPE (right));\n+  else\n+    gcc_assert (TREE_TYPE (left) == TREE_TYPE (right));\n \n   if (chrec_zerop (right))\n     return left;"}, {"sha": "6f3ba84938863e3ee1967e70a775f8989c112502", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -495,25 +495,30 @@ split_constant_offset (tree exp, tree *var, tree *off)\n   tree type = TREE_TYPE (exp), otype;\n   tree var0, var1;\n   tree off0, off1;\n+  enum tree_code code;\n \n   *var = exp;\n   STRIP_NOPS (exp);\n   otype = TREE_TYPE (exp);\n+  code = TREE_CODE (exp);\n \n-  switch (TREE_CODE (exp))\n+  switch (code)\n     {\n     case INTEGER_CST:\n       *var = build_int_cst (type, 0);\n       *off = fold_convert (ssizetype, exp);\n       return;\n \n+    case POINTER_PLUS_EXPR:\n+      code = PLUS_EXPR;\n+      /* FALLTHROUGH */\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       split_constant_offset (TREE_OPERAND (exp, 0), &var0, &off0);\n       split_constant_offset (TREE_OPERAND (exp, 1), &var1, &off1);\n       *var = fold_convert (type, fold_build2 (TREE_CODE (exp), otype, \n \t\t\t\t\t      var0, var1));\n-      *off = size_binop (TREE_CODE (exp), off0, off1);\n+      *off = size_binop (code, off0, off1);\n       return;\n \n     case MULT_EXPR:"}, {"sha": "01816862ce04cb8cd39175fc0193f3670b5876c6", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2085,6 +2085,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case VEC_COND_EXPR:\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n "}, {"sha": "3ea0fb017cf4722f68f2f1fba0edcc34bb3c9634", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -824,8 +824,8 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n \t      elt = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (elt)),\n \t\t\t    elt);\n             addr = fold_convert (ptr_type_node, elt ? elt : base);\n-            addr = fold_build2 (PLUS_EXPR, ptr_type_node,\n-\t\t\t\taddr, fold_convert (ptr_type_node,\n+            addr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t\taddr, fold_convert (sizetype,\n \t\t\t\t\t\t    byte_position (field)));\n           }\n         else\n@@ -842,17 +842,19 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n     case INDIRECT_REF:\n       addr = TREE_OPERAND (t, 0);\n       base = addr;\n-      limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n-                           fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n-                           integer_one_node);\n+      limit = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t   fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, base,\n+\t\t\t\t\tsize),\n+\t\t\t   size_int (-1));\n       break;\n \n     case TARGET_MEM_REF:\n       addr = tree_mem_ref_addr (ptr_type_node, t);\n       base = addr;\n-      limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n-\t\t\t   fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n-\t\t\t   build_int_cst (ptr_type_node, 1));\n+      limit = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t   fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, base,\n+\t\t\t\t\tsize),\n+\t\t\t   size_int (-1));\n       break;\n \n     case ARRAY_RANGE_REF:\n@@ -872,7 +874,7 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n         bpu = bitsize_int (BITS_PER_UNIT);\n         ofs = convert (bitsizetype, TREE_OPERAND (t, 2));\n         rem = size_binop (TRUNC_MOD_EXPR, ofs, bpu);\n-        ofs = size_binop (TRUNC_DIV_EXPR, ofs, bpu);\n+        ofs = fold_convert (sizetype, size_binop (TRUNC_DIV_EXPR, ofs, bpu));\n \n         size = convert (bitsizetype, TREE_OPERAND (t, 1));\n         size = size_binop (PLUS_EXPR, size, rem);\n@@ -881,12 +883,13 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n \n         addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n         addr = convert (ptr_type_node, addr);\n-        addr = fold_build2 (PLUS_EXPR, ptr_type_node, addr, ofs);\n+        addr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node, addr, ofs);\n \n         base = addr;\n-        limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n-                             fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n-                             integer_one_node);\n+        limit = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+                             fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t\t\t   base, size),\n+                             size_int (-1));\n       }\n       break;\n "}, {"sha": "aff1875752dbbb1705ea2e78c318e2306afdd78d", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 11, "deletions": 45, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -555,41 +555,25 @@ merge_object_sizes (struct object_size_info *osi, tree dest, tree orig,\n \n \n /* Compute object_sizes for PTR, defined to VALUE, which is\n-   a PLUS_EXPR.  Return true if the object size might need reexamination\n+   a POINTER_PLUS_EXPR.  Return true if the object size might need reexamination\n    later.  */\n \n static bool\n plus_expr_object_size (struct object_size_info *osi, tree var, tree value)\n {\n   tree op0 = TREE_OPERAND (value, 0);\n   tree op1 = TREE_OPERAND (value, 1);\n-  bool ptr1_p = POINTER_TYPE_P (TREE_TYPE (op0))\n-\t\t&& TREE_CODE (op0) != INTEGER_CST;\n-  bool ptr2_p = POINTER_TYPE_P (TREE_TYPE (op1))\n-\t\t&& TREE_CODE (op1) != INTEGER_CST;\n   int object_size_type = osi->object_size_type;\n   unsigned int varno = SSA_NAME_VERSION (var);\n   unsigned HOST_WIDE_INT bytes;\n \n-  gcc_assert (TREE_CODE (value) == PLUS_EXPR);\n+  gcc_assert (TREE_CODE (value) == POINTER_PLUS_EXPR);\n \n   if (object_sizes[object_size_type][varno] == unknown[object_size_type])\n     return false;\n \n-  /* Swap operands if needed.  */\n-  if (ptr2_p && !ptr1_p)\n-    {\n-      tree tem = op0;\n-      op0 = op1;\n-      op1 = tem;\n-      ptr1_p = true;\n-      ptr2_p = false;\n-    }\n-\n   /* Handle PTR + OFFSET here.  */\n-  if (ptr1_p\n-      && !ptr2_p\n-      && TREE_CODE (op1) == INTEGER_CST\n+  if (TREE_CODE (op1) == INTEGER_CST\n       && (TREE_CODE (op0) == SSA_NAME\n \t  || TREE_CODE (op0) == ADDR_EXPR))\n     {\n@@ -669,7 +653,7 @@ cond_expr_object_size (struct object_size_info *osi, tree var, tree value)\n    OSI->object_size_type).\n    For allocation CALL_EXPR like malloc or calloc object size is the size\n    of the allocation.\n-   For pointer PLUS_EXPR where second operand is a constant integer,\n+   For POINTER_PLUS_EXPR where second operand is a constant integer,\n    object size is object size of the first operand minus the constant.\n    If the constant is bigger than the number of remaining bytes until the\n    end of the object, object size is 0, but if it is instead a pointer\n@@ -750,7 +734,7 @@ collect_object_sizes_for (struct object_size_info *osi, tree var)\n \t    && POINTER_TYPE_P (TREE_TYPE (rhs)))\n \t  reexamine = merge_object_sizes (osi, var, rhs, 0);\n \n-\telse if (TREE_CODE (rhs) == PLUS_EXPR)\n+\telse if (TREE_CODE (rhs) == POINTER_PLUS_EXPR)\n \t  reexamine = plus_expr_object_size (osi, var, rhs);\n \n         else if (TREE_CODE (rhs) == COND_EXPR)\n@@ -877,23 +861,14 @@ check_for_plus_in_loops_1 (struct object_size_info *osi, tree var,\n \n \tif (TREE_CODE (rhs) == SSA_NAME)\n \t  check_for_plus_in_loops_1 (osi, rhs, depth);\n-\telse if (TREE_CODE (rhs) == PLUS_EXPR)\n+\telse if (TREE_CODE (rhs) == POINTER_PLUS_EXPR)\n \t  {\n \t    tree op0 = TREE_OPERAND (rhs, 0);\n \t    tree op1 = TREE_OPERAND (rhs, 1);\n \t    tree cst, basevar;\n \n-\t    if (TREE_CODE (op0) == SSA_NAME)\n-\t      {\n-\t\tbasevar = op0;\n-\t\tcst = op1;\n-\t      }\n-\t    else\n-\t      {\n-\t\tbasevar = op1;\n-\t\tcst = op0;\n-\t\tgcc_assert (TREE_CODE (basevar) == SSA_NAME);\n-\t      }\n+\t    basevar = op0;\n+\t    cst = op1;\n \t    gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n \n \t    check_for_plus_in_loops_1 (osi, basevar,\n@@ -953,23 +928,14 @@ check_for_plus_in_loops (struct object_size_info *osi, tree var)\n \t      rhs = arg;\n \t  }\n \n-\tif (TREE_CODE (rhs) == PLUS_EXPR)\n+\tif (TREE_CODE (rhs) == POINTER_PLUS_EXPR)\n \t  {\n \t    tree op0 = TREE_OPERAND (rhs, 0);\n \t    tree op1 = TREE_OPERAND (rhs, 1);\n \t    tree cst, basevar;\n \n-\t    if (TREE_CODE (op0) == SSA_NAME)\n-\t      {\n-\t\tbasevar = op0;\n-\t\tcst = op1;\n-\t      }\n-\t    else\n-\t      {\n-\t\tbasevar = op1;\n-\t\tcst = op0;\n-\t\tgcc_assert (TREE_CODE (basevar) == SSA_NAME);\n-\t      }\n+\t    basevar = op0;\n+\t    cst = op1;\n \t    gcc_assert (TREE_CODE (cst) == INTEGER_CST);\n \n \t    if (integer_zerop (cst))"}, {"sha": "db9a8d509f09626cc29aab41926c3fbda85bfa91", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1350,9 +1350,18 @@ ref_at_iteration (struct loop *loop, tree ref, int iter)\n   else\n     {\n       type = TREE_TYPE (iv.base);\n-      val = fold_build2 (MULT_EXPR, type, iv.step,\n-\t\t\t build_int_cst_type (type, iter));\n-      val = fold_build2 (PLUS_EXPR, type, iv.base, val);\n+      if (POINTER_TYPE_P (type))\n+\t{\n+\t  val = fold_build2 (MULT_EXPR, sizetype, iv.step,\n+\t\t\t     size_int (iter));\n+\t  val = fold_build2 (POINTER_PLUS_EXPR, type, iv.base, val);\n+\t}\n+      else\n+\t{\n+\t  val = fold_build2 (MULT_EXPR, type, iv.step,\n+\t\t\t     build_int_cst_type (type, iter));\n+\t  val = fold_build2 (PLUS_EXPR, type, iv.base, val);\n+\t}\n       *idx_p = unshare_expr (val);\n     }\n "}, {"sha": "3aac9c7d9a7706379c0a27ab9e89de02daab23b0", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1233,6 +1233,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case WIDEN_MULT_EXPR:\n     case MULT_EXPR:\n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n@@ -2328,6 +2329,7 @@ op_prio (tree op)\n \n     case WIDEN_SUM_EXPR:\n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       return 12;\n \n@@ -2486,6 +2488,9 @@ op_symbol_code (enum tree_code code)\n \n     case VEC_RSHIFT_EXPR:\n       return \"v>>\";\n+\n+    case POINTER_PLUS_EXPR:\n+      return \"+\";\n  \n     case PLUS_EXPR:\n       return \"+\";"}, {"sha": "6dc69f2d304f616e6f2a5737ec9a349793058cb4", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 26, "deletions": 197, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -665,8 +665,8 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \t    }\n \n \t  to_add = chrec_convert (type, to_add, at_stmt);\n-\t  right = chrec_convert (type, right, at_stmt);\n-\t  right = chrec_fold_plus (type, right, to_add);\n+\t  right = chrec_convert_rhs (type, right, at_stmt);\n+\t  right = chrec_fold_plus (chrec_type (right), right, to_add);\n \t  return build_polynomial_chrec (var, left, right);\n \t}\n       else\n@@ -677,7 +677,7 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \t  left = add_to_evolution_1 (loop_nb, CHREC_LEFT (chrec_before),\n \t\t\t\t     to_add, at_stmt);\n \t  right = CHREC_RIGHT (chrec_before);\n-\t  right = chrec_convert (chrec_type (left), right, at_stmt);\n+\t  right = chrec_convert_rhs (chrec_type (left), right, at_stmt);\n \t  return build_polynomial_chrec (CHREC_VARIABLE (chrec_before),\n \t\t\t\t\t left, right);\n \t}\n@@ -688,7 +688,7 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \treturn chrec_dont_know;\n \n       left = chrec_before;\n-      right = chrec_convert (chrec_type (left), to_add, at_stmt);\n+      right = chrec_convert_rhs (chrec_type (left), to_add, at_stmt);\n       return build_polynomial_chrec (loop_nb, left, right);\n     }\n }\n@@ -1014,15 +1014,18 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n   tree rhs0, rhs1;\n   tree type_rhs = TREE_TYPE (rhs);\n   tree evol;\n+  enum tree_code code;\n   \n   /* The RHS is one of the following cases:\n      - an SSA_NAME, \n      - an INTEGER_CST,\n      - a PLUS_EXPR, \n+     - a POINTER_PLUS_EXPR, \n      - a MINUS_EXPR,\n      - an ASSERT_EXPR,\n      - other cases are not yet handled.  */\n-  switch (TREE_CODE (rhs))\n+  code = TREE_CODE (rhs);\n+  switch (code)\n     {\n     case NOP_EXPR:\n       /* This assignment is under the form \"a_1 = (cast) rhs.  */\n@@ -1043,6 +1046,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t(loop, SSA_NAME_DEF_STMT (rhs), halting_phi, evolution_of_loop, limit);\n       break;\n       \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       /* This case is under the form \"rhs0 + rhs1\".  */\n       rhs0 = TREE_OPERAND (rhs, 0);\n@@ -1071,7 +1075,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, \n \t\t   chrec_convert (type_rhs, evol, at_stmt), \n-\t\t   PLUS_EXPR, rhs1, at_stmt);\n+\t\t   code, rhs1, at_stmt);\n \t      \n \t      else if (res == t_false)\n \t\t{\n@@ -1083,7 +1087,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t\t    *evolution_of_loop = add_to_evolution \n \t\t      (loop->num, \n \t\t       chrec_convert (type_rhs, *evolution_of_loop, at_stmt), \n-\t\t       PLUS_EXPR, rhs0, at_stmt);\n+\t\t       code, rhs0, at_stmt);\n \n \t\t  else if (res == t_dont_know)\n \t\t    *evolution_of_loop = chrec_dont_know;\n@@ -1104,7 +1108,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t\t*evolution_of_loop = add_to_evolution \n \t\t  (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n \t\t\t\t\t     at_stmt),\n-\t\t   PLUS_EXPR, rhs1, at_stmt);\n+\t\t   code, rhs1, at_stmt);\n \n \t      else if (res == t_dont_know)\n \t\t*evolution_of_loop = chrec_dont_know;\n@@ -1122,7 +1126,7 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t    *evolution_of_loop = add_to_evolution \n \t      (loop->num, chrec_convert (type_rhs, *evolution_of_loop,\n \t\t\t\t\t at_stmt),\n-\t       PLUS_EXPR, rhs0, at_stmt);\n+\t       code, rhs0, at_stmt);\n \n \t  else if (res == t_dont_know)\n \t    *evolution_of_loop = chrec_dont_know;\n@@ -1611,6 +1615,16 @@ interpret_rhs_modify_stmt (struct loop *loop, tree at_stmt,\n \n   switch (TREE_CODE (opnd1))\n     {\n+    case POINTER_PLUS_EXPR:\n+      opnd10 = TREE_OPERAND (opnd1, 0);\n+      opnd11 = TREE_OPERAND (opnd1, 1);\n+      chrec10 = analyze_scalar_evolution (loop, opnd10);\n+      chrec11 = analyze_scalar_evolution (loop, opnd11);\n+      chrec10 = chrec_convert (type, chrec10, at_stmt);\n+      chrec11 = chrec_convert (sizetype, chrec11, at_stmt);\n+      res = chrec_fold_plus (type, chrec10, chrec11);\n+      break;\n+\n     case PLUS_EXPR:\n       opnd10 = TREE_OPERAND (opnd1, 0);\n       opnd11 = TREE_OPERAND (opnd1, 1);\n@@ -1702,187 +1716,6 @@ compute_scalar_evolution_in_loop (struct loop *wrto_loop,\n   return analyze_scalar_evolution_1 (wrto_loop, res, chrec_not_analyzed_yet);\n }\n \n-/* Folds EXPR, if it is a cast to pointer, assuming that the created\n-   polynomial_chrec does not wrap.  */\n-\n-static tree\n-fold_used_pointer_cast (tree expr)\n-{\n-  tree op;\n-  tree type, inner_type;\n-\n-  if (TREE_CODE (expr) != NOP_EXPR && TREE_CODE (expr) != CONVERT_EXPR)\n-    return expr;\n-\n-  op = TREE_OPERAND (expr, 0);\n-  if (TREE_CODE (op) != POLYNOMIAL_CHREC)\n-    return expr;\n-\n-  type = TREE_TYPE (expr);\n-  inner_type = TREE_TYPE (op);\n-\n-  if (!INTEGRAL_TYPE_P (inner_type)\n-      || TYPE_PRECISION (inner_type) != TYPE_PRECISION (type))\n-    return expr;\n-\n-  return build_polynomial_chrec (CHREC_VARIABLE (op),\n-\t\tchrec_convert (type, CHREC_LEFT (op), NULL_TREE),\n-\t\tchrec_convert (type, CHREC_RIGHT (op), NULL_TREE));\n-}\n-\n-/* Returns true if EXPR is an expression corresponding to offset of pointer\n-   in p + offset.  */\n-\n-static bool\n-pointer_offset_p (tree expr)\n-{\n-  if (TREE_CODE (expr) == INTEGER_CST)\n-    return true;\n-\n-  if ((TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (expr, 0))))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* EXPR is a scalar evolution of a pointer that is dereferenced or used in\n-   comparison.  This means that it must point to a part of some object in\n-   memory, which enables us to argue about overflows and possibly simplify\n-   the EXPR.  AT_STMT is the statement in which this conversion has to be\n-   performed.  Returns the simplified value.\n-\n-   Currently, for\n-\n-   int i, n;\n-   int *p;\n-\n-   for (i = -n; i < n; i++)\n-     *(p + i) = ...;\n-\n-   We generate the following code (assuming that size of int and size_t is\n-   4 bytes):\n-\n-   for (i = -n; i < n; i++)\n-     {\n-       size_t tmp1, tmp2;\n-       int *tmp3, *tmp4;\n-\n-       tmp1 = (size_t) i;\t(1)\n-       tmp2 = 4 * tmp1;\t\t(2)\n-       tmp3 = (int *) tmp2;\t(3)\n-       tmp4 = p + tmp3;\t\t(4)\n-\n-       *tmp4 = ...;\n-     }\n-\n-   We in general assume that pointer arithmetics does not overflow (since its\n-   behavior is undefined in that case).  One of the problems is that our\n-   translation does not capture this property very well -- (int *) is\n-   considered unsigned, hence the computation in (4) does overflow if i is\n-   negative.\n-\n-   This impreciseness creates complications in scev analysis.  The scalar\n-   evolution of i is [-n, +, 1].  Since int and size_t have the same precision\n-   (in this example), and size_t is unsigned (so we do not care about\n-   overflows), we succeed to derive that scev of tmp1 is [(size_t) -n, +, 1]\n-   and scev of tmp2 is [4 * (size_t) -n, +, 4].  With tmp3, we run into\n-   problem -- [(int *) (4 * (size_t) -n), +, 4] wraps, and since we on several\n-   places assume that this is not the case for scevs with pointer type, we\n-   cannot use this scev for tmp3; hence, its scev is\n-   (int *) [(4 * (size_t) -n), +, 4], and scev of tmp4 is\n-   p + (int *) [(4 * (size_t) -n), +, 4].  Most of the optimizers are unable to\n-   work with scevs of this shape.\n-\n-   However, since tmp4 is dereferenced, all its values must belong to a single\n-   object, and taking into account that the precision of int * and size_t is\n-   the same, it is impossible for its scev to wrap.  Hence, we can derive that\n-   its evolution is [p + (int *) (4 * (size_t) -n), +, 4], which the optimizers\n-   can work with.\n-\n-   ??? Maybe we should use different representation for pointer arithmetics,\n-   however that is a long-term project with a lot of potential for creating\n-   bugs.  */\n-\n-static tree\n-fold_used_pointer (tree expr, tree at_stmt)\n-{\n-  tree op0, op1, new0, new1;\n-  enum tree_code code = TREE_CODE (expr);\n-\n-  if (code == PLUS_EXPR\n-      || code == MINUS_EXPR)\n-    {\n-      op0 = TREE_OPERAND (expr, 0);\n-      op1 = TREE_OPERAND (expr, 1);\n-\n-      if (pointer_offset_p (op1))\n-\t{\n-\t  new0 = fold_used_pointer (op0, at_stmt);\n-\t  new1 = fold_used_pointer_cast (op1);\n-\t}\n-      else if (code == PLUS_EXPR && pointer_offset_p (op0))\n-\t{\n-\t  new0 = fold_used_pointer_cast (op0);\n-\t  new1 = fold_used_pointer (op1, at_stmt);\n-\t}\n-      else\n-\treturn expr;\n-\n-      if (new0 == op0 && new1 == op1)\n-\treturn expr;\n-\n-      new0 = chrec_convert (TREE_TYPE (expr), new0, at_stmt);\n-      new1 = chrec_convert (TREE_TYPE (expr), new1, at_stmt);\n-\n-      if (code == PLUS_EXPR)\n-\texpr = chrec_fold_plus (TREE_TYPE (expr), new0, new1);\n-      else\n-\texpr = chrec_fold_minus (TREE_TYPE (expr), new0, new1);\n-\n-      return expr;\n-    }\n-  else\n-    return fold_used_pointer_cast (expr);\n-}\n-\n-/* Returns true if PTR is dereferenced, or used in comparison.  */\n-\n-static bool\n-pointer_used_p (tree ptr)\n-{\n-  use_operand_p use_p;\n-  imm_use_iterator imm_iter;\n-  tree stmt, rhs;\n-  struct ptr_info_def *pi = get_ptr_info (ptr);\n-\n-  /* Check whether the pointer has a memory tag; if it does, it is\n-     (or at least used to be) dereferenced.  */\n-  if ((pi != NULL && pi->name_mem_tag != NULL)\n-      || symbol_mem_tag (SSA_NAME_VAR (ptr)))\n-    return true;\n-\n-  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, ptr)\n-    {\n-      stmt = USE_STMT (use_p);\n-      if (TREE_CODE (stmt) == COND_EXPR)\n-\treturn true;\n-\n-      if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n-\tcontinue;\n-\n-      rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n-      if (!COMPARISON_CLASS_P (rhs))\n-\tcontinue;\n-\n-      if (GIMPLE_STMT_OPERAND (stmt, 0) == ptr\n-\t  || GIMPLE_STMT_OPERAND (stmt, 1) == ptr)\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n /* Helper recursive function.  */\n \n static tree\n@@ -1932,11 +1765,6 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n     case GIMPLE_MODIFY_STMT:\n       res = interpret_rhs_modify_stmt (loop, def,\n \t  \t\t\t       GIMPLE_STMT_OPERAND (def, 1), type);\n-\n-      if (POINTER_TYPE_P (type)\n-\t  && !automatically_generated_chrec_p (res)\n-\t  && pointer_used_p (var))\n-\tres = fold_used_pointer (res, def);\n       break;\n \n     case PHI_NODE:\n@@ -2220,11 +2048,12 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n       if (CHREC_LEFT (chrec) != op0\n \t  || CHREC_RIGHT (chrec) != op1)\n \t{\n-\t  op1 = chrec_convert (chrec_type (op0), op1, NULL_TREE);\n+\t  op1 = chrec_convert_rhs (chrec_type (op0), op1, NULL_TREE);\n \t  chrec = build_polynomial_chrec (CHREC_VARIABLE (chrec), op0, op1);\n \t}\n       return chrec;\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n \t\t\t\t      flags, cache, size_expr);\n@@ -2240,7 +2069,7 @@ instantiate_parameters_1 (struct loop *loop, tree chrec, int flags, htab_t cache\n \t  || TREE_OPERAND (chrec, 1) != op1)\n \t{\n \t  op0 = chrec_convert (type, op0, NULL_TREE);\n-\t  op1 = chrec_convert (type, op1, NULL_TREE);\n+\t  op1 = chrec_convert_rhs (type, op1, NULL_TREE);\n \t  chrec = chrec_fold_plus (type, op0, op1);\n \t}\n       return chrec;"}, {"sha": "5606dca89ea278fc6bbc62720c14dd8b6b268160", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -290,9 +290,10 @@ tree_mem_ref_addr (tree type, tree mem_ref)\n \n   if (addr_off)\n     {\n-      addr = fold_convert (type, addr_off);\n       if (addr_base)\n-\taddr = fold_build2 (PLUS_EXPR, type, addr_base, addr);\n+\taddr = fold_build2 (POINTER_PLUS_EXPR, type, addr_base, addr_off);\n+      else\n+\taddr = fold_convert (type, addr_off);\n     }\n   else if (addr_base)\n     addr = addr_base;\n@@ -410,7 +411,7 @@ add_to_parts (struct mem_address *parts, tree elt)\n \n   if (!parts->index)\n     {\n-      parts->index = elt;\n+      parts->index = fold_convert (sizetype, elt);\n       return;\n     }\n \n@@ -482,7 +483,7 @@ most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr)\n \t  j++;\n \t  continue;\n \t}\n-  \n+\n       elt = fold_convert (sizetype, addr->elts[i].val);\n       if (mult_elt)\n \tmult_elt = fold_build2 (op_code, sizetype, mult_elt, elt);\n@@ -658,9 +659,9 @@ create_mem_ref (block_stmt_iterator *bsi, tree type, aff_tree *addr)\n \t{\n \t  atype = TREE_TYPE (parts.base);\n \t  parts.base = force_gimple_operand_bsi (bsi, \n-\t\t\tfold_build2 (PLUS_EXPR, atype,\n+\t\t\tfold_build2 (POINTER_PLUS_EXPR, atype,\n \t\t\t\t     parts.base,\n-\t\t\t\t     fold_convert (atype, parts.offset)),\n+\t\t\t\t     fold_convert (sizetype, parts.offset)),\n \t\t\ttrue, NULL_TREE);\n \t}\n       else"}, {"sha": "0ea8675ae6b7deccc7a9e7293cd793cf502e3cdc", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -1853,8 +1853,8 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n   if (t)\n     return t;\n \n-  /* Add in any offset from a PLUS_EXPR.  */\n-  if (TREE_CODE (base) == PLUS_EXPR)\n+  /* Add in any offset from a POINTER_PLUS_EXPR.  */\n+  if (TREE_CODE (base) == POINTER_PLUS_EXPR)\n     {\n       tree offset2;\n \n@@ -1863,7 +1863,8 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n \treturn NULL_TREE;\n       base = TREE_OPERAND (base, 0);\n \n-      offset = int_const_binop (PLUS_EXPR, offset, offset2, 1);\n+      offset = fold_convert (sizetype,\n+\t\t\t     int_const_binop (PLUS_EXPR, offset, offset2, 1));\n     }\n \n   if (TREE_CODE (base) == ADDR_EXPR)\n@@ -1923,7 +1924,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n }\n \n \n-/* A subroutine of fold_stmt_r.  EXPR is a PLUS_EXPR.\n+/* A subroutine of fold_stmt_r.  EXPR is a POINTER_PLUS_EXPR.\n \n    A quaint feature extant in our address arithmetic is that there\n    can be hidden type changes here.  The type of the result need\n@@ -1932,7 +1933,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n    What we're after here is an expression of the form\n \t(T *)(&array + const)\n    where the cast doesn't actually exist, but is implicit in the\n-   type of the PLUS_EXPR.  We'd like to turn this into\n+   type of the POINTER_PLUS_EXPR.  We'd like to turn this into\n \t&array[x]\n    which may be able to propagate further.  */\n \n@@ -1944,18 +1945,9 @@ maybe_fold_stmt_addition (tree expr)\n   tree ptr_type = TREE_TYPE (expr);\n   tree ptd_type;\n   tree t;\n-  bool subtract = (TREE_CODE (expr) == MINUS_EXPR);\n \n-  /* We're only interested in pointer arithmetic.  */\n-  if (!POINTER_TYPE_P (ptr_type))\n-    return NULL_TREE;\n-  /* Canonicalize the integral operand to op1.  */\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (op0)))\n-    {\n-      if (subtract)\n-\treturn NULL_TREE;\n-      t = op0, op0 = op1, op1 = t;\n-    }\n+  gcc_assert (TREE_CODE (expr) == POINTER_PLUS_EXPR);\n+\n   /* It had better be a constant.  */\n   if (TREE_CODE (op1) != INTEGER_CST)\n     return NULL_TREE;\n@@ -2001,32 +1993,11 @@ maybe_fold_stmt_addition (tree expr)\n       array_idx = int_const_binop (MULT_EXPR, array_idx, elt_size, 0);\n \n       /* Update the operands for the next round, or for folding.  */\n-      /* If we're manipulating unsigned types, then folding into negative\n-\t values can produce incorrect results.  Particularly if the type\n-\t is smaller than the width of the pointer.  */\n-      if (subtract\n-\t  && TYPE_UNSIGNED (TREE_TYPE (op1))\n-\t  && tree_int_cst_lt (array_idx, op1))\n-\treturn NULL;\n-      op1 = int_const_binop (subtract ? MINUS_EXPR : PLUS_EXPR,\n+      op1 = int_const_binop (PLUS_EXPR,\n \t\t\t     array_idx, op1, 0);\n-      subtract = false;\n       op0 = array_obj;\n     }\n \n-  /* If we weren't able to fold the subtraction into another array reference,\n-     canonicalize the integer for passing to the array and component ref\n-     simplification functions.  */\n-  if (subtract)\n-    {\n-      if (TYPE_UNSIGNED (TREE_TYPE (op1)))\n-\treturn NULL;\n-      op1 = fold_unary (NEGATE_EXPR, TREE_TYPE (op1), op1);\n-      /* ??? In theory fold should always produce another integer.  */\n-      if (op1 == NULL || TREE_CODE (op1) != INTEGER_CST)\n-\treturn NULL;\n-    }\n-\n   ptd_type = TREE_TYPE (ptr_type);\n \n   /* At which point we can try some of the same things as for indirects.  */\n@@ -2116,8 +2087,7 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n         recompute_tree_invariant_for_addr_expr (expr);\n       return NULL_TREE;\n \n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n       t = walk_tree (&TREE_OPERAND (expr, 0), fold_stmt_r, data, NULL);\n       if (t)\n \treturn t;"}, {"sha": "29ee8887230f1864fc4cec19215dd3052124a08a", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 13, "deletions": 38, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -504,35 +504,26 @@ forward_propagate_addr_into_variable_array_index (tree offset,\n {\n   tree index;\n \n-  /* The offset must be defined by a simple GIMPLE_MODIFY_STMT statement.  */\n-  if (TREE_CODE (offset) != GIMPLE_MODIFY_STMT)\n-    return false;\n-\n-  /* The RHS of the statement which defines OFFSET must be a gimple\n-     cast of another SSA_NAME.  */\n-  offset = GIMPLE_STMT_OPERAND (offset, 1);\n-  if (!is_gimple_cast (offset))\n-    return false;\n-\n-  offset = TREE_OPERAND (offset, 0);\n-  if (TREE_CODE (offset) != SSA_NAME)\n-    return false;\n-\n   /* Try to find an expression for a proper index.  This is either\n      a multiplication expression by the element size or just the\n      ssa name we came along in case the element size is one.  */\n   if (integer_onep (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (def_rhs)))))\n     index = offset;\n   else\n     {\n+      /* Get the offset's defining statement.  */\n       offset = SSA_NAME_DEF_STMT (offset);\n \n-      /* The RHS of the statement which defines OFFSET must be a\n-\t multiplication of an object by the size of the array elements.  */\n+      /* The statement which defines OFFSET before type conversion\n+         must be a simple GIMPLE_MODIFY_STMT.  */\n       if (TREE_CODE (offset) != GIMPLE_MODIFY_STMT)\n \treturn false;\n \n-      offset = GIMPLE_STMT_OPERAND (offset, 1);\n+      /* The RHS of the statement which defines OFFSET must be a\n+\t multiplication of an object by the size of the array elements. \n+\t This implicitly verifies that the size of the array elements\n+\t is constant.  */\n+     offset = GIMPLE_STMT_OPERAND (offset, 1);\n       if (TREE_CODE (offset) != MULT_EXPR\n \t  || TREE_CODE (TREE_OPERAND (offset, 1)) != INTEGER_CST\n \t  || !simple_cst_equal (TREE_OPERAND (offset, 1),\n@@ -642,12 +633,12 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n       || !integer_zerop (TREE_OPERAND (array_ref, 1)))\n     return false;\n \n-  /* If the use of the ADDR_EXPR must be a PLUS_EXPR, or else there\n+  /* If the use of the ADDR_EXPR is not a POINTER_PLUS_EXPR, there\n      is nothing to do. */\n-  if (TREE_CODE (rhs) != PLUS_EXPR)\n+  if (TREE_CODE (rhs) != POINTER_PLUS_EXPR)\n     return false;\n \n-  /* Try to optimize &x[0] + C where C is a multiple of the size\n+  /* Try to optimize &x[0] p+ C where C is a multiple of the size\n      of the elements in X into &x[C/element size].  */\n   if (TREE_OPERAND (rhs, 0) == name\n       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n@@ -671,7 +662,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n \t}\n     }\n \n-  /* Try to optimize &x[0] + OFFSET where OFFSET is defined by\n+  /* Try to optimize &x[0] p+ OFFSET where OFFSET is defined by\n      converting a multiplication of an index by the size of the\n      array elements, then the result is converted into the proper\n      type for the arithmetic.  */\n@@ -682,24 +673,8 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n       && lang_hooks.types_compatible_p (TREE_TYPE (name), TREE_TYPE (rhs)))\n     {\n       bool res;\n-      tree offset_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 1));\n       \n-      res = forward_propagate_addr_into_variable_array_index (offset_stmt,\n-\t\t\t\t\t\t\t      def_rhs, use_stmt);\n-      return res;\n-    }\n-\t      \n-  /* Same as the previous case, except the operands of the PLUS_EXPR\n-     were reversed.  */\n-  if (TREE_OPERAND (rhs, 1) == name\n-      && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n-      /* Avoid problems with IVopts creating PLUS_EXPRs with a\n-\t different type than their operands.  */\n-      && lang_hooks.types_compatible_p (TREE_TYPE (name), TREE_TYPE (rhs)))\n-    {\n-      bool res;\n-      tree offset_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (rhs, 0));\n-      res = forward_propagate_addr_into_variable_array_index (offset_stmt,\n+      res = forward_propagate_addr_into_variable_array_index (TREE_OPERAND (rhs, 1),\n \t\t\t\t\t\t\t      def_rhs, use_stmt);\n       return res;\n     }"}, {"sha": "7337d0213f3d0b15a415438a495d1d28015794ae", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -755,7 +755,7 @@ static tree\n determine_base_object (tree expr)\n {\n   enum tree_code code = TREE_CODE (expr);\n-  tree base, obj, op0, op1;\n+  tree base, obj;\n \n   /* If this is a pointer casted to any type, we need to determine\n      the base object for the pointer; so handle conversions before\n@@ -785,20 +785,13 @@ determine_base_object (tree expr)\n       return fold_convert (ptr_type_node,\n \t\t           build_fold_addr_expr (base));\n \n+    case POINTER_PLUS_EXPR:\n+      return determine_base_object (TREE_OPERAND (expr, 0));\n+\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      op0 = determine_base_object (TREE_OPERAND (expr, 0));\n-      op1 = determine_base_object (TREE_OPERAND (expr, 1));\n-      \n-      if (!op1)\n-\treturn op0;\n-\n-      if (!op0)\n-\treturn (code == PLUS_EXPR\n-\t\t? op1\n-\t\t: fold_build1 (NEGATE_EXPR, ptr_type_node, op1));\n-\n-      return fold_build2 (code, ptr_type_node, op0, op1);\n+      /* Pointer addition is done solely using POINTER_PLUS_EXPR.  */\n+      gcc_unreachable ();\n \n     default:\n       return fold_convert (ptr_type_node, expr);\n@@ -3100,9 +3093,9 @@ force_expr_to_var_cost (tree expr)\n       symbol_cost = computation_cost (addr) + 1;\n \n       address_cost\n-\t= computation_cost (build2 (PLUS_EXPR, type,\n+\t= computation_cost (build2 (POINTER_PLUS_EXPR, type,\n \t\t\t\t    addr,\n-\t\t\t\t    build_int_cst (type, 2000))) + 1;\n+\t\t\t\t    build_int_cst (sizetype, 2000))) + 1;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"force_expr_to_var_cost:\\n\");\n@@ -3141,6 +3134,7 @@ force_expr_to_var_cost (tree expr)\n \n   switch (TREE_CODE (expr))\n     {\n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n@@ -3169,6 +3163,7 @@ force_expr_to_var_cost (tree expr)\n   mode = TYPE_MODE (TREE_TYPE (expr));\n   switch (TREE_CODE (expr))\n     {\n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n       cost = add_cost (mode);"}, {"sha": "3354fdea6df5e73044805fc1fcd254d242656124", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -96,7 +96,13 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \t    }\n \t}\n     }\n-\n+  if (POINTER_TYPE_P (TREE_TYPE (base)))\n+    {\n+      step = fold_convert (sizetype, step);\n+      if (incr_op == MINUS_EXPR)\n+\tstep = fold_build1 (NEGATE_EXPR, sizetype, step);\n+      incr_op = POINTER_PLUS_EXPR;\n+    }\n   /* Gimplify the step if necessary.  We put the computations in front of the\n      loop (i.e. the step should be loop invariant).  */\n   step = force_gimple_operand (step, &stmts, true, var);"}, {"sha": "966e52b06b395282881e6a02e1dce12d51a9b9bb", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -85,6 +85,7 @@ split_to_var_and_offset (tree expr, tree *var, mpz_t offset)\n       /* Fallthru.  */\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n       op0 = TREE_OPERAND (expr, 0);\n       op1 = TREE_OPERAND (expr, 1);\n \n@@ -678,12 +679,15 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n   mpz_t mmod;\n   tree assumption = boolean_true_node, bound, noloop;\n   bool ret = false;\n+  tree type1 = type;\n+  if (POINTER_TYPE_P (type))\n+    type1 = sizetype;\n \n   if (TREE_CODE (mod) != INTEGER_CST)\n     return false;\n   if (integer_nonzerop (mod))\n     mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n-  tmod = fold_convert (type, mod);\n+  tmod = fold_convert (type1, mod);\n \n   mpz_init (mmod);\n   mpz_set_double_int (mmod, tree_to_double_int (mod), true);\n@@ -697,7 +701,7 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n       if (!iv1->no_overflow && !integer_zerop (mod))\n \t{\n \t  bound = fold_build2 (MINUS_EXPR, type,\n-\t\t\t       TYPE_MAX_VALUE (type), tmod);\n+\t\t\t       TYPE_MAX_VALUE (type1), tmod);\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n \t  if (integer_zerop (assumption))\n@@ -708,7 +712,7 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n       else\n \tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n \t\t\t      iv0->base,\n-\t\t\t      fold_build2 (PLUS_EXPR, type,\n+\t\t\t      fold_build2 (PLUS_EXPR, type1,\n \t\t\t\t\t   iv1->base, tmod));\n     }\n   else\n@@ -718,8 +722,8 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \t iv0->base - MOD <= iv1->base. */\n       if (!iv0->no_overflow && !integer_zerop (mod))\n \t{\n-\t  bound = fold_build2 (PLUS_EXPR, type,\n-\t\t\t       TYPE_MIN_VALUE (type), tmod);\n+\t  bound = fold_build2 (PLUS_EXPR, type1,\n+\t\t\t       TYPE_MIN_VALUE (type1), tmod);\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n \t  if (integer_zerop (assumption))\n@@ -729,7 +733,7 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \tnoloop = boolean_false_node;\n       else\n \tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t      fold_build2 (MINUS_EXPR, type,\n+\t\t\t      fold_build2 (MINUS_EXPR, type1,\n \t\t\t\t\t   iv0->base, tmod),\n \t\t\t      iv1->base);\n     }\n@@ -830,7 +834,7 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t      struct tree_niter_desc *niter, bounds *bnds)\n {\n   tree assumption = boolean_true_node, bound, diff;\n-  tree mbz, mbzl, mbzr;\n+  tree mbz, mbzl, mbzr, type1;\n   bool rolls_p, no_overflow_p;\n   double_int dstep;\n   mpz_t mstep, max;\n@@ -888,46 +892,50 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   if (rolls_p && no_overflow_p)\n     return;\n+  \n+  type1 = type;\n+  if (POINTER_TYPE_P (type))\n+    type1 = sizetype;\n \n   /* Now the hard part; we must formulate the assumption(s) as expressions, and\n      we must be careful not to introduce overflow.  */\n \n   if (integer_nonzerop (iv0->step))\n     {\n-      diff = fold_build2 (MINUS_EXPR, type,\n-\t\t\t  iv0->step, build_int_cst (type, 1));\n+      diff = fold_build2 (MINUS_EXPR, type1,\n+\t\t\t  iv0->step, build_int_cst (type1, 1));\n \n       /* We need to know that iv0->base >= MIN + iv0->step - 1.  Since\n \t 0 address never belongs to any object, we can assume this for\n \t pointers.  */\n       if (!POINTER_TYPE_P (type))\n \t{\n-\t  bound = fold_build2 (PLUS_EXPR, type,\n+\t  bound = fold_build2 (PLUS_EXPR, type1,\n \t\t\t       TYPE_MIN_VALUE (type), diff);\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n \t}\n \n       /* And then we can compute iv0->base - diff, and compare it with\n \t iv1->base.  */      \n-      mbzl = fold_build2 (MINUS_EXPR, type, iv0->base, diff);\n+      mbzl = fold_build2 (MINUS_EXPR, type1, iv0->base, diff);\n       mbzr = iv1->base;\n     }\n   else\n     {\n-      diff = fold_build2 (PLUS_EXPR, type,\n-\t\t\t  iv1->step, build_int_cst (type, 1));\n+      diff = fold_build2 (PLUS_EXPR, type1,\n+\t\t\t  iv1->step, build_int_cst (type1, 1));\n \n       if (!POINTER_TYPE_P (type))\n \t{\n-\t  bound = fold_build2 (PLUS_EXPR, type,\n+\t  bound = fold_build2 (PLUS_EXPR, type1,\n \t\t\t       TYPE_MAX_VALUE (type), diff);\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n \t}\n \n       mbzl = iv0->base;\n-      mbzr = fold_build2 (MINUS_EXPR, type, iv1->base, diff);\n+      mbzr = fold_build2 (MINUS_EXPR, type1, iv1->base, diff);\n     }\n \n   if (!integer_nonzerop (assumption))\n@@ -1062,6 +1070,9 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t bounds *bnds)\n {\n   tree assumption;\n+  tree type1 = type;\n+  if (POINTER_TYPE_P (type))\n+    type1 = sizetype;\n \n   /* Say that IV0 is the control variable.  Then IV0 <= IV1 iff\n      IV0 < IV1 + 1, assuming that IV1 is not equal to the greatest\n@@ -1072,10 +1083,10 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n     {\n       if (integer_nonzerop (iv0->step))\n \tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t  iv1->base, TYPE_MAX_VALUE (type));\n+\t\t\t\t  iv1->base, TYPE_MAX_VALUE (type1));\n       else\n \tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t  iv0->base, TYPE_MIN_VALUE (type));\n+\t\t\t\t  iv0->base, TYPE_MIN_VALUE (type1));\n \n       if (integer_zerop (assumption))\n \treturn false;\n@@ -1085,13 +1096,13 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n     }\n \n   if (integer_nonzerop (iv0->step))\n-    iv1->base = fold_build2 (PLUS_EXPR, type,\n-\t\t\t     iv1->base, build_int_cst (type, 1));\n+    iv1->base = fold_build2 (PLUS_EXPR, type1,\n+\t\t\t     iv1->base, build_int_cst (type1, 1));\n   else\n-    iv0->base = fold_build2 (MINUS_EXPR, type,\n-\t\t\t     iv0->base, build_int_cst (type, 1));\n+    iv0->base = fold_build2 (MINUS_EXPR, type1,\n+\t\t\t     iv0->base, build_int_cst (type1, 1));\n \n-  bounds_add (bnds, double_int_one, type);\n+  bounds_add (bnds, double_int_one, type1);\n \n   return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite, bnds);\n }\n@@ -1433,7 +1444,8 @@ expand_simple_operations (tree expr)\n       && !is_gimple_min_invariant (e)\n       /* And increments and decrements by a constant are simple.  */\n       && !((TREE_CODE (e) == PLUS_EXPR\n-\t    || TREE_CODE (e) == MINUS_EXPR)\n+\t    || TREE_CODE (e) == MINUS_EXPR\n+\t    || TREE_CODE (e) == POINTER_PLUS_EXPR)\n \t   && is_gimple_min_invariant (TREE_OPERAND (e, 1))))\n     return expr;\n \n@@ -2205,6 +2217,7 @@ derive_constant_upper_bound (tree val)\n       return bnd;\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       op0 = TREE_OPERAND (val, 0);\n       op1 = TREE_OPERAND (val, 1);"}, {"sha": "4c965d19eb5185fafa0643675a73b437e279173a", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -375,7 +375,7 @@ idx_analyze_ref (tree base, tree *index, void *data)\n     return false;\n   istep = int_cst_value (step);\n \n-  if (TREE_CODE (ibase) == PLUS_EXPR\n+  if (TREE_CODE (ibase) == POINTER_PLUS_EXPR\n       && cst_and_fits_in_hwi (TREE_OPERAND (ibase, 1)))\n     {\n       idelta = int_cst_value (TREE_OPERAND (ibase, 1));\n@@ -891,8 +891,8 @@ issue_prefetch_ref (struct mem_ref *ref, unsigned unroll_factor, unsigned ahead)\n     {\n       /* Determine the address to prefetch.  */\n       delta = (ahead + ap * ref->prefetch_mod) * ref->group->step;\n-      addr = fold_build2 (PLUS_EXPR, ptr_type_node,\n-\t\t\t  addr_base, build_int_cst (ptr_type_node, delta));\n+      addr = fold_build2 (POINTER_PLUS_EXPR, ptr_type_node,\n+\t\t\t  addr_base, size_int (delta));\n       addr = force_gimple_operand_bsi (&bsi, unshare_expr (addr), true, NULL);\n \n       /* Create the prefetch instruction.  */"}, {"sha": "f1abf37308ae5fe7fae1aa9f12b5663585338949", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -3293,23 +3293,17 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n   VEC (ce_s, heap) *temp = NULL;\n   unsigned int rhsoffset = 0;\n \n-  if (TREE_CODE (expr) != PLUS_EXPR\n-      && TREE_CODE (expr) != MINUS_EXPR)\n+  if (TREE_CODE (expr) != POINTER_PLUS_EXPR)\n     return false;\n \n   op0 = TREE_OPERAND (expr, 0);\n   op1 = TREE_OPERAND (expr, 1);\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (op0)));\n \n   get_constraint_for (op0, &temp);\n-  if (POINTER_TYPE_P (TREE_TYPE (op0))\n-      && TREE_CODE (op1) == INTEGER_CST\n-      && TREE_CODE (expr) == PLUS_EXPR)\n-    {\n-      rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n-    }\n-  else\n-    return false;\n \n+  if (TREE_CODE (op1) == INTEGER_CST)\n+    rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n \n   for (i = 0; VEC_iterate (ce_s, lhsc, i, c); i++)\n     for (j = 0; VEC_iterate (ce_s, temp, j, c2); j++)"}, {"sha": "9c9206deb5a84cf9c9bd545ff12f5e4b9e63ca18", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -949,13 +949,15 @@ tree_ssa_useless_type_conversion_1 (tree outer_type, tree inner_type)\n   else if (INTEGRAL_TYPE_P (inner_type)\n            && INTEGRAL_TYPE_P (outer_type)\n \t   && TYPE_UNSIGNED (inner_type) == TYPE_UNSIGNED (outer_type)\n-\t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type)\n-\t   && simple_cst_equal (TYPE_MAX_VALUE (inner_type), TYPE_MAX_VALUE (outer_type))\n-\t   && simple_cst_equal (TYPE_MIN_VALUE (inner_type), TYPE_MIN_VALUE (outer_type)))\n+\t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type))\n     {\n+      tree min_inner = fold_convert (outer_type, TYPE_MIN_VALUE (inner_type));\n+      tree max_inner = fold_convert (outer_type, TYPE_MAX_VALUE (inner_type));\n       bool first_boolean = (TREE_CODE (inner_type) == BOOLEAN_TYPE);\n       bool second_boolean = (TREE_CODE (outer_type) == BOOLEAN_TYPE);\n-      if (first_boolean == second_boolean)\n+      if (simple_cst_equal (max_inner, TYPE_MAX_VALUE (outer_type))\n+\t  && simple_cst_equal (min_inner, TYPE_MIN_VALUE (outer_type))\n+\t  && first_boolean == second_boolean)\n \treturn true;\n     }\n "}, {"sha": "0c0d259705b46ef903a7bab9788232461e00240d", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -171,7 +171,8 @@ va_list_counter_bump (struct stdarg_info *si, tree counter, tree rhs,\n \t  continue;\n \t}\n \n-      if (TREE_CODE (rhs) == PLUS_EXPR\n+      if ((TREE_CODE (rhs) == POINTER_PLUS_EXPR\n+\t   || TREE_CODE (rhs) == PLUS_EXPR)\n \t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n \t  && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n \t  && host_integerp (TREE_OPERAND (rhs, 1), 1))\n@@ -229,7 +230,8 @@ va_list_counter_bump (struct stdarg_info *si, tree counter, tree rhs,\n \t  continue;\n \t}\n \n-      if (TREE_CODE (rhs) == PLUS_EXPR\n+      if ((TREE_CODE (rhs) == POINTER_PLUS_EXPR\n+\t   || TREE_CODE (rhs) == PLUS_EXPR)\n \t  && TREE_CODE (TREE_OPERAND (rhs, 0)) == SSA_NAME\n \t  && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n \t  && host_integerp (TREE_OPERAND (rhs, 1), 1))\n@@ -447,10 +449,11 @@ check_va_list_escapes (struct stdarg_info *si, tree lhs, tree rhs)\n   if (! POINTER_TYPE_P (TREE_TYPE (rhs)))\n     return;\n \n-  if ((TREE_CODE (rhs) == PLUS_EXPR\n-       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n-      || TREE_CODE (rhs) == NOP_EXPR\n-      || TREE_CODE (rhs) == CONVERT_EXPR)\n+ if (((TREE_CODE (rhs) == POINTER_PLUS_EXPR\n+       || TREE_CODE (rhs) == PLUS_EXPR)\n+      && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n+     || TREE_CODE (rhs) == NOP_EXPR\n+     || TREE_CODE (rhs) == CONVERT_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n \n   if (TREE_CODE (rhs) != SSA_NAME\n@@ -555,7 +558,7 @@ check_all_va_list_escapes (struct stdarg_info *si)\n \t\t     other_ap_temp = (some_type *) ap_temp;\n \t\t     ap = ap_temp;\n \t\t     statements.  */\n-\t\t  if ((TREE_CODE (rhs) == PLUS_EXPR\n+\t\t  if ((TREE_CODE (rhs) == POINTER_PLUS_EXPR\n \t\t       && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST)\n \t\t      || TREE_CODE (rhs) == NOP_EXPR\n \t\t      || TREE_CODE (rhs) == CONVERT_EXPR)"}, {"sha": "bf13f537ede092c93d741611dae9bc4c9083a075", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -347,7 +347,7 @@ process_assignment (tree ass, tree stmt, block_stmt_iterator call, tree *m,\n       *ass_var = dest;\n       return true;\n \n-      /* TODO -- Handle other codes (NEGATE_EXPR, MINUS_EXPR).  */\n+      /* TODO -- Handle other codes (NEGATE_EXPR, MINUS_EXPR, POINTER_PLUS_EXPR).  */\n \n     default:\n       return false;"}, {"sha": "d9152f95a6bfc5640e93f9ecd31a21118d1dbf27", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -635,14 +635,15 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n \n   /* Create base_offset */\n   base_offset = size_binop (PLUS_EXPR, base_offset, init);\n+  base_offset = fold_convert (sizetype, base_offset);\n   dest = create_tmp_var (TREE_TYPE (base_offset), \"base_off\");\n   add_referenced_var (dest);\n   base_offset = force_gimple_operand (base_offset, &new_stmt, false, dest);  \n   append_to_statement_list_force (new_stmt, new_stmt_list);\n \n   if (offset)\n     {\n-      tree tmp = create_tmp_var (TREE_TYPE (base_offset), \"offset\");\n+      tree tmp = create_tmp_var (sizetype, \"offset\");\n       tree step; \n \n       /* For interleaved access step we divide STEP by the size of the\n@@ -663,7 +664,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n     }\n   \n   /* base + base_offset */\n-  addr_base = fold_build2 (PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base,\n+  addr_base = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base,\n \t\t\t   base_offset);\n \n   vect_ptr_type = build_pointer_type (STMT_VINFO_VECTYPE (stmt_info));\n@@ -894,14 +895,14 @@ bump_vector_ptr (tree dataref_ptr, tree ptr_incr, block_stmt_iterator *bsi,\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree vptr_type = TREE_TYPE (dataref_ptr);\n   tree ptr_var = SSA_NAME_VAR (dataref_ptr);\n-  tree update = fold_convert (vptr_type, TYPE_SIZE_UNIT (vectype));\n+  tree update = TYPE_SIZE_UNIT (vectype);\n   tree incr_stmt;\n   ssa_op_iter iter;\n   use_operand_p use_p;\n   tree new_dataref_ptr;\n \n   incr_stmt = build_gimple_modify_stmt (ptr_var,\n-\t\t\t\t\tbuild2 (PLUS_EXPR, vptr_type,\n+\t\t\t\t\tbuild2 (POINTER_PLUS_EXPR, vptr_type,\n \t\t\t\t\t\tdataref_ptr, update));\n   new_dataref_ptr = make_ssa_name (ptr_var, incr_stmt);\n   GIMPLE_STMT_OPERAND (incr_stmt, 0) = new_dataref_ptr;\n@@ -5270,12 +5271,21 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n       init_expr = unshare_expr (initial_condition_in_loop_num (access_fn, \n \t\t\t\t\t\t\t       loop->num));\n \n-      ni = fold_build2 (PLUS_EXPR, TREE_TYPE (init_expr),\n-\t\t\tfold_build2 (MULT_EXPR, TREE_TYPE (init_expr),\n-\t\t\t\t     fold_convert (TREE_TYPE (init_expr), \n-\t\t\t\t\t\t   niters), \n-\t\t\t\t     step_expr),\n-\t\t\tinit_expr);\n+      if (POINTER_TYPE_P (TREE_TYPE (init_expr)))\n+\tni = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (init_expr), \n+\t\t\t  init_expr, \n+\t\t\t  fold_convert (sizetype, \n+\t\t\t\t\tfold_build2 (MULT_EXPR, TREE_TYPE (niters),\n+\t\t\t\t\t\t     niters, step_expr)));\n+      else\n+\tni = fold_build2 (PLUS_EXPR, TREE_TYPE (init_expr),\n+\t\t\t  fold_build2 (MULT_EXPR, TREE_TYPE (init_expr),\n+\t\t\t\t       fold_convert (TREE_TYPE (init_expr),\n+\t\t\t\t\t\t     niters),\n+\t\t\t\t       step_expr),\n+\t\t\t  init_expr);\n+\n+\n \n       var = create_tmp_var (TREE_TYPE (init_expr), \"tmp\");\n       add_referenced_var (var);\n@@ -5473,7 +5483,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n   \n       /* Create:  byte_misalign = addr & (vectype_size - 1)  */\n       byte_misalign = \n-        fold_build2 (BIT_AND_EXPR, type, start_addr, vectype_size_minus_1);\n+        fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), vectype_size_minus_1);\n   \n       /* Create:  elem_misalign = byte_misalign / element_size  */\n       elem_misalign ="}, {"sha": "8fba946ff6adeabdf6b8a5c6344bfca637726772", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -766,6 +766,10 @@ compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)\n      both integers.  */\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (val1))\n \t      == POINTER_TYPE_P (TREE_TYPE (val2)));\n+  /* Convert the two values into the same type.  This is needed because\n+     sizetype causes sign extension even for unsigned types.  */\n+  val2 = fold_convert (TREE_TYPE (val1), val2);\n+  STRIP_USELESS_TYPE_CONVERSION (val2);\n \n   if ((TREE_CODE (val1) == SSA_NAME\n        || TREE_CODE (val1) == PLUS_EXPR\n@@ -1494,10 +1498,14 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t\t    }\n \t\t  max = negative_overflow_infinity (TREE_TYPE (var_vr->min));\n \t\t}\n-\t      else\n+\t      else if (!POINTER_TYPE_P (TREE_TYPE (var_vr->min)))\n \t\tmax = fold_build2 (MINUS_EXPR, TREE_TYPE (var_vr->min),\n \t\t\t\t   anti_min,\n \t\t\t\t   build_int_cst (TREE_TYPE (var_vr->min), 1));\n+\t      else\n+\t\tmax = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (var_vr->min),\n+\t\t\t\t   anti_min,\n+\t\t\t\t   size_int (-1));\n \t      min = real_min;\n \t      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n \t    }\n@@ -1693,6 +1701,7 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n      meaningful way.  Handle only arithmetic operations.  */\n   if (code != PLUS_EXPR\n       && code != MINUS_EXPR\n+      && code != POINTER_PLUS_EXPR\n       && code != MULT_EXPR\n       && code != TRUNC_DIV_EXPR\n       && code != FLOOR_DIV_EXPR\n@@ -1763,26 +1772,30 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n       || POINTER_TYPE_P (TREE_TYPE (op0))\n       || POINTER_TYPE_P (TREE_TYPE (op1)))\n     {\n-      /* For pointer types, we are really only interested in asserting\n-\t whether the expression evaluates to non-NULL.  FIXME, we used\n-\t to gcc_assert (code == PLUS_EXPR || code == MINUS_EXPR), but\n-\t ivopts is generating expressions with pointer multiplication\n-\t in them.  */\n-      if (code == PLUS_EXPR)\n+      if (code == MIN_EXPR || code == MAX_EXPR)\n \t{\n-\t  if (range_is_nonnull (&vr0) || range_is_nonnull (&vr1))\n+\t  /* For MIN/MAX expressions with pointers, we only care about\n+\t     nullness, if both are non null, then the result is nonnull.\n+\t     If both are null, then the result is null. Otherwise they\n+\t     are varying.  */\n+\t  if (range_is_nonnull (&vr0) && range_is_nonnull (&vr1))\n \t    set_value_range_to_nonnull (vr, TREE_TYPE (expr));\n \t  else if (range_is_null (&vr0) && range_is_null (&vr1))\n \t    set_value_range_to_null (vr, TREE_TYPE (expr));\n \t  else\n \t    set_value_range_to_varying (vr);\n+\n+\t  return;\n \t}\n+      gcc_assert (code == POINTER_PLUS_EXPR);\n+      /* For pointer types, we are really only interested in asserting\n+\t whether the expression evaluates to non-NULL.  */\n+      if (range_is_nonnull (&vr0) || range_is_nonnull (&vr1))\n+\tset_value_range_to_nonnull (vr, TREE_TYPE (expr));\n+      else if (range_is_null (&vr0) && range_is_null (&vr1))\n+\tset_value_range_to_null (vr, TREE_TYPE (expr));\n       else\n-\t{\n-\t  /* Subtracting from a pointer, may yield 0, so just drop the\n-\t     resulting range to varying.  */\n-\t  set_value_range_to_varying (vr);\n-\t}\n+\tset_value_range_to_varying (vr);\n \n       return;\n     }"}, {"sha": "45e53ccda4b4540fe43a40931aeb9a45dc21841a", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -3069,6 +3069,16 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   gcc_assert (code != GIMPLE_MODIFY_STMT);\n #endif\n \n+  if ((code == MINUS_EXPR || code == PLUS_EXPR || code == MULT_EXPR)\n+      && arg0 && arg1 && tt && POINTER_TYPE_P (tt))\n+    gcc_assert (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST);\n+\n+  if (code == POINTER_PLUS_EXPR && arg0 && arg1 && tt)\n+    gcc_assert (POINTER_TYPE_P (tt) && POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t\t&& TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n+\t\t&& tree_ssa_useless_type_conversion_1 (sizetype,\n+\t\t\t\t\t\t       TREE_TYPE (arg1)));\n+\n   t = make_node_stat (code PASS_MEM_STAT);\n   TREE_TYPE (t) = tt;\n "}, {"sha": "d46499ab1e64716da393050d5cea17c23cd07d53", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -612,6 +612,10 @@ DEFTREECODE (PLUS_EXPR, \"plus_expr\", tcc_binary, 2)\n DEFTREECODE (MINUS_EXPR, \"minus_expr\", tcc_binary, 2)\n DEFTREECODE (MULT_EXPR, \"mult_expr\", tcc_binary, 2)\n \n+/* Pointer addition.  The first operand is always a pointer and the\n+   second operand is an integer of type sizetype.  */\n+DEFTREECODE (POINTER_PLUS_EXPR, \"pointer_plus_expr\", tcc_binary, 2)\n+\n /* Division for integer result that rounds the quotient toward zero.  */\n DEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", tcc_binary, 2)\n "}, {"sha": "511bf89e6ec080379566cb705581eff18daff76a", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5be014d5b728cf754020b8ab4df1cd029f69922e/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5be014d5b728cf754020b8ab4df1cd029f69922e", "patch": "@@ -2810,6 +2810,7 @@ const_hash_1 (const tree exp)\n       return hi;\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       return (const_hash_1 (TREE_OPERAND (exp, 0)) * 9\n \t      + const_hash_1 (TREE_OPERAND (exp, 1)));\n@@ -2956,6 +2957,7 @@ compare_constant (const tree t1, const tree t2)\n       }\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n     case RANGE_EXPR:\n       return (compare_constant (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0))\n@@ -3010,6 +3012,7 @@ copy_constant (tree exp)\n \t\t\t    copy_constant (TREE_IMAGPART (exp)));\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       return build2 (TREE_CODE (exp), TREE_TYPE (exp),\n \t\t     copy_constant (TREE_OPERAND (exp, 0)),\n@@ -3901,6 +3904,7 @@ compute_reloc_for_constant (tree exp)\n       break;\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n       reloc = compute_reloc_for_constant (TREE_OPERAND (exp, 0));\n       reloc |= compute_reloc_for_constant (TREE_OPERAND (exp, 1));\n       break;\n@@ -3970,6 +3974,7 @@ output_addressed_constants (tree exp)\n       break;\n \n     case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       output_addressed_constants (TREE_OPERAND (exp, 1));\n       /* Fall through.  */\n@@ -4147,6 +4152,7 @@ initializer_constant_valid_p (tree value, tree endtype)\n       }\n       break;\n \n+    case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n       if (! INTEGRAL_TYPE_P (endtype)\n \t  || TYPE_PRECISION (endtype) >= POINTER_SIZE)"}]}