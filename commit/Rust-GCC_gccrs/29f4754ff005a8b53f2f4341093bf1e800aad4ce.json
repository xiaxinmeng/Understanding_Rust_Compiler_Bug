{"sha": "29f4754ff005a8b53f2f4341093bf1e800aad4ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlmNDc1NGZmMDA1YThiNTNmMmY0MzQxMDkzYmYxZTgwMGFhZDRjZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-04-15T07:18:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-04-15T07:18:21Z"}, "message": "ada-tree.h (DECL_BY_COMPONENT_PTR_P): Use DECL_LANG_FLAG_3.\n\n\t* ada-tree.h (DECL_BY_COMPONENT_PTR_P): Use DECL_LANG_FLAG_3.\n\t* decl.c (gnat_to_gnu_entity) <object>: Call maybe_pad_type only\n\tif a size or alignment is specified.  Do not take into account\n\talignment promotions for the computation of the object's size.\n\t<type>: Call maybe_pad_type only if a size or alignment is specified.\n\t(maybe_pad_type): Really reuse the RM_Size of the original type if\n\trequested.\n\t* trans.c (Attribute_to_gnu): Fix a couple of nits.\n\t* utils2.c (build_binary_op) <MODIFY_EXPR>: Merge related conditional\n\tstatements.  Use the padded view of the type when copying between\n\tpadded objects of the same underlying type.\n\nFrom-SVN: r134310", "tree": {"sha": "0c68173537cdf9a84c8102d91ef9ec47541a5d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c68173537cdf9a84c8102d91ef9ec47541a5d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29f4754ff005a8b53f2f4341093bf1e800aad4ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f4754ff005a8b53f2f4341093bf1e800aad4ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f4754ff005a8b53f2f4341093bf1e800aad4ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f4754ff005a8b53f2f4341093bf1e800aad4ce/comments", "author": null, "committer": null, "parents": [{"sha": "55d7d0fa979fee55901c9ed8a65fd59461b70840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d7d0fa979fee55901c9ed8a65fd59461b70840", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d7d0fa979fee55901c9ed8a65fd59461b70840"}], "stats": {"total": 105, "additions": 68, "deletions": 37}, "files": [{"sha": "d00479bb92619c5cd8d1a4c6babe8bb94723f896", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=29f4754ff005a8b53f2f4341093bf1e800aad4ce", "patch": "@@ -1,3 +1,17 @@\n+2008-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ada-tree.h (DECL_BY_COMPONENT_PTR_P): Use DECL_LANG_FLAG_3.\n+\t* decl.c (gnat_to_gnu_entity) <object>: Call maybe_pad_type only\n+\tif a size or alignment is specified.  Do not take into account\n+\talignment promotions for the computation of the object's size.\n+\t<type>: Call maybe_pad_type only if a size or alignment is specified.\n+\t(maybe_pad_type): Really reuse the RM_Size of the original type if\n+\trequested.\n+\t* trans.c (Attribute_to_gnu): Fix a couple of nits.\n+\t* utils2.c (build_binary_op) <MODIFY_EXPR>: Merge related conditional\n+\tstatements.  Use the padded view of the type when copying between\n+\tpadded objects of the same underlying type.\n+\n 2008-04-14  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* vms_data.ads: Fix typo in constant."}, {"sha": "6c60adfbfa4acee3f32571e320829894d8ef9d2d", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=29f4754ff005a8b53f2f4341093bf1e800aad4ce", "patch": "@@ -243,13 +243,13 @@ struct lang_type GTY(()) {tree t; };\n    is needed to access the object.  */\n #define DECL_BY_REF_P(NODE) DECL_LANG_FLAG_1 (NODE)\n \n-/* Nonzero if this decl is a PARM_DECL for an Ada array being passed to a\n-   foreign convention subprogram.  */\n-#define DECL_BY_COMPONENT_PTR_P(NODE) DECL_LANG_FLAG_2 (PARM_DECL_CHECK (NODE))\n-\n /* Nonzero in a FIELD_DECL that is a dummy built for some internal reason.  */\n #define DECL_INTERNAL_P(NODE) DECL_LANG_FLAG_3 (FIELD_DECL_CHECK (NODE))\n \n+/* Nonzero if this decl is a PARM_DECL for an Ada array being passed to a\n+   foreign convention subprogram.  */\n+#define DECL_BY_COMPONENT_PTR_P(NODE) DECL_LANG_FLAG_3 (PARM_DECL_CHECK (NODE))\n+\n /* Nonzero in a FUNCTION_DECL that corresponds to an elaboration procedure.  */\n #define DECL_ELABORATION_PROC_P(NODE) \\\n   DECL_LANG_FLAG_3 (FUNCTION_DECL_CHECK (NODE))"}, {"sha": "2b2ec684668363bface036c6342e31e11208a48c", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=29f4754ff005a8b53f2f4341093bf1e800aad4ce", "patch": "@@ -516,6 +516,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool mutable_p = false;\n \ttree gnu_ext_name = NULL_TREE;\n \ttree renamed_obj = NULL_TREE;\n+\ttree gnu_object_size;\n \n \tif (Present (Renamed_Object (gnat_entity)) && !definition)\n \t  {\n@@ -771,9 +772,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  align = MINIMUM_ATOMIC_ALIGNMENT;\n #endif\n \n-\t/* Make a new type with the desired size and alignment, if needed. */\n-\tgnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n-\t\t\t\t   \"PAD\", false, definition, true);\n+\t/* Make a new type with the desired size and alignment, if needed.\n+\t   But do not take into account alignment promotions to compute the\n+\t   size of the object.  */\n+\tgnu_object_size = gnu_size ? gnu_size : TYPE_SIZE (gnu_type);\n+\tif (gnu_size || align > 0)\n+\t  gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n+\t\t\t\t     \"PAD\", false, definition,\n+\t\t\t\t     gnu_size ? true : false);\n \n \t/* Make a volatile version of this object's type if we are to make\n \t   the object volatile.  We also interpret 13.3(19) conservatively\n@@ -1290,16 +1296,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \tif (!used_by_ref && Unknown_Esize (gnat_entity))\n \t  {\n-\t    tree gnu_back_size;\n-\n \t    if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t\t&& TYPE_CONTAINS_TEMPLATE_P (gnu_type))\n-\t      gnu_back_size\n+\t      gnu_object_size\n \t\t= TYPE_SIZE (TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type))));\n-            else\n-\t      gnu_back_size = TYPE_SIZE (gnu_type);\n \n-\t    Set_Esize (gnat_entity, annotate_value (gnu_back_size));\n+\t    Set_Esize (gnat_entity, annotate_value (gnu_object_size));\n \t  }\n       }\n       break;\n@@ -4237,8 +4239,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* See if we need to pad the type.  If we did, and made a record,\n \t the name of the new type may be changed.  So get it back for\n \t us when we make the new TYPE_DECL below.  */\n-      gnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity, \"PAD\",\n-\t\t\t\t true, definition, false);\n+      if (gnu_size || align > 0)\n+\tgnu_type = maybe_pad_type (gnu_type, gnu_size, align, gnat_entity,\n+\t\t\t\t   \"PAD\", true, definition, false);\n+\n       if (TREE_CODE (gnu_type) == RECORD_TYPE\n \t  && TYPE_IS_PADDING_P (gnu_type))\n \t{\n@@ -5562,19 +5566,18 @@ make_packable_type (tree type, bool in_record)\n \n    DEFINITION is true if this type is being defined.\n \n-   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be\n-   set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n-   type.  */\n+   SAME_RM_SIZE is true if the RM_Size of the resulting type is to be set\n+   to SIZE too; otherwise, it's set to the RM_Size of the original type.  */\n \n tree\n maybe_pad_type (tree type, tree size, unsigned int align,\n \t\tEntity_Id gnat_entity, const char *name_trailer,\n \t\tbool is_user_type, bool definition, bool same_rm_size)\n {\n+  tree orig_rm_size = same_rm_size ? NULL_TREE : rm_size (type);\n   tree orig_size = TYPE_SIZE (type);\n   unsigned int orig_align = align;\n-  tree record;\n-  tree field;\n+  tree record, field;\n \n   /* If TYPE is a padded type, see if it agrees with any size and alignment\n      we were given.  If so, return the original type.  Otherwise, strip\n@@ -5673,9 +5676,9 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* Do not finalize it until after the auxiliary record is built.  */\n   finish_record_type (record, field, 1, true);\n \n-  /* Keep the RM_Size of the padded record as that of the old record\n-     if requested.  */\n-  SET_TYPE_ADA_SIZE (record, same_rm_size ? size : rm_size (type));\n+  /* Set the same size for its RM_size if requested; otherwise reuse\n+     the RM_size of the original type.  */\n+  SET_TYPE_ADA_SIZE (record, same_rm_size ? size : orig_rm_size);\n \n   /* Unless debugging information isn't being written for the input type,\n      write a record that shows what we are a subtype of and also make a"}, {"sha": "300ac780f200ab211af54208764a41d0f172fb13", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=29f4754ff005a8b53f2f4341093bf1e800aad4ce", "patch": "@@ -996,8 +996,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* Remove NOPS from gnu_expr and conversions from gnu_prefix.\n \t We only use GNU_EXPR to see if a COMPONENT_REF was involved. */\n       while (TREE_CODE (gnu_expr) == NOP_EXPR)\n-\tgnu_expr = TREE_OPERAND (gnu_expr, 0)\n-\t  ;\n+\tgnu_expr = TREE_OPERAND (gnu_expr, 0);\n \n       gnu_prefix = remove_conversions (gnu_prefix, true);\n       prefix_unused = true;\n@@ -1018,7 +1017,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       /* If we're looking for the size of a field, return the field size.\n \t Otherwise, if the prefix is an object, or if 'Object_Size or\n \t 'Max_Size_In_Storage_Elements has been specified, the result is the\n-\t GCC size of the type. Otherwise, the result is the RM_Size of the\n+\t GCC size of the type.  Otherwise, the result is the RM_Size of the\n \t type.  */\n       if (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n \tgnu_result = DECL_SIZE (TREE_OPERAND (gnu_prefix, 1));"}, {"sha": "5888bc583c47ad3b4f26edb0b0c21ad075fedb59", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29f4754ff005a8b53f2f4341093bf1e800aad4ce/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=29f4754ff005a8b53f2f4341093bf1e800aad4ce", "patch": "@@ -687,23 +687,38 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t  left_type = TREE_TYPE (left_operand);\n \t}\n \n-      if (!operation_type)\n-\toperation_type = left_type;\n-\n-      /* Find the best type to use for copying between aggregate types.  */\n-      if (((TREE_CODE (left_type) == ARRAY_TYPE\n-\t    && TREE_CODE (right_type) == ARRAY_TYPE)\n-\t   || (TREE_CODE (left_type) == RECORD_TYPE\n-\t       && TREE_CODE (right_type) == RECORD_TYPE))\n-\t  && (best_type = find_common_type (left_type, right_type)))\n-\toperation_type = best_type;\n-\n       /* If a class-wide type may be involved, force use of the RHS type.  */\n       if ((TREE_CODE (right_type) == RECORD_TYPE\n \t   || TREE_CODE (right_type) == UNION_TYPE)\n \t  && TYPE_ALIGN_OK (right_type))\n \toperation_type = right_type;\n \n+      /* If we are copying between padded objects of the same underlying\n+\t type with a non-zero size, use the padded view of the type, this\n+\t is very likely more efficient.  */\n+      else if (TREE_CODE (left_type) == RECORD_TYPE\n+\t       && TYPE_IS_PADDING_P (left_type)\n+\t       && TREE_TYPE (TYPE_FIELDS (left_type)) == right_type\n+\t       && !integer_zerop (TYPE_SIZE (right_type))\n+\t       && TREE_CODE (right_operand) == COMPONENT_REF\n+\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t  == RECORD_TYPE\n+\t       && TYPE_IS_PADDING_P\n+\t\t  (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n+\toperation_type = left_type;\n+\n+      /* Find the best type to use for copying between aggregate types.  */\n+      else if (((TREE_CODE (left_type) == ARRAY_TYPE\n+\t\t && TREE_CODE (right_type) == ARRAY_TYPE)\n+\t\t|| (TREE_CODE (left_type) == RECORD_TYPE\n+\t\t    && TREE_CODE (right_type) == RECORD_TYPE))\n+\t       && (best_type = find_common_type (left_type, right_type)))\n+\toperation_type = best_type;\n+\n+      /* Otherwise use the LHS type.  */\n+      else if (!operation_type)\n+\toperation_type = left_type;\n+\n       /* Ensure everything on the LHS is valid.  If we have a field reference,\n \t strip anything that get_inner_reference can handle.  Then remove any\n \t conversions between types having the same code and mode.  And mark"}]}