{"sha": "ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM4YTFkZDVhOGZjYTFiNGMxMzQ1MjJhMzM3ZTJmNjZlMWRlNjg2Yg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-07-25T12:50:44Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-07-25T12:50:44Z"}, "message": "[multiple changes]\n\n2003-07-25  Mark Wielaard  <mark@klomp.org>\n\n\t* Makefile.am (awt_java_source_files): java/awt/GridBagLayoutInfo.java\n\tadded.\n\t* Makefile.in: Likewise.\n\n2003-07-25  Jeroen Frijters  <jeroen@frijters.net>\n\n\t* java/awt/Component.java\n\t(getPreferredSize): Call preferredSize.\n\t(preferredSize): Moved body of getPreferredSize here.\n\t(getMinimumSize): Call minimumSize.\n\t(minimumSize): Moved body of getMinimumSize here.\n\t(prepareImage): Fall back on Toolkit.prepareImage if there is no peer\n\t(checkImage(Image,ImageObserver)): Don't call getWidth/getHeight, but\n\tpass -1\n\t* java/awt/Container.java\n\t(validate): Don't validate if there is no peer.\n\t(update): Clear background before calling paint.\n\t* java/awt/GridBagLayout.java\n\tCompleted the implementation and fixed several bugs.\n\t* java/awt/MediaTracker.java\n\t(MediaEntry.imageUpdate): Fixed typo. & instead of | was used to\n\tcombine flags.\n\t* java/awt/Window.java\n\t(Window): Don't call setVisible(false). Windows are invisible by\n\tdefault and calling virtual methods from constructor causes\n\tcompatibility problems (e.g. subclasses may assume that the peer\n\talready exists).\n\n2003-07-25  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/GridBagLayout.java:\n\tTotally reworked and partly implemented.\n\t* java/awt/GridBagLayoutInfo.java:\n\tNew file.\n\nFrom-SVN: r69785", "tree": {"sha": "8d66ae82e4f61f694871339ba9479724ddce0bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d66ae82e4f61f694871339ba9479724ddce0bea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/comments", "author": null, "committer": null, "parents": [{"sha": "0fe37f686827a4d6c12d766ecb6d2b99fb0a286b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe37f686827a4d6c12d766ecb6d2b99fb0a286b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe37f686827a4d6c12d766ecb6d2b99fb0a286b"}], "stats": {"total": 838, "additions": 765, "deletions": 73}, "files": [{"sha": "2e34c9a2ea1cc435e18183961d4d75a44aec58ea", "filename": "libjava/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -1,3 +1,40 @@\n+2003-07-25  Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.am (awt_java_source_files): java/awt/GridBagLayoutInfo.java\n+\tadded.\n+\t* Makefile.in: Likewise.\n+\n+2003-07-25  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/awt/Component.java\n+\t(getPreferredSize): Call preferredSize.\n+\t(preferredSize): Moved body of getPreferredSize here.\n+\t(getMinimumSize): Call minimumSize.\n+\t(minimumSize): Moved body of getMinimumSize here.\n+\t(prepareImage): Fall back on Toolkit.prepareImage if there is no peer\n+\t(checkImage(Image,ImageObserver)): Don't call getWidth/getHeight, but\n+\tpass -1\n+\t* java/awt/Container.java\n+\t(validate): Don't validate if there is no peer.\n+\t(update): Clear background before calling paint.\n+\t* java/awt/GridBagLayout.java\n+\tCompleted the implementation and fixed several bugs.\n+\t* java/awt/MediaTracker.java\n+\t(MediaEntry.imageUpdate): Fixed typo. & instead of | was used to\n+\tcombine flags.\n+\t* java/awt/Window.java\n+\t(Window): Don't call setVisible(false). Windows are invisible by\n+\tdefault and calling virtual methods from constructor causes\n+\tcompatibility problems (e.g. subclasses may assume that the peer\n+\talready exists).\n+\n+2003-07-25  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/GridBagLayout.java:\n+\tTotally reworked and partly implemented.\n+\t* java/awt/GridBagLayoutInfo.java:\n+\tNew file.\n+\n 2003-07-24  Thomas Fitzsimmons  <fitzsim@redhat.com>\n \n \t* jni/gtk-peer/gnu_java_awt_peer_gtk_GtkLabelPeer.c (create):"}, {"sha": "4e02c07ab4a5fd5440db0e5446e97b598c5ae16c", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -818,6 +818,7 @@ java/awt/Graphics2D.java \\\n java/awt/GraphicsConfiguration.java \\\n java/awt/GridBagConstraints.java \\\n java/awt/GridBagLayout.java \\\n+java/awt/GridBagLayoutInfo.java \\\n java/awt/GridLayout.java \\\n java/awt/IllegalComponentStateException.java \\\n java/awt/Image.java \\"}, {"sha": "11cf8ba10098ccba84e6a6d81acbba4c6eb8e19d", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -589,6 +589,7 @@ java/awt/Graphics2D.java \\\n java/awt/GraphicsConfiguration.java \\\n java/awt/GridBagConstraints.java \\\n java/awt/GridBagLayout.java \\\n+java/awt/GridBagLayoutInfo.java \\\n java/awt/GridLayout.java \\\n java/awt/IllegalComponentStateException.java \\\n java/awt/Image.java \\\n@@ -3094,6 +3095,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/awt/GraphicsConfiguration.P .deps/java/awt/GraphicsDevice.P \\\n .deps/java/awt/GraphicsEnvironment.P \\\n .deps/java/awt/GridBagConstraints.P .deps/java/awt/GridBagLayout.P \\\n+.deps/java/awt/GridBagLayoutInfo.P \\\n .deps/java/awt/GridLayout.P .deps/java/awt/HeadlessException.P \\\n .deps/java/awt/IllegalComponentStateException.P .deps/java/awt/Image.P \\\n .deps/java/awt/ImageCapabilities.P .deps/java/awt/Insets.P \\"}, {"sha": "9a38919f1c574ebb48b1aaf6330f41618701c5e1", "filename": "libjava/java/awt/Component.java", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FComponent.java?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -1452,12 +1452,7 @@ public boolean isLightweight()\n    */\n   public Dimension getPreferredSize()\n   {\n-    if (prefSize == null)\n-      if (peer == null)\n-\treturn new Dimension(width, height);\n-      else \n-        prefSize = peer.getPreferredSize();\n-    return prefSize;\n+    return preferredSize();\n   }\n \n   /**\n@@ -1468,7 +1463,12 @@ public Dimension getPreferredSize()\n    */\n   public Dimension preferredSize()\n   {\n-    return getPreferredSize();\n+    if (prefSize == null)\n+      if (peer == null)\n+\treturn new Dimension(width, height);\n+      else \n+        prefSize = peer.getPreferredSize();\n+    return prefSize;\n   }\n \n   /**\n@@ -1480,10 +1480,7 @@ public Dimension preferredSize()\n    */\n   public Dimension getMinimumSize()\n   {\n-    if (minSize == null)\n-      minSize = (peer != null ? peer.getMinimumSize()\n-                 : new Dimension(width, height));\n-    return minSize;\n+    return minimumSize();\n   }\n \n   /**\n@@ -1494,7 +1491,10 @@ public Dimension getMinimumSize()\n    */\n   public Dimension minimumSize()\n   {\n-    return getMinimumSize();\n+    if (minSize == null)\n+      minSize = (peer != null ? peer.getMinimumSize()\n+                 : new Dimension(width, height));\n+    return minSize;\n   }\n \n   /**\n@@ -1941,7 +1941,10 @@ public boolean prepareImage(Image image, ImageObserver observer)\n   public boolean prepareImage(Image image, int width, int height,\n                               ImageObserver observer)\n   {\n-    return peer.prepareImage(image, width, height, observer);\n+    if (peer != null)\n+\treturn peer.prepareImage(image, width, height, observer);\n+    else\n+\treturn getToolkit().prepareImage(image, width, height, observer);\n   }\n \n   /**\n@@ -1957,8 +1960,7 @@ public boolean prepareImage(Image image, int width, int height,\n    */\n   public int checkImage(Image image, ImageObserver observer)\n   {\n-    return checkImage(image, image.getWidth(observer),\n-                      image.getHeight(observer), observer);\n+    return checkImage(image, -1, -1, observer);\n   }\n \n   /**"}, {"sha": "226d5496724fa94a8e092b84f9726cb60b127142", "filename": "libjava/java/awt/Container.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FContainer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FContainer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FContainer.java?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -473,7 +473,7 @@ public void validate()\n   {\n     synchronized (getTreeLock ())\n       {\n-        if (! isValid())\n+        if (! isValid() && peer != null)\n           {\n             validateTree();\n           }\n@@ -658,6 +658,7 @@ public void paint(Graphics g)\n    */\n   public void update(Graphics g)\n   {\n+    g.clearRect(0, 0, width, height);\n     super.update(g);\n   }\n "}, {"sha": "dd49a1cf905d31f33680a11138bc470e360af665", "filename": "libjava/java/awt/GridBagLayout.java", "status": "modified", "additions": 633, "deletions": 53, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FGridBagLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagLayout.java?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -1,5 +1,5 @@\n /* GridBagLayout - Layout manager for components according to GridBagConstraints\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,64 +35,644 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.awt;\n \n import java.io.Serializable;\n+import java.util.Hashtable;\n \n /**\n- * Stub implementation.\n+ * @author Michael Koch <konqueror@gmx.de>\n+ * @author Jeroen Frijters <jeroen@frijters.net>\n  */\n public class GridBagLayout\n-  implements Serializable, LayoutManager2\n+    implements Serializable, LayoutManager2\n {\n-  static final long serialVersionUID = 8838754796412211005L;\n-\n-  public void addLayoutComponent(String name, Component component)\n-  {\n-  }\n-\n-  public void removeLayoutComponent(Component component)\n-  {\n-  }\n-\n-  public Dimension preferredLayoutSize(Container parent)\n-  {\n-    return null;\n-  }\n-\n-  public Dimension minimumLayoutSize(Container parent)\n-  {\n-    return null;\n-  }\n-\n-  public void layoutContainer(Container parent)\n-  {\n-  }\n-\n-  public void addLayoutComponent(Component component, Object contraint)\n-  {\n-  }\n-\n-  public Dimension maximumLayoutSize(Container target)\n-  {\n-    return null;\n-  }\n-\n-  public float getLayoutAlignmentX(Container target)\n-  {\n-    return 0.0f;\n-  }\n-\n-  public float getLayoutAlignmentY(Container target)\n-  {\n-    return 0.0f;\n-  }\n-\n-  public void invalidateLayout(Container target)\n-  {\n-  }\n-\n-  public void setConstraints(Component comp, GridBagConstraints constraints)\n-  {\n-  }\n+    private static final long serialVersionUID = 8838754796412211005L;\n+\n+    protected static final int MINSIZE = 1;\n+    protected static final int PREFERREDSIZE = 2;\n+    protected static final int MAXGRIDSIZE = 512;\n+\n+    protected Hashtable comptable;\n+    protected GridBagLayoutInfo layoutInfo;\n+    protected GridBagConstraints defaultConstraints;\n+\n+    public double[] columnWeights;\n+    public int[] columnWidths;\n+    public double[] rowWeights;\n+    public int[] rowHeights;\n+\n+    public GridBagLayout ()\n+    {\n+\tthis.comptable = new Hashtable();\n+\tthis.defaultConstraints= new GridBagConstraints();\n+    }\n+\n+    /**\n+     * Helper method to calc the sum of a range of elements in an int array.\n+     */\n+    private int sumIntArray (int[] array, int upto)\n+    {\n+\tint result = 0;\n+\n+\tfor (int i = 0; i < upto; i++)\n+\t    result += array [i];\n+\n+\treturn result;\n+    }\n+\n+    /**\n+     * Helper method to calc the sum of all elements in an int array.\n+     */\n+    private int sumIntArray (int[] array)\n+    {\n+\treturn sumIntArray(array, array.length);\n+    }\n+\n+    /**\n+     * Helper method to calc the sum of all elements in an double array.\n+     */\n+    private double sumDoubleArray (double[] array)\n+    {\n+\tdouble result = 0;\n+\n+\tfor (int i = 0; i < array.length; i++)\n+\t    result += array [i];\n+\n+\treturn result;\n+    }\n+\n+    public void addLayoutComponent (String name, Component component)\n+    {\n+\t// do nothing here.\n+    }\n+\n+    public void removeLayoutComponent (Component component)\n+    {\n+\t// do nothing here\n+    }\n+\n+    public void addLayoutComponent (Component component, Object constraints)\n+    {\n+\tif (constraints == null)\n+\t    return;\n+\n+\tif (!(constraints instanceof GridBagConstraints))\n+\t    throw new IllegalArgumentException();\n+\n+\tsetConstraints (component, (GridBagConstraints) constraints);\n+    }\n+\n+    public Dimension preferredLayoutSize (Container parent)\n+    {\n+\tif (parent == null)\n+\t    return new Dimension (0, 0);\n+    \n+\tGridBagLayoutInfo li = getLayoutInfo (parent, PREFERREDSIZE);\n+\treturn getMinSize (parent, li);\n+    }\n+\n+    public Dimension minimumLayoutSize (Container parent)\n+    {\n+\tif (parent == null)\n+\t    return new Dimension (0, 0);\n+    \n+\tGridBagLayoutInfo li = getLayoutInfo (parent, MINSIZE);\n+\treturn getMinSize (parent, li);\n+    }\n+\n+    public Dimension maximumLayoutSize (Container target)\n+    {\n+\treturn new Dimension (Integer.MAX_VALUE, Integer.MAX_VALUE);\n+    }\n+\n+    public void layoutContainer (Container parent)\n+    {\n+\tarrangeGrid (parent);\n+    }\n+\n+    public float getLayoutAlignmentX (Container target)\n+    {\n+\treturn Component.CENTER_ALIGNMENT;\n+    }\n+\n+    public float getLayoutAlignmentY (Container target)\n+    {\n+\treturn Component.CENTER_ALIGNMENT;\n+    }\n+\n+    public void invalidateLayout (Container target)\n+    {\n+\tthis.layoutInfo = null;\n+    }\n+\n+    public void setConstraints (Component component,\n+\tGridBagConstraints constraints)\n+    {\n+\tGridBagConstraints clone = (GridBagConstraints) constraints.clone();\n+\n+\tif (clone.gridx < 0)\n+\t    clone.gridx = GridBagConstraints.RELATIVE;\n+    \n+\tif (clone.gridy < 0)\n+\t    clone.gridy = GridBagConstraints.RELATIVE;\n+\n+\tif (clone.gridwidth == 0)\n+\t    clone.gridwidth = GridBagConstraints.REMAINDER;\n+\telse if (clone.gridwidth < 0\n+\t    && clone.gridwidth != GridBagConstraints.REMAINDER\n+\t    && clone.gridwidth != GridBagConstraints.RELATIVE)\n+\t    clone.gridwidth = 1;\n+    \n+\tif (clone.gridheight == 0)\n+\t    clone.gridheight = GridBagConstraints.REMAINDER;\n+\telse if (clone.gridheight < 0\n+\t    && clone.gridheight != GridBagConstraints.REMAINDER\n+\t    && clone.gridheight != GridBagConstraints.RELATIVE)\n+\t    clone.gridheight = 1;\n+    \n+\tcomptable.put (component, clone);\n+    }\n+\n+    public GridBagConstraints getConstraints (Component component)\n+    {\n+\treturn (GridBagConstraints) (lookupConstraints (component).clone());\n+    }\n+\n+    protected GridBagConstraints lookupConstraints (Component component)\n+    {\n+\tGridBagConstraints result = (GridBagConstraints) comptable.get (component);\n+\n+\tif (result == null)\n+\t{\n+\t    setConstraints (component, defaultConstraints);\n+\t    result = (GridBagConstraints) comptable.get (component);\n+\t}\n+    \n+\treturn result;\n+    }\n+\n+    /**\n+     * @since 1.1\n+     */\n+    public Point getLayoutOrigin ()\n+    {\n+\tif (layoutInfo == null)\n+\t    return new Point (0, 0);\n+    \n+\treturn new Point (layoutInfo.pos_x, layoutInfo.pos_y);\n+    }\n+\n+    /**\n+     * @since 1.1\n+     */\n+    public int[][] getLayoutDimensions ()\n+    {\n+\tif (layoutInfo == null)\n+\t    return new int [2][];\n+\n+\tint[][] result = new int [2][];\n+\tresult [0] = new int [layoutInfo.cols];\n+\tSystem.arraycopy (layoutInfo.colWidths, 0, result [0], 0, layoutInfo.cols);\n+\tresult [1] = new int [layoutInfo.rows];\n+\tSystem.arraycopy (layoutInfo.rowHeights, 0, result [1], 0, layoutInfo.rows);\n+\treturn result;\n+    }\n+\n+    public double[][] getLayoutWeights ()\n+    {\n+\tif (layoutInfo == null)\n+\t    return new double [2][];\n+      \n+\tdouble[][] result = new double [2][];\n+\tresult [0] = new double [layoutInfo.cols];\n+\tSystem.arraycopy (layoutInfo.colWeights, 0, result [0], 0, layoutInfo.cols);\n+\tresult [1] = new double [layoutInfo.rows];\n+\tSystem.arraycopy (layoutInfo.rowWeights, 0, result [1], 0, layoutInfo.rows);\n+\treturn result;\n+    }\n+\n+    /**\n+     * @since 1.1\n+     */\n+    public Point location (int x, int y)\n+    {\n+\tif (layoutInfo == null)\n+\t    return new Point (0, 0);\n+\n+\tint col;\n+\tint row;\n+\tint pixel_x = layoutInfo.pos_x;\n+\tint pixel_y = layoutInfo.pos_y;\n+\n+\tfor (col = 0; col < layoutInfo.cols; col++)\n+\t{\n+\t    int w = layoutInfo.colWidths [col];\n+\t    if (x < pixel_x + w)\n+\t\tbreak;\n+\n+\t    pixel_x += w;\n+\t}\n+\n+\tfor (row = 0; row < layoutInfo.rows; row++)\n+\t{\n+\t    int h = layoutInfo.rowHeights [row];\n+\t    if (y < pixel_y + h)\n+\t\tbreak;\n+\n+\t    pixel_y += h;\n+\t}\n+\n+\treturn new Point (col, row);\n+    }\n+\n+    /**\n+     * Obsolete.\n+     */\n+    protected void AdjustForGravity (GridBagConstraints gbc, Rectangle rect)\n+    {\n+\tadjustForGravity (gbc, rect);\n+    }\n+\n+    /**\n+     * Obsolete.\n+     */\n+    protected void ArrangeGrid (Container parent)\n+    {\n+\tarrangeGrid (parent);\n+    }\n+\n+    /**\n+     * Obsolete.\n+     */\n+    protected GridBagLayoutInfo GetLayoutInfo (Container parent, int sizeflag)\n+    {\n+\treturn getLayoutInfo (parent, sizeflag);\n+    }\n+\n+    /**\n+     * Obsolete.\n+     */\n+    protected Dimension GetMinSize (Container parent, GridBagLayoutInfo info)\n+    {\n+\treturn getMinSize (parent, info);\n+    }\n+\n+    /**\n+     * @since 1.4\n+     */\n+    protected Dimension getMinSize (Container parent, GridBagLayoutInfo info)\n+    {\n+\tif (parent == null || info == null)\n+\t    return new Dimension (0, 0);\n+\n+\tInsets insets = parent.getInsets();\n+\tint width = sumIntArray (info.colWidths) + insets.left + insets.right;\n+\tint height = sumIntArray (info.rowHeights) + insets.top + insets.bottom;\n+\treturn new Dimension (width, height);\n+    }\n+\n+    private void calcCellSizes (int[] sizes, double[] weights, int range)\n+    {\n+\tint diff = range - sumIntArray (sizes);\n+\n+\tif (diff == 0)\n+\t    return;\n+    \n+\tdouble weight = sumDoubleArray (weights);\n+\n+\tfor (int i = 0; i < sizes.length; i++)\n+\t{\n+\t    sizes [i] += (int) (((double) diff) * weights [i] / weight );\n+\n+\t    if (sizes [i] < 0)\n+\t\tsizes [i] = 0;\n+\t}\n+    }\n+\n+    private void dumpLayoutInfo (GridBagLayoutInfo info)\n+    {\n+\tSystem.out.println (\"GridBagLayoutInfo:\");\n+\tSystem.out.println (\"cols: \" + info.cols + \", rows: \" + info.rows);\n+\tSystem.out.print (\"colWidths: \");\n+\tdumpArray(info.colWidths);\n+\tSystem.out.print (\"rowHeights: \");\n+\tdumpArray(info.rowHeights);\n+\tSystem.out.print (\"colWeights: \");\n+\tdumpArray(info.colWeights);\n+\tSystem.out.print (\"rowWeights: \");\n+\tdumpArray(info.rowWeights);\n+    }\n+\n+    private void dumpArray(int[] array)\n+    {\n+\tString sep = \"\";\n+\tfor(int i = 0; i < array.length; i++)\n+\t{\n+\t    System.out.print(sep);\n+\t    System.out.print(array[i]);\n+\t    sep = \", \";\n+\t}\n+\tSystem.out.println();\n+    }\n+\n+    private void dumpArray(double[] array)\n+    {\n+\tString sep = \"\";\n+\tfor(int i = 0; i < array.length; i++)\n+\t{\n+\t    System.out.print(sep);\n+\t    System.out.print(array[i]);\n+\t    sep = \", \";\n+\t}\n+\tSystem.out.println();\n+    }\n+  \n+    /**\n+     * @since 1.4\n+     */\n+    protected void arrangeGrid (Container parent)\n+    {\n+\tComponent[] components = parent.getComponents();\n+\n+\tif (components.length == 0)\n+\t    return;\n+\n+\tGridBagLayoutInfo info = getLayoutInfo (parent, PREFERREDSIZE);\n+\tif (info.cols == 0 && info.rows == 0)\n+\t    return;\n+\tlayoutInfo = info;\n+\n+\t// DEBUG\n+\t//dumpLayoutInfo (layoutInfo);\n+    \n+\tfor(int i = 0; i < components.length; i++)\n+\t{\n+\t    Component component = components [i];\n+\t\t\n+\t    // If component is not visible we dont have to care about it.\n+\t    if (!component.isVisible())\n+\t\tcontinue;\n+\t\t\n+\t    GridBagConstraints constraints = lookupConstraints (component);\n+\n+\t    int cellx = sumIntArray(layoutInfo.colWidths, constraints.gridx);\n+\t    int celly = sumIntArray(layoutInfo.rowHeights, constraints.gridy);\n+\t    int cellw = sumIntArray(layoutInfo.colWidths,\n+\t\tconstraints.gridx + constraints.gridwidth) - cellx;\n+\t    int cellh = sumIntArray(layoutInfo.rowHeights,\n+\t\tconstraints.gridy + constraints.gridheight) - celly;\n+\n+\t    Insets insets = constraints.insets;\n+\t    if (insets != null)\n+\t    {\n+\t\tcellx += insets.left;\n+\t\tcelly += insets.top;\n+\t\tcellw -= insets.left + insets.right;\n+\t\tcellh -= insets.top + insets.bottom;\n+\t    }\n+\n+\t    Dimension dim = component.preferredSize();\n+\n+\t    // Note: Documentation says that padding is added on both sides, but\n+\t    // visual inspection shows that the Sun implementation only adds it\n+\t    // once, so we do the same.\n+\t    dim.width += constraints.ipadx;\n+\t    dim.height += constraints.ipady;\n+\n+\t    switch(constraints.fill)\n+\t    {\n+\t\tcase GridBagConstraints.HORIZONTAL:\n+\t\t    dim.width = cellw;\n+\t\t    break;\n+\t\tcase GridBagConstraints.VERTICAL:\n+\t\t    dim.height = cellh;\n+\t\t    break;\n+\t\tcase GridBagConstraints.BOTH:\n+\t\t    dim.width = cellw;\n+\t\t    dim.height = cellh;\n+\t\t    break;\n+\t    }\n+\n+\t    int x;\n+\t    int y;\n+\n+\t    switch(constraints.anchor)\n+\t    {\n+\t\tcase GridBagConstraints.NORTH:\n+\t\t    x = cellx + (cellw - dim.width) / 2;\n+\t\t    y = celly;\n+\t\t    break;\n+\t\tcase GridBagConstraints.SOUTH:\n+\t\t    x = cellx + (cellw - dim.width) / 2;\n+\t\t    y = celly + cellh - dim.height;\n+\t\t    break;\n+\t\tcase GridBagConstraints.WEST:\n+\t\t    x = cellx;\n+\t\t    y = celly + (cellh - dim.height) / 2;\n+\t\t    break;\n+\t\tcase GridBagConstraints.EAST:\n+\t\t    x = cellx + cellw - dim.width;\n+\t\t    y = celly + (cellh - dim.height) / 2;\n+\t\t    break;\n+\t\tcase GridBagConstraints.NORTHEAST:\n+\t\t    x = cellx + cellw - dim.width;\n+\t\t    y = celly;\n+\t\t    break;\n+\t\tcase GridBagConstraints.NORTHWEST:\n+\t\t    x = cellx;\n+\t\t    y = celly;\n+\t\t    break;\n+\t\tcase GridBagConstraints.SOUTHEAST:\n+\t\t    x = cellx + cellw - dim.width;\n+\t\t    y = celly + cellh - dim.height;\n+\t\t    break;\n+\t\tcase GridBagConstraints.SOUTHWEST:\n+\t\t    x = cellx;\n+\t\t    y = celly + cellh - dim.height;\n+\t\t    break;\n+\t\tdefault:\n+\t\t    x = cellx + (cellw - dim.width) / 2;\n+\t\t    y = celly + (cellh - dim.height) / 2;\n+\t\t    break;\n+\t    }\n+\n+\t    component.setBounds(layoutInfo.pos_x + x, layoutInfo.pos_y + y, dim.width, dim.height);\n+\t}\n+    \n+\t// DEBUG\n+\t//dumpLayoutInfo (layoutInfo);\n+\n+    }\n+\n+    /**\n+     * @since 1.4\n+     */\n+    protected GridBagLayoutInfo getLayoutInfo (Container parent, int sizeflag)\n+    {\n+\tif (sizeflag != MINSIZE && sizeflag != PREFERREDSIZE)\n+\t    throw new IllegalArgumentException();\n+\n+\tDimension parentDim = parent.size();\n+\tInsets parentInsets = parent.insets();\n+\tparentDim.width -= parentInsets.left + parentInsets.right;\n+\tparentDim.height -= parentInsets.top + parentInsets.bottom;\n+   \n+\tint x = 0;\n+\tint y = 0;\n+\tint max_x = 0;\n+\tint max_y = 0;\n+\n+\t// first we figure out how many rows/columns\n+\tComponent[] components = parent.getComponents();\n+\tfor (int i = 0; i < components.length; i++)\n+\t{\n+\t    Component component = components [i];\n+\t\t\n+\t    // If component is not visible we dont have to care about it.\n+\t    if (!component.isVisible())\n+\t\tcontinue;\n+\t\t\n+\t    GridBagConstraints constraints = lookupConstraints (component);\n+\t\t\n+\t    if(constraints.gridx == GridBagConstraints.RELATIVE)\n+\t\tconstraints.gridx = x;\n+\n+\t    if(constraints.gridy == GridBagConstraints.RELATIVE)\n+\t\tconstraints.gridy = y;\n+\t\t\n+\t    max_x = Math.max(max_x, \n+\t\tconstraints.gridx + Math.max(1, constraints.gridwidth));\n+\t    max_y = Math.max(max_y,\n+\t\tconstraints.gridy + Math.max(1, constraints.gridheight));\n+\n+\t    if(constraints.gridwidth == GridBagConstraints.REMAINDER)\n+\t    {\n+\t\tx = 0;\n+\t\ty++;\n+\t    }\n+\t    else\n+\t    {\n+\t\tx = constraints.gridx + Math.max(1, constraints.gridwidth);\n+\t\ty = constraints.gridy;\n+\t    }\n+\t}\n+\t\n+\tGridBagLayoutInfo info = new GridBagLayoutInfo(max_x, max_y);\n+\n+\tfor (x = 0; x <= max_x; x++)\n+\t{\n+\t    if(columnWidths != null && columnWidths.length > x)\n+\t    {\n+\t\tinfo.colWidths[x] = columnWidths[x];\n+\t    }\n+\t    if(columnWeights != null && columnWeights.length > x)\n+\t    {\n+\t\tinfo.colWeights[x] = columnWeights[x];\n+\t    }\n+\t    for (int i = 0; i < components.length; i++)\n+\t    {\n+\t\tComponent component = components [i];\n+\t\t\t\n+\t\t// If component is not visible we dont have to care about it.\n+\t\tif (!component.isVisible())\n+\t\t    continue;\n+\t\t\t\n+\t\tGridBagConstraints constraints = lookupConstraints (component);\n+\n+\t\t// first we fix up any REMAINDER cells\n+\t\tif(constraints.gridwidth == GridBagConstraints.REMAINDER)\n+\t\t{\n+\t\t    constraints.gridwidth = max_x - constraints.gridx;\n+\t\t}\n+\t\tif(constraints.gridheight == GridBagConstraints.REMAINDER)\n+\t\t{\n+\t\t    constraints.gridheight = max_y - constraints.gridy;\n+\t\t}\n+\n+\t\tif(constraints.gridx + constraints.gridwidth - 1 == x)\n+\t\t{\n+\t\t    int width = (sizeflag == PREFERREDSIZE) ?\n+\t\t\tcomponent.preferredSize().width :\n+\t\t\tcomponent.minimumSize().width;\n+\t\t    if(constraints.insets != null)\n+\t\t    {\n+\t\t\twidth += constraints.insets.left + constraints.insets.right;\n+\t\t    }\n+\t\t    width += constraints.ipadx;\n+\t\t    for(int w = 1; w < constraints.gridwidth; w++)\n+\t\t    {\n+\t\t\twidth -= info.colWidths[x - w];\n+\t\t    }\n+\t\t    info.colWidths[x] = Math.max(info.colWidths[x], width);\n+\t\t    info.colWeights[x] =\n+\t\t\tMath.max(info.colWeights[x], constraints.weightx);\n+\t\t}\n+\t    }\n+\t}\n+\n+\tfor (y = 0; y <= max_y; y++)\n+\t{\n+\t    if(rowHeights != null && rowHeights.length > y)\n+\t    {\n+\t\tinfo.rowHeights[y] = rowHeights[y];\n+\t    }\n+\t    if(rowWeights != null && rowWeights.length > y)\n+\t    {\n+\t\tinfo.rowWeights[y] = rowWeights[y];\n+\t    }\n+\t    for (int i = 0; i < components.length; i++)\n+\t    {\n+\t\tComponent component = components [i];\n+\t\t\t\n+\t\t// If component is not visible we dont have to care about it.\n+\t\tif (!component.isVisible())\n+\t\t    continue;\n+\t\t\t\n+\t\tGridBagConstraints constraints = lookupConstraints (component);\n+\n+\t\tif(constraints.gridy + constraints.gridheight - 1 == y)\n+\t\t{\n+\t\t    int height = (sizeflag == PREFERREDSIZE) ?\n+\t\t\tcomponent.preferredSize().height :\n+\t\t\tcomponent.minimumSize().height;\n+\t\t    if(constraints.insets != null)\n+\t\t    {\n+\t\t\theight += constraints.insets.top + constraints.insets.bottom;\n+\t\t    } \n+\t\t    height += constraints.ipady;\n+\t\t    for(int h = 1; h < constraints.gridheight; h++)\n+\t\t    {\n+\t\t\theight -= info.rowHeights[y - h];\n+\t\t    }\n+\t\t    info.rowHeights[y] = Math.max(info.rowHeights[y], height);\n+\t\t    info.rowWeights[y] =\n+\t\t\tMath.max(info.rowWeights[y], constraints.weighty);\n+\t\t}\n+\t    }\n+\t}\n+\n+\tcalcCellSizes (info.colWidths, info.colWeights, parentDim.width);\n+\tcalcCellSizes (info.rowHeights, info.rowWeights, parentDim.height);\n+\n+\tint totalWidth = sumIntArray(info.colWidths);\n+\tint totalHeight = sumIntArray(info.rowHeights);\n+\tinfo.pos_x = parentInsets.left + (parentDim.width - totalWidth) / 2;\n+\tinfo.pos_y = parentInsets.top + (parentDim.height - totalHeight) / 2;\n+\n+\t// DEBUG\n+\t//dumpLayoutInfo (info);\n+\n+\treturn info;\n+    }\n+\n+    /**\n+     * @since 1.4\n+     */\n+    protected void adjustForGravity (GridBagConstraints gbc, Rectangle rect)\n+    {\n+\t// FIXME\n+\tthrow new Error (\"Not implemented\");\n+    }\n }"}, {"sha": "6bd7f6787a88ccf9108ab0196b2668acd7e64f84", "filename": "libjava/java/awt/GridBagLayoutInfo.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FGridBagLayoutInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FGridBagLayoutInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagLayoutInfo.java?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -0,0 +1,70 @@\n+/* GridBagLayoutInfo -\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.awt;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * @author Michael Koch <konqueror@gmx.de>\n+ */\n+class GridBagLayoutInfo implements Serializable\n+{\n+  private static final long serialVersionUID = -4899416460737170217L;\n+\n+  int pos_x;\n+  int pos_y;\n+  int cols;\n+  int rows;\n+  int colWidths[];\n+  int rowHeights[];\n+  double colWeights[];\n+  double rowWeights[];\n+\n+  GridBagLayoutInfo (int cols, int rows)\n+  {\n+    this.pos_x = 0;\n+    this.pos_y = 0;\n+    this.cols = cols;\n+    this.rows = rows;\n+    this.colWidths = new int [cols];\n+    this.rowHeights = new int [rows];\n+    this.colWeights = new double [cols];\n+    this.rowWeights = new double [rows];\n+  }\n+}"}, {"sha": "0f4e1c3aeda8e532df4d9476637b7fff67f05d4b", "filename": "libjava/java/awt/MediaTracker.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FMediaTracker.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FMediaTracker.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMediaTracker.java?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -76,9 +76,9 @@ public boolean imageUpdate(Image img, int flags, int x, int y,\n \t\t\t       int width, int height)\n     {\n       if ((flags & ABORT) != 0)\n-        status = ABORTED & COMPLETE;\n+        status = ABORTED | COMPLETE;\n       else if ((flags & ERROR) != 0)\n-        status = ERRORED & COMPLETE;\n+        status = ERRORED | COMPLETE;\n       else if ((flags & ALLBITS) != 0)\n         status = COMPLETE;\n       else"}, {"sha": "ebaa0d1f02f1a94983e360304f5a9f3199ea3b78", "filename": "libjava/java/awt/Window.java", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FWindow.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8a1dd5a8fca1b4c134522a337e2f66e1de686b/libjava%2Fjava%2Fawt%2FWindow.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FWindow.java?ref=ec8a1dd5a8fca1b4c134522a337e2f66e1de686b", "patch": "@@ -84,7 +84,6 @@ public class Window extends Container implements Accessible\n    */\n   Window()\n   {\n-    setVisible(false);\n     setLayout(new BorderLayout());\n   }\n \n@@ -106,7 +105,7 @@ public class Window extends Container implements Accessible\n     peer = ((EmbeddedWindowSupport) getToolkit())\n \t    .createEmbeddedWindow (window_id, width, height);\n   }\n-    \n+  \n   /**\n    * Initializes a new instance of <code>Window</code> with the specified\n    * parent.  The window will initially be invisible."}]}