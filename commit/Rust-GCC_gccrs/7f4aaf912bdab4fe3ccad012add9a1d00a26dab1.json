{"sha": "7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y0YWFmOTEyYmRhYjRmZTNjY2FkMDEyYWRkOWExZDAwYTI2ZGFiMQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-07-12T19:00:47Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-07-12T19:00:47Z"}, "message": "check.c (gfc_check_atomic): Update for STAT=.\n\ngcc/fortran/\n2014-07-12  Tobias Burnus  <burnus@net-b.de>\n\n        * check.c (gfc_check_atomic): Update for STAT=.\n        (gfc_check_atomic_def, gfc_check_atomic_ref): Update call.\n        (gfc_check_atomic_op, gfc_check_atomic_cas,\n        gfc_check_atomic_fetch_op): New.\n        * gfortran.h (gfc_isym_id): GFC_ISYM_ATOMIC_CAS,\n        * GFC_ISYM_ATOMIC_ADD,\n        GFC_ISYM_ATOMIC_AND, GFC_ISYM_ATOMIC_OR, GFC_ISYM_ATOMIC_XOR,\n        GFC_ISYM_ATOMIC_FETCH_ADD, GFC_ISYM_ATOMIC_FETCH_AND,\n        GFC_ISYM_ATOMIC_FETCH_OR and GFC_ISYM_ATOMIC_FETCH_XOR.\n        * intrinsic.c (add_subroutines): Handle them.\n        * intrinsic.texi: Add documentation for them.\n        (ATOMIC_REF, ATOMIC_DEFINE): Add STAT=.\n        (ISO_FORTRAN_ENV): Add STAT_FAILED_IMAGE.\n        * intrinsic.h (gfc_check_atomic_op, gfc_check_atomic_cas,\n        gfc_check_atomic_fetch_op): New\n        prototypes.\n        * libgfortran.h (libgfortran_stat_codes): Add\n        * GFC_STAT_FAILED_IMAGE.\n        * iso-fortran-env.def: Add it.\n        * trans-intrinsic.c (conv_intrinsic_atomic_op): Renamed from\n        conv_intrinsic_atomic_ref; handle more atomics.\n        (conv_intrinsic_atomic_def): Handle STAT=.\n        (conv_intrinsic_atomic_cas): New.\n        (gfc_conv_intrinsic_subroutine): Handle new atomics.\n\ngcc/testsuite/\n2014-07-12  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/coarray_atomic_1.f90: Update dg-error.\n        * gfortran.dg/coarray_atomic_2.f90: New.\n        * gfortran.dg/coarray_atomic_3.f90: New.\n        * gfortran.dg/coarray_atomic_4.f90: New.\n        * gfortran.dg/coarray/atomic_2.f90: New.\n\nFrom-SVN: r212483", "tree": {"sha": "9038e580c528fda84a1b16297c39c9848284db75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9038e580c528fda84a1b16297c39c9848284db75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0eb5f1586fa04fd82180135917b2c80511473c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb5f1586fa04fd82180135917b2c80511473c6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb5f1586fa04fd82180135917b2c80511473c6b"}], "stats": {"total": 1883, "additions": 1827, "deletions": 56}, "files": [{"sha": "2771ea7ecb9e8eb4f0a73c3358eee97f1bf39741", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -1,3 +1,28 @@\n+2014-07-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* check.c (gfc_check_atomic): Update for STAT=.\n+\t(gfc_check_atomic_def, gfc_check_atomic_ref): Update call.\n+\t(gfc_check_atomic_op, gfc_check_atomic_cas,\n+\tgfc_check_atomic_fetch_op): New.\n+\t* gfortran.h (gfc_isym_id): GFC_ISYM_ATOMIC_CAS, GFC_ISYM_ATOMIC_ADD,\n+\tGFC_ISYM_ATOMIC_AND, GFC_ISYM_ATOMIC_OR, GFC_ISYM_ATOMIC_XOR,\n+\tGFC_ISYM_ATOMIC_FETCH_ADD, GFC_ISYM_ATOMIC_FETCH_AND,\n+\tGFC_ISYM_ATOMIC_FETCH_OR and GFC_ISYM_ATOMIC_FETCH_XOR.\n+\t* intrinsic.c (add_subroutines): Handle them.\n+\t* intrinsic.texi: Add documentation for them.\n+\t(ATOMIC_REF, ATOMIC_DEFINE): Add STAT=.\n+\t(ISO_FORTRAN_ENV): Add STAT_FAILED_IMAGE.\n+\t* intrinsic.h (gfc_check_atomic_op, gfc_check_atomic_cas,\n+\tgfc_check_atomic_fetch_op): New\n+\tprototypes.\n+\t* libgfortran.h (libgfortran_stat_codes): Add GFC_STAT_FAILED_IMAGE.\n+\t* iso-fortran-env.def: Add it.\n+\t* trans-intrinsic.c (conv_intrinsic_atomic_op): Renamed from\n+\tconv_intrinsic_atomic_ref; handle more atomics.\n+\t(conv_intrinsic_atomic_def): Handle STAT=.\n+\t(conv_intrinsic_atomic_cas): New.\n+\t(gfc_conv_intrinsic_subroutine): Handle new atomics.\n+\n 2014-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* trans-array.c (gfc_build_constant_array_constructor): Build a"}, {"sha": "eff2c4c78a74307d2c07c5cb7c010c40ab83ca45", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 130, "deletions": 17, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -1006,12 +1006,11 @@ gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n \n \n static bool\n-gfc_check_atomic (gfc_expr *atom, gfc_expr *value)\n+gfc_check_atomic (gfc_expr *atom, int atom_no, gfc_expr *value, int val_no,\n+\t\t  gfc_expr *stat, int stat_no)\n {\n-  if (atom->expr_type == EXPR_FUNCTION\n-      && atom->value.function.isym\n-      && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n-    atom = atom->value.function.actual->expr;\n+  if (!scalar_check (atom, atom_no) || !scalar_check (value, val_no))\n+    return false;\n \n   if (!(atom->ts.type == BT_INTEGER && atom->ts.kind == gfc_atomic_int_kind)\n       && !(atom->ts.type == BT_LOGICAL\n@@ -1032,43 +1031,74 @@ gfc_check_atomic (gfc_expr *atom, gfc_expr *value)\n \n   if (atom->ts.type != value->ts.type)\n     {\n-      gfc_error (\"ATOM and VALUE argument of the %s intrinsic function shall \"\n-\t\t \"have the same type at %L\", gfc_current_intrinsic,\n-\t\t &value->where);\n+      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall have the same \"\n+\t\t \"type as '%s' at %L\", gfc_current_intrinsic_arg[val_no]->name,\n+\t\t gfc_current_intrinsic, &value->where,\n+\t\t gfc_current_intrinsic_arg[atom_no]->name, &atom->where);\n       return false;\n     }\n \n+  if (stat != NULL)\n+    {\n+      if (!type_check (stat, stat_no, BT_INTEGER))\n+\treturn false;\n+      if (!scalar_check (stat, stat_no))\n+\treturn false;\n+      if (!variable_check (stat, stat_no, false))\n+\treturn false;\n+      if (!kind_value_check (stat, stat_no, gfc_default_integer_kind))\n+\treturn false;\n+\n+      if (!gfc_notify_std (GFC_STD_F2008_TS, \"STAT= argument to %s at %L\",\n+\t\t\t   gfc_current_intrinsic, &stat->where))\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n \n bool\n-gfc_check_atomic_def (gfc_expr *atom, gfc_expr *value)\n+gfc_check_atomic_def (gfc_expr *atom, gfc_expr *value, gfc_expr *stat)\n {\n   if (atom->expr_type == EXPR_FUNCTION\n       && atom->value.function.isym\n       && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n     atom = atom->value.function.actual->expr;\n \n-  if (!scalar_check (atom, 0) || !scalar_check (value, 1))\n-    return false;\n-\n   if (!gfc_check_vardef_context (atom, false, false, false, NULL))\n     {\n       gfc_error (\"ATOM argument of the %s intrinsic function at %L shall be \"\n \t\t \"definable\", gfc_current_intrinsic, &atom->where);\n       return false;\n     }\n \n-  return gfc_check_atomic (atom, value);\n+  return gfc_check_atomic (atom, 0, value, 1, stat, 2);\n }\n \n \n bool\n-gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom)\n+gfc_check_atomic_op (gfc_expr *atom, gfc_expr *value, gfc_expr *stat)\n {\n-  if (!scalar_check (value, 0) || !scalar_check (atom, 1))\n-    return false;\n+  if (atom->ts.type != BT_INTEGER || atom->ts.kind != gfc_atomic_int_kind)\n+    {\n+      gfc_error (\"ATOM argument at %L to intrinsic function %s shall be an \"\n+\t\t \"integer of ATOMIC_INT_KIND\", &atom->where,\n+\t\t gfc_current_intrinsic);\n+      return false;\n+    }\n+\n+  return gfc_check_atomic_def (atom, value, stat);\n+}\n+\n+\n+bool\n+gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom, gfc_expr *stat)\n+{\n+  if (atom->expr_type == EXPR_FUNCTION\n+      && atom->value.function.isym\n+      && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom = atom->value.function.actual->expr;\n \n   if (!gfc_check_vardef_context (value, false, false, false, NULL))\n     {\n@@ -1077,7 +1107,90 @@ gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom)\n       return false;\n     }\n \n-  return gfc_check_atomic (atom, value);\n+  return gfc_check_atomic (atom, 1, value, 0, stat, 2);\n+}\n+\n+\n+bool\n+gfc_check_atomic_cas (gfc_expr *atom, gfc_expr *old, gfc_expr *compare,\n+\t\t      gfc_expr *new_val,  gfc_expr *stat)\n+{\n+  if (atom->expr_type == EXPR_FUNCTION\n+      && atom->value.function.isym\n+      && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom = atom->value.function.actual->expr;\n+\n+  if (!gfc_check_atomic (atom, 0, new_val, 3, stat, 4))\n+    return false;\n+\n+  if (!scalar_check (old, 1) || !scalar_check (compare, 2))\n+    return false;\n+\n+  if (!same_type_check (atom, 0, old, 1))\n+    return false;\n+\n+  if (!same_type_check (atom, 0, compare, 2))\n+    return false;\n+\n+  if (!gfc_check_vardef_context (atom, false, false, false, NULL))\n+    {\n+      gfc_error (\"ATOM argument of the %s intrinsic function at %L shall be \"\n+\t\t \"definable\", gfc_current_intrinsic, &atom->where);\n+      return false;\n+    }\n+\n+  if (!gfc_check_vardef_context (old, false, false, false, NULL))\n+    {\n+      gfc_error (\"OLD argument of the %s intrinsic function at %L shall be \"\n+\t\t \"definable\", gfc_current_intrinsic, &old->where);\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+\n+bool\n+gfc_check_atomic_fetch_op (gfc_expr *atom, gfc_expr *value, gfc_expr *old,\n+\t\t\t   gfc_expr *stat)\n+{\n+  if (atom->expr_type == EXPR_FUNCTION\n+      && atom->value.function.isym\n+      && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom = atom->value.function.actual->expr;\n+\n+  if (atom->ts.type != BT_INTEGER || atom->ts.kind != gfc_atomic_int_kind)\n+    {\n+      gfc_error (\"ATOM argument at %L to intrinsic function %s shall be an \"\n+\t\t \"integer of ATOMIC_INT_KIND\", &atom->where,\n+\t\t gfc_current_intrinsic);\n+      return false;\n+    }\n+\n+  if (!gfc_check_atomic (atom, 0, value, 1, stat, 3))\n+    return false;\n+\n+  if (!scalar_check (old, 2))\n+    return false;\n+\n+  if (!same_type_check (atom, 0, old, 2))\n+    return false;\n+\n+  if (!gfc_check_vardef_context (atom, false, false, false, NULL))\n+    {\n+      gfc_error (\"ATOM argument of the %s intrinsic function at %L shall be \"\n+\t\t \"definable\", gfc_current_intrinsic, &atom->where);\n+      return false;\n+    }\n+\n+  if (!gfc_check_vardef_context (old, false, false, false, NULL))\n+    {\n+      gfc_error (\"OLD argument of the %s intrinsic function at %L shall be \"\n+\t\t \"definable\", gfc_current_intrinsic, &old->where);\n+      return false;\n+    }\n+\n+  return true;\n }\n \n "}, {"sha": "f1750da07e97a13edcfa25d134434999993c8a6f", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -332,8 +332,17 @@ enum gfc_isym_id\n   GFC_ISYM_ATAN,\n   GFC_ISYM_ATAN2,\n   GFC_ISYM_ATANH,\n+  GFC_ISYM_ATOMIC_ADD,\n+  GFC_ISYM_ATOMIC_AND,\n+  GFC_ISYM_ATOMIC_CAS,\n   GFC_ISYM_ATOMIC_DEF,\n+  GFC_ISYM_ATOMIC_FETCH_ADD,\n+  GFC_ISYM_ATOMIC_FETCH_AND,\n+  GFC_ISYM_ATOMIC_FETCH_OR,\n+  GFC_ISYM_ATOMIC_FETCH_XOR,\n+  GFC_ISYM_ATOMIC_OR,\n   GFC_ISYM_ATOMIC_REF,\n+  GFC_ISYM_ATOMIC_XOR,\n   GFC_ISYM_BGE,\n   GFC_ISYM_BGT,\n   GFC_ISYM_BIT_SIZE,"}, {"sha": "d681d702822a39749dac04b8f1104165e1145284", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 75, "deletions": 4, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -3038,17 +3038,88 @@ add_subroutines (void)\n \n   make_noreturn();\n \n-  add_sym_2s (\"atomic_define\", GFC_ISYM_ATOMIC_DEF, CLASS_ATOMIC,\n+  add_sym_3s (\"atomic_define\", GFC_ISYM_ATOMIC_DEF, CLASS_ATOMIC,\n \t      BT_UNKNOWN, 0, GFC_STD_F2008,\n \t      gfc_check_atomic_def, NULL, gfc_resolve_atomic_def,\n \t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n-\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN);\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n \n-  add_sym_2s (\"atomic_ref\", GFC_ISYM_ATOMIC_REF, CLASS_ATOMIC,\n+  add_sym_3s (\"atomic_ref\", GFC_ISYM_ATOMIC_REF, CLASS_ATOMIC,\n \t      BT_UNKNOWN, 0, GFC_STD_F2008,\n \t      gfc_check_atomic_ref, NULL, gfc_resolve_atomic_ref,\n \t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n-\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_IN);\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_5s (\"atomic_cas\", GFC_ISYM_ATOMIC_CAS, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_cas, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_INOUT,\n+\t      \"old\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"compare\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      \"new\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_3s (\"atomic_add\", GFC_ISYM_ATOMIC_ADD, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_3s (\"atomic_and\", GFC_ISYM_ATOMIC_AND, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_3s (\"atomic_or\", GFC_ISYM_ATOMIC_OR, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_3s (\"atomic_xor\", GFC_ISYM_ATOMIC_XOR, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_4s (\"atomic_fetch_add\", GFC_ISYM_ATOMIC_FETCH_ADD, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_fetch_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      \"old\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_4s (\"atomic_fetch_and\", GFC_ISYM_ATOMIC_FETCH_AND, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_fetch_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      \"old\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_4s (\"atomic_fetch_or\", GFC_ISYM_ATOMIC_FETCH_OR, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_fetch_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      \"old\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n+\n+  add_sym_4s (\"atomic_fetch_xor\", GFC_ISYM_ATOMIC_FETCH_XOR, CLASS_ATOMIC,\n+\t      BT_UNKNOWN, 0, GFC_STD_F2008_TS,\n+\t      gfc_check_atomic_fetch_op, NULL, NULL,\n+\t      \"atom\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      \"value\", BT_INTEGER, di, REQUIRED, INTENT_IN,\n+\t      \"old\", BT_INTEGER, di, REQUIRED, INTENT_OUT,\n+\t      stat, BT_INTEGER, di, OPTIONAL, INTENT_OUT);\n \n   add_sym_0s (\"backtrace\", GFC_ISYM_BACKTRACE, GFC_STD_GNU, NULL);\n "}, {"sha": "9437171bac68b96ba663c60f45b4734005744623", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -38,8 +38,12 @@ bool gfc_check_allocated (gfc_expr *);\n bool gfc_check_associated (gfc_expr *, gfc_expr *);\n bool gfc_check_atan_2 (gfc_expr *, gfc_expr *);\n bool gfc_check_atan2 (gfc_expr *, gfc_expr *);\n-bool gfc_check_atomic_def (gfc_expr *, gfc_expr *);\n-bool gfc_check_atomic_ref (gfc_expr *, gfc_expr *);\n+bool gfc_check_atomic_cas (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n+\t\t\t   gfc_expr *);\n+bool gfc_check_atomic_def (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_atomic_fetch_op (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_atomic_op (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_atomic_ref (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_besn (gfc_expr *, gfc_expr *);\n bool gfc_check_bessel_n2 (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_bge_bgt_ble_blt (gfc_expr *, gfc_expr *);"}, {"sha": "2cf6dfe4415abfb66bbb225987c1a07ecd84ca2d", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 502, "deletions": 18, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -60,8 +60,17 @@ Some basic guidelines for editing this document:\n * @code{ATAN}:          ATAN,      Arctangent function\n * @code{ATAN2}:         ATAN2,     Arctangent function\n * @code{ATANH}:         ATANH,     Inverse hyperbolic tangent function\n+* @code{ATOMIC_ADD}:    ATOMIC_ADD, Atomic ADD operation\n+* @code{ATOMIC_AND}:    ATOMIC_AND, Atomic bitwise AND operation\n+* @code{ATOMIC_CAS}:    ATOMIC_CAS, Atomic compare and swap\n+* @code{ATOMIC_FETCH_ADD}: ATOMIC_FETCH_ADD, Atomic ADD operation with prior fetch\n+* @code{ATOMIC_FETCH_AND}: ATOMIC_FETCH_AND, Atomic bitwise AND operation with prior fetch\n+* @code{ATOMIC_FETCH_OR}: ATOMIC_FETCH_OR, Atomic bitwise OR operation with prior fetch\n+* @code{ATOMIC_FETCH_XOR}: ATOMIC_FETCH_XOR, Atomic bitwise XOR operation with prior fetch\n+* @code{ATOMIC_OR}:     ATOMIC_OR, Atomic bitwise OR operation\n * @code{ATOMIC_DEFINE}: ATOMIC_DEFINE, Setting a variable atomically\n * @code{ATOMIC_REF}:    ATOMIC_REF, Obtaining the value of a variable atomically\n+* @code{ATOMIC_XOR}:    ATOMIC_XOR, Atomic bitwise OR operation\n * @code{BACKTRACE}:     BACKTRACE, Show a backtrace\n * @code{BESSEL_J0}:     BESSEL_J0, Bessel function of the first kind of order 0\n * @code{BESSEL_J1}:     BESSEL_J1, Bessel function of the first kind of order 1\n@@ -1554,6 +1563,159 @@ Inverse function: @ref{TANH}\n \n \n \n+@node ATOMIC_ADD\n+@section @code{ATOMIC_ADD} --- Atomic ADD operation\n+@fnindex ATOMIC_ADD\n+@cindex Atomic subroutine, add\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_ADD(ATOM, VALUE)} atomically adds the value of @var{VAR} to the\n+variable @var{ATOM}. When @var{STAT} is present and the invokation was\n+successful, it is assigned the value 0. If it is present and the invokation\n+has failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_ADD (ATOM, VALUE [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*]\n+  call atomic_add (atom[1], this_image())\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_FETCH_ADD}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_AND}, @ref{ATOMIC_OR}, @ref{ATOMIC_XOR}\n+@end table\n+\n+\n+\n+\n+@node ATOMIC_AND\n+@section @code{ATOMIC_AND} --- Atomic bitwise AND operation\n+@fnindex ATOMIC_AND\n+@cindex Atomic subroutine, AND\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_AND(ATOM, VALUE)} atomically defines @var{ATOM} with the bitwise\n+AND between the values of @var{ATOM} and @var{VALUE}. When @var{STAT} is present\n+and the invokation was successful, it is assigned the value 0. If it is present\n+and the invokation has failed, it is assigned a positive value; in particular,\n+for a coindexed @var{ATOM}, if the remote image has stopped, it is assigned the\n+value of @code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote\n+image has failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_AND (ATOM, VALUE [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*]\n+  call atomic_and (atom[1], int(b'10100011101'))\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_FETCH_AND}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_ADD}, @ref{ATOMIC_OR}, @ref{ATOMIC_XOR}\n+@end table\n+\n+\n+\n+@node ATOMIC_CAS\n+@section @code{ATOMIC_CAS} --- Atomic compare and swap\n+@fnindex ATOMIC_DEFINE\n+@cindex Atomic subroutine, compare and swap\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_CAS} compares the variable @var{ATOM} with the value of\n+@var{COMPARE}; if the value is the same, @var{ATOM} is set to the value\n+of @var{NEW}. Additionally, @var{OLD} is set to the value of @var{ATOM}\n+that was used for the comparison.  When @var{STAT} is present and the invokation\n+was successful, it is assigned the value 0. If it is present and the invokation\n+has failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_CAS (ATOM, OLD, COMPARE, NEW [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}    @tab Scalar coarray or coindexed variable of either integer\n+type with @code{ATOMIC_INT_KIND} kind or logical type with\n+@code{ATOMIC_LOGICAL_KIND} kind.\n+@item @var{OLD}     @tab Scalar of the same type and kind as @var{ATOM}.\n+@item @var{COMPARE} @tab Scalar variable of the same type and kind as\n+@var{ATOM}.\n+@item @var{NEW}     @tab Scalar variable of the same type as @var{ATOM}. If kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{STAT}    @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  logical(atomic_logical_kind) :: atom[*], prev\n+  call atomic_cas (atom[1], prev, .false., .true.))\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_REF}, @ref{ISO_FORTRAN_ENV}\n+@end table\n+\n+\n+\n @node ATOMIC_DEFINE\n @section @code{ATOMIC_DEFINE} --- Setting a variable atomically\n @fnindex ATOMIC_DEFINE\n@@ -1562,25 +1724,31 @@ Inverse function: @ref{TANH}\n @table @asis\n @item @emph{Description}:\n @code{ATOMIC_DEFINE(ATOM, VALUE)} defines the variable @var{ATOM} with the value\n-@var{VALUE} atomically.\n+@var{VALUE} atomically. When @var{STAT} is present and the invokation was\n+successful, it is assigned the value 0. If it is present and the invokation\n+has failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n \n @item @emph{Standard}:\n-Fortran 2008 and later\n+Fortran 2008 and later; with @var{STAT}, TS 18508 or later\n \n @item @emph{Class}:\n Atomic subroutine\n \n @item @emph{Syntax}:\n-@code{CALL ATOMIC_DEFINE(ATOM, VALUE)}\n+@code{CALL ATOMIC_DEFINE (ATOM, VALUE [, STAT])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{ATOM}   @tab Scalar coarray or coindexed variable of either integer\n-                        type with @code{ATOMIC_INT_KIND} kind or logical type\n-                        with @code{ATOMIC_LOGICAL_KIND} kind.\n-@item @var{VALURE} @tab Scalar and of the same type as @var{ATOM}. If the kind\n-                        is different, the value is converted to the kind of\n-                        @var{ATOM}.\n+type with @code{ATOMIC_INT_KIND} kind or logical type with\n+@code{ATOMIC_LOGICAL_KIND} kind.\n+\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n @end multitable\n \n @item @emph{Example}:\n@@ -1593,7 +1761,263 @@ end program atomic\n @end smallexample\n \n @item @emph{See also}:\n-@ref{ATOMIC_REF}, @ref{ISO_FORTRAN_ENV}\n+@ref{ATOMIC_REF}, @ref{ATOMIC_CAS}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_ADD}, @ref{ATOMIC_AND}, @ref{ATOMIC_OR}, @ref{ATOMIC_XOR}\n+@end table\n+\n+\n+\n+@node ATOMIC_FETCH_ADD\n+@section @code{ATOMIC_FETCH_ADD} --- Atomic ADD operation with prior fetch\n+@fnindex ATOMIC_FETCH_ADD\n+@cindex Atomic subroutine, ADD with fetch\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_FETCH_ADD(ATOM, VALUE, OLD)} atomically stores the value of\n+@var{ATOM} in @var{OLD} and adds the value of @var{VAR} to the\n+variable @var{ATOM}. When @var{STAT} is present and the invokation was\n+successful, it is assigned the value 0. If it is present and the invokation\n+has failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_FETCH_ADD (ATOM, VALUE, old [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@code{ATOMIC_LOGICAL_KIND} kind.\n+\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{OLD}    @tab Scalar of the same type and kind as @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*], old\n+  call atomic_add (atom[1], this_image(), old)\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_ADD}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_FETCH_AND}, @ref{ATOMIC_FETCH_OR}, @ref{ATOMIC_FETCH_XOR}\n+@end table\n+\n+\n+\n+@node ATOMIC_FETCH_AND\n+@section @code{ATOMIC_FETCH_AND} --- Atomic bitwise AND operation with prior fetch\n+@fnindex ATOMIC_FETCH_AND\n+@cindex Atomic subroutine, AND with fetch\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_AND(ATOM, VALUE)} atomically stores the value of @var{ATOM} in\n+@var{OLD} and defines @var{ATOM} with the bitwise AND between the values of\n+@var{ATOM} and @var{VALUE}. When @var{STAT} is present and the invokation was\n+successful, it is assigned the value 0. If it is present and the invokation has\n+failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_FETCH_AND (ATOM, VALUE, OLD [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{OLD}    @tab Scalar of the same type and kind as @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*], old\n+  call atomic_fetch_and (atom[1], int(b'10100011101'), old)\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_AND}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_FETCH_ADD}, @ref{ATOMIC_FETCH_OR}, @ref{ATOMIC_FETCH_XOR}\n+@end table\n+\n+\n+\n+@node ATOMIC_FETCH_OR\n+@section @code{ATOMIC_FETCH_OR} --- Atomic bitwise OR operation with prior fetch\n+@fnindex ATOMIC_FETCH_OR\n+@cindex Atomic subroutine, OR with fetch\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_OR(ATOM, VALUE)} atomically stores the value of @var{ATOM} in\n+@var{OLD} and defines @var{ATOM} with the bitwise OR between the values of\n+@var{ATOM} and @var{VALUE}. When @var{STAT} is present and the invokation was\n+successful, it is assigned the value 0. If it is present and the invokation has\n+failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_FETCH_OR (ATOM, VALUE, OLD [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{OLD}    @tab Scalar of the same type and kind as @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*], old\n+  call atomic_fetch_or (atom[1], int(b'10100011101'), old)\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_OR}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_FETCH_ADD}, @ref{ATOMIC_FETCH_AND}, @ref{ATOMIC_FETCH_XOR}\n+@end table\n+\n+\n+\n+@node ATOMIC_FETCH_XOR\n+@section @code{ATOMIC_FETCH_XOR} --- Atomic bitwise XOR operation with prior fetch\n+@fnindex ATOMIC_FETCH_XOR\n+@cindex Atomic subroutine, XOR with fetch\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_XOR(ATOM, VALUE)} atomically stores the value of @var{ATOM} in\n+@var{OLD} and defines @var{ATOM} with the bitwise XOR between the values of\n+@var{ATOM} and @var{VALUE}. When @var{STAT} is present and the invokation was\n+successful, it is assigned the value 0. If it is present and the invokation has\n+failed, it is assigned a positive value; in particular, for a coindexed\n+@var{ATOM}, if the remote image has stopped, it is assigned the value of\n+@code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image has\n+failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_FETCH_XOR (ATOM, VALUE, OLD [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{OLD}    @tab Scalar of the same type and kind as @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*], old\n+  call atomic_fetch_xor (atom[1], int(b'10100011101'), old)\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_XOR}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_FETCH_ADD}, @ref{ATOMIC_FETCH_AND}, @ref{ATOMIC_FETCH_OR}\n+@end table\n+\n+\n+\n+@node ATOMIC_OR\n+@section @code{ATOMIC_OR} --- Atomic bitwise OR operation\n+@fnindex ATOMIC_OR\n+@cindex Atomic subroutine, OR\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_OR(ATOM, VALUE)} atomically defines @var{ATOM} with the bitwise\n+AND between the values of @var{ATOM} and @var{VALUE}. When @var{STAT} is present\n+and the invokation was successful, it is assigned the value 0. If it is present\n+and the invokation has failed, it is assigned a positive value; in particular,\n+for a coindexed @var{ATOM}, if the remote image has stopped, it is assigned the\n+value of @code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote\n+image has failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_OR (ATOM, VALUE [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*]\n+  call atomic_or (atom[1], int(b'10100011101'))\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_FETCH_OR}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_ADD}, @ref{ATOMIC_OR}, @ref{ATOMIC_XOR}\n @end table\n \n \n@@ -1606,25 +2030,31 @@ end program atomic\n @table @asis\n @item @emph{Description}:\n @code{ATOMIC_DEFINE(ATOM, VALUE)} atomically assigns the value of the\n-variable @var{ATOM} to @var{VALUE}.\n+variable @var{ATOM} to @var{VALUE}. When @var{STAT} is present and the\n+invokation was successful, it is assigned the value 0. If it is present and the\n+invokation has failed, it is assigned a positive value; in particular, for a\n+coindexed @var{ATOM}, if the remote image has stopped, it is assigned the value\n+of @code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote image\n+has failed, the value @code{STAT_FAILED_IMAGE}.\n+\n \n @item @emph{Standard}:\n-Fortran 2008 and later\n+Fortran 2008 and later; with @var{STAT}, TS 18508 or later\n \n @item @emph{Class}:\n Atomic subroutine\n \n @item @emph{Syntax}:\n-@code{CALL ATOMIC_REF(VALUE, ATOM)}\n+@code{CALL ATOMIC_REF(VALUE, ATOM [, STAT])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{VALURE} @tab Scalar and of the same type as @var{ATOM}. If the kind\n-                        is different, the value is converted to the kind of\n-                        @var{ATOM}.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n @item @var{ATOM}   @tab Scalar coarray or coindexed variable of either integer\n-                        type with @code{ATOMIC_INT_KIND} kind or logical type\n-                        with @code{ATOMIC_LOGICAL_KIND} kind.\n+type with @code{ATOMIC_INT_KIND} kind or logical type with\n+@code{ATOMIC_LOGICAL_KIND} kind.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n @end multitable\n \n @item @emph{Example}:\n@@ -1643,10 +2073,59 @@ end program atomic\n @end smallexample\n \n @item @emph{See also}:\n-@ref{ATOMIC_DEFINE}, @ref{ISO_FORTRAN_ENV}\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_CAS}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_FETCH_ADD}, @ref{ATOMIC_FETCH_AND}, @ref{ATOMIC_FETCH_OR},\n+@ref{ATOMIC_FETCH_XOR}\n @end table\n \n \n+@node ATOMIC_XOR\n+@section @code{ATOMIC_XOR} --- Atomic bitwise OR operation\n+@fnindex ATOMIC_XOR\n+@cindex Atomic subroutine, XOR\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATOMIC_AND(ATOM, VALUE)} atomically defines @var{ATOM} with the bitwise\n+XOR between the values of @var{ATOM} and @var{VALUE}. When @var{STAT} is present\n+and the invokation was successful, it is assigned the value 0. If it is present\n+and the invokation has failed, it is assigned a positive value; in particular,\n+for a coindexed @var{ATOM}, if the remote image has stopped, it is assigned the\n+value of @code{ISO_FORTRAN_ENV}'s @code{STAT_STOPPED_IMAGE} and if the remote\n+image has failed, the value @code{STAT_FAILED_IMAGE}.\n+\n+@item @emph{Standard}:\n+TS 18508 or later\n+\n+@item @emph{Class}:\n+Atomic subroutine\n+\n+@item @emph{Syntax}:\n+@code{CALL ATOMIC_XOR (ATOM, VALUE [, STAT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ATOM}   @tab Scalar coarray or coindexed variable of integer\n+type with @code{ATOMIC_INT_KIND} kind.\n+@item @var{VALUE}  @tab Scalar of the same type as @var{ATOM}. If the kind\n+is different, the value is converted to the kind of @var{ATOM}.\n+@item @var{STAT}   @tab (optional) Scalar default-kind integer variable.\n+@end multitable\n+\n+@item @emph{Example}:\n+@smallexample\n+program atomic\n+  use iso_fortran_env\n+  integer(atomic_int_kind) :: atom[*]\n+  call atomic_xor (atom[1], int(b'10100011101'))\n+end program atomic\n+@end smallexample\n+\n+@item @emph{See also}:\n+@ref{ATOMIC_DEFINE}, @ref{ATOMIC_FETCH_XOR}, @ref{ISO_FORTRAN_ENV},\n+@ref{ATOMIC_ADD}, @ref{ATOMIC_OR}, @ref{ATOMIC_XOR}\n+@end table\n+\n \n @node BACKTRACE\n @section @code{BACKTRACE} --- Show a backtrace\n@@ -13252,6 +13731,11 @@ Positive, scalar default-integer constant used as STAT= return value if the\n argument in the statement requires synchronisation with an image, which has\n initiated the termination of the execution. (Fortran 2008 or later.)\n \n+@item @code{STAT_FAILED_IMAGE}:\n+Positive, scalar default-integer constant used as STAT= return value if the\n+argument in the statement requires communication with an image, which has\n+is in the failed state. (TS 18508 or later.)\n+\n @item @code{STAT_UNLOCKED}:\n Scalar default-integer constant used as STAT= return value by @code{UNLOCK} to\n denote that the lock variable is unlocked. (Fortran 2008 or later.)"}, {"sha": "c1d990ac61e1612f223d9f70e64c147bc7d1cfde", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -85,6 +85,8 @@ NAMED_INTCST (ISOFORTRANENV_FILE_STAT_LOCKED_OTHER_IMAGE, \\\n \t      GFC_STAT_LOCKED_OTHER_IMAGE, GFC_STD_F2008)\n NAMED_INTCST (ISOFORTRANENV_FILE_STAT_STOPPED_IMAGE, \"stat_stopped_image\", \\\n               GFC_STAT_STOPPED_IMAGE, GFC_STD_F2008)\n+NAMED_INTCST (ISOFORTRANENV_FILE_STAT_FAILED_IMAGE, \"stat_failed_image\", \\\n+              GFC_STAT_FAILED_IMAGE, GFC_STD_F2008_TS)\n NAMED_INTCST (ISOFORTRANENV_FILE_STAT_UNLOCKED, \"stat_unlocked\", \\\n               GFC_STAT_UNLOCKED, GFC_STD_F2008)\n "}, {"sha": "b90dac6d9d9f8c71ef8564f87381bb606f8bfe76", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -115,7 +115,8 @@ typedef enum\n   GFC_STAT_UNLOCKED = 0,\n   GFC_STAT_LOCKED,\n   GFC_STAT_LOCKED_OTHER_IMAGE,\n-  GFC_STAT_STOPPED_IMAGE = 6000 /* See LIBERROR_INQUIRE_INTERNAL_UNIT above. */\n+  GFC_STAT_STOPPED_IMAGE = 6000, /* See LIBERROR_INQUIRE_INTERNAL_UNIT above. */\n+  GFC_STAT_FAILED_IMAGE\n }\n libgfortran_stat_codes;\n "}, {"sha": "a285e9d6723b77b3334ce416f574f664086ca4b1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 206, "deletions": 13, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -8339,25 +8339,104 @@ conv_co_minmaxsum (gfc_code *code)\n \n \n static tree\n-conv_intrinsic_atomic_def (gfc_code *code)\n+conv_intrinsic_atomic_op (gfc_code *code)\n {\n-  gfc_se atom, value;\n-  stmtblock_t block;\n+  gfc_se atom, value, old;\n+  tree tmp;\n+  stmtblock_t block, post_block;\n   gfc_expr *atom_expr = code->ext.actual->expr;\n+  gfc_expr *stat;\n+  built_in_function fn;\n \n   if (atom_expr->expr_type == EXPR_FUNCTION\n       && atom_expr->value.function.isym\n       && atom_expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n     atom_expr = atom_expr->value.function.actual->expr;\n \n+  gfc_start_block (&block);\n+  gfc_init_block (&post_block);\n   gfc_init_se (&atom, NULL);\n   gfc_init_se (&value, NULL);\n+  atom.want_pointer = 1;\n   gfc_conv_expr (&atom, atom_expr);\n+  gfc_add_block_to_block (&block, &atom.pre);\n+  gfc_add_block_to_block (&post_block, &atom.post);\n   gfc_conv_expr (&value, code->ext.actual->next->expr);\n+  gfc_add_block_to_block (&block, &value.pre);\n+  gfc_add_block_to_block (&post_block, &value.post);\n \n-  gfc_init_block (&block);\n-  gfc_add_modify (&block, atom.expr,\n-\t\t  fold_convert (TREE_TYPE (atom.expr), value.expr));\n+  switch (code->resolved_isym->id)\n+    {\n+    case GFC_ISYM_ATOMIC_ADD:\n+    case GFC_ISYM_ATOMIC_FETCH_ADD:\n+      fn = BUILT_IN_ATOMIC_FETCH_ADD_N;\n+      break;\n+    case GFC_ISYM_ATOMIC_AND:\n+    case GFC_ISYM_ATOMIC_FETCH_AND:\n+      fn = BUILT_IN_ATOMIC_FETCH_AND_N;\n+      break;\n+    case GFC_ISYM_ATOMIC_DEF:\n+      fn = BUILT_IN_ATOMIC_STORE_N;\n+      break;\n+    case GFC_ISYM_ATOMIC_OR:\n+    case GFC_ISYM_ATOMIC_FETCH_OR:\n+      fn = BUILT_IN_ATOMIC_FETCH_OR_N;\n+      break;\n+    case GFC_ISYM_ATOMIC_XOR:\n+    case GFC_ISYM_ATOMIC_FETCH_XOR:\n+      fn = BUILT_IN_ATOMIC_FETCH_XOR_N;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  tmp = TREE_TYPE (TREE_TYPE (atom.expr));\n+  fn = (built_in_function) ((int) fn\n+\t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n+\t\t\t    + 1);\n+  tmp = builtin_decl_explicit (fn);\n+  tree itype = TREE_TYPE (TREE_TYPE (atom.expr));\n+  tmp = builtin_decl_explicit (fn);\n+\n+  switch (code->resolved_isym->id)\n+    {\n+    case GFC_ISYM_ATOMIC_ADD:\n+    case GFC_ISYM_ATOMIC_AND:\n+    case GFC_ISYM_ATOMIC_DEF:\n+    case GFC_ISYM_ATOMIC_OR:\n+    case GFC_ISYM_ATOMIC_XOR:\n+      stat = code->ext.actual->next->next->expr;\n+      tmp = build_call_expr_loc (input_location, tmp, 3, atom.expr,\n+\t\t\t\t fold_convert (itype, value.expr),\n+\t\t\t\t build_int_cst (NULL, MEMMODEL_RELAXED));\n+      gfc_add_expr_to_block (&block, tmp);\n+      break;\n+    default:\n+      stat = code->ext.actual->next->next->next->expr;\n+      gfc_init_se (&old, NULL);\n+      gfc_conv_expr (&old, code->ext.actual->next->next->expr);\n+      gfc_add_block_to_block (&block, &old.pre);\n+      gfc_add_block_to_block (&post_block, &old.post);\n+      tmp = build_call_expr_loc (input_location, tmp, 3, atom.expr,\n+\t\t\t\t fold_convert (itype, value.expr),\n+\t\t\t\t build_int_cst (NULL, MEMMODEL_RELAXED));\n+      gfc_add_modify (&block, old.expr,\n+\t\t      fold_convert (TREE_TYPE (old.expr), tmp));\n+      break;\n+    }\n+\n+  /* STAT=  */\n+  if (stat != NULL)\n+    {\n+      gcc_assert (stat->expr_type == EXPR_VARIABLE);\n+      gfc_init_se (&value, NULL);\n+      gfc_conv_expr_val (&value, stat);\n+      gfc_add_block_to_block (&block, &value.pre);\n+      gfc_add_block_to_block (&post_block, &value.post);\n+      gfc_add_modify (&block, value.expr,\n+\t\t      build_int_cst (TREE_TYPE (value.expr), 0));\n+    }\n+  gfc_add_block_to_block (&block, &post_block);\n   return gfc_finish_block (&block);\n }\n \n@@ -8366,22 +8445,124 @@ static tree\n conv_intrinsic_atomic_ref (gfc_code *code)\n {\n   gfc_se atom, value;\n-  stmtblock_t block;\n-  gfc_expr *atom_expr = code->ext.actual->expr;\n+  tree tmp;\n+  stmtblock_t block, post_block;\n+  built_in_function fn;\n+  gfc_expr *atom_expr = code->ext.actual->next->expr;\n \n   if (atom_expr->expr_type == EXPR_FUNCTION\n       && atom_expr->value.function.isym\n       && atom_expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n     atom_expr = atom_expr->value.function.actual->expr;\n \n+  gfc_start_block (&block);\n+  gfc_init_block (&post_block);\n   gfc_init_se (&atom, NULL);\n   gfc_init_se (&value, NULL);\n-  gfc_conv_expr (&value, atom_expr);\n-  gfc_conv_expr (&atom, code->ext.actual->next->expr);\n+  atom.want_pointer = 1;\n+  gfc_conv_expr (&value, code->ext.actual->expr);\n+  gfc_add_block_to_block (&block, &value.pre);\n+  gfc_add_block_to_block (&post_block, &value.post);\n+  gfc_conv_expr (&atom, atom_expr);\n+  gfc_add_block_to_block (&block, &atom.pre);\n+  gfc_add_block_to_block (&post_block, &atom.post);\n+\n+  tmp = TREE_TYPE (TREE_TYPE (atom.expr));\n+  fn = (built_in_function) ((int) BUILT_IN_ATOMIC_LOAD_N\n+\t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n+\t\t\t    + 1);\n+  tmp = builtin_decl_explicit (fn);\n+  tmp = build_call_expr_loc (input_location, tmp, 2, atom.expr,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    MEMMODEL_RELAXED));\n+  gfc_add_modify (&block, value.expr,\n+\t\t  fold_convert (TREE_TYPE (value.expr), tmp));\n+  \n+  /* STAT=  */\n+  if (code->ext.actual->next->next->expr != NULL)\n+    {\n+      gcc_assert (code->ext.actual->next->next->expr->expr_type\n+\t\t  == EXPR_VARIABLE);\n+      gfc_init_se (&value, NULL);\n+      gfc_conv_expr_val (&value, code->ext.actual->next->next->expr);\n+      gfc_add_block_to_block (&block, &value.pre);\n+      gfc_add_block_to_block (&post_block, &value.post);\n+      gfc_add_modify (&block, value.expr,\n+\t\t      build_int_cst (TREE_TYPE (value.expr), 0));\n+    }\n+  gfc_add_block_to_block (&block, &post_block);\n+  return gfc_finish_block (&block);\n+}\n+\n+\n+static tree\n+conv_intrinsic_atomic_cas (gfc_code *code)\n+{\n+  gfc_se argse;\n+  tree tmp, atom, old, new_val, comp;\n+  stmtblock_t block, post_block;\n+  built_in_function fn;\n+  gfc_expr *atom_expr = code->ext.actual->expr;\n+\n+  if (atom_expr->expr_type == EXPR_FUNCTION\n+      && atom_expr->value.function.isym\n+      && atom_expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom_expr = atom_expr->value.function.actual->expr;\n \n   gfc_init_block (&block);\n-  gfc_add_modify (&block, value.expr,\n-\t\t  fold_convert (TREE_TYPE (value.expr), atom.expr));\n+  gfc_init_block (&post_block);\n+  gfc_init_se (&argse, NULL);\n+  argse.want_pointer = 1;\n+  gfc_conv_expr (&argse, atom_expr);\n+  atom = argse.expr;\n+\n+  gfc_init_se (&argse, NULL);\n+  gfc_conv_expr (&argse, code->ext.actual->next->expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  old = argse.expr;\n+\n+  gfc_init_se (&argse, NULL);\n+  gfc_conv_expr (&argse, code->ext.actual->next->next->expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  comp = argse.expr;\n+\n+  gfc_init_se (&argse, NULL);\n+  gfc_conv_expr (&argse, code->ext.actual->next->next->next->expr);\n+  gfc_add_block_to_block (&block, &argse.pre);\n+  gfc_add_block_to_block (&post_block, &argse.post);\n+  new_val = argse.expr;\n+\n+  tmp = TREE_TYPE (TREE_TYPE (atom));\n+  fn = (built_in_function) ((int) BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N\n+\t\t\t    + exact_log2 (tree_to_uhwi (TYPE_SIZE_UNIT (tmp)))\n+\t\t\t    + 1);\n+  tmp = builtin_decl_explicit (fn);\n+\n+  gfc_add_modify (&block, old, comp);\n+  tmp = build_call_expr_loc (input_location, tmp, 6, atom,\n+\t\t\t     gfc_build_addr_expr (NULL, old),\n+\t\t\t     fold_convert (TREE_TYPE (old), new_val),\n+\t\t\t     boolean_false_node,\n+\t\t\t     build_int_cst (NULL, MEMMODEL_RELAXED),\n+\t\t\t     build_int_cst (NULL, MEMMODEL_RELAXED));\n+  gfc_add_expr_to_block (&block, tmp);\n+  \n+  /* STAT=  */\n+  if (code->ext.actual->next->next->next->next->expr != NULL)\n+    {\n+      gcc_assert (code->ext.actual->next->next->next->next->expr->expr_type\n+\t\t  == EXPR_VARIABLE);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_val (&argse,\n+\t\t\t code->ext.actual->next->next->next->next->expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      gfc_add_modify (&block, argse.expr,\n+\t\t      build_int_cst (TREE_TYPE (argse.expr), 0));\n+    }\n+  gfc_add_block_to_block (&block, &post_block);\n   return gfc_finish_block (&block);\n }\n \n@@ -8632,8 +8813,20 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)\n       res = conv_intrinsic_move_alloc (code);\n       break;\n \n+    case GFC_ISYM_ATOMIC_CAS:\n+      res = conv_intrinsic_atomic_cas (code);\n+      break;\n+\n+    case GFC_ISYM_ATOMIC_ADD:\n+    case GFC_ISYM_ATOMIC_AND:\n     case GFC_ISYM_ATOMIC_DEF:\n-      res = conv_intrinsic_atomic_def (code);\n+    case GFC_ISYM_ATOMIC_OR:\n+    case GFC_ISYM_ATOMIC_XOR:\n+    case GFC_ISYM_ATOMIC_FETCH_ADD:\n+    case GFC_ISYM_ATOMIC_FETCH_AND:\n+    case GFC_ISYM_ATOMIC_FETCH_OR:\n+    case GFC_ISYM_ATOMIC_FETCH_XOR:\n+      res = conv_intrinsic_atomic_op (code);\n       break;\n \n     case GFC_ISYM_ATOMIC_REF:"}, {"sha": "9d4689b7da1721e56ecf4231c96d285cd3c19da3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -1,3 +1,11 @@\n+2014-07-12  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_atomic_1.f90: Update dg-error.\n+\t* gfortran.dg/coarray_atomic_2.f90: New.\n+\t* gfortran.dg/coarray_atomic_3.f90: New.\n+\t* gfortran.dg/coarray_atomic_4.f90: New.\n+\t* gfortran.dg/coarray/atomic_2.f90: New.\n+\n 2014-07-11  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tPR c++/57644 - [C++1y] Cannot bind bitfield to lvalue reference"}, {"sha": "20b6890a9671991a9b2f6af77d48ddfb7c979d2f", "filename": "gcc/testsuite/gfortran.dg/coarray/atomic_2.f90", "status": "added", "additions": 653, "deletions": 0, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fatomic_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fatomic_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fatomic_2.f90?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -0,0 +1,653 @@\n+! { dg-do run }\n+!\n+use iso_fortran_env, only: atomic_int_kind, atomic_logical_kind\n+implicit none\n+\n+intrinsic :: atomic_define\n+intrinsic :: atomic_ref\n+intrinsic :: atomic_cas\n+intrinsic :: atomic_add\n+intrinsic :: atomic_and\n+intrinsic :: atomic_or\n+intrinsic :: atomic_xor\n+intrinsic :: atomic_fetch_add\n+intrinsic :: atomic_fetch_and\n+intrinsic :: atomic_fetch_or\n+intrinsic :: atomic_fetch_xor\n+integer(atomic_int_kind) :: caf[*], var, var3\n+logical(atomic_logical_kind) :: caf_log[*], var2\n+integer :: stat, i\n+\n+caf = 0\n+caf_log = .false.\n+sync all\n+\n+if (this_image() == 1) then\n+  call atomic_define(caf[num_images()], 5, stat=stat)\n+  if (stat /= 0) call abort()\n+  call atomic_define(caf_log[num_images()], .true., stat=stat)\n+  if (stat /= 0) call abort()\n+end if\n+sync all\n+\n+if (this_image() == num_images()) then\n+  if (caf /= 5) call abort()\n+  if (.not. caf_log) call abort()\n+  var = 99\n+  call atomic_ref(var, caf, stat=stat)\n+  if (stat /= 0 .or. var /= 5) call abort()\n+  var2 = .false.\n+  call atomic_ref(var2, caf_log, stat=stat)\n+  if (stat /= 0 .or. .not. var2) call abort()\n+end if\n+call atomic_ref(var, caf[num_images()], stat=stat)\n+if (stat /= 0 .or. var /= 5) call abort()\n+call atomic_ref(var2, caf_log[num_images()], stat=stat)\n+if (stat /= 0 .or. .not. var2) call abort()\n+sync all\n+\n+! ADD\n+caf = 0\n+sync all\n+\n+call atomic_add(caf, this_image(), stat=stat)\n+if (stat /= 0) call abort()\n+do i = 1, num_images()\n+  call atomic_add(caf[i], 1, stat=stat)\n+  if (stat /= 0) call abort()\n+  call atomic_ref(var, caf, stat=stat)\n+  if (stat /= 0 .or. var < this_image()) call abort()\n+end do\n+sync all\n+\n+call atomic_ref(var, caf[num_images()], stat=stat)\n+if (stat /= 0 .or. var /= num_images() + this_image()) call abort()\n+do i = 1, num_images()\n+  call atomic_ref(var, caf[i], stat=stat)\n+  if (stat /= 0 .or. var /= num_images() + i) call abort()\n+end do\n+sync all\n+\n+! AND(1)\n+caf = 0\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_and(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = 0\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = iand(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! AND(2)\n+caf = -1\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_and(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = -1\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = iand(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! AND(3)\n+caf = 0\n+do i = 1, storage_size(caf)-2, 2\n+  caf = shiftl(1, i)\n+  var3 = shiftl(1, i)\n+end do\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_and(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = iand(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! OR(1)\n+caf = 0\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_or(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = 0\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ior(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! OR(2)\n+caf = -1\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_or(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = -1\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ior(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! OR(3)\n+caf = 0\n+do i = 1, storage_size(caf)-2, 2\n+  caf = shiftl(1, i)\n+  var3 = shiftl(1, i)\n+end do\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_or(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ior(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! XOR(1)\n+caf = 0\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_xor(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = 0\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ieor(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! XOR(2)\n+caf = -1\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_xor(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = -1\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ieor(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! XOR(3)\n+caf = 0\n+do i = 1, storage_size(caf)-2, 2\n+  caf = shiftl(1, i)\n+  var3 = shiftl(1, i)\n+end do\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    call atomic_xor(caf[i], shiftl(1, this_image()), stat=stat)\n+    if (stat /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ieor(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! ADD\n+caf = 0\n+sync all\n+var = -99\n+call atomic_fetch_add(caf, this_image(), var, stat=stat)\n+if (stat /= 0 .or. var < 0) call abort()\n+if (num_images() == 1 .and. var /= 0) call abort()\n+do i = 1, num_images()\n+  var = -99\n+  call atomic_fetch_add(caf[i], 1, var, stat=stat)\n+  if (stat /= 0 .or. var < 0) call abort()\n+  call atomic_ref(var, caf, stat=stat)\n+  if (stat /= 0 .or. var < this_image()) call abort()\n+end do\n+sync all\n+\n+call atomic_ref(var, caf[num_images()], stat=stat)\n+if (stat /= 0 .or. var /= num_images() + this_image()) call abort()\n+do i = 1, num_images()\n+  call atomic_ref(var, caf[i], stat=stat)\n+  if (stat /= 0 .or. var /= num_images() + i) call abort()\n+end do\n+sync all\n+\n+\n+! AND(1)\n+caf = 0\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = 99\n+    call atomic_fetch_and(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var /= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = 0\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = iand(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! AND(2)\n+caf = -1\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_and(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var == shiftl(1, this_image())) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = -1\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = iand(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! AND(3)\n+caf = 0\n+var3 = 0\n+do i = 1, storage_size(caf)-2, 2\n+  caf = ior(shiftl(1, i), caf)\n+  var3 = ior(shiftl(1, i), var3)\n+end do\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_and(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var <= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = iand(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+\n+\n+! OR(1)\n+caf = 0\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_or(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var < 0 .or. var == shiftl(1, this_image())) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = 0\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ior(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! OR(2)\n+caf = -1\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_or(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. (var < 0 .and. var /= -1)) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = -1\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ior(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! OR(3)\n+caf = 0\n+var3 = 0\n+do i = 1, storage_size(caf)-2, 2\n+  caf = ior(shiftl(1, i), caf)\n+  var3 = ior(shiftl(1, i), var3)\n+end do\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_or(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var <= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ior(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+\n+! XOR(1)\n+caf = 0\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_xor(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var < 0 .or. var == shiftl(1, this_image())) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = 0\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ieor(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! XOR(2)\n+caf = -1\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_xor(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. (var < 0 .and. var /= -1)) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  var3 = -1\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ieor(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! XOR(3)\n+caf = 0\n+var3 = 0\n+do i = 1, storage_size(caf)-2, 2\n+  caf = ior(shiftl(1, i), caf)\n+  var3 = ior(shiftl(1, i), var3)\n+end do\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = this_image(), min(num_images(), storage_size(caf)-2)\n+    var = -99\n+    call atomic_fetch_xor(caf[i], shiftl(1, this_image()), var, stat=stat)\n+    if (stat /= 0 .or. var <= 0) call abort()\n+  end do\n+end if\n+sync all\n+\n+if (this_image() < storage_size(caf)-2) then\n+  do i = 1, min(num_images(), storage_size(caf)-2)\n+    var3 = ieor(var3, shiftl(1, i))\n+    call atomic_ref(var, caf[i], stat=stat)\n+    if (stat /= 0 .or. var /= var3) call abort()\n+    if (i == this_image()) then\n+      call atomic_ref(var, caf[i], stat=stat)\n+      if (stat /= 0 .or. var /= var3) call abort()\n+    end if\n+  end do\n+end if\n+sync all\n+\n+! CAS\n+caf = 9\n+caf_log = .true.\n+sync all\n+\n+if (this_image() == 1) then\n+  call atomic_cas(caf[num_images()], compare=5, new=3, old=var, stat=stat)\n+  if (stat /= 0 .or. var /= 9) call abort()\n+  call atomic_ref(var, caf[num_images()], stat=stat)\n+  if (stat /= 0 .or. var /= 9) call abort()\n+end if\n+sync all\n+\n+if (this_image() == num_images() .and. caf /= 9) call abort()\n+call atomic_ref(var, caf[num_images()], stat=stat)\n+if (stat /= 0 .or. var /= 9) call abort()\n+sync all\n+\n+if (this_image() == 1) then\n+  call atomic_cas(caf[num_images()], compare=9, new=3, old=var, stat=stat)\n+  if (stat /= 0 .or. var /= 9) call abort()\n+  call atomic_ref(var, caf[num_images()], stat=stat)\n+  if (stat /= 0 .or. var /= 3) call abort()\n+end if\n+sync all\n+\n+if (this_image() == num_images() .and. caf /= 3) call abort()\n+call atomic_ref(var, caf[num_images()], stat=stat)\n+if (stat /= 0 .or. var /= 3) call abort()\n+sync all\n+\n+\n+if (this_image() == 1) then\n+  call atomic_cas(caf_log[num_images()], compare=.false., new=.false., old=var2, stat=stat)\n+  if (stat /= 0 .or. var2 .neqv. .true.) call abort()\n+  call atomic_ref(var2, caf_log[num_images()], stat=stat)\n+  if (stat /= 0 .or. var2 .neqv. .true.) call abort()\n+end if\n+sync all\n+\n+if (this_image() == num_images() .and. caf_log .neqv. .true.) call abort()\n+call atomic_ref(var2, caf_log[num_images()], stat=stat)\n+if (stat /= 0 .or. var2 .neqv. .true.) call abort()\n+sync all\n+\n+if (this_image() == 1) then\n+  call atomic_cas(caf_log[num_images()], compare=.true., new=.false., old=var2, stat=stat)\n+  if (stat /= 0 .or. var2 .neqv. .true.) call abort()\n+  call atomic_ref(var2, caf_log[num_images()], stat=stat)\n+  if (stat /= 0 .or. var2 .neqv. .false.) call abort()\n+end if\n+sync all\n+\n+if (this_image() == num_images() .and. caf_log .neqv. .false.) call abort()\n+call atomic_ref(var2, caf_log[num_images()], stat=stat)\n+if (stat /= 0 .or. var2 .neqv. .false.) call abort()\n+end"}, {"sha": "107f076f130692c6d68036e55dbca5b748d090bf", "filename": "gcc/testsuite/gfortran.dg/coarray_atomic_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_1.f90?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -16,6 +16,6 @@\n call atomic_ref(b, b) ! { dg-error \"shall be a coarray\" }\n \n call atomic_define(c, 7) ! { dg-error \"an integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n-call atomic_ref(d, a(1)) ! { dg-error \"shall have the same type\" }\n+call atomic_ref(d, a(1)) ! { dg-error \"shall have the same type as 'atom'\" }\n call atomic_ref(.true., e) ! { dg-error \"shall be definable\" }\n end"}, {"sha": "c66827b63149c1702939f41cfef663b0738300d1", "filename": "gcc/testsuite/gfortran.dg/coarray_atomic_2.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_2.f90?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -std=f2008\" }\n+!\n+use iso_fortran_env, only: atomic_int_kind, atomic_logical_kind\n+implicit none\n+\n+intrinsic :: atomic_define\n+intrinsic :: atomic_ref\n+intrinsic :: atomic_cas ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_add ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_and ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_or ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_xor ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_fetch_add ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_fetch_and ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_fetch_or ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+intrinsic :: atomic_fetch_xor ! { dg-error \"not available in the current standard settings but new in TS 29113/TS 18508.\" }\n+integer(atomic_int_kind) :: caf[*], var\n+logical(atomic_logical_kind) :: caf_log[*], var2\n+integer :: stat\n+integer(1) :: stat2\n+\n+call atomic_define(caf, 5, stat=stat) ! { dg-error \"STAT= argument to atomic_define\" }\n+call atomic_define(caf_log, .true., stat=stat2) ! { dg-error \"must be of kind 4\" }\n+call atomic_ref(var, caf[1], stat=stat2) ! { dg-error \"must be of kind 4\" }\n+call atomic_ref(var2, caf_log[1], stat=stat) ! { dg-error \"STAT= argument to atomic_ref\" }\n+end"}, {"sha": "a3c4264e68e91e2ec565ca6c79292c4bc41e84f7", "filename": "gcc/testsuite/gfortran.dg/coarray_atomic_3.f90", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_3.f90?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -std=f2008ts -fmax-errors=200\" }\n+!\n+use iso_fortran_env, only: atomic_int_kind, atomic_logical_kind\n+implicit none\n+\n+intrinsic :: atomic_define\n+intrinsic :: atomic_ref\n+intrinsic :: atomic_cas\n+intrinsic :: atomic_add\n+intrinsic :: atomic_and\n+intrinsic :: atomic_or\n+intrinsic :: atomic_xor\n+intrinsic :: atomic_fetch_add\n+intrinsic :: atomic_fetch_and\n+intrinsic :: atomic_fetch_or\n+intrinsic :: atomic_fetch_xor\n+integer(atomic_int_kind) :: caf[*], var\n+logical(atomic_logical_kind) :: caf_log[*], var2\n+integer :: stat\n+integer(1) :: var3, caf0[*]\n+logical(1) :: var4, caf0_log[*]\n+\n+call atomic_define(caf[1], 2_2, stat=stat)\n+call atomic_define(atom=caf_log[1], value=.false._2)\n+call atomic_define(caf_log[1], 2) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_define(var, 2_2, stat=stat) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_define(caf0, 2_2, stat=stat) ! { dg-error \"integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+call atomic_define(var2, 2_2, stat=stat) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_define(caf0_log, 2_2, stat=stat) ! { dg-error \"integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+\n+call atomic_ref(var3, caf[1], stat=stat)\n+call atomic_ref(value=var4, atom=caf_log[1])\n+call atomic_ref(var, caf_log[1]) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_ref(var, var) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_ref(var, caf0) ! { dg-error \"integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+call atomic_ref(var, caf0_log) ! { dg-error \"integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+\n+call atomic_cas(caf[1], var, 2_4, 1_1, stat=stat)\n+call atomic_cas(caf[1], var, 2_2, 1_1, stat=stat) ! { dg-error \"'compare' argument of 'atomic_cas' intrinsic at .1. must be the same type and kind as 'atom'\" }\n+call atomic_cas(caf[1], var3, 2_2, 1_1, stat=stat) ! { dg-error \"'old' argument of 'atomic_cas' intrinsic at .1. must be the same type and kind as 'atom'\" }\n+call atomic_cas(caf[1], var3, 2_4, .false._4, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_cas(caf0[1], var, 2_4, 1_1, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+call atomic_cas(var, var, 2_4, 1_1, stat=stat) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_cas(caf_log[1], var2, .true._4, .false._1, stat=stat)\n+call atomic_cas(caf_log[1], var2, .true._2, .false._1, stat=stat) ! { dg-error \"'compare' argument of 'atomic_cas' intrinsic at .1. must be the same type and kind as 'atom'\" }\n+call atomic_cas(caf_log[1], var4, .true._4, .false._1, stat=stat) ! { dg-error \"'old' argument of 'atomic_cas' intrinsic at .1. must be the same type and kind as 'atom'\" }\n+call atomic_cas(caf_log[1], var4, .true._4, 4_4, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_cas(atom=caf0_log[1], old=var4, compare=.true._4, new=.false._4, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND or a logical of ATOMIC_LOGICAL_KIND\" }\n+call atomic_cas(var2, var4, .true._4, .false._4, stat=stat) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_cas(caf[1], var, 2_4, 1_1, stat=var3) ! { dg-error \"'stat' argument of 'atomic_cas' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_add(atom=caf, value=2_4, stat=stat)\n+call atomic_add(caf, 2_2, stat=stat)\n+call atomic_add(caf, .false._2, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_add(caf_log, .false._2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_add(var, 34._4) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_add(atom=caf, value=2_4, stat=var3) ! { dg-error \"'stat' argument of 'atomic_add' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_and(caf, 2_4, stat=stat)\n+call atomic_and(atom=caf, value=2_2, stat=stat)\n+call atomic_and(caf, .false._2, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_and(caf_log, .false._2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_and(var, 34._4) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_and(caf, 2_4, stat=var3) ! { dg-error \"'stat' argument of 'atomic_and' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_or(caf, value=2_4, stat=stat)\n+call atomic_or(atom=caf, value=2_2, stat=stat)\n+call atomic_or(caf, .false._2, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_or(caf_log, .false._2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_or(var, 34._4) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_or(caf, value=2_4, stat=var3) ! { dg-error \"'stat' argument of 'atomic_or' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_xor(caf, 2_4, stat=stat)\n+call atomic_xor(atom=caf, value=2_2, stat=stat)\n+call atomic_xor(caf, .false._2, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_xor(caf_log, .false._2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_xor(var, 34._4) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_xor(caf, 2_4, stat=var3) ! { dg-error \"'stat' argument of 'atomic_xor' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_fetch_add(atom=caf, value=2_4, old=var, stat=stat)\n+call atomic_fetch_add(caf, 2_2, var)\n+call atomic_fetch_add(caf, .false._2, var, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_fetch_add(caf_log, .false._2, var2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_fetch_add(var, 34._4, var) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_fetch_add(caf, 2_2, var3) ! { dg-error \"must be the same type and kind as 'atom'\" }\n+call atomic_fetch_add(atom=caf, value=2_4, old=var, stat=var3) ! { dg-error \"'stat' argument of 'atomic_fetch_add' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_fetch_and(atom=caf, value=2_4, old=var, stat=stat)\n+call atomic_fetch_and(caf, 2_2, var)\n+call atomic_fetch_and(caf, .false._2, var, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_fetch_and(caf_log, .false._2, var2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_fetch_and(var, 34._4, var) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_fetch_and(caf, 2_2, var3) ! { dg-error \"must be the same type and kind as 'atom'\" }\n+call atomic_fetch_and(atom=caf, value=2_4, old=var, stat=var3) ! { dg-error \"'stat' argument of 'atomic_fetch_and' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_fetch_or(atom=caf, value=2_4, old=var, stat=stat)\n+call atomic_fetch_or(caf, 2_2, var)\n+call atomic_fetch_or(caf, .false._2, var, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_fetch_or(caf_log, .false._2, var2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_fetch_or(var, 34._4, var) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_fetch_or(caf, 2_2, var3) ! { dg-error \"must be the same type and kind as 'atom'\" }\n+call atomic_fetch_or(atom=caf, value=2_4, old=var, stat=var3) ! { dg-error \"'stat' argument of 'atomic_fetch_or' intrinsic at .1. must be of kind 4\" }\n+\n+call atomic_fetch_xor(atom=caf, value=2_4, old=var, stat=stat)\n+call atomic_fetch_xor(caf, 2_2, var)\n+call atomic_fetch_xor(caf, .false._2, var, stat=stat) ! { dg-error \"shall have the same type as 'atom'\" }\n+call atomic_fetch_xor(caf_log, .false._2, var2, stat=stat) ! { dg-error \"shall be an integer of ATOMIC_INT_KIND\" }\n+call atomic_fetch_xor(var, 34._4, var) ! { dg-error \"shall be a coarray or coindexed\" }\n+call atomic_fetch_xor(caf, 2_2, var3) ! { dg-error \"must be the same type and kind as 'atom'\" }\n+call atomic_fetch_xor(atom=caf, value=2_4, old=var, stat=var3) ! { dg-error \"'stat' argument of 'atomic_fetch_xor' intrinsic at .1. must be of kind 4\" }\n+end"}, {"sha": "663a6c83da43c5fddf971c6ba0469fcef4c0c978", "filename": "gcc/testsuite/gfortran.dg/coarray_atomic_4.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f4aaf912bdab4fe3ccad012add9a1d00a26dab1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_atomic_4.f90?ref=7f4aaf912bdab4fe3ccad012add9a1d00a26dab1", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single -fdump-tree-original\" }\n+!\n+use iso_fortran_env, only: atomic_int_kind, atomic_logical_kind\n+implicit none\n+\n+intrinsic :: atomic_define\n+intrinsic :: atomic_ref\n+intrinsic :: atomic_cas\n+intrinsic :: atomic_add\n+intrinsic :: atomic_and\n+intrinsic :: atomic_or\n+intrinsic :: atomic_xor\n+intrinsic :: atomic_fetch_add\n+intrinsic :: atomic_fetch_and\n+intrinsic :: atomic_fetch_or\n+intrinsic :: atomic_fetch_xor\n+integer(atomic_int_kind) :: caf[*], var\n+logical(atomic_logical_kind) :: caf_log[*], var2\n+integer :: stat\n+integer(1) :: var3\n+logical(1) :: var4\n+\n+call atomic_define(caf, var, stat=stat)\n+call atomic_define(caf_log, var2, stat=stat)\n+\n+call atomic_ref(var, caf, stat=stat)\n+call atomic_ref(var2, caf_log, stat=stat)\n+\n+call atomic_cas(caf, var, 3_atomic_int_kind, 5_1, stat=stat)\n+call atomic_cas(caf_log, var2, .true._atomic_logical_kind, &\n+                .false._2, stat=stat)\n+\n+call atomic_add(caf, 77, stat=stat)\n+call atomic_and(caf, 88, stat=stat)\n+call atomic_or(caf, 101, stat=stat)\n+call atomic_xor(caf, 105_2, stat=stat)\n+\n+call atomic_fetch_add(caf, var3, var, stat=stat)\n+call atomic_fetch_and(caf, 22_16, var, stat=stat)\n+call atomic_fetch_or(caf, var3, var, stat=stat)\n+call atomic_fetch_xor(caf, 47_2, var, stat=stat)\n+\n+end\n+\n+! All the atomic calls:\n+! { dg-final { scan-tree-dump-times \"  __atomic_store_4 \\\\(&caf, \\\\(integer\\\\(kind=4\\\\)\\\\) var, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_store_4 \\\\(&caf_log, \\\\(logical\\\\(kind=4\\\\)\\\\) var2, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"var = \\\\(integer\\\\(kind=4\\\\)\\\\) __atomic_load_4 \\\\(&caf, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"var2 = \\\\(logical\\\\(kind=4\\\\)\\\\) __atomic_load_4 \\\\(&caf_log, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_compare_exchange_4 \\\\(&caf, &var, 5, 0, 0, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_compare_exchange_4 \\\\(&caf_log, &var2, 0, 0, 0, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_fetch_add_4 \\\\(&caf, 77, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_fetch_and_4 \\\\(&caf, 88, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_fetch_or_4 \\\\(&caf, 101, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  __atomic_fetch_xor_4 \\\\(&caf, 105, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"var = \\\\(integer\\\\(kind=4\\\\)\\\\) __atomic_fetch_add_4 \\\\(&caf, \\\\(integer\\\\(kind=4\\\\)\\\\) var3, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"var = \\\\(integer\\\\(kind=4\\\\)\\\\) __atomic_fetch_and_4 \\\\(&caf, 22, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  var = \\\\(integer\\\\(kind=4\\\\)\\\\) __atomic_fetch_or_4 \\\\(&caf, \\\\(integer\\\\(kind=4\\\\)\\\\) var3, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"  var = \\\\(integer\\\\(kind=4\\\\)\\\\) __atomic_fetch_xor_4 \\\\(&caf, 47, 0\\\\);\" 1 \"original\" } }\n+\n+! CAS: Handle \"compare\" argument\n+! { dg-final { scan-tree-dump-times \"var = 3;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"var2 = 1;\" 1 \"original\" } }\n+\n+! All calls should have a stat=0\n+! { dg-final { scan-tree-dump-times \"stat = 0;\" 14 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}