{"sha": "c980ac4985328f6d96826091d278d5d0d3389684", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4MGFjNDk4NTMyOGY2ZDk2ODI2MDkxZDI3OGQ1ZDBkMzM4OTY4NA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-01T05:17:45Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-01T05:17:45Z"}, "message": "(expand_expr...\n\n(expand_expr, case PLUS_EXPR): In the special case\nto return sym+integer as an expression, limit it to when\nthe non-CONST_INT arg is at least a constant.\n\n(expand_increment): Do preinc with single insn if there's such an insn.\n\n(store_field): Store unaligned field with bit field methods.\n\nFrom-SVN: r4810", "tree": {"sha": "329841782696fb90ef1b021b4d1480760ef4b452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329841782696fb90ef1b021b4d1480760ef4b452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c980ac4985328f6d96826091d278d5d0d3389684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c980ac4985328f6d96826091d278d5d0d3389684", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c980ac4985328f6d96826091d278d5d0d3389684", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c980ac4985328f6d96826091d278d5d0d3389684/comments", "author": null, "committer": null, "parents": [{"sha": "c62d2a9cfb45e31199914e5848976be795ae6e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62d2a9cfb45e31199914e5848976be795ae6e5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c62d2a9cfb45e31199914e5848976be795ae6e5b"}], "stats": {"total": 85, "additions": 58, "deletions": 27}, "files": [{"sha": "f8cb7b42b81756e435c0b3c44628f1bed1350ba8", "filename": "gcc/expr.c", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980ac4985328f6d96826091d278d5d0d3389684/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980ac4985328f6d96826091d278d5d0d3389684/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c980ac4985328f6d96826091d278d5d0d3389684", "patch": "@@ -2701,7 +2701,14 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n   if (mode == VOIDmode\n       || (mode != BLKmode && ! direct_store[(int) mode])\n       || GET_CODE (target) == REG\n-      || GET_CODE (target) == SUBREG)\n+      || GET_CODE (target) == SUBREG\n+      /* If the field isn't aligned enough to fetch as a unit,\n+\t fetch it as a bit field.  */\n+#ifdef STRICT_ALIGNMENT\n+      || align * BITS_PER_UNIT < GET_MODE_ALIGNMENT (mode)\n+      || bitpos % GET_MODE_ALIGNMENT (mode) != 0\n+#endif\n+      )\n     {\n       rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n       /* Store the value in the bitfield.  */\n@@ -4306,38 +4313,47 @@ expand_expr (exp, target, tmode, modifier)\n \t address.\n \n \t If this is an EXPAND_SUM call, always return the sum.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n-\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n-\t      || mode == Pmode))\n+      if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n+\t  || mode == Pmode)\n \t{\n-\t  op1 = expand_expr (TREE_OPERAND (exp, 1), subtarget, VOIDmode,\n-\t\t\t     EXPAND_SUM);\n-\t  op1 = plus_constant (op1, TREE_INT_CST_LOW (TREE_OPERAND (exp, 0)));\n-\t  if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n-\t    op1 = force_operand (op1, target);\n-\t  return op1;\n-\t}\n+\t  if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && TREE_CONSTANT (TREE_OPERAND (exp, 1)))\n+\t    {\n+\t      op1 = expand_expr (TREE_OPERAND (exp, 1), subtarget, VOIDmode,\n+\t\t\t\t EXPAND_SUM);\n+\t      op1 = plus_constant (op1, TREE_INT_CST_LOW (TREE_OPERAND (exp, 0)));\n+\t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n+\t\top1 = force_operand (op1, target);\n+\t      return op1;\n+\t    }\n \n-      else if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n-\t       && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n-\t       && (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER\n-\t\t   || mode == Pmode))\n-\t{\n-\t  op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n-\t\t\t     EXPAND_SUM);\n-\t  op0 = plus_constant (op0, TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)));\n-\t  if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n-\t    op0 = force_operand (op0, target);\n-\t  return op0;\n+\t  else if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST\n+\t\t   && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_INT\n+\t\t   && TREE_CONSTANT (TREE_OPERAND (exp, 0)))\n+\t    {\n+\t      op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode,\n+\t\t\t\t EXPAND_SUM);\n+\t      if (! CONSTANT_P (op0))\n+\t\t{\n+\t\t  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n+\t\t\t\t     VOIDmode, modifier);\n+\t\t  goto both_summands;\n+\t\t}\n+\t      op0 = plus_constant (op0, TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)));\n+\t      if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n+\t\top0 = force_operand (op0, target);\n+\t      return op0;\n+\t    }\n \t}\n \n       /* No sense saving up arithmetic to be done\n \t if it's all in the wrong mode to form part of an address.\n \t And force_operand won't know whether to sign-extend or\n \t zero-extend.  */\n       if ((modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n-\t  || mode != Pmode) goto binop;\n+\t  || mode != Pmode)\n+\tgoto binop;\n \n       preexpand_calls (exp);\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n@@ -4346,6 +4362,7 @@ expand_expr (exp, target, tmode, modifier)\n       op0 = expand_expr (TREE_OPERAND (exp, 0), subtarget, VOIDmode, modifier);\n       op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, modifier);\n \n+    both_summands:\n       /* Make sure any term that's a sum with a constant comes last.  */\n       if (GET_CODE (op0) == PLUS\n \t  && CONSTANT_P (XEXP (op0, 1)))\n@@ -6839,6 +6856,7 @@ expand_increment (exp, post)\n   int icode;\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n   int op0_is_copy = 0;\n+  int single_insn = 0;\n \n   /* Stabilize any component ref that might need to be\n      evaluated more than once below.  */\n@@ -6877,12 +6895,25 @@ expand_increment (exp, post)\n       || TREE_CODE (exp) == PREDECREMENT_EXPR)\n     this_optab = sub_optab;\n \n+  /* For a preincrement, see if we can do this with a single instruction.  */\n+  if (!post)\n+    {\n+      icode = (int) this_optab->handlers[(int) mode].insn_code;\n+      if (icode != (int) CODE_FOR_nothing\n+\t  /* Make sure that OP0 is valid for operands 0 and 1\n+\t     of the insn we want to queue.  */\n+\t  && (*insn_operand_predicate[icode][0]) (op0, mode)\n+\t  && (*insn_operand_predicate[icode][1]) (op0, mode)\n+\t  && (*insn_operand_predicate[icode][2]) (op1, mode))\n+\tsingle_insn = 1;\n+    }\n+\n   /* If OP0 is not the actual lvalue, but rather a copy in a register,\n      then we cannot just increment OP0.  We must therefore contrive to\n      increment the original value.  Then, for postincrement, we can return\n-     OP0 since it is a copy of the old value.  For preincrement, we want\n-     to always expand here, since this generates better or equivalent code.  */\n-  if (!post || op0_is_copy)\n+     OP0 since it is a copy of the old value.  For preincrement, expand here\n+     unless we can do it with a single insn.  */\n+  if (op0_is_copy || (!post && !single_insn))\n     {\n       /* This is the easiest way to increment the value wherever it is.\n \t Problems with multiple evaluation of INCREMENTED are prevented"}]}