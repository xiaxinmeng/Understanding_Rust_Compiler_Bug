{"sha": "6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRhYjlkNDEwOTJhMDZjZDdkMWRjOGI2ODEzNjM5YzIwNzFjYjkyYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-20T01:40:14Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-04-20T01:40:14Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r800", "tree": {"sha": "92dfedc5fa233fe59d49b55be4be110603a32536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92dfedc5fa233fe59d49b55be4be110603a32536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/comments", "author": null, "committer": null, "parents": [{"sha": "21163e24aaa662d60cf930aeb502246c81aa373f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21163e24aaa662d60cf930aeb502246c81aa373f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21163e24aaa662d60cf930aeb502246c81aa373f"}], "stats": {"total": 197, "additions": 96, "deletions": 101}, "files": [{"sha": "6120d2ba5218ac0cfc40dfb903136029347e7769", "filename": "gcc/config/mips/t-mips", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fconfig%2Fmips%2Ft-mips", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fconfig%2Fmips%2Ft-mips", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-mips?ref=6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "patch": "@@ -1,5 +1,4 @@\n EXTRA_PASSES\t= mips-tfile mips-tdump\n-EXTRA_PROGRAMS\t= ld\n CCLIBFLAGS\t= -O -G 0\n LIBGCC2_CFLAGS\t= -O2 $(GCC_CFLAGS) -g1 -G 0\n CONFIG2_H\t= $(srcdir)/config/mips.h"}, {"sha": "c0e08489649fc33a30bfd2d2ccc968340f35b55a", "filename": "gcc/config/mips/t-osfrose", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fconfig%2Fmips%2Ft-osfrose", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fconfig%2Fmips%2Ft-osfrose", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-osfrose?ref=6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "patch": "@@ -1,5 +1,3 @@\n-# Use collect2 to link.\n-EXTRA_PROGRAMS\t= ld\n EXTRA_OBJS\t= halfpic.o\n LIMITS_H\t=\n CONFIG2_H\t= $(srcdir)/config/mips.h $(srcdir)/config/decrose.h $(srcdir)/halfpic.h"}, {"sha": "6120d2ba5218ac0cfc40dfb903136029347e7769", "filename": "gcc/config/mips/t-ultrix", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fconfig%2Fmips%2Ft-ultrix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fconfig%2Fmips%2Ft-ultrix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-ultrix?ref=6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "patch": "@@ -1,6 +1,4 @@\n EXTRA_PASSES\t= mips-tfile mips-tdump\n-# Use collect2 to link.\n-EXTRA_PROGRAMS\t= ld\n CCLIBFLAGS\t= -O -G 0\n LIBGCC2_CFLAGS\t= -O2 $(GCC_CFLAGS) -g1 -G 0\n CONFIG2_H\t= $(srcdir)/config/mips.h"}, {"sha": "2bd43eb1fb03c435bfae797fcfb39b9e11ae3d7b", "filename": "gcc/rtl.c", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "patch": "@@ -371,101 +371,6 @@ copy_most_rtx (orig, may_share)\n   return copy;\n }\n \f\n-/* Helper functions for instruction scheduling.  */\n-\n-/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n-   LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n-   of dependence that this link represents.  */\n-\n-void\n-add_dependence (insn, elem, dep_type)\n-     rtx insn;\n-     rtx elem;\n-     enum reg_note dep_type;\n-{\n-  rtx link, next;\n-\n-  /* Don't depend an insn on itself.  */\n-  if (insn == elem)\n-    return;\n-\n-  /* If elem is part of a sequence that must be scheduled together, then\n-     make the dependence point to the last insn of the sequence.\n-     When HAVE_cc0, it is possible for NOTEs to exist between users and\n-     setters of the condition codes, so we must skip past notes here.\n-     Otherwise, NOTEs are impossible here.  */\n-\n-  next = NEXT_INSN (elem);\n-\n-#ifdef HAVE_cc0\n-  while (next && GET_CODE (next) == NOTE)\n-    next = NEXT_INSN (next);\n-#endif\n-\n-  if (next && SCHED_GROUP_P (next))\n-    {\n-      /* Notes will never intervene here though, so don't bother checking\n-\t for them.  */\n-      while (next && SCHED_GROUP_P (next))\n-\tnext = NEXT_INSN (next);\n-\n-      /* Again, don't depend an insn on itself.  */\n-      if (insn == next)\n-\treturn;\n-\n-      /* Make the dependence to NEXT, the last insn of the group, instead\n-\t of the original ELEM.  */\n-      elem = next;\n-    }\n-\n-  /* Check that we don't already have this dependence.  */\n-  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-    if (XEXP (link, 0) == elem)\n-      {\n-\t/* If this is a more restrictive type of dependence than the existing\n-\t   one, then change the existing dependence to this type.  */\n-\tif ((int) dep_type < (int) REG_NOTE_KIND (link))\n-\t  PUT_REG_NOTE_KIND (link, dep_type);\n-\treturn;\n-      }\n-  /* Might want to check one level of transitivity to save conses.  */\n-\n-  link = rtx_alloc (INSN_LIST);\n-  /* Insn dependency, not data dependency.  */\n-  PUT_REG_NOTE_KIND (link, dep_type);\n-  XEXP (link, 0) = elem;\n-  XEXP (link, 1) = LOG_LINKS (insn);\n-  LOG_LINKS (insn) = link;\n-}\n-\n-/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n-   of INSN.  Abort if not found.  */\n-void\n-remove_dependence (insn, elem)\n-     rtx insn;\n-     rtx elem;\n-{\n-  rtx prev, link;\n-  int found = 0;\n-\n-  for (prev = 0, link = LOG_LINKS (insn); link;\n-       prev = link, link = XEXP (link, 1))\n-    {\n-      if (XEXP (link, 0) == elem)\n-\t{\n-\t  if (prev)\n-\t    XEXP (prev, 1) = XEXP (link, 1);\n-\t  else\n-\t    LOG_LINKS (insn) = XEXP (link, 1);\n-\t  found = 1;\n-\t}\n-    }\n-\n-  if (! found)\n-    abort ();\n-  return;\n-}\n-\f\n /* Subroutines of read_rtx.  */\n \n /* Dump code after printing a message.  Used when read_rtx finds"}, {"sha": "b18c68c9228d29598db04abfb5d987317c969bb5", "filename": "gcc/sched.c", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab9d41092a06cd7d1dc8b6813639c2071cb92b/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=6dab9d41092a06cd7d1dc8b6813639c2071cb92b", "patch": "@@ -213,7 +213,7 @@ static int q_ptr = 0;\n static int q_size = 0;\n #define NEXT_Q(X) (((X)+1) & (Q_SIZE-1))\n #define NEXT_Q_AFTER(X,C) (((X)+C) & (Q_SIZE-1))\n-\f\n+\n /* Forward declarations.  */\n static void sched_analyze_2 ();\n static void schedule_block ();\n@@ -692,6 +692,101 @@ output_dependence (mem, x)\n \t\t    && ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem))));\n }\n \f\n+/* Helper functions for instruction scheduling.  */\n+\n+/* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n+   LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n+   of dependence that this link represents.  */\n+\n+void\n+add_dependence (insn, elem, dep_type)\n+     rtx insn;\n+     rtx elem;\n+     enum reg_note dep_type;\n+{\n+  rtx link, next;\n+\n+  /* Don't depend an insn on itself.  */\n+  if (insn == elem)\n+    return;\n+\n+  /* If elem is part of a sequence that must be scheduled together, then\n+     make the dependence point to the last insn of the sequence.\n+     When HAVE_cc0, it is possible for NOTEs to exist between users and\n+     setters of the condition codes, so we must skip past notes here.\n+     Otherwise, NOTEs are impossible here.  */\n+\n+  next = NEXT_INSN (elem);\n+\n+#ifdef HAVE_cc0\n+  while (next && GET_CODE (next) == NOTE)\n+    next = NEXT_INSN (next);\n+#endif\n+\n+  if (next && SCHED_GROUP_P (next))\n+    {\n+      /* Notes will never intervene here though, so don't bother checking\n+\t for them.  */\n+      while (NEXT_INSN (next) && SCHED_GROUP_P (NEXT_INSN (next)))\n+\tnext = NEXT_INSN (next);\n+\n+      /* Again, don't depend an insn on itself.  */\n+      if (insn == next)\n+\treturn;\n+\n+      /* Make the dependence to NEXT, the last insn of the group, instead\n+\t of the original ELEM.  */\n+      elem = next;\n+    }\n+\n+  /* Check that we don't already have this dependence.  */\n+  for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+    if (XEXP (link, 0) == elem)\n+      {\n+\t/* If this is a more restrictive type of dependence than the existing\n+\t   one, then change the existing dependence to this type.  */\n+\tif ((int) dep_type < (int) REG_NOTE_KIND (link))\n+\t  PUT_REG_NOTE_KIND (link, dep_type);\n+\treturn;\n+      }\n+  /* Might want to check one level of transitivity to save conses.  */\n+\n+  link = rtx_alloc (INSN_LIST);\n+  /* Insn dependency, not data dependency.  */\n+  PUT_REG_NOTE_KIND (link, dep_type);\n+  XEXP (link, 0) = elem;\n+  XEXP (link, 1) = LOG_LINKS (insn);\n+  LOG_LINKS (insn) = link;\n+}\n+\n+/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n+   of INSN.  Abort if not found.  */\n+void\n+remove_dependence (insn, elem)\n+     rtx insn;\n+     rtx elem;\n+{\n+  rtx prev, link;\n+  int found = 0;\n+\n+  for (prev = 0, link = LOG_LINKS (insn); link;\n+       prev = link, link = XEXP (link, 1))\n+    {\n+      if (XEXP (link, 0) == elem)\n+\t{\n+\t  if (prev)\n+\t    XEXP (prev, 1) = XEXP (link, 1);\n+\t  else\n+\t    LOG_LINKS (insn) = XEXP (link, 1);\n+\t  found = 1;\n+\t}\n+    }\n+\n+  if (! found)\n+    abort ();\n+  return;\n+}\n+\f\n #ifndef INSN_SCHEDULING\n void schedule_insns () {}\n #else"}]}