{"sha": "b111229af91d7ab08f334dfb16c55b4266e14a28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExMTIyOWFmOTFkN2FiMDhmMzM0ZGZiMTZjNTViNDI2NmUxNGEyOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-07-16T14:54:40Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-07-16T14:54:40Z"}, "message": "(tune_flags): New variable.\n\n(target_{cpu,fpe}_name): Delete.\n(arm_fpu_arch): New variable.\n(arm_select): Also allow -march=... to configure just the\narchitecture.\n(all_procs): Allow armv{2,2a,3,3m,4,4t} for use with -march=.\n(arm_override_options): Handle -march=, but don't let -mcpu=\nand -mtune= match the architecture names, since we can only\ntune for an implementation.  Rework selection of tuning options\nfor floating point.\n(use_return_insn): Support interworking with Thumb code.\n(arm_rtx_costs): Rework multiply costs so that cost is based on\nthe tune, not the architecture.\n(f_register_operand): New function.\n(output_return_instruction): Support interworking with Thumb code.\n(output_func_epilogue): Support interworking with Thumb code.\nRemove redundant calculation of code_size. Use floating-point\nload-multiples if permitted.\n(emit_sfm): New function.\n(arm_expand_prologue): Use floating-point store-multiples if\npermitted.\n\nFrom-SVN: r14457", "tree": {"sha": "7f6d9336ac40efa03f7d2ccada1f3684896e60d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f6d9336ac40efa03f7d2ccada1f3684896e60d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b111229af91d7ab08f334dfb16c55b4266e14a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b111229af91d7ab08f334dfb16c55b4266e14a28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b111229af91d7ab08f334dfb16c55b4266e14a28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b111229af91d7ab08f334dfb16c55b4266e14a28/comments", "author": null, "committer": null, "parents": [{"sha": "d23f41585d5cc3aae5a97ad2f5933d0ef653c312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d23f41585d5cc3aae5a97ad2f5933d0ef653c312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d23f41585d5cc3aae5a97ad2f5933d0ef653c312"}], "stats": {"total": 329, "additions": 268, "deletions": 61}, "files": [{"sha": "fe263ba04d3353ce2f49143b3ab8c6275f37f858", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 268, "deletions": 61, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b111229af91d7ab08f334dfb16c55b4266e14a28/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b111229af91d7ab08f334dfb16c55b4266e14a28/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b111229af91d7ab08f334dfb16c55b4266e14a28", "patch": "@@ -66,6 +66,7 @@ static char *shift_op PROTO ((rtx, HOST_WIDE_INT *));\n static int pattern_really_clobbers_lr PROTO ((rtx));\n static int function_really_clobbers_lr PROTO ((rtx));\n static void emit_multi_reg_push PROTO ((int));\n+static void emit_sfm PROTO ((int, int));\n static enum arm_cond_code get_arm_condition_code PROTO ((rtx));\n \n /*  Define the information needed to generate branch insns.  This is\n@@ -77,21 +78,27 @@ int arm_compare_fp;\n /* What type of cpu are we compiling for? */\n enum processor_type arm_cpu;\n \n-/* What type of floating point are we compiling for? */\n+/* What type of floating point are we tuning for? */\n enum floating_point_type arm_fpu;\n \n+/* What type of floating point instructions are available? */\n+enum floating_point_type arm_fpu_arch;\n+\n /* What program mode is the cpu running in? 26-bit mode or 32-bit mode */\n enum prog_mode_type arm_prgmode;\n \n-char *target_cpu_name = ARM_CPU_NAME;\n-char *target_fpe_name = NULL;\n+/* Set by the -mfp=... option */\n+char *target_fp_name = NULL;\n \n /* Nonzero if this is an \"M\" variant of the processor.  */\n int arm_fast_multiply = 0;\n \n /* Nonzero if this chip supports the ARM Architecture 4 extensions */\n int arm_arch4 = 0;\n \n+/* Set to the features we should tune the code for (multiply speed etc). */\n+int tune_flags = 0;\n+\n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n    must report the mode of the memory reference from PRINT_OPERAND to\n    PRINT_OPERAND_ADDRESS.  */\n@@ -135,11 +142,12 @@ static enum arm_cond_code get_arm_condition_code ();\n \f\n /* Initialization code */\n \n-struct arm_cpu_select arm_select[3] =\n+struct arm_cpu_select arm_select[4] =\n {\n   /* switch\tname,\t\ttune\tarch */\n   { (char *)0,\t\"--with-cpu=\",\t1,\t1 },\n   { (char *)0,\t\"-mcpu=\",\t1,\t1 },\n+  { (char *)0,\t\"-march=\",\t0,\t1 },\n   { (char *)0,\t\"-mtune=\",\t1,\t0 },\n };\n \n@@ -192,6 +200,17 @@ static struct processors all_procs[] =\n \t\t\t\t  | FL_ARCH4)},\n   {\"strongarm110\", PROCESSOR_STARM, (FL_FAST_MULT | FL_MODE32 | FL_MODE26\n \t\t\t\t     | FL_ARCH4)},\n+  {\"armv2\",\tPROCESSOR_NONE, FL_CO_PROC | FL_MODE26},\n+  {\"armv2a\",\tPROCESSOR_NONE, FL_CO_PROC | FL_MODE26},\n+  {\"armv3\",\tPROCESSOR_NONE, FL_CO_PROC | FL_MODE32 | FL_MODE26},\n+  {\"armv3m\",\tPROCESSOR_NONE, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n+\t\t\t\t | FL_MODE26)},\n+  {\"armv4\",\tPROCESSOR_NONE, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n+\t\t\t\t | FL_MODE26 | FL_ARCH4)},\n+  /* Strictly, FL_MODE26 is a permitted option for v4t, but there are no\n+     implementations that support it, so we will leave it out for now.  */\n+  {\"armv4t\",\tPROCESSOR_NONE, (FL_CO_PROC | FL_FAST_MULT | FL_MODE32\n+\t\t\t\t | FL_ARCH4)},\n   {NULL, 0, 0}\n };\n \n@@ -240,11 +259,21 @@ arm_override_options ()\n           for (sel = all_procs; sel->name != NULL; sel++)\n             if (! strcmp (ptr->string, sel->name))\n               {\n+\t\t/* -march= is the only flag that can take an architecture\n+\t\t   type, so if we match when the tune bit is set, the\n+\t\t   option was invalid.  */\n                 if (ptr->set_tune_p)\n-                  arm_cpu = sel->type;\n+\t\t  {\n+\t\t    if (sel->type == PROCESSOR_NONE)\n+\t\t      continue; /* Its an architecture, not a cpu */\n+\n+                    arm_cpu = sel->type;\n+\t\t    tune_flags = sel->flags;\n+\t\t  }\n \n                 if (ptr->set_arch_p)\n \t\t  flags = sel->flags;\n+\n                 break;\n               }\n \n@@ -292,29 +321,33 @@ arm_override_options ()\n       target_flags |= ARM_FLAG_APCS_FRAME;\n     }\n \n+  /* Default is to tune for an FPA */\n   arm_fpu = FP_HARD;\n \n   /* Default value for floating point code... if no co-processor\n      bus, then schedule for emulated floating point.  Otherwise,\n-     assume the user has an FPA, unless overridden with -mfpe-...  */\n-  if (flags & FL_CO_PROC == 0)\n+     assume the user has an FPA.\n+     Note: this does not prevent use of floating point instructions,\n+     -msoft-float does that.  */\n+  if (tune_flags & FL_CO_PROC == 0)\n     arm_fpu = FP_SOFT3;\n-  else\n-    arm_fpu = FP_HARD;\n+\n   arm_fast_multiply = (flags & FL_FAST_MULT) != 0;\n   arm_arch4 = (flags & FL_ARCH4) != 0;\n   arm_thumb_aware = (flags & FL_THUMB) != 0;\n \n-  if (target_fpe_name)\n+  if (target_fp_name)\n     {\n-      if (strcmp (target_fpe_name, \"2\") == 0)\n-\tarm_fpu = FP_SOFT2;\n-      else if (strcmp (target_fpe_name, \"3\") == 0)\n-\tarm_fpu = FP_SOFT3;\n+      if (strcmp (target_fp_name, \"2\") == 0)\n+\tarm_fpu_arch = FP_SOFT2;\n+      else if (strcmp (target_fp_name, \"3\") == 0)\n+\tarm_fpu_arch = FP_HARD;\n       else\n-\tfatal (\"Invalid floating point emulation option: -mfpe-%s\",\n-\t       target_fpe_name);\n+\tfatal (\"Invalid floating point emulation option: -mfpe=%s\",\n+\t       target_fp_name);\n     }\n+  else\n+    arm_fpu_arch = FP_DEFAULT;\n \n   if (TARGET_THUMB_INTERWORK && ! arm_thumb_aware)\n     {\n@@ -346,10 +379,17 @@ use_return_insn ()\n       || (get_frame_size () && !(TARGET_APCS || frame_pointer_needed)))\n     return 0;\n \n+  /* Can't be done if interworking with Thumb, and any registers have been\n+     stacked */\n+  if (TARGET_THUMB_INTERWORK)\n+    for (regno = 0; regno < 16; regno++)\n+      if (regs_ever_live[regno] && ! call_used_regs[regno])\n+\treturn 0;\n+      \n   /* Can't be done if any of the FPU regs are pushed, since this also\n      requires an insn */\n-  for (regno = 20; regno < 24; regno++)\n-    if (regs_ever_live[regno])\n+  for (regno = 16; regno < 24; regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n       return 0;\n \n   /* If a function is naked, don't use the \"return\" insn.  */\n@@ -1427,6 +1467,8 @@ arm_rtx_costs (x, code, outer_code)\n       return 8;\n \n     case MULT:\n+      /* There is no point basing this on the tuning, since it is always the\n+\t fast variant if it exists at all */\n       if (arm_fast_multiply && mode == DImode\n \t  && (GET_CODE (XEXP (x, 0)) == GET_CODE (XEXP (x, 1)))\n \t  && (GET_CODE (XEXP (x, 0)) == ZERO_EXTEND\n@@ -1443,7 +1485,8 @@ arm_rtx_costs (x, code, outer_code)\n \t\t\t\t      & (unsigned HOST_WIDE_INT) 0xffffffff);\n \t  int add_cost = const_ok_for_arm (i) ? 4 : 8;\n \t  int j;\n-\t  int booth_unit_size = (arm_fast_multiply ? 8 : 2);\n+\t  /* Tune as appropriate */ \n+\t  int booth_unit_size = ((tune_flags & FL_FAST_MULT) ? 8 : 2);\n \n \t  for (j = 0; i && j < 32; j += booth_unit_size)\n \t    {\n@@ -1454,7 +1497,7 @@ arm_rtx_costs (x, code, outer_code)\n \t  return add_cost;\n \t}\n \n-      return ((arm_fast_multiply ? 8 : 30)\n+      return (((tune_flags & FL_FAST_MULT) ? 8 : 30)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4));\n \n@@ -1775,6 +1818,26 @@ alignable_memory_operand (op, mode)\n \t  && REGNO_POINTER_ALIGN (REGNO (reg)) >= 4);\n }\n \n+/* Similar to s_register_operand, but does not allow hard integer \n+   registers.  */\n+int\n+f_register_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) == FPU_REGS));\n+}\n+\n /* Return TRUE for valid operands for the rhs of an FPU instruction.  */\n \n int\n@@ -4578,8 +4641,11 @@ output_return_instruction (operand, really_return, reverse)\n     }\n   else if (really_return)\n     {\n-      sprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n-\t       reverse ? \"D\" : \"d\", TARGET_APCS_32 ? \"\" : \"s\");\n+      if (TARGET_THUMB_INTERWORK)\n+\tsprintf (instr, \"bx%%?%%%s\\t%%|lr\", reverse ? \"D\" : \"d\");\n+      else\n+\tsprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n+\t\t reverse ? \"D\" : \"d\", TARGET_APCS_32 ? \"\" : \"s\");\n       output_asm_insn (instr, &operand);\n     }\n \n@@ -4687,9 +4753,9 @@ output_func_epilogue (f, frame_size)\n      FILE *f;\n      int frame_size;\n {\n-  int reg, live_regs_mask = 0, code_size = 0;\n-  /* If we need this then it will always be at lesat this much */\n-  int floats_offset = 24;\n+  int reg, live_regs_mask = 0;\n+  /* If we need this then it will always be at least this much */\n+  int floats_offset = 12;\n   rtx operands[3];\n   int volatile_func = (optimize > 0\n \t\t       && TREE_THIS_VOLATILE (current_function_decl));\n@@ -4713,7 +4779,6 @@ output_func_epilogue (f, frame_size)\n       rtx op = gen_rtx (SYMBOL_REF, Pmode, \"abort\");\n       assemble_external_libcall (op);\n       output_asm_insn (\"bl\\t%a0\", &op);\n-      code_size = 4;\n       goto epilogue_done;\n     }\n \n@@ -4726,19 +4791,64 @@ output_func_epilogue (f, frame_size)\n \n   if (frame_pointer_needed)\n     {\n-      for (reg = 23; reg > 15; reg--)\n-\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t  {\n-\t    fprintf (f, \"\\tldfe\\t%s%s, [%sfp, #-%d]\\n\", REGISTER_PREFIX,\n-\t\t     reg_names[reg], REGISTER_PREFIX, floats_offset);\n-\t    floats_offset += 12;\n-\t    code_size += 4;\n-\t  }\n+      if (arm_fpu_arch == FP_SOFT2)\n+\t{\n+\t  for (reg = 23; reg > 15; reg--)\n+\t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t      {\n+\t\tfloats_offset += 12;\n+\t\tfprintf (f, \"\\tldfe\\t%s%s, [%sfp, #-%d]\\n\", REGISTER_PREFIX,\n+\t\t\t reg_names[reg], REGISTER_PREFIX, floats_offset);\n+\t      }\n+\t}\n+      else\n+\t{\n+\t  int start_reg = 23;\n+\n+\t  for (reg = 23; reg > 15; reg--)\n+\t    {\n+\t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t\t{\n+\t\t  floats_offset += 12;\n+\t\t  /* We can't unstack more than four registers at once */\n+\t\t  if (start_reg - reg == 3)\n+\t\t    {\n+\t\t      fprintf (f, \"\\tlfm\\t%s%s, 4, [%sfp, #-%d]\\n\",\n+\t\t\t       REGISTER_PREFIX, reg_names[reg],\n+\t\t\t       REGISTER_PREFIX, floats_offset);\n+\t\t      start_reg = reg - 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (reg != start_reg)\n+\t\t    fprintf (f, \"\\tlfm\\t%s%s, %d, [%sfp, #-%d]\\n\",\n+\t\t\t     REGISTER_PREFIX, reg_names[reg + 1],\n+\t\t\t     start_reg - reg, REGISTER_PREFIX, floats_offset);\n \n-      live_regs_mask |= 0xA800;\n-      print_multi_reg (f, \"ldmea\\t%sfp\", live_regs_mask,\n-\t\t       TARGET_APCS_32 ? FALSE : TRUE);\n-      code_size += 4;\n+\t\t  start_reg = reg - 1;\n+\t\t}\n+\t    }\n+\n+\t  /* Just in case the last register checked also needs unstacking.  */\n+\t  if (reg != start_reg)\n+\t    fprintf (f, \"\\tlfm\\t%s%s, %d, [%sfp, #-%d]\\n\",\n+\t\t     REGISTER_PREFIX, reg_names[reg + 1],\n+\t\t     start_reg - reg, REGISTER_PREFIX, floats_offset);\n+\t}\n+\n+      if (TARGET_THUMB_INTERWORK)\n+\t{\n+\t  live_regs_mask |= 0x6800;\n+\t  print_multi_reg (f, \"ldmea\\t%sfp\", live_regs_mask, FALSE);\n+\t  fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t}\n+      else\n+\t{\n+\t  live_regs_mask |= 0xA800;\n+\t  print_multi_reg (f, \"ldmea\\t%sfp\", live_regs_mask,\n+\t\t\t   TARGET_APCS_32 ? FALSE : TRUE);\n+\t}\n     }\n   else\n     {\n@@ -4750,23 +4860,64 @@ output_func_epilogue (f, frame_size)\n \t  output_add_immediate (operands);\n \t}\n \n-      for (reg = 16; reg < 24; reg++)\n-\tif (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t  {\n-\t    fprintf (f, \"\\tldfe\\t%s%s, [%ssp], #12\\n\", REGISTER_PREFIX,\n-\t\t     reg_names[reg], REGISTER_PREFIX);\n-\t    code_size += 4;\n-\t  }\n+      if (arm_fpu_arch == FP_SOFT2)\n+\t{\n+\t  for (reg = 16; reg < 24; reg++)\n+\t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t      fprintf (f, \"\\tldfe\\t%s%s, [%ssp], #12\\n\", REGISTER_PREFIX,\n+\t\t       reg_names[reg], REGISTER_PREFIX);\n+\t}\n+      else\n+\t{\n+\t  int start_reg = 16;\n+\n+\t  for (reg = 16; reg < 24; reg++)\n+\t    {\n+\t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t\t{\n+\t\t  if (reg - start_reg == 3)\n+\t\t    {\n+\t\t      fprintf (f, \"\\tlfmfd\\t%s%s, 4, [%ssp]!\\n\",\n+\t\t\t       REGISTER_PREFIX, reg_names[start_reg],\n+\t\t\t       REGISTER_PREFIX);\n+\t\t      start_reg = reg + 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (reg != start_reg)\n+\t\t    fprintf (f, \"\\tlfmfd\\t%s%s, %d, [%ssp]!\\n\",\n+\t\t\t     REGISTER_PREFIX, reg_names[start_reg],\n+\t\t\t     reg - start_reg, REGISTER_PREFIX);\n+\n+\t\t  start_reg = reg + 1;\n+\t\t}\n+\t    }\n+\n+\t  /* Just in case the last register checked also needs unstacking.  */\n+\t  if (reg != start_reg)\n+\t    fprintf (f, \"\\tlfmfd\\t%s%s, %d, [%ssp]!\\n\",\n+\t\t     REGISTER_PREFIX, reg_names[start_reg],\n+\t\t     reg - start_reg, REGISTER_PREFIX);\n+\t}\n+\n       if (current_function_pretend_args_size == 0 && regs_ever_live[14])\n \t{\n-\t  if (lr_save_eliminated)\n+\t  if (TARGET_THUMB_INTERWORK)\n+\t    {\n+\t      if (! lr_save_eliminated)\n+\t\tprint_multi_reg(f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x4000,\n+\t\t\t\tFALSE);\n+\n+\t      fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t    }\n+\t  else if (lr_save_eliminated)\n \t    fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n \t\t\t : \"\\tmovs\\t%spc, %slr\\n\"),\n \t\t     REGISTER_PREFIX, REGISTER_PREFIX, f);\n \t  else\n \t    print_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask | 0x8000,\n \t\t\t     TARGET_APCS_32 ? FALSE : TRUE);\n-\t  code_size += 4;\n \t}\n       else\n \t{\n@@ -4777,11 +4928,9 @@ output_func_epilogue (f, frame_size)\n \t\tlive_regs_mask |= 0x4000;\n \n \t      if (live_regs_mask != 0)\n-\t      {\n \t\tprint_multi_reg (f, \"ldmfd\\t%ssp!\", live_regs_mask, FALSE);\n-\t\tcode_size += 4;\n-\t      }\n \t    }\n+\n \t  if (current_function_pretend_args_size)\n \t    {\n \t      /* Unwind the pre-pushed regs */\n@@ -4791,10 +4940,12 @@ output_func_epilogue (f, frame_size)\n \t      output_add_immediate (operands);\n \t    }\n \t  /* And finally, go home */\n-\t  fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n-\t\t       : \"\\tmovs\\t%spc, %slr\\n\"),\n-\t\t   REGISTER_PREFIX, REGISTER_PREFIX, f);\n-\t  code_size += 4;\n+\t  if (TARGET_THUMB_INTERWORK)\n+\t    fprintf (f, \"\\tbx\\t%slr\\n\", REGISTER_PREFIX);\n+\t  else\n+\t    fprintf (f, (TARGET_APCS_32 ? \"\\tmov\\t%spc, %slr\\n\"\n+\t\t\t : \"\\tmovs\\t%spc, %slr\\n\"),\n+\t\t     REGISTER_PREFIX, REGISTER_PREFIX, f);\n \t}\n     }\n \n@@ -4844,6 +4995,32 @@ emit_multi_reg_push (mask)\n \t  j++;\n \t}\n     }\n+\n+  emit_insn (par);\n+}\n+\n+static void\n+emit_sfm (base_reg, count)\n+     int base_reg;\n+     int count;\n+{\n+  rtx par;\n+  int i;\n+\n+  par = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (count));\n+\n+  XVECEXP (par, 0, 0) = gen_rtx (SET, VOIDmode, \n+\t\t\t\t gen_rtx (MEM, BLKmode,\n+\t\t\t\t\t  gen_rtx (PRE_DEC, BLKmode,\n+\t\t\t\t\t\t   stack_pointer_rtx)),\n+\t\t\t\t gen_rtx (UNSPEC, BLKmode,\n+\t\t\t\t\t  gen_rtvec (1, gen_rtx (REG, XFmode, \n+\t\t\t\t\t\t\t\t base_reg++)),\n+\t\t\t\t\t  2));\n+  for (i = 1; i < count; i++)\n+    XVECEXP (par, 0, i) = gen_rtx (USE, VOIDmode, \n+\t\t\t\t   gen_rtx (REG, XFmode, base_reg++));\n+\n   emit_insn (par);\n }\n \n@@ -4902,13 +5079,43 @@ arm_expand_prologue ()\n   /* For now the integer regs are still pushed in output_func_epilogue ().  */\n \n   if (! volatile_func)\n-    for (reg = 23; reg > 15; reg--)\n-      if (regs_ever_live[reg] && ! call_used_regs[reg])\n-\temit_insn (gen_rtx (SET, VOIDmode, \n-\t\t\t    gen_rtx (MEM, XFmode, \n-\t\t\t\t     gen_rtx (PRE_DEC, XFmode,\n-\t\t\t\t\t      stack_pointer_rtx)),\n-\t\t\t    gen_rtx (REG, XFmode, reg)));\n+    {\n+      if (arm_fpu_arch == FP_SOFT2)\n+\t{\n+\t  for (reg = 23; reg > 15; reg--)\n+\t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t      emit_insn (gen_rtx (SET, VOIDmode, \n+\t\t\t\t  gen_rtx (MEM, XFmode, \n+\t\t\t\t\t   gen_rtx (PRE_DEC, XFmode,\n+\t\t\t\t\t\t    stack_pointer_rtx)),\n+\t\t\t\t  gen_rtx (REG, XFmode, reg)));\n+\t}\n+      else\n+\t{\n+\t  int start_reg = 23;\n+\n+\t  for (reg = 23; reg > 15; reg--)\n+\t    {\n+\t      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\t\t{\n+\t\t  if (start_reg - reg == 3)\n+\t\t    {\n+\t\t      emit_sfm (reg, 4);\n+\t\t      start_reg = reg - 1;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (start_reg != reg)\n+\t\t    emit_sfm (reg + 1, start_reg - reg);\n+\t\t  start_reg = reg - 1;\n+\t\t}\n+\t    }\n+\n+\t  if (start_reg != reg)\n+\t    emit_sfm (reg + 1, start_reg - reg);\n+\t}\n+    }\n \n   if (frame_pointer_needed)\n     emit_insn (gen_addsi3 (hard_frame_pointer_rtx, gen_rtx (REG, SImode, 12),"}]}