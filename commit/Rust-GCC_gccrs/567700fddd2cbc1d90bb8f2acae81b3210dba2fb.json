{"sha": "567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3NzAwZmRkZDJjYmMxZDkwYmI4ZjJhY2FlODFiMzIxMGRiYTJmYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-06T16:04:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-06T16:04:38Z"}, "message": "re PR ipa/68057 (450.soplex in SPEC CPU 2006 failed to build)\n\n\n\tPR ipa/68057\n\tPR ipa/68220\n\t* ipa-polymorphic-call.c\n\t(ipa_polymorphic_call_context::restrict_to_inner_type): Fix ordering\n\tissue when offset is out of range.\n\t(contains_type_p): Fix out of range check, clear dynamic flag.\n\t* g++.dg/lto/pr68057_0.C: New testcase.\n\t* g++.dg/lto/pr68057_1.C: New testcase.\n\t* g++.dg/torture/pr68220.C: New testcase.\n\nFrom-SVN: r229859", "tree": {"sha": "3f1b62e0829f2a22ffd60ffa7837118243d314e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f1b62e0829f2a22ffd60ffa7837118243d314e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/comments", "author": null, "committer": null, "parents": [{"sha": "563407398727d5943aa1b16320483d9e275cc11d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/563407398727d5943aa1b16320483d9e275cc11d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/563407398727d5943aa1b16320483d9e275cc11d"}], "stats": {"total": 316, "additions": 309, "deletions": 7}, "files": [{"sha": "48fbdae4e9d21762dd543589ce4c1a3203bc3639", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "patch": "@@ -1,3 +1,12 @@\n+2015-11-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/68057\n+\tPR ipa/68220\n+\t* ipa-polymorphic-call.c\n+\t(ipa_polymorphic_call_context::restrict_to_inner_type): Fix ordering\n+\tissue when offset is out of range.\n+\t(contains_type_p): Fix out of range check, clear dynamic flag.\n+\n 2015-11-06  Arnout Vandecappelle  <arnout@mind.be>\n \n \t* config.gcc (e6500): Fix cpu_is_64bit typo."}, {"sha": "5730e46069f48de1249ee3c12e91f19b575e1431", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "patch": "@@ -154,6 +154,8 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t   && tree_to_shwi (TYPE_SIZE (outer_type)) >= 0\n \t   && tree_to_shwi (TYPE_SIZE (outer_type)) <= offset)\n    {\n+     bool der = maybe_derived_type; /* clear_outer_type will reset it.  */\n+     bool dyn = dynamic;\n      clear_outer_type (otr_type);\n      type = otr_type;\n      cur_offset = 0;\n@@ -162,7 +164,7 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \tFor dynamic types, we really do not have information about\n \tsize of the memory location.  It is possible that completely\n \tdifferent type is stored after outer_type.  */\n-     if (!maybe_derived_type && !dynamic)\n+     if (!der && !dyn)\n        {\n \t clear_speculation ();\n \t invalid = true;\n@@ -425,8 +427,10 @@ ipa_polymorphic_call_context::restrict_to_inner_class (tree otr_type,\n \t\t    return true;\n \t\t}\n \t      else\n-\t\tclear_speculation ();\n-\t      return true;\n+\t\t{\n+\t\t  clear_speculation ();\n+\t          return true;\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -459,15 +463,18 @@ contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n   if (offset < 0)\n     return false;\n   if (TYPE_SIZE (outer_type) && TYPE_SIZE (otr_type)\n-      && TREE_CODE (outer_type) == INTEGER_CST\n-      && TREE_CODE (otr_type) == INTEGER_CST\n-      && wi::ltu_p (wi::to_offset (outer_type), (wi::to_offset (otr_type) + offset)))\n+      && TREE_CODE (TYPE_SIZE (outer_type)) == INTEGER_CST\n+      && TREE_CODE (TYPE_SIZE (otr_type)) == INTEGER_CST\n+      && wi::ltu_p (wi::to_offset (TYPE_SIZE (outer_type)),\n+\t\t    (wi::to_offset (TYPE_SIZE (otr_type)) + offset)))\n     return false;\n \n   context.offset = offset;\n   context.outer_type = TYPE_MAIN_VARIANT (outer_type);\n   context.maybe_derived_type = false;\n-  return context.restrict_to_inner_class (otr_type, consider_placement_new, consider_bases);\n+  context.dynamic = false;\n+  return context.restrict_to_inner_class (otr_type, consider_placement_new,\n+\t\t\t\t\t  consider_bases);\n }\n \n "}, {"sha": "1fe39a4525a7249aab6c8a6a0ac275e540dacc31", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "patch": "@@ -1,3 +1,11 @@\n+2015-11-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/68057\n+\tPR ipa/68220\n+\t* g++.dg/lto/pr68057_0.C: New testcase.\n+\t* g++.dg/lto/pr68057_1.C: New testcase.\n+\t* g++.dg/torture/pr68220.C: New testcase.\n+\n 2015-11-06  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vtbX.c: Fix typos in"}, {"sha": "9894b9b1ce76f4943c387aca494f82a8ebb32659", "filename": "gcc/testsuite/g++.dg/lto/pr68057_0.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr68057_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr68057_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr68057_0.C?ref=567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "patch": "@@ -0,0 +1,23 @@\n+// { dg-lto-do compile }\n+/* { dg-extra-ld-options { -O2 -Wno-odr -r -nostdlib } } */\n+struct SPxPricer;\n+struct SoPlex {\n+  virtual void setPricer(SPxPricer *);\n+};\n+struct SPxPricer {\n+  virtual void load(SoPlex *);\n+};\n+struct SLUFactor {\n+  SLUFactor();\n+  virtual ~SLUFactor();\n+};\n+struct SPxSolver : SoPlex {\n+  SPxPricer pr;\n+  SLUFactor slu;\n+  SPxSolver();\n+};\n+struct A : SPxSolver {};\n+A a;\n+\n+void SoPlex::setPricer(SPxPricer *p1) { p1->load(this); }\n+"}, {"sha": "f45a81ec88bce22ac3d02f65f712981329e8764d", "filename": "gcc/testsuite/g++.dg/lto/pr68057_1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr68057_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr68057_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr68057_1.C?ref=567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "patch": "@@ -0,0 +1,17 @@\n+struct SPxPricer;\n+struct SoPlex {\n+  virtual void setPricer(SPxPricer *);\n+};\n+struct SPxPricer {\n+  virtual void load(SoPlex *);\n+};\n+struct SLUFactor {\n+  SLUFactor();\n+  virtual ~SLUFactor();\n+};\n+struct SPxSolver : SoPlex {\n+  SPxPricer pr;\n+  SLUFactor slu;\n+  SPxSolver();\n+};\n+SPxSolver::SPxSolver() { setPricer(&pr); }"}, {"sha": "3b27653219cdff7b6e1586f6462de07af45b121f", "filename": "gcc/testsuite/g++.dg/torture/pr68220.C", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr68220.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567700fddd2cbc1d90bb8f2acae81b3210dba2fb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr68220.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr68220.C?ref=567700fddd2cbc1d90bb8f2acae81b3210dba2fb", "patch": "@@ -0,0 +1,238 @@\n+// { dg-do compile }\n+namespace mpl {\n+template <typename, typename = int> struct lambda;\n+template <typename T3> struct if_ { typedef T3 type; };\n+template <int> struct arg {\n+  template <typename U1, typename> struct apply { typedef U1 type; };\n+};\n+template <typename> struct begin_impl;\n+template <typename Sequence> struct begin {\n+  typedef typename Sequence::tag tag_;\n+  typedef typename begin_impl<tag_>::template apply<Sequence>::type type;\n+};\n+template <typename> struct O1_size_impl;\n+}\n+template <long N> struct long_ { static const long value = N; };\n+namespace mpl {\n+template <typename Sequence>\n+struct O1_size\n+    : O1_size_impl<typename Sequence::tag>::template apply<Sequence> {};\n+typedef arg<1> _1;\n+template <typename T> struct protect : T {};\n+template <typename F> struct apply_wrap1 : F::template apply<int> {};\n+template <typename F, typename T1, typename T2>\n+struct apply_wrap2 : F::template apply<T1, T2> {};\n+template <typename F> struct apply_wrap5 : F::template apply<int> {};\n+template <typename, typename, typename, typename, typename, typename>\n+struct resolve_bind_arg;\n+template <typename T, typename> struct replace_unnamed_arg { typedef T type; };\n+template <typename F, typename> struct bind1 {\n+  template <typename> struct apply {\n+    typedef typename apply_wrap1<F>::type type;\n+  };\n+};\n+template <typename F, typename T1, typename U1, typename U2, typename U3,\n+          typename U4, typename U5>\n+struct resolve_bind_arg<bind1<F, T1>, U1, U2, U3, U4, U5> {\n+  typedef typename apply_wrap5<bind1<F, T1>>::type type;\n+};\n+template <typename F, typename, typename T2> struct bind2 {\n+  template <typename U1, typename U2> struct apply {\n+    typedef resolve_bind_arg<typename replace_unnamed_arg<T2, arg<1>>::type, U1,\n+                             U2, int, int, int> t2;\n+    typedef typename apply_wrap2<F, typename U1::type, typename t2::type>::type\n+        type;\n+  };\n+};\n+template <typename T> struct quote_impl { typedef T type; };\n+template <template <typename> class F> struct quote1 {\n+  template <typename> struct apply : quote_impl<F<int>> {};\n+};\n+template <typename T, typename> struct lambda {\n+  typedef T type;\n+  typedef arg<1> result_;\n+};\n+template <typename, template <typename> class, typename> struct le_result1;\n+template <template <typename> class F, typename L1>\n+struct le_result1<int, F, L1> {\n+  typedef protect<bind1<quote1<F>, typename L1::result_>> type;\n+};\n+template <template <typename> class F, typename T1, typename Tag>\n+struct lambda<F<T1>, Tag> {\n+  typedef typename le_result1<int, F, lambda<T1>>::type type;\n+};\n+template <int, typename, typename, typename> struct iter_fold_impl;\n+template <typename First, typename State, typename ForwardOp>\n+struct iter_fold_impl<1, First, State, ForwardOp> {\n+  typedef typename apply_wrap2<ForwardOp, State, First>::type state;\n+};\n+template <typename Sequence, typename State, typename ForwardOp>\n+struct iter_fold {\n+  typedef typename iter_fold_impl<O1_size<Sequence>::value,\n+                                  typename begin<Sequence>::type, State,\n+                                  ForwardOp>::state type;\n+};\n+template <typename> struct deref;\n+template <typename> struct push_front_impl;\n+template <typename T> struct l_item {\n+  typedef int tag;\n+  typedef l_item type;\n+  typedef long_<1> size;\n+  typedef T item;\n+};\n+struct l_end {\n+  typedef int tag;\n+  typedef l_end type;\n+};\n+template <> struct push_front_impl<int> {\n+  template <typename, typename T> struct apply { typedef l_item<T> type; };\n+};\n+template <> struct O1_size_impl<int> {\n+  template <typename> struct apply : l_item<int>::size {};\n+};\n+template <typename> struct l_iter;\n+template <typename Node> struct deref<l_iter<Node>> {\n+  typedef typename Node::item type;\n+};\n+template <> struct begin_impl<int> {\n+  template <typename List> struct apply {\n+    typedef l_iter<typename List::type> type;\n+  };\n+};\n+template <typename> struct list : l_item<int> {};\n+}\n+template <typename T> T &cast_storage(void *storage) {\n+  return *static_cast<T *>(storage);\n+}\n+struct symbol;\n+struct visitation_impl_step {\n+  typedef symbol type;\n+};\n+template <typename Visitor, typename VoidPtrCV, typename T>\n+void visitation_impl_invoke_impl(int, Visitor visitor, VoidPtrCV storage, T *) {\n+  visitor.internal_visit(cast_storage<T>(storage), 1);\n+}\n+int visitation_impl_invoke_internal_which, visitation_impl_logical_which;\n+template <typename Visitor, typename VoidPtrCV, typename T,\n+          typename NoBackupFlag>\n+void visitation_impl_invoke(Visitor visitor, VoidPtrCV storage, T t,\n+                            NoBackupFlag, int) {\n+  visitation_impl_invoke_impl(visitation_impl_invoke_internal_which, visitor,\n+                              storage, t);\n+}\n+template <typename Which, typename step0, typename Visitor, typename VoidPtrCV,\n+          typename NoBackupFlag>\n+void visitation_impl(int, Visitor visitor, VoidPtrCV storage, int,\n+                     NoBackupFlag no_backup_flag, Which, step0 *) {\n+  switch (visitation_impl_logical_which)\n+  case 0:\n+  visitation_impl_invoke(visitor, storage,\n+                         static_cast<typename step0::type *>(0), no_backup_flag,\n+                         1);\n+}\n+template <long N> struct size_t { static const long value = N; };\n+struct aligned_storage_imp {};\n+template <long> class aligned_storage : aligned_storage_imp {\n+public:\n+  void *address() { return static_cast<aligned_storage_imp *>(this); }\n+};\n+namespace mpl {\n+template <typename> struct less;\n+template <typename> struct select_max {\n+  template <typename OldIterator, typename> struct apply {\n+    typedef OldIterator type;\n+  };\n+};\n+template <typename Sequence, typename Predicate = less<arg<11>>>\n+struct max_element : iter_fold<Sequence, typename begin<Sequence>::type,\n+                               protect<select_max<Predicate>>> {};\n+template <typename Sequence = int, typename T = int>\n+struct push_front\n+    : push_front_impl<typename Sequence::tag>::template apply<Sequence, T> {};\n+template <> struct push_front<> {\n+  template <typename T1, typename T2> struct apply : push_front<T1, T2> {};\n+};\n+template <typename> struct sizeof_ : size_t<sizeof(int)> {};\n+template <long, typename, typename, typename, typename>\n+struct reverse_fold_impl;\n+template <typename First, typename State, typename BackwardOp,\n+          typename ForwardOp>\n+struct reverse_fold_impl<1, First, State, BackwardOp, ForwardOp> {\n+  typedef First iter0;\n+  typedef typename apply_wrap2<\n+      BackwardOp,\n+      typename apply_wrap2<ForwardOp, State, typename deref<iter0>::type>::type,\n+      typename deref<iter0>::type>::type state;\n+};\n+template <typename Sequence, typename State, typename BackwardOp,\n+          typename ForwardOp = arg<1>>\n+struct reverse_fold {\n+  typedef typename reverse_fold_impl<O1_size<Sequence>::value,\n+                                     typename begin<Sequence>::type, State,\n+                                     BackwardOp, ForwardOp>::state type;\n+};\n+template <typename> struct inserter {\n+  typedef mpl::l_end state;\n+  typedef mpl::push_front<> operation;\n+};\n+template <typename Seq, typename Op, typename In>\n+struct reverse_transform1_impl\n+    : reverse_fold<Seq, typename In::state,\n+                   bind2<typename lambda<typename In::operation>::type, _1,\n+                         bind1<typename lambda<Op>::type, arg<2>>>> {};\n+template <typename P1, typename P2>\n+struct transform1\n+    : if_<reverse_transform1_impl<P1, P2, inserter<push_front<>>>>::type {};\n+}\n+template <typename, typename> struct max_value {\n+  typedef mpl::transform1<mpl::list<symbol>, mpl::sizeof_<mpl::arg<1>>>::type\n+      transformed_;\n+  typedef mpl::max_element<transformed_>::type max_it;\n+  typedef mpl::deref<max_it>::type type;\n+};\n+template <typename> struct make_storage {\n+  typedef max_value<int, mpl::sizeof_<int>>::type max_size;\n+  typedef aligned_storage<max_size::value> type;\n+};\n+struct destroyer {\n+  template <typename T> void internal_visit(T &operand, int) { operand.~T(); }\n+};\n+template <typename, typename...> class variant {\n+  typedef int internal_types;\n+  int which_;\n+  make_storage<internal_types>::type storage_;\n+public:\n+  ~variant() {\n+    destroyer visitor;\n+    internal_apply_visitor(visitor);\n+  }\n+  template <typename Visitor, typename VoidPtrCV>\n+  void internal_apply_visitor_impl(int internal_which, int, Visitor visitor,\n+                                   VoidPtrCV storage) {\n+    visitation_impl(internal_which, visitor, storage, int(), int(),\n+                    static_cast<int>(0),\n+                    static_cast<visitation_impl_step *>(0));\n+  }\n+  int internal_apply_visitor___trans_tmp_1;\n+  template <typename Visitor> void internal_apply_visitor(Visitor visitor) {\n+    internal_apply_visitor_impl(which_, internal_apply_visitor___trans_tmp_1,\n+                                visitor, storage_.address());\n+  }\n+};\n+struct symbol {\n+  virtual ~symbol();\n+};\n+using Identifier = variant<int>;\n+struct Fragment {\n+  virtual void foo() const = 0;\n+  virtual ~Fragment();\n+};\n+struct ProcFrag : Fragment {\n+  ~ProcFrag() {}\n+  void foo() const;\n+  Identifier id;\n+};\n+struct Fragments {\n+  ~Fragments() { delete x; }\n+  Fragment *x;\n+} fragments;"}]}