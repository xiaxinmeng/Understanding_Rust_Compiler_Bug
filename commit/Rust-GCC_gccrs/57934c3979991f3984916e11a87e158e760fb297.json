{"sha": "57934c3979991f3984916e11a87e158e760fb297", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5MzRjMzk3OTk5MWYzOTg0OTE2ZTExYTg3ZTE1OGU3NjBmYjI5Nw==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-11T20:59:15Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-11T20:59:15Z"}, "message": "arm.c (thumb_force_lr_save): Add prototype.\n\n\t* arm.c (thumb_force_lr_save): Add prototype.\n\t(thumb_compute_save_reg_mask): New function.\n\t(thumb_find_work_register): New function.\n\t(arm_get_frame_offsets): Use thumb_compute_save_reg_mask.\n\t(thumb_unexpanded_epilogue): Ditto.  Remove redundant code.\n\tDon't clobber r3 when removing pretend args.\n\t(thumb_expand_prologue): Use thumb_compute_save_reg_mask.\n\t(thumb_output_function_prologue): Use new functions.\n\t(thumb_set_return_address): Use thumb_compute_save_reg_mask.\n\t* arm.h (THUMB_REG_PUSHED_P): Remove.\n\nFrom-SVN: r85818", "tree": {"sha": "9f9099725e1e7cd3097e1c04521551931d0e2cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9099725e1e7cd3097e1c04521551931d0e2cff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57934c3979991f3984916e11a87e158e760fb297", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57934c3979991f3984916e11a87e158e760fb297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57934c3979991f3984916e11a87e158e760fb297", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57934c3979991f3984916e11a87e158e760fb297/comments", "author": null, "committer": null, "parents": [{"sha": "af874237026fe74596f56717961c674352d8a0f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af874237026fe74596f56717961c674352d8a0f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af874237026fe74596f56717961c674352d8a0f6"}], "stats": {"total": 327, "additions": 166, "deletions": 161}, "files": [{"sha": "55ceca11af7c12cccf5bc4abc108cbba9a27b613", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57934c3979991f3984916e11a87e158e760fb297/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57934c3979991f3984916e11a87e158e760fb297/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57934c3979991f3984916e11a87e158e760fb297", "patch": "@@ -1,3 +1,16 @@\n+2004-08-11  Paul Brook  <paul@codesourcery.com>\n+\n+\t* arm.c (thumb_force_lr_save): Add prototype.\n+\t(thumb_compute_save_reg_mask): New function.\n+\t(thumb_find_work_register): New function.\n+\t(arm_get_frame_offsets): Use thumb_compute_save_reg_mask.\n+\t(thumb_unexpanded_epilogue): Ditto.  Remove redundant code.\n+\tDon't clobber r3 when removing pretend args.\n+\t(thumb_expand_prologue): Use thumb_compute_save_reg_mask.\n+\t(thumb_output_function_prologue): Use new functions.\n+\t(thumb_set_return_address): Use thumb_compute_save_reg_mask.\n+\t* arm.h (THUMB_REG_PUSHED_P): Remove.\n+\n 2004-08-11  James E Wilson  <wilson@specifixinc.com>\n \n \tPR rtl-optimization/16490"}, {"sha": "41c27efa9110921aad09cde4599faf53eaf189f5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 153, "deletions": 155, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57934c3979991f3984916e11a87e158e760fb297/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57934c3979991f3984916e11a87e158e760fb297/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=57934c3979991f3984916e11a87e158e760fb297", "patch": "@@ -70,6 +70,8 @@ static int arm_legitimate_index_p (enum machine_mode, rtx, RTX_CODE, int);\n static int thumb_base_register_rtx_p (rtx, enum machine_mode, int);\n inline static int thumb_index_register_rtx_p (rtx, int);\n static int thumb_far_jump_used_p (void);\n+static bool thumb_force_lr_save (void);\n+static unsigned long thumb_compute_save_reg_mask (void);\n static int const_ok_for_op (HOST_WIDE_INT, enum rtx_code);\n static rtx emit_multi_reg_push (int);\n static rtx emit_sfm (int, int);\n@@ -2989,6 +2991,27 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n   return orig;\n }\n \n+\n+/* Find a spare low register.  */\n+\n+static int\n+thumb_find_work_register (int live_regs_mask)\n+{\n+  int reg;\n+\n+  /* Use a spare arg register.  */\n+  if (!regs_ever_live[LAST_ARG_REGNUM])\n+    return LAST_ARG_REGNUM;\n+\n+  /* Look for a pushed register.  */\n+  for (reg = 0; reg < LAST_LO_REGNUM; reg++)\n+    if (live_regs_mask & (1 << reg))\n+      return reg;\n+\n+  /* Something went wrong.  */\n+  abort ();\n+}\n+\n /* Generate code to load the PIC register.  PROLOGUE is true if\n    called from arm_expand_prologue (in which case we want the \n    generated insns at the start of the function);  false if called\n@@ -9158,6 +9181,39 @@ arm_compute_save_reg_mask (void)\n }\n \n \n+/* Compute a bit mask of which registers need to be\n+   saved on the stack for the current function.  */\n+static unsigned long\n+thumb_compute_save_reg_mask (void)\n+{\n+  unsigned long mask;\n+  int reg;\n+\n+  mask = 0;\n+  for (reg = 0; reg < 12; reg ++)\n+    {\n+      if (regs_ever_live[reg] && !call_used_regs[reg])\n+\tmask |= 1 << reg;\n+    }\n+\n+  if (flag_pic && !TARGET_SINGLE_PIC_BASE)\n+    mask |= PIC_OFFSET_TABLE_REGNUM;\n+  if (TARGET_SINGLE_PIC_BASE)\n+    mask &= ~(1 << arm_pic_register);\n+\n+  /* lr will also be pushed if any lo regs are pushed.  */\n+  if (mask & 0xff || thumb_force_lr_save ())\n+    mask |= (1 << LR_REGNUM);\n+\n+  /* Make sure we have a low work register if we need one.  */\n+  if (((mask & 0xff) == 0 && regs_ever_live[LAST_ARG_REGNUM])\n+      && ((mask & 0x0f00) || TARGET_BACKTRACE))\n+    mask |= 1 << LAST_LO_REGNUM;\n+\n+  return mask;\n+}\n+\n+\n /* Return the number of bytes required to save VFP registers.  */\n static int\n arm_get_vfp_saved_size (void)\n@@ -10216,29 +10272,9 @@ arm_get_frame_offsets (void)\n     }\n   else /* TARGET_THUMB */\n     {\n-      int reg;\n-      int count_regs;\n-\n-      saved = 0;\n-      count_regs = 0;\n-      for (reg = 8; reg < 13; reg ++)\n-\tif (THUMB_REG_PUSHED_P (reg))\n-\t  count_regs ++;\n-      if (count_regs)\n-\tsaved += 4 * count_regs;\n-      count_regs = 0;\n-      for (reg = 0; reg <= LAST_LO_REGNUM; reg ++)\n-\tif (THUMB_REG_PUSHED_P (reg))\n-\t  count_regs ++;\n-      if (count_regs || thumb_force_lr_save ())\n-\tsaved += 4 * (count_regs + 1);\n+      saved = bit_count (thumb_compute_save_reg_mask ()) * 4;\n       if (TARGET_BACKTRACE)\n-\t{\n-\t  if ((count_regs & 0xFF) == 0 && (regs_ever_live[3] != 0))\n-\t    saved += 20;\n-\t  else\n-\t    saved += 16;\n-\t}\n+\tsaved += 16;\n     }\n \n   /* Saved registers include the stack frame.  */\n@@ -13049,20 +13085,29 @@ thumb_unexpanded_epilogue (void)\n   int live_regs_mask = 0;\n   int high_regs_pushed = 0;\n   int had_to_push_lr;\n+  int size;\n+  int mode;\n \n   if (return_used_this_function)\n     return \"\";\n \n   if (IS_NAKED (arm_current_func_type ()))\n     return \"\";\n \n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n-    if (THUMB_REG_PUSHED_P (regno))\n-      live_regs_mask |= 1 << regno;\n+  live_regs_mask = thumb_compute_save_reg_mask ();\n+  high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n+\n+  /* If we can deduce the registers used from the function's return value.\n+     This is more reliable that examining regs_ever_live[] because that\n+     will be set if the register is ever used in the function, not just if\n+     the register is used to hold a return value.  */\n \n-  for (regno = 8; regno < 13; regno++)\n-    if (THUMB_REG_PUSHED_P (regno))\n-      high_regs_pushed++;\n+  if (current_function_return_rtx != 0)\n+    mode = GET_MODE (current_function_return_rtx);\n+  else\n+    mode = DECL_MODE (DECL_RESULT (current_function_decl));\n+\n+  size = GET_MODE_SIZE (mode);\n \n   /* The prolog may have pushed some high registers to use as\n      work registers.  eg the testsuite file:\n@@ -13076,27 +13121,15 @@ thumb_unexpanded_epilogue (void)\n   \n   if (high_regs_pushed)\n     {\n-      int mask = live_regs_mask;\n+      int mask = live_regs_mask & 0xff;\n       int next_hi_reg;\n-      int size;\n-      int mode;\n-       \n-      /* If we can deduce the registers used from the function's return value.\n-\t This is more reliable that examining regs_ever_live[] because that\n-\t will be set if the register is ever used in the function, not just if\n-\t the register is used to hold a return value.  */\n-\n-      if (current_function_return_rtx != 0)\n-\tmode = GET_MODE (current_function_return_rtx);\n-      else\n-\tmode = DECL_MODE (DECL_RESULT (current_function_decl));\n \n-      size = GET_MODE_SIZE (mode);\n-\n-      /* Unless we are returning a type of size > 12 register r3 is\n-         available.  */\n-      if (size < 13)\n+      /* The available low registers depend on the size of the value we are\n+         returning.  */\n+      if (size <= 12)\n \tmask |=  1 << 3;\n+      if (size <= 8)\n+\tmask |= 1 << 2;\n \n       if (mask == 0)\n \t/* Oh dear!  We have no low registers into which we can pop\n@@ -13105,7 +13138,7 @@ thumb_unexpanded_epilogue (void)\n \t  (\"no low registers available for popping high registers\");\n       \n       for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n-\tif (THUMB_REG_PUSHED_P (next_hi_reg))\n+\tif (live_regs_mask & (1 << next_hi_reg))\n \t  break;\n \n       while (high_regs_pushed)\n@@ -13134,29 +13167,21 @@ thumb_unexpanded_epilogue (void)\n \t\t\t       regno);\n \t\t  \n \t\t  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)\n-\t\t    if (THUMB_REG_PUSHED_P (next_hi_reg))\n+\t\t    if (live_regs_mask & (1 << next_hi_reg))\n \t\t      break;\n \t\t}\n \t    }\n \t}\n+      live_regs_mask &= ~0x0f00;\n     }\n \n-  had_to_push_lr = (live_regs_mask || thumb_force_lr_save ());\n-  \n-  if (TARGET_BACKTRACE\n-      && ((live_regs_mask & 0xFF) == 0)\n-      && regs_ever_live [LAST_ARG_REGNUM] != 0)\n-    {\n-      /* The stack backtrace structure creation code had to\n-\t push R7 in order to get a work register, so we pop\n-\t it now.  */\n-      live_regs_mask |= (1 << LAST_LO_REGNUM);\n-    }\n-  \n+  had_to_push_lr = (live_regs_mask & (1 << LR_REGNUM)) != 0;\n+  live_regs_mask &= 0xff;\n+\n   if (current_function_pretend_args_size == 0 || TARGET_BACKTRACE)\n     {\n-      if (had_to_push_lr\n-\t  && !is_called_in_ARM_mode (current_function_decl))\n+      /* Pop the return address into the PC.  */ \n+      if (had_to_push_lr)\n \tlive_regs_mask |= 1 << PC_REGNUM;\n \n       /* Either no argument registers were pushed or a backtrace\n@@ -13165,38 +13190,54 @@ thumb_unexpanded_epilogue (void)\n       if (live_regs_mask)\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE, NULL,\n \t\t       live_regs_mask);\n-      \n+\n       /* We have either just popped the return address into the\n-\t PC or it is was kept in LR for the entire function or\n-\t it is still on the stack because we do not want to\n-\t return by doing a pop {pc}.  */\n-      if ((live_regs_mask & (1 << PC_REGNUM)) == 0)\n-\tthumb_exit (asm_out_file,\n-\t\t    (had_to_push_lr\n-\t\t     && is_called_in_ARM_mode (current_function_decl)) ?\n-\t\t    -1 : LR_REGNUM);\n+\t PC or it is was kept in LR for the entire function.  */\n+      if (!had_to_push_lr)\n+\tthumb_exit (asm_out_file, LR_REGNUM);\n     }\n   else\n     {\n       /* Pop everything but the return address.  */\n-      live_regs_mask &= ~(1 << PC_REGNUM);\n-      \n       if (live_regs_mask)\n \tthumb_pushpop (asm_out_file, live_regs_mask, FALSE, NULL,\n \t\t       live_regs_mask);\n \n       if (had_to_push_lr)\n-\t/* Get the return address into a temporary register.  */\n-\tthumb_pushpop (asm_out_file, 1 << LAST_ARG_REGNUM, 0, NULL,\n-\t\t       1 << LAST_ARG_REGNUM);\n+\t{\n+\t  if (size > 12)\n+\t    {\n+\t      /* We have no free low regs, so save one.  */\n+\t      asm_fprintf (asm_out_file, \"\\tmov\\t%r, %r\\n\", IP_REGNUM,\n+\t\t\t   LAST_ARG_REGNUM);\n+\t    }\n+\n+\t  /* Get the return address into a temporary register.  */\n+\t  thumb_pushpop (asm_out_file, 1 << LAST_ARG_REGNUM, 0, NULL,\n+\t\t\t 1 << LAST_ARG_REGNUM);\n+\n+\t  if (size > 12)\n+\t    {\n+\t      /* Move the return address to lr.  */\n+\t      asm_fprintf (asm_out_file, \"\\tmov\\t%r, %r\\n\", LR_REGNUM,\n+\t\t\t   LAST_ARG_REGNUM);\n+\t      /* Restore the low register.  */\n+\t      asm_fprintf (asm_out_file, \"\\tmov\\t%r, %r\\n\", LAST_ARG_REGNUM,\n+\t\t\t   IP_REGNUM);\n+\t      regno = LR_REGNUM;\n+\t    }\n+\t  else\n+\t    regno = LAST_ARG_REGNUM;\n+\t}\n+      else\n+\tregno = LR_REGNUM;\n       \n       /* Remove the argument registers that were pushed onto the stack.  */\n       asm_fprintf (asm_out_file, \"\\tadd\\t%r, %r, #%d\\n\",\n \t\t   SP_REGNUM, SP_REGNUM,\n \t\t   current_function_pretend_args_size);\n       \n-      thumb_exit (asm_out_file,\n-\t\t  had_to_push_lr ? LAST_ARG_REGNUM : LR_REGNUM);\n+      thumb_exit (asm_out_file, regno);\n     }\n \n   return \"\";\n@@ -13302,6 +13343,7 @@ thumb_expand_prologue (void)\n   arm_stack_offsets *offsets;\n   unsigned long func_type;\n   int regno;\n+  unsigned long live_regs_mask;\n \n   func_type = arm_current_func_type ();\n   \n@@ -13324,6 +13366,7 @@ thumb_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  live_regs_mask = thumb_compute_save_reg_mask ();\n   amount = offsets->outgoing_args - offsets->saved_regs;\n   if (amount)\n     {\n@@ -13352,7 +13395,7 @@ thumb_expand_prologue (void)\n \t     been pushed at the start of the prologue and so we can corrupt\n \t     it now.  */\n \t  for (regno = LAST_ARG_REGNUM + 1; regno <= LAST_LO_REGNUM; regno++)\n-\t    if (THUMB_REG_PUSHED_P (regno)\n+\t    if (live_regs_mask & (1 << regno)\n \t\t&& !(frame_pointer_needed\n \t\t     && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))\n \t      break;\n@@ -13421,21 +13464,16 @@ thumb_expand_prologue (void)\n     emit_insn (gen_blockage ());\n \n   cfun->machine->lr_save_eliminated = !thumb_force_lr_save ();\n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n-    {\n-      if (THUMB_REG_PUSHED_P (regno))\n-        {\n-          cfun->machine->lr_save_eliminated = 0;\n-          break;\n-        }\n-    }\n+  if (live_regs_mask & 0xff)\n+    cfun->machine->lr_save_eliminated = 0;\n \n   /* If the link register is being kept alive, with the return address in it,\n      then make sure that it does not get reused by the ce2 pass.  */\n   if (cfun->machine->lr_save_eliminated)\n     emit_insn (gen_prologue_use (gen_rtx_REG (SImode, LR_REGNUM)));\n }\n \n+\n void\n thumb_expand_epilogue (void)\n {\n@@ -13488,6 +13526,7 @@ static void\n thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   int live_regs_mask = 0;\n+  int l_mask;\n   int high_regs_pushed = 0;\n   int cfa_offset = 0;\n   int regno;\n@@ -13564,26 +13603,22 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t}\n     }\n \n-  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n-    if (THUMB_REG_PUSHED_P (regno))\n-      live_regs_mask |= 1 << regno;\n-\n-  if (live_regs_mask || thumb_force_lr_save ())\n-    live_regs_mask |= 1 << LR_REGNUM;\n+  live_regs_mask = thumb_compute_save_reg_mask ();\n+  /* Just low regs and lr. */\n+  l_mask = live_regs_mask & 0x40ff;\n \n   if (TARGET_BACKTRACE)\n     {\n       int    offset;\n-      int    work_register = 0;\n-      int    wr;\n+      int    work_register;\n       \n       /* We have been asked to create a stack backtrace structure.\n          The code looks like this:\n \t \n \t 0   .align 2\n \t 0   func:\n          0     sub   SP, #16         Reserve space for 4 registers.\n-\t 2     push  {R7}            Get a work register.\n+\t 2     push  {R7}            Push low registers.\n          4     add   R7, SP, #20     Get the stack pointer before the push.\n          6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).\n          8     mov   R7, PC          Get hold of the start of this code plus 12.\n@@ -13595,24 +13630,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n         20     add   R7, SP, #16     Point at the start of the backtrace structure.\n         22     mov   FP, R7          Put this value into the frame pointer.  */\n \n-      if ((live_regs_mask & 0xFF) == 0)\n-\t{\n-\t  /* See if the a4 register is free.  */\n-\n-\t  if (regs_ever_live [LAST_ARG_REGNUM] == 0)\n-\t    work_register = LAST_ARG_REGNUM;\n-\t  else\t  /* We must push a register of our own.  */\n-\t    live_regs_mask |= (1 << LAST_LO_REGNUM);\n-\t}\n-\n-      if (work_register == 0)\n-\t{\n-\t  /* Select a register from the list that will be pushed to\n-             use as our work register.  */\n-\t  for (work_register = (LAST_LO_REGNUM + 1); work_register--;)\n-\t    if ((1 << work_register) & live_regs_mask)\n-\t      break;\n-\t}\n+      work_register = thumb_find_work_register (live_regs_mask);\n       \n       asm_fprintf\n \t(f, \"\\tsub\\t%r, %r, #16\\t%@ Create stack backtrace structure\\n\",\n@@ -13625,12 +13643,13 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t  dwarf2out_def_cfa (l, SP_REGNUM, cfa_offset);\n \t}\n \n-      if (live_regs_mask)\n-\tthumb_pushpop (f, live_regs_mask, 1, &cfa_offset, live_regs_mask);\n-      \n-      for (offset = 0, wr = 1 << 15; wr != 0; wr >>= 1)\n-\tif (wr & live_regs_mask)\n-\t  offset += 4;\n+      if (l_mask)\n+\t{\n+\t  thumb_pushpop (f, l_mask, 1, &cfa_offset, l_mask);\n+\t  offset = bit_count (l_mask);\n+\t}\n+      else\n+\toffset = 0;\n       \n       asm_fprintf (f, \"\\tadd\\t%r, %r, #%d\\n\", work_register, SP_REGNUM,\n \t\t   offset + 16 + current_function_pretend_args_size);\n@@ -13640,7 +13659,7 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       /* Make sure that the instruction fetching the PC is in the right place\n \t to calculate \"start of backtrace creation code + 12\".  */\n-      if (live_regs_mask)\n+      if (l_mask)\n \t{\n \t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", work_register, PC_REGNUM);\n \t  asm_fprintf (f, \"\\tstr\\t%r, [%r, #%d]\\n\", work_register, SP_REGNUM,\n@@ -13669,40 +13688,32 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n       asm_fprintf (f, \"\\tmov\\t%r, %r\\t\\t%@ Backtrace structure created\\n\",\n \t\t   ARM_HARD_FRAME_POINTER_REGNUM, work_register);\n     }\n-  else if (live_regs_mask)\n-    thumb_pushpop (f, live_regs_mask, 1, &cfa_offset, live_regs_mask);\n+  else if (l_mask)\n+    thumb_pushpop (f, l_mask, 1, &cfa_offset, l_mask);\n \n-  for (regno = 8; regno < 13; regno++)\n-    if (THUMB_REG_PUSHED_P (regno))\n-      high_regs_pushed++;\n+  high_regs_pushed = bit_count (live_regs_mask & 0x0f00);\n \n   if (high_regs_pushed)\n     {\n       int pushable_regs = 0;\n-      int mask = live_regs_mask & 0xff;\n       int next_hi_reg;\n \n       for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)\n-\tif (THUMB_REG_PUSHED_P (next_hi_reg))\n+\tif (live_regs_mask & (1 << next_hi_reg))\n \t  break;\n \n-      pushable_regs = mask;\n+      pushable_regs = l_mask & 0xff;\n \n       if (pushable_regs == 0)\n-\t{\n-\t  /* Desperation time -- this probably will never happen.  */\n-\t  if (THUMB_REG_PUSHED_P (LAST_ARG_REGNUM))\n-\t    asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", IP_REGNUM, LAST_ARG_REGNUM);\n-\t  mask = 1 << LAST_ARG_REGNUM;\n-\t}\n+\tpushable_regs = 1 << thumb_find_work_register (live_regs_mask);\n \n       while (high_regs_pushed > 0)\n \t{\n \t  int real_regs_mask = 0;\n \n \t  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)\n \t    {\n-\t      if (mask & (1 << regno))\n+\t      if (pushable_regs & (1 << regno))\n \t\t{\n \t\t  asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", regno, next_hi_reg);\n \t\t  \n@@ -13713,23 +13724,19 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \t\t    {\n \t\t      for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;\n \t\t\t   next_hi_reg--)\n-\t\t\tif (THUMB_REG_PUSHED_P (next_hi_reg))\n+\t\t\tif (live_regs_mask & (1 << next_hi_reg))\n \t\t\t  break;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      mask &= ~((1 << regno) - 1);\n+\t\t      pushable_regs &= ~((1 << regno) - 1);\n \t\t      break;\n \t\t    }\n \t\t}\n \t    }\n \n-\t  thumb_pushpop (f, mask, 1, &cfa_offset, real_regs_mask);\n+\t  thumb_pushpop (f, pushable_regs, 1, &cfa_offset, real_regs_mask);\n \t}\n-\n-      if (pushable_regs == 0\n-\t  && (THUMB_REG_PUSHED_P (LAST_ARG_REGNUM)))\n-\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", LAST_ARG_REGNUM, IP_REGNUM);\n     }\n }\n \n@@ -14741,24 +14748,15 @@ void\n thumb_set_return_address (rtx source, rtx scratch)\n {\n   arm_stack_offsets *offsets;\n-  bool lr_saved;\n   HOST_WIDE_INT delta;\n   int reg;\n   rtx addr;\n+  unsigned long mask;\n \n   emit_insn (gen_rtx_USE (VOIDmode, source));\n-  lr_saved = FALSE;\n-  for (reg = 0; reg <= LAST_LO_REGNUM; reg++)\n-    {\n-      if (THUMB_REG_PUSHED_P (reg))\n-\t{\n-\t  lr_saved = TRUE;\n-\t  break;\n-\t}\n-    }\n-  lr_saved |= thumb_force_lr_save ();\n \n-  if (lr_saved)\n+  mask = thumb_compute_save_reg_mask ();\n+  if (mask & (1 << LR_REGNUM))\n     {\n       offsets = arm_get_frame_offsets ();\n "}, {"sha": "c3ea52a70e8107d0ff26ca3ef7f8b8d53c512f3d", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57934c3979991f3984916e11a87e158e760fb297/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57934c3979991f3984916e11a87e158e760fb297/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=57934c3979991f3984916e11a87e158e760fb297", "patch": "@@ -1857,12 +1857,6 @@ typedef struct\n    ((TO) == THUMB_HARD_FRAME_POINTER_REGNUM && TARGET_ARM) ? 0 :\t\\\n    1)\n \n-#define THUMB_REG_PUSHED_P(reg)\t\t\t\t\t\\\n-  (regs_ever_live [reg]\t\t\t\t\t\t\\\n-   && (! call_used_regs [reg]\t\t\t\t\t\\\n-       || (flag_pic && (reg) == PIC_OFFSET_TABLE_REGNUM))\t\\\n-   && !(TARGET_SINGLE_PIC_BASE && ((reg) == arm_pic_register)))\n-     \n /* Define the offset between two registers, one to be eliminated, and the\n    other its replacement, at the start of a routine.  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\"}]}