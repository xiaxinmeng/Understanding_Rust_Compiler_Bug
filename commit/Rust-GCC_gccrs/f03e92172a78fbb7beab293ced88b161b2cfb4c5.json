{"sha": "f03e92172a78fbb7beab293ced88b161b2cfb4c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAzZTkyMTcyYTc4ZmJiN2JlYWIyOTNjZWQ4OGIxNjFiMmNmYjRjNQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-03-02T12:54:27Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2017-03-02T12:54:27Z"}, "message": "matmul.m4 (matmul_'rtype_code`): Avoid race condition on storing function pointer.\n\n2017-03-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\t    Jakub Jelinek  <jakub@redhat.com>\n\n\t* m4/matmul.m4 (matmul_'rtype_code`):  Avoid\n\trace condition on storing function pointer.\n        * generated/matmul_c10.c: Regenerated.\n        * generated/matmul_c16.c: Regenerated.\n        * generated/matmul_c4.c: Regenerated.\n        * generated/matmul_c8.c: Regenerated.\n        * generated/matmul_i1.c: Regenerated.\n        * generated/matmul_i16.c: Regenerated.\n        * generated/matmul_i2.c: Regenerated.\n        * generated/matmul_i4.c: Regenerated.\n        * generated/matmul_i8.c: Regenerated.\n        * generated/matmul_r10.c: Regenerated.\n        * generated/matmul_r16.c: Regenerated.\n        * generated/matmul_r4.c: Regenerated.\n        * generated/matmul_r8.c: Regenerated.\n\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r245839", "tree": {"sha": "dd78c8e62aef0ed2943837d26ed7b56b1e9e37a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd78c8e62aef0ed2943837d26ed7b56b1e9e37a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f03e92172a78fbb7beab293ced88b161b2cfb4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03e92172a78fbb7beab293ced88b161b2cfb4c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f03e92172a78fbb7beab293ced88b161b2cfb4c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f03e92172a78fbb7beab293ced88b161b2cfb4c5/comments", "author": null, "committer": null, "parents": [{"sha": "eb0e7c34d71173a90a2c48f2acbf4c7995240fa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb0e7c34d71173a90a2c48f2acbf4c7995240fa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb0e7c34d71173a90a2c48f2acbf4c7995240fa0"}], "stats": {"total": 411, "additions": 257, "deletions": 154}, "files": [{"sha": "ec689fd7285f385f8d36565013031050e5a8624a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -1,3 +1,22 @@\n+2017-03-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* m4/matmul.m4 (matmul_'rtype_code`):  Avoid\n+\trace condition on storing function pointer.\n+        * generated/matmul_c10.c: Regenerated.\n+        * generated/matmul_c16.c: Regenerated.\n+        * generated/matmul_c4.c: Regenerated.\n+        * generated/matmul_c8.c: Regenerated.\n+        * generated/matmul_i1.c: Regenerated.\n+        * generated/matmul_i16.c: Regenerated.\n+        * generated/matmul_i2.c: Regenerated.\n+        * generated/matmul_i4.c: Regenerated.\n+        * generated/matmul_i8.c: Regenerated.\n+        * generated/matmul_r10.c: Regenerated.\n+        * generated/matmul_r16.c: Regenerated.\n+        * generated/matmul_r4.c: Regenerated.\n+        * generated/matmul_r8.c: Regenerated.\n+\n 2017-03-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/78379"}, {"sha": "c8e7a6c37fbddd520c8fc635e213984e1bf289dd", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_c10 (gfc_array_c10 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_c10 * const restrict retarray, \n \tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_c10 * const restrict retarray, \n+\tgfc_array_c10 * const restrict a, gfc_array_c10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_c10_vanilla;\n+      matmul_fn = matmul_c10_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_c10_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c10_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_c10 (gfc_array_c10 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_c10_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c10_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_c10_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_c10_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "adbf1c81a7ae4b984efa3ee65b9c2e660acc1395", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_c16 (gfc_array_c16 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_c16 * const restrict retarray, \n \tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_c16 * const restrict retarray, \n+\tgfc_array_c16 * const restrict a, gfc_array_c16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_c16_vanilla;\n+      matmul_fn = matmul_c16_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_c16_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c16_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_c16 (gfc_array_c16 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_c16_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c16_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_c16_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_c16_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "ff0e76a9275ed4f71848a76dcac35aa8a45cd4cd", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_c4 (gfc_array_c4 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_c4 * const restrict retarray, \n \tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_c4 * const restrict retarray, \n+\tgfc_array_c4 * const restrict a, gfc_array_c4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_c4_vanilla;\n+      matmul_fn = matmul_c4_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_c4_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c4_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_c4 (gfc_array_c4 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_c4_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c4_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_c4_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_c4_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "483ebf114d718733534dfd598ee51e2980d96f2e", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_c8 (gfc_array_c8 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_c8 * const restrict retarray, \n \tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_c8 * const restrict retarray, \n+\tgfc_array_c8 * const restrict a, gfc_array_c8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_c8_vanilla;\n+      matmul_fn = matmul_c8_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_c8_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c8_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_c8 (gfc_array_c8 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_c8_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_c8_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_c8_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_c8_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "51cfcc05360728ebf1bfc9f95edfe607158ff223", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_i1 (gfc_array_i1 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_i1 * const restrict retarray, \n \tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_i1 * const restrict retarray, \n+\tgfc_array_i1 * const restrict a, gfc_array_i1 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_i1_vanilla;\n+      matmul_fn = matmul_i1_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_i1_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i1_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_i1 (gfc_array_i1 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_i1_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i1_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_i1_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_i1_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "90a422f42900a914cb52a55c72c1eb010c75abb9", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_i16 (gfc_array_i16 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_i16 * const restrict retarray, \n \tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_i16 * const restrict retarray, \n+\tgfc_array_i16 * const restrict a, gfc_array_i16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_i16_vanilla;\n+      matmul_fn = matmul_i16_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_i16_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i16_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_i16 (gfc_array_i16 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_i16_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i16_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_i16_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_i16_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "58be84fc9c82b43d46d798e7c8b06a18aa193dab", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_i2 (gfc_array_i2 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_i2 * const restrict retarray, \n \tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_i2 * const restrict retarray, \n+\tgfc_array_i2 * const restrict a, gfc_array_i2 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_i2_vanilla;\n+      matmul_fn = matmul_i2_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_i2_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i2_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_i2 (gfc_array_i2 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_i2_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i2_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_i2_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_i2_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "1e724d54ffafa1e8c78cf18502a67bd275668110", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_i4 (gfc_array_i4 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_i4 * const restrict retarray, \n \tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_i4 * const restrict retarray, \n+\tgfc_array_i4 * const restrict a, gfc_array_i4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_i4_vanilla;\n+      matmul_fn = matmul_i4_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_i4_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i4_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_i4 (gfc_array_i4 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_i4_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i4_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_i4_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_i4_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "f5ed84fa2885fa98d90035c4dbe934ba9ed9e346", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_i8 (gfc_array_i8 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_i8 * const restrict retarray, \n \tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_i8 * const restrict retarray, \n+\tgfc_array_i8 * const restrict a, gfc_array_i8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_i8_vanilla;\n+      matmul_fn = matmul_i8_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_i8_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i8_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_i8 (gfc_array_i8 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_i8_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_i8_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_i8_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_i8_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "8f76faceabff6aa988b6f343dc3b7430e015989b", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_r10 (gfc_array_r10 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_r10 * const restrict retarray, \n \tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_r10 * const restrict retarray, \n+\tgfc_array_r10 * const restrict a, gfc_array_r10 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_r10_vanilla;\n+      matmul_fn = matmul_r10_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_r10_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r10_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_r10 (gfc_array_r10 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_r10_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r10_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_r10_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_r10_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "6a7687fdc33731a304dcdd9926c8264783338e3f", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_r16 (gfc_array_r16 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_r16 * const restrict retarray, \n \tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_r16 * const restrict retarray, \n+\tgfc_array_r16 * const restrict a, gfc_array_r16 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_r16_vanilla;\n+      matmul_fn = matmul_r16_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_r16_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r16_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_r16 (gfc_array_r16 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_r16_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r16_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_r16_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_r16_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "dbb31b05c3bc9d1139cbfc6f4e93b641e376878f", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_r4 (gfc_array_r4 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_r4 * const restrict retarray, \n \tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_r4 * const restrict retarray, \n+\tgfc_array_r4 * const restrict a, gfc_array_r4 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_r4_vanilla;\n+      matmul_fn = matmul_r4_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_r4_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r4_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_r4 (gfc_array_r4 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_r4_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r4_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_r4_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_r4_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "23efed22e2ab91d9b164a3d1fba8a8eeb62988ec", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -2256,19 +2256,24 @@ void matmul_r8 (gfc_array_r8 * const restrict retarray,\n {\n   static void (*matmul_p) (gfc_array_r8 * const restrict retarray, \n \tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) (gfc_array_r8 * const restrict retarray, \n+\tgfc_array_r8 * const restrict a, gfc_array_r8 * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_r8_vanilla;\n+      matmul_fn = matmul_r8_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_r8_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r8_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -2277,24 +2282,25 @@ void matmul_r8 (gfc_array_r8 * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_r8_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_r8_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_r8_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_r8_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}, {"sha": "7976fda8bb4610c8169a142fcb5c444a361e7bd5", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f03e92172a78fbb7beab293ced88b161b2cfb4c5/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=f03e92172a78fbb7beab293ced88b161b2cfb4c5", "patch": "@@ -121,19 +121,24 @@ void matmul_'rtype_code` ('rtype` * const restrict retarray,\n {\n   static void (*matmul_p) ('rtype` * const restrict retarray, \n \t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n-\tint blas_limit, blas_call gemm) = NULL;\n+\tint blas_limit, blas_call gemm);\n+\n+  void (*matmul_fn) ('rtype` * const restrict retarray, \n+\t'rtype` * const restrict a, 'rtype` * const restrict b, int try_blas,\n+\tint blas_limit, blas_call gemm);\n \n-  if (matmul_p == NULL)\n+  matmul_fn = __atomic_load_n (&matmul_p, __ATOMIC_RELAXED);\n+  if (matmul_fn == NULL)\n     {\n-      matmul_p = matmul_'rtype_code`_vanilla;\n+      matmul_fn = matmul_'rtype_code`_vanilla;\n       if (__cpu_model.__cpu_vendor == VENDOR_INTEL)\n \t{\n           /* Run down the available processors in order of preference.  */\n #ifdef HAVE_AVX512F\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX512F))\n \t    {\n-\t      matmul_p = matmul_'rtype_code`_avx512f;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_'rtype_code`_avx512f;\n+\t      goto store;\n \t    }\n \n #endif  /* HAVE_AVX512F */\n@@ -142,24 +147,25 @@ void matmul_'rtype_code` ('rtype` * const restrict retarray,\n       \t  if ((__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX2))\n \t     && (__cpu_model.__cpu_features[0] & (1 << FEATURE_FMA)))\n \t    {\n-\t      matmul_p = matmul_'rtype_code`_avx2;\n-\t      goto tailcall;\n+\t      matmul_fn = matmul_'rtype_code`_avx2;\n+\t      goto store;\n \t    }\n \n #endif\n \n #ifdef HAVE_AVX\n       \t  if (__cpu_model.__cpu_features[0] & (1 << FEATURE_AVX))\n  \t    {\n-              matmul_p = matmul_'rtype_code`_avx;\n-\t      goto tailcall;\n+              matmul_fn = matmul_'rtype_code`_avx;\n+\t      goto store;\n \t    }\n #endif  /* HAVE_AVX */\n         }\n+   store:\n+      __atomic_store_n (&matmul_p, matmul_fn, __ATOMIC_RELAXED);\n    }\n \n-tailcall:\n-   (*matmul_p) (retarray, a, b, try_blas, blas_limit, gemm);\n+   (*matmul_fn) (retarray, a, b, try_blas, blas_limit, gemm);\n }\n \n #else  /* Just the vanilla function.  */"}]}