{"sha": "38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiYzc2ZGEzZDBmMTIwNThmMGZiYTJlZTFkM2RmZjE3YWJiMmRjNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-01-29T11:26:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-01-29T11:26:27Z"}, "message": "re PR middle-end/37448 (cannot compile big function)\n\n2010-01-29  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/37448\n\t* ipa-inline.c (cgraph_decide_inlining_incrementally): Avoid\n\tquadratic behavior in most cases.\n\nFrom-SVN: r156343", "tree": {"sha": "61daeccfe3e92ea241e835e5a130482b57c2267a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61daeccfe3e92ea241e835e5a130482b57c2267a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ee5ebeb8d7d072fa161be010d5bd8b3dab06197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ee5ebeb8d7d072fa161be010d5bd8b3dab06197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ee5ebeb8d7d072fa161be010d5bd8b3dab06197"}], "stats": {"total": 191, "additions": 103, "deletions": 88}, "files": [{"sha": "39fd7f82e01ad8251afa0a0e4bb5eb316374e19c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7", "patch": "@@ -1,3 +1,9 @@\n+2010-01-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/37448\n+\t* ipa-inline.c (cgraph_decide_inlining_incrementally): Avoid\n+\tquadratic behavior in most cases.\n+\n 2010-01-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/42891"}, {"sha": "916c2a7afecdbad39b96905f1ff6f3234fbac528", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 97, "deletions": 88, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=38bc76da3d0f12058f0fba2ee1d3dff17abb2dc7", "patch": "@@ -1510,97 +1510,106 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n       /* Never inline regular functions into always-inline functions\n \t during incremental inlining.  */\n       && !node->local.disregard_inline_limits)\n-    for (e = node->callees; e; e = e->next_callee)\n-      {\n-        int allowed_growth = 0;\n-\tif (!e->callee->local.inlinable\n-\t    || !e->inline_failed\n-\t    || e->callee->local.disregard_inline_limits)\n-\t  continue;\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"Considering inline candidate %s.\\n\",\n-\t\t   cgraph_node_name (e->callee));\n-\tif (cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed))\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file, \"Not inlining: recursive call.\\n\");\n-\t      }\n+    {\n+      bitmap visited = BITMAP_ALLOC (NULL);\n+      for (e = node->callees; e; e = e->next_callee)\n+\t{\n+\t  int allowed_growth = 0;\n+\t  if (!e->callee->local.inlinable\n+\t      || !e->inline_failed\n+\t      || e->callee->local.disregard_inline_limits)\n \t    continue;\n-\t  }\n-\tif (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t    != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n-\t      }\n+\t  /* We are inlining a function to all call-sites in node\n+\t     or to none.  So visit each candidate only once.  */\n+\t  if (!bitmap_set_bit (visited, e->callee->uid))\n \t    continue;\n-\t  }\n-\n-\tif (cgraph_maybe_hot_edge_p (e) && leaf_node_p (e->callee)\n-\t    && optimize_function_for_speed_p (cfun))\n-\t  allowed_growth = PARAM_VALUE (PARAM_EARLY_INLINING_INSNS);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Considering inline candidate %s.\\n\",\n+\t\t     cgraph_node_name (e->callee));\n+\t  if (cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  indent_to (dump_file, depth);\n+\t\t  fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n+\t      != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  indent_to (dump_file, depth);\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Not inlining: SSA form does not match.\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n \n-\t/* When the function body would grow and inlining the function won't\n-\t   eliminate the need for offline copy of the function, don't inline.\n-\t */\n-\tif (((mode == INLINE_SIZE || mode == INLINE_SIZE_NORECURSIVE)\n-\t     || (!flag_inline_functions\n-\t\t && !DECL_DECLARED_INLINE_P (e->callee->decl)))\n-\t    && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n-\t\t> e->caller->global.size + allowed_growth)\n-\t    && cgraph_estimate_growth (e->callee) > allowed_growth)\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: code size would grow by %i.\\n\",\n-\t\t\t cgraph_estimate_size_after_inlining (1, e->caller,\n-\t\t\t\t\t\t\t      e->callee)\n-\t\t\t - e->caller->global.size);\n-\t      }\n-\t    continue;\n-\t  }\n-\tif (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n-\t\t\t\t         false)\n-\t    || e->call_stmt_cannot_inline_p)\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file, \"Not inlining: %s.\\n\",\n-\t\t\t cgraph_inline_failed_string (e->inline_failed));\n-\t      }\n-\t    continue;\n-\t  }\n-\tif (!e->callee->analyzed)\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: Function body no longer available.\\n\");\n-\t      }\n-\t    continue;\n-\t  }\n-\tif (!tree_can_inline_p (e))\n-\t  {\n-\t    if (dump_file)\n-\t      {\n-\t\tindent_to (dump_file, depth);\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: %s.\",\n-                         cgraph_inline_failed_string (e->inline_failed));\n-\t      }\n-\t    continue;\n-\t  }\n-\tif (cgraph_default_inline_p (e->callee, &failed_reason))\n-\t  inlined |= try_inline (e, mode, depth);\n-      }\n+\t  if (cgraph_maybe_hot_edge_p (e) && leaf_node_p (e->callee)\n+\t      && optimize_function_for_speed_p (cfun))\n+\t    allowed_growth = PARAM_VALUE (PARAM_EARLY_INLINING_INSNS);\n+\n+\t  /* When the function body would grow and inlining the function\n+\t     won't eliminate the need for offline copy of the function,\n+\t     don't inline.  */\n+\t  if (((mode == INLINE_SIZE || mode == INLINE_SIZE_NORECURSIVE)\n+\t       || (!flag_inline_functions\n+\t\t   && !DECL_DECLARED_INLINE_P (e->callee->decl)))\n+\t      && (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n+\t\t  > e->caller->global.size + allowed_growth)\n+\t      && cgraph_estimate_growth (e->callee) > allowed_growth)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  indent_to (dump_file, depth);\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Not inlining: code size would grow by %i.\\n\",\n+\t\t\t   cgraph_estimate_size_after_inlining (1, e->caller,\n+\t\t\t\t\t\t\t\te->callee)\n+\t\t\t   - e->caller->global.size);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (!cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n+\t\t\t\t\t   false)\n+\t      || e->call_stmt_cannot_inline_p)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  indent_to (dump_file, depth);\n+\t\t  fprintf (dump_file, \"Not inlining: %s.\\n\",\n+\t\t\t   cgraph_inline_failed_string (e->inline_failed));\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (!e->callee->analyzed)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  indent_to (dump_file, depth);\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Not inlining: Function body no longer available.\\n\");\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (!tree_can_inline_p (e))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  indent_to (dump_file, depth);\n+\t\t  fprintf (dump_file,\n+\t\t\t   \"Not inlining: %s.\",\n+\t\t\t   cgraph_inline_failed_string (e->inline_failed));\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n+\t    inlined |= try_inline (e, mode, depth);\n+\t}\n+      BITMAP_FREE (visited);\n+    }\n   node->aux = (void *)(size_t) old_mode;\n   return inlined;\n }"}]}