{"sha": "a7701dd16103048432ec8051e4773760c0e2cf90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc3MDFkZDE2MTAzMDQ4NDMyZWM4MDUxZTQ3NzM3NjBjMGUyY2Y5MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-24T13:43:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-24T13:43:07Z"}, "message": "tree-vectorizer.h (_stmt_vec_info::const_cond_reduc_code): Rename to...\n\n2019-09-24  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info::const_cond_reduc_code):\n\tRename to...\n\t(_stmt_vec_info::cond_reduc_code): ... this.\n\t(_stmt_vec_info::induc_cond_initial_val): Add.\n\t(STMT_VINFO_VEC_CONST_COND_REDUC_CODE): Rename to...\n\t(STMT_VINFO_VEC_COND_REDUC_CODE): ... this.\n\t(STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL): Add.\n\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Adjust.\n\t* tree-vect-loop.c (get_initial_def_for_reduction): Pass in\n\tthe reduction code.\n\t(vect_create_epilog_for_reduction): Drop special\n\tinduction condition reduction params, pass in reduction code\n\tand simplify.\n\t(vectorizable_reduction): Perform condition reduction kind\n\tselection only at analysis time.  Adjust passing on state.\n\nFrom-SVN: r276099", "tree": {"sha": "4a0b480e88c36a52cce24b4cbd4fe9939e5d8aac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a0b480e88c36a52cce24b4cbd4fe9939e5d8aac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7701dd16103048432ec8051e4773760c0e2cf90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7701dd16103048432ec8051e4773760c0e2cf90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7701dd16103048432ec8051e4773760c0e2cf90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7701dd16103048432ec8051e4773760c0e2cf90/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01b9402c483365acb15aec42d1277467711e9e11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b9402c483365acb15aec42d1277467711e9e11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b9402c483365acb15aec42d1277467711e9e11"}], "stats": {"total": 161, "additions": 74, "deletions": 87}, "files": [{"sha": "47f3a006a325e0f6ed306e3ba3d36075385ce5e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7701dd16103048432ec8051e4773760c0e2cf90", "patch": "@@ -1,3 +1,21 @@\n+2019-09-24  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::const_cond_reduc_code):\n+\tRename to...\n+\t(_stmt_vec_info::cond_reduc_code): ... this.\n+\t(_stmt_vec_info::induc_cond_initial_val): Add.\n+\t(STMT_VINFO_VEC_CONST_COND_REDUC_CODE): Rename to...\n+\t(STMT_VINFO_VEC_COND_REDUC_CODE): ... this.\n+\t(STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL): Add.\n+\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Adjust.\n+\t* tree-vect-loop.c (get_initial_def_for_reduction): Pass in\n+\tthe reduction code.\n+\t(vect_create_epilog_for_reduction): Drop special\n+\tinduction condition reduction params, pass in reduction code\n+\tand simplify.\n+\t(vectorizable_reduction): Perform condition reduction kind\n+\tselection only at analysis time.  Adjust passing on state.\n+\n 2019-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64.md (mov<mode>): Don't call"}, {"sha": "bc705d8e9be6da28aa74a71bf5fa3dc84e655a5f", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 47, "deletions": 83, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=a7701dd16103048432ec8051e4773760c0e2cf90", "patch": "@@ -3981,14 +3981,14 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies,\n    A cost model should help decide between these two schemes.  */\n \n static tree\n-get_initial_def_for_reduction (stmt_vec_info stmt_vinfo, tree init_val,\n+get_initial_def_for_reduction (stmt_vec_info stmt_vinfo,\n+\t\t\t       enum tree_code code, tree init_val,\n                                tree *adjustment_def)\n {\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (init_val);\n   tree vectype = get_vectype_for_scalar_type (scalar_type);\n-  enum tree_code code = gimple_assign_rhs_code (stmt_vinfo->stmt);\n   tree def_for_init;\n   tree init_def;\n   REAL_VALUE_TYPE real_init_val = dconst0;\n@@ -4273,14 +4273,15 @@ static void\n vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t\t\t\t  stmt_vec_info stmt_info,\n \t\t\t\t  gimple *reduc_def_stmt,\n+\t\t\t\t  enum tree_code code,\n \t\t\t\t  int ncopies, internal_fn reduc_fn,\n \t\t\t\t  vec<stmt_vec_info> reduction_phis,\n                                   bool double_reduc, \n \t\t\t\t  slp_tree slp_node,\n \t\t\t\t  slp_instance slp_node_instance,\n-\t\t\t\t  tree induc_val, enum tree_code induc_code,\n \t\t\t\t  tree neutral_op)\n {\n+  tree induc_val = NULL_TREE;\n   stmt_vec_info prev_phi_info;\n   tree vectype;\n   machine_mode mode;\n@@ -4370,17 +4371,22 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n       /* Optimize: if initial_def is for REDUC_MAX smaller than the base\n \t and we can't use zero for induc_val, use initial_def.  Similarly\n \t for REDUC_MIN and initial_def larger than the base.  */\n-      if (TREE_CODE (initial_def) == INTEGER_CST\n-\t  && (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t      == INTEGER_INDUC_COND_REDUCTION)\n-\t  && !integer_zerop (induc_val)\n-\t  && ((induc_code == MAX_EXPR\n-\t       && tree_int_cst_lt (initial_def, induc_val))\n-\t      || (induc_code == MIN_EXPR\n-\t\t  && tree_int_cst_lt (induc_val, initial_def))))\n-\tinduc_val = initial_def;\n-\n-      if (double_reduc)\n+      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t  == INTEGER_INDUC_COND_REDUCTION)\n+\t{\n+\t  induc_val = STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info);\n+\t  if (TREE_CODE (initial_def) == INTEGER_CST\n+\t      && (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t  == INTEGER_INDUC_COND_REDUCTION)\n+\t      && !integer_zerop (induc_val)\n+\t      && ((code == MAX_EXPR\n+\t\t   && tree_int_cst_lt (initial_def, induc_val))\n+\t\t  || (code == MIN_EXPR\n+\t\t      && tree_int_cst_lt (induc_val, initial_def))))\n+\t    induc_val = initial_def;\n+\t  vec_initial_def = build_vector_from_val (vectype, induc_val);\n+\t}\n+      else if (double_reduc)\n \t/* In case of double reduction we only create a vector variable\n \t   to be put in the reduction phi node.  The actual statement\n \t   creation is done later in this function.  */\n@@ -4394,7 +4400,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t}\n       else\n \tvec_initial_def\n-\t  = get_initial_def_for_reduction (stmt_info, initial_def,\n+\t  = get_initial_def_for_reduction (stmt_info, code, initial_def,\n \t\t\t\t\t   &adjustment_def);\n       vec_initial_defs.create (1);\n       vec_initial_defs.quick_push (vec_initial_def);\n@@ -4418,24 +4424,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n \t  /* Set the loop-entry arg of the reduction-phi.  */\n \n \t  gphi *phi = as_a <gphi *> (phi_info->stmt);\n-\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t      == INTEGER_INDUC_COND_REDUCTION)\n-\t    {\n-\t      /* Initialise the reduction phi to zero.  This prevents initial\n-\t\t values of non-zero interferring with the reduction op.  */\n-\t      gcc_assert (ncopies == 1);\n-\t      gcc_assert (i == 0);\n-\n-\t      tree vec_init_def_type = TREE_TYPE (vec_init_def);\n-\t      tree induc_val_vec\n-\t\t= build_vector_from_val (vec_init_def_type, induc_val);\n-\n-\t      add_phi_arg (phi, induc_val_vec, loop_preheader_edge (loop),\n-\t\t\t   UNKNOWN_LOCATION);\n-\t    }\n-\t  else\n-\t    add_phi_arg (phi, vec_init_def, loop_preheader_edge (loop),\n-\t\t\t UNKNOWN_LOCATION);\n+\t  add_phi_arg (phi, vec_init_def, loop_preheader_edge (loop),\n+\t\t       UNKNOWN_LOCATION);\n \n           /* Set the loop-latch arg for the reduction-phi.  */\n           if (j > 0)\n@@ -4652,12 +4642,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n     ;\n   else\n     {\n-  enum tree_code code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n-  /* For MINUS_EXPR the initial vector is [init_val,0,...,0], therefore,\n-     partial results are added and not subtracted.  */\n-  if (code == MINUS_EXPR) \n-    code = PLUS_EXPR;\n-\n   /* SLP reduction without reduction chain, e.g.,\n      # a1 = phi <a2, a0>\n      # b1 = phi <b2, b0>\n@@ -5049,20 +5033,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n       bool reduce_with_shift;\n       tree vec_temp;\n \n-      /* COND reductions all do the final reduction with MAX_EXPR\n-\t or MIN_EXPR.  */\n-      if (code == COND_EXPR)\n-\t{\n-\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t      == INTEGER_INDUC_COND_REDUCTION)\n-\t    code = induc_code;\n-\t  else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n-\t\t   == CONST_COND_REDUCTION)\n-\t    code = STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info);\n-\t  else\n-\t    code = MAX_EXPR;\n-\t}\n-\n       /* See if the target wants to do the final (shift) reduction\n \t in a vector mode of smaller size and first reduce upper/lower\n \t halves against each other.  */\n@@ -5543,7 +5513,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs,\n                   preheader_arg = PHI_ARG_DEF_FROM_EDGE (use_stmt,\n                                              loop_preheader_edge (outer_loop));\n                   vect_phi_init = get_initial_def_for_reduction\n-\t\t    (stmt_info, preheader_arg, NULL);\n+\t\t    (stmt_info, code, preheader_arg, NULL);\n \n                   /* Update phi node arguments with vs0 and vs2.  */\n                   add_phi_arg (vect_phi, vect_phi_init,\n@@ -6021,15 +5991,14 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum tree_code code, orig_code;\n+  enum tree_code code;\n   internal_fn reduc_fn;\n   machine_mode vec_mode;\n   int op_type;\n   optab optab;\n   tree new_temp = NULL_TREE;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n   stmt_vec_info cond_stmt_vinfo = NULL;\n-  enum tree_code cond_reduc_op_code = ERROR_MARK;\n   tree scalar_type;\n   bool is_simple_use;\n   int i;\n@@ -6362,9 +6331,11 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     = STMT_VINFO_REDUC_TYPE (reduc_def_info);\n   stmt_vec_info tmp = STMT_VINFO_REDUC_DEF (reduc_def_info);\n \n-  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = v_reduc_type;\n+  if (!vec_stmt)\n+    STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = v_reduc_type;\n   /* If we have a condition reduction, see if we can simplify it further.  */\n-  if (v_reduc_type == COND_REDUCTION)\n+  if (v_reduc_type == COND_REDUCTION\n+      && !vec_stmt)\n     {\n       /* TODO: We can't yet handle reduction chains, since we need to treat\n \t each COND_EXPR in the chain specially, not just the last one.\n@@ -6386,20 +6357,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  return false;\n \t}\n \n-      /* Loop peeling modifies initial value of reduction PHI, which\n-\t makes the reduction stmt to be transformed different to the\n-\t original stmt analyzed.  We need to record reduction code for\n-\t CONST_COND_REDUCTION type reduction at analyzing stage, thus\n-\t it can be used directly at transform stage.  */\n-      if (STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info) == MAX_EXPR\n-\t  || STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info) == MIN_EXPR)\n-\t{\n-\t  /* Also set the reduction type to CONST_COND_REDUCTION.  */\n-\t  gcc_assert (cond_reduc_dt == vect_constant_def);\n-\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = CONST_COND_REDUCTION;\n-\t}\n-      else if (direct_internal_fn_supported_p (IFN_FOLD_EXTRACT_LAST,\n-\t\t\t\t\t       vectype_in, OPTIMIZE_FOR_SPEED))\n+      if (direct_internal_fn_supported_p (IFN_FOLD_EXTRACT_LAST,\n+\t\t\t\t\t  vectype_in, OPTIMIZE_FOR_SPEED))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6416,6 +6375,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  gcc_assert (TREE_CODE (base) == INTEGER_CST\n \t\t      && TREE_CODE (step) == INTEGER_CST);\n \t  cond_reduc_val = NULL_TREE;\n+\t  enum tree_code cond_reduc_op_code = ERROR_MARK;\n \t  tree res = PHI_RESULT (STMT_VINFO_STMT (cond_stmt_vinfo));\n \t  if (!types_compatible_p (TREE_TYPE (res), TREE_TYPE (base)))\n \t    ;\n@@ -6444,10 +6404,10 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t    }\n \t  if (cond_reduc_val)\n \t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"condition expression based on \"\n-\t\t\t\t \"integer induction.\\n\");\n+\t      STMT_VINFO_VEC_COND_REDUC_CODE (stmt_info)\n+\t\t= cond_reduc_op_code;\n+\t      STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL (stmt_info)\n+\t\t= cond_reduc_val;\n \t      STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t\t= INTEGER_INDUC_COND_REDUCTION;\n \t    }\n@@ -6474,14 +6434,19 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t     \"condition expression based on \"\n \t\t\t\t     \"compile time constant.\\n\");\n \t\t  /* Record reduction code at analysis stage.  */\n-\t\t  STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info)\n+\t\t  STMT_VINFO_VEC_COND_REDUC_CODE (stmt_info)\n \t\t    = integer_onep (e) ? MAX_EXPR : MIN_EXPR;\n \t\t  STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t\t    = CONST_COND_REDUCTION;\n \t\t}\n \t    }\n \t}\n     }\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == INTEGER_INDUC_COND_REDUCTION\n+      && dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"condition expression based on \"\n+\t\t     \"integer induction.\\n\");\n \n   if (orig_stmt_info)\n     gcc_assert (tmp == orig_stmt_info\n@@ -6637,6 +6602,7 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n           (and also the same tree-code) when generating the epilog code and\n           when generating the code inside the loop.  */\n \n+  enum tree_code orig_code;\n   if (orig_stmt_info\n       && (reduction_type == TREE_CODE_REDUCTION\n \t  || reduction_type == FOLD_LEFT_REDUCTION))\n@@ -6658,13 +6624,12 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \n       /* For simple condition reductions, replace with the actual expression\n \t we want to base our reduction around.  */\n-      if (reduction_type == CONST_COND_REDUCTION)\n+      if (reduction_type == CONST_COND_REDUCTION\n+\t  || reduction_type == INTEGER_INDUC_COND_REDUCTION)\n \t{\n-\t  orig_code = STMT_VINFO_VEC_CONST_COND_REDUC_CODE (stmt_info);\n+\t  orig_code = STMT_VINFO_VEC_COND_REDUC_CODE (stmt_info);\n \t  gcc_assert (orig_code == MAX_EXPR || orig_code == MIN_EXPR);\n \t}\n-      else if (reduction_type == INTEGER_INDUC_COND_REDUCTION)\n-\torig_code = cond_reduc_op_code;\n     }\n \n   reduc_fn = IFN_LAST;\n@@ -7171,9 +7136,8 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     vect_defs[0] = gimple_get_lhs ((*vec_stmt)->stmt);\n \n   vect_create_epilog_for_reduction (vect_defs, stmt_info, reduc_def_phi,\n-\t\t\t\t    epilog_copies, reduc_fn, phis,\n+\t\t\t\t    orig_code, epilog_copies, reduc_fn, phis,\n \t\t\t\t    double_reduc, slp_node, slp_node_instance,\n-\t\t\t\t    cond_reduc_val, cond_reduc_op_code,\n \t\t\t\t    neutral_op);\n \n   return true;"}, {"sha": "c3004f6f3a2a9dfe4b9291396b08e47af983e5ec", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=a7701dd16103048432ec8051e4773760c0e2cf90", "patch": "@@ -638,7 +638,7 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n-  STMT_VINFO_VEC_CONST_COND_REDUC_CODE (res) = ERROR_MARK;\n+  STMT_VINFO_VEC_COND_REDUC_CODE (res) = ERROR_MARK;\n   STMT_VINFO_REDUC_IDX (res) = -1;\n   STMT_VINFO_SLP_VECT_ONLY (res) = false;\n "}, {"sha": "370ce132f74fb228dcb4a106967f93e4c3b55bea", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7701dd16103048432ec8051e4773760c0e2cf90/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=a7701dd16103048432ec8051e4773760c0e2cf90", "patch": "@@ -934,8 +934,12 @@ class _stmt_vec_info {\n   /* For reduction loops, this is the type of reduction.  */\n   enum vect_reduction_type v_reduc_type;\n \n-  /* For CONST_COND_REDUCTION, record the reduc code.  */\n-  enum tree_code const_cond_reduc_code;\n+  /* For CONST_COND_REDUCTION and INTEGER_INDUC_COND_REDUCTION, the\n+     reduction code.  */\n+  enum tree_code cond_reduc_code;\n+\n+  /* For INTEGER_INDUC_COND_REDUCTION, the initial value to be used.  */\n+  tree induc_cond_initial_val;\n \n   /* On a reduction PHI the reduction type as detected by\n      vect_force_simple_reduction.  */\n@@ -1033,7 +1037,8 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_MEMORY_ACCESS_TYPE(S)   (S)->memory_access_type\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n #define STMT_VINFO_VEC_REDUCTION_TYPE(S)   (S)->v_reduc_type\n-#define STMT_VINFO_VEC_CONST_COND_REDUC_CODE(S) (S)->const_cond_reduc_code\n+#define STMT_VINFO_VEC_COND_REDUC_CODE(S)  (S)->cond_reduc_code\n+#define STMT_VINFO_VEC_INDUC_COND_INITIAL_VAL(S) (S)->induc_cond_initial_val\n #define STMT_VINFO_REDUC_IDX(S)\t\t   (S)->reduc_idx\n \n #define STMT_VINFO_DR_WRT_VEC_LOOP(S)      (S)->dr_wrt_vec_loop"}]}