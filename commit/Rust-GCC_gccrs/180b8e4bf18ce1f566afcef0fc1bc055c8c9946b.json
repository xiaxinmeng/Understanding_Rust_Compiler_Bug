{"sha": "180b8e4bf18ce1f566afcef0fc1bc055c8c9946b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgwYjhlNGJmMThjZTFmNTY2YWZjZWYwZmMxYmMwNTVjOGM5OTQ2Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-29T20:03:08Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-29T20:03:08Z"}, "message": "(force_to_mode): NEXT_SELECT is true for NEG.\n\nOnly exit quickly if X is narrower than MODE and MASK has all bits in X's\nmode set.\n(force_to_mode, case SUBREG): Don't check for WORD_REGISTER_OPERATIONS.\n(force_to_mode, case NEG): Special-case test for low-order bit.\n\nFrom-SVN: r7384", "tree": {"sha": "b7b0099152d30534c6245d5ac0df294ac39780ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7b0099152d30534c6245d5ac0df294ac39780ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/180b8e4bf18ce1f566afcef0fc1bc055c8c9946b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180b8e4bf18ce1f566afcef0fc1bc055c8c9946b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/180b8e4bf18ce1f566afcef0fc1bc055c8c9946b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180b8e4bf18ce1f566afcef0fc1bc055c8c9946b/comments", "author": null, "committer": null, "parents": [{"sha": "31001f722819375a994b3e69fc7f4e1b624179c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31001f722819375a994b3e69fc7f4e1b624179c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31001f722819375a994b3e69fc7f4e1b624179c2"}], "stats": {"total": 27, "additions": 15, "deletions": 12}, "files": [{"sha": "b70195aa575359f1a91ce4bfa5ee46fd1e89a1b3", "filename": "gcc/combine.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/180b8e4bf18ce1f566afcef0fc1bc055c8c9946b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/180b8e4bf18ce1f566afcef0fc1bc055c8c9946b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=180b8e4bf18ce1f566afcef0fc1bc055c8c9946b", "patch": "@@ -5587,7 +5587,7 @@ get_pos_from_mask (m, plen)\n \n    If JUST_SELECT is nonzero, don't optimize by noticing that bits in MASK\n    are all off in X.  This is used when X will be complemented, by either\n-   NOT or XOR.  */\n+   NOT, NEG, or XOR.  */\n \n static rtx\n force_to_mode (x, mode, mask, reg, just_select)\n@@ -5598,7 +5598,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n      int just_select;\n {\n   enum rtx_code code = GET_CODE (x);\n-  int next_select = just_select || code == XOR || code == NOT;\n+  int next_select = just_select || code == XOR || code == NOT || code == NEG;\n   enum machine_mode op_mode;\n   unsigned HOST_WIDE_INT fuller_mask, nonzero;\n   rtx op0, op1, temp;\n@@ -5659,8 +5659,10 @@ force_to_mode (x, mode, mask, reg, just_select)\n       return GEN_INT (cval);\n     }\n \n-  /* If X is narrower than MODE, just get X in the proper mode.  */\n-  if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode))\n+  /* If X is narrower than MODE and we want all the bits in X's mode, just\n+     get X in the proper mode.  */\n+  if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode)\n+      && (GET_MODE_MASK (GET_MODE (x)) & ~ mask) == 0)\n     return gen_lowpart_for_combine (mode, x);\n \n   /* If we aren't changing the mode, X is not a SUBREG, and all zero bits in\n@@ -5701,18 +5703,14 @@ force_to_mode (x, mode, mask, reg, just_select)\n \n     case SUBREG:\n       if (subreg_lowpart_p (x)\n-\t  /* We can ignore the effect this SUBREG if it narrows the mode or,\n-\t     on machines where register operations are performed on the full\n-\t     word, if the constant masks to zero all the bits the mode\n-\t     doesn't have.  */\n+\t  /* We can ignore the effect of this SUBREG if it narrows the mode or\n+\t     if the constant masks to zero all the bits the mode doesn't\n+\t     have.  */\n \t  && ((GET_MODE_SIZE (GET_MODE (x))\n \t       < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n-#ifdef WORD_REGISTER_OPERATIONS\n \t      || (0 == (mask\n \t\t\t& GET_MODE_MASK (GET_MODE (x))\n-\t\t\t& ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))\n-#endif\n-\t      ))\n+\t\t\t& ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (x)))))))\n \treturn force_to_mode (SUBREG_REG (x), mode, mask, reg, next_select);\n       break;\n \n@@ -5991,6 +5989,11 @@ force_to_mode (x, mode, mask, reg, just_select)\n       break;\n \t\n     case NEG:\n+      /* If we just want the low-order bit, the NEG isn't needed since it\n+\t won't change the low-order bit.    */\n+      if (mask == 1)\n+\treturn force_to_mode (XEXP (x, 0), mode, mask, reg, just_select);\n+\n       /* We need any bits less significant than the most significant bit in\n \t MASK since carries from those bits will affect the bits we are\n \t interested in.  */"}]}