{"sha": "daf5c7705fe749beef4971a4cbaff770f784d4d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFmNWM3NzA1ZmU3NDliZWVmNDk3MWE0Y2JhZmY3NzBmNzg0ZDRkNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-09T07:37:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-09T07:37:53Z"}, "message": "ipa-profile.c: Add toplevel comment.\n\n\n\t* ipa-profile.c: Add toplevel comment.\n\t(ipa_propagate_frequency_1): Be more conservative when profile is read.\n\t(contains_hot_call_p): New function.\n\t(ipa_propagate_frequency): Set frequencies based on counts when\n\tprofile is read.\n\t* predict.c (compute_function_frequency): Use PROFILE_READ gueard for\n\tprofile; do not tamper with profile after inlining if it is read.\n\nFrom-SVN: r202382", "tree": {"sha": "bf09a0700a2bcf2fd44b45cba67aa2fbf69d9130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf09a0700a2bcf2fd44b45cba67aa2fbf69d9130"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daf5c7705fe749beef4971a4cbaff770f784d4d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf5c7705fe749beef4971a4cbaff770f784d4d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf5c7705fe749beef4971a4cbaff770f784d4d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf5c7705fe749beef4971a4cbaff770f784d4d6/comments", "author": null, "committer": null, "parents": [{"sha": "a12cd2db29add721d2124b5cafa1dd44128dd554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a12cd2db29add721d2124b5cafa1dd44128dd554", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a12cd2db29add721d2124b5cafa1dd44128dd554"}], "stats": {"total": 109, "additions": 107, "deletions": 2}, "files": [{"sha": "9c0e334f689fa884bed93432d5b4b1601e84960a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf5c7705fe749beef4971a4cbaff770f784d4d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf5c7705fe749beef4971a4cbaff770f784d4d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=daf5c7705fe749beef4971a4cbaff770f784d4d6", "patch": "@@ -1,3 +1,13 @@\n+2013-09-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-profile.c: Add toplevel comment.\n+\t(ipa_propagate_frequency_1): Be more conservative when profile is read.\n+\t(contains_hot_call_p): New function.\n+\t(ipa_propagate_frequency): Set frequencies based on counts when\n+\tprofile is read.\n+\t* predict.c (compute_function_frequency): Use PROFILE_READ gueard for\n+\tprofile; do not tamper with profile after inlining if it is read.\n+\n 2013-09-08  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-prop.c (try_make_edge_direct_simple_call): Do not special case"}, {"sha": "2b22333d1b910a8dcd85d7c1030a04bc0d8e141a", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf5c7705fe749beef4971a4cbaff770f784d4d6/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf5c7705fe749beef4971a4cbaff770f784d4d6/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=daf5c7705fe749beef4971a4cbaff770f784d4d6", "patch": "@@ -17,6 +17,33 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* ipa-profile pass implements the following analysis propagating profille\n+   inter-procedurally.\n+\n+   - Count histogram construction.  This is a histogram analyzing how much\n+     time is spent executing statements with a given execution count read\n+     from profile feedback. This histogram is complette only with LTO,\n+     otherwise it contains information only about the current unit.\n+\n+     Similar histogram is also estimated by coverage runtime.  This histogram\n+     is not dependent on LTO, but it suffers from various defects; first\n+     gcov runtime is not weighting individual basic block by estimated execution\n+     time and second the merging of multiple runs makes assumption that the\n+     histogram distribution did not change.  Consequentely histogram constructed\n+     here may be more precise.\n+\n+     The information is used to set hot/cold thresholds.\n+   - Next speculative indirect call resolution is performed:  the local\n+     profile pass assigns profile-id to each function and provide us with a\n+     histogram specifying the most common target.  We look up the callgraph\n+     node corresponding to the target and produce a speculative call.\n+\n+     This call may or may not survive through IPA optimization based on decision\n+     of inliner. \n+   - Finally we propagate the following flags: unlikely executed, executed\n+     once, executed at startup and executed at exit.  These flags are used to\n+     control code size/performance threshold and and code placement (by producing\n+     .text.unlikely/.text.hot/.text.startup/.text.exit subsections).  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -301,6 +328,18 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \t    d->only_called_at_startup = 0;\n           d->only_called_at_exit &= edge->caller->only_called_at_exit;\n \t}\n+\n+      /* When profile feedback is available, do not try to propagate too hard;\n+\t counts are already good guide on function frequencies and roundoff\n+\t errors can make us to push function into unlikely section even when\n+\t it is executed by the train run.  Transfer the function only if all\n+\t callers are unlikely executed.  */\n+      if (profile_info && flag_branch_probabilities\n+\t  && (edge->caller->frequency != NODE_FREQUENCY_UNLIKELY_EXECUTED\n+\t      || (edge->caller->global.inlined_to\n+\t\t  && edge->caller->global.inlined_to->frequency\n+\t\t     != NODE_FREQUENCY_UNLIKELY_EXECUTED)))\n+\t  d->maybe_unlikely_executed = false;\n       if (!edge->frequency)\n \tcontinue;\n       switch (edge->caller->frequency)\n@@ -332,6 +371,24 @@ ipa_propagate_frequency_1 (struct cgraph_node *node, void *data)\n   return edge != NULL;\n }\n \n+/* Return ture if NODE contains hot calls.  */\n+\n+bool\n+contains_hot_call_p (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  for (e = node->callees; e; e = e->next_callee)\n+    if (cgraph_maybe_hot_edge_p (e))\n+      return true;\n+    else if (!e->inline_failed\n+\t     && contains_hot_call_p (e->callee))\n+      return true;\n+  for (e = node->indirect_calls; e; e = e->next_callee)\n+    if (cgraph_maybe_hot_edge_p (e))\n+      return true;\n+  return false;\n+}\n+\n /* See if the frequency of NODE can be updated based on frequencies of its\n    callers.  */\n bool\n@@ -343,6 +400,7 @@ ipa_propagate_frequency (struct cgraph_node *node)\n   /* We can not propagate anything useful about externally visible functions\n      nor about virtuals.  */\n   if (!node->local.local\n+      || node->symbol.alias\n       || (flag_devirtualize && DECL_VIRTUAL_P (node->symbol.decl)))\n     return false;\n   gcc_assert (node->symbol.analyzed);\n@@ -369,6 +427,36 @@ ipa_propagate_frequency (struct cgraph_node *node)\n \t\t  cgraph_node_name (node));\n        changed = true;\n     }\n+\n+  /* With profile we can decide on hot/normal based on count.  */\n+  if (node->count)\n+    {\n+      bool hot = false;\n+      if (node->count >= get_hot_bb_threshold ())\n+\thot = true;\n+      if (!hot)\n+\thot |= contains_hot_call_p (node);\n+      if (hot)\n+\t{\n+\t  if (node->frequency != NODE_FREQUENCY_HOT)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Node %s promoted to hot.\\n\",\n+\t\t\t cgraph_node_name (node));\n+\t      node->frequency = NODE_FREQUENCY_HOT;\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n+      else if (node->frequency == NODE_FREQUENCY_HOT)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Node %s reduced to normal.\\n\",\n+\t\t     cgraph_node_name (node));\n+\t  node->frequency = NODE_FREQUENCY_NORMAL;\n+\t  changed = true;\n+\t}\n+    }\n   /* These come either from profile or user hints; never update them.  */\n   if (node->frequency == NODE_FREQUENCY_HOT\n       || node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)"}, {"sha": "affed79ae9d8f5da52ac83b339fdc482b15d101d", "filename": "gcc/predict.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf5c7705fe749beef4971a4cbaff770f784d4d6/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf5c7705fe749beef4971a4cbaff770f784d4d6/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=daf5c7705fe749beef4971a4cbaff770f784d4d6", "patch": "@@ -2871,13 +2871,14 @@ compute_function_frequency (void)\n {\n   basic_block bb;\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n+\n   if (DECL_STATIC_CONSTRUCTOR (current_function_decl)\n       || MAIN_NAME_P (DECL_NAME (current_function_decl)))\n     node->only_called_at_startup = true;\n   if (DECL_STATIC_DESTRUCTOR (current_function_decl))\n     node->only_called_at_exit = true;\n \n-  if (!profile_info || !flag_branch_probabilities)\n+  if (profile_status != PROFILE_READ)\n     {\n       int flags = flags_from_decl_or_type (current_function_decl);\n       if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (current_function_decl))\n@@ -2895,7 +2896,13 @@ compute_function_frequency (void)\n         node->frequency = NODE_FREQUENCY_EXECUTED_ONCE;\n       return;\n     }\n-  node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n+\n+  /* Only first time try to drop function into unlikely executed.\n+     After inlining the roundoff errors may confuse us.\n+     Ipa-profile pass will drop functions only called from unlikely\n+     functions to unlikely and that is most of what we care about.  */\n+  if (!cfun->after_inlining)\n+    node->frequency = NODE_FREQUENCY_UNLIKELY_EXECUTED;\n   FOR_EACH_BB (bb)\n     {\n       if (maybe_hot_bb_p (cfun, bb))"}]}