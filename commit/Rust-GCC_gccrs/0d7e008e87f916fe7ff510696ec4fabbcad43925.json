{"sha": "0d7e008e87f916fe7ff510696ec4fabbcad43925", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ3ZTAwOGU4N2Y5MTZmZTdmZjUxMDY5NmVjNGZhYmJjYWQ0MzkyNQ==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-02-05T21:03:19Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1994-02-05T21:03:19Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r6486", "tree": {"sha": "8f2f22c60ed2077b0d103bbb3ee10a5de7ef8ee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f2f22c60ed2077b0d103bbb3ee10a5de7ef8ee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d7e008e87f916fe7ff510696ec4fabbcad43925", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7e008e87f916fe7ff510696ec4fabbcad43925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d7e008e87f916fe7ff510696ec4fabbcad43925", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7e008e87f916fe7ff510696ec4fabbcad43925/comments", "author": null, "committer": null, "parents": [{"sha": "2c65021a94a2a2020bd2c76d147a747c6f4e5928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c65021a94a2a2020bd2c76d147a747c6f4e5928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c65021a94a2a2020bd2c76d147a747c6f4e5928"}], "stats": {"total": 4287, "additions": 2821, "deletions": 1466}, "files": [{"sha": "d8d73ba610e0b3bb443e2f90b070510aebfe10cb", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1436, "deletions": 822, "changes": 2258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7e008e87f916fe7ff510696ec4fabbcad43925/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7e008e87f916fe7ff510696ec4fabbcad43925/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=0d7e008e87f916fe7ff510696ec4fabbcad43925", "patch": "@@ -1,21 +1,21 @@\n /* Output routines for GCC for Hitachi Super-H\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n \n-This file is part of GNU CC.\n+   This file is part of GNU CC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n /* Contributed by Steve Chamberlain (sac@cygnus.com) */\n@@ -32,27 +32,30 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-flags.h\"\n #include \"tree.h\"\n #include \"output.h\"\n+\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"obstack.h\"\n #include \"expr.h\"\n \n+static rtx add_constant ();\n \n-static int add_constant ();\n-int dump_constants ();\n+int pragma_interrupt;\n+int pragma_trapa;\n \n int current_function_anonymous_args;\n extern int current_function_pretend_args_size;\n extern char *version_string;\n extern int flag_traditional;\n \n-\n+static rtx shiftsyms[32];\n+struct rtx_def *table_lab;\n enum attr_cpu sh_cpu;\t\t/* target cpu */\n \n /* Global variables for machine-dependent things. */\n \n /* Saved operands from the last compare to use when we generate an scc\n-  or bcc insn. */\n+   or bcc insn. */\n \n rtx sh_compare_op0;\n rtx sh_compare_op1;\n@@ -62,12 +65,12 @@ rtx sh_compare_op1;\n \n int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n {\n-  R0_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n+  R0_REGS,      GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n   GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,\n-  GENERAL_REGS, PR_REGS, T_REGS, NO_REGS, MAC_REGS,\n-  MAC_REGS,\n+  GENERAL_REGS, PR_REGS,      T_REGS,       NO_REGS, \n+  MAC_REGS,     MAC_REGS,\n };\n \n /* Provide reg_class from a letter such as appears in the machine\n@@ -84,24 +87,45 @@ enum reg_class reg_class_from_letter[] =\n   /* y */ NO_REGS, /* z */ R0_REGS\n };\n \n+/* Value is 1 if register/mode pair is acceptable on SH.  Even\n+   registers can hold DIs and DF values. The rest can only hold\n+   SI's efficiently  */\n+\n+\n+#define REG_ODD \\\n+ (  (1 << (int) QImode)  | (1 << (int) HImode) | (1 << (int) SImode)\t\\\n+  | (1 << (int) QFmode)  | (1 << (int) HFmode) | (1 << (int) SFmode)\t\\\n+  | (1 << (int) CQImode) | (1 << (int) CHImode))\n \n+#define REG_EVEN \\\n+  (REG_ODD | (1 << (int) DImode) | (1 << (int) DFmode)\t\\\n+           | (1 << (int) CSImode) | (1 << (int) SCmode))\n \n+#define SI_ONLY (1<<(int)SImode)\n+int hard_regno_mode_ok[] =\n+{\n+  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n+  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n+  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n+  REG_EVEN,   REG_ODD,   REG_EVEN,   REG_ODD,\n+  REG,         0,        SI_ONLY,    SI_ONLY,\n+  SI_ONLY,    SI_ONLY\n+};\n \n /* Local label counter, used for constants in the pool and inside\n    pattern branches.  */\n-\n static int lf = 100;\n \n-/* Used to work out sizes of instructions */\n-static int first_pc;\n-static int pc;\n-#define MAYBE_DUMP_LEVEL 900\n-#define MUST_DUMP_LEVEL 1000\n-static int dumpnext;\n+\n+/* Number of bytes pushed for anonymous args, used to pass information\n+   between expand_prologue and expand_epilogue. */\n+static int extra_push;\n+\n \f\n \n void\n push (rn)\n+     int rn;\n {\n   emit_insn (gen_push (gen_rtx (REG, SImode, rn)));\n }\n@@ -116,33 +140,26 @@ pop (rn)\n /* Adjust the stack and return the number of bytes taken to do it */\n \n static void\n-output_stack_adjust (direction, size)\n-     int direction;\n+output_stack_adjust (size)\n      int size;\n {\n   if (size)\n     {\n       rtx val = GEN_INT (size);\n       rtx insn;\n \n-      if (size > 120)\n+      if (!CONST_OK_FOR_I (size))\n \t{\n-\t  rtx nval = gen_rtx (REG, SImode, 13);\n+\t  rtx nval = gen_rtx (REG, SImode, 3);\n \t  emit_insn (gen_movsi (nval, val));\n \t  val = nval;\n \t}\n \n-      if (direction > 0)\n-\tinsn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n-      else\n-\tinsn = gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n-\n+      insn = gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, val);\n       emit_insn (insn);\n     }\n }\n \n-\n-\n /* Generate code to push the regs specified in the mask, and return\n    the number of bytes the insns take. */\n \n@@ -151,7 +168,6 @@ push_regs (mask)\n      int mask;\n {\n   int i;\n-  int size = 0;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -163,13 +179,11 @@ push_regs (mask)\n }\n \n \n-/*\n-  Print an instruction which would have gone into a delay slot\n-  after an instructiuon, but couldn't because the instruction expanded\n-  into a sequence where putting the slot insn at the end wouldn't work.\n-  */\n+/* Print an instruction which would have gone into a delay slot after\n+   an instructiuon, but couldn't because the instruction expanded into a\n+   sequence where putting the slot insn at the end wouldn't work. */\n \n-void\n+static void\n print_slot (insn)\n      rtx insn;\n {\n@@ -178,35 +192,65 @@ print_slot (insn)\n   INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n }\n \n-/* Number of bytes pushed for anonymous args */\n-\n-static int extra_push;\n \n /* Work out the registers which need to be saved, both as a mask and a\n-   count */\n+   count.\n \n-int\n-calc_live_regs (count)\n-     int *count;\n+   If doing a pragma interrupt function, then push all regs used by the function,\n+   and if we call another function (we can tell by looking at PR), make sure that all the\n+   regs it clobbers are safe too.\n+ */\n+static int\n+calc_live_regs (count_ptr)\n+     int *count_ptr;\n {\n   int reg;\n   int live_regs_mask = 0;\n-  *count = 0;\n-\n+  int count = 0;\n   for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg++)\n     {\n-      if (regs_ever_live[reg] && !call_used_regs[reg])\n+      if (reg == ARG_POINTER_REGNUM)\n+\tcontinue;\n+      if (reg == T_REG)\n+\tcontinue;\n+      if (reg == GBR_REG)\n+\tcontinue;\n+\n+      if (pragma_interrupt && !pragma_trapa)\n+\t{\n+\t  /* Need to save all the regs ever live */\n+\t  if ((regs_ever_live[reg]\n+\t       || (call_used_regs[reg] && regs_ever_live[PR_REG]))\n+\t      && reg != 15)\n+\t    {\n+\t      live_regs_mask |= 1 << reg;\n+\t      count++;\n+\t    }\n+\t}\n+      else if (TARGET_SMALLCALL)\n+\t{\n+\t  /* Don't need to push anthing, but count the regs which have\n+\t     been pushed by the wrapper */\n+\t  if (call_used_regs[reg])\n+\t    count++;\n+\t}\n+      else\n \t{\n-\t  (*count)++;\n-\t  live_regs_mask |= (1 << reg);\n+\t  /* Only push those regs which are used and need to be saved */\n+\t  if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t    {\n+\t      count++;\n+\t      live_regs_mask |= (1 << reg);\n+\t    }\n \t}\n     }\n+\n+\n+  *count_ptr = count;\n   return live_regs_mask;\n }\n \f\n \n-\n-\n static int\n need_slot (insn)\n      rtx insn;\n@@ -287,7 +331,7 @@ print_operand_address (stream, x)\n    a double word value\n    'O'  print a constant without the #\n    'M'  print a constant as its negative\n-   'I'  put something into the constant pool and print its label */\n+   'N'  print insides of a @++ or @-- o */\n \n void\n print_operand (stream, x, code)\n@@ -297,22 +341,16 @@ print_operand (stream, x, code)\n {\n   switch (code)\n     {\n-\n-\n     case '.':\n       if (need_slot (final_sequence))\n \tfprintf (stream, \".s\");\n       break;\n     case '*':\n       fprintf (stream, \"LF%d\", lf);\n       break;\n-    case '!':\n-      dump_constants (0);\n-      break;\n     case '^':\n       lf++;\n       break;\n-\n     case '#':\n       /* Output a nop if there's nothing in the delay slot */\n       if (dbr_sequence_length () == 0)\n@@ -321,31 +359,26 @@ print_operand (stream, x, code)\n \t}\n       break;\n     case 'O':\n-      fprintf (asm_out_file, \"%d\", INTVAL (x));\n-      break;\n-\n-    case 'I':\n-      fprintf (asm_out_file, \"LK%d\", add_constant (x, SImode));\n+      output_addr_const (stream, x);\n       break;\n-\n     case 'M':\n       fprintf (asm_out_file, \"#%d\", -INTVAL (x));\n       break;\n-\n+    case 'N':\n+      fputs (reg_names[REGNO (XEXP (XEXP (x, 0), 0))], (stream));\n+      break;\n     case 'R':\n-      /* Next location along in memory or register*/\n+      /* Next location along in memory or register */\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n \t  fputs (reg_names[REGNO (x) + 1], (stream));\n \t  break;\n \tcase MEM:\n-\t  print_operand_address (stream,\n-\t\t\t       XEXP (adj_offsettable_operand (x, 4), 0), 0);\n+\t  print_operand_address (stream, XEXP (adj_offsettable_operand (x, 4), 0));\n \t  break;\n \t}\n       break;\n-\n     default:\n       switch (GET_CODE (x))\n \t{\n@@ -359,43 +392,241 @@ print_operand (stream, x, code)\n \t  fputc ('#', stream);\n \t  output_addr_const (stream, x);\n \t  break;\n-\n \t}\n       break;\n     }\n }\n \f\n \n+sextb (x)\n+{\n+  x &= 0xff;\n+  if (x > 127)\n+    {\n+      x = -256 + x;\n+    }\n+  return x;\n+}\n+\n \n-/* Define the offset between two registers, one to be eliminated, and\n-   the other its replacement, at the start of a routine.  */\n \n-int\n-initial_elimination_offset (from, to)\n+/* Take a move with integer constant source in OPERANDS, see if it can be generated by\n+   devious shifting.  If so, generate the instruction sequence and return 1, otherwise\n+   return 0.\n+   \n+    OPERANDS[0] Destination register\n+    OPERANDS[1] Source constant\n+\n+   00000000 00000000 00000000 0NNNNNNNN simple load\n+   00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n+   00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n+   00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n+   00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n+   N0000000 00000000 00000000 00NNNNNNN load and rotate right\n+\n+   11111111 11111111 11111111 1NNNNNNNN simple load\n+   11111111 11111111 11111111 NNNNNNNN0 load and shift by 1\n+   11111111 11111111 1111111N NNNNNNN00 load and shift by 2\n+   11111111 11111111 1NNNNNNN 000000000 load and shift by 8\n+   11111111 1NNNNNNN 00000000 000000000 load and shift by 16\n+   N1111111 11111111 11111111 11NNNNNNN load and rotate right\n+\n+   00000000 00000000 00000000 1NNNNNNNN load and zero extend byte\n+   00000000 00000000 11111111 1NNNNNNNN load and zero extend word\n+\n+\n+*/   \n+\n+static int\n+synth_constant (operands, mode)\n+     rtx operands[];\n+     enum machine_mode mode;\n {\n-  int regs_saved;\n-  int d = calc_live_regs (&regs_saved);\n-  int total_saved_regs_space = (regs_saved) * 4;\n-  int total_auto_space = get_frame_size ();\n+  rtx dst;\n+  int i = INTVAL (operands[1]) & 0xffffffff;\n+\n+  if (CONST_OK_FOR_I (i))\n+    return 0;\n \n+  dst = mode == SImode ? operands[0] : gen_reg_rtx (SImode);\n \n-  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+  /*  00000000 00000000 11111111 1NNNNNNNN load and zero extend word      */\n+  if ((i & 0xffffff80) == 0x0000ff80)\n+    {\n+      emit_move_insn (dst, GEN_INT (sextb (i)));\n+      emit_insn (gen_and_ffff (dst, dst));\n+    }\n+  /*    00000000 00000000 00000000 1NNNNNNNN load and zero extend byte */\n+  else if ((i & 0xffffff80) == 0x00000080)\n     {\n-      return total_saved_regs_space;\n+      emit_move_insn (dst, GEN_INT (sextb (i)));\n+      emit_insn (gen_and_ff (dst, dst));\n     }\n+  /*   00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n+       11111111 11111111 11111111 NNNNNNNN0 load and shift by 1 */\n+  else if ((i & 0xffffff01) == 0\n+\t   || (i & 0xffffff01) == 0xffffff00)\n+    {\n+      emit_move_insn (dst, GEN_INT (sextb (i >> 1)));\n+      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (1)));\n+    }\n+  /*   00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n+       11111111 11111111 1111111N NNNNNNN00 load and shift by 2*/\n+  else if ((i & 0xfffffe03) == 0\n+\t   || (i & 0xfffffe03) == 0xfffffe00)\n+    {\n+      emit_move_insn (dst, GEN_INT (sextb (i >> 2)));\n+      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (2)));\n+    }\n+  /*   00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n+       11111111 11111111 1NNNNNNN 000000000 load and shift by 8 */\n \n-  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+  else if ((i & 0xffff80ff) == 0\n+\t   || (i & 0xffff80ff) == 0xffff8000)\n     {\n-      return total_saved_regs_space + total_auto_space;\n+      emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n+      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (8)));\n+    }\n+  /*     00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n+\t 11111111 1NNNNNNN 00000000 000000000 load and shift by 16 */\n+  else if ((i & 0xff80ffff) == 0\n+\t   || (i & 0xff80ffff) == 0xff80ffff)\n+    {\n+      emit_move_insn (dst, GEN_INT (sextb (i >> 16)));\n+      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (16)));\n     }\n+  /*   00000000 00000000 0NNNNNNN 0NNNNNNNN load shift 8 and add */\n+  else if ((i & 0xffff8080) == 0 && TARGET_CLEN3)\n+    {\n+      emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n+      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (8)));\n+      emit_insn (gen_addsi3 (dst, dst, GEN_INT (i & 0x7f)));\n+    }\n+  else\n+    return 0;\n \n-  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+  if (mode != SImode)\n     {\n-      return total_auto_space;\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t  gen_rtx (SUBREG, mode, dst, 0)));\n+\n     }\n+  return 1;\n }\n \n \n+/* Emit code to perform a block move.  Choose the best method.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the source.\n+   OPERANDS[2] is the size.\n+   OPERANDS[3] is the alignment safe to use.  */\n+\n+\n+int\n+expand_block_move (operands)\n+     rtx *operands;\n+{\n+  int align = INTVAL (operands[3]);\n+  int constp = (GET_CODE (operands[2]) == CONST_INT);\n+  int bytes = (constp ? INTVAL (operands[2]) : 0);\n+  enum machine_mode mode;\n+  /* IF odd then fail */\n+  if (!constp || bytes <= 0)\n+    return 0;\n+\n+  switch (align)\n+    {\n+    case 1:\n+      mode = QImode;\n+      break;\n+    case 2:\n+      mode = HImode;\n+      break;\n+    default:\n+      mode = SImode;\n+      align = 4;\n+    }\n+  if (mode == SImode && constp && bytes < 64 && (bytes % 4 == 0))\n+    {\n+      char entry[30];\n+      tree entry_name;\n+      rtx func_addr_rtx;\n+      rtx r4 = gen_rtx (REG, SImode, 4);\n+      rtx r5 = gen_rtx (REG, SImode, 5);\n+      sprintf (entry, \"__movstr%s%d\", GET_MODE_NAME (mode), bytes);\n+      entry_name = get_identifier (entry);\n+\n+      func_addr_rtx = copy_to_mode_reg (Pmode,\n+\t      gen_rtx (SYMBOL_REF, Pmode, IDENTIFIER_POINTER (entry_name)));\n+      emit_insn (gen_move_insn (r4, XEXP (operands[0], 0)));\n+      emit_insn (gen_move_insn (r5, XEXP (operands[1], 0)));\n+      emit_insn (gen_block_move_real (func_addr_rtx));\n+      return 1;\n+    }\n+  if (mode == SImode && constp && (bytes % 4 == 0))\n+    {\n+      char entry[30];\n+      tree entry_name;\n+      rtx func_addr_rtx;\n+      int groups;\n+      rtx r4 = gen_rtx (REG, SImode, 4);\n+      rtx r5 = gen_rtx (REG, SImode, 5);\n+      rtx r6 = gen_rtx (REG, SImode, 6);\n+      entry_name = get_identifier (\"__movstr\");\n+\n+      func_addr_rtx = copy_to_mode_reg (Pmode,\n+\t\t\t\t\tgen_rtx (SYMBOL_REF, Pmode,\n+\t\t\t\t\t  IDENTIFIER_POINTER (entry_name)));\n+      emit_insn (gen_move_insn (r4, XEXP (operands[0], 0)));\n+      emit_insn (gen_move_insn (r5, XEXP (operands[1], 0)));\n+\n+      /* r6 controls the size of the move, 16 is decremented from it\n+\t for each 64 bytes moved, then the -ve bit is used as an index into a\n+\t list of move instructions like this:\n+\t\n+\t {\n+\t do {\n+\t *dst++ = *src++;\n+\t *dst++ = *src++;\n+\t *dst++ = *src++;\n+\t ..etc.. 16 in all\n+\t *dst++ = *src++;\n+\t *dst++ = *src++;\n+\t size -= 16;\n+\t } while (size > 0);\n+\t\n+\t switch (size)\n+\t {\n+\t case -15:\n+\t *dst++ = *src++;\n+\t case -14:\n+\t *dst++ = *src++;\n+\t .. etc.. ;\n+\t case -2:\n+\t *dst++ = *src++;\n+\t case -1:\n+\t *dst++ = *src++;\n+\t case 0:\n+\t ;\n+\t }\n+\t }\n+\t\n+\t eg, a 72 byte move would be set up with size(r6) = 14, for one\n+\t iteration through the big while loop, and a switch of -2 for the last part  */\n+\n+      {\n+\tint final_switch = 16 - ((bytes / 4) % 16);\n+\tint while_loop = ((bytes / 4) / 16 - 1) * 16;\n+\temit_insn (gen_move_insn (r6, GEN_INT (while_loop + final_switch)));\n+\temit_insn (gen_block_lump_real (func_addr_rtx));\n+\treturn 1;\n+      }\n+    }\n+  return 0;\n+\n+}\n+\n /* Prepare operands for a move define_expand; specifically, one of the\n    operands must be in a register.  Take this chance to remove\n    addressing modes which can't be coped with very well. */\n@@ -405,38 +636,130 @@ prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n-  /* One of the operands has to be a register */\n-  if ((!register_operand (operands[0], mode)\n-       && !register_operand (operands[1], mode))\n-      || GET_CODE (operands[1]) == PLUS)\n+  if (!(reload_in_progress || reload_completed)\n+      && ((!register_operand (operands[0], mode)\n+\t   && !register_operand (operands[1], mode))\n+\t  || GET_CODE (operands[1]) == PLUS))\n     {\n       /* copy the source to a register */\n       operands[1] = copy_to_mode_reg (mode, operands[1]);\n     }\n-\n-  /* If we've got a negative index, break it down */\n-\n-  if (GET_CODE (operands[0]) == MEM && !reload_in_progress)\n+  if ((mode == DImode || mode == SImode || mode == HImode || mode == QImode) \n+      && GET_CODE (operands[1]) == CONST_INT)\n     {\n+      return synth_constant (operands, mode);\n+    }\n+  if (mode == DFmode || mode == DImode)\n+    {\n+      rtx src = operands[1];\n+      rtx dst = operands[0];\n+      rtx insns;\n \n-      rtx inside = XEXP (operands[0], 0);\n-      if (GET_CODE (inside) == PLUS)\n+      if (src == dst)\n \t{\n-\t  rtx inside1 = XEXP (inside, 1);\n-\t  if (GET_CODE (inside1) == CONST_INT\n-\t      && INTVAL (inside1) < 0)\n-\t    {\n-\t      /* Catch this now and break it into bits, it will only cause\n-\t\t problems later */\n+\t  emit_insn (gen_rtx (SET, VOIDmode, dst, src));\n+\t  return 1;\n+\t}\n \n-\t      rtx sub = copy_to_mode_reg (SImode, inside);\n-\t      XEXP (operands[0], 0) = sub;\n-\t    }\n+      if (GET_CODE (src) == REG &&\n+\t  REGNO (src) >= FIRST_PSEUDO_REGISTER)\n+\treturn 0;\n+\n+      if (GET_CODE (dst) == REG &&\n+\t  REGNO (dst) >= FIRST_PSEUDO_REGISTER)\n+\treturn 0;\n+\n+\n+      if (push_operand (dst, mode))\n+\treturn 0;\n+\n+      if (GET_CODE (src) == CONST_DOUBLE)\n+\tsrc = force_const_mem (DFmode, src);\n+\n+      if (reload_in_progress)\n+\t{\n+\t  if (!(offsettable_memref_p (src) || register_operand (src, mode)))\n+\t    return 0;\n+\t  if (!(offsettable_memref_p (dst) || register_operand (dst,\n+\t\t\t\t\t\t\t\tmode)))\n+\t    return 0;\n+\t}\n+      start_sequence ();\n+      if (GET_CODE (operands[0]) != REG\n+\t  || !refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1, operands[1], 0))\n+\t{\n+\t  emit_move_insn (operand_subword (dst, 0, 1, mode),\n+\t\t\t  operand_subword_force (src, 0, mode));\n+\t  emit_move_insn (operand_subword (dst, 1, 1, mode),\n+\t\t\t  operand_subword_force (src, 1, mode));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (operand_subword (dst, 1, 1, mode),\n+\t\t\t  operand_subword_force (src, 1, mode));\n+\t  emit_move_insn (operand_subword (dst, 0, 1, mode),\n+\t\t\t  operand_subword_force (src, 0, mode));\n \t}\n+\n+      insns = get_insns ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (insns, dst, src, 0, src);\n+      return 1;\n     }\n+\n   return 0;\n }\n \n+/* Work out the subword parts to split up a double move\n+   into two SI moves - take care to do it in the right order\n+ */\n+\n+int\n+prepare_split_double_ops (operands, mode)\n+     rtx operands[];\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (operands[1]) == REG\n+      && REGNO (operands[1]) > FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  if (GET_CODE (operands[0]) == REG\n+      && REGNO (operands[0]) > FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  /* If we split move insns from memory, it confuses scheduling\n+     later on. */\n+  if (GET_CODE (operands[1]) == MEM)\n+    return 0;\n+  if (GET_CODE (operands[0]) == MEM)\n+    return 0;\n+\n+  if (GET_CODE (operands[0]) != REG\n+      || !refers_to_regno_p (REGNO (operands[0]),\n+\t\t\t     REGNO (operands[0]) + 1, operands[1], 0))\n+    {\n+      operands[2] = operand_subword (operands[0], 0, 0, mode);\n+      operands[3] = operand_subword (operands[1], 0, 0, mode);\n+      operands[4] = operand_subword (operands[0], 1, 0, mode);\n+      operands[5] = operand_subword (operands[1], 1, 0, mode);\n+    }\n+  else\n+    {\n+      operands[2] = operand_subword (operands[0], 1, 0, mode);\n+      operands[3] = operand_subword (operands[1], 1, 0, mode);\n+      operands[4] = operand_subword (operands[0], 0, 0, mode);\n+      operands[5] = operand_subword (operands[1], 0, 0, mode);\n+    }\n+\n+  if (operands[2] == 0 || operands[3] == 0\n+      || operands[4] == 0 || operands[5] == 0)\n+    return 0;\n+\n+  emit_move_insn (operands[2], operands[3]);\n+  emit_move_insn (operands[4], operands[5]);\n+  return 1;\n+}\n \n /* Prepare the operands for an scc instruction; make sure that the\n    compare has been done.  */\n@@ -446,58 +769,101 @@ prepare_scc_operands (code)\n   if (GET_CODE (sh_compare_op0) != REG\n       || REGNO (sh_compare_op0) != T_REG)\n     {\n+      int newcode = code;\n       /* First need a compare insn */\n-      emit_insn (gen_rtx (SET, SImode,\n+      switch (code)\n+\t{\n+\tcase NE:\n+\t  newcode = EQ;\n+\t  break;\n+\tcase LT:\n+\t  newcode = GT;\n+\t  break;\n+\tcase LE:\n+\t  newcode = GE;\n+\t  break;\n+\tcase LTU:\n+\t  newcode = GTU;\n+\t  break;\n+\tcase LEU:\n+\t  newcode = GEU;\n+\t  break;\n+\t}\n+      if (newcode != code)\n+\t{\n+\t  rtx tmp = sh_compare_op0;\n+\t  sh_compare_op0 = sh_compare_op1;\n+\t  sh_compare_op1 = tmp;\n+\t  code = newcode;\n+\t}\n+\n+      sh_compare_op0 = force_reg (SImode, sh_compare_op0);\n+      emit_insn (gen_rtx (SET, VOIDmode,\n \t\t\t  gen_rtx (REG, SImode, T_REG),\n-\t\t\t  gen_rtx (code, SImode, sh_compare_op0,\n-\t\t\t\t   sh_compare_op1)));\n+\t\t   gen_rtx (code, SImode, sh_compare_op0, sh_compare_op1)));\n     }\n   return gen_rtx (REG, SImode, T_REG);\n }\n \f\n \n-/* Functions to output assembly */\n+/* Functions to output assembly code. */\n \n /* Return a sequence of instructions to perform DI or DF move.\n \n    Since the SH cannot move a DI or DF in one instruction, we have\n    to take care when we see overlapping source and dest registers.\n \n  */\n+\n char *\n-output_movedouble (operands, mode)\n+output_movedouble (insn, operands, mode)\n+     rtx insn;\n      rtx operands[];\n      enum machine_mode mode;\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n-  int lowfirst;\n \n+  fprintf (asm_out_file, \"! move double \\n\");\n+  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);\n+  if (GET_CODE (dst) == MEM\n+      && GET_CODE (XEXP (dst, 0)) == POST_INC)\n+    {\n+      operands[0] = XEXP (XEXP (dst, 0), 0);\n+      return \"mov.l\t%R1,@(4,%0)\\n\\tmov.l\t%1,@%0\\n\\tadd\t#8,%0\";\n+    }\n   if (register_operand (dst, mode)\n       && register_operand (src, mode))\n     {\n       if (REGNO (src) == MACH_REG)\n \treturn \"sts\tmach,%0\\n\\tsts\tmacl,%R0\";\n \n       /*\n-\twhen mov.d r1,r2 do r2->r3 then r1->r2\n-\twhen mov.d r1,r0 do r1->r0 then r2->r1\n-\t*/\n+         when mov.d r1,r2 do r2->r3 then r1->r2\n+         when mov.d r1,r0 do r1->r0 then r2->r1\n+       */\n \n       if (REGNO (src) + 1 == REGNO (dst))\n-\treturn \"mov\t%1,%0\\n\\tmov\t%R1,%R0 ! cr\";\n+\treturn \"mov\t%R1,%R0\\n\\tmov\t%1,%0 ! cra\";\n       else\n-\treturn \"mov\t%R1,%R0\\n\\tmov\t%1,%0 \";\n-\n+\treturn \"mov\t%1,%0\\n\\tmov\t%R1,%R0 ! crb\";\n     }\n   else if (GET_CODE (src) == CONST_INT)\n     {\n-      if (INTVAL (src) < 0)\n-\treturn \"mov\t#-1,%0\\n\\tmov\t%1,%R0\";\n+      HOST_WIDE_INT val = INTVAL (src);\n+      int rn = REGNO (operands[0]);\n+      if (val < 0)\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov\t#-1,r%d\\n\", rn);\n+\t}\n       else\n-\treturn \"mov\t#0,%0\\n\\tmov\t%1,%R0\";\n-    }\n+\t{\n+\t  fprintf (asm_out_file, \"\\tmov\t#0,r%d\\n\", rn);\n+\t}\n \n+      fprintf (asm_out_file, \"\\tmov\t#%d,r%d\\n\", val, rn + 1);\n+      return \"\";\n+    }\n   else if (GET_CODE (src) == MEM)\n     {\n       int ptrreg1 = -1;\n@@ -518,10 +884,13 @@ output_movedouble (operands, mode)\n \t  if (GET_CODE (rhs) == REG)\n \t    ptrreg2 = REGNO (rhs);\n \t}\n+      else if (GET_CODE (inside) == LABEL_REF)\n+\t{\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1+4,%R0\";\n+\t}\n       else\n \tabort ();\n \n-\n       if ((ptrreg1 >= 0 && ptrreg2 >= 0)\n \t  && (dreg == ptrreg1\n \t      || dreg == ptrreg2\n@@ -582,7 +951,24 @@ output_shift (string, reg, k, code)\n \n {\n   int s = INTVAL (k);\n-\n+  if (s < 0)\n+    {\n+      s = -s;\n+      switch (code)\n+\t{\n+\tcase LSHIFTRT:\n+\tcase ASHIFTRT:\n+\t  code = LSHIFT;\n+\t  break;\n+\tcase ASHIFT:\n+\t  code = ASHIFTRT;\n+\t  break;\n+\tcase LSHIFT:\n+\t  code = LSHIFTRT;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n   if (code == ASHIFT && s == 31)\n     {\n       /* Shift left by 31 moving into the t bit, clearing and rotating the other way */\n@@ -632,13 +1018,80 @@ output_shift (string, reg, k, code)\n   return \"\";\n }\n \n+\n+void\n+function_epilogue (stream, size)\n+     FILE *stream;\n+     int size;\n+{\n+  fprintf (stream, \"\\trts\\n\");\n+  fprintf (stream, \"\\tor\tr0,r0\\n\");\n+}\n+\n+\n /* Return the text of the branch instruction which matches its length\n    attribute.\n \n    This gets tricky if we have an insn in the delay slot of a branch\n-   and the branch needs more than 1 insn to complete.*/\n+   and the branch needs more than 1 insn to complete. */\n+\n+int pending_const_table;\n+\n+ /* We can't tell if we need a register as a scratch for the jump\n+    until after branch shortening, and then it's too late to allocate a\n+    register the 'proper' way.  These instruction sequences are rare\n+    anyway, so to avoid always using a reg up from our limited set, we'll\n+    grab one when we need one on output. */\n+\n+char *\n+output_far_jump (insn, op)\n+     rtx insn;\n+     rtx op;\n+{\n+  rtx thislab = gen_label_rtx ();\n+\n+  /* See if we can grab a reg from the prev insn */\n+  rtx gotone = 0;\n+  rtx prev = PREV_INSN (insn);\n+  rtx link;\n+\n+  if (dbr_sequence_length ())\n+    {\n+      /* Something to go in what would have been the delay\n+\t slot if this had been a short branch. Make sure the\n+\t reg we use to generate the branch target address\n+\t doesn't conflict */\n+\n+      int i;\n+      rtx vec[2];\n+      vec[0] = thislab;\n+\n+      for (i = 0; i < 8; i++)\n+\t{\n+\t  vec[1] = gen_rtx (REG, SImode, i);\n+\t  if (!reg_referenced_p (vec[1], PATTERN (XVECEXP (final_sequence, 0, 1))))\n+\t    break;\n+\t}\n \n+      output_asm_insn (\"mov.l\t%1,@-r15\", vec);\n+      output_asm_insn (\"mov.l\t%O0,%1\", vec);\n+      print_slot (final_sequence);\n+      output_asm_insn (\"jmp\t@%1 ! 32 xcond\", vec);\n+      output_asm_insn (\"mov.l\t@r15+,%1\", vec);\n+    }\n+  else\n+    {\n+      output_asm_insn (\"mov.l\tr13,@-r15\", 0);\n+      output_asm_insn (\"mov.l\t%O0,r13\", &thislab);\n+      output_asm_insn (\"jmp\t@r13 ! 32 zcond\", 0);\n+      output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n+    }\n \n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (thislab));\n+  output_asm_insn (\".align\t2\", 0);\n+  output_asm_insn (\".long\t%O0\", &op);\n+  return \"\";\n+}\n \n char *\n output_branch (logic, insn)\n@@ -649,6 +1102,7 @@ output_branch (logic, insn)\n   int label = lf++;\n   int rn = -1;\n   int need_save;\n+  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);\n \n   switch (get_attr_length (insn))\n     {\n@@ -679,16 +1133,13 @@ output_branch (logic, insn)\n \n \toutput_asm_insn (\"bra\t%l0\t! 12 bit cond \", recog_operand);\n \tfprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n-\tlabel = dump_constants (label);\n \tfprintf (asm_out_file, \"LF%d:\\n\", label);\n       }\n-\n       return \"\";\n \n-    case 8:\n+    case 16:\n       /* Branches a long way away */\n       {\n-\n \trtx oldop = recog_operand[0];\n \n \tif (need_slot (final_sequence))\n@@ -702,20 +1153,7 @@ output_branch (logic, insn)\n \t    fprintf (asm_out_file, \"\\tb%c\\tLF%d\\n\", logic ? 'f' : 't', label);\n \t  }\n \n-\trecog_operand[0] = oldop;\n-\n-\t/* We use r13 as a scratch */\n-\tneed_save = 0;\n-\trn = 13;\n-\n-\tif (need_save)\n-\t  fprintf (asm_out_file, \"\\tpush  r%d\\n\", rn);\n-\tfprintf (asm_out_file, \"\\tmov.l\tLK%d,r%d\\n\", add_constant (oldop, SImode), rn);\n-\tfprintf (asm_out_file, \"\\tjmp\t@r%d\t! 32 cond \\n\", rn);\n-\tif (need_save)\n-\t  fprintf (asm_out_file, \"\\tpop  r%d\\n\", rn);\n-\telse\n-\t  fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n+\toutput_far_jump (insn, oldop);\n \tfprintf (asm_out_file, \"LF%d:\\n\", label);\n \treturn \"\";\n       }\n@@ -724,231 +1162,70 @@ output_branch (logic, insn)\n }\n \f\n \n-/* Predicates used by the templates */\n-\n-/* Non zero if op is an immediate ok for a byte index */\n+/* The SH cannot load a large constant into a register, constants have to\n+   come from a pc relative load.  The reference of a pc relative load\n+   instruction must be less than 1k infront of the instruction.  This\n+   means that we often have to dump a constant inside a function, and\n+   generate code to branch around it.\n \n-int \n-byte_index_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= 0 && INTVAL (op) <= 15);\n-}\n+   It is important to minimize this, since the branches will slow things\n+   down and make things bigger.\n \n-/* Non zero if OP is a pop operand */\n+   Worst case code looks like:\n \n-int\n-pop_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  if (GET_CODE (op) != POST_INC)\n-    return 0;\n-\n-  return XEXP (op, 0) == stack_pointer_rtx;\n-}\n-\n-/* Non zero if OP is an immediate which can be made from two insns. */\n-\n-int\n-painful_immediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      int i = INTVAL (op);\n-\n-      if (i > 127 && i < 255)\n-\treturn 1;\t\t/* two adds */\n-    }\n-  return 0;\n-}\n-\n-\n-/* Non zero if OP can be source of a simple move operation. */\n-\n-int\n-general_movsrc_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == REG\n-      || GET_CODE (op) == SUBREG\n-      || (GET_CODE (op) == CONST_INT &&\n-\t  CONST_OK_FOR_I (INTVAL (op)))\n-      || GET_CODE (op) == MEM)\n-    return general_operand (op, mode);\n-  return 0;\n-}\n-\n-\n-\n-/* Nonzero if OP is a normal arithmetic register. */\n-\n-int\n-arith_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    {\n-      if (GET_CODE (op) == REG)\n-\treturn REGNO (op) != T_REG;\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Nonzero if OP is a valid source operand for an arithmetic insn.  */\n-\n-int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (CONST_OK_FOR_I (INTVAL (op)))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Nonzero if OP is a valid source operand for a logical operation */\n-\n-int\n-logical_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      if (CONST_OK_FOR_L (INTVAL (op)))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-/* Nonzero if p is a valid shift operand for lshr and ashl */\n+   mov.l L1,rn\n+   bra   L2\n+   nop\n+   align\n+   L1:   .long value\n+   L2:\n+   ..\n \n-int\n-ok_shift_value (p)\n-     rtx p;\n-{\n-  if (GET_CODE (p) == CONST_INT)\n-    {\n-      switch (INTVAL (p))\n-\t{\n-\tcase 1:\n-\tcase 2:\n-\tcase 8:\n-\tcase 16:\n-\t  return 1;\n-\tdefault:\n-\t  if (TARGET_FASTCODE)\n-\t    return INTVAL (p) >= 0;\n-\t}\n-    }\n-  return 0;\n-}\n+   mov.l L3,rn\n+   bra   L4\n+   nop\n+   align\n+   L3:   .long value\n+   L4:\n+   ..\n \n-/* Nonzero if the arg is an immediate which has to be loaded from\n-   memory */\n+   We fix this by performing a scan before scheduling, which notices which\n+   instructions need to have their operands fetched from the constant table\n+   and builds the table.\n \n-int\n-hard_immediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (immediate_operand (op, mode))\n-    {\n-      if (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= -128 && INTVAL (op) < 127)\n-\treturn 0;\n-      return 1;\n-    }\n-  return 0;\n-}\n-\f\n-/* The SH cannot load a large constant into a register, constants have to\n-   come from a pc relative load.  The reference of a pc relative load\n-   instruction must be less than 1k infront of the instruction.  This\n-   means that we often have to dump a constant inside a function, and\n-   generate code to branch around it.\n \n-   It is important to minimize this, since the branches will slow things\n-   down and make things bigger.\n+   The algorithm is:\n \n-  Worst case code looks like:\n-\n-      mov.l L1,rn\n-      bra   L2\n-      nop\n-      align\n-L1:   .long value\n-L2:\n-      ..\n-\n-      mov.l L3,rn\n-      bra   L4\n-      nop\n-      align\n-L3:   .long value\n-L4:\n-      ..\n-\n-   During shorten_branches we notice the instructions which can have a\n-   constant table in them, if we see two that are close enough\n-   together, we move the constants from the first table to the second\n-   table and continue.  This process can happen again and again, and\n-   in the best case, moves the constant table outside of the function.\n+   scan, find an instruction which needs a pcrel move.  Look forward, find the\n+   last barrier which is within MAX_COUNT bytes of the requirement.\n+   If there isn't one, make one.  Process all the instructions between\n+   the find and the barrier.\n \n    In the above example, we can tell that L3 is within 1k of L1, so\n    the first move can be shrunk from the 3 insn+constant sequence into\n    just 1 insn, and the constant moved to L3 to make:\n \n-   mov.l\tL1,rn\n+   mov.l        L1,rn\n    ..\n-   mov.l\tL3,rn\n-   bra\t\tL4\n+   mov.l        L3,rn\n+   bra          L4\n    nop\n    align\n-L3:.long value\n-L4:.long value\n+   L3:.long value\n+   L4:.long value\n \n    Then the second move becomes the target for the shortening process.\n \n-   We keep a simple list of all the constants accumulated in the\n-   current pool so there are no duplicates in a single table, but\n-   they are not factored into the size estimates.\n-\n-*/\n+ */\n \n typedef struct\n {\n-  rtx value;\n-  int number;\n-  enum machine_mode mode;\n-} pool_node;\n+  rtx value;\t\t\t/* Value in table */\n+  rtx label;\t\t\t/* Label of value */\n+  enum machine_mode mode;\t/* Mode of value */\n+}\n+\n+pool_node;\n \n /* The maximum number of constants that can fit into one pool, since\n    the pc relative range is 0...1020 bytes and constants are at least 4\n@@ -958,28 +1235,19 @@ typedef struct\n static pool_node pool_vector[MAX_POOL_SIZE];\n static int pool_size;\n \n+/* Add a constant to the pool and return its label.  */\n \n-/* Add a constant to the pool and return its label number.  */\n-\n-static int\n+static rtx\n add_constant (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n   int i;\n-\n-  /* Start the countdown on the first constant */\n-\n-  if (!pool_size)\n-    {\n-      first_pc = pc;\n-    }\n-\n+  rtx lab;\n   /* First see if we've already got it */\n \n   for (i = 0; i < pool_size; i++)\n     {\n-\n       if (x->code == pool_vector[i].value->code\n \t  && mode == pool_vector[i].mode)\n \t{\n@@ -989,546 +1257,657 @@ add_constant (x, mode)\n \t\tcontinue;\n \t    }\n \t}\n-\n       if (rtx_equal_p (x, pool_vector[i].value))\n-\treturn pool_vector[i].number;\n+\treturn pool_vector[i].label;\n     }\n \n+  /* Need a new one */\n \n   pool_vector[pool_size].value = x;\n+  lab = gen_label_rtx ();\n   pool_vector[pool_size].mode = mode;\n-  pool_vector[pool_size].number = lf;\n+  pool_vector[pool_size].label = lab;\n   pool_size++;\n-\n-  return lf++;\n+  return lab;\n }\n \n-/* Nonzero if the insn could take a constant table.  */\n+/* Dump out interesting debug info */\n \n-static int\n-has_constant_table (insn)\n+rtx\n+final_prescan_insn (insn, opvec, noperands)\n      rtx insn;\n+     rtx *opvec;\n+     int noperands;\n {\n-  rtx body;\n-\n-  if (GET_CODE (insn) == NOTE\n-      || GET_CODE (insn) == BARRIER\n-      || GET_CODE (insn) == CODE_LABEL)\n-    return 0;\n-\n-  body = PATTERN (insn);\n-  if (GET_CODE (body) == SEQUENCE)\n-    return 0;\n-  if (GET_CODE (body) == ADDR_VEC)\n-    return 0;\n-  if (GET_CODE (body) == USE)\n-    return 0;\n-  if (GET_CODE (body) == CLOBBER)\n-    return 0;\n-  if (get_attr_constneed (insn) == CONSTNEED_YES)\n-    return 1;\n-\n-  if (GET_CODE (body) == UNSPEC_VOLATILE)\n+  if (target_flags & ISIZE_BIT)\n     {\n-      return INTVAL (XVECEXP (body, 0, 0)) == 1;\n+      extern int *insn_addresses;\n+      fprintf (asm_out_file, \"\\n! at %04x\\n\",\n+\t       insn_addresses[INSN_UID (insn)]);\n     }\n-  return 0;\n }\n \n-/*  Adjust the length of an instruction.\n-\n-    We'll look at the previous instruction which holds a constant\n-    table and see if we can move the table to here instead. */\n \n-int target_insn_uid;\n-int target_insn_smallest_size;\n+\f\n \n-int target_pc;\n-int target_insn_range;\n-int current_pc;\n-int pool_bytes;\n+/* Stuff taken from m88k.c */\n \n-int last_uid;\n-int last_pc;\n+/* Output to FILE the start of the assembler file.  */\n \n-void\n-adjust_insn_length (insn, insn_lengths)\n-     rtx insn;\n-     short *insn_lengths;\n+struct option\n {\n-  int uid = INSN_UID (insn);\n-  rtx body = PATTERN (insn);\n-\n-  current_pc += insn_lengths[uid];\n-\n+  char *string;\n+  int *variable;\n+  int on_value;\n+};\n \n-  if (GET_CODE (body) == SEQUENCE)\n+static int\n+output_option (file, sep, type, name, indent, pos, max)\n+     FILE *file;\n+     char *sep;\n+     char *type;\n+     char *name;\n+     char *indent;\n+     int pos;\n+     int max;\n+{\n+  if (strlen (sep) + strlen (type) + strlen (name) + pos > max)\n     {\n-      int i;\n-\n-      for (i = 0; i < XVECLEN (body, 0); i++)\n-\t{\n-\t  adjust_insn_length (XVECEXP (body, 0, i), insn_lengths);\n-\t}\n+      fprintf (file, indent);\n+      return fprintf (file, \"%s%s\", type, name);\n     }\n-  else\n-    {\n-      if (has_constant_table (insn))\n-\t{\n-\t  if (current_pc >= target_insn_range)\n-\t    {\n-\t      /* This instruction is further away from the referencing\n-\t       instruction than it can reach, so we'll stop accumulating\n-\t       from that one and start fresh. */\n-\t      target_pc = current_pc;\n-\t      target_insn_range = current_pc + MAYBE_DUMP_LEVEL;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This instruction is within the reach of the target,\n-\t       remove the constant table from the target by adjusting\n-\t       downwards, and increase the size of this one to\n-\t       compensate.  */\n-\n+  return pos + fprintf (file, \"%s%s%s\", sep, type, name);\n+}\n \n-\t      /* Add the stuff from this insn to what will go in the\n-\t       growing table. */\n+static struct\n+{\n+  char *name;\n+  int value;\n+}\n \n-\t      pool_bytes += get_attr_constantsize (insn);\n+m_options[] = TARGET_SWITCHES;\n \n-\t      /* The target shinks to its smallest natural size */\n-\t      insn_lengths[target_insn_uid] = target_insn_smallest_size;\n+static void\n+output_options (file, f_options, f_len, W_options, W_len,\n+\t\tpos, max, sep, indent, term)\n+     FILE *file;\n+     struct option *f_options;\n+     struct option *W_options;\n+     int f_len, W_len;\n+     int pos;\n+     int max;\n+     char *sep;\n+     char *indent;\n+     char *term;\n+{\n+  register int j;\n \n-\t      /* The current insn grows to be its larger size plust the\n-\t       table size. */\n \n-\t      insn_lengths[uid] = get_attr_largestsize (insn) + pool_bytes;\n+  if (optimize)\n+    pos = output_option (file, sep, \"-O\", \"\", indent, pos, max);\n+  if (write_symbols != NO_DEBUG)\n+    pos = output_option (file, sep, \"-g\", \"\", indent, pos, max);\n+  if (flag_traditional)\n+    pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n+  if (profile_flag)\n+    pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n+  if (profile_block_flag)\n+    pos = output_option (file, sep, \"-a\", \"\", indent, pos, max);\n \n-\t    }\n-\t  /* Current insn becomes the target.  */\n-\t  target_insn_uid = uid;\n-\t  target_insn_smallest_size = get_attr_smallestsize (insn);\n+  for (j = 0; j < f_len; j++)\n+    if (*f_options[j].variable == f_options[j].on_value)\n+      pos = output_option (file, sep, \"-f\", f_options[j].string,\n+\t\t\t   indent, pos, max);\n \n-\t}\n-    }\n-}\n+  for (j = 0; j < W_len; j++)\n+    if (*W_options[j].variable == W_options[j].on_value)\n+      pos = output_option (file, sep, \"-W\", W_options[j].string,\n+\t\t\t   indent, pos, max);\n \n+  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n+    if (m_options[j].name[0] != '\\0'\n+\t&& m_options[j].value > 0\n+\t&& ((m_options[j].value & target_flags)\n+\t    == m_options[j].value))\n+      pos = output_option (file, sep, \"-m\", m_options[j].name,\n+\t\t\t   indent, pos, max);\n \n \n-/* Dump out the pending constant pool.\n-   If label provided then insert an branch in the middle of the table\n-   */\n+  fprintf (file, term);\n+  fprintf (file, \"! %d %d\\n\", max_count_si, max_count_hi);\n+}\n \n-int\n-dump_constants (label)\n+void\n+output_file_start (file, f_options, f_len, W_options, W_len)\n+     FILE *file;\n+     struct option *f_options;\n+     struct option *W_options;\n+     int f_len, W_len;\n {\n-  int i;\n-  int rlabel = label;\n-  int size = 0;\n-\n-  if (pool_size)\n-    {\n-      fprintf (asm_out_file, \"\\n\\t! constants - waited %d\\n\", pc - first_pc);\n-      fprintf (asm_out_file, \"\\t.align\\t2\\n\");\n-\n-      for (i = 0; i < pool_size; i++)\n-\t{\n-\t  pool_node *p = pool_vector + i;\n-\n-\t  fprintf (asm_out_file, \"LK%d:\", p->number);\n-\t  size += GET_MODE_SIZE (p->mode);\n-\n-\t  switch (GET_MODE_CLASS (p->mode))\n-\t    {\n-\t    case MODE_INT:\n-\t    case MODE_PARTIAL_INT:\n-\t      assemble_integer (p->value, GET_MODE_SIZE (p->mode), 1);\n-\t      break;\n-\t    case MODE_FLOAT:\n-\t      {\n-\t\tunion real_extract u;\n-\t\tbcopy (&CONST_DOUBLE_LOW (p->value), &u, sizeof u);\n-\t\tassemble_real (u.d, p->mode);\n-\t      }\n-\t    }\n-\n-\t  /* After 200 bytes of table, stick in another branch */\n-\t  if (label && size > 200)\n-\t    {\n-\t      rlabel = lf++;\n-\t      fprintf (asm_out_file, \"LF%d:\\tbra\tLF%d\\n\", label, rlabel);\n-\t      fprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n-\t      label = 0;\n-\t    }\n+  register int pos;\n \n-\t}\n-    }\n+  output_file_directive (file, main_input_filename);\n \n-  pool_size = 0;\n-  current_pc = 0;\n-  pc = 0;\n-  pool_bytes = 0;\n+  /* Switch to the data section so that the coffsem symbol and the\n+     gcc2_compiled. symbol aren't in the text section.  */\n+  data_section ();\n \n-  target_insn_range = 0;\n-  return rlabel;\n \n+  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) arguments:\", version_string);\n+  output_options (file, f_options, f_len, W_options, W_len,\n+\t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n }\n+\f\n \n \n-/* Emit the text to load a value from a constant table.  */\n+/* Return the cost of a shift */\n \n-char *\n-output_movepcrel (insn, operands, mode)\n-     rtx insn;\n-     rtx operands[];\n-     enum machine_mode mode;\n+int\n+shiftcosts (RTX)\n+     rtx RTX;\n {\n-  int len = GET_MODE_SIZE (mode);\n-  int rn = REGNO (operands[0]);\n-\n-  fprintf (asm_out_file, \"\\tmov.l\tLK%d,r%d\\n\",\n-\t   add_constant (operands[1], mode), rn);\n-\n-  if (GET_MODE_SIZE (mode) > 4)\n-    {\n-      fprintf (asm_out_file,\n-\t       \"\\tmov.l\tLK%d+4,r%d\\n\",\n-\t       add_constant (operands[1], mode),\n-\t       rn + 1);\n+  /* If shift by a non constant, then this will be expensive. */\n+  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n+    return 20;\n \n-    }\n+  /* otherwise, it will be very cheap if by one of the constants\n+     we can cope with. */\n+  if (CONST_OK_FOR_K (INTVAL (XEXP (RTX, 1))))\n+    return 1;\n \n-  /* This may have been the last move in the function, so nothing\n-     took its constant table, we may be able to move it past the end\n-     of the function (after the rts) if we are careful */\n+  /* otherwise it will be several insns, but we pretend that it will be more than\n+     just the components, so that combine doesn't glue together a load of shifts into\n+     one shift which has to be emitted as a bunch anyway - breaking scheduling */\n+  return 100;\n+}\n \n-  if (target_insn_uid == INSN_UID (insn)\n-      && current_pc < target_insn_range)\n-    return \"\";\n+int \n+andcosts (RTX)\n+     rtx RTX;\n+{\n+  int i;\n+  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n+    return 2;\n+  i = INTVAL (XEXP (RTX, 1));\n+  /* And can use the extend insns cheaply */\n+  if (i == 0xff || i == 0xffff)\n+    return 2;\n+  /* Any small constant is reasonably cheap - but requires r0 */\n+  if (CONST_OK_FOR_I (i))\n+    return 3;\n+  return 5;\n+}\n+/* Return the cost of a multiply */\n+int\n+multcosts (RTX)\n+     rtx RTX;\n+{\n+  if (TARGET_SH2)\n+    return 2;\n+  /* If we we're aiming at small code, then just count the number of\n+     insns in a multiply call sequence, otherwise, count all the insnsn\n+     inside the call. */\n+  if (TARGET_SMALLCODE)\n+    return 3;\n+  return 30;\n+}\n \n+/* Code to expand a shift */\n \n-  /* If this instruction is as small as it can be, there can be no\n-     constant table attached to it.  */\n-  if (get_attr_length (insn) != get_attr_smallestsize (insn))\n+void\n+gen_ashift (type, n, reg)\n+     int type;\n+     int n;\n+     rtx reg;\n+{\n+  switch (type)\n     {\n-      /* This needs a constant table */\n-      fprintf (asm_out_file, \"\\t!constant table start\\n\");\n-      fprintf (asm_out_file, \"\\tbra\tLF%d\\n\", lf);\n-      fprintf (asm_out_file, \"\\tor\tr0,r0 ! wasted slot\\n\");\n-      dump_constants (0);\n-      fprintf (asm_out_file, \"LF%d:\\n\", lf++);\n-      fprintf (asm_out_file, \"\\t!constant table end\\n\");\n+    case ASHIFTRT:\n+      emit_insn (gen_ashrsi3_k (reg, reg, GEN_INT (n)));\n+      break;\n+    case LSHIFTRT:\n+      emit_insn (gen_lshrsi3_k (reg, reg, GEN_INT (n)));\n+      break;\n+    case ASHIFT:\n+      if (n == 1)\n+\temit_insn (gen_addsi3 (reg, reg, reg));\n+      else\n+\temit_insn (gen_ashlsi3_k (reg, reg, GEN_INT (n)));\n+      break;\n     }\n-  return \"\";\n }\n-\f\n-\n-/* Dump out interesting debug info */\n \n-rtx\n-final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx *opvec;\n-     int noperands;\n+int\n+gen_shifty_op (code, operands)\n+     int code;\n+     rtx *operands;\n {\n-  register rtx body = PATTERN (insn);\n-\n-  if (target_flags & ISIZE_BIT)\n+  rtx wrk = gen_reg_rtx (SImode);\n+  rtx t;\n+  char *func;\n+  if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      extern int *insn_addresses;\n-\n-      fprintf (asm_out_file, \"\\n!%04x*\\n\",\n-\t       insn_addresses[INSN_UID (insn)] + 0x10);\n+      int value = INTVAL (operands[2]);\n+    top:\n+      switch (code)\n+\t{\n+\tcase ASHIFTRT:\n+\t  if (value < 0)\n+\t    {\n+\t      code = ASHIFT;\n+\t      value = -value;\n+\t      goto top;\n+\t    }\n \n-      fprintf (asm_out_file, \"\\n!%04x %d %04x len=%d\\n\",\n-\t       pc, pool_size, first_pc, get_attr_length (insn));\n+\t  /* Expand a short sequence inline, longer call a magic routine */\n+\t  if (value < 4)\n+\t    {\n+\t      emit_move_insn (wrk, operands[1]);\n+\t      while (value--)\n+\t\t{\n+\t\t  gen_ashift (ASHIFTRT, 1, wrk);\n+\t\t}\n+\t      emit_move_insn (operands[0], wrk);\n+\t      return 1;\n+\t    }\n+\t  t = gen_reg_rtx (Pmode);\n+\t  /*  Load the value into an arg reg and call a helper */\n+\t  emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n+\t  if (!shiftsyms[value])\n+\t    {\n+\t      func = xmalloc (18);\n+\t      sprintf (func, \"__ashiftrt_r4_%d\", value);\n+\t      shiftsyms[value] = gen_rtx (SYMBOL_REF, Pmode, func);\n+\t    }\n+\t  emit_move_insn (t, shiftsyms[value]);\n+\t  emit_insn (gen_ashrsi3_n (GEN_INT (value), t));\n+\t  emit_move_insn (operands[0], gen_rtx (REG, SImode, 4));\n+\t  return 1;\n \n-      if (TARGET_DUMP_RTL)\n-\tprint_rtl (asm_out_file, body);\n+\tcase ASHIFT:\n+\t  if (value < 0)\n+\t    {\n+\t      code = LSHIFTRT;\n+\t      value = -value;\n+\t      goto top;\n+\t    }\n+\t  /* Fall through */\n+\tcase LSHIFTRT:\n \n+\t  if (value < 0)\n+\t    {\n+\t      code = ASHIFT;\n+\t      value = -value;\n+\t      goto top;\n+\t    }\n \n-    }\n+\t  emit_move_insn (wrk, operands[1]);\n+\t  while (value)\n+\t    {\n+\t      if (value >= 16)\n+\t\t{\n+\t\t  gen_ashift (code, 16, wrk);\n+\t\t  value -= 16;\n+\t\t}\n+\t      else if (value >= 8)\n+\t\t{\n+\t\t  gen_ashift (code, 8, wrk);\n+\t\t  value -= 8;\n+\t\t}\n+\t      else if (value >= 2)\n+\t\t{\n+\t\t  gen_ashift (code, 2, wrk);\n+\t\t  value -= 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gen_ashift (code, 1, wrk);\n+\t\t  value--;\n+\t\t}\n+\t    }\n+\t  emit_move_insn (operands[0], wrk);\n+\t  return 1;\n \n-  pc += get_attr_length (insn);\n-  if (pool_size && pc - first_pc > MUST_DUMP_LEVEL)\n-    {\n-      /* For some reason we have not dumped out a constant table, and\n-\t we have emitted a lot of code.  This can happen if the think\n-\t which wants the table is a long conditional branch (which has no\n-\t room for a constant table), and there has not been a move\n-\t constant anywhere. */\n-      int label = lf++;\n-      fprintf (asm_out_file, \"\\t!forced constant table\\n\");\n-      fprintf (asm_out_file, \"\\tbra\tLF%d\\n\", label);\n-      fprintf (asm_out_file, \"\\tor\tr0,r0 ! wasted slot\\n\");\n-      label = dump_constants (label);\n-      fprintf (asm_out_file, \"LF%d:\\n\", label);\n-      fprintf (asm_out_file, \"\\t!constant table end\\n\");\n+\t}\n     }\n+  return 0;\n }\n \n+/* Dump out any constants accumulated in the final pass -\n+   which will only be labels */\n+char *\n+output_jump_label_table ()\n+{\n+  int i;\n+  if (pool_size)\n+    {\n+      fprintf (asm_out_file, \"\\t.align 2\\n\");\n+      for (i = 0; i < pool_size; i++)\n+\t{\n+\t  pool_node *p = pool_vector + i;\n \n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\", CODE_LABEL_NUMBER (p->label));\n+\t  output_asm_insn (\".long\t%O0\", &p->value);\n+\t}\n+      pool_size = 0;\n+    }\n \n-/* Block move stuff stolen from m88k*/\n-\n-/* Emit code to perform a block move.  Choose the best method.\n-\n-   OPERANDS[0] is the destination.\n-   OPERANDS[1] is the source.\n-   OPERANDS[2] is the size.\n-   OPERANDS[3] is the alignment safe to use.  */\n-\n-/* Emit code to perform a block move with an offset sequence of ld/st\n-   instructions (..., ld 0, st 1, ld 1, st 0, ...).  SIZE and ALIGN are\n-   known constants.  DEST and SRC are registers.  OFFSET is the known\n-   starting point for the output pattern.  */\n+  return \"\";\n+}\n+/* Output the literal table */\n \n-static enum machine_mode mode_from_align[] =\n-{VOIDmode, QImode, HImode, VOIDmode, SImode,\n- VOIDmode, VOIDmode, VOIDmode, DImode};\n static void\n-\n-block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n-     rtx dest, dest_mem;\n-     rtx src, src_mem;\n-     int size;\n-     int align;\n-     int offset;\n+dump_table (scan)\n+     rtx scan;\n {\n-  rtx temp[2];\n-  enum machine_mode mode[2];\n-  int amount[2];\n-  int active[2];\n-  int phase = 0;\n-  int next;\n-  int offset_ld = offset;\n-  int offset_st = offset;\n-\n-  active[0] = active[1] = FALSE;\n-\n-  /* Establish parameters for the first load and for the second load if\n-     it is known to be the same mode as the first.  */\n-  amount[0] = amount[1] = align;\n+  int i;\n+  int pass;\n+  int need_align = 1;\n \n \n-  mode[0] = mode_from_align[align];\n+  /* Do two passes, first time dump out the HI sized constants */\n \n-  temp[0] = gen_reg_rtx (mode[0]);\n-  if (size >= 2 * align)\n+  for (i = 0; i < pool_size; i++)\n     {\n-      mode[1] = mode[0];\n-      temp[1] = gen_reg_rtx (mode[1]);\n+      pool_node *p = pool_vector + i;\n+      if (p->mode == HImode)\n+\t{\n+\t  if (need_align)\n+\t    {\n+\t      scan = emit_insn_after (gen_align_2 (), scan);\n+\t      need_align = 0;\n+\t    }\n+\t  scan = emit_label_after (p->label, scan);\n+\t  scan = emit_insn_after (gen_consttable_2 (p->value), scan);\n+\t}\n     }\n+  need_align = 1;\n \n-  do\n+\n+  for (i = 0; i < pool_size; i++)\n     {\n-      rtx srcp, dstp;\n-      next = phase;\n-      phase = !phase;\n+      pool_node *p = pool_vector + i;\n \n-      if (size > 0)\n+      switch (p->mode)\n \t{\n-\t  /* Change modes as the sequence tails off.  */\n-\t  if (size < amount[next])\n+\tcase HImode:\n+\t  break;\n+\tcase SImode:\n+\t  if (need_align)\n \t    {\n-\t      amount[next] = (size >= 4 ? 4 : (size >= 2 ? 2 : 1));\n-\t      mode[next] = mode_from_align[amount[next]];\n-\t      temp[next] = gen_reg_rtx (mode[next]);\n+\t      need_align = 0;\n+\t      scan = emit_insn_after (gen_align_4 (), scan);\n \t    }\n-\t  size -= amount[next];\n-\t  srcp = gen_rtx (MEM,\n-\t\t\t  MEM_IN_STRUCT_P (src_mem) ? mode[next] : BLKmode,\n-\t\t\t  gen_rtx (PLUS, Pmode, src,\n-\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_ld)));\n-\t  RTX_UNCHANGING_P (srcp) = RTX_UNCHANGING_P (src_mem);\n-\t  MEM_VOLATILE_P (srcp) = MEM_VOLATILE_P (src_mem);\n-\t  MEM_IN_STRUCT_P (srcp) = 1;\n-\t  emit_insn (gen_rtx (SET, VOIDmode, temp[next], srcp));\n-\t  offset_ld += amount[next];\n-\t  active[next] = TRUE;\n-\t}\n-\n-      if (active[phase])\n-\t{\n-\t  active[phase] = FALSE;\n-\t  dstp = gen_rtx (MEM,\n-\t\t\t  MEM_IN_STRUCT_P (dest_mem) ? mode[phase] : BLKmode,\n-\t\t\t  gen_rtx (PLUS, Pmode, dest,\n-\t\t\t\t   gen_rtx (CONST_INT, SImode, offset_st)));\n-\t  RTX_UNCHANGING_P (dstp) = RTX_UNCHANGING_P (dest_mem);\n-\t  MEM_VOLATILE_P (dstp) = MEM_VOLATILE_P (dest_mem);\n-\t  MEM_IN_STRUCT_P (dstp) = 1;\n-\t  emit_insn (gen_rtx (SET, VOIDmode, dstp, temp[phase]));\n-\t  offset_st += amount[phase];\n+\t  scan = emit_label_after (p->label, scan);\n+\t  scan = emit_insn_after (gen_consttable_4 (p->value), scan);\n+\t  break;\n+\tcase DImode:\n+\t  if (need_align)\n+\t    {\n+\t      need_align = 0;\n+\t      scan = emit_insn_after (gen_align_4 (), scan);\n+\t    }\n+\t  scan = emit_label_after (p->label, scan);\n+\t  scan = emit_insn_after (gen_consttable_8 (p->value), scan);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t  break;\n \t}\n     }\n-  while (active[next]);\n-}\n-\n-void\n-expand_block_move (dest_mem, src_mem, operands)\n-     rtx dest_mem;\n-     rtx src_mem;\n-     rtx *operands;\n-{\n-  int align = INTVAL (operands[3]);\n-  int constp = (GET_CODE (operands[2]) == CONST_INT);\n-  int bytes = (constp ? INTVAL (operands[2]) : 0);\n \n-#if 0\n-  if (constp && bytes <= 0)\n-    return;\n+  scan = emit_insn_after (gen_consttable_end (), scan);\n+  scan = emit_barrier_after (scan);\n+  pool_size = 0;\n+}\n \n-  if (align > 4)\n-    align = 4;\n \n-  if (constp && bytes <= 3 * align)\n-    block_move_sequence (operands[0], dest_mem, operands[1], src_mem,\n-\t\t\t bytes, align, 0);\n \n-#if 0\n-  else if (constp && bytes <= best_from_align[target][align])\n-    block_move_no_loop (operands[0], dest_mem, operands[1], src_mem,\n-\t\t\tbytes, align);\n+/* Non zero if the src operand needs to be fixed up */\n+static\n+int\n+fixit (src, mode)\n+     rtx src;\n+     enum machine_mode mode;\n+{\n+  if (mode == QImode)\n+    return 0;\t\t\t/* QIs never need to be fixed */\n+  if (GET_CODE (src) == CONST)\n+    return 1;\n \n-  else if (constp && align == 4 && TARGET_88100)\n-    block_move_loop (operands[0], dest_mem, operands[1], src_mem,\n-\t\t     bytes, align);\n-#endif\n-  else\n-#endif\n+  if (GET_CODE (src) == SYMBOL_REF)\n     {\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n-\t\t\t VOIDmode, 3,\n-\t\t\t operands[0], Pmode,\n-\t\t\t operands[1], Pmode,\n-\t\t\t operands[2], SImode);\n+      return 1;\n+    }\n+  if (GET_CODE (src) == CONST_INT)\n+    {\n+      /* All QI insns are ok */\n+      if (mode == QImode)\n+\treturn 1;\n+      /* The rest may need to be fixed */\n+      return !CONST_OK_FOR_I (INTVAL (src));\n     }\n+  return 0;\n }\n \n-\n-override_options ()\n+/* Return Non-zero if constant would be an ok source for a\n+   mov.w instead of a mov.l */\n+int\n+hi_const (src)\n+     rtx src;\n {\n-  sh_cpu = CPU_SH0;\n-  if (TARGET_SH1)\n-    sh_cpu = CPU_SH1;\n-  if (TARGET_SH2)\n-    sh_cpu = CPU_SH2;\n-  if (TARGET_SH3)\n-    sh_cpu = CPU_SH3;\n+  return (GET_CODE (src) == CONST_INT\n+\t  && INTVAL (src) >= -32768\n+\t  && INTVAL (src) <= 32767);\n }\n-\f\n-\n-/* Stuff taken from m88k.c */\n \n-/* Output to FILE the start of the assembler file.  */\n+/* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.\n+   If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from that one. */\n \n-struct option\n+static\n+rtx\n+find_barrier (from)\n+     rtx from;\n {\n-  char *string;\n-  int *variable;\n-  int on_value;\n-};\n+  int count_si = 0;\n+  int count_hi = 0;\n+  int found_hi = 0;\n+  int found_si = 0;\n+  rtx found_barrier = 0;\n+\n+  while (from\n+\t && count_si < max_count_si\n+\t && count_hi < max_count_hi)\n+    {\n+      int inc;\n+      if (GET_CODE (from) == BARRIER)\n+\t{\n+\t  found_barrier = from;\n+\t}\n+      /* Count the length of this insn - we assume that all the pcrelloads\n+         will work out to be only 2 bytes long */\n \n-static int\n-output_option (file, sep, type, name, indent, pos, max)\n-     FILE *file;\n-     char *sep;\n-     char *type;\n-     char *name;\n-     char *indent;\n-     int pos;\n-     int max;\n-{\n-  if (strlen (sep) + strlen (type) + strlen (name) + pos > max)\n+      if (GET_CODE (from) == INSN &&\n+\t  GET_CODE (PATTERN (from)) == SET)\n+\t{\n+\t  rtx src = SET_SRC (PATTERN (from));\n+\t  if (hi_const (src))\n+\t    found_hi = 1;\n+\t  else\n+\t    found_si = 1;\n+\t  inc = 2;\n+\t}\n+      else\n+\t{\n+\t  inc = get_attr_length (from);\n+\t}\n+      if (found_si)\n+\tcount_si += inc;\n+      if (found_hi)\n+\tcount_hi += inc;\n+      from = NEXT_INSN (from);\n+    }\n+\n+  if (!found_barrier)\n     {\n-      fprintf (file, indent);\n-      return fprintf (file, \"%s%s\", type, name);\n+      /* Insert a jump around the barrier here */\n+      rtx label = gen_label_rtx ();\n+      /* Walk back to be just before any jump */\n+      while (GET_CODE (from) == JUMP_INSN\n+\t     || GET_CODE (from) == NOTE)\n+\t{\n+\t  from = PREV_INSN (from);\n+\t}\n+      from = emit_jump_insn_after (gen_jump (label), from);\n+      JUMP_LABEL (from) = label;\n+      found_barrier = emit_barrier_after (from);\n+      emit_label_after (label, found_barrier);\n+      return found_barrier;\n     }\n-  return pos + fprintf (file, \"%s%s%s\", sep, type, name);\n+  return found_barrier;\n }\n \n-static struct\n-  {\n-    char *name;\n-    int value;\n-  }\n-\n-m_options[] = TARGET_SWITCHES;\n+/* Non zero if the insn is a move instruction which needs to be fixed. */\n \n-static void\n-output_options (file, f_options, f_len, W_options, W_len,\n-\t\tpos, max, sep, indent, term)\n-     FILE *file;\n-     struct option *f_options;\n-     struct option *W_options;\n-     int f_len, W_len;\n-     int pos;\n-     int max;\n-     char *sep;\n-     char *indent;\n-     char *term;\n+static\n+int\n+broken_move (insn)\n+     rtx insn;\n {\n-  register int j;\n-\n-\n-  if (optimize)\n-    pos = output_option (file, sep, \"-O\", \"\", indent, pos, max);\n-  if (write_symbols != NO_DEBUG)\n-    pos = output_option (file, sep, \"-g\", \"\", indent, pos, max);\n-  if (flag_traditional)\n-    pos = output_option (file, sep, \"-traditional\", \"\", indent, pos, max);\n-  if (profile_flag)\n-    pos = output_option (file, sep, \"-p\", \"\", indent, pos, max);\n-  if (profile_block_flag)\n-    pos = output_option (file, sep, \"-a\", \"\", indent, pos, max);\n+  if (!INSN_DELETED_P (insn)\n+      && GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == SET)\n+    {\n+      rtx pat = PATTERN (insn);\n+      rtx src = SET_SRC (pat);\n+      rtx dst = SET_DEST (pat);\n+      enum machine_mode mode = GET_MODE (dst);\n+      if (dst == pc_rtx)\n+\treturn 0;\n+      return fixit (src, mode);\n+    }\n+  return 0;\n+}\n \n-  for (j = 0; j < f_len; j++)\n-    if (*f_options[j].variable == f_options[j].on_value)\n-      pos = output_option (file, sep, \"-f\", f_options[j].string,\n-\t\t\t   indent, pos, max);\n \n-  for (j = 0; j < W_len; j++)\n-    if (*W_options[j].variable == W_options[j].on_value)\n-      pos = output_option (file, sep, \"-W\", W_options[j].string,\n-\t\t\t   indent, pos, max);\n+/* Exported to toplev.c\n \n-  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n-    if (m_options[j].name[0] != '\\0'\n-\t&& m_options[j].value > 0\n-\t&& ((m_options[j].value & target_flags)\n-\t    == m_options[j].value))\n-      pos = output_option (file, sep, \"-m\", m_options[j].name,\n-\t\t\t   indent, pos, max);\n+   Scan the function looking for move instructions which have to be changed to\n+   pcrel loads and insert the literal tables. */\n \n+void\n+machine_dependent_reorg (first)\n+     rtx first;\n+{\n+  rtx insn;\n+  int limit;\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (broken_move (insn))\n+\t{\n+\t  /* This is a broken move instruction, scan ahead looking for\n+\t     a barrier to stick the constant table behind */\n+\t  rtx scan;\n+\t  rtx barrier = find_barrier (insn);\n \n-  fprintf (file, term);\n+\t  /* Now find all the moves between the points and modify them */\n+\t  for (scan = insn; scan != barrier; scan = NEXT_INSN (scan))\n+\t    {\n+\t      if (broken_move (scan))\n+\t\t{\n+\t\t  rtx pat = PATTERN (scan);\n+\t\t  rtx src = SET_SRC (pat);\n+\t\t  rtx dst = SET_DEST (pat);\n+\t\t  enum machine_mode mode = GET_MODE (dst);\n+\t\t  rtx lab;\n+\t\t  rtx newinsn;\n+\t\t  rtx newsrc;\n+\t\t  /* This is a broken move instruction, add it to the pool */\n+\n+\t\t  if (mode == SImode && hi_const (src))\n+\t\t    {\n+\t\t      /* This is an HI source, clobber the dest to get the mode right too */\n+\t\t      mode = HImode;\n+\t\t      dst = gen_rtx (REG, HImode, REGNO (dst));\n+\t\t    }\n+\t\t  lab = add_constant (src, mode);\n+\t\t  newsrc = gen_rtx (MEM, mode,\n+\t\t\t\t    gen_rtx (LABEL_REF, VOIDmode, lab));\n+\n+\t\t  /* Build a jump insn wrapper around the move instead\n+\t\t     of an ordinary insn, because we want to have room for\n+\t\t     the target label rtx in fld[7], which an ordinary\n+\t\t     insn doesn't have. */\n+\t\t  newinsn = emit_jump_insn_after (gen_rtx (SET, VOIDmode,\n+\t\t\t\t\t\t\tdst, newsrc), scan);\n+\t\t  JUMP_LABEL (newinsn) = lab;\n+\n+\t\t  /* But it's still an ordinary insn */\n+\t\t  PUT_CODE (newinsn, INSN);\n+\n+\t\t  /* Kill old insn */\n+\t\t  delete_insn (scan);\n+\t\t  scan = newinsn;\n+\t\t}\n+\t    }\n+\t  dump_table (barrier);\n+\t}\n+    }\n }\n \n-void\n-output_file_start (file, f_options, f_len, W_options, W_len)\n-     FILE *file;\n-     struct option *f_options;\n-     struct option *W_options;\n-     int f_len, W_len;\n+/* Called from the md file, set up the operands of a compare instruction */\n+\n+int\n+from_compare (operands, code)\n+     rtx *operands;\n+     int code;\n {\n-  register int pos;\n+  operands[1] = sh_compare_op0;\n+  operands[2] = force_reg (SImode, sh_compare_op1);\n+  operands[1] = force_reg (SImode, operands[1]);\n+}\n \n-  output_file_directive (file, main_input_filename);\n+/* Non-zero if x is EQ or NE */\n \n-  /* Switch to the data section so that the coffsem symbol and the\n-     gcc2_compiled. symbol aren't in the text section.  */\n-  data_section ();\n+int\n+equality_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (x);\n+  return (code == EQ || code == NE);\n+}\n \n \n-  pos = fprintf (file, \"\\n! Hitachi SH cc1 (%s) arguments:\", version_string);\n-  output_options (file, f_options, f_len, W_options, W_len,\n-\t\t  pos, 75, \" \", \"\\n! \", \"\\n\\n\");\n-}\n-\f\n+/* Framefull frame looks like:\n+\n+   arg-5\n+   arg-4\n+   [ if current_function_anonymous_args\n+   arg-3\n+   arg-2\n+   arg-1\n+   arg-0 ]\n+   saved-fp\n+   saved-r10\n+   saved-r11\n+   saved-r12\n+   saved-pr\n+   local-n\n+   ..\n+   local-1\n+   local-0        <- fp points here\n+\n+\n+   If TARGET_SMALLCALL, then the preserved registers are pushed by a\n+   wrapper before the routine is entered, so the regs are always pushed\n+   and there are two pr's on the stack - the caller and the wrapper.\n+ */\n+\n \n /* Code to generate prologue and epilogue sequences */\n \n+\n void\n sh_expand_prologue ()\n {\n@@ -1537,7 +1916,9 @@ sh_expand_prologue ()\n \n   live_regs_mask = calc_live_regs (&d);\n \n-  output_stack_adjust (-1, current_function_pretend_args_size);\n+  /* We have pretend args if we had an object sent partially in registers\n+     and partially on the stack - eg a large structure */\n+  output_stack_adjust (-current_function_pretend_args_size);\n \n   if (current_function_anonymous_args)\n     {\n@@ -1549,22 +1930,16 @@ sh_expand_prologue ()\n \t  if (i > NPARM_REGS - current_function_args_info)\n \t    break;\n \t  push (rn);\n-\n \t  extra_push += 4;\n \t}\n     }\n+  push_regs (live_regs_mask);\n+  output_stack_adjust (-get_frame_size ());\n \n   if (frame_pointer_needed)\n     {\n-      push_regs (live_regs_mask);\n       emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n     }\n-  else\n-    {\n-      push_regs (live_regs_mask);\n-    }\n-\n-  output_stack_adjust (-1, get_frame_size ());\n }\n \n void\n@@ -1580,13 +1955,10 @@ sh_expand_epilogue ()\n     {\n       emit_insn (gen_movsi (stack_pointer_rtx, frame_pointer_rtx));\n     }\n-  else\n-    {\n-      output_stack_adjust (1, get_frame_size ());\n-    }\n-\n+  output_stack_adjust (get_frame_size ());\n \n   /* Pop all the registers */\n+\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n@@ -1595,43 +1967,285 @@ sh_expand_epilogue ()\n \t  pop (j);\n \t}\n     }\n-  output_stack_adjust (1, extra_push +\n-\t\t       current_function_pretend_args_size);\n \n-  extra_push = 0;\n+  output_stack_adjust (extra_push + current_function_pretend_args_size);\n \n+  extra_push = 0;\n+  current_function_pretend_args_size = 0;\n   current_function_anonymous_args = 0;\n+  for (i = 0; i < 32; i++)\n+    shiftsyms[i] = 0;\n }\n \n+/* Define the offset between two registers, one to be eliminated, and\n+   the other its replacement, at the start of a routine.  */\n+\n+int\n+initial_elimination_offset (from, to)\n+{\n+  int regs_saved;\n+  int regs_saved_mask = calc_live_regs (&regs_saved);\n+  int total_saved_regs_space;\n+  int total_auto_space = get_frame_size ();\n+  total_saved_regs_space = (regs_saved) * 4;\n \n-/* Return the cost of a shift */\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    {\n+      return total_saved_regs_space + total_auto_space;\n+    }\n+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    {\n+      return total_saved_regs_space + total_auto_space;\n+    }\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    {\n+      /* Initial gap between fp and sp is 0 */\n+      return 0;\n+    }\n+  abort ();\n+}\n+\n+/* Handle machine specific pragmas to be semi-compatible with Hitachi\n+   compiler  */\n \n int\n-shiftcosts (RTX)\n-     rtx RTX;\n+handle_pragma (file)\n+     FILE *file;\n {\n-  /* If shift by a non constant, then this will be expensive. */\n-  if (GET_CODE (XEXP (RTX, 1)) != CONST_INT)\n-    return 20;\n+  int c;\n+  char pbuf[200];\n+  int psize = 0;\n \n-  /* otherwise, it will be very cheap if by one of the constants\n-     we can cope with. */\n-  if (CONST_OK_FOR_K (INTVAL (XEXP (RTX, 1))))\n+  c = getc (file);\n+  while (c == ' ' || c == '\\t')\n+    c = getc (file);\n+\n+  if (c == '\\n' || c == EOF)\n+    return c;\n+\n+  while (psize < sizeof (pbuf) - 1 && c != '\\n')\n+    {\n+      pbuf[psize++] = c;\n+      if (psize == 9 && strncmp (pbuf, \"interrupt\", 9) == 0)\n+\t{\n+\t  pragma_interrupt = 1;\n+\t  return;\n+\t}\n+      if (psize == 5 && strncmp (pbuf, \"trapa\", 5) == 0)\n+\t{\n+\t  pragma_interrupt = pragma_trapa = 1;\n+\t  return;\n+\t}\n+      c = getc (file);\n+    }\n+  return c;\n+}\n+\f\n+/* insn expand helpers */\n+\n+/* Emit insns to perform a call.  If TARGET_SMALLCALL, then load the\n+   target address into r1 and call __saveargs, otherwise\n+   perform the standard call sequence */\n+\n+void\n+expand_acall (isa_retval, operands)\n+     int isa_retval;\n+     rtx *operands;\n+{\n+  rtx call;\n+  rtx ret = operands[0];\n+  rtx call_target = operands[isa_retval + 0];\n+  rtx numargs = operands[isa_retval + 1];\n+\n+  if (GET_CODE (call_target) == MEM)\n+    {\n+      call_target = force_reg (Pmode,\n+\t\t\t       XEXP (call_target, 0));\n+    }\n+  if (TARGET_SMALLCALL)\n+    {\n+      rtx tmp = gen_reg_rtx (SImode);\n+      rtx r1 = gen_rtx (REG, SImode, 1);\n+      emit_move_insn (tmp, gen_rtx (SYMBOL_REF, SImode, \"__saveargs\"));\n+      emit_move_insn (r1, call_target);\n+      emit_insn (gen_rtx (USE, VOIDmode, r1));\n+      call_target = tmp;\n+    }\n+\n+  call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n+\n+  if (isa_retval)\n+    {\n+      call = gen_rtx (SET, VOIDmode, ret, call);\n+    }\n+\n+  emit_call_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\t   gen_rtvec (2,\n+\t\t\t\t      call,\n+\t\t  gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, SImode, 17)))));\n+\n+}\n+\f\n+\n+/* Predicates used by the templates */\n+\n+\n+/* Returns 1 if OP can be source of a simple move operation.\n+   Same as general_operand, but a LABEL_REF is valid, PRE_DEC is\n+   invalid as are subregs of system registers. */\n+\n+int\n+general_movsrc_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  /* Any MEM(label_ref) is ok, that's a pcrel load */\n+  if (GET_CODE (op) == MEM &&\n+      GET_CODE (XEXP (op, 0)) == LABEL_REF)\n     return 1;\n \n-  /* otherwise it will be several insns. */\n-  return 4;\n+  /* No predec allowed */\n+\n+  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == PRE_DEC)\n+    return 0;\n+\n+  if ((mode == QImode || mode == HImode)\n+      && (GET_CODE (op) == SUBREG\n+\t  && GET_CODE (XEXP (op, 0)) == REG\n+\t  && system_reg_operand (XEXP (op, 0), mode)))\n+    return 0;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      int i = INTVAL (op);\n+      return CONST_OK_FOR_I (i);\n+    }\n+  return general_operand (op, mode);\n }\n \n-/* Return the cost of a multiply */\n+\n+/* Returns 1 if OP can be a destination of a move.\n+   Same as general_operand, but no preinc allowed.  */\n+\n int\n-multcosts (RTX)\n-     rtx RTX;\n+general_movdst_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n {\n-  /* If we we're aiming at small code, then just count the number of\n-     insns in a multiply call sequence, otherwise, count all the insnsn\n-     inside the call. */\n-  if (TARGET_SMALLCODE)\n-    return 3;\n-  return 30;\n+  if (GET_CODE (op) == MEM\n+      && GET_CODE (XEXP (op, 0)) == PRE_INC)\n+    return 0;\n+  return general_operand (op, mode);\n+}\n+\n+\n+/* Returns 1 if OP is an immediate ok for a byte index.  */\n+\n+int\n+byte_index_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == CONST_INT\n+\t  && INTVAL (op) >= 0\n+\t  && INTVAL (op) <= 15);\n+}\n+\n+/* Returns 1 if OP is a pop operand.   */\n+\n+int\n+pop_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+\n+  op = XEXP (op, 0);\n+\n+  if (GET_CODE (op) != POST_INC)\n+    return 0;\n+\n+  return XEXP (op, 0) == stack_pointer_rtx;\n+}\n+\n+\n+/* Returns 1 if OP is a normal arithmetic register.  */\n+\n+int\n+arith_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    {\n+      if (GET_CODE (op) == REG)\n+\treturn (REGNO (op) != T_REG\n+\t\t&& REGNO (op) != PR_REG);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Returns 1 if OP is MACL, MACH or PR.  */\n+\n+int\n+system_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == REG)\n+    {\n+      switch (REGNO (op))\n+\t{\n+\tcase PR_REG:\n+\tcase MACL_REG:\n+\tcase MACH_REG:\n+\t  return 1;\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+/* Returns 1 if OP is a valid source operand for an arithmetic insn.  */\n+\n+int\n+arith_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (arith_reg_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (CONST_OK_FOR_I (INTVAL (op)))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Returns 1 if OP is a valid source operand for a logical operation. */\n+\n+int\n+logical_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (arith_reg_operand (op, mode))\n+    return 1;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      if (CONST_OK_FOR_L (INTVAL (op)))\n+\treturn 1;\n+    }\n+  return 0;\n }\n+"}, {"sha": "74094f1418b2b907955c679224d8892872aecb3d", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 336, "deletions": 158, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7e008e87f916fe7ff510696ec4fabbcad43925/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7e008e87f916fe7ff510696ec4fabbcad43925/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=0d7e008e87f916fe7ff510696ec4fabbcad43925", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for Hitachi Super-H.\n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n \n    Contributed by Steve Chamberlain (sac@cygnus.com)\n \n@@ -36,24 +36,48 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP\n+\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n+  /* Experimental calling convention with fewer saved registers */\t\\\n+  if (TARGET_NOSAVE)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      call_used_regs[8] = 1;\t\t\t\t\t\\\n+      call_used_regs[9] = 1;\t\t\t\t\t\\\n+      call_used_regs[10] = 1;\t\t\t\t\t\\\n+      call_used_regs[11] = 1;\t\t\t\t\t\\\n+    }    \t\t\t\t\t\t\t\\\n+  /* Hitachi saves and restores mac registers on call */        \\\n+  if (TARGET_HITACHI)\t\t\t\t\t\t\\\n+   {\t\t\t\t\t\t\t\t\\\n+     call_used_regs[MACH_REG] = 0;\t\t\t\t\\\n+     call_used_regs[MACL_REG] = 0;\t\t\t\t\\\n+  }\t\t\t\t\t\n+\n \f\n /* Run-time compilation parameters selecting different hardware subsets. */\n \n extern int target_flags;\n-#define ISIZE_BIT  1\n-#define FAST_BIT   2\n-\n-#define MAC_BIT    8\n-#define RTL_BIT    16\n-#define DT_BIT     32\n-#define DALIGN_BIT 64\n-#define SH0_BIT\t128\n-#define SH1_BIT\t256\n-#define SH2_BIT\t512\n-#define SH3_BIT\t1024\n-#define C_BIT\t2048\n-#define R_BIT     (1<<12)\n-#define SPACE_BIT (1<<13)\n+#define ISIZE_BIT      \t(1<<1)\n+#define FAST_BIT       \t(1<<2)\n+#define MAC_BIT        \t(1<<3)\n+#define RTL_BIT        \t(1<<4)\n+#define DT_BIT         \t(1<<5)\n+#define DALIGN_BIT     \t(1<<6)\n+#define SH0_BIT\t       \t(1<<7)\n+#define SH1_BIT\t       \t(1<<8)\n+#define SH2_BIT\t       \t(1<<9)\n+#define SH3_BIT\t       \t(1<<10)\n+#define C_BIT\t       \t(1<<11)\n+#define R_BIT     \t(1<<12)\n+#define SPACE_BIT \t(1<<13)\n+#define BIGTABLE_BIT  \t(1<<14)\n+#define TRYR0_BIT  \t(1<<15)\n+#define NOSAVE_BIT  \t(1<<16)\n+#define SMALLCALL_BIT  \t(1<<17)\n+#define CONSTLEN_2_BIT  (1<<20)\n+#define CONSTLEN_3_BIT  (1<<21)\n+#define HITACHI_BIT     (1<<22)\n \n /* Nonzero if we should generate code using type 0 insns */\n #define TARGET_SH0 (target_flags & SH0_BIT)\n@@ -88,28 +112,81 @@ extern int target_flags;\n /* Nonzero to align doubles on 64 bit boundaries */\n #define TARGET_ALIGN_DOUBLE (target_flags & DALIGN_BIT)\n \n+/* Nonzero to use long jump tables */\n+#define TARGET_BIGTABLE     (target_flags & BIGTABLE_BIT)\n \n-/* Nonzero if Combine dumping wanted */\n+/* Nonzero if combine dumping wanted */\n #define TARGET_CDUMP (target_flags & C_BIT)\n \n-#define TARGET_SWITCHES  \t\\\n-{ {\"isize\", \t( ISIZE_BIT)  },\\\n-  {\"space\", \t( SPACE_BIT)   },\\\n-  {\"0\",\t        ( SH0_BIT) },\\\n-  {\"1\",\t        ( SH1_BIT) },\\\n-  {\"2\",\t        ( SH2_BIT) },\\\n-  {\"3\",\t        ( SH3_BIT) },\\\n-  {\"ac\",  \t( MAC_BIT)    },\\\n-  {\"dalign\",  \t( DALIGN_BIT) },\\\n-  {\"c\",  \t( C_BIT) },\\\n-  {\"r\",  \t( RTL_BIT) },\\\n-  {\"R\",  \t( R_BIT) },\\\n-  {\"\",   \tTARGET_DEFAULT} \\\n+/* Nonzero if trying to use reg+disp for QIs and HIs.  This\n+   doesn't work yet.*/\n+#define TARGET_TRYR0 (target_flags & TRYR0_BIT)\n+\n+/* Nonzero if using no save calling convention */\n+#define TARGET_NOSAVE (target_flags & NOSAVE_BIT)\n+\n+/* Nonzero if using no save calling convention */\n+#define TARGET_SMALLCALL (target_flags & SMALLCALL_BIT)\n+\n+/* Select max size of computed constant code sequences to be 3 insns */\n+#define TARGET_CLEN3 (target_flags & CONSTLEN_3_BIT)\n+\n+/* Nonzero if using Hitachi's calling convention */\n+#define TARGET_HITACHI (target_flags & HITACHI_BIT)\n+\n+#define TARGET_SWITCHES  \t\t\\\n+{ {\"isize\", \t( ISIZE_BIT) },\t\t\\\n+  {\"space\", \t( SPACE_BIT) },\t\t\\\n+  {\"0\",\t        ( SH0_BIT) },\t\t\\\n+  {\"1\",\t        ( SH1_BIT) },\t\t\\\n+  {\"2\",\t        ( SH2_BIT) },\t\t\\\n+  {\"3\",\t        ( SH3_BIT) },\t\t\\\n+  {\"ac\",  \t( MAC_BIT) },\t\t\\\n+  {\"dalign\",  \t( DALIGN_BIT) },\t\\\n+  {\"c\",  \t( C_BIT) },\t\t\\\n+  {\"r\",  \t( RTL_BIT) },\t\t\\\n+  {\"bigtable\", \t( BIGTABLE_BIT)},\t\\\n+  {\"try-r0\", \t( TRYR0_BIT)},\t\t\\\n+  {\"R\",  \t( R_BIT) },\t\t\\\n+  {\"nosave\",  \t( NOSAVE_BIT) },\t\\\n+  {\"clen3\",     ( CONSTLEN_3_BIT) },    \\\n+  {\"smallcall\",\t( SMALLCALL_BIT) },\t\\\n+  {\"hitachi\",\t( HITACHI_BIT) },\t\\\n+  {\"\",   \tTARGET_DEFAULT} \t\\\n }\n \n-#define TARGET_DEFAULT  FAST_BIT\n-\n-#define OVERRIDE_OPTIONS override_options();\n+#define TARGET_DEFAULT  (FAST_BIT)\n+\n+/* Macro to define table for command options with values.  */\n+#define TARGET_OPTIONS \\\n+\t{ { \"maxsi-\", &max_si}, \\\n+\t  { \"maxhi-\", &max_hi} }\n+\n+#define OVERRIDE_OPTIONS \t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  sh_cpu = CPU_SH0;\t\t\t\t\t\t\\\n+  if (TARGET_SH1)\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH1;\t\t\t\t\t\t\\\n+  if (TARGET_SH2)\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH2;\t\t\t\t\t\t\\\n+  if (TARGET_SH3)\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH3;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  /*  We *MUST* always define optimize since we *HAVE* to run   \\\n+      shorten branches to get correct code. */                  \\\n+                                                                \\\n+  optimize = 1;                                                 \\\n+  flag_delayed_branch = 1;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (max_si)\t\t\t\t\t\t\t\\\n+    max_count_si = atoi (max_si);\t\t\t\t\\\n+  else                                                          \\\n+    max_count_si = 1010;                                        \\\n+  if (max_hi)\t\t\t\t\t\t\t\\\n+    max_count_hi = atoi (max_hi);\t\t\t\t\\\n+  else      \t\t\t\t\t\t\t\\\n+    max_count_hi = 505;\t\t\t\t                \\\n+} while (0)\n \n \f\n /* Target machine storage Layout.  */\n@@ -171,7 +248,7 @@ extern int target_flags;\n #define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n   ((TREE_CODE (EXP) == STRING_CST\t\\\n     && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n-   ? FASTEST_ALIGNMENT : (ALIGN))\n+    ? FASTEST_ALIGNMENT : (ALIGN))\n \n /* Make arrays of chars word-aligned for the same reasons.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n@@ -186,13 +263,13 @@ extern int target_flags;\n \f\n /* Standard register usage.  */\n \n-/* Register allocation for our first guess \n+/* Register allocation for the Hitachi calling convention:\n \n-\tr0-r3\t\tscratch\n-\tr4-r7\t\targs in and out\n-\tr8-r12\t\tcall saved\n-\tr13\t\tassembler temp\n-\tr14\t\tframe pointer\n+        r0\t\targ return\n+\tr1..r3          scratch\n+\tr4-r7\t\targs in\n+\tr8..r13\t\tcall saved\n+\tr14\t\tframe pointer/call saved\n \tr15\t\tstack pointer\n \tap\t\targ pointer (doesn't really exist, always eliminated)\n \tpr\t\tsubroutine return address\n@@ -207,23 +284,33 @@ extern int target_flags;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.\n \n-   SH has 16 integer registers and 4 control registers + the arg\n-   pointer */\n-\n-#define FIRST_PSEUDO_REGISTER 22\n+*/\n \n+#define AP_REG   16  \n #define PR_REG   17\n #define T_REG    18\n #define GBR_REG  19\n #define MACH_REG 20\n #define MACL_REG 21\n \n+#define FIRST_PSEUDO_REGISTER 22\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n- /*  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh   ml */\n-#define FIXED_REGISTERS  \\\n-   { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1, 1,   1}\n+ /*  r0  r1  r2  r3 \n+     r4  r5  r6  r7\n+     r8  r9  r10 r11\n+     r12 r13 r14 r15\n+     ap  pr  t   gbr\n+     mh   ml */\n+\n+#define FIXED_REGISTERS  \t\\\n+  { 0,  0,  0,  0, \t\t\\\n+    0,  0,  0,  0, \t\t\\\n+    0,  0,  0,  0, \t\t\\\n+    0,  0,  0,  1, \t\t\\\n+    1,  1,  1,  1, \t\t\\\n+    1,  1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -232,24 +319,37 @@ extern int target_flags;\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n \n- /*  r0  r1  r2  r3  r4  r5  r6  r7  r8 r9  r10 r11 r12 r13 r14 r15 ap  pr  t   gbr mh  ml */\n-#define CALL_USED_REGISTERS \\\n-   { 1,  1,  1,  1,  1,  1,  1,  1,  0, 0,  0,  0,  0,  1,  0,  1,  1,  0,  1,  1, 1, 1}\n+ /*  r0  r1  r2  r3  \n+     r4  r5  r6  r7 \n+     r8  r9  r10 r11\n+     r12 r13 r14 r15\n+     ap  pr  t   gbr \n+     mh  ml */\n+\n+#define CALL_USED_REGISTERS \t\\\n+   { 1,  1,  1,  1,\t\t\\\n+     1,  1,  1,  1, \t\t\\\n+     0,  0,  0,  0,\t\t\\\n+     0,  0,  0,  1,\t\t\\\n+     1,  0,  1,  1,\t\t\\\n+     1,  1}\t\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n    On the SH regs are UNITS_PER_WORD bits wide; */\n+\n #define HARD_REGNO_NREGS(REGNO, MODE)  \\\n    (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    We may keep double values in even registers */\n \n+extern int hard_regno_mode_ok[];\n #define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n-  ((TARGET_ALIGN_DOUBLE && GET_MODE_SIZE(MODE) > 4) ? (((REGNO)&1)==0) : 1)\n+  (hard_regno_mode_ok[REGNO] & (1<<(int)MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -275,8 +375,7 @@ extern int target_flags;\n    Zero means the frame pointer need not be set up (and parms may be accessed\n    via the stack pointer) in functions that seem suitable.  */\n \n-\n-#define FRAME_POINTER_REQUIRED\t(get_frame_size() > 1000)\n+#define FRAME_POINTER_REQUIRED\t0\n \n /* Definitions for register eliminations.\n \n@@ -290,11 +389,17 @@ extern int target_flags;\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.  */\n \n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+\n #define ELIMINABLE_REGS\t\t\t\t\\\n {{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n  { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\\\n  { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},}\n \n+\n /* Given FROM and TO register numbers, say whether this elimination\n    is allowed.  */\n #define CAN_ELIMINATE(FROM, TO) \\\n@@ -314,9 +419,21 @@ extern int target_flags;\n \n /* The register in which a struct value address is passed */\n \n-#define STRUCT_VALUE_REGNUM 3\n+#define STRUCT_VALUE_REGNUM 2\n+\n+/* If the structure value address is not passed in a register, define\n+   `STRUCT_VALUE' as an expression returning an RTX for the place\n+   where the address is passed.  If it returns 0, the address is\n+   passed as an \"invisible\" first argument.  */\n+\n+/*#define STRUCT_VALUE ((rtx)0)*/\n \n \n+/* Don't default to pcc-struct-return, because we have already specified\n+   exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n+\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n \f\n /* Define the classes of registers for register constraints in the\n    machine description.  Also define ranges of constants.\n@@ -347,10 +464,10 @@ enum reg_class\n {\n   NO_REGS,\n   R0_REGS,\n-  GENERAL_REGS,\n   PR_REGS,\n   T_REGS,\n   MAC_REGS,\n+  GENERAL_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -362,10 +479,10 @@ enum reg_class\n {\t\t\t\\\n   \"NO_REGS\",\t\t\\\n   \"R0_REGS\",\t\t\\\n-  \"GENERAL_REGS\",\t\\\n   \"PR_REGS\",\t\t\\\n   \"T_REGS\",\t\t\\\n   \"MAC_REGS\",\t\t\\\n+  \"GENERAL_REGS\",\t\\\n   \"ALL_REGS\",\t\t\\\n }\n \n@@ -377,10 +494,10 @@ enum reg_class\n {\t\t\t\t\\\n   0x000000,  /* NO_REGS      */\t\\\n   0x000001,  /* R0_REGS      */\t\\\n-  0x01FFFF,  /* GENERAL_REGS */\t\\\n   0x020000,  /* PR_REGS      */\t\\\n   0x040000,  /* T_REGS       */\t\\\n   0x300000,  /* MAC_REGS     */\t\\\n+  0x01FFFF,  /* GENERAL_REGS */\t\\\n   0x37FFFF   /* ALL_REGS     */\t\\\n }\n \n@@ -392,9 +509,15 @@ enum reg_class\n extern int regno_reg_class[];\n #define REGNO_REG_CLASS(REGNO) regno_reg_class[REGNO]\n \n+/* When defined, the compiler allows registers explicitly used in the\n+   rtl to be used as spill registers but prevents the compiler from\n+   extending the lifetime of these registers. */\n+\n+#define SMALL_REGISTER_CLASSES\n+\n /* The order in which register should be allocated.  */\n #define REG_ALLOC_ORDER  \\\n-  { 1,2,3,7,4,5,6,0,8,9,10,11,12,13,14,15,16,17,18,19,20,21}\n+  { 1,2,3,7,6,5,4,0,8,9,10,11,12,13,14,15,16,17,18,19,20,21 }\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS  R0_REGS\n@@ -415,20 +538,22 @@ extern enum reg_class reg_class_from_letter[];\n    Return 1 if VALUE is in the range specified by C.\n \tI: arithmetic operand -127..128, as used in add, sub, etc\n \tL: logical operand 0..255, as used in and, or, etc.\n+\tJ: something ok as a move source - so it must be easy to make\n \tM: constant 1\n+\tN: constant 0\n \tK: shift operand 1,2,8 or 16 */\n \n \n #define CONST_OK_FOR_I(VALUE) (((int)(VALUE))>= -128 && ((int)(VALUE)) <= 127)\n #define CONST_OK_FOR_L(VALUE) (((int)(VALUE))>=    0 && ((int)(VALUE)) <= 255)\n #define CONST_OK_FOR_M(VALUE) ((VALUE)==1)\n+#define CONST_OK_FOR_N(VALUE) ((VALUE)==0)\n #define CONST_OK_FOR_K(VALUE) ((VALUE)==1||(VALUE)==2||(VALUE)==8||(VALUE)==16)\n-\n #define CONST_OK_FOR_LETTER_P(VALUE, C)     \\\n      ((C) == 'I' ? CONST_OK_FOR_I (VALUE)   \\\n+    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)   \\\n     : (C) == 'L' ? CONST_OK_FOR_L (VALUE)   \\\n     : (C) == 'M' ? CONST_OK_FOR_M (VALUE)   \\\n-    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)   \\\n     : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n@@ -444,13 +569,12 @@ extern enum reg_class reg_class_from_letter[];\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.  */\n \n-#define PREFERRED_RELOAD_CLASS(X, CLASS)  CLASS\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) CLASS\n \n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n \n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) NO_REGS\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS. \n@@ -459,29 +583,29 @@ extern enum reg_class reg_class_from_letter[];\n #define CLASS_MAX_NREGS(CLASS, MODE)  \\\n      ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n+\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n /* Define the number of register that can hold parameters.\n    These two macros are used only in other macro definitions below.  */\n #define NPARM_REGS 4\n #define FIRST_PARM_REG 4\n-#define FIRST_RET_REG 4\n+#define FIRST_RET_REG 0\n \n /* Define this if pushing a word on the stack\n    makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD  \n \n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD \n+/*  Define this macro if the addresses of local variable slots are at\n+    negative offsets from the frame pointer.\n \n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n+    The SH only has positive indexes, so grow the frame up \n+*/\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset from the frame pointer to the first local variable slot to\n+   be allocated. */\n #define STARTING_FRAME_OFFSET  0\n \n /* If we generate an insn to push BYTES bytes,\n@@ -505,16 +629,19 @@ extern enum reg_class reg_class_from_letter[];\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n    otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-    gen_rtx (REG, TYPE_MODE (VALTYPE), FIRST_RET_REG)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  gen_rtx (REG, \\\n+\t   TYPE_MODE (VALTYPE) == BLKmode ? SImode : TYPE_MODE (VALTYPE), \\\n+\t   FIRST_RET_REG)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE)  \\\n     gen_rtx (REG, MODE, FIRST_RET_REG)\n \n /* 1 if N is a possible register number for a function value.\n-   On the SH, only r4 can return results.  */\n+   On the SH, only r0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n \t  ((REGNO) == FIRST_RET_REG)\n \n@@ -593,6 +720,7 @@ extern enum reg_class reg_class_from_letter[];\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n   (NAMED && ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\\\n+   && (MODE) != BLKmode \t\t\t\t\t\\\n    && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\\\n    && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\\\n        || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\\\n@@ -603,20 +731,10 @@ extern enum reg_class reg_class_from_letter[];\n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.\n-   Any arg that starts in the first NPARM_REGS regs but won't entirely\n-   fit in them needs partial registers on the SH.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n-  ((ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\\\n-    && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n-    && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n-\t|| (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n-    && (ROUND_REG ((CUM), (MODE))\t\t\t\t\t\\\n-\t+ ((MODE) == BLKmode\t\t\t\t\t\t\\\n-\t   ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\t\\\n-\t   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))) - NPARM_REGS > 0)\t\\\n-   ? (NPARM_REGS - ROUND_REG ((CUM), (MODE)))\t\t\t\t\\\n-   : 0)\n+   \n+   We never split args */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n extern int current_function_anonymous_args;\n \n@@ -647,8 +765,8 @@ extern int current_function_anonymous_args;\n /* Generate the assembly code for function exit \n    Just dump out any accumulated constant table.*/\n \n-#define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n-  dump_constants(0);  \n+#define FUNCTION_EPILOGUE(STREAM, SIZE)  function_epilogue (STREAM, SIZE)\n+\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n@@ -691,7 +809,6 @@ extern int current_function_anonymous_args;\n \n \f\n /* Addressing modes, and classification of registers for them.  */\n-\n /*#define HAVE_POST_INCREMENT  1*/\n /*#define HAVE_PRE_INCREMENT   1*/\n /*#define HAVE_POST_DECREMENT  1*/\n@@ -706,27 +823,27 @@ extern int current_function_anonymous_args;\n    has been allocated, which happens in local-alloc.c.\n \n */\n+\n #define REGNO_OK_FOR_BASE_P(REGNO)  \\\n   ((REGNO) < PR_REG || (unsigned) reg_renumber[(REGNO)] < PR_REG)\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO)   ((REGNO)==0)\n+#define REGNO_OK_FOR_INDEX_P(REGNO)   \\\n+  ((REGNO) == 0 || (unsigned) reg_renumber[(REGNO)] == 0)\n \n /* Maximum number of registers that can appear in a valid memory \n    address. */\n \n-#define MAX_REGS_PER_ADDRESS 4\n+#define MAX_REGS_PER_ADDRESS 2\n \n /* Recognize any constant value that is a valid address.  */\n \n #define CONSTANT_ADDRESS_P(X) \t\\\n   (GET_CODE (X) == LABEL_REF)\n \n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+/* Nonzero if the constant value X is a legitimate general operand. */\n \n-   On the SH, allow anything but a double */\n+#define LEGITIMATE_CONSTANT_P(X) \\\n+  (GET_CODE(X) != CONST_DOUBLE && GET_CODE(X) != LABEL_REF)\n \n-#define LEGITIMATE_CONSTANT_P(X)  (GET_CODE(X) != CONST_DOUBLE)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -735,23 +852,27 @@ extern int current_function_anonymous_args;\n    them unless they have been allocated suitable hard regs.\n    The symbol REG_OK_STRICT causes the latter definition to be used.  */\n \n+#define MODE_DISP_OK_4(X,MODE) ((GET_MODE_SIZE(MODE)==4) && ((unsigned)INTVAL(X)<64))\n+#define MODE_DISP_OK_2(X,MODE) ((GET_MODE_SIZE(MODE)==2) && ((unsigned)INTVAL(X)<32) && TARGET_TRYR0)\n+#define MODE_DISP_OK_1(X,MODE) ((GET_MODE_SIZE(MODE)==1) && ((unsigned)INTVAL(X)<16) && TARGET_TRYR0)\n+\n #ifndef REG_OK_STRICT\n \n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-    \t(REGNO (X) <= 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n+  (REGNO (X) <= 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n+\n #define REG_OK_FOR_INDEX_P(X) \\\n-    \t(REGNO (X) == 0 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  (REGNO (X) == 0 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n \n #define REG_OK_FOR_PRE_POST_P(X) \\\n   \t(REGNO (X) <= 16)\n \n #else\n-\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X)\t\\\n \tREGNO_OK_FOR_BASE_P (REGNO (X))\n@@ -761,8 +882,29 @@ extern int current_function_anonymous_args;\n   \tREGNO_OK_FOR_INDEX_P (REGNO (X))\n \n #define REG_OK_FOR_PRE_POST_P(X)  \\\n-\t(REGNO (X) <= 16 || (unsigned) reg_renumber[REGNO (X)] <=16)\n+\t(REGNO (X) <= 16)\n #endif\n+\n+/* The Q is a pc relative load operand */\n+#define EXTRA_CONSTRAINT_Q(OP)    \\\n+   (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP,0)) == LABEL_REF)\n+\n+/* The U is a label ref */\n+#define EXTRA_CONSTRAINT_U(OP)    \\\n+   (GET_CODE (OP) == LABEL_REF)\n+\n+#define IS_INDEX(OP) \t\t\t\t\t\t\t\t\\\n+  ((GET_CODE(OP) == PLUS && \t\t\t\t\t\t\t\\\n+    (INDEX_REGISTER_RTX_P(XEXP(OP,0)) && BASE_REGISTER_RTX_P(XEXP(OP,1))) ||\t\\\n+    (INDEX_REGISTER_RTX_P(XEXP(OP,1)) && BASE_REGISTER_RTX_P(XEXP(OP,0)))))\n+\n+\n+\n+#define EXTRA_CONSTRAINT(OP, C)   \\\n+     ((C) == 'Q' ? EXTRA_CONSTRAINT_Q (OP)   \\\n+    : (C) == 'U' ? EXTRA_CONSTRAINT_U (OP)   \\\n+    : 0)\n+\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -796,18 +938,14 @@ extern int current_function_anonymous_args;\n    A legitimate index for a QI or HI is 0, SI and above can be any \n    number 0..63 */\n \n-#define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)  \\\n-  do {\t\t\t\t\t\t\t\\\n-    if (GET_CODE (OP) == CONST_INT) \t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (0&&GET_MODE_SIZE (MODE) == 2 && ((unsigned)INTVAL(OP)) <=30)\\\n-\t  goto LABEL;\t\t\t\t\t\\\n-\tif (0&&GET_MODE_SIZE (MODE) == 1 && ((unsigned)INTVAL(OP)) <=15)\\\n-\t  goto LABEL;\t\t\t\t\t\\\n-\tif (GET_MODE_SIZE (MODE) >=4 \t\t\t\\\n-\t    && ((unsigned)INTVAL(OP)) < 64)\t\t\\\n-\t  goto LABEL;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n+#define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)  \t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (MODE_DISP_OK_4 (OP, MODE))  goto LABEL;\t\t      \t\\\n+\tif (MODE_DISP_OK_2 (OP, MODE))  goto LABEL;\t\t      \t\\\n+\tif (MODE_DISP_OK_1 (OP, MODE))  goto LABEL;\t\t      \t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   } while(0)\n \n \n@@ -819,13 +957,13 @@ extern int current_function_anonymous_args;\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t  \\\n \t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t  \\\n     goto LABEL;\t\t\t\t\t\t\t  \\\n-  else if (GET_CODE (X) == PLUS || GET_CODE(X) == LO_SUM) \t  \\\n+  else if (GET_CODE (X) == PLUS) \t  \t\t\t  \\\n     {\t\t\t\t\t\t\t\t  \\\n       rtx xop0 = XEXP(X,0);\t\t\t\t\t  \\\n       rtx xop1 = XEXP(X,1);\t\t\t\t\t  \\\n-      if (GET_MODE_SIZE(MODE) >= 4 && BASE_REGISTER_RTX_P (xop0)) \\\n+      if (GET_MODE_SIZE(MODE) <= 4 && BASE_REGISTER_RTX_P (xop0)) \\\n \tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL); \\\n-      if (GET_MODE_SIZE(MODE) >= 4 && BASE_REGISTER_RTX_P (xop1)) \\\n+      if (GET_MODE_SIZE(MODE) <= 4 && BASE_REGISTER_RTX_P (xop1)) \\\n \tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL); \\\n       if (GET_MODE_SIZE(MODE)<=4) {\t\t\t\t  \\\n \tif(BASE_REGISTER_RTX_P(xop1) &&\t\t\t \t  \\\n@@ -869,12 +1007,12 @@ extern int current_function_anonymous_args;\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n+#define CASE_VECTOR_MODE (TARGET_BIGTABLE ? SImode : HImode)\n \n /* Define this if the tablejump instruction expects the table\n    to contain offsets from the address of the table.\n    Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE */\n+#define CASE_VECTOR_PC_RELATIVE \n \n /* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n@@ -889,7 +1027,7 @@ extern int current_function_anonymous_args;\n #define SIZE_TYPE \"unsigned int\"\n \n /* Don't cse the address of the function being compiled.  */\n-#define NO_RECURSIVE_FUNCTION_CSE 1\n+/*#define NO_RECURSIVE_FUNCTION_CSE 1*/\n \n /* Max number of bytes we can move from memory to memory\n    in one reasonably fast instruction.  */\n@@ -940,15 +1078,12 @@ extern int current_function_anonymous_args;\n #define Pmode  SImode\n #define FUNCTION_MODE  Pmode\n \n-/* The structure type of the machine dependent info field of insns\n-   No uses for this yet.  */\n-/* #define INSN_MACHINE_INFO  struct machine_info  */\n-\n /* The relative costs of various types of constants.  Note that cse.c defines\n    REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n \n #define CONST_COSTS(RTX, CODE, OUTER_CODE)      \\\n   case CONST_INT:\t\t\t\t\\\n+  if (INTVAL(RTX)==0) return 0; \\\n     if (CONST_OK_FOR_I (INTVAL(RTX)))           \\\n       return 1;\t\t\t\t\t\\\n     else\t\t\t\t\t\\\n@@ -961,6 +1096,8 @@ extern int current_function_anonymous_args;\n       return 10;\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n+  case AND:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (andcosts (X));                \\\n   case MULT:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (multcosts (X));\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\\\n@@ -976,6 +1113,34 @@ extern int current_function_anonymous_args;\n   case FIX:\t\t\t\t\t\t\\\n     return 100;\n \n+\n+/* The multiply and divide insns on the SH are actually function calls\n+   with some special constraints on arguments and register usage.\n+\n+   These macros tell reorg that the references to arguments and \n+   register clobbers for insns of type sfunc do not appear to happen \n+   until after the millicode call.  This allows reorg to put insns\n+   which set the argument registers into the delay slot of the millicode\n+   call -- thus they act more like traditional CALL_INSNs.\n+\n+   get_attr_type will try to recognize the given insn, so make sure to\n+   filter out things it will not accept -- SEQUENCE, USE and CLOBBER insns\n+   in particular.  */\n+\n+#define INSN_SETS_ARE_DELAYED(X) \t\t\\\n+  ((GET_CODE (X) == INSN\t\t\t\\\n+    && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n+    && GET_CODE (PATTERN (X)) != USE\t\t\\\n+    && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n+    && get_attr_type (X) == TYPE_SFUNC))\n+\n+#define INSN_REFERENCES_ARE_DELAYED(X) \t\t\\\n+  ((GET_CODE (X) == INSN\t\t\t\\\n+    && GET_CODE (PATTERN (X)) != SEQUENCE\t\\\n+    && GET_CODE (PATTERN (X)) != USE\t\t\\\n+    && GET_CODE (PATTERN (X)) != CLOBBER\t\\\n+    && get_attr_type (X) == TYPE_SFUNC))\t\n+\n /* Compute extra cost of moving data between one register class\n    and another.  \n \n@@ -984,7 +1149,7 @@ extern int current_function_anonymous_args;\n */\n \n #define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS)  \\\n-\t((DSTCLASS == T_REGS) ? 10 : 1)\n+\t(((DSTCLASS == T_REGS) || (DSTCLASS == PR_REG)) ? 10 : 1)\n \f\n /* Assembler output control */\n \n@@ -994,23 +1159,23 @@ extern int current_function_anonymous_args;\n \t\t     W_options, sizeof W_options / sizeof W_options[0]); \t\n \n \n-#define ASM_FILE_END(STREAM) \\\n-  dump_constants(0);  \n+#define ASM_FILE_END(STREAM) \n \n-#define ASM_APP_ON  \"\"\n-#define ASM_APP_OFF  \"\"\n \n-#define FILE_ASM_OP \"\\t.file\\n\"\n-#define IDENT_ASM_OP \"\\t.ident\\n\"\n+#define ASM_APP_ON  \t\t\"\"\n+#define ASM_APP_OFF  \t\t\"\"\n+#define FILE_ASM_OP \t\t\"\\t.file\\n\"\n+#define IDENT_ASM_OP \t\t\"\\t.ident\\n\"\n \n+/* How to change between sections. */\n \n-/* Switch to the text or data segment.  */\n-#define TEXT_SECTION_ASM_OP  \"\\t.text\"\n-#define DATA_SECTION_ASM_OP  \"\\t.data\"\n-#define CTORS_SECTION_ASM_OP \"\\t.section\\t.ctors\\n\"\n-#define DTORS_SECTION_ASM_OP \"\\t.section\\t.dtors\\n\"\n+#define TEXT_SECTION_ASM_OP  \t\"\\t.text\"\n+#define DATA_SECTION_ASM_OP  \t\"\\t.data\"\n+#define CTORS_SECTION_ASM_OP \t\"\\t.section\\t.ctors\\n\"\n+#define DTORS_SECTION_ASM_OP \t\"\\t.section\\t.dtors\\n\"\n+#define INIT_SECTION_ASM_OP  \t\"\\t.section\\t.init\\n\"\n+#define EXTRA_SECTIONS \t\tin_ctors, in_dtors\n \n-#define EXTRA_SECTIONS in_ctors, in_dtors\n #define EXTRA_SECTION_FUNCTIONS                              \\\n void\t\t\t\t\t\t\t     \\\n ctors_section() \t\t\t\t\t     \\\n@@ -1040,8 +1205,8 @@ dtors_section() \t\t\t\t\t     \\\n #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\\\n    do {  dtors_section();  fprintf(FILE,\"\\t.long\\t_%s\\n\", NAME); } while (0)\n \n-\n #undef DO_GLOBAL_CTORS_BODY                     \n+\n #define DO_GLOBAL_CTORS_BODY\t\t\t\\\n {\t\t\t\t\t\t\\\n   typedef (*pfunc)();\t\t\t\t\\\n@@ -1068,14 +1233,12 @@ dtors_section() \t\t\t\t\t     \\\n }\t\t\t\t\t\t \n \n \n-\n #define ASM_OUTPUT_REG_PUSH(file, v) \\\n   fprintf (file, \"\\tmov.l\tr%s,-@r15\\n\", v);\n \n #define ASM_OUTPUT_REG_POP(file, v) \\\n   fprintf (file, \"\\tmov.l\t@r15+,r%s\\n\", v);\n \n-\n   \n /* The assembler's names for the registers.  RFP need not always be used as\n    the Real framepointer; it can also be used as a normal general register.\n@@ -1133,18 +1296,25 @@ dtors_section() \t\t\t\t\t     \\\n   ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n    sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n \n-/* Jump tables must be 32 bit aligned. */\n+/* Jump tables must be 32 bit aligned, no matter the size of the element */\n #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE) \\\n-  fprintf (STREAM, \"\\t.align 2\\n%s%d:\\n\", PREFIX, NUM);\n+    fprintf (STREAM, \"\\t.align 2\\n%s%d:\\n\",  PREFIX, NUM);\n+\n+/* Output a relative address table. */\n \n-/* Output a relative address. Not needed since jump tables are absolute\n-   but we must define it anyway.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \\\n-  fputs (\"- - - ASM_OUTPUT_ADDR_DIFF_ELT called!\\n\", STREAM)\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \t\t\t\\\n+  if (TARGET_BIGTABLE) \t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.long\tL%d-L%d\\n\", VALUE,REL); \t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.word\tL%d-L%d\\n\", VALUE,REL); \t\\\n \n-/* Output an element of a dispatch table.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n-    fprintf (STREAM, \"\\t.long\\tL%d\\n\", VALUE)\n+/* Output an absolute table element */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \t\t\t\t\\\n+  if (TARGET_BIGTABLE) \t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.long\tL%d\\n\", VALUE); \t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+        fprintf (STREAM, \"\\t.word\tL%d\\n\", VALUE); \t\t\\\n \n /* Output various types of constants.  */\n \n@@ -1165,7 +1335,6 @@ do { char dstr[30];\t\t\t\t\t\\\n      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n    } while (0)\n \n-\n #define ASM_OUTPUT_INT(STREAM, EXP)  \t\\\n   (fprintf (STREAM, \"\\t.long\\t\"),      \t\\\n    output_addr_const (STREAM, (EXP)),  \t\\\n@@ -1237,16 +1406,13 @@ do { char dstr[30];\t\t\t\t\t\\\n #define PRINT_OPERAND_ADDRESS(STREAM,X)  print_operand_address (STREAM, X)\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n+  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR)=='!')\n \n \f\n-/* Define the information needed to generate branch insns.  This is stored\n-   from the compare operation.  Note that we can't use \"rtx\" here since it\n-   hasn't been defined!  */\n-\n extern struct rtx_def *sh_compare_op0;\n extern struct rtx_def *sh_compare_op1;\n extern struct rtx_def *prepare_scc_operands();\n+extern struct rtx_def *table_lab;\n \n extern enum attr_cpu sh_cpu;\t/* target cpu */\n \n@@ -1256,12 +1422,24 @@ extern char *output_branch();\n extern char *output_shift();\n extern char *output_movedouble();\n extern char *output_movepcrel();\n+extern char *output_jump_label_table();\n+extern char *output_far_jump();\n+\n \n+#define MACHINE_DEPENDENT_REORG(X) machine_dependent_reorg(X)\n \n-#define ADJUST_INSN_LENGTH(insn, length) \\\n-  adjust_insn_length (insn, insn_lengths)\n+/* Generate calls to memcpy, memcmp and memset.  */\n \n+#define TARGET_MEM_FUNCTIONS\n \n+#define HANDLE_PRAGMA(finput) handle_pragma (finput)\n \n+/* Set when processing a function with pragma interrupt turned on. */\n \n+extern int pragma_interrupt;\n+#define MOVE_RATIO 16\n \n+char *max_si;\n+char *max_hi;\n+int max_count_si;\n+int max_count_hi;"}, {"sha": "3bdb8010fa119ba740639ad5dd45ded2006e43fc", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1049, "deletions": 486, "changes": 1535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d7e008e87f916fe7ff510696ec4fabbcad43925/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d7e008e87f916fe7ff510696ec4fabbcad43925/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=0d7e008e87f916fe7ff510696ec4fabbcad43925", "patch": "@@ -18,10 +18,37 @@\n ;; along with GNU CC; see the file COPYING.  If not, write to\n ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n \n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n \n \n+;; Special constraints for SH machine description:\n+;;\n+;;    t -- T \n+;;    x -- mac \n+;;    l -- pr \n+;;    z -- r0\n+;;\n+;; Special formats used for outputting SH instructions:\n+;;\n+;;   %.  --  print a .s if insn needs delay slot\n+;;   %*  --  print a local label\n+;;   %^  --  increment the local label number\n+;;   %#  --  output a nop if there is nothing to put in the delay slot\n+;;   %R  --  print the next register or memory location along, ie the lsw in\n+;;           a double word value\n+;;   %O  --  print a constant without the #\n+;;   %M  --  print a constant as its negative\n+;;\n+;;\n+;; Special predicates:\n+;;\n+;;  arith_operand          -- operand is valid source for arithmetic op\n+;;  arith_reg_operand      -- operand is valid register for arithmetic op\n+;;  byte_index_operand     -- operand is ok as an index in a mov.b\n+;;  general_movdst_operand -- operand is valid move destination\n+;;  general_movsrc_operand -- operand is valid move source\n+;;  logical_operand        -- operand is valid source for logical op\n+;;  pop_operand            -- operand is a pop from the stack\n+;;  system_reg_operand     -- operand is MACL, MACH, or PR\n ;; -------------------------------------------------------------------------\n ;; Attributes\n ;; -------------------------------------------------------------------------\n@@ -30,66 +57,98 @@\n \n (define_attr \"cpu\" \"sh0,sh1,sh2,sh3\"\n   (const (symbol_ref \"sh_cpu\")))\n-\n-(define_attr \"type\" \"cbranch,ctable,jump,arith,other,load,store,move,smpy,dmpy,return,pload\"\n+;;\n+;; cbranch\tconditional branch instructions\n+;; jump\t\tunconditional jumps\n+;; arith\tordinary arithmetic\n+;; load\t\tfrom memory\n+;; store\tto memory\n+;; move\t\tregister to register\n+;; smpy\t\tsingle precision integer multiply\n+;; dmpy\t\tdouble precision integer multiply\n+;; return\trts\n+;; pload\tload of pr reg (can't be put into delay slot of rts)\n+;; pcloadsi\tpc relative load of SI value\n+;; pcloadhi \tpc relative load of HI value\n+;; rte\t\treturn from exception\n+;; sfunc\tspecial function call with known used registers\n+\n+(define_attr \"type\" \n+ \"cbranch,jump,arith,other,load,store,move,smpy,dmpy,return,pload,pcloadsi,pcloadhi,rte,sfunc\"\n   (const_string \"other\"))\n \n-; If a conditional branch destination is within -100..100 bytes away \n+; If a conditional branch destination is within -120..120 bytes away \n ; from the instruction it can be 2 bytes long.  Something in the\n-; range -4000..4000 bytes can be 6 bytes long, all other conditional\n+; range -4090..4090 bytes can be 6 bytes long, all other conditional\n ; branches are 8 bytes long.\n \n ; An unconditional jump which can reach forward or back 4k can be \n ; 6 bytes long (including the delay slot).  If it is too big, it\n-; must be 8 bytes long.\n+; must be 10 bytes long.\n \n+; If a pcrel instruction is within 500 bytes of the constant, then the insn is \n+; 2 bytes long, otherwise 12 bytes\n ; All other instructions are two bytes long by default.\n \n (define_attr \"length\" \"\" \n   (cond [(eq_attr \"type\" \"cbranch\")\n-\t  (if_then_else (and (ge (minus (pc) (match_dup 0))\n-\t\t\t\t (const_int -100))\n-\t\t\t     (le (minus (pc) (match_dup 0))\n-\t\t\t\t (const_int 100)))\n-\t\t\t(const_int 2)\n-\t\t\t(if_then_else (and (ge (minus (pc) (match_dup 0))\n-\t\t\t\t\t       (const_int -4000))\n-\t\t\t\t\t   (le (minus (pc) (match_dup 0))\n-\t\t\t\t\t       (const_int 4000)))\n-\t\t\t\t      (const_int 6)\n-\t\t\t\t      (const_int 8)))\n+\t (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int -122))\n+\t\t\t    (le (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int 122)))\n+\t\t       (const_int 2)\n+\t\t       (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t\t      (const_int -4090))\n+\t\t\t\t\t  (le (minus (pc) (match_dup 0))\n+\t\t\t\t\t      (const_int 4090)))\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 16)))\n \n \t (eq_attr \"type\" \"jump\")\n-\t\t\t(if_then_else (and (ge (minus (pc) (match_dup 0))\n-\t\t\t\t\t       (const_int -4000))\n-\t\t\t\t\t   (le (minus (pc) (match_dup 0))\n-\t\t\t\t\t       (const_int 4000)))\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 6))\n+\t (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int -4090))\n+\t\t\t    (le (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int 4090)))\n+\t\t       (const_int 4)\n+\t\t       (const_int 10))\n+\t (eq_attr \"type\" \"pcloadsi\")\n+\t (if_then_else (gt (pc) (minus (match_dup 0) (const_int 1000)))\n+\t\t       (const_int 2)\n+\t\t       (const_int 12))\n+\t (eq_attr \"type\" \"pcloadhi\")\n+\t (if_then_else (gt (pc) (minus (match_dup 0) (const_int 500)))\n+\t\t       (const_int 2)\n+\t\t       (const_int 12))\n+\n \t ] (const_int 2)))\n \n ;; (define_function_unit {name} {num-units} {n-users} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \t\t\t\t      \n-(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 1 0)\n-(define_function_unit \"mpy\"    1 1 (eq_attr \"type\" \"smpy\") 3 0)\n-(define_function_unit \"mpy\"    1 1 (eq_attr \"type\" \"dmpy\") 5 0)\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcloadsi,pcloadhi\") 2 0)\n+(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 3 0)\n+(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 5 0)\n \n (define_attr \"needs_delay_slot\" \"yes,no\"\n-  (cond [(eq_attr \"type\" \"jump\") (const_string \"yes\")\n+  (cond [(eq_attr \"type\" \"jump\")   (const_string \"yes\")\n \t (eq_attr \"type\" \"return\") (const_string \"yes\")]\n \t(const_string \"no\")))\n \n (define_delay \n-  (eq_attr \"needs_delay_slot\" \"yes\") \n+  (eq_attr \"needs_delay_slot\" \"yes\")\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n \n+(define_delay \n+  (eq_attr \"type\" \"rte\")\n+  [(and (eq_attr \"in_delay_slot\" \"yes\") \n+\t(eq_attr \"hit_stack\" \"no\")) (nil) (nil)])\n+\n+(define_attr \"hit_stack\" \"yes,no\" (const_string \"no\"))\n \n-(define_attr \"dump\" \"yes,no,must\" (const_string \"no\"))\n-(define_attr \"constneed\" \"yes,no\" (const_string \"no\"))\n-(define_attr \"smallestsize\" \"\" (const_int 2))\n-(define_attr \"largestsize\" \"\" (const_int 8))\n-(define_attr \"constantsize\" \"\" (const_int 4))\n+(define_delay \n+  (and (eq_attr \"type\" \"cbranch\") \n+       (eq_attr \"cpu\" \"sh2\"))\n+  [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n \n (define_attr \"in_delay_slot\" \"maybe,yes,no\" \n   (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n@@ -100,7 +159,6 @@\n \t (eq_attr \"length\" \"4,6,8,10,12\") (const_string \"no\")\n \t ] (const_string \"yes\")))\n \n-\n \f\n ;; -------------------------------------------------------------------------\n ;; SImode signed integer comparisons\n@@ -112,88 +170,82 @@\n \t       (const_int 1)))]\n   \"\"\n   \"movt\t%0 !movt1\")\n-  \n+\n (define_insn \"\"\n-  [(set (reg:SI 18) (gt (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t  (const_int 0)))]\n+  [(set (reg:SI 18) (gt:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n+\t\t\t   (const_int 0)))]\n   \"\"\n   \"cmp/pl\t%0\")\n \n (define_insn \"\"\n-  [(set (reg:SI 18) (ge (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t  (const_int 0)))]\n+  [(set (reg:SI 18) (ge:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n+\t\t\t   (const_int 0)))]\n   \"\"\n   \"cmp/pz\t%0\")\n \n-(define_insn \"cmpeqsi_t\"\n-  [(set (reg:SI 18) (eq (match_operand:SI 0 \"arith_reg_operand\" \"r,z\")\n-\t\t  (match_operand:SI 1 \"arith_operand\" \"r,I\")))]\n+(define_insn \"cmpeq_0\"\n+  [(set (reg:SI 18) (eq:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n+\t\t\t   (const_int 0)))]\n   \"\"\n-  \"cmp/eq\t%1,%0\")\n+  \"tst\t%0,%0 ! t0\")\n \n+(define_insn \"cmpeqsi_t\"\n+  [(set (reg:SI 18) (eq:SI (match_operand:SI 0 \"arith_operand\" \"r,N,r,z\")\n+\t\t\t   (match_operand:SI 1 \"arith_operand\" \"N,r,r,I\")))]\n+  \"\"\n+  \"@\n+\ttst\t%0,%0 !t1\n+\ttst\t%1,%1 !t2\n+\tcmp/eq\t%1,%0\n+\tcmp/eq\t%1,%0\")\n \n (define_insn \"cmpgtsi_t\"\n-  [(set (reg:SI 18) (gt (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (reg:SI 18) (gt:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n+\t\t\t   (match_operand:SI 1 \"arith_operand\" \"N,r\")))]\n   \"\"\n-  \"cmp/gt\t%1,%0\")\n+  \"@\n+\tcmp/pl\t%0\n+\tcmp/gt\t%1,%0\")\n \n (define_insn \"cmpgesi_t\"\n-  [(set (reg:SI 18) (ge (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (reg:SI 18) (ge:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n+\t\t\t   (match_operand:SI 1 \"arith_operand\" \"N,r\")))]\n   \"\"\n-  \"cmp/ge\t%1,%0\")\n-\n-(define_insn \"cmpltsi_t\"\n-  [(set (reg:SI 18) (lt (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"cmp/gt\t%0,%1\")\n-\n-(define_insn \"cmplesi_t\"\n-  [(set (reg:SI 18) (le (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"cmp/ge\t%0,%1\")\n+  \"@\n+\tcmp/pz\t%0\n+\tcmp/ge\t%1,%0\")\n \n \f\n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n ;; -------------------------------------------------------------------------\n \n (define_insn \"cmpgeusi_t\"\n-  [(set (reg:SI 18) (geu (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t   (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (reg:SI 18) (geu:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 1 \"arith_operand\" \"N,r\")))]\n   \"\"\n-  \"cmp/hs\t%1,%0\")\n+  \"@\n+\tcmp/pz\t%1\n+\tcmp/hs\t%1,%0\")\n \n (define_insn \"cmpgtusi_t\"\n-  [(set (reg:SI 18) (gtu (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t   (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"cmp/hi\t%1,%0\")\n-\n-(define_insn \"cmpleusi_t\"\n-  [(set (reg:SI 18) (leu (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t   (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"cmp/hs\t%0,%1\")\n-\n-(define_insn \"cmpltusi_t\"\n-  [(set (reg:SI 18) (ltu (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t   (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (reg:SI 18) (gtu:SI (match_operand:SI 0 \"arith_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 1 \"arith_operand\" \"N,r\")))]\n   \"\"\n-  \"cmp/hi\t%0,%1\")\n+  \"@\n+\tcmp/pl\t%1\n+\tcmp/hi\t%1,%0\")\n \n ;; We save the compare operands in the cmpxx patterns and use them when\n ;; we generate the branch.\n \n (define_expand \"cmpsi\"\n-  [(set (reg:SI 18) (compare (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t\t     (match_operand:SI 1 \"arith_reg_operand\" \"\")))]\n+  [(set (reg:SI 18) (compare (match_operand:SI 0 \"arith_operand\" \"\")\n+\t\t\t     (match_operand:SI 1 \"arith_operand\" \"\")))]\n   \"\"\n   \"\n-{ sh_compare_op0 = operands[0];\n+{\n+  sh_compare_op0 = operands[0];\n   sh_compare_op1 = operands[1];\n   DONE;\n }\")\n@@ -203,19 +255,36 @@\n ;; Addition instructions\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=&r\")\n-\t(plus:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"arith_reg_operand\" \"r\")))\n+(define_insn \"addc\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(plus:SI (reg:SI 18)\n+\t\t (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"clrt\\;addc\t%R2,%R0\\;addc\t%2,%0\"\n-  [(set_attr \"length\" \"6\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"type\" \"arith\")])\n+  \"addc\t%2,%0\")\n+\n \n+;; this should be a define split.\n+\n+(define_expand \"adddi3\"\n+  [(set (reg:SI 18) (const_int 0))\n+   (parallel\n+    [(set (subreg:SI (match_operand:DI 0 \"arith_reg_operand\" \"=r\") 1)\n+\t  (plus:SI (reg:SI 18)\n+\t\t   (plus:SI (subreg:SI (match_operand:DI 1 \"arith_reg_operand\" \"r\") 1)\n+\t\t\t    (subreg:SI (match_operand:DI 2 \"arith_reg_operand\" \"r\") 1))))\n+     (clobber (reg:SI 18))])\n+   (parallel\n+    [(set (subreg:SI (match_dup 0) 0)\n+\t  (plus:SI (reg:SI 18)\n+\t\t   (plus:SI (subreg:SI (match_dup 1) 0)\n+\t\t\t    (subreg:SI (match_dup 2) 0))))\n+     (clobber (reg:SI 18))])]\n+  \"\"\n+  \"\")\n \n-(define_insn \"addsi3_i\"\n+(define_insn \"addsi3_real\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n@@ -226,7 +295,7 @@\n \n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n+\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"\"\n   \"\")\n@@ -237,7 +306,7 @@\n ;; -------------------------------------------------------------------------\n \n (define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=&r\")\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"arith_reg_operand\" \"0\")\n \t\t  (match_operand:DI 2 \"arith_reg_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n@@ -248,27 +317,95 @@\n    (set_attr \"type\" \"arith\")])\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"r,I\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"arith_operand\" \"r\")))]\n   \"\"\n-  \"@\n-\tsub\t%2,%0\n-\tadd\t%M2,%0\"\n+  \"sub\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n \f\n ;; -------------------------------------------------------------------------\n-;; Multiplication instructions\n+;; Division instructions\n ;; -------------------------------------------------------------------------\n \n \n+;; we take advantage of the library routines which don't clobber as many\n+;; registers as a normal function call would.\n+\n+\n+(define_insn \"\"\n+  [(set (reg:SI 0)\n+\t(udiv:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 18))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:SI 6))\n+   (clobber (reg:SI 4))\n+   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_expand \"udivsi3\"\n+  [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"g\"))\n+   (set (match_dup 3) (symbol_ref:SI \"__udivsi3\"))\n+   (parallel[(set (reg:SI 0)\n+\t\t  (udiv:SI (reg:SI 4)\n+\t\t\t   (reg:SI 5)))\n+\t     (clobber (reg:SI 18))\n+\t     (clobber (reg:SI 17))\n+\t     (clobber (reg:SI 6))\n+\t     (clobber (reg:SI 4))\n+\t     (use (match_dup 3))])\n+   (set (match_operand:SI 0 \"general_operand\" \"=g\") \n+\t(reg:SI 0))]\n+  \"\"\n+  \"operands[3] = gen_reg_rtx(SImode);\")\n+\n+\n+(define_insn \"\"\n+  [(set (reg:SI 0)\n+\t(div:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 18))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 3))\n+   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_expand \"divsi3\"\n+  [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"g\"))\n+   (set (match_dup 3) (symbol_ref:SI \"__sdivsi3\"))\n+   (parallel[(set (reg:SI 0)\n+\t\t  (div:SI (reg:SI 4)\n+\t\t\t   (reg:SI 5)))\n+\t     (clobber (reg:SI 18))\n+\t     (clobber (reg:SI 17))\n+\t     (clobber (reg:SI 4))\n+\t     (clobber (reg:SI 3))\n+\t     (use (match_dup 3))])\n+   (set (match_operand:SI 0 \"general_operand\" \"=g\") \n+\t(reg:SI 0))]\n+  \"\"\n+  \"operands[3] = gen_reg_rtx(SImode);\")\n+\t    \n+\f\n+;; -------------------------------------------------------------------------\n+;; Multiplication instructions\n+;; -------------------------------------------------------------------------\n+\n (define_insn \"\"\n   [(set (reg:SI 21)\n-\t(mult:SI (zero_extend:SI\n-\t\t  (match_operand:HI 1 \"arith_reg_operand\" \"r\"))\n-\t\t (zero_extend:SI\n-\t\t  (match_operand:HI 2 \"arith_reg_operand\" \"r\"))))]\n+\t(mult:SI (zero_extend:SI (match_operand:HI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (zero_extend:SI (match_operand:HI 2 \"arith_reg_operand\" \"r\"))))]\n   \"\"\n   \"mulu\t%2,%1\"\n   [(set_attr \"type\" \"smpy\")])\n@@ -305,19 +442,138 @@\n   \"\"\n   \"\")\n \n+;; mulsi3 on the SH2 can be done in one instruction, on the SH1 we generate\n+;; a call to a routine which clobbers known registers.\n+\n+(define_insn \"\"\n+  [(set (reg:SI 0)\n+\t(mult:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 21))\n+   (clobber (reg:SI 18))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:SI 3))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 1))\n+   (use (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_expand \"mulsi3_call\"\n+  [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"g\"))\n+   (set (match_dup 3) (symbol_ref:SI \"__mulsi3\"))\n+   (parallel[(set (reg:SI 0)\n+\t\t  (mult:SI (reg:SI 4)\n+\t\t\t   (reg:SI 5)))\n+\t     (clobber (reg:SI 21))\n+\t     (clobber (reg:SI 18))\n+\t     (clobber (reg:SI 17))\n+\t     (clobber (reg:SI 3))\n+\t     (clobber (reg:SI 2))\n+\t     (clobber (reg:SI 1))\n+\t     (use (match_dup 3))])\n+   (set (match_operand:SI 0 \"general_operand\" \"=g\") \n+\t(reg:SI 0))]\n+  \"\"\n+  \"operands[3] = gen_reg_rtx(SImode);\")\n+\t\n+(define_insn \"mul_l\"\n+  [(set (reg:SI 21)\n+\t(mult:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n+\t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+  \"TARGET_SH2\"\n+  \"mul.l\t%1,%0\"\n+  [(set_attr \"type\" \"smpy\")])\n+\n+(define_expand \"mulsi3\"\n+  [(set (reg:SI 21)\n+\t(mult:SI  (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))\n+   (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(reg:SI 21))]\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_SH2)\n+    {\n+      emit_insn (gen_mulsi3_call (operands[0], operands[1], operands[2])); \n+      DONE; \n+    } \n+}\")\n+\n+(define_insn \"\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n+  \"TARGET_SH2\"\n+  \"dmuls.l\t%2,%1\"\n+  [(set_attr \"type\" \"dmpy\")])\n+\n+(define_expand \"mulsidi3\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n+   (set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(reg:DI 20))]\n+  \"TARGET_SH2\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n+  \"TARGET_SH2\"\n+  \"dmulu.l\t%2,%1\"\n+  [(set_attr \"type\" \"dmpy\")])\n+\n+(define_expand \"umulsidi3\"\n+  [(set (reg:DI 20)\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n+   (set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(reg:DI 20))]\n+  \"TARGET_SH2\"\n+  \"\")\n+\n \f\n ;; -------------------------------------------------------------------------\n ;; Logical operations\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"andsi3\"\n+(define_insn \"and_ffff\"\n+ [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+       (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t       (const_int 65535)))]\n+ \"\"\n+ \"extu.w\t%1,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"and_ff\"\n+ [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+       (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t       (const_int 255)))]\n+ \"\"\n+ \"extu.b\t%1,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+   \n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z\")\n \t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n   \"\"\n   \"and\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_expand \"andsi3\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t(match_operand:SI 2 \"logical_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z\")\n \t(ior:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n@@ -326,9 +582,9 @@\n   \"or\t%2,%0\")\n \n (define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z\")\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=z,r\")\n \t(xor:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,L\")))]\n+\t\t(match_operand:SI 2 \"logical_operand\" \"L,r\")))]\n   \"\"\n   \"xor\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n@@ -370,15 +626,34 @@\n   \"\"\n   \"{ if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) != 1) FAIL;}\")\n \n+\n+;;\n+;; shift left\n+\n (define_insn \"ashlsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"K,n\")))\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"M,K\")))\n    (clobber (reg:SI 18))]\n-  \"\"\n+  \"CONST_OK_FOR_K (INTVAL (operands[2]))\"\n+  \"@\n+\tshll\t%0\n+\tshll%O2\t%0\")\n+\n+; seperate pattern for shifts by any N.  Look at pnum_clobbers\n+; to see if this is being recognised inside combine.  If so, dont\n+; match, since combine will try and merge shifts, which will break\n+; scheduling\n+\n+(define_insn \"ashlsi3_n\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+   (clobber (reg:SI 18))]\n+  \"(! pnum_clobbers)\"\n   \"*return output_shift(\\\"shll\\\", operands[0], operands[2], ASHIFT);\"\n-  [(set_attr \"length\" \"2,12\")\n-   (set_attr \"in_delay_slot\" \"yes,no\")\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"arith\")])\n \n (define_expand \"ashlsi3\"\n@@ -387,48 +662,104 @@\n \t\t\t     (match_operand:SI 2 \"immediate_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"if (!ok_shift_value(operands[2], ASHIFT)) FAIL;\")\n+  \"if (gen_shifty_op (ASHIFT, operands)) DONE; else FAIL;\")\n+\n+;\n+; arithmetic shift right\n+;\n \n (define_insn \"ashrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (const_int 1)))\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"M\")))\n    (clobber (reg:SI 18))]\n-  \"\"\n+  \"INTVAL(operands[2]) == 1\"\n   \"shar\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+(define_insn \"ashrsi3_16\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"i\")))\n+   (clobber (reg:SI 18))]\n+  \"INTVAL(operands[2]) == 16\"\n+  \"shlr16\t%0\\;exts.w\t%0,%0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")])\n+\n+; an arithmetic shift right by 16 is better as a logical shift and a \n+; sign extend\n+\n+;(define_split \n+;  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+;\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+;\t\t     (const_int 16)))\n+;   (clobber (reg:SI 18))]\n+;  \"\"\n+;  [(set (match_dup 3) (match_dup 0))\n+;    (set (match_dup 3) (lshiftrt:SI (match_dup 3) (const_int 16)))\n+;    (set (match_dup 0) (sign_extend:SI (subreg:HI (match_dup 3) 0)))]\n+;  \"operands[3] = gen_reg_rtx (SImode);\")\n+\n+(define_insn \"ashrsi3_n\"\n+  [(set (reg:SI 4)\n+\t(ashiftrt:SI (reg:SI 4)\n+\t\t     (match_operand:SI 0 \"immediate_operand\" \"i\")))\n+   (clobber (reg:SI 18))\n+   (clobber (reg:SI 17))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+  \"\"\n+  \"jsr\t@%1%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"in_delay_slot\" \"no\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n (define_expand \"ashrsi3\"\n   [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t\t  (ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n \t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"M\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT ||\n-      INTVAL (operands[2]) != 1) FAIL;\n-}\n-\")\n+  \"if (gen_shifty_op (ASHIFTRT, operands)) DONE; else FAIL;\")\n+\n+; logical shift right\n+;\n \n (define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t     (match_operand:SI 2 \"immediate_operand\" \"K,n\")))\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"M,K\")))\n    (clobber (reg:SI 18))]\n-  \"\"\n+  \"CONST_OK_FOR_K (INTVAL (operands[2]))\"\n+  \"@\n+\tshlr\t%0\n+\tshlr%O2\t%0\")\n+\n+; seperate pattern for shifts by any N.  Look at pnum_clobbers\n+; to see if this is being recognised inside combine.  If so, dont\n+; match, since combine will try and merge shifts, which will break\n+; scheduling - this could be handled with a large number of\n+; define_splits\n+\n+(define_insn \"lshrsi3_n\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"immediate_operand\" \"n\")))\n+   (clobber (reg:SI 18))]\n+  \"!pnum_clobbers\"\n   \"* return output_shift (\\\"shlr\\\", operands[0], operands[2], LSHIFTRT);\"\n-  [(set_attr \"length\" \"2,12\")\n-   (set_attr \"in_delay_slot\" \"yes,no\")\n+  [(set_attr \"length\" \"12\")\n+   (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"arith\")])\n \n (define_expand \"lshrsi3\"\n   [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t\t  (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t\t\t       (match_operand:SI 2 \"immediate_operand\" \"\")))\n \t     (clobber (reg:SI 18))])]\n   \"\"\n-  \"if (!ok_shift_value (operands[2])) FAIL; \")\n+  \"if (gen_shifty_op (LSHIFTRT, operands)) DONE; else FAIL;\") \n \n (define_insn \"ashldi3_k\"\n   [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n@@ -485,7 +816,6 @@\n   \"{ if (GET_CODE (operands[2]) != CONST_INT \n \t|| INTVAL (operands[2]) != 1) FAIL; } \")\n \n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Unary arithmetic\n@@ -512,7 +842,7 @@\n \t(not:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"\"\n   \"not\t%1,%0\"\n-[  (set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"arith\")])\n \n \f\n ;; -------------------------------------------------------------------------\n@@ -546,170 +876,187 @@\n ;; -------------------------------------------------------------------------\n \n (define_insn \"extendsidi2\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"0\")))]\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r,r\")\n+\t(sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"0,r\")))\n+   (clobber (reg:SI 18))]\n   \"\"\n-  \"mov\t%1,%0\\;shll\t%0\\;subc\t%0,%0\"\n-  [(set_attr \"length\" \"6\")]) \n+  \"@\n+\tmov\t%1,%0\\;shll\t%0\\;subc\t%0,%0 ! b sidi2\n+\tmov\t%1,%0\\;mov\t%1,%R0\\;shll\t%0\\;subc\t%0,%0 ! a sidi2\"\n+  [(set_attr \"length\" \"6,8\")]) \n \n (define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"arith_operand\" \"r,u,m\")))]\n   \"\"\n-  \"exts.w\t%1,%0\")\n+  \"@\n+\texts.w\t%1,%0\n+   \tmov.w\t%1,%0\n+   \tmov.w\t%1,%0\"\n+  [(set_attr \"type\" \"arith,load,load\")])\n \n (define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_movsrc_operand\" \"r,U,m\")))]\n   \"\"\n-  \"exts.b\t%1,%0\")\n+  \"@\n+\texts.b\t%1,%0\n+\tmov.b\t%1,%0 !p9\n+\tmov.b\t%1,%0 !p8\"\n+  [(set_attr \"type\" \"arith,load,load\")])\n \n (define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n+  [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r,z,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_movsrc_operand\" \"r,U,m\")))]\n   \"\"\n-  \"exts.b\t%1,%0\")\n+  \"@\n+\texts.b\t%1,%0\n+\tmov.b\t%1,%0  !p7\n+\tmov.b\t%1,%0 ! p6\"\n+  [(set_attr \"type\" \"arith,load,load\")])\n \n \f\n ;; -------------------------------------------------------------------------\n ;; Move instructions\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SI 1 \"arith_reg_operand\" \"r,l\"))]\n-  \"\"\n-  \"@\n-\tmov.l\t%1,%0\n-\tsts.l\tpr,%0\"\n-  [(set_attr \"type\" \"store\")])\n-\n-(define_insn \"\"\n-  [(set\t(match_operand:SI 0 \"arith_reg_operand\" \"=r,l\")\n-\t(match_operand:SI 1 \"pop_operand\" \"=>,>\"))]\n-  \"\"\n-  \"@\n-\tmov.l\t%1,%0\n-\tlds.l\t%1,pr\"\n-  [(set_attr \"type\" \"load,pload\")])\n+;; define push and pop so it is easy for sh.c\n \n (define_insn \"push\"\n   [(set (mem:SI (pre_dec:SI (reg:SI 15)))\n-\t(match_operand:SI 0 \"register_operand\" \"r,l\"))]\n+\t(match_operand:SI 0 \"register_operand\" \"r,lx\"))]\n   \"\"\n   \"@\n \tmov.l\t%0,@-r15\n-\tsts.l\tpr,@-r15\")\n+\tsts.l\t%0,@-r15 ! push\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"hit_stack\" \"yes\")])\n \n (define_insn \"pop\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,l\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,lx\")\n \t(mem:SI (post_inc:SI (reg:SI 15))))]\n   \"\"\n   \"@\n \tmov.l\t@r15+,%0\n-\tlds.l\t@r15+,pr\"\n-  [(set_attr \"type\" \"load,pload\")])\n-\n-; some constants are easier to generate with alu operations\n-; rather than loading from memory\n+\tlds.l\t@r15+,%0\"\n+  [(set_attr \"type\" \"load,pload\")\n+   (set_attr \"hit_stack\" \"yes\")])\n \n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"painful_immediate_operand\" \"i\"))]\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<,<\")\n+\t(match_operand:SI 1 \"arith_reg_operand\" \"r,xl\"))]\n   \"\"\n-  [(set (match_dup 0) (const_int 127))\n-   (set (match_dup 0) (plus:SI (match_dup 0)\n-\t\t\t       (match_dup 2)))]\n-  \"operands[2] = GEN_INT (INTVAL(operands[1]) - 127);\" )\n+  \"@\n+\tmov.l\t%1,%0\n+\tsts.l\t%1,%0\"\n+  [(set_attr \"type\" \"store\")])\n \n-(define_insn \"movsi_i\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m,l,r,r,r,t,x\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\"  \"r,I,m,r,r,l,t,x,r,r\"))]\n+(define_insn \"\"\n+  [(set\t(match_operand:SI 0 \"arith_reg_operand\" \"=r,xl\")\n+\t(match_operand:SI 1 \"pop_operand\" \"=>,>\"))]\n   \"\"\n   \"@\n-\tmov\t%1,%0\n-\tmov\t%1,%0\n \tmov.l\t%1,%0\n-\tmov.l\t%1,%0\n-\tlds\t%1,%0\n-\tsts\t%1,%0\n-        movt\t%0\n-\tsts\t%1,%0\n-\ttst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\n-\tlds\t%1,%0\"\n-  [(set_attr \"length\" \"2,2,2,2,2,2,2,2,10,2\")\n-   (set_attr \"type\" \"move,move,load,pload,move,move,move,move,move,move\")])\n+\tlds.l\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n \n-(define_insn \"movsi_pcrel\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(match_operand:SI 1 \"hard_immediate_operand\" \"i\"))]\n+(define_insn \"clrt\"\n+  [(set (reg:SI 18) (const_int 0))]\n   \"\"\n-  \"* return output_movepcrel (insn, operands, SImode);\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"constneed\" \"yes\")\n-   (set_attr \"smallestsize\" \"2\")\n-   (set_attr \"largestsize\" \"8\")\n-   (set_attr \"type\" \"load\")])\n+  \"clrt\")\n \n+(define_insn \"movsi_i\"\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,r,<m,<,xl,xl,t,r\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,>m,xl,t,r,xl,r,>,r,i\"))]\n+  \"\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      switch (get_attr_length(insn)) \n+\t{\n+\tcase 2:\n+\t  return \\\"mov.l\t%1,%0 ! 2 byte\\\";\n+\tcase 12:\n+\t  return \\\"mov.l\tTA%*,%0\\;bra\tTB%*\\;mov.l\t@%0,%0\\;.align 2\\;TA%*: .long %1\\;TB%*:%^\\\";\n+\t}\n+    case 1: return \\\"mov\t%1,%0\\\";\n+    case 2: return \\\"mov.l\t%1,%0\\\";\n+    case 3: return \\\"sts\t%1,%0\\\";\n+    case 4: return \\\"movt\t%0\\\";\n+    case 5: return \\\"mov.l\t%1,%0\\\";\n+    case 6: return \\\"sts.l\t%1,%0\\\";\n+    case 7: return \\\"lds\t%1,%0\\\";\n+    case 8: return \\\"lds.l\t%1,%0\\\";\n+    case 9: return \\\"tst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\\\";\n+    case 10: return \\\"fake %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"length\" \"*,2,2,2,2,2,2,2,2,6,2\")\n+   (set_attr \"type\" \"pcloadsi,move,load,move,store,store,move,load,move,move,move\")])\n+\t\t\t  \n (define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n-  \"{ if(prepare_move_operands(operands, SImode)) DONE; } \")\n+  \"{ if (prepare_move_operands(operands, SImode)) DONE; } \")\n \n (define_insn \"movqi_i\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,r,r,m,r,m,r,r\")\n-\t(match_operand:QI 1 \"general_operand\"  \"r,n,m,r,m,r,x,t\"))]\n-  \"\"\n+  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,>m,r,r,l\")\n+\t(match_operand:QI 1 \"general_movsrc_operand\"  \"ri,<m,r,t,l,r\"))]\n+  \"arith_reg_operand (operands[0], QImode) \n+   || arith_reg_operand (operands[1], QImode)\"\n   \"@\n \tmov\t%1,%0\n-\tmov\t%1,%0\n-\tmov.b\t%1,%0 \n-\tmov.b\t%1,%0 \n-\tmov.b\t%1,%0 \n-\tmov.b\t%1,%0 \n+\tmov.b\t%1,%0\n+\tmov.b\t%1,%0\n+\tmovt\t%0\n \tsts\t%1,%0\n-\tmovt\t%0\")\n+\tlds\t%1,%0\"\n+ [(set_attr \"length\" \"2,2,2,2,2,2\")\n+  (set_attr \"type\" \"move,load,store,move,move,move\")])\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\"  \"\"))]\n   \"\"\n-  \"prepare_move_operands(operands, QImode);\")\n-  \n-(define_insn \"movhi_pcrel\"\n-  [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r\")\n-\t(match_operand:HI 1 \"hard_immediate_operand\" \"i\"))]\n-  \"\"\n-  \"* return output_movepcrel (insn, operands, SImode);\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"constneed\" \"yes\")\n-   (set_attr \"smallestsize\" \"2\")\n-   (set_attr \"largestsize\" \"8\")\n-   (set_attr \"type\" \"load\")])\n+  \"if (prepare_move_operands(operands, QImode)) DONE; \")\n \n (define_insn \"movhi_i\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,r,m,z,m,r,r\")\n-\t(match_operand:HI 1 \"general_operand\"  \"rI,m,r,m,z,x,t\"))]\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,<m,r,r,l\")\n+\t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,>m,t,r,i,l,r\"))]\n   \"\"\n-  \"@\n-\tmov\t%1,%0\n-\tmov.w\t%1,%0\n-\tmov.w\t%1,%0\n-\tmov.w\t%1,%0\n-\tmov.w\t%1,%0\n-\tsts\t%1,%0\n-\tmovt\t%0\"\n-  [(set_attr \"type\" \"move,load,store,load,store,move,move\")])\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      switch (get_attr_length(insn)) \n+\t{\n+\tcase 2:\n+\t  return \\\"mov.w\t%1,%0 ! 2 byte\\\";\n+\tcase 12:\n+\t  return \\\"mov.l\tTA%*,%0\\;bra\tTB%*\\;mov.w\t@%0,%0\\;.align 2\\;TA%*: .long %1\\;TB%*:%^\\\";\n+\t}\n+    case 1: return \\\"mov\t%1,%0\\\";\n+    case 2: return \\\"mov.w\t%1,%0\\\";\n+    case 3: return \\\"movt\t%0\\\";\n+    case 4: return \\\"mov.w\t%1,%0\\\";\n+    case 5: return \\\"fake %1,%0\\\";\n+    case 6: return \\\"sts\t%1,%0\\\";\n+    case 7: return \\\"lds\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"length\" \"*,2,2,2,2,2,2,2\")\n+   (set_attr \"type\" \"pcloadhi,move,load,move,store,move,move,move\")])\n \n (define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\"  \"\"))]\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:HI 1 \"general_movsrc_operand\"  \"\"))]\n   \"\"\n-  \"prepare_move_operands (operands, HImode);\")\n-  \n+  \"if (prepare_move_operands (operands, HImode)) DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n \t(match_operand:DI 1 \"arith_reg_operand\" \"r\"))]\n@@ -718,108 +1065,88 @@\n    [(set_attr \"length\" \"4\")\n     (set_attr \"type\" \"store\")])\n \n-(define_insn \"movdi_pcrel\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(match_operand:DI 1 \"hard_immediate_operand\" \"i\"))]\n-  \"\"\n-  \"* return output_movepcrel (insn, operands, DImode);\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"constneed\" \"yes\")\n-   (set_attr \"smallestsize\" \"4\")\n-   (set_attr \"constantsize\" \"8\")\n-   (set_attr \"largestsize\" \"18\")\n-   (set_attr \"type\" \"load\")])\n-\n-(define_insn \"movdi_k\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r,r,m,r,r,m,r\")\n-\t(match_operand:DI 1 \"general_operand\" \"r,m,r,I,m,r,x\"))]\n+(define_split \n+  [(set (match_operand:DI 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:DI 1 \"nonimmediate_operand\" \"\"))]\n   \"\"\n-  \"* return output_movedouble(operands, DImode);\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"move,load,store,move,load,store,load\")])\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"if (prepare_split_double_ops (operands, DImode)) DONE; else FAIL;\")\n \n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,r,r,m,r\")\n+\t(match_operand:DI 1 \"general_movsrc_operand\" \"Q,r,m,r,i\"))]\n+  \"register_operand (operands[0], DImode)\n+  || register_operand (operands[1], DImode)\"\n+  \"* return output_movedouble (insn, operands, DImode);\"\n+  [(set_attr \"length\" \"*,4,4,4,4\")\n+   (set_attr \"type\" \"pcloadsi,move,load,store,move\")])\n \n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DI 0 \"general_movdst_operand\" \"=r,m,r\")\n+\t(match_operand:DI 1 \"general_movsrc_operand\" \"m,r,i\"))]\n   \"\"\n-  \"prepare_move_operands (operands, DImode);\")\n+  \"if (prepare_move_operands(operands, DImode)) DONE;\")\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<\")\n \t(match_operand:DF 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n-   \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n+  \"mov.l\t%R1,%0\\;mov.l\t%1,%0\"\n    [(set_attr \"length\" \"4\")\n     (set_attr \"type\" \"store\")])\n \n-(define_insn \"movdf_pcrel\"\n-  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=r\")\n-\t(match_operand:DF 1 \"hard_immediate_operand\" \"i\"))]\n+(define_split \n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"\"))]\n   \"\"\n-  \"* return output_movepcrel  (insn, operands, DFmode);\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"constneed\" \"yes\")\n-   (set_attr \"smallestsize\" \"4\")\n-   (set_attr \"constantsize\" \"8\")\n-   (set_attr \"largestsize\" \"18\")\n-   (set_attr \"type\" \"load\")])\n+  [(set (match_dup 2) (match_dup 3))\n+   (set (match_dup 4) (match_dup 5))]\n+  \"if (prepare_split_double_ops (operands, DFmode)) DONE; else FAIL;\")\n \n (define_insn \"movdf_k\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,r,m\")\n-\t(match_operand:DF 1 \"general_operand\" \"r,m,r\"))]\n-  \"\"\n-  \"* return output_movedouble(operands, DFmode);\"\n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,m\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\" \"r,m,r\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"* return output_movedouble (insn, operands, DFmode);\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"move,load,store\")])\n \n (define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n-  \"prepare_move_operands(operands, DFmode);\")\n+  \"if (prepare_move_operands (operands, DFmode)) DONE;\")\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n \t(match_operand:SF 1 \"arith_reg_operand\" \"r\"))]\n    \"\"\n    \"mov.l\t%1,%0\"\n   [(set_attr \"type\" \"store\")])\n-\n-(define_insn \"movsf_pcrel\"\n-  [(set (match_operand:SF 0 \"arith_reg_operand\" \"=r\")\n-\t(match_operand:SF 1 \"hard_immediate_operand\" \"i\"))]\n-  \"\"\n-  \"* return output_movepcrel (insn, operands, SFmode);\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"constneed\" \"yes\")\n-   (set_attr \"smallestsize\" \"2\")\n-   (set_attr \"largestsize\" \"8\")\n-   (set_attr \"type\" \"load\")])\n \t\t\n (define_insn \"movsf_i\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,r,r,m,l,r,m,r\")\n-\t(match_operand:SF 1 \"general_operand\"  \"r,I,m,r,r,l,r,m\"))]\n+  [(set (match_operand:SF 0 \"general_movdst_operand\" \"=>,r,r,r,r,m,l,r\")\n+\t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,<,r,I,m,r,r,l\"))]\n   \"\"\n   \"@\n+        mov.l\t%1,@%N0\\;add\t#4,%N0\n+        add\t#-4,%1\\;mov.l\t@%N1,%0\n \tmov\t%1,%0\n \tmov\t%1,%0\n \tmov.l\t%1,%0\n \tmov.l\t%1,%0\n \tlds\t%1,%0\n-\tsts\t%1,%0\n-\tmov\t%1,%0\n-\tmov\t%1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store,move,move,move,move\")])\n+\tsts\t%1,%0\"\n+  [(set_attr \"type\" \"store,load,move,move,load,store,move,move\")\n+   (set_attr \"length\" \"4,4,*,*,*,*,*,*\")])\n \n (define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:SF 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:SF 1 \"general_movsrc_operand\" \"\"))]\n   \"\"\n-  \"prepare_move_operands(operands, SFmode);\")\n+  \"if (prepare_move_operands (operands, SFmode)) DONE;\")\n \n \f\n ;; ------------------------------------------------------------------------\n@@ -839,7 +1166,7 @@\n \t\t\t   (label_ref (match_operand 0 \"\" \"\"))\n \t\t\t   (pc)))]\n   \"\"\n-  \"* return output_branch (0, insn);\"\n+  \"* return output_branch (0, insn, operands[1]);\"\n   [(set_attr \"type\" \"cbranch\")])\n \n (define_insn \"inverse_branch_true\"\n@@ -869,12 +1196,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n-\n+  \"from_compare (operands, EQ);\")\n \n ; There is no bne compare, so we reverse the branch arms.\n \n@@ -886,138 +1208,103 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, NE);\")\n \n (define_expand \"bgt\"\n   [(set (reg:SI 18) (gt:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n \t(if_then_else (eq (reg:SI 18)\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t      (pc))) ]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, GT);\")\n \n (define_expand \"blt\"\n-  [(set (reg:SI 18) (lt:SI (match_dup 1) (match_dup 2)))\n+  [(set (reg:SI 18) (ge:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t(if_then_else (eq (reg:SI 18)(const_int 1))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, LT);\")\n \n (define_expand \"ble\"\n-  [(set (reg:SI 18) (le:SI (match_dup 1) (match_dup 2)))\n-   (set (pc)\t\t\t\t\n+  [(set (reg:SI 18) (gt:SI (match_dup 1) (match_dup 2)))\n+   (set (pc)\n \t(if_then_else (eq (reg:SI 18)\n \t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n+   ]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, LE);\")\n \n (define_expand \"bge\"\n   [(set (reg:SI 18) (ge:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n \t(if_then_else (eq (reg:SI 18)\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t      (pc))) ]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, GE);\")\n \n (define_expand \"bgtu\"\n   [(set (reg:SI 18) (gtu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n \t(if_then_else (eq (reg:SI 18)\n-\t\t\t   (const_int 1))\n+\t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, GTU); \")\n \n (define_expand \"bltu\"\n-  [(set (reg:SI 18) (ltu:SI (match_dup 1) (match_dup 2)))\n+  [(set (reg:SI 18) (geu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n-\t(if_then_else (eq (reg:SI 18)\n-\t\t\t   (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t  (if_then_else (eq (reg:SI 18)\n+\t\t\t\t    (const_int 1))\n+\t\t\t\t(pc)\n+\t\t\t\t(label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, LTU);\")\n \n (define_expand \"bgeu\"\n   [(set (reg:SI 18) (geu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n \t(if_then_else (eq (reg:SI 18)\n-\t\t\t   (const_int 1))\n+\t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t      (pc)))\n+   ]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, GEU);\")\n \n (define_expand \"bleu\"\n-  [(set (reg:SI 18) (leu:SI (match_dup 1) (match_dup 2)))\n+  [(set (reg:SI 18) (gtu:SI (match_dup 1) (match_dup 2)))\n    (set (pc)\n \t(if_then_else (eq (reg:SI 18)\n-\t\t\t   (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+\t\t\t  (const_int 1))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"\n-{\n-  operands[1] = sh_compare_op0;\n-  operands[2] = sh_compare_op1;\n-}\")\n+  \"from_compare (operands, LEU);\")\n \n \f\n ;; ------------------------------------------------------------------------\n ;; Jump and linkage insns\n ;; ------------------------------------------------------------------------\n \n-(define_insn \"jump_real\"\n+(define_insn \"jump\"\n   [(set (pc)\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"*\n {\n-  if (get_attr_length(insn) == 6) \n+  if (get_attr_length(insn) == 10) \n     {\n-      return \\\"mov.l\t%I0,r13\\;jmp\t@r13%#\\\";\n+      return output_far_jump(insn, operands[0]);\n     }\n   else\n     {\n@@ -1027,15 +1314,6 @@\n   [(set_attr \"type\" \"jump\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n-(define_expand \"jump\"\n- [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n- \"\"\n- \"\n-{\n-  emit_insn(gen_jump_real(operand0));\n-  DONE;\n-}\n-\")\n \n (define_insn \"calli\"\n   [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n@@ -1063,33 +1341,15 @@\n \t\t   (match_operand 1 \"\" \"\"))\n \t     (clobber (reg:SI 17))])]\n   \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM) \n-    {\n-      operands[0] \n-\t= gen_rtx(MEM,GET_MODE (operands[0]),\n-\t\t  force_reg (Pmode,\n-\t\t\t    XEXP (operands[0], 0)));\n-    }\n-}\")\n+  \"expand_acall(0, operands); DONE;\")\n \n (define_expand \"call_value\"\n   [(parallel[(set (match_operand 0 \"\" \"=rf\")\n \t\t  (call (match_operand 1 \"arith_reg_operand\" \"o\")\n \t\t\t(match_operand 2 \"\" \"\")))\n \t     (clobber (reg:SI 17))])]\n   \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) == MEM) \n-    {\n-      operands[1] \n-\t= gen_rtx (MEM, GET_MODE (operands[1]),\n-\t\t   force_reg (Pmode,\n-\t\t\t      XEXP (operands[1], 0)));\n-    }\n-}\")\n+  \"expand_acall(1, operands); DONE; \")\n \n (define_insn \"indirect_jump\"\n   [(set (pc)\n@@ -1100,36 +1360,107 @@\n    (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"length\" \"4\")])\n \n-\n \f\n ;; ------------------------------------------------------------------------\n ;; Misc insns\n ;; ------------------------------------------------------------------------\n \n+(define_insn \"dect\"\n+  [(parallel[\n+\t     (set (reg:SI 18)\n+\t\t  (eq:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t\t (const_int 1)))\n+\n+\t     (set (match_dup 0)\n+\t\t  (plus:SI (match_dup 0)\n+\t\t\t   (const_int -1)))])]\n+  \"TARGET_SH2\"\n+  \"dt\t%0\")\n \n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n   \"or\tr0,r0\")\n \n-(define_insn \"tablejump\"\n-  [(set (pc)\n-\t(match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n+; experimental use of auto inc and dec made these...\n+; can be deleted\n+\n+(define_insn \"fake\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (pre_dec:SI (match_operand:SI 1 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"!table jump\\;jmp\t@%0\\;or\tr0,r0\\;%!\"\n+  \"add\t#-1,%1\\;mov.b\t@%1,%0\"\n+  [(set_attr \"length\" \"4\")])\n+\n+;; Load address of a label. This is only generated by the casesi expand.\n+\n+(define_insn \"mova\"\n+  [(set (reg:SI 0) \n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"mova\t%O0,r0\"\n+  [(set_attr \"in_delay_slot\" \"no\")])\n+\n+;; case instruction for switch statements.\n+\n+;; Operand 0 is index\n+;; operand 1 is the minimum bound\n+;; operand 2 is the maximum bound - minimum bound + 1\n+;; operand 3 is CODE_LABEL for the table;\n+;; operand 4 is the CODE_LABEL to go to if index out of range.\n+\n+(define_expand \"casesi\"\n+  [(set (match_dup 5) (match_operand:SI 0 \"arith_reg_operand\" \"\"))\n+   (set (match_dup 5) (minus:SI (match_dup 5)\n+\t\t\t\t(match_operand:SI 1 \"arith_operand\" \"\")))\n+   (set (reg:SI 18)\n+\t(gtu:SI (match_dup 5)\n+\t\t(match_operand:SI 2 \"arith_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (eq (reg:SI 18)\n+\t\t\t  (const_int 1))\n+\t\t      (label_ref (match_operand 4 \"\" \"\"))\n+\t\t      (pc)))\n+   (set (match_dup 6) (plus:SI (match_dup 5) (match_dup 5)))\n+   (set (reg:SI 0) (label_ref (match_operand 3 \"\" \"\")))\n+   (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n+\t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n+\t\t\t\t\t\t       (match_dup 6)))))\n+\t     (set (match_dup 6) (mem:HI (plus:SI (reg:SI 0) (match_dup 6))))])\n+   (set (pc) (reg:SI 0))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+  operands[2] = copy_to_mode_reg (SImode, operands[2]);\n+  operands[5] = gen_reg_rtx (SImode);\n+  operands[6] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"casesi_worker\"\n+  [(set (reg:SI 0) \n+\t(plus:SI (reg:SI 0) \n+\t\t (mem:HI (plus:SI (reg:SI 0)\n+\t\t\t\t  (match_operand:SI 0 \"register_operand\" \"=r\")))))\n+   (set (match_dup 0) (mem:HI (plus:SI (reg:SI 0)\n+\t\t\t\t       (match_dup 0))))]\n+  \"\"\n+  \"mov.w\t@(r0,%0),%0\\;add\t%0,r0\"\n   [(set_attr \"needs_delay_slot\" \"no\")\n    (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"type\" \"jump\")\n-   (set_attr \"dump\" \"no\")])\n+   (set_attr \"length\" \"6\")])\n \n-(define_insn \"return\"\n+(define_insn \"\"\n  [(return)]\n- \"reload_completed\"\n- \"rts\t%#\"\n- [(set_attr \"type\" \"return\")\n-  (set_attr \"needs_delay_slot\" \"yes\")\n-  (set_attr \"dump\" \"yes\")])\n+ \"!pragma_interrupt && reload_completed\"\n+ \"rts%#\"\n+ [(set_attr \"type\" \"return\")])\n+\n+(define_insn \"\"\n+  [(return)]\n+  \"pragma_interrupt && reload_completed\"\n+  \"rte%#\"\n+  [(set_attr \"type\" \"rte\")])\n \n (define_expand \"prologue\"\n   [(const_int 0)]\n@@ -1152,7 +1483,7 @@\n ;; Scc instructions\n ;; ------------------------------------------------------------------------\n \n-(define_insn \"\"\n+(define_insn \"movt\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(eq (reg:SI 18) (const_int 1)))]\n   \"\"\n@@ -1219,59 +1550,6 @@\n   \"\"\n   \"operands[1] = prepare_scc_operands (EQ);\")\n \n-; these patterns give better code then gcc invents if\n-; left to its own devices\n-\n-(define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(and:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"and\t%2,%0\\;and\t%R2,%R0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(ior:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"or\t%2,%0\\;or\t%R2,%R0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"xordi3\"\n-  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n-\t(xor:DI (match_operand:DI 1 \"arith_reg_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"arith_reg_operand\" \"r\")))]\n-  \"\"\n-  \"xor\t%2,%0\\;xor\t%R2,%R0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-\f\n-;; ------------------------------------------------------------------------\n-;; Block move\n-;; ------------------------------------------------------------------------\n-\n-(define_expand \"movstrsi\"\n-  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n-\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n-\t     (use (match_operand:SI 2 \"general_operand\" \"\"))\n-\t     (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n-  ])]\n-  \"\"\n-  \"\n-{\n-  rtx dest_mem = operands[0];\n-  rtx src_mem = operands[1];\n-  operands[0] = copy_to_mode_reg (SImode, XEXP (operands[0], 0));\n-  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n-  expand_block_move (dest_mem, src_mem, operands);\n-  DONE;\n-}\")\n-\n-\n-\n-\n-   \n ;; -------------------------------------------------------------------------\n ;; Peepholes\n ;; -------------------------------------------------------------------------\n@@ -1281,39 +1559,39 @@\n   [(set (match_operand:QI 0 \"arith_reg_operand\" \"\")\n \t(mem:QI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n    (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.b\t@%1+,%0\")\n \n (define_peephole \n   [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n \t(mem:HI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n    (set (match_dup 1) (plus:SI (match_dup 1) (const_int 2)))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.w\t@%1+,%0\")\n \n (define_peephole \n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n    (set (match_dup 1) (plus:SI (match_dup 1) (const_int 4)))]\n-  \"REGNO(operands[1]) != REGNO(operands[0])\"\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n   \"mov.l\t@%1+,%0\")\n \n (define_peephole\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"general_operand\" \"g\"))\n+\t(match_operand:QI 1 \"memory_operand\" \"g\"))\n    (set (match_operand:SI 2 \"register_operand\" \"=r\")\n \t(sign_extend:SI (match_dup 0)))]\n-  \"REGNO(operands[0]) == REGNO(operands[2])\"\n-  \"mov.b\t%1,%0\")\n+  \"REGNO (operands[0]) == REGNO (operands[2])\"\n+  \"mov.b\t%1,%0 !p 5\")\n \n (define_peephole \n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"general_operand\" \"g\"))\n+\t(match_operand:QI 1 \"general_movsrc_operand\" \"g\"))\n    (set (match_operand:SI 2 \"register_operand\" \"=r\")\n \t(sign_extend:SI (match_dup 0)))]\n-  \"REGNO(operands[0]) != REGNO(operands[2]) \n+  \"REGNO (operands[0]) != REGNO (operands[2]) \n    && dead_or_set_p (insn, operands[0])\"\n-  \"mov.b\t%1,%2\")\n+  \"mov.b\t%1,%2 ! p4\")\n \n ; notice when a mov.b could be done with a displacement\n \n@@ -1322,17 +1600,302 @@\n \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 1 \"byte_index_operand\" \"i\")))\n    (set (mem:QI (match_dup 0))\t(reg:QI 0))]\n-  \"dead_or_set_p(insn, operands[0])\"\n+  \"dead_or_set_p (insn, operands[0])\"\n   \"mov.b\tr0,@(%O1,%0)\")\n \n (define_peephole\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_operand:SI 1 \"byte_index_operand\" \"i\")))\n    (set (reg:QI 0) (mem:QI (match_dup 0)))]\n-  \"dead_or_set_p(insn, operands[0])\"\n+  \"dead_or_set_p (insn, operands[0])\"\n   \"mov.b\t@(%O1,%0),r0\")\n   \n+;; -------------------------------------------------------------------------\n+;; Peepholes\n+;; -------------------------------------------------------------------------\n+\n+(define_peephole \n+  [(set (reg:SI 0) (label_ref (match_operand 0 \"\" \"\")))\n+   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n+\t(reg:SI 0))\n+   (set (reg:SI 0) (label_ref (match_dup 0)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(reg:SI 0))]\n+   \"\"\n+   \"mova\t%O0,r0\\;mov\tr0,%1\\;mov\tr0,%2\"\n+   [(set_attr \"length\" \"6\")\n+    (set_attr \"in_delay_slot\" \"no\")])\n+\n+\n+;\tmov\tr4,r3\n+;\tshll\tr3\n+;\tmov\tr3,r0\n+;->\n+;\tmov\tr4,r0\n+;\tshll\tr0\n+\n+(define_peephole \n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand:SI 1 \"register_operand\" \"r\"))\n+  (set (match_dup 0)\n+\t  (plus:SI (match_dup 0) (match_dup 1)))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(match_dup 0))]\n+  \"dead_or_set_p (NEXT_INSN (insn), operands[0])\"\n+  \"mov\t%1,%2\\;add\t%2,%2\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(and:SI (match_dup 0)\n+\t\t(const_int 1)))\n+   (set (match_operand:SI 1 \"arith_reg_operand\" \"=r\")\n+\t(const_int 0))\n+   (set (reg:SI 18)\n+\t(eq:SI (match_dup 0) (match_dup 1)))]\n+  \"dead_or_set_p (insn, operands[0])\n+   && dead_or_set_p (insn, operands[1])\"\n+  \"rotr\t%0\")\n+\n+(define_peephole\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"z,r\")\n+\t(and:SI (match_dup  0)\n+\t\t(match_operand:SI 1 \"arith_operand\" \"L,r\")))\n+   (set (reg:SI 18) \n+\t(eq:SI (match_dup 0) (const_int 0)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  \"tst\t%1,%0 !t5\")\n+  \n+(define_peephole\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"z,r\")\n+\t(and:SI (match_dup  0)\n+\t\t(match_operand:SI 1 \"arith_operand\" \"L,r\")))\n+   (set (reg:SI 18) \n+\t(eq:SI (match_dup 0) (const_int 0)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  \"tst\t%1,%0 !t4\")\n+\n+;; -------------------------------------------------------------------------\n+;; Combine patterns\n+;; -------------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:HI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"add\t%2,%0 ! why\")\n+\n+(define_insn \"addc_2\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=&r\")\n+\t(plus:SI (reg:SI 18)\n+\t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  \"mov\t#0,%0\\;addc\t%1,%0 ! addc1\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_insn \"combine_1\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(sign_extend:SI (mem:QI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))]\n+  \"\"\n+  \"mov.b\t@%1,%0 ! why\"\n+  [(set_attr \"type\" \"load\")])\n+  \n+(define_insn \"combine_2\"\n+  [(set (reg:SI 18)\n+\t(eq (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"z,r\")\n+\t\t    (match_operand:SI 1 \"arith_operand\" \"L,r\"))\n+\t    (const_int 0)))]\n+  \"\"\n+  \"tst\t%1,%0 !t2\")\n+\n+(define_split\n+  [(set (pc) \n+\t(if_then_else\n+\t (match_operator 2 \"equality_operator\" [(match_operand:SI 0 \"arith_reg_operand\" \"r\")\n+\t\t\t\t\t\t(const_int 0)])\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (clobber (reg:SI 18))]\n+  \"\"\n+  [(set (reg:SI 18) (eq (and:SI (match_dup 0) (match_dup 0))\n+\t\t\t(const_int 0)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 2 [(reg:SI 18) (const_int 1)])\n+\t\t      (label_ref (match_dup 1))\n+\t\t      (pc)))]\n+  \"\")\n+\n+;; -------------------------------------------------------------------------\n+;; Instructions to cope with inline literal tables\n+;; -------------------------------------------------------------------------\n+\n+; 2 byte integer in line\n \n+(define_insn \"consttable_2\"\n+ [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"=g\")] 2)]\n+ \"\"\n+ \"*\n+{\n+  assemble_integer (operands[0], 2, 1);\n+  return \\\"\\\";\n+}\"\n+ [(set_attr \"length\" \"2\")\n+ (set_attr \"in_delay_slot\" \"no\")])\n+\n+; 4 byte integer in line\n+\n+(define_insn \"consttable_4\"\n+ [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"=g\")] 4)]\n+ \"\"\n+ \"*\n+{\n+  assemble_integer (operands[0], 4, 1);\n+  return \\\"\\\";\n+}\"\n+ [(set_attr \"length\" \"4\")\n+  (set_attr \"in_delay_slot\" \"no\")])\n+\n+; 8 byte integer in line\n+\n+(define_insn \"consttable_8\"\n+ [(unspec_volatile [(match_operand:SI 0 \"general_operand\" \"=g\")] 6)]\n+ \"\"\n+ \"*\n+{\n+  assemble_integer (operands[0], 8, 1);\n+  return \\\"\\\";\n+}\"\n+ [(set_attr \"length\" \"8\")\n+  (set_attr \"in_delay_slot\" \"no\")])\n+\n+; align to a two byte boundary\n+\n+(define_insn \"align_2\"\n+ [(unspec_volatile [(const_int 0)] 10)]\n+ \"\"\n+ \".align 1\"\n+ [(set_attr \"length\" \"0\")\n+  (set_attr \"in_delay_slot\" \"no\")])\n+\n+; align to a four byte boundary\n+\n+(define_insn \"align_4\"\n+ [(unspec_volatile [(const_int 0)] 5)]\n+ \"\"\n+ \".align 2\"\n+ [(set_attr \"in_delay_slot\" \"no\")])\n+\n+; emitted at the end of the literal table, used to emit the\n+; 32bit branch labels if needed.\n+\n+(define_insn \"consttable_end\"\n+  [(unspec_volatile [(const_int 0)] 11)]\n+  \"\"\n+  \"* return output_jump_label_table ();\"\n+  [(set_attr \"in_delay_slot\" \"no\")])\n+\n+\n+;(define_split \n+;  [(set (subreg:SI (match_operand:QI 0 \"register_operand\" \"=r\") 0)\n+;\t(plus:SI (subreg:SI (match_operand:QI 1 \"general_operand\" \"g\") 0)\n+;\t\t (subreg:SI (match_operand:QI 2 \"general_operand\" \"g\") 0)))]\n+;  \"\"\n+;  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))\n+;   (set (match_dup 1) (subreg:SI (match_dup 3) 0))]\n+;  \"operands[3] = gen_reg_rtx(SImode);\")\n+\n+\n+; byte arithmetic involving constants which need to be sign extended can be \n+; fixed up...\n+\n+\n+(define_split \n+  [(set (subreg:SI (match_operand:QI 0 \"register_operand\" \"=r\") 0)\n+\t(plus:SI (subreg:SI (match_operand:QI 1 \"register_operand\" \"0\") 0)\n+\t\t (subreg:SI (match_operand 2 \"immediate_operand\" \"n\") 0)))]\n+  \"\"\n+  [(set (match_dup 4) (plus:SI (match_dup 2) (match_dup 3)))\n+   (set (match_dup 0) (and:SI (match_dup 0) (const_int 255)))]\n+  \"{ int i = INTVAL(operands[2]) & 0xff;\n+   if (i > 127) i = i - 256;\n+   operands[3] = GEN_INT(i); \n+   operands[4] = gen_reg_rtx(SImode);} \")\n+\n+\n+(define_insn \"movsi_k\"\n+ [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  \"!pnum_clobbers\"\n+  \"! this is a fake\")\n+\n+\n+(define_insn \"movhi_k\"\n+ [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+       (match_operand:HI 1 \"immediate_operand\" \"\"))]\n+  \"!pnum_clobbers\"\n+  \"! this is a fake\")\n+\n+(define_insn \"movdi_k\"\n+ [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+       (match_operand:DI 1 \"immediate_operand\" \"\"))]\n+  \"!pnum_clobbers\"\n+  \"! this is a fake\")\n+\n+;; -------------------------------------------------------------------------\n+;; Misc\n+;; -------------------------------------------------------------------------\n+\n+\n+;; String/block move insn.  \n+\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"\" \"\")))\n+\t      (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 4))\n+\t      (clobber (reg:SI 5))\n+\t      (clobber (reg:SI 0))])]\n+  \"\"\n+  \"\n+{\n+  if(expand_block_move (operands))\n+     DONE;\n+  else FAIL;\n+}\")\n+\n+(define_insn \"block_move_real\"\n+  [(parallel [(set (mem:BLK (reg:SI 4))\n+\t\t   (mem:BLK (reg:SI 5)))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 4))\n+\t      (clobber (reg:SI 5))\n+\t      (clobber (reg:SI 0))])]\n+  \"\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"block_lump_real\"\n+  [(parallel [(set (mem:BLK (reg:SI 4))\n+\t\t   (mem:BLK (reg:SI 5)))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (use (reg:SI 6))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 4))\n+\t      (clobber (reg:SI 5))\n+\t      (clobber (reg:SI 6))\n+\t      (clobber (reg:SI 0))])]\n+  \"\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n \n "}]}