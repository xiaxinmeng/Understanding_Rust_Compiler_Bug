{"sha": "e075ae69f9d1263e78376038ab138c03e279f391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA3NWFlNjlmOWQxMjYzZTc4Mzc2MDM4YWIxMzhjMDNlMjc5ZjM5MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-02T04:20:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-02T04:20:21Z"}, "message": "Merge new ia32 backend from the branch!\n\nFrom-SVN: r29044", "tree": {"sha": "2741b1e654e069ae0926889ad907a3122fc70944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2741b1e654e069ae0926889ad907a3122fc70944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e075ae69f9d1263e78376038ab138c03e279f391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e075ae69f9d1263e78376038ab138c03e279f391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e075ae69f9d1263e78376038ab138c03e279f391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e075ae69f9d1263e78376038ab138c03e279f391/comments", "author": null, "committer": null, "parents": [{"sha": "a41cb705f69a848a70b1765cc0e9fdb70a079db9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41cb705f69a848a70b1765cc0e9fdb70a079db9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41cb705f69a848a70b1765cc0e9fdb70a079db9"}], "stats": {"total": 21918, "additions": 10766, "deletions": 11152}, "files": [{"sha": "c6188fb563e5eb7f341638c358e63f0af547f1a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -1,3 +1,18 @@\n+Wed Sep  1 21:13:48 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\tMerge new ia32 backend from the branch!\n+\n+\t* i386.h, i386.c, i386.md, reg-stack.c, i386/unix.h: Many changes.\n+\tSee ChangeLog.P2 on new_ia32_branch for details.\n+\n+\t* rtl.h (stack_regs_mentioned_p): Delete prototype.\n+\t* i386/cygwin.h (SUBTARGET_PROLOGUE): No more do_rtl.\n+\t* i386/win32.h (SUBTARGET_PROLOGUE): Likewise.\n+\t* i386/gas.h (ASM_FILE_START): Define.\n+\t* i386/winnt.c (i386_pe_valid_decl_attribute_p): Update\n+\tfor name change of ix86_valid_decl_attribute_p.\n+\t(i386_pe_valid_type_attribute_p): Similarly.\n+\n Wed Sep  1 18:21:23 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* emit-rtl.c (init_emit_once): Don't use GET_MODE_WIDER_MODE"}, {"sha": "a6e967f15257bf8c2203198c21f9c10e904cbb3e", "filename": "gcc/config/i386/cygwin.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fcygwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fcygwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.h?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -482,13 +482,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n       && strcmp (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),\\\n \t\t \"main\") == 0)\t\t\t\t\t\t\\\n      {\t\t\t\t\t\t\t\t\t\\\n-      rtx xops[1];\t\t\t\t\t\t\t\\\n-      xops[0] = gen_rtx_MEM (FUNCTION_MODE,\t\t\t\t\\\n-\t\t\t gen_rtx (SYMBOL_REF, Pmode, \"_monstartup\"));\t\\\n-      if (do_rtl)\t\t\t\t\t\t\t\\\n-\temit_call_insn (gen_rtx (CALL, VOIDmode, xops[0], const0_rtx));\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\toutput_asm_insn (AS1 (call,%P1), xops);\t\t\t\\\n+      emit_call_insn (gen_rtx (CALL, VOIDmode, \t\t\t\t\\\n+        gen_rtx_MEM (FUNCTION_MODE,\t\t\t\t\t\\\n+\t\t     gen_rtx_SYMBOL_REF (Pmode, \"_monstartup\")),\t\\\n+\tconst0_rtx));\t\t\t\t\t\t\t\\\n      }\n \n /* External function declarations.  */"}, {"sha": "cef43857b0792d1d1a0bcd6ff10de255f8f5e493", "filename": "gcc/config/i386/gas.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fgas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fgas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgas.h?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -160,3 +160,14 @@ Boston, MA 02111-1307, USA.  */\n   fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n \n #endif /* NO_UNDERSCORES */\n+\n+/* Output at beginning of assembler file.  */\n+/* The .file command should always begin the output.  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+\tif (target_flags & MASK_INTEL_SYNTAX)\t\t\t\t\\\n+\t  fputs (\"\\t.intel_syntax\\n\", FILE);\t\t\t\t\\\n+        output_file_directive (FILE, main_input_filename);\t\t\\\n+        fputs (\"\\t.version\\t\\\"01.01\\\"\\n\", FILE);\t\t\t\\\n+  } while (0)"}, {"sha": "faa4eac070fc54021712051d2a457fae6fbf5427", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3450, "deletions": 3470, "changes": 6920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e075ae69f9d1263e78376038ab138c03e279f391"}, {"sha": "ec05ac468f8c305cebb2dd634188f19fd3a51fff", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 549, "deletions": 807, "changes": 1356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -1,6 +1,5 @@\n-/* Definitions of target machine for GNU compiler for Intel X86\n-   (386, 486, Pentium).\n-   Copyright (C) 1988, 92, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.\n+/* Definitions of target machine for GNU compiler for IA-32.\n+   Copyright (C) 1988, 92, 94-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -30,9 +29,9 @@ Boston, MA 02111-1307, USA. */\n \n    Many macros that specify assembler syntax are omitted entirely from\n    this file because they really belong in the files for particular\n-   assemblers.  These include AS1, AS2, AS3, RP, IP, LPREFIX, L_SIZE,\n-   PUT_OP_SIZE, USE_STAR, ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE,\n-   PRINT_B_I_S, and many that start with ASM_ or end in ASM_OP.  */\n+   assemblers.  These include RP, IP, LPREFIX, PUT_OP_SIZE, USE_STAR,\n+   ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE, PRINT_B_I_S, and many\n+   that start with ASM_ or end in ASM_OP.  */\n \n /* Names to predefine in the preprocessor for this target machine.  */\n \n@@ -62,6 +61,7 @@ struct processor_costs {\n   int mult_init;\t\t/* cost of starting a multiply */\n   int mult_bit;\t\t\t/* cost of multiply per each bit set */\n   int divide;\t\t\t/* cost of a divide/mod */\n+  int large_insn;\t\t/* insns larger than this cost more */\n };\n \n extern struct processor_costs *ix86_cost;\n@@ -73,29 +73,26 @@ extern int target_flags;\n /* Macros used in the machine description to test the flags.  */\n \n /* configure can arrange to make this 2, to force a 486.  */\n+\n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT 0\n #endif\n \n /* Masks for the -m switches */\n-#define MASK_80387\t\t000000000001\t/* Hardware floating point */\n-#define MASK_NOTUSED1\t\t000000000002\t/* bit not currently used */\n-#define MASK_NOTUSED2\t\t000000000004\t/* bit not currently used */\n-#define MASK_RTD\t\t000000000010\t/* Use ret that pops args */\n-#define MASK_ALIGN_DOUBLE\t000000000020\t/* align doubles to 2 word boundary */\n-#define MASK_SVR3_SHLIB\t\t000000000040\t/* Uninit locals into bss */\n-#define MASK_IEEE_FP\t\t000000000100\t/* IEEE fp comparisons */\n-#define MASK_FLOAT_RETURNS\t000000000200\t/* Return float in st(0) */\n-#define MASK_NO_FANCY_MATH_387\t000000000400\t/* Disable sin, cos, sqrt */\n-#define MASK_OMIT_LEAF_FRAME_POINTER 0x00000800 /* omit leaf frame pointers */\n-\t\t\t\t\t\t/* Temporary codegen switches */\n-#define MASK_DEBUG_ADDR\t\t000001000000\t/* Debug GO_IF_LEGITIMATE_ADDRESS */\n-#define MASK_NO_WIDE_MULTIPLY\t000002000000\t/* Disable 32x32->64 multiplies */\n-#define MASK_NO_MOVE\t\t000004000000\t/* Don't generate mem->mem */\n-#define MASK_NO_PSEUDO\t\t000010000000\t/* Move op's args -> pseudos */\n-#define MASK_DEBUG_ARG\t\t000020000000\t/* Debug function_arg */   \n-#define MASK_SCHEDULE_PROLOGUE  000040000000    /* Emit prologue as rtl */\n-#define MASK_STACK_PROBE\t000100000000\t/* Enable stack probing */\n+#define MASK_80387\t\t0x00000001\t/* Hardware floating point */\n+#define MASK_RTD\t\t0x00000002\t/* Use ret that pops args */\n+#define MASK_ALIGN_DOUBLE\t0x00000004\t/* align doubles to 2 word boundary */\n+#define MASK_SVR3_SHLIB\t\t0x00000008\t/* Uninit locals into bss */\n+#define MASK_IEEE_FP\t\t0x00000010\t/* IEEE fp comparisons */\n+#define MASK_FLOAT_RETURNS\t0x00000020\t/* Return float in st(0) */\n+#define MASK_NO_FANCY_MATH_387\t0x00000040\t/* Disable sin, cos, sqrt */\n+#define MASK_OMIT_LEAF_FRAME_POINTER 0x080      /* omit leaf frame pointers */\n+#define MASK_STACK_PROBE\t0x00000100\t/* Enable stack probing */\n+\n+/* Temporary codegen switches */\n+#define MASK_INTEL_SYNTAX\t0x10000000\n+#define MASK_DEBUG_ARG\t\t0x20000000\t/* function_arg */   \n+#define MASK_DEBUG_ADDR\t\t0x40000000\t/* GO_IF_LEGITIMATE_ADDRESS */\n \n /* Use the floating point instructions */\n #define TARGET_80387 (target_flags & MASK_80387)\n@@ -129,28 +126,15 @@ extern int target_flags;\n #define TARGET_NO_FANCY_MATH_387 (target_flags & MASK_NO_FANCY_MATH_387)\n \n /* Don't create frame pointers for leaf functions */\n-#define TARGET_OMIT_LEAF_FRAME_POINTER (target_flags & MASK_OMIT_LEAF_FRAME_POINTER)\n-\n-/* Temporary switches for tuning code generation */\n-\n-/* Disable 32x32->64 bit multiplies that are used for long long multiplies\n-   and division by constants, but sometimes cause reload problems.  */\n-#define TARGET_NO_WIDE_MULTIPLY (target_flags & MASK_NO_WIDE_MULTIPLY)\n-#define TARGET_WIDE_MULTIPLY (!TARGET_NO_WIDE_MULTIPLY)\n-\n-/* Emit/Don't emit prologue as rtl */\n-#define TARGET_SCHEDULE_PROLOGUE (target_flags & MASK_SCHEDULE_PROLOGUE)\n+#define TARGET_OMIT_LEAF_FRAME_POINTER \\\n+  (target_flags & MASK_OMIT_LEAF_FRAME_POINTER)\n \n /* Debug GO_IF_LEGITIMATE_ADDRESS */\n #define TARGET_DEBUG_ADDR (target_flags & MASK_DEBUG_ADDR)\n \n /* Debug FUNCTION_ARG macros */\n #define TARGET_DEBUG_ARG (target_flags & MASK_DEBUG_ARG)\n \n-/* Hack macros for tuning code generation */\n-#define TARGET_MOVE\t((target_flags & MASK_NO_MOVE) == 0)\t/* Don't generate memory->memory */\n-#define TARGET_PSEUDO\t((target_flags & MASK_NO_PSEUDO) == 0)\t/* Move op's args into pseudos */\n-\n #define TARGET_386 (ix86_cpu == PROCESSOR_I386)\n #define TARGET_486 (ix86_cpu == PROCESSOR_I486)\n #define TARGET_PENTIUM (ix86_cpu == PROCESSOR_PENTIUM)\n@@ -161,7 +145,10 @@ extern int target_flags;\n extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;\n extern const int x86_use_bit_test, x86_cmove, x86_deep_branch;\n extern const int x86_unroll_strlen, x86_use_q_reg, x86_use_any_reg;\n-extern const int x86_double_with_add;\n+extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;\n+extern const int x86_use_loop, x86_use_fiop, x86_use_mov0;\n+extern const int x86_use_cltd, x86_read_modify_write;\n+extern const int x86_read_modify, x86_split_long_moves;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -173,81 +160,87 @@ extern const int x86_double_with_add;\n #define TARGET_CMOVE (x86_cmove & (1 << ix86_arch))\n #define TARGET_DEEP_BRANCH_PREDICTION (x86_deep_branch & CPUMASK)\n #define TARGET_DOUBLE_WITH_ADD (x86_double_with_add & CPUMASK)\n+#define TARGET_USE_SAHF (x86_use_sahf & CPUMASK)\n+#define TARGET_MOVX (x86_movx & CPUMASK)\n+#define TARGET_PARTIAL_REG_STALL (x86_partial_reg_stall & CPUMASK)\n+#define TARGET_USE_LOOP (x86_use_loop & CPUMASK)\n+#define TARGET_USE_FIOP (x86_use_fiop & CPUMASK)\n+#define TARGET_USE_MOV0 (x86_use_mov0 & CPUMASK)\n+#define TARGET_USE_CLTD (x86_use_cltd & CPUMASK)\n+#define TARGET_SPLIT_LONG_MOVES (x86_split_long_moves & CPUMASK)\n+#define TARGET_READ_MODIFY_WRITE (x86_read_modify_write & CPUMASK)\n+#define TARGET_READ_MODIFY (x86_read_modify & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n \n-#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-{ { \"80387\",\t\t\t MASK_80387, \"Use hardware fp\" },\t\\\n-  { \"no-80387\",\t\t\t-MASK_80387, \"Do not use hardware fp\" },\\\n-  { \"hard-float\",\t\t MASK_80387, \"Use hardware fp\" },\t\\\n-  { \"soft-float\",\t\t-MASK_80387, \"Do not use hardware fp\" },\\\n-  { \"no-soft-float\",\t\t MASK_80387, \"Use hardware fp\" },\t\\\n-  { \"386\",\t\t\t 0, \"Same as -mcpu=i386\" },\t\t\\\n-  { \"486\",\t\t\t 0, \"Same as -mcpu=i486\" },\t\t\\\n-  { \"pentium\",\t\t\t 0, \"Same as -mcpu=pentium\" },\t\t\\\n-  { \"pentiumpro\",\t\t 0, \"Same as -mcpu=pentiumpro\" },\t\\\n-  { \"rtd\",\t\t\t MASK_RTD, \"Alternate calling convention\" },\\\n-  { \"no-rtd\",\t\t\t-MASK_RTD, \"Use normal calling convention\" },\\\n-  { \"align-double\",\t\t MASK_ALIGN_DOUBLE, \"Align some doubles on dword boundary\" },\\\n-  { \"no-align-double\",\t\t-MASK_ALIGN_DOUBLE, \"Align doubles on word boundary\" },\t\t\\\n-  { \"svr3-shlib\",\t\t MASK_SVR3_SHLIB, \"Uninitialized locals in .bss\"  },\t\t\t\\\n-  { \"no-svr3-shlib\",\t\t-MASK_SVR3_SHLIB, \"Uninitialized locals in .data\" },\t\t\t\\\n-  { \"ieee-fp\",\t\t\t MASK_IEEE_FP, \"Use IEEE math for fp comparisons\" },\t\\\n-  { \"no-ieee-fp\",\t\t-MASK_IEEE_FP, \"Do not use IEEE math for fp comparisons\" },\t\t\t\\\n-  { \"fp-ret-in-387\",\t\t MASK_FLOAT_RETURNS, \"Return values of functions in FPU registers\" },\t\t\t\\\n-  { \"no-fp-ret-in-387\",\t\t-MASK_FLOAT_RETURNS , \"Do not return values of functions in FPU registers\"},\t\t\t\\\n-  { \"no-fancy-math-387\",\t MASK_NO_FANCY_MATH_387, \"Do not generate sin, cos, sqrt for 387\" },\t\t\\\n-  { \"fancy-math-387\",\t\t-MASK_NO_FANCY_MATH_387, \"Generate sin, cos, sqrt for FPU\"},\t\t\\\n-  { \"omit-leaf-frame-pointer\",\t MASK_OMIT_LEAF_FRAME_POINTER, \"Omit the frame pointer in leaf functions\" }, \t\\\n-  { \"no-omit-leaf-frame-pointer\",-MASK_OMIT_LEAF_FRAME_POINTER, \"\" },       \\\n-  { \"no-wide-multiply\",\t\t MASK_NO_WIDE_MULTIPLY, \"multiplies of 32 bits constrained to 32 bits\" },\t\t\\\n-  { \"wide-multiply\",\t\t-MASK_NO_WIDE_MULTIPLY, \"multiplies of 32 bits are 64 bits\" },\t\t\\\n-  { \"schedule-prologue\",\t MASK_SCHEDULE_PROLOGUE, \"Schedule function prologues\" },\t\t\\\n-  { \"no-schedule-prologue\",\t-MASK_SCHEDULE_PROLOGUE, \"\" },\t\t\\\n-  { \"debug-addr\",\t\t MASK_DEBUG_ADDR, 0 /* intentionally undoc */ },\t\t\t\\\n-  { \"no-debug-addr\",\t\t-MASK_DEBUG_ADDR, 0 /* intentionally undoc */ },\t\t\t\\\n-  { \"move\",\t\t\t-MASK_NO_MOVE, \"Generate mem-mem moves\" },\t\t\t\\\n-  { \"no-move\",\t\t\t MASK_NO_MOVE, \"Don't generate mem-mem moves\" },\t\t\t\\\n-  { \"debug-arg\",\t\t MASK_DEBUG_ARG, 0 /* intentionally undoc */ },\t\t\t\\\n-  { \"no-debug-arg\",\t\t-MASK_DEBUG_ARG, 0 /* intentionally undoc */ },\t\t\t\\\n-  { \"stack-arg-probe\",\t\t MASK_STACK_PROBE, \"Enable stack probing\" },\t\t\t\\\n-  { \"no-stack-arg-probe\",\t-MASK_STACK_PROBE, \"\" },\t\t\t\\\n-  { \"windows\",\t\t\t0, 0 /* intentionally undoc */ },\t\t\t\t\t\\\n-  { \"dll\",\t\t\t0, 0 /* intentionally undoc */ },\t\t\t\t\t\\\n-  SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n-  { \"\", MASK_SCHEDULE_PROLOGUE | TARGET_DEFAULT, 0 }}\n+#define ASSEMBLER_DIALECT ((target_flags & MASK_INTEL_SYNTAX) != 0)\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t      \\\n+{ { \"80387\",\t\t\t MASK_80387, \"Use hardware fp\" },\t      \\\n+  { \"no-80387\",\t\t\t-MASK_80387, \"Do not use hardware fp\" },      \\\n+  { \"hard-float\",\t\t MASK_80387, \"Use hardware fp\" },\t      \\\n+  { \"soft-float\",\t\t-MASK_80387, \"Do not use hardware fp\" },      \\\n+  { \"no-soft-float\",\t\t MASK_80387, \"Use hardware fp\" },\t      \\\n+  { \"386\",\t\t\t 0, \"Same as -mcpu=i386\" },\t\t      \\\n+  { \"486\",\t\t\t 0, \"Same as -mcpu=i486\" },\t\t      \\\n+  { \"pentium\",\t\t\t 0, \"Same as -mcpu=pentium\" },\t\t      \\\n+  { \"pentiumpro\",\t\t 0, \"Same as -mcpu=pentiumpro\" },\t      \\\n+  { \"rtd\",\t\t\t MASK_RTD, \"Alternate calling convention\" },  \\\n+  { \"no-rtd\",\t\t\t-MASK_RTD, \"Use normal calling convention\" }, \\\n+  { \"align-double\",\t\t MASK_ALIGN_DOUBLE,\t\t\t      \\\n+    \"Align some doubles on dword boundary\" },\t\t\t\t      \\\n+  { \"no-align-double\",\t\t-MASK_ALIGN_DOUBLE,\t\t\t      \\\n+    \"Align doubles on word boundary\" },\t\t\t\t\t      \\\n+  { \"svr3-shlib\",\t\t MASK_SVR3_SHLIB,\t\t\t      \\\n+    \"Uninitialized locals in .bss\"  },\t\t\t\t\t      \\\n+  { \"no-svr3-shlib\",\t\t-MASK_SVR3_SHLIB,\t\t\t      \\\n+    \"Uninitialized locals in .data\" },\t\t\t\t\t      \\\n+  { \"ieee-fp\",\t\t\t MASK_IEEE_FP,\t\t\t\t      \\\n+    \"Use IEEE math for fp comparisons\" },\t\t\t\t      \\\n+  { \"no-ieee-fp\",\t\t-MASK_IEEE_FP,\t\t\t\t      \\\n+    \"Do not use IEEE math for fp comparisons\" },\t\t\t      \\\n+  { \"fp-ret-in-387\",\t\t MASK_FLOAT_RETURNS,\t\t\t      \\\n+    \"Return values of functions in FPU registers\" },\t\t\t      \\\n+  { \"no-fp-ret-in-387\",\t\t-MASK_FLOAT_RETURNS ,\t\t\t      \\\n+    \"Do not return values of functions in FPU registers\"},\t\t      \\\n+  { \"no-fancy-math-387\",\t MASK_NO_FANCY_MATH_387,\t\t      \\\n+    \"Do not generate sin, cos, sqrt for FPU\" },\t\t\t\t      \\\n+  { \"fancy-math-387\",\t\t-MASK_NO_FANCY_MATH_387,\t\t      \\\n+     \"Generate sin, cos, sqrt for FPU\"},\t\t\t\t      \\\n+  { \"omit-leaf-frame-pointer\",\t MASK_OMIT_LEAF_FRAME_POINTER,\t\t      \\\n+    \"Omit the frame pointer in leaf functions\" },\t\t\t      \\\n+  { \"no-omit-leaf-frame-pointer\",-MASK_OMIT_LEAF_FRAME_POINTER, \"\" },\t      \\\n+  { \"debug-addr\",\t\t MASK_DEBUG_ADDR, 0 /* undocumented */ },     \\\n+  { \"no-debug-addr\",\t\t-MASK_DEBUG_ADDR, 0 /* undocumented */ },     \\\n+  { \"debug-arg\",\t\t MASK_DEBUG_ARG, 0 /* undocumented */ },      \\\n+  { \"no-debug-arg\",\t\t-MASK_DEBUG_ARG, 0 /* undocumented */ },      \\\n+  { \"stack-arg-probe\",\t\t MASK_STACK_PROBE, \"Enable stack probing\" },  \\\n+  { \"no-stack-arg-probe\",\t-MASK_STACK_PROBE, \"\" },\t\t      \\\n+  { \"windows\",\t\t\t0, 0 /* undocumented */ },\t\t      \\\n+  { \"dll\",\t\t\t0,  0 /* undocumented */ },\t\t      \\\n+  { \"intel-syntax\",\t\tMASK_INTEL_SYNTAX,\t\t\t      \\\n+    \"Emit Intel syntax assembler opcodes\" },\t\t\t\t      \\\n+  { \"no-intel-syntax\",\t\t-MASK_INTEL_SYNTAX, \"\" },\t\t      \\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\t      \\\n+  { \"\", TARGET_DEFAULT, 0 }}\n \n /* Which processor to schedule for. The cpu attribute defines a list that\n    mirrors this list, so changes to i386.md must be made at the same time.  */\n \n enum processor_type\n- {PROCESSOR_I386,\t\t\t/* 80386 */\n+{\n+  PROCESSOR_I386,\t\t\t/* 80386 */\n   PROCESSOR_I486,\t\t\t/* 80486DX, 80486SX, 80486DX[24] */\n   PROCESSOR_PENTIUM,\n   PROCESSOR_PENTIUMPRO,\n-  PROCESSOR_K6};\n-\n-#define PROCESSOR_I386_STRING \"i386\"\n-#define PROCESSOR_I486_STRING \"i486\"\n-#define PROCESSOR_I586_STRING \"i586\"\n-#define PROCESSOR_PENTIUM_STRING \"pentium\"\n-#define PROCESSOR_I686_STRING \"i686\"\n-#define PROCESSOR_PENTIUMPRO_STRING \"pentiumpro\"\n-#define PROCESSOR_K6_STRING \"k6\"\n+  PROCESSOR_K6,\n+  PROCESSOR_max\n+};\n \n extern enum processor_type ix86_cpu;\n \n extern int ix86_arch;\n \n-/* Define the default processor.  This is overridden by other tm.h files.  */\n-#define PROCESSOR_DEFAULT (enum processor_type) TARGET_CPU_DEFAULT\n-#define PROCESSOR_DEFAULT_STRING \\\n-  (PROCESSOR_DEFAULT == PROCESSOR_I486 ? PROCESSOR_I486_STRING  \\\n-  : PROCESSOR_DEFAULT == PROCESSOR_PENTIUM ? PROCESSOR_PENTIUM_STRING  \\\n-  : PROCESSOR_DEFAULT == PROCESSOR_PENTIUMPRO ? PROCESSOR_PENTIUMPRO_STRING  \\\n-  : PROCESSOR_DEFAULT == PROCESSOR_K6 ? PROCESSOR_K6_STRING  \\\n-  : PROCESSOR_I386_STRING)\n-\n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n    initializer with a subgrouping for each command option.\n@@ -257,17 +250,27 @@ extern int ix86_arch;\n    variable, type `char *', is set to the variable part of the given\n    option if the fixed part matches.  The actual option name is made\n    by appending `-m' to the specified name.  */\n-#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n-{ { \"cpu=\",\t\t&ix86_cpu_string, \"Schedule code for given CPU\"}, \\\n-  { \"arch=\",\t\t&ix86_arch_string, \"Generate code for given CPU\"}, \\\n-  { \"reg-alloc=\",\t&i386_reg_alloc_order, \"Control allocation order of integer registers\" }, \\\n-  { \"regparm=\",\t\t&i386_regparm_string, \"Number of registers used to pass integer arguments\" }, \\\n-  { \"align-loops=\",\t&i386_align_loops_string, \"Loop code aligned to this power of 2\" }, \\\n-  { \"align-jumps=\",\t&i386_align_jumps_string, \"Jump targets are aligned to this power of 2\" }, \\\n-  { \"align-functions=\",\t&i386_align_funcs_string, \"Function starts are aligned to this power of 2\" }, \\\n-  { \"preferred-stack-boundary=\", &i386_preferred_stack_boundary_string, \"Attempt to keep stack aligned to this power of 2\" }, \\\n-  { \"branch-cost=\",\t&i386_branch_cost_string, \"Branches are this expensive (1-5, arbitrary units)\" },\t\t\t\\\n-  SUBTARGET_OPTIONS\t\t\t\t\t\t\t\\\n+#define TARGET_OPTIONS\t\t\t\t\t\t\\\n+{ { \"cpu=\",\t\t&ix86_cpu_string,\t\t\t\\\n+    \"Schedule code for given CPU\"},\t\t\t\t\\\n+  { \"arch=\",\t\t&ix86_arch_string,\t\t\t\\\n+    \"Generate code for given CPU\"},\t\t\t\t\\\n+  { \"reg-alloc=\",\t&ix86_reg_alloc_order,\t\t\t\\\n+    \"Control allocation order of integer registers\" },\t\t\\\n+  { \"regparm=\",\t\t&ix86_regparm_string,\t\t\t\\\n+    \"Number of registers used to pass integer arguments\" },\t\\\n+  { \"align-loops=\",\t&ix86_align_loops_string,\t\t\\\n+    \"Loop code aligned to this power of 2\" },\t\t\t\\\n+  { \"align-jumps=\",\t&ix86_align_jumps_string,\t\t\\\n+    \"Jump targets are aligned to this power of 2\" },\t\t\\\n+  { \"align-functions=\",\t&ix86_align_funcs_string,\t\t\\\n+    \"Function starts are aligned to this power of 2\" },\t\t\\\n+  { \"preferred-stack-boundary=\",\t\t\t\t\\\n+    &ix86_preferred_stack_boundary_string,\t\t\t\\\n+    \"Attempt to keep stack aligned to this power of 2\" },\t\\\n+  { \"branch-cost=\",\t&ix86_branch_cost_string,\t\t\\\n+    \"Branches are this expensive (1-5, arbitrary units)\" },\t\\\n+  SUBTARGET_OPTIONS\t\t\t\t\t\t\\\n }\n \n /* Sometimes certain combinations of command options do not make\n@@ -294,34 +297,34 @@ extern int ix86_arch;\n #define CC1_CPU_SPEC \"\\\n %{!mcpu*: \\\n %{m386:-mcpu=i386 -march=i386} \\\n+%{mno-486:-mcpu=i386 -march=i386} \\\n %{m486:-mcpu=i486 -march=i486} \\\n+%{mno-386:-mcpu=i486 -march=i486} \\\n+%{mno-pentium:-mcpu=i486 -march=i486} \\\n %{mpentium:-mcpu=pentium} \\\n+%{mno-pentiumpro:-mcpu=pentium} \\\n %{mpentiumpro:-mcpu=pentiumpro}}\"\n #endif\n \f\n #define CPP_486_SPEC \"%{!ansi:-Di486} -D__i486 -D__i486__\"\n #define CPP_586_SPEC \"%{!ansi:-Di586 -Dpentium} \\\n \t-D__i586 -D__i586__ -D__pentium -D__pentium__\"\n-#define CPP_K6_SPEC \"%{!ansi:-Di586 -Dk6} \\\n-\t-D__i586 -D__i586__ -D__k6 -D__k6__\" \n #define CPP_686_SPEC \"%{!ansi:-Di686 -Dpentiumpro} \\\n \t-D__i686 -D__i686__ -D__pentiumpro -D__pentiumpro__\"\n \n #ifndef CPP_CPU_DEFAULT_SPEC\n #if TARGET_CPU_DEFAULT == 1\n #define CPP_CPU_DEFAULT_SPEC \"%(cpp_486)\"\n-#endif\n+#else\n #if TARGET_CPU_DEFAULT == 2\n #define CPP_CPU_DEFAULT_SPEC \"%(cpp_586)\"\n-#endif\n+#else\n #if TARGET_CPU_DEFAULT == 3\n #define CPP_CPU_DEFAULT_SPEC \"%(cpp_686)\"\n+#else\n+#define CPP_CPU_DEFAULT_SPEC \"\"\n #endif\n-#if TARGET_CPU_DEFAULT == 4\n-#define CPP_CPU_DEFAULT_SPEC \"%(cpp_k6)\"\n #endif\n-#ifndef CPP_CPU_DEFAULT_SPEC\n-#define CPP_CPU_DEFAULT_SPEC \"\"\n #endif\n #endif /* CPP_CPU_DEFAULT_SPEC */\n \n@@ -332,7 +335,6 @@ extern int ix86_arch;\n %{mcpu=i486:%(cpp_486)} %{m486:%(cpp_486)} \\\n %{mpentium:%(cpp_586)} %{mcpu=pentium:%(cpp_586)} \\\n %{mpentiumpro:%(cpp_686)} %{mcpu=pentiumpro:%(cpp_686)} \\\n-%{mcpu=k6:%(cpp_k6)} \\\n %{!mcpu*:%{!m486:%{!mpentium*:%(cpp_cpu_default)}}}\"\n #endif\n \n@@ -357,7 +359,6 @@ extern int ix86_arch;\n #define EXTRA_SPECS\t\t\t\t\t\t\t\\\n   { \"cpp_486\", CPP_486_SPEC},\t\t\t\t\t\t\\\n   { \"cpp_586\", CPP_586_SPEC},\t\t\t\t\t\t\\\n-  { \"cpp_k6\", CPP_K6_SPEC},\t\t\t\t\t\t\\\n   { \"cpp_686\", CPP_686_SPEC},\t\t\t\t\t\t\\\n   { \"cpp_cpu_default\",\tCPP_CPU_DEFAULT_SPEC },\t\t\t\t\\\n   { \"cpp_cpu\",\tCPP_CPU_SPEC },\t\t\t\t\t\t\\\n@@ -408,17 +409,16 @@ extern int ix86_arch;\n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY 32\n \n-/* Boundary (in *bits*) on which the stack pointer must be aligned.  */\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY 32\n \n /* Boundary (in *bits*) on which the stack pointer preferrs to be\n    aligned; the compiler cannot rely on having this alignment.  */\n-#define PREFERRED_STACK_BOUNDARY i386_preferred_stack_boundary\n+#define PREFERRED_STACK_BOUNDARY ix86_preferred_stack_boundary\n \n-/* Allocation boundary (in *bits*) for the code of a function.\n-   For i486, we get better performance by aligning to a cache\n-   line (i.e. 16 byte) boundary.  */\n-#define FUNCTION_BOUNDARY (1 << (i386_align_funcs + 3))\n+/* Allocation boundary for the code of a function. */\n+#define FUNCTION_BOUNDARY \\\n+   (1 << ((ix86_align_funcs >= 0 ? ix86_align_funcs : -ix86_align_funcs) + 3))\n \n /* Alignment of field after `int : 0' in a structure. */\n \n@@ -556,19 +556,17 @@ extern int ix86_arch;\n /* Required on the 386 since it doesn't have bitfield insns.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* Maximum power of 2 that code can be aligned to.  */\n-#define MAX_CODE_ALIGN\t6\t\t\t/* 64 byte alignment */\n-\n /* Align loop starts for optimal branching.  */\n-#define LOOP_ALIGN(LABEL) (i386_align_loops)\n-#define LOOP_ALIGN_MAX_SKIP (i386_align_loops_string ? 0 : 7)\n-\n-/* This is how to align an instruction for optimal branching.\n-   On i486 we'll get better performance by aligning on a\n-   cache line (i.e. 16 byte) boundary.  */\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (i386_align_jumps)\n-#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP (i386_align_jumps_string ? 0 : 7)\n-\n+#define LOOP_ALIGN(LABEL) \\\n+\t(ix86_align_loops < 0 ? -ix86_align_loops : ix86_align_loops)\n+#define LOOP_ALIGN_MAX_SKIP \\\n+\t(ix86_align_loops < -3 ? (1<<(-ix86_align_loops-1))-1 : 0)\n+\n+/* This is how to align an instruction for optimal branching.  */\n+#define LABEL_ALIGN_AFTER_BARRIER(LABEL) \\\n+\t(ix86_align_jumps < 0 ? -ix86_align_jumps : ix86_align_jumps)\n+#define LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP \\\n+\t(ix86_align_jumps < -3 ? (1<<(-ix86_align_jumps-1))-1 : 0)\n \f\n /* Standard register usage.  */\n \n@@ -594,14 +592,14 @@ extern int ix86_arch;\n    eliminated during reloading in favor of either the stack or frame\n    pointer. */\n \n-#define FIRST_PSEUDO_REGISTER 17\n+#define FIRST_PSEUDO_REGISTER 19\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer. */\n #define FIXED_REGISTERS \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/       \\\n-{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1 }\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr*/ \\\n+{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1,    0,   0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -611,8 +609,8 @@ extern int ix86_arch;\n    Aside from that, you can include as many other registers as you like.  */\n \n #define CALL_USED_REGISTERS \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n-{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1 }\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr*/ \\\n+{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,    1,   1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -634,8 +632,8 @@ extern int ix86_arch;\n    generated by allocating edx first, so restore the 'natural' order of things. */\n \n #define REG_ALLOC_ORDER \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n-{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16 }\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,cc,fpsr*/ \\\n+{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16,17,  18 }\n \n /* A C statement (sans semicolon) to choose the order in which to\n    allocate hard registers for pseudo-registers local to a basic\n@@ -685,22 +683,26 @@ extern int ix86_arch;\n   (FP_REGNO_P (REGNO) ? 1 \\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the 80386, the first 4 cpu registers can hold any mode\n-   while the floating point registers may hold only floating point.\n-   Make it clear that the fp regs could not hold a 16-byte float.  */\n-\n-/* The casts to int placate a compiler on a microvax,\n-   for cross-compiler testing.  */\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((REGNO) < 4 ? 1\t\t\t\t\t\t\\\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n+  /* Flags and only flags can only hold CCmode values.  */\t\\\n+  (CC_REGNO_P (REGNO)\t\t\t\t\t\t\\\n+   ? GET_MODE_CLASS (MODE) == MODE_CC\t\t\t\t\\\n+   : GET_MODE_CLASS (MODE) == MODE_CC ? 0\t\t\t\\\n+   /* FP regs can only hold floating point; make it clear they\t\\\n+      cannot hold TFmode floats.  */\t\t\t\t\\\n    : FP_REGNO_P (REGNO)\t\t\t\t\t\t\\\n-   ? (((int) GET_MODE_CLASS (MODE) == (int) MODE_FLOAT\t\t\\\n-       || (int) GET_MODE_CLASS (MODE) == (int) MODE_COMPLEX_FLOAT)\t\\\n+   ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n       && GET_MODE_UNIT_SIZE (MODE) <= (LONG_DOUBLE_TYPE_SIZE == 96 ? 12 : 8))\\\n-   : (int) (MODE) != (int) QImode ? 1\t\t\t\t\\\n-   : (reload_in_progress | reload_completed) == 1)\n+   /* Only allow DImode in even registers.  */\t\t\t\\\n+   : (MODE) == DImode && ((REGNO) & 1) ? 0\t\t\t\\\n+   /* The first four integer regs can hold any mode.  */\t\\\n+   : (REGNO) < 4 ? 1\t\t\t\t\t\t\\\n+   /* Other regs cannot do byte accesses.  */\t\t\t\\\n+   : (MODE) != QImode ? 1\t\t\t\t\t\\\n+   : reload_in_progress || reload_completed)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -712,6 +714,13 @@ extern int ix86_arch;\n    || ((MODE1) == SImode && (MODE2) == HImode)\t\t\t\\\n    || ((MODE1) == HImode && (MODE2) == SImode))\n \n+/* Specify the modes required to caller save a given hard regno.\n+   We do this on i386 to prevent flags from being saved at all.  */\n+\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS)\t\t\\\n+  (CC_REGNO_P (REGNO) ? VOIDmode\t\t\t\t\\\n+   : choose_hard_reg_mode ((REGNO), (NREGS)))\n+\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n@@ -732,6 +741,9 @@ extern int ix86_arch;\n #define FIRST_STACK_REG FIRST_FLOAT_REG\n #define LAST_STACK_REG (FIRST_FLOAT_REG + 7)\n \n+#define FLAGS_REG 17\n+#define FPSR_REG 18\n+\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n@@ -800,15 +812,17 @@ extern int ix86_arch;\n \n    It might seem that class BREG is unnecessary, since no useful 386\n    opcode needs reg %ebx.  But some systems pass args to the OS in ebx,\n-   and the \"b\" register constraint is useful in asms for syscalls.  */\n+   and the \"b\" register constraint is useful in asms for syscalls.\n+\n+   The flags and fpsr registers are in no class.  */\n \n enum reg_class\n {\n   NO_REGS,\n-  AREG, DREG, CREG, BREG,\n+  AREG, DREG, CREG, BREG, SIREG, DIREG,\n   AD_REGS,\t\t\t/* %eax/%edx for DImode */\n   Q_REGS,\t\t\t/* %eax %ebx %ecx %edx */\n-  SIREG, DIREG,\n+  NON_Q_REGS,\t\t\t/* %esi %edi %ebp %esi */\n   INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n   GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n@@ -825,9 +839,9 @@ enum reg_class\n #define REG_CLASS_NAMES \\\n {  \"NO_REGS\",\t\t\t\t\\\n    \"AREG\", \"DREG\", \"CREG\", \"BREG\",\t\\\n-   \"AD_REGS\",\t\t\t\t\\\n-   \"Q_REGS\",\t\t\t\t\\\n    \"SIREG\", \"DIREG\",\t\t\t\\\n+   \"AD_REGS\",\t\t\t\t\\\n+   \"Q_REGS\", \"NON_Q_REGS\",\t\t\\\n    \"INDEX_REGS\",\t\t\t\\\n    \"GENERAL_REGS\",\t\t\t\\\n    \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n@@ -838,17 +852,19 @@ enum reg_class\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS \\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n {      {0},\t\t\t\t\t\t\t\\\n-     {0x1},    {0x2},  {0x4},\t {0x8},\t/* AREG, DREG, CREG, BREG */\t\\\n+     {0x1}, {0x2}, {0x4}, {0x8},/* AREG, DREG, CREG, BREG */\t\\\n+    {0x10},   {0x20},\t\t/* SIREG, DIREG */\t\t\\\n      {0x3},\t\t\t/* AD_REGS */\t\t\t\\\n      {0xf},\t\t\t/* Q_REGS */\t\t\t\\\n-    {0x10},   {0x20},\t\t/* SIREG, DIREG */\t\t\\\n- {0x7f},\t\t\t\t/* INDEX_REGS */\t\t\\\n+    {0xf0},\t\t\t/* NON_Q_REGS */\t\t\\\n+    {0x7f},\t\t\t/* INDEX_REGS */\t\t\\\n  {0x100ff},\t\t\t/* GENERAL_REGS */\t\t\\\n   {0x0100}, {0x0200},\t\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n   {0xff00},\t\t\t/* FLOAT_REGS */\t\t\\\n- {0x1ffff}}\n+ {0x7ffff}\t\t\t\t\t\t\t\\\n+}\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -879,6 +895,9 @@ enum reg_class\n \n #define STACK_TOP_P(xop) (REG_P (xop) && REGNO (xop) == FIRST_STACK_REG)\n \n+#define CC_REG_P(X) (REG_P (X) && CC_REGNO_P (REGNO (X)))\n+#define CC_REGNO_P(X) ((X) == FLAGS_REG || (X) == FPSR_REG)\n+\n /* 1 if register REGNO can magically overlap other regs.\n    Note that nonzero values work only in very special circumstances. */\n \n@@ -919,19 +938,18 @@ enum reg_class\n \n    I is for non-DImode shifts.\n    J is for DImode shifts.\n-   K and L are for an `andsi' optimization.\n+   K is for signed imm8 operands.\n+   L is for andsi as zero-extending move.\n    M is for shifts that can be executed by the \"lea\" opcode.\n    */\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? (VALUE) >= 0 && (VALUE) <= 31 :\t\\\n-   (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 63 :\t\\\n-   (C) == 'K' ? (VALUE) == 0xff :\t\t\\\n-   (C) == 'L' ? (VALUE) == 0xffff :\t\t\\\n-   (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3 :\t\\\n-   (C) == 'N' ? (VALUE) >= 0 && (VALUE) <= 255 :\\\n-   (C) == 'O' ? (VALUE) >= 0 && (VALUE) <= 32 :\t\\\n-   0)\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((C) == 'I' ? (VALUE) >= 0 && (VALUE) <= 31\t\t\t\\\n+   : (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 63\t\t\t\\\n+   : (C) == 'K' ? (VALUE) >= -128 && (VALUE) <= 127\t\t\\\n+   : (C) == 'L' ? (VALUE) == 0xff || (VALUE) == 0xffff\t\t\\\n+   : (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3\t\t\t\\\n+   : 0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself.  We allow constants even if\n@@ -976,8 +994,14 @@ enum reg_class\n    location.  */\n \n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE) \\\n-  ((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\\\n-   || (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2)))\n+  (FLOAT_CLASS_P (CLASS1) != FLOAT_CLASS_P (CLASS2))\n+\n+/* QImode spills from non-QI registers need a scratch.  This does not\n+   happen often -- the only example so far requires an uninitialized \n+   pseudo.  */\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT) \\\n+  ((CLASS) == GENERAL_REGS && (MODE) == QImode ? Q_REGS : NO_REGS)\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n@@ -1012,6 +1036,17 @@ enum reg_class\n    || ((CLASS) == SIREG)\t\t\t\t\t\t\\\n    || ((CLASS) == DIREG))\n \n+/* A C statement that adds to CLOBBERS any hard regs the port wishes\n+   to automatically clobber for all asms. \n+\n+   We do this in the new i386 backend to maintain source compatibility\n+   with the old cc0-based compiler.  */\n+\n+#define MD_ASM_CLOBBERS(CLOBBERS)\t\t\t\t\t      \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (5, \"flags\"), (CLOBBERS));\\\n+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (4, \"fpsr\"), (CLOBBERS)); \\\n+  } while (0)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1060,7 +1095,7 @@ enum reg_class\n    The attribute stdcall is equivalent to RTD on a per module basis.  */\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) \\\n-  (i386_return_pops_args (FUNDECL, FUNTYPE, SIZE))\n+  (ix86_return_pops_args (FUNDECL, FUNTYPE, SIZE))\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n@@ -1091,7 +1126,7 @@ enum reg_class\n    and about the args processed so far, enough to enable macros\n    such as FUNCTION_ARG to determine where the next arg should go.  */\n \n-typedef struct i386_args {\n+typedef struct ix86_args {\n   int words;\t\t\t/* # words passed so far */\n   int nregs;\t\t\t/* # registers available for passing */\n   int regno;\t\t\t/* next available register number */\n@@ -1131,8 +1166,7 @@ typedef struct i386_args {\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n \n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  (function_arg_partial_nregs (&CUM, MODE, TYPE, NAMED))\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n /* This macro is invoked just before the start of a function.\n    It is used here to output code for -fpic that will load the\n@@ -1142,32 +1176,21 @@ typedef struct i386_args {\n #define ASM_OUTPUT_FUNCTION_PREFIX(FILE, FNNAME) \\\n   asm_output_function_prefix (FILE, FNNAME)\n \n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-  function_prologue (FILE, SIZE)\n-\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n #define FUNCTION_PROFILER(FILE, LABELNO)  \\\n {\t\t\t\t\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n+      fprintf (FILE, \"\\tleal\\t%sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n \t       LPREFIX, (LABELNO));\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tcall *_mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+      fprintf (FILE, \"\\tcall\\t*_mcount@GOT(%%ebx)\\n\");\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n-      fprintf (FILE, \"\\tcall _mcount\\n\");\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovl\\t$%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf (FILE, \"\\tcall\\t_mcount\\n\");\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n@@ -1202,262 +1225,19 @@ typedef struct i386_args {\n */\n \n /* The following macro shall output assembler code to FILE\n-   to initialize basic-block profiling.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to call the subroutine `__bb_init_trace_func'\n-\tand pass two parameters to it. The first parameter is\n-\tthe address of a block allocated in the object module.\n-\tThe second parameter is the number of the first basic block\n-\tof the function.\n-\n-\tThe name of the block is a local symbol made with this statement:\n-\t\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tThe number of the first basic block of the function is\n-\tpassed to the macro in BLOCK_OR_LABEL.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tparameter1 <- LPBX0\n-\t\tparameter2 <- BLOCK_OR_LABEL\n-\t\tcall __bb_init_trace_func\n-\n-    else if profile_block_flag != 0\n-\n-\tOutput code to call the subroutine `__bb_init_func'\n-\tand pass one single parameter to it, which is the same\n-\tas the first parameter to `__bb_init_trace_func'.\n-\n-\tThe first word of this parameter is a flag which will be nonzero if\n-\tthe object module has already been initialized.  So test this word\n-\tfirst, and do not call `__bb_init_func' if the flag is nonzero.\n-\tNote: When profile_block_flag == 2 the test need not be done\n-\tbut `__bb_init_trace_func' *must* be called.\n-\n-\tBLOCK_OR_LABEL may be used to generate a label number as a\n-\tbranch destination in case `__bb_init_func' will not be called.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tcmp (LPBX0),0\n-\t\tjne local_label\n-\t\tparameter1 <- LPBX0\n-\t\tcall __bb_init_func\n-local_label:\n-\n-*/\n+   to initialize basic-block profiling.  */\n \n #undef\tFUNCTION_BLOCK_PROFILER\n-#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    static int num_func = 0;\t\t\t\t\t\t\\\n-    rtx xops[8];\t\t\t\t\t\t\t\\\n-    char block_table[80], false_label[80];\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    xops[1] = gen_rtx_SYMBOL_REF (VOIDmode, block_table);\t\t\\\n-    xops[5] = stack_pointer_rtx;\t\t\t\t\t\\\n-    xops[7] = gen_rtx_REG (Pmode, 0);\t/* eax */\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    CONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    switch (profile_block_flag) \t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      case 2:\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        xops[2] = GEN_INT ((BLOCK_OR_LABEL));\t\t\t\t\\\n-        xops[3] = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_init_trace_func\")); \\\n-        xops[6] = GEN_INT (8);\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        output_asm_insn (AS1(push%L2,%2), xops);\t\t\t\\\n-        if (!flag_pic)\t\t\t\t\t\t\t\\\n-          output_asm_insn (AS1(push%L1,%1), xops);\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-            output_asm_insn (AS2 (lea%L7,%a1,%7), xops);\t\t\\\n-            output_asm_insn (AS1 (push%L7,%7), xops);\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n-        output_asm_insn (AS2(add%L0,%6,%5), xops);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        ASM_GENERATE_INTERNAL_LABEL (false_label, \"LPBZ\", num_func);\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        xops[0] = const0_rtx;\t\t\t\t\t\t\\\n-        xops[2] = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (VOIDmode, false_label)); \\\n-        xops[3] = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_init_func\")); \\\n-        xops[4] = gen_rtx_MEM (Pmode, xops[1]);\t\t\t\\\n-        xops[6] = GEN_INT (4);\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        CONSTANT_POOL_ADDRESS_P (xops[2]) = TRUE;\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        output_asm_insn (AS2(cmp%L4,%0,%4), xops);\t\t\t\\\n-        output_asm_insn (AS1(jne,%2), xops);\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        if (!flag_pic)\t\t\t\t\t\t\t\\\n-          output_asm_insn (AS1(push%L1,%1), xops);\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          {\t\t\t\t\t\t\t\t\\\n-            output_asm_insn (AS2 (lea%L7,%a1,%7), xops);\t\t\\\n-            output_asm_insn (AS1 (push%L7,%7), xops);\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-    \t\t\t\t\t\t\t\t\t\\\n-        output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n-        output_asm_insn (AS2(add%L0,%6,%5), xops);\t\t\t\\\n-        ASM_OUTPUT_INTERNAL_LABEL (FILE, \"LPBZ\", num_func);\t\t\\\n-        num_func++;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL) \\\n+\tix86_output_function_block_profiler (FILE, BLOCK_OR_LABEL)\n \n /* The following macro shall output assembler code to FILE\n-   to increment a counter associated with basic block number BLOCKNO.\n-\n-   If profile_block_flag == 2\n-\n-\tOutput code to initialize the global structure `__bb' and\n-\tcall the function `__bb_trace_func' which will increment the\n-\tcounter.\n-\n-\t`__bb' consists of two words. In the first word the number\n-\tof the basic block has to be stored. In the second word\n-\tthe address of a block allocated in the object module \n-\thas to be stored.\n-\n-\tThe basic block number is given by BLOCKNO.\n-\n-\tThe address of the block is given by the label created with \n+   to increment a counter associated with basic block number BLOCKNO.  */\n \n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n-\n-\tby FUNCTION_BLOCK_PROFILER.\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result.\n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tmove BLOCKNO -> (__bb)\n-\t\tmove LPBX0 -> (__bb+4)\n-\t\tcall __bb_trace_func\n-\n-\tNote that function `__bb_trace_func' must not change the\n-\tmachine state, especially the flag register. To grant\n-\tthis, you must output code to save and restore registers\n-\teither in this macro or in the macros MACHINE_STATE_SAVE\n-\tand MACHINE_STATE_RESTORE. The last two macros will be\n-\tused in the function `__bb_trace_func', so you must make\n-\tsure that the function prologue does not change any \n-\tregister prior to saving it with MACHINE_STATE_SAVE.\n-\n-   else if profile_block_flag != 0\n-\n-\tOutput code to increment the counter directly.\n-\tBasic blocks are numbered separately from zero within each\n-\tcompiled object module. The count associated with block number\n-\tBLOCKNO is at index BLOCKNO in an array of words; the name of \n-\tthis array is a local symbol made with this statement:\n-\n-\t    ASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n-\n-\tOf course, since you are writing the definition of\n-\t`ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n-\tcan take a short cut in the definition of this macro and use the\n-\tname that you know will result. \n-\n-\tIf described in a virtual assembler language the code to be\n-\toutput looks like:\n-\n-\t\tinc (LPBX2+4*BLOCKNO)\n-\n-*/\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    rtx xops[8], cnt_rtx;\t\t\t\t\t\t\\\n-    char counts[80];\t\t\t\t\t\t\t\\\n-    char *block_table = counts;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    switch (profile_block_flag) \t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      case 2:\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        ASM_GENERATE_INTERNAL_LABEL (block_table, \"LPBX\", 0);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\txops[1] = gen_rtx_SYMBOL_REF (VOIDmode, block_table);\t\t\\\n-        xops[2] = GEN_INT ((BLOCKNO));\t\t\t\t\t\\\n-        xops[3] = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_trace_func\")); \\\n-        xops[4] = gen_rtx_SYMBOL_REF (VOIDmode, \"__bb\");\t\t\\\n-\txops[5] = plus_constant (xops[4], 4);\t\t\t\t\\\n-\txops[0] = gen_rtx_MEM (SImode, xops[4]);\t\t\t\\\n-\txops[6] = gen_rtx_MEM (SImode, xops[5]);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tCONSTANT_POOL_ADDRESS_P (xops[1]) = TRUE;\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tpushf\\n\");\t\t\t\t\t\\\n-        output_asm_insn (AS2(mov%L0,%2,%0), xops);\t\t\t\\\n-\tif (flag_pic)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            xops[7] = gen_rtx_REG (Pmode, 0);\t/* eax */\t\t\\\n-            output_asm_insn (AS1(push%L7,%7), xops);\t\t\t\\\n-            output_asm_insn (AS2(lea%L7,%a1,%7), xops);\t\t\t\\\n-            output_asm_insn (AS2(mov%L6,%7,%6), xops);\t\t\t\\\n-            output_asm_insn (AS1(pop%L7,%7), xops);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-        else\t\t\t\t\t\t\t\t\\\n-          output_asm_insn (AS2(mov%L6,%1,%6), xops);\t\t\t\\\n-        output_asm_insn (AS1(call,%P3), xops);\t\t\t\t\\\n-\tfprintf(FILE, \"\\tpopf\\n\");\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        ASM_GENERATE_INTERNAL_LABEL (counts, \"LPBX\", 2);\t\t\\\n-        cnt_rtx = gen_rtx_SYMBOL_REF (VOIDmode, counts);\t\t\\\n-        SYMBOL_REF_FLAG (cnt_rtx) = TRUE;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        if (BLOCKNO)\t\t\t\t\t\t\t\\\n-          cnt_rtx = plus_constant (cnt_rtx, (BLOCKNO)*4);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        if (flag_pic)\t\t\t\t\t\t\t\\\n-          cnt_rtx = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, cnt_rtx);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        xops[0] = gen_rtx_MEM (SImode, cnt_rtx);\t\t\t\\\n-        output_asm_insn (AS1(inc%L0,%0), xops);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-        break;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n+\tix86_output_block_profiler (FILE, BLOCKNO)\n \n-/* The following macro shall output assembler code to FILE\n+/* The following macro shall output rtl for the epilogue\n    to indicate a return from function during basic-block profiling.\n \n    If profiling_block_flag == 2:\n@@ -1479,17 +1259,10 @@ while (0)\n \tthese cases.\n */\n \n-#define FUNCTION_BLOCK_PROFILER_EXIT(FILE) \\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    rtx xops[1];\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    xops[0] = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_trace_ret\")); \\\n-\t\t\t\t\t\t\t\t\t\\\n-    output_asm_insn (AS1(call,%P0), xops);\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n+#define FUNCTION_BLOCK_PROFILER_EXIT\t\t\t\\\n+emit_call_insn (gen_call (gen_rtx_MEM (Pmode,\t\t\\\n+  gen_rtx_SYMBOL_REF (VOIDmode, \"__bb_trace_ret\")),\t\\\n+  const0_rtx))\n \n /* The function `__bb_trace_func' is called in every basic block\n    and is not allowed to change the machine state. Saving (restoring)\n@@ -1512,17 +1285,33 @@ while (0)\n    therefore we handle save and restore of the flag register \n    in the BLOCK_PROFILER macro. */\n \n-#define MACHINE_STATE_SAVE(ID) \\\n-  asm (\"\tpushl %eax\"); \\\n-  asm (\"\tpushl %ecx\"); \\\n-  asm (\"\tpushl %edx\"); \\\n-  asm (\"\tpushl %esi\");\n-\n-#define MACHINE_STATE_RESTORE(ID) \\\n-  asm (\"\tpopl %esi\"); \\\n-  asm (\"\tpopl %edx\"); \\\n-  asm (\"\tpopl %ecx\"); \\\n-  asm (\"\tpopl %eax\");\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  register int eax_ __asm__(\"eax\");\t\t\t\t\\\n+  register int ecx_ __asm__(\"ecx\");\t\t\t\t\\\n+  register int edx_ __asm__(\"edx\");\t\t\t\t\\\n+  register int esi_ __asm__(\"esi\");\t\t\t\t\\\n+  __asm__ __volatile__ (\t\t\t\t\t\\\n+\t\"push{l} %0\\n\\t\"\t\t\t\t\t\\\n+\t\"push{l} %1\\n\\t\"\t\t\t\t\t\\\n+\t\"push{l} %2\\n\\t\"\t\t\t\t\t\\\n+\t\"push{l} %3\"\t\t\t\t\t\t\\\n+\t: : \"r\"(eax_), \"r\"(ecx_), \"r\"(edx_), \"r\"(esi_));\t\\\n+} while (0);\n+\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  register int eax_ __asm__(\"eax\");\t\t\t\t\\\n+  register int ecx_ __asm__(\"ecx\");\t\t\t\t\\\n+  register int edx_ __asm__(\"edx\");\t\t\t\t\\\n+  register int esi_ __asm__(\"esi\");\t\t\t\t\\\n+  __asm__ __volatile__ (\t\t\t\t\t\\\n+\t\"pop{l} %3\\n\\t\"\t\t\t\t\t\t\\\n+\t\"pop{l} %2\\n\\t\"\t\t\t\t\t\t\\\n+\t\"pop{l} %1\\n\\t\"\t\t\t\t\t\t\\\n+\t\"pop{l} %0\"\t\t\t\t\t\t\\\n+\t: \"=r\"(eax_), \"=r\"(ecx_), \"=r\"(edx_), \"=r\"(esi_));\t\\\n+} while (0);\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n@@ -1534,35 +1323,6 @@ while (0)\n \n #define EXIT_IGNORE_STACK 1\n \n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.\n-\n-   If the last non-note insn in the function is a BARRIER, then there\n-   is no need to emit a function prologue, because control does not fall\n-   off the end.  This happens if the function ends in an \"exit\" call, or\n-   if a `return' insn is emitted directly into the function. */\n-\n-#if 0\n-#define FUNCTION_BEGIN_EPILOGUE(FILE)\t\t\\\n-do {\t\t\t\t\t\t\\\n-  rtx last = get_last_insn ();\t\t\t\\\n-  if (last && GET_CODE (last) == NOTE)\t\t\\\n-    last = prev_nonnote_insn (last);\t\t\\\n-/*  if (! last || GET_CODE (last) != BARRIER)\t\\\n-    function_epilogue (FILE, SIZE);*/\t\t\\\n-} while (0)\n-#endif\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)     \\\n-  function_epilogue (FILE, SIZE)\n-\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n \n@@ -1797,8 +1557,9 @@ do {\t\t\t\t\t\t\\\n    when generating PIC code.  It is given that flag_pic is on and \n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-#define LEGITIMATE_PIC_OPERAND_P(X) \\\n-  (! SYMBOLIC_CONST (X) || legitimate_pic_address_disp_p (X))\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\\\n+  (! SYMBOLIC_CONST (X)\t\t\t\t\\\n+   || legitimate_pic_address_disp_p (X))\n \n #define SYMBOLIC_CONST(X)\t\\\n (GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n@@ -1869,22 +1630,22 @@ while (0)\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n \n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, NAME, ARGS) \\\n-  (i386_valid_decl_attribute_p (DECL, ATTRIBUTES, NAME, ARGS))\n+  (ix86_valid_decl_attribute_p (DECL, ATTRIBUTES, NAME, ARGS))\n \n /* If defined, a C expression whose value is nonzero if IDENTIFIER\n    with arguments ARGS is a valid machine specific attribute for TYPE.\n    The attributes in ATTRIBUTES have previously been assigned to TYPE.  */\n \n #define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n-  (i386_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n+  (ix86_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n \n /* If defined, a C expression whose value is zero if the attributes on\n    TYPE1 and TYPE2 are incompatible, one if they are compatible, and\n    two if they are nearly compatible (which causes a warning to be\n    generated).  */\n \n #define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n-  (i386_comp_type_attributes (TYPE1, TYPE2))\n+  (ix86_comp_type_attributes (TYPE1, TYPE2))\n \n /* If defined, a C statement that assigns default attributes to newly\n    defined TYPE.  */\n@@ -2002,7 +1763,8 @@ while (0)\n     }\n \n /* Delete the definition here when TOPLEVEL_COSTS_N_INSNS gets added to cse.c */\n-#define TOPLEVEL_COSTS_N_INSNS(N) {total = COSTS_N_INSNS (N); break;}\n+#define TOPLEVEL_COSTS_N_INSNS(N) \\\n+  do { total = COSTS_N_INSNS (N); goto egress_rtx_costs; } while (0)\n \n /* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n    This can be used, for example, to indicate how costly a multiply\n@@ -2020,14 +1782,10 @@ while (0)\n \t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tHOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n \tif (value == 1)\t\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->add) \t\t\t\\\n-\t\t\t\t+ rtx_cost(XEXP (X, 0), OUTER_CODE);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\\\n \tif (value == 2 || value == 3)\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->lea)\t\t\t\t\\\n-\t\t\t\t + rtx_cost(XEXP (X, 0), OUTER_CODE);\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->lea);\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n \t\t  \t\t\t\t\t\t\t\\\n@@ -2040,18 +1798,26 @@ while (0)\n \tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    if (INTVAL (XEXP (X, 1)) > 32)\t\t\t\t\\\n-\t      return COSTS_N_INSNS(ix86_cost->shift_const + 2);\t\t\\\n-\t    return COSTS_N_INSNS(ix86_cost->shift_const * 2);\t\t\\\n+\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_const + 2);\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_const * 2);\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (X, 1)) == AND)\t\t\t\t\\\n+\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_var * 2);\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      TOPLEVEL_COSTS_N_INSNS(ix86_cost->shift_var * 6 + 2);\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n-\treturn ((GET_CODE (XEXP (X, 1)) == AND\t\t\t\t\\\n-\t\t ? COSTS_N_INSNS(ix86_cost->shift_var * 2)\t\t\\\n-\t\t : COSTS_N_INSNS(ix86_cost->shift_var * 6 + 2))\t\t\\\n-\t\t+ rtx_cost(XEXP (X, 0), OUTER_CODE));\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t\t\t  ? ix86_cost->shift_const\t\t\t\\\n-\t\t\t  : ix86_cost->shift_var)\t\t\t\\\n-      + rtx_cost(XEXP (X, 0), OUTER_CODE);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->shift_const);\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->shift_var);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case MULT:\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n@@ -2060,11 +1826,9 @@ while (0)\n \tint nbits = 0;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tif (value == 2)\t\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->add)\t\t\t\t\\\n-\t\t\t\t + rtx_cost(XEXP (X, 0), OUTER_CODE);\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\\\n \tif (value == 4 || value == 8)\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->lea)\t\t\t\t\\\n-\t\t\t\t + rtx_cost(XEXP (X, 0), OUTER_CODE);\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->lea);\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \twhile (value != 0)\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n@@ -2073,14 +1837,11 @@ while (0)\n \t  } \t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \tif (nbits == 1)\t\t\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (ix86_cost->shift_const)\t\t\t\\\n-\t    + rtx_cost(XEXP (X, 0), OUTER_CODE);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n-\t\t\t      + nbits * ix86_cost->mult_bit)\t\t\\\n-\t  + rtx_cost(XEXP (X, 0), OUTER_CODE);\t\t\t\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->shift_const);\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  TOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n+\t\t\t          + nbits * ix86_cost->mult_bit);\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n     else\t\t\t/* This is arbitrary */\t\t\t\\\n       TOPLEVEL_COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n \t\t\t      + 7 * ix86_cost->mult_bit);\t\t\\\n@@ -2092,27 +1853,60 @@ while (0)\n     TOPLEVEL_COSTS_N_INSNS (ix86_cost->divide);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   case PLUS:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t&& GET_MODE (XEXP (X, 0)) == SImode\t\t\t\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == PLUS)\t\t\t\t\\\n-      return COSTS_N_INSNS (ix86_cost->lea);\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (X, 0), 0)) == MULT\t\t\t\\\n+\t&& GET_CODE (XEXP (XEXP (XEXP (X, 0), 0), 1)) == CONST_INT\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tHOST_WIDE_INT val = INTVAL (XEXP (XEXP (XEXP (X, 0), 0), 1));\t\\\n+\tif (val == 2 || val == 4 || val == 8)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            return (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n+\t\t    + rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\\\n+\t\t    + rtx_cost (XEXP (XEXP (XEXP (X, 0), 0), 0), OUTER_CODE) \\\n+\t\t    + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n+\t     && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT)\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tHOST_WIDE_INT val = INTVAL (XEXP (XEXP (X, 0), 1));\t\t\\\n+\tif (val == 2 || val == 4 || val == 8)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    return (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\\\n+\t\t    + rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n+\t\t    + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else if (GET_CODE (XEXP (X, 0)) == PLUS)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\treturn (COSTS_N_INSNS (ix86_cost->lea)\t\t\t\t\\\n+\t\t+ rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\t\\\n+\t\t+ rtx_cost (XEXP (XEXP (X, 0), 1), OUTER_CODE)\t\t\\\n+\t\t+ rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     /* fall through */\t\t\t\t\t\t\t\\\n   case AND:\t\t\t\t\t\t\t\t\\\n   case IOR:\t\t\t\t\t\t\t\t\\\n   case XOR:\t\t\t\t\t\t\t\t\\\n   case MINUS:\t\t\t\t\t\t\t\t\\\n     if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\t\\\n-\t+ (rtx_cost (XEXP (X, 0), OUTER_CODE)\t\t\t\t\\\n-\t   << (GET_MODE (XEXP (X, 0)) != DImode))\t\t\t\\\n-\t+ (rtx_cost (XEXP (X, 1), OUTER_CODE)\t\t\t\t\\\n- \t   << (GET_MODE (XEXP (X, 1)) != DImode));\t\t\t\\\n+      return (COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\\\n+\t      + (rtx_cost (XEXP (X, 0), OUTER_CODE)\t\t\t\\\n+\t         << (GET_MODE (XEXP (X, 0)) != DImode))\t\t\t\\\n+\t      + (rtx_cost (XEXP (X, 1), OUTER_CODE)\t\t\t\\\n+ \t         << (GET_MODE (XEXP (X, 1)) != DImode)));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n   case NEG:\t\t\t\t\t\t\t\t\\\n   case NOT:\t\t\t\t\t\t\t\t\\\n     if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n-      TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2)\t\t\t\\\n-    TOPLEVEL_COSTS_N_INSNS (ix86_cost->add)\n+      TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2);\t\t\t\\\n+    TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  egress_rtx_costs:\t\t\t\t\t\t\t\\\n+    break;\n \n \n /* An expression giving the cost of an addressing mode that contains\n@@ -2198,7 +1992,7 @@ while (0)\n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */\n \n-#define BRANCH_COST i386_branch_cost\n+#define BRANCH_COST ix86_branch_cost\n \n /* Define this macro as a C expression which is nonzero if accessing\n    less than a word of memory (i.e. a `char' or a `short') is no\n@@ -2273,94 +2067,51 @@ while (0)\n    the scheduler that an output- or anti-dependence does not incur\n    the same cost as a data-dependence.  */\n \n-#define ADJUST_COST(insn,link,dep_insn,cost)\t\t\t\t\\\n-     (cost) = x86_adjust_cost(insn, link, dep_insn, cost)\n+#define ADJUST_COST(insn,link,dep_insn,cost) \\\n+  (cost) = ix86_adjust_cost(insn, link, dep_insn, cost)\n \n-#define ADJUST_BLOCKAGE(last_insn,insn,blockage)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (is_fp_store (last_insn) && is_fp_insn (insn)\t\t\t\\\n-      && NEXT_INSN (last_insn) && NEXT_INSN (NEXT_INSN (last_insn))\t\\\n-      && NEXT_INSN (NEXT_INSN (NEXT_INSN (last_insn)))\t\t\t\\\n-      && (GET_CODE (NEXT_INSN (last_insn)) == INSN)\t\t\t\\\n-      && (GET_CODE (NEXT_INSN (NEXT_INSN (last_insn))) == JUMP_INSN)\t\\\n-      && (GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (last_insn)))) == NOTE) \\\n-      && (NOTE_LINE_NUMBER (NEXT_INSN (NEXT_INSN (NEXT_INSN (last_insn)))) \\\n-\t  == NOTE_INSN_LOOP_END))\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      (blockage) = 3;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+#define ISSUE_RATE \\\n+  ix86_issue_rate ()\n+\n+#define MD_SCHED_INIT(DUMP, SCHED_VERBOSE) \\\n+  ix86_sched_init (DUMP, SCHED_VERBOSE)\n \n-#define ISSUE_RATE ((int)ix86_cpu > (int)PROCESSOR_I486 ? 2 : 1)\n+#define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n+  (CIM) = ix86_sched_reorder (DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK)\n \n+#define MD_SCHED_VARIABLE_ISSUE(DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE) \\\n+  ((CAN_ISSUE_MORE) =\t\t\t\t\t\t\t   \\\n+   ix86_variable_issue (DUMP, SCHED_VERBOSE, INSN, CAN_ISSUE_MORE))\n \f\n /* Add any extra modes needed to represent the condition code.\n \n-   For the i386, we need separate modes when floating-point equality\n-   comparisons are being done.  */\n+   For the i386, we need separate modes when floating-point\n+   equality comparisons are being done. \n+\n+   Add CCNO to indicate No Overflow, which is often also includes\n+   No Carry.  This is typically used on the output of logicals,\n+   and is only valid in comparisons against zero.  */\n \n-#define EXTRA_CC_MODES CC(CCFPEQmode, \"CCFPEQ\")\n+#define EXTRA_CC_MODES \\\n+\tCC(CCNOmode, \"CCNO\") \\\n+\tCC(CCFPmode, \"CCFP\") \\\n+\tCC(CCFPUmode, \"CCFPU\")\n \n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison.\n \n    For floating-point equality comparisons, CCFPEQmode should be used.\n-   VOIDmode should be used in all other cases.  */\n-\n-#define SELECT_CC_MODE(OP,X,Y) \\\n-  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\t\\\n-   && ((OP) == EQ || (OP) == NE) ? CCFPEQmode : VOIDmode)\n-\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  Note that we can't use \"rtx\" here\n-   since it hasn't been defined!  */\n-\n-extern struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n+   VOIDmode should be used in all other cases.\n \n-/* Tell final.c how to eliminate redundant test instructions.  */\n+   For integer comparisons against zero, reduce to CCNOmode if\n+   possible, to allow for more combinations.  */\n \n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* Set if the cc value was actually from the 80387 and\n-   we are testing eax directly (i.e. no sahf) */\n-#define CC_TEST_AX 020000\n-\n-/* Set if the cc value is actually in the 80387, so a floating point\n-   conditional branch must be output.  */\n-#define CC_IN_80387 04000\n-\n-/* Set if the CC value was stored in a nonstandard way, so that\n-   the state of equality is indicated by zero in the carry bit.  */\n-#define CC_Z_IN_NOT_C 010000\n-\n-/* Set if the CC value was actually from the 80387 and loaded directly\n-   into the eflags instead of via eax/sahf.  */\n-#define CC_FCOMI 040000\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-  notice_update_cc((EXP))\n-\n-/* Output a signed jump insn.  Use template NORMAL ordinarily, or\n-   FLOAT following a floating point comparison.\n-   Use NO_OV following an arithmetic insn that set the cc's\n-   before a test insn that was deleted.\n-   NO_OV may be zero, meaning final should reinsert the test insn\n-   because the jump cannot be handled properly without it.  */\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (cc_prev_status.flags & CC_IN_80387)\t\t\t\\\n-    return FLOAT;\t\t\t\t\t\t\\\n-  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\t\t\\\n-    return NO_OV;\t\t\t\t\t\t\\\n-  return NORMAL;\t\t\t\t\t\t\\\n-}\n+#define SELECT_CC_MODE(OP,X,Y)\t\t\t\t\\\n+  (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\t\\\n+   ? (OP) == EQ || (OP) == NE ? CCFPUmode : CCFPmode\t\\\n+   : (OP) == LE || (OP) == GT ? CCmode\t\t\t\\\n+   : (Y) != const0_rtx ? CCmode\t\t\t\t\\\n+   : CCNOmode)\n \f\n /* Control the assembler format that we output, to the extent\n    this does not vary between assemblers.  */\n@@ -2374,9 +2125,10 @@ extern struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n    For float regs, the stack top is sometimes referred to as \"%st(0)\"\n    instead of just \"%st\".  PRINT_REG handles this with the \"y\" code.  */\n \n-#define HI_REGISTER_NAMES \\\n-{\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",          \\\n- \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\" }\n+#define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n+{\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n+ \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n+ \"flags\",\"fpsr\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n \n@@ -2447,7 +2199,7 @@ number as al, and ax.\n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n do { long l[2];\t\t\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-     fprintf (FILE, \"%s 0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1]);\t\t\\\n+     fprintf (FILE, \"%s\\t0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1]);\t\t\\\n    } while (0)\n \n /* This is how to output a `long double' extended real constant. */\n@@ -2456,15 +2208,15 @@ do { long l[2];\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\\\n do { long l[3];\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\\\n-     fprintf (FILE, \"%s 0x%lx,0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+     fprintf (FILE, \"%s\\t0x%lx,0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n    } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n #define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n do { long l;\t\t\t\t\t\t\\\n      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n-     fprintf ((FILE), \"%s 0x%lx\\n\", ASM_LONG, l);\t\\\n+     fprintf ((FILE), \"%s\\t0x%lx\\n\", ASM_LONG, l);\t\\\n    } while (0)\n \n /* Store in OUTPUT a string (made with alloca) containing\n@@ -2475,54 +2227,42 @@ do { long l;\t\t\t\t\t\t\\\n ( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n   sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n \n-\n-\n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s \", ASM_LONG),\t\t\\\n+( fprintf (FILE, \"%s\\t\", ASM_LONG),\t\t\\\n   output_addr_const (FILE,(VALUE)),\t\t\\\n   putc('\\n',FILE))\n \n /* Likewise for `char' and `short' constants.  */\n /* is this supposed to do align too?? */\n \n #define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s \", ASM_SHORT),\t\t\\\n+( fprintf (FILE, \"%s\\t\", ASM_SHORT),\t\t\\\n   output_addr_const (FILE,(VALUE)),\t\t\\\n   putc('\\n',FILE))\n \n-/*\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s \", ASM_BYTE_OP),\t\t\\\n-  output_addr_const (FILE,(VALUE)),\t\t\\\n-  fputs (\",\", FILE),\t\t      \t\t\\\n-  output_addr_const (FILE,(VALUE)),\t\t\\\n-  fputs (\" >> 8\\n\",FILE))\n-*/\n-\n-\n #define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"%s \", ASM_BYTE_OP),\t\t\\\n+( fprintf (FILE, \"%s\\t\", ASM_BYTE_OP),\t\t\\\n   output_addr_const (FILE, (VALUE)),\t\t\\\n   putc ('\\n', FILE))\n \n /* This is how to output an assembler line for a numeric constant byte.  */\n \n #define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf ((FILE), \"%s 0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+  asm_fprintf ((FILE), \"%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n \n /* This is how to output an insn to push a register on the stack.\n    It need not be very fast code.  */\n \n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tpushl %%e%s\\n\", reg_names[REGNO])\n+  asm_fprintf (FILE, \"\\tpush{l}\\t%%e%s\\n\", reg_names[REGNO])\n \n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n #define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tpopl %%e%s\\n\", reg_names[REGNO])\n+  asm_fprintf (FILE, \"\\tpop{l}\\t%%e%s\\n\", reg_names[REGNO])\n \n /* This is how to output an element of a case-vector that is absolute.\n      */\n@@ -2536,7 +2276,7 @@ do { long l;\t\t\t\t\t\t\\\n  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  fprintf (FILE, \"\\t.word %s%d-%s%d\\n\",LPREFIX, VALUE,LPREFIX, REL)\n+  fprintf (FILE, \"\\t%s\\t%s%d-%s%d\\n\",ASM_LONG, LPREFIX, VALUE, LPREFIX, REL)\n \n /* Define the parentheses used to group arithmetic operations\n    in assembler code.  */\n@@ -2566,14 +2306,13 @@ do { long l;\t\t\t\t\t\t\\\n    * -- print a star (in certain assembler syntax)\n    P -- if PIC, print an @PLT suffix.\n    X -- don't print any sort of PIC '@' suffix for a symbol.\n-   J -- print jump insn for arithmetic_comparison_operator.\n    s -- ??? something to do with double shifts.  not actually used, afaik.\n    C -- print a conditional move suffix corresponding to the op code.\n    c -- likewise, but reverse the condition.\n    F,f -- likewise, but for floating-point.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '*' || (CODE) == '_')\n+  ((CODE) == '*')\n \n /* Print the name of a register based on its machine mode and number.\n    If CODE is 'w', pretend the mode is HImode.\n@@ -2582,42 +2321,8 @@ do { long l;\t\t\t\t\t\t\\\n    If CODE is 'h', pretend the reg is the `high' byte register.\n    If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op. */\n \n-extern char *hi_reg_name[];\n-extern char *qi_reg_name[];\n-extern char *qi_high_reg_name[];\n-\n-#define PRINT_REG(X, CODE, FILE) \\\n-  do { if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n-\t abort ();\t\t\t\t\t\\\n-       fprintf (FILE, \"%s\", RP);\t\t\t\\\n-       switch ((CODE == 'w' ? 2 \t\t\t\\\n-\t\t: CODE == 'b' ? 1\t\t\t\\\n-\t\t: CODE == 'k' ? 4\t\t\t\\\n-\t\t: CODE == 'y' ? 3\t\t\t\\\n-\t\t: CODE == 'h' ? 0\t\t\t\\\n-\t\t: GET_MODE_SIZE (GET_MODE (X))))\t\\\n-\t {\t\t\t\t\t\t\\\n-\t case 3:\t\t\t\t\t\\\n-\t   if (STACK_TOP_P (X))\t\t\t\t\\\n-\t     {\t\t\t\t\t\t\\\n-\t       fputs (\"st(0)\", FILE);\t\t\t\\\n-\t       break;\t\t\t\t\t\\\n-\t     }\t\t\t\t\t\t\\\n-\t case 4:\t\t\t\t\t\\\n-\t case 8:\t\t\t\t\t\\\n-\t case 12:\t\t\t\t\t\\\n-\t   if (! FP_REG_P (X)) fputs (\"e\", FILE);\t\\\n-\t case 2:\t\t\t\t\t\\\n-\t   fputs (hi_reg_name[REGNO (X)], FILE);\t\\\n-\t   break;\t\t\t\t\t\\\n-\t case 1:\t\t\t\t\t\\\n-\t   fputs (qi_reg_name[REGNO (X)], FILE);\t\\\n-\t   break;\t\t\t\t\t\\\n-\t case 0:\t\t\t\t\t\\\n-\t   fputs (qi_high_reg_name[REGNO (X)], FILE);\t\\\n-\t   break;\t\t\t\t\t\\\n-\t }\t\t\t\t\t\t\\\n-     } while (0)\n+#define PRINT_REG(X, CODE, FILE)  \\\n+  print_reg (X, CODE, FILE)\n \n #define PRINT_OPERAND(FILE, X, CODE)  \\\n   print_operand (FILE, X, CODE)\n@@ -2630,10 +2335,14 @@ extern char *qi_high_reg_name[];\n    This macro is different from PRINT_REG in that it may be used in\n    programs that are not linked with aux-output.o.  */\n \n-#define DEBUG_PRINT_REG(X, CODE, FILE) \\\n+#define DEBUG_PRINT_REG(X, CODE, FILE)\t\t\t\\\n   do { static char *hi_name[] = HI_REGISTER_NAMES;\t\\\n        static char *qi_name[] = QI_REGISTER_NAMES;\t\\\n-       fprintf (FILE, \"%d %s\", REGNO (X), RP);\t\\\n+       fprintf (FILE, \"%d \", REGNO (X));\t\t\\\n+       if (REGNO (X) == FLAGS_REG)\t\t\t\\\n+\t { fputs (\"flags\", FILE); break; }\t\t\\\n+       if (REGNO (X) == FPSR_REG)\t\t\t\\\n+\t { fputs (\"fpsr\", FILE); break; }\t\t\\\n        if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n \t { fputs (\"argp\", FILE); break; }\t\t\\\n        if (STACK_TOP_P (X))\t\t\t\t\\\n@@ -2653,150 +2362,183 @@ extern char *qi_high_reg_name[];\n \t }\t\t\t\t\t\t\\\n      } while (0)\n \n-/* Output the prefix for an immediate operand, or for an offset operand.  */\n-#define PRINT_IMMED_PREFIX(FILE)  fputs (IP, (FILE))\n-#define PRINT_OFFSET_PREFIX(FILE)  fputs (IP, (FILE))\n-\n /* Routines in libgcc that return floats must return them in an fp reg,\n    just as other functions do which return such values.\n    These macros make that happen.  */\n \n #define FLOAT_VALUE_TYPE float\n #define INTIFY(FLOATVAL) FLOATVAL\n \n-/* Nonzero if INSN magically clobbers register REGNO.  */\n-\n-/* #define INSN_CLOBBERS_REGNO_P(INSN, REGNO)\t\\\n-    (FP_REGNO_P (REGNO)\t\t\t\t\\\n-     && (GET_CODE (INSN) == JUMP_INSN || GET_CODE (INSN) == BARRIER))\n-*/\n-\n /* a letter which is not needed by the normal asm syntax, which\n    we can use for operand syntax in the extended asm */\n \n #define ASM_OPERAND_LETTER '#'\n #define RET return \"\"\n #define AT_SP(mode) (gen_rtx_MEM ((mode), stack_pointer_rtx))\n \f\n-/* Helper macros to expand a binary/unary operator if needed */\n-#define IX86_EXPAND_BINARY_OPERATOR(OP, MODE, OPERANDS)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (!ix86_expand_binary_operator (OP, MODE, OPERANDS))\t\t\\\n-    FAIL;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define IX86_EXPAND_UNARY_OPERATOR(OP, MODE, OPERANDS)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (!ix86_expand_unary_operator (OP, MODE, OPERANDS,))\t\t\\\n-    FAIL;\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n+/* Define the codes that are matched by predicates in i386.c.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n+  {\"pic_symbolic_operand\", {CONST}},\t\t\t\t\t\\\n+  {\"call_insn_operand\", {MEM}},\t\t\t\t\t\t\\\n+  {\"expander_call_insn_operand\", {MEM}},\t\t\t\t\\\n+  {\"constant_call_address_operand\", {MEM}},\t\t\t\t\\\n+  {\"const0_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n+  {\"const1_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"const248_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"incdec_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"reg_no_sp_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n+  {\"q_regs_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n+  {\"non_q_regs_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"no_comparison_operator\", {EQ, NE, LT, GE, LTU, GTU, LEU, GEU}},\t\\\n+  {\"fcmov_comparison_operator\", {EQ, NE, LTU, GTU, LEU, GEU}},\t\t\\\n+  {\"cmp_fp_expander_operand\", {CONST_DOUBLE, SUBREG, REG, MEM}},\t\\\n+  {\"ext_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"binary_fp_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\\n+  {\"mult_operator\", {MULT}},\t\t\t\t\t\t\\\n+  {\"div_operator\", {DIV}},\t\t\t\t\t\t\\\n+  {\"arith_or_logical_operator\", {PLUS, MULT, AND, IOR, XOR, SMIN, SMAX, \\\n+\t\t\t\t UMIN, UMAX, COMPARE, MINUS, DIV, MOD,\t\\\n+\t\t\t\t UDIV, UMOD, ASHIFT, ROTATE, ASHIFTRT,\t\\\n+\t\t\t\t LSHIFTRT, ROTATERT}},\t\t\t\\\n+  {\"memory_displacement_operand\", {MEM}},\t\t\t\t\\\n+  {\"cmpsi_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n+\t\t     LABEL_REF, SUBREG, REG, MEM, AND}},\n \f\n /* Functions in i386.c */\n-extern void override_options ();\n-extern void order_regs_for_local_alloc ();\n-extern char *output_strlen_unroll ();\n-extern struct rtx_def *i386_sext16_if_const ();\n-extern int i386_aligned_p ();\n-extern int i386_cc_probably_useless_p ();\n-extern int i386_valid_decl_attribute_p ();\n-extern int i386_valid_type_attribute_p ();\n-extern int i386_return_pops_args ();\n-extern int i386_comp_type_attributes ();\n-extern void init_cumulative_args ();\n-extern void function_arg_advance ();\n-extern struct rtx_def *function_arg ();\n-extern int function_arg_partial_nregs ();\n-extern char *output_strlen_unroll ();\n-extern char *singlemove_string ();\n-extern char *output_move_double ();\n-extern char *output_move_pushmem ();\n-extern int standard_80387_constant_p ();\n-extern char *output_move_const_single ();\n-extern int symbolic_operand ();\n-extern int call_insn_operand ();\n-extern int expander_call_insn_operand ();\n-extern int symbolic_reference_mentioned_p ();\n-extern int ix86_expand_binary_operator ();\n-extern int ix86_binary_operator_ok ();\n-extern int ix86_expand_unary_operator ();\n-extern int ix86_unary_operator_ok ();\n-extern void emit_pic_move ();\n-extern void function_prologue ();\n-extern int simple_386_epilogue ();\n-extern void function_epilogue ();\n-extern int legitimate_address_p ();\n-extern struct rtx_def *legitimize_pic_address ();\n-extern struct rtx_def *legitimize_address ();\n-extern void print_operand ();\n-extern void print_operand_address ();\n-extern void notice_update_cc ();\n-extern void split_di ();\n-extern int binary_387_op ();\n-extern int shift_op ();\n-extern int VOIDmode_compare_op ();\n-extern char *output_387_binary_op ();\n-extern char *output_fix_trunc ();\n-extern void output_float_extend ();\n-extern char *output_float_compare ();\n-extern char *output_fp_cc0_set ();\n-extern void save_386_machine_status ();\n-extern void restore_386_machine_status ();\n-extern void clear_386_stack_locals ();\n-extern struct rtx_def *assign_386_stack_local ();\n-extern int is_mul ();\n-extern int is_div ();\n-extern int last_to_set_cc ();\n-extern int doesnt_set_condition_code ();\n-extern int sets_condition_code ();\n-extern int str_immediate_operand ();\n-extern int is_fp_insn ();\n-extern int is_fp_dest ();\n-extern int is_fp_store ();\n-extern int agi_dependent ();\n-extern int reg_mentioned_in_mem ();\n-extern char *output_int_conditional_move ();\n-extern char *output_fp_conditional_move ();\n-extern int ix86_can_use_return_insn_p ();\n-extern int small_shift_operand ();\n-extern char *output_ashl ();\n-extern int memory_address_info ();\n-\n-#ifdef NOTYET\n-extern struct rtx_def *copy_all_rtx ();\n-extern void rewrite_address ();\n+\n+#if 1\n+#define XPARAMS(x) ()\n+#else\n+#define XPARAMS(x) PROTO(x)\n #endif\n+#define xrtx\tstruct rtx_def *\n+#define xtree\tstruct tree_def *\n+#define xmode\tenum machine_mode\n+#define xcode\tenum rtx_code\n+\n+extern void override_options XPARAMS((void));\n+extern void order_regs_for_local_alloc XPARAMS((void));\n+extern void optimization_options XPARAMS((int, int));\n+extern int ix86_aligned_p XPARAMS((xrtx));\n+extern int ix86_valid_decl_attribute_p XPARAMS((xtree, xtree, xtree, xtree));\n+extern int ix86_valid_type_attribute_p XPARAMS((xtree, xtree, xtree, xtree));\n+extern int ix86_comp_type_attributes XPARAMS((xtree, xtree));\n+extern int ix86_return_pops_args XPARAMS((xtree, xtree, int));\n+extern void init_cumulative_args XPARAMS((CUMULATIVE_ARGS*, xtree, xrtx));\n+extern void function_arg_advance XPARAMS((CUMULATIVE_ARGS*,xmode,xtree,int));\n+extern xrtx function_arg XPARAMS((CUMULATIVE_ARGS*, xmode, xtree, int));\n+\n+extern int symbolic_operand XPARAMS((xrtx, xmode));\n+extern int pic_symbolic_operand XPARAMS((xrtx, xmode));\n+extern int call_insn_operand XPARAMS((xrtx, xmode));\n+extern int expander_call_insn_operand XPARAMS((xrtx, xmode));\n+extern int constant_call_address_operand XPARAMS((xrtx, xmode));\n+extern int const0_operand XPARAMS((xrtx, xmode));\n+extern int const1_operand XPARAMS((xrtx, xmode));\n+extern int const248_operand XPARAMS((xrtx, xmode));\n+extern int incdec_operand XPARAMS((xrtx, xmode));\n+extern int reg_no_sp_operand XPARAMS((xrtx, xmode));\n+extern int q_regs_operand XPARAMS((xrtx, xmode));\n+extern int non_q_regs_operand XPARAMS((xrtx, xmode));\n+extern int no_comparison_operator XPARAMS((xrtx, xmode));\n+extern int fcmov_comparison_operator XPARAMS((xrtx, xmode));\n+extern int cmp_fp_expander_operand XPARAMS((xrtx, xmode));\n+extern int ext_register_operand XPARAMS((xrtx, xmode));\n+extern int binary_fp_operator XPARAMS((xrtx, xmode));\n+extern int mult_operator XPARAMS((xrtx, xmode));\n+extern int div_operator XPARAMS((xrtx, xmode));\n+extern int arith_or_logical_operator XPARAMS((xrtx, xmode));\n+extern int memory_displacement_operand XPARAMS((xrtx, xmode));\n+extern int cmpsi_operand XPARAMS((xrtx, xmode));\n+\n+extern int standard_80387_constant_p XPARAMS((xrtx));\n+extern int symbolic_reference_mentioned_p XPARAMS((xrtx));\n+extern int ix86_can_use_return_insn_p XPARAMS((void));\n+\n+extern void asm_output_function_prefix XPARAMS((FILE, char *));\n+extern void load_pic_register XPARAMS((void));\n+#if 0\n+/* HOST_WIDE_INT isn't defined yet.  */\n+extern HOST_WIDE_INT ix86_compute_frame_size XPARAMS ((HOST_WIDE_INT, int *));\n+#endif\n+extern void ix86_expand_prologue XPARAMS((void));\n+extern void ix86_expand_epilogue XPARAMS((void));\n+\n+extern int legitimate_pic_address_disp_p XPARAMS((xrtx));\n+extern int legitimate_address_p XPARAMS((xmode, xrtx, int));\n+extern xrtx legitimize_pic_address XPARAMS((xrtx, xrtx));\n+extern xrtx legitimize_address XPARAMS((xrtx, xrtx, xmode));\n+\n+extern void print_reg XPARAMS((xrtx, int, FILE*));\n+extern void print_operand XPARAMS((FILE*, xrtx, int));\n+extern void print_operand_address XPARAMS((FILE*, xrtx));\n+\n+extern void split_di XPARAMS((xrtx[], int, xrtx[], xrtx[]));\n+\n+extern char *output_387_binary_op XPARAMS((xrtx, xrtx*));\n+extern char *output_fix_trunc XPARAMS((xrtx, xrtx*));\n+extern char *output_fp_compare XPARAMS((xrtx, xrtx*, int, int));\n+extern void ix86_output_function_block_profiler XPARAMS((FILE*, int));\n+extern void ix86_output_block_profiler XPARAMS((FILE*, int));\n+\n+extern void ix86_expand_move XPARAMS((xmode, xrtx[]));\n+extern void ix86_expand_binary_operator XPARAMS((xcode, xmode, xrtx[]));\n+extern int ix86_binary_operator_ok XPARAMS((xcode, xmode, xrtx[]));\n+extern int ix86_expand_unary_operator XPARAMS((xcode, xmode, xrtx[]));\n+extern int ix86_unary_operator_ok XPARAMS((xcode, xmode, xrtx[]));\n+extern void ix86_expand_branch XPARAMS((xcode, int, xrtx));\n+extern int ix86_expand_setcc XPARAMS((xcode, int, xrtx));\n+extern int ix86_expand_int_movcc XPARAMS((xrtx[]));\n+extern int ix86_expand_fp_movcc XPARAMS((xrtx[]));\n+extern int ix86_split_movdi XPARAMS((xrtx[]));\n+extern void ix86_split_ashldi XPARAMS((xrtx *, xrtx));\n+extern void ix86_split_ashrdi XPARAMS((xrtx *, xrtx));\n+extern void ix86_split_lshrdi XPARAMS((xrtx *, xrtx));\n+extern void ix86_expand_strlensi_unroll_1 XPARAMS((xrtx, xrtx, xrtx));\n+\n+extern void save_386_machine_status XPARAMS((struct function *));\n+extern void restore_386_machine_status XPARAMS((struct function *));\n+extern void clear_386_stack_locals XPARAMS((void));\n+extern xrtx assign_386_stack_local XPARAMS((xmode, int));\n+extern int ix86_attr_length_default XPARAMS((xrtx));\n+\n+extern int ix86_issue_rate XPARAMS((void));\n+extern int ix86_adjust_cost XPARAMS((xrtx, xrtx, xrtx, int));\n+extern void ix86_sched_init XPARAMS((FILE *, int));\n+extern int ix86_sched_reorder XPARAMS((FILE *, int, xrtx *, int));\n+extern int ix86_variable_issue XPARAMS((FILE *, int, xrtx, int));\n+\n+\n+#undef XPARAMS\n+#undef xrtx\n+#undef xtree\n+#undef xmode\n+#undef xcode\n \n /* Variables in i386.c */\n extern const char *ix86_cpu_string;\t\t/* for -mcpu=<xxx> */\n extern const char *ix86_arch_string;\t\t/* for -march=<xxx> */\n-extern const char *i386_reg_alloc_order;\t/* register allocation order */\n-extern const char *i386_regparm_string;\t\t/* # registers to use to pass args */\n-extern const char *i386_align_loops_string;\t/* power of two alignment for loops */\n-extern const char *i386_align_jumps_string;\t/* power of two alignment for non-loop jumps */\n-extern const char *i386_align_funcs_string;\t/* power of two alignment for functions */\n-extern const char *i386_preferred_stack_boundary_string;/* power of two alignment for stack boundary */\n-extern const char *i386_branch_cost_string;\t/* values 1-5: see jump.c */\n-extern int i386_regparm;\t\t\t/* i386_regparm_string as a number */\n-extern int i386_align_loops;\t\t\t/* power of two alignment for loops */\n-extern int i386_align_jumps;\t\t\t/* power of two alignment for non-loop jumps */\n-extern int i386_align_funcs;\t\t\t/* power of two alignment for functions */\n-extern int i386_preferred_stack_boundary;\t/* preferred stack boundary alignment in bits */\n-extern int i386_branch_cost;\t\t\t/* values 1-5: see jump.c */\n-extern char *hi_reg_name[];\t\t\t/* names for 16 bit regs */\n-extern char *qi_reg_name[];\t\t\t/* names for 8 bit regs (low) */\n-extern char *qi_high_reg_name[];\t\t/* names for 8 bit regs (high) */\n-extern enum reg_class regclass_map[];\t\t/* smalled class containing REGNO */\n-extern struct rtx_def *i386_compare_op0;\t/* operand 0 for comparisons */\n-extern struct rtx_def *i386_compare_op1;\t/* operand 1 for comparisons */\n-\n-/* External variables used */\n-extern int optimize;\t\t\t\t/* optimization level */\n-extern int obey_regdecls;\t\t\t/* TRUE if stupid register allocation */\n-\n-/* External functions used */\n-extern struct rtx_def *force_operand ();\n-\n+extern const char *ix86_reg_alloc_order;\t/* register allocation order */\n+extern const char *ix86_regparm_string;\t\t/* # registers to use to pass args */\n+extern const char *ix86_align_loops_string;\t/* power of two alignment for loops */\n+extern const char *ix86_align_jumps_string;\t/* power of two alignment for non-loop jumps */\n+extern const char *ix86_align_funcs_string;\t/* power of two alignment for functions */\n+extern const char *ix86_preferred_stack_boundary_string;/* power of two alignment for stack boundary */\n+extern const char *ix86_branch_cost_string;\t/* values 1-5: see jump.c */\n+extern int ix86_regparm;\t\t\t/* ix86_regparm_string as a number */\n+extern int ix86_align_loops;\t\t\t/* power of two alignment for loops */\n+extern int ix86_align_jumps;\t\t\t/* power of two alignment for non-loop jumps */\n+extern int ix86_align_funcs;\t\t\t/* power of two alignment for functions */\n+extern int ix86_preferred_stack_boundary;\t/* preferred stack boundary alignment in bits */\n+extern int ix86_branch_cost;\t\t\t/* values 1-5: see jump.c */\n+extern const char * const hi_reg_name[];\t/* names for 16 bit regs */\n+extern const char * const qi_reg_name[];\t/* names for 8 bit regs (low) */\n+extern const char * const qi_high_reg_name[];\t/* names for 8 bit regs (high) */\n+extern enum reg_class const regclass_map[];\t/* smalled class containing REGNO */\n+extern struct rtx_def *ix86_compare_op0;\t/* operand 0 for comparisons */\n+extern struct rtx_def *ix86_compare_op1;\t/* operand 1 for comparisons */\n \f\n /*\n Local variables:"}, {"sha": "7620712899cfa545f30503a6fab685b4147d1fb7", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 6270, "deletions": 6372, "changes": 12642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e075ae69f9d1263e78376038ab138c03e279f391"}, {"sha": "03095c4ddafa9360fd6af17ded8cf894f1948bf0", "filename": "gcc/config/i386/unix.h", "status": "modified", "additions": 45, "deletions": 106, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Funix.h?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -22,79 +22,13 @@ Boston, MA 02111-1307, USA.  */\n    that are the same for all the i386 Unix systems\n    (though they may differ in non-Unix systems).  */\n \n-/* Define some concatenation macros to concatenate an opcode\n-   and one, two or three operands.  In other assembler syntaxes\n-   they may alter the order of ther operands.  */\n-\n-/* Note that the other files fail to use these\n-   in some of the places where they should.  */\n-\n-#if defined(__STDC__) || defined(ALMOST_STDC)\n-#define AS2(a,b,c) #a \" \" #b \",\" #c\n-#define AS2C(b,c) \" \" #b \",\" #c\n-#define AS3(a,b,c,d) #a \" \" #b \",\" #c \",\" #d\n-#define AS1(a,b) #a \" \" #b\n-#else\n-#define AS1(a,b) \"a b\"\n-#define AS2(a,b,c) \"a b,c\"\n-#define AS2C(b,c) \" b,c\"\n-#define AS3(a,b,c,d) \"a b,c,d\"\n-#endif  \n+#define DEFAULT_ASSEMBLER_DIALECT 0\n \n /* Define macro used to output shift-double opcodes when the shift\n    count is in %cl.  Some assemblers require %cl as an argument;\n    some don't.  This macro controls what to do: by default, don't\n    print %cl.  */\n #define SHIFT_DOUBLE_OMITS_COUNT 1\n-#define AS3_SHIFT_DOUBLE(a,b,c,d) \\\n-\t(SHIFT_DOUBLE_OMITS_COUNT ? AS2 (a,c,d) : AS3 (a,b,c,d))\n-\n-/* Output the size-letter for an opcode.\n-   CODE is the letter used in an operand spec (L, B, W, S or Q).\n-   CH is the corresponding lower case letter\n-     (except if CODE is `Q' then CH is `l', unless GAS_MNEMONICS).  */\n-#define PUT_OP_SIZE(CODE,CH,FILE) putc (CH,(FILE))\n-\n-/* Opcode suffix for fullword insn.  */\n-#define L_SIZE \"l\"\n-\n-/* Prefix for register names in this syntax.  */\n-#define RP \"%\"\n-\n-/* Prefix for immediate operands in this syntax.  */\n-#define IP \"$\"\n-\n-/* Indirect call instructions should use `*'.  */\n-#define USE_STAR 1\n-\n-/* Prefix for a memory-operand X.  */\n-#define PRINT_PTR(X, FILE)\n-\n-/* Delimiters that surround base reg and index reg.  */\n-#define ADDR_BEG(FILE) putc('(', (FILE))\n-#define ADDR_END(FILE) putc(')', (FILE))\n-\n-/* Print an index register (whose rtx is IREG).  */\n-#define PRINT_IREG(FILE,IREG) \\\n-  do\t\t\t\t\t\t\t\t\\\n-  { fputs (\",\", (FILE)); PRINT_REG ((IREG), 0, (FILE)); }\t\\\n-  while (0)\n-  \n-/* Print an index scale factor SCALE.  */\n-#define PRINT_SCALE(FILE,SCALE) \\\n-  if ((SCALE) != 1) fprintf ((FILE), \",%d\", (SCALE))\n-\n-/* Print a base/index combination.\n-   BREG is the base reg rtx, IREG is the index reg rtx,\n-   and SCALE is the index scale factor (an integer).  */\n-\n-#define PRINT_B_I_S(BREG,IREG,SCALE,FILE) \\\n-  { ADDR_BEG (FILE); \t\t\t\t\\\n-    if (BREG) PRINT_REG ((BREG), 0, (FILE));\t\\\n-    if ((IREG) != 0)\t\t\t\t\\\n-      { PRINT_IREG ((FILE), (IREG));\t\t\\\n-        PRINT_SCALE ((FILE), (SCALE)); }\t\\\n-    ADDR_END (FILE); }\n \f\n /* Define the syntax of pseudo-ops, labels and comments.  */\n \n@@ -148,43 +82,48 @@ Boston, MA 02111-1307, USA.  */\n \n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.  */\n-#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t      \\\n-do {\t\t\t\t\t\t\t\t\t      \\\n-  tree parm;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-  if (i386_regparm > 0)\t\t\t\t\t\t\t      \\\n-    parm = TYPE_ARG_TYPES (TREE_TYPE (function));\t\t\t      \\\n-  else\t\t\t\t\t\t\t\t\t      \\\n-    parm = NULL_TREE;\t\t\t\t\t\t\t      \\\n-  for (; parm; parm = TREE_CHAIN (parm))\t\t\t\t      \\\n-    if (TREE_VALUE (parm) == void_type_node)\t\t\t\t      \\\n-      break;\t\t\t\t\t\t\t\t      \\\n-  fprintf (FILE, \"\\taddl $%d,%s\\n\", DELTA,\t\t\t\t      \\\n-\t   parm ? \"%eax\"\t\t\t\t\t\t      \\\n-\t   : aggregate_value_p (TREE_TYPE (TREE_TYPE (FUNCTION))) ? \"8(%esp)\" \\\n-\t   : \"4(%esp)\");\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-  if (flag_pic)\t\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      rtx xops[2];\t\t\t\t\t\t\t      \\\n-      xops[0] = pic_offset_table_rtx;\t\t\t\t\t      \\\n-      xops[1] = (rtx) gen_label_rtx ();\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-      if (i386_regparm > 2)\t\t\t\t\t\t      \\\n-\tabort ();\t\t\t\t\t\t\t      \\\n-      output_asm_insn (\"push%L0 %0\", xops);\t\t\t\t      \\\n-      output_asm_insn (AS1 (call,%P1), xops);\t\t\t\t      \\\n-      ASM_OUTPUT_INTERNAL_LABEL (FILE, \"L\", CODE_LABEL_NUMBER (xops[1]));     \\\n-      output_asm_insn (AS1 (pop%L0,%0), xops);\t\t\t\t      \\\n-      output_asm_insn (\"addl $%__GLOBAL_OFFSET_TABLE_+[.-%P1],%0\", xops);     \\\n-      fprintf (FILE, \"\\tmovl \");\t\t\t\t\t      \\\n-      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t      \\\n-      fprintf (FILE, \"@GOT(%%ebx),%%ecx\\n\\tpopl %%ebx\\n\\tjmp *%%ecx\\n\");      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-  else\t\t\t\t\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      fprintf (FILE, \"\\tjmp \");\t\t\t\t\t\t      \\\n-      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t      \\\n-      fprintf (FILE, \"\\n\");\t\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t    \\\n+do {\t\t\t\t\t\t\t\t\t    \\\n+  tree parm;\t\t\t\t\t\t\t\t    \\\n+  rtx xops[2];\t\t\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  if (ix86_regparm > 0)\t\t\t\t\t\t\t    \\\n+    parm = TYPE_ARG_TYPES (TREE_TYPE (function));\t\t\t    \\\n+  else\t\t\t\t\t\t\t\t\t    \\\n+    parm = NULL_TREE;\t\t\t\t\t\t\t    \\\n+  for (; parm; parm = TREE_CHAIN (parm))\t\t\t\t    \\\n+    if (TREE_VALUE (parm) == void_type_node)\t\t\t\t    \\\n+      break;\t\t\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  xops[0] = GEN_INT (DELTA);\t\t\t\t\t\t    \\\n+  if (parm)\t\t\t\t\t\t\t\t    \\\n+    xops[1] = gen_rtx_REG (SImode, 0);\t\t\t\t\t    \\\n+  else if (aggregate_value_p (TREE_TYPE (TREE_TYPE (FUNCTION))))\t    \\\n+    xops[1] = gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 8));   \\\n+  else\t\t\t\t\t\t\t\t\t    \\\n+    xops[1] = gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 4));   \\\n+  output_asm_insn (\"add{l} {%0, %1|%1, %0}\", xops);\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  if (flag_pic)\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      xops[0] = pic_offset_table_rtx;\t\t\t\t\t    \\\n+      xops[1] = gen_label_rtx ();\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+      if (ix86_regparm > 2)\t\t\t\t\t\t    \\\n+\tabort ();\t\t\t\t\t\t\t    \\\n+      output_asm_insn (\"push{l}\\t%0\", xops);\t\t\t\t    \\\n+      output_asm_insn (\"call\\t%P1\", xops);\t\t\t\t    \\\n+      ASM_OUTPUT_INTERNAL_LABEL (FILE, \"L\", CODE_LABEL_NUMBER (xops[1]));   \\\n+      output_asm_insn (\"pop{l}\\t%0\", xops);\t\t\t\t    \\\n+      output_asm_insn (\"add{l}\\t$_GLOBAL_OFFSET_TABLE_+[.-%P1], %0\", xops); \\\n+      fprintf (FILE, \"\\tmovl \");\t\t\t\t\t    \\\n+      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t    \\\n+      fprintf (FILE, \"@GOT(%%ebx),%%ecx\\n\\tpopl %%ebx\\n\\tjmp *%%ecx\\n\");    \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n+  else\t\t\t\t\t\t\t\t\t    \\\n+    {\t\t\t\t\t\t\t\t\t    \\\n+      fprintf (FILE, \"\\tjmp \");\t\t\t\t\t\t    \\\n+      assemble_name (FILE, XSTR (XEXP (DECL_RTL (FUNCTION), 0), 0));\t    \\\n+      fprintf (FILE, \"\\n\");\t\t\t\t\t\t    \\\n+    }\t\t\t\t\t\t\t\t\t    \\\n } while (0)"}, {"sha": "b97a5c8d3838b5ef1223b5306f621c54587549bf", "filename": "gcc/config/i386/win32.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwin32.h?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -274,8 +274,5 @@ do {\t\t\t\t\t\t\t\t\\\n       rtx xops[1];\t\t\t\t\t\t\t\\\n       xops[0] = gen_rtx_MEM (FUNCTION_MODE,\t\t\t\t\\\n \t\t\t gen_rtx (SYMBOL_REF, Pmode, \"_monstartup\"));\t\\\n-      if (do_rtl)\t\t\t\t\t\t\t\\\n-\temit_call_insn (gen_rtx (CALL, VOIDmode, xops[0], const0_rtx));\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\toutput_asm_insn (AS1 (call,%P1), xops);\t\t\t\\\n+      emit_call_insn (gen_rtx (CALL, VOIDmode, xops[0], const0_rtx));\t\\\n      }"}, {"sha": "bda9311a42aa503ba9bbede2861634f1651fd019", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -58,7 +58,7 @@ i386_pe_valid_decl_attribute_p (decl, attributes, attr, args)\n \treturn 1;\n     }\n \n-  return i386_valid_decl_attribute_p (decl, attributes, attr, args);\n+  return ix86_valid_decl_attribute_p (decl, attributes, attr, args);\n }\n \n /* Return nonzero if ATTR is a valid attribute for TYPE.\n@@ -81,7 +81,7 @@ i386_pe_valid_type_attribute_p (type, attributes, attr, args)\n \treturn 1;\n     }\n \n-  return i386_valid_type_attribute_p (type, attributes, attr, args);\n+  return ix86_valid_type_attribute_p (type, attributes, attr, args);\n }\n \n /* Merge attributes in decls OLD and NEW."}, {"sha": "d9c404833586afa15ada9d37cb15fb9722bdb3f6", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 419, "deletions": 383, "changes": 802, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -160,8 +160,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"insn-flags.h\"\n-#include \"recog.h\"\n #include \"toplev.h\"\n+#include \"recog.h\"\n #include \"varray.h\"\n \n #ifdef STACK_REGS\n@@ -232,26 +232,13 @@ static rtx\n /* Get the basic block number of an insn.  See note at block_number\n    definition are validity of this information.  */\n \n-static int BLOCK_NUM PROTO((rtx));\n-\n-#ifdef __GNUC__\n-__inline__\n-#endif\n-static int\n-BLOCK_NUM(insn)\n-     rtx insn;\n-{\n-  int tmp = INSN_UID (insn);\n-  if (tmp > max_uid)\n-    abort ();\n-  tmp = block_number[tmp];\n-  if (tmp < 0)\n-    abort ();\n-  return tmp;\n-}\n+#define BLOCK_NUM(INSN)\t\t\t\t\t\\\n+  ((INSN_UID (INSN) > max_uid)\t\t\t\t\\\n+   ? (abort() , -1) : block_number[INSN_UID (INSN)])\n \n /* Forward declarations */\n \n+static int stack_regs_mentioned_p\tPROTO((rtx pat));\n static void mark_regs_pat\t\tPROTO((rtx, HARD_REG_SET *));\n static void straighten_stack\t\tPROTO((rtx, stack));\n static void pop_stack\t\t\tPROTO((stack, int));\n@@ -273,7 +260,8 @@ static void delete_insn_for_stacker\tPROTO((rtx));\n static rtx emit_pop_insn\t\tPROTO((rtx, stack, rtx, rtx (*) ()));\n static void emit_swap_insn\t\tPROTO((rtx, stack, rtx));\n static void move_for_stack_reg\t\tPROTO((rtx, stack, rtx));\n-static void swap_rtx_condition\t\tPROTO((rtx));\n+static int swap_rtx_condition_1\t\tPROTO((rtx));\n+static int swap_rtx_condition\t\tPROTO((rtx));\n static void compare_for_stack_reg\tPROTO((rtx, stack, rtx));\n static void subst_stack_regs_pat\tPROTO((rtx, stack, rtx));\n static void subst_asm_stack_regs\tPROTO((rtx, stack));\n@@ -284,47 +272,96 @@ static void goto_block_pat\t\tPROTO((rtx, stack, rtx));\n static void convert_regs\t\tPROTO((void));\n static void print_blocks\t\tPROTO((FILE *, rtx, rtx));\n static void dump_stack_info\t\tPROTO((FILE *));\n-static int check_stack_regs_mentioned\tPROTO((rtx insn));\n \f\n-/* Initialize stack_regs_mentioned_data for INSN (growing the virtual array\n-   if needed.  Return nonzero if INSN mentions stacked registers.  */\n+/* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n \n static int\n-check_stack_regs_mentioned (insn)\n-     rtx insn;\n+stack_regs_mentioned_p (pat)\n+     rtx pat;\n {\n-  unsigned int uid = INSN_UID (insn);\n-  if (uid >= VARRAY_SIZE (stack_regs_mentioned_data))\n-    /* Allocate some extra size to avoid too many reallocs, but\n-       do not grow exponentially.  */\n-    VARRAY_GROW (stack_regs_mentioned_data, uid + uid / 20);\n-  if (stack_regs_mentioned_p (PATTERN (insn)))\n+  register const char *fmt;\n+  register int i;\n+\n+  if (STACK_REG_P (pat))\n+    return 1;\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n     {\n-      VARRAY_CHAR (stack_regs_mentioned_data, uid) = 1;\n-      return 1;\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n+\n+\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n+\t    if (stack_regs_mentioned_p (XVECEXP (pat, i, j)))\n+\t      return 1;\n+\t}\n+      else if (fmt[i] == 'e' && stack_regs_mentioned_p (XEXP (pat, i)))\n+\treturn 1;\n     }\n-  else\n-    VARRAY_CHAR (stack_regs_mentioned_data, uid) = 2;\n+\n   return 0;\n }\n \n-/* Return nonzero if INSN mentions stacked registers, else return\n-   zero.  */\n+/* Return nonzero if INSN mentions stacked registers, else return zero.  */\n \n int\n stack_regs_mentioned (insn)\n      rtx insn;\n {\n-  unsigned int uid;\n+  unsigned int uid, max;\n+  int test;\n+\n   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n     return 0;\n+\n   uid = INSN_UID (insn);\n-  if (uid >= VARRAY_SIZE (stack_regs_mentioned_data)\n-      || ! VARRAY_CHAR (stack_regs_mentioned_data, uid))\n-    return (check_stack_regs_mentioned (insn));\n-  return VARRAY_CHAR (stack_regs_mentioned_data, uid) == 1;\n+  max = VARRAY_SIZE (stack_regs_mentioned_data);\n+  if (uid >= max)\n+    {\n+      /* Allocate some extra size to avoid too many reallocs, but\n+\t do not grow too quickly.  */\n+      max = uid + uid / 20;\n+      VARRAY_GROW (stack_regs_mentioned_data, max);\n+    }\n+\n+  test = VARRAY_CHAR (stack_regs_mentioned_data, uid);\n+  if (test == 0)\n+    {\n+      /* This insn has yet to be examined.  Do so now.  */\n+      test = stack_regs_mentioned_p (PATTERN (insn)) ? 1 : 2;\n+      VARRAY_CHAR (stack_regs_mentioned_data, uid) = test;\n+    }\n+\n+  return test == 1;\n }\n+\f\n+static rtx ix86_flags_rtx;\n \n+static rtx\n+next_flags_user (insn)\n+     rtx insn;\n+{\n+  /* Search forward looking for the first use of this value. \n+     Stop at block boundaries.  */\n+  /* ??? This really cries for BLOCK_END!  */\n+\n+  while (1)\n+    {\n+      insn = NEXT_INSN (insn);\n+      if (!insn)\n+\treturn NULL_RTX;\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+          && reg_mentioned_p (ix86_flags_rtx, PATTERN (insn)))\n+        return insn;\n+\n+      if (GET_CODE (insn) == JUMP_INSN\n+\t  || GET_CODE (insn) == CODE_LABEL\n+\t  || GET_CODE (insn) == CALL_INSN)\n+\treturn NULL_RTX;\n+    }\n+}\n \f\n /* Mark all registers needed for this pattern.  */\n \n@@ -338,17 +375,17 @@ mark_regs_pat (pat, set)\n   register int count;\n \n   if (GET_CODE (pat) == SUBREG)\n-   {\n-     mode = GET_MODE (pat);\n-     regno = SUBREG_WORD (pat);\n-     regno += REGNO (SUBREG_REG (pat));\n-   }\n+    {\n+      mode = GET_MODE (pat);\n+      regno = SUBREG_WORD (pat);\n+      regno += REGNO (SUBREG_REG (pat));\n+    }\n   else\n-     regno = REGNO (pat), mode = GET_MODE (pat);\n+    regno = REGNO (pat), mode = GET_MODE (pat);\n \n   for (count = HARD_REGNO_NREGS (regno, mode);\n        count; count--, regno++)\n-     SET_HARD_REG_BIT (*set, regno);\n+    SET_HARD_REG_BIT (*set, regno);\n }\n \f\n /* Reorganise the stack into ascending numbers,\n@@ -372,7 +409,7 @@ straighten_stack (insn, regstack)\n   temp_stack.reg_set = regstack->reg_set;\n \n   for (top = temp_stack.top = regstack->top; top >= 0; top--)\n-     temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;\n+    temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;\n   \n   change_stack (insn, regstack, &temp_stack, emit_insn_after);\n }\n@@ -403,36 +440,6 @@ pop_stack (regstack, regno)\n     }\n }\n \f\n-/* Return non-zero if any stack register is mentioned somewhere within PAT.  */\n-\n-int\n-stack_regs_mentioned_p (pat)\n-     rtx pat;\n-{\n-  register const char *fmt;\n-  register int i;\n-\n-  if (STACK_REG_P (pat))\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n-  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'E')\n-\t{\n-\t  register int j;\n-\n-\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n-\t    if (stack_regs_mentioned_p (XVECEXP (pat, i, j)))\n-\t      return 1;\n-\t}\n-      else if (fmt[i] == 'e' && stack_regs_mentioned_p (XEXP (pat, i)))\n-\treturn 1;\n-    }\n-\n-  return 0;\n-}\n-\f\n /* Convert register usage from \"flat\" register file usage to a \"stack\n    register file.  FIRST is the first insn in the function, FILE is the\n    dump file, if used.\n@@ -454,15 +461,17 @@ reg_to_stack (first, file)\n   enum machine_mode mode;\n   HARD_REG_SET stackentry;\n \n+  ix86_flags_rtx = gen_rtx_REG (CCmode, FLAGS_REG);\n+\n   max_uid = get_max_uid ();\n   VARRAY_CHAR_INIT (stack_regs_mentioned_data, max_uid + 1,\n \t\t    \"stack_regs_mentioned cache\");\n \n   CLEAR_HARD_REG_SET (stackentry);\n \n-   {\n-     static int initialised;\n-     if (!initialised)\n+  {\n+    static int initialised;\n+    if (!initialised)\n       {\n #if 0\n \tinitialised = 1;\t/* This array can not have been previously\n@@ -471,16 +480,16 @@ reg_to_stack (first, file)\n \t\t\t\t   functions.  */\n #endif\n         for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n-         {\n-           for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n-               mode = GET_MODE_WIDER_MODE (mode))\n+\t  {\n+\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n+\t\t mode = GET_MODE_WIDER_MODE (mode))\n               FP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-           for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT); mode != VOIDmode;\n-               mode = GET_MODE_WIDER_MODE (mode))\n+\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT); mode != VOIDmode;\n+\t\t mode = GET_MODE_WIDER_MODE (mode))\n               FP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n-         }\n+\t  }\n       }\n-   }\n+  }\n \n   /* Count the basic blocks.  Also find maximum insn uid.  */\n   {\n@@ -509,7 +518,7 @@ reg_to_stack (first, file)\n \t  blocks++;\n \n \tif (code == NOTE && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-\t   before_function_beg = 0;\n+\t  before_function_beg = 0;\n \n \t/* Remember whether or not this insn mentions an FP regs.\n \t   Check JUMP_INSNs too, in case someone creates a funny PARALLEL.  */\n@@ -518,7 +527,7 @@ reg_to_stack (first, file)\n \t    && stack_regs_mentioned_p (PATTERN (insn)))\n \t  {\n \t    stack_reg_seen = 1;\n-\t    VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 1;\n+ \t    VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 1;\n \n \t    /* Note any register passing parameters.  */\n \n@@ -565,7 +574,6 @@ reg_to_stack (first, file)\n   bzero ((char *) block_out_reg_set, blocks * sizeof (HARD_REG_SET));\n \n   block_number = (int *) alloca ((max_uid + 1) * sizeof (int));\n-  memset (block_number, -1, (max_uid + 1) * sizeof (int));\n \n   find_blocks (first);\n   stack_reg_life_analysis (first, &stackentry);\n@@ -648,32 +656,30 @@ get_true_reg (pat)\n      rtx *pat;\n {\n   for (;;)\n-     switch (GET_CODE (*pat))\n+    switch (GET_CODE (*pat))\n       {\n-\tcase SUBREG:\n-\t\t/* eliminate FP subregister accesses in favour of the\n-\t\t   actual FP register in use.  */\n-\t {\n-\t   rtx subreg;\n-\t   if (FP_REG_P (subreg = SUBREG_REG (*pat)))\n+      case SUBREG:\n+\t/* Eliminate FP subregister accesses in favour of the\n+\t   actual FP register in use.  */\n+\t{\n+\t  rtx subreg;\n+\t  if (FP_REG_P (subreg = SUBREG_REG (*pat)))\n \t    {\n \t      *pat = FP_MODE_REG (REGNO (subreg) + SUBREG_WORD (*pat),\n \t\t\t\t  GET_MODE (subreg));\n-\tdefault:\n+\t    default:\n \t      return pat;\n \t    }\n-\t }\n-\tcase FLOAT:\n-\tcase FIX:\n-\tcase FLOAT_EXTEND:\n-\t   pat = & XEXP (*pat, 0);\n+\t}\n+      case FLOAT:\n+      case FIX:\n+      case FLOAT_EXTEND:\n+\tpat = & XEXP (*pat, 0);\n       }\n }\n \f\n /* Record the life info of each stack reg in INSN, updating REGSTACK.\n    N_INPUTS is the number of inputs; N_OUTPUTS the outputs.\n-   OPERANDS is an array of all operands for the insn, and is assumed to\n-   contain all output operands, then all inputs operands.\n \n    There are many rules that an asm statement for stack-like regs must\n    follow.  Those rules are explained at the top of this file: the rule\n@@ -712,7 +718,7 @@ record_asm_reg_life (insn, regstack)\n       malformed_asm = 1;\n       /* Avoid further trouble with this insn.  */\n       PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n-      VARRAY_CHAR (stack_regs_mentioned_data, INSN_UID (insn)) = 2;\n+      PUT_MODE (insn, VOIDmode);\n       return;\n     }\n \n@@ -917,10 +923,10 @@ record_reg_life_pat (pat, src, dest, douse)\n       || (GET_CODE (pat) == SUBREG && STACK_REG_P (SUBREG_REG (pat))))\n     {\n       if (src)\n-\t mark_regs_pat (pat, src);\n+\tmark_regs_pat (pat, src);\n \n       if (dest)\n-\t mark_regs_pat (pat, dest);\n+\tmark_regs_pat (pat, dest);\n \n       return;\n     }\n@@ -1022,74 +1028,74 @@ record_reg_life (insn, block, regstack)\n       return;\n     }\n \n-    {\n-      HARD_REG_SET src, dest;\n-      int regno;\n-\n-      CLEAR_HARD_REG_SET (src);\n-      CLEAR_HARD_REG_SET (dest);\n-\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t for (note = CALL_INSN_FUNCTION_USAGE (insn);\n-\t      note;\n-\t      note = XEXP (note, 1))\n-\t   if (GET_CODE (XEXP (note, 0)) == USE)\n-\t     record_reg_life_pat (SET_DEST (XEXP (note, 0)), &src, NULL_PTR, 0);\n-\n-      record_reg_life_pat (PATTERN (insn), &src, &dest, 0);\n-      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n-\tif (! TEST_HARD_REG_BIT (regstack->reg_set, regno))\n-\t  {\n-\t    if (TEST_HARD_REG_BIT (src, regno)\n-\t\t&& ! TEST_HARD_REG_BIT (dest, regno))\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t\t    FP_MODE_REG (regno, DFmode),\n-\t\t\t\t\t\t    REG_NOTES (insn));\n-\t    else if (TEST_HARD_REG_BIT (dest, regno))\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t\t\t\t    FP_MODE_REG (regno, DFmode),\n-\t\t\t\t\t\t    REG_NOTES (insn));\n-\t  }\n+  {\n+    HARD_REG_SET src, dest;\n+    int regno;\n+\n+    CLEAR_HARD_REG_SET (src);\n+    CLEAR_HARD_REG_SET (dest);\n+\n+    if (GET_CODE (insn) == CALL_INSN)\n+      for (note = CALL_INSN_FUNCTION_USAGE (insn);\n+\t   note;\n+\t   note = XEXP (note, 1))\n+\tif (GET_CODE (XEXP (note, 0)) == USE)\n+\t  record_reg_life_pat (SET_DEST (XEXP (note, 0)), &src, NULL_PTR, 0);\n+\n+    record_reg_life_pat (PATTERN (insn), &src, &dest, 0);\n+    for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n+      if (! TEST_HARD_REG_BIT (regstack->reg_set, regno))\n+\t{\n+\t  if (TEST_HARD_REG_BIT (src, regno)\n+\t      && ! TEST_HARD_REG_BIT (dest, regno))\n+\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n+\t\t\t\t\t\t  REG_NOTES (insn));\n+\t  else if (TEST_HARD_REG_BIT (dest, regno))\n+\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n+\t\t\t\t\t\t  REG_NOTES (insn));\n+\t}\n \n-      if (GET_CODE (insn) == CALL_INSN)\n-        {\n-\t  int reg;\n+    if (GET_CODE (insn) == CALL_INSN)\n+      {\n+\tint reg;\n \n-          /* There might be a reg that is live after a function call.\n-             Initialize it to zero so that the program does not crash.  See\n-\t     comment towards the end of stack_reg_life_analysis().  */\n+\t/* There might be a reg that is live after a function call.\n+\t   Initialize it to zero so that the program does not crash.  See\n+\t   comment towards the end of stack_reg_life_analysis().  */\n \n-          for (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n-\t    if (! TEST_HARD_REG_BIT (dest, reg)\n-\t        && TEST_HARD_REG_BIT (regstack->reg_set, reg))\n-\t      {\n-\t        rtx init, pat;\n+\tfor (reg = FIRST_STACK_REG; reg <= LAST_STACK_REG; reg++)\n+\t  if (! TEST_HARD_REG_BIT (dest, reg)\n+\t      && TEST_HARD_REG_BIT (regstack->reg_set, reg))\n+\t    {\n+\t      rtx init, pat;\n \n-\t        /* The insn will use virtual register numbers, and so\n-\t           convert_regs is expected to process these.  But BLOCK_NUM\n-\t           cannot be used on these insns, because they do not appear in\n-\t           block_number[].  */\n+\t      /* The insn will use virtual register numbers, and so\n+\t\t convert_regs is expected to process these.  But BLOCK_NUM\n+\t\t cannot be used on these insns, because they do not appear in\n+\t\t block_number[].  */\n \n-\t        pat = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, DFmode),\n-\t\t\t\t   CONST0_RTX (DFmode));\n-\t        init = emit_insn_after (pat, insn);\n+\t      pat = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, DFmode),\n+\t\t\t\t CONST0_RTX (DFmode));\n+\t      init = emit_insn_after (pat, insn);\n \n-\t        CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n+\t      CLEAR_HARD_REG_BIT (regstack->reg_set, reg);\n \n-\t        /* If the CALL_INSN was the end of a block, move the\n-\t           block_end to point to the new insn.  */\n+\t      /* If the CALL_INSN was the end of a block, move the\n+\t\t block_end to point to the new insn.  */\n \n-\t        if (block_end[block] == insn)\n-\t          block_end[block] = init;\n-\t      }\n+\t      if (block_end[block] == insn)\n+\t\tblock_end[block] = init;\n+\t    }\n \n-\t  /* Some regs do not survive a CALL */\n-          AND_COMPL_HARD_REG_SET (regstack->reg_set, call_used_reg_set);\n-\t}\n+\t/* Some regs do not survive a CALL */\n+\tAND_COMPL_HARD_REG_SET (regstack->reg_set, call_used_reg_set);\n+      }\n \n-      AND_COMPL_HARD_REG_SET (regstack->reg_set, dest);\n-      IOR_HARD_REG_SET (regstack->reg_set, src);\n-    }\n+    AND_COMPL_HARD_REG_SET (regstack->reg_set, dest);\n+    IOR_HARD_REG_SET (regstack->reg_set, src);\n+  }\n }\n \f\n /* Find all basic blocks of the function, which starts with FIRST.\n@@ -1240,26 +1246,26 @@ stack_reg_life_analysis (first, stackentry)\n   int reg, block;\n   struct stack_def regstack;\n \n-   {\n-     rtx retvalue;\n+  {\n+    rtx retvalue;\n \n-     if ((retvalue = stack_result (current_function_decl)))\n+    if ((retvalue = stack_result (current_function_decl)))\n       {\n         /* Find all RETURN insns and mark them.  */\n \n         for (block = blocks - 1; --block >= 0;)\n-\t   if (GET_CODE (block_end[block]) == JUMP_INSN\n-\t       && returnjump_p (block_end[block]))\n-\t      mark_regs_pat (retvalue, block_out_reg_set+block);\n+\t  if (GET_CODE (block_end[block]) == JUMP_INSN\n+\t      && returnjump_p (block_end[block]))\n+\t    mark_regs_pat (retvalue, block_out_reg_set+block);\n \n         /* Mark off the end of last block if we \"fall off\" the end of the\n \t   function into the epilogue.  */\n \n         if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n-\t    || returnjump_p (block_end[blocks-1]))\n+\t    || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n \t  mark_regs_pat (retvalue, block_out_reg_set+blocks-1);\n       }\n-   }\n+  }\n \n   /* now scan all blocks backward for stack register use */\n \n@@ -1343,10 +1349,10 @@ stack_reg_life_analysis (first, stackentry)\n       block -= 1;\n     }\n \n-    /* If any reg is live at the start of the first block of a\n-       function, then we must guarantee that the reg holds some value by\n-       generating our own \"load\" of that register.  Otherwise a 387 would\n-       fault trying to access an empty register.  */\n+  /* If any reg is live at the start of the first block of a\n+     function, then we must guarantee that the reg holds some value by\n+     generating our own \"load\" of that register.  Otherwise a 387 would\n+     fault trying to access an empty register.  */\n \n   /* Load zero into each live register.  The fact that a register\n      appears live at the function start necessarily implies an error\n@@ -1373,10 +1379,10 @@ stack_reg_life_analysis (first, stackentry)\n       }\n }\n \f\n-/*****************************************************************************\n-   This section deals with stack register substitution, and forms the second\n-   pass over the RTL.\n- *****************************************************************************/\n+/*\n+ * This section deals with stack register substitution, and forms the second\n+ * pass over the RTL.\n+ */\n \n /* Replace REG, which is a pointer to a stack reg RTX, with an RTX for\n    the desired hard REGNO.  */\n@@ -1391,11 +1397,11 @@ replace_reg (reg, regno)\n     abort ();\n \n   switch (GET_MODE_CLASS (GET_MODE (*reg)))\n-   {\n-     default: abort ();\n-     case MODE_FLOAT:\n-     case MODE_COMPLEX_FLOAT:;\n-   }\n+    {\n+    default: abort ();\n+    case MODE_FLOAT:\n+    case MODE_COMPLEX_FLOAT:;\n+    }\n \n   *reg = FP_MODE_REG (regno, GET_MODE (*reg));\n }\n@@ -1454,27 +1460,16 @@ static void\n delete_insn_for_stacker (insn)\n      rtx insn;\n {\n-  int i;\n-\n-  /* Ensure that the side effects were clobbers when deleting a PARALLEL.  */\n-  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-    for (i = 1; i < XVECLEN (PATTERN (insn), 0); i++)\n-      if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) != CLOBBER)\n-\tabort ();\n-\n   PUT_CODE (insn, NOTE);\n   NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n   NOTE_SOURCE_FILE (insn) = 0;\n }\n \f\n /* Emit an insn to pop virtual register REG before or after INSN.\n    REGSTACK is the stack state after INSN and is updated to reflect this\n-   pop.  WHEN is either emit_insn_before, emit_insn_after or NULL. \n-   in case WHEN is NULL we don't really emit the insn, just modify stack \n-   information.  Caller is expected to emit insn himself.\n-\n-   A pop insn is represented as a SET whose destination is the register to\n-   be popped and source is the top of stack.  A death note for the top of stack\n+   pop.  WHEN is either emit_insn_before or emit_insn_after.  A pop insn\n+   is represented as a SET whose destination is the register to be popped\n+   and source is the top of stack.  A death note for the top of stack\n    cases the movdf pattern to pop.  */\n \n static rtx\n@@ -1492,18 +1487,14 @@ emit_pop_insn (insn, regstack, reg, when)\n   if (hard_regno < FIRST_STACK_REG)\n     abort ();\n \n-  if (when)\n-   {\n-     pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n-\t\t\t    FP_MODE_REG (FIRST_STACK_REG, DFmode));\n+  pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n+\t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n-     pop_insn = (*when) (pop_rtx, insn);\n+  pop_insn = (*when) (pop_rtx, insn);\n \n-     REG_NOTES (pop_insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t       FP_MODE_REG (FIRST_STACK_REG,\n-\t\t\t\t\t\t\t    DFmode),\n-\t\t\t\t\t       REG_NOTES (pop_insn));\n-   }\n+  REG_NOTES (pop_insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t    FP_MODE_REG (FIRST_STACK_REG, DFmode),\n+\t\t\t\t\t    REG_NOTES (pop_insn));\n \n   regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n     = regstack->reg[regstack->top];\n@@ -1528,7 +1519,6 @@ emit_swap_insn (insn, regstack, reg)\n      rtx reg;\n {\n   int hard_regno;\n-  rtx gen_swapdf();\n   rtx swap_rtx, swap_insn;\n   int tmp, other_reg;\t\t/* swap regno temps */\n   rtx i1;\t\t\t/* the stack-reg insn prior to INSN */\n@@ -1578,15 +1568,8 @@ emit_swap_insn (insn, regstack, reg)\n \treturn;\n     }\n \n-  if (GET_RTX_CLASS (GET_CODE (i1)) == 'i' && sets_cc0_p (PATTERN (i1)))\n-    {\n-      i1 = next_nonnote_insn (i1);\n-      if (i1 == insn)\n-\tabort ();\n-    }\n-\n-  swap_rtx = gen_swapdf (FP_MODE_REG (hard_regno, DFmode),\n-\t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n+  swap_rtx = gen_swapxf (FP_MODE_REG (hard_regno, XFmode),\n+\t\t\t FP_MODE_REG (FIRST_STACK_REG, XFmode));\n   swap_insn = emit_insn_after (swap_rtx, i1);\n }\n \f\n@@ -1732,109 +1715,144 @@ move_for_stack_reg (insn, regstack, pat)\n     abort ();\n }\n \f\n-static void\n-swap_rtx_condition (pat)\n+/* Swap the condition on a branch, if there is one.  Return true if we\n+   found a condition to swap.  False if the condition was not used as\n+   such. */\n+\n+static int\n+swap_rtx_condition_1 (pat)\n      rtx pat;\n {\n   register const char *fmt;\n-  register int i;\n+  register int i, r = 0;\n \n   if (GET_RTX_CLASS (GET_CODE (pat)) == '<')\n     {\n       PUT_CODE (pat, swap_condition (GET_CODE (pat)));\n-      return;\n+      r = 1;\n     }\n-\n-  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n-  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n+  else\n     {\n-      if (fmt[i] == 'E')\n+      fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+      for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n \t{\n-\t  register int j;\n+\t  if (fmt[i] == 'E')\n+\t    {\n+\t      register int j;\n \n-\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n-\t    swap_rtx_condition (XVECEXP (pat, i, j));\n+\t      for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n+\t\tr |= swap_rtx_condition_1 (XVECEXP (pat, i, j));\n+\t    }\n+\t  else if (fmt[i] == 'e')\n+\t    r |= swap_rtx_condition_1 (XEXP (pat, i));\n \t}\n-      else if (fmt[i] == 'e')\n-\tswap_rtx_condition (XEXP (pat, i));\n     }\n+\n+  return r;\n+}\n+\n+static int\n+swap_rtx_condition (insn)\n+     rtx insn;\n+{\n+  rtx pat = PATTERN (insn);\n+\n+  /* We're looking for a single set to cc0 or an HImode temporary.  */\n+\n+  if (GET_CODE (pat) == SET\n+      && GET_CODE (SET_DEST (pat)) == REG\n+      && REGNO (SET_DEST (pat)) == FLAGS_REG)\n+    {\n+      insn = next_flags_user (insn);\n+      if (insn == NULL_RTX)\n+\treturn 0;\n+      pat = PATTERN (insn);\n+    }\n+\n+  /* See if this is, or ends in, a fnstsw, aka unspec 9.  If so, we're\n+     not doing anything with the cc value right now.  We may be able to\n+     search for one though.  */\n+\n+  if (GET_CODE (pat) == SET\n+      && GET_CODE (SET_SRC (pat)) == UNSPEC\n+      && XINT (SET_SRC (pat), 1) == 9)\n+    {\n+      rtx dest = SET_DEST (pat);\n+\n+      /* Search forward looking for the first use of this value. \n+\t Stop at block boundaries.  */\n+      /* ??? This really cries for BLOCK_END!  */\n+      while (1)\n+\t{\n+\t  insn = NEXT_INSN (insn);\n+\t  if (insn == NULL_RTX)\n+\t    return 0;\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t      && reg_mentioned_p (dest, insn))\n+\t    break;\n+\t  if (GET_CODE (insn) == JUMP_INSN)\n+\t    return 0;\n+\t  if (GET_CODE (insn) == CODE_LABEL)\n+\t    return 0;\n+\t}\n+\n+      /* So we've found the insn using this value.  If it is anything\n+\t other than sahf, aka unspec 10, or the value does not die\n+\t (meaning we'd have to search further), then we must give up.  */\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) != SET\n+\t  || GET_CODE (SET_SRC (pat)) != UNSPEC\n+\t  || XINT (SET_SRC (pat), 1) != 10\n+\t  || ! dead_or_set_p (insn, dest))\n+\treturn 0;\n+\n+      /* Now we are prepared to handle this as a normal cc0 setter.  */\n+      insn = next_flags_user (insn);\n+      if (insn == NULL_RTX)\n+\treturn 0;\n+      pat = PATTERN (insn);\n+    }\n+\n+  return swap_rtx_condition_1 (pat);\n }\n \n /* Handle a comparison.  Special care needs to be taken to avoid\n    causing comparisons that a 387 cannot do correctly, such as EQ.\n \n-   Also, a fstp instruction may need to be emitted.  The 387 does have an\n+   Also, a pop insn may need to be emitted.  The 387 does have an\n    `fcompp' insn that can pop two regs, but it is sometimes too expensive\n    to do this - a `fcomp' followed by a `fstpl %st(0)' may be easier to\n-   set up. \n- \n-   We can not handle this by emiting fpop instruction after compare, because\n-   it appears between cc0 setter and user.  So we emit only\n-   REG_DEAD note and handle it as a special case in machine description.\n- \n-   This code used trick with delay_slot filling to emit pop insn after\n-   comparsion but it didn't worked because it caused confusion with cc_status\n-   in final pass. */\n+   set up.  */\n \n static void\n-compare_for_stack_reg (insn, regstack, pat)\n+compare_for_stack_reg (insn, regstack, pat_src)\n      rtx insn;\n      stack regstack;\n-     rtx pat;\n+     rtx pat_src;\n {\n   rtx *src1, *src2;\n   rtx src1_note, src2_note;\n-  rtx cc0_user;\n-  int have_cmove; \n-  int hard_regno;\n+  rtx flags_user;\n \n-  src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n-  src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n-  cc0_user = next_cc0_user (insn);\n-\n-  /* If the insn that uses cc0 is an FP-conditional move, then the destination\n-     must be the top of stack */\n-  if (GET_CODE (PATTERN (cc0_user)) == SET\n-      && SET_DEST (PATTERN (cc0_user)) != pc_rtx\n-      && GET_CODE (SET_SRC (PATTERN (cc0_user))) == IF_THEN_ELSE\n-      && (GET_MODE_CLASS (GET_MODE (SET_DEST (PATTERN (cc0_user))))\n-\t  == MODE_FLOAT))\n-    {\n-      rtx *dest;\n-      \n-      dest = get_true_reg (&SET_DEST (PATTERN (cc0_user)));\n-\n-      have_cmove = 1;\n-      if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG\n-\t  && REGNO (*dest) != regstack->reg[regstack->top])\n-\t{\n-\t  emit_swap_insn (insn, regstack, *dest);\t\n-\t}\n-    }\n-  else\n-    have_cmove = 0;\n+  src1 = get_true_reg (&XEXP (pat_src, 0));\n+  src2 = get_true_reg (&XEXP (pat_src, 1));\n+  flags_user = next_flags_user (insn);\n \n   /* ??? If fxch turns out to be cheaper than fstp, give priority to\n      registers that die in this insn - move those to stack top first.  */\n-  if (! STACK_REG_P (*src1)\n-      || (STACK_REG_P (*src2)\n-\t  && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))\n+  if ((! STACK_REG_P (*src1)\n+       || (STACK_REG_P (*src2)\n+\t   && get_hard_regnum (regstack, *src2) == FIRST_STACK_REG))\n+      && swap_rtx_condition (insn))\n     {\n-      rtx temp, next;\n-\n-      temp = XEXP (SET_SRC (pat), 0);\n-      XEXP (SET_SRC (pat), 0) = XEXP (SET_SRC (pat), 1);\n-      XEXP (SET_SRC (pat), 1) = temp;\n+      rtx temp;\n+      temp = XEXP (pat_src, 0);\n+      XEXP (pat_src, 0) = XEXP (pat_src, 1);\n+      XEXP (pat_src, 1) = temp;\n \n-      src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n-      src2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n-\n-      next = next_cc0_user (insn);\n-      if (next == NULL_RTX)\n-\tabort ();\n+      src1 = get_true_reg (&XEXP (pat_src, 0));\n+      src2 = get_true_reg (&XEXP (pat_src, 1));\n \n-      swap_rtx_condition (PATTERN (next));\n-      INSN_CODE (next) = -1;\n       INSN_CODE (insn) = -1;\n     }\n \n@@ -1847,16 +1865,12 @@ compare_for_stack_reg (insn, regstack, pat)\n   else\n     src2_note = NULL_RTX;\n \n-  if (! have_cmove)\n-     emit_swap_insn (insn, regstack, *src1);\n+  emit_swap_insn (insn, regstack, *src1);\n \n   replace_reg (src1, FIRST_STACK_REG);\n \n   if (STACK_REG_P (*src2))\n-    {\n-      hard_regno = get_hard_regnum (regstack, *src2);\n-      replace_reg (src2, hard_regno);\n-    }\n+    replace_reg (src2, get_hard_regnum (regstack, *src2));\n \n   if (src1_note)\n     {\n@@ -1885,11 +1899,16 @@ compare_for_stack_reg (insn, regstack, pat)\n \t}\n       else\n \t{\n-\t  /* Pop of second operand is handled using special REG_DEAD note\n-\t     because we can't emit pop insn after cc0 setter.  */\n+\t  /* The 386 can only represent death of the first operand in\n+\t     the case handled above.  In all other cases, emit a separate\n+\t     pop and remove the death note from here.  */\n+\n+\t  /* link_cc0_insns (insn); */\n \n-\t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0), NULL);\n-\t  replace_reg (&XEXP (src2_note, 0), hard_regno);\n+\t  remove_regno_note (insn, REG_DEAD, REGNO (XEXP (src2_note, 0)));\n+\n+\t  emit_pop_insn (insn, regstack, XEXP (src2_note, 0),\n+\t\t\t emit_insn_after);\n \t}\n     }\n }\n@@ -1906,12 +1925,14 @@ subst_stack_regs_pat (insn, regstack, pat)\n   rtx *dest, *src;\n   rtx *src1 = (rtx *) NULL_PTR, *src2;\n   rtx src1_note, src2_note;\n+  rtx pat_src;\n \n   if (GET_CODE (pat) != SET)\n     return;\n \n   dest = get_true_reg (&SET_DEST (pat));\n   src  = get_true_reg (&SET_SRC (pat));\n+  pat_src = SET_SRC (pat);\n \n   /* See if this is a `movM' pattern, and handle elsewhere if so.  */\n \n@@ -1922,22 +1943,22 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t\t  || GET_CODE (*src) == CONST_DOUBLE))))\n     move_for_stack_reg (insn, regstack, pat);\n   else\n-    switch (GET_CODE (SET_SRC (pat)))\n+    switch (GET_CODE (pat_src))\n       {\n       case COMPARE:\n-\tcompare_for_stack_reg (insn, regstack, pat);\n+\tcompare_for_stack_reg (insn, regstack, pat_src);\n \tbreak;\n \n       case CALL:\n-\t {\n-\t   int count;\n-\t   for (count = HARD_REGNO_NREGS (REGNO (*dest), GET_MODE (*dest));\n-              --count >= 0;)\n+\t{\n+\t  int count;\n+\t  for (count = HARD_REGNO_NREGS (REGNO (*dest), GET_MODE (*dest));\n+\t       --count >= 0;)\n \t    {\n \t      regstack->reg[++regstack->top] = REGNO (*dest) + count;\n \t      SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest) + count);\n \t    }\n-\t }\n+\t}\n \treplace_reg (dest, FIRST_STACK_REG);\n \tbreak;\n \n@@ -1960,7 +1981,7 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t   source.  */\n \n \tif (src1 == 0)\n-\t  src1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n+\t  src1 = get_true_reg (&XEXP (pat_src, 0));\n \n \temit_swap_insn (insn, regstack, *src1);\n \n@@ -1992,8 +2013,8 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t   source and some other stack register (possibly top of stack)\n \t   as a destination.  */\n \n-\tsrc1 = get_true_reg (&XEXP (SET_SRC (pat), 0));\n-\tsrc2 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n+\tsrc1 = get_true_reg (&XEXP (pat_src, 0));\n+\tsrc2 = get_true_reg (&XEXP (pat_src, 1));\n \n \t/* We will fix any death note later.  */\n \n@@ -2095,13 +2116,13 @@ subst_stack_regs_pat (insn, regstack, pat)\n \tbreak;\n \n       case UNSPEC:\n-\tswitch (XINT (SET_SRC (pat), 1))\n+\tswitch (XINT (pat_src, 1))\n \t  {\n \t  case 1: /* sin */\n \t  case 2: /* cos */\n \t    /* These insns only operate on the top of the stack.  */\n \n-\t    src1 = get_true_reg (&XVECEXP (SET_SRC (pat), 0, 0));\n+\t    src1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n \n \t    emit_swap_insn (insn, regstack, *src1);\n \n@@ -2121,16 +2142,35 @@ subst_stack_regs_pat (insn, regstack, pat)\n \n \t    break;\n \n+\t  case 10:\n+\t    /* (unspec [(unspec [(compare ..)] 9)] 10)\n+\t       Unspec 9 is fnstsw; unspec 10 is sahf.  The combination\n+\t       matches the PPRO fcomi instruction.  */\n+\n+\t    pat_src = XVECEXP (pat_src, 0, 0);\n+\t    if (GET_CODE (pat_src) != UNSPEC\n+\t\t|| XINT (pat_src, 1) != 9)\n+\t      abort ();\n+\t    /* FALLTHRU */\n+\n+\t  case 9:\n+\t    /* (unspec [(compare ..)] 9)\n+\t       Combined fcomp+fnstsw generated for doing well with CSE.\n+\t       When optimizing this would have been broken up before now.  */\n+\n+\t    pat_src = XVECEXP (pat_src, 0, 0);\n+\t    if (GET_CODE (pat_src) != COMPARE)\n+\t      abort ();\n+\n+\t    compare_for_stack_reg (insn, regstack, pat_src);\n+\t    break;\n+\n \t  default:\n \t    abort ();\n \t  }\n \tbreak;\n \n       case IF_THEN_ELSE:\n-\t/* dest has to be on stack. */\n-\tif (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n-\t  abort ();\n-\n \t/* This insn requires the top of stack to be the destination. */\n \n \t/* If the comparison operator is an FP comparison operator,\n@@ -2142,8 +2182,8 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t    && REGNO (*dest) != regstack->reg[regstack->top])\n \t  emit_swap_insn (insn, regstack, *dest);\t\n \n-\tsrc1 = get_true_reg (&XEXP (SET_SRC (pat), 1));\n-\tsrc2 = get_true_reg (&XEXP (SET_SRC (pat), 2));\n+\tsrc1 = get_true_reg (&XEXP (pat_src, 1));\n+\tsrc2 = get_true_reg (&XEXP (pat_src, 2));\n \n \tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \tsrc2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n@@ -2184,7 +2224,9 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t      }\n \t}\n \n-\t/* Make dest the top of stack. */\n+\t/* Make dest the top of stack.  Add dest to regstack if not present. */\n+\tif (get_hard_regnum (regstack, *dest) < FIRST_STACK_REG)\n+\t  regstack->reg[++regstack->top] = REGNO (*dest);\t\n \tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n \treplace_reg (dest, FIRST_STACK_REG);\n \n@@ -2500,26 +2542,26 @@ subst_stack_regs (insn, regstack)\n   register int i;\n \n   if (GET_CODE (insn) == CALL_INSN)\n-   {\n-     int top = regstack->top;\n+    {\n+      int top = regstack->top;\n \n-     /* If there are any floating point parameters to be passed in\n-\tregisters for this call, make sure they are in the right\n-\torder.  */\n+      /* If there are any floating point parameters to be passed in\n+\t registers for this call, make sure they are in the right\n+\t order.  */\n \n-     if (top >= 0)\n-      {\n-\tstraighten_stack (PREV_INSN (insn), regstack);\n+      if (top >= 0)\n+\t{\n+\t  straighten_stack (PREV_INSN (insn), regstack);\n \n-\t/* Now mark the arguments as dead after the call.  */\n+\t  /* Now mark the arguments as dead after the call.  */\n \n-        while (regstack->top >= 0)\n-         {\n-           CLEAR_HARD_REG_BIT (regstack->reg_set, FIRST_STACK_REG + regstack->top);\n-\t   regstack->top--;\n-         }\n-      }\n-   }\n+\t  while (regstack->top >= 0)\n+\t    {\n+\t      CLEAR_HARD_REG_BIT (regstack->reg_set, FIRST_STACK_REG + regstack->top);\n+\t      regstack->top--;\n+\t    }\n+\t}\n+    }\n \n   /* Do the actual substitution if any stack regs are mentioned.\n      Since we only record whether entire insn mentions stack regs, and\n@@ -2544,14 +2586,8 @@ subst_stack_regs (insn, regstack)\n \tfor (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n \t  {\n \t    if (stack_regs_mentioned_p (XVECEXP (PATTERN (insn), 0, i)))\n-\t      {\n-\t\tsubst_stack_regs_pat (insn, regstack,\n-\t\t\t\t      XVECEXP (PATTERN (insn), 0, i));\n-\n-\t\t/* subst_stack_regs_pat may have deleted a no-op insn.  */\n-\t\tif (GET_CODE (insn) == NOTE)\n-\t\t  break;\n-\t      }\n+\t      subst_stack_regs_pat (insn, regstack,\n+\t\t\t\t    XVECEXP (PATTERN (insn), 0, i));\n \t  }\n       else\n \tsubst_stack_regs_pat (insn, regstack, PATTERN (insn));\n@@ -2712,27 +2748,27 @@ goto_block_pat (insn, regstack, pat)\n   int reg;\n \n   switch (GET_CODE (pat))\n-   {\n-     case RETURN:\n-\tstraighten_stack (PREV_INSN (insn), regstack);\n-\treturn;\n-     default:\n-     {\n-      int i, j;\n-      const char *fmt = GET_RTX_FORMAT (GET_CODE (pat));\n-\n-      for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n-\t{\n-\t  if (fmt[i] == 'e')\n-\t    goto_block_pat (insn, regstack, XEXP (pat, i));\n-\t  if (fmt[i] == 'E')\n-\t    for (j = 0; j < XVECLEN (pat, i); j++)\n-\t      goto_block_pat (insn, regstack, XVECEXP (pat, i, j));\n-\t}\n+    {\n+    case RETURN:\n+      straighten_stack (PREV_INSN (insn), regstack);\n       return;\n-     }\n-     case LABEL_REF:;\n-   }\n+    default:\n+      {\n+\tint i, j;\n+\tconst char *fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+\n+\tfor (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n+\t  {\n+\t    if (fmt[i] == 'e')\n+\t      goto_block_pat (insn, regstack, XEXP (pat, i));\n+\t    if (fmt[i] == 'E')\n+\t      for (j = 0; j < XVECLEN (pat, i); j++)\n+\t\tgoto_block_pat (insn, regstack, XVECEXP (pat, i, j));\n+\t  }\n+\treturn;\n+      }\n+    case LABEL_REF:;\n+    }\n \n   label = XEXP (pat, 0);\n   if (GET_CODE (label) != CODE_LABEL)\n@@ -2896,26 +2932,26 @@ convert_regs ()\n      regs live at its start, then the last basic block will have regs live\n      at its end that need to be popped before the function returns.  */\n \n-   {\n-     int value_reg_low, value_reg_high;\n-     value_reg_low = value_reg_high = -1;\n-      {\n-        rtx retvalue;\n-        if ((retvalue = stack_result (current_function_decl)))\n-\t {\n-\t   value_reg_low = REGNO (retvalue);\n-\t   value_reg_high = value_reg_low +\n+  {\n+    int value_reg_low, value_reg_high;\n+    value_reg_low = value_reg_high = -1;\n+    {\n+      rtx retvalue;\n+      if ((retvalue = stack_result (current_function_decl)))\n+\t{\n+\t  value_reg_low = REGNO (retvalue);\n+\t  value_reg_high = value_reg_low +\n \t    HARD_REGNO_NREGS (value_reg_low, GET_MODE (retvalue)) - 1;\n-\t }\n+\t}\n \n-      }\n-     for (reg = regstack.top; reg >= 0; reg--)\n-        if (regstack.reg[reg] < value_reg_low\n-\t    || regstack.reg[reg] > value_reg_high)\n-           insn = emit_pop_insn (insn, &regstack,\n-\t\t\t    FP_MODE_REG (regstack.reg[reg], DFmode),\n-\t\t\t    emit_insn_after);\n-   }\n+    }\n+    for (reg = regstack.top; reg >= 0; reg--)\n+      if (regstack.reg[reg] < value_reg_low\n+\t  || regstack.reg[reg] > value_reg_high)\n+\tinsn = emit_pop_insn (insn, &regstack,\n+\t\t\t      FP_MODE_REG (regstack.reg[reg], DFmode),\n+\t\t\t      emit_insn_after);\n+  }\n   straighten_stack (insn, &regstack);\n }\n \f"}, {"sha": "59b27069466284c26a9e22267e26634b5c234784", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e075ae69f9d1263e78376038ab138c03e279f391/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e075ae69f9d1263e78376038ab138c03e279f391", "patch": "@@ -1568,7 +1568,6 @@ extern void output_func_start_profiler\tPROTO ((void));\n #ifdef BUFSIZ\n extern void reg_to_stack\t\tPROTO ((rtx, FILE *));\n #endif\n-extern int stack_regs_mentioned_p\tPROTO ((rtx));\n \n /* In fold-const.c */\n extern int add_double\t\tPROTO ((HOST_WIDE_INT, HOST_WIDE_INT,"}]}