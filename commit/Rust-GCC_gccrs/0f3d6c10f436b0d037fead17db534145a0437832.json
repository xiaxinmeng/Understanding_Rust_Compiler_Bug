{"sha": "0f3d6c10f436b0d037fead17db534145a0437832", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYzZDZjMTBmNDM2YjBkMDM3ZmVhZDE3ZGI1MzQxNDVhMDQzNzgzMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-12-21T00:41:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-21T00:41:24Z"}, "message": "Always simplify vector shifts by scalars.\n\nAlso decompose vectors in large integer modes.\n\n        * tree-vect-generic.c (expand_vector_operations_1): Correct tests\n        for vector types -- use the type not the mode.  Fix optab selection\n        for vector shifts by a scalar.  Handle over-large integer modes\n        like BLKmode.\n\nFrom-SVN: r182563", "tree": {"sha": "d40a75700f03d712360993d8d1068d8a7eacbf26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d40a75700f03d712360993d8d1068d8a7eacbf26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f3d6c10f436b0d037fead17db534145a0437832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3d6c10f436b0d037fead17db534145a0437832", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3d6c10f436b0d037fead17db534145a0437832", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3d6c10f436b0d037fead17db534145a0437832/comments", "author": null, "committer": null, "parents": [{"sha": "96e69fe20ef229fda89951492305a14c3701262f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96e69fe20ef229fda89951492305a14c3701262f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96e69fe20ef229fda89951492305a14c3701262f"}], "stats": {"total": 28, "additions": 20, "deletions": 8}, "files": [{"sha": "fbd55ef2790e6d8b5c6f7140b3181e6369936272", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f3d6c10f436b0d037fead17db534145a0437832/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f3d6c10f436b0d037fead17db534145a0437832/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f3d6c10f436b0d037fead17db534145a0437832", "patch": "@@ -1,3 +1,10 @@\n+2011-12-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-vect-generic.c (expand_vector_operations_1): Correct tests\n+\tfor vector types -- use the type not the mode.  Fix optab selection\n+\tfor vector shifts by a scalar.  Handle over-large integer modes\n+\tlike BLKmode.\n+\n 2011-12-20  Richard Henderson  <rth@redhat.com>\n \n \t* config/arm/arm.md (*arm_xorsi3): Match iorsi3 and perform"}, {"sha": "469a46545fc7a10fc92e96e74b82cc70bffe74a9", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f3d6c10f436b0d037fead17db534145a0437832/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f3d6c10f436b0d037fead17db534145a0437832/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=0f3d6c10f436b0d037fead17db534145a0437832", "patch": "@@ -796,10 +796,12 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n       || code == LROTATE_EXPR\n       || code == RROTATE_EXPR)\n     {\n+      optab opv;\n+\n       /* Check whether we have vector <op> {x,x,x,x} where x\n          could be a scalar variable or a constant.  Transform\n          vector <op> {x,x,x,x} ==> vector <op> scalar.  */\n-      if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (rhs2))))\n+      if (VECTOR_INTEGER_TYPE_P (TREE_TYPE (rhs2)))\n         {\n           tree first;\n           gimple def_stmt;\n@@ -818,17 +820,18 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n             }\n         }\n \n-      if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (rhs2))))\n-        op = optab_for_tree_code (code, type, optab_vector);\n+      opv = optab_for_tree_code (code, type, optab_vector);\n+      if (VECTOR_INTEGER_TYPE_P (TREE_TYPE (rhs2)))\n+\top = opv;\n       else\n \t{\n           op = optab_for_tree_code (code, type, optab_scalar);\n \n \t  /* The rtl expander will expand vector/scalar as vector/vector\n \t     if necessary.  Don't bother converting the stmt here.  */\n-\t  if (op == NULL\n-\t      || optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing)\n-\t    op = optab_for_tree_code (code, type, optab_vector);\n+\t  if (optab_handler (op, TYPE_MODE (type)) == CODE_FOR_nothing\n+\t      && optab_handler (opv, TYPE_MODE (type)) != CODE_FOR_nothing)\n+\t    return;\n \t}\n     }\n   else\n@@ -859,14 +862,16 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n \n   /* For very wide vectors, try using a smaller vector mode.  */\n   compute_type = type;\n-  if (TYPE_MODE (type) == BLKmode && op)\n+  if (!VECTOR_MODE_P (TYPE_MODE (type)) && op)\n     {\n       tree vector_compute_type\n         = type_for_widest_vector_mode (TYPE_MODE (TREE_TYPE (type)), op,\n \t\t\t\t       TYPE_SATURATING (TREE_TYPE (type)));\n       if (vector_compute_type != NULL_TREE\n \t  && (TYPE_VECTOR_SUBPARTS (vector_compute_type)\n-\t      < TYPE_VECTOR_SUBPARTS (compute_type)))\n+\t      < TYPE_VECTOR_SUBPARTS (compute_type))\n+\t  && (optab_handler (op, TYPE_MODE (vector_compute_type))\n+\t      != CODE_FOR_nothing))\n \tcompute_type = vector_compute_type;\n     }\n "}]}