{"sha": "ba31d94ee642e435d03ba73be3db027b362edd1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzMWQ5NGVlNjQyZTQzNWQwM2JhNzNiZTNkYjAyN2IzNjJlZGQxYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-03T21:10:09Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-03T21:10:09Z"}, "message": "emit-rtl.c, [...]: Remove all #ifndef REAL_ARITHMETIC blocks...\n\n\t* emit-rtl.c, final.c, fold-const.c, gengenrtl.c, optabs.c,\n\tprint-tree.c, real.c, real.h, recog.c, rtl.c, simplify-rtx.c,\n\ttree.c, config/m68k/m68k.c, f/com.c, f/target.h, java/expr.c,\n\tjava/jcf-parse.c, java/lex.c:\n\tRemove all #ifndef REAL_ARITHMETIC blocks, make all #ifdef\n\tREAL_ARITHMETIC blocks unconditional.  Delete some further\n\t#ifdef blocks predicated on REAL_ARITHMETIC.\n\t* flags.h, toplev.c: Delete remaining references to\n\tflag_pretend_float.\n\n\t* doc/invoke.texi: Remove documentation of -fpretend-float.\n\t* doc/tm.texi: Describe the various REAL_* macros as provided by\n\treal.h, not by the target configuration files.\n\n\t* config/alpha/alpha.h, config/alpha/unicosmk.h, config/arm/arm.h,\n\tconfig/avr/avr.h, config/c4x/c4x.h, config/convex/convex.h,\n\tconfig/cris/cris.h, config/d30v/d30v.h, config/dsp16xx/dsp16xx.h,\n\tconfig/h8300/h8300.h, config/i370/i370.h, config/i386/i386.h,\n\tconfig/i386/osf1elf.h, config/i960/i960.h, config/ia64/ia64.h,\n\tconfig/m32r/m32r.h, config/m68hc11/m68hc11.h, config/m68k/dpx2.h,\n\tconfig/m68k/linux-aout.h, config/m68k/linux.h, config/m68k/m68k.h,\n\tconfig/m68k/sun3.h, config/m68k/vxm68k.h, config/mcore/mcore.h,\n\tconfig/mips/mips.h, config/mmix/mmix.h, config/mn10200/mn10200.h,\n\tconfig/mn10300/mn10300.h, config/pa/pa.h, config/pj/pj.h,\n\tconfig/rs6000/rs6000.h, config/s390/s390.h, config/sh/sh.h,\n\tconfig/sparc/freebsd.h, config/sparc/linux.h, config/sparc/linux64.h,\n\tconfig/sparc/sol2.h, config/sparc/sparc.h, config/sparc/vxsim.h,\n\tconfig/stormy16/stormy16.h, config/v850/v850.h, config/vax/vax.h,\n\tconfig/xtensa/xtensa.h:\n\tDo not define, undefine, or mention in comments any of\n\tREAL_ARITHMETIC, REAL_VALUE_ATOF, REAL_VALUE_HTOF,\n\tREAL_VALUE_ISNAN, REAL_VALUE_ISINF,\n\tREAL_VALUE_TO_TARGET_SINGLE, REAL_VALUE_TO_TARGET_DOUBLE,\n\tREAL_VALUE_TO_TARGET_LONG_DOUBLE, REAL_VALUE_TO_DECIMAL,\n\tREAL_VALUE_TYPE, REAL_VALUES_EQUAL, REAL_VALUES_LESS,\n\tREAL_VALUE_LDEXP, REAL_VALUE_FIX, REAL_VALUE_UNSIGNED_FIX,\n\tREAL_VALUE_RNDZINT, REAL_VALUE_UNSIGNED_RNDZINT,\n\tREAL_INFINITY, REAL_VALUE_NEGATE, REAL_VALUE_TRUNCATE,\n\tREAL_VALUE_TO_INT, or REAL_VALUE_FROM_INT.\n\nFrom-SVN: r50263", "tree": {"sha": "95ce10820dcdc63db9f1448b54fe058ae5559247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95ce10820dcdc63db9f1448b54fe058ae5559247"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba31d94ee642e435d03ba73be3db027b362edd1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba31d94ee642e435d03ba73be3db027b362edd1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba31d94ee642e435d03ba73be3db027b362edd1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba31d94ee642e435d03ba73be3db027b362edd1b/comments", "author": null, "committer": null, "parents": [{"sha": "e98f0f5c1310aef9c628db762adc220b7521c027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98f0f5c1310aef9c628db762adc220b7521c027", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98f0f5c1310aef9c628db762adc220b7521c027"}], "stats": {"total": 2159, "additions": 123, "deletions": 2036}, "files": [{"sha": "d82d278e7e5f250170e27489786806bb5b4ebec2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1,3 +1,44 @@\n+2002-03-03  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* emit-rtl.c, final.c, fold-const.c, gengenrtl.c, optabs.c,\n+\tprint-tree.c, real.c, real.h, recog.c, rtl.c, simplify-rtx.c,\n+\ttree.c, config/m68k/m68k.c:\n+\tRemove all #ifndef REAL_ARITHMETIC blocks, make all #ifdef\n+\tREAL_ARITHMETIC blocks unconditional.  Delete some further\n+\t#ifdef blocks predicated on REAL_ARITHMETIC.\n+\t* flags.h, toplev.c: Delete remaining references to\n+\tflag_pretend_float.\n+\n+\t* doc/invoke.texi: Remove documentation of -fpretend-float.\n+\t* doc/tm.texi: Describe the various REAL_* macros as provided by\n+\treal.h, not by the target configuration files.\n+\n+\t* config/alpha/alpha.h, config/alpha/unicosmk.h, config/arm/arm.h,\n+\tconfig/avr/avr.h, config/c4x/c4x.h, config/convex/convex.h,\n+\tconfig/cris/cris.h, config/d30v/d30v.h, config/dsp16xx/dsp16xx.h,\n+\tconfig/h8300/h8300.h, config/i370/i370.h, config/i386/i386.h,\n+\tconfig/i386/osf1elf.h, config/i960/i960.h, config/ia64/ia64.h,\n+\tconfig/m32r/m32r.h, config/m68hc11/m68hc11.h, config/m68k/dpx2.h,\n+\tconfig/m68k/linux-aout.h, config/m68k/linux.h, config/m68k/m68k.h,\n+\tconfig/m68k/sun3.h, config/m68k/vxm68k.h, config/mcore/mcore.h,\n+\tconfig/mips/mips.h, config/mmix/mmix.h, config/mn10200/mn10200.h,\n+\tconfig/mn10300/mn10300.h, config/pa/pa.h, config/pj/pj.h,\n+\tconfig/rs6000/rs6000.h, config/s390/s390.h, config/sh/sh.h,\n+\tconfig/sparc/freebsd.h, config/sparc/linux.h, config/sparc/linux64.h,\n+\tconfig/sparc/sol2.h, config/sparc/sparc.h, config/sparc/vxsim.h,\n+\tconfig/stormy16/stormy16.h, config/v850/v850.h, config/vax/vax.h,\n+\tconfig/xtensa/xtensa.h:\n+\tDo not define, undefine, or mention in comments any of\n+\tREAL_ARITHMETIC, REAL_VALUE_ATOF, REAL_VALUE_HTOF,\n+\tREAL_VALUE_ISNAN, REAL_VALUE_ISINF,\n+\tREAL_VALUE_TO_TARGET_SINGLE, REAL_VALUE_TO_TARGET_DOUBLE,\n+\tREAL_VALUE_TO_TARGET_LONG_DOUBLE, REAL_VALUE_TO_DECIMAL,\n+\tREAL_VALUE_TYPE, REAL_VALUES_EQUAL, REAL_VALUES_LESS,\n+\tREAL_VALUE_LDEXP, REAL_VALUE_FIX, REAL_VALUE_UNSIGNED_FIX,\n+\tREAL_VALUE_RNDZINT, REAL_VALUE_UNSIGNED_RNDZINT,\n+\tREAL_INFINITY, REAL_VALUE_NEGATE, REAL_VALUE_TRUNCATE,\n+\tREAL_VALUE_TO_INT, or REAL_VALUE_FROM_INT.\n+\n 2002-03-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* 1750a.h, a29k.h, alpha.h, arc.h, arm.h, avr.h, c4x.h, clipper.h,\n@@ -8,7 +49,7 @@\n \tstormy16.h, v850.h, vax.h, we32k.h, xtensa.h (BITS_PER_WORD):\n \tDelete.\n \t* defaults.h (BITS_PER_WORD): Define.\n-\t* doc/tm.texi (BITS_PER_WORD): Document default value.\t\n+\t* doc/tm.texi (BITS_PER_WORD): Document default value.\n \n \t* 1750a.h, avr.h, convex.h, d30v.h, dsp16xx.h, fr30.h, ia64.h,\n \tm68hc11.h, m88k.h, mips.h, pdp11.h, rs6000.h, sparc.c,\n@@ -32,7 +73,7 @@\n \t* ggc-page.c (NUM_EXTRA_ORDERS): Likewise.\n \t* lcm.c (N_ENTITIES): Likewise.\n \t* stor-layout.c (set_sizetype): Likewise.\n-\t\n+\n 2002-03-03  Richard Henderson  <rth@redhat.com>\n \n \t* toplev.c (rest_of_decl_compilation): Do not invoke make_decl_rtl\n@@ -74,7 +115,7 @@\n \n \t* config/darwin-protos.h, config/darwin.c, config/darwin.h,\n \tconfig/a29k/a29k.h, config/alpha/alpha-protos.h, config/alpha/alpha.c,\n-\tconfig/alpha/alpha.h, config/arc/arc.h, config/arm/arm-protos.h, \n+\tconfig/alpha/alpha.h, config/arc/arc.h, config/arm/arm-protos.h,\n \tconfig/arm/arm.h, config/arm/pe.c, config/arm/pe.h,\n \tconfig/avr/avr-protos.h, config/avr/avr.c, config/avr/avr.h,\n \tconfig/c4x/c4x-protos.h, config/c4x/c4x.c, config/c4x/c4x.h,\n@@ -84,20 +125,20 @@\n \tconfig/i386/osfrose.h, config/i386/win32.h, config/i386/winnt.c,\n \tconfig/ia64/ia64-protos.h, config/ia64/ia64.c, config/ia64/ia64.h,\n \tconfig/m32r/m32r-protos.h, config/m32r/m32r.c, config/m32r/m32r.h,\n-\tconfig/m68hc11/m68hc11-protos.h, config/m68hc11/m68hc11.c, \n-\tconfig/m68hc11/m68hc11.h, config/m88k/m88k.h, \n+\tconfig/m68hc11/m68hc11-protos.h, config/m68hc11/m68hc11.c,\n+\tconfig/m68hc11/m68hc11.h, config/m88k/m88k.h,\n \tconfig/mcore/mcore-protos.h, config/mcore/mcore.c,\n \tconfig/mcore/mcore.h, config/mips/mips.h, config/ns32k/ns32k.h,\n \tconfig/pa/pa.h, config/romp/romp.h, config/rs6000/linux64.h,\n-\tconfig/rs6000/rs6000-protos.h, config/rs6000/rs6000.c, \n+\tconfig/rs6000/rs6000-protos.h, config/rs6000/rs6000.c,\n \tconfig/rs6000/sysv4.h, config/rs6000/xcoff.h, config/s390/s390.h,\n \tconfig/sh/sh.h, config/sparc/sparc.h,\n \tconfig/stormy16/stormy16-protos.h, config/stormy16/stormy16.c,\n \tconfig/stormy16/stormy16.h, config/v850/v850.h, config/vax/vms.h,\n \tconfig/xtensa/xtensa.h, doc/tm.texi: ENCODE_SECTION_INFO now takes\n \tFIRST argument.  As needed, examine it and do nothing.\n \n-\t* config/darwin.h, config/alpha/alpha.h, config/arm/pe.h, \n+\t* config/darwin.h, config/alpha/alpha.h, config/arm/pe.h,\n \tconfig/i386/cygwin.h, config/ia64/ia64.h, config/m68hc11/m68hc11.h,\n \tconfig/mcore/mcore.h: Remove REDO_SECTION_INFO_P.\n \n@@ -380,7 +421,7 @@ objc:\n \n 2002-02-27  Andrew MacLeod  <amacleod@redhat.com>\n \n-\t* dwarf2out.c (stack_adjust_offset): Add support for POST_INC, \n+\t* dwarf2out.c (stack_adjust_offset): Add support for POST_INC,\n \tPOST_DEC, and POST_MODIFY.\n \n 2002-02-27  Zack Weinberg  <zack@codesourcery.com>"}, {"sha": "683740d913c06fec560cb4b961a7f7cb1e0697a9", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -409,9 +409,6 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n \f\n /* target machine storage layout */\n \n-/* Define to enable software floating point emulation.  */\n-#define REAL_ARITHMETIC\n-\n /* Define the size of `int'.  The default is the same as the word size.  */\n #define INT_TYPE_SIZE 32\n "}, {"sha": "80492e486b85ce1c4881092816c808fbfc88013b", "filename": "gcc/config/alpha/unicosmk.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -35,13 +35,6 @@ Boston, MA 02111-1307, USA.  */\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-D__unix=1 -D_UNICOS=205 -D_CRAY=1 -D_CRAYT3E=1 -D_CRAYMPP=1 -D_CRAYIEEE=1 -D_ADDR64=1 -D_LD64=1 -D__UNICOSMK__ -D__INT_MAX__=9223372036854775807 -D__SHRT_MAX__=2147483647\"\n \n-/* Disable software floating point emulation because it requires a 16-bit\n-   type which we do not have.  */\n-\n-#ifndef __GNUC__\n-#undef REAL_ARITHMETIC\n-#endif\n-\n #define SHORT_TYPE_SIZE 32\n \n #undef INT_TYPE_SIZE\n@@ -568,14 +561,6 @@ ssib_section ()\t\t\t\\\n #undef ASM_OUTPUT_MAX_SKIP_ALIGN\n #define ASM_OUTPUT_MAX_SKIP_ALIGN(STREAM,POWER,MAXSKIP)\n \f\n-/* We have to define these because we do not use the floating-point\n-   emulation. Unfortunately, atof does not accept hex literals.  */ \n-\n-#ifndef REAL_ARITHMETIC\n-#define REAL_VALUE_ATOF(x,s) atof(x)\n-#define REAL_VALUE_HTOF(x,s) atof(x)\n-#endif\n-\n #undef NM_FLAGS\n \n #undef OBJECT_FORMAT_COFF"}, {"sha": "f536126acb1b0024f750a1fa77fd41efd41d0279", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -168,10 +168,6 @@ do {\t\t\t\t\\\n \f\n /* Target machine storage layout.  */\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 1"}, {"sha": "9a27c533c2e287124960ec3be858898f4a34b90a", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -647,8 +647,6 @@ extern int arm_is_6_or_7;\n /* This is required to ensure that push insns always push a word.  */\n #define PROMOTE_FUNCTION_ARGS\n \n-/* Define for XFmode extended real floating point support.\n-   This will automatically cause REAL_ARITHMETIC to be defined.  */\n /* For the ARM:\n    I think I have added all the code to make this work.  Unfortunately,\n    early releases of the floating point emulation code on RISCiX used a\n@@ -663,12 +661,6 @@ extern int arm_is_6_or_7;\n /* Disable XFmode patterns in md file */\n #define ENABLE_XF_PATTERNS 0\n \n-/* Define if you don't want extended real, but do want to use the\n-   software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n-/* See comment above */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN  0"}, {"sha": "e11961ab5a1d9c8e6058137653a6fb7550240f43", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -2915,10 +2915,6 @@ extern struct rtx_def *ldi_reg_rtx;\n \n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n-#define REAL_ARITHMETIC\n-\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n \n /* Get the standard ELF stabs definitions.  */"}, {"sha": "d9cd3da4e995353dcce2d604a49df6d9b9696450", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -360,11 +360,6 @@ extern const char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n #define BITS_PER_HIGH 16\n #define BITS_PER_LO_SUM 16\n \n-/* Use the internal floating point stuff in the compiler and not the\n-   host floating point stuff.  */\n-\n-#define REAL_ARITHMETIC\n-\n /* Define register numbers.  */\n \n /* Extended-precision registers.  */"}, {"sha": "7ed4e4539d92b0dc12ddf1b6b76143868ca03470", "filename": "gcc/config/convex/convex.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fconvex%2Fconvex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fconvex%2Fconvex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fconvex%2Fconvex.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -409,18 +409,6 @@ extern int target_flags;\n \n #define LINK_LIBGCC_SPECIAL_1\n \n-/* Since IEEE support was added to gcc, most things seem to like it\n-   better if we disable exceptions and check afterward for infinity.  */\n-\n-#if __convex__\n-#if _IEEE_FLOAT_\n-#define REAL_VALUE_ISNAN(x) 0\n-#define REAL_VALUE_ISINF(x) ((*(short *) &(x) & 0x7ff0) == 0x7ff0)\n-#else\n-#define REAL_VALUE_ISNAN(x) 0\n-#define REAL_VALUE_ISINF(x) ((*(short *) &(x) & 0xfff0) == 0x8000)\n-#endif\n-#endif\n \f\n /* Target machine storage layout */\n \n@@ -1089,9 +1077,6 @@ enum reg_class {\n    Follow the host format.  */\n #define TARGET_FLOAT_FORMAT HOST_FLOAT_FORMAT\n \n-/* But must prevent real.c from constructing VAX dfloats */\n-#define REAL_VALUE_ATOF(X,S) atof (X)\n-\n /* Check a `double' value for validity for a particular machine mode.  */\n #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\\n    (OVERFLOW = check_float_value (MODE, &D, OVERFLOW))"}, {"sha": "ac3d521a2dc2154272a99eaf222f4f490eb29532", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1746,10 +1746,6 @@ call_ ## FUNC (void)\t\t\t\t\t\t\\\n /* Node: SDB and DWARF */\n /* (no definitions) */\n \n-/* Node: Cross-compilation */\n-#define REAL_ARITHMETIC\n-\n-\n /* Node: Misc */\n \n /* FIXME: Check this one more time.  */"}, {"sha": "1ef08ac2ca2ce2382192619760f8aa81ceddd526", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -3000,27 +3000,6 @@ extern const char *d30v_branch_cost_string;\n /* These macros are provided by `real.h' for writing the definitions of\n    `ASM_OUTPUT_DOUBLE' and the like: */\n \n-/* These translate X, of type `REAL_VALUE_TYPE', to the target's floating point\n-   representation, and store its bit pattern in the array of `long int' whose\n-   address is L.  The number of elements in the output array is determined by\n-   the size of the desired target floating point data type: 32 bits of it go in\n-   each `long int' array element.  Each array element holds 32 bits of the\n-   result, even if `long int' is wider than 32 bits on the host machine.\n-\n-   The array element values are designed so that you can print them out using\n-   `fprintf' in the order they should appear in the target machine's memory.  */\n-/* #define REAL_VALUE_TO_TARGET_SINGLE(X, L) */\n-/* #define REAL_VALUE_TO_TARGET_DOUBLE(X, L) */\n-/* #define REAL_VALUE_TO_TARGET_LONG_DOUBLE(X, L) */\n-\n-/* This macro converts X, of type `REAL_VALUE_TYPE', to a decimal number and\n-   stores it as a string into STRING.  You must pass, as STRING, the address of\n-   a long enough block of space to hold the result.\n-\n-   The argument FORMAT is a `printf'-specification that serves as a suggestion\n-   for how to format the output string.  */\n-/* #define REAL_VALUE_TO_DECIMAL(X, FORMAT, STRING) */\n-\n \f\n /* Output of Uninitialized Variables.  */\n \n@@ -4139,144 +4118,6 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n /* #define SDB_ALLOW_FORWARD_REFERENCES */\n \n \f\n-/* Cross Compilation and Floating Point.  */\n-\n-/* While all modern machines use 2's complement representation for integers,\n-   there are a variety of representations for floating point numbers.  This\n-   means that in a cross-compiler the representation of floating point numbers\n-   in the compiled program may be different from that used in the machine doing\n-   the compilation.\n-\n-   Because different representation systems may offer different amounts of\n-   range and precision, the cross compiler cannot safely use the host machine's\n-   floating point arithmetic.  Therefore, floating point constants must be\n-   represented in the target machine's format.  This means that the cross\n-   compiler cannot use `atof' to parse a floating point constant; it must have\n-   its own special routine to use instead.  Also, constant folding must emulate\n-   the target machine's arithmetic (or must not be done at all).\n-\n-   The macros in the following table should be defined only if you are cross\n-   compiling between different floating point formats.\n-\n-   Otherwise, don't define them.  Then default definitions will be set up which\n-   use `double' as the data type, `==' to test for equality, etc.\n-\n-   You don't need to worry about how many times you use an operand of any of\n-   these macros.  The compiler never uses operands which have side effects.  */\n-\n-/* A macro for the C data type to be used to hold a floating point value in the\n-   target machine's format.  Typically this would be a `struct' containing an\n-   array of `int'.  */\n-/* #define REAL_VALUE_TYPE */\n-\n-/* A macro for a C expression which compares for equality the two values, X and\n-   Y, both of type `REAL_VALUE_TYPE'.  */\n-/* #define REAL_VALUES_EQUAL(X, Y) */\n-\n-/* A macro for a C expression which tests whether X is less than Y, both values\n-   being of type `REAL_VALUE_TYPE' and interpreted as floating point numbers in\n-   the target machine's representation.  */\n-/* #define REAL_VALUES_LESS(X, Y) */\n-\n-/* A macro for a C expression which performs the standard library function\n-   `ldexp', but using the target machine's floating point representation.  Both\n-   X and the value of the expression have type `REAL_VALUE_TYPE'.  The second\n-   argument, SCALE, is an integer.  */\n-/* #define REAL_VALUE_LDEXP(X, SCALE) */\n-\n-/* A macro whose definition is a C expression to convert the target-machine\n-   floating point value X to a signed integer.  X has type `REAL_VALUE_TYPE'.  */\n-/* #define REAL_VALUE_FIX(X) */\n-\n-/* A macro whose definition is a C expression to convert the target-machine\n-   floating point value X to an unsigned integer.  X has type\n-   `REAL_VALUE_TYPE'.  */\n-/* #define REAL_VALUE_UNSIGNED_FIX(X) */\n-\n-/* A macro whose definition is a C expression to round the target-machine\n-   floating point value X towards zero to an integer value (but still as a\n-   floating point number).  X has type `REAL_VALUE_TYPE', and so does the\n-   value.  */\n-/* #define REAL_VALUE_RNDZINT(X) */\n-\n-/* A macro whose definition is a C expression to round the target-machine\n-   floating point value X towards zero to an unsigned integer value (but still\n-   represented as a floating point number).  X has type `REAL_VALUE_TYPE', and\n-   so does the value.  */\n-/* #define REAL_VALUE_UNSIGNED_RNDZINT(X) */\n-\n-/* A macro for a C expression which converts STRING, an expression of type\n-   `char *', into a floating point number in the target machine's\n-   representation for mode MODE.  The value has type `REAL_VALUE_TYPE'.  */\n-/* #define REAL_VALUE_ATOF(STRING, MODE) */\n-\n-/* Define this macro if infinity is a possible floating point value, and\n-   therefore division by 0 is legitimate.  */\n-/* #define REAL_INFINITY */\n-\n-/* A macro for a C expression which determines whether X, a floating point\n-   value, is infinity.  The value has type `int'.  By default, this is defined\n-   to call `isinf'.  */\n-/* #define REAL_VALUE_ISINF(X) */\n-\n-/* A macro for a C expression which determines whether X, a floating point\n-   value, is a \"nan\" (not-a-number).  The value has type `int'.  By default,\n-   this is defined to call `isnan'.  */\n-/* #define REAL_VALUE_ISNAN(X) */\n-\n-/* Define the following additional macros if you want to make floating point\n-   constant folding work while cross compiling.  If you don't define them,\n-   cross compilation is still possible, but constant folding will not happen\n-   for floating point values.  */\n-\n-/* A macro for a C statement which calculates an arithmetic operation of the\n-   two floating point values X and Y, both of type `REAL_VALUE_TYPE' in the\n-   target machine's representation, to produce a result of the same type and\n-   representation which is stored in OUTPUT (which will be a variable).\n-\n-   The operation to be performed is specified by CODE, a tree code which will\n-   always be one of the following: `PLUS_EXPR', `MINUS_EXPR', `MULT_EXPR',\n-   `RDIV_EXPR', `MAX_EXPR', `MIN_EXPR'.\n-\n-   The expansion of this macro is responsible for checking for overflow.  If\n-   overflow happens, the macro expansion should execute the statement `return\n-   0;', which indicates the inability to perform the arithmetic operation\n-   requested.  */\n-/* #define REAL_ARITHMETIC(OUTPUT, CODE, X, Y) */\n-\n-/* The real.h file actually defines REAL_ARITHMETIC appropriately if it was\n-   defined at all before entering into the code, by using #undef first.  */\n-#define REAL_ARITHMETIC\n-\n-/* A macro for a C expression which returns the negative of the floating point\n-   value X.  Both X and the value of the expression have type `REAL_VALUE_TYPE'\n-   and are in the target machine's floating point representation.\n-\n-   There is no way for this macro to report overflow, since overflow can't\n-   happen in the negation operation.  */\n-/* #define REAL_VALUE_NEGATE(X) */\n-\n-/* A macro for a C expression which converts the floating point value X to mode\n-   MODE.\n-\n-   Both X and the value of the expression are in the target machine's floating\n-   point representation and have type `REAL_VALUE_TYPE'.  However, the value\n-   should have an appropriate bit pattern to be output properly as a floating\n-   constant whose precision accords with mode MODE.\n-\n-   There is no way for this macro to report overflow.  */\n-/* #define REAL_VALUE_TRUNCATE(MODE, X) */\n-\n-/* A macro for a C expression which converts a floating point value X into a\n-   double-precision integer which is then stored into LOW and HIGH, two\n-   variables of type INT.  */\n-/* #define REAL_VALUE_TO_INT(LOW, HIGH, X) */\n-\n-/* A macro for a C expression which converts a double-precision integer found\n-   in LOW and HIGH, two variables of type INT, into a floating point value\n-   which is then stored into X.  */\n-/* #define REAL_VALUE_FROM_INT(X, LOW, HIGH) */\n-\n \f\n /* Miscellaneous Parameters.  */\n "}, {"sha": "a9812830454b66dc30a7755cb0a9800ee0bfa9eb", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -294,11 +294,6 @@ extern int target_flags;\n \f\n /* STORAGE LAYOUT */\n \n-/* Define if you don't want extended real, but do want to use the\n-   software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n  */"}, {"sha": "f5b54db6b31a0594e07f7d9f531c2384e6d1c528", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -180,10 +180,6 @@ extern int target_flags;\n \f\n /* Target machine storage layout */\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n    This is not true on the H8/300.  */"}, {"sha": "52a343859498260ac3a6af0a239dfdbc10a5d279", "filename": "gcc/config/i370/linux.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi370%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi370%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Flinux.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -28,14 +28,6 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_ELF_ABI\n #define LINUX_DEFAULT_ELF\n \n-\n-/* hack alert define to get dbx/gdb/dwarf to compile  */\n-/* problem is that host float format is not target float format.  */\n-/* define REAL_ARITHMETIC for software emulation of float to\n- * int conversion.  This seems to have somethings to do with \n- * cross-compiling ...  */\n-#define REAL_ARITHMETIC\n-\n /* Include system common definitions */\n /* TODO: convert include to ${tm_file} list in config.gcc.  */\n #include \"i370/i370.h\""}, {"sha": "023a9dc14646b12045b116d05954fda532c30933", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -669,8 +669,6 @@ extern int ix86_arch;\n /* target machine storage layout */\n \n /* Define for XFmode or TFmode extended real floating point support.\n-   This will automatically cause REAL_ARITHMETIC to be defined.\n- \n    The XFmode is specified by i386 ABI, while TFmode may be faster\n    due to alignment and simplifications in the address calculations.\n  */\n@@ -702,11 +700,6 @@ extern int ix86_arch;\n #define MAX_LONG_TYPE_SIZE 32\n #endif\n \n-/* Define if you don't want extended real, but do want to use the\n-   software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-/* #define REAL_ARITHMETIC */\n-\n /* Define this if most significant byte of a word is the lowest numbered.  */\n /* That is true on the 80386.  */\n "}, {"sha": "a772442c4fc89536e9d94ee697d1554eb05c993e", "filename": "gcc/config/i386/osf1elf.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi386%2Fosf1elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosf1elf.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -205,9 +205,3 @@ do\t\t\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n-\n-#if defined (CROSS_COMPILE) && defined (HOST_BITS_PER_INT) && defined (HOST_BITS_PER_LONG) && defined (HOST_BITS_PER_LONGLONG)\n-#if (HOST_BITS_PER_INT==32) && (HOST_BITS_PER_LONG==64) && (HOST_BITS_PER_LONGLONG==64)\n-#define REAL_ARITHMETIC\n-#endif\n-#endif"}, {"sha": "a9f7e256c0ac2c5d5ee9faa9839012171c5fbd80", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -380,10 +380,6 @@ extern int target_flags;\n \f\n /* Target machine storage layout.  */\n \n-/* Define for cross-compilation from a host with a different float format\n-   or endianness, as well as to support 80 bit long doubles on the i960.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 0"}, {"sha": "b8f2449f91a4be5accdf8ccf31e566f19d7c65ec", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -2276,12 +2276,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n     assemble_name (FILE, LABEL);\t\t\t\\\n     fputc (')', FILE);\t\t\t\t\t\\\n   } while (0)\n-\f\n-/* Cross Compilation and Floating Point.  */\n-\n-/* Define to enable software floating point emulation.  */\n-#define REAL_ARITHMETIC\n-\n \f\n /* Register Renaming Parameters.  */\n "}, {"sha": "02a916812580fc0f0f173c71ff90e6623a80833e", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -421,10 +421,6 @@ extern enum m32r_sdata m32r_sdata;\n \f\n /* Target machine storage layout.  */\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 1"}, {"sha": "cdb28e796c6bcbea58eb28547382bd01e3518319", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -244,11 +244,6 @@ extern const struct processor_costs *m68hc11_cost;\n /* Width of a word, in units (bytes).  */\n #define UNITS_PER_WORD\t\t2\n \n-/* Define if you don't want extended real, but do want to use the\n-   software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */\n #define POINTER_SIZE\t\t16\n "}, {"sha": "06dfd50514db9b4305a38de21c3737afa363b408", "filename": "gcc/config/m68k/dpx2.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fdpx2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fdpx2.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -113,11 +113,6 @@ Boston, MA 02111-1307, USA.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE 64\n \n-/* Define if you don't want extended real, but do want to use the\n-   software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC \n-\n #undef ASM_OUTPUT_SOURCE_FILENAME\n #define ASM_OUTPUT_SOURCE_FILENAME(FILE, NA)\t\\\n   do { fprintf ((FILE), \"\\t.file\\t'%s'\\n\", (NA)); } while (0)"}, {"sha": "f7bb33726ad86013488966ac34c3815b43add992", "filename": "gcc/config/m68k/linux-aout.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux-aout.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -73,6 +73,3 @@ Boston, MA 02111-1307, USA.  */\n /* Don't default to pcc-struct-return, because gcc is the only compiler.  */\n #undef PCC_STATIC_STRUCT_RETURN\n #define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* Allow folding division by zero.  */\n-#define REAL_INFINITY"}, {"sha": "b1ec977736473391e07ea514d78069b3b5495cc8", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -247,9 +247,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define DBX_CONTIN_LENGTH 0\n \n-/* Allow folding division by zero.  */\n-#define REAL_INFINITY\n-\n /* 1 if N is a possible register number for a function value.  For\n    m68k/SVR4 allow d0, a0, or fp0 as return registers, for integral,\n    pointer, or floating types, respectively.  Reject fp0 if not using"}, {"sha": "6289d3f6ef5a8df9dd23d67b0200cd5e156db220", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -3112,13 +3112,6 @@ standard_68881_constant_p (x)\n   if (TARGET_68040 || TARGET_68060)\n     return 0;\n \n-#ifndef REAL_ARITHMETIC\n-#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-  if (! flag_pretend_float)\n-    return 0;\n-#endif\n-#endif\n-\n   if (! inited_68881_table)\n     init_68881_table ();\n \n@@ -3153,13 +3146,6 @@ floating_exact_log2 (x)\n   REAL_VALUE_TYPE r, r1;\n   int i;\n \n-#ifndef REAL_ARITHMETIC\n-#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-  if (! flag_pretend_float)\n-    return 0;\n-#endif\n-#endif\n-\n   REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n \n   if (REAL_VALUES_LESS (r, dconst0))\n@@ -3305,13 +3291,6 @@ standard_sun_fpa_constant_p (x)\n   REAL_VALUE_TYPE r;\n   int i;\n \n-#ifndef REAL_ARITHMETIC\n-#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-  if (! flag_pretend_float)\n-    return 0;\n-#endif\n-#endif\n-\n   if (! inited_FPA_table)\n     init_FPA_table ();\n "}, {"sha": "1f21ba96bac4bb31186543399e2ff6757406841d", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -294,15 +294,9 @@ extern int target_flags;\n \f\n /* target machine storage layout */\n \n-/* Define for XFmode extended real floating point support.\n-   This will automatically cause REAL_ARITHMETIC to be defined.  */\n+/* Define for XFmode extended real floating point support.  */\n #define LONG_DOUBLE_TYPE_SIZE 96\n \n-/* Define if you don't want extended real, but do want to use the\n-   software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-/* #define REAL_ARITHMETIC */\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n    This is true for 68020 insns such as bfins and bfexts."}, {"sha": "f0d1e91e3b18b42e2cedebb07055bc3d63161a59", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -34,10 +34,6 @@ Boston, MA 02111-1307, USA.  */\n #if TARGET_DEFAULT == 0\n #undef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE 64\n-\n-/* Use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n #endif\n \n #ifdef __mc68010__"}, {"sha": "2db724fb95e155c04bdb1a88d5c4350d3f0f082e", "filename": "gcc/config/m68k/sun3.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -163,9 +163,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define DBX_DEBUGGING_INFO\n \n-/* Allow folding division by zero.  */\n-#define REAL_INFINITY\n-\n /* Generate calls to memcpy, memcmp and memset.  */\n #define TARGET_MEM_FUNCTIONS\n "}, {"sha": "161d063a1294f9d38cb108ba7a4bbea44bec3743", "filename": "gcc/config/m68k/vxm68k.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fvxm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fm68k%2Fvxm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fvxm68k.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -94,9 +94,6 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n \n #define STRUCTURE_SIZE_BOUNDARY 16\n \n-/* Allow folding division by zero.  */\n-#define REAL_INFINITY\n-\n /* GCC is the primary compiler for VxWorks, so we don't need this.  */\n #undef PCC_STATIC_STRUCT_RETURN\n "}, {"sha": "01336756f1c574d3f6bd59e9ed6a9cd32db87275", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -214,10 +214,6 @@ extern const char * mcore_stack_increment_string;\n \n /* Target machine storage Layout.  */\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n #define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \t\\\n   if (GET_MODE_CLASS (MODE) == MODE_INT         \\\n       && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\"}, {"sha": "72d44982de4ba1d62bbd6d542f88aa51b9ecaf70", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1546,10 +1546,6 @@ do {\t\t\t\t\t\t\t\\\n \f\n /* Target machine storage layout */\n \n-/* Define in order to support both big and little endian float formats\n-   in the same gcc binary.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n */"}, {"sha": "e42274088b5484380b15b3def6c64950934fd926", "filename": "gcc/config/mmix/mmix.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmmix%2Fmmix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmmix%2Fmmix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1154,17 +1154,6 @@ const_section ()\t\t\t\t\t\t\\\n #define DWARF2_DEBUGGING_INFO\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n \n-/* Node: Cross-compilation */\n-\n-/* FIXME: I don't know whether it is best to tweak emit-rtl.c to handle\n-   the case where sizeof (float) == word_size / 2 on the target, or to fix\n-   real.h to define REAL_ARITHMETIC in that case.  Anyway, it should be\n-   documented that a target can define this to force emulation.  Note that\n-   we don't check #ifdef CROSS_COMPILE here; not even if mmix gets\n-   self-hosted must we do that.  Case gcc.c-torture/compile/930611-1.c.  */\n-#define REAL_ARITHMETIC\n-\n-\n /* Node: Misc */\n \n #define PREDICATE_CODES\t\t\t\t\\"}, {"sha": "a0191fcbcdf1503c89bd3ecc4d7a7d739cbe3919", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -915,10 +915,6 @@ struct cum_arg { int nbytes; };\n   ((GET_CODE (X) == PLUS ? OFFSET : 0) \\\n     + (frame_pointer_needed ? 0 : -total_frame_size ()))\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n-#define REAL_ARITHMETIC\n-\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE Pmode"}, {"sha": "a0fe0cd833fa525c0f1fbdd3f5ecd78e2da719b1", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1013,10 +1013,6 @@ struct cum_arg {int nbytes; };\n     + (frame_pointer_needed \\\n        ? 0 : -initial_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM)))\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n-#define REAL_ARITHMETIC\n-\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE Pmode"}, {"sha": "41250568a46ef8f0b68c3ac982beefadf25fe3f2", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -362,10 +362,6 @@ extern int target_flags;\n \f\n /* target machine storage layout */\n \n-/* Define for cross-compilation from a host with a different float format\n-   or endianness (e.g. VAX, x86).  */\n-#define REAL_ARITHMETIC\n-\n /* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases, \n    the value is constrained to be within the bounds of the declared"}, {"sha": "42065f532a865f4e8e32d46bf8d6a982332d2d33", "filename": "gcc/config/pj/pj.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fpj%2Fpj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fpj%2Fpj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -110,10 +110,6 @@ extern int target_flags;\n \f\n /* Target machine storage layout.  */\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN  0"}, {"sha": "30c87bf5fa9794294b767ab78797576aa5e8ef6f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -483,9 +483,6 @@ extern int rs6000_altivec_abi;\n \f\n /* target machine storage layout */\n \n-/* Define to support cross compilation to an RS6000 target.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared"}, {"sha": "959bc9cf1f8a767077f34dc0d9137f5c5164b7bd", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -78,7 +78,7 @@ extern int target_flags;\n #define OVERRIDE_OPTIONS override_options ()\n \n \n-/* Defines for REAL_ARITHMETIC.  */\n+/* Defines for real.c.  */\n #define IEEE_FLOAT 1\n #define TARGET_IBM_FLOAT           0\n #define TARGET_IEEE_FLOAT          1 \n@@ -201,10 +201,6 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n \n #define STRICT_ALIGNMENT 0\n \n-/* real arithmetic */\n-\n-#define REAL_ARITHMETIC\n-\n /* Define target floating point format.  */\n \n #undef TARGET_FLOAT_FORMAT"}, {"sha": "75e7d5eae3f2bdf9271dbd0dca61b634ca2a0b25", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -406,10 +406,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Target machine storage layout.  */\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n "}, {"sha": "ff7c3e716bcc7b626c785b7fc4681960d8574f2d", "filename": "gcc/config/sparc/freebsd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ffreebsd.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -56,7 +56,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef  WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE 32\n \n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+/* Define for support of TFmode long double.\n    Sparc ABI says that long double is 4 words.  */\n #undef  LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_128 ? 128 : 64)"}, {"sha": "086bcdbdfc8a52b2cabd74a1216c60f5fde05c94", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -228,7 +228,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   sprintf (LABEL, \"*.L%s%ld\", PREFIX, (long)(NUM))\n \n \f\n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+/* Define for support of TFmode long double.\n    Sparc ABI says that long double is 4 words.  */\n #define LONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_128 ? 128 : 64)\n "}, {"sha": "1d5dfa05a69479b5ec7055ef4590b76c13d1d6c5", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -146,7 +146,7 @@ Boston, MA 02111-1307, USA.  */\n \n #undef MAX_WCHAR_TYPE_SIZE\n \n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+/* Define for support of TFmode long double.\n    Sparc ABI says that long double is 4 words.  */\n #undef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_128 ? 128 : 64)"}, {"sha": "49945849ca633b0546f08825491fee257569a7d4", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -196,7 +196,7 @@ Boston, MA 02111-1307, USA.  */\n \f\n /* ??? This does not work in SunOS 4.x, so it is not enabled in sparc.h.\n    Instead, it is enabled here, because it does work under Solaris.  */\n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+/* Define for support of TFmode long double.\n    Sparc ABI says that long double is 4 words.  */\n #define LONG_DOUBLE_TYPE_SIZE 128\n "}, {"sha": "c1e472de7d67ae6a07c23192dbe53d3afca490b9", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -687,10 +687,6 @@ extern struct sparc_cpu_select sparc_select[];\n \f\n /* target machine storage layout */\n \n-/* Define for cross-compilation to a sparc target with no TFmode from a host\n-   with a different float format (e.g. VAX).  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN 1\n@@ -732,7 +728,7 @@ extern struct sparc_cpu_select sparc_select[];\n #if 0\n /* ??? This does not work in SunOS 4.x, so it is not enabled here.\n    Instead, it is enabled in sol2.h, because it does work under Solaris.  */\n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+/* Define for support of TFmode long double.\n    Sparc ABI says that long double is 4 words.  */\n #define LONG_DOUBLE_TYPE_SIZE 128\n #endif"}, {"sha": "30d9279df0104780df6951fc900dd59f9ad94e3d", "filename": "gcc/config/sparc/vxsim.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Fvxsim.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fsparc%2Fvxsim.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fvxsim.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -128,6 +128,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* ??? This does not work in SunOS 4.x, so it is not enabled in sparc.h.\n    Instead, it is enabled here, because it does work under Solaris.  */\n-/* Define for support of TFmode long double and REAL_ARITHMETIC.\n+/* Define for support of TFmode long double.\n    Sparc ABI says that long double is 4 words.  */\n #define LONG_DOUBLE_TYPE_SIZE 64"}, {"sha": "846ac246a123c828b6da91df77cb3071d920b60e", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -2808,30 +2808,6 @@ do {\t\t\t\t\t\t\t\\\n    is treated as a logical line separator.  */\n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) ((C) == '|')\n \n-/* These macros are provided by `real.h' for writing the definitions of\n-   `ASM_OUTPUT_DOUBLE' and the like: */\n-\n-/* These translate X, of type `REAL_VALUE_TYPE', to the target's floating point\n-   representation, and store its bit pattern in the array of `long int' whose\n-   address is L.  The number of elements in the output array is determined by\n-   the size of the desired target floating point data type: 32 bits of it go in\n-   each `long int' array element.  Each array element holds 32 bits of the\n-   result, even if `long int' is wider than 32 bits on the host machine.\n-\n-   The array element values are designed so that you can print them out using\n-   `fprintf' in the order they should appear in the target machine's memory.  */\n-/* #define REAL_VALUE_TO_TARGET_SINGLE(X, L) */\n-/* #define REAL_VALUE_TO_TARGET_DOUBLE(X, L) */\n-/* #define REAL_VALUE_TO_TARGET_LONG_DOUBLE(X, L) */\n-\n-/* This macro converts X, of type `REAL_VALUE_TYPE', to a decimal number and\n-   stores it as a string into STRING.  You must pass, as STRING, the address of\n-   a long enough block of space to hold the result.\n-\n-   The argument FORMAT is a `printf'-specification that serves as a suggestion\n-   for how to format the output string.  */\n-/* #define REAL_VALUE_TO_DECIMAL(X, FORMAT, STRING) */\n-\n \f\n /* Output of Uninitialized Variables.  */\n \n@@ -3859,10 +3835,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Miscellaneous Parameters.  */\n \n-/* Define REAL_ARITHMETIC to use a software emulator for the target floating\n-   point mode.  Otherwise the host floating point mode is used.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if you have defined special-purpose predicates in the file\n    `MACHINE.c'.  This macro is called within an initializer of an array of\n    structures.  The first field in the structure is the name of a predicate and"}, {"sha": "175fc9ffd5e68a45b9fd9ecb2282ad7af94bd66d", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1360,10 +1360,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef PREFERRED_DEBUGGING_TYPE\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n \n-/* Define to use software floating point emulator for REAL_ARITHMETIC and\n-   decimal <-> binary conversion. */\n-#define REAL_ARITHMETIC\n-\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE (TARGET_BIG_SWITCH ? SImode : HImode)"}, {"sha": "87f405c76a90c7eaa4d7921e27caa6c12766d9e6", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -89,8 +89,6 @@ extern int target_flags;\n \f\n /* Target machine storage layout */\n \n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.\n    This is not true on the VAX.  */"}, {"sha": "1083ebc71db33addc63de9262aaaff81dc5dbd5e", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -221,10 +221,6 @@ extern unsigned xtensa_current_frame_size;\n \n /* Target machine storage layout */\n \n-/* Define in order to support both big and little endian float formats\n-   in the same gcc binary.  */\n-#define REAL_ARITHMETIC\n-\n /* Define this if most significant bit is lowest numbered\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)"}, {"sha": "9244d61a6f7398c2bef5d91708a39f216524f281", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -247,7 +247,7 @@ in the following sections.\n -fdump-class-hierarchy@r{[}-@var{n}@r{]} @gol\n -fdump-tree-original@r{[}-@var{n}@r{]} -fdump-tree-optimized@r{[}-@var{n}@r{]} @gol\n -fdump-tree-inlined@r{[}-@var{n}@r{]} @gol\n--fmem-report  -fpretend-float @gol\n+-fmem-report @gol\n -fprofile-arcs  -ftest-coverage  -ftime-report @gol\n -g  -g@var{level}  -gcoff  -gdwarf  -gdwarf-1  -gdwarf-1+  -gdwarf-2 @gol\n -ggdb  -gstabs  -gstabs+  -gvms  -gxcoff  -gxcoff+ @gol\n@@ -3042,14 +3042,6 @@ Dump after all tree based optimization, to @file{@var{file}.optimized}.\n Dump after function inlining, to @file{@var{file}.inlined}.\n @end table\n \n-@item -fpretend-float\n-@opindex fpretend-float\n-When running a cross-compiler, pretend that the target machine uses the\n-same floating point format as the host machine.  This causes incorrect\n-output of the actual floating constants, but the actual instruction\n-sequence will probably be the same as GCC would make when running on\n-the target machine.\n-\n @item -save-temps\n @opindex save-temps\n Store the usual ``temporary'' intermediate files permanently; place them"}, {"sha": "8d1a3188074c99a3c7a198b535242a81e2351e28", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -7678,14 +7678,10 @@ it must have its own special routine to use instead.  Also, constant\n folding must emulate the target machine's arithmetic (or must not be done\n at all).\n \n-The macros in the following table should be defined only if you are cross\n-compiling between different floating point formats.\n-\n-Otherwise, don't define them.  Then default definitions will be set up which\n-use @code{double} as the data type, @code{==} to test for equality, etc.\n-\n-You don't need to worry about how many times you use an operand of any\n-of these macros.  The compiler never uses operands which have side effects.\n+The macros in the following table are provided by @file{real.h} for the\n+compiler to use.  All parts of the compiler which generate or optimize\n+floating-point calculations must use these macros.  They may evaluate\n+their operands more than once, so operands must not have side effects.\n \n @table @code\n @findex REAL_VALUE_TYPE\n@@ -7766,15 +7762,7 @@ By default, this is defined to call @code{isinf}.\n A macro for a C expression which determines whether @var{x}, a floating\n point value, is a ``nan'' (not-a-number).  The value has type\n @code{int}.  By default, this is defined to call @code{isnan}.\n-@end table\n \n-@cindex constant folding and floating point\n-Define the following additional macros if you want to make floating\n-point constant folding work while cross compiling.  If you don't\n-define them, cross compilation is still possible, but constant folding\n-will not happen for floating point values.\n-\n-@table @code\n @findex REAL_ARITHMETIC\n @item REAL_ARITHMETIC (@var{output}, @var{code}, @var{x}, @var{y})\n A macro for a C statement which calculates an arithmetic operation of\n@@ -7789,8 +7777,7 @@ which will always be one of the following: @code{PLUS_EXPR},\n @code{MAX_EXPR}, @code{MIN_EXPR}.\n \n @cindex overflow while constant folding\n-The expansion of this macro is responsible for checking for overflow.\n-If overflow happens, the macro expansion should execute the statement\n+If overflow happens, the macro expansion executes the statement\n @code{return 0;}, which indicates the inability to perform the\n arithmetic operation requested.\n "}, {"sha": "ae3ab5f070eaa067afc8f13e8cb3717735283029", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 146, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -887,94 +887,7 @@ gen_lowpart_common (mode, x)\n \t}\n     }\n \n-#ifndef REAL_ARITHMETIC\n-  /* If X is an integral constant but we want it in floating-point, it\n-     must be the case that we have a union of an integer and a floating-point\n-     value.  If the machine-parameters allow it, simulate that union here\n-     and return the result.  The two-word and single-word cases are\n-     different.  */\n-\n-  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-\t    || flag_pretend_float)\n-\t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-\t   && GET_CODE (x) == CONST_INT\n-\t   && sizeof (float) * HOST_BITS_PER_CHAR == HOST_BITS_PER_WIDE_INT)\n-    {\n-      union {HOST_WIDE_INT i; float d; } u;\n-\n-      u.i = INTVAL (x);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (u.d, mode);\n-    }\n-  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-\t    || flag_pretend_float)\n-\t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-\t   && (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n-\t   && GET_MODE (x) == VOIDmode\n-\t   && (sizeof (double) * HOST_BITS_PER_CHAR\n-\t       == 2 * HOST_BITS_PER_WIDE_INT))\n-    {\n-      union {HOST_WIDE_INT i[2]; double d; } u;\n-      HOST_WIDE_INT low, high;\n-\n-      if (GET_CODE (x) == CONST_INT)\n-\tlow = INTVAL (x), high = low >> (HOST_BITS_PER_WIDE_INT -1);\n-      else\n-\tlow = CONST_DOUBLE_LOW (x), high = CONST_DOUBLE_HIGH (x);\n-#ifdef HOST_WORDS_BIG_ENDIAN\n-      u.i[0] = high, u.i[1] = low;\n-#else\n-      u.i[0] = low, u.i[1] = high;\n-#endif\n-      return CONST_DOUBLE_FROM_REAL_VALUE (u.d, mode);\n-    }\n-\n-  /* Similarly, if this is converting a floating-point value into a\n-     single-word integer.  Only do this is the host and target parameters are\n-     compatible.  */\n-\n-  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-\t    || flag_pretend_float)\n-\t   && (GET_MODE_CLASS (mode) == MODE_INT\n-\t       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-\t   && GET_CODE (x) == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n-\t   && GET_MODE_BITSIZE (mode) == BITS_PER_WORD)\n-    return constant_subword (x, (offset / UNITS_PER_WORD), GET_MODE (x));\n-\n-  /* Similarly, if this is converting a floating-point value into a\n-     two-word integer, we can do this one word at a time and make an\n-     integer.  Only do this is the host and target parameters are\n-     compatible.  */\n-\n-  else if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t     && HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-\t    || flag_pretend_float)\n-\t   && (GET_MODE_CLASS (mode) == MODE_INT\n-\t       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n-\t   && GET_CODE (x) == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT\n-\t   && GET_MODE_BITSIZE (mode) == 2 * BITS_PER_WORD)\n-    {\n-      rtx lowpart, highpart;\n-\n-      lowpart = constant_subword (x,\n-\t\t\t\t  (offset / UNITS_PER_WORD) + WORDS_BIG_ENDIAN,\n-\t\t\t\t  GET_MODE (x));\n-      highpart = constant_subword (x,\n-\t\t\t\t   (offset / UNITS_PER_WORD) + (! WORDS_BIG_ENDIAN),\n-\t\t\t\t   GET_MODE (x));\n-      if (lowpart && GET_CODE (lowpart) == CONST_INT\n-\t  && highpart && GET_CODE (highpart) == CONST_INT)\n-\treturn immed_double_const (INTVAL (lowpart), INTVAL (highpart), mode);\n-    }\n-#else /* ifndef REAL_ARITHMETIC */\n-\n-  /* When we have a FP emulator, we can handle all conversions between\n+  /* The floating-point emulator can handle all conversions between\n      FP and integer operands.  This simplifies reload because it\n      doesn't have to deal with constructs like (subreg:DI\n      (const_double:SF ...)) or (subreg:DF (const_int ...)).  */\n@@ -1076,7 +989,6 @@ gen_lowpart_common (mode, x)\n \t\t\t\t mode);\n #endif\n     }\n-#endif /* ifndef REAL_ARITHMETIC */\n \n   /* Otherwise, we can't do this.  */\n   return 0;\n@@ -1310,7 +1222,6 @@ constant_subword (op, offset, mode)\n       && GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n     return op;\n \n-#ifdef REAL_ARITHMETIC\n   /* The output is some bits, the width of the target machine's word.\n      A wider-word host can surely hold them in a CONST_INT. A narrower-word\n      host can't.  */\n@@ -1389,32 +1300,10 @@ constant_subword (op, offset, mode)\n       else\n \tabort ();\n     }\n-#else /* no REAL_ARITHMETIC */\n-  if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-       || flag_pretend_float)\n-      && GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      /* The constant is stored in the host's word-ordering,\n-\t but we want to access it in the target's word-ordering.  Some\n-\t compilers don't like a conditional inside macro args, so we have two\n-\t copies of the return.  */\n-#ifdef HOST_WORDS_BIG_ENDIAN\n-      return GEN_INT (offset == WORDS_BIG_ENDIAN\n-\t\t      ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op));\n-#else\n-      return GEN_INT (offset != WORDS_BIG_ENDIAN\n-\t\t      ? CONST_DOUBLE_HIGH (op) : CONST_DOUBLE_LOW (op));\n-#endif\n-    }\n-#endif /* no REAL_ARITHMETIC */\n \n   /* Single word float is a little harder, since single- and double-word\n      values often do not have the same high-order bits.  We have already\n      verified that we want the only defined word of the single-word value.  */\n-#ifdef REAL_ARITHMETIC\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_MODE_BITSIZE (mode) == 32\n       && GET_CODE (op) == CONST_DOUBLE)\n@@ -1438,40 +1327,6 @@ constant_subword (op, offset, mode)\n \n       return GEN_INT (val);\n     }\n-#else\n-  if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-       || flag_pretend_float)\n-      && sizeof (float) * 8 == HOST_BITS_PER_WIDE_INT\n-      && GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-      && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      double d;\n-      union {float f; HOST_WIDE_INT i; } u;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-\n-      u.f = d;\n-      return GEN_INT (u.i);\n-    }\n-  if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-       || flag_pretend_float)\n-      && sizeof (double) * 8 == HOST_BITS_PER_WIDE_INT\n-      && GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_MODE_SIZE (mode) == UNITS_PER_WORD\n-      && GET_CODE (op) == CONST_DOUBLE)\n-    {\n-      double d;\n-      union {double d; HOST_WIDE_INT i; } u;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-\n-      u.d = d;\n-      return GEN_INT (u.i);\n-    }\n-#endif /* no REAL_ARITHMETIC */\n \n   /* The only remaining cases that we can handle are integers.\n      Convert to proper endianness now since these cases need it."}, {"sha": "0b910d7b9c92e0fc29706019e9f5d60ab24d816c", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1,3 +1,9 @@\n+2002-03-03  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* com.c, target.h: Remove all #ifndef REAL_ARITHMETIC\n+\tblocks, make all #ifdef REAL_ARITHMETIC blocks unconditional.\n+\tDelete some further #ifdef blocks predicated on REAL_ARITHMETIC.\n+\n Thu Feb 28 07:53:46 2002  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* com.c (copy_lang_decl): Delete."}, {"sha": "f64df2bd740f4a6e06da6a2dfbdb1a3e6b3bd37a", "filename": "gcc/f/com.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -11799,11 +11799,7 @@ ffecom_init_0 ()\n   {\n     REAL_VALUE_TYPE point_5;\n \n-#ifdef REAL_ARITHMETIC\n     REAL_ARITHMETIC (point_5, RDIV_EXPR, dconst1, dconst2);\n-#else\n-    point_5 = .5;\n-#endif\n     ffecom_float_half_ = build_real (float_type_node, point_5);\n     ffecom_double_half_ = build_real (double_type_node, point_5);\n   }"}, {"sha": "1c50b1c2fa50015936f9b2f4535d59000ed2ac71", "filename": "gcc/f/target.h", "status": "modified", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ff%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ff%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Ftarget.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -38,16 +38,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif\n #endif\n \n-/* For now, g77 requires the ability to determine the exact bit pattern\n-   of a float on the target machine.  (Hopefully this will be changed\n-   soon).  Make sure we can do this.  */\n-\n-#if !defined (REAL_ARITHMETIC) \\\n-  && ((TARGET_FLOAT_FORMAT != HOST_FLOAT_FORMAT) \\\n-      || (FLOAT_WORDS_BIG_ENDIAN != HOST_FLOAT_WORDS_BIG_ENDIAN))\n-#error \"g77 requires ability to access exact FP representation of target machine\"\n-#endif\n-\n /* Simple definitions and enumerations. */\n \n #define FFETARGET_charactersizeNONE (-1)\n@@ -333,7 +323,6 @@ typedef ? ffetargetLogical8;\n ?\n #endif\n #if FFETARGET_okREAL1\n-#ifdef REAL_ARITHMETIC\n #ifdef FFETARGET_32bit_longs\n typedef long int ffetargetReal1;\n #define ffetargetReal1_f \"l\"\n@@ -351,13 +340,8 @@ typedef int ffetargetReal1;\n      REAL_VALUE_TO_TARGET_SINGLE ((in), _tmp); \\\n      (out) = (ffetargetReal1) _tmp; })\n #endif\n-#else\t/* REAL_ARITHMETIC */\n-typedef float ffetargetReal1;\n-#define ffetargetReal1_f \"\"\n-#endif\t/* REAL_ARITHMETIC */\n #endif\n #if FFETARGET_okREAL2\n-#ifdef REAL_ARITHMETIC\n #ifdef FFETARGET_32bit_longs\n typedef struct\n   {\n@@ -387,63 +371,29 @@ ffetargetReal2;\n      (out)[0] = (int) (_tmp[0]); \\\n      (out)[1] = (int) (_tmp[1]); })\n #endif\n-#else\n-typedef double ffetargetReal2;\n-#define ffetargetReal2_f \"\"\n-#endif\n #endif\n #if FFETARGET_okREAL3\n-#ifdef REAL_ARITHMETIC\n typedef long ffetargetReal3[?];\n-#else\n-typedef ? ffetargetReal3;\n-#define ffetargetReal3_f\n-#endif\n ?\n #endif\n #if FFETARGET_okREAL4\n-#ifdef REAL_ARITHMETIC\n typedef long ffetargetReal4[?];\n-#else\n-typedef ? ffetargetReal4;\n-#define ffetargetReal4_f\n-#endif\n ?\n #endif\n #if FFETARGET_okREAL5\n-#ifdef REAL_ARITHMETIC\n typedef long ffetargetReal5[?];\n-#else\n-typedef ? ffetargetReal5;\n-#define ffetargetReal5_f\n-#endif\n ?\n #endif\n #if FFETARGET_okREAL6\n-#ifdef REAL_ARITHMETIC\n typedef long ffetargetReal6[?];\n-#else\n-typedef ? ffetargetReal6;\n-#define ffetargetReal6_f\n-#endif\n ?\n #endif\n #if FFETARGET_okREAL7\n-#ifdef REAL_ARITHMETIC\n typedef long ffetargetReal7[?];\n-#else\n-typedef ? ffetargetReal7;\n-#define ffetargetReal7_f\n-#endif\n ?\n #endif\n #if FFETARGET_okREAL8\n-#ifdef REAL_ARITHMETIC\n typedef long ffetargetReal8[?];\n-#else\n-typedef ? ffetargetReal8;\n-#define ffetargetReal8_f\n-#endif\n ?\n #endif\n #if FFETARGET_okCOMPLEX1\n@@ -864,7 +814,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   REAL_VALUE_FROM_INT (resr, (long) lf, (long) ((lf < 0) ? -1 : 0),\t\\\n \t\t       ((kt == 1) ? SFmode : DFmode))\n \n-#ifdef REAL_ARITHMETIC\n #define ffetarget_add_complex1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, li, rr, ri, resr, resi; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l).real); \\\n@@ -887,19 +836,10 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->real.v[0])); \\\n      ffetarget_cvt_rv_to_r2_ (resi, &((res)->imaginary.v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_add_complex1(res,l,r) \\\n-  ((res)->real = (l).real + (r).real, \\\n-   (res)->imaginary = (l).imaginary + (r).imaginary, FFEBAD)\n-#define ffetarget_add_complex2(res,l,r) \\\n-  ((res)->real = (l).real + (r).real, \\\n-   (res)->imaginary = (l).imaginary + (r).imaginary, FFEBAD)\n-#endif\n #define ffetarget_add_integer1(res,l,r) (*(res) = (l) + (r), FFEBAD)\n #define ffetarget_add_integer2(res,l,r) (*(res) = (l) + (r), FFEBAD)\n #define ffetarget_add_integer3(res,l,r) (*(res) = (l) + (r), FFEBAD)\n #define ffetarget_add_integer4(res,l,r) (*(res) = (l) + (r), FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_add_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr, resr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -914,10 +854,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      REAL_ARITHMETIC (resr, PLUS_EXPR, lr, rr); \\\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_add_real1(res,l,r) (*(res) = (l) + (r), FFEBAD)\n-#define ffetarget_add_real2(res,l,r) (*(res) = (l) + (r), FFEBAD)\n-#endif\n #define ffetarget_aggregate_ptr_memcpy(dbt,dkt,sbt,skt) \\\n   ((ffetargetCopyfunc) ffetarget_memcpy_)\n #define ffetarget_and_integer1(res,l,r) (*(res) = (l) & (r), FFEBAD)\n@@ -961,19 +897,13 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   ffetarget_convert_any_hollerith_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_complex1_typeless(res,l) \\\n   ffetarget_convert_any_typeless_ ((char *) (res), sizeof(*(res)), l)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex1_complex2(res,l) \\\n   ({ REAL_VALUE_TYPE lr, li; \\\n      lr = ffetarget_cvt_r2_to_rv_ (&((l).real.v[0])); \\\n      li = ffetarget_cvt_r2_to_rv_ (&((l).imaginary.v[0])); \\\n      ffetarget_cvt_rv_to_r1_ (lr, (res)->real); \\\n      ffetarget_cvt_rv_to_r1_ (li, (res)->imaginary), \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_complex1_complex2(res,l) \\\n-  ((res)->real = (l).real, (res)->imaginary = (l).imaginary, FFEBAD)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex1_integer(res,l) \\\n   ({ REAL_VALUE_TYPE resi, resr; \\\n      ffetargetInteger1 lf = (l); \\\n@@ -982,19 +912,10 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      ffetarget_cvt_rv_to_r1_ (resr, (res)->real); \\\n      ffetarget_cvt_rv_to_r1_ (resi, (res)->imaginary); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_complex1_integer(res,l) \\\n-  ((res)->real = (l), (res)->imaginary = 0, FFEBAD)\n-#endif\n #define ffetarget_convert_complex1_integer1 ffetarget_convert_complex1_integer\n #define ffetarget_convert_complex1_integer2 ffetarget_convert_complex1_integer\n #define ffetarget_convert_complex1_integer3 ffetarget_convert_complex1_integer\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex1_integer4(res,l) FFEBAD_NOCANDO\n-#else\n-#define ffetarget_convert_complex1_integer4 ffetarget_convert_complex1_integer\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex1_real1(res,l) \\\n   ((res)->real = (l), \\\n    ffetarget_cvt_rv_to_r1_ (dconst0, (res)->imaginary), \\\n@@ -1005,31 +926,19 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      ffetarget_cvt_rv_to_r1_ (lr, (res)->real); \\\n      ffetarget_cvt_rv_to_r1_ (dconst0, (res)->imaginary), \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_complex1_real1(res,l) \\\n-  ((res)->real = (l), (res)->imaginary = 0, FFEBAD)\n-#define ffetarget_convert_complex1_real2(res,l) \\\n-  ((res)->real = (l), (res)->imaginary = 0, FFEBAD)\n-#endif\n #define ffetarget_convert_complex2_character1(res,l) \\\n   ffetarget_convert_any_character1_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_complex2_hollerith(res,l) \\\n   ffetarget_convert_any_hollerith_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_complex2_typeless(res,l) \\\n   ffetarget_convert_any_typeless_ ((char *) (res), sizeof(*(res)), l)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex2_complex1(res,l) \\\n   ({ REAL_VALUE_TYPE lr, li; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l).real); \\\n      li = ffetarget_cvt_r1_to_rv_ ((l).imaginary); \\\n      ffetarget_cvt_rv_to_r2_ (lr, &((res)->real.v[0])); \\\n      ffetarget_cvt_rv_to_r2_ (li, &((res)->imaginary.v[0])), \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_complex2_complex1(res,l) \\\n-  ((res)->real = (l).real, (res)->imaginary = (l).imaginary, FFEBAD)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex2_integer(res,l) \\\n   ({ REAL_VALUE_TYPE resi, resr; \\\n      ffetargetInteger1 lf = (l); \\\n@@ -1038,19 +947,10 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->real.v[0])); \\\n      ffetarget_cvt_rv_to_r2_ (resi, &((res)->imaginary.v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_complex2_integer(res,l) \\\n-  ((res)->real = (l), (res)->imaginary = 0, FFEBAD)\n-#endif\n #define ffetarget_convert_complex2_integer1 ffetarget_convert_complex2_integer\n #define ffetarget_convert_complex2_integer2 ffetarget_convert_complex2_integer\n #define ffetarget_convert_complex2_integer3 ffetarget_convert_complex2_integer\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex2_integer4(res,l) FFEBAD_NOCANDO\n-#else\n-#define ffetarget_convert_complex2_integer4 ffetarget_convert_complex2_integer\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_complex2_real1(res,l) \\\n   ({ REAL_VALUE_TYPE lr; \\\n      lr = ffetarget_cvt_r1_to_rv_ (l); \\\n@@ -1061,12 +961,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   ((res)->real = (l), \\\n    ffetarget_cvt_rv_to_r2_ (dconst0, &((res)->imaginary.v[0])), \\\n    FFEBAD)\n-#else\n-#define ffetarget_convert_complex2_real1(res,l) \\\n-  ((res)->real = (l), (res)->imaginary = 0, FFEBAD)\n-#define ffetarget_convert_complex2_real2(res,l) \\\n-  ((res)->real = (l), (res)->imaginary = 0, FFEBAD)\n-#endif\n #define ffetarget_convert_integer2_character1(res,l) \\\n         ffetarget_convert_integer1_character1(res,l)\n #define ffetarget_convert_integer2_complex1(res,l) \\\n@@ -1119,15 +1013,8 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n         ffetarget_convert_integer1_typeless(res,l)\n #define ffetarget_convert_integer4_character1(res,l) \\\n         ffetarget_convert_integer1_character1(res,l)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_integer4_complex1(res,l) FFEBAD_NOCANDO\n #define ffetarget_convert_integer4_complex2(res,l) FFEBAD_NOCANDO\n-#else\n-#define ffetarget_convert_integer4_complex1(res,l) \\\n-        ffetarget_convert_integer1_complex1(res,l)\n-#define ffetarget_convert_integer4_complex2(res,l) \\\n-        ffetarget_convert_integer1_complex2(res,l)\n-#endif\n #define ffetarget_convert_integer4_hollerith(res,l) \\\n         ffetarget_convert_integer1_hollerith(res,l)\n #define ffetarget_convert_integer4_integer1(res,l) (*(res) = (l), FFEBAD)\n@@ -1141,15 +1028,8 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n         ffetarget_convert_integer1_logical1(res,l)\n #define ffetarget_convert_integer4_logical4(res,l) \\\n         ffetarget_convert_integer1_logical1(res,l)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_integer4_real1(res,l) FFEBAD_NOCANDO\n #define ffetarget_convert_integer4_real2(res,l) FFEBAD_NOCANDO\n-#else\n-#define ffetarget_convert_integer4_real1(res,l) \\\n-        ffetarget_convert_integer1_real1(res,l)\n-#define ffetarget_convert_integer4_real2(res,l) \\\n-        ffetarget_convert_integer1_real2(res,l)\n-#endif\n #define ffetarget_convert_integer4_typeless(res,l) \\\n         ffetarget_convert_integer1_typeless(res,l)\n #define ffetarget_convert_logical1_character1(res,l) \\\n@@ -1217,7 +1097,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n #define ffetarget_convert_integer1_logical2(res,l) (*(res) = (l), FFEBAD)\n #define ffetarget_convert_integer1_logical3(res,l) (*(res) = (l), FFEBAD)\n #define ffetarget_convert_integer1_logical4(res,l) (*(res) = (l), FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_integer1_real1(res,l) \\\n   ({ REAL_VALUE_TYPE lr; \\\n      lr = ffetarget_cvt_r1_to_rv_ (l); \\\n@@ -1242,12 +1121,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      REAL_VALUE_TO_INT (&ffetarget_long_val_, &ffetarget_long_junk_, lr); \\\n      *(res) = ffetarget_long_val_; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_integer1_real1(res,l) (*(res) = (l), FFEBAD)\n-#define ffetarget_convert_integer1_real2(res,l) (*(res) = (l), FFEBAD)\n-#define ffetarget_convert_integer1_complex1(res,l) (*(res) = (l).real, FFEBAD)\n-#define ffetarget_convert_integer1_complex2(res,l) (*(res) = (l).real, FFEBAD)\n-#endif\n #define ffetarget_convert_real1_character1(res,l) \\\n   ffetarget_convert_any_character1_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_real1_hollerith(res,l) \\\n@@ -1256,36 +1129,23 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n         ffetarget_convert_real1_integer1(res,l)\n #define ffetarget_convert_real1_integer3(res,l) \\\n         ffetarget_convert_real1_integer1(res,l)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_real1_integer4(res,l) FFEBAD_NOCANDO\n-#else\n-#define ffetarget_convert_real1_integer4(res,l) \\\n-        ffetarget_convert_real1_integer1(res,l)\n-#endif\n #define ffetarget_convert_real1_typeless(res,l) \\\n   ffetarget_convert_any_typeless_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_real1_complex1(res,l) (*(res) = (l).real, FFEBAD)\n #define ffetarget_convert_real1_complex2(res,l) \\\n   ffetarget_convert_real1_real2 ((res), (l).real)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_real1_integer1(res,l) \\\n   ({ REAL_VALUE_TYPE resr; \\\n      ffetargetInteger1 lf = (l); \\\n      FFETARGET_REAL_VALUE_FROM_INT_ (resr, lf, 1); \\\n      ffetarget_cvt_rv_to_r1_ (resr, *(res)); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_real1_integer1(res,l) (*(res) = (l), FFEBAD)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_real1_real2(res,l) \\\n   ({ REAL_VALUE_TYPE lr; \\\n      lr = ffetarget_cvt_r2_to_rv_ (&((l).v[0])); \\\n      ffetarget_cvt_rv_to_r1_ (lr, *(res)); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_real1_real2(res,l) (*(res) = (l), FFEBAD)\n-#endif\n #define ffetarget_convert_real2_character1(res,l) \\\n   ffetarget_convert_any_character1_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_real2_hollerith(res,l) \\\n@@ -1294,37 +1154,24 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n         ffetarget_convert_real2_integer1(res,l)\n #define ffetarget_convert_real2_integer3(res,l) \\\n         ffetarget_convert_real2_integer1(res,l)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_real2_integer4(res,l) FFEBAD_NOCANDO\n-#else\n-#define ffetarget_convert_real2_integer4(res,l) \\\n-        ffetarget_convert_real2_integer1(res,l)\n-#endif\n #define ffetarget_convert_real2_typeless(res,l) \\\n   ffetarget_convert_any_typeless_ ((char *) (res), sizeof(*(res)), l)\n #define ffetarget_convert_real2_complex1(res,l) \\\n   ffetarget_convert_real2_real1 ((res), (l).real)\n #define ffetarget_convert_real2_complex2(res,l) (*(res) = (l).real, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_real2_integer(res,l) \\\n   ({ REAL_VALUE_TYPE resr; \\\n      ffetargetInteger1 lf = (l); \\\n      FFETARGET_REAL_VALUE_FROM_INT_ (resr, lf, 2); \\\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->v[0])); \\\n      FFEBAD; })\n #define ffetarget_convert_real2_integer1 ffetarget_convert_real2_integer\n-#else\n-#define ffetarget_convert_real2_integer1(res,l) (*(res) = (l), FFEBAD)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_convert_real2_real1(res,l) \\\n   ({ REAL_VALUE_TYPE lr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n      ffetarget_cvt_rv_to_r2_ (lr, &((res)->v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_convert_real2_real1(res,l) (*(res) = (l), FFEBAD)\n-#endif\n #define ffetarget_divide_integer1(res,l,r) \\\n   (((r) == 0) ? (*(res) = 0, FFEBAD_DIV_BY_ZERO)  \\\n    : (*(res) = (l) / (r), FFEBAD))\n@@ -1334,7 +1181,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n         ffetarget_divide_integer1(res,l,r)\n #define ffetarget_divide_integer4(res,l,r) \\\n         ffetarget_divide_integer1(res,l,r)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_divide_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr, resr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1361,15 +1207,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n \t      FFEBAD; \\\n \t    }); \\\n \t })\n-#else\n-#define ffetarget_divide_real1(res,l,r) \\\n-  (((r) == 0) ? (*(res) = 0, FFEBAD_DIV_BY_ZERO)  \\\n-   : (*(res) = (l) / (r), FFEBAD))\n-#define ffetarget_divide_real2(res,l,r) \\\n-  (((r) == 0) ? (*(res) = 0, FFEBAD_DIV_BY_ZERO)  \\\n-   : (*(res) = (l) / (r), FFEBAD))\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_eq_complex1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, li, rr, ri; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l).real); \\\n@@ -1388,14 +1225,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      *(res) = (REAL_VALUES_EQUAL (lr, rr) && REAL_VALUES_EQUAL (li, ri)) \\\n        ? TRUE : FALSE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_eq_complex1(res,l,r) \\\n-  (*(res) = (((l).real == (r).real) && ((l).imaginary == (r).imaginary))  \\\n-   ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_eq_complex2(res,l,r) \\\n-  (*(res) = (((l).real == (r).real) && ((l).imaginary == (r).imaginary))  \\\n-   ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_eq_integer1(res,l,r) \\\n   (*(res) = ((l) == (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_eq_integer2(res,l,r) \\\n@@ -1404,7 +1233,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   (*(res) = ((l) == (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_eq_integer4(res,l,r) \\\n   (*(res) = ((l) == (r)) ? TRUE : FALSE, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_eq_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1417,12 +1245,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      rr = ffetarget_cvt_r2_to_rv_ (&((r).v[0])); \\\n      *(res) = REAL_VALUES_EQUAL (lr, rr) ? TRUE : FALSE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_eq_real1(res,l,r) \\\n-  (*(res) = ((l) == (r)) ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_eq_real2(res,l,r) \\\n-  (*(res) = ((l) == (r)) ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_eqv_integer1(res,l,r) (*(res) = (l) ^ ~(r), FFEBAD)\n #define ffetarget_eqv_integer2(res,l,r) (*(res) = (l) ^ ~(r), FFEBAD)\n #define ffetarget_eqv_integer3(res,l,r) (*(res) = (l) ^ ~(r), FFEBAD)\n@@ -1439,7 +1261,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   (*(res) = ((l) >= (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_ge_integer4(res,l,r) \\\n   (*(res) = ((l) >= (r)) ? TRUE : FALSE, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_ge_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1452,12 +1273,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      rr = ffetarget_cvt_r2_to_rv_ (&((r).v[0])); \\\n      *(res) = REAL_VALUES_LESS (lr, rr) ? FALSE : TRUE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_ge_real1(res,l,r) \\\n-  (*(res) = ((l) >= (r)) ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_ge_real2(res,l,r) \\\n-  (*(res) = ((l) >= (r)) ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_gt_integer1(res,l,r) \\\n   (*(res) = ((l) > (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_gt_integer2(res,l,r) \\\n@@ -1466,7 +1281,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   (*(res) = ((l) > (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_gt_integer4(res,l,r) \\\n   (*(res) = ((l) > (r)) ? TRUE : FALSE, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_gt_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1481,12 +1295,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      *(res) = (REAL_VALUES_LESS (lr, rr) || REAL_VALUES_EQUAL (lr, rr)) \\\n        ? FALSE : TRUE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_gt_real1(res,l,r) \\\n-  (*(res) = ((l) > (r)) ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_gt_real2(res,l,r) \\\n-  (*(res) = ((l) > (r)) ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_hexxmil(v,t) ffetarget_typeless_hex (v, t)\n #define ffetarget_hexxvxt(v,t) ffetarget_typeless_hex (v, t)\n #define ffetarget_hexzmil(v,t) ffetarget_typeless_hex (v, t)\n@@ -1503,7 +1311,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n #define ffetarget_integerdefault_is_magical(i) \\\n   (((unsigned int) i) == FFETARGET_integerBIG_MAGICAL)\n #endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_iszero_real1(l) \\\n   ({ REAL_VALUE_TYPE lr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1514,10 +1321,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      lr = ffetarget_cvt_r2_to_rv_ (&((l).v[0])); \\\n      REAL_VALUES_EQUAL (lr, dconst0); \\\n    })\n-#else\n-#define ffetarget_iszero_real1(l) ((l) == 0.)\n-#define ffetarget_iszero_real2(l) ((l) == 0.)\n-#endif\n #define ffetarget_iszero_typeless(l) ((l) == 0)\n #define ffetarget_logical1(v,truth) (*(v) = truth ? 1 : 0)\n #define ffetarget_le_integer1(res,l,r) \\\n@@ -1528,7 +1331,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   (*(res) = ((l) <= (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_le_integer4(res,l,r) \\\n   (*(res) = ((l) <= (r)) ? TRUE : FALSE, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_le_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1543,12 +1345,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      *(res) = (REAL_VALUES_LESS (lr, rr) || REAL_VALUES_EQUAL (lr, rr)) \\\n        ? TRUE : FALSE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_le_real1(res,l,r) \\\n-  (*(res) = ((l) <= (r)) ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_le_real2(res,l,r) \\\n-  (*(res) = ((l) <= (r)) ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_lt_integer1(res,l,r) \\\n   (*(res) = ((l) < (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_lt_integer2(res,l,r) \\\n@@ -1557,7 +1353,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   (*(res) = ((l) < (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_lt_integer4(res,l,r) \\\n   (*(res) = ((l) < (r)) ? TRUE : FALSE, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_lt_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1570,28 +1365,16 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      rr = ffetarget_cvt_r2_to_rv_ (&((r).v[0])); \\\n      *(res) = REAL_VALUES_LESS (lr, rr) ? TRUE : FALSE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_lt_real1(res,l,r) \\\n-  (*(res) = ((l) < (r)) ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_lt_real2(res,l,r) \\\n-  (*(res) = ((l) < (r)) ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_length_character1(c) ((c).length)\n #define ffetarget_length_characterdefault ffetarget_length_character1\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_make_real1(res,lr) \\\n   ffetarget_cvt_rv_to_r1_ ((lr), *(res))\n #define ffetarget_make_real2(res,lr) \\\n   ffetarget_cvt_rv_to_r2_ ((lr), &((res)->v[0]))\n-#else\n-#define ffetarget_make_real1(res,lr) (*(res) = (lr))\n-#define ffetarget_make_real2(res,lr) (*(res) = (lr))\n-#endif\n #define ffetarget_multiply_integer1(res,l,r) (*(res) = (l) * (r), FFEBAD)\n #define ffetarget_multiply_integer2(res,l,r) (*(res) = (l) * (r), FFEBAD)\n #define ffetarget_multiply_integer3(res,l,r) (*(res) = (l) * (r), FFEBAD)\n #define ffetarget_multiply_integer4(res,l,r) (*(res) = (l) * (r), FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_multiply_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr, resr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1606,11 +1389,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      REAL_ARITHMETIC (resr, MULT_EXPR, lr, rr); \\\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_multiply_real1(res,l,r) (*(res) = (l) * (r), FFEBAD)\n-#define ffetarget_multiply_real2(res,l,r) (*(res) = (l) * (r), FFEBAD)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_ne_complex1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, li, rr, ri; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l).real); \\\n@@ -1629,14 +1407,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      *(res) = (REAL_VALUES_EQUAL (lr, rr) && REAL_VALUES_EQUAL (li, ri)) \\\n        ? FALSE : TRUE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_ne_complex1(res,l,r) \\\n-  (*(res) = (((l).real != (r).real) || ((l).imaginary != (r).imaginary))  \\\n-   ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_ne_complex2(res,l,r) \\\n-  (*(res) = (((l).real != (r).real) || ((l).imaginary != (r).imaginary))  \\\n-   ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_ne_integer1(res,l,r) \\\n   (*(res) = ((l) != (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_ne_integer2(res,l,r) \\\n@@ -1645,7 +1415,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   (*(res) = ((l) != (r)) ? TRUE : FALSE, FFEBAD)\n #define ffetarget_ne_integer4(res,l,r) \\\n   (*(res) = ((l) != (r)) ? TRUE : FALSE, FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_ne_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1658,12 +1427,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      rr = ffetarget_cvt_r2_to_rv_ (&((r).v[0])); \\\n      *(res) = REAL_VALUES_EQUAL (lr, rr) ? FALSE : TRUE; \\\n      FFEBAD; })\n-#else\n-#define ffetarget_ne_real1(res,l,r) \\\n-  (*(res) = ((l) != (r)) ? TRUE : FALSE, FFEBAD)\n-#define ffetarget_ne_real2(res,l,r) \\\n-  (*(res) = ((l) != (r)) ? TRUE : FALSE, FFEBAD)\n-#endif\n #define ffetarget_neqv_integer1(res,l,r) (*(res) = (l) ^ (r), FFEBAD)\n #define ffetarget_neqv_integer2(res,l,r) (*(res) = (l) ^ (r), FFEBAD)\n #define ffetarget_neqv_integer3(res,l,r) (*(res) = (l) ^ (r), FFEBAD)\n@@ -1719,7 +1482,6 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n   fprintf ((f), \"%\" ffetargetLogical4_f \"d\", (v))\n #define ffetarget_print_octalmil(f,v) ffetarget_print_octal(f,v)\n #define ffetarget_print_octalvxt(f,v) ffetarget_print_octal(f,v)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_print_real1(f,l) \\\n   ({ REAL_VALUE_TYPE lr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1732,38 +1494,16 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      REAL_VALUE_TO_DECIMAL (lr, bad_fmt_val??, ffetarget_string_); \\\n      fputs (ffetarget_string_, (f)); \\\n    })\n-#else\n-#define ffetarget_print_real1(f,v) \\\n-  fprintf ((f), \"%\" ffetargetReal1_f \"g\", (v))\n-#define ffetarget_print_real2(f,v) \\\n-  fprintf ((f), \"%\" ffetargetReal2_f \"g\", (v))\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_real1_one(res) ffetarget_cvt_rv_to_r1_ (dconst1, *(res))\n #define ffetarget_real2_one(res) ffetarget_cvt_rv_to_r2_ (dconst1, &((res)->v[0]))\n-#else\n-#define ffetarget_real1_one(res) (*(res) = (float) 1.)\n-#define ffetarget_real2_one(res) (*(res) = 1.)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_real1_two(res) ffetarget_cvt_rv_to_r1_ (dconst2, *(res))\n #define ffetarget_real2_two(res) ffetarget_cvt_rv_to_r2_ (dconst2, &((res)->v[0]))\n-#else\n-#define ffetarget_real1_two(res) (*(res) = (float) 2.)\n-#define ffetarget_real2_two(res) (*(res) = 2.)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_real1_zero(res) ffetarget_cvt_rv_to_r1_ (dconst0, *(res))\n #define ffetarget_real2_zero(res) ffetarget_cvt_rv_to_r2_ (dconst0, &((res)->v[0]))\n-#else\n-#define ffetarget_real1_zero(res) (*(res) = (float) 0.)\n-#define ffetarget_real2_zero(res) (*(res) = 0.)\n-#endif\n #define ffetarget_size_typeless_binary(t) ((ffetarget_num_digits_(t) + 7) / 8)\n #define ffetarget_size_typeless_octal(t) \\\n   ((ffetarget_num_digits_(t) * 3 + 7) / 8)\n #define ffetarget_size_typeless_hex(t) ((ffetarget_num_digits_(t) + 1) / 2)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_subtract_complex1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, li, rr, ri, resr, resi; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l).real); \\\n@@ -1786,19 +1526,10 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->real.v[0])); \\\n      ffetarget_cvt_rv_to_r2_ (resi, &((res)->imaginary.v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_subtract_complex1(res,l,r) \\\n-  ((res)->real = (l).real - (r).real, \\\n-   (res)->imaginary = (l).imaginary - (r).imaginary, FFEBAD)\n-#define ffetarget_subtract_complex2(res,l,r) \\\n-  ((res)->real = (l).real - (r).real, \\\n-   (res)->imaginary = (l).imaginary - (r).imaginary, FFEBAD)\n-#endif\n #define ffetarget_subtract_integer1(res,l,r) (*(res) = (l) - (r), FFEBAD)\n #define ffetarget_subtract_integer2(res,l,r) (*(res) = (l) - (r), FFEBAD)\n #define ffetarget_subtract_integer3(res,l,r) (*(res) = (l) - (r), FFEBAD)\n #define ffetarget_subtract_integer4(res,l,r) (*(res) = (l) - (r), FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_subtract_real1(res,l,r) \\\n   ({ REAL_VALUE_TYPE lr, rr, resr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1813,18 +1544,13 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      REAL_ARITHMETIC (resr, MINUS_EXPR, lr, rr); \\\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_subtract_real1(res,l,r) (*(res) = (l) - (r), FFEBAD)\n-#define ffetarget_subtract_real2(res,l,r) (*(res) = (l) - (r), FFEBAD)\n-#endif\n #define ffetarget_terminate_0()\n #define ffetarget_terminate_1()\n #define ffetarget_terminate_2()\n #define ffetarget_terminate_3()\n #define ffetarget_terminate_4()\n #define ffetarget_text_character1(c) ((c).text)\n #define ffetarget_text_characterdefault ffetarget_text_character1\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_uminus_complex1(res,l) \\\n   ({ REAL_VALUE_TYPE lr, li, resr, resi; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l).real); \\\n@@ -1843,17 +1569,10 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->real.v[0])); \\\n      ffetarget_cvt_rv_to_r2_ (resi, &((res)->imaginary.v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_uminus_complex1(res,l) \\\n-  ((res)->real = -(l).real, (res)->imaginary = -(l).imaginary, FFEBAD)\n-#define ffetarget_uminus_complex2(res,l) \\\n-  ((res)->real = -(l).real, (res)->imaginary = -(l).imaginary, FFEBAD)\n-#endif\n #define ffetarget_uminus_integer1(res,l) (*(res) = -(l), FFEBAD)\n #define ffetarget_uminus_integer2(res,l) (*(res) = -(l), FFEBAD)\n #define ffetarget_uminus_integer3(res,l) (*(res) = -(l), FFEBAD)\n #define ffetarget_uminus_integer4(res,l) (*(res) = -(l), FFEBAD)\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_uminus_real1(res,l) \\\n   ({ REAL_VALUE_TYPE lr, resr; \\\n      lr = ffetarget_cvt_r1_to_rv_ ((l)); \\\n@@ -1866,17 +1585,8 @@ void *ffetarget_memcpy_ (void *dst, void *src, size_t len);\n      resr = REAL_VALUE_NEGATE (lr); \\\n      ffetarget_cvt_rv_to_r2_ (resr, &((res)->v[0])); \\\n      FFEBAD; })\n-#else\n-#define ffetarget_uminus_real1(res,l) (*(res) = -(l), FFEBAD)\n-#define ffetarget_uminus_real2(res,l) (*(res) = -(l), FFEBAD)\n-#endif\n-#ifdef REAL_ARITHMETIC\n #define ffetarget_value_real1(lr) ffetarget_cvt_r1_to_rv_ ((lr))\n #define ffetarget_value_real2(lr) ffetarget_cvt_r2_to_rv_ (&((lr).v[0]))\n-#else\n-#define ffetarget_value_real1\n-#define ffetarget_value_real2\n-#endif\n #define ffetarget_xor_integer1(res,l,r) (*(res) = (l) ^ (r), FFEBAD)\n #define ffetarget_xor_integer2(res,l,r) (*(res) = (l) ^ (r), FFEBAD)\n #define ffetarget_xor_integer3(res,l,r) (*(res) = (l) ^ (r), FFEBAD)"}, {"sha": "47dd4555644dc1552c370424041e8bc3c1042b5e", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -3771,7 +3771,6 @@ split_double (value, first, second)\n     }\n   else\n     {\n-#ifdef REAL_ARITHMETIC\n       REAL_VALUE_TYPE r;\n       long l[2];\n       REAL_VALUE_FROM_CONST_DOUBLE (r, value);\n@@ -3800,30 +3799,6 @@ split_double (value, first, second)\n \n       *first = GEN_INT ((HOST_WIDE_INT) l[0]);\n       *second = GEN_INT ((HOST_WIDE_INT) l[1]);\n-#else\n-      if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t   || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n-\t  && ! flag_pretend_float)\n-\tabort ();\n-\n-      if (\n-#ifdef HOST_WORDS_BIG_ENDIAN\n-\t  WORDS_BIG_ENDIAN\n-#else\n-\t  ! WORDS_BIG_ENDIAN\n-#endif\n-\t  )\n-\t{\n-\t  /* Host and target agree => no need to swap.  */\n-\t  *first = GEN_INT (CONST_DOUBLE_LOW (value));\n-\t  *second = GEN_INT (CONST_DOUBLE_HIGH (value));\n-\t}\n-      else\n-\t{\n-\t  *second = GEN_INT (CONST_DOUBLE_LOW (value));\n-\t  *first = GEN_INT (CONST_DOUBLE_HIGH (value));\n-\t}\n-#endif /* no REAL_ARITHMETIC */\n     }\n }\n \f"}, {"sha": "2c69497fb7dd38e6a32266d4bca5b1b44c387e10", "filename": "gcc/flags.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -434,12 +434,6 @@ extern int flag_delayed_branch;\n \n extern int flag_dump_unnumbered;\n \n-/* Nonzero means pretend it is OK to examine bits of target floats,\n-   even if that isn't true.  The resulting code will have incorrect constants,\n-   but the same series of instructions that the native compiler would make.  */\n-\n-extern int flag_pretend_float;\n-\n /* Nonzero means change certain warnings into errors.\n    Usually these are warnings about failure to conform to some standard.  */\n "}, {"sha": "aee10565e9a9e81575646f3869c2ad0547c7c842", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 594, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -59,9 +59,6 @@ static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n \t\t\t\t\t unsigned HOST_WIDE_INT *,\n \t\t\t\t\t HOST_WIDE_INT *));\n-#ifndef REAL_ARITHMETIC\n-static void exact_real_inverse_1 PARAMS ((PTR));\n-#endif\n static tree negate_expr\t\tPARAMS ((tree));\n static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n \t\t\t\t\t int));\n@@ -834,512 +831,6 @@ div_and_round_double (code, uns,\n   return overflow;\n }\n \f\n-#ifndef REAL_ARITHMETIC\n-/* Effectively truncate a real value to represent the nearest possible value\n-   in a narrower mode.  The result is actually represented in the same data\n-   type as the argument, but its value is usually different.\n-\n-   A trap may occur during the FP operations and it is the responsibility\n-   of the calling function to have a handler established.  */\n-\n-REAL_VALUE_TYPE\n-real_value_truncate (mode, arg)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE arg;\n-{\n-  return REAL_VALUE_TRUNCATE (mode, arg);\n-}\n-\n-#if TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\n-/* Check for infinity in an IEEE double precision number.  */\n-\n-int\n-target_isinf (x)\n-     REAL_VALUE_TYPE x;\n-{\n-  /* The IEEE 64-bit double format.  */\n-  union {\n-    REAL_VALUE_TYPE d;\n-    struct {\n-      unsigned sign      :  1;\n-      unsigned exponent  : 11;\n-      unsigned mantissa1 : 20;\n-      unsigned mantissa2 : 32;\n-    } little_endian;\n-    struct {\n-      unsigned mantissa2 : 32;\n-      unsigned mantissa1 : 20;\n-      unsigned exponent  : 11;\n-      unsigned sign      :  1;\n-    } big_endian;\n-  } u;\n-\n-  u.d = dconstm1;\n-  if (u.big_endian.sign == 1)\n-    {\n-      u.d = x;\n-      return (u.big_endian.exponent == 2047\n-\t      && u.big_endian.mantissa1 == 0\n-\t      && u.big_endian.mantissa2 == 0);\n-    }\n-  else\n-    {\n-      u.d = x;\n-      return (u.little_endian.exponent == 2047\n-\t      && u.little_endian.mantissa1 == 0\n-\t      && u.little_endian.mantissa2 == 0);\n-    }\n-}\n-\n-/* Check whether an IEEE double precision number is a NaN.  */\n-\n-int\n-target_isnan (x)\n-     REAL_VALUE_TYPE x;\n-{\n-  /* The IEEE 64-bit double format.  */\n-  union {\n-    REAL_VALUE_TYPE d;\n-    struct {\n-      unsigned sign      :  1;\n-      unsigned exponent  : 11;\n-      unsigned mantissa1 : 20;\n-      unsigned mantissa2 : 32;\n-    } little_endian;\n-    struct {\n-      unsigned mantissa2 : 32;\n-      unsigned mantissa1 : 20;\n-      unsigned exponent  : 11;\n-      unsigned sign      :  1;\n-    } big_endian;\n-  } u;\n-\n-  u.d = dconstm1;\n-  if (u.big_endian.sign == 1)\n-    {\n-      u.d = x;\n-      return (u.big_endian.exponent == 2047\n-\t      && (u.big_endian.mantissa1 != 0\n-\t\t  || u.big_endian.mantissa2 != 0));\n-    }\n-  else\n-    {\n-      u.d = x;\n-      return (u.little_endian.exponent == 2047\n-\t      && (u.little_endian.mantissa1 != 0\n-\t\t  || u.little_endian.mantissa2 != 0));\n-    }\n-}\n-\n-/* Check for a negative IEEE double precision number.  */\n-\n-int\n-target_negative (x)\n-     REAL_VALUE_TYPE x;\n-{\n-  /* The IEEE 64-bit double format.  */\n-  union {\n-    REAL_VALUE_TYPE d;\n-    struct {\n-      unsigned sign      :  1;\n-      unsigned exponent  : 11;\n-      unsigned mantissa1 : 20;\n-      unsigned mantissa2 : 32;\n-    } little_endian;\n-    struct {\n-      unsigned mantissa2 : 32;\n-      unsigned mantissa1 : 20;\n-      unsigned exponent  : 11;\n-      unsigned sign      :  1;\n-    } big_endian;\n-  } u;\n-\n-  u.d = dconstm1;\n-  if (u.big_endian.sign == 1)\n-    {\n-      u.d = x;\n-      return u.big_endian.sign;\n-    }\n-  else\n-    {\n-      u.d = x;\n-      return u.little_endian.sign;\n-    }\n-}\n-#else /* Target not IEEE */\n-\n-/* Let's assume other float formats don't have infinity.\n-   (This can be overridden by redefining REAL_VALUE_ISINF.)  */\n-\n-int\n-target_isinf (x)\n-     REAL_VALUE_TYPE x ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n-/* Let's assume other float formats don't have NaNs.\n-   (This can be overridden by redefining REAL_VALUE_ISNAN.)  */\n-\n-int\n-target_isnan (x)\n-     REAL_VALUE_TYPE x ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n-/* Let's assume other float formats don't have minus zero.\n-   (This can be overridden by redefining REAL_VALUE_NEGATIVE.)  */\n-\n-int\n-target_negative (x)\n-     REAL_VALUE_TYPE x;\n-{\n-  return x < 0;\n-}\n-#endif /* Target not IEEE */\n-\n-/* Try to change R into its exact multiplicative inverse in machine mode\n-   MODE.  Return nonzero function value if successful.  */\n-struct exact_real_inverse_args\n-{\n-  REAL_VALUE_TYPE *r;\n-  enum machine_mode mode;\n-  int success;\n-};\n-\n-static void\n-exact_real_inverse_1 (p)\n-     PTR p;\n-{\n-  struct exact_real_inverse_args *args =\n-    (struct exact_real_inverse_args *) p;\n-\n-  enum machine_mode mode = args->mode;\n-  REAL_VALUE_TYPE *r = args->r;\n-\n-  union\n-  {\n-    double d;\n-    unsigned short i[4];\n-  }\n-  x, t, y;\n-#ifdef CHECK_FLOAT_VALUE\n-  int i;\n-#endif\n-\n-  /* Set array index to the less significant bits in the unions, depending\n-     on the endian-ness of the host doubles.  */\n-#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT \\\n- || HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n-# define K 2\n-#else\n-# define K (2 * HOST_FLOAT_WORDS_BIG_ENDIAN)\n-#endif\n-\n-  /* Domain check the argument.  */\n-  x.d = *r;\n-  if (x.d == 0.0)\n-    goto fail;\n-\n-#ifdef REAL_INFINITY\n-  if (REAL_VALUE_ISINF (x.d) || REAL_VALUE_ISNAN (x.d))\n-    goto fail;\n-#endif\n-\n-  /* Compute the reciprocal and check for numerical exactness.\n-     It is unnecessary to check all the significand bits to determine\n-     whether X is a power of 2.  If X is not, then it is impossible for\n-     the bottom half significand of both X and 1/X to be all zero bits.\n-     Hence we ignore the data structure of the top half and examine only\n-     the low order bits of the two significands.  */\n-  t.d = 1.0 / x.d;\n-  if (x.i[K] != 0 || x.i[K + 1] != 0 || t.i[K] != 0 || t.i[K + 1] != 0)\n-    goto fail;\n-\n-  /* Truncate to the required mode and range-check the result.  */\n-  y.d = REAL_VALUE_TRUNCATE (mode, t.d);\n-#ifdef CHECK_FLOAT_VALUE\n-  i = 0;\n-  if (CHECK_FLOAT_VALUE (mode, y.d, i))\n-    goto fail;\n-#endif\n-\n-  /* Fail if truncation changed the value.  */\n-  if (y.d != t.d || y.d == 0.0)\n-    goto fail;\n-\n-#ifdef REAL_INFINITY\n-  if (REAL_VALUE_ISINF (y.d) || REAL_VALUE_ISNAN (y.d))\n-    goto fail;\n-#endif\n-\n-  /* Output the reciprocal and return success flag.  */\n-  *r = y.d;\n-  args->success = 1;\n-  return;\n-\n- fail:\n-  args->success = 0;\n-  return;\n-\n-#undef K\n-}\n-\n-\n-int\n-exact_real_inverse (mode, r)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE *r;\n-{\n-  struct exact_real_inverse_args args;\n-\n-  /* Disable if insufficient information on the data structure.  */\n-#if HOST_FLOAT_FORMAT == UNKNOWN_FLOAT_FORMAT\n-  return 0;\n-#endif\n-\n-  /* Usually disable if bounds checks are not reliable.  */\n-  if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT) && !flag_pretend_float)\n-    return 0;\n-\n-  args.mode = mode;\n-  args.r = r;\n-\n-  if (do_float_handler (exact_real_inverse_1, (PTR) &args))\n-    return args.success;\n-  return 0;\n-}\n-\n-/* Convert C99 hexadecimal floating point string constant S.  Return\n-   real value type in mode MODE.  This function uses the host computer's\n-   floating point arithmetic when there is no REAL_ARITHMETIC.  */\n-\n-REAL_VALUE_TYPE\n-real_hex_to_f (s, mode)\n-   const char *s;\n-   enum machine_mode mode;\n-{\n-  REAL_VALUE_TYPE ip;\n-  const char *p = s;\n-  unsigned HOST_WIDE_INT low, high;\n-  int shcount, nrmcount, k;\n-  int sign, expsign, isfloat;\n-  int lost = 0;/* Nonzero low order bits shifted out and discarded.  */\n-  int frexpon = 0;  /* Bits after the decimal point.  */\n-  int expon = 0;  /* Value of exponent.  */\n-  int decpt = 0;  /* How many decimal points.  */\n-  int gotp = 0;  /* How many P's.  */\n-  char c;\n-\n-  isfloat = 0;\n-  expsign = 1;\n-  ip = 0.0;\n-\n-  while (*p == ' ' || *p == '\\t')\n-    ++p;\n-\n-  /* Sign, if any, comes first.  */\n-  sign = 1;\n-  if (*p == '-')\n-    {\n-      sign = -1;\n-      ++p;\n-    }\n-\n-  /* The string is supposed to start with 0x or 0X .  */\n-  if (*p == '0')\n-    {\n-      ++p;\n-      if (*p == 'x' || *p == 'X')\n-\t++p;\n-      else\n-\tabort ();\n-    }\n-  else\n-    abort ();\n-\n-  while (*p == '0')\n-    ++p;\n-\n-  high = 0;\n-  low = 0;\n-  shcount = 0;\n-  while ((c = *p) != '\\0')\n-    {\n-      if (ISXDIGIT (c))\n-\t{\n-\t  k = hex_value (c & CHARMASK);\n-\n-\t  if ((high & 0xf0000000) == 0)\n-\t    {\n-\t      high = (high << 4) + ((low >> 28) & 15);\n-\t      low = (low << 4) + k;\n-\t      shcount += 4;\n-\t      if (decpt)\n-\t\tfrexpon += 4;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Record nonzero lost bits.  */\n-\t      lost |= k;\n-\t      if (! decpt)\n-\t\tfrexpon -= 4;\n-\t    }\n-\t  ++p;\n-\t}\n-      else if (c == '.')\n-\t{\n-\t  ++decpt;\n-\t  ++p;\n-\t}\n-\n-      else if (c == 'p' || c == 'P')\n-\t{\n-\t  ++gotp;\n-\t  ++p;\n-\t  /* Sign of exponent.  */\n-\t  if (*p == '-')\n-\t    {\n-\t      expsign = -1;\n-\t      ++p;\n-\t    }\n-\n-\t  /* Value of exponent.\n-\t     The exponent field is a decimal integer.  */\n-\t  while (ISDIGIT (*p))\n-\t    {\n-\t      k = (*p++ & CHARMASK) - '0';\n-\t      expon = 10 * expon + k;\n-\t    }\n-\n-\t  expon *= expsign;\n-\t  /* F suffix is ambiguous in the significand part\n-\t     so it must appear after the decimal exponent field.  */\n-\t  if (*p == 'f' || *p == 'F')\n-\t    {\n-\t      isfloat = 1;\n-\t      ++p;\n-\t      break;\n-\t    }\n-\t}\n-\n-      else if (c == 'l' || c == 'L')\n-\t{\n-\t  ++p;\n-\t  break;\n-\t}\n-      else\n-\tbreak;\n-    }\n-\n-  /* Abort if last character read was not legitimate.  */\n-  c = *p;\n-  if ((c != '\\0' && c != ' ' && c != '\\n' && c != '\\r') || (decpt > 1))\n-    abort ();\n-\n-  /* There must be either one decimal point or one p.  */\n-  if (decpt == 0 && gotp == 0)\n-    abort ();\n-\n-  shcount -= 4;\n-  if (high == 0 && low == 0)\n-    return dconst0;\n-\n-  /* Normalize.  */\n-  nrmcount = 0;\n-  if (high == 0)\n-    {\n-      high = low;\n-      low = 0;\n-      nrmcount += 32;\n-    }\n-\n-  /* Leave a high guard bit for carry-out.  */\n-  if ((high & 0x80000000) != 0)\n-    {\n-      lost |= low & 1;\n-      low = (low >> 1) | (high << 31);\n-      high = high >> 1;\n-      nrmcount -= 1;\n-    }\n-\n-  if ((high & 0xffff8000) == 0)\n-    {\n-      high = (high << 16) + ((low >> 16) & 0xffff);\n-      low = low << 16;\n-      nrmcount += 16;\n-    }\n-\n-  while ((high & 0xc0000000) == 0)\n-    {\n-      high = (high << 1) + ((low >> 31) & 1);\n-      low = low << 1;\n-      nrmcount += 1;\n-    }\n-\n-  if (isfloat || GET_MODE_SIZE (mode) == UNITS_PER_WORD)\n-    {\n-      /* Keep 24 bits precision, bits 0x7fffff80.\n-\t Rounding bit is 0x40.  */\n-      lost = lost | low | (high & 0x3f);\n-      low = 0;\n-      if (high & 0x40)\n-\t{\n-\t  if ((high & 0x80) || lost)\n-\t    high += 0x40;\n-\t}\n-      high &= 0xffffff80;\n-    }\n-  else\n-    {\n-      /* We need real.c to do long double formats, so here default\n-\t to double precision.  */\n-#if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-      /* IEEE double.\n-\t Keep 53 bits precision, bits 0x7fffffff fffffc00.\n-\t Rounding bit is low word 0x200.  */\n-      lost = lost | (low & 0x1ff);\n-      if (low & 0x200)\n-\t{\n-\t  if ((low & 0x400) || lost)\n-\t    {\n-\t      low = (low + 0x200) & 0xfffffc00;\n-\t      if (low == 0)\n-\t\thigh += 1;\n-\t    }\n-\t}\n-      low &= 0xfffffc00;\n-#else\n-      /* Assume it's a VAX with 56-bit significand,\n-\t bits 0x7fffffff ffffff80.  */\n-      lost = lost | (low & 0x7f);\n-      if (low & 0x40)\n-\t{\n-\t  if ((low & 0x80) || lost)\n-\t    {\n-\t      low = (low + 0x40) & 0xffffff80;\n-\t      if (low == 0)\n-\t\thigh += 1;\n-\t    }\n-\t}\n-      low &= 0xffffff80;\n-#endif\n-    }\n-\n-  ip = (double) high;\n-  ip = REAL_VALUE_LDEXP (ip, 32) + (double) low;\n-  /* Apply shifts and exponent value as power of 2.  */\n-  ip = REAL_VALUE_LDEXP (ip, expon - (nrmcount + frexpon));\n-\n-  if (sign < 0)\n-    ip = -ip;\n-  return ip;\n-}\n-\n-#endif /* no REAL_ARITHMETIC */\n-\f\n /* Given T, an expression, return the negation of T.  Allow for T to be\n    null, in which case return null.  */\n \n@@ -1725,44 +1216,7 @@ const_binop_1 (data)\n   struct cb_args *args = (struct cb_args *) data;\n   REAL_VALUE_TYPE value;\n \n-#ifdef REAL_ARITHMETIC\n   REAL_ARITHMETIC (value, args->code, args->d1, args->d2);\n-#else\n-  switch (args->code)\n-    {\n-    case PLUS_EXPR:\n-      value = args->d1 + args->d2;\n-      break;\n-\n-    case MINUS_EXPR:\n-      value = args->d1 - args->d2;\n-      break;\n-\n-    case MULT_EXPR:\n-      value = args->d1 * args->d2;\n-      break;\n-\n-    case RDIV_EXPR:\n-#ifndef REAL_INFINITY\n-      if (args->d2 == 0)\n-\tabort ();\n-#endif\n-\n-      value = args->d1 / args->d2;\n-      break;\n-\n-    case MIN_EXPR:\n-      value = MIN (args->d1, args->d2);\n-      break;\n-\n-    case MAX_EXPR:\n-      value = MAX (args->d1, args->d2);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-#endif /* no REAL_ARITHMETIC */\n \n   args->t\n     = build_real (args->type,\n@@ -1787,7 +1241,6 @@ const_binop (code, arg1, arg2, notrunc)\n   if (TREE_CODE (arg1) == INTEGER_CST)\n     return int_const_binop (code, arg1, arg2, notrunc);\n \n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (TREE_CODE (arg1) == REAL_CST)\n     {\n       REAL_VALUE_TYPE d1;\n@@ -1831,7 +1284,6 @@ const_binop (code, arg1, arg2, notrunc)\n \t  | TREE_CONSTANT_OVERFLOW (arg2);\n       return t;\n     }\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n   if (TREE_CODE (arg1) == COMPLEX_CST)\n     {\n       tree type = TREE_TYPE (arg1);\n@@ -2145,7 +1597,6 @@ fold_convert (t, arg1)\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t}\n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n       else if (TREE_CODE (arg1) == REAL_CST)\n \t{\n \t  /* Don't initialize these, use assignments.\n@@ -2166,15 +1617,9 @@ fold_convert (t, arg1)\n \t  /* See if X will be in range after truncation towards 0.\n \t     To compensate for truncation, move the bounds away from 0,\n \t     but reject if X exactly equals the adjusted bounds.  */\n-#ifdef REAL_ARITHMETIC\n \t  REAL_ARITHMETIC (l, MINUS_EXPR, l, dconst1);\n \t  if (!no_upper_bound)\n \t    REAL_ARITHMETIC (u, PLUS_EXPR, u, dconst1);\n-#else\n-\t  l--;\n-\t  if (!no_upper_bound)\n-\t    u++;\n-#endif\n \t  /* If X is a NaN, use zero instead and show we have an overflow.\n \t     Otherwise, range check.  */\n \t  if (REAL_VALUE_ISNAN (x))\n@@ -2184,50 +1629,23 @@ fold_convert (t, arg1)\n \t\t      && REAL_VALUES_LESS (x, u)))\n \t    overflow = 1;\n \n-#ifndef REAL_ARITHMETIC\n-\t  {\n-\t    HOST_WIDE_INT low, high;\n-\t    HOST_WIDE_INT half_word\n-\t      = (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2);\n-\n-\t    if (x < 0)\n-\t      x = -x;\n-\n-\t    high = (HOST_WIDE_INT) (x / half_word / half_word);\n-\t    x -= (REAL_VALUE_TYPE) high * half_word * half_word;\n-\t    if (x >= (REAL_VALUE_TYPE) half_word * half_word / 2)\n-\t      {\n-\t\tlow = x - (REAL_VALUE_TYPE) half_word * half_word / 2;\n-\t\tlow |= (HOST_WIDE_INT) -1 << (HOST_BITS_PER_WIDE_INT - 1);\n-\t      }\n-\t    else\n-\t      low = (HOST_WIDE_INT) x;\n-\t    if (TREE_REAL_CST (arg1) < 0)\n-\t      neg_double (low, high, &low, &high);\n-\t    t = build_int_2 (low, high);\n-\t  }\n-#else\n \t  {\n \t    HOST_WIDE_INT low, high;\n \t    REAL_VALUE_TO_INT (&low, &high, x);\n \t    t = build_int_2 (low, high);\n \t  }\n-#endif\n \t  TREE_TYPE (t) = type;\n \t  TREE_OVERFLOW (t)\n \t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t}\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n       TREE_TYPE (t) = type;\n     }\n   else if (TREE_CODE (type) == REAL_TYPE)\n     {\n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n       if (TREE_CODE (arg1) == INTEGER_CST)\n \treturn build_real_from_int_cst (type, arg1);\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n \t  struct fc_args args;\n@@ -5008,9 +4426,7 @@ fold (expr)\n \tsubop = arg0;\n \n       if (subop != 0 && TREE_CODE (subop) != INTEGER_CST\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n \t  && TREE_CODE (subop) != REAL_CST\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \t  )\n \t/* Note that TREE_CONSTANT isn't enough:\n \t   static var addresses are constant but we can't\n@@ -5045,10 +4461,7 @@ fold (expr)\n \t    subop = op;\n \n \t  if (TREE_CODE (subop) != INTEGER_CST\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-\t      && TREE_CODE (subop) != REAL_CST\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n-\t      )\n+\t      && TREE_CODE (subop) != REAL_CST)\n \t    /* Note that TREE_CONSTANT isn't enough:\n \t       static var addresses are constant but we can't\n \t       do arithmetic on them.  */\n@@ -5704,10 +5117,6 @@ fold (expr)\n \t}\n \n     binary:\n-#if defined (REAL_IS_NOT_DOUBLE) && ! defined (REAL_ARITHMETIC)\n-      if (TREE_CODE (arg1) == REAL_CST)\n-\treturn t;\n-#endif /* REAL_IS_NOT_DOUBLE, and no REAL_ARITHMETIC */\n       if (wins)\n \tt1 = const_binop (code, arg0, arg1, 0);\n       if (t1 != NULL_TREE)\n@@ -5948,12 +5357,10 @@ fold (expr)\n \n     case RDIV_EXPR:\n       /* In most cases, do nothing with a divide by zero.  */\n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n #ifndef REAL_INFINITY\n       if (TREE_CODE (arg1) == REAL_CST && real_zerop (arg1))\n \treturn t;\n #endif\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n       /* (-A) / (-B) -> A / B  */\n       if (TREE_CODE (arg0) == NEGATE_EXPR && TREE_CODE (arg1) == NEGATE_EXPR)"}, {"sha": "f35402940ab906afd3890c01fb509306da5babe2", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -31,30 +31,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Calculate the format for CONST_DOUBLE.  This depends on the relative\n    widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n \n-   We need to go out to e0wwwww, since REAL_ARITHMETIC assumes 16-bits\n-   per element in REAL_VALUE_TYPE.\n+   We need to go out to e0wwwww, since real.c assumes 16 bits per element\n+   in REAL_VALUE_TYPE.\n \n    This is duplicated in rtl.c.\n \n    A number of places assume that there are always at least two 'w'\n    slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n \n-#ifdef REAL_ARITHMETIC\n-# if MAX_LONG_DOUBLE_TYPE_SIZE == 96\n-#  define REAL_WIDTH\t\\\n+#if MAX_LONG_DOUBLE_TYPE_SIZE == 96\n+# define REAL_WIDTH\t\\\n      (11*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n+#else\n+# if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n+#  define REAL_WIDTH\t\\\n+     (19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n # else\n-#  if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n+#  if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n #   define REAL_WIDTH\t\\\n-      (19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#  else\n-#   if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-#    define REAL_WIDTH\t\\\n       (7*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#   endif\n #  endif\n # endif\n-#endif /* REAL_ARITHMETIC */\n+#endif\n \n #ifndef REAL_WIDTH\n # if HOST_BITS_PER_WIDE_INT*2 >= MAX_LONG_DOUBLE_TYPE_SIZE"}, {"sha": "b1b01b98b07ea1f9e1d13f310dc915a93a188e26", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1,3 +1,10 @@\n+2002-03-03  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* java/expr.c, java/jcf-parse.c, java/lex.c:\n+\tRemove all #ifndef REAL_ARITHMETIC blocks, make all #ifdef\n+\tREAL_ARITHMETIC blocks unconditional.  Delete some further\n+\t#ifdef blocks predicated on REAL_ARITHMETIC.\n+\n 2002-03-03  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* class.c (init_class_processing): Use ARRAY_SIZE in lieu of"}, {"sha": "b6a01065983274fecb5eb1e22fc74ba66bc376c8", "filename": "gcc/java/expr.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1099,11 +1099,7 @@ expand_java_pushc (ival, type)\n   else if (type == float_type_node || type == double_type_node)\n     {\n       REAL_VALUE_TYPE x;\n-#ifdef REAL_ARITHMETIC\n       REAL_VALUE_FROM_INT (x, ival, 0, TYPE_MODE (type));\n-#else\n-      x = ival;\n-#endif\n       value = build_real (type, x);\n     }\n   else"}, {"sha": "c4faa8e3711927e6935557bb9c4054aa6e195446", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -306,13 +306,7 @@ get_constant (jcf, index)\n       {\n \tjint num = JPOOL_INT(jcf, index);\n \tREAL_VALUE_TYPE d;\n-#ifdef REAL_ARITHMETIC\n \td = REAL_VALUE_FROM_TARGET_SINGLE (num);\n-#else\n-\tunion { float f;  jint i; } u;\n-\tu.i = num;\n-\td = u.f;\n-#endif\n \tvalue = build_real (float_type_node, d);\n \tbreak;\n       }\n@@ -343,16 +337,7 @@ get_constant (jcf, index)\n \t    num[0] = lo;\n \t    num[1] = hi;\n \t  }\n-#ifdef REAL_ARITHMETIC\n \td = REAL_VALUE_FROM_TARGET_DOUBLE (num);\n-#else\n-\t{\n-\t  union { double d;  jint i[2]; } u;\n-\t  u.i[0] = (jint) num[0];\n-\t  u.i[1] = (jint) num[1];\n-\t  d = u.d;\n-\t}\n-#endif\n \tvalue = build_real (double_type_node, d);\n \tbreak;\n       }"}, {"sha": "17a7e1b62f0486c4eb933f8af6947915388ffd3a", "filename": "gcc/java/lex.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -840,11 +840,7 @@ struct jpa_args\n   int number_beginning;\n };\n \n-#ifdef REAL_ARITHMETIC\n #define IS_ZERO(X) (ereal_cmp (X, dconst0) == 0)\n-#else\n-#define IS_ZERO(X) ((X) == 0)\n-#endif\n \n static void java_perform_atof\tPARAMS ((PTR));\n "}, {"sha": "0db33ca06679d99a456d05a989dc10320247492e", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -4120,8 +4120,6 @@ expand_float (to, from, unsignedp)\n \t  }\n     }\n \n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-\n   /* Unsigned integer, and no way to convert directly.\n      Convert as signed, then conditionally adjust the result.  */\n   if (unsignedp)\n@@ -4236,7 +4234,6 @@ expand_float (to, from, unsignedp)\n       emit_label (label);\n       goto done;\n     }\n-#endif\n \n   /* No hardware instruction available; call a library routine to convert from\n      SImode, DImode, or TImode into SFmode, DFmode, XFmode, or TFmode.  */\n@@ -4387,7 +4384,6 @@ expand_fix (to, from, unsignedp)\n \t  }\n       }\n \n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   /* For an unsigned conversion, there is one more way to do it.\n      If we have a signed conversion, we generate code that compares\n      the real value to the largest representable positive number.  If if\n@@ -4467,7 +4463,6 @@ expand_fix (to, from, unsignedp)\n \n \t  return;\n \t}\n-#endif\n \n   /* We can't do it with an insn, so use a library call.  But first ensure\n      that the mode of TO is at least as wide as SImode, since those are the"}, {"sha": "e5627e2bfa5f5f0d100e552d8dde9b9ffa868253", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -124,7 +124,6 @@ print_node_brief (file, prefix, node, indent)\n       if (TREE_OVERFLOW (node))\n \tfprintf (file, \" overflow\");\n \n-#if !defined(REAL_IS_NOT_DOUBLE) || defined(REAL_ARITHMETIC)\n       d = TREE_REAL_CST (node);\n       if (REAL_VALUE_ISINF (d))\n \tfprintf (file, \" Inf\");\n@@ -137,16 +136,6 @@ print_node_brief (file, prefix, node, indent)\n \t  REAL_VALUE_TO_DECIMAL (d, \"%e\", string);\n \t  fprintf (file, \" %s\", string);\n \t}\n-#else\n-      {\n-\tint i;\n-\tunsigned char *p = (unsigned char *) &TREE_REAL_CST (node);\n-\tfprintf (file, \" 0x\");\n-\tfor (i = 0; i < sizeof TREE_REAL_CST (node); i++)\n-\t  fprintf (file, \"%02x\", *p++);\n-\tfprintf (file, \"\");\n-      }\n-#endif\n     }\n \n   fprintf (file, \">\");\n@@ -681,7 +670,6 @@ print_node (file, prefix, node, indent)\n \t    if (TREE_OVERFLOW (node))\n \t      fprintf (file, \" overflow\");\n \n-#if !defined(REAL_IS_NOT_DOUBLE) || defined(REAL_ARITHMETIC)\n \t    d = TREE_REAL_CST (node);\n \t    if (REAL_VALUE_ISINF (d))\n \t      fprintf (file, \" Inf\");\n@@ -694,16 +682,6 @@ print_node (file, prefix, node, indent)\n \t\tREAL_VALUE_TO_DECIMAL (d, \"%e\", string);\n \t\tfprintf (file, \" %s\", string);\n \t      }\n-#else\n-\t    {\n-\t      int i;\n-\t      unsigned char *p = (unsigned char *) &TREE_REAL_CST (node);\n-\t      fprintf (file, \" 0x\");\n-\t      for (i = 0; i < sizeof TREE_REAL_CST (node); i++)\n-\t\tfprintf (file, \"%02x\", *p++);\n-\t      fprintf (file, \"\");\n-\t    }\n-#endif\n \t  }\n \t  break;\n "}, {"sha": "559cb058cc7effea1bd33ec0e810a29c91d16056", "filename": "gcc/real.c", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -30,19 +30,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* To enable support of XFmode extended real floating point, define\n LONG_DOUBLE_TYPE_SIZE 96 in the tm.h file (m68k.h or i386.h).\n \n-To support cross compilation between IEEE, VAX and IBM floating\n-point formats, define REAL_ARITHMETIC in the tm.h file.\n-\n-In either case the machine files (tm.h) must not contain any code\n+Machine files (tm.h etc) must not contain any code\n that tries to use host floating point arithmetic to convert\n REAL_VALUE_TYPEs from `double' to `float', pass them to fprintf,\n etc.  In cross-compile situations a REAL_VALUE_TYPE may not\n be intelligible to the host computer's native arithmetic.\n \n-The emulator defaults to the host's floating point format so that\n-its decimal conversion functions can be used if desired (see\n-real.h).\n-\n The first part of this file interfaces gcc to a floating point\n arithmetic suite that was not written with gcc in mind.  Avoid\n changing the low-level arithmetic routines unless you have suitable\n@@ -88,10 +81,7 @@ netlib.att.com: netlib/cephes.  */\n \n    If LONG_DOUBLE_TYPE_SIZE = 64 (the default, unless tm.h defines it)\n    then `long double' and `double' are both implemented, but they\n-   both mean DFmode.  In this case, the software floating-point\n-   support available here is activated by writing\n-      #define REAL_ARITHMETIC\n-   in tm.h.\n+   both mean DFmode.\n \n    The case LONG_DOUBLE_TYPE_SIZE = 128 activates TFmode support\n    and may deactivate XFmode since `long double' is used to refer\n@@ -113,10 +103,6 @@ netlib.att.com: netlib/cephes.  */\n \n /* The following converts gcc macros into the ones used by this file.  */\n \n-/* REAL_ARITHMETIC defined means that macros in real.h are\n-   defined to call emulator functions.  */\n-#ifdef REAL_ARITHMETIC\n-\n #if TARGET_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n /* PDP-11, Pro350, VAX: */\n #define DEC 1\n@@ -142,33 +128,6 @@ unknown arithmetic type\n \n #define REAL_WORDS_BIG_ENDIAN FLOAT_WORDS_BIG_ENDIAN\n \n-#else\n-/* REAL_ARITHMETIC not defined means that the *host's* data\n-   structure will be used.  It may differ by endian-ness from the\n-   target machine's structure and will get its ends swapped\n-   accordingly (but not here).  Probably only the decimal <-> binary\n-   functions in this file will actually be used in this case.  */\n-\n-#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n-#define DEC 1\n-#else /* it's not VAX */\n-#if HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n-/* IBM System/370 style */\n-#define IBM 1\n-#else /* it's also not an IBM */\n-#if HOST_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-#define IEEE\n-#else /* it's not IEEE either */\n-unknown arithmetic type\n-#define UNK 1\n-#endif /* not IEEE */\n-#endif /* not IBM */\n-#endif /* not VAX */\n-\n-#define REAL_WORDS_BIG_ENDIAN HOST_FLOAT_WORDS_BIG_ENDIAN\n-\n-#endif /* REAL_ARITHMETIC not defined */\n-\n /* Define INFINITY for support of infinity.\n    Define NANS for support of Not-a-Number's (NaN's).  */\n #if !defined(DEC) && !defined(IBM) && !defined(C4X)\n@@ -290,7 +249,6 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n #define NE 6\n #define MAXDECEXP 4932\n #define MINDECEXP -4956\n-#ifdef REAL_ARITHMETIC\n /* Emulator uses target format internally\n    but host stores it in host endian-ness.  */\n \n@@ -324,13 +282,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n        }\t\t\t\t\t\t\t\t\\\n    } while (0)\n \n-#else /* not REAL_ARITHMETIC */\n-\n-/* emulator uses host format */\n-#define GET_REAL(r,e) e53toe ((const UEMUSHORT *) (r), (e))\n-#define PUT_REAL(e,r) etoe53 ((e), (UEMUSHORT *) (r))\n-\n-#endif /* not REAL_ARITHMETIC */\n #endif /* not TFmode */\n #endif /* not XFmode */\n \n@@ -1048,11 +999,6 @@ ereal_ldexp (x, n)\n   return (r);\n }\n \n-/* These routines are conditionally compiled because functions\n-   of the same names may be defined in fold-const.c.  */\n-\n-#ifdef REAL_ARITHMETIC\n-\n /* Check for infinity in a REAL_VALUE_TYPE.  */\n \n int\n@@ -1226,7 +1172,6 @@ exact_real_inverse (mode, r)\n   PUT_REAL (einv, r);\n   return 1;\n }\n-#endif /* REAL_ARITHMETIC defined */\n \n /* Used for debugging--print the value of R in human-readable format\n    on stderr.  */\n@@ -1361,7 +1306,6 @@ ereal_isneg (x)\n   return (eisneg (ex));\n }\n \n-/* End of REAL_ARITHMETIC interface */\n \f\n /*\n   Extended precision IEEE binary floating point arithmetic routines"}, {"sha": "e734b26548e8e207a44657fa0b93d22ca5dfeedc", "filename": "gcc/real.h", "status": "modified", "additions": 22, "deletions": 223, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -65,10 +65,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #endif\n #endif\n \n-/* Defining REAL_ARITHMETIC invokes a floating point emulator\n-   that can produce a target machine format differing by more\n-   than just endian-ness from the host's format.  The emulator\n-   is also used to support extended real XFmode.  */\n #ifndef LONG_DOUBLE_TYPE_SIZE\n #define LONG_DOUBLE_TYPE_SIZE 64\n #endif\n@@ -80,19 +76,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef MAX_LONG_DOUBLE_TYPE_SIZE\n #define MAX_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n #endif\n-#if (MAX_LONG_DOUBLE_TYPE_SIZE == 96) || (MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n-#ifndef REAL_ARITHMETIC\n-#define REAL_ARITHMETIC\n-#endif\n-#endif\n-#ifdef REAL_ARITHMETIC\n+\n /* **** Start of software floating point emulator interface macros **** */\n \n /* Support 80-bit extended real XFmode if LONG_DOUBLE_TYPE_SIZE\n    has been defined to be 96 in the tm.h machine file.  */\n #if (MAX_LONG_DOUBLE_TYPE_SIZE == 96)\n #define REAL_IS_NOT_DOUBLE\n-#define REAL_ARITHMETIC\n typedef struct {\n   HOST_WIDE_INT r[(11 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n } realvaluetype;\n@@ -103,7 +93,6 @@ typedef struct {\n #if (MAX_LONG_DOUBLE_TYPE_SIZE == 128)\n \n #define REAL_IS_NOT_DOUBLE\n-#define REAL_ARITHMETIC\n typedef struct {\n   HOST_WIDE_INT r[(19 + sizeof (HOST_WIDE_INT))/(sizeof (HOST_WIDE_INT))];\n } realvaluetype;\n@@ -130,13 +119,6 @@ typedef struct {\n \n extern unsigned int significand_size\tPARAMS ((enum machine_mode));\n \n-/* If emulation has been enabled by defining REAL_ARITHMETIC or by\n-   setting LONG_DOUBLE_TYPE_SIZE to 96 or 128, then define macros so that\n-   they invoke emulator functions. This will succeed only if the machine\n-   files have been updated to use these macros in place of any\n-   references to host machine `double' or `float' types.  */\n-#ifdef REAL_ARITHMETIC\n-#undef REAL_ARITHMETIC\n #define REAL_ARITHMETIC(value, code, d1, d2) \\\n   earith (&(value), (code), &(d1), &(d2))\n \n@@ -176,10 +158,21 @@ extern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n #define REAL_VALUES_LESS(x, y) (ereal_cmp ((x), (y)) == -1)\n #define REAL_VALUE_LDEXP(x, n) ereal_ldexp (x, n)\n \n+/* Compare two floating-point objects for bitwise identity.\n+   This is not the same as comparing for equality on IEEE hosts:\n+   -0.0 equals 0.0 but they are not identical, and conversely\n+   two NaNs might be identical but they cannot be equal.  */\n+#define REAL_VALUES_IDENTICAL(x, y) \\\n+  (!memcmp ((char *) &(x), (char *) &(y), sizeof (REAL_VALUE_TYPE)))\n+\n /* These return REAL_VALUE_TYPE: */\n #define REAL_VALUE_RNDZINT(x) (etrunci (x))\n #define REAL_VALUE_UNSIGNED_RNDZINT(x) (etruncui (x))\n+\n+/* Truncate the floating-point value X to mode MODE.  */\n #define REAL_VALUE_TRUNCATE(mode, x)  real_value_truncate (mode, x)\n+extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n+                                                 REAL_VALUE_TYPE));\n \n /* These return HOST_WIDE_INT: */\n /* Convert a floating-point value to integer, rounding toward zero.  */\n@@ -195,6 +188,16 @@ extern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n \n #define REAL_VALUE_NEGATE ereal_negate\n \n+/* Determine whether a floating-point value X is infinite.  */\n+#define REAL_VALUE_ISINF(x) (target_isinf (x))\n+\n+/* Determine whether a floating-point value X is a NaN.  */\n+#define REAL_VALUE_ISNAN(x) (target_isnan (x))\n+\n+/* Determine whether a floating-point value X is negative.  */\n+#define REAL_VALUE_NEGATIVE(x) (target_negative (x))\n+\n+/* Determine whether a floating-point value X is minus zero.  */\n #define REAL_VALUE_MINUS_ZERO(x) \\\n  ((ereal_cmp (x, dconst0) == 0) && (ereal_isneg (x) != 0 ))\n \n@@ -234,203 +237,7 @@ extern REAL_VALUE_TYPE ereal_from_double PARAMS ((HOST_WIDE_INT *));\n /* Conversions to decimal ASCII string.  */\n #define REAL_VALUE_TO_DECIMAL(r, fmt, s) (ereal_to_decimal (r, s))\n \n-#endif /* REAL_ARITHMETIC defined */\n-\n /* **** End of software floating point emulator interface macros **** */\n-#else /* No XFmode or TFmode and REAL_ARITHMETIC not defined */\n-\n-/* old interface */\n-#ifdef REAL_ARITHMETIC\n-/* Defining REAL_IS_NOT_DOUBLE breaks certain initializations\n-   when REAL_ARITHMETIC etc. are not defined.  */\n-\n-/* Now see if the host and target machines use the same format. \n-   If not, define REAL_IS_NOT_DOUBLE (even if we end up representing\n-   reals as doubles because we have no better way in this cross compiler.)\n-   This turns off various optimizations that can happen when we know the\n-   compiler's float format matches the target's float format.\n-   */\n-#if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-#define\tREAL_IS_NOT_DOUBLE\n-#ifndef REAL_VALUE_TYPE\n-typedef struct {\n-    HOST_WIDE_INT r[sizeof (double)/sizeof (HOST_WIDE_INT)];\n-  } realvaluetype;\n-#define REAL_VALUE_TYPE realvaluetype\n-#endif /* no REAL_VALUE_TYPE */\n-#endif /* formats differ */\n-#endif /* 0 */\n-\n-#endif /* emulator not used */\n-\n-/* If we are not cross-compiling, use a `double' to represent the\n-   floating-point value.  Otherwise, use some other type\n-   (probably a struct containing an array of longs).  */\n-#ifndef REAL_VALUE_TYPE\n-#define REAL_VALUE_TYPE double\n-#else\n-#define REAL_IS_NOT_DOUBLE\n-#endif\n-\n-#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-\n-/* Convert a type `double' value in host format first to a type `float'\n-   value in host format and then to a single type `long' value which\n-   is the bitwise equivalent of the `float' value.  */\n-#ifndef REAL_VALUE_TO_TARGET_SINGLE\n-#define REAL_VALUE_TO_TARGET_SINGLE(IN, OUT)\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  union {\t\t\t\t\t\t\\\n-    float f;\t\t\t\t\t\t\\\n-    HOST_WIDE_INT l;\t\t\t\t\t\\\n-  } u;\t\t\t\t\t\t\t\\\n-  if (sizeof(HOST_WIDE_INT) < sizeof(float))\t\t\\\n-    abort ();\t\t\t\t\t\t\\\n-  u.l = 0;\t\t\t\t\t\t\\\n-  u.f = (IN);\t\t\t\t\t\t\\\n-  (OUT) = u.l;\t\t\t\t\t\t\\\n-} while (0)\n-#endif\n-\n-/* Convert a type `double' value in host format to a pair of type `long'\n-   values which is its bitwise equivalent, but put the two words into\n-   proper word order for the target.  */\n-#ifndef REAL_VALUE_TO_TARGET_DOUBLE\n-#define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  union {\t\t\t\t\t\t\t\t\\\n-    REAL_VALUE_TYPE f;\t\t\t\t\t\t\t\\\n-    HOST_WIDE_INT l[2];\t\t\t\t\t\t\t\\\n-  } u;\t\t\t\t\t\t\t\t\t\\\n-  if (sizeof(HOST_WIDE_INT) * 2 < sizeof(REAL_VALUE_TYPE))\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-  u.l[0] = u.l[1] = 0;\t\t\t\t\t\t\t\\\n-  u.f = (IN);\t\t\t\t\t\t\t\t\\\n-  if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\t\\\n-    (OUT)[0] = u.l[0], (OUT)[1] = u.l[1];\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    (OUT)[1] = u.l[0], (OUT)[0] = u.l[1];\t\t\t\t\\\n-} while (0)\n-#endif\n-#endif /* HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT */\n-\n-/* In this configuration, double and long double are the same.  */\n-#ifndef REAL_VALUE_TO_TARGET_LONG_DOUBLE\n-#define REAL_VALUE_TO_TARGET_LONG_DOUBLE(a, b) REAL_VALUE_TO_TARGET_DOUBLE (a, b)\n-#endif\n-\n-/* Compare two floating-point objects for bitwise identity.\n-   This is not the same as comparing for equality on IEEE hosts:\n-   -0.0 equals 0.0 but they are not identical, and conversely\n-   two NaNs might be identical but they cannot be equal.  */\n-#define REAL_VALUES_IDENTICAL(x, y) \\\n-  (!memcmp ((char *) &(x), (char *) &(y), sizeof (REAL_VALUE_TYPE)))\n-\n-/* Compare two floating-point values for equality.  */\n-#ifndef REAL_VALUES_EQUAL\n-#define REAL_VALUES_EQUAL(x, y) ((x) == (y))\n-#endif\n-\n-/* Compare two floating-point values for less than.  */\n-#ifndef REAL_VALUES_LESS\n-#define REAL_VALUES_LESS(x, y) ((x) < (y))\n-#endif\n-\n-/* Truncate toward zero to an integer floating-point value.  */\n-#ifndef REAL_VALUE_RNDZINT\n-#define REAL_VALUE_RNDZINT(x) ((double) ((int) (x)))\n-#endif\n-\n-/* Truncate toward zero to an unsigned integer floating-point value.  */\n-#ifndef REAL_VALUE_UNSIGNED_RNDZINT\n-#define REAL_VALUE_UNSIGNED_RNDZINT(x) ((double) ((unsigned int) (x)))\n-#endif\n-\n-/* Convert a floating-point value to integer, rounding toward zero.  */\n-#ifndef REAL_VALUE_FIX\n-#define REAL_VALUE_FIX(x) ((int) (x))\n-#endif\n-\n-/* Convert a floating-point value to unsigned integer, rounding\n-   toward zero.  */\n-#ifndef REAL_VALUE_UNSIGNED_FIX\n-#define REAL_VALUE_UNSIGNED_FIX(x) ((unsigned int) (x))\n-#endif\n-\n-/* Scale X by Y powers of 2.  */\n-#ifndef REAL_VALUE_LDEXP\n-#define REAL_VALUE_LDEXP(x, y) ldexp (x, y)\n-extern double ldexp PARAMS ((double, int));\n-#endif\n-\n-/* Convert the string X to a floating-point value.  */\n-#ifndef REAL_VALUE_ATOF\n-#if 1\n-/* Use real.c to convert decimal numbers to binary, ...  */\n-#define REAL_VALUE_ATOF(x, s) ereal_atof (x, s)\n-/* Could use ereal_atof here for hexadecimal floats too, but real_hex_to_f\n-   is OK and it uses faster native fp arithmetic.  */\n-/* #define REAL_VALUE_HTOF(x, s) ereal_atof (x, s) */\n-#else\n-/* ... or, if you like the host computer's atof, go ahead and use it: */\n-#define REAL_VALUE_ATOF(x, s) atof (x)\n-#if defined (MIPSEL) || defined (MIPSEB)\n-/* MIPS compiler can't handle parens around the function name.\n-   This problem *does not* appear to be connected with any\n-   macro definition for atof.  It does not seem there is one.  */\n-extern double atof ();\n-#else\n-extern double (atof) ();\n-#endif\n-#endif\n-#endif\n-\n-/* Hexadecimal floating constant input for use with host computer's\n-   fp arithmetic.  */\n-#ifndef REAL_VALUE_HTOF\n-extern REAL_VALUE_TYPE real_hex_to_f PARAMS ((const char *,\n-\t\t\t\t\t      enum machine_mode));\n-#define REAL_VALUE_HTOF(s,m) real_hex_to_f(s,m)\n-#endif\n-\n-/* Negate the floating-point value X.  */\n-#ifndef REAL_VALUE_NEGATE\n-#define REAL_VALUE_NEGATE(x) (- (x))\n-#endif\n-\n-/* Truncate the floating-point value X to mode MODE.  This is correct only\n-   for the most common case where the host and target have objects of the same\n-   size and where `float' is SFmode.  */\n-\n-/* Don't use REAL_VALUE_TRUNCATE directly--always call real_value_truncate.  */\n-extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n-\t\t\t\t\t\t  REAL_VALUE_TYPE));\n-\n-#ifndef REAL_VALUE_TRUNCATE\n-#define REAL_VALUE_TRUNCATE(mode, x) \\\n- (GET_MODE_BITSIZE (mode) == sizeof (float) * HOST_BITS_PER_CHAR\t\\\n-  ? (float) (x) : (x))\n-#endif\n-\n-/* Determine whether a floating-point value X is infinite.  */\n-#ifndef REAL_VALUE_ISINF\n-#define REAL_VALUE_ISINF(x) (target_isinf (x))\n-#endif\n-\n-/* Determine whether a floating-point value X is a NaN.  */\n-#ifndef REAL_VALUE_ISNAN\n-#define REAL_VALUE_ISNAN(x) (target_isnan (x))\n-#endif\n-\n-/* Determine whether a floating-point value X is negative.  */\n-#ifndef REAL_VALUE_NEGATIVE\n-#define REAL_VALUE_NEGATIVE(x) (target_negative (x))\n-#endif\n-\n-/* Determine whether a floating-point value X is minus 0.  */\n-#ifndef REAL_VALUE_MINUS_ZERO\n-#define REAL_VALUE_MINUS_ZERO(x) ((x) == 0 && REAL_VALUE_NEGATIVE (x))\n-#endif\n \f\n /* Constant real values 0, 1, 2, and -1.  */\n \n@@ -466,14 +273,6 @@ do { union real_extract u;\t\t\t\t\\\n extern struct rtx_def *immed_real_const_1\tPARAMS ((REAL_VALUE_TYPE,\n \t\t\t\t\t\t       enum machine_mode));\n \n-\n-/* Convert a floating point value `r', that can be interpreted\n-   as a host machine float or double, to a decimal ASCII string `s'\n-   using printf format string `fmt'.  */\n-#ifndef REAL_VALUE_TO_DECIMAL\n-#define REAL_VALUE_TO_DECIMAL(r, fmt, s) (sprintf (s, fmt, r))\n-#endif\n-\n /* Replace R by 1/R in the given machine mode, if the result is exact.  */\n extern int exact_real_inverse\tPARAMS ((enum machine_mode, REAL_VALUE_TYPE *));\n extern int target_isnan\t\tPARAMS ((REAL_VALUE_TYPE));"}, {"sha": "968f1e51d08085b1f4bc6015aa8108482f6e96b3", "filename": "gcc/recog.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1716,16 +1716,6 @@ asm_operand_ok (op, constraint)\n \t  break;\n \n \tcase 'E':\n-#ifndef REAL_ARITHMETIC\n-\t  /* Match any floating double constant, but only if\n-\t     we can examine the bits of it reliably.  */\n-\t  if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t       || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n-\t      && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n-\t    break;\n-#endif\n-\t  /* FALLTHRU */\n-\n \tcase 'F':\n \t  if (GET_CODE (op) == CONST_DOUBLE)\n \t    return 1;\n@@ -2492,18 +2482,6 @@ constrain_operands (strict)\n \t\tbreak;\n \n \t      case 'E':\n-#ifndef REAL_ARITHMETIC\n-\t\t/* Match any CONST_DOUBLE, but only if\n-\t\t   we can examine the bits of it reliably.  */\n-\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n-\t\t    && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n-\t\t  break;\n-#endif\n-\t\tif (GET_CODE (op) == CONST_DOUBLE)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n \t      case 'F':\n \t\tif (GET_CODE (op) == CONST_DOUBLE)\n \t\t  win = 1;"}, {"sha": "0d74e38927d0788538536c5ad49b41496dc1f4d2", "filename": "gcc/regclass.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -1635,18 +1635,6 @@ record_reg_classes (n_alts, n_ops, ops, modes,\n \t\tbreak;\n \n \t      case 'E':\n-#ifndef REAL_ARITHMETIC\n-\t\t/* Match any floating double constant, but only if\n-\t\t   we can examine the bits of it reliably.  */\n-\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n-\t\t    && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n-\t\t  break;\n-#endif\n-\t\tif (GET_CODE (op) == CONST_DOUBLE)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n \t      case 'F':\n \t\tif (GET_CODE (op) == CONST_DOUBLE)\n \t\t  win = 1;"}, {"sha": "0e08aba61b2dc2b00511d214fe9e6c34da94c4a3", "filename": "gcc/reload.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -3121,18 +3121,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\tbreak;\n \n \t      case 'E':\n-#ifndef REAL_ARITHMETIC\n-\t\t/* Match any floating double constant, but only if\n-\t\t   we can examine the bits of it reliably.  */\n-\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n-\t\t    && GET_MODE (operand) != VOIDmode && ! flag_pretend_float)\n-\t\t  break;\n-#endif\n-\t\tif (GET_CODE (operand) == CONST_DOUBLE)\n-\t\t  win = 1;\n-\t\tbreak;\n-\n \t      case 'F':\n \t\tif (GET_CODE (operand) == CONST_DOUBLE)\n \t\t  win = 1;"}, {"sha": "50058ee38fc7b072794f7560ae58d8cd4ddd0838", "filename": "gcc/rtl.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -30,30 +30,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Calculate the format for CONST_DOUBLE.  This depends on the relative\n    widths of HOST_WIDE_INT and REAL_VALUE_TYPE.\n \n-   We need to go out to 0wwwww, since REAL_ARITHMETIC assumes 16-bits\n-   per element in REAL_VALUE_TYPE.\n+   We need to go out to 0wwwww, since real.c assumes 16 bits per element\n+   in REAL_VALUE_TYPE.\n \n    This is duplicated in gengenrtl.c.\n \n    A number of places assume that there are always at least two 'w'\n    slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */\n \n-#ifdef REAL_ARITHMETIC\n-# if MAX_LONG_DOUBLE_TYPE_SIZE == 96\n-#  define REAL_WIDTH\t\\\n+#if MAX_LONG_DOUBLE_TYPE_SIZE == 96\n+# define REAL_WIDTH\t\\\n      (11*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n+#else\n+# if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n+#  define REAL_WIDTH\t\\\n+      (19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n # else\n-#  if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n+#  if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n #   define REAL_WIDTH\t\\\n-      (19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#  else\n-#   if HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-#    define REAL_WIDTH\t\\\n        (7*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT\n-#   endif\n #  endif\n # endif\n-#endif /* REAL_ARITHMETIC */\n+#endif\n \n #ifndef REAL_WIDTH\n # if HOST_BITS_PER_WIDE_INT*2 >= MAX_LONG_DOUBLE_TYPE_SIZE"}, {"sha": "5596e0c1e0a29e40c869a85ef4ae5c644d7a9679", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 1, "deletions": 79, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -102,10 +102,8 @@ static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx,\n \t\t\t\t\t\t rtx, int));\n static void check_fold_consts\t\tPARAMS ((PTR));\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n static void simplify_unary_real\t\tPARAMS ((PTR));\n static void simplify_binary_real\tPARAMS ((PTR));\n-#endif\n static void simplify_binary_is2orm1\tPARAMS ((PTR));\n \n \f\n@@ -339,7 +337,6 @@ simplify_replace_rtx (x, old, new)\n   return x;\n }\n \f\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n /* Subroutine of simplify_unary_operation, called via do_float_handler.\n    Handles simplification of unary ops on floating point values.  */\n struct simplify_unary_real_args\n@@ -398,7 +395,6 @@ simplify_unary_real (p)\n       args->result = CONST_DOUBLE_FROM_REAL_VALUE (d, args->mode);\n     }\n }\n-#endif\n \n /* Try to simplify a unary operation CODE whose output mode is to be\n    MODE with input operand OP whose mode was originally OP_MODE.\n@@ -417,8 +413,6 @@ simplify_unary_operation (code, mode, op, op_mode)\n      check the wrong mode (input vs. output) for a conversion operation,\n      such as FIX.  At some point, this should be simplified.  */\n \n-#if !defined(REAL_IS_NOT_DOUBLE) || defined(REAL_ARITHMETIC)\n-\n   if (code == FLOAT && GET_MODE (trueop) == VOIDmode\n       && (GET_CODE (trueop) == CONST_DOUBLE || GET_CODE (trueop) == CONST_INT))\n     {\n@@ -430,25 +424,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n       else\n \tlv = CONST_DOUBLE_LOW (trueop),  hv = CONST_DOUBLE_HIGH (trueop);\n \n-#ifdef REAL_ARITHMETIC\n       REAL_VALUE_FROM_INT (d, lv, hv, mode);\n-#else\n-      if (hv < 0)\n-\t{\n-\t  d = (double) (~ hv);\n-\t  d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n-\t\t* (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-\t  d += (double) (unsigned HOST_WIDE_INT) (~ lv);\n-\t  d = (- d - 1.0);\n-\t}\n-      else\n-\t{\n-\t  d = (double) hv;\n-\t  d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n-\t\t* (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-\t  d += (double) (unsigned HOST_WIDE_INT) lv;\n-\t}\n-#endif  /* REAL_ARITHMETIC */\n       d = real_value_truncate (mode, d);\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n@@ -476,19 +452,10 @@ simplify_unary_operation (code, mode, op, op_mode)\n       else\n \thv = 0, lv &= GET_MODE_MASK (op_mode);\n \n-#ifdef REAL_ARITHMETIC\n       REAL_VALUE_FROM_UNSIGNED_INT (d, lv, hv, mode);\n-#else\n-\n-      d = (double) (unsigned HOST_WIDE_INT) hv;\n-      d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n-\t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-      d += (double) (unsigned HOST_WIDE_INT) lv;\n-#endif  /* REAL_ARITHMETIC */\n       d = real_value_truncate (mode, d);\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n-#endif\n \n   if (GET_CODE (trueop) == CONST_INT\n       && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n@@ -664,7 +631,6 @@ simplify_unary_operation (code, mode, op, op_mode)\n       return immed_double_const (lv, hv, mode);\n     }\n \n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n@@ -696,7 +662,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n       return 0;\n     }\n-#endif\n+\n   /* This was formerly used only for non-IEEE float.\n      eggert@twinsun.com says it is safe for IEEE also.  */\n   else\n@@ -770,7 +736,6 @@ simplify_unary_operation (code, mode, op, op_mode)\n     }\n }\n \f\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n /* Subroutine of simplify_binary_operation, called via do_float_handler.\n    Handles simplification of binary ops on floating point values.  */\n struct simplify_binary_real_args\n@@ -794,7 +759,6 @@ simplify_binary_real (p)\n   f0 = real_value_truncate (args->mode, f0);\n   f1 = real_value_truncate (args->mode, f1);\n \n-#ifdef REAL_ARITHMETIC\n #ifndef REAL_INFINITY\n   if (args->code == DIV && REAL_VALUES_EQUAL (f1, dconst0))\n     {\n@@ -803,40 +767,10 @@ simplify_binary_real (p)\n     }\n #endif\n   REAL_ARITHMETIC (value, rtx_to_tree_code (args->code), f0, f1);\n-#else\n-  switch (args->code)\n-    {\n-    case PLUS:\n-      value = f0 + f1;\n-      break;\n-    case MINUS:\n-      value = f0 - f1;\n-      break;\n-    case MULT:\n-      value = f0 * f1;\n-      break;\n-    case DIV:\n-#ifndef REAL_INFINITY\n-      if (f1 == 0)\n-\treturn 0;\n-#endif\n-      value = f0 / f1;\n-      break;\n-    case SMIN:\n-      value = MIN (f0, f1);\n-      break;\n-    case SMAX:\n-      value = MAX (f0, f1);\n-      break;\n-    default:\n-      abort ();\n-    }\n-#endif\n \n   value = real_value_truncate (args->mode, value);\n   args->result = CONST_DOUBLE_FROM_REAL_VALUE (value, args->mode);\n }\n-#endif\n \n /* Another subroutine called via do_float_handler.  This one tests\n    the floating point value given against 2. and -1.  */\n@@ -894,7 +828,6 @@ simplify_binary_operation (code, mode, op0, op1)\n       tem = trueop0, trueop0 = trueop1, trueop1 = tem;\n     }\n \n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_CODE (trueop0) == CONST_DOUBLE\n       && GET_CODE (trueop1) == CONST_DOUBLE\n@@ -910,7 +843,6 @@ simplify_binary_operation (code, mode, op0, op1)\n \treturn args.result;\n       return 0;\n     }\n-#endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n   /* We can fold some multi-word operations.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n@@ -1432,7 +1364,6 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n \n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n \t  /* Change division by a constant into multiplication.  Only do\n \t     this with -funsafe-math-optimizations.  */\n \t  else if (GET_CODE (trueop1) == CONST_DOUBLE\n@@ -1445,18 +1376,11 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t      if (! REAL_VALUES_EQUAL (d, dconst0))\n \t\t{\n-#if defined (REAL_ARITHMETIC)\n \t\t  REAL_ARITHMETIC (d, rtx_to_tree_code (DIV), dconst1, d);\n \t\t  return gen_rtx_MULT (mode, op0, \n \t\t\t\t       CONST_DOUBLE_FROM_REAL_VALUE (d, mode));\n-#else\n-\t\t  return\n-\t\t    gen_rtx_MULT (mode, op0, \n-\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (1./d, mode));\n-#endif\n \t\t}\n \t    }\n-#endif\n \t  break;\n \n \tcase UMOD:\n@@ -2102,7 +2026,6 @@ simplify_relational_operation (code, mode, op0, op1)\n \n   /* If the operands are floating-point constants, see if we can fold\n      the result.  */\n-#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   else if (GET_CODE (trueop0) == CONST_DOUBLE\n \t   && GET_CODE (trueop1) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (trueop0)) == MODE_FLOAT)\n@@ -2145,7 +2068,6 @@ simplify_relational_operation (code, mode, op0, op1)\n       op0lt = op0ltu = args.op0lt;\n       op1lt = op1ltu = args.op1lt;\n     }\n-#endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n   /* Otherwise, see if the operands are both integers.  */\n   else if ((GET_MODE_CLASS (mode) == MODE_INT || mode == VOIDmode)"}, {"sha": "11c55464468df672c82bab97ef1e3c037f7a4290", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -726,12 +726,6 @@ int flag_asynchronous_unwind_tables = 0;\n \n int flag_no_common;\n \n-/* Nonzero means pretend it is OK to examine bits of target floats,\n-   even if that isn't true.  The resulting code will have incorrect constants,\n-   but the same series of instructions that the native compiler would make.  */\n-\n-int flag_pretend_float;\n-\n /* Nonzero means change certain warnings into errors.\n    Usually these are warnings about failure to conform to some standard.  */\n \n@@ -1055,8 +1049,6 @@ static const lang_independent_options f_options[] =\n    N_(\"Run the loop optimizer twice\") },\n   {\"delete-null-pointer-checks\", &flag_delete_null_pointer_checks, 1,\n    N_(\"Delete useless null pointer checks\") },\n-  {\"pretend-float\", &flag_pretend_float, 1,\n-   N_(\"Pretend that host and target use the same FP format\") },\n   {\"schedule-insns\", &flag_schedule_insns, 1,\n    N_(\"Reschedule instructions before register allocation\") },\n   {\"schedule-insns2\", &flag_schedule_insns_after_reload, 1,"}, {"sha": "a54b50641cb1cba8d130a0f25d93cf1cec64fae8", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba31d94ee642e435d03ba73be3db027b362edd1b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ba31d94ee642e435d03ba73be3db027b362edd1b", "patch": "@@ -613,15 +613,12 @@ build_real (type, d)\n /* Return a new REAL_CST node whose type is TYPE\n    and whose value is the integer value of the INTEGER_CST node I.  */\n \n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-\n REAL_VALUE_TYPE\n real_value_from_int_cst (type, i)\n      tree type ATTRIBUTE_UNUSED, i;\n {\n   REAL_VALUE_TYPE d;\n \n-#ifdef REAL_ARITHMETIC\n   /* Clear all bits of the real value type so that we can later do\n      bitwise comparisons to see if two values are the same.  */\n   memset ((char *) &d, 0, sizeof d);\n@@ -632,33 +629,6 @@ real_value_from_int_cst (type, i)\n   else\n     REAL_VALUE_FROM_UNSIGNED_INT (d, TREE_INT_CST_LOW (i),\n \t\t\t\t  TREE_INT_CST_HIGH (i), TYPE_MODE (type));\n-#else /* not REAL_ARITHMETIC */\n-  /* Some 386 compilers mishandle unsigned int to float conversions,\n-     so introduce a temporary variable E to avoid those bugs.  */\n-  if (TREE_INT_CST_HIGH (i) < 0 && ! TREE_UNSIGNED (TREE_TYPE (i)))\n-    {\n-      REAL_VALUE_TYPE e;\n-\n-      d = (double) (~TREE_INT_CST_HIGH (i));\n-      e = ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n-\t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-      d *= e;\n-      e = (double) (~TREE_INT_CST_LOW (i));\n-      d += e;\n-      d = (- d - 1.0);\n-    }\n-  else\n-    {\n-      REAL_VALUE_TYPE e;\n-\n-      d = (double) (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (i);\n-      e = ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n-\t   * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n-      d *= e;\n-      e = (double) TREE_INT_CST_LOW (i);\n-      d += e;\n-    }\n-#endif /* not REAL_ARITHMETIC */\n   return d;\n }\n \n@@ -680,13 +650,7 @@ build_real_from_int_cst_1 (data)\n {\n   struct brfic_args *args = (struct brfic_args *) data;\n \n-#ifdef REAL_ARITHMETIC\n   args->d = real_value_from_int_cst (args->type, args->i);\n-#else\n-  args->d\n-    = REAL_VALUE_TRUNCATE (TYPE_MODE (args->type),\n-\t\t\t   real_value_from_int_cst (args->type, args->i));\n-#endif\n }\n \n /* Given a tree representing an integer constant I, return a tree\n@@ -732,8 +696,6 @@ build_real_from_int_cst (type, i)\n   return v;\n }\n \n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n-\n /* Return a newly constructed STRING_CST node whose value is\n    the LEN characters at STR.\n    The TREE_TYPE is not initialized.  */"}]}