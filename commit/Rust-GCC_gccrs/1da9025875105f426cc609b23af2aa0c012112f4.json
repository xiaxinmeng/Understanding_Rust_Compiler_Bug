{"sha": "1da9025875105f426cc609b23af2aa0c012112f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRhOTAyNTg3NTEwNWY0MjZjYzYwOWIyM2FmMmFhMGMwMTIxMTJmNA==", "commit": {"author": {"name": "Daniel Franke", "email": "franke.daniel@gmail.com", "date": "2007-04-26T21:16:01Z"}, "committer": {"name": "Daniel Franke", "email": "dfranke@gcc.gnu.org", "date": "2007-04-26T21:16:01Z"}, "message": "intrinsic.texi (NULL, [...]): New.\n\n2007-04-26  Daniel Franke  <franke.daniel@gmail.com>\n\n\t* intrinsic.texi (NULL, PACK, PRESENT, REPEAT, SCAN, SHAPE, \n\tSIZE, TRANSPOSE, TRIM, VERIFY): New.\n\t(ADJUSTL, ADJUSTR, INDEX): Added cross references.\n\t(INT, INT2, INT8, LONG): Enabled section header.\n\nFrom-SVN: r124200", "tree": {"sha": "5bb2269e62b04a36dcd2648d005fbb0191eb5683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb2269e62b04a36dcd2648d005fbb0191eb5683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1da9025875105f426cc609b23af2aa0c012112f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da9025875105f426cc609b23af2aa0c012112f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1da9025875105f426cc609b23af2aa0c012112f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1da9025875105f426cc609b23af2aa0c012112f4/comments", "author": {"login": "dfranke76", "id": 15729164, "node_id": "MDQ6VXNlcjE1NzI5MTY0", "avatar_url": "https://avatars.githubusercontent.com/u/15729164?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dfranke76", "html_url": "https://github.com/dfranke76", "followers_url": "https://api.github.com/users/dfranke76/followers", "following_url": "https://api.github.com/users/dfranke76/following{/other_user}", "gists_url": "https://api.github.com/users/dfranke76/gists{/gist_id}", "starred_url": "https://api.github.com/users/dfranke76/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dfranke76/subscriptions", "organizations_url": "https://api.github.com/users/dfranke76/orgs", "repos_url": "https://api.github.com/users/dfranke76/repos", "events_url": "https://api.github.com/users/dfranke76/events{/privacy}", "received_events_url": "https://api.github.com/users/dfranke76/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd3b6c09eaf412bd0e67b9f5807e9dff5775ae9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3b6c09eaf412bd0e67b9f5807e9dff5775ae9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3b6c09eaf412bd0e67b9f5807e9dff5775ae9d"}], "stats": {"total": 308, "additions": 267, "deletions": 41}, "files": [{"sha": "e17d309e4110701c09f4edb68f2a79c40c3e7ea2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da9025875105f426cc609b23af2aa0c012112f4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da9025875105f426cc609b23af2aa0c012112f4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1da9025875105f426cc609b23af2aa0c012112f4", "patch": "@@ -1,3 +1,10 @@\n+2007-04-26  Daniel Franke  <franke.daniel@gmail.com>\n+\n+\t* intrinsic.texi (NULL, PACK, PRESENT, REPEAT, SCAN, SHAPE, \n+\tSIZE, TRANSPOSE, TRIM, VERIFY): New.\n+\t(ADJUSTL, ADJUSTR, INDEX): Added cross references.\n+\t(INT, INT2, INT8, LONG): Enabled section header.\n+\n 2007-04-25  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* module.c (module_char): Replace fgetc() with"}, {"sha": "7c328ad57b10eb6a5d41ba72311386c51f93bf4a", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 260, "deletions": 41, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1da9025875105f426cc609b23af2aa0c012112f4/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1da9025875105f426cc609b23af2aa0c012112f4/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=1da9025875105f426cc609b23af2aa0c012112f4", "patch": "@@ -194,7 +194,7 @@ Some basic guidelines for editing this document:\n * @code{PACK}:          PACK,      Pack an array into an array of rank one\n * @code{PERROR}:        PERROR,    Print system error message\n * @code{PRECISION}:     PRECISION, Decimal precision of a real kind\n-* @code{PRESENT}:       PRESENT,   Determine whether an optional argument is specified\n+* @code{PRESENT}:       PRESENT,   Determine whether an optional dummy argument is specified\n * @code{PRODUCT}:       PRODUCT,   Product of array elements\n * @code{RADIX}:         RADIX,     Base of a data model\n * @code{RANDOM_NUMBER}: RANDOM_NUMBER, Pseudo-random number\n@@ -239,7 +239,7 @@ Some basic guidelines for editing this document:\n * @code{TINY}:          TINY,      Smallest positive number of a real kind\n * @code{TRANSFER}:      TRANSFER,  Transfer bit patterns\n * @code{TRANSPOSE}:     TRANSPOSE, Transpose an array of rank two\n-* @code{TRIM}:          TRIM,      Function to remove trailing blank characters of a string\n+* @code{TRIM}:          TRIM,      Remove trailing blank characters of a string\n * @code{TTYNAM}:        TTYNAM,    Get the name of a terminal device.\n * @code{UBOUND}:        UBOUND,    Upper dimension bounds of an array\n * @code{UMASK}:         UMASK,     Set the file creation mask\n@@ -597,7 +597,7 @@ Inverse function: @ref{COSH}\n @node ADJUSTL\n @section @code{ADJUSTL} --- Left adjust a string \n @cindex @code{ADJUSTL} intrinsic\n-@cindex adjust string\n+@cindex string manipulation\n \n @table @asis\n @item @emph{Description}:\n@@ -631,14 +631,17 @@ program test_adjustl\n   print *, str\n end program test_adjustl\n @end smallexample\n+\n+@item @emph{See also}:\n+@ref{ADJUSTR}, @ref{TRIM}\n @end table\n \n \n \n @node ADJUSTR\n @section @code{ADJUSTR} --- Right adjust a string \n @cindex @code{ADJUSTR} intrinsic\n-@cindex adjust string\n+@cindex string manipulation\n \n @table @asis\n @item @emph{Description}:\n@@ -672,6 +675,9 @@ program test_adjustr\n   print *, str\n end program test_adjustr\n @end smallexample\n+\n+@item @emph{See also}:\n+@ref{ADJUSTL}, @ref{TRIM}\n @end table\n \n \n@@ -5053,6 +5059,7 @@ kind.\n @node INDEX\n @section @code{INDEX} --- Position of a substring within a string\n @cindex @code{INDEX} intrinsic\n+@cindex string manipulation\n \n @table @asis\n @item @emph{Description}:\n@@ -5086,6 +5093,7 @@ The return value is of type @code{INTEGER} and of the default integer\n kind.\n \n @item @emph{See also}:\n+@ref{SCAN}, @ref{VERIFY}\n @end table\n \n \n@@ -5151,7 +5159,6 @@ end program\n @item @code{IDINT(A)}  @tab @code{REAL(8) A}    @tab @code{INTEGER}    @tab F77 and later\n @end multitable\n \n-@comment @item @emph{See also}:\n @end table\n \n \n@@ -5188,7 +5195,7 @@ Elemental function\n @item @emph{Return value}:\n The return value is a @code{INTEGER(2)} variable.\n \n-@comment @item @emph{See also}:\n+@item @emph{See also}:\n @ref{INT}, @ref{INT8}, @ref{LONG}\n @end table\n \n@@ -5223,7 +5230,7 @@ Elemental function\n @item @emph{Return value}:\n The return value is a @code{INTEGER(8)} variable.\n \n-@comment @item @emph{See also}:\n+@item @emph{See also}:\n @ref{INT}, @ref{INT2}, @ref{LONG}\n @end table\n \n@@ -6133,7 +6140,7 @@ Elemental function\n @item @emph{Return value}:\n The return value is a @code{INTEGER(4)} variable.\n \n-@comment @item @emph{See also}:\n+@item @emph{See also}:\n @ref{INT}, @ref{INT2}, @ref{INT8}\n @end table\n \n@@ -7280,22 +7287,41 @@ argument.\n @node NULL\n @section @code{NULL} --- Function that returns an disassociated pointer\n @cindex @code{NULL} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@cindex pointer status\n \n @table @asis\n @item @emph{Description}:\n+Returns a disassociated pointer.\n+\n+If @var{MOLD} is present, a dissassociated pointer of the same type is\n+returned, otherwise the type is determined by context.\n+\n+In Fortran 95, @var{MOLD} is optional. Please note that F2003 includes\n+cases where it is required.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{PTR => NULL([MOLD])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{MOLD} @tab (Optional) shall be a pointer of any association\n+status and of any type.\n+@end multitable\n+\n @item @emph{Return value}:\n+A disassociated pointer.\n+\n @item @emph{Example}:\n+@smallexample\n+REAL, POINTER, DIMENSION(:) :: VEC => NULL ()\n+@end smallexample\n+\n @item @emph{See also}:\n @ref{ASSOCIATED}\n @end table\n@@ -7355,23 +7381,63 @@ F95 elemental function: @ref{IOR}\n @node PACK\n @section @code{PACK} --- Pack an array into an array of rank one\n @cindex @code{PACK} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n+@cindex array manipulation\n \n @table @asis\n @item @emph{Description}:\n+Stores the elements of @var{ARRAY} in an array of rank one.\n+\n+The beginning of the resulting array is made up of elements whose @var{MASK} \n+equals @code{TRUE}. Afterwards, positions are filled with elements taken from\n+@var{VECTOR}.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = PACK(ARRAY, MASK[,VECTOR]}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY}  @tab Shall be an array of any type.\n+@item @var{MASK}   @tab Shall be an array of type @code{LOGICAL} and \n+of the same size as @var{ARRAY}. Alternatively, it may be a @code{LOGICAL} \n+scalar.\n+@item @var{VECTOR} @tab (Optional) shall be an array of the same type \n+as @var{ARRAY} and of rank one. If present, the number of elements in \n+@var{VECTOR} shall be equal to or greater than the number of true elements \n+in @var{MASK}. If @var{MASK} is scalar, the number of elements in \n+@var{VECTOR} shall be equal to or greater than the number of elements in\n+@var{ARRAY}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The result is an array of rank one and the same type as that of @var{ARRAY}.\n+If @var{VECTOR} is present, the result size is that of @var{VECTOR}, the\n+number of @code{TRUE} values in @var{MASK} otherwise.\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+Gathering non-zero elements from an array:\n+@smallexample\n+PROGRAM test_pack_1\n+  INTEGER :: m(6)\n+  m = (/ 1, 0, 0, 0, 5, 0 /)\n+  WRITE(*, FMT=\"(6(I0, ' '))\") pack(m, m /= 0)  ! \"1 5\"\n+END PROGRAM\n+@end smallexample\n+\n+Gathering non-zero elements from an array and appending elements from @var{VECTOR}:\n+@smallexample\n+PROGRAM test_pack_2\n+  INTEGER :: m(4)\n+  m = (/ 1, 0, 0, 2 /)\n+  WRITE(*, FMT=\"(4(I0, ' '))\") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! \"1 2 3 4\"\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n @ref{UNPACK}\n @end table\n@@ -7451,25 +7517,44 @@ end program prec_and_range\n \n \n @node PRESENT\n-@section @code{PRESENT} --- Determine whether an optional argument is specified\n+@section @code{PRESENT} --- Determine whether an optional dummy argument is specified\n @cindex @code{PRESENT} intrinsic\n-@cindex undocumented intrinsic \n-\n-Intrinsic implemented, documentation pending.\n \n @table @asis\n @item @emph{Description}:\n+Determines whether an optional dummy argument is present.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Inquiry function\n \n @item @emph{Syntax}:\n+@code{RESULT = PRESENT(A)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{A} @tab May be of any type and may be a pointer, scalar or array\n+value, or a dummy procedure. It shall be the name of an optional dummy argument\n+accessible within the current subroutine or function.\n+@end multitable\n+\n @item @emph{Return value}:\n+Returns either @code{TRUE} if the optional argument @var{A} is present, or\n+@code{FALSE} otherwise.\n+\n @item @emph{Example}:\n-@item @emph{See also}:\n+@smallexample\n+PROGRAM test_present\n+  WRITE(*,*) f(), f(42)      ! \"F T\"\n+CONTAINS\n+  LOGICAL FUNCTION f(x)\n+    INTEGER, INTENT(IN), OPTIONAL :: x\n+    f = PRESENT(x)\n+  END FUNCTION\n+END PROGRAM\n+@end smallexample\n @end table\n \n \n@@ -7867,21 +7952,35 @@ Subroutine, non-elemental function\n @cindex @code{REPEAT} intrinsic\n @cindex string manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Concatenates @var{NCOPIES} copies of a string.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = REPEAT(STRING, NCOPIES)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{STRING}  @tab Shall be scalar and of type @code{CHARACTER(*)}.\n+@item @var{NCOPIES} @tab Shall be scalar and of type @code{INTEGER(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n+A new scalar of type @code{CHARACTER} built up from @var{NCOPIES} copies \n+of @var{STRING}.\n+\n @item @emph{Example}:\n-@item @emph{See also}:\n+@smallexample\n+program test_repeat\n+  write(*,*) repeat(\"x\", 5)   ! \"xxxxx\"\n+end program\n+@end smallexample\n @end table\n \n \n@@ -7906,7 +8005,7 @@ Transformational function\n @item @emph{Return value}:\n @item @emph{Example}:\n @item @emph{See also}:\n-@ref{SHAPE}\n+@ref{SHAPE}, @ref{SIZE}\n @end table\n \n \n@@ -8030,21 +8129,48 @@ end program test_scale\n @cindex @code{SCAN} intrinsic\n @cindex string manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Scans a @var{STRING} for any of the characters in a @var{SET} \n+of characters.\n+\n+If @var{BACK} is either absent or equals @code{FALSE}, this function\n+returns the position of the leftmost character of @var{STRING} that is\n+in @var{SET}. If @var{BACK} equals @code{TRUE}, the rightmost position\n+is returned. If no character of @var{SET} is found in @var{STRING}, the \n+result is zero.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = SCAN(STRING, SET[, BACK])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{STRING} @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{SET}    @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{BACK}   @tab (Optional) shall be of type @code{LOGICAL}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the default\n+integer kind.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_scan\n+  WRITE(*,*) SCAN(\"FORTRAN\", \"AO\")          ! 2, found 'O'\n+  WRITE(*,*) SCAN(\"FORTRAN\", \"AO\", .TRUE.)  ! 6, found 'A'\n+  WRITE(*,*) SCAN(\"FORTRAN\", \"C++\")         ! 0, found none\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{INDEX}, @ref{VERIFY}\n @end table\n \n \n@@ -8296,22 +8422,43 @@ end program test_setexp\n @cindex @code{SHAPE} intrinsic\n @cindex array manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Determines the shape of an array.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Inquiry function\n \n @item @emph{Syntax}:\n+@code{RESULT = SHAPE(SOURCE)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{SOURCE} @tab Shall be an array or scalar of any type. \n+If @var{SOURCE} is a pointer it must be associated and allocatable \n+arrays must be allocated.\n+@end multitable\n+\n @item @emph{Return value}:\n+An @code{INTEGER} array of rank one with as many elements as @var{SOURCE} \n+has dimensions. The elements of the resulting array correspond to the extent\n+of @var{SOURCE} along the respective dimensions. If @var{SOURCE} is a scalar,\n+the result is the rank one array of size zero.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_shape\n+  INTEGER, DIMENSION(-1:1, -1:2) :: A\n+  WRITE(*,*) SHAPE(A)             ! (/ 3, 4 /)\n+  WRITE(*,*) SIZE(SHAPE(42))      ! (/ /)\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n-@ref{RESHAPE}\n+@ref{RESHAPE}, @ref{SIZE}\n @end table\n \n \n@@ -8533,21 +8680,42 @@ end program test_sinh\n @cindex @code{SIZE} intrinsic\n @cindex array manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Determine the extent of @var{ARRAY} along a specified dimension @var{DIM},\n+or the total number of elements in @var{ARRAY} if @var{DIM} is absent.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Inquiry function\n \n @item @emph{Syntax}:\n+@code{RESULT = SIZE(ARRAY[, DIM])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{ARRAY} @tab Shall be an array of any type. If @var{ARRAY} is\n+a pointer it must be associated and allocatable arrays must be allocated.\n+@item @var{DIM}   @tab (Optional) shall be a scalar of type @code{INTEGER} \n+and its value shall be in the range from 1 to n, where n equals the rank \n+of @var{ARRAY}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the default\n+integer kind.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_size\n+  WRITE(*,*) SIZE((/ 1, 2 /))    ! 2\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{SHAPE}, @ref{RESHAPE}\n @end table\n \n \n@@ -9218,45 +9386,69 @@ Transformational function\n @cindex @code{TRANSPOSE} intrinsic\n @cindex matrix manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Transpose an array of rank two. Element (i, j) of the result has the value \n+@code{MATRIX(j, i)}, for all i, j.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = TRANSPOSE(MATRIX)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{MATRIX} @tab Shall be an array of any type and have a rank of two.\n+@end multitable\n+\n @item @emph{Return value}:\n-@item @emph{Example}:\n-@item @emph{See also}:\n+The result has the the same type as @var{MATRIX}, and has shape \n+@code{(/ m, n /)} if @var{MATRIX} has shape @code{(/ n, m /)}.\n @end table\n \n \n \n @node TRIM\n-@section @code{TRIM} --- Function to remove trailing blank characters of a string\n+@section @code{TRIM} --- Remove trailing blank characters of a string\n @cindex @code{TRIM} intrinsic\n @cindex string manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Removes trailing blank characters of a string.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Transformational function\n \n @item @emph{Syntax}:\n+@code{RESULT = TRIM(STRING)}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{STRING} @tab Shall be a scalar of type @code{CHARACTER(*)}.\n+@end multitable\n+\n @item @emph{Return value}:\n+A scalar of type @code{CHARACTER(*)} which length is that of @var{STRING}\n+less the number of trailing blanks.\n+\n @item @emph{Example}:\n+@smallexample\n+PROGRAM test_trim\n+  CHARACTER(len=10), PARAMETER :: s = \"GFORTRAN  \"\n+  WRITE(*,*) LEN(s), LEN(TRIM(s))  ! \"10 8\", with/without trailing blanks\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{ADJUSTL}, @ref{ADJUSTR}\n @end table\n \n \n@@ -9446,22 +9638,49 @@ Transformational function\n @cindex @code{VERIFY} intrinsic\n @cindex string manipulation\n \n-Intrinsic implemented, documentation pending.\n-\n @table @asis\n @item @emph{Description}:\n+Verifies that all the characters in a @var{SET} are present in a @var{STRING}.\n+\n+If @var{BACK} is either absent or equals @code{FALSE}, this function\n+returns the position of the leftmost character of @var{STRING} that is\n+not in @var{SET}. If @var{BACK} equals @code{TRUE}, the rightmost position\n+is returned. If all characters of @var{SET} are found in @var{STRING}, the \n+result is zero.\n+\n @item @emph{Standard}:\n F95 and later\n \n @item @emph{Class}:\n Elemental function\n \n @item @emph{Syntax}:\n+@code{RESULT = VERFIY(STRING, SET[, BACK])}\n+\n @item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{STRING} @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{SET}    @tab Shall be of type @code{CHARACTER(*)}.\n+@item @var{BACK}   @tab (Optional) shall be of type @code{LOGICAL}.\n+@end multitable\n+\n @item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the default\n+integer kind.\n+\n @item @emph{Example}:\n-@item @emph{Specific names}:\n+@smallexample\n+PROGRAM test_verify\n+  WRITE(*,*) VERIFY(\"FORTRAN\", \"AO\")           ! 1, found 'F'\n+  WRITE(*,*) VERIFY(\"FORTRAN\", \"FOO\")          ! 3, found 'R'\n+  WRITE(*,*) VERIFY(\"FORTRAN\", \"C++\")          ! 1, found 'F'\n+  WRITE(*,*) VERIFY(\"FORTRAN\", \"C++\", .TRUE.)  ! 7, found 'N'\n+  WRITE(*,*) VERIFY(\"FORTRAN\", \"FORTRAN\")      ! 0' found none\n+END PROGRAM\n+@end smallexample\n+\n @item @emph{See also}:\n+@ref{SCAN}, @ref{INDEX}\n @end table\n \n "}]}