{"sha": "6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiOTQ2OWExNWFhYTAxN2E4ZDRjNzFmOTg5ZmFmZWYwMjBjYjBjMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-08-16T17:22:57Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-08-16T17:22:57Z"}, "message": "* gnu/xml/xpath/XPathParser.y: Removed.\n\nFrom-SVN: r103162", "tree": {"sha": "efcbdd5698d17c2030154742f1c7268a1e5b3ee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efcbdd5698d17c2030154742f1c7268a1e5b3ee2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab9469a15aaa017a8d4c71f989fafef020cb0c3/comments", "author": null, "committer": null, "parents": [{"sha": "33173fd40fa6fa47d85c9dfa169ad4dcb3916a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33173fd40fa6fa47d85c9dfa169ad4dcb3916a3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33173fd40fa6fa47d85c9dfa169ad4dcb3916a3b"}], "stats": {"total": 786, "additions": 4, "deletions": 782}, "files": [{"sha": "574d211adef7aff292449d60f9274e8ab1dda978", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab9469a15aaa017a8d4c71f989fafef020cb0c3/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab9469a15aaa017a8d4c71f989fafef020cb0c3/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6ab9469a15aaa017a8d4c71f989fafef020cb0c3", "patch": "@@ -1,3 +1,7 @@\n+2005-08-16  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gnu/xml/xpath/XPathParser.y: Removed.\n+\n 2005-08-12  Morgan Deters  <mdeters@morgandeters.com>\n \n \tPR libgcj/23353:"}, {"sha": "f8a60363b7fc300301a22239df2be83f1158ef44", "filename": "libjava/gnu/xml/xpath/XPathParser.y", "status": "removed", "additions": 0, "deletions": 782, "changes": 782, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33173fd40fa6fa47d85c9dfa169ad4dcb3916a3b/libjava%2Fgnu%2Fxml%2Fxpath%2FXPathParser.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33173fd40fa6fa47d85c9dfa169ad4dcb3916a3b/libjava%2Fgnu%2Fxml%2Fxpath%2FXPathParser.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fxml%2Fxpath%2FXPathParser.y?ref=33173fd40fa6fa47d85c9dfa169ad4dcb3916a3b", "patch": "@@ -1,782 +0,0 @@\n-%{\n-/* XPathParser.java -- An XPath 1.0 parser.\n-   Copyright (C) 2004 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package gnu.xml.xpath;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import javax.xml.namespace.NamespaceContext;\n-import javax.xml.namespace.QName;\n-import javax.xml.xpath.XPathFunctionResolver;\n-import javax.xml.xpath.XPathVariableResolver;\n-import org.w3c.dom.Node;\n-\n-/**\n- * An XPath 1.0 parser.\n- *\n- * @author <a href='mailto:dog@gnu.org'>Chris Burdess</a>\n- */\n-public class XPathParser\n-{\n-\n-  NamespaceContext namespaceContext;\n-  XPathVariableResolver variableResolver;\n-  XPathFunctionResolver functionResolver;\n-\n-  QName getQName(String name)\n-  {\n-    QName qName = QName.valueOf(name);\n-    if (namespaceContext != null)\n-      {\n-        String prefix = qName.getPrefix();\n-        String uri = qName.getNamespaceURI();\n-        if (prefix != null && (uri == null || uri.length() == 0))\n-          {\n-            uri = namespaceContext.getNamespaceURI(prefix);\n-            String localName = qName.getLocalPart();\n-            qName = new QName(uri, localName, prefix);\n-          }\n-      }\n-    return qName;\n-  }\n-\n-  Expr lookupFunction(String name, List args)\n-  {\n-    int arity = args.size();\n-    if (\"position\".equals(name) && arity == 0)\n-      {\n-        return new PositionFunction();\n-      }\n-    else if (\"last\".equals(name) && arity == 0)\n-      {\n-        return new LastFunction();\n-      }\n-    else if (\"string\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new StringFunction(args);\n-      }\n-    else if (\"number\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new NumberFunction(args);\n-      }\n-    else if (\"boolean\".equals(name) && arity == 1)\n-      {\n-        return new BooleanFunction(args);\n-      }\n-    else if (\"count\".equals(name) && arity == 1)\n-      {\n-        return new CountFunction(args);\n-      }\n-    else if (\"not\".equals(name) && arity == 1)\n-      {\n-        return new NotFunction(args);\n-      }\n-    else if (\"id\".equals(name) && arity == 1)\n-      {\n-        return new IdFunction(args);\n-      }\n-    else if (\"concat\".equals(name) && arity > 1)\n-      {\n-        return new ConcatFunction(args);\n-      }\n-    else if (\"true\".equals(name) && arity == 0)\n-      {\n-        return new TrueFunction();\n-      }\n-    else if (\"false\".equals(name) && arity == 0)\n-      {\n-        return new FalseFunction();\n-      }\n-    else if (\"name\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new NameFunction(args);\n-      }\n-    else if (\"local-name\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new LocalNameFunction(args);\n-      }\n-    else if (\"namespace-uri\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new NamespaceUriFunction(args);\n-      }\n-    else if (\"starts-with\".equals(name) && arity == 2)\n-      {\n-        return new StartsWithFunction(args);\n-      }\n-    else if (\"contains\".equals(name) && arity == 2)\n-      {\n-        return new ContainsFunction(args);\n-      }\n-    else if (\"string-length\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new StringLengthFunction(args);\n-      }\n-    else if (\"translate\".equals(name) && arity == 3)\n-      {\n-        return new TranslateFunction(args);\n-      }\n-    else if (\"normalize-space\".equals(name) && (arity == 1 || arity == 0))\n-      {\n-        return new NormalizeSpaceFunction(args);\n-      }\n-    else if (\"substring\".equals(name) && (arity == 2 || arity == 3))\n-      {\n-        return new SubstringFunction(args);\n-      }\n-    else if (\"substring-before\".equals(name) && arity == 2)\n-      {\n-        return new SubstringBeforeFunction(args);\n-      }\n-    else if (\"substring-after\".equals(name) && arity == 2)\n-      {\n-        return new SubstringAfterFunction(args);\n-      }\n-    else if (\"lang\".equals(name) && arity == 1)\n-      {\n-        return new LangFunction(args);\n-      }\n-    else if (\"sum\".equals(name) && arity == 1)\n-      {\n-        return new SumFunction(args);\n-      }\n-    else if (\"floor\".equals(name) && arity == 1)\n-      {\n-        return new FloorFunction(args);\n-      }\n-    else if (\"ceiling\".equals(name) && arity == 1)\n-      {\n-        return new CeilingFunction(args);\n-      }\n-    else if (\"round\".equals(name) && arity == 1)\n-      {\n-        return new RoundFunction(args);\n-      }\n-    else if (functionResolver != null)\n-      {\n-        QName qName = QName.valueOf(name);\n-        Object function = functionResolver.resolveFunction(qName, arity);\n-        if (function != null &&\n-            function instanceof Function &&\n-            function instanceof Expr)\n-          {\n-            Function f = (Function) function;\n-            f.setArguments(args);\n-            return (Expr) function;\n-          }\n-      }\n-    return new FunctionCall(functionResolver, name, args);\n-  }\n-\n-%}\n-\n-%token LITERAL\n-%token DIGITS\n-%token NAME\n-\n-%token LP // '('\n-%token RP // ')'\n-%token LB // '['\n-%token RB // ']'\n-%token COMMA // ','\n-%token PIPE // '|'\n-%token SLASH // '/'\n-%token DOUBLE_SLASH // '//'\n-%token EQ // '='\n-%token NE // '!='\n-%token GT // '>'\n-%token LT // '<'\n-%token GTE // '>='\n-%token LTE // '<='\n-%token PLUS // '+'\n-%token MINUS // '-'\n-%token AT // '@'\n-%token STAR // '*'\n-%token DOLLAR // '$'\n-%token COLON // ':'\n-%token DOUBLE_COLON // '::'\n-%token DOT // '.'\n-%token DOUBLE_DOT // '..'\n-\n-%token ANCESTOR\n-%token ANCESTOR_OR_SELF\n-%token ATTRIBUTE\n-%token CHILD\n-%token DESCENDANT\n-%token DESCENDANT_OR_SELF\n-%token FOLLOWING\n-%token FOLLOWING_SIBLING\n-%token NAMESPACE\n-%token PARENT\n-%token PRECEDING\n-%token PRECEDING_SIBLING\n-%token SELF\n-%token DIV\n-%token MOD\n-%token OR\n-%token AND\n-%token COMMENT\n-%token PROCESSING_INSTRUCTION\n-%token TEXT\n-%token NODE\n-\n-%right UNARY\n-\n-%start expr\n-\n-%%\n-\n-expr:\n-  or_expr\n-  ;\n-\n-location_path:\n-  relative_location_path\n-  | absolute_location_path\n-  ;\n-\n-absolute_location_path:\n-  SLASH\n-    {\n-      $$ = new Root();\n-    }\n-  | SLASH relative_location_path\n-    {\n-      Steps steps;\n-      if ($2 instanceof Steps)\n-        {\n-          steps = (Steps) $2;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($2);\n-        }\n-      steps.path.addFirst(new Root());\n-      $$ = steps;\n-      //$$ = new Step(new Root(), (Path) $2);\n-    }\n-  | DOUBLE_SLASH relative_location_path\n-    {\n-      Test nt = new NodeTypeTest((short) 0);\n-      Selector s = new Selector(Selector.DESCENDANT_OR_SELF,\n-                                Collections.singletonList (nt));\n-      Steps steps;\n-      if ($2 instanceof Steps)\n-        {\n-          steps = (Steps) $2;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($2);\n-        }\n-      steps.path.addFirst(s);\n-      steps.path.addFirst(new Root());\n-      $$ = steps;\n-      //Step step = new Step(s, (Path) $2);\n-      //$$ = new Step(new Root(), step);\n-    }\n-  ;\n-\n-relative_location_path:\n-  step\n-  | relative_location_path SLASH step\n-    {\n-      Steps steps;\n-      if ($1 instanceof Steps)\n-        {\n-          steps = (Steps) $1;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($1);\n-        }\n-      steps.path.addLast($3);\n-      $$ = steps;\n-      //$$ = new Step((Expr) $1, (Path) $3);\n-    }\n-  | relative_location_path DOUBLE_SLASH step\n-    {\n-      Test nt = new NodeTypeTest((short) 0);\n-      Selector s = new Selector(Selector.DESCENDANT_OR_SELF,\n-                                Collections.singletonList (nt));\n-      Steps steps;\n-      if ($1 instanceof Steps)\n-        {\n-          steps = (Steps) $1;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($1);\n-        }\n-      steps.path.addLast(s);\n-      steps.path.addLast($3);\n-      $$ = steps;\n-      //Step step = new Step(s, (Path) $3);\n-      //$$ = new Step((Expr) $1, step);\n-    }\n-  ;\n-\n-step:\n-  step_node_test\n-    {\n-      $$ = new Selector (Selector.CHILD, (List) $1);\n-    }\n-  | AT step_node_test\n-    {\n-      $$ = new Selector (Selector.ATTRIBUTE, (List) $2);\n-    }\n-  | axis_name DOUBLE_COLON step_node_test\n-    {\n-      $$ = new Selector (((Integer) $1).intValue (), (List) $3);\n-    }\n-  | DOT\n-    {\n-      $$ = new Selector (Selector.SELF, Collections.EMPTY_LIST);\n-    }\n-  | DOUBLE_DOT\n-    {\n-      $$ = new Selector (Selector.PARENT, Collections.EMPTY_LIST);\n-    }\n-  ;\n-\n-step_node_test:\n-  node_test\n-    {\n-      List list = new ArrayList();\n-      list.add($1);\n-      $$ = list;\n-    }\n-  | step_node_test predicate\n-    {\n-      List list = (List)$1;\n-      list.add($2);\n-      $$ = list;\n-    }\n-  ;\n-\n-/*predicate_list:\n-  predicate\n-    {\n-      List list = new ArrayList ();\n-      list.add ($1);\n-      $$ = list;\n-    }\n-  | predicate predicate_list\n-    {\n-      List list = (List) $3;\n-      list.add (0, $1);\n-      $$ = list;\n-    }\n-  ;*/\n-\n-axis_name:\n-  ANCESTOR\n-    {\n-      $$ = new Integer(Selector.ANCESTOR);\n-    }\n-  | ANCESTOR_OR_SELF\n-    {\n-      $$ = new Integer(Selector.ANCESTOR_OR_SELF);\n-    }\n-  | ATTRIBUTE\n-    {\n-      $$ = new Integer(Selector.ATTRIBUTE);\n-    }\n-  | CHILD\n-    {\n-      $$ = new Integer(Selector.CHILD);\n-    }\n-  | DESCENDANT\n-    {\n-      $$ = new Integer(Selector.DESCENDANT);\n-    }\n-  | DESCENDANT_OR_SELF\n-    {\n-      $$ = new Integer(Selector.DESCENDANT_OR_SELF);\n-    }\n-  | FOLLOWING\n-    {\n-      $$ = new Integer(Selector.FOLLOWING);\n-    }\n-  | FOLLOWING_SIBLING\n-    {\n-      $$ = new Integer(Selector.FOLLOWING_SIBLING);\n-    }\n-  | NAMESPACE\n-    {\n-      $$ = new Integer(Selector.NAMESPACE);\n-    }\n-  | PARENT\n-    {\n-      $$ = new Integer(Selector.PARENT);\n-    }\n-  | PRECEDING\n-    {\n-      $$ = new Integer(Selector.PRECEDING);\n-    }\n-  | PRECEDING_SIBLING\n-    {\n-      $$ = new Integer(Selector.PRECEDING_SIBLING);\n-    }\n-  | SELF\n-    {\n-      $$ = new Integer(Selector.SELF);\n-    }\n-  ;\n-\n-node_test:\n-  name_test\n-  /*| PROCESSING_INSTRUCTION LP LITERAL RP*/\n-  | PROCESSING_INSTRUCTION LITERAL RP\n-    {\n-      $$ = new NodeTypeTest(Node.PROCESSING_INSTRUCTION_NODE, (String) $2);\n-    }\n-  /*| node_type LP RP*/\n-  | node_type RP\n-    {\n-      $$ = new NodeTypeTest(((Short) $1).shortValue());\n-    }\n-  ;\n-\n-predicate:\n-  LB expr RB\n-    {\n-      $$ = new Predicate((Expr) $2);\n-    }\n-  ;\n-\n-primary_expr:\n-  variable_reference\n-  | LP expr RP\n-    {\n-      $$ = new ParenthesizedExpr((Expr) $2);\n-    }\n-  | LITERAL\n-    {\n-      $$ = new Constant($1);\n-    }\n-  | number\n-    {\n-      $$ = new Constant($1);\n-    }\n-  | function_call\n-  ;\n-\n-function_call:\n-  function_name LP RP\n-    {\n-      $$ = lookupFunction((String) $1, Collections.EMPTY_LIST);\n-    }\n-  | function_name LP argument_list RP\n-    {\n-      $$ = lookupFunction((String) $1, (List) $3);\n-    }\n-  ;\n-\n-argument_list:\n-  expr\n-    {\n-      List list = new ArrayList();\n-      list.add($1);\n-      $$ = list;\n-    }\n-  | expr COMMA argument_list\n-    {\n-      List list = (List) $3;\n-      list.add(0, $1);\n-      $$ = list;\n-    }\n-  ;\n-\n-union_expr:\n-  path_expr\n-  | union_expr PIPE path_expr\n-    {\n-      $$ = new UnionExpr((Expr) $1, (Expr) $3);\n-    }\n-  ;\n-\n-path_expr:\n-  location_path\n-  | filter_expr\n-  | filter_expr SLASH relative_location_path\n-    {\n-      Steps steps;\n-      if ($3 instanceof Steps)\n-        {\n-          steps = (Steps) $3;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($3);\n-        }\n-      steps.path.addFirst($1);\n-      $$ = steps;\n-      //$$ = new Step ((Expr) $1, (Path) $3);\n-    }\n-  | filter_expr DOUBLE_SLASH relative_location_path\n-    {\n-      Test nt = new NodeTypeTest((short) 0);\n-      Selector s = new Selector(Selector.DESCENDANT_OR_SELF,\n-                                Collections.singletonList(nt));\n-      Steps steps;\n-      if ($3 instanceof Steps)\n-        {\n-          steps = (Steps) $3;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($3);\n-        }\n-      steps.path.addFirst(s);\n-      steps.path.addFirst($1);\n-      $$ = steps;\n-      //Step step = new Step (s, (Path) $3);\n-      //$$ = new Step ((Expr) $1, step);\n-    }\n-  ;\n-\n-filter_expr:\n-  primary_expr\n-  | filter_expr predicate\n-    {\n-      Predicate filter = (Predicate) $2;\n-      Selector s = new Selector(Selector.SELF,\n-                                Collections.singletonList(filter));\n-      Steps steps;\n-      if ($1 instanceof Steps)\n-        {\n-          steps = (Steps) $1;\n-        }\n-      else\n-        {\n-          steps = new Steps();\n-          steps.path.addFirst($1);\n-        }\n-      steps.path.addLast(s);\n-      $$ = steps;\n-      //$$ = new Step ((Expr) $1, s);\n-    }\n-  ;\n-\n-or_expr:\n-  and_expr\n-  | or_expr OR and_expr\n-    {\n-      $$ = new OrExpr((Expr) $1, (Expr) $3);\n-    }\n-  ;\n-\n-and_expr:\n-  equality_expr\n-  | and_expr AND equality_expr\n-    {\n-      $$ = new AndExpr((Expr) $1, (Expr) $3);\n-    }\n-  ;\n-\n-equality_expr:\n-  relational_expr\n-  | equality_expr EQ relational_expr\n-    {\n-      $$ = new EqualityExpr((Expr) $1, (Expr) $3, false);\n-    }\n-  | equality_expr NE relational_expr\n-    {\n-      $$ = new EqualityExpr((Expr) $1, (Expr) $3, true);\n-    }\n-  ;\n-\n-relational_expr:\n-  additive_expr\n-  | relational_expr LT additive_expr\n-    {\n-      $$ = new RelationalExpr((Expr) $1, (Expr) $3, true, false);\n-    }\n-  | relational_expr GT additive_expr\n-    {\n-      $$ = new RelationalExpr((Expr) $1, (Expr) $3, false, false);\n-    }\n-  | relational_expr LTE additive_expr\n-    {\n-      $$ = new RelationalExpr((Expr) $1, (Expr) $3, true, true);\n-    }\n-  | relational_expr GTE additive_expr\n-    {\n-      $$ = new RelationalExpr((Expr) $1, (Expr) $3, false, true);\n-    }\n-  ;\n-\n-additive_expr:\n-  multiplicative_expr\n-  | additive_expr PLUS multiplicative_expr\n-    {\n-      $$ = new ArithmeticExpr((Expr) $1, (Expr) $3, ArithmeticExpr.ADD);\n-    }\n-  | additive_expr MINUS multiplicative_expr\n-    {\n-      $$ = new ArithmeticExpr((Expr) $1, (Expr) $3, ArithmeticExpr.SUBTRACT);\n-    }\n-  ;\n-\n-multiplicative_expr:\n-  unary_expr\n-  | multiplicative_expr STAR unary_expr\n-    {\n-      $$ = new ArithmeticExpr((Expr) $1, (Expr) $3, ArithmeticExpr.MULTIPLY);\n-    }\n-  | multiplicative_expr DIV unary_expr\n-    {\n-      $$ = new ArithmeticExpr((Expr) $1, (Expr) $3, ArithmeticExpr.DIVIDE);\n-    }\n-  | multiplicative_expr MOD unary_expr\n-    {\n-      $$ = new ArithmeticExpr((Expr) $1, (Expr) $3, ArithmeticExpr.MODULO);\n-    }\n-  ;\n-\n-unary_expr:\n-  union_expr\n-  | MINUS unary_expr %prec UNARY\n-    {\n-      $$ = new NegativeExpr((Expr) $2);\n-    }\n-  ;\n-\n-number:\n-  DIGITS\n-    {\n-      $$ = new Double((String) $1 + \".0\");\n-    }\n-  | DIGITS DOT\n-    {\n-      $$ = new Double((String) $1 + \".0\");\n-    }\n-  | DIGITS DOT DIGITS\n-    {\n-      $$ = new Double((String) $1 + \".\" + (String) $3);\n-    }\n-  | DOT DIGITS\n-    {\n-      $$ = new Double(\"0.\" + (String) $2);\n-    }\n-  ;\n-\n-function_name:\n-  qname\n-/*  | node_type\n-    {\n-      switch (((Short) $1).shortValue ())\n-        {\n-        case Node.COMMENT_NODE:\n-          $$ = \"comment\";\n-          break;\n-        case Node.TEXT_NODE:\n-          $$ = \"text\";\n-          break;\n-        case Node.PROCESSING_INSTRUCTION_NODE:\n-          $$ = \"processing-instruction\";\n-          break;\n-        default:\n-          $$ = \"node\";\n-          break;\n-        }\n-    }*/\n-  ;\n-\n-variable_reference:\n-  DOLLAR qname\n-    {\n-      $$ = new VariableReference(variableResolver, (String) $2);\n-    }\n-  ;\n-\n-name_test:\n-  STAR\n-    {\n-      $$ = new NameTest(null, true, true);\n-    }\n-  | NAME COLON STAR\n-    {\n-      QName qName = getQName((String) $1);\n-      $$ = new NameTest(qName, true, false);\n-    }\n-  | qname\n-    {\n-      QName qName = getQName((String) $1);\n-      $$ = new NameTest(qName, false, false);\n-    }\n-  ;\n-\n-qname:\n-  NAME\n-  | NAME COLON NAME\n-    {\n-      $$ = (String) $1 + ':' + (String) $3;\n-    }\n-  ;\n-\n-node_type:\n-  COMMENT\n-    {\n-      $$ = new Short(Node.COMMENT_NODE);\n-    }\n-  | TEXT\n-    {\n-      $$ = new Short(Node.TEXT_NODE);\n-    }\n-  | PROCESSING_INSTRUCTION\n-    {\n-      $$ = new Short(Node.PROCESSING_INSTRUCTION_NODE);\n-    }\n-  | NODE\n-    {\n-      $$ = new Short((short) 0);\n-    }\n-  ;\n-\n-%%\n-\n-}"}]}