{"sha": "2c0fa3ecf70d199af18785702e9e0548fd3ab793", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMwZmEzZWNmNzBkMTk5YWYxODc4NTcwMmU5ZTA1NDhmZDNhYjc5Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-04-02T12:28:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-04-02T12:28:14Z"}, "message": "cselib: Reuse VALUEs on sp adjustments [PR92264]\n\nAs discussed in the PR, if !ACCUMULATE_OUTGOING_ARGS on large functions we\ncan have hundreds of thousands of stack pointer adjustments and cselib\ncreates a new VALUE after each sp adjustment, which form extremely deep\nVALUE chains, which is very harmful e.g. for find_base_term.\nE.g. if we have\nsp -= 4\nsp -= 4\nsp += 4\nsp += 4\nsp -= 4\nsp += 4\nthat means 7 VALUEs, one for the sp at beginning (val1), than val2 = val1 -\n4, then val3 = val2 - 4, then val4 = val3 + 4, then val5 = val4 + 4, then\nval6 = val5 - 4, then val7 = val6 + 4.\nThis patch tweaks cselib, so that it is smarter about sp adjustments.\nWhen cselib_lookup (stack_pointer_rtx, Pmode, 1, VOIDmode) and we know\nnothing about sp yet (this happens at the start of the function, for\nnon-var-tracking also after cselib_reset_table and for var-tracking after\nprocessing fp_setter insn where we forget about former sp values because\nthat is now hfp related while everything after it is sp related), we\nlook it up normally, but in addition to what we have been doing before\nwe mark the VALUE as SP_DERIVED_VALUE_P.  Further lookups of sp + offset\nare then special cased, so that it is canonicalized to that\nSP_DERIVED_VALUE_P VALUE + CONST_INT (if possible).  So, for the above,\nwe get val1 with SP_DERIVED_VALUE_P set, then val2 = val1 - 4, val3 = val1 -\n8 (note, no longer val2 - 4!), then we get val2 again, val1 again, val2\nagain, val1 again.\nIn the find_base_term visited_vals.length () > 100 find_base_term\nstatistics during combined x86_64-linux and i686-linux bootstrap+regtest\ncycle, without the patch I see:\n\t\t\tfind_base_term > 100\n\t\t\treturning NULL\treturning non-NULL\n32-bit compilations\t4229178\t\t407\n64-bit compilations\t217523\t\t0\nwith largest visited_vals.length () when returning non-NULL being 206.\nWith the patch the same numbers are:\n32-bit compilations\t1249588\t\t135\n64-bit compilations\t3510\t\t0\nwith largest visited_vals.length () when returning non-NULL being 173.\nThis shows significant reduction of the deep VALUE chains.\nOn powerpc64{,le}-linux, these stats didn't change at all, we have\n\t\t\t1008\t\t0\nfor all of -m32, -m64 and little-endian -m64, just the\ngcc.dg/pr85180.c and gcc.dg/pr87985.c testcases which are unrelated to sp.\n\nMy earlier version of the patch, which contained just the rtl.h and cselib.c\nchanges, regressed some tests:\ngcc.dg/guality/{pr36728-{1,3},pr68860-{1,2}}.c\ngcc.target/i386/{pr88416,sse-{13,23,24,25,26}}.c\nThe problem with the former tests was worse debug info, where with -m32\nwhere arg7 was passed in a stack slot we though a push later on might have\ninvalidated it, when it couldn't.  This is something I've solved with the\nvar-tracking.c (vt_initialize) changes.  In those problematic functions, we\ncreate a cfa_base VALUE (argp) and want to record that at the start of\nthe function the argp VALUE is sp + off and also record that current sp\nVALUE is argp's VALUE - off.  The second permanent equivalence didn't make\nit after the patch though, because cselib_add_permanent_equiv will\ncselib_lookup the value of the expression it wants to add as the equivalence\nand if it is the same VALUE as we are calling it on, it doesn't do anything;\nand due to the cselib changes for sp based accesses that is exactly what\nhappened.  By reversing the order of the cselib_add_permanent_equiv calls we\nget both equivalences though and thus are able to canonicalize the sp based\naccesses in var-tracking to the cfa_base value + offset.\nThe i386 FAILs were all ICEs, where we had pushf instruction pushing flags\nand then pop pseudo reading that value again.  With the cselib changes,\ncselib during RTL DSE is able to see through the sp adjustment and wanted\nto replace_read what was done pushf, by moving the flags register into a\npseudo and replace the memory read in the pop with that pseudo.  That is\nwrong for two reasons: one is that the backend doesn't have an instruction\nto move the flags hard register into some other register, but replace_read\nhas been validating just the mem -> pseudo replacement and not the insns\nemitted by copy_to_mode_reg.  And the second issue is that it is obviously\nwrong to replace a stack pop which contains stack post-increment by a copy\nof pseudo into destination.  dse.c has some code to handle RTX_AUTOINC, but\nonly uses it when actually removing stores and only when there is REG_INC\nnote (stack RTX_AUTOINC does not have those), in check_for_inc_dec* where\nit emits the reg adjustment(s) before the insn that is going to be deleted.\nreplace_read doesn't remove the insn, so if it e.g. contained REG_INC note,\nit would be kept there and we might have the RTX_AUTOINC not just in *loc,\nbut other spots.\nSo, the dse.c changes try to validate the added insns and punt on all\nRTX_AUTOINC in *loc.  Furthermore, it seems that with the cselib.c changes\non the gfortran.dg/pr87360.f90 and gcc.target/i386/pr88416.c testcases\ncheck_for_inc_dec{,_1} happily throws stack pointer autoinc on the floor,\nwhich is also wrong.  While we could perhaps do the for_each_inc_dec\ncall regardless of whether we have REG_INC note or not, we aren't prepared\nto handle e.g. REG_ARGS_SIZE distribution and thus could end up with wrong\nunwind info or ICEs during dwarf2cfi.c.  So the patch also punts on those,\nafter all, if we'd in theory managed to try to optimize such pushes before,\nwe'd create wrong-code.\n\nOn x86_64-linux and i686-linux, the patch has some minor debug info coverage\ndifferences, but it doesn't appear very significant to me.\nhttps://github.com/pmachata/dwlocstat tool gives (where before is vanilla\ntrunk + the rtl.h patch but not {cselib,var-tracking,dse}.c\n--enable-checking=yes,rtl,extra bootstrapped, then {cselib,var-tracking,dse}.c\nhunks applied and make cc1plus, while after is trunk with the whole patch\napplied).\n\n64-bit cc1plus\nbefore\ncov%\tsamples\tcumul\n0..10\t1232756/48%\t1232756/48%\n11..20\t31089/1%\t1263845/49%\n21..30\t39172/1%\t1303017/51%\n31..40\t38853/1%\t1341870/52%\n41..50\t47473/1%\t1389343/54%\n51..60\t45171/1%\t1434514/56%\n61..70\t69393/2%\t1503907/59%\n71..80\t61988/2%\t1565895/61%\n81..90\t104528/4%\t1670423/65%\n91..100\t875402/34%\t2545825/100%\nafter\ncov%\tsamples\tcumul\n0..10\t1233238/48%\t1233238/48%\n11..20\t31086/1%\t1264324/49%\n21..30\t39157/1%\t1303481/51%\n31..40\t38819/1%\t1342300/52%\n41..50\t47447/1%\t1389747/54%\n51..60\t45151/1%\t1434898/56%\n61..70\t69379/2%\t1504277/59%\n71..80\t61946/2%\t1566223/61%\n81..90\t104508/4%\t1670731/65%\n91..100\t875094/34%\t2545825/100%\n\n32-bit cc1plus\nbefore\ncov%\tsamples\tcumul\n0..10\t1231221/48%\t1231221/48%\n11..20\t30992/1%\t1262213/49%\n21..30\t36422/1%\t1298635/51%\n31..40\t35793/1%\t1334428/52%\n41..50\t47102/1%\t1381530/54%\n51..60\t41201/1%\t1422731/56%\n61..70\t65467/2%\t1488198/58%\n71..80\t59560/2%\t1547758/61%\n81..90\t104076/4%\t1651834/65%\n91..100\t881879/34%\t2533713/100%\nafter\ncov%\tsamples\tcumul\n0..10\t1230469/48%\t1230469/48%\n11..20\t30390/1%\t1260859/49%\n21..30\t36362/1%\t1297221/51%\n31..40\t36042/1%\t1333263/52%\n41..50\t47619/1%\t1380882/54%\n51..60\t41674/1%\t1422556/56%\n61..70\t65849/2%\t1488405/58%\n71..80\t59857/2%\t1548262/61%\n81..90\t104178/4%\t1652440/65%\n91..100\t881273/34%\t2533713/100%\n\n2020-04-02  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/92264\n\t* rtl.h (struct rtx_def): Mention that call bit is used as\n\tSP_DERIVED_VALUE_P in cselib.c.\n\t* cselib.c (SP_DERIVED_VALUE_P): Define.\n\t(PRESERVED_VALUE_P, SP_BASED_VALUE_P): Move definitions earlier.\n\t(cselib_hasher::equal): Handle equality between SP_DERIVED_VALUE_P\n\tval_rtx and sp based expression where offsets cancel each other.\n\t(preserve_constants_and_equivs): Formatting fix.\n\t(cselib_reset_table): Add reverse op loc to SP_DERIVED_VALUE_P\n\tlocs list for cfa_base_preserved_val if needed.  Formatting fix.\n\t(autoinc_split): If the to be returned value is a REG, MEM or\n\tVALUE which has SP_DERIVED_VALUE_P + CONST_INT as one of its\n\tlocs, return the SP_DERIVED_VALUE_P VALUE and adjust *off.\n\t(rtx_equal_for_cselib_1): Call autoinc_split even if both\n\texpressions are PLUS in Pmode with CONST_INT second operands.\n\tHandle SP_DERIVED_VALUE_P cases.\n\t(cselib_hash_plus_const_int): New function.\n\t(cselib_hash_rtx): Use it for PLUS in Pmode with CONST_INT\n\tsecond operand, as well as for PRE_DEC etc. that ought to be\n\thashed the same way.\n\t(cselib_subst_to_values): Substitute PLUS with Pmode and\n\tCONST_INT operand if the first operand is a VALUE which has\n\tSP_DERIVED_VALUE_P + CONST_INT as one of its locs for the\n\tSP_DERIVED_VALUE_P + adjusted offset.\n\t(cselib_lookup_1): When creating a new VALUE for stack_pointer_rtx,\n\tset SP_DERIVED_VALUE_P on it.  Set PRESERVED_VALUE_P when adding\n\tSP_DERIVED_VALUE_P PRESERVED_VALUE_P subseted VALUE location.\n\t* var-tracking.c (vt_initialize): Call cselib_add_permanent_equiv\n\ton the sp value before calling cselib_add_permanent_equiv on the\n\tcfa_base value.\n\t* dse.c (check_for_inc_dec_1, check_for_inc_dec): Punt on RTX_AUTOINC\n\tin the insn without REG_INC note.\n\t(replace_read): Punt on RTX_AUTOINC in the *loc being replaced.\n\tPunt on invalid insns added by copy_to_mode_reg.  Formatting fixes.", "tree": {"sha": "49298a052a770de461f6e07eb0f9fb66095b1f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49298a052a770de461f6e07eb0f9fb66095b1f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c0fa3ecf70d199af18785702e9e0548fd3ab793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c0fa3ecf70d199af18785702e9e0548fd3ab793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c0fa3ecf70d199af18785702e9e0548fd3ab793", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c0fa3ecf70d199af18785702e9e0548fd3ab793/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df562b12d90699c20923f91df48eed08ebcb572e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df562b12d90699c20923f91df48eed08ebcb572e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df562b12d90699c20923f91df48eed08ebcb572e"}], "stats": {"total": 352, "additions": 310, "deletions": 42}, "files": [{"sha": "fe52459f601cdaf2778c19e15efd9d05e9d3fd46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c0fa3ecf70d199af18785702e9e0548fd3ab793", "patch": "@@ -1,5 +1,40 @@\n 2020-04-02  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR rtl-optimization/92264\n+\t* rtl.h (struct rtx_def): Mention that call bit is used as\n+\tSP_DERIVED_VALUE_P in cselib.c.\n+\t* cselib.c (SP_DERIVED_VALUE_P): Define.\n+\t(PRESERVED_VALUE_P, SP_BASED_VALUE_P): Move definitions earlier.\n+\t(cselib_hasher::equal): Handle equality between SP_DERIVED_VALUE_P\n+\tval_rtx and sp based expression where offsets cancel each other.\n+\t(preserve_constants_and_equivs): Formatting fix.\n+\t(cselib_reset_table): Add reverse op loc to SP_DERIVED_VALUE_P\n+\tlocs list for cfa_base_preserved_val if needed.  Formatting fix.\n+\t(autoinc_split): If the to be returned value is a REG, MEM or\n+\tVALUE which has SP_DERIVED_VALUE_P + CONST_INT as one of its\n+\tlocs, return the SP_DERIVED_VALUE_P VALUE and adjust *off.\n+\t(rtx_equal_for_cselib_1): Call autoinc_split even if both\n+\texpressions are PLUS in Pmode with CONST_INT second operands.\n+\tHandle SP_DERIVED_VALUE_P cases.\n+\t(cselib_hash_plus_const_int): New function.\n+\t(cselib_hash_rtx): Use it for PLUS in Pmode with CONST_INT\n+\tsecond operand, as well as for PRE_DEC etc. that ought to be\n+\thashed the same way.\n+\t(cselib_subst_to_values): Substitute PLUS with Pmode and\n+\tCONST_INT operand if the first operand is a VALUE which has\n+\tSP_DERIVED_VALUE_P + CONST_INT as one of its locs for the\n+\tSP_DERIVED_VALUE_P + adjusted offset.\n+\t(cselib_lookup_1): When creating a new VALUE for stack_pointer_rtx,\n+\tset SP_DERIVED_VALUE_P on it.  Set PRESERVED_VALUE_P when adding\n+\tSP_DERIVED_VALUE_P PRESERVED_VALUE_P subseted VALUE location.\n+\t* var-tracking.c (vt_initialize): Call cselib_add_permanent_equiv\n+\ton the sp value before calling cselib_add_permanent_equiv on the\n+\tcfa_base value.\n+\t* dse.c (check_for_inc_dec_1, check_for_inc_dec): Punt on RTX_AUTOINC\n+\tin the insn without REG_INC note.\n+\t(replace_read): Punt on RTX_AUTOINC in the *loc being replaced.\n+\tPunt on invalid insns added by copy_to_mode_reg.  Formatting fixes.\n+\n \tPR target/94435\n \t* config/aarch64/aarch64.c (aarch64_gen_compare_reg_maybe_ze): For\n \ty_mode E_[QH]Imode and y being a CONST_INT, change y_mode to SImode."}, {"sha": "507898ed1e8361edbdaefb6780b50ab7d10f8c14", "filename": "gcc/cselib.c", "status": "modified", "additions": 206, "deletions": 29, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=2c0fa3ecf70d199af18785702e9e0548fd3ab793", "patch": "@@ -58,6 +58,16 @@ static void cselib_invalidate_regno (unsigned int, machine_mode);\n static void cselib_invalidate_mem (rtx);\n static void cselib_record_set (rtx, cselib_val *, cselib_val *);\n static void cselib_record_sets (rtx_insn *);\n+static rtx autoinc_split (rtx, rtx *, machine_mode);\n+\n+#define PRESERVED_VALUE_P(RTX) \\\n+  (RTL_FLAG_CHECK1 (\"PRESERVED_VALUE_P\", (RTX), VALUE)->unchanging)\n+\n+#define SP_BASED_VALUE_P(RTX) \\\n+  (RTL_FLAG_CHECK1 (\"SP_BASED_VALUE_P\", (RTX), VALUE)->jump)\n+\n+#define SP_DERIVED_VALUE_P(RTX) \\\n+  (RTL_FLAG_CHECK1 (\"SP_DERIVED_VALUE_P\", (RTX), VALUE)->call)\n \n struct expand_value_data\n {\n@@ -122,6 +132,13 @@ cselib_hasher::equal (const cselib_val *v, const key *x_arg)\n   if (GET_CODE (x) == VALUE)\n     return x == v->val_rtx;\n \n+  if (SP_DERIVED_VALUE_P (v->val_rtx) && GET_MODE (x) == Pmode)\n+    {\n+      rtx xoff = NULL;\n+      if (autoinc_split (x, &xoff, memmode) == v->val_rtx && xoff == NULL_RTX)\n+\treturn true;\n+    }\n+\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n@@ -256,12 +273,6 @@ void (*cselib_discard_hook) (cselib_val *);\n void (*cselib_record_sets_hook) (rtx_insn *insn, struct cselib_set *sets,\n \t\t\t\t int n_sets);\n \n-#define PRESERVED_VALUE_P(RTX) \\\n-  (RTL_FLAG_CHECK1 (\"PRESERVED_VALUE_P\", (RTX), VALUE)->unchanging)\n-\n-#define SP_BASED_VALUE_P(RTX) \\\n-  (RTL_FLAG_CHECK1 (\"SP_BASED_VALUE_P\", (RTX), VALUE)->jump)\n-\n \f\n \n /* Allocate a struct elt_list and fill in its two elements with the\n@@ -494,7 +505,7 @@ preserve_constants_and_equivs (cselib_val **x, void *info ATTRIBUTE_UNUSED)\n       };\n       cselib_val **slot\n \t= cselib_preserved_hash_table->find_slot_with_hash (&lookup,\n-\t\t\t\t\t\t\t   v->hash, INSERT);\n+\t\t\t\t\t\t\t    v->hash, INSERT);\n       gcc_assert (!*slot);\n       *slot = v;\n     }\n@@ -532,6 +543,28 @@ cselib_reset_table (unsigned int num)\n       max_value_regs\n \t= hard_regno_nregs (regno,\n \t\t\t    GET_MODE (cfa_base_preserved_val->locs->loc));\n+\n+      /* If cfa_base is sp + const_int, need to preserve also the\n+\t SP_DERIVED_VALUE_P value.  */\n+      for (struct elt_loc_list *l = cfa_base_preserved_val->locs;\n+\t   l; l = l->next)\n+\tif (GET_CODE (l->loc) == PLUS\n+\t    && GET_CODE (XEXP (l->loc, 0)) == VALUE\n+\t    && SP_DERIVED_VALUE_P (XEXP (l->loc, 0))\n+\t    && CONST_INT_P (XEXP (l->loc, 1)))\n+\t  {\n+\t    if (! invariant_or_equiv_p (CSELIB_VAL_PTR (XEXP (l->loc, 0))))\n+\t      {\n+\t\trtx val = cfa_base_preserved_val->val_rtx;\n+\t\trtx_insn *save_cselib_current_insn = cselib_current_insn;\n+\t\tcselib_current_insn = l->setting_insn;\n+\t\tnew_elt_loc_list (CSELIB_VAL_PTR (XEXP (l->loc, 0)),\n+\t\t\t\t  plus_constant (Pmode, val,\n+\t\t\t\t\t\t -UINTVAL (XEXP (l->loc, 1))));\n+\t\tcselib_current_insn = save_cselib_current_insn;\n+\t      }\n+\t    break;\n+\t  }\n     }\n   else\n     {\n@@ -541,8 +574,7 @@ cselib_reset_table (unsigned int num)\n     }\n \n   if (cselib_preserve_constants)\n-    cselib_hash_table->traverse <void *, preserve_constants_and_equivs>\n-      (NULL);\n+    cselib_hash_table->traverse <void *, preserve_constants_and_equivs> (NULL);\n   else\n     {\n       cselib_hash_table->empty ();\n@@ -799,33 +831,66 @@ autoinc_split (rtx x, rtx *off, machine_mode memmode)\n     {\n     case PLUS:\n       *off = XEXP (x, 1);\n-      return XEXP (x, 0);\n+      x = XEXP (x, 0);\n+      break;\n \n     case PRE_DEC:\n       if (memmode == VOIDmode)\n \treturn x;\n \n       *off = gen_int_mode (-GET_MODE_SIZE (memmode), GET_MODE (x));\n-      return XEXP (x, 0);\n+      x = XEXP (x, 0);\n+      break;\n \n     case PRE_INC:\n       if (memmode == VOIDmode)\n \treturn x;\n \n       *off = gen_int_mode (GET_MODE_SIZE (memmode), GET_MODE (x));\n-      return XEXP (x, 0);\n+      x = XEXP (x, 0);\n+      break;\n \n     case PRE_MODIFY:\n-      return XEXP (x, 1);\n+      x = XEXP (x, 1);\n+      break;\n \n     case POST_DEC:\n     case POST_INC:\n     case POST_MODIFY:\n-      return XEXP (x, 0);\n+      x = XEXP (x, 0);\n+      break;\n \n     default:\n-      return x;\n+      break;\n+    }\n+\n+  if (GET_MODE (x) == Pmode\n+      && (REG_P (x) || MEM_P (x) || GET_CODE (x) == VALUE)\n+      && (*off == NULL_RTX || CONST_INT_P (*off)))\n+    {\n+      cselib_val *e;\n+      if (GET_CODE (x) == VALUE)\n+\te = CSELIB_VAL_PTR (x);\n+      else\n+\te = cselib_lookup (x, GET_MODE (x), 0, memmode);\n+      if (e)\n+\tfor (struct elt_loc_list *l = e->locs; l; l = l->next)\n+\t  if (GET_CODE (l->loc) == PLUS\n+\t      && GET_CODE (XEXP (l->loc, 0)) == VALUE\n+\t      && SP_DERIVED_VALUE_P (XEXP (l->loc, 0))\n+\t      && CONST_INT_P (XEXP (l->loc, 1)))\n+\t    {\n+\t      if (*off == NULL_RTX)\n+\t\t*off = XEXP (l->loc, 1);\n+\t      else\n+\t\t*off = plus_constant (Pmode, *off,\n+\t\t\t\t      INTVAL (XEXP (l->loc, 1)));\n+\t      if (*off == const0_rtx)\n+\t\t*off = NULL_RTX;\n+\t      return XEXP (l->loc, 0);\n+\t    }\n     }\n+  return x;\n }\n \n /* Return nonzero if we can prove that X and Y contain the same value,\n@@ -868,6 +933,16 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n       if (GET_CODE (y) == VALUE)\n \treturn e == canonical_cselib_val (CSELIB_VAL_PTR (y));\n \n+      if ((SP_DERIVED_VALUE_P (x)\n+\t   || SP_DERIVED_VALUE_P (e->val_rtx))\n+\t  && GET_MODE (y) == Pmode)\n+\t{\n+\t  rtx yoff = NULL;\n+\t  rtx yr = autoinc_split (y, &yoff, memmode);\n+\t  if ((yr == x || yr == e->val_rtx) && yoff == NULL_RTX)\n+\t    return 1;\n+\t}\n+\n       if (depth == 128)\n \treturn 0;\n \n@@ -891,6 +966,16 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n       cselib_val *e = canonical_cselib_val (CSELIB_VAL_PTR (y));\n       struct elt_loc_list *l;\n \n+      if ((SP_DERIVED_VALUE_P (y)\n+\t   || SP_DERIVED_VALUE_P (e->val_rtx))\n+\t  && GET_MODE (x) == Pmode)\n+\t{\n+\t  rtx xoff = NULL;\n+\t  rtx xr = autoinc_split (x, &xoff, memmode);\n+\t  if ((xr == y || xr == e->val_rtx) && xoff == NULL_RTX)\n+\t    return 1;\n+\t}\n+\n       if (depth == 128)\n \treturn 0;\n \n@@ -910,25 +995,32 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  if (GET_CODE (x) != GET_CODE (y))\n+  if (GET_CODE (x) != GET_CODE (y)\n+      || (GET_CODE (x) == PLUS\n+\t  && GET_MODE (x) == Pmode\n+\t  && CONST_INT_P (XEXP (x, 1))\n+\t  && CONST_INT_P (XEXP (y, 1))))\n     {\n       rtx xorig = x, yorig = y;\n       rtx xoff = NULL, yoff = NULL;\n \n       x = autoinc_split (x, &xoff, memmode);\n       y = autoinc_split (y, &yoff, memmode);\n \n-      if (!xoff != !yoff)\n-\treturn 0;\n-\n-      if (xoff && !rtx_equal_for_cselib_1 (xoff, yoff, memmode, depth))\n-\treturn 0;\n-\n       /* Don't recurse if nothing changed.  */\n       if (x != xorig || y != yorig)\n-\treturn rtx_equal_for_cselib_1 (x, y, memmode, depth);\n+\t{\n+\t  if (!xoff != !yoff)\n+\t    return 0;\n \n-      return 0;\n+\t  if (xoff && !rtx_equal_for_cselib_1 (xoff, yoff, memmode, depth))\n+\t    return 0;\n+\n+\t  return rtx_equal_for_cselib_1 (x, y, memmode, depth);\n+\t}\n+\n+      if (GET_CODE (xorig) != GET_CODE (yorig))\n+\treturn 0;\n     }\n \n   /* These won't be handled correctly by the code below.  */\n@@ -1042,6 +1134,41 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n   return 1;\n }\n \n+/* Helper function for cselib_hash_rtx.  Arguments like for cselib_hash_rtx,\n+   except that it hashes (plus:P x c).  */\n+\n+static unsigned int\n+cselib_hash_plus_const_int (rtx x, HOST_WIDE_INT c, int create,\n+\t\t\t    machine_mode memmode)\n+{\n+  cselib_val *e = cselib_lookup (x, GET_MODE (x), create, memmode);\n+  if (! e)\n+    return 0;\n+\n+  if (! SP_DERIVED_VALUE_P (e->val_rtx))\n+    for (struct elt_loc_list *l = e->locs; l; l = l->next)\n+      if (GET_CODE (l->loc) == PLUS\n+\t  && GET_CODE (XEXP (l->loc, 0)) == VALUE\n+\t  && SP_DERIVED_VALUE_P (XEXP (l->loc, 0))\n+\t  && CONST_INT_P (XEXP (l->loc, 1)))\n+\t{\n+\t  e = CSELIB_VAL_PTR (XEXP (l->loc, 0));\n+\t  c = trunc_int_for_mode (c + UINTVAL (XEXP (l->loc, 1)), Pmode);\n+\t  break;\n+\t}\n+  if (c == 0)\n+    return e->hash;\n+\n+  unsigned hash = (unsigned) PLUS + (unsigned) GET_MODE (x);\n+  hash += e->hash;\n+  unsigned int tem_hash = (unsigned) CONST_INT + (unsigned) VOIDmode;\n+  tem_hash += ((unsigned) CONST_INT << 7) + (unsigned HOST_WIDE_INT) c;\n+  if (tem_hash == 0)\n+    tem_hash = (unsigned int) CONST_INT;\n+  hash += tem_hash;\n+  return hash ? hash : 1 + (unsigned int) PLUS;\n+}\n+\n /* Hash an rtx.  Return 0 if we couldn't hash the rtx.\n    For registers and memory locations, we look up their cselib_val structure\n    and return its VALUE element.\n@@ -1209,10 +1336,21 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n \toffset = -offset;\n       /* Adjust the hash so that (mem:MEMMODE (pre_* (reg))) hashes\n \t like (mem:MEMMODE (plus (reg) (const_int I))).  */\n-      hash += (unsigned) PLUS - (unsigned)code\n-\t+ cselib_hash_rtx (XEXP (x, 0), create, memmode)\n-\t+ cselib_hash_rtx (gen_int_mode (offset, GET_MODE (x)),\n-\t\t\t   create, memmode);\n+      if (GET_MODE (x) == Pmode\n+\t  && (REG_P (XEXP (x, 0))\n+\t      || MEM_P (XEXP (x, 0))\n+\t      || GET_CODE (XEXP (x, 0)) == VALUE))\n+\t{\n+\t  HOST_WIDE_INT c;\n+\t  if (offset.is_constant (&c))\n+\t    return cselib_hash_plus_const_int (XEXP (x, 0),\n+\t\t\t\t\t       trunc_int_for_mode (c, Pmode),\n+\t\t\t\t\t       create, memmode);\n+\t}\n+      hash = ((unsigned) PLUS + (unsigned) GET_MODE (x)\n+\t      + cselib_hash_rtx (XEXP (x, 0), create, memmode)\n+\t      + cselib_hash_rtx (gen_int_mode (offset, GET_MODE (x)),\n+\t\t\t\t create, memmode));\n       return hash ? hash : 1 + (unsigned) PLUS;\n \n     case PRE_MODIFY:\n@@ -1237,6 +1375,16 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n \n       break;\n \n+    case PLUS:\n+      if (GET_MODE (x) == Pmode\n+\t  && (REG_P (XEXP (x, 0))\n+\t      || MEM_P (XEXP (x, 0))\n+\t      || GET_CODE (XEXP (x, 0)) == VALUE)\n+\t  && CONST_INT_P (XEXP (x, 1)))\n+\treturn cselib_hash_plus_const_int (XEXP (x, 0), INTVAL (XEXP (x, 1)),\n+\t\t\t\t\t   create, memmode);\n+      break;\n+\n     default:\n       break;\n     }\n@@ -1927,6 +2075,26 @@ cselib_subst_to_values (rtx x, machine_mode memmode)\n       gcc_assert (memmode != VOIDmode);\n       return cselib_subst_to_values (XEXP (x, 0), memmode);\n \n+    case PLUS:\n+      if (GET_MODE (x) == Pmode && CONST_INT_P (XEXP (x, 1)))\n+\t{\n+\t  rtx t = cselib_subst_to_values (XEXP (x, 0), memmode);\n+\t  if (GET_CODE (t) == VALUE)\n+\t    for (struct elt_loc_list *l = CSELIB_VAL_PTR (t)->locs;\n+\t\t l; l = l->next)\n+\t      if (GET_CODE (l->loc) == PLUS\n+\t\t  && GET_CODE (XEXP (l->loc, 0)) == VALUE\n+\t\t  && SP_DERIVED_VALUE_P (XEXP (l->loc, 0))\n+\t\t  && CONST_INT_P (XEXP (l->loc, 1)))\n+\t\treturn plus_constant (Pmode, l->loc, INTVAL (XEXP (x, 1)));\n+\t  if (t != XEXP (x, 0))\n+\t    {\n+\t      copy = shallow_copy_rtx (x);\n+\t      XEXP (copy, 0) = t;\n+\t    }\n+\t  return copy;\n+\t}\n+\n     default:\n       break;\n     }\n@@ -2030,6 +2198,8 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n \t}\n \n       e = new_cselib_val (next_uid, GET_MODE (x), x);\n+      if (GET_MODE (x) == Pmode && x == stack_pointer_rtx)\n+\tSP_DERIVED_VALUE_P (e->val_rtx) = 1;\n       new_elt_loc_list (e, x);\n \n       scalar_int_mode int_mode;\n@@ -2107,7 +2277,14 @@ cselib_lookup_1 (rtx x, machine_mode mode,\n      the hash table is inconsistent until we do so, and\n      cselib_subst_to_values will need to do lookups.  */\n   *slot = e;\n-  new_elt_loc_list (e, cselib_subst_to_values (x, memmode));\n+  rtx v = cselib_subst_to_values (x, memmode);\n+\n+  /* If cselib_preserve_constants, we might get a SP_DERIVED_VALUE_P\n+     VALUE that isn't in the hash tables anymore.  */\n+  if (GET_CODE (v) == VALUE && SP_DERIVED_VALUE_P (v) && PRESERVED_VALUE_P (v))\n+    PRESERVED_VALUE_P (e->val_rtx) = 1;\n+\n+  new_elt_loc_list (e, v);\n   return e;\n }\n "}, {"sha": "bbe792e48e855a6bb75b7e106fecdec30515c689", "filename": "gcc/dse.c", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=2c0fa3ecf70d199af18785702e9e0548fd3ab793", "patch": "@@ -846,6 +846,17 @@ check_for_inc_dec_1 (insn_info_t insn_info)\n   if (note)\n     return for_each_inc_dec (PATTERN (insn), emit_inc_dec_insn_before,\n \t\t\t     insn_info) == 0;\n+\n+  /* Punt on stack pushes, those don't have REG_INC notes and we are\n+     unprepared to deal with distribution of REG_ARGS_SIZE notes etc.  */\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, PATTERN (insn), NONCONST)\n+    {\n+      const_rtx x = *iter;\n+      if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n@@ -866,6 +877,17 @@ check_for_inc_dec (rtx_insn *insn)\n   if (note)\n     return for_each_inc_dec (PATTERN (insn), emit_inc_dec_insn_before,\n \t\t\t     &insn_info) == 0;\n+\n+  /* Punt on stack pushes, those don't have REG_INC notes and we are\n+     unprepared to deal with distribution of REG_ARGS_SIZE notes etc.  */\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, PATTERN (insn), NONCONST)\n+    {\n+      const_rtx x = *iter;\n+      if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n+\treturn false;\n+    }\n+\n   return true;\n }\n \n@@ -1980,16 +2002,30 @@ replace_read (store_info *store_info, insn_info_t store_insn,\n \t point.  This does occasionally happen, see PR 37922.  */\n       bitmap regs_set = BITMAP_ALLOC (&reg_obstack);\n \n-      for (this_insn = insns; this_insn != NULL_RTX; this_insn = NEXT_INSN (this_insn))\n-\tnote_stores (this_insn, look_for_hardregs, regs_set);\n+      for (this_insn = insns;\n+\t   this_insn != NULL_RTX; this_insn = NEXT_INSN (this_insn))\n+\t{\n+\t  if (insn_invalid_p (this_insn, false))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \" -- replacing the loaded MEM with \");\n+\t\t  print_simple_rtl (dump_file, read_reg);\n+\t\t  fprintf (dump_file, \" led to an invalid instruction\\n\");\n+\t\t}\n+\t      BITMAP_FREE (regs_set);\n+\t      return false;\n+\t    }\n+\t  note_stores (this_insn, look_for_hardregs, regs_set);\n+\t}\n \n       bitmap_and_into (regs_set, regs_live);\n       if (!bitmap_empty_p (regs_set))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file,\n-\t\t       \"abandoning replacement because sequence clobbers live hardregs:\");\n+\t      fprintf (dump_file, \"abandoning replacement because sequence \"\n+\t\t\t\t  \"clobbers live hardregs:\");\n \t      df_print_regset (dump_file, regs_set);\n \t    }\n \n@@ -1999,6 +2035,19 @@ replace_read (store_info *store_info, insn_info_t store_insn,\n       BITMAP_FREE (regs_set);\n     }\n \n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, *loc, NONCONST)\n+    {\n+      const_rtx x = *iter;\n+      if (GET_RTX_CLASS (GET_CODE (x)) == RTX_AUTOINC)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \" -- replacing the MEM failed due to address \"\n+\t\t\t\t\"side-effects\\n\");\n+\t  return false;\n+\t}\n+    }\n+\n   if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n       deferred_change *change = deferred_change_pool.allocate ();"}, {"sha": "b29afca8d6b67db9870f00158a2b56e51e352a4e", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2c0fa3ecf70d199af18785702e9e0548fd3ab793", "patch": "@@ -331,6 +331,7 @@ struct GTY((desc(\"0\"), tag(\"0\"),\n      1 in a MEM if it cannot trap.\n      1 in a CALL_INSN logically equivalent to\n        ECF_LOOPING_CONST_OR_PURE and DECL_LOOPING_CONST_OR_PURE_P.\n+     1 in a VALUE is SP_DERIVED_VALUE_P in cselib.c.\n      Dumped as \"/c\" in RTL dumps.  */\n   unsigned int call : 1;\n   /* 1 in a REG, MEM, or CONCAT if the value is set at most once, anywhere."}, {"sha": "8274df987418786990df72ec276a6430e6740d9d", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c0fa3ecf70d199af18785702e9e0548fd3ab793/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=2c0fa3ecf70d199af18785702e9e0548fd3ab793", "patch": "@@ -10045,19 +10045,25 @@ vt_initialize (void)\n       preserve_value (val);\n       if (reg != hard_frame_pointer_rtx && fixed_regs[REGNO (reg)])\n \tcselib_preserve_cfa_base_value (val, REGNO (reg));\n-      expr = plus_constant (GET_MODE (stack_pointer_rtx),\n-\t\t\t    stack_pointer_rtx, -ofst);\n-      cselib_add_permanent_equiv (val, expr, get_insns ());\n-\n       if (ofst)\n \t{\n-\t  val = cselib_lookup_from_insn (stack_pointer_rtx,\n-\t\t\t\t\t GET_MODE (stack_pointer_rtx), 1,\n-\t\t\t\t\t VOIDmode, get_insns ());\n-\t  preserve_value (val);\n+\t  cselib_val *valsp\n+\t    = cselib_lookup_from_insn (stack_pointer_rtx,\n+\t\t\t\t       GET_MODE (stack_pointer_rtx), 1,\n+\t\t\t\t       VOIDmode, get_insns ());\n+\t  preserve_value (valsp);\n \t  expr = plus_constant (GET_MODE (reg), reg, ofst);\n-\t  cselib_add_permanent_equiv (val, expr, get_insns ());\n+\t  /* This cselib_add_permanent_equiv call needs to be done before\n+\t     the other cselib_add_permanent_equiv a few lines later,\n+\t     because after that one is done, cselib_lookup on this expr\n+\t     will due to the cselib SP_DERIVED_VALUE_P optimizations\n+\t     return valsp and so no permanent equivalency will be added.  */\n+\t  cselib_add_permanent_equiv (valsp, expr, get_insns ());\n \t}\n+\n+      expr = plus_constant (GET_MODE (stack_pointer_rtx),\n+\t\t\t    stack_pointer_rtx, -ofst);\n+      cselib_add_permanent_equiv (val, expr, get_insns ());\n     }\n \n   /* In order to factor out the adjustments made to the stack pointer or to"}]}