{"sha": "b649398a84df1df9c44e50b58c4fe766909af897", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY0OTM5OGE4NGRmMWRmOWM0NGU1MGI1OGM0ZmU3NjY5MDlhZjg5Nw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2001-08-18T20:46:45Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-18T20:46:45Z"}, "message": "ansidecl.h: Reorganize for readability...\n\ninclude:\n        * ansidecl.h: Reorganize for readability, remove documentation\n        of obsolete macros, document PARAMS and VPARAMS.  Add new\n        macros VA_OPEN, VA_CLOSE, and VA_FIXEDARG for nicer variadic\n        function implementation.\n\ngcc:\n        * cpperror.c: Use VA_OPEN/VA_CLOSE/VA_FIXEDARG throughout.\n\nFrom-SVN: r45011", "tree": {"sha": "5f075c3b2cc6977486b8c21118218978fae417e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f075c3b2cc6977486b8c21118218978fae417e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b649398a84df1df9c44e50b58c4fe766909af897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b649398a84df1df9c44e50b58c4fe766909af897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b649398a84df1df9c44e50b58c4fe766909af897", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b649398a84df1df9c44e50b58c4fe766909af897/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76f4925a6fab80e9c9ff87e77e6119ea4b3c9df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f4925a6fab80e9c9ff87e77e6119ea4b3c9df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f4925a6fab80e9c9ff87e77e6119ea4b3c9df5"}], "stats": {"total": 508, "additions": 242, "deletions": 266}, "files": [{"sha": "274f22bc2a20839a4feb09613de4e010932b0703", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b649398a84df1df9c44e50b58c4fe766909af897/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b649398a84df1df9c44e50b58c4fe766909af897/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b649398a84df1df9c44e50b58c4fe766909af897", "patch": "@@ -1,3 +1,7 @@\n+2001-08-18  Zack Weinberg  <zackw@panix.com>\n+\n+\t* cpperror.c: Use VA_OPEN/VA_CLOSE/VA_FIXEDARG throughout. \n+\n 2001-08-18  Zack Weinberg  <zackw@panix.com>\n \n \t* haifa-sched.c: Convert to target hooks.  Macros replaced"}, {"sha": "6b137abcd75a22a2822132fd10d312fc146f3fce", "filename": "gcc/cpperror.c", "status": "modified", "additions": 52, "deletions": 129, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b649398a84df1df9c44e50b58c4fe766909af897/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b649398a84df1df9c44e50b58c4fe766909af897/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=b649398a84df1df9c44e50b58c4fe766909af897", "patch": "@@ -142,22 +142,14 @@ _cpp_begin_message (pfile, code, pos)\n void\n cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n {  \n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   if (_cpp_begin_message (pfile, ICE, 0))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n /* Same as cpp_error, except we consider the error to be \"fatal\",\n@@ -169,72 +161,47 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n void\n cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n {  \n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   if (_cpp_begin_message (pfile, FATAL, 0))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n void\n cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-\n-  VA_START(ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   if (_cpp_begin_message (pfile, ERROR, 0))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n void\n cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n \t\t\t     const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n   cpp_lexer_pos pos;\n   \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  line = va_arg (ap, int);\n-  column = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, int, line);\n+  VA_FIXEDARG (ap, int, column);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   pos.line = line;\n   pos.col = column;\n   if (_cpp_begin_message (pfile, ERROR, &pos))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n /* Error including a message from `errno'.  */\n@@ -249,127 +216,83 @@ cpp_error_from_errno (pfile, name)\n void\n cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   if (_cpp_begin_message (pfile, WARNING, 0))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n void\n cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n \t\t\t       const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n   cpp_lexer_pos pos;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  line = va_arg (ap, int);\n-  column = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, int, line);\n+  VA_FIXEDARG (ap, int, column);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   pos.line = line;\n   pos.col = column;\n   if (_cpp_begin_message (pfile, WARNING, &pos))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n void\n cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   if (_cpp_begin_message (pfile, PEDWARN, 0))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n void\n cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n \t\t\t       const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  int line;\n-  int column;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n   cpp_lexer_pos pos;\n   \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  line = va_arg (ap, int);\n-  column = va_arg (ap, int);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, int, line);\n+  VA_FIXEDARG (ap, int, column);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   pos.line = line;\n   pos.col = column;\n   if (_cpp_begin_message (pfile, PEDWARN, &pos))\n     v_message (msgid, ap);\n-  va_end(ap);\n+\n+  VA_CLOSE (ap);\n }\n \n /* Print an error message not associated with a file.  */\n void\n cpp_notice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n {\n-#ifndef ANSI_PROTOTYPES\n-  cpp_reader *pfile;\n-  const char *msgid;\n-#endif\n-  va_list ap;\n-  \n-  VA_START (ap, msgid);\n-  \n-#ifndef ANSI_PROTOTYPES\n-  pfile = va_arg (ap, cpp_reader *);\n-  msgid = va_arg (ap, const char *);\n-#endif\n+  VA_OPEN (ap, msgid);\n+  VA_FIXEDARG (ap, cpp_reader *, pfile);\n+  VA_FIXEDARG (ap, const char *, msgid);\n \n   if (pfile->errors < CPP_FATAL_LIMIT)\n     pfile->errors++;\n \n-  vfprintf (stderr, _(msgid), ap);\n-  putc('\\n', stderr);\n+  v_message (msgid, ap);\n \n-  va_end(ap);\n+  VA_CLOSE (ap);\n }\n \n void"}, {"sha": "ed435beb78f63946c8b01d0787fffcd83bbc4de4", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b649398a84df1df9c44e50b58c4fe766909af897/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b649398a84df1df9c44e50b58c4fe766909af897/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=b649398a84df1df9c44e50b58c4fe766909af897", "patch": "@@ -1,3 +1,10 @@\n+2001-08-18  Zack Weinberg  <zackw@panix.com>\n+\n+\t* ansidecl.h: Reorganize for readability, remove documentation\n+\tof obsolete macros, document PARAMS and VPARAMS.  Add new\n+\tmacros VA_OPEN, VA_CLOSE, and VA_FIXEDARG for nicer variadic\n+\tfunction implementation.\n+\n 2001-08-16  Richard Henderson  <rth@redhat.com>\n \n \t* hashtab.h (htab_hash_string): Declare."}, {"sha": "b7c4c40abff94dd8e69f92d2a976e2b1bef8eaa7", "filename": "include/ansidecl.h", "status": "modified", "additions": 179, "deletions": 137, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b649398a84df1df9c44e50b58c4fe766909af897/include%2Fansidecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b649398a84df1df9c44e50b58c4fe766909af897/include%2Fansidecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fansidecl.h?ref=b649398a84df1df9c44e50b58c4fe766909af897", "patch": "@@ -1,5 +1,5 @@\n /* ANSI and traditional C compatability macros\n-   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000\n+   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc.\n    This file is part of the GNU C Library.\n \n@@ -21,164 +21,214 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n    ANSI C is assumed if __STDC__ is #defined.\n \n-   Macro\tANSI C definition\tTraditional C definition\n-   -----\t---- - ----------\t----------- - ----------\n-   PTR\t\t`void *'\t\t`char *'\n-   LONG_DOUBLE\t`long double'\t\t`double'\n-   VOLATILE\t`volatile'\t\t`'\n-   SIGNED\t`signed'\t\t`'\n-   PTRCONST\t`void *const'\t\t`char *'\n-   ANSI_PROTOTYPES  1\t\t\tnot defined\n-\n-   CONST is also defined, but is obsolete.  Just use const.\n-\n-   obsolete --     DEFUN (name, arglist, args)\n-\n-\tDefines function NAME.\n-\n-\tARGLIST lists the arguments, separated by commas and enclosed in\n-\tparentheses.  ARGLIST becomes the argument list in traditional C.\n-\n-\tARGS list the arguments with their types.  It becomes a prototype in\n-\tANSI C, and the type declarations in traditional C.  Arguments should\n-\tbe separated with `AND'.  For functions with a variable number of\n-\targuments, the last thing listed should be `DOTS'.\n-\n-   obsolete --     DEFUN_VOID (name)\n-\n-\tDefines a function NAME, which takes no arguments.\n-\n-   obsolete --     EXFUN (name, (prototype))\t-- obsolete.\n-\n-\tReplaced by PARAMS.  Do not use; will disappear someday soon.\n-\tWas used in external function declarations.\n-\tIn ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in\n-\tparentheses).  In traditional C it is `NAME()'.\n-\tFor a function that takes no arguments, PROTOTYPE should be `(void)'.\n-\n-   obsolete --     PROTO (type, name, (prototype)    -- obsolete.\n-\n-\tThis one has also been replaced by PARAMS.  Do not use.\n-\n-   PARAMS ((args))\n-\n-\tWe could use the EXFUN macro to handle prototype declarations, but\n-\tthe name is misleading and the result is ugly.  So we just define a\n-\tsimple macro to handle the parameter lists, as in:\n-\n-\t      static int foo PARAMS ((int, char));\n-\n-\tThis produces:  `static int foo();' or `static int foo (int, char);'\n-\n-\tEXFUN would have done it like this:\n-\n-\t      static int EXFUN (foo, (int, char));\n-\n-\tbut the function is not external...and it's hard to visually parse\n-\tthe function name out of the mess.   EXFUN should be considered\n-\tobsolete; new code should be written to use PARAMS.\n-\n-   DOTS is also obsolete.\n-\n-   Examples:\n-\n-\textern int printf PARAMS ((const char *format, ...));\n-*/\n+   Macro\t\tANSI C definition\tTraditional C definition\n+   -----\t\t---- - ----------\t----------- - ----------\n+   ANSI_PROTOTYPES\t1\t\t\tnot defined\n+   PTR\t\t\t`void *'\t\t`char *'\n+   PTRCONST\t\t`void *const'\t\t`char *'\n+   LONG_DOUBLE\t\t`long double'\t\t`double'\n+   const\t\tnot defined\t\t`'\n+   volatile\t\tnot defined\t\t`'\n+   signed\t\tnot defined\t\t`'\n+   VA_START(ap, var)\tva_start(ap, var)\tva_start(ap)\n+\n+   Note that it is safe to write \"void foo();\" indicating a function\n+   with no return value, in all K+R compilers we have been able to test.\n+\n+   For declaring functions with prototypes, we also provide these:\n+\n+   PARAMS ((prototype))\n+   -- for functions which take a fixed number of arguments.  Use this\n+   when declaring the function.  When defining the function, write a\n+   K+R style argument list.  For example:\n+\n+\tchar *strcpy PARAMS ((char *dest, char *source));\n+\t...\n+\tchar *\n+\tstrcpy (dest, source)\n+\t     char *dest;\n+\t     char *source;\n+\t{ ... }\n+\n+\n+   VPARAMS ((prototype, ...))\n+   -- for functions which take a variable number of arguments.  Use\n+   PARAMS to declare the function, VPARAMS to define it.  For example:\n+\n+\tint printf PARAMS ((const char *format, ...));\n+\t...\n+\tint\n+\tprintf VPARAMS ((const char *format, ...))\n+\t{\n+\t   ...\n+\t}\n+\n+   For writing functions which take variable numbers of arguments, we\n+   also provide the VA_OPEN, VA_CLOSE, and VA_FIXEDARG macros.  These\n+   hide the differences between K+R <varargs.h> and C89 <stdarg.h> more\n+   thoroughly than the simple VA_START() macro mentioned above.\n+\n+   VA_OPEN and VA_CLOSE are used *instead of* va_start and va_end.\n+   Immediately after VA_OPEN, put a sequence of VA_FIXEDARG calls\n+   corresponding to the list of fixed arguments.  Then use va_arg\n+   normally to get the variable arguments, or pass your va_list object\n+   around.  You do not declare the va_list yourself; VA_OPEN does it\n+   for you.\n+\n+   Here is a complete example:\n+\n+\tint\n+\tprintf VPARAMS ((const char *format, ...))\n+\t{\n+\t   int result;\n+\n+\t   VA_OPEN (ap, format);\n+\t   VA_FIXEDARG (ap, const char *, format);\n+\n+\t   result = vfprintf (stdout, format, ap);\n+\t   VA_CLOSE (ap);\n+\n+\t   return result;\n+\t}\n+\n+\n+   You can declare variables either before or after the VA_OPEN,\n+   VA_FIXEDARG sequence.  You can _not_ put statements before VA_OPEN.\n+   Also, VA_OPEN and VA_CLOSE are the beginning and end of a block.\n+   They must appear at the same nesting level, and any variables\n+   declared after VA_OPEN go out of scope at VA_CLOSE.  Unfortunately,\n+   with a K+R compiler, that includes the argument list.\n+\n+   For ease of writing code which uses GCC extensions but needs to be\n+   portable to other compilers, we provide the GCC_VERSION macro that\n+   simplifies testing __GNUC__ and __GNUC_MINOR__ together, and various\n+   wrappers around __attribute__.  Also, __extension__ will be #defined\n+   to nothing if it doesn't work.  See below.\n+\n+   This header also defines a lot of obsolete macros:\n+   CONST, VOLATILE, SIGNED, PROTO, EXFUN, DEFUN, DEFUN_VOID,\n+   AND, DOTS, NOARGS.  Don't use them.  */\n \n #ifndef\t_ANSIDECL_H\n-\n-#define\t_ANSIDECL_H\t1\n-\n+#define _ANSIDECL_H\t1\n \n /* Every source file includes this file,\n    so they will all get the switch for lint.  */\n /* LINTLIBRARY */\n \n+/* Using MACRO(x,y) in cpp #if conditionals does not work with some\n+   older preprocessors.  Thus we can't define something like this:\n+\n+#define HAVE_GCC_VERSION(MAJOR, MINOR) \\\n+  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))\n+\n+and then test \"#if HAVE_GCC_VERSION(2,7)\".\n+\n+So instead we use the macro below and test it against specific values.  */\n+\n+/* This macro simplifies testing whether we are using gcc, and if it\n+   is of a particular minimum version. (Both major & minor numbers are\n+   significant.)  This macro will evaluate to 0 if we are not using\n+   gcc at all.  */\n+#ifndef GCC_VERSION\n+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif /* GCC_VERSION */\n \n #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)\n /* All known AIX compilers implement these things (but don't always\n    define __STDC__).  The RISC/OS MIPS compiler defines these things\n    in SVR4 mode, but does not define __STDC__.  */\n \n-#define\tPTR\t\tvoid *\n-#define\tPTRCONST\tvoid *CONST\n-#define\tLONG_DOUBLE\tlong double\n-\n-#ifndef IN_GCC\n-#define\tAND\t\t,\n-#define\tNOARGS\t\tvoid\n-#define\tVOLATILE\tvolatile\n-#define\tSIGNED\t\tsigned\n-#endif /* ! IN_GCC */\n-\n-#define PARAMS(paramlist)\t\tparamlist\n-#define ANSI_PROTOTYPES\t\t\t1\n-\n-#define VPARAMS(ARGS)\t\t\tARGS\n-#define VA_START(va_list,var)\t\tva_start(va_list,var)\n+#define ANSI_PROTOTYPES\t1\n+#define PTR\t\tvoid *\n+#define PTRCONST\tvoid *const\n+#define LONG_DOUBLE\tlong double\n+\n+#define PARAMS(ARGS)\t\tARGS\n+#define VPARAMS(ARGS)\t\tARGS\n+#define VA_START(VA_LIST, VAR)\tva_start(VA_LIST, VAR)\n+\n+/* variadic function helper macros */\n+/* \"struct Qdmy\" swallows the semicolon after VA_OPEN/VA_FIXEDARG's\n+   use without inhibiting further decls and without declaring an\n+   actual variable.  */\n+#define VA_OPEN(AP, VAR)\tva_list AP; va_start(AP, VAR); { struct Qdmy\n+#define VA_CLOSE(AP)\t\t} va_end(AP)\n+#define VA_FIXEDARG(AP, T, N)\tstruct Qdmy\n+ \n+#undef const\n+#undef volatile\n+#undef signed\n+\n+/* inline requires special treatment; it's in C99, and GCC >=2.7 supports\n+   it too, but it's not in C89.  */\n+#undef inline\n+#if __STDC_VERSION__ > 199901L\n+/* it's a keyword */\n+#else\n+# if GCC_VERSION >= 2007\n+#  define inline __inline__   /* __inline__ prevents -pedantic warnings */\n+# else\n+#  define inline  /* nothing */\n+# endif\n+#endif\n \n /* These are obsolete.  Do not use.  */\n #ifndef IN_GCC\n-#define CONST\t\t\t\tconst\n-#define DOTS\t\t\t\t, ...\n+#define CONST\t\tconst\n+#define VOLATILE\tvolatile\n+#define SIGNED\t\tsigned\n+\n #define PROTO(type, name, arglist)\ttype name arglist\n #define EXFUN(name, proto)\t\tname proto\n #define DEFUN(name, arglist, args)\tname(args)\n #define DEFUN_VOID(name)\t\tname(void)\n+#define AND\t\t,\n+#define DOTS\t\t, ...\n+#define NOARGS\t\tvoid\n #endif /* ! IN_GCC */\n \n #else\t/* Not ANSI C.  */\n \n-#define\tPTR\t\tchar *\n-#define\tPTRCONST\tPTR\n-#define\tLONG_DOUBLE\tdouble\n+#undef  ANSI_PROTOTYPES\n+#define PTR\t\tchar *\n+#define PTRCONST\tPTR\n+#define LONG_DOUBLE\tdouble\n+\n+#define PARAMS(args)\t\t()\n+#define VPARAMS(args)\t\t(va_alist) va_dcl\n+#define VA_START(va_list, var)\tva_start(va_list)\n+\n+#define VA_OPEN(AP, VAR)\t\tva_list AP; va_start(AP); { struct Qdmy\n+#define VA_CLOSE(AP)\t\t\t} va_end(AP)\n+#define VA_FIXEDARG(AP, TYPE, NAME)\tTYPE NAME = va_arg(AP, TYPE)\n+\n+/* some systems define these in header files for non-ansi mode */\n+#undef const\n+#undef volatile\n+#undef signed\n+#undef inline\n+#define const\n+#define volatile\n+#define signed\n+#define inline\n \n-#ifndef IN_GCC\n-#define\tAND\t\t;\n-#define\tNOARGS\n-#define\tVOLATILE\n-#define\tSIGNED\n-#endif /* !IN_GCC */\n-\n-#ifndef const /* some systems define it in header files for non-ansi mode */\n-#define\tconst\n-#endif\n-\n-#define PARAMS(paramlist)\t\t()\n-\n-#define VPARAMS(ARGS)\t\t\t(va_alist) va_dcl\n-#define VA_START(va_list,var)\t\tva_start(va_list)\n-\n-/* These are obsolete.  Do not use.  */\n #ifndef IN_GCC\n #define CONST\n-#define DOTS\n+#define VOLATILE\n+#define SIGNED\n+\n #define PROTO(type, name, arglist)\ttype name ()\n #define EXFUN(name, proto)\t\tname()\n #define DEFUN(name, arglist, args)\tname arglist args;\n #define DEFUN_VOID(name)\t\tname()\n+#define AND\t\t;\n+#define DOTS\n+#define NOARGS\n #endif /* ! IN_GCC */\n \n #endif\t/* ANSI C.  */\n \n-/* Using MACRO(x,y) in cpp #if conditionals does not work with some\n-   older preprocessors.  Thus we can't define something like this:\n-\n-#define HAVE_GCC_VERSION(MAJOR, MINOR) \\\n-  (__GNUC__ > (MAJOR) || (__GNUC__ == (MAJOR) && __GNUC_MINOR__ >= (MINOR)))\n-\n-and then test \"#if HAVE_GCC_VERSION(2,7)\".\n-\n-So instead we use the macro below and test it against specific values.  */\n-\n-/* This macro simplifies testing whether we are using gcc, and if it\n-   is of a particular minimum version. (Both major & minor numbers are\n-   significant.)  This macro will evaluate to 0 if we are not using\n-   gcc at all.  */\n-#ifndef GCC_VERSION\n-#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n-#endif /* GCC_VERSION */\n-\n /* Define macros for some gcc attributes.  This permits us to use the\n    macros freely, and know that they will come into play for the\n    version of gcc in which they are supported.  */\n@@ -229,20 +279,12 @@ So instead we use the macro below and test it against specific values.  */\n #define __extension__\n #endif\n \n-/* Bootstrap support: Autoconf will possibly define the `inline' or\n-   `const' keywords as macros, however this is only valid for the\n-   stage1 compiler.  If we detect a modern version of gcc,\n-   unconditionally reset the values.  This makes sure the right thing\n-   happens in stage2 and later.  We need to do this very early;\n-   i.e. before any header files that might use these keywords.\n-   Otherwise conflicts might occur.  */\n-\n+/* Bootstrap support:  Adjust certain macros defined by Autoconf,\n+   which are only valid for the stage1 compiler.  If we detect\n+   a modern version of GCC, we are probably in stage2 or beyond,\n+   so unconditionally reset the values.  Note that const, inline,\n+   etc. have been dealt with above.  */\n #if (GCC_VERSION >= 2007)\n-# ifdef __STDC__\n-#  undef const\n-# endif\n-# undef inline\n-# define inline __inline__  /* __inline__ prevents -pedantic warnings */\n # ifndef HAVE_LONG_DOUBLE\n #  define HAVE_LONG_DOUBLE 1\n # endif"}]}