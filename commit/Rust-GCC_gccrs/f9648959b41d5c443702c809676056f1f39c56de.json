{"sha": "f9648959b41d5c443702c809676056f1f39c56de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk2NDg5NTliNDFkNWM0NDM3MDJjODA5Njc2MDU2ZjFmMzljNTZkZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:40:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:40:26Z"}, "message": "[multiple changes]\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb, sem_ch13.adb: Minor reformatting.\n\n2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-intnam-linux.ads: Minor: update obsolete comments.\n\t* s-taasde.adb: Minor: fix comment header.\n\n2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-auxdec-vms-ia64.adb, s-parame-vms-alpha.ads, s-asthan-vms-alpha.adb,\n\ts-tpopde-vms.adb, s-mastop-vms.adb, s-tpopde-vms.ads, s-taprop-vms.adb,\n\tmlib-tgt-vms_common.adb, mlib-tgt-vms_common.ads, s-inmaop-vms.adb,\n\tg-enblsp-vms-alpha.adb, s-ransee-vms.adb, s-osprim-vms.adb,\n\ts-osprim-vms.ads, g-socthi-vms.adb, g-socthi-vms.ads, system-vms_64.ads,\n\ts-osinte-vms.adb, s-osinte-vms.ads, g-eacodu-vms.adb,\n\ts-vaflop-vms-alpha.adb, s-parame-vms-ia64.ads, a-dirval-vms.adb,\n\ta-caldel-vms.adb, mlib-tgt-specific-vms-alpha.adb, s-tasdeb-vms.adb,\n\tsymbols-vms.adb, a-intnam-vms.ads, g-expect-vms.adb,\n\tsymbols-processing-vms-alpha.adb, mlib-tgt-specific-vms-ia64.adb,\n\ts-traent-vms.adb, s-traent-vms.ads, i-cstrea-vms.adb, a-numaux-vms.ads,\n\tsymbols-processing-vms-ia64.adb, s-interr-vms.adb, s-memory-vms_64.adb,\n\ts-memory-vms_64.ads, g-enblsp-vms-ia64.adb, s-taspri-vms.ads,\n\ts-auxdec-vms_64.ads, s-intman-vms.adb, s-intman-vms.ads,\n\ts-tpopsp-vms.adb, s-asthan-vms-ia64.adb, a-calend-vms.adb,\n\ta-calend-vms.ads, system-vms-ia64.ads, s-auxdec-vms-alpha.adb: Removed.\n\t* namet.h (Is_Non_Ada_Error): Remove.\n\nFrom-SVN: r213368", "tree": {"sha": "e7a73c16b1fee3a487105efe3fa4df970c9d7b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7a73c16b1fee3a487105efe3fa4df970c9d7b34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9648959b41d5c443702c809676056f1f39c56de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9648959b41d5c443702c809676056f1f39c56de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9648959b41d5c443702c809676056f1f39c56de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9648959b41d5c443702c809676056f1f39c56de/comments", "author": null, "committer": null, "parents": [{"sha": "fec4842dee0f49ce7db1f472cb0b18227b489271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fec4842dee0f49ce7db1f472cb0b18227b489271", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fec4842dee0f49ce7db1f472cb0b18227b489271"}], "stats": {"total": 19730, "additions": 46, "deletions": 19684}, "files": [{"sha": "488e7595aed74e92665729348a3d7cd7eeda6e56", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f9648959b41d5c443702c809676056f1f39c56de", "patch": "@@ -1,3 +1,32 @@\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb, sem_ch13.adb: Minor reformatting.\n+\n+2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-intnam-linux.ads: Minor: update obsolete comments.\n+\t* s-taasde.adb: Minor: fix comment header.\n+\n+2014-07-31  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-auxdec-vms-ia64.adb, s-parame-vms-alpha.ads, s-asthan-vms-alpha.adb,\n+\ts-tpopde-vms.adb, s-mastop-vms.adb, s-tpopde-vms.ads, s-taprop-vms.adb,\n+\tmlib-tgt-vms_common.adb, mlib-tgt-vms_common.ads, s-inmaop-vms.adb,\n+\tg-enblsp-vms-alpha.adb, s-ransee-vms.adb, s-osprim-vms.adb,\n+\ts-osprim-vms.ads, g-socthi-vms.adb, g-socthi-vms.ads, system-vms_64.ads,\n+\ts-osinte-vms.adb, s-osinte-vms.ads, g-eacodu-vms.adb,\n+\ts-vaflop-vms-alpha.adb, s-parame-vms-ia64.ads, a-dirval-vms.adb,\n+\ta-caldel-vms.adb, mlib-tgt-specific-vms-alpha.adb, s-tasdeb-vms.adb,\n+\tsymbols-vms.adb, a-intnam-vms.ads, g-expect-vms.adb,\n+\tsymbols-processing-vms-alpha.adb, mlib-tgt-specific-vms-ia64.adb,\n+\ts-traent-vms.adb, s-traent-vms.ads, i-cstrea-vms.adb, a-numaux-vms.ads,\n+\tsymbols-processing-vms-ia64.adb, s-interr-vms.adb, s-memory-vms_64.adb,\n+\ts-memory-vms_64.ads, g-enblsp-vms-ia64.adb, s-taspri-vms.ads,\n+\ts-auxdec-vms_64.ads, s-intman-vms.adb, s-intman-vms.ads,\n+\ts-tpopsp-vms.adb, s-asthan-vms-ia64.adb, a-calend-vms.adb,\n+\ta-calend-vms.ads, system-vms-ia64.ads, s-auxdec-vms-alpha.adb: Removed.\n+\t* namet.h (Is_Non_Ada_Error): Remove.\n+\n 2014-07-31  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_util.adb, lib-writ.adb, sem_ch12.adb, s-direio.adb: Minor"}, {"sha": "1cf6f00d974641cd8554da035a478a52edbd3998", "filename": "gcc/ada/a-caldel-vms.adb", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-caldel-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-caldel-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-caldel-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,105 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   A D A . C A L E N D A R . D E L A Y S                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2012, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha/VMS version\n-\n-with System.OS_Primitives;\n-with System.Soft_Links;\n-\n-package body Ada.Calendar.Delays is\n-\n-   package OSP renames System.OS_Primitives;\n-   package TSL renames System.Soft_Links;\n-\n-   use type TSL.Timed_Delay_Call;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Timed_Delay_NT (Time : Duration; Mode : Integer);\n-   --  Timed delay procedure used when no tasking is active\n-\n-   ---------------\n-   -- Delay_For --\n-   ---------------\n-\n-   procedure Delay_For (D : Duration) is\n-   begin\n-      TSL.Timed_Delay.all\n-        (Duration'Min (D, OSP.Max_Sensible_Delay), OSP.Relative);\n-   end Delay_For;\n-\n-   -----------------\n-   -- Delay_Until --\n-   -----------------\n-\n-   procedure Delay_Until (T : Time) is\n-   begin\n-      TSL.Timed_Delay.all (To_Duration (T), OSP.Absolute_Calendar);\n-   end Delay_Until;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (T : Time) return Duration is\n-      Safe_Ada_High : constant Time := Time_Of (2250, 1, 1, 0.0);\n-      --  A value distant enough to emulate \"end of time\" but which does not\n-      --  cause overflow.\n-\n-      Safe_T : constant Time :=\n-        (if T > Safe_Ada_High then Safe_Ada_High else T);\n-\n-   begin\n-      return OSP.To_Duration (OSP.OS_Time (Safe_T), OSP.Absolute_Calendar);\n-   end To_Duration;\n-\n-   --------------------\n-   -- Timed_Delay_NT --\n-   --------------------\n-\n-   procedure Timed_Delay_NT (Time : Duration; Mode : Integer) is\n-   begin\n-      OSP.Timed_Delay (Time, Mode);\n-   end Timed_Delay_NT;\n-\n-begin\n-   --  Set up the Timed_Delay soft link to the non tasking version if it has\n-   --  not been already set. If tasking is present, Timed_Delay has already set\n-   --  this soft link, or this will be overridden during the elaboration of\n-   --  System.Tasking.Initialization\n-\n-   if TSL.Timed_Delay = null then\n-      TSL.Timed_Delay := Timed_Delay_NT'Access;\n-   end if;\n-end Ada.Calendar.Delays;"}, {"sha": "bb878cbfe453b636a582fa16f282f05dc8f258cb", "filename": "gcc/ada/a-calend-vms.adb", "status": "removed", "additions": 0, "deletions": 1317, "changes": 1317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-calend-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-calend-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,1317 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                         A D A . C A L E N D A R                          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha/VMS version\n-\n-with Ada.Unchecked_Conversion;\n-\n-with System.Aux_DEC;       use System.Aux_DEC;\n-with System.OS_Primitives; use System.OS_Primitives;\n-\n-package body Ada.Calendar is\n-\n-   --------------------------\n-   -- Implementation Notes --\n-   --------------------------\n-\n-   --  Variables of type Ada.Calendar.Time have suffix _S or _M to denote\n-   --  units of seconds or milis.\n-\n-   --  Because time is measured in different units and from different origins\n-   --  on various targets, a system independent model is incorporated into\n-   --  Ada.Calendar. The idea behind the design is to encapsulate all target\n-   --  dependent machinery in a single package, thus providing a uniform\n-   --  interface to all existing and potential children.\n-\n-   --     package Ada.Calendar\n-   --        procedure Split (5 parameters) -------+\n-   --                                              | Call from local routine\n-   --     private                                  |\n-   --        package Formatting_Operations         |\n-   --           procedure Split (11 parameters) <--+\n-   --        end Formatting_Operations             |\n-   --     end Ada.Calendar                         |\n-   --                                              |\n-   --     package Ada.Calendar.Formatting          | Call from child routine\n-   --        procedure Split (9 or 10 parameters) -+\n-   --     end Ada.Calendar.Formatting\n-\n-   --  The behaviour of the interfacing routines is controlled via various\n-   --  flags. All new Ada 2005 types from children of Ada.Calendar are\n-   --  emulated by a similar type. For instance, type Day_Number is replaced\n-   --  by Integer in various routines. One ramification of this model is that\n-   --  the caller site must perform validity checks on returned results.\n-   --  The end result of this model is the lack of target specific files per\n-   --  child of Ada.Calendar (a-calfor, a-calfor-vms, a-calfor-vxwors, etc).\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Check_Within_Time_Bounds (T : OS_Time);\n-   --  Ensure that a time representation value falls withing the bounds of Ada\n-   --  time. Leap seconds support is taken into account.\n-\n-   procedure Cumulative_Leap_Seconds\n-     (Start_Date    : OS_Time;\n-      End_Date      : OS_Time;\n-      Elapsed_Leaps : out Natural;\n-      Next_Leap_Sec : out OS_Time);\n-   --  Elapsed_Leaps is the sum of the leap seconds that have occurred on or\n-   --  after Start_Date and before (strictly before) End_Date. Next_Leap_Sec\n-   --  represents the next leap second occurrence on or after End_Date. If\n-   --  there are no leaps seconds after End_Date, End_Of_Time is returned.\n-   --  End_Of_Time can be used as End_Date to count all the leap seconds that\n-   --  have occurred on or after Start_Date.\n-   --\n-   --  Note: Any sub seconds of Start_Date and End_Date are discarded before\n-   --  the calculations are done. For instance: if 113 seconds is a leap\n-   --  second (it isn't) and 113.5 is input as an End_Date, the leap second\n-   --  at 113 will not be counted in Leaps_Between, but it will be returned\n-   --  as Next_Leap_Sec. Thus, if the caller wants to know if the End_Date is\n-   --  a leap second, the comparison should be:\n-   --\n-   --     End_Date >= Next_Leap_Sec;\n-   --\n-   --  After_Last_Leap is designed so that this comparison works without\n-   --  having to first check if Next_Leap_Sec is a valid leap second.\n-\n-   function To_Duration (T : Time) return Duration;\n-   function To_Relative_Time (D : Duration) return Time;\n-   --  It is important to note that duration's fractional part denotes nano\n-   --  seconds while the units of Time are 100 nanoseconds. If a regular\n-   --  Unchecked_Conversion was employed, the resulting values would be off\n-   --  by 100.\n-\n-   --------------------------\n-   -- Leap seconds control --\n-   --------------------------\n-\n-   Flag : Integer;\n-   pragma Import (C, Flag, \"__gl_leap_seconds_support\");\n-   --  This imported value is used to determine whether the compilation had\n-   --  binder flag \"-y\" present which enables leap seconds. A value of zero\n-   --  signifies no leap seconds support while a value of one enables the\n-   --  support.\n-\n-   Leap_Support : constant Boolean := Flag = 1;\n-   --  The above flag controls the usage of leap seconds in all Ada.Calendar\n-   --  routines.\n-\n-   Leap_Seconds_Count : constant Natural := 25;\n-\n-   ---------------------\n-   -- Local Constants --\n-   ---------------------\n-\n-   --  The range of Ada time expressed as milis since the VMS Epoch\n-\n-   Ada_Low  : constant OS_Time :=  (10 * 366 +  32 * 365 + 45) * Milis_In_Day;\n-   Ada_High : constant OS_Time := (131 * 366 + 410 * 365 + 45) * Milis_In_Day;\n-\n-   --  Even though the upper bound of time is 2399-12-31 23:59:59.9999999\n-   --  UTC, it must be increased to include all leap seconds.\n-\n-   Ada_High_And_Leaps : constant OS_Time :=\n-     Ada_High + OS_Time (Leap_Seconds_Count) * Mili;\n-\n-   --  Two constants used in the calculations of elapsed leap seconds.\n-   --  End_Of_Time is later than Ada_High in time zone -28. Start_Of_Time\n-   --  is earlier than Ada_Low in time zone +28.\n-\n-   End_Of_Time   : constant OS_Time := Ada_High + OS_Time (3) * Milis_In_Day;\n-   Start_Of_Time : constant OS_Time := Ada_Low  - OS_Time (3) * Milis_In_Day;\n-\n-   --  The following table contains the hard time values of all existing leap\n-   --  seconds. The values are produced by the utility program xleaps.adb.\n-\n-   Leap_Second_Times : constant array (1 .. Leap_Seconds_Count) of OS_Time :=\n-     (35855136000000000,\n-      36014112010000000,\n-      36329472020000000,\n-      36644832030000000,\n-      36960192040000000,\n-      37276416050000000,\n-      37591776060000000,\n-      37907136070000000,\n-      38222496080000000,\n-      38695104090000000,\n-      39010464100000000,\n-      39325824110000000,\n-      39957408120000000,\n-      40747104130000000,\n-      41378688140000000,\n-      41694048150000000,\n-      42166656160000000,\n-      42482016170000000,\n-      42797376180000000,\n-      43271712190000000,\n-      43744320200000000,\n-      44218656210000000,\n-      46427904220000000,\n-      47374848230000000,\n-      48478176240000000);\n-\n-   ---------\n-   -- \"+\" --\n-   ---------\n-\n-   function \"+\" (Left : Time; Right : Duration) return Time is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return Left + To_Relative_Time (Right);\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"+\";\n-\n-   function \"+\" (Left : Duration; Right : Time) return Time is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return Right + Left;\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"+\";\n-\n-   ---------\n-   -- \"-\" --\n-   ---------\n-\n-   function \"-\" (Left : Time; Right : Duration) return Time is\n-      pragma Unsuppress (Overflow_Check);\n-   begin\n-      return Left - To_Relative_Time (Right);\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"-\";\n-\n-   function \"-\" (Left : Time; Right : Time) return Duration is\n-      pragma Unsuppress (Overflow_Check);\n-\n-      --  The bound of type Duration expressed as time\n-\n-      Dur_High : constant OS_Time :=\n-        OS_Time (To_Relative_Time (Duration'Last));\n-      Dur_Low  : constant OS_Time :=\n-        OS_Time (To_Relative_Time (Duration'First));\n-\n-      Res_M : OS_Time;\n-\n-   begin\n-      Res_M := OS_Time (Left) - OS_Time (Right);\n-\n-      --  Due to the extended range of Ada time, \"-\" is capable of producing\n-      --  results which may exceed the range of Duration. In order to prevent\n-      --  the generation of bogus values by the Unchecked_Conversion, we apply\n-      --  the following check.\n-\n-      if Res_M < Dur_Low\n-        or else Res_M >= Dur_High\n-      then\n-         raise Time_Error;\n-\n-      --  Normal case, result fits\n-\n-      else\n-         return To_Duration (Time (Res_M));\n-      end if;\n-\n-   exception\n-      when Constraint_Error =>\n-         raise Time_Error;\n-   end \"-\";\n-\n-   ---------\n-   -- \"<\" --\n-   ---------\n-\n-   function \"<\" (Left, Right : Time) return Boolean is\n-   begin\n-      return OS_Time (Left) < OS_Time (Right);\n-   end \"<\";\n-\n-   ----------\n-   -- \"<=\" --\n-   ----------\n-\n-   function \"<=\" (Left, Right : Time) return Boolean is\n-   begin\n-      return OS_Time (Left) <= OS_Time (Right);\n-   end \"<=\";\n-\n-   ---------\n-   -- \">\" --\n-   ---------\n-\n-   function \">\" (Left, Right : Time) return Boolean is\n-   begin\n-      return OS_Time (Left) > OS_Time (Right);\n-   end \">\";\n-\n-   ----------\n-   -- \">=\" --\n-   ----------\n-\n-   function \">=\" (Left, Right : Time) return Boolean is\n-   begin\n-      return OS_Time (Left) >= OS_Time (Right);\n-   end \">=\";\n-\n-   ------------------------------\n-   -- Check_Within_Time_Bounds --\n-   ------------------------------\n-\n-   procedure Check_Within_Time_Bounds (T : OS_Time) is\n-   begin\n-      if Leap_Support then\n-         if T < Ada_Low or else T > Ada_High_And_Leaps then\n-            raise Time_Error;\n-         end if;\n-      else\n-         if T < Ada_Low or else T > Ada_High then\n-            raise Time_Error;\n-         end if;\n-      end if;\n-   end Check_Within_Time_Bounds;\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   function Clock return Time is\n-      Elapsed_Leaps : Natural;\n-      Next_Leap_M   : OS_Time;\n-      Res_M         : constant OS_Time := OS_Clock;\n-\n-   begin\n-      --  Note that on other targets a soft-link is used to get a different\n-      --  clock depending whether tasking is used or not. On VMS this isn't\n-      --  needed since all clock calls end up using SYS$GETTIM, so call the\n-      --  OS_Primitives version for efficiency.\n-\n-      --  If the target supports leap seconds, determine the number of leap\n-      --  seconds elapsed until this moment.\n-\n-      if Leap_Support then\n-         Cumulative_Leap_Seconds\n-           (Start_Of_Time, Res_M, Elapsed_Leaps, Next_Leap_M);\n-\n-         --  The system clock may fall exactly on a leap second\n-\n-         if Res_M >= Next_Leap_M then\n-            Elapsed_Leaps := Elapsed_Leaps + 1;\n-         end if;\n-\n-      --  The target does not support leap seconds\n-\n-      else\n-         Elapsed_Leaps := 0;\n-      end if;\n-\n-      return Time (Res_M + OS_Time (Elapsed_Leaps) * Mili);\n-   end Clock;\n-\n-   -----------------------------\n-   -- Cumulative_Leap_Seconds --\n-   -----------------------------\n-\n-   procedure Cumulative_Leap_Seconds\n-     (Start_Date    : OS_Time;\n-      End_Date      : OS_Time;\n-      Elapsed_Leaps : out Natural;\n-      Next_Leap_Sec : out OS_Time)\n-   is\n-      End_Index   : Positive;\n-      End_T       : OS_Time := End_Date;\n-      Start_Index : Positive;\n-      Start_T     : OS_Time := Start_Date;\n-\n-   begin\n-      pragma Assert (Leap_Support and then End_Date >= Start_Date);\n-\n-      Next_Leap_Sec := End_Of_Time;\n-\n-      --  Make sure that the end date does not exceed the upper bound\n-      --  of Ada time.\n-\n-      if End_Date > Ada_High then\n-         End_T := Ada_High;\n-      end if;\n-\n-      --  Remove the sub seconds from both dates\n-\n-      Start_T := Start_T - (Start_T mod Mili);\n-      End_T   := End_T   - (End_T   mod Mili);\n-\n-      --  Some trivial cases:\n-      --                     Leap 1 . . . Leap N\n-      --  ---+========+------+############+-------+========+-----\n-      --     Start_T  End_T                       Start_T  End_T\n-\n-      if End_T < Leap_Second_Times (1) then\n-         Elapsed_Leaps := 0;\n-         Next_Leap_Sec := Leap_Second_Times (1);\n-         return;\n-\n-      elsif Start_T > Leap_Second_Times (Leap_Seconds_Count) then\n-         Elapsed_Leaps := 0;\n-         Next_Leap_Sec := End_Of_Time;\n-         return;\n-      end if;\n-\n-      --  Perform the calculations only if the start date is within the leap\n-      --  second occurrences table.\n-\n-      if Start_T <= Leap_Second_Times (Leap_Seconds_Count) then\n-\n-         --    1    2                  N - 1   N\n-         --  +----+----+--  . . .  --+-------+---+\n-         --  | T1 | T2 |             | N - 1 | N |\n-         --  +----+----+--  . . .  --+-------+---+\n-         --         ^                   ^\n-         --         | Start_Index       | End_Index\n-         --         +-------------------+\n-         --             Leaps_Between\n-\n-         --  The idea behind the algorithm is to iterate and find two closest\n-         --  dates which are after Start_T and End_T. Their corresponding\n-         --  index difference denotes the number of leap seconds elapsed.\n-\n-         Start_Index := 1;\n-         loop\n-            exit when Leap_Second_Times (Start_Index) >= Start_T;\n-            Start_Index := Start_Index + 1;\n-         end loop;\n-\n-         End_Index := Start_Index;\n-         loop\n-            exit when End_Index > Leap_Seconds_Count\n-              or else Leap_Second_Times (End_Index) >= End_T;\n-            End_Index := End_Index + 1;\n-         end loop;\n-\n-         if End_Index <= Leap_Seconds_Count then\n-            Next_Leap_Sec := Leap_Second_Times (End_Index);\n-         end if;\n-\n-         Elapsed_Leaps := End_Index - Start_Index;\n-\n-      else\n-         Elapsed_Leaps := 0;\n-      end if;\n-   end Cumulative_Leap_Seconds;\n-\n-   ---------\n-   -- Day --\n-   ---------\n-\n-   function Day (Date : Time) return Day_Number is\n-      Y : Year_Number;\n-      M : Month_Number;\n-      D : Day_Number;\n-      S : Day_Duration;\n-      pragma Unreferenced (Y, M, S);\n-   begin\n-      Split (Date, Y, M, D, S);\n-      return D;\n-   end Day;\n-\n-   -------------\n-   -- Is_Leap --\n-   -------------\n-\n-   function Is_Leap (Year : Year_Number) return Boolean is\n-   begin\n-      --  Leap centennial years\n-\n-      if Year mod 400 = 0 then\n-         return True;\n-\n-      --  Non-leap centennial years\n-\n-      elsif Year mod 100 = 0 then\n-         return False;\n-\n-      --  Regular years\n-\n-      else\n-         return Year mod 4 = 0;\n-      end if;\n-   end Is_Leap;\n-\n-   -----------\n-   -- Month --\n-   -----------\n-\n-   function Month (Date : Time) return Month_Number is\n-      Y : Year_Number;\n-      M : Month_Number;\n-      D : Day_Number;\n-      S : Day_Duration;\n-      pragma Unreferenced (Y, D, S);\n-   begin\n-      Split (Date, Y, M, D, S);\n-      return M;\n-   end Month;\n-\n-   -------------\n-   -- Seconds --\n-   -------------\n-\n-   function Seconds (Date : Time) return Day_Duration is\n-      Y : Year_Number;\n-      M : Month_Number;\n-      D : Day_Number;\n-      S : Day_Duration;\n-      pragma Unreferenced (Y, M, D);\n-   begin\n-      Split (Date, Y, M, D, S);\n-      return S;\n-   end Seconds;\n-\n-   -----------\n-   -- Split --\n-   -----------\n-\n-   procedure Split\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration)\n-   is\n-      H  : Integer;\n-      M  : Integer;\n-      Se : Integer;\n-      Ss : Duration;\n-      Le : Boolean;\n-\n-   begin\n-      --  Use UTC as the local time zone on VMS, the status of flag Use_TZ is\n-      --  irrelevant in this case.\n-\n-      Formatting_Operations.Split\n-        (Date        => Date,\n-         Year        => Year,\n-         Month       => Month,\n-         Day         => Day,\n-         Day_Secs    => Seconds,\n-         Hour        => H,\n-         Minute      => M,\n-         Second      => Se,\n-         Sub_Sec     => Ss,\n-         Leap_Sec    => Le,\n-         Use_TZ      => False,\n-         Is_Historic => True,\n-         Time_Zone   => 0);\n-\n-      --  Validity checks\n-\n-      if not Year'Valid\n-        or else not Month'Valid\n-        or else not Day'Valid\n-        or else not Seconds'Valid\n-      then\n-         raise Time_Error;\n-      end if;\n-   end Split;\n-\n-   -------------\n-   -- Time_Of --\n-   -------------\n-\n-   function Time_Of\n-     (Year    : Year_Number;\n-      Month   : Month_Number;\n-      Day     : Day_Number;\n-      Seconds : Day_Duration := 0.0) return Time\n-   is\n-      --  The values in the following constants are irrelevant, they are just\n-      --  placeholders; the choice of constructing a Day_Duration value is\n-      --  controlled by the Use_Day_Secs flag.\n-\n-      H  : constant Integer := 1;\n-      M  : constant Integer := 1;\n-      Se : constant Integer := 1;\n-      Ss : constant Duration := 0.1;\n-\n-   begin\n-      if not Year'Valid\n-        or else not Month'Valid\n-        or else not Day'Valid\n-        or else not Seconds'Valid\n-      then\n-         raise Time_Error;\n-      end if;\n-\n-      --  Use UTC as the local time zone on VMS, the status of flag Use_TZ is\n-      --  irrelevant in this case.\n-\n-      return\n-        Formatting_Operations.Time_Of\n-          (Year         => Year,\n-           Month        => Month,\n-           Day          => Day,\n-           Day_Secs     => Seconds,\n-           Hour         => H,\n-           Minute       => M,\n-           Second       => Se,\n-           Sub_Sec      => Ss,\n-           Leap_Sec     => False,\n-           Use_Day_Secs => True,\n-           Use_TZ       => False,\n-           Is_Historic  => True,\n-           Time_Zone    => 0);\n-   end Time_Of;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (T : Time) return Duration is\n-      function Time_To_Duration is\n-        new Ada.Unchecked_Conversion (Time, Duration);\n-   begin\n-      return Time_To_Duration (T * 100);\n-   end To_Duration;\n-\n-   ----------------------\n-   -- To_Relative_Time --\n-   ----------------------\n-\n-   function To_Relative_Time (D : Duration) return Time is\n-      function Duration_To_Time is\n-        new Ada.Unchecked_Conversion (Duration, Time);\n-   begin\n-      return Duration_To_Time (D / 100.0);\n-   end To_Relative_Time;\n-\n-   ----------\n-   -- Year --\n-   ----------\n-\n-   function Year (Date : Time) return Year_Number is\n-      Y : Year_Number;\n-      M : Month_Number;\n-      D : Day_Number;\n-      S : Day_Duration;\n-      pragma Unreferenced (M, D, S);\n-   begin\n-      Split (Date, Y, M, D, S);\n-      return Y;\n-   end Year;\n-\n-   --  The following packages assume that Time is a Long_Integer, the units\n-   --  are 100 nanoseconds and the starting point in the VMS Epoch.\n-\n-   ---------------------------\n-   -- Arithmetic_Operations --\n-   ---------------------------\n-\n-   package body Arithmetic_Operations is\n-\n-      ---------\n-      -- Add --\n-      ---------\n-\n-      function Add (Date : Time; Days : Long_Integer) return Time is\n-         pragma Unsuppress (Overflow_Check);\n-         Date_M : constant OS_Time := OS_Time (Date);\n-      begin\n-         return Time (Date_M + OS_Time (Days) * Milis_In_Day);\n-      exception\n-         when Constraint_Error =>\n-            raise Time_Error;\n-      end Add;\n-\n-      ----------------\n-      -- Difference --\n-      ----------------\n-\n-      procedure Difference\n-        (Left         : Time;\n-         Right        : Time;\n-         Days         : out Long_Integer;\n-         Seconds      : out Duration;\n-         Leap_Seconds : out Integer)\n-      is\n-         Diff_M        : OS_Time;\n-         Diff_S        : OS_Time;\n-         Earlier       : OS_Time;\n-         Elapsed_Leaps : Natural;\n-         Later         : OS_Time;\n-         Negate        : Boolean := False;\n-         Next_Leap     : OS_Time;\n-         Sub_Seconds   : Duration;\n-\n-      begin\n-         --  This classification is necessary in order to avoid a Time_Error\n-         --  being raised by the arithmetic operators in Ada.Calendar.\n-\n-         if Left >= Right then\n-            Later   := OS_Time (Left);\n-            Earlier := OS_Time (Right);\n-         else\n-            Later   := OS_Time (Right);\n-            Earlier := OS_Time (Left);\n-            Negate  := True;\n-         end if;\n-\n-         --  If the target supports leap seconds, process them\n-\n-         if Leap_Support then\n-            Cumulative_Leap_Seconds\n-              (Earlier, Later, Elapsed_Leaps, Next_Leap);\n-\n-            if Later >= Next_Leap then\n-               Elapsed_Leaps := Elapsed_Leaps + 1;\n-            end if;\n-\n-         --  The target does not support leap seconds\n-\n-         else\n-            Elapsed_Leaps := 0;\n-         end if;\n-\n-         Diff_M := Later - Earlier - OS_Time (Elapsed_Leaps) * Mili;\n-\n-         --  Sub second processing\n-\n-         Sub_Seconds := Duration (Diff_M mod Mili) / Mili_F;\n-\n-         --  Convert to seconds. Note that his action eliminates the sub\n-         --  seconds automatically.\n-\n-         Diff_S := Diff_M / Mili;\n-\n-         Days := Long_Integer (Diff_S / Secs_In_Day);\n-         Seconds := Duration (Diff_S mod Secs_In_Day) + Sub_Seconds;\n-         Leap_Seconds := Integer (Elapsed_Leaps);\n-\n-         if Negate then\n-            Days    := -Days;\n-            Seconds := -Seconds;\n-\n-            if Leap_Seconds /= 0 then\n-               Leap_Seconds := -Leap_Seconds;\n-            end if;\n-         end if;\n-      end Difference;\n-\n-      --------------\n-      -- Subtract --\n-      --------------\n-\n-      function Subtract (Date : Time; Days : Long_Integer) return Time is\n-         pragma Unsuppress (Overflow_Check);\n-         Date_M : constant OS_Time := OS_Time (Date);\n-      begin\n-         return Time (Date_M - OS_Time (Days) * Milis_In_Day);\n-      exception\n-         when Constraint_Error =>\n-            raise Time_Error;\n-      end Subtract;\n-   end Arithmetic_Operations;\n-\n-   ---------------------------\n-   -- Conversion_Operations --\n-   ---------------------------\n-\n-   package body Conversion_Operations is\n-\n-      Epoch_Offset : constant OS_Time := 35067168000000000;\n-      --  The difference between 1970-1-1 UTC and 1858-11-17 UTC expressed in\n-      --  100 nanoseconds.\n-\n-      -----------------\n-      -- To_Ada_Time --\n-      -----------------\n-\n-      function To_Ada_Time (Unix_Time : Long_Integer) return Time is\n-         pragma Unsuppress (Overflow_Check);\n-         Unix_Rep : constant OS_Time := OS_Time (Unix_Time) * Mili;\n-      begin\n-         return Time (Unix_Rep + Epoch_Offset);\n-      exception\n-         when Constraint_Error =>\n-            raise Time_Error;\n-      end To_Ada_Time;\n-\n-      -----------------\n-      -- To_Ada_Time --\n-      -----------------\n-\n-      function To_Ada_Time\n-        (tm_year  : Integer;\n-         tm_mon   : Integer;\n-         tm_day   : Integer;\n-         tm_hour  : Integer;\n-         tm_min   : Integer;\n-         tm_sec   : Integer;\n-         tm_isdst : Integer) return Time\n-      is\n-         pragma Unsuppress (Overflow_Check);\n-\n-         Year_Shift  : constant Integer := 1900;\n-         Month_Shift : constant Integer := 1;\n-\n-         Year   : Year_Number;\n-         Month  : Month_Number;\n-         Day    : Day_Number;\n-         Second : Integer;\n-         Leap   : Boolean;\n-         Result : OS_Time;\n-\n-      begin\n-         --  Input processing\n-\n-         Year  := Year_Number (Year_Shift + tm_year);\n-         Month := Month_Number (Month_Shift + tm_mon);\n-         Day   := Day_Number (tm_day);\n-\n-         --  Step 1: Validity checks of input values\n-\n-         if not Year'Valid\n-           or else not Month'Valid\n-           or else not Day'Valid\n-           or else tm_hour not in 0 .. 24\n-           or else tm_min not in 0 .. 59\n-           or else tm_sec not in 0 .. 60\n-           or else tm_isdst not in -1 .. 1\n-         then\n-            raise Time_Error;\n-         end if;\n-\n-         --  Step 2: Potential leap second\n-\n-         if tm_sec = 60 then\n-            Leap   := True;\n-            Second := 59;\n-         else\n-            Leap   := False;\n-            Second := tm_sec;\n-         end if;\n-\n-         --  Step 3: Calculate the time value\n-\n-         Result :=\n-           OS_Time\n-             (Formatting_Operations.Time_Of\n-               (Year         => Year,\n-                Month        => Month,\n-                Day          => Day,\n-                Day_Secs     => 0.0,      --  Time is given in h:m:s\n-                Hour         => tm_hour,\n-                Minute       => tm_min,\n-                Second       => Second,\n-                Sub_Sec      => 0.0,      --  No precise sub second given\n-                Leap_Sec     => Leap,\n-                Use_Day_Secs => False,    --  Time is given in h:m:s\n-                Use_TZ       => True,     --  Force usage of explicit time zone\n-                Is_Historic  => True,\n-                Time_Zone    => 0));      --  Place the value in UTC\n-         --  Step 4: Daylight Savings Time\n-\n-         if tm_isdst = 1 then\n-            Result := Result + OS_Time (3_600) * Mili;\n-         end if;\n-\n-         return Time (Result);\n-      exception\n-         when Constraint_Error =>\n-            raise Time_Error;\n-      end To_Ada_Time;\n-\n-      -----------------\n-      -- To_Duration --\n-      -----------------\n-\n-      function To_Duration\n-        (tv_sec  : Long_Integer;\n-         tv_nsec : Long_Integer) return Duration\n-      is\n-         pragma Unsuppress (Overflow_Check);\n-      begin\n-         return Duration (tv_sec) + Duration (tv_nsec) / Mili_F;\n-      end To_Duration;\n-\n-      ------------------------\n-      -- To_Struct_Timespec --\n-      ------------------------\n-\n-      procedure To_Struct_Timespec\n-        (D       : Duration;\n-         tv_sec  : out Long_Integer;\n-         tv_nsec : out Long_Integer)\n-      is\n-         pragma Unsuppress (Overflow_Check);\n-         Secs      : Duration;\n-         Nano_Secs : Duration;\n-\n-      begin\n-         --  Seconds extraction, avoid potential rounding errors\n-\n-         Secs   := D - 0.5;\n-         tv_sec := Long_Integer (Secs);\n-\n-         --  100 Nanoseconds extraction\n-\n-         Nano_Secs := D - Duration (tv_sec);\n-         tv_nsec := Long_Integer (Nano_Secs * Mili);\n-      end To_Struct_Timespec;\n-\n-      ------------------\n-      -- To_Struct_Tm --\n-      ------------------\n-\n-      procedure To_Struct_Tm\n-        (T       : Time;\n-         tm_year : out Integer;\n-         tm_mon  : out Integer;\n-         tm_day  : out Integer;\n-         tm_hour : out Integer;\n-         tm_min  : out Integer;\n-         tm_sec  : out Integer)\n-      is\n-         pragma Unsuppress (Overflow_Check);\n-         Year      : Year_Number;\n-         Month     : Month_Number;\n-         Second    : Integer;\n-         Day_Secs  : Day_Duration;\n-         Sub_Sec   : Duration;\n-         Leap_Sec  : Boolean;\n-\n-      begin\n-         --  Step 1: Split the input time\n-\n-         Formatting_Operations.Split\n-           (Date        => T,\n-            Year        => Year,\n-            Month       => Month,\n-            Day         => tm_day,\n-            Day_Secs    => Day_Secs,\n-            Hour        => tm_hour,\n-            Minute      => tm_min,\n-            Second      => Second,\n-            Sub_Sec     => Sub_Sec,\n-            Leap_Sec    => Leap_Sec,\n-            Use_TZ      => True,\n-            Is_Historic => False,\n-            Time_Zone   => 0);\n-\n-         --  Step 2: Correct the year and month\n-\n-         tm_year := Year - 1900;\n-         tm_mon  := Month - 1;\n-\n-         --  Step 3: Handle leap second occurrences\n-\n-         tm_sec := (if Leap_Sec then 60 else Second);\n-      end To_Struct_Tm;\n-\n-      ------------------\n-      -- To_Unix_Time --\n-      ------------------\n-\n-      function To_Unix_Time (Ada_Time : Time) return Long_Integer is\n-         pragma Unsuppress (Overflow_Check);\n-         Ada_OS_Time : constant OS_Time := OS_Time (Ada_Time);\n-      begin\n-         return Long_Integer ((Ada_OS_Time - Epoch_Offset) / Mili);\n-      exception\n-         when Constraint_Error =>\n-            raise Time_Error;\n-      end To_Unix_Time;\n-   end Conversion_Operations;\n-\n-   ---------------------------\n-   -- Formatting_Operations --\n-   ---------------------------\n-\n-   package body Formatting_Operations is\n-\n-      -----------------\n-      -- Day_Of_Week --\n-      -----------------\n-\n-      function Day_Of_Week (Date : Time) return Integer is\n-         Y : Year_Number;\n-         M : Month_Number;\n-         D : Day_Number;\n-         S : Day_Duration;\n-\n-         Day_Count     : Long_Integer;\n-         Midday_Date_S : Time;\n-\n-      begin\n-         Split (Date, Y, M, D, S);\n-\n-         --  Build a time value in the middle of the same day and convert the\n-         --  time value to seconds.\n-\n-         Midday_Date_S := Time_Of (Y, M, D, 43_200.0) / Mili;\n-\n-         --  Count the number of days since the start of VMS time. 1858-11-17\n-         --  was a Wednesday.\n-\n-         Day_Count := Long_Integer (Midday_Date_S / Secs_In_Day) + 2;\n-\n-         return Integer (Day_Count mod 7);\n-      end Day_Of_Week;\n-\n-      -----------\n-      -- Split --\n-      -----------\n-\n-      procedure Split\n-        (Date        : Time;\n-         Year        : out Year_Number;\n-         Month       : out Month_Number;\n-         Day         : out Day_Number;\n-         Day_Secs    : out Day_Duration;\n-         Hour        : out Integer;\n-         Minute      : out Integer;\n-         Second      : out Integer;\n-         Sub_Sec     : out Duration;\n-         Leap_Sec    : out Boolean;\n-         Use_TZ      : Boolean;\n-         Is_Historic : Boolean;\n-         Time_Zone   : Long_Integer)\n-      is\n-         --  Flags Use_TZ and Is_Historic are present for interfacing purposes\n-\n-         pragma Unreferenced (Use_TZ, Is_Historic);\n-\n-         procedure Numtim\n-           (Status : out Unsigned_Longword;\n-            Timbuf : out Unsigned_Word_Array;\n-            Timadr : Time);\n-\n-         pragma Import (External, Numtim);\n-\n-         pragma Import_Valued_Procedure\n-           (Numtim, \"SYS$NUMTIM\",\n-           (Unsigned_Longword, Unsigned_Word_Array, Time),\n-           (Value, Reference, Reference));\n-\n-         Status : Unsigned_Longword;\n-         Timbuf : Unsigned_Word_Array (1 .. 7);\n-\n-         Ada_Min_Year : constant := 1901;\n-         Ada_Max_Year : constant := 2399;\n-\n-         Date_M        : OS_Time;\n-         Elapsed_Leaps : Natural;\n-         Next_Leap_M   : OS_Time;\n-\n-      begin\n-         Date_M := OS_Time (Date);\n-\n-         --  Step 1: Leap seconds processing\n-\n-         if Leap_Support then\n-            Cumulative_Leap_Seconds\n-              (Start_Of_Time, Date_M, Elapsed_Leaps, Next_Leap_M);\n-\n-            Leap_Sec := Date_M >= Next_Leap_M;\n-\n-            if Leap_Sec then\n-               Elapsed_Leaps := Elapsed_Leaps + 1;\n-            end if;\n-\n-         --  The target does not support leap seconds\n-\n-         else\n-            Elapsed_Leaps := 0;\n-            Leap_Sec      := False;\n-         end if;\n-\n-         Date_M := Date_M - OS_Time (Elapsed_Leaps) * Mili;\n-\n-         --  Step 2: Time zone processing\n-\n-         if Time_Zone /= 0 then\n-            Date_M := Date_M + OS_Time (Time_Zone) * 60 * Mili;\n-         end if;\n-\n-         --  After the leap seconds and time zone have been accounted for,\n-         --  the date should be within the bounds of Ada time.\n-\n-         if Date_M < Ada_Low\n-           or else Date_M > Ada_High\n-         then\n-            raise Time_Error;\n-         end if;\n-\n-         --  Step 3: Sub second processing\n-\n-         Sub_Sec := Duration (Date_M mod Mili) / Mili_F;\n-\n-         --  Drop the sub seconds\n-\n-         Date_M := Date_M - (Date_M mod Mili);\n-\n-         --  Step 4: VMS system call\n-\n-         Numtim (Status, Timbuf, Time (Date_M));\n-\n-         if Status mod 2 /= 1\n-           or else Timbuf (1) not in Ada_Min_Year .. Ada_Max_Year\n-         then\n-            raise Time_Error;\n-         end if;\n-\n-         --  Step 5: Time components processing\n-\n-         Year   := Year_Number (Timbuf (1));\n-         Month  := Month_Number (Timbuf (2));\n-         Day    := Day_Number (Timbuf (3));\n-         Hour   := Integer (Timbuf (4));\n-         Minute := Integer (Timbuf (5));\n-         Second := Integer (Timbuf (6));\n-\n-         Day_Secs := Day_Duration (Hour   * 3_600) +\n-                     Day_Duration (Minute *    60) +\n-                     Day_Duration (Second)         +\n-                                   Sub_Sec;\n-      end Split;\n-\n-      -------------\n-      -- Time_Of --\n-      -------------\n-\n-      function Time_Of\n-        (Year         : Year_Number;\n-         Month        : Month_Number;\n-         Day          : Day_Number;\n-         Day_Secs     : Day_Duration;\n-         Hour         : Integer;\n-         Minute       : Integer;\n-         Second       : Integer;\n-         Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean;\n-         Use_Day_Secs : Boolean;\n-         Use_TZ       : Boolean;\n-         Is_Historic  : Boolean;\n-         Time_Zone    : Long_Integer) return Time\n-      is\n-         --  Flag Is_Historic is present for interfacing purposes\n-\n-         pragma Unreferenced (Is_Historic);\n-\n-         procedure Cvt_Vectim\n-           (Status         : out Unsigned_Longword;\n-            Input_Time     : Unsigned_Word_Array;\n-            Resultant_Time : out Time);\n-\n-         pragma Import (External, Cvt_Vectim);\n-\n-         pragma Import_Valued_Procedure\n-           (Cvt_Vectim, \"LIB$CVT_VECTIM\",\n-           (Unsigned_Longword, Unsigned_Word_Array, Time),\n-           (Value, Reference, Reference));\n-\n-         Status : Unsigned_Longword;\n-         Timbuf : Unsigned_Word_Array (1 .. 7);\n-\n-         Y  : Year_Number  := Year;\n-         Mo : Month_Number := Month;\n-         D  : Day_Number   := Day;\n-         H  : Integer      := Hour;\n-         Mi : Integer      := Minute;\n-         Se : Integer      := Second;\n-         Su : Duration     := Sub_Sec;\n-\n-         Elapsed_Leaps : Natural;\n-         Int_Day_Secs  : Integer;\n-         Next_Leap_M   : OS_Time;\n-         Res           : Time;\n-         Res_M         : OS_Time;\n-         Rounded_Res_M : OS_Time;\n-\n-      begin\n-         --  No validity checks are performed on the input values since it is\n-         --  assumed that the called has already performed them.\n-\n-         --  Step 1: Hour, minute, second and sub second processing\n-\n-         if Use_Day_Secs then\n-\n-            --  A day seconds value of 86_400 designates a new day\n-\n-            if Day_Secs = 86_400.0 then\n-               declare\n-                  Adj_Year  : Year_Number := Year;\n-                  Adj_Month : Month_Number := Month;\n-                  Adj_Day   : Day_Number   := Day;\n-\n-               begin\n-                  if Day < Days_In_Month (Month)\n-                    or else (Month = 2\n-                               and then Is_Leap (Year))\n-                  then\n-                     Adj_Day := Day + 1;\n-\n-                  --  The day adjustment moves the date to a new month\n-\n-                  else\n-                     Adj_Day := 1;\n-\n-                     if Month < 12 then\n-                        Adj_Month := Month + 1;\n-\n-                     --  The month adjustment moves the date to a new year\n-\n-                     else\n-                        Adj_Month := 1;\n-                        Adj_Year  := Year + 1;\n-                     end if;\n-                  end if;\n-\n-                  Y  := Adj_Year;\n-                  Mo := Adj_Month;\n-                  D  := Adj_Day;\n-                  H  := 0;\n-                  Mi := 0;\n-                  Se := 0;\n-                  Su := 0.0;\n-               end;\n-\n-            --  Normal case (not exactly one day)\n-\n-            else\n-               --  Sub second extraction\n-\n-               Int_Day_Secs :=\n-                 (if Day_Secs > 0.0\n-                  then Integer (Day_Secs - 0.5)\n-                  else Integer (Day_Secs));\n-\n-               H  := Int_Day_Secs / 3_600;\n-               Mi := (Int_Day_Secs / 60) mod 60;\n-               Se := Int_Day_Secs mod 60;\n-               Su := Day_Secs - Duration (Int_Day_Secs);\n-            end if;\n-         end if;\n-\n-         --  Step 2: System call to VMS\n-\n-         Timbuf (1) := Unsigned_Word (Y);\n-         Timbuf (2) := Unsigned_Word (Mo);\n-         Timbuf (3) := Unsigned_Word (D);\n-         Timbuf (4) := Unsigned_Word (H);\n-         Timbuf (5) := Unsigned_Word (Mi);\n-         Timbuf (6) := Unsigned_Word (Se);\n-         Timbuf (7) := 0;\n-\n-         Cvt_Vectim (Status, Timbuf, Res);\n-\n-         if Status mod 2 /= 1 then\n-            raise Time_Error;\n-         end if;\n-\n-         --  Step 3: Sub second adjustment\n-\n-         Res_M := OS_Time (Res) + OS_Time (Su * Mili_F);\n-\n-         --  Step 4: Bounds check\n-\n-         Check_Within_Time_Bounds (Res_M);\n-\n-         --  Step 5: Time zone processing\n-\n-         if Time_Zone /= 0 then\n-            Res_M := Res_M - OS_Time (Time_Zone) * 60 * Mili;\n-         end if;\n-\n-         --  Step 6: Leap seconds processing\n-\n-         if Leap_Support then\n-            Cumulative_Leap_Seconds\n-              (Start_Of_Time, Res_M, Elapsed_Leaps, Next_Leap_M);\n-\n-            Res_M := Res_M + OS_Time (Elapsed_Leaps) * Mili;\n-\n-            --  An Ada 2005 caller requesting an explicit leap second or an\n-            --  Ada 95 caller accounting for an invisible leap second.\n-\n-            if Leap_Sec\n-              or else Res_M >= Next_Leap_M\n-            then\n-               Res_M := Res_M + OS_Time (1) * Mili;\n-            end if;\n-\n-            --  Leap second validity check\n-\n-            Rounded_Res_M := Res_M - (Res_M mod Mili);\n-\n-            if Use_TZ\n-              and then Leap_Sec\n-              and then Rounded_Res_M /= Next_Leap_M\n-            then\n-               raise Time_Error;\n-            end if;\n-         end if;\n-\n-         return Time (Res_M);\n-      end Time_Of;\n-   end Formatting_Operations;\n-\n-   ---------------------------\n-   -- Time_Zones_Operations --\n-   ---------------------------\n-\n-   package body Time_Zones_Operations is\n-\n-      ---------------------\n-      -- UTC_Time_Offset --\n-      ---------------------\n-\n-      function UTC_Time_Offset (Date : Time) return Long_Integer is\n-         --  Formal parameter Date is here for interfacing, but is never\n-         --  actually used.\n-\n-         pragma Unreferenced (Date);\n-\n-         function get_gmtoff return Long_Integer;\n-         pragma Import (C, get_gmtoff, \"get_gmtoff\");\n-\n-      begin\n-         --  VMS is not capable of determining the time zone in some past or\n-         --  future point in time denoted by Date, thus the current time zone\n-         --  is retrieved.\n-\n-         return get_gmtoff;\n-      end UTC_Time_Offset;\n-   end Time_Zones_Operations;\n-end Ada.Calendar;"}, {"sha": "744011ae00871e042eff2742a881cc075ede2d47", "filename": "gcc/ada/a-calend-vms.ads", "status": "removed", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-calend-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-calend-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,310 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                         A D A . C A L E N D A R                          --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS version\n-\n-with System.OS_Primitives;\n-\n-package Ada.Calendar is\n-\n-   type Time is private;\n-\n-   --  Declarations representing limits of allowed local time values. Note that\n-   --  these do NOT constrain the possible stored values of time which may well\n-   --  permit a larger range of times (this is explicitly allowed in Ada 95).\n-\n-   subtype Year_Number  is Integer range 1901 .. 2399;\n-   subtype Month_Number is Integer range 1 .. 12;\n-   subtype Day_Number   is Integer range 1 .. 31;\n-\n-   subtype Day_Duration is Duration range 0.0 .. 86_400.0;\n-   --  Note that a value of 86_400.0 is the start of the next day\n-\n-   function Clock return Time;\n-   --  The returned time value is the number of nanoseconds since the start\n-   --  of Ada time (1901-01-01 00:00:00.0 UTC). If leap seconds are enabled,\n-   --  the result will contain all elapsed leap seconds since the start of\n-   --  Ada time until now.\n-\n-   function Year    (Date : Time) return Year_Number;\n-   function Month   (Date : Time) return Month_Number;\n-   function Day     (Date : Time) return Day_Number;\n-   function Seconds (Date : Time) return Day_Duration;\n-\n-   procedure Split\n-     (Date    : Time;\n-      Year    : out Year_Number;\n-      Month   : out Month_Number;\n-      Day     : out Day_Number;\n-      Seconds : out Day_Duration);\n-   --  Break down a time value into its date components set in the current\n-   --  time zone. If Split is called on a time value created using Ada 2005\n-   --  Time_Of in some arbitrary time zone, the input value will always be\n-   --  interpreted as relative to the local time zone.\n-\n-   function Time_Of\n-     (Year    : Year_Number;\n-      Month   : Month_Number;\n-      Day     : Day_Number;\n-      Seconds : Day_Duration := 0.0) return Time;\n-   --  GNAT Note: Normally when procedure Split is called on a Time value\n-   --  result of a call to function Time_Of, the out parameters of procedure\n-   --  Split are identical to the in parameters of function Time_Of. However,\n-   --  when a non-existent time of day is specified, the values for Seconds\n-   --  may or may not be different. This may happen when Daylight Saving Time\n-   --  (DST) is in effect, on the day when switching to DST, if Seconds\n-   --  specifies a time of day in the hour that does not exist. For example,\n-   --  in New York:\n-   --\n-   --    Time_Of (Year => 1998, Month => 4, Day => 5, Seconds => 10740.0)\n-   --\n-   --  will return a Time value T. If Split is called on T, the resulting\n-   --  Seconds may be 14340.0 (3:59:00) instead of 10740.0 (2:59:00 being\n-   --  a time that not exist).\n-\n-   function \"+\" (Left : Time;     Right : Duration) return Time;\n-   function \"+\" (Left : Duration; Right : Time)     return Time;\n-   function \"-\" (Left : Time;     Right : Duration) return Time;\n-   function \"-\" (Left : Time;     Right : Time)     return Duration;\n-   --  The first three functions will raise Time_Error if the resulting time\n-   --  value is less than the start of Ada time in UTC or greater than the\n-   --  end of Ada time in UTC. The last function will raise Time_Error if the\n-   --  resulting difference cannot fit into a duration value.\n-\n-   function \"<\"  (Left, Right : Time) return Boolean;\n-   function \"<=\" (Left, Right : Time) return Boolean;\n-   function \">\"  (Left, Right : Time) return Boolean;\n-   function \">=\" (Left, Right : Time) return Boolean;\n-\n-   Time_Error : exception;\n-\n-private\n-   pragma Inline (Clock);\n-\n-   pragma Inline (Year);\n-   pragma Inline (Month);\n-   pragma Inline (Day);\n-\n-   pragma Inline (\"+\");\n-   pragma Inline (\"-\");\n-\n-   pragma Inline (\"<\");\n-   pragma Inline (\"<=\");\n-   pragma Inline (\">\");\n-   pragma Inline (\">=\");\n-\n-   --  Although the units are 100 nanoseconds, for the purpose of better\n-   --  readability, this unit will be called \"mili\".\n-\n-   Mili         : constant := 10_000_000;\n-   Mili_F       : constant := 10_000_000.0;\n-   Milis_In_Day : constant := 864_000_000_000;\n-   Secs_In_Day  : constant := 86_400;\n-\n-   --  Time is represented as the number of 100-nanosecond (ns) units from the\n-   --  system base date and time 1858-11-17 0.0 (the Smithsonian base date and\n-   --  time for the astronomic calendar).\n-\n-   --  The time value stored is typically a UTC value, as provided in standard\n-   --  Unix environments. If this is the case then Split and Time_Of perform\n-   --  required conversions to and from local times.\n-\n-   --  Notwithstanding this definition, Time is not quite the same as OS_Time.\n-   --  Relative Time is positive, whereas relative OS_Time is negative,\n-   --  but this declaration makes for easier conversion.\n-\n-   type Time is new System.OS_Primitives.OS_Time;\n-\n-   Days_In_Month : constant array (Month_Number) of Day_Number :=\n-                     (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);\n-   --  Days in month for non-leap year, leap year case is adjusted in code\n-\n-   Invalid_Time_Zone_Offset : Long_Integer;\n-   pragma Import (C, Invalid_Time_Zone_Offset, \"__gnat_invalid_tzoff\");\n-\n-   function Is_Leap (Year : Year_Number) return Boolean;\n-   --  Determine whether a given year is leap\n-\n-   ----------------------------------------------------------\n-   -- Target-Independent Interface to Children of Calendar --\n-   ----------------------------------------------------------\n-\n-   --  The following packages provide a target-independent interface to the\n-   --  children of Calendar - Arithmetic, Conversions, Delays, Formatting and\n-   --  Time_Zones.\n-\n-   --  NOTE: Delays does not need a target independent interface because\n-   --  VMS already has a target specific file for that package.\n-\n-   ---------------------------\n-   -- Arithmetic_Operations --\n-   ---------------------------\n-\n-   package Arithmetic_Operations is\n-\n-      function Add (Date : Time; Days : Long_Integer) return Time;\n-      --  Add a certain number of days to a time value\n-\n-      procedure Difference\n-        (Left         : Time;\n-         Right        : Time;\n-         Days         : out Long_Integer;\n-         Seconds      : out Duration;\n-         Leap_Seconds : out Integer);\n-      --  Calculate the difference between two time values in terms of days,\n-      --  seconds and leap seconds elapsed. The leap seconds are not included\n-      --  in the seconds returned. If Left is greater than Right, the returned\n-      --  values are positive, negative otherwise.\n-\n-      function Subtract (Date : Time; Days : Long_Integer) return Time;\n-      --  Subtract a certain number of days from a time value\n-\n-   end Arithmetic_Operations;\n-\n-   ---------------------------\n-   -- Conversion_Operations --\n-   ---------------------------\n-\n-   package Conversion_Operations is\n-\n-      function To_Ada_Time (Unix_Time : Long_Integer) return Time;\n-      --  Unix to Ada Epoch conversion\n-\n-      function To_Ada_Time\n-        (tm_year  : Integer;\n-         tm_mon   : Integer;\n-         tm_day   : Integer;\n-         tm_hour  : Integer;\n-         tm_min   : Integer;\n-         tm_sec   : Integer;\n-         tm_isdst : Integer) return Time;\n-      --  Struct tm to Ada Epoch conversion\n-\n-      function To_Duration\n-        (tv_sec  : Long_Integer;\n-         tv_nsec : Long_Integer) return Duration;\n-      --  Struct timespec to Duration conversion\n-\n-      procedure To_Struct_Timespec\n-        (D       : Duration;\n-         tv_sec  : out Long_Integer;\n-         tv_nsec : out Long_Integer);\n-      --  Duration to struct timespec conversion\n-\n-      procedure To_Struct_Tm\n-        (T       : Time;\n-         tm_year : out Integer;\n-         tm_mon  : out Integer;\n-         tm_day  : out Integer;\n-         tm_hour : out Integer;\n-         tm_min  : out Integer;\n-         tm_sec  : out Integer);\n-      --  Time to struct tm conversion\n-\n-      function To_Unix_Time (Ada_Time : Time) return Long_Integer;\n-      --  Ada to Unix Epoch conversion\n-\n-   end Conversion_Operations;\n-\n-   ---------------------------\n-   -- Formatting_Operations --\n-   ---------------------------\n-\n-   package Formatting_Operations is\n-\n-      function Day_Of_Week (Date : Time) return Integer;\n-      --  Determine which day of week Date falls on. The returned values are\n-      --  within the range of 0 .. 6 (Monday .. Sunday).\n-\n-      procedure Split\n-        (Date        : Time;\n-         Year        : out Year_Number;\n-         Month       : out Month_Number;\n-         Day         : out Day_Number;\n-         Day_Secs    : out Day_Duration;\n-         Hour        : out Integer;\n-         Minute      : out Integer;\n-         Second      : out Integer;\n-         Sub_Sec     : out Duration;\n-         Leap_Sec    : out Boolean;\n-         Use_TZ      : Boolean;\n-         Is_Historic : Boolean;\n-         Time_Zone   : Long_Integer);\n-      pragma Export (Ada, Split, \"__gnat_split\");\n-      --  Split a time value into its components. If flag Is_Historic is set,\n-      --  this routine would try to use to the best of the OS's abilities the\n-      --  time zone offset that was or will be in effect on Date. Set Use_TZ\n-      --  to use the local time zone (the value in Time_Zone is ignored) when\n-      --  splitting a time value.\n-\n-      function Time_Of\n-        (Year         : Year_Number;\n-         Month        : Month_Number;\n-         Day          : Day_Number;\n-         Day_Secs     : Day_Duration;\n-         Hour         : Integer;\n-         Minute       : Integer;\n-         Second       : Integer;\n-         Sub_Sec      : Duration;\n-         Leap_Sec     : Boolean;\n-         Use_Day_Secs : Boolean;\n-         Use_TZ       : Boolean;\n-         Is_Historic  : Boolean;\n-         Time_Zone    : Long_Integer) return Time;\n-      pragma Export (Ada, Time_Of, \"__gnat_time_of\");\n-      --  Given all the components of a date, return the corresponding time\n-      --  value. Set Use_Day_Secs to use the value in Day_Secs, otherwise the\n-      --  day duration will be calculated from Hour, Minute, Second and Sub_\n-      --  Sec. If flag Is_Historic is set, this routine would try to use to the\n-      --  best of the OS's abilities the time zone offset that was or will be\n-      --  in effect on the input date. Set Use_TZ to use the local time zone\n-      --  (the value in formal Time_Zone is ignored) when building a time value\n-      --  and to verify the validity of a requested leap second.\n-\n-   end Formatting_Operations;\n-\n-   ---------------------------\n-   -- Time_Zones_Operations --\n-   ---------------------------\n-\n-   package Time_Zones_Operations is\n-\n-      function UTC_Time_Offset (Date : Time) return Long_Integer;\n-      --  Return (in seconds) the difference between the local time zone and\n-      --  UTC time at a specific historic date.\n-\n-   end Time_Zones_Operations;\n-\n-end Ada.Calendar;"}, {"sha": "c9a08310d749273a7a45a428dcc49d530e800232", "filename": "gcc/ada/a-dirval-vms.adb", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-dirval-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-dirval-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-dirval-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,200 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---             A D A . D I R E C T O R I E S . V A L I D I T Y              --\n---                                                                          --\n---                                 B o d y                                  --\n---                              (VMS Version)                               --\n---                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS version of this package\n-\n-package body Ada.Directories.Validity is\n-\n-   Max_Number_Of_Characters : constant := 39;\n-   Max_Path_Length          : constant := 1_024;\n-\n-   Invalid_Character : constant array (Character) of Boolean :=\n-     ('a' .. 'z' => False,\n-      'A' .. 'Z' => False,\n-      '0' .. '9' => False,\n-      '_' | '$' | '-' | '.' => False,\n-      others => True);\n-\n-   ---------------------------------\n-   -- Is_Path_Name_Case_Sensitive --\n-   ---------------------------------\n-\n-   function Is_Path_Name_Case_Sensitive return Boolean is\n-   begin\n-      return False;\n-   end Is_Path_Name_Case_Sensitive;\n-\n-   ------------------------\n-   -- Is_Valid_Path_Name --\n-   ------------------------\n-\n-   function Is_Valid_Path_Name (Name : String) return Boolean is\n-      First     : Positive := Name'First;\n-      Last      : Positive;\n-      Dot_Found : Boolean := False;\n-\n-   begin\n-      --  A valid path (directory) name cannot be empty, and cannot contain\n-      --  more than 1024 characters. Directories can be \".\", \"..\" or be simple\n-      --  name without extensions.\n-\n-      if Name'Length = 0 or else Name'Length > Max_Path_Length then\n-         return False;\n-\n-      else\n-         loop\n-            --  Look for the start of the next directory or file name\n-\n-            while First <= Name'Last and then Name (First) = '/' loop\n-               First := First + 1;\n-            end loop;\n-\n-            --  If all directories/file names are OK, return True\n-\n-            exit when First > Name'Last;\n-\n-            Last := First;\n-            Dot_Found := False;\n-\n-            --  Look for the end of the directory/file name\n-\n-            while Last < Name'Last loop\n-               exit when Name (Last + 1) = '/';\n-               Last := Last + 1;\n-\n-               if Name (Last) = '.' then\n-                  Dot_Found := True;\n-               end if;\n-            end loop;\n-\n-            --  If name include a dot, it can only be \".\", \"..\" or the last\n-            --  file name.\n-\n-            if Dot_Found then\n-               if Name (First .. Last) /= \".\" and then\n-                  Name (First .. Last) /= \"..\"\n-               then\n-                  return Last = Name'Last\n-                    and then Is_Valid_Simple_Name (Name (First .. Last));\n-\n-               end if;\n-\n-            --  Check if the directory/file name is valid\n-\n-            elsif not Is_Valid_Simple_Name (Name (First .. Last)) then\n-                  return False;\n-            end if;\n-\n-            --  Move to the next name\n-\n-            First := Last + 1;\n-         end loop;\n-      end if;\n-\n-      --  If Name follows the rules, then it is valid\n-\n-      return True;\n-   end Is_Valid_Path_Name;\n-\n-   --------------------------\n-   -- Is_Valid_Simple_Name --\n-   --------------------------\n-\n-   function Is_Valid_Simple_Name (Name : String) return Boolean is\n-      In_Extension         : Boolean := False;\n-      Number_Of_Characters : Natural := 0;\n-\n-   begin\n-      --  A file name cannot be empty, and cannot have more than 39 characters\n-      --  before or after a single '.'.\n-\n-      if Name'Length = 0 then\n-         return False;\n-\n-      else\n-         --  Check each character for validity\n-\n-         for J in Name'Range loop\n-            if Invalid_Character (Name (J)) then\n-               return False;\n-\n-            elsif Name (J) = '.' then\n-\n-               --  Name cannot contain several dots\n-\n-               if In_Extension then\n-                  return False;\n-\n-               else\n-                  --  Reset the number of characters to count the characters\n-                  --  of the extension.\n-\n-                  In_Extension := True;\n-                  Number_Of_Characters := 0;\n-               end if;\n-\n-            else\n-               --  Check that the number of character is not too large\n-\n-               Number_Of_Characters := Number_Of_Characters + 1;\n-\n-               if Number_Of_Characters > Max_Number_Of_Characters then\n-                  return False;\n-               end if;\n-            end if;\n-         end loop;\n-      end if;\n-\n-      --  If the rules are followed, then it is valid\n-\n-      return True;\n-   end Is_Valid_Simple_Name;\n-\n-   -------------\n-   -- OpenVMS --\n-   -------------\n-\n-   function OpenVMS return Boolean is\n-   begin\n-      return True;\n-   end OpenVMS;\n-\n-   -------------\n-   -- Windows --\n-   -------------\n-\n-   function Windows return Boolean is\n-   begin\n-      return False;\n-   end Windows;\n-\n-end Ada.Directories.Validity;"}, {"sha": "9bbff6b832356247ed9eb0e1a1d9b963267189d1", "filename": "gcc/ada/a-intnam-linux.ads", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fa-intnam-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fa-intnam-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intnam-linux.ads?ref=f9648959b41d5c443702c809676056f1f39c56de", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1991-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,12 +31,7 @@\n \n --  This is a GNU/Linux version of this package\n \n---  The following signals are reserved by the run time (FSU threads):\n-\n---  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,\n---  SIGALRM, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL\n-\n---  The following signals are reserved by the run time (LinuxThreads):\n+--  The following signals are reserved by the run time:\n \n --  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,\n --  SIGUSR1, SIGUSR2, SIGVTALRM, SIGUNUSED, SIGSTOP, SIGKILL"}, {"sha": "30f98d334661adaf9744e520dc414987235059ae", "filename": "gcc/ada/a-intnam-vms.ads", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-intnam-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-intnam-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intnam-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,80 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   A D A . I N T E R R U P T S . N A M E S                --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/Alpha version of this package\n-\n---  This target-dependent package spec contains names of interrupts\n---  supported by the local system.\n-\n-with System.OS_Interface;\n-\n-package Ada.Interrupts.Names is\n-\n-   --  All identifiers in this unit are implementation defined\n-\n-   pragma Implementation_Defined;\n-\n-   package OS renames System.OS_Interface;\n-\n-   Interrupt_ID_0   : constant Interrupt_ID := OS.Interrupt_ID_0;\n-   Interrupt_ID_1   : constant Interrupt_ID := OS.Interrupt_ID_1;\n-   Interrupt_ID_2   : constant Interrupt_ID := OS.Interrupt_ID_2;\n-   Interrupt_ID_3   : constant Interrupt_ID := OS.Interrupt_ID_3;\n-   Interrupt_ID_4   : constant Interrupt_ID := OS.Interrupt_ID_4;\n-   Interrupt_ID_5   : constant Interrupt_ID := OS.Interrupt_ID_5;\n-   Interrupt_ID_6   : constant Interrupt_ID := OS.Interrupt_ID_6;\n-   Interrupt_ID_7   : constant Interrupt_ID := OS.Interrupt_ID_7;\n-   Interrupt_ID_8   : constant Interrupt_ID := OS.Interrupt_ID_8;\n-   Interrupt_ID_9   : constant Interrupt_ID := OS.Interrupt_ID_9;\n-   Interrupt_ID_10  : constant Interrupt_ID := OS.Interrupt_ID_10;\n-   Interrupt_ID_11  : constant Interrupt_ID := OS.Interrupt_ID_11;\n-   Interrupt_ID_12  : constant Interrupt_ID := OS.Interrupt_ID_12;\n-   Interrupt_ID_13  : constant Interrupt_ID := OS.Interrupt_ID_13;\n-   Interrupt_ID_14  : constant Interrupt_ID := OS.Interrupt_ID_14;\n-   Interrupt_ID_15  : constant Interrupt_ID := OS.Interrupt_ID_15;\n-   Interrupt_ID_16  : constant Interrupt_ID := OS.Interrupt_ID_16;\n-   Interrupt_ID_17  : constant Interrupt_ID := OS.Interrupt_ID_17;\n-   Interrupt_ID_18  : constant Interrupt_ID := OS.Interrupt_ID_18;\n-   Interrupt_ID_19  : constant Interrupt_ID := OS.Interrupt_ID_19;\n-   Interrupt_ID_20  : constant Interrupt_ID := OS.Interrupt_ID_20;\n-   Interrupt_ID_21  : constant Interrupt_ID := OS.Interrupt_ID_21;\n-   Interrupt_ID_22  : constant Interrupt_ID := OS.Interrupt_ID_22;\n-   Interrupt_ID_23  : constant Interrupt_ID := OS.Interrupt_ID_23;\n-   Interrupt_ID_24  : constant Interrupt_ID := OS.Interrupt_ID_24;\n-   Interrupt_ID_25  : constant Interrupt_ID := OS.Interrupt_ID_25;\n-   Interrupt_ID_26  : constant Interrupt_ID := OS.Interrupt_ID_26;\n-   Interrupt_ID_27  : constant Interrupt_ID := OS.Interrupt_ID_27;\n-   Interrupt_ID_28  : constant Interrupt_ID := OS.Interrupt_ID_28;\n-   Interrupt_ID_29  : constant Interrupt_ID := OS.Interrupt_ID_29;\n-   Interrupt_ID_30  : constant Interrupt_ID := OS.Interrupt_ID_30;\n-   Interrupt_ID_31  : constant Interrupt_ID := OS.Interrupt_ID_31;\n-\n-end Ada.Interrupts.Names;"}, {"sha": "f6d1dfa90816fd1271c476a211d548ecd6b830d7", "filename": "gcc/ada/a-numaux-vms.ads", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-numaux-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fa-numaux-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-numaux-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,104 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                     A D A . N U M E R I C S . A U X                      --\n---                                                                          --\n---                                 S p e c                                  --\n---                             (VMS Version)                                --\n---                                                                          --\n---          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides the basic computational interface for the generic\n---  elementary functions. The C library version interfaces with the routines\n---  in the C mathematical library, and is thus quite portable, although it may\n---  not necessarily meet the requirements for accuracy in the numerics annex.\n-\n---  This is the VMS version\n-\n-package Ada.Numerics.Aux is\n-   pragma Pure;\n-\n-   type Double is digits 15;\n-   pragma Float_Representation (IEEE_Float, Double);\n-   --  Type Double is the type used to call the C routines. Note that this\n-   --  is IEEE format even when running on VMS with VAX_Native representation\n-   --  since we use the IEEE version of the C library with VMS.\n-\n-   --  We import these functions directly from C. Note that we label them\n-   --  all as pure functions, because indeed all of them are in fact pure.\n-\n-   function Sin (X : Double) return Double;\n-   pragma Import (C, Sin, \"MATH$SIN_T\");\n-   pragma Pure_Function (Sin);\n-\n-   function Cos (X : Double) return Double;\n-   pragma Import (C, Cos, \"MATH$COS_T\");\n-   pragma Pure_Function (Cos);\n-\n-   function Tan (X : Double) return Double;\n-   pragma Import (C, Tan, \"MATH$TAN_T\");\n-   pragma Pure_Function (Tan);\n-\n-   function Exp (X : Double) return Double;\n-   pragma Import (C, Exp, \"MATH$EXP_T\");\n-   pragma Pure_Function (Exp);\n-\n-   function Sqrt (X : Double) return Double;\n-   pragma Import (C, Sqrt, \"MATH$SQRT_T\");\n-   pragma Pure_Function (Sqrt);\n-\n-   function Log (X : Double) return Double;\n-   pragma Import (C, Log, \"DECC$TLOG_2\");\n-   pragma Pure_Function (Log);\n-\n-   function Acos (X : Double) return Double;\n-   pragma Import (C, Acos, \"MATH$ACOS_T\");\n-   pragma Pure_Function (Acos);\n-\n-   function Asin (X : Double) return Double;\n-   pragma Import (C, Asin, \"MATH$ASIN_T\");\n-   pragma Pure_Function (Asin);\n-\n-   function Atan (X : Double) return Double;\n-   pragma Import (C, Atan, \"MATH$ATAN_T\");\n-   pragma Pure_Function (Atan);\n-\n-   function Sinh (X : Double) return Double;\n-   pragma Import (C, Sinh, \"MATH$SINH_T\");\n-   pragma Pure_Function (Sinh);\n-\n-   function Cosh (X : Double) return Double;\n-   pragma Import (C, Cosh, \"MATH$COSH_T\");\n-   pragma Pure_Function (Cosh);\n-\n-   function Tanh (X : Double) return Double;\n-   pragma Import (C, Tanh, \"MATH$TANH_T\");\n-   pragma Pure_Function (Tanh);\n-\n-   function Pow (X, Y : Double) return Double;\n-   pragma Import (C, Pow, \"DECC$TPOW_2\");\n-   pragma Pure_Function (Pow);\n-\n-end Ada.Numerics.Aux;"}, {"sha": "ceff6e98c09f8d839e4a07a55072f2cfb65becf9", "filename": "gcc/ada/g-eacodu-vms.adb", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-eacodu-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-eacodu-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-eacodu-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,71 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---      G N A T . E X C E P T I O N _ A C T I O N S . C O R E _ D U M P     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VMS version\n-\n-with System;\n-with System.Aux_DEC;\n-separate (GNAT.Exception_Actions)\n-procedure Core_Dump (Occurrence : Exception_Occurrence) is\n-\n-   use System;\n-   use System.Aux_DEC;\n-\n-   pragma Unreferenced (Occurrence);\n-\n-   SS_IMGDMP : constant := 1276;\n-\n-   subtype Cond_Value_Type is Unsigned_Longword;\n-   subtype Access_Mode_Type is\n-      Unsigned_Word range 0 .. 3;\n-   Access_Mode_Zero : constant Access_Mode_Type := 0;\n-\n-   Status : Cond_Value_Type;\n-\n-   procedure Setexv (\n-     Status : out Cond_Value_Type;\n-     Vector : Unsigned_Longword := 0;\n-     Addres : Address           := Address_Zero;\n-     Acmode : Access_Mode_Type  := Access_Mode_Zero;\n-     Prvhnd : Unsigned_Longword := 0);\n-   pragma Import (External, Setexv);\n-   pragma Import_Valued_Procedure (Setexv, \"SYS$SETEXV\",\n-     (Cond_Value_Type, Unsigned_Longword, Address, Access_Mode_Type,\n-      Unsigned_Longword),\n-     (Value, Value, Value, Value, Value));\n-\n-   procedure Lib_Signal (I : Integer);\n-   pragma Import (C, Lib_Signal);\n-   pragma Import_Procedure (Lib_Signal, \"LIB$SIGNAL\", Mechanism => (Value));\n-begin\n-   Setexv (Status, 1, Address_Zero, 3);\n-   Lib_Signal (SS_IMGDMP);\n-end Core_Dump;"}, {"sha": "f932a075b88f9d6d8f66816af2aba91309c004e7", "filename": "gcc/ada/g-enblsp-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-enblsp-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-enblsp-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-enblsp-vms-alpha.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,128 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---         G N A T . E X P E C T . N O N _ B L O C K I N G _ S P A W N      --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                    Copyright (C) 2005-2010, AdaCore                      --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a target dependent non-blocking spawn function\n---  for use by the VMS GNAT.Expect package (g-expect-vms.adb). This package\n---  should not be directly with'ed by an application program.\n-\n---  This version is for Alpha/VMS\n-\n-separate (GNAT.Expect)\n-procedure Non_Blocking_Spawn\n-  (Descriptor  : out Process_Descriptor'Class;\n-   Command     : String;\n-   Args        : GNAT.OS_Lib.Argument_List;\n-   Buffer_Size : Natural := 4096;\n-   Err_To_Out  : Boolean := False)\n-is\n-   function Alloc_Vfork_Blocks return Integer;\n-   pragma Import (C, Alloc_Vfork_Blocks, \"decc$$alloc_vfork_blocks\");\n-\n-   function Get_Vfork_Jmpbuf return System.Address;\n-   pragma Import (C, Get_Vfork_Jmpbuf, \"decc$$get_vfork_jmpbuf\");\n-\n-   function Get_Current_Invo_Context\n-     (Addr : System.Address) return Process_Id;\n-   pragma Import (C, Get_Current_Invo_Context,\n-     \"LIB$GET_CURRENT_INVO_CONTEXT\");\n-\n-   Pipe1, Pipe2, Pipe3 : aliased Pipe_Type;\n-\n-   Arg      : String_Access;\n-   Arg_List : aliased array (1 .. Args'Length + 2) of System.Address;\n-\n-   Command_With_Path : String_Access;\n-\n-begin\n-   --  Create the rest of the pipes\n-\n-   Set_Up_Communications\n-     (Descriptor, Err_To_Out, Pipe1'Access, Pipe2'Access, Pipe3'Access);\n-\n-   Command_With_Path := Locate_Exec_On_Path (Command);\n-\n-   if Command_With_Path = null then\n-      raise Invalid_Process;\n-   end if;\n-\n-   --  Fork a new process (it is not possible to do this in a subprogram)\n-\n-   Descriptor.Pid :=\n-     (if Alloc_Vfork_Blocks >= 0\n-      then Get_Current_Invo_Context (Get_Vfork_Jmpbuf) else -1);\n-\n-   --  Are we now in the child\n-\n-   if Descriptor.Pid = Null_Pid then\n-\n-      --  Prepare an array of arguments to pass to C\n-\n-      Arg   := new String (1 .. Command_With_Path'Length + 1);\n-      Arg (1 .. Command_With_Path'Length) := Command_With_Path.all;\n-      Arg (Arg'Last)        := ASCII.NUL;\n-      Arg_List (1)          := Arg.all'Address;\n-\n-      for J in Args'Range loop\n-         Arg                     := new String (1 .. Args (J)'Length + 1);\n-         Arg (1 .. Args (J)'Length)  := Args (J).all;\n-         Arg (Arg'Last)              := ASCII.NUL;\n-         Arg_List (J + 2 - Args'First) := Arg.all'Address;\n-      end loop;\n-\n-      Arg_List (Arg_List'Last) := System.Null_Address;\n-\n-      --  This does not return on Unix systems\n-\n-      Set_Up_Child_Communications\n-        (Descriptor, Pipe1, Pipe2, Pipe3, Command_With_Path.all,\n-         Arg_List'Address);\n-   end if;\n-\n-   Free (Command_With_Path);\n-\n-   --  Did we have an error when spawning the child ?\n-\n-   if Descriptor.Pid < Null_Pid then\n-      raise Invalid_Process;\n-   else\n-      --  We are now in the parent process\n-\n-      Set_Up_Parent_Communications (Descriptor, Pipe1, Pipe2, Pipe3);\n-   end if;\n-\n-   --  Create the buffer\n-\n-   Descriptor.Buffer_Size := Buffer_Size;\n-\n-   if Buffer_Size /= 0 then\n-      Descriptor.Buffer := new String (1 .. Positive (Buffer_Size));\n-   end if;\n-end Non_Blocking_Spawn;"}, {"sha": "fa024474731e2fdaf2a63aa9920affa5b38995aa", "filename": "gcc/ada/g-enblsp-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-enblsp-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-enblsp-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-enblsp-vms-ia64.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,125 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---         G N A T . E X P E C T . N O N _ B L O C K I N G _ S P A W N      --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                    Copyright (C) 2005-2010, AdaCore                      --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a target dependent non-blocking spawn function\n---  for use by the VMS GNAT.Expect package (g-expect-vms.adb). This package\n---  should not be directly with'ed by an application program.\n-\n---  This version is for IA64/VMS\n-\n-separate (GNAT.Expect)\n-procedure Non_Blocking_Spawn\n-  (Descriptor  : out Process_Descriptor'Class;\n-   Command     : String;\n-   Args        : GNAT.OS_Lib.Argument_List;\n-   Buffer_Size : Natural := 4096;\n-   Err_To_Out  : Boolean := False)\n-is\n-   function Alloc_Vfork_Blocks return Integer;\n-   pragma Import (C, Alloc_Vfork_Blocks, \"decc$$alloc_vfork_blocks\");\n-\n-   function Get_Vfork_Jmpbuf return System.Address;\n-   pragma Import (C, Get_Vfork_Jmpbuf, \"decc$$get_vfork_jmpbuf\");\n-\n-   function Setjmp1 (Addr : System.Address) return Process_Id;\n-   pragma Import (C, Setjmp1, \"decc$setjmp1\");\n-\n-   Pipe1, Pipe2, Pipe3 : aliased Pipe_Type;\n-\n-   Arg      : String_Access;\n-   Arg_List : aliased array (1 .. Args'Length + 2) of System.Address;\n-\n-   Command_With_Path : String_Access;\n-\n-begin\n-   --  Create the rest of the pipes\n-\n-   Set_Up_Communications\n-     (Descriptor, Err_To_Out, Pipe1'Access, Pipe2'Access, Pipe3'Access);\n-\n-   Command_With_Path := Locate_Exec_On_Path (Command);\n-\n-   if Command_With_Path = null then\n-      raise Invalid_Process;\n-   end if;\n-\n-   --  Fork a new process (it is not possible to do this in a subprogram)\n-\n-   Descriptor.Pid :=\n-     (if Alloc_Vfork_Blocks >= 0 then Setjmp1 (Get_Vfork_Jmpbuf) else -1);\n-\n-   --  Are we now in the child\n-\n-   if Descriptor.Pid = Null_Pid then\n-\n-      --  Prepare an array of arguments to pass to C\n-\n-      Arg   := new String (1 .. Command_With_Path'Length + 1);\n-      Arg (1 .. Command_With_Path'Length) := Command_With_Path.all;\n-      Arg (Arg'Last)        := ASCII.NUL;\n-      Arg_List (1)          := Arg.all'Address;\n-\n-      for J in Args'Range loop\n-         Arg                     := new String (1 .. Args (J)'Length + 1);\n-         Arg (1 .. Args (J)'Length)  := Args (J).all;\n-         Arg (Arg'Last)              := ASCII.NUL;\n-         Arg_List (J + 2 - Args'First) := Arg.all'Address;\n-      end loop;\n-\n-      Arg_List (Arg_List'Last) := System.Null_Address;\n-\n-      --  This does not return on Unix systems\n-\n-      Set_Up_Child_Communications\n-        (Descriptor, Pipe1, Pipe2, Pipe3, Command_With_Path.all,\n-         Arg_List'Address);\n-   end if;\n-\n-   Free (Command_With_Path);\n-\n-   --  Did we have an error when spawning the child ?\n-\n-   if Descriptor.Pid < Null_Pid then\n-      raise Invalid_Process;\n-   else\n-      --  We are now in the parent process\n-\n-      Set_Up_Parent_Communications (Descriptor, Pipe1, Pipe2, Pipe3);\n-   end if;\n-\n-   --  Create the buffer\n-\n-   Descriptor.Buffer_Size := Buffer_Size;\n-\n-   if Buffer_Size /= 0 then\n-      Descriptor.Buffer := new String (1 .. Positive (Buffer_Size));\n-   end if;\n-end Non_Blocking_Spawn;"}, {"sha": "aa1f8038b2f44c2a3d203f2475f8ec24a8fc32ed", "filename": "gcc/ada/g-expect-vms.adb", "status": "removed", "additions": 0, "deletions": 1306, "changes": 1306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-expect-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-expect-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,1306 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---                          G N A T . E X P E C T                           --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2002-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VMS version\n-\n---  Note: there is far too much code duplication wrt g-expect.adb (the\n---  standard version). This should be factored out ???\n-\n-with System;       use System;\n-with Ada.Calendar; use Ada.Calendar;\n-\n-with GNAT.IO;\n-with GNAT.OS_Lib;  use GNAT.OS_Lib;\n-with GNAT.Regpat;  use GNAT.Regpat;\n-\n-with Ada.Unchecked_Deallocation;\n-\n-package body GNAT.Expect is\n-\n-   type Array_Of_Pd is array (Positive range <>) of Process_Descriptor_Access;\n-\n-   Save_Input  : File_Descriptor;\n-   Save_Output : File_Descriptor;\n-   Save_Error  : File_Descriptor;\n-\n-   Expect_Process_Died   : constant Expect_Match := -100;\n-   Expect_Internal_Error : constant Expect_Match := -101;\n-   --  Additional possible outputs of Expect_Internal. These are not visible in\n-   --  the spec because the user will never see them.\n-\n-   procedure Expect_Internal\n-     (Descriptors : in out Array_Of_Pd;\n-      Result      : out Expect_Match;\n-      Timeout     : Integer;\n-      Full_Buffer : Boolean);\n-   --  Internal function used to read from the process Descriptor.\n-   --\n-   --  Several outputs are possible:\n-   --     Result=Expect_Timeout, if no output was available before the timeout\n-   --        expired.\n-   --     Result=Expect_Full_Buffer, if Full_Buffer is True and some characters\n-   --        had to be discarded from the internal buffer of Descriptor.\n-   --     Result=Express_Process_Died if one of the processes was terminated.\n-   --        That process's Input_Fd is set to Invalid_FD\n-   --     Result=Express_Internal_Error\n-   --     Result=<integer>, indicates how many characters were added to the\n-   --        internal buffer. These characters are from indexes\n-   --        Descriptor.Buffer_Index - Result + 1 .. Descriptor.Buffer_Index\n-   --  Process_Died is raised if the process is no longer valid.\n-\n-   procedure Reinitialize_Buffer\n-     (Descriptor : in out Process_Descriptor'Class);\n-   --  Reinitialize the internal buffer.\n-   --  The buffer is deleted up to the end of the last match.\n-\n-   procedure Free is new Ada.Unchecked_Deallocation\n-     (Pattern_Matcher, Pattern_Matcher_Access);\n-\n-   procedure Call_Filters\n-     (Pid       : Process_Descriptor'Class;\n-      Str       : String;\n-      Filter_On : Filter_Type);\n-   --  Call all the filters that have the appropriate type.\n-   --  This function does nothing if the filters are locked\n-\n-   ------------------------------\n-   -- Target dependent section --\n-   ------------------------------\n-\n-   function Dup (Fd : File_Descriptor) return File_Descriptor;\n-   pragma Import (C, Dup, \"decc$dup\");\n-\n-   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n-   pragma Import (C, Dup2, \"decc$dup2\");\n-\n-   procedure Kill (Pid : Process_Id; Sig_Num : Integer);\n-   pragma Import (C, Kill, \"decc$kill\");\n-\n-   function Create_Pipe (Pipe : not null access Pipe_Type) return Integer;\n-   pragma Import (C, Create_Pipe, \"__gnat_pipe\");\n-\n-   function Poll\n-     (Fds     : System.Address;\n-      Num_Fds : Integer;\n-      Timeout : Integer;\n-      Is_Set  : System.Address) return Integer;\n-   pragma Import (C, Poll, \"__gnat_expect_poll\");\n-   --  Check whether there is any data waiting on the file descriptor\n-   --  Out_fd, and wait if there is none, at most Timeout milliseconds\n-   --  Returns -1 in case of error, 0 if the timeout expired before\n-   --  data became available.\n-   --\n-   --  Out_Is_Set is set to 1 if data was available, 0 otherwise.\n-\n-   function Waitpid (Pid : Process_Id) return Integer;\n-   pragma Import (C, Waitpid, \"__gnat_waitpid\");\n-   --  Wait for a specific process id, and return its exit code\n-\n-   ---------\n-   -- \"+\" --\n-   ---------\n-\n-   function \"+\" (S : String) return GNAT.OS_Lib.String_Access is\n-   begin\n-      return new String'(S);\n-   end \"+\";\n-\n-   ---------\n-   -- \"+\" --\n-   ---------\n-\n-   function \"+\"\n-     (P : GNAT.Regpat.Pattern_Matcher) return Pattern_Matcher_Access\n-   is\n-   begin\n-      return new GNAT.Regpat.Pattern_Matcher'(P);\n-   end \"+\";\n-\n-   ----------------\n-   -- Add_Filter --\n-   ----------------\n-\n-   procedure Add_Filter\n-     (Descriptor : in out Process_Descriptor;\n-      Filter     : Filter_Function;\n-      Filter_On  : Filter_Type := Output;\n-      User_Data  : System.Address := System.Null_Address;\n-      After      : Boolean := False)\n-   is\n-      Current : Filter_List := Descriptor.Filters;\n-\n-   begin\n-      if After then\n-         while Current /= null and then Current.Next /= null loop\n-            Current := Current.Next;\n-         end loop;\n-\n-         if Current = null then\n-            Descriptor.Filters :=\n-              new Filter_List_Elem'\n-               (Filter => Filter, Filter_On => Filter_On,\n-                User_Data => User_Data, Next => null);\n-         else\n-            Current.Next :=\n-              new Filter_List_Elem'\n-              (Filter => Filter, Filter_On => Filter_On,\n-               User_Data => User_Data, Next => null);\n-         end if;\n-\n-      else\n-         Descriptor.Filters :=\n-           new Filter_List_Elem'\n-             (Filter => Filter, Filter_On => Filter_On,\n-              User_Data => User_Data, Next => Descriptor.Filters);\n-      end if;\n-   end Add_Filter;\n-\n-   ------------------\n-   -- Call_Filters --\n-   ------------------\n-\n-   procedure Call_Filters\n-     (Pid       : Process_Descriptor'Class;\n-      Str       : String;\n-      Filter_On : Filter_Type)\n-   is\n-      Current_Filter  : Filter_List;\n-\n-   begin\n-      if Pid.Filters_Lock = 0 then\n-         Current_Filter := Pid.Filters;\n-\n-         while Current_Filter /= null loop\n-            if Current_Filter.Filter_On = Filter_On then\n-               Current_Filter.Filter\n-                 (Pid, Str, Current_Filter.User_Data);\n-            end if;\n-\n-            Current_Filter := Current_Filter.Next;\n-         end loop;\n-      end if;\n-   end Call_Filters;\n-\n-   -----------\n-   -- Close --\n-   -----------\n-\n-   procedure Close\n-     (Descriptor : in out Process_Descriptor;\n-      Status     : out Integer)\n-   is\n-   begin\n-      if Descriptor.Input_Fd /= Invalid_FD then\n-         Close (Descriptor.Input_Fd);\n-      end if;\n-\n-      if Descriptor.Error_Fd /= Descriptor.Output_Fd then\n-         Close (Descriptor.Error_Fd);\n-      end if;\n-\n-      Close (Descriptor.Output_Fd);\n-\n-      --  ??? Should have timeouts for different signals\n-\n-      if Descriptor.Pid > 0 then  --  see comment in Send_Signal\n-         Kill (Descriptor.Pid, Sig_Num => 9);\n-      end if;\n-\n-      GNAT.OS_Lib.Free (Descriptor.Buffer);\n-      Descriptor.Buffer_Size := 0;\n-\n-      --  Check process id (see comment in Send_Signal)\n-\n-      if Descriptor.Pid > 0 then\n-         Status := Waitpid (Descriptor.Pid);\n-      else\n-         raise Invalid_Process;\n-      end if;\n-   end Close;\n-\n-   procedure Close (Descriptor : in out Process_Descriptor) is\n-      Status : Integer;\n-   begin\n-      Close (Descriptor, Status);\n-   end Close;\n-\n-   ------------\n-   -- Expect --\n-   ------------\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexp      : String;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-   begin\n-      if Regexp = \"\" then\n-         Expect (Descriptor, Result, Never_Match, Timeout, Full_Buffer);\n-      else\n-         Expect (Descriptor, Result, Compile (Regexp), Timeout, Full_Buffer);\n-      end if;\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexp      : String;\n-      Matched     : out GNAT.Regpat.Match_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-   begin\n-      pragma Assert (Matched'First = 0);\n-      if Regexp = \"\" then\n-         Expect\n-           (Descriptor, Result, Never_Match, Matched, Timeout, Full_Buffer);\n-      else\n-         Expect\n-           (Descriptor, Result, Compile (Regexp), Matched, Timeout,\n-            Full_Buffer);\n-      end if;\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexp      : GNAT.Regpat.Pattern_Matcher;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      Matched : GNAT.Regpat.Match_Array (0 .. 0);\n-\n-   begin\n-      Expect (Descriptor, Result, Regexp, Matched, Timeout, Full_Buffer);\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexp      : GNAT.Regpat.Pattern_Matcher;\n-      Matched     : out GNAT.Regpat.Match_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      N           : Expect_Match;\n-      Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n-      Try_Until   : constant Time := Clock + Duration (Timeout) / 1000.0;\n-      Timeout_Tmp : Integer := Timeout;\n-\n-   begin\n-      pragma Assert (Matched'First = 0);\n-      Reinitialize_Buffer (Descriptor);\n-\n-      loop\n-         --  First, test if what is already in the buffer matches (This is\n-         --  required if this package is used in multi-task mode, since one of\n-         --  the tasks might have added something in the buffer, and we don't\n-         --  want other tasks to wait for new input to be available before\n-         --  checking the regexps).\n-\n-         Match\n-           (Regexp, Descriptor.Buffer (1 .. Descriptor.Buffer_Index), Matched);\n-\n-         if Descriptor.Buffer_Index >= 1 and then Matched (0).First /= 0 then\n-            Result := 1;\n-            Descriptor.Last_Match_Start := Matched (0).First;\n-            Descriptor.Last_Match_End := Matched (0).Last;\n-            return;\n-         end if;\n-\n-         --  Else try to read new input\n-\n-         Expect_Internal (Descriptors, N, Timeout_Tmp, Full_Buffer);\n-\n-         case N is\n-            when Expect_Internal_Error | Expect_Process_Died =>\n-               raise Process_Died;\n-\n-            when Expect_Timeout | Expect_Full_Buffer =>\n-               Result := N;\n-               return;\n-\n-            when others =>\n-               null;  --  See below\n-         end case;\n-\n-         --  Calculate the timeout for the next turn\n-\n-         --  Note that Timeout is, from the caller's perspective, the maximum\n-         --  time until a match, not the maximum time until some output is\n-         --  read, and thus cannot be reused as is for Expect_Internal.\n-\n-         if Timeout /= -1 then\n-            Timeout_Tmp := Integer (Try_Until - Clock) * 1000;\n-\n-            if Timeout_Tmp < 0 then\n-               Result := Expect_Timeout;\n-               exit;\n-            end if;\n-         end if;\n-      end loop;\n-\n-      --  Even if we had the general timeout above, we have to test that the\n-      --  last test we read from the external process didn't match.\n-\n-      Match\n-        (Regexp, Descriptor.Buffer (1 .. Descriptor.Buffer_Index), Matched);\n-\n-      if Matched (0).First /= 0 then\n-         Result := 1;\n-         Descriptor.Last_Match_Start := Matched (0).First;\n-         Descriptor.Last_Match_End := Matched (0).Last;\n-         return;\n-      end if;\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexps     : Regexp_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      Patterns : Compiled_Regexp_Array (Regexps'Range);\n-      Matched  : GNAT.Regpat.Match_Array (0 .. 0);\n-\n-   begin\n-      for J in Regexps'Range loop\n-         Patterns (J) := new Pattern_Matcher'(Compile (Regexps (J).all));\n-      end loop;\n-\n-      Expect (Descriptor, Result, Patterns, Matched, Timeout, Full_Buffer);\n-\n-      for J in Regexps'Range loop\n-         Free (Patterns (J));\n-      end loop;\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexps     : Compiled_Regexp_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      Matched : GNAT.Regpat.Match_Array (0 .. 0);\n-\n-   begin\n-      Expect (Descriptor, Result, Regexps, Matched, Timeout, Full_Buffer);\n-   end Expect;\n-\n-   procedure Expect\n-     (Result      : out Expect_Match;\n-      Regexps     : Multiprocess_Regexp_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      Matched : GNAT.Regpat.Match_Array (0 .. 0);\n-\n-   begin\n-      Expect (Result, Regexps, Matched, Timeout, Full_Buffer);\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexps     : Regexp_Array;\n-      Matched     : out GNAT.Regpat.Match_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      Patterns : Compiled_Regexp_Array (Regexps'Range);\n-\n-   begin\n-      pragma Assert (Matched'First = 0);\n-\n-      for J in Regexps'Range loop\n-         Patterns (J) := new Pattern_Matcher'(Compile (Regexps (J).all));\n-      end loop;\n-\n-      Expect (Descriptor, Result, Patterns, Matched, Timeout, Full_Buffer);\n-\n-      for J in Regexps'Range loop\n-         Free (Patterns (J));\n-      end loop;\n-   end Expect;\n-\n-   procedure Expect\n-     (Descriptor  : in out Process_Descriptor;\n-      Result      : out Expect_Match;\n-      Regexps     : Compiled_Regexp_Array;\n-      Matched     : out GNAT.Regpat.Match_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      N           : Expect_Match;\n-      Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n-\n-   begin\n-      pragma Assert (Matched'First = 0);\n-\n-      Reinitialize_Buffer (Descriptor);\n-\n-      loop\n-         --  First, test if what is already in the buffer matches (This is\n-         --  required if this package is used in multi-task mode, since one of\n-         --  the tasks might have added something in the buffer, and we don't\n-         --  want other tasks to wait for new input to be available before\n-         --  checking the regexps).\n-\n-         if Descriptor.Buffer /= null then\n-            for J in Regexps'Range loop\n-               Match\n-                 (Regexps (J).all,\n-                  Descriptor.Buffer (1 .. Descriptor.Buffer_Index),\n-                  Matched);\n-\n-               if Matched (0) /= No_Match then\n-                  Result := Expect_Match (J);\n-                  Descriptor.Last_Match_Start := Matched (0).First;\n-                  Descriptor.Last_Match_End := Matched (0).Last;\n-                  return;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n-\n-         case N is\n-            when Expect_Internal_Error | Expect_Process_Died =>\n-               raise Process_Died;\n-\n-            when Expect_Timeout | Expect_Full_Buffer =>\n-               Result := N;\n-               return;\n-\n-            when others =>\n-               null;  --  Continue\n-         end case;\n-      end loop;\n-   end Expect;\n-\n-   procedure Expect\n-     (Result      : out Expect_Match;\n-      Regexps     : Multiprocess_Regexp_Array;\n-      Matched     : out GNAT.Regpat.Match_Array;\n-      Timeout     : Integer := 10_000;\n-      Full_Buffer : Boolean := False)\n-   is\n-      N           : Expect_Match;\n-      Descriptors : Array_Of_Pd (Regexps'Range);\n-\n-   begin\n-      pragma Assert (Matched'First = 0);\n-\n-      for J in Descriptors'Range loop\n-         Descriptors (J) := Regexps (J).Descriptor;\n-\n-         if Descriptors (J) /= null then\n-            Reinitialize_Buffer (Regexps (J).Descriptor.all);\n-         end if;\n-      end loop;\n-\n-      loop\n-         --  First, test if what is already in the buffer matches (This is\n-         --  required if this package is used in multi-task mode, since one of\n-         --  the tasks might have added something in the buffer, and we don't\n-         --  want other tasks to wait for new input to be available before\n-         --  checking the regexps).\n-\n-         for J in Regexps'Range loop\n-            if Regexps (J).Regexp /= null\n-               and then Regexps (J).Descriptor /= null\n-            then\n-               Match (Regexps (J).Regexp.all,\n-                      Regexps (J).Descriptor.Buffer\n-                        (1 .. Regexps (J).Descriptor.Buffer_Index),\n-                      Matched);\n-\n-               if Matched (0) /= No_Match then\n-                  Result := Expect_Match (J);\n-                  Regexps (J).Descriptor.Last_Match_Start := Matched (0).First;\n-                  Regexps (J).Descriptor.Last_Match_End := Matched (0).Last;\n-                  return;\n-               end if;\n-            end if;\n-         end loop;\n-\n-         Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n-\n-         case N is\n-            when Expect_Internal_Error | Expect_Process_Died =>\n-               raise Process_Died;\n-\n-            when Expect_Timeout | Expect_Full_Buffer =>\n-               Result := N;\n-               return;\n-\n-            when others =>\n-               null;  --  Continue\n-         end case;\n-      end loop;\n-   end Expect;\n-\n-   ---------------------\n-   -- Expect_Internal --\n-   ---------------------\n-\n-   procedure Expect_Internal\n-     (Descriptors : in out Array_Of_Pd;\n-      Result      : out Expect_Match;\n-      Timeout     : Integer;\n-      Full_Buffer : Boolean)\n-   is\n-      Num_Descriptors : Integer;\n-      Buffer_Size     : Integer := 0;\n-\n-      N : Integer;\n-\n-      type File_Descriptor_Array is\n-        array (0 .. Descriptors'Length - 1) of File_Descriptor;\n-      Fds : aliased File_Descriptor_Array;\n-      Fds_Count : Natural := 0;\n-\n-      Fds_To_Descriptor : array (Fds'Range) of Integer;\n-      --  Maps file descriptor entries from Fds to entries in Descriptors.\n-      --  They do not have the same index when entries in Descriptors are null.\n-\n-      type Integer_Array is array (Fds'Range) of Integer;\n-      Is_Set : aliased Integer_Array;\n-\n-   begin\n-      for J in Descriptors'Range loop\n-         if Descriptors (J) /= null then\n-            Fds (Fds'First + Fds_Count) := Descriptors (J).Output_Fd;\n-            Fds_To_Descriptor (Fds'First + Fds_Count) := J;\n-            Fds_Count := Fds_Count + 1;\n-\n-            if Descriptors (J).Buffer_Size = 0 then\n-               Buffer_Size := Integer'Max (Buffer_Size, 4096);\n-            else\n-               Buffer_Size :=\n-                 Integer'Max (Buffer_Size, Descriptors (J).Buffer_Size);\n-            end if;\n-         end if;\n-      end loop;\n-\n-      declare\n-         Buffer : aliased String (1 .. Buffer_Size);\n-         --  Buffer used for input. This is allocated only once, not for\n-         --  every iteration of the loop\n-\n-         D : Integer;\n-         --  Index in Descriptors\n-\n-      begin\n-         --  Loop until we match or we have a timeout\n-\n-         loop\n-            Num_Descriptors :=\n-              Poll (Fds'Address, Fds_Count, Timeout, Is_Set'Address);\n-\n-            case Num_Descriptors is\n-\n-               --  Error?\n-\n-               when -1 =>\n-                  Result := Expect_Internal_Error;\n-                  return;\n-\n-               --  Timeout?\n-\n-               when 0  =>\n-                  Result := Expect_Timeout;\n-                  return;\n-\n-               --  Some input\n-\n-               when others =>\n-                  for F in Fds'Range loop\n-                     if Is_Set (F) = 1 then\n-                        D := Fds_To_Descriptor (F);\n-\n-                        Buffer_Size := Descriptors (D).Buffer_Size;\n-\n-                        if Buffer_Size = 0 then\n-                           Buffer_Size := 4096;\n-                        end if;\n-\n-                        N := Read (Descriptors (D).Output_Fd, Buffer'Address,\n-                                   Buffer_Size);\n-\n-                        --  Error or End of file\n-\n-                        if N <= 0 then\n-                           --  ??? Note that ddd tries again up to three times\n-                           --  in that case. See LiterateA.C:174\n-\n-                           Descriptors (D).Input_Fd := Invalid_FD;\n-                           Result := Expect_Process_Died;\n-                           return;\n-\n-                        else\n-                           --  If there is no limit to the buffer size\n-\n-                           if Descriptors (D).Buffer_Size = 0 then\n-\n-                              declare\n-                                 Tmp : String_Access := Descriptors (D).Buffer;\n-\n-                              begin\n-                                 if Tmp /= null then\n-                                    Descriptors (D).Buffer :=\n-                                      new String (1 .. Tmp'Length + N);\n-                                    Descriptors (D).Buffer (1 .. Tmp'Length) :=\n-                                      Tmp.all;\n-                                    Descriptors (D).Buffer\n-                                      (Tmp'Length + 1 .. Tmp'Length + N) :=\n-                                      Buffer (1 .. N);\n-                                    Free (Tmp);\n-                                    Descriptors (D).Buffer_Index :=\n-                                      Descriptors (D).Buffer'Last;\n-\n-                                 else\n-                                    Descriptors (D).Buffer :=\n-                                      new String (1 .. N);\n-                                    Descriptors (D).Buffer.all :=\n-                                      Buffer (1 .. N);\n-                                    Descriptors (D).Buffer_Index := N;\n-                                 end if;\n-                              end;\n-\n-                           else\n-                              --  Add what we read to the buffer\n-\n-                              if Descriptors (D).Buffer_Index + N >\n-                                Descriptors (D).Buffer_Size\n-                              then\n-                                 --  If the user wants to know when we have\n-                                 --  read more than the buffer can contain.\n-\n-                                 if Full_Buffer then\n-                                    Result := Expect_Full_Buffer;\n-                                    return;\n-                                 end if;\n-\n-                                 --  Keep as much as possible from the buffer,\n-                                 --  and forget old characters.\n-\n-                                 Descriptors (D).Buffer\n-                                   (1 .. Descriptors (D).Buffer_Size - N) :=\n-                                  Descriptors (D).Buffer\n-                                   (N - Descriptors (D).Buffer_Size +\n-                                    Descriptors (D).Buffer_Index + 1 ..\n-                                    Descriptors (D).Buffer_Index);\n-                                 Descriptors (D).Buffer_Index :=\n-                                   Descriptors (D).Buffer_Size - N;\n-                              end if;\n-\n-                              --  Keep what we read in the buffer\n-\n-                              Descriptors (D).Buffer\n-                                (Descriptors (D).Buffer_Index + 1 ..\n-                                 Descriptors (D).Buffer_Index + N) :=\n-                                Buffer (1 .. N);\n-                              Descriptors (D).Buffer_Index :=\n-                                Descriptors (D).Buffer_Index + N;\n-                           end if;\n-\n-                           --  Call each of the output filter with what we\n-                           --  read.\n-\n-                           Call_Filters\n-                             (Descriptors (D).all, Buffer (1 .. N), Output);\n-\n-                           Result := Expect_Match (D);\n-                           return;\n-                        end if;\n-                     end if;\n-                  end loop;\n-            end case;\n-         end loop;\n-      end;\n-   end Expect_Internal;\n-\n-   ----------------\n-   -- Expect_Out --\n-   ----------------\n-\n-   function Expect_Out (Descriptor : Process_Descriptor) return String is\n-   begin\n-      return Descriptor.Buffer (1 .. Descriptor.Last_Match_End);\n-   end Expect_Out;\n-\n-   ----------------------\n-   -- Expect_Out_Match --\n-   ----------------------\n-\n-   function Expect_Out_Match (Descriptor : Process_Descriptor) return String is\n-   begin\n-      return Descriptor.Buffer\n-        (Descriptor.Last_Match_Start .. Descriptor.Last_Match_End);\n-   end Expect_Out_Match;\n-\n-   ------------------------\n-   -- First_Dead_Process --\n-   ------------------------\n-\n-   function First_Dead_Process\n-     (Regexp : Multiprocess_Regexp_Array) return Natural\n-   is\n-   begin\n-      for R in Regexp'Range loop\n-         if Regexp (R).Descriptor /= null\n-           and then Regexp (R).Descriptor.Input_Fd = GNAT.OS_Lib.Invalid_FD\n-         then\n-            return R;\n-         end if;\n-      end loop;\n-\n-      return 0;\n-   end First_Dead_Process;\n-\n-   -----------\n-   -- Flush --\n-   -----------\n-\n-   procedure Flush\n-     (Descriptor : in out Process_Descriptor;\n-      Timeout    : Integer := 0)\n-   is\n-      Buffer_Size     : constant Integer := 8192;\n-      Num_Descriptors : Integer;\n-      N               : Integer;\n-      Is_Set          : aliased Integer;\n-      Buffer          : aliased String (1 .. Buffer_Size);\n-\n-   begin\n-      --  Empty the current buffer\n-\n-      Descriptor.Last_Match_End := Descriptor.Buffer_Index;\n-      Reinitialize_Buffer (Descriptor);\n-\n-      --  Read everything from the process to flush its output\n-\n-      loop\n-         Num_Descriptors :=\n-           Poll (Descriptor.Output_Fd'Address, 1, Timeout, Is_Set'Address);\n-\n-         case Num_Descriptors is\n-\n-            --  Error ?\n-\n-            when -1 =>\n-               raise Process_Died;\n-\n-            --  Timeout => End of flush\n-\n-            when 0  =>\n-               return;\n-\n-            --  Some input\n-\n-            when others =>\n-               if Is_Set = 1 then\n-                  N := Read (Descriptor.Output_Fd, Buffer'Address,\n-                             Buffer_Size);\n-\n-                  if N = -1 then\n-                     raise Process_Died;\n-                  elsif N = 0 then\n-                     return;\n-                  end if;\n-               end if;\n-         end case;\n-      end loop;\n-   end Flush;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Regexp : in out Multiprocess_Regexp) is\n-      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n-        (Process_Descriptor'Class, Process_Descriptor_Access);\n-   begin\n-      Unchecked_Free (Regexp.Descriptor);\n-      Free (Regexp.Regexp);\n-   end Free;\n-\n-   ------------------------\n-   -- Get_Command_Output --\n-   ------------------------\n-\n-   function Get_Command_Output\n-     (Command    : String;\n-      Arguments  : GNAT.OS_Lib.Argument_List;\n-      Input      : String;\n-      Status     : not null access Integer;\n-      Err_To_Out : Boolean := False) return String\n-   is\n-      use GNAT.Expect;\n-\n-      Process : Process_Descriptor;\n-\n-      Output : String_Access := new String (1 .. 1024);\n-      --  Buffer used to accumulate standard output from the launched\n-      --  command, expanded as necessary during execution.\n-\n-      Last : Integer := 0;\n-      --  Index of the last used character within Output\n-\n-   begin\n-      Non_Blocking_Spawn\n-        (Process, Command, Arguments, Err_To_Out => Err_To_Out);\n-\n-      if Input'Length > 0 then\n-         Send (Process, Input);\n-      end if;\n-\n-      GNAT.OS_Lib.Close (Get_Input_Fd (Process));\n-\n-      declare\n-         Result : Expect_Match;\n-\n-      begin\n-         --  This loop runs until the call to Expect raises Process_Died\n-\n-         loop\n-            Expect (Process, Result, \".+\");\n-\n-            declare\n-               NOutput : String_Access;\n-               S       : constant String := Expect_Out (Process);\n-               pragma Assert (S'Length > 0);\n-\n-            begin\n-               --  Expand buffer if we need more space\n-\n-               if Last + S'Length > Output'Last then\n-                  NOutput := new String (1 .. 2 * Output'Last);\n-                  NOutput (Output'Range) := Output.all;\n-                  Free (Output);\n-\n-                  --  Here if current buffer size is OK\n-\n-               else\n-                  NOutput := Output;\n-               end if;\n-\n-               NOutput (Last + 1 .. Last + S'Length) := S;\n-               Last := Last + S'Length;\n-               Output := NOutput;\n-            end;\n-         end loop;\n-\n-      exception\n-         when Process_Died =>\n-            Close (Process, Status.all);\n-      end;\n-\n-      if Last = 0 then\n-         return \"\";\n-      end if;\n-\n-      declare\n-         S : constant String := Output (1 .. Last);\n-      begin\n-         Free (Output);\n-         return S;\n-      end;\n-   end Get_Command_Output;\n-\n-   ------------------\n-   -- Get_Error_Fd --\n-   ------------------\n-\n-   function Get_Error_Fd\n-     (Descriptor : Process_Descriptor) return GNAT.OS_Lib.File_Descriptor\n-   is\n-   begin\n-      return Descriptor.Error_Fd;\n-   end Get_Error_Fd;\n-\n-   ------------------\n-   -- Get_Input_Fd --\n-   ------------------\n-\n-   function Get_Input_Fd\n-     (Descriptor : Process_Descriptor) return GNAT.OS_Lib.File_Descriptor\n-   is\n-   begin\n-      return Descriptor.Input_Fd;\n-   end Get_Input_Fd;\n-\n-   -------------------\n-   -- Get_Output_Fd --\n-   -------------------\n-\n-   function Get_Output_Fd\n-     (Descriptor : Process_Descriptor) return GNAT.OS_Lib.File_Descriptor\n-   is\n-   begin\n-      return Descriptor.Output_Fd;\n-   end Get_Output_Fd;\n-\n-   -------------\n-   -- Get_Pid --\n-   -------------\n-\n-   function Get_Pid\n-     (Descriptor : Process_Descriptor) return Process_Id\n-   is\n-   begin\n-      return Descriptor.Pid;\n-   end Get_Pid;\n-\n-   -----------------\n-   -- Has_Process --\n-   -----------------\n-\n-   function Has_Process (Regexp : Multiprocess_Regexp_Array) return Boolean is\n-   begin\n-      return Regexp /= (Regexp'Range => (null, null));\n-   end Has_Process;\n-\n-   ---------------\n-   -- Interrupt --\n-   ---------------\n-\n-   procedure Interrupt (Descriptor : in out Process_Descriptor) is\n-      SIGINT : constant := 2;\n-   begin\n-      Send_Signal (Descriptor, SIGINT);\n-   end Interrupt;\n-\n-   ------------------\n-   -- Lock_Filters --\n-   ------------------\n-\n-   procedure Lock_Filters (Descriptor : in out Process_Descriptor) is\n-   begin\n-      Descriptor.Filters_Lock := Descriptor.Filters_Lock + 1;\n-   end Lock_Filters;\n-\n-   ------------------------\n-   -- Non_Blocking_Spawn --\n-   ------------------------\n-\n-   procedure Non_Blocking_Spawn\n-     (Descriptor  : out Process_Descriptor'Class;\n-      Command     : String;\n-      Args        : GNAT.OS_Lib.Argument_List;\n-      Buffer_Size : Natural := 4096;\n-      Err_To_Out  : Boolean := False)\n-   is separate;\n-\n-   -------------------------\n-   -- Reinitialize_Buffer --\n-   -------------------------\n-\n-   procedure Reinitialize_Buffer\n-     (Descriptor : in out Process_Descriptor'Class)\n-   is\n-   begin\n-      if Descriptor.Buffer_Size = 0 then\n-         declare\n-            Tmp : String_Access := Descriptor.Buffer;\n-\n-         begin\n-            Descriptor.Buffer :=\n-              new String\n-                (1 .. Descriptor.Buffer_Index - Descriptor.Last_Match_End);\n-\n-            if Tmp /= null then\n-               Descriptor.Buffer.all := Tmp\n-                 (Descriptor.Last_Match_End + 1 .. Descriptor.Buffer_Index);\n-               Free (Tmp);\n-            end if;\n-         end;\n-\n-         Descriptor.Buffer_Index := Descriptor.Buffer'Last;\n-\n-      else\n-         Descriptor.Buffer\n-           (1 .. Descriptor.Buffer_Index - Descriptor.Last_Match_End) :=\n-             Descriptor.Buffer\n-               (Descriptor.Last_Match_End + 1 .. Descriptor.Buffer_Index);\n-\n-         if Descriptor.Buffer_Index > Descriptor.Last_Match_End then\n-            Descriptor.Buffer_Index :=\n-              Descriptor.Buffer_Index - Descriptor.Last_Match_End;\n-         else\n-            Descriptor.Buffer_Index := 0;\n-         end if;\n-      end if;\n-\n-      Descriptor.Last_Match_Start := 0;\n-      Descriptor.Last_Match_End := 0;\n-   end Reinitialize_Buffer;\n-\n-   -------------------\n-   -- Remove_Filter --\n-   -------------------\n-\n-   procedure Remove_Filter\n-     (Descriptor : in out Process_Descriptor;\n-      Filter     : Filter_Function)\n-   is\n-      Previous : Filter_List := null;\n-      Current  : Filter_List := Descriptor.Filters;\n-\n-   begin\n-      while Current /= null loop\n-         if Current.Filter = Filter then\n-            if Previous = null then\n-               Descriptor.Filters := Current.Next;\n-            else\n-               Previous.Next := Current.Next;\n-            end if;\n-         end if;\n-\n-         Previous := Current;\n-         Current := Current.Next;\n-      end loop;\n-   end Remove_Filter;\n-\n-   ----------\n-   -- Send --\n-   ----------\n-\n-   procedure Send\n-     (Descriptor   : in out Process_Descriptor;\n-      Str          : String;\n-      Add_LF       : Boolean := True;\n-      Empty_Buffer : Boolean := False)\n-   is\n-      Full_Str    : constant String := Str & ASCII.LF;\n-      Last        : Natural;\n-      Result      : Expect_Match;\n-      Descriptors : Array_Of_Pd := (1 => Descriptor'Unrestricted_Access);\n-\n-      Discard : Natural;\n-\n-   begin\n-      if Empty_Buffer then\n-\n-         --  Force a read on the process if there is anything waiting\n-\n-         Expect_Internal (Descriptors, Result,\n-                          Timeout => 0, Full_Buffer => False);\n-\n-         if Result = Expect_Internal_Error\n-           or else Result = Expect_Process_Died\n-         then\n-            raise Process_Died;\n-         end if;\n-\n-         Descriptor.Last_Match_End := Descriptor.Buffer_Index;\n-\n-         --  Empty the buffer\n-\n-         Reinitialize_Buffer (Descriptor);\n-      end if;\n-\n-      Last := (if Add_LF then Full_Str'Last else Full_Str'Last - 1);\n-\n-      Call_Filters (Descriptor, Full_Str (Full_Str'First .. Last), Input);\n-\n-      Discard :=\n-        Write (Descriptor.Input_Fd,\n-               Full_Str'Address,\n-               Last - Full_Str'First + 1);\n-      --  Shouldn't we at least have a pragma Assert on the result ???\n-   end Send;\n-\n-   -----------------\n-   -- Send_Signal --\n-   -----------------\n-\n-   procedure Send_Signal\n-     (Descriptor : Process_Descriptor;\n-      Signal     : Integer)\n-   is\n-   begin\n-      --  A nonpositive process id passed to kill has special meanings. For\n-      --  example, -1 means kill all processes in sight, including self, in\n-      --  POSIX and Windows (and something slightly different in Linux). See\n-      --  man pages for details. In any case, we don't want to do that. Note\n-      --  that Descriptor.Pid will be -1 if the process was not successfully\n-      --  started; we don't want to kill ourself in that case.\n-\n-      if Descriptor.Pid > 0 then\n-         Kill (Descriptor.Pid, Signal);\n-         --  ??? Need to check process status here\n-      else\n-         raise Invalid_Process;\n-      end if;\n-   end Send_Signal;\n-\n-   ---------------------------------\n-   -- Set_Up_Child_Communications --\n-   ---------------------------------\n-\n-   procedure Set_Up_Child_Communications\n-     (Pid   : in out Process_Descriptor;\n-      Pipe1 : in out Pipe_Type;\n-      Pipe2 : in out Pipe_Type;\n-      Pipe3 : in out Pipe_Type;\n-      Cmd   : String;\n-      Args  : System.Address)\n-   is\n-      pragma Warnings (Off, Pid);\n-      pragma Warnings (Off, Pipe1);\n-      pragma Warnings (Off, Pipe2);\n-      pragma Warnings (Off, Pipe3);\n-\n-   begin\n-      --  Since the code between fork and exec on VMS executes\n-      --  in the context of the parent process, we need to\n-      --  perform the following actions:\n-      --    - save stdin, stdout, stderr\n-      --    - replace them by our pipes\n-      --    - create the child with process handle inheritance\n-      --    - revert to the previous stdin, stdout and stderr.\n-\n-      Save_Input  := Dup (GNAT.OS_Lib.Standin);\n-      Save_Output := Dup (GNAT.OS_Lib.Standout);\n-      Save_Error  := Dup (GNAT.OS_Lib.Standerr);\n-\n-      --  Since we are still called from the parent process, there is no way\n-      --  currently we can cleanly close the unneeded ends of the pipes, but\n-      --  this doesn't really matter.\n-\n-      --  We could close Pipe1.Output, Pipe2.Input, Pipe3.Input\n-\n-      Dup2 (Pipe1.Input,  GNAT.OS_Lib.Standin);\n-      Dup2 (Pipe2.Output, GNAT.OS_Lib.Standout);\n-      Dup2 (Pipe3.Output, GNAT.OS_Lib.Standerr);\n-\n-      Portable_Execvp (Pid.Pid'Access, Cmd & ASCII.NUL, Args);\n-   end Set_Up_Child_Communications;\n-\n-   ---------------------------\n-   -- Set_Up_Communications --\n-   ---------------------------\n-\n-   procedure Set_Up_Communications\n-     (Pid        : in out Process_Descriptor;\n-      Err_To_Out : Boolean;\n-      Pipe1      : not null access Pipe_Type;\n-      Pipe2      : not null access Pipe_Type;\n-      Pipe3      : not null access Pipe_Type)\n-   is\n-   begin\n-      --  Create the pipes\n-\n-      if Create_Pipe (Pipe1) /= 0 then\n-         return;\n-      end if;\n-\n-      if Create_Pipe (Pipe2) /= 0 then\n-         return;\n-      end if;\n-\n-      Pid.Input_Fd  := Pipe1.Output;\n-      Pid.Output_Fd := Pipe2.Input;\n-\n-      if Err_To_Out then\n-         Pipe3.all := Pipe2.all;\n-      else\n-         if Create_Pipe (Pipe3) /= 0 then\n-            return;\n-         end if;\n-      end if;\n-\n-      Pid.Error_Fd := Pipe3.Input;\n-   end Set_Up_Communications;\n-\n-   ----------------------------------\n-   -- Set_Up_Parent_Communications --\n-   ----------------------------------\n-\n-   procedure Set_Up_Parent_Communications\n-     (Pid   : in out Process_Descriptor;\n-      Pipe1 : in out Pipe_Type;\n-      Pipe2 : in out Pipe_Type;\n-      Pipe3 : in out Pipe_Type)\n-   is\n-      pragma Warnings (Off, Pid);\n-      pragma Warnings (Off, Pipe1);\n-      pragma Warnings (Off, Pipe2);\n-      pragma Warnings (Off, Pipe3);\n-\n-   begin\n-\n-      Dup2 (Save_Input,  GNAT.OS_Lib.Standin);\n-      Dup2 (Save_Output, GNAT.OS_Lib.Standout);\n-      Dup2 (Save_Error,  GNAT.OS_Lib.Standerr);\n-\n-      Close (Save_Input);\n-      Close (Save_Output);\n-      Close (Save_Error);\n-\n-      Close (Pipe1.Input);\n-      Close (Pipe2.Output);\n-      Close (Pipe3.Output);\n-   end Set_Up_Parent_Communications;\n-\n-   ------------------\n-   -- Trace_Filter --\n-   ------------------\n-\n-   procedure Trace_Filter\n-     (Descriptor : Process_Descriptor'Class;\n-      Str        : String;\n-      User_Data  : System.Address := System.Null_Address)\n-   is\n-      pragma Warnings (Off, Descriptor);\n-      pragma Warnings (Off, User_Data);\n-   begin\n-      GNAT.IO.Put (Str);\n-   end Trace_Filter;\n-\n-   --------------------\n-   -- Unlock_Filters --\n-   --------------------\n-\n-   procedure Unlock_Filters (Descriptor : in out Process_Descriptor) is\n-   begin\n-      if Descriptor.Filters_Lock > 0 then\n-         Descriptor.Filters_Lock := Descriptor.Filters_Lock - 1;\n-      end if;\n-   end Unlock_Filters;\n-\n-end GNAT.Expect;"}, {"sha": "e2adc8c488d69e60f61cbd0098d0fa83b9520582", "filename": "gcc/ada/g-socthi-vms.adb", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-socthi-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-socthi-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,501 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    G N A T . S O C K E T S . T H I N                     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---                     Copyright (C) 2001-2014, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the version for OpenVMS\n-\n-with GNAT.OS_Lib; use GNAT.OS_Lib;\n-with GNAT.Task_Lock;\n-\n-with Interfaces.C; use Interfaces.C;\n-\n-package body GNAT.Sockets.Thin is\n-\n-   type VMS_Msghdr is new Msghdr;\n-   pragma Pack (VMS_Msghdr);\n-   --  On VMS 8.x (unlike other platforms), struct msghdr is packed, so a\n-   --  specific derived type is required. This structure was not packed on\n-   --  VMS 7.3.\n-\n-   function Is_VMS_V7 return Integer;\n-   pragma Import (C, Is_VMS_V7, \"__gnat_is_vms_v7\");\n-   --  Helper (defined in init.c) that returns a non-zero value if the VMS\n-   --  version is 7.x.\n-\n-   VMS_V7 : constant Boolean := Is_VMS_V7 /= 0;\n-   --  True if VMS version is 7.x.\n-\n-   Non_Blocking_Sockets : aliased Fd_Set;\n-   --  When this package is initialized with Process_Blocking_IO set to True,\n-   --  sockets are set in non-blocking mode to avoid blocking the whole process\n-   --  when a thread wants to perform a blocking IO operation. But the user can\n-   --  also set a socket in non-blocking mode by purpose. In order to make a\n-   --  difference between these two situations, we track the origin of\n-   --  non-blocking mode in Non_Blocking_Sockets. Note that if S is in\n-   --  Non_Blocking_Sockets, it has been set in non-blocking mode by the user.\n-\n-   Quantum : constant Duration := 0.2;\n-   --  When SOSC.Thread_Blocking_IO is False, we set sockets to non-blocking\n-   --  mode and we spend a period of time Quantum between two attempts on a\n-   --  blocking operation.\n-\n-   function Syscall_Accept\n-     (S       : C.int;\n-      Addr    : System.Address;\n-      Addrlen : not null access C.int) return C.int;\n-   pragma Import (C, Syscall_Accept, \"accept\");\n-\n-   function Syscall_Connect\n-     (S       : C.int;\n-      Name    : System.Address;\n-      Namelen : C.int) return C.int;\n-   pragma Import (C, Syscall_Connect, \"connect\");\n-\n-   function Syscall_Recv\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Len   : C.int;\n-      Flags : C.int) return C.int;\n-   pragma Import (C, Syscall_Recv, \"recv\");\n-\n-   function Syscall_Recvfrom\n-     (S       : C.int;\n-      Msg     : System.Address;\n-      Len     : C.int;\n-      Flags   : C.int;\n-      From    : System.Address;\n-      Fromlen : not null access C.int) return C.int;\n-   pragma Import (C, Syscall_Recvfrom, \"recvfrom\");\n-\n-   function Syscall_Recvmsg\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Flags : C.int) return C.int;\n-   pragma Import (C, Syscall_Recvmsg, \"recvmsg\");\n-\n-   function Syscall_Sendmsg\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Flags : C.int) return C.int;\n-   pragma Import (C, Syscall_Sendmsg, \"sendmsg\");\n-\n-   function Syscall_Sendto\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Len   : C.int;\n-      Flags : C.int;\n-      To    : System.Address;\n-      Tolen : C.int) return C.int;\n-   pragma Import (C, Syscall_Sendto, \"sendto\");\n-\n-   function Syscall_Socket\n-     (Domain, Typ, Protocol : C.int) return C.int;\n-   pragma Import (C, Syscall_Socket, \"socket\");\n-\n-   function Non_Blocking_Socket (S : C.int) return Boolean;\n-   procedure Set_Non_Blocking_Socket (S : C.int; V : Boolean);\n-\n-   --------------\n-   -- C_Accept --\n-   --------------\n-\n-   function C_Accept\n-     (S       : C.int;\n-      Addr    : System.Address;\n-      Addrlen : not null access C.int) return C.int\n-   is\n-      R   : C.int;\n-      Val : aliased C.int := 1;\n-\n-      Discard : C.int;\n-      pragma Warnings (Off, Discard);\n-\n-   begin\n-      loop\n-         R := Syscall_Accept (S, Addr, Addrlen);\n-         exit when SOSC.Thread_Blocking_IO\n-           or else R /= Failure\n-           or else Non_Blocking_Socket (S)\n-           or else Errno /= SOSC.EWOULDBLOCK;\n-         delay Quantum;\n-      end loop;\n-\n-      if not SOSC.Thread_Blocking_IO\n-        and then R /= Failure\n-      then\n-         --  A socket inherits the properties of its server, especially\n-         --  the FIONBIO flag. Do not use Socket_Ioctl as this subprogram\n-         --  tracks sockets set in non-blocking mode by user.\n-\n-         Set_Non_Blocking_Socket (R, Non_Blocking_Socket (S));\n-         Discard := C_Ioctl (R, SOSC.FIONBIO, Val'Access);\n-      end if;\n-\n-      return R;\n-   end C_Accept;\n-\n-   ---------------\n-   -- C_Connect --\n-   ---------------\n-\n-   function C_Connect\n-     (S       : C.int;\n-      Name    : System.Address;\n-      Namelen : C.int) return C.int\n-   is\n-      Res : C.int;\n-\n-   begin\n-      Res := Syscall_Connect (S, Name, Namelen);\n-\n-      if SOSC.Thread_Blocking_IO\n-        or else Res /= Failure\n-        or else Non_Blocking_Socket (S)\n-        or else Errno /= SOSC.EINPROGRESS\n-      then\n-         return Res;\n-      end if;\n-\n-      declare\n-         WSet : aliased Fd_Set;\n-         Now  : aliased Timeval;\n-\n-      begin\n-         Reset_Socket_Set (WSet'Access);\n-         loop\n-            Insert_Socket_In_Set (WSet'Access, S);\n-            Now := Immediat;\n-            Res := C_Select\n-              (S + 1,\n-               No_Fd_Set_Access,\n-               WSet'Access,\n-               No_Fd_Set_Access,\n-               Now'Unchecked_Access);\n-\n-            exit when Res > 0;\n-\n-            if Res = Failure then\n-               return Res;\n-            end if;\n-\n-            delay Quantum;\n-         end loop;\n-      end;\n-\n-      Res := Syscall_Connect (S, Name, Namelen);\n-\n-      if Res = Failure and then Errno = SOSC.EISCONN then\n-         return Thin_Common.Success;\n-      else\n-         return Res;\n-      end if;\n-   end C_Connect;\n-\n-   ------------------\n-   -- Socket_Ioctl --\n-   ------------------\n-\n-   function Socket_Ioctl\n-     (S   : C.int;\n-      Req : SOSC.IOCTL_Req_T;\n-      Arg : access C.int) return C.int\n-   is\n-   begin\n-      if not SOSC.Thread_Blocking_IO and then Req = SOSC.FIONBIO then\n-         if Arg.all /= 0 then\n-            Set_Non_Blocking_Socket (S, True);\n-         end if;\n-      end if;\n-\n-      return C_Ioctl (S, Req, Arg);\n-   end Socket_Ioctl;\n-\n-   ------------\n-   -- C_Recv --\n-   ------------\n-\n-   function C_Recv\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Len   : C.int;\n-      Flags : C.int) return C.int\n-   is\n-      Res : C.int;\n-\n-   begin\n-      loop\n-         Res := Syscall_Recv (S, Msg, Len, Flags);\n-         exit when SOSC.Thread_Blocking_IO\n-           or else Res /= Failure\n-           or else Non_Blocking_Socket (S)\n-           or else Errno /= SOSC.EWOULDBLOCK;\n-         delay Quantum;\n-      end loop;\n-\n-      return Res;\n-   end C_Recv;\n-\n-   ----------------\n-   -- C_Recvfrom --\n-   ----------------\n-\n-   function C_Recvfrom\n-     (S       : C.int;\n-      Msg     : System.Address;\n-      Len     : C.int;\n-      Flags   : C.int;\n-      From    : System.Address;\n-      Fromlen : not null access C.int) return C.int\n-   is\n-      Res : C.int;\n-\n-   begin\n-      loop\n-         Res := Syscall_Recvfrom (S, Msg, Len, Flags, From, Fromlen);\n-         exit when SOSC.Thread_Blocking_IO\n-           or else Res /= Failure\n-           or else Non_Blocking_Socket (S)\n-           or else Errno /= SOSC.EWOULDBLOCK;\n-         delay Quantum;\n-      end loop;\n-\n-      return Res;\n-   end C_Recvfrom;\n-\n-   ---------------\n-   -- C_Recvmsg --\n-   ---------------\n-\n-   function C_Recvmsg\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Flags : C.int) return System.CRTL.ssize_t\n-   is\n-      Res : C.int;\n-\n-      Msg_Addr : System.Address;\n-\n-      GNAT_Msg : Msghdr;\n-      for GNAT_Msg'Address use Msg;\n-      pragma Import (Ada, GNAT_Msg);\n-\n-      VMS_Msg : aliased VMS_Msghdr;\n-\n-   begin\n-      if VMS_V7 then\n-         Msg_Addr := Msg;\n-      else\n-         VMS_Msg := VMS_Msghdr (GNAT_Msg);\n-         Msg_Addr := VMS_Msg'Address;\n-      end if;\n-\n-      loop\n-         Res := Syscall_Recvmsg (S, Msg_Addr, Flags);\n-         exit when SOSC.Thread_Blocking_IO\n-           or else Res /= Failure\n-           or else Non_Blocking_Socket (S)\n-           or else Errno /= SOSC.EWOULDBLOCK;\n-         delay Quantum;\n-      end loop;\n-\n-      if not VMS_V7 then\n-         GNAT_Msg := Msghdr (VMS_Msg);\n-      end if;\n-\n-      return System.CRTL.ssize_t (Res);\n-   end C_Recvmsg;\n-\n-   ---------------\n-   -- C_Sendmsg --\n-   ---------------\n-\n-   function C_Sendmsg\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Flags : C.int) return System.CRTL.ssize_t\n-   is\n-      Res : C.int;\n-\n-      Msg_Addr : System.Address;\n-\n-      GNAT_Msg : Msghdr;\n-      for GNAT_Msg'Address use Msg;\n-      pragma Import (Ada, GNAT_Msg);\n-\n-      VMS_Msg : aliased VMS_Msghdr;\n-\n-   begin\n-      if VMS_V7 then\n-         Msg_Addr := Msg;\n-      else\n-         VMS_Msg := VMS_Msghdr (GNAT_Msg);\n-         Msg_Addr := VMS_Msg'Address;\n-      end if;\n-\n-      loop\n-         Res := Syscall_Sendmsg (S, Msg_Addr, Flags);\n-         exit when SOSC.Thread_Blocking_IO\n-           or else Res /= Failure\n-           or else Non_Blocking_Socket (S)\n-           or else Errno /= SOSC.EWOULDBLOCK;\n-         delay Quantum;\n-      end loop;\n-\n-      if not VMS_V7 then\n-         GNAT_Msg := Msghdr (VMS_Msg);\n-      end if;\n-\n-      return System.CRTL.ssize_t (Res);\n-   end C_Sendmsg;\n-\n-   --------------\n-   -- C_Sendto --\n-   --------------\n-\n-   function C_Sendto\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Len   : C.int;\n-      Flags : C.int;\n-      To    : System.Address;\n-      Tolen : C.int) return C.int\n-   is\n-      Res : C.int;\n-\n-   begin\n-      loop\n-         Res := Syscall_Sendto (S, Msg, Len, Flags, To, Tolen);\n-         exit when SOSC.Thread_Blocking_IO\n-           or else Res /= Failure\n-           or else Non_Blocking_Socket (S)\n-           or else Errno /= SOSC.EWOULDBLOCK;\n-         delay Quantum;\n-      end loop;\n-\n-      return Res;\n-   end C_Sendto;\n-\n-   --------------\n-   -- C_Socket --\n-   --------------\n-\n-   function C_Socket\n-     (Domain   : C.int;\n-      Typ      : C.int;\n-      Protocol : C.int) return C.int\n-   is\n-      R   : C.int;\n-      Val : aliased C.int := 1;\n-\n-      Discard : C.int;\n-\n-   begin\n-      R := Syscall_Socket (Domain, Typ, Protocol);\n-\n-      if not SOSC.Thread_Blocking_IO\n-        and then R /= Failure\n-      then\n-         --  Do not use Socket_Ioctl as this subprogram tracks sockets set\n-         --  in non-blocking mode by user.\n-\n-         Discard := C_Ioctl (R, SOSC.FIONBIO, Val'Access);\n-         Set_Non_Blocking_Socket (R, False);\n-      end if;\n-\n-      return R;\n-   end C_Socket;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize is\n-   begin\n-      null;\n-   end Finalize;\n-\n-   -------------------------\n-   -- Host_Error_Messages --\n-   -------------------------\n-\n-   package body Host_Error_Messages is separate;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-   begin\n-      Reset_Socket_Set (Non_Blocking_Sockets'Access);\n-   end Initialize;\n-\n-   -------------------------\n-   -- Non_Blocking_Socket --\n-   -------------------------\n-\n-   function Non_Blocking_Socket (S : C.int) return Boolean is\n-      R : Boolean;\n-   begin\n-      Task_Lock.Lock;\n-      R := (Is_Socket_In_Set (Non_Blocking_Sockets'Access, S) /= 0);\n-      Task_Lock.Unlock;\n-      return R;\n-   end Non_Blocking_Socket;\n-\n-   -----------------------------\n-   -- Set_Non_Blocking_Socket --\n-   -----------------------------\n-\n-   procedure Set_Non_Blocking_Socket (S : C.int; V : Boolean) is\n-   begin\n-      Task_Lock.Lock;\n-\n-      if V then\n-         Insert_Socket_In_Set (Non_Blocking_Sockets'Access, S);\n-      else\n-         Remove_Socket_From_Set (Non_Blocking_Sockets'Access, S);\n-      end if;\n-\n-      Task_Lock.Unlock;\n-   end Set_Non_Blocking_Socket;\n-\n-   --------------------\n-   -- Signalling_Fds --\n-   --------------------\n-\n-   package body Signalling_Fds is separate;\n-\n-   --------------------------\n-   -- Socket_Error_Message --\n-   --------------------------\n-\n-   function Socket_Error_Message (Errno : Integer) return String is separate;\n-\n-end GNAT.Sockets.Thin;"}, {"sha": "25c587057036f32304cb8d42b3d0f49445879dfd", "filename": "gcc/ada/g-socthi-vms.ads", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-socthi-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fg-socthi-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,257 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    G N A T . S O C K E T S . T H I N                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---                     Copyright (C) 2002-2013, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides a target dependent thin interface to the sockets\n---  layer for use by the GNAT.Sockets package (g-socket.ads). This package\n---  should not be directly with'ed by an applications program.\n-\n---  This is the Alpha/VMS version\n-\n-with Interfaces.C;\n-\n-with GNAT.OS_Lib;\n-with GNAT.Sockets.Thin_Common;\n-\n-with System;\n-with System.CRTL;\n-\n-package GNAT.Sockets.Thin is\n-\n-   --  ??? more comments needed ???\n-\n-   use Thin_Common;\n-\n-   package C renames Interfaces.C;\n-\n-   use type System.CRTL.ssize_t;\n-\n-   function Socket_Errno return Integer renames GNAT.OS_Lib.Errno;\n-   --  Returns last socket error number\n-\n-   procedure Set_Socket_Errno (Errno : Integer) renames GNAT.OS_Lib.Set_Errno;\n-   --  Set last socket error number\n-\n-   function Socket_Error_Message (Errno : Integer) return String;\n-   --  Returns the error message string for the error number Errno. If Errno is\n-   --  not known, returns \"Unknown system error\".\n-\n-   function Host_Errno return Integer;\n-   pragma Import (C, Host_Errno, \"__gnat_get_h_errno\");\n-   --  Returns last host error number\n-\n-   package Host_Error_Messages is\n-\n-      function Host_Error_Message (H_Errno : Integer) return String;\n-      --  Returns the error message string for the host error number H_Errno.\n-      --  If H_Errno is not known, returns \"Unknown system error\".\n-\n-   end Host_Error_Messages;\n-\n-   --------------------------------\n-   -- Standard library functions --\n-   --------------------------------\n-\n-   function C_Accept\n-     (S       : C.int;\n-      Addr    : System.Address;\n-      Addrlen : not null access C.int) return C.int;\n-\n-   function C_Bind\n-     (S       : C.int;\n-      Name    : System.Address;\n-      Namelen : C.int) return C.int;\n-\n-   function C_Close\n-     (Fd : C.int) return C.int;\n-\n-   function C_Connect\n-     (S       : C.int;\n-      Name    : System.Address;\n-      Namelen : C.int) return C.int;\n-\n-   function C_Gethostname\n-     (Name    : System.Address;\n-      Namelen : C.int) return C.int;\n-\n-   function C_Getpeername\n-     (S       : C.int;\n-      Name    : System.Address;\n-      Namelen : not null access C.int) return C.int;\n-\n-   function C_Getsockname\n-     (S       : C.int;\n-      Name    : System.Address;\n-      Namelen : not null access C.int) return C.int;\n-\n-   function C_Getsockopt\n-     (S       : C.int;\n-      Level   : C.int;\n-      Optname : C.int;\n-      Optval  : System.Address;\n-      Optlen  : not null access C.int) return C.int;\n-\n-   function Socket_Ioctl\n-     (S   : C.int;\n-      Req : SOSC.IOCTL_Req_T;\n-      Arg : access C.int) return C.int;\n-\n-   function C_Listen\n-     (S       : C.int;\n-      Backlog : C.int) return C.int;\n-\n-   function C_Recv\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Len   : C.int;\n-      Flags : C.int) return C.int;\n-\n-   function C_Recvfrom\n-     (S       : C.int;\n-      Msg     : System.Address;\n-      Len     : C.int;\n-      Flags   : C.int;\n-      From    : System.Address;\n-      Fromlen : not null access C.int) return C.int;\n-\n-   function C_Recvmsg\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Flags : C.int) return System.CRTL.ssize_t;\n-\n-   function C_Select\n-     (Nfds      : C.int;\n-      Readfds   : access Fd_Set;\n-      Writefds  : access Fd_Set;\n-      Exceptfds : access Fd_Set;\n-      Timeout   : Timeval_Access) return C.int;\n-\n-   function C_Sendmsg\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Flags : C.int) return System.CRTL.ssize_t;\n-\n-   function C_Sendto\n-     (S     : C.int;\n-      Msg   : System.Address;\n-      Len   : C.int;\n-      Flags : C.int;\n-      To    : System.Address;\n-      Tolen : C.int) return C.int;\n-\n-   function C_Setsockopt\n-     (S       : C.int;\n-      Level   : C.int;\n-      Optname : C.int;\n-      Optval  : System.Address;\n-      Optlen  : C.int) return C.int;\n-\n-   function C_Shutdown\n-     (S   : C.int;\n-      How : C.int) return C.int;\n-\n-   function C_Socket\n-     (Domain   : C.int;\n-      Typ      : C.int;\n-      Protocol : C.int) return C.int;\n-\n-   function C_System\n-     (Command : System.Address) return C.int;\n-\n-   -------------------------------------------------------\n-   -- Signalling file descriptors for selector abortion --\n-   -------------------------------------------------------\n-\n-   package Signalling_Fds is\n-\n-      function Create (Fds : not null access Fd_Pair) return C.int;\n-      pragma Convention (C, Create);\n-      --  Create a pair of connected descriptors suitable for use with C_Select\n-      --  (used for signalling in Selector objects).\n-\n-      function Read (Rsig : C.int) return C.int;\n-      pragma Convention (C, Read);\n-      --  Read one byte of data from rsig, the read end of a pair of signalling\n-      --  fds created by Create_Signalling_Fds.\n-\n-      function Write (Wsig : C.int) return C.int;\n-      pragma Convention (C, Write);\n-      --  Write one byte of data to wsig, the write end of a pair of signalling\n-      --  fds created by Create_Signalling_Fds.\n-\n-      procedure Close (Sig : C.int);\n-      pragma Convention (C, Close);\n-      --  Close one end of a pair of signalling fds (ignoring any error)\n-\n-   end Signalling_Fds;\n-\n-   -------------------------------------------\n-   -- Nonreentrant network databases access --\n-   -------------------------------------------\n-\n-   function Nonreentrant_Gethostbyname\n-     (Name : C.char_array) return Hostent_Access;\n-\n-   function Nonreentrant_Gethostbyaddr\n-     (Addr      : System.Address;\n-      Addr_Len  : C.int;\n-      Addr_Type : C.int) return Hostent_Access;\n-\n-   function Nonreentrant_Getservbyname\n-     (Name  : C.char_array;\n-      Proto : C.char_array) return Servent_Access;\n-\n-   function Nonreentrant_Getservbyport\n-     (Port  : C.int;\n-      Proto : C.char_array) return Servent_Access;\n-\n-   procedure Initialize;\n-   procedure Finalize;\n-\n-private\n-\n-   pragma Import (C, C_Bind,          \"DECC$BIND\");\n-   pragma Import (C, C_Close,         \"DECC$CLOSE\");\n-   pragma Import (C, C_Gethostname,   \"DECC$GETHOSTNAME\");\n-   pragma Import (C, C_Getpeername,   \"DECC$GETPEERNAME\");\n-   pragma Import (C, C_Getsockname,   \"DECC$GETSOCKNAME\");\n-   pragma Import (C, C_Getsockopt,    \"DECC$GETSOCKOPT\");\n-   pragma Import (C, C_Listen,        \"DECC$LISTEN\");\n-   pragma Import (C, C_Select,        \"DECC$SELECT\");\n-   pragma Import (C, C_Setsockopt,    \"DECC$SETSOCKOPT\");\n-   pragma Import (C, C_Shutdown,      \"DECC$SHUTDOWN\");\n-   pragma Import (C, C_System,        \"DECC$SYSTEM\");\n-\n-   pragma Import (C, Nonreentrant_Gethostbyname, \"DECC$GETHOSTBYNAME\");\n-   pragma Import (C, Nonreentrant_Gethostbyaddr, \"DECC$GETHOSTBYADDR\");\n-   pragma Import (C, Nonreentrant_Getservbyname, \"DECC$GETSERVBYNAME\");\n-   pragma Import (C, Nonreentrant_Getservbyport, \"DECC$GETSERVBYPORT\");\n-\n-end GNAT.Sockets.Thin;"}, {"sha": "85e6f56b31afe5aaa5c148662b5626f90ab962b1", "filename": "gcc/ada/i-cstrea-vms.adb", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fi-cstrea-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fi-cstrea-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,253 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                 I N T E R F A C E S . C _ S T R E A M S                  --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1996-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha/VMS version\n-\n-with Ada.Unchecked_Conversion;\n-package body Interfaces.C_Streams is\n-\n-   use type System.CRTL.size_t;\n-\n-   --  As the functions fread, fwrite and setvbuf are too big to be inlined,\n-   --  they are just wrappers to the following implementation functions.\n-\n-   function fread_impl\n-     (buffer : voids;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t;\n-\n-   function fread_impl\n-     (buffer : voids;\n-      index  : size_t;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t;\n-\n-   function fwrite_impl\n-     (buffer : voids;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t;\n-\n-   function setvbuf_impl\n-     (stream : FILEs;\n-      buffer : chars;\n-      mode   : int;\n-      size   : size_t) return int;\n-\n-   ------------\n-   -- fread --\n-   ------------\n-\n-   function fread_impl\n-     (buffer : voids;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t\n-   is\n-      Get_Count : size_t := 0;\n-\n-      type Buffer_Type is array (size_t range 1 .. count,\n-                                 size_t range 1 .. size) of Character;\n-      type Buffer_Access is access Buffer_Type;\n-      function To_BA is new Ada.Unchecked_Conversion (voids, Buffer_Access);\n-\n-      BA : constant Buffer_Access := To_BA (buffer);\n-      Ch : int;\n-\n-   begin\n-      --  This Fread goes with the Fwrite below. The C library fread sometimes\n-      --  can't read fputc generated files.\n-\n-      for C in 1 .. count loop\n-         for S in 1 .. size loop\n-            Ch := fgetc (stream);\n-\n-            if Ch = EOF then\n-               return Get_Count;\n-            end if;\n-\n-            BA.all (C, S) := Character'Val (Ch);\n-         end loop;\n-\n-         Get_Count := Get_Count + 1;\n-      end loop;\n-\n-      return Get_Count;\n-   end fread_impl;\n-\n-   function fread_impl\n-     (buffer : voids;\n-      index  : size_t;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t\n-   is\n-      Get_Count : size_t := 0;\n-\n-      type Buffer_Type is array (size_t range 1 .. count,\n-                                 size_t range 1 .. size) of Character;\n-      type Buffer_Access is access Buffer_Type;\n-      function To_BA is new Ada.Unchecked_Conversion (voids, Buffer_Access);\n-\n-      BA : constant Buffer_Access := To_BA (buffer);\n-      Ch : int;\n-\n-   begin\n-      --  This Fread goes with the Fwrite below. The C library fread sometimes\n-      --  can't read fputc generated files.\n-\n-      for C in 1 + index .. count + index loop\n-         for S in 1 .. size loop\n-            Ch := fgetc (stream);\n-\n-            if Ch = EOF then\n-               return Get_Count;\n-            end if;\n-\n-            BA.all (C, S) := Character'Val (Ch);\n-         end loop;\n-\n-         Get_Count := Get_Count + 1;\n-      end loop;\n-\n-      return Get_Count;\n-   end fread_impl;\n-\n-   function fread\n-     (buffer : voids;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t\n-   is\n-   begin\n-      return fread_impl (buffer, size, count, stream);\n-   end fread;\n-\n-   function fread\n-     (buffer : voids;\n-      index  : size_t;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t\n-   is\n-   begin\n-      return fread_impl (buffer, index, size, count, stream);\n-   end fread;\n-\n-   ------------\n-   -- fwrite --\n-   ------------\n-\n-   function fwrite_impl\n-     (buffer : voids;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t\n-   is\n-      Put_Count : size_t := 0;\n-\n-      type Buffer_Type is array (size_t range 1 .. count,\n-                                 size_t range 1 .. size) of Character;\n-      type Buffer_Access is access Buffer_Type;\n-      function To_BA is new Ada.Unchecked_Conversion (voids, Buffer_Access);\n-\n-      BA : constant Buffer_Access := To_BA (buffer);\n-\n-   begin\n-      --  Fwrite on VMS has the undesirable effect of always generating at\n-      --  least one record of output per call, regardless of buffering.  To\n-      --  get around this, we do multiple fputc calls instead.\n-\n-      for C in 1 .. count loop\n-         for S in 1 .. size loop\n-            if fputc (Character'Pos (BA.all (C, S)), stream) = EOF then\n-               return Put_Count;\n-            end if;\n-         end loop;\n-\n-         Put_Count := Put_Count + 1;\n-      end loop;\n-\n-      return Put_Count;\n-   end fwrite_impl;\n-\n-   function fwrite\n-     (buffer : voids;\n-      size   : size_t;\n-      count  : size_t;\n-      stream : FILEs) return size_t\n-   is\n-   begin\n-      return fwrite_impl (buffer, size, count, stream);\n-   end fwrite;\n-\n-   -------------\n-   -- setvbuf --\n-   -------------\n-\n-   function setvbuf_impl\n-     (stream : FILEs;\n-      buffer : chars;\n-      mode   : int;\n-      size   : size_t) return int\n-   is\n-      use type System.Address;\n-\n-   begin\n-      --  In order for the above fwrite hack to work, we must always buffer\n-      --  stdout and stderr. Is_regular_file on VMS cannot detect when\n-      --  these are redirected to a file, so checking for that condition\n-      --  doesn't help.\n-\n-      if mode = IONBF\n-        and then (stream = stdout or else stream = stderr)\n-      then\n-         return System.CRTL.setvbuf\n-           (stream, buffer, IOLBF, System.CRTL.size_t (size));\n-      else\n-         return System.CRTL.setvbuf\n-           (stream, buffer, mode, System.CRTL.size_t (size));\n-      end if;\n-   end setvbuf_impl;\n-\n-   function setvbuf\n-     (stream : FILEs;\n-      buffer : chars;\n-      mode   : int;\n-      size   : size_t) return int\n-   is\n-   begin\n-      return setvbuf_impl (stream, buffer, mode, size);\n-   end setvbuf;\n-\n-end Interfaces.C_Streams;"}, {"sha": "082cbbebcd4c5c5c279c4d7a90c15471bef0ad45", "filename": "gcc/ada/mlib-tgt-specific-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 509, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-specific-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-specific-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-vms-alpha.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,509 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                           (Alpha VMS Version)                            --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha VMS version of the body\n-\n-with Ada.Characters.Handling; use Ada.Characters.Handling;\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-\n-with MLib.Tgt.VMS_Common; use MLib.Tgt.VMS_Common;\n-\n-with Opt;      use Opt;\n-with Output;   use Output;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n-with System;           use System;\n-with System.Case_Util; use System.Case_Util;\n-with System.CRTL;      use System.CRTL;\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Non default subprogram. See comment in mlib-tgt.ads\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   --  Local variables\n-\n-   Empty_Argument_List : aliased Argument_List := (1 .. 0 => null);\n-   Additional_Objects  : Argument_List_Access := Empty_Argument_List'Access;\n-   --  Used to add the generated auto-init object files for auto-initializing\n-   --  stand-alone libraries.\n-\n-   Macro_Name : constant String := \"mcr gnu:[bin]gcc -c -x assembler\";\n-   --  The name of the command to invoke the macro-assembler\n-\n-   VMS_Options : Argument_List := (1 .. 1 => null);\n-\n-   Gnatsym_Name : constant String := \"gnatsym\";\n-\n-   Gnatsym_Path : String_Access;\n-\n-   Arguments : Argument_List_Access := null;\n-   Last_Argument : Natural := 0;\n-\n-   Success : Boolean := False;\n-\n-   Shared_Libgcc : aliased String := \"-shared-libgcc\";\n-\n-   Shared_Libgcc_Switch : constant Argument_List :=\n-                            (1 => Shared_Libgcc'Access);\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-\n-      Lib_File : constant String :=\n-                   Lib_Dir & Directory_Separator & \"lib\" &\n-                   Fil.Ext_To (Lib_Filename, DLL_Ext);\n-\n-      Opts      : Argument_List := Options;\n-      Last_Opt  : Natural       := Opts'Last;\n-      Opts2     : Argument_List (Options'Range);\n-      Last_Opt2 : Natural       := Opts2'First - 1;\n-\n-      Inter : constant Argument_List := Interfaces;\n-\n-      function Is_Interface (Obj_File : String) return Boolean;\n-      --  For a Stand-Alone Library, returns True if Obj_File is the object\n-      --  file name of an interface of the SAL. For other libraries, always\n-      --  return True.\n-\n-      function Option_File_Name return String;\n-      --  Returns Symbol_File, if not empty. Otherwise, returns \"symvec.opt\"\n-\n-      function Version_String return String;\n-      --  Returns Lib_Version if not empty and if Symbol_Data.Symbol_Policy is\n-      --  not Autonomous, otherwise returns \"\". When Symbol_Data.Symbol_Policy\n-      --  is Autonomous, fails gnatmake if Lib_Version is not the image of a\n-      --  positive number.\n-\n-      ------------------\n-      -- Is_Interface --\n-      ------------------\n-\n-      function Is_Interface (Obj_File : String) return Boolean is\n-         ALI : constant String :=\n-                 Fil.Ext_To\n-                  (Filename => To_Lower (Base_Name (Obj_File)),\n-                   New_Ext  => \"ali\");\n-\n-      begin\n-         if Inter'Length = 0 then\n-            return True;\n-\n-         elsif ALI'Length > 2 and then\n-               ALI (ALI'First .. ALI'First + 2) = \"b__\"\n-         then\n-            return True;\n-\n-         else\n-            for J in Inter'Range loop\n-               if Inter (J).all = ALI then\n-                  return True;\n-               end if;\n-            end loop;\n-\n-            return False;\n-         end if;\n-      end Is_Interface;\n-\n-      ----------------------\n-      -- Option_File_Name --\n-      ----------------------\n-\n-      function Option_File_Name return String is\n-      begin\n-         if Symbol_Data.Symbol_File = No_Path then\n-            return \"symvec.opt\";\n-         else\n-            Get_Name_String (Symbol_Data.Symbol_File);\n-            To_Lower (Name_Buffer (1 .. Name_Len));\n-            return Name_Buffer (1 .. Name_Len);\n-         end if;\n-      end Option_File_Name;\n-\n-      --------------------\n-      -- Version_String --\n-      --------------------\n-\n-      function Version_String return String is\n-         Version : Integer := 0;\n-\n-      begin\n-         if Lib_Version = \"\"\n-           or else Symbol_Data.Symbol_Policy /= Autonomous\n-         then\n-            return \"\";\n-\n-         else\n-            begin\n-               Version := Integer'Value (Lib_Version);\n-\n-               if Version <= 0 then\n-                  raise Constraint_Error;\n-               end if;\n-\n-               return Lib_Version;\n-\n-            exception\n-               when Constraint_Error =>\n-                  Fail (\"illegal version \"\"\"\n-                        & Lib_Version\n-                        & \"\"\" (on VMS version must be a positive number)\");\n-                  return \"\";\n-            end;\n-         end if;\n-      end Version_String;\n-\n-      ---------------------\n-      -- Local Variables --\n-      ---------------------\n-\n-      Opt_File_Name  : constant String := Option_File_Name;\n-      Version        : constant String := Version_String;\n-      For_Linker_Opt : String_Access;\n-\n-   --  Start of processing for Build_Dynamic_Library\n-\n-   begin\n-      --  If option file name does not ends with \".opt\", append \"/OPTIONS\"\n-      --  to its specification for the VMS linker.\n-\n-      if Opt_File_Name'Length > 4\n-        and then\n-          Opt_File_Name (Opt_File_Name'Last - 3 .. Opt_File_Name'Last) = \".opt\"\n-      then\n-         For_Linker_Opt := new String'(\"--for-linker=\" & Opt_File_Name);\n-      else\n-         For_Linker_Opt :=\n-           new String'(\"--for-linker=\" & Opt_File_Name & \"/OPTIONS\");\n-      end if;\n-\n-      VMS_Options (VMS_Options'First) := For_Linker_Opt;\n-\n-      for J in Inter'Range loop\n-         To_Lower (Inter (J).all);\n-      end loop;\n-\n-      --  \"gnatsym\" is necessary for building the option file\n-\n-      if Gnatsym_Path = null then\n-         Gnatsym_Path := Locate_Exec_On_Path (Gnatsym_Name);\n-\n-         if Gnatsym_Path = null then\n-            Fail (Gnatsym_Name & \" not found in path\");\n-         end if;\n-      end if;\n-\n-      --  For auto-initialization of a stand-alone library, we create\n-      --  a macro-assembly file and we invoke the macro-assembler.\n-\n-      if Auto_Init then\n-         declare\n-            Macro_File_Name : constant String := Lib_Filename & \"__init.asm\";\n-            Macro_File      : File_Descriptor;\n-            Init_Proc       : constant String := Init_Proc_Name (Lib_Filename);\n-            Popen_Result    : System.Address;\n-            Pclose_Result   : Integer;\n-            Len             : Natural;\n-            OK              : Boolean := True;\n-\n-            command  : constant String :=\n-                         Macro_Name & \" \" & Macro_File_Name & ASCII.NUL;\n-            --  The command to invoke the assembler on the generated auto-init\n-            --  assembly file.\n-\n-            mode : constant String := \"r\" & ASCII.NUL;\n-            --  The mode for the invocation of Popen\n-\n-         begin\n-            if Verbose_Mode then\n-               Write_Str (\"Creating auto-init assembly file \"\"\");\n-               Write_Str (Macro_File_Name);\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            --  Create and write the auto-init assembly file\n-\n-            declare\n-               use ASCII;\n-\n-               --  Output a dummy transfer address for debugging\n-               --  followed by the LIB$INITIALIZE section.\n-\n-               Lines : constant String :=\n-                 HT & \".text\" & LF &\n-                 HT & \".align 4\" & LF &\n-                 HT & \".globl __main\" & LF &\n-                 HT & \".ent __main\" & LF &\n-                 \"__main..en:\" & LF &\n-                 HT & \".base $27\" & LF &\n-                 HT & \".frame $29,0,$26,8\" & LF &\n-                 HT & \"ret $31,($26),1\" & LF &\n-                 HT & \".link\" & LF &\n-                 \"__main:\" & LF &\n-                 HT & \".pdesc __main..en,null\" & LF &\n-                 HT & \".end __main\" & LF & LF &\n-                 HT & \".section LIB$INITIALIZE,GBL,NOWRT\" & LF &\n-                 HT & \".long \" & Init_Proc & LF;\n-\n-            begin\n-               Macro_File := Create_File (Macro_File_Name, Text);\n-               OK := Macro_File /= Invalid_FD;\n-\n-               if OK then\n-                  Len := Write\n-                    (Macro_File, Lines (Lines'First)'Address,\n-                     Lines'Length);\n-                  OK := Len = Lines'Length;\n-               end if;\n-\n-               if OK then\n-                  Close (Macro_File, OK);\n-               end if;\n-\n-               if not OK then\n-                  Fail (\"creation of auto-init assembly file \"\"\"\n-                        & Macro_File_Name\n-                        & \"\"\" failed\");\n-               end if;\n-            end;\n-\n-            --  Invoke the macro-assembler\n-\n-            if Verbose_Mode then\n-               Write_Str (\"Assembling auto-init assembly file \"\"\");\n-               Write_Str (Macro_File_Name);\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            Popen_Result := popen (command (command'First)'Address,\n-                                   mode (mode'First)'Address);\n-\n-            if Popen_Result = Null_Address then\n-               Fail (\"assembly of auto-init assembly file \"\"\"\n-                     & Macro_File_Name\n-                     & \"\"\" failed\");\n-            end if;\n-\n-            --  Wait for the end of execution of the macro-assembler\n-\n-            Pclose_Result := pclose (Popen_Result);\n-\n-            if Pclose_Result < 0 then\n-               Fail (\"assembly of auto init assembly file \"\"\"\n-                     & Macro_File_Name\n-                     & \"\"\" failed\");\n-            end if;\n-\n-            --  Add the generated object file to the list of objects to be\n-            --  included in the library.\n-\n-            Additional_Objects :=\n-              new Argument_List'\n-                (1 => new String'(Lib_Filename & \"__init.obj\"));\n-         end;\n-      end if;\n-\n-      --  Allocate the argument list and put the symbol file name, the\n-      --  reference (if any) and the policy (if not autonomous).\n-\n-      Arguments := new Argument_List (1 .. Ofiles'Length + 8);\n-\n-      Last_Argument := 0;\n-\n-      --  Verbosity\n-\n-      if Verbose_Mode then\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(\"-v\");\n-      end if;\n-\n-      --  Version number (major ID)\n-\n-      if Lib_Version /= \"\" then\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(\"-V\");\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(Version);\n-      end if;\n-\n-      --  Symbol file\n-\n-      Last_Argument := Last_Argument + 1;\n-      Arguments (Last_Argument) := new String'(\"-s\");\n-      Last_Argument := Last_Argument + 1;\n-      Arguments (Last_Argument) := new String'(Opt_File_Name);\n-\n-      --  Reference Symbol File\n-\n-      if Symbol_Data.Reference /= No_Path then\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(\"-r\");\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) :=\n-           new String'(Get_Name_String (Symbol_Data.Reference));\n-      end if;\n-\n-      --  Policy\n-\n-      case Symbol_Data.Symbol_Policy is\n-         when Autonomous =>\n-            null;\n-\n-         when Compliant =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-c\");\n-\n-         when Controlled =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-C\");\n-\n-         when Restricted =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-R\");\n-\n-         when Direct =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-D\");\n-\n-      end case;\n-\n-      --  Add each relevant object file\n-\n-      for Index in Ofiles'Range loop\n-         if Is_Interface (Ofiles (Index).all) then\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(Ofiles (Index).all);\n-         end if;\n-      end loop;\n-\n-      --  Spawn gnatsym\n-\n-      Spawn (Program_Name => Gnatsym_Path.all,\n-             Args         => Arguments (1 .. Last_Argument),\n-             Success      => Success);\n-\n-      if not Success then\n-         Fail (\"unable to create symbol file for library \"\"\"\n-               & Lib_Filename\n-               & \"\"\"\");\n-      end if;\n-\n-      Free (Arguments);\n-\n-      --  Move all the -l switches from Opts to Opts2\n-\n-      declare\n-         Index : Natural := Opts'First;\n-         Opt   : String_Access;\n-\n-      begin\n-         while Index <= Last_Opt loop\n-            Opt := Opts (Index);\n-\n-            if Opt'Length > 2 and then\n-              Opt (Opt'First .. Opt'First + 1) = \"-l\"\n-            then\n-               if Index < Last_Opt then\n-                  Opts (Index .. Last_Opt - 1) :=\n-                    Opts (Index + 1 .. Last_Opt);\n-               end if;\n-\n-               Last_Opt := Last_Opt - 1;\n-\n-               Last_Opt2 := Last_Opt2 + 1;\n-               Opts2 (Last_Opt2) := Opt;\n-\n-            else\n-               Index := Index + 1;\n-            end if;\n-         end loop;\n-      end;\n-\n-      --  Invoke gcc to build the library\n-\n-      Utl.Gcc\n-        (Output_File => Lib_File,\n-         Objects     => Ofiles & Additional_Objects.all,\n-         Options     => VMS_Options,\n-         Options_2   => Shared_Libgcc_Switch &\n-                        Opts (Opts'First .. Last_Opt) &\n-                        Opts2 (Opts2'First .. Last_Opt2),\n-         Driver_Name => Driver_Name);\n-\n-      --  The auto-init object file need to be deleted, so that it will not\n-      --  be included in the library as a regular object file, otherwise\n-      --  it will be included twice when the library will be built next\n-      --  time, which may lead to errors.\n-\n-      if Auto_Init then\n-         declare\n-            Auto_Init_Object_File_Name : constant String :=\n-                                           Lib_Filename & \"__init.obj\";\n-            Disregard : Boolean;\n-\n-         begin\n-            if Verbose_Mode then\n-               Write_Str (\"deleting auto-init object file \"\"\");\n-               Write_Str (Auto_Init_Object_File_Name);\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            Delete_File (Auto_Init_Object_File_Name, Success => Disregard);\n-         end;\n-      end if;\n-   end Build_Dynamic_Library;\n-\n---  Package initialization\n-\n-begin\n-   Build_Dynamic_Library_Ptr    := Build_Dynamic_Library'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "c2958586097e8176b96e8578dc7459dbf91c6c73", "filename": "gcc/ada/mlib-tgt-specific-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 513, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-specific-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-specific-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-vms-ia64.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,513 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                         (Integrity VMS Version)                          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Integrity VMS version of the body\n-\n-with Ada.Characters.Handling; use Ada.Characters.Handling;\n-\n-with MLib.Fil;\n-with MLib.Utl;\n-\n-with MLib.Tgt.VMS_Common; use MLib.Tgt.VMS_Common;\n-\n-with Opt;      use Opt;\n-with Output;   use Output;\n-\n-with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n-\n-with System;           use System;\n-with System.Case_Util; use System.Case_Util;\n-with System.CRTL;      use System.CRTL;\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Non default subprogram, see comment in mlib-tgt.ads\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   --  Local variables\n-\n-   Empty_Argument_List : aliased Argument_List := (1 .. 0 => null);\n-   Additional_Objects  : Argument_List_Access := Empty_Argument_List'Access;\n-   --  Used to add the generated auto-init object files for auto-initializing\n-   --  stand-alone libraries.\n-\n-   Macro_Name : constant String := \"mcr gnu:[bin]gcc -c -x assembler\";\n-   --  The name of the command to invoke the macro-assembler\n-\n-   VMS_Options : Argument_List := (1 .. 1 => null);\n-\n-   Gnatsym_Name : constant String := \"gnatsym\";\n-\n-   Gnatsym_Path : String_Access;\n-\n-   Arguments     : Argument_List_Access := null;\n-   Last_Argument : Natural := 0;\n-\n-   Success : Boolean := False;\n-\n-   Shared_Libgcc : aliased String := \"-shared-libgcc\";\n-\n-   Shared_Libgcc_Switch : constant Argument_List :=\n-                            (1 => Shared_Libgcc'Access);\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-\n-      Lib_File : constant String :=\n-                   Lib_Dir & Directory_Separator & \"lib\" &\n-                   Fil.Ext_To (Lib_Filename, DLL_Ext);\n-\n-      Opts      : Argument_List := Options;\n-      Last_Opt  : Natural       := Opts'Last;\n-      Opts2     : Argument_List (Options'Range);\n-      Last_Opt2 : Natural       := Opts2'First - 1;\n-\n-      Inter : constant Argument_List := Interfaces;\n-\n-      function Is_Interface (Obj_File : String) return Boolean;\n-      --  For a Stand-Alone Library, returns True if Obj_File is the object\n-      --  file name of an interface of the SAL. For other libraries, always\n-      --  return True.\n-\n-      function Option_File_Name return String;\n-      --  Returns Symbol_File, if not empty. Otherwise, returns \"symvec.opt\"\n-\n-      function Version_String return String;\n-      --  Returns Lib_Version if not empty and if Symbol_Data.Symbol_Policy is\n-      --  not Autonomous, otherwise returns \"\". When Symbol_Data.Symbol_Policy\n-      --  is Autonomous, fails gnatmake if Lib_Version is not the image of a\n-      --  positive number.\n-\n-      ------------------\n-      -- Is_Interface --\n-      ------------------\n-\n-      function Is_Interface (Obj_File : String) return Boolean is\n-         ALI : constant String :=\n-                 Fil.Ext_To\n-                  (Filename => To_Lower (Base_Name (Obj_File)),\n-                   New_Ext  => \"ali\");\n-\n-      begin\n-         if Inter'Length = 0 then\n-            return True;\n-\n-         elsif ALI'Length > 2 and then\n-               ALI (ALI'First .. ALI'First + 2) = \"b__\"\n-         then\n-            return True;\n-\n-         else\n-            for J in Inter'Range loop\n-               if Inter (J).all = ALI then\n-                  return True;\n-               end if;\n-            end loop;\n-\n-            return False;\n-         end if;\n-      end Is_Interface;\n-\n-      ----------------------\n-      -- Option_File_Name --\n-      ----------------------\n-\n-      function Option_File_Name return String is\n-      begin\n-         if Symbol_Data.Symbol_File = No_Path then\n-            return \"symvec.opt\";\n-         else\n-            Get_Name_String (Symbol_Data.Symbol_File);\n-            To_Lower (Name_Buffer (1 .. Name_Len));\n-            return Name_Buffer (1 .. Name_Len);\n-         end if;\n-      end Option_File_Name;\n-\n-      --------------------\n-      -- Version_String --\n-      --------------------\n-\n-      function Version_String return String is\n-         Version : Integer := 0;\n-      begin\n-         if Lib_Version = \"\"\n-           or else Symbol_Data.Symbol_Policy /= Autonomous\n-         then\n-            return \"\";\n-\n-         else\n-            begin\n-               Version := Integer'Value (Lib_Version);\n-\n-               if Version <= 0 then\n-                  raise Constraint_Error;\n-               end if;\n-\n-               return Lib_Version;\n-\n-            exception\n-               when Constraint_Error =>\n-                  Fail (\"illegal version \"\"\"\n-                        & Lib_Version\n-                        & \"\"\" (on VMS version must be a positive number)\");\n-                  return \"\";\n-            end;\n-         end if;\n-      end Version_String;\n-\n-      ---------------------\n-      -- Local Variables --\n-      ---------------------\n-\n-      Opt_File_Name  : constant String := Option_File_Name;\n-      Version        : constant String := Version_String;\n-      For_Linker_Opt : String_Access;\n-\n-   --  Start of processing for Build_Dynamic_Library\n-\n-   begin\n-      --  Option file must end with \".opt\"\n-\n-      if Opt_File_Name'Length > 4\n-        and then\n-          Opt_File_Name (Opt_File_Name'Last - 3 .. Opt_File_Name'Last) = \".opt\"\n-      then\n-         For_Linker_Opt := new String'(\"--for-linker=\" & Opt_File_Name);\n-      else\n-         Fail (\"Options File \"\"\" & Opt_File_Name & \"\"\" must end with .opt\");\n-      end if;\n-\n-      VMS_Options (VMS_Options'First) := For_Linker_Opt;\n-\n-      for J in Inter'Range loop\n-         To_Lower (Inter (J).all);\n-      end loop;\n-\n-      --  \"gnatsym\" is necessary for building the option file\n-\n-      if Gnatsym_Path = null then\n-         Gnatsym_Path := Locate_Exec_On_Path (Gnatsym_Name);\n-\n-         if Gnatsym_Path = null then\n-            Fail (Gnatsym_Name & \" not found in path\");\n-         end if;\n-      end if;\n-\n-      --  For auto-initialization of a stand-alone library, we create\n-      --  a macro-assembly file and we invoke the macro-assembler.\n-\n-      if Auto_Init then\n-         declare\n-            Macro_File_Name : constant String := Lib_Filename & \"__init.asm\";\n-            Macro_File      : File_Descriptor;\n-            Init_Proc       : constant String := Init_Proc_Name (Lib_Filename);\n-            Popen_Result    : System.Address;\n-            Pclose_Result   : Integer;\n-            Len             : Natural;\n-            OK              : Boolean := True;\n-\n-            command : constant String :=\n-                        Macro_Name & \" \" & Macro_File_Name & ASCII.NUL;\n-            --  The command to invoke the assembler on the generated auto-init\n-            --  assembly file.\n-            --  Why odd lower case name ???\n-\n-            mode : constant String := \"r\" & ASCII.NUL;\n-            --  The mode for the invocation of Popen\n-            --  Why odd lower case name ???\n-\n-         begin\n-            if Verbose_Mode then\n-               Write_Str (\"Creating auto-init assembly file \"\"\");\n-               Write_Str (Macro_File_Name);\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            --  Create and write the auto-init assembly file\n-\n-            declare\n-               use ASCII;\n-\n-               --  Output a dummy transfer address for debugging\n-               --  followed by the LIB$INITIALIZE section.\n-\n-               Lines : constant String :=\n-                 HT & \".pred.safe_across_calls p1-p5,p16-p63\" & LF &\n-                 HT & \".text\" & LF &\n-                 HT & \".align 16\" & LF &\n-                 HT & \".global __main#\" & LF &\n-                 HT & \".proc __main#\" & LF &\n-                      \"__main:\" & LF &\n-                 HT & \".prologue\" & LF &\n-                 HT & \".body\" & LF &\n-                 HT & \".mib\" & LF &\n-                 HT & \"nop 0\" & LF &\n-                 HT & \"nop 0\" & LF &\n-                 HT & \"br.ret.sptk.many b0\" & LF &\n-                 HT & \".endp __main#\" & LF & LF &\n-                 HT & \".type \" & Init_Proc & \"#, @function\" & LF &\n-                 HT & \".global \" & Init_Proc & \"#\" & LF &\n-                 HT & \".global LIB$INITIALIZE#\" & LF &\n-                 HT & \".section LIB$INITIALIZE#,\"\"a\"\",@progbits\" & LF &\n-                 HT & \"data4 @fptr(\" & Init_Proc & \"#)\" & LF;\n-\n-            begin\n-               Macro_File := Create_File (Macro_File_Name, Text);\n-               OK := Macro_File /= Invalid_FD;\n-\n-               if OK then\n-                  Len := Write\n-                    (Macro_File, Lines (Lines'First)'Address,\n-                     Lines'Length);\n-                  OK := Len = Lines'Length;\n-               end if;\n-\n-               if OK then\n-                  Close (Macro_File, OK);\n-               end if;\n-\n-               if not OK then\n-                  Fail (\"creation of auto-init assembly file \"\"\"\n-                        & Macro_File_Name\n-                        & \"\"\" failed\");\n-               end if;\n-            end;\n-\n-            --  Invoke the macro-assembler\n-\n-            if Verbose_Mode then\n-               Write_Str (\"Assembling auto-init assembly file \"\"\");\n-               Write_Str (Macro_File_Name);\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            Popen_Result := popen (command (command'First)'Address,\n-                                   mode (mode'First)'Address);\n-\n-            if Popen_Result = Null_Address then\n-               Fail (\"assembly of auto-init assembly file \"\"\"\n-                     & Macro_File_Name\n-                     & \"\"\" failed\");\n-            end if;\n-\n-            --  Wait for the end of execution of the macro-assembler\n-\n-            Pclose_Result := pclose (Popen_Result);\n-\n-            if Pclose_Result < 0 then\n-               Fail (\"assembly of auto init assembly file \"\"\"\n-                     & Macro_File_Name\n-                     & \"\"\" failed\");\n-            end if;\n-\n-            --  Add the generated object file to the list of objects to be\n-            --  included in the library.\n-\n-            Additional_Objects :=\n-              new Argument_List'\n-                (1 => new String'(Lib_Filename & \"__init.obj\"));\n-         end;\n-      end if;\n-\n-      --  Allocate the argument list and put the symbol file name, the\n-      --  reference (if any) and the policy (if not autonomous).\n-\n-      Arguments := new Argument_List (1 .. Ofiles'Length + 8);\n-\n-      Last_Argument := 0;\n-\n-      --  Verbosity\n-\n-      if Verbose_Mode then\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(\"-v\");\n-      end if;\n-\n-      --  Version number (major ID)\n-\n-      if Lib_Version /= \"\" then\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(\"-V\");\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(Version);\n-      end if;\n-\n-      --  Symbol file\n-\n-      Last_Argument := Last_Argument + 1;\n-      Arguments (Last_Argument) := new String'(\"-s\");\n-      Last_Argument := Last_Argument + 1;\n-      Arguments (Last_Argument) := new String'(Opt_File_Name);\n-\n-      --  Reference Symbol File\n-\n-      if Symbol_Data.Reference /= No_Path then\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) := new String'(\"-r\");\n-         Last_Argument := Last_Argument + 1;\n-         Arguments (Last_Argument) :=\n-           new String'(Get_Name_String (Symbol_Data.Reference));\n-      end if;\n-\n-      --  Policy\n-\n-      case Symbol_Data.Symbol_Policy is\n-         when Autonomous =>\n-            null;\n-\n-         when Compliant =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-c\");\n-\n-         when Controlled =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-C\");\n-\n-         when Restricted =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-R\");\n-\n-         when Direct =>\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(\"-D\");\n-      end case;\n-\n-      --  Add each relevant object file\n-\n-      for Index in Ofiles'Range loop\n-         if Is_Interface (Ofiles (Index).all) then\n-            Last_Argument := Last_Argument + 1;\n-            Arguments (Last_Argument) := new String'(Ofiles (Index).all);\n-         end if;\n-      end loop;\n-\n-      --  Spawn gnatsym\n-\n-      Spawn (Program_Name => Gnatsym_Path.all,\n-             Args         => Arguments (1 .. Last_Argument),\n-             Success      => Success);\n-\n-      if not Success then\n-         Fail (\"unable to create symbol file for library \"\"\"\n-               & Lib_Filename\n-               & \"\"\"\");\n-      end if;\n-\n-      Free (Arguments);\n-\n-      --  Move all the -l switches from Opts to Opts2\n-\n-      declare\n-         Index : Natural := Opts'First;\n-         Opt   : String_Access;\n-\n-      begin\n-         while Index <= Last_Opt loop\n-            Opt := Opts (Index);\n-\n-            if Opt'Length > 2 and then\n-              Opt (Opt'First .. Opt'First + 1) = \"-l\"\n-            then\n-               if Index < Last_Opt then\n-                  Opts (Index .. Last_Opt - 1) :=\n-                    Opts (Index + 1 .. Last_Opt);\n-               end if;\n-\n-               Last_Opt := Last_Opt - 1;\n-\n-               Last_Opt2 := Last_Opt2 + 1;\n-               Opts2 (Last_Opt2) := Opt;\n-\n-            else\n-               Index := Index + 1;\n-            end if;\n-         end loop;\n-      end;\n-\n-      --  Invoke gcc to build the library\n-\n-      Utl.Gcc\n-        (Output_File => Lib_File,\n-         Objects     => Ofiles & Additional_Objects.all,\n-         Options     => VMS_Options,\n-         Options_2   => Shared_Libgcc_Switch &\n-                        Opts (Opts'First .. Last_Opt) &\n-                        Opts2 (Opts2'First .. Last_Opt2),\n-         Driver_Name => Driver_Name);\n-\n-      --  The auto-init object file need to be deleted, so that it will not\n-      --  be included in the library as a regular object file, otherwise\n-      --  it will be included twice when the library will be built next\n-      --  time, which may lead to errors.\n-\n-      if Auto_Init then\n-         declare\n-            Auto_Init_Object_File_Name : constant String :=\n-                                           Lib_Filename & \"__init.obj\";\n-\n-            Disregard : Boolean;\n-            pragma Warnings (Off, Disregard);\n-\n-         begin\n-            if Verbose_Mode then\n-               Write_Str (\"deleting auto-init object file \"\"\");\n-               Write_Str (Auto_Init_Object_File_Name);\n-               Write_Line (\"\"\"\");\n-            end if;\n-\n-            Delete_File (Auto_Init_Object_File_Name, Success => Disregard);\n-         end;\n-      end if;\n-   end Build_Dynamic_Library;\n-\n---  Package initialization\n-\n-begin\n-   Build_Dynamic_Library_Ptr    := Build_Dynamic_Library'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "53db3a887d41f01253e273de6776a66f30399ac9", "filename": "gcc/ada/mlib-tgt-vms_common.adb", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-vms_common.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-vms_common.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vms_common.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,174 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                  M L I B . T G T . V M S _ C O M M O N                   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the part of MLib.Tgt.Specific common to both VMS versions\n-\n-with System.Case_Util; use System.Case_Util;\n-\n-package body MLib.Tgt.VMS_Common is\n-\n-   --  Non default subprograms. See comments in mlib-tgt.ads\n-\n-   function Archive_Ext return String;\n-\n-   function Default_Symbol_File_Name return String;\n-\n-   function DLL_Ext return String;\n-\n-   function Is_Object_Ext (Ext : String) return Boolean;\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean;\n-\n-   function Libgnat return String;\n-\n-   function Object_Ext return String;\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-\n-   function PIC_Option return String;\n-\n-   -----------------\n-   -- Archive_Ext --\n-   -----------------\n-\n-   function Archive_Ext return String is\n-   begin\n-      return \"olb\";\n-   end Archive_Ext;\n-\n-   ------------------------------\n-   -- Default_Symbol_File_Name --\n-   ------------------------------\n-\n-   function Default_Symbol_File_Name return String is\n-   begin\n-      return \"symvec.opt\";\n-   end Default_Symbol_File_Name;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"exe\";\n-   end DLL_Ext;\n-\n-   --------------------\n-   -- Init_Proc_Name --\n-   --------------------\n-\n-   function Init_Proc_Name (Library_Name : String) return String is\n-      Result : String := Library_Name & \"INIT\";\n-   begin\n-      To_Upper (Result);\n-\n-      if Result = \"ADAINIT\" then\n-         return \"ADA_INIT\";\n-\n-      else\n-         return Result;\n-      end if;\n-   end Init_Proc_Name;\n-\n-   -------------------\n-   -- Is_Object_Ext --\n-   -------------------\n-\n-   function Is_Object_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".obj\";\n-   end Is_Object_Ext;\n-\n-   --------------------\n-   -- Is_Archive_Ext --\n-   --------------------\n-\n-   function Is_Archive_Ext (Ext : String) return Boolean is\n-   begin\n-      return Ext = \".olb\" or else Ext = \".exe\";\n-   end Is_Archive_Ext;\n-\n-   -------------\n-   -- Libgnat --\n-   -------------\n-\n-   function Libgnat return String is\n-      Libgnat_A : constant String := \"libgnat.a\";\n-      Libgnat_Olb : constant String := \"libgnat.olb\";\n-\n-   begin\n-      Name_Len := Libgnat_A'Length;\n-      Name_Buffer (1 .. Name_Len) := Libgnat_A;\n-\n-      if Osint.Find_File (Name_Enter, Osint.Library) /= No_File then\n-         return Libgnat_A;\n-      else\n-         return Libgnat_Olb;\n-      end if;\n-   end Libgnat;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return False;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ----------------\n-   -- Object_Ext --\n-   ----------------\n-\n-   function Object_Ext return String is\n-   begin\n-      return \"obj\";\n-   end Object_Ext;\n-\n-   ----------------\n-   -- PIC_Option --\n-   ----------------\n-\n-   function PIC_Option return String is\n-   begin\n-      return \"\";\n-   end PIC_Option;\n-\n---  Package initialization\n-\n-begin\n-   Archive_Ext_Ptr              := Archive_Ext'Access;\n-   Default_Symbol_File_Name_Ptr := Default_Symbol_File_Name'Access;\n-   DLL_Ext_Ptr                  := DLL_Ext'Access;\n-   Is_Object_Ext_Ptr            := Is_Object_Ext'Access;\n-   Is_Archive_Ext_Ptr           := Is_Archive_Ext'Access;\n-   Libgnat_Ptr                  := Libgnat'Access;\n-   Object_Ext_Ptr               := Object_Ext'Access;\n-   PIC_Option_Ptr               := PIC_Option'Access;\n-   Library_Major_Minor_Id_Supported_Ptr :=\n-                                   Library_Major_Minor_Id_Supported'Access;\n-\n-end MLib.Tgt.VMS_Common;"}, {"sha": "7a4fbb882782d785054a0d146e7c21519a24674b", "filename": "gcc/ada/mlib-tgt-vms_common.ads", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-vms_common.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fmlib-tgt-vms_common.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-vms_common.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,35 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                  M L I B . T G T . V M S _ C O M M O N                   --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---        Copyright (C) 2007-2011, Free Software Foundation, Inc.           --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the part of MLib.Tgt.Specific common to both VMS versions\n-\n-package MLib.Tgt.VMS_Common is\n-   pragma Elaborate_Body;\n-\n-   function Init_Proc_Name (Library_Name : String) return String;\n-   --  Returns, in upper case, Library_Name & \"INIT\", except when Library_Name\n-   --  is \"ada\" (case insensitive), returns \"ADA_INIT\".\n-\n-end MLib.Tgt.VMS_Common;"}, {"sha": "1ca589ba50ce7f0863bf9e52cc653c97fa9c82fb", "filename": "gcc/ada/namet.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fnamet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fnamet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.h?ref=f9648959b41d5c443702c809676056f1f39c56de", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *            Copyright (C) 1992-2012, Free Software Foundation, Inc.       *\n+ *            Copyright (C) 1992-2014, Free Software Foundation, Inc.       *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -109,9 +109,6 @@ extern char *Spec_Context_List, *Body_Context_List;\n #define Body_Filename exp_dbug__body_filename\n extern char *Spec_Filename, *Body_Filename;\n \n-#define Is_Non_Ada_Error exp_ch11__is_non_ada_error\n-extern Boolean Is_Non_Ada_Error (Entity_Id);\n-\n /* Here are some functions in sinput.adb we call from trans.c.  */\n \n typedef Nat Source_File_Index;"}, {"sha": "1f09a71be1f333d3b9e977e880185333116af180", "filename": "gcc/ada/s-asthan-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 603, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-asthan-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-asthan-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan-vms-alpha.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,603 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                  S Y S T E M . A S T _ H A N D L I N G                   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS/Alpha version\n-\n-with System; use System;\n-\n-with System.IO;\n-\n-with System.Machine_Code;\n-with System.Parameters;\n-with System.Storage_Elements;\n-\n-with System.Tasking;\n-with System.Tasking.Rendezvous;\n-with System.Tasking.Initialization;\n-with System.Tasking.Utilities;\n-\n-with System.Task_Primitives;\n-with System.Task_Primitives.Operations;\n-with System.Task_Primitives.Operations.DEC;\n-\n-with Ada.Finalization;\n-with Ada.Task_Attributes;\n-\n-with Ada.Exceptions; use Ada.Exceptions;\n-\n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n-\n-package body System.AST_Handling is\n-\n-   package ATID renames Ada.Task_Identification;\n-\n-   package SP   renames System.Parameters;\n-   package ST   renames System.Tasking;\n-   package STR  renames System.Tasking.Rendezvous;\n-   package STI  renames System.Tasking.Initialization;\n-   package STU  renames System.Tasking.Utilities;\n-\n-   package SSE  renames System.Storage_Elements;\n-   package STPO renames System.Task_Primitives.Operations;\n-   package STPOD renames System.Task_Primitives.Operations.DEC;\n-\n-   AST_Lock : aliased System.Task_Primitives.RTS_Lock;\n-   --  This is a global lock; it is used to execute in mutual exclusion\n-   --  from all other AST tasks.  It is only used by Lock_AST and\n-   --  Unlock_AST.\n-\n-   procedure Lock_AST (Self_ID : ST.Task_Id);\n-   --  Locks out other AST tasks. Preceding a section of code by Lock_AST and\n-   --  following it by Unlock_AST creates a critical region.\n-\n-   procedure Unlock_AST (Self_ID : ST.Task_Id);\n-   --  Releases lock previously set by call to Lock_AST.\n-   --  All nested locks must be released before other tasks competing for the\n-   --  tasking lock are released.\n-\n-   --------------\n-   -- Lock_AST --\n-   --------------\n-\n-   procedure Lock_AST (Self_ID : ST.Task_Id) is\n-   begin\n-      STI.Defer_Abort_Nestable (Self_ID);\n-      STPO.Write_Lock (AST_Lock'Access, Global_Lock => True);\n-   end Lock_AST;\n-\n-   ----------------\n-   -- Unlock_AST --\n-   ----------------\n-\n-   procedure Unlock_AST (Self_ID : ST.Task_Id) is\n-   begin\n-      STPO.Unlock (AST_Lock'Access, Global_Lock => True);\n-      STI.Undefer_Abort_Nestable (Self_ID);\n-   end Unlock_AST;\n-\n-   ---------------------------------\n-   -- AST_Handler Data Structures --\n-   ---------------------------------\n-\n-   --  As noted in the private part of the spec of System.Aux_DEC, the\n-   --  AST_Handler type is simply a pointer to a procedure that takes\n-   --  a single 64bit parameter. The following is a local copy\n-   --  of that definition.\n-\n-   --  We need our own copy because we need to get our hands on this\n-   --  and we cannot see the private part of System.Aux_DEC. We don't\n-   --  want to be a child of Aux_Dec because of complications resulting\n-   --  from the use of pragma Extend_System. We will use unchecked\n-   --  conversions between the two versions of the declarations.\n-\n-   type AST_Handler is access procedure (Param : Long_Integer);\n-\n-   --  However, this declaration is somewhat misleading, since the values\n-   --  referenced by AST_Handler values (all produced in this package by\n-   --  calls to Create_AST_Handler) are highly stylized.\n-\n-   --  The first point is that in VMS/Alpha, procedure pointers do not in\n-   --  fact point to code, but rather to a 48-byte procedure descriptor.\n-   --  So a value of type AST_Handler is in fact a pointer to one of these\n-   --  48-byte descriptors.\n-\n-   type Descriptor_Type is new SSE.Storage_Array (1 .. 48);\n-   for  Descriptor_Type'Alignment use Standard'Maximum_Alignment;\n-\n-   type Descriptor_Ref is access all Descriptor_Type;\n-\n-   --  Normally, there is only one such descriptor for a given procedure, but\n-   --  it works fine to make a copy of the single allocated descriptor, and\n-   --  use the copy itself, and we take advantage of this in the design here.\n-   --  The idea is that AST_Handler values will all point to a record with the\n-   --  following structure:\n-\n-   --  Note: When we say it works fine, there is one delicate point, which\n-   --  is that the code for the AST procedure itself requires the original\n-   --  descriptor address.  We handle this by saving the original descriptor\n-   --  address in this structure and restoring in Process_AST.\n-\n-   type AST_Handler_Data is record\n-      Descriptor              : Descriptor_Type;\n-      Original_Descriptor_Ref : Descriptor_Ref;\n-      Taskid                  : ATID.Task_Id;\n-      Entryno                 : Natural;\n-   end record;\n-\n-   type AST_Handler_Data_Ref is access all AST_Handler_Data;\n-\n-   function To_AST_Handler is new Ada.Unchecked_Conversion\n-     (AST_Handler_Data_Ref, System.Aux_DEC.AST_Handler);\n-\n-   --  Each time Create_AST_Handler is called, a new value of this record\n-   --  type is created, containing a copy of the procedure descriptor for\n-   --  the routine used to handle all AST's (Process_AST), and the Task_Id\n-   --  and entry number parameters identifying the task entry involved.\n-\n-   --  The AST_Handler value returned is a pointer to this record. Since\n-   --  the record starts with the procedure descriptor, it can be used\n-   --  by the system in the normal way to call the procedure. But now\n-   --  when the procedure gets control, it can determine the address of\n-   --  the procedure descriptor used to call it (since the ABI specifies\n-   --  that this is left sitting in register r27 on entry), and then use\n-   --  that address to retrieve the Task_Id and entry number so that it\n-   --  knows on which entry to queue the AST request.\n-\n-   --  The next issue is where are these records placed. Since we intend\n-   --  to pass pointers to these records to asynchronous system service\n-   --  routines, they have to be on the heap, which means we have to worry\n-   --  about when to allocate them and deallocate them.\n-\n-   --  We solve this problem by introducing a task attribute that points to\n-   --  a vector, indexed by the entry number, of AST_Handler_Data records\n-   --  for a given task. The pointer itself is a controlled object allowing\n-   --  us to write a finalization routine that frees the referenced vector.\n-\n-   --  An entry in this vector is either initialized (Entryno non-zero) and\n-   --  can be used for any subsequent reference to the same entry, or it is\n-   --  unused, marked by the Entryno value being zero.\n-\n-   type AST_Handler_Vector is array (Natural range <>) of AST_Handler_Data;\n-   type AST_Handler_Vector_Ref is access all AST_Handler_Vector;\n-\n-   type AST_Vector_Ptr is new Ada.Finalization.Controlled with record\n-      Vector : AST_Handler_Vector_Ref;\n-   end record;\n-\n-   procedure Finalize (Obj : in out AST_Vector_Ptr);\n-   --  Override Finalize so that the AST Vector gets freed.\n-\n-   procedure Finalize (Obj : in out AST_Vector_Ptr) is\n-      procedure Free is new\n-       Ada.Unchecked_Deallocation (AST_Handler_Vector, AST_Handler_Vector_Ref);\n-   begin\n-      if Obj.Vector /= null then\n-         Free (Obj.Vector);\n-      end if;\n-   end Finalize;\n-\n-   AST_Vector_Init : AST_Vector_Ptr;\n-   --  Initial value, treated as constant, Vector will be null\n-\n-   package AST_Attribute is new Ada.Task_Attributes\n-     (Attribute     => AST_Vector_Ptr,\n-      Initial_Value => AST_Vector_Init);\n-\n-   use AST_Attribute;\n-\n-   -----------------------\n-   -- AST Service Queue --\n-   -----------------------\n-\n-   --  The following global data structures are used to queue pending\n-   --  AST requests. When an AST is signalled, the AST service routine\n-   --  Process_AST is called, and it makes an entry in this structure.\n-\n-   type AST_Instance is record\n-      Taskid  : ATID.Task_Id;\n-      Entryno : Natural;\n-      Param   : Long_Integer;\n-   end record;\n-   --  The Taskid and Entryno indicate the entry on which this AST is to\n-   --  be queued, and Param is the parameter provided from the AST itself.\n-\n-   AST_Service_Queue_Size  : constant := 256;\n-   AST_Service_Queue_Limit : constant := 250;\n-   type AST_Service_Queue_Index is mod AST_Service_Queue_Size;\n-   --  Index used to refer to entries in the circular buffer which holds\n-   --  active AST_Instance values. The upper bound reflects the maximum\n-   --  number of AST instances that can be stored in the buffer. Since\n-   --  these entries are immediately serviced by the high priority server\n-   --  task that does the actual entry queuing, it is very unusual to have\n-   --  any significant number of entries simultaneously queued.\n-\n-   AST_Service_Queue : array (AST_Service_Queue_Index) of AST_Instance;\n-   pragma Volatile_Components (AST_Service_Queue);\n-   --  The circular buffer used to store active AST requests\n-\n-   AST_Service_Queue_Put : AST_Service_Queue_Index := 0;\n-   AST_Service_Queue_Get : AST_Service_Queue_Index := 0;\n-   pragma Atomic (AST_Service_Queue_Put);\n-   pragma Atomic (AST_Service_Queue_Get);\n-   --  These two variables point to the next slots in the AST_Service_Queue\n-   --  to be used for putting a new entry in and taking an entry out. This\n-   --  is a circular buffer, so these pointers wrap around. If the two values\n-   --  are equal the buffer is currently empty. The pointers are atomic to\n-   --  ensure proper synchronization between the single producer (namely the\n-   --  Process_AST procedure), and the single consumer (the AST_Service_Task).\n-\n-   --------------------------------\n-   -- AST Server Task Structures --\n-   --------------------------------\n-\n-   --  The basic approach is that when an AST comes in, a call is made to\n-   --  the Process_AST procedure. It queues the request in the service queue\n-   --  and then wakes up an AST server task to perform the actual call to the\n-   --  required entry. We use this intermediate server task, since the AST\n-   --  procedure itself cannot wait to return, and we need some caller for\n-   --  the rendezvous so that we can use the normal rendezvous mechanism.\n-\n-   --  It would work to have only one AST server task, but then we would lose\n-   --  all overlap in AST processing, and furthermore, we could get priority\n-   --  inversion effects resulting in starvation of AST requests.\n-\n-   --  We therefore maintain a small pool of AST server tasks. We adjust\n-   --  the size of the pool dynamically to reflect traffic, so that we have\n-   --  a sufficient number of server tasks to avoid starvation.\n-\n-   Max_AST_Servers : constant Natural := 16;\n-   --  Maximum number of AST server tasks that can be allocated\n-\n-   Num_AST_Servers : Natural := 0;\n-   --  Number of AST server tasks currently active\n-\n-   Num_Waiting_AST_Servers : Natural := 0;\n-   --  This is the number of AST server tasks that are either waiting for\n-   --  work, or just about to go to sleep and wait for work.\n-\n-   Is_Waiting : array (1 .. Max_AST_Servers) of Boolean := (others => False);\n-   --  An array of flags showing which AST server tasks are currently waiting\n-\n-   AST_Task_Ids : array (1 .. Max_AST_Servers) of ST.Task_Id;\n-   --  Task Id's of allocated AST server tasks\n-\n-   task type AST_Server_Task (Num : Natural) is\n-      pragma Priority (Priority'Last);\n-   end AST_Server_Task;\n-   --  Declaration for AST server task. This task has no entries, it is\n-   --  controlled by sleep and wakeup calls at the task primitives level.\n-\n-   type AST_Server_Task_Ptr is access all AST_Server_Task;\n-   --  Type used to allocate server tasks\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Allocate_New_AST_Server;\n-   --  Allocate an additional AST server task\n-\n-   procedure Process_AST (Param : Long_Integer);\n-   --  This is the central routine for processing all AST's, it is referenced\n-   --  as the code address of all created AST_Handler values. See detailed\n-   --  description in body to understand how it works to have a single such\n-   --  procedure for all AST's even though it does not get any indication of\n-   --  the entry involved passed as an explicit parameter. The single explicit\n-   --  parameter Param is the parameter passed by the system with the AST.\n-\n-   -----------------------------\n-   -- Allocate_New_AST_Server --\n-   -----------------------------\n-\n-   procedure Allocate_New_AST_Server is\n-      Dummy : AST_Server_Task_Ptr;\n-\n-   begin\n-      if Num_AST_Servers = Max_AST_Servers then\n-         return;\n-\n-      else\n-         --  Note: it is safe to increment Num_AST_Servers immediately, since\n-         --  no one will try to activate this task until it indicates that it\n-         --  is sleeping by setting its entry in Is_Waiting to True.\n-\n-         Num_AST_Servers := Num_AST_Servers + 1;\n-         Dummy := new AST_Server_Task (Num_AST_Servers);\n-      end if;\n-   end Allocate_New_AST_Server;\n-\n-   ---------------------\n-   -- AST_Server_Task --\n-   ---------------------\n-\n-   task body AST_Server_Task is\n-      Taskid  : ATID.Task_Id;\n-      Entryno : Natural;\n-      Param   : aliased Long_Integer;\n-      Self_Id : constant ST.Task_Id := ST.Self;\n-\n-      pragma Volatile (Param);\n-\n-      --  By making this task independent of master, when the environment\n-      --  task is finalizing, the AST_Server_Task will be notified that it\n-      --  should terminate.\n-\n-      Ignore : constant Boolean := STU.Make_Independent;\n-      pragma Unreferenced (Ignore);\n-\n-   begin\n-      --  Record our task Id for access by Process_AST\n-\n-      AST_Task_Ids (Num) := Self_Id;\n-\n-      --  Note: this entire task operates with the main task lock set, except\n-      --  when it is sleeping waiting for work, or busy doing a rendezvous\n-      --  with an AST server. This lock protects the data structures that\n-      --  are shared by multiple instances of the server task.\n-\n-      Lock_AST (Self_Id);\n-\n-      --  This is the main infinite loop of the task. We go to sleep and\n-      --  wait to be woken up by Process_AST when there is some work to do.\n-\n-      loop\n-         Num_Waiting_AST_Servers := Num_Waiting_AST_Servers + 1;\n-\n-         Unlock_AST (Self_Id);\n-\n-         STI.Defer_Abort (Self_Id);\n-\n-         if SP.Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n-         STPO.Write_Lock (Self_Id);\n-\n-         Is_Waiting (Num) := True;\n-\n-         Self_Id.Common.State := ST.AST_Server_Sleep;\n-         STPO.Sleep (Self_Id, ST.AST_Server_Sleep);\n-         Self_Id.Common.State := ST.Runnable;\n-\n-         STPO.Unlock (Self_Id);\n-\n-         if SP.Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n-         --  If the process is finalizing, Undefer_Abort will simply end\n-         --  this task.\n-\n-         STI.Undefer_Abort (Self_Id);\n-\n-         --  We are awake, there is something to do\n-\n-         Lock_AST (Self_Id);\n-         Num_Waiting_AST_Servers := Num_Waiting_AST_Servers - 1;\n-\n-         --  Loop here to service outstanding requests. We are always\n-         --  locked on entry to this loop.\n-\n-         while AST_Service_Queue_Get /= AST_Service_Queue_Put loop\n-            Taskid  := AST_Service_Queue (AST_Service_Queue_Get).Taskid;\n-            Entryno := AST_Service_Queue (AST_Service_Queue_Get).Entryno;\n-            Param   := AST_Service_Queue (AST_Service_Queue_Get).Param;\n-\n-            AST_Service_Queue_Get := AST_Service_Queue_Get + 1;\n-\n-            --  This is a manual expansion of the normal call simple code\n-\n-            declare\n-               type AA is access all Long_Integer;\n-               P : AA := Param'Unrestricted_Access;\n-\n-               function To_ST_Task_Id is new Ada.Unchecked_Conversion\n-                 (ATID.Task_Id, ST.Task_Id);\n-\n-            begin\n-               Unlock_AST (Self_Id);\n-               STR.Call_Simple\n-                 (Acceptor           => To_ST_Task_Id (Taskid),\n-                  E                  => ST.Task_Entry_Index (Entryno),\n-                  Uninterpreted_Data => P'Address);\n-\n-            exception\n-               when E : others =>\n-                  System.IO.Put_Line (\"%Debugging event\");\n-                  System.IO.Put_Line (Exception_Name (E) &\n-                    \" raised when trying to deliver an AST.\");\n-\n-                  if Exception_Message (E)'Length /= 0 then\n-                     System.IO.Put_Line (Exception_Message (E));\n-                  end if;\n-\n-                  System.IO.Put_Line (\"Task type is \" & \"Receiver_Type\");\n-                  System.IO.Put_Line (\"Task id is \" & ATID.Image (Taskid));\n-            end;\n-\n-            Lock_AST (Self_Id);\n-         end loop;\n-      end loop;\n-   end AST_Server_Task;\n-\n-   ------------------------\n-   -- Create_AST_Handler --\n-   ------------------------\n-\n-   function Create_AST_Handler\n-     (Taskid  : ATID.Task_Id;\n-      Entryno : Natural) return System.Aux_DEC.AST_Handler\n-   is\n-      Attr_Ref : Attribute_Handle;\n-\n-      Process_AST_Ptr : constant AST_Handler := Process_AST'Access;\n-      --  Reference to standard procedure descriptor for Process_AST\n-\n-      pragma Warnings (Off, \"*alignment*\");\n-      --  Suppress harmless warnings about alignment.\n-      --  Should explain why this warning is harmless ???\n-\n-      function To_Descriptor_Ref is new Ada.Unchecked_Conversion\n-        (AST_Handler, Descriptor_Ref);\n-\n-      Original_Descriptor_Ref : constant Descriptor_Ref :=\n-                                  To_Descriptor_Ref (Process_AST_Ptr);\n-\n-      pragma Warnings (On, \"*alignment*\");\n-\n-   begin\n-      if ATID.Is_Terminated (Taskid) then\n-         raise Program_Error;\n-      end if;\n-\n-      Attr_Ref := Reference (Taskid);\n-\n-      --  Allocate another server if supply is getting low\n-\n-      if Num_Waiting_AST_Servers < 2 then\n-         Allocate_New_AST_Server;\n-      end if;\n-\n-      --  No point in creating more if we have zillions waiting to\n-      --  be serviced.\n-\n-      while AST_Service_Queue_Put - AST_Service_Queue_Get\n-         > AST_Service_Queue_Limit\n-      loop\n-         delay 0.01;\n-      end loop;\n-\n-      --  If no AST vector allocated, or the one we have is too short, then\n-      --  allocate one of right size and initialize all entries except the\n-      --  one we will use to unused. Note that the assignment automatically\n-      --  frees the old allocated table if there is one.\n-\n-      if Attr_Ref.Vector = null\n-        or else Attr_Ref.Vector'Length < Entryno\n-      then\n-         Attr_Ref.Vector := new AST_Handler_Vector (1 .. Entryno);\n-\n-         for E in 1 .. Entryno loop\n-            Attr_Ref.Vector (E).Descriptor :=\n-              Original_Descriptor_Ref.all;\n-            Attr_Ref.Vector (E).Original_Descriptor_Ref :=\n-              Original_Descriptor_Ref;\n-            Attr_Ref.Vector (E).Taskid  := Taskid;\n-            Attr_Ref.Vector (E).Entryno := E;\n-         end loop;\n-      end if;\n-\n-      return To_AST_Handler (Attr_Ref.Vector (Entryno)'Unrestricted_Access);\n-   end Create_AST_Handler;\n-\n-   ----------------------------\n-   -- Expand_AST_Packet_Pool --\n-   ----------------------------\n-\n-   procedure Expand_AST_Packet_Pool\n-     (Requested_Packets : Natural;\n-      Actual_Number     : out Natural;\n-      Total_Number      : out Natural)\n-   is\n-      pragma Unreferenced (Requested_Packets);\n-   begin\n-      --  The AST implementation of GNAT does not permit dynamic expansion\n-      --  of the pool, so we simply add no entries and return the total. If\n-      --  it is necessary to expand the allocation, then this package body\n-      --  must be recompiled with a larger value for AST_Service_Queue_Size.\n-\n-      Actual_Number := 0;\n-      Total_Number := AST_Service_Queue_Size;\n-   end Expand_AST_Packet_Pool;\n-\n-   -----------------\n-   -- Process_AST --\n-   -----------------\n-\n-   procedure Process_AST (Param : Long_Integer) is\n-\n-      Handler_Data_Ptr : AST_Handler_Data_Ref;\n-      --  This variable is set to the address of the descriptor through\n-      --  which Process_AST is called. Since the descriptor is part of\n-      --  an AST_Handler value, this is also the address of this value,\n-      --  from which we can obtain the task and entry number information.\n-\n-      function To_Address is new Ada.Unchecked_Conversion\n-        (ST.Task_Id, System.Task_Primitives.Task_Address);\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (Template => \"addq $27,0,%0\",\n-         Outputs  => AST_Handler_Data_Ref'Asm_Output (\"=r\", Handler_Data_Ptr),\n-         Volatile => True);\n-\n-      System.Machine_Code.Asm\n-        (Template => \"ldq $27,%0\",\n-         Inputs  => Descriptor_Ref'Asm_Input\n-           (\"m\", Handler_Data_Ptr.Original_Descriptor_Ref),\n-         Volatile => True);\n-\n-      AST_Service_Queue (AST_Service_Queue_Put) := AST_Instance'\n-        (Taskid  => Handler_Data_Ptr.Taskid,\n-         Entryno => Handler_Data_Ptr.Entryno,\n-         Param   => Param);\n-\n-      --  OpenVMS Programming Concepts manual, chapter 8.2.3:\n-      --  \"Implicit synchronization can be achieved for data that is shared\n-      --   for write by using only AST routines to write the data, since only\n-      --   one AST can be running at any one time.\"\n-\n-      --  This subprogram runs at AST level so is guaranteed to be\n-      --  called sequentially at a given access level.\n-\n-      AST_Service_Queue_Put := AST_Service_Queue_Put + 1;\n-\n-      --  Need to wake up processing task. If there is no waiting server\n-      --  then we have temporarily run out, but things should still be\n-      --  OK, since one of the active ones will eventually pick up the\n-      --  service request queued in the AST_Service_Queue.\n-\n-      for J in 1 .. Num_AST_Servers loop\n-         if Is_Waiting (J) then\n-            Is_Waiting (J) := False;\n-\n-            --  Sleeps are handled by ASTs on VMS, so don't call Wakeup\n-\n-            STPOD.Interrupt_AST_Handler (To_Address (AST_Task_Ids (J)));\n-            exit;\n-         end if;\n-      end loop;\n-   end Process_AST;\n-\n-begin\n-   STPO.Initialize_Lock (AST_Lock'Access, STPO.Global_Task_Level);\n-end System.AST_Handling;"}, {"sha": "0fd29b125e96dbe4c20ce60c1d45a933d08af972", "filename": "gcc/ada/s-asthan-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 608, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-asthan-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-asthan-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-asthan-vms-ia64.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,608 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                  S Y S T E M . A S T _ H A N D L I N G                   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---         Copyright (C) 1996-2014, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS/IA64 version\n-\n-with System; use System;\n-\n-with System.IO;\n-\n-with System.Machine_Code;\n-with System.Parameters;\n-\n-with System.Tasking;\n-with System.Tasking.Rendezvous;\n-with System.Tasking.Initialization;\n-with System.Tasking.Utilities;\n-\n-with System.Task_Primitives;\n-with System.Task_Primitives.Operations;\n-with System.Task_Primitives.Operations.DEC;\n-\n-with Ada.Finalization;\n-with Ada.Task_Attributes;\n-\n-with Ada.Exceptions; use Ada.Exceptions;\n-\n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n-\n-package body System.AST_Handling is\n-\n-   package ATID renames Ada.Task_Identification;\n-\n-   package SP   renames System.Parameters;\n-   package ST   renames System.Tasking;\n-   package STR  renames System.Tasking.Rendezvous;\n-   package STI  renames System.Tasking.Initialization;\n-   package STU  renames System.Tasking.Utilities;\n-\n-   package STPO renames System.Task_Primitives.Operations;\n-   package STPOD renames System.Task_Primitives.Operations.DEC;\n-\n-   AST_Lock : aliased System.Task_Primitives.RTS_Lock;\n-   --  This is a global lock; it is used to execute in mutual exclusion\n-   --  from all other AST tasks.  It is only used by Lock_AST and\n-   --  Unlock_AST.\n-\n-   procedure Lock_AST (Self_ID : ST.Task_Id);\n-   --  Locks out other AST tasks. Preceding a section of code by Lock_AST and\n-   --  following it by Unlock_AST creates a critical region.\n-\n-   procedure Unlock_AST (Self_ID : ST.Task_Id);\n-   --  Releases lock previously set by call to Lock_AST.\n-   --  All nested locks must be released before other tasks competing for the\n-   --  tasking lock are released.\n-\n-   --------------\n-   -- Lock_AST --\n-   --------------\n-\n-   procedure Lock_AST (Self_ID : ST.Task_Id) is\n-   begin\n-      STI.Defer_Abort_Nestable (Self_ID);\n-      STPO.Write_Lock (AST_Lock'Access, Global_Lock => True);\n-   end Lock_AST;\n-\n-   ----------------\n-   -- Unlock_AST --\n-   ----------------\n-\n-   procedure Unlock_AST (Self_ID : ST.Task_Id) is\n-   begin\n-      STPO.Unlock (AST_Lock'Access, Global_Lock => True);\n-      STI.Undefer_Abort_Nestable (Self_ID);\n-   end Unlock_AST;\n-\n-   ---------------------------------\n-   -- AST_Handler Data Structures --\n-   ---------------------------------\n-\n-   --  As noted in the private part of the spec of System.Aux_DEC, the\n-   --  AST_Handler type is simply a pointer to a procedure that takes\n-   --  a single 64bit parameter. The following is a local copy\n-   --  of that definition.\n-\n-   --  We need our own copy because we need to get our hands on this\n-   --  and we cannot see the private part of System.Aux_DEC. We don't\n-   --  want to be a child of Aux_Dec because of complications resulting\n-   --  from the use of pragma Extend_System. We will use unchecked\n-   --  conversions between the two versions of the declarations.\n-\n-   type AST_Handler is access procedure (Param : Long_Integer);\n-\n-   --  However, this declaration is somewhat misleading, since the values\n-   --  referenced by AST_Handler values (all produced in this package by\n-   --  calls to Create_AST_Handler) are highly stylized.\n-\n-   --  The first point is that in VMS/I64, procedure pointers do not in\n-   --  fact point to code, but rather to a procedure descriptor.\n-   --  So a value of type AST_Handler is in fact a pointer to one of\n-   --  descriptors.\n-\n-   type Descriptor_Type is\n-   record\n-      Entry_Point : System.Address;\n-      GP_Value    : System.Address;\n-   end record;\n-   for  Descriptor_Type'Alignment use Standard'Maximum_Alignment;\n-   --  pragma Warnings (Off, Descriptor_Type);\n-   --  Suppress harmless warnings about alignment.\n-   --  Should explain why this warning is harmless ???\n-\n-   type Descriptor_Ref is access all Descriptor_Type;\n-\n-   --  Normally, there is only one such descriptor for a given procedure, but\n-   --  it works fine to make a copy of the single allocated descriptor, and\n-   --  use the copy itself, and we take advantage of this in the design here.\n-   --  The idea is that AST_Handler values will all point to a record with the\n-   --  following structure:\n-\n-   --  Note: When we say it works fine, there is one delicate point, which\n-   --  is that the code for the AST procedure itself requires the original\n-   --  descriptor address.  We handle this by saving the orignal descriptor\n-   --  address in this structure and restoring in Process_AST.\n-\n-   type AST_Handler_Data is record\n-      Descriptor              : Descriptor_Type;\n-      Original_Descriptor_Ref : Descriptor_Ref;\n-      Taskid                  : ATID.Task_Id;\n-      Entryno                 : Natural;\n-   end record;\n-\n-   type AST_Handler_Data_Ref is access all AST_Handler_Data;\n-\n-   function To_AST_Handler is new Ada.Unchecked_Conversion\n-     (AST_Handler_Data_Ref, System.Aux_DEC.AST_Handler);\n-\n-   --  Each time Create_AST_Handler is called, a new value of this record\n-   --  type is created, containing a copy of the procedure descriptor for\n-   --  the routine used to handle all AST's (Process_AST), and the Task_Id\n-   --  and entry number parameters identifying the task entry involved.\n-\n-   --  The AST_Handler value returned is a pointer to this record. Since\n-   --  the record starts with the procedure descriptor, it can be used\n-   --  by the system in the normal way to call the procedure. But now\n-   --  when the procedure gets control, it can determine the address of\n-   --  the procedure descriptor used to call it (since the ABI specifies\n-   --  that this is left sitting in register r27 on entry), and then use\n-   --  that address to retrieve the Task_Id and entry number so that it\n-   --  knows on which entry to queue the AST request.\n-\n-   --  The next issue is where are these records placed. Since we intend\n-   --  to pass pointers to these records to asynchronous system service\n-   --  routines, they have to be on the heap, which means we have to worry\n-   --  about when to allocate them and deallocate them.\n-\n-   --  We solve this problem by introducing a task attribute that points to\n-   --  a vector, indexed by the entry number, of AST_Handler_Data records\n-   --  for a given task. The pointer itself is a controlled object allowing\n-   --  us to write a finalization routine that frees the referenced vector.\n-\n-   --  An entry in this vector is either initialized (Entryno non-zero) and\n-   --  can be used for any subsequent reference to the same entry, or it is\n-   --  unused, marked by the Entryno value being zero.\n-\n-   type AST_Handler_Vector is array (Natural range <>) of AST_Handler_Data;\n-   type AST_Handler_Vector_Ref is access all AST_Handler_Vector;\n-\n-   type AST_Vector_Ptr is new Ada.Finalization.Controlled with record\n-      Vector : AST_Handler_Vector_Ref;\n-   end record;\n-\n-   procedure Finalize (Obj : in out AST_Vector_Ptr);\n-   --  Override Finalize so that the AST Vector gets freed.\n-\n-   procedure Finalize (Obj : in out AST_Vector_Ptr) is\n-      procedure Free is new\n-       Ada.Unchecked_Deallocation (AST_Handler_Vector, AST_Handler_Vector_Ref);\n-   begin\n-      if Obj.Vector /= null then\n-         Free (Obj.Vector);\n-      end if;\n-   end Finalize;\n-\n-   AST_Vector_Init : AST_Vector_Ptr;\n-   --  Initial value, treated as constant, Vector will be null\n-\n-   package AST_Attribute is new Ada.Task_Attributes\n-     (Attribute     => AST_Vector_Ptr,\n-      Initial_Value => AST_Vector_Init);\n-\n-   use AST_Attribute;\n-\n-   -----------------------\n-   -- AST Service Queue --\n-   -----------------------\n-\n-   --  The following global data structures are used to queue pending\n-   --  AST requests. When an AST is signalled, the AST service routine\n-   --  Process_AST is called, and it makes an entry in this structure.\n-\n-   type AST_Instance is record\n-      Taskid  : ATID.Task_Id;\n-      Entryno : Natural;\n-      Param   : Long_Integer;\n-   end record;\n-   --  The Taskid and Entryno indicate the entry on which this AST is to\n-   --  be queued, and Param is the parameter provided from the AST itself.\n-\n-   AST_Service_Queue_Size  : constant := 256;\n-   AST_Service_Queue_Limit : constant := 250;\n-   type AST_Service_Queue_Index is mod AST_Service_Queue_Size;\n-   --  Index used to refer to entries in the circular buffer which holds\n-   --  active AST_Instance values. The upper bound reflects the maximum\n-   --  number of AST instances that can be stored in the buffer. Since\n-   --  these entries are immediately serviced by the high priority server\n-   --  task that does the actual entry queuing, it is very unusual to have\n-   --  any significant number of entries simulaneously queued.\n-\n-   AST_Service_Queue : array (AST_Service_Queue_Index) of AST_Instance;\n-   pragma Volatile_Components (AST_Service_Queue);\n-   --  The circular buffer used to store active AST requests\n-\n-   AST_Service_Queue_Put : AST_Service_Queue_Index := 0;\n-   AST_Service_Queue_Get : AST_Service_Queue_Index := 0;\n-   pragma Atomic (AST_Service_Queue_Put);\n-   pragma Atomic (AST_Service_Queue_Get);\n-   --  These two variables point to the next slots in the AST_Service_Queue\n-   --  to be used for putting a new entry in and taking an entry out. This\n-   --  is a circular buffer, so these pointers wrap around. If the two values\n-   --  are equal the buffer is currently empty. The pointers are atomic to\n-   --  ensure proper synchronization between the single producer (namely the\n-   --  Process_AST procedure), and the single consumer (the AST_Service_Task).\n-\n-   --------------------------------\n-   -- AST Server Task Structures --\n-   --------------------------------\n-\n-   --  The basic approach is that when an AST comes in, a call is made to\n-   --  the Process_AST procedure. It queues the request in the service queue\n-   --  and then wakes up an AST server task to perform the actual call to the\n-   --  required entry. We use this intermediate server task, since the AST\n-   --  procedure itself cannot wait to return, and we need some caller for\n-   --  the rendezvous so that we can use the normal rendezvous mechanism.\n-\n-   --  It would work to have only one AST server task, but then we would lose\n-   --  all overlap in AST processing, and furthermore, we could get priority\n-   --  inversion effects resulting in starvation of AST requests.\n-\n-   --  We therefore maintain a small pool of AST server tasks. We adjust\n-   --  the size of the pool dynamically to reflect traffic, so that we have\n-   --  a sufficient number of server tasks to avoid starvation.\n-\n-   Max_AST_Servers : constant Natural := 16;\n-   --  Maximum number of AST server tasks that can be allocated\n-\n-   Num_AST_Servers : Natural := 0;\n-   --  Number of AST server tasks currently active\n-\n-   Num_Waiting_AST_Servers : Natural := 0;\n-   --  This is the number of AST server tasks that are either waiting for\n-   --  work, or just about to go to sleep and wait for work.\n-\n-   Is_Waiting : array (1 .. Max_AST_Servers) of Boolean := (others => False);\n-   --  An array of flags showing which AST server tasks are currently waiting\n-\n-   AST_Task_Ids : array (1 .. Max_AST_Servers) of ST.Task_Id;\n-   --  Task Id's of allocated AST server tasks\n-\n-   task type AST_Server_Task (Num : Natural) is\n-      pragma Priority (Priority'Last);\n-   end AST_Server_Task;\n-   --  Declaration for AST server task. This task has no entries, it is\n-   --  controlled by sleep and wakeup calls at the task primitives level.\n-\n-   type AST_Server_Task_Ptr is access all AST_Server_Task;\n-   --  Type used to allocate server tasks\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Allocate_New_AST_Server;\n-   --  Allocate an additional AST server task\n-\n-   procedure Process_AST (Param : Long_Integer);\n-   --  This is the central routine for processing all AST's, it is referenced\n-   --  as the code address of all created AST_Handler values. See detailed\n-   --  description in body to understand how it works to have a single such\n-   --  procedure for all AST's even though it does not get any indication of\n-   --  the entry involved passed as an explicit parameter. The single explicit\n-   --  parameter Param is the parameter passed by the system with the AST.\n-\n-   -----------------------------\n-   -- Allocate_New_AST_Server --\n-   -----------------------------\n-\n-   procedure Allocate_New_AST_Server is\n-      Dummy : AST_Server_Task_Ptr;\n-\n-   begin\n-      if Num_AST_Servers = Max_AST_Servers then\n-         return;\n-\n-      else\n-         --  Note: it is safe to increment Num_AST_Servers immediately, since\n-         --  no one will try to activate this task until it indicates that it\n-         --  is sleeping by setting its entry in Is_Waiting to True.\n-\n-         Num_AST_Servers := Num_AST_Servers + 1;\n-         Dummy := new AST_Server_Task (Num_AST_Servers);\n-      end if;\n-   end Allocate_New_AST_Server;\n-\n-   ---------------------\n-   -- AST_Server_Task --\n-   ---------------------\n-\n-   task body AST_Server_Task is\n-      Taskid  : ATID.Task_Id;\n-      Entryno : Natural;\n-      Param   : aliased Long_Integer;\n-      Self_Id : constant ST.Task_Id := ST.Self;\n-\n-      pragma Volatile (Param);\n-\n-      --  By making this task independent of master, when the environment\n-      --  task is finalizing, the AST_Server_Task will be notified that it\n-      --  should terminate.\n-\n-      Ignore : constant Boolean := STU.Make_Independent;\n-      pragma Unreferenced (Ignore);\n-\n-   begin\n-      --  Record our task Id for access by Process_AST\n-\n-      AST_Task_Ids (Num) := Self_Id;\n-\n-      --  Note: this entire task operates with the main task lock set, except\n-      --  when it is sleeping waiting for work, or busy doing a rendezvous\n-      --  with an AST server. This lock protects the data structures that\n-      --  are shared by multiple instances of the server task.\n-\n-      Lock_AST (Self_Id);\n-\n-      --  This is the main infinite loop of the task. We go to sleep and\n-      --  wait to be woken up by Process_AST when there is some work to do.\n-\n-      loop\n-         Num_Waiting_AST_Servers := Num_Waiting_AST_Servers + 1;\n-\n-         Unlock_AST (Self_Id);\n-\n-         STI.Defer_Abort (Self_Id);\n-\n-         if SP.Single_Lock then\n-            STPO.Lock_RTS;\n-         end if;\n-\n-         STPO.Write_Lock (Self_Id);\n-\n-         Is_Waiting (Num) := True;\n-\n-         Self_Id.Common.State := ST.AST_Server_Sleep;\n-         STPO.Sleep (Self_Id, ST.AST_Server_Sleep);\n-         Self_Id.Common.State := ST.Runnable;\n-\n-         STPO.Unlock (Self_Id);\n-\n-         if SP.Single_Lock then\n-            STPO.Unlock_RTS;\n-         end if;\n-\n-         --  If the process is finalizing, Undefer_Abort will simply end\n-         --  this task.\n-\n-         STI.Undefer_Abort (Self_Id);\n-\n-         --  We are awake, there is something to do\n-\n-         Lock_AST (Self_Id);\n-         Num_Waiting_AST_Servers := Num_Waiting_AST_Servers - 1;\n-\n-         --  Loop here to service outstanding requests. We are always\n-         --  locked on entry to this loop.\n-\n-         while AST_Service_Queue_Get /= AST_Service_Queue_Put loop\n-            Taskid  := AST_Service_Queue (AST_Service_Queue_Get).Taskid;\n-            Entryno := AST_Service_Queue (AST_Service_Queue_Get).Entryno;\n-            Param   := AST_Service_Queue (AST_Service_Queue_Get).Param;\n-\n-            AST_Service_Queue_Get := AST_Service_Queue_Get + 1;\n-\n-            --  This is a manual expansion of the normal call simple code\n-\n-            declare\n-               type AA is access all Long_Integer;\n-               P : AA := Param'Unrestricted_Access;\n-\n-               function To_ST_Task_Id is new Ada.Unchecked_Conversion\n-                 (ATID.Task_Id, ST.Task_Id);\n-\n-            begin\n-               Unlock_AST (Self_Id);\n-               STR.Call_Simple\n-                 (Acceptor           => To_ST_Task_Id (Taskid),\n-                  E                  => ST.Task_Entry_Index (Entryno),\n-                  Uninterpreted_Data => P'Address);\n-\n-            exception\n-               when E : others =>\n-                  System.IO.Put_Line (\"%Debugging event\");\n-                  System.IO.Put_Line (Exception_Name (E) &\n-                    \" raised when trying to deliver an AST.\");\n-\n-                  if Exception_Message (E)'Length /= 0 then\n-                     System.IO.Put_Line (Exception_Message (E));\n-                  end if;\n-\n-                  System.IO.Put_Line (\"Task type is \" & \"Receiver_Type\");\n-                  System.IO.Put_Line (\"Task id is \" & ATID.Image (Taskid));\n-            end;\n-\n-            Lock_AST (Self_Id);\n-         end loop;\n-      end loop;\n-   end AST_Server_Task;\n-\n-   ------------------------\n-   -- Create_AST_Handler --\n-   ------------------------\n-\n-   function Create_AST_Handler\n-     (Taskid  : ATID.Task_Id;\n-      Entryno : Natural) return System.Aux_DEC.AST_Handler\n-   is\n-      Attr_Ref : Attribute_Handle;\n-\n-      Process_AST_Ptr : constant AST_Handler := Process_AST'Access;\n-      --  Reference to standard procedure descriptor for Process_AST\n-\n-      function To_Descriptor_Ref is new Ada.Unchecked_Conversion\n-        (AST_Handler, Descriptor_Ref);\n-\n-      Original_Descriptor_Ref : constant Descriptor_Ref :=\n-                                  To_Descriptor_Ref (Process_AST_Ptr);\n-\n-   begin\n-      if ATID.Is_Terminated (Taskid) then\n-         raise Program_Error;\n-      end if;\n-\n-      Attr_Ref := Reference (Taskid);\n-\n-      --  Allocate another server if supply is getting low\n-\n-      if Num_Waiting_AST_Servers < 2 then\n-         Allocate_New_AST_Server;\n-      end if;\n-\n-      --  No point in creating more if we have zillions waiting to\n-      --  be serviced.\n-\n-      while AST_Service_Queue_Put - AST_Service_Queue_Get\n-         > AST_Service_Queue_Limit\n-      loop\n-         delay 0.01;\n-      end loop;\n-\n-      --  If no AST vector allocated, or the one we have is too short, then\n-      --  allocate one of right size and initialize all entries except the\n-      --  one we will use to unused. Note that the assignment automatically\n-      --  frees the old allocated table if there is one.\n-\n-      if Attr_Ref.Vector = null\n-        or else Attr_Ref.Vector'Length < Entryno\n-      then\n-         Attr_Ref.Vector := new AST_Handler_Vector (1 .. Entryno);\n-\n-         for E in 1 .. Entryno loop\n-            Attr_Ref.Vector (E).Descriptor.Entry_Point :=\n-              Original_Descriptor_Ref.Entry_Point;\n-            Attr_Ref.Vector (E).Descriptor.GP_Value :=\n-              Attr_Ref.Vector (E)'Address;\n-            Attr_Ref.Vector (E).Original_Descriptor_Ref :=\n-              Original_Descriptor_Ref;\n-            Attr_Ref.Vector (E).Taskid  := Taskid;\n-            Attr_Ref.Vector (E).Entryno := E;\n-         end loop;\n-      end if;\n-\n-      return To_AST_Handler (Attr_Ref.Vector (Entryno)'Unrestricted_Access);\n-   end Create_AST_Handler;\n-\n-   ----------------------------\n-   -- Expand_AST_Packet_Pool --\n-   ----------------------------\n-\n-   procedure Expand_AST_Packet_Pool\n-     (Requested_Packets : Natural;\n-      Actual_Number     : out Natural;\n-      Total_Number      : out Natural)\n-   is\n-      pragma Unreferenced (Requested_Packets);\n-   begin\n-      --  The AST implementation of GNAT does not permit dynamic expansion\n-      --  of the pool, so we simply add no entries and return the total. If\n-      --  it is necessary to expand the allocation, then this package body\n-      --  must be recompiled with a larger value for AST_Service_Queue_Size.\n-\n-      Actual_Number := 0;\n-      Total_Number := AST_Service_Queue_Size;\n-   end Expand_AST_Packet_Pool;\n-\n-   -----------------\n-   -- Process_AST --\n-   -----------------\n-\n-   procedure Process_AST (Param : Long_Integer) is\n-\n-      Handler_Data_Ptr : AST_Handler_Data_Ref;\n-      --  This variable is set to the address of the descriptor through\n-      --  which Process_AST is called. Since the descriptor is part of\n-      --  an AST_Handler value, this is also the address of this value,\n-      --  from which we can obtain the task and entry number information.\n-\n-      function To_Address is new Ada.Unchecked_Conversion\n-        (ST.Task_Id, System.Task_Primitives.Task_Address);\n-\n-   begin\n-      --  Move the contrived GP into place so Taskid and Entryno\n-      --  become available, then restore the true GP.\n-\n-      System.Machine_Code.Asm\n-        (Template => \"mov %0 = r1\",\n-         Outputs  => AST_Handler_Data_Ref'Asm_Output\n-          (\"=r\", Handler_Data_Ptr),\n-         Volatile => True);\n-\n-      System.Machine_Code.Asm\n-        (Template => \"ld8 r1 = %0;;\",\n-         Inputs => System.Address'Asm_Input\n-           (\"m\", Handler_Data_Ptr.Original_Descriptor_Ref.GP_Value),\n-         Volatile => True);\n-\n-      AST_Service_Queue (AST_Service_Queue_Put) := AST_Instance'\n-        (Taskid  => Handler_Data_Ptr.Taskid,\n-         Entryno => Handler_Data_Ptr.Entryno,\n-         Param   => Param);\n-\n-      --  OpenVMS Programming Concepts manual, chapter 8.2.3:\n-      --  \"Implicit synchronization can be achieved for data that is shared\n-      --   for write by using only AST routines to write the data, since only\n-      --   one AST can be running at any one time.\"\n-\n-      --  This subprogram runs at AST level so is guaranteed to be\n-      --  called sequentially at a given access level.\n-\n-      AST_Service_Queue_Put := AST_Service_Queue_Put + 1;\n-\n-      --  Need to wake up processing task. If there is no waiting server\n-      --  then we have temporarily run out, but things should still be\n-      --  OK, since one of the active ones will eventually pick up the\n-      --  service request queued in the AST_Service_Queue.\n-\n-      for J in 1 .. Num_AST_Servers loop\n-         if Is_Waiting (J) then\n-            Is_Waiting (J) := False;\n-\n-            --  Sleeps are handled by ASTs on VMS, so don't call Wakeup\n-\n-            STPOD.Interrupt_AST_Handler (To_Address (AST_Task_Ids (J)));\n-            exit;\n-         end if;\n-      end loop;\n-   end Process_AST;\n-\n-begin\n-   STPO.Initialize_Lock (AST_Lock'Access, STPO.Global_Task_Level);\n-end System.AST_Handling;"}, {"sha": "4116e32b3551c5dc85de73a6a45d792776a75d6d", "filename": "gcc/ada/s-auxdec-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 809, "changes": 809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-auxdec-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-auxdec-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms-alpha.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,809 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       S Y S T E M . A U X _ D E C                        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/Or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha/VMS version.\n-\n-pragma Style_Checks (All_Checks);\n---  Turn off alpha ordering check on subprograms, this unit is laid\n---  out to correspond to the declarations in the DEC 83 System unit.\n-\n-with System.Machine_Code; use System.Machine_Code;\n-package body System.Aux_DEC is\n-\n-   ------------------------\n-   -- Fetch_From_Address --\n-   ------------------------\n-\n-   function Fetch_From_Address (A : Address) return Target is\n-      type T_Ptr is access all Target;\n-      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n-      Ptr : constant T_Ptr := To_T_Ptr (A);\n-   begin\n-      return Ptr.all;\n-   end Fetch_From_Address;\n-\n-   -----------------------\n-   -- Assign_To_Address --\n-   -----------------------\n-\n-   procedure Assign_To_Address (A : Address; T : Target) is\n-      type T_Ptr is access all Target;\n-      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n-      Ptr : constant T_Ptr := To_T_Ptr (A);\n-   begin\n-      Ptr.all := T;\n-   end Assign_To_Address;\n-\n-   -----------------------\n-   -- Clear_Interlocked --\n-   -----------------------\n-\n-   procedure Clear_Interlocked\n-     (Bit       : in out Boolean;\n-      Old_Value : out Boolean)\n-   is\n-      use ASCII;\n-      Clr_Bit : Boolean := Bit;\n-      Old_Bit : Boolean;\n-\n-   begin\n-      --  All these ASM sequences should be commented. I suggest defining\n-      --  a constant called E which is LF & HT and then you have more space\n-      --  for line by line comments ???\n-\n-      System.Machine_Code.Asm\n-        (\n-         \"lda $16, %2\"      & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"sll $16, 3, $17 \" & LF & HT &\n-         \"bis $31, 1, $1\"   & LF & HT &\n-         \"and $17, 63, $18\" & LF & HT &\n-         \"bic $17, 63, $17\" & LF & HT &\n-         \"sra $17, 3, $17\"  & LF & HT &\n-         \"bis $31, 1, %1\"   & LF & HT &\n-         \"sll %1, $18, $18\" & LF & HT &\n-         \"1:\"               & LF & HT &\n-         \"ldq_l $1, 0($17)\" & LF & HT &\n-         \"and $1, $18, %1\"  & LF & HT &\n-         \"bic $1, $18, $1\"  & LF & HT &\n-         \"stq_c $1, 0($17)\" & LF & HT &\n-         \"cmpeq %1, 0, %1\"  & LF & HT &\n-         \"beq $1, 1b\"       & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"xor %1, 1, %1\"    & LF & HT &\n-         \"trapb\",\n-         Outputs  => (Boolean'Asm_Output (\"=m\", Clr_Bit),\n-                      Boolean'Asm_Output (\"=r\", Old_Bit)),\n-         Inputs   => Boolean'Asm_Input (\"m\", Clr_Bit),\n-         Clobber  => \"$1, $16, $17, $18\",\n-         Volatile => True);\n-\n-         Bit := Clr_Bit;\n-         Old_Value := Old_Bit;\n-   end Clear_Interlocked;\n-\n-   procedure Clear_Interlocked\n-     (Bit          : in out Boolean;\n-      Old_Value    : out Boolean;\n-      Retry_Count  : Natural;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-      Clr_Bit : Boolean := Bit;\n-      Succ, Old_Bit : Boolean;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"lda $16, %3\"      & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"sll $16, 3, $18 \" & LF & HT &\n-         \"bis $31, 1, %1\"   & LF & HT &\n-         \"and $18, 63, $19\" & LF & HT &\n-         \"bic $18, 63, $18\" & LF & HT &\n-         \"sra $18, 3, $18\"  & LF & HT &\n-         \"bis $31, %4, $17\" & LF & HT &\n-         \"sll %1, $19, $19\" & LF & HT &\n-         \"1:\"               & LF & HT &\n-         \"ldq_l %2, 0($18)\" & LF & HT &\n-         \"and %2, $19, %1\"  & LF & HT &\n-         \"bic %2, $19, %2\"  & LF & HT &\n-         \"stq_c %2, 0($18)\" & LF & HT &\n-         \"beq %2, 2f\"       & LF & HT &\n-         \"cmpeq %1, 0, %1\"  & LF & HT &\n-         \"br 3f\"            & LF & HT &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"xor %1, 1, %1\"    & LF & HT &\n-         \"trapb\",\n-         Outputs  => (Boolean'Asm_Output (\"=m\", Clr_Bit),\n-                      Boolean'Asm_Output (\"=r\", Old_Bit),\n-                      Boolean'Asm_Output (\"=r\", Succ)),\n-         Inputs   => (Boolean'Asm_Input (\"m\", Clr_Bit),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$16, $17, $18, $19\",\n-         Volatile => True);\n-\n-         Bit := Clr_Bit;\n-         Old_Value := Old_Bit;\n-         Success_Flag := Succ;\n-   end Clear_Interlocked;\n-\n-   ---------------------\n-   -- Set_Interlocked --\n-   ---------------------\n-\n-   procedure Set_Interlocked\n-     (Bit       : in out Boolean;\n-      Old_Value : out Boolean)\n-   is\n-      use ASCII;\n-      Set_Bit : Boolean := Bit;\n-      Old_Bit : Boolean;\n-\n-   begin\n-      --  Don't we need comments on these long asm sequences???\n-\n-      System.Machine_Code.Asm\n-        (\n-         \"lda $16, %2\"      & LF & HT &\n-         \"sll $16, 3, $17 \" & LF & HT &\n-         \"bis $31, 1, $1\"   & LF & HT &\n-         \"and $17, 63, $18\" & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"bic $17, 63, $17\" & LF & HT &\n-         \"sra $17, 3, $17\"  & LF & HT &\n-         \"bis $31, 1, %1\"   & LF & HT &\n-         \"sll %1, $18, $18\" & LF & HT &\n-         \"1:\"               & LF & HT &\n-         \"ldq_l $1, 0($17)\" & LF & HT &\n-         \"and $1, $18, %1\"  & LF & HT &\n-         \"bis $1, $18, $1\"  & LF & HT &\n-         \"stq_c $1, 0($17)\" & LF & HT &\n-         \"cmovne %1, 1, %1\" & LF & HT &\n-         \"beq $1, 1b\"       & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"trapb\",\n-         Outputs  => (Boolean'Asm_Output (\"=m\", Set_Bit),\n-                      Boolean'Asm_Output (\"=r\", Old_Bit)),\n-         Inputs   => Boolean'Asm_Input (\"m\", Set_Bit),\n-         Clobber  => \"$1, $16, $17, $18\",\n-         Volatile => True);\n-\n-         Bit := Set_Bit;\n-         Old_Value := Old_Bit;\n-   end Set_Interlocked;\n-\n-   procedure Set_Interlocked\n-     (Bit          : in out Boolean;\n-      Old_Value    : out Boolean;\n-      Retry_Count  : Natural;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-      Set_Bit : Boolean := Bit;\n-      Succ, Old_Bit : Boolean;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"lda $16, %3\"      & LF & HT &  --  Address of Bit\n-         \"mb\"               & LF & HT &\n-         \"sll $16, 3, $18 \" & LF & HT &  --  Byte address to bit address\n-         \"bis $31, 1, %1\"   & LF & HT &  --  Set temp to 1 for the sll\n-         \"and $18, 63, $19\" & LF & HT &  --  Quadword bit offset\n-         \"bic $18, 63, $18\" & LF & HT &  --  Quadword bit address\n-         \"sra $18, 3, $18\"  & LF & HT &  --  Quadword address\n-         \"bis $31, %4, $17\" & LF & HT &  --  Retry_Count -> $17\n-         \"sll %1, $19, $19\" & LF &       --  $19 = 1 << bit_offset\n-         \"1:\"               & LF & HT &\n-         \"ldq_l %2, 0($18)\" & LF & HT &  --  Load & lock\n-         \"and %2, $19, %1\"  & LF & HT &  --  Previous value -> %1\n-         \"bis %2, $19, %2\"  & LF & HT &  --  Set Bit\n-         \"stq_c %2, 0($18)\" & LF & HT &  --  Store conditional\n-         \"beq %2, 2f\"       & LF & HT &  --  Goto 2: if failed\n-         \"cmovne %1, 1, %1\" & LF & HT &  --  Set Old_Bit\n-         \"br 3f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &  --  Retry_Count - 1\n-         \"bgt $17, 1b\"      & LF &       --  Retry ?\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"trapb\",\n-         Outputs  => (Boolean'Asm_Output (\"=m\", Set_Bit),\n-                      Boolean'Asm_Output (\"=r\", Old_Bit),\n-                      Boolean'Asm_Output (\"=r\", Succ)),\n-         Inputs   => (Boolean'Asm_Input (\"m\", Set_Bit),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$16, $17, $18, $19\",\n-         Volatile => True);\n-\n-         Bit := Set_Bit;\n-         Old_Value := Old_Bit;\n-         Success_Flag := Succ;\n-   end Set_Interlocked;\n-\n-   ---------------------\n-   -- Add_Interlocked --\n-   ---------------------\n-\n-   procedure Add_Interlocked\n-     (Addend : Short_Integer;\n-      Augend : in out Aligned_Word;\n-      Sign   : out Integer)\n-   is\n-      use ASCII;\n-      Overflowed : Boolean := False;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"lda $18, %0\"         & LF & HT &\n-         \"bic $18, 6, $21\"     & LF & HT &\n-         \"mb\"                  & LF & HT &\n-         \"1:\"                  & LF & HT &\n-         \"ldq_l $0, 0($21)\"    & LF & HT &\n-         \"extwl $0, $18, $19\"  & LF & HT &\n-         \"mskwl $0, $18, $0\"   & LF & HT &\n-         \"addq $19, %3, $20\"   & LF & HT &\n-         \"inswl $20, $18, $17\" & LF & HT &\n-         \"xor $19, %3, $19\"    & LF & HT &\n-         \"bis $17, $0, $0\"     & LF & HT &\n-         \"stq_c $0, 0($21)\"    & LF & HT &\n-         \"beq $0, 1b\"          & LF & HT &\n-         \"srl $20, 16, $0\"     & LF & HT &\n-         \"mb\"                  & LF & HT &\n-         \"srl $20, 12, $21\"    & LF & HT &\n-         \"zapnot $20, 3, $20\"  & LF & HT &\n-         \"and $0, 1, $0\"       & LF & HT &\n-         \"and $21, 8, $21\"     & LF & HT &\n-         \"bis $21, $0, $0\"     & LF & HT &\n-         \"cmpeq $20, 0, $21\"   & LF & HT &\n-         \"xor $20, 2, $20\"     & LF & HT &\n-         \"sll $21, 2, $21\"     & LF & HT &\n-         \"bis $21, $0, $0\"     & LF & HT &\n-         \"bic $20, $19, $21\"   & LF & HT &\n-         \"srl $21, 14, $21\"    & LF & HT &\n-         \"and $21, 2, $21\"     & LF & HT &\n-         \"bis $21, $0, $0\"     & LF & HT &\n-         \"and $0, 2, %2\"       & LF & HT &\n-         \"bne %2, 2f\"          & LF & HT &\n-         \"and $0, 4, %1\"       & LF & HT &\n-         \"cmpeq %1, 0, %1\"     & LF & HT &\n-         \"and $0, 8, $0\"       & LF & HT &\n-         \"lda $16, -1\"         & LF & HT &\n-         \"cmovne $0, $16, %1\"  & LF & HT &\n-         \"2:\",\n-         Outputs  => (Aligned_Word'Asm_Output (\"=m\", Augend),\n-                      Integer'Asm_Output (\"=r\", Sign),\n-                      Boolean'Asm_Output (\"=r\", Overflowed)),\n-         Inputs   => (Short_Integer'Asm_Input (\"r\", Addend),\n-                      Aligned_Word'Asm_Input (\"m\", Augend)),\n-         Clobber  => \"$0, $1, $16, $17, $18, $19, $20, $21\",\n-         Volatile => True);\n-\n-         if Overflowed then\n-            raise Constraint_Error;\n-         end if;\n-   end Add_Interlocked;\n-\n-   ----------------\n-   -- Add_Atomic --\n-   ----------------\n-\n-   procedure Add_Atomic\n-     (To     : in out Aligned_Integer;\n-      Amount : Integer)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"              & LF &\n-         \"1:\"              & LF & HT &\n-         \"ldl_l $1, %0\"    & LF & HT &\n-         \"addl $1, %2, $0\" & LF & HT &\n-         \"stl_c $0, %1\"    & LF & HT &\n-         \"beq $0, 1b\"      & LF & HT &\n-         \"mb\",\n-         Outputs  => Aligned_Integer'Asm_Output (\"=m\", To),\n-         Inputs   => (Aligned_Integer'Asm_Input (\"m\", To),\n-                      Integer'Asm_Input (\"rJ\", Amount)),\n-         Clobber  => \"$0, $1\",\n-         Volatile => True);\n-   end Add_Atomic;\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Integer;\n-      Amount       : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"               & LF & HT &\n-         \"bis $31, %5, $17\" & LF &\n-         \"1:\"               & LF & HT &\n-         \"ldl_l $1, %0\"     & LF & HT &\n-         \"addl $1, %4, $0\"  & LF & HT &\n-         \"stl_c $0, %3\"     & LF & HT &\n-         \"beq $0, 2f\"       & LF &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"stq $0, %2\"       & LF & HT &\n-         \"stl $1, %1\"       & LF & HT &\n-         \"br 4f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"br 3b\"            & LF &\n-         \"4:\",\n-         Outputs  => (Aligned_Integer'Asm_Output (\"=m\", To),\n-                      Integer'Asm_Output (\"=m\", Old_Value),\n-                      Boolean'Asm_Output (\"=m\", Success_Flag)),\n-         Inputs   => (Aligned_Integer'Asm_Input (\"m\", To),\n-                      Integer'Asm_Input (\"rJ\", Amount),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$0, $1, $17\",\n-         Volatile => True);\n-   end Add_Atomic;\n-\n-   procedure Add_Atomic\n-     (To     : in out Aligned_Long_Integer;\n-      Amount : Long_Integer)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"              & LF &\n-         \"1:\"              & LF & HT &\n-         \"ldq_l $1, %0\"    & LF & HT &\n-         \"addq $1, %2, $0\" & LF & HT &\n-         \"stq_c $0, %1\"    & LF & HT &\n-         \"beq $0, 1b\"      & LF & HT &\n-         \"mb\",\n-         Outputs  => Aligned_Long_Integer'Asm_Output (\"=m\", To),\n-         Inputs   => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n-                      Long_Integer'Asm_Input (\"rJ\", Amount)),\n-         Clobber  => \"$0, $1\",\n-         Volatile => True);\n-   end Add_Atomic;\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      Amount       : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"               & LF & HT &\n-         \"bis $31, %5, $17\" & LF &\n-         \"1:\"               & LF & HT &\n-         \"ldq_l $1, %0\"     & LF & HT &\n-         \"addq $1, %4, $0\"  & LF & HT &\n-         \"stq_c $0, %3\"     & LF & HT &\n-         \"beq $0, 2f\"       & LF &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"stq $0, %2\"       & LF & HT &\n-         \"stq $1, %1\"       & LF & HT &\n-         \"br 4f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"br 3b\"            & LF &\n-         \"4:\",\n-         Outputs  => (Aligned_Long_Integer'Asm_Output (\"=m\", To),\n-                      Long_Integer'Asm_Output (\"=m\", Old_Value),\n-                      Boolean'Asm_Output (\"=m\", Success_Flag)),\n-         Inputs   => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n-                      Long_Integer'Asm_Input (\"rJ\", Amount),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$0, $1, $17\",\n-         Volatile => True);\n-   end Add_Atomic;\n-\n-   ----------------\n-   -- And_Atomic --\n-   ----------------\n-\n-   procedure And_Atomic\n-     (To   : in out Aligned_Integer;\n-      From : Integer)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"             & LF &\n-         \"1:\"             & LF & HT &\n-         \"ldl_l $1, %0\"   & LF & HT &\n-         \"and $1, %2, $0\" & LF & HT &\n-         \"stl_c $0, %1\"   & LF & HT &\n-         \"beq $0, 1b\"     & LF & HT &\n-         \"mb\",\n-         Outputs  => Aligned_Integer'Asm_Output (\"=m\", To),\n-         Inputs   => (Aligned_Integer'Asm_Input (\"m\", To),\n-                      Integer'Asm_Input (\"rJ\", From)),\n-         Clobber  => \"$0, $1\",\n-         Volatile => True);\n-   end And_Atomic;\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"               & LF & HT &\n-         \"bis $31, %5, $17\" & LF &\n-         \"1:\"               & LF & HT &\n-         \"ldl_l $1, %0\"     & LF & HT &\n-         \"and $1, %4, $0\"   & LF & HT &\n-         \"stl_c $0, %3\"     & LF & HT &\n-         \"beq $0, 2f\"       & LF &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"stq $0, %2\"       & LF & HT &\n-         \"stl $1, %1\"       & LF & HT &\n-         \"br 4f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"br 3b\"            & LF &\n-         \"4:\",\n-         Outputs  => (Aligned_Integer'Asm_Output (\"=m\", To),\n-                      Integer'Asm_Output (\"=m\", Old_Value),\n-                      Boolean'Asm_Output (\"=m\", Success_Flag)),\n-         Inputs   => (Aligned_Integer'Asm_Input (\"m\", To),\n-                      Integer'Asm_Input (\"rJ\", From),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$0, $1, $17\",\n-         Volatile => True);\n-   end And_Atomic;\n-\n-   procedure And_Atomic\n-     (To   : in out Aligned_Long_Integer;\n-      From : Long_Integer)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"             & LF &\n-         \"1:\"             & LF & HT &\n-         \"ldq_l $1, %0\"   & LF & HT &\n-         \"and $1, %2, $0\" & LF & HT &\n-         \"stq_c $0, %1\"   & LF & HT &\n-         \"beq $0, 1b\"     & LF & HT &\n-         \"mb\",\n-         Outputs  => Aligned_Long_Integer'Asm_Output (\"=m\", To),\n-         Inputs   => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n-                      Long_Integer'Asm_Input (\"rJ\", From)),\n-         Clobber  => \"$0, $1\",\n-         Volatile => True);\n-   end And_Atomic;\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"               & LF & HT &\n-         \"bis $31, %5, $17\" & LF &\n-         \"1:\"               & LF & HT &\n-         \"ldq_l $1, %0\"     & LF & HT &\n-         \"and $1, %4, $0\"   & LF & HT &\n-         \"stq_c $0, %3\"     & LF & HT &\n-         \"beq $0, 2f\"       & LF &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"stq $0, %2\"       & LF & HT &\n-         \"stq $1, %1\"       & LF & HT &\n-         \"br 4f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"br 3b\"            & LF &\n-         \"4:\",\n-         Outputs  => (Aligned_Long_Integer'Asm_Output (\"=m\", To),\n-                      Long_Integer'Asm_Output (\"=m\", Old_Value),\n-                      Boolean'Asm_Output (\"=m\", Success_Flag)),\n-         Inputs   => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n-                      Long_Integer'Asm_Input (\"rJ\", From),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$0, $1, $17\",\n-         Volatile => True);\n-   end And_Atomic;\n-\n-   ---------------\n-   -- Or_Atomic --\n-   ---------------\n-\n-   procedure Or_Atomic\n-     (To   : in out Aligned_Integer;\n-      From : Integer)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"             & LF &\n-         \"1:\"             & LF & HT &\n-         \"ldl_l $1, %0\"   & LF & HT &\n-         \"bis $1, %2, $0\" & LF & HT &\n-         \"stl_c $0, %1\"   & LF & HT &\n-         \"beq $0, 1b\"     & LF & HT &\n-         \"mb\",\n-         Outputs  => Aligned_Integer'Asm_Output (\"=m\", To),\n-         Inputs   => (Aligned_Integer'Asm_Input (\"m\", To),\n-                      Integer'Asm_Input (\"rJ\", From)),\n-         Clobber  => \"$0, $1\",\n-         Volatile => True);\n-   end Or_Atomic;\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"               & LF & HT &\n-         \"bis $31, %5, $17\" & LF &\n-         \"1:\"               & LF & HT &\n-         \"ldl_l $1, %0\"     & LF & HT &\n-         \"bis $1, %4, $0\"   & LF & HT &\n-         \"stl_c $0, %3\"     & LF & HT &\n-         \"beq $0, 2f\"       & LF &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"stq $0, %2\"       & LF & HT &\n-         \"stl $1, %1\"       & LF & HT &\n-         \"br 4f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"br 3b\"            & LF &\n-         \"4:\",\n-         Outputs  => (Aligned_Integer'Asm_Output (\"=m\", To),\n-                      Integer'Asm_Output (\"=m\", Old_Value),\n-                      Boolean'Asm_Output (\"=m\", Success_Flag)),\n-         Inputs   => (Aligned_Integer'Asm_Input (\"m\", To),\n-                      Integer'Asm_Input (\"rJ\", From),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$0, $1, $17\",\n-         Volatile => True);\n-   end Or_Atomic;\n-\n-   procedure Or_Atomic\n-     (To   : in out Aligned_Long_Integer;\n-      From : Long_Integer)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"             & LF &\n-         \"1:\"             & LF & HT &\n-         \"ldq_l $1, %0\"   & LF & HT &\n-         \"bis $1, %2, $0\" & LF & HT &\n-         \"stq_c $0, %1\"   & LF & HT &\n-         \"beq $0, 1b\"     & LF & HT &\n-         \"mb\",\n-         Outputs  => Aligned_Long_Integer'Asm_Output (\"=m\", To),\n-         Inputs   => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n-                      Long_Integer'Asm_Input (\"rJ\", From)),\n-         Clobber  => \"$0, $1\",\n-         Volatile => True);\n-   end Or_Atomic;\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"mb\"               & LF & HT &\n-         \"bis $31, %5, $17\" & LF &\n-         \"1:\"               & LF & HT &\n-         \"ldq_l $1, %0\"     & LF & HT &\n-         \"bis $1, %4, $0\"   & LF & HT &\n-         \"stq_c $0, %3\"     & LF & HT &\n-         \"beq $0, 2f\"       & LF &\n-         \"3:\"               & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"stq $0, %2\"       & LF & HT &\n-         \"stq $1, %1\"       & LF & HT &\n-         \"br 4f\"            & LF &\n-         \"2:\"               & LF & HT &\n-         \"subq $17, 1, $17\" & LF & HT &\n-         \"bgt $17, 1b\"      & LF & HT &\n-         \"br 3b\"            & LF &\n-         \"4:\",\n-         Outputs  => (Aligned_Long_Integer'Asm_Output (\"=m\", To),\n-                      Long_Integer'Asm_Output (\"=m\", Old_Value),\n-                      Boolean'Asm_Output (\"=m\", Success_Flag)),\n-         Inputs   => (Aligned_Long_Integer'Asm_Input (\"m\", To),\n-                      Long_Integer'Asm_Input (\"rJ\", From),\n-                      Natural'Asm_Input (\"rJ\", Retry_Count)),\n-         Clobber  => \"$0, $1, $17\",\n-         Volatile => True);\n-   end Or_Atomic;\n-\n-   ------------\n-   -- Insqhi --\n-   ------------\n-\n-   procedure Insqhi\n-     (Item   : Address;\n-      Header : Address;\n-      Status : out Insq_Status)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"bis $31, %1, $17\" & LF & HT &\n-         \"bis $31, %2, $16\" & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"call_pal 0x87\"    & LF & HT &\n-         \"mb\",\n-         Outputs  => Insq_Status'Asm_Output (\"=v\", Status),\n-         Inputs   => (Address'Asm_Input (\"rJ\", Item),\n-                      Address'Asm_Input (\"rJ\", Header)),\n-         Clobber  => \"$16, $17\",\n-         Volatile => True);\n-   end Insqhi;\n-\n-   ------------\n-   -- Remqhi --\n-   ------------\n-\n-   procedure Remqhi\n-     (Header : Address;\n-      Item   : out Address;\n-      Status : out Remq_Status)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"bis $31, %2, $16\" & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"call_pal 0x93\"    & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"bis $31, $1, %1\",\n-         Outputs  => (Remq_Status'Asm_Output (\"=v\", Status),\n-                      Address'Asm_Output (\"=r\", Item)),\n-         Inputs   => Address'Asm_Input (\"rJ\", Header),\n-         Clobber  => \"$1, $16\",\n-         Volatile => True);\n-   end Remqhi;\n-\n-   ------------\n-   -- Insqti --\n-   ------------\n-\n-   procedure Insqti\n-     (Item   : Address;\n-      Header : Address;\n-      Status : out Insq_Status)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"bis $31, %1, $17\" & LF & HT &\n-         \"bis $31, %2, $16\" & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"call_pal 0x88\"    & LF & HT &\n-         \"mb\",\n-         Outputs  => Insq_Status'Asm_Output (\"=v\", Status),\n-         Inputs   => (Address'Asm_Input (\"rJ\", Item),\n-                      Address'Asm_Input (\"rJ\", Header)),\n-         Clobber  => \"$16, $17\",\n-         Volatile => True);\n-   end Insqti;\n-\n-   ------------\n-   -- Remqti --\n-   ------------\n-\n-   procedure Remqti\n-     (Header : Address;\n-      Item   : out Address;\n-      Status : out Remq_Status)\n-   is\n-      use ASCII;\n-\n-   begin\n-      System.Machine_Code.Asm\n-        (\n-         \"bis $31, %2, $16\" & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"call_pal 0x94\"    & LF & HT &\n-         \"mb\"               & LF & HT &\n-         \"bis $31, $1, %1\",\n-         Outputs  => (Remq_Status'Asm_Output (\"=v\", Status),\n-                      Address'Asm_Output (\"=r\", Item)),\n-         Inputs   => Address'Asm_Input (\"rJ\", Header),\n-         Clobber  => \"$1, $16\",\n-         Volatile => True);\n-   end Remqti;\n-\n-end System.Aux_DEC;"}, {"sha": "b8ca67e85b2fec4ac801c823b68a6d6738b5145a", "filename": "gcc/ada/s-auxdec-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 576, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-auxdec-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-auxdec-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms-ia64.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,576 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       S Y S T E M . A U X _ D E C                        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Itanium/VMS version.\n-\n---  The Add,Clear_Interlocked subprograms are dubiously implmented due to\n---  the lack of a single bit sync_lock_test_and_set builtin.\n-\n---  The \"Retry\" parameter is ignored due to the lack of retry builtins making\n---  the subprograms identical to the non-retry versions.\n-\n-pragma Style_Checks (All_Checks);\n---  Turn off alpha ordering check on subprograms, this unit is laid\n---  out to correspond to the declarations in the DEC 83 System unit.\n-\n-with Interfaces;\n-package body System.Aux_DEC is\n-\n-   use type Interfaces.Unsigned_8;\n-\n-   ------------------------\n-   -- Fetch_From_Address --\n-   ------------------------\n-\n-   function Fetch_From_Address (A : Address) return Target is\n-      type T_Ptr is access all Target;\n-      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n-      Ptr : constant T_Ptr := To_T_Ptr (A);\n-   begin\n-      return Ptr.all;\n-   end Fetch_From_Address;\n-\n-   -----------------------\n-   -- Assign_To_Address --\n-   -----------------------\n-\n-   procedure Assign_To_Address (A : Address; T : Target) is\n-      type T_Ptr is access all Target;\n-      function To_T_Ptr is new Ada.Unchecked_Conversion (Address, T_Ptr);\n-      Ptr : constant T_Ptr := To_T_Ptr (A);\n-   begin\n-      Ptr.all := T;\n-   end Assign_To_Address;\n-\n-   -----------------------\n-   -- Clear_Interlocked --\n-   -----------------------\n-\n-   procedure Clear_Interlocked\n-     (Bit       : in out Boolean;\n-      Old_Value : out Boolean)\n-   is\n-      Clr_Bit : Boolean := Bit;\n-      Old_Uns : Interfaces.Unsigned_8;\n-\n-      function Sync_Lock_Test_And_Set\n-        (Ptr   : Address;\n-         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n-      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n-                     \"__sync_lock_test_and_set_1\");\n-\n-   begin\n-      Old_Uns := Sync_Lock_Test_And_Set (Clr_Bit'Address, 0);\n-      Bit := Clr_Bit;\n-      Old_Value := Old_Uns /= 0;\n-   end Clear_Interlocked;\n-\n-   procedure Clear_Interlocked\n-     (Bit          : in out Boolean;\n-      Old_Value    : out Boolean;\n-      Retry_Count  : Natural;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      Clr_Bit : Boolean := Bit;\n-      Old_Uns : Interfaces.Unsigned_8;\n-\n-      function Sync_Lock_Test_And_Set\n-        (Ptr   : Address;\n-         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n-      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n-                     \"__sync_lock_test_and_set_1\");\n-\n-   begin\n-      Old_Uns := Sync_Lock_Test_And_Set (Clr_Bit'Address, 0);\n-      Bit := Clr_Bit;\n-      Old_Value := Old_Uns /= 0;\n-      Success_Flag := True;\n-   end Clear_Interlocked;\n-\n-   ---------------------\n-   -- Set_Interlocked --\n-   ---------------------\n-\n-   procedure Set_Interlocked\n-     (Bit       : in out Boolean;\n-      Old_Value : out Boolean)\n-   is\n-      Set_Bit : Boolean := Bit;\n-      Old_Uns : Interfaces.Unsigned_8;\n-\n-      function Sync_Lock_Test_And_Set\n-        (Ptr   : Address;\n-         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n-      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n-                     \"__sync_lock_test_and_set_1\");\n-\n-   begin\n-      Old_Uns := Sync_Lock_Test_And_Set (Set_Bit'Address, 1);\n-      Bit := Set_Bit;\n-      Old_Value := Old_Uns /= 0;\n-   end Set_Interlocked;\n-\n-   procedure Set_Interlocked\n-     (Bit          : in out Boolean;\n-      Old_Value    : out Boolean;\n-      Retry_Count  : Natural;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      Set_Bit : Boolean := Bit;\n-      Old_Uns : Interfaces.Unsigned_8;\n-\n-      function Sync_Lock_Test_And_Set\n-        (Ptr   : Address;\n-         Value : Interfaces.Unsigned_8) return Interfaces.Unsigned_8;\n-      pragma Import (Intrinsic, Sync_Lock_Test_And_Set,\n-                     \"__sync_lock_test_and_set_1\");\n-   begin\n-      Old_Uns := Sync_Lock_Test_And_Set (Set_Bit'Address, 1);\n-      Bit := Set_Bit;\n-      Old_Value := Old_Uns /= 0;\n-      Success_Flag := True;\n-   end Set_Interlocked;\n-\n-   ---------------------\n-   -- Add_Interlocked --\n-   ---------------------\n-\n-   procedure Add_Interlocked\n-     (Addend : Short_Integer;\n-      Augend : in out Aligned_Word;\n-      Sign   : out Integer)\n-   is\n-      Overflowed : Boolean := False;\n-      Former     : Aligned_Word;\n-\n-      function Sync_Fetch_And_Add\n-        (Ptr   : Address;\n-         Value : Short_Integer) return Short_Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_Add, \"__sync_fetch_and_add_2\");\n-\n-   begin\n-      Former.Value := Sync_Fetch_And_Add (Augend.Value'Address, Addend);\n-\n-      if Augend.Value < 0 then\n-         Sign := -1;\n-      elsif Augend.Value > 0 then\n-         Sign := 1;\n-      else\n-         Sign := 0;\n-      end if;\n-\n-      if Former.Value > 0 and then Augend.Value <= 0 then\n-         Overflowed := True;\n-      end if;\n-\n-      if Overflowed then\n-         raise Constraint_Error;\n-      end if;\n-   end Add_Interlocked;\n-\n-   ----------------\n-   -- Add_Atomic --\n-   ----------------\n-\n-   procedure Add_Atomic\n-     (To     : in out Aligned_Integer;\n-      Amount : Integer)\n-   is\n-      procedure Sync_Add_And_Fetch\n-        (Ptr   : Address;\n-         Value : Integer);\n-      pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_4\");\n-   begin\n-      Sync_Add_And_Fetch (To.Value'Address, Amount);\n-   end Add_Atomic;\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Integer;\n-      Amount       : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      function Sync_Fetch_And_Add\n-        (Ptr   : Address;\n-         Value : Integer) return Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_Add, \"__sync_fetch_and_add_4\");\n-\n-   begin\n-      Old_Value := Sync_Fetch_And_Add (To.Value'Address, Amount);\n-      Success_Flag := True;\n-   end Add_Atomic;\n-\n-   procedure Add_Atomic\n-     (To     : in out Aligned_Long_Integer;\n-      Amount : Long_Integer)\n-   is\n-      procedure Sync_Add_And_Fetch\n-        (Ptr   : Address;\n-         Value : Long_Integer);\n-      pragma Import (Intrinsic, Sync_Add_And_Fetch, \"__sync_add_and_fetch_8\");\n-   begin\n-      Sync_Add_And_Fetch (To.Value'Address, Amount);\n-   end Add_Atomic;\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      Amount       : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      function Sync_Fetch_And_Add\n-        (Ptr   : Address;\n-         Value : Long_Integer) return Long_Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_Add, \"__sync_fetch_and_add_8\");\n-      --  Why do we keep importing this over and over again???\n-\n-   begin\n-      Old_Value := Sync_Fetch_And_Add (To.Value'Address, Amount);\n-      Success_Flag := True;\n-   end Add_Atomic;\n-\n-   ----------------\n-   -- And_Atomic --\n-   ----------------\n-\n-   procedure And_Atomic\n-     (To   : in out Aligned_Integer;\n-      From : Integer)\n-   is\n-      procedure Sync_And_And_Fetch\n-        (Ptr   : Address;\n-         Value : Integer);\n-      pragma Import (Intrinsic, Sync_And_And_Fetch, \"__sync_and_and_fetch_4\");\n-   begin\n-      Sync_And_And_Fetch (To.Value'Address, From);\n-   end And_Atomic;\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      function Sync_Fetch_And_And\n-        (Ptr   : Address;\n-         Value : Integer) return Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_And, \"__sync_fetch_and_and_4\");\n-\n-   begin\n-      Old_Value := Sync_Fetch_And_And (To.Value'Address, From);\n-      Success_Flag := True;\n-   end And_Atomic;\n-\n-   procedure And_Atomic\n-     (To   : in out Aligned_Long_Integer;\n-      From : Long_Integer)\n-   is\n-      procedure Sync_And_And_Fetch\n-        (Ptr   : Address;\n-         Value : Long_Integer);\n-      pragma Import (Intrinsic, Sync_And_And_Fetch, \"__sync_and_and_fetch_8\");\n-   begin\n-      Sync_And_And_Fetch (To.Value'Address, From);\n-   end And_Atomic;\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      function Sync_Fetch_And_And\n-        (Ptr   : Address;\n-         Value : Long_Integer) return Long_Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_And, \"__sync_fetch_and_and_8\");\n-\n-   begin\n-      Old_Value := Sync_Fetch_And_And (To.Value'Address, From);\n-      Success_Flag := True;\n-   end And_Atomic;\n-\n-   ---------------\n-   -- Or_Atomic --\n-   ---------------\n-\n-   procedure Or_Atomic\n-     (To   : in out Aligned_Integer;\n-      From : Integer)\n-   is\n-      procedure Sync_Or_And_Fetch\n-        (Ptr   : Address;\n-         Value : Integer);\n-      pragma Import (Intrinsic, Sync_Or_And_Fetch, \"__sync_or_and_fetch_4\");\n-\n-   begin\n-      Sync_Or_And_Fetch (To.Value'Address, From);\n-   end Or_Atomic;\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      function Sync_Fetch_And_Or\n-        (Ptr   : Address;\n-         Value : Integer) return Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_Or, \"__sync_fetch_and_or_4\");\n-\n-   begin\n-      Old_Value := Sync_Fetch_And_Or (To.Value'Address, From);\n-      Success_Flag := True;\n-   end Or_Atomic;\n-\n-   procedure Or_Atomic\n-     (To   : in out Aligned_Long_Integer;\n-      From : Long_Integer)\n-   is\n-      procedure Sync_Or_And_Fetch\n-        (Ptr   : Address;\n-         Value : Long_Integer);\n-      pragma Import (Intrinsic, Sync_Or_And_Fetch, \"__sync_or_and_fetch_8\");\n-   begin\n-      Sync_Or_And_Fetch (To.Value'Address, From);\n-   end Or_Atomic;\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean)\n-   is\n-      pragma Unreferenced (Retry_Count);\n-\n-      function Sync_Fetch_And_Or\n-        (Ptr   : Address;\n-         Value : Long_Integer) return Long_Integer;\n-      pragma Import (Intrinsic, Sync_Fetch_And_Or, \"__sync_fetch_and_or_8\");\n-\n-   begin\n-      Old_Value := Sync_Fetch_And_Or (To.Value'Address, From);\n-      Success_Flag := True;\n-   end Or_Atomic;\n-\n-   ------------\n-   -- Insqhi --\n-   ------------\n-\n-   procedure Insqhi\n-     (Item   : Address;\n-      Header : Address;\n-      Status : out Insq_Status) is\n-\n-      procedure SYS_PAL_INSQHIL\n-        (STATUS : out Integer; Header : Address; ITEM : Address);\n-      pragma Import (External, SYS_PAL_INSQHIL);\n-      pragma Import_Valued_Procedure (SYS_PAL_INSQHIL, \"SYS$PAL_INSQHIL\",\n-         (Integer, Address, Address),\n-         (Value, Value, Value));\n-\n-      Istat : Integer;\n-\n-   begin\n-      SYS_PAL_INSQHIL (Istat, Header, Item);\n-\n-      if Istat = 0 then\n-         Status := OK_Not_First;\n-      elsif Istat = 1 then\n-         Status := OK_First;\n-\n-      else\n-         --  This status is never returned on IVMS\n-\n-         Status := Fail_No_Lock;\n-      end if;\n-   end Insqhi;\n-\n-   ------------\n-   -- Remqhi --\n-   ------------\n-\n-   procedure Remqhi\n-     (Header : Address;\n-      Item   : out Address;\n-      Status : out Remq_Status)\n-   is\n-      --  The removed item is returned in the second function return register,\n-      --  R9 on IVMS. The VMS ABI calls for \"small\" records to be returned in\n-      --  these registers, so inventing this odd looking record type makes that\n-      --  all work.\n-\n-      type Remq is record\n-         Status : Long_Integer;\n-         Item   : Address;\n-      end record;\n-\n-      procedure SYS_PAL_REMQHIL\n-        (Remret : out Remq; Header : Address);\n-      pragma Import (External, SYS_PAL_REMQHIL);\n-      pragma Import_Valued_Procedure\n-        (SYS_PAL_REMQHIL, \"SYS$PAL_REMQHIL\",\n-         (Remq, Address),\n-         (Value, Value));\n-\n-      --  Following variables need documentation???\n-\n-      Rstat  : Long_Integer;\n-      Remret : Remq;\n-\n-   begin\n-      SYS_PAL_REMQHIL (Remret, Header);\n-\n-      Rstat := Remret.Status;\n-      Item := Remret.Item;\n-\n-      if Rstat = 0 then\n-         Status := Fail_Was_Empty;\n-\n-      elsif Rstat = 1 then\n-         Status := OK_Not_Empty;\n-\n-      elsif Rstat = 2 then\n-         Status := OK_Empty;\n-\n-      else\n-         --  This status is never returned on IVMS\n-\n-         Status := Fail_No_Lock;\n-      end if;\n-\n-   end Remqhi;\n-\n-   ------------\n-   -- Insqti --\n-   ------------\n-\n-   procedure Insqti\n-     (Item   : Address;\n-      Header : Address;\n-      Status : out Insq_Status) is\n-\n-      procedure SYS_PAL_INSQTIL\n-        (STATUS : out Integer; Header : Address; ITEM : Address);\n-      pragma Import (External, SYS_PAL_INSQTIL);\n-      pragma Import_Valued_Procedure (SYS_PAL_INSQTIL, \"SYS$PAL_INSQTIL\",\n-         (Integer, Address, Address),\n-         (Value, Value, Value));\n-\n-      Istat : Integer;\n-\n-   begin\n-      SYS_PAL_INSQTIL (Istat, Header, Item);\n-\n-      if Istat = 0 then\n-         Status := OK_Not_First;\n-\n-      elsif Istat = 1 then\n-         Status := OK_First;\n-\n-      else\n-         --  This status is never returned on IVMS\n-\n-         Status := Fail_No_Lock;\n-      end if;\n-   end Insqti;\n-\n-   ------------\n-   -- Remqti --\n-   ------------\n-\n-   procedure Remqti\n-     (Header : Address;\n-      Item   : out Address;\n-      Status : out Remq_Status)\n-   is\n-      --  The removed item is returned in the second function return register,\n-      --  R9 on IVMS. The VMS ABI calls for \"small\" records to be returned in\n-      --  these registers, so inventing (where is rest of this comment???)\n-\n-      type Remq is record\n-         Status : Long_Integer;\n-         Item   : Address;\n-      end record;\n-\n-      procedure SYS_PAL_REMQTIL\n-        (Remret : out Remq; Header : Address);\n-      pragma Import (External, SYS_PAL_REMQTIL);\n-      pragma Import_Valued_Procedure (SYS_PAL_REMQTIL, \"SYS$PAL_REMQTIL\",\n-         (Remq, Address),\n-         (Value, Value));\n-\n-      Rstat  : Long_Integer;\n-      Remret : Remq;\n-\n-   begin\n-      SYS_PAL_REMQTIL (Remret, Header);\n-\n-      Rstat := Remret.Status;\n-      Item := Remret.Item;\n-\n-      --  Wouldn't case be nicer here, and in previous similar cases ???\n-\n-      if Rstat = 0 then\n-         Status := Fail_Was_Empty;\n-\n-      elsif Rstat = 1 then\n-         Status := OK_Not_Empty;\n-\n-      elsif Rstat = 2 then\n-         Status := OK_Empty;\n-      else\n-         --  This status is never returned on IVMS\n-\n-         Status := Fail_No_Lock;\n-      end if;\n-   end Remqti;\n-\n-end System.Aux_DEC;"}, {"sha": "1bac3fbac954e55c264b10fbad301660f09b63db", "filename": "gcc/ada/s-auxdec-vms_64.ads", "status": "removed", "additions": 0, "deletions": 693, "changes": 693, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-auxdec-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-auxdec-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-auxdec-vms_64.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,693 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       S Y S T E M . A U X _ D E C                        --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1996-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package contains definitions that are designed to be compatible\n---  with the extra definitions in package System for DEC Ada implementations.\n-\n---  These definitions can be used directly by withing this package, or merged\n---  with System using pragma Extend_System (Aux_DEC)\n-\n---  This is the VMS 64 bit version\n-\n-with Ada.Unchecked_Conversion;\n-\n-package System.Aux_DEC is\n-   pragma Preelaborate;\n-\n-   type Short_Integer_Address is\n-     range -2 ** (32 - 1) .. +2 ** (32 - 1) - 1;\n-   --  Integer literals cannot appear naked in an address context, as a\n-   --  result the bounds of Short_Address cannot be given simply as 2^32 etc.\n-\n-   subtype Short_Address is Address\n-     range Address (Short_Integer_Address'First) ..\n-           Address (Short_Integer_Address'Last);\n-   for Short_Address'Object_Size use 32;\n-   --  This subtype allows addresses to be converted from 64 bits to 32 bits\n-   --  with an appropriate range check. Note that since this is a subtype of\n-   --  type System.Address, the same limitations apply to this subtype. Namely\n-   --  there are no visible arithmetic operations, and integer literals are\n-   --  not available.\n-\n-   Short_Memory_Size : constant := 2 ** 32;\n-   --  Defined for convenience of porting\n-\n-   type Integer_8  is range -2 **  (8 - 1) .. +2 **  (8 - 1) - 1;\n-   for Integer_8'Size  use  8;\n-\n-   type Integer_16 is range -2 ** (16 - 1) .. +2 ** (16 - 1) - 1;\n-   for Integer_16'Size use 16;\n-\n-   type Integer_32 is range -2 ** (32 - 1) .. +2 ** (32 - 1) - 1;\n-   for Integer_32'Size use 32;\n-\n-   type Integer_64 is range -2 ** (64 - 1) .. +2 ** (64 - 1) - 1;\n-   for Integer_64'Size use 64;\n-\n-   type Integer_8_Array  is array (Integer range <>) of Integer_8;\n-   type Integer_16_Array is array (Integer range <>) of Integer_16;\n-   type Integer_32_Array is array (Integer range <>) of Integer_32;\n-   type Integer_64_Array is array (Integer range <>) of Integer_64;\n-   --  These array types are not in all versions of DEC System, and in fact it\n-   --  is not quite clear why they are in some and not others, but since they\n-   --  definitely appear in some versions, we include them unconditionally.\n-\n-   type Largest_Integer is range Min_Int .. Max_Int;\n-\n-   type AST_Handler is private;\n-\n-   No_AST_Handler : constant AST_Handler;\n-\n-   type Type_Class is\n-     (Type_Class_Enumeration,\n-      Type_Class_Integer,\n-      Type_Class_Fixed_Point,\n-      Type_Class_Floating_Point,\n-      Type_Class_Array,\n-      Type_Class_Record,\n-      Type_Class_Access,\n-      Type_Class_Task,             -- also in Ada 95 protected\n-      Type_Class_Address);\n-\n-   function \"not\" (Left        : Largest_Integer) return Largest_Integer;\n-   function \"and\" (Left, Right : Largest_Integer) return Largest_Integer;\n-   function \"or\"  (Left, Right : Largest_Integer) return Largest_Integer;\n-   function \"xor\" (Left, Right : Largest_Integer) return Largest_Integer;\n-\n-   Address_Zero       : constant Address;\n-   No_Addr            : constant Address;\n-   Address_Size       : constant := Standard'Address_Size;\n-   Short_Address_Size : constant := 32;\n-\n-   function \"+\" (Left : Address; Right : Integer) return Address;\n-   function \"+\" (Left : Integer; Right : Address) return Address;\n-   function \"-\" (Left : Address; Right : Address) return Integer;\n-   function \"-\" (Left : Address; Right : Integer) return Address;\n-\n-   pragma Import (Intrinsic, \"+\");\n-   pragma Import (Intrinsic, \"-\");\n-\n-   generic\n-      type Target is private;\n-   function Fetch_From_Address (A : Address) return Target;\n-\n-   generic\n-      type Target is private;\n-   procedure Assign_To_Address (A : Address; T : Target);\n-\n-   --  Floating point type declarations for VAX floating point data types\n-\n-   pragma Warnings (Off);\n-   --  ??? needs comment\n-\n-   type F_Float is digits 6;\n-   pragma Float_Representation (VAX_Float, F_Float);\n-\n-   type D_Float is digits 9;\n-   pragma Float_Representation (Vax_Float, D_Float);\n-\n-   type G_Float is digits 15;\n-   pragma Float_Representation (Vax_Float, G_Float);\n-\n-   --  Floating point type declarations for IEEE floating point data types\n-\n-   type IEEE_Single_Float is digits 6;\n-   pragma Float_Representation (IEEE_Float, IEEE_Single_Float);\n-\n-   type IEEE_Double_Float is digits 15;\n-   pragma Float_Representation (IEEE_Float, IEEE_Double_Float);\n-\n-   pragma Warnings (On);\n-\n-   Non_Ada_Error : exception;\n-\n-   --  Hardware-oriented types and functions\n-\n-   type Bit_Array is array (Integer range <>) of Boolean;\n-   pragma Pack (Bit_Array);\n-\n-   subtype Bit_Array_8  is Bit_Array (0 ..  7);\n-   subtype Bit_Array_16 is Bit_Array (0 .. 15);\n-   subtype Bit_Array_32 is Bit_Array (0 .. 31);\n-   subtype Bit_Array_64 is Bit_Array (0 .. 63);\n-\n-   type Unsigned_Byte is range 0 .. 255;\n-   for  Unsigned_Byte'Size use 8;\n-\n-   function \"not\" (Left        : Unsigned_Byte) return Unsigned_Byte;\n-   function \"and\" (Left, Right : Unsigned_Byte) return Unsigned_Byte;\n-   function \"or\"  (Left, Right : Unsigned_Byte) return Unsigned_Byte;\n-   function \"xor\" (Left, Right : Unsigned_Byte) return Unsigned_Byte;\n-\n-   function To_Unsigned_Byte (X : Bit_Array_8) return Unsigned_Byte;\n-   function To_Bit_Array_8   (X : Unsigned_Byte) return Bit_Array_8;\n-\n-   type Unsigned_Byte_Array is array (Integer range <>) of Unsigned_Byte;\n-\n-   type Unsigned_Word is range 0 .. 65535;\n-   for  Unsigned_Word'Size use 16;\n-\n-   function \"not\" (Left        : Unsigned_Word) return Unsigned_Word;\n-   function \"and\" (Left, Right : Unsigned_Word) return Unsigned_Word;\n-   function \"or\"  (Left, Right : Unsigned_Word) return Unsigned_Word;\n-   function \"xor\" (Left, Right : Unsigned_Word) return Unsigned_Word;\n-\n-   function To_Unsigned_Word (X : Bit_Array_16) return Unsigned_Word;\n-   function To_Bit_Array_16  (X : Unsigned_Word) return Bit_Array_16;\n-\n-   type Unsigned_Word_Array is array (Integer range <>) of Unsigned_Word;\n-\n-   type Unsigned_Longword is range -2_147_483_648 .. 2_147_483_647;\n-   for  Unsigned_Longword'Size use 32;\n-\n-   function \"not\" (Left        : Unsigned_Longword) return Unsigned_Longword;\n-   function \"and\" (Left, Right : Unsigned_Longword) return Unsigned_Longword;\n-   function \"or\"  (Left, Right : Unsigned_Longword) return Unsigned_Longword;\n-   function \"xor\" (Left, Right : Unsigned_Longword) return Unsigned_Longword;\n-\n-   function To_Unsigned_Longword (X : Bit_Array_32) return Unsigned_Longword;\n-   function To_Bit_Array_32 (X : Unsigned_Longword) return Bit_Array_32;\n-\n-   type Unsigned_Longword_Array is\n-      array (Integer range <>) of Unsigned_Longword;\n-\n-   type Unsigned_32 is range 0 .. 4_294_967_295;\n-   for  Unsigned_32'Size use 32;\n-\n-   function \"not\" (Left        : Unsigned_32) return Unsigned_32;\n-   function \"and\" (Left, Right : Unsigned_32) return Unsigned_32;\n-   function \"or\"  (Left, Right : Unsigned_32) return Unsigned_32;\n-   function \"xor\" (Left, Right : Unsigned_32) return Unsigned_32;\n-\n-   function To_Unsigned_32 (X : Bit_Array_32) return Unsigned_32;\n-   function To_Bit_Array_32 (X : Unsigned_32) return Bit_Array_32;\n-\n-   type Unsigned_Quadword is record\n-      L0 : Unsigned_Longword;\n-      L1 : Unsigned_Longword;\n-   end record;\n-\n-   for Unsigned_Quadword'Size      use 64;\n-   for Unsigned_Quadword'Alignment use\n-     Integer'Min (8, Standard'Maximum_Alignment);\n-\n-   function \"not\" (Left        : Unsigned_Quadword) return Unsigned_Quadword;\n-   function \"and\" (Left, Right : Unsigned_Quadword) return Unsigned_Quadword;\n-   function \"or\"  (Left, Right : Unsigned_Quadword) return Unsigned_Quadword;\n-   function \"xor\" (Left, Right : Unsigned_Quadword) return Unsigned_Quadword;\n-\n-   function To_Unsigned_Quadword (X : Bit_Array_64) return Unsigned_Quadword;\n-   function To_Bit_Array_64 (X : Unsigned_Quadword) return Bit_Array_64;\n-\n-   type Unsigned_Quadword_Array is\n-      array (Integer range <>) of Unsigned_Quadword;\n-\n-   function To_Address      (X : Integer)           return Short_Address;\n-   pragma Pure_Function (To_Address);\n-\n-   function To_Address_Long (X : Unsigned_Longword) return Short_Address;\n-   pragma Pure_Function (To_Address_Long);\n-\n-   function To_Integer      (X : Short_Address)     return Integer;\n-\n-   function To_Unsigned_Longword (X : Short_Address) return Unsigned_Longword;\n-   function To_Unsigned_Longword (X : AST_Handler)   return Unsigned_Longword;\n-\n-   --  Conventional names for static subtypes of type UNSIGNED_LONGWORD\n-\n-   subtype Unsigned_1  is Unsigned_Longword range 0 .. 2** 1 - 1;\n-   subtype Unsigned_2  is Unsigned_Longword range 0 .. 2** 2 - 1;\n-   subtype Unsigned_3  is Unsigned_Longword range 0 .. 2** 3 - 1;\n-   subtype Unsigned_4  is Unsigned_Longword range 0 .. 2** 4 - 1;\n-   subtype Unsigned_5  is Unsigned_Longword range 0 .. 2** 5 - 1;\n-   subtype Unsigned_6  is Unsigned_Longword range 0 .. 2** 6 - 1;\n-   subtype Unsigned_7  is Unsigned_Longword range 0 .. 2** 7 - 1;\n-   subtype Unsigned_8  is Unsigned_Longword range 0 .. 2** 8 - 1;\n-   subtype Unsigned_9  is Unsigned_Longword range 0 .. 2** 9 - 1;\n-   subtype Unsigned_10 is Unsigned_Longword range 0 .. 2**10 - 1;\n-   subtype Unsigned_11 is Unsigned_Longword range 0 .. 2**11 - 1;\n-   subtype Unsigned_12 is Unsigned_Longword range 0 .. 2**12 - 1;\n-   subtype Unsigned_13 is Unsigned_Longword range 0 .. 2**13 - 1;\n-   subtype Unsigned_14 is Unsigned_Longword range 0 .. 2**14 - 1;\n-   subtype Unsigned_15 is Unsigned_Longword range 0 .. 2**15 - 1;\n-   subtype Unsigned_16 is Unsigned_Longword range 0 .. 2**16 - 1;\n-   subtype Unsigned_17 is Unsigned_Longword range 0 .. 2**17 - 1;\n-   subtype Unsigned_18 is Unsigned_Longword range 0 .. 2**18 - 1;\n-   subtype Unsigned_19 is Unsigned_Longword range 0 .. 2**19 - 1;\n-   subtype Unsigned_20 is Unsigned_Longword range 0 .. 2**20 - 1;\n-   subtype Unsigned_21 is Unsigned_Longword range 0 .. 2**21 - 1;\n-   subtype Unsigned_22 is Unsigned_Longword range 0 .. 2**22 - 1;\n-   subtype Unsigned_23 is Unsigned_Longword range 0 .. 2**23 - 1;\n-   subtype Unsigned_24 is Unsigned_Longword range 0 .. 2**24 - 1;\n-   subtype Unsigned_25 is Unsigned_Longword range 0 .. 2**25 - 1;\n-   subtype Unsigned_26 is Unsigned_Longword range 0 .. 2**26 - 1;\n-   subtype Unsigned_27 is Unsigned_Longword range 0 .. 2**27 - 1;\n-   subtype Unsigned_28 is Unsigned_Longword range 0 .. 2**28 - 1;\n-   subtype Unsigned_29 is Unsigned_Longword range 0 .. 2**29 - 1;\n-   subtype Unsigned_30 is Unsigned_Longword range 0 .. 2**30 - 1;\n-   subtype Unsigned_31 is Unsigned_Longword range 0 .. 2**31 - 1;\n-\n-   --  Function for obtaining global symbol values\n-\n-   function Import_Value         (Symbol : String) return Unsigned_Longword;\n-   function Import_Address       (Symbol : String) return Address;\n-   function Import_Largest_Value (Symbol : String) return Largest_Integer;\n-\n-   pragma Import (Intrinsic, Import_Value);\n-   pragma Import (Intrinsic, Import_Address);\n-   pragma Import (Intrinsic, Import_Largest_Value);\n-\n-   --  For the following declarations, note that the declaration without a\n-   --  Retry_Count parameter means to retry infinitely. A value of zero for\n-   --  the Retry_Count parameter means do not retry.\n-\n-   --  Interlocked-instruction procedures\n-\n-   procedure Clear_Interlocked\n-     (Bit       : in out Boolean;\n-      Old_Value : out Boolean);\n-\n-   procedure Set_Interlocked\n-     (Bit       : in out Boolean;\n-      Old_Value : out Boolean);\n-\n-   type Aligned_Word is record\n-      Value : Short_Integer;\n-   end record;\n-\n-   for Aligned_Word'Alignment use Integer'Min (2, Standard'Maximum_Alignment);\n-\n-   procedure Clear_Interlocked\n-     (Bit          : in out Boolean;\n-      Old_Value    : out Boolean;\n-      Retry_Count  : Natural;\n-      Success_Flag : out Boolean);\n-\n-   procedure Set_Interlocked\n-     (Bit          : in out Boolean;\n-      Old_Value    : out Boolean;\n-      Retry_Count  : Natural;\n-      Success_Flag : out Boolean);\n-\n-   procedure Add_Interlocked\n-     (Addend       : Short_Integer;\n-      Augend       : in out Aligned_Word;\n-      Sign         : out Integer);\n-\n-   type Aligned_Integer is record\n-      Value : Integer;\n-   end record;\n-\n-   for Aligned_Integer'Alignment use\n-     Integer'Min (4, Standard'Maximum_Alignment);\n-\n-   type Aligned_Long_Integer is record\n-      Value : Long_Integer;\n-   end record;\n-\n-   for Aligned_Long_Integer'Alignment use\n-     Integer'Min (8, Standard'Maximum_Alignment);\n-\n-   --  For the following declarations, note that the declaration without a\n-   --  Retry_Count parameter mean to retry infinitely. A value of zero for\n-   --  the Retry_Count means do not retry.\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Integer;\n-      Amount       : Integer);\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Integer;\n-      Amount       : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean);\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      Amount       : Long_Integer);\n-\n-   procedure Add_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      Amount       : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean);\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer);\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean);\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer);\n-\n-   procedure And_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean);\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer);\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Integer;\n-      From         : Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Integer;\n-      Success_Flag : out Boolean);\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer);\n-\n-   procedure Or_Atomic\n-     (To           : in out Aligned_Long_Integer;\n-      From         : Long_Integer;\n-      Retry_Count  : Natural;\n-      Old_Value    : out Long_Integer;\n-      Success_Flag : out Boolean);\n-\n-   type Insq_Status is (Fail_No_Lock, OK_Not_First, OK_First);\n-\n-   for Insq_Status use\n-     (Fail_No_Lock => -1,\n-      OK_Not_First =>  0,\n-      OK_First     => +1);\n-\n-   type Remq_Status is (\n-     Fail_No_Lock,\n-     Fail_Was_Empty,\n-     OK_Not_Empty,\n-     OK_Empty);\n-\n-   for Remq_Status use\n-     (Fail_No_Lock   => -1,\n-      Fail_Was_Empty =>  0,\n-      OK_Not_Empty   => +1,\n-      OK_Empty       => +2);\n-\n-   procedure Insqhi\n-     (Item   : Address;\n-      Header : Address;\n-      Status : out Insq_Status);\n-\n-   procedure Remqhi\n-     (Header : Address;\n-      Item   : out Address;\n-      Status : out Remq_Status);\n-\n-   procedure Insqti\n-     (Item   : Address;\n-      Header : Address;\n-      Status : out Insq_Status);\n-\n-   procedure Remqti\n-     (Header : Address;\n-      Item   : out Address;\n-      Status : out Remq_Status);\n-\n-private\n-\n-   Address_Zero : constant Address := Null_Address;\n-   No_Addr      : constant Address := Null_Address;\n-\n-   --  An AST_Handler value is from a typing point of view simply a pointer\n-   --  to a procedure taking a single 64 bit parameter. However, this\n-   --  is a bit misleading, because the data that this pointer references is\n-   --  highly stylized. See body of System.AST_Handling for full details.\n-\n-   type AST_Handler is access procedure (Param : Long_Integer);\n-   No_AST_Handler : constant AST_Handler := null;\n-\n-   --  Other operators have incorrect profiles. It would be nice to make\n-   --  them intrinsic, since the backend can handle them, but the front\n-   --  end is not prepared to deal with them, so at least inline them.\n-\n-   pragma Import (Intrinsic, \"not\");\n-   pragma Import (Intrinsic, \"and\");\n-   pragma Import (Intrinsic, \"or\");\n-   pragma Import (Intrinsic, \"xor\");\n-\n-   --  Other inlined subprograms\n-\n-   pragma Inline_Always (Fetch_From_Address);\n-   pragma Inline_Always (Assign_To_Address);\n-\n-   --  Synchronization related subprograms. Mechanism is explicitly set\n-   --  so that the critical parameters are passed by reference.\n-   --  Without this, the parameters are passed by copy, creating load/store\n-   --  race conditions. We also inline them, since this seems more in the\n-   --  spirit of the original (hardware intrinsic) routines.\n-\n-   pragma Export_Procedure\n-     (Clear_Interlocked,\n-      External        => \"system__aux_dec__clear_interlocked__1\",\n-      Parameter_Types => (Boolean, Boolean),\n-      Mechanism       => (Reference, Reference));\n-   pragma Export_Procedure\n-     (Clear_Interlocked,\n-      External        => \"system__aux_dec__clear_interlocked__2\",\n-      Parameter_Types => (Boolean, Boolean, Natural, Boolean),\n-      Mechanism       => (Reference, Reference, Value, Reference));\n-   pragma Inline_Always (Clear_Interlocked);\n-\n-   pragma Export_Procedure\n-     (Set_Interlocked,\n-      External        => \"system__aux_dec__set_interlocked__1\",\n-      Parameter_Types => (Boolean, Boolean),\n-      Mechanism       => (Reference, Reference));\n-   pragma Export_Procedure\n-     (Set_Interlocked,\n-      External        => \"system__aux_dec__set_interlocked__2\",\n-      Parameter_Types => (Boolean, Boolean, Natural, Boolean),\n-      Mechanism       => (Reference, Reference, Value, Reference));\n-   pragma Inline_Always (Set_Interlocked);\n-\n-   pragma Export_Procedure\n-     (Add_Interlocked,\n-      External        => \"system__aux_dec__add_interlocked__1\",\n-      Mechanism       => (Value, Reference, Reference));\n-   pragma Inline_Always (Add_Interlocked);\n-\n-   pragma Export_Procedure\n-     (Add_Atomic,\n-      External        => \"system__aux_dec__add_atomic__1\",\n-      Parameter_Types => (Aligned_Integer, Integer),\n-      Mechanism       => (Reference, Value));\n-   pragma Export_Procedure\n-     (Add_Atomic,\n-      External        => \"system__aux_dec__add_atomic__2\",\n-      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n-      Mechanism       => (Reference, Value, Value, Reference, Reference));\n-   pragma Export_Procedure\n-     (Add_Atomic,\n-      External        => \"system__aux_dec__add_atomic__3\",\n-      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n-      Mechanism       => (Reference, Value));\n-   pragma Export_Procedure\n-     (Add_Atomic,\n-      External        => \"system__aux_dec__add_atomic__4\",\n-      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n-                          Long_Integer, Boolean),\n-      Mechanism       => (Reference, Value, Value, Reference, Reference));\n-   pragma Inline_Always (Add_Atomic);\n-\n-   pragma Export_Procedure\n-     (And_Atomic,\n-      External        => \"system__aux_dec__and_atomic__1\",\n-      Parameter_Types => (Aligned_Integer, Integer),\n-      Mechanism       => (Reference, Value));\n-   pragma Export_Procedure\n-     (And_Atomic,\n-      External        => \"system__aux_dec__and_atomic__2\",\n-      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n-      Mechanism       => (Reference, Value, Value, Reference, Reference));\n-   pragma Export_Procedure\n-     (And_Atomic,\n-      External        => \"system__aux_dec__and_atomic__3\",\n-      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n-      Mechanism       => (Reference, Value));\n-   pragma Export_Procedure\n-     (And_Atomic,\n-      External        => \"system__aux_dec__and_atomic__4\",\n-      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n-                          Long_Integer, Boolean),\n-      Mechanism       => (Reference, Value, Value, Reference, Reference));\n-   pragma Inline_Always (And_Atomic);\n-\n-   pragma Export_Procedure\n-     (Or_Atomic,\n-      External        => \"system__aux_dec__or_atomic__1\",\n-      Parameter_Types => (Aligned_Integer, Integer),\n-      Mechanism       => (Reference, Value));\n-   pragma Export_Procedure\n-     (Or_Atomic,\n-      External        => \"system__aux_dec__or_atomic__2\",\n-      Parameter_Types => (Aligned_Integer, Integer, Natural, Integer, Boolean),\n-      Mechanism       => (Reference, Value, Value, Reference, Reference));\n-   pragma Export_Procedure\n-     (Or_Atomic,\n-      External        => \"system__aux_dec__or_atomic__3\",\n-      Parameter_Types => (Aligned_Long_Integer, Long_Integer),\n-      Mechanism       => (Reference, Value));\n-   pragma Export_Procedure\n-     (Or_Atomic,\n-      External        => \"system__aux_dec__or_atomic__4\",\n-      Parameter_Types => (Aligned_Long_Integer, Long_Integer, Natural,\n-                          Long_Integer, Boolean),\n-      Mechanism       => (Reference, Value, Value, Reference, Reference));\n-   pragma Inline_Always (Or_Atomic);\n-\n-   --  Inline the VAX Queue Functions\n-\n-   pragma Inline_Always (Insqhi);\n-   pragma Inline_Always (Remqhi);\n-   pragma Inline_Always (Insqti);\n-   pragma Inline_Always (Remqti);\n-\n-   --  Provide proper unchecked conversion definitions for transfer\n-   --  functions. Note that we need this level of indirection because\n-   --  the formal parameter name is X and not Source (and this is indeed\n-   --  detectable by a program)\n-\n-   function To_Unsigned_Byte_A is new\n-     Ada.Unchecked_Conversion (Bit_Array_8, Unsigned_Byte);\n-\n-   function To_Unsigned_Byte (X : Bit_Array_8) return Unsigned_Byte\n-     renames To_Unsigned_Byte_A;\n-\n-   function To_Bit_Array_8_A is new\n-     Ada.Unchecked_Conversion (Unsigned_Byte, Bit_Array_8);\n-\n-   function To_Bit_Array_8 (X : Unsigned_Byte) return Bit_Array_8\n-     renames To_Bit_Array_8_A;\n-\n-   function To_Unsigned_Word_A is new\n-     Ada.Unchecked_Conversion (Bit_Array_16, Unsigned_Word);\n-\n-   function To_Unsigned_Word (X : Bit_Array_16) return Unsigned_Word\n-     renames To_Unsigned_Word_A;\n-\n-   function To_Bit_Array_16_A is new\n-     Ada.Unchecked_Conversion (Unsigned_Word, Bit_Array_16);\n-\n-   function To_Bit_Array_16 (X : Unsigned_Word) return Bit_Array_16\n-     renames To_Bit_Array_16_A;\n-\n-   function To_Unsigned_Longword_A is new\n-     Ada.Unchecked_Conversion (Bit_Array_32, Unsigned_Longword);\n-\n-   function To_Unsigned_Longword (X : Bit_Array_32) return Unsigned_Longword\n-     renames To_Unsigned_Longword_A;\n-\n-   function To_Bit_Array_32_A is new\n-     Ada.Unchecked_Conversion (Unsigned_Longword, Bit_Array_32);\n-\n-   function To_Bit_Array_32 (X : Unsigned_Longword) return Bit_Array_32\n-     renames To_Bit_Array_32_A;\n-\n-   function To_Unsigned_32_A is new\n-     Ada.Unchecked_Conversion (Bit_Array_32, Unsigned_32);\n-\n-   function To_Unsigned_32 (X : Bit_Array_32) return Unsigned_32\n-     renames To_Unsigned_32_A;\n-\n-   function To_Bit_Array_32_A is new\n-     Ada.Unchecked_Conversion (Unsigned_32, Bit_Array_32);\n-\n-   function To_Bit_Array_32 (X : Unsigned_32) return Bit_Array_32\n-     renames To_Bit_Array_32_A;\n-\n-   function To_Unsigned_Quadword_A is new\n-     Ada.Unchecked_Conversion (Bit_Array_64, Unsigned_Quadword);\n-\n-   function To_Unsigned_Quadword (X : Bit_Array_64) return Unsigned_Quadword\n-     renames To_Unsigned_Quadword_A;\n-\n-   function To_Bit_Array_64_A is new\n-     Ada.Unchecked_Conversion (Unsigned_Quadword, Bit_Array_64);\n-\n-   function To_Bit_Array_64 (X : Unsigned_Quadword) return Bit_Array_64\n-     renames To_Bit_Array_64_A;\n-\n-   pragma Warnings (Off);\n-   --  Turn warnings off. This is needed for systems with 64-bit integers,\n-   --  where some of these operations are of dubious meaning, but we do not\n-   --  want warnings when we compile on such systems.\n-\n-   function To_Address_A is new\n-     Ada.Unchecked_Conversion (Integer, Short_Address);\n-   pragma Pure_Function (To_Address_A);\n-\n-   function To_Address (X : Integer) return Short_Address\n-     renames To_Address_A;\n-   pragma Pure_Function (To_Address);\n-\n-   function To_Address_Long_A is new\n-     Ada.Unchecked_Conversion (Unsigned_Longword, Short_Address);\n-   pragma Pure_Function (To_Address_Long_A);\n-\n-   function To_Address_Long (X : Unsigned_Longword) return Short_Address\n-     renames To_Address_Long_A;\n-   pragma Pure_Function (To_Address_Long);\n-\n-   function To_Integer_A is new\n-     Ada.Unchecked_Conversion (Short_Address, Integer);\n-\n-   function To_Integer (X : Short_Address) return Integer\n-     renames To_Integer_A;\n-\n-   function To_Unsigned_Longword_A is new\n-     Ada.Unchecked_Conversion (Short_Address, Unsigned_Longword);\n-\n-   function To_Unsigned_Longword (X : Short_Address) return Unsigned_Longword\n-     renames To_Unsigned_Longword_A;\n-\n-   function To_Unsigned_Longword_A is new\n-     Ada.Unchecked_Conversion (AST_Handler, Unsigned_Longword);\n-\n-   function To_Unsigned_Longword (X : AST_Handler) return Unsigned_Longword\n-     renames To_Unsigned_Longword_A;\n-\n-   pragma Warnings (On);\n-\n-end System.Aux_DEC;"}, {"sha": "b99b155f38c8e3fc737426d419bde181623b948b", "filename": "gcc/ada/s-inmaop-vms.adb", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-inmaop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-inmaop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,303 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                  SYSTEM.INTERRUPT_MANAGEMENT.OPERATIONS                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/Alpha version of this package\n-\n-with System.OS_Interface;\n-with System.Aux_DEC;\n-with System.Parameters;\n-with System.Tasking;\n-with System.Tasking.Initialization;\n-with System.Task_Primitives;\n-with System.Task_Primitives.Operations;\n-with System.Task_Primitives.Operations.DEC;\n-\n-with Ada.Unchecked_Conversion;\n-\n-package body System.Interrupt_Management.Operations is\n-\n-   use System.OS_Interface;\n-   use System.Parameters;\n-   use System.Tasking;\n-   use type unsigned_short;\n-\n-   function To_Address is\n-     new Ada.Unchecked_Conversion\n-       (Task_Id, System.Task_Primitives.Task_Address);\n-\n-   package POP renames System.Task_Primitives.Operations;\n-\n-   ----------------------------\n-   -- Thread_Block_Interrupt --\n-   ----------------------------\n-\n-   procedure Thread_Block_Interrupt (Interrupt : Interrupt_ID) is\n-      pragma Warnings (Off, Interrupt);\n-   begin\n-      null;\n-   end Thread_Block_Interrupt;\n-\n-   ------------------------------\n-   -- Thread_Unblock_Interrupt --\n-   ------------------------------\n-\n-   procedure Thread_Unblock_Interrupt (Interrupt : Interrupt_ID) is\n-      pragma Warnings (Off, Interrupt);\n-   begin\n-      null;\n-   end Thread_Unblock_Interrupt;\n-\n-   ------------------------\n-   -- Set_Interrupt_Mask --\n-   ------------------------\n-\n-   procedure Set_Interrupt_Mask (Mask : access Interrupt_Mask) is\n-      pragma Warnings (Off, Mask);\n-   begin\n-      null;\n-   end Set_Interrupt_Mask;\n-\n-   procedure Set_Interrupt_Mask\n-     (Mask  : access Interrupt_Mask;\n-      OMask : access Interrupt_Mask)\n-   is\n-      pragma Warnings (Off, Mask);\n-      pragma Warnings (Off, OMask);\n-   begin\n-      null;\n-   end Set_Interrupt_Mask;\n-\n-   ------------------------\n-   -- Get_Interrupt_Mask --\n-   ------------------------\n-\n-   procedure Get_Interrupt_Mask (Mask : access Interrupt_Mask) is\n-      pragma Warnings (Off, Mask);\n-   begin\n-      null;\n-   end Get_Interrupt_Mask;\n-\n-   --------------------\n-   -- Interrupt_Wait --\n-   --------------------\n-\n-   function To_unsigned_long is new\n-     Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, unsigned_long);\n-\n-   function Interrupt_Wait (Mask : access Interrupt_Mask)\n-     return Interrupt_ID\n-   is\n-      Self_ID : constant Task_Id := Self;\n-      Iosb    : IO_Status_Block_Type := (0, 0, 0);\n-      Status  : Cond_Value_Type;\n-\n-   begin\n-\n-      --  A QIO read is registered. The system call returns immediately\n-      --  after scheduling an AST to be fired when the operation\n-      --  completes.\n-\n-      Sys_QIO\n-        (Status => Status,\n-         Chan   => Rcv_Interrupt_Chan,\n-         Func   => IO_READVBLK,\n-         Iosb   => Iosb,\n-         Astadr =>\n-           POP.DEC.Interrupt_AST_Handler'Access,\n-         Astprm => To_Address (Self_ID),\n-         P1     => To_unsigned_long (Interrupt_Mailbox'Address),\n-         P2     => Interrupt_ID'Size / 8);\n-\n-      pragma Assert ((Status and 1) = 1);\n-\n-      loop\n-\n-         --  Wait to be woken up. Could be that the AST has fired,\n-         --  in which case the Iosb.Status variable will be non-zero,\n-         --  or maybe the wait is being aborted.\n-\n-         POP.Sleep\n-           (Self_ID,\n-            System.Tasking.Interrupt_Server_Blocked_On_Event_Flag);\n-\n-         if Iosb.Status /= 0 then\n-            if (Iosb.Status and 1) = 1\n-              and then Mask (Signal (Interrupt_Mailbox))\n-            then\n-               return Interrupt_Mailbox;\n-            else\n-               return 0;\n-            end if;\n-         else\n-            POP.Unlock (Self_ID);\n-\n-            if Single_Lock then\n-               POP.Unlock_RTS;\n-            end if;\n-\n-            System.Tasking.Initialization.Undefer_Abort (Self_ID);\n-            System.Tasking.Initialization.Defer_Abort (Self_ID);\n-\n-            if Single_Lock then\n-               POP.Lock_RTS;\n-            end if;\n-\n-            POP.Write_Lock (Self_ID);\n-         end if;\n-      end loop;\n-   end Interrupt_Wait;\n-\n-   ----------------------------\n-   -- Install_Default_Action --\n-   ----------------------------\n-\n-   procedure Install_Default_Action (Interrupt : Interrupt_ID) is\n-      pragma Warnings (Off, Interrupt);\n-   begin\n-      null;\n-   end Install_Default_Action;\n-\n-   ---------------------------\n-   -- Install_Ignore_Action --\n-   ---------------------------\n-\n-   procedure Install_Ignore_Action (Interrupt : Interrupt_ID) is\n-      pragma Warnings (Off, Interrupt);\n-   begin\n-      null;\n-   end Install_Ignore_Action;\n-\n-   -------------------------\n-   -- Fill_Interrupt_Mask --\n-   -------------------------\n-\n-   procedure Fill_Interrupt_Mask (Mask : access Interrupt_Mask) is\n-   begin\n-      Mask.all := (others => True);\n-   end Fill_Interrupt_Mask;\n-\n-   --------------------------\n-   -- Empty_Interrupt_Mask --\n-   --------------------------\n-\n-   procedure Empty_Interrupt_Mask (Mask : access Interrupt_Mask) is\n-   begin\n-      Mask.all := (others => False);\n-   end Empty_Interrupt_Mask;\n-\n-   ---------------------------\n-   -- Add_To_Interrupt_Mask --\n-   ---------------------------\n-\n-   procedure Add_To_Interrupt_Mask\n-     (Mask      : access Interrupt_Mask;\n-      Interrupt : Interrupt_ID)\n-   is\n-   begin\n-      Mask (Signal (Interrupt)) := True;\n-   end Add_To_Interrupt_Mask;\n-\n-   --------------------------------\n-   -- Delete_From_Interrupt_Mask --\n-   --------------------------------\n-\n-   procedure Delete_From_Interrupt_Mask\n-     (Mask      : access Interrupt_Mask;\n-      Interrupt : Interrupt_ID)\n-   is\n-   begin\n-      Mask (Signal (Interrupt)) := False;\n-   end Delete_From_Interrupt_Mask;\n-\n-   ---------------\n-   -- Is_Member --\n-   ---------------\n-\n-   function Is_Member\n-     (Mask      : access Interrupt_Mask;\n-      Interrupt : Interrupt_ID) return Boolean\n-   is\n-   begin\n-      return Mask (Signal (Interrupt));\n-   end Is_Member;\n-\n-   -------------------------\n-   -- Copy_Interrupt_Mask --\n-   -------------------------\n-\n-   procedure Copy_Interrupt_Mask\n-     (X : out Interrupt_Mask;\n-      Y : Interrupt_Mask)\n-   is\n-   begin\n-      X := Y;\n-   end Copy_Interrupt_Mask;\n-\n-   ----------------------------\n-   -- Interrupt_Self_Process --\n-   ----------------------------\n-\n-   procedure Interrupt_Self_Process (Interrupt : Interrupt_ID) is\n-      Status : Cond_Value_Type;\n-   begin\n-      Sys_QIO\n-        (Status => Status,\n-         Chan   => Snd_Interrupt_Chan,\n-         Func   => IO_WRITEVBLK,\n-         P1     => To_unsigned_long (Interrupt'Address),\n-         P2     => Interrupt_ID'Size / 8);\n-\n-      --  The following could use a comment ???\n-\n-      pragma Assert ((Status and 1) = 1);\n-   end Interrupt_Self_Process;\n-\n-   --------------------------\n-   -- Setup_Interrupt_Mask --\n-   --------------------------\n-\n-   procedure Setup_Interrupt_Mask is\n-   begin\n-      null;\n-   end Setup_Interrupt_Mask;\n-\n-begin\n-   Interrupt_Management.Initialize;\n-   Environment_Mask := (others => False);\n-   All_Tasks_Mask := (others => True);\n-\n-   for J in Interrupt_ID loop\n-      if Keep_Unmasked (J) then\n-         Environment_Mask (Signal (J)) := True;\n-         All_Tasks_Mask (Signal (J)) := False;\n-      end if;\n-   end loop;\n-end System.Interrupt_Management.Operations;"}, {"sha": "1fc141f62e6aa5a99c30464eca09499ced05e728", "filename": "gcc/ada/s-interr-vms.adb", "status": "removed", "additions": 0, "deletions": 1128, "changes": 1128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-interr-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-interr-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,1128 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                     S Y S T E M . I N T E R R U P T S                    --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is an OpenVMS/Alpha version of this package\n-\n---  Invariants:\n-\n---  Once we associate a Server_Task with an interrupt, the task never\n---  goes away, and we never remove the association.\n-\n---  There is no more than one interrupt per Server_Task and no more than\n---  one Server_Task per interrupt.\n-\n---  Within this package, the lock L is used to protect the various status\n---  tables. If there is a Server_Task associated with an interrupt, we use\n---  the per-task lock of the Server_Task instead so that we protect the\n---  status between Interrupt_Manager and Server_Task. Protection among\n---  service requests are done using User Request to Interrupt_Manager\n---  rendezvous.\n-\n-with Ada.Task_Identification;\n-with Ada.Unchecked_Conversion;\n-\n-with System.Task_Primitives;\n-with System.Interrupt_Management;\n-\n-with System.Interrupt_Management.Operations;\n-pragma Elaborate_All (System.Interrupt_Management.Operations);\n-\n-with System.Task_Primitives.Operations;\n-with System.Task_Primitives.Interrupt_Operations;\n-with System.Storage_Elements;\n-with System.Tasking.Utilities;\n-\n-with System.Tasking.Rendezvous;\n-pragma Elaborate_All (System.Tasking.Rendezvous);\n-\n-with System.Tasking.Initialization;\n-with System.Parameters;\n-\n-package body System.Interrupts is\n-\n-   use Tasking;\n-   use System.Parameters;\n-\n-   package POP renames System.Task_Primitives.Operations;\n-   package PIO renames System.Task_Primitives.Interrupt_Operations;\n-   package IMNG renames System.Interrupt_Management;\n-   package IMOP renames System.Interrupt_Management.Operations;\n-\n-   function To_System is new Ada.Unchecked_Conversion\n-     (Ada.Task_Identification.Task_Id, Task_Id);\n-\n-   -----------------\n-   -- Local Tasks --\n-   -----------------\n-\n-   --  WARNING: System.Tasking.Stages performs calls to this task with\n-   --  low-level constructs. Do not change this spec without synchronizing it.\n-\n-   task Interrupt_Manager is\n-      entry Detach_Interrupt_Entries (T : Task_Id);\n-\n-      entry Initialize (Mask : IMNG.Interrupt_Mask);\n-\n-      entry Attach_Handler\n-        (New_Handler : Parameterless_Handler;\n-         Interrupt   : Interrupt_ID;\n-         Static      : Boolean;\n-         Restoration : Boolean := False);\n-\n-      entry Exchange_Handler\n-        (Old_Handler : out Parameterless_Handler;\n-         New_Handler : Parameterless_Handler;\n-         Interrupt   : Interrupt_ID;\n-         Static      : Boolean);\n-\n-      entry Detach_Handler\n-        (Interrupt : Interrupt_ID;\n-         Static    : Boolean);\n-\n-      entry Bind_Interrupt_To_Entry\n-        (T         : Task_Id;\n-         E         : Task_Entry_Index;\n-         Interrupt : Interrupt_ID);\n-\n-      entry Block_Interrupt (Interrupt : Interrupt_ID);\n-\n-      entry Unblock_Interrupt (Interrupt : Interrupt_ID);\n-\n-      entry Ignore_Interrupt (Interrupt : Interrupt_ID);\n-\n-      entry Unignore_Interrupt (Interrupt : Interrupt_ID);\n-\n-      pragma Interrupt_Priority (System.Interrupt_Priority'Last);\n-   end Interrupt_Manager;\n-\n-   task type Server_Task (Interrupt : Interrupt_ID) is\n-      pragma Priority (System.Interrupt_Priority'Last);\n-      --  Note: the above pragma Priority is strictly speaking improper since\n-      --  it is outside the range of allowed priorities, but the compiler\n-      --  treats system units specially and does not apply this range checking\n-      --  rule to system units.\n-\n-   end Server_Task;\n-\n-   type Server_Task_Access is access Server_Task;\n-\n-   -------------------------------\n-   -- Local Types and Variables --\n-   -------------------------------\n-\n-   type Entry_Assoc is record\n-      T : Task_Id;\n-      E : Task_Entry_Index;\n-   end record;\n-\n-   type Handler_Assoc is record\n-      H      : Parameterless_Handler;\n-      Static : Boolean;   --  Indicates static binding;\n-   end record;\n-\n-   User_Handler : array (Interrupt_ID'Range) of Handler_Assoc :=\n-                    (others => (null, Static => False));\n-   pragma Volatile_Components (User_Handler);\n-   --  Holds the protected procedure handler (if any) and its Static\n-   --  information for each interrupt. A handler is a Static one if it is\n-   --  specified through the pragma Attach_Handler. Attach_Handler. Otherwise,\n-   --  not static)\n-\n-   User_Entry : array (Interrupt_ID'Range) of Entry_Assoc :=\n-                  (others => (T => Null_Task, E => Null_Task_Entry));\n-   pragma Volatile_Components (User_Entry);\n-   --  Holds the task and entry index (if any) for each interrupt\n-\n-   Blocked : constant array (Interrupt_ID'Range) of Boolean :=\n-     (others => False);\n-   --  ??? pragma Volatile_Components (Blocked);\n-   --  True iff the corresponding interrupt is blocked in the process level\n-\n-   Ignored : array (Interrupt_ID'Range) of Boolean := (others => False);\n-   pragma Volatile_Components (Ignored);\n-   --  True iff the corresponding interrupt is blocked in the process level\n-\n-   Last_Unblocker : constant array (Interrupt_ID'Range) of Task_Id :=\n-     (others => Null_Task);\n-   --  ??? pragma Volatile_Components (Last_Unblocker);\n-   --  Holds the ID of the last Task which Unblocked this Interrupt. It\n-   --  contains Null_Task if no tasks have ever requested the Unblocking\n-   --  operation or the Interrupt is currently Blocked.\n-\n-   Server_ID : array (Interrupt_ID'Range) of Task_Id :=\n-                 (others => Null_Task);\n-   pragma Atomic_Components (Server_ID);\n-   --  Holds the Task_Id of the Server_Task for each interrupt. Task_Id is\n-   --  needed to accomplish locking per Interrupt base. Also is needed to\n-   --  decide whether to create a new Server_Task.\n-\n-   --  Type and Head, Tail of the list containing Registered Interrupt\n-   --  Handlers. These definitions are used to register the handlers\n-   --  specified by the pragma Interrupt_Handler.\n-\n-   type Registered_Handler;\n-   type R_Link is access all Registered_Handler;\n-\n-   type Registered_Handler is record\n-      H :    System.Address := System.Null_Address;\n-      Next : R_Link := null;\n-   end record;\n-\n-   Registered_Handler_Head : R_Link := null;\n-   Registered_Handler_Tail : R_Link := null;\n-\n-   Access_Hold : Server_Task_Access;\n-   --  variable used to allocate Server_Task using \"new\"\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Is_Registered (Handler : Parameterless_Handler) return Boolean;\n-   --  See if the Handler has been \"pragma\"ed using Interrupt_Handler.\n-   --  Always consider a null handler as registered.\n-\n-   --------------------------------\n-   -- Register_Interrupt_Handler --\n-   --------------------------------\n-\n-   procedure Register_Interrupt_Handler (Handler_Addr : System.Address) is\n-      New_Node_Ptr : R_Link;\n-\n-   begin\n-      --  This routine registers the Handler as usable for Dynamic Interrupt\n-      --  Handler. Routines attaching and detaching Handler dynamically should\n-      --  first consult if the Handler is registered. A Program Error should be\n-      --  raised if it is not registered.\n-\n-      --  The pragma Interrupt_Handler can only appear in the library level PO\n-      --  definition and instantiation. Therefore, we do not need to implement\n-      --  Unregistering operation. Neither we need to protect the queue\n-      --  structure using a Lock.\n-\n-      pragma Assert (Handler_Addr /= System.Null_Address);\n-\n-      New_Node_Ptr := new Registered_Handler;\n-      New_Node_Ptr.H := Handler_Addr;\n-\n-      if Registered_Handler_Head = null then\n-         Registered_Handler_Head := New_Node_Ptr;\n-         Registered_Handler_Tail := New_Node_Ptr;\n-\n-      else\n-         Registered_Handler_Tail.Next := New_Node_Ptr;\n-         Registered_Handler_Tail := New_Node_Ptr;\n-      end if;\n-   end Register_Interrupt_Handler;\n-\n-   -------------------\n-   -- Is_Registered --\n-   -------------------\n-\n-   function Is_Registered (Handler : Parameterless_Handler) return Boolean is\n-      type Fat_Ptr is record\n-         Object_Addr  : System.Address;\n-         Handler_Addr : System.Address;\n-      end record;\n-\n-      function To_Fat_Ptr is new Ada.Unchecked_Conversion\n-        (Parameterless_Handler, Fat_Ptr);\n-\n-      Ptr : R_Link;\n-      Fat : Fat_Ptr;\n-\n-   begin\n-      if Handler = null then\n-         return True;\n-      end if;\n-\n-      Fat := To_Fat_Ptr (Handler);\n-\n-      Ptr := Registered_Handler_Head;\n-      while Ptr /= null loop\n-         if Ptr.H = Fat.Handler_Addr then\n-            return True;\n-         end if;\n-\n-         Ptr := Ptr.Next;\n-      end loop;\n-\n-      return False;\n-   end Is_Registered;\n-\n-   -----------------\n-   -- Is_Reserved --\n-   -----------------\n-\n-   function Is_Reserved (Interrupt : Interrupt_ID) return Boolean is\n-   begin\n-      return IMNG.Reserve (IMNG.Interrupt_ID (Interrupt));\n-   end Is_Reserved;\n-\n-   -----------------------\n-   -- Is_Entry_Attached --\n-   -----------------------\n-\n-   function Is_Entry_Attached (Interrupt : Interrupt_ID) return Boolean is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      return User_Entry (Interrupt).T /= Null_Task;\n-   end Is_Entry_Attached;\n-\n-   -------------------------\n-   -- Is_Handler_Attached --\n-   -------------------------\n-\n-   function Is_Handler_Attached (Interrupt : Interrupt_ID) return Boolean is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      return User_Handler (Interrupt).H /= null;\n-   end Is_Handler_Attached;\n-\n-   ----------------\n-   -- Is_Blocked --\n-   ----------------\n-\n-   function Is_Blocked (Interrupt : Interrupt_ID) return Boolean is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      return Blocked (Interrupt);\n-   end Is_Blocked;\n-\n-   ----------------\n-   -- Is_Ignored --\n-   ----------------\n-\n-   function Is_Ignored (Interrupt : Interrupt_ID) return Boolean is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      return Ignored (Interrupt);\n-   end Is_Ignored;\n-\n-   ---------------------\n-   -- Current_Handler --\n-   ---------------------\n-\n-   function Current_Handler\n-     (Interrupt : Interrupt_ID) return Parameterless_Handler\n-   is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      --  ??? Since Parameterless_Handler is not Atomic, the current\n-      --  implementation is wrong. We need a new service in Interrupt_Manager\n-      --  to ensure atomicity.\n-\n-      return User_Handler (Interrupt).H;\n-   end Current_Handler;\n-\n-   --------------------\n-   -- Attach_Handler --\n-   --------------------\n-\n-   --  Calling this procedure with New_Handler = null and Static = True\n-   --  means we want to detach the current handler regardless of the previous\n-   --  handler's binding status (i.e. we do not care if it is a dynamic or\n-   --  static handler).\n-\n-   --  This option is needed so that during the finalization of a PO, we\n-   --  can detach handlers attached through pragma Attach_Handler.\n-\n-   procedure Attach_Handler\n-     (New_Handler : Parameterless_Handler;\n-      Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False)\n-   is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Attach_Handler (New_Handler, Interrupt, Static);\n-   end Attach_Handler;\n-\n-   ----------------------\n-   -- Exchange_Handler --\n-   ----------------------\n-\n-   --  Calling this procedure with New_Handler = null and Static = True means\n-   --  we want to detach the current handler regardless of the previous\n-   --  handler's binding status (i.e. do not care if it is dynamic or static\n-   --  handler).\n-\n-   --  This option is needed so that during the finalization of a PO, we can\n-   --  detach handlers attached through pragma Attach_Handler.\n-\n-   procedure Exchange_Handler\n-     (Old_Handler : out Parameterless_Handler;\n-      New_Handler : Parameterless_Handler;\n-      Interrupt   : Interrupt_ID;\n-      Static      : Boolean := False)\n-   is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Exchange_Handler\n-        (Old_Handler, New_Handler, Interrupt, Static);\n-   end Exchange_Handler;\n-\n-   --------------------\n-   -- Detach_Handler --\n-   --------------------\n-\n-   --  Calling this procedure with Static = True means we want to Detach the\n-   --  current handler regardless of the previous handler's binding status\n-   --  (i.e. do not care if it is a dynamic or static handler).\n-\n-   --  This option is needed so that during the finalization of a PO, we can\n-   --  detach handlers attached through pragma Attach_Handler.\n-\n-   procedure Detach_Handler\n-     (Interrupt : Interrupt_ID;\n-      Static    : Boolean := False)\n-   is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Detach_Handler (Interrupt, Static);\n-   end Detach_Handler;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference (Interrupt : Interrupt_ID) return System.Address is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      return Storage_Elements.To_Address\n-               (Storage_Elements.Integer_Address (Interrupt));\n-   end Reference;\n-\n-   -----------------------------\n-   -- Bind_Interrupt_To_Entry --\n-   -----------------------------\n-\n-   --  This procedure raises a Program_Error if it tries to\n-   --  bind an interrupt to which an Entry or a Procedure is\n-   --  already bound.\n-\n-   procedure Bind_Interrupt_To_Entry\n-     (T       : Task_Id;\n-      E       : Task_Entry_Index;\n-      Int_Ref : System.Address)\n-   is\n-      Interrupt : constant Interrupt_ID :=\n-                    Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n-\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Bind_Interrupt_To_Entry (T, E, Interrupt);\n-   end Bind_Interrupt_To_Entry;\n-\n-   ------------------------------\n-   -- Detach_Interrupt_Entries --\n-   ------------------------------\n-\n-   procedure Detach_Interrupt_Entries (T : Task_Id) is\n-   begin\n-      Interrupt_Manager.Detach_Interrupt_Entries (T);\n-   end Detach_Interrupt_Entries;\n-\n-   ---------------------\n-   -- Block_Interrupt --\n-   ---------------------\n-\n-   procedure Block_Interrupt (Interrupt : Interrupt_ID) is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Block_Interrupt (Interrupt);\n-   end Block_Interrupt;\n-\n-   -----------------------\n-   -- Unblock_Interrupt --\n-   -----------------------\n-\n-   procedure Unblock_Interrupt (Interrupt : Interrupt_ID) is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Unblock_Interrupt (Interrupt);\n-   end Unblock_Interrupt;\n-\n-   ------------------\n-   -- Unblocked_By --\n-   ------------------\n-\n-   function Unblocked_By\n-     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      return Last_Unblocker (Interrupt);\n-   end Unblocked_By;\n-\n-   ----------------------\n-   -- Ignore_Interrupt --\n-   ----------------------\n-\n-   procedure Ignore_Interrupt (Interrupt : Interrupt_ID) is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Ignore_Interrupt (Interrupt);\n-   end Ignore_Interrupt;\n-\n-   ------------------------\n-   -- Unignore_Interrupt --\n-   ------------------------\n-\n-   procedure Unignore_Interrupt (Interrupt : Interrupt_ID) is\n-   begin\n-      if Is_Reserved (Interrupt) then\n-         raise Program_Error with\n-           \"Interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n-      end if;\n-\n-      Interrupt_Manager.Unignore_Interrupt (Interrupt);\n-   end Unignore_Interrupt;\n-\n-   -----------------------\n-   -- Interrupt_Manager --\n-   -----------------------\n-\n-   task body Interrupt_Manager is\n-      --  By making this task independent of master, when the process goes\n-      --  away, the Interrupt_Manager will terminate gracefully.\n-\n-      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n-\n-      --------------------\n-      -- Local Routines --\n-      --------------------\n-\n-      procedure Unprotected_Exchange_Handler\n-        (Old_Handler : out Parameterless_Handler;\n-         New_Handler : Parameterless_Handler;\n-         Interrupt   : Interrupt_ID;\n-         Static      : Boolean;\n-         Restoration : Boolean := False);\n-\n-      procedure Unprotected_Detach_Handler\n-        (Interrupt : Interrupt_ID;\n-         Static    : Boolean);\n-\n-      ----------------------------------\n-      -- Unprotected_Exchange_Handler --\n-      ----------------------------------\n-\n-      procedure Unprotected_Exchange_Handler\n-        (Old_Handler : out Parameterless_Handler;\n-         New_Handler : Parameterless_Handler;\n-         Interrupt   : Interrupt_ID;\n-         Static      : Boolean;\n-         Restoration : Boolean := False)\n-      is\n-      begin\n-         if User_Entry (Interrupt).T /= Null_Task then\n-\n-            --  In case we have an Interrupt Entry already installed.\n-            --  raise a program error. (propagate it to the caller).\n-\n-            raise Program_Error with \"an interrupt is already installed\";\n-         end if;\n-\n-         --  Note: A null handler with Static=True will pass the following\n-         --  check. That is the case when we want to Detach a handler\n-         --  regardless of the Static status of the current_Handler. We don't\n-         --  check anything if Restoration is True, since we may be detaching\n-         --  a static handler to restore a dynamic one.\n-\n-         if not Restoration and then not Static\n-\n-            --  Tries to overwrite a static Interrupt Handler with a\n-            --  dynamic Handler\n-\n-           and then (User_Handler (Interrupt).Static\n-\n-                       --  The new handler is not specified as an\n-                       --  Interrupt Handler by a pragma.\n-\n-                       or else not Is_Registered (New_Handler))\n-         then\n-            raise Program_Error with\n-              \"trying to overwrite a static interrupt handler with a \" &\n-              \"dynamic handler\";\n-         end if;\n-\n-         --  The interrupt should no longer be ignored if it was ever ignored\n-\n-         Ignored (Interrupt) := False;\n-\n-         --  Save the old handler\n-\n-         Old_Handler := User_Handler (Interrupt).H;\n-\n-         --  The new handler\n-\n-         User_Handler (Interrupt).H := New_Handler;\n-\n-         if New_Handler = null then\n-\n-            --  The null handler means we are detaching the handler\n-\n-            User_Handler (Interrupt).Static := False;\n-\n-         else\n-            User_Handler (Interrupt).Static := Static;\n-         end if;\n-\n-         --  Invoke a corresponding Server_Task if not yet created.\n-         --  Place Task_Id info in Server_ID array.\n-\n-         if Server_ID (Interrupt) = Null_Task then\n-            Access_Hold := new Server_Task (Interrupt);\n-            Server_ID (Interrupt) := To_System (Access_Hold.all'Identity);\n-         else\n-            POP.Wakeup (Server_ID (Interrupt), Interrupt_Server_Idle_Sleep);\n-         end if;\n-\n-      end Unprotected_Exchange_Handler;\n-\n-      --------------------------------\n-      -- Unprotected_Detach_Handler --\n-      --------------------------------\n-\n-      procedure Unprotected_Detach_Handler\n-        (Interrupt   : Interrupt_ID;\n-         Static      : Boolean)\n-      is\n-      begin\n-         if User_Entry (Interrupt).T /= Null_Task then\n-\n-            --  In case we have an Interrupt Entry installed, raise a program\n-            --  error, (propagate it to the caller).\n-\n-            raise Program_Error with\n-              \"an interrupt entry is already installed\";\n-         end if;\n-\n-         --  Note : Static = True will pass the following check. That is the\n-         --  case when we want to detach a handler regardless of the static\n-         --  status of the current_Handler.\n-\n-         if not Static and then User_Handler (Interrupt).Static then\n-\n-            --  Tries to detach a static Interrupt Handler, raise program error\n-\n-            raise Program_Error with\n-              \"trying to detach a static interrupt handler\";\n-         end if;\n-\n-         --  The interrupt should no longer be ignored if\n-         --  it was ever ignored.\n-\n-         Ignored (Interrupt) := False;\n-\n-         --  The new handler\n-\n-         User_Handler (Interrupt).H := null;\n-         User_Handler (Interrupt).Static := False;\n-         IMOP.Interrupt_Self_Process (IMNG.Interrupt_ID (Interrupt));\n-\n-      end Unprotected_Detach_Handler;\n-\n-   --  Start of processing for Interrupt_Manager\n-\n-   begin\n-      --  Environment task gets its own interrupt mask, saves it, and then\n-      --  masks all interrupts except the Keep_Unmasked set.\n-\n-      --  During rendezvous, the Interrupt_Manager receives the old interrupt\n-      --  mask of the environment task, and sets its own interrupt mask to that\n-      --  value.\n-\n-      --  The environment task will call the entry of Interrupt_Manager some\n-      --  during elaboration of the body of this package.\n-\n-      accept Initialize (Mask : IMNG.Interrupt_Mask) do\n-         pragma Warnings (Off, Mask);\n-         null;\n-      end Initialize;\n-\n-      --  Note: All tasks in RTS will have all the Reserve Interrupts being\n-      --  masked (except the Interrupt_Manager) and Keep_Unmasked unmasked\n-      --  when created.\n-\n-      --  Abort_Task_Interrupt is one of the Interrupt unmasked in all tasks.\n-      --  We mask the Interrupt in this particular task so that \"sigwait\" is\n-      --  possible to catch an explicitly sent Abort_Task_Interrupt from the\n-      --  Server_Tasks.\n-\n-      --  This sigwaiting is needed so that we make sure a Server_Task is out\n-      --  of its own sigwait state. This extra synchronization is necessary to\n-      --  prevent following scenarios.\n-\n-      --   1) Interrupt_Manager sends an Abort_Task_Interrupt to the\n-      --      Server_Task then changes its own interrupt mask (OS level).\n-      --      If an interrupt (corresponding to the Server_Task) arrives\n-      --      in the mean time we have the Interrupt_Manager unmasked and\n-      --      the Server_Task waiting on sigwait.\n-\n-      --   2) For unbinding handler, we install a default action in the\n-      --      Interrupt_Manager. POSIX.1c states that the result of using\n-      --      \"sigwait\" and \"sigaction\" simultaneously on the same interrupt\n-      --      is undefined. Therefore, we need to be informed from the\n-      --      Server_Task of the fact that the Server_Task is out of its\n-      --      sigwait stage.\n-\n-      loop\n-         --  A block is needed to absorb Program_Error exception\n-\n-         declare\n-            Old_Handler : Parameterless_Handler;\n-\n-         begin\n-            select\n-\n-            accept Attach_Handler\n-               (New_Handler : Parameterless_Handler;\n-                Interrupt   : Interrupt_ID;\n-                Static      : Boolean;\n-                Restoration : Boolean := False)\n-            do\n-               Unprotected_Exchange_Handler\n-                 (Old_Handler, New_Handler, Interrupt, Static, Restoration);\n-            end Attach_Handler;\n-\n-            or accept Exchange_Handler\n-               (Old_Handler : out Parameterless_Handler;\n-                New_Handler : Parameterless_Handler;\n-                Interrupt   : Interrupt_ID;\n-                Static      : Boolean)\n-            do\n-               Unprotected_Exchange_Handler\n-                 (Old_Handler, New_Handler, Interrupt, Static);\n-            end Exchange_Handler;\n-\n-            or accept Detach_Handler\n-               (Interrupt   : Interrupt_ID;\n-                Static      : Boolean)\n-            do\n-               Unprotected_Detach_Handler (Interrupt, Static);\n-            end Detach_Handler;\n-\n-            or accept Bind_Interrupt_To_Entry\n-              (T       : Task_Id;\n-               E       : Task_Entry_Index;\n-               Interrupt : Interrupt_ID)\n-            do\n-               --  if there is a binding already (either a procedure or an\n-               --  entry), raise Program_Error (propagate it to the caller).\n-\n-               if User_Handler (Interrupt).H /= null\n-                 or else User_Entry (Interrupt).T /= Null_Task\n-               then\n-                  raise Program_Error with\n-                    \"a binding for this interrupt is already present\";\n-               end if;\n-\n-               --  The interrupt should no longer be ignored if\n-               --  it was ever ignored.\n-\n-               Ignored (Interrupt) := False;\n-               User_Entry (Interrupt) := Entry_Assoc'(T => T, E => E);\n-\n-               --  Indicate the attachment of Interrupt Entry in ATCB.\n-               --  This is need so that when an Interrupt Entry task\n-               --  terminates the binding can be cleaned.\n-               --  The call to unbinding must be\n-               --  make by the task before it terminates.\n-\n-               T.Interrupt_Entry := True;\n-\n-               --  Invoke a corresponding Server_Task if not yet created.\n-               --  Place Task_Id info in Server_ID array.\n-\n-               if Server_ID (Interrupt) = Null_Task then\n-\n-                  Access_Hold := new Server_Task (Interrupt);\n-                  Server_ID (Interrupt) :=\n-                    To_System (Access_Hold.all'Identity);\n-               else\n-                  POP.Wakeup (Server_ID (Interrupt),\n-                              Interrupt_Server_Idle_Sleep);\n-               end if;\n-            end Bind_Interrupt_To_Entry;\n-\n-            or accept Detach_Interrupt_Entries (T : Task_Id)\n-            do\n-               for J in Interrupt_ID'Range loop\n-                  if not Is_Reserved (J) then\n-                     if User_Entry (J).T = T then\n-\n-                        --  The interrupt should no longer be ignored if\n-                        --  it was ever ignored.\n-\n-                        Ignored (J) := False;\n-                        User_Entry (J) :=\n-                          Entry_Assoc'(T => Null_Task, E => Null_Task_Entry);\n-                        IMOP.Interrupt_Self_Process (IMNG.Interrupt_ID (J));\n-                     end if;\n-                  end if;\n-               end loop;\n-\n-               --  Indicate in ATCB that no Interrupt Entries are attached\n-\n-               T.Interrupt_Entry := False;\n-            end Detach_Interrupt_Entries;\n-\n-            or accept Block_Interrupt (Interrupt : Interrupt_ID) do\n-               pragma Warnings (Off, Interrupt);\n-               raise Program_Error;\n-            end Block_Interrupt;\n-\n-            or accept Unblock_Interrupt (Interrupt : Interrupt_ID) do\n-               pragma Warnings (Off, Interrupt);\n-               raise Program_Error;\n-            end Unblock_Interrupt;\n-\n-            or accept Ignore_Interrupt (Interrupt : Interrupt_ID) do\n-               pragma Warnings (Off, Interrupt);\n-               raise Program_Error;\n-            end Ignore_Interrupt;\n-\n-            or accept Unignore_Interrupt (Interrupt : Interrupt_ID) do\n-               pragma Warnings (Off, Interrupt);\n-               raise Program_Error;\n-            end Unignore_Interrupt;\n-\n-            end select;\n-\n-         exception\n-            --  If there is a program error we just want to propagate it to the\n-            --  caller and do not want to stop this task.\n-\n-            when Program_Error =>\n-               null;\n-\n-            when others =>\n-               pragma Assert (False);\n-               null;\n-         end;\n-      end loop;\n-   end Interrupt_Manager;\n-\n-   -----------------\n-   -- Server_Task --\n-   -----------------\n-\n-   task body Server_Task is\n-      --  By making this task independent of master, when the process\n-      --  goes away, the Server_Task will terminate gracefully.\n-\n-      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n-\n-      Self_ID         : constant Task_Id := Self;\n-      Tmp_Handler     : Parameterless_Handler;\n-      Tmp_ID          : Task_Id;\n-      Tmp_Entry_Index : Task_Entry_Index;\n-      Intwait_Mask    : aliased IMNG.Interrupt_Mask;\n-\n-   begin\n-      --  Install default action in system level\n-\n-      IMOP.Install_Default_Action (IMNG.Interrupt_ID (Interrupt));\n-\n-      --  Set up the mask (also clears the event flag)\n-\n-      IMOP.Empty_Interrupt_Mask (Intwait_Mask'Access);\n-      IMOP.Add_To_Interrupt_Mask\n-        (Intwait_Mask'Access, IMNG.Interrupt_ID (Interrupt));\n-\n-      --  Remember the Interrupt_ID for Abort_Task\n-\n-      PIO.Set_Interrupt_ID (IMNG.Interrupt_ID (Interrupt), Self_ID);\n-\n-      --  Note: All tasks in RTS will have all the Reserve Interrupts\n-      --  being masked (except the Interrupt_Manager) and Keep_Unmasked\n-      --  unmasked when created.\n-\n-      loop\n-         System.Tasking.Initialization.Defer_Abort (Self_ID);\n-\n-         --  A Handler or an Entry is installed. At this point all tasks\n-         --  mask for the Interrupt is masked. Catch the Interrupt using\n-         --  sigwait.\n-\n-         --  This task may wake up from sigwait by receiving an interrupt\n-         --  (Abort_Task_Interrupt) from the Interrupt_Manager for unbinding\n-         --  a Procedure Handler or an Entry. Or it could be a wake up\n-         --  from status change (Unblocked -> Blocked). If that is not\n-         --  the case, we should execute the attached Procedure or Entry.\n-\n-         if Single_Lock then\n-            POP.Lock_RTS;\n-         end if;\n-\n-         POP.Write_Lock (Self_ID);\n-\n-         if User_Handler (Interrupt).H = null\n-           and then User_Entry (Interrupt).T = Null_Task\n-         then\n-            --  No Interrupt binding. If there is an interrupt,\n-            --  Interrupt_Manager will take default action.\n-\n-            Self_ID.Common.State := Interrupt_Server_Idle_Sleep;\n-            POP.Sleep (Self_ID, Interrupt_Server_Idle_Sleep);\n-            Self_ID.Common.State := Runnable;\n-\n-         else\n-            Self_ID.Common.State := Interrupt_Server_Blocked_On_Event_Flag;\n-            Self_ID.Common.State := Runnable;\n-\n-            if not (Self_ID.Deferral_Level = 0\n-                    and then Self_ID.Pending_ATC_Level\n-                             < Self_ID.ATC_Nesting_Level)\n-            then\n-               if User_Handler (Interrupt).H /= null then\n-                  Tmp_Handler := User_Handler (Interrupt).H;\n-\n-                  --  RTS calls should not be made with self being locked\n-\n-                  POP.Unlock (Self_ID);\n-\n-                  if Single_Lock then\n-                     POP.Unlock_RTS;\n-                  end if;\n-\n-                  Tmp_Handler.all;\n-\n-                  if Single_Lock then\n-                     POP.Lock_RTS;\n-                  end if;\n-\n-                  POP.Write_Lock (Self_ID);\n-\n-               elsif User_Entry (Interrupt).T /= Null_Task then\n-                  Tmp_ID := User_Entry (Interrupt).T;\n-                  Tmp_Entry_Index := User_Entry (Interrupt).E;\n-\n-                  --  RTS calls should not be made with self being locked\n-\n-                  POP.Unlock (Self_ID);\n-\n-                  if Single_Lock then\n-                     POP.Unlock_RTS;\n-                  end if;\n-\n-                  System.Tasking.Rendezvous.Call_Simple\n-                    (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n-\n-                  if Single_Lock then\n-                     POP.Lock_RTS;\n-                  end if;\n-\n-                  POP.Write_Lock (Self_ID);\n-               end if;\n-            end if;\n-         end if;\n-\n-         POP.Unlock (Self_ID);\n-\n-         if Single_Lock then\n-            POP.Unlock_RTS;\n-         end if;\n-\n-         --  Undefer abort here to allow a window for this task to be aborted\n-         --  at the time of system shutdown.\n-\n-         System.Tasking.Initialization.Undefer_Abort (Self_ID);\n-      end loop;\n-   end Server_Task;\n-\n-   -------------------------------------\n-   -- Has_Interrupt_Or_Attach_Handler --\n-   -------------------------------------\n-\n-   function Has_Interrupt_Or_Attach_Handler\n-     (Object : access Dynamic_Interrupt_Protection) return Boolean\n-   is\n-      pragma Warnings (Off, Object);\n-   begin\n-      return True;\n-   end Has_Interrupt_Or_Attach_Handler;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Object : in out Static_Interrupt_Protection) is\n-   begin\n-      --  ??? loop to be executed only when we're not doing library level\n-      --  finalization, since in this case all interrupt tasks are gone.\n-\n-      if not Interrupt_Manager'Terminated then\n-         for N in reverse Object.Previous_Handlers'Range loop\n-            Interrupt_Manager.Attach_Handler\n-              (New_Handler => Object.Previous_Handlers (N).Handler,\n-               Interrupt   => Object.Previous_Handlers (N).Interrupt,\n-               Static      => Object.Previous_Handlers (N).Static,\n-               Restoration => True);\n-         end loop;\n-      end if;\n-\n-      Tasking.Protected_Objects.Entries.Finalize\n-        (Tasking.Protected_Objects.Entries.Protection_Entries (Object));\n-   end Finalize;\n-\n-   -------------------------------------\n-   -- Has_Interrupt_Or_Attach_Handler --\n-   -------------------------------------\n-\n-   function Has_Interrupt_Or_Attach_Handler\n-     (Object : access Static_Interrupt_Protection) return Boolean\n-   is\n-      pragma Warnings (Off, Object);\n-   begin\n-      return True;\n-   end Has_Interrupt_Or_Attach_Handler;\n-\n-   ----------------------\n-   -- Install_Handlers --\n-   ----------------------\n-\n-   procedure Install_Handlers\n-     (Object       : access Static_Interrupt_Protection;\n-      New_Handlers : New_Handler_Array)\n-   is\n-   begin\n-      for N in New_Handlers'Range loop\n-\n-         --  We need a lock around this ???\n-\n-         Object.Previous_Handlers (N).Interrupt := New_Handlers (N).Interrupt;\n-         Object.Previous_Handlers (N).Static    := User_Handler\n-           (New_Handlers (N).Interrupt).Static;\n-\n-         --  We call Exchange_Handler and not directly Interrupt_Manager.\n-         --  Exchange_Handler so we get the Is_Reserved check.\n-\n-         Exchange_Handler\n-           (Old_Handler => Object.Previous_Handlers (N).Handler,\n-            New_Handler => New_Handlers (N).Handler,\n-            Interrupt   => New_Handlers (N).Interrupt,\n-            Static      => True);\n-      end loop;\n-   end Install_Handlers;\n-\n-   ---------------------------------\n-   -- Install_Restricted_Handlers --\n-   ---------------------------------\n-\n-   procedure Install_Restricted_Handlers\n-      (Prio     : Any_Priority;\n-       Handlers : New_Handler_Array)\n-   is\n-      pragma Unreferenced (Prio);\n-   begin\n-      for N in Handlers'Range loop\n-         Attach_Handler (Handlers (N).Handler, Handlers (N).Interrupt, True);\n-      end loop;\n-   end Install_Restricted_Handlers;\n-\n---  Elaboration code for package System.Interrupts\n-\n-begin\n-   --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent\n-\n-   Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n-\n-   --  During the elaboration of this package body we want RTS to inherit the\n-   --  interrupt mask from the Environment Task.\n-\n-   --  The Environment Task should have gotten its mask from the enclosing\n-   --  process during the RTS start up. (See in s-inmaop.adb). Pass the\n-   --  Interrupt_Mask of the Environment task to the Interrupt_Manager.\n-\n-   --  Note : At this point we know that all tasks (including RTS internal\n-   --  servers) are masked for non-reserved signals (see s-taprop.adb). Only\n-   --  the Interrupt_Manager will have masks set up differently inheriting the\n-   --  original Environment Task's mask.\n-\n-   Interrupt_Manager.Initialize (IMOP.Environment_Mask);\n-end System.Interrupts;"}, {"sha": "0f198f1522601511301cc90de11e8abbaac9ad93", "filename": "gcc/ada/s-intman-vms.adb", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-intman-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-intman-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,76 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/Alpha version of this package\n-\n-package body System.Interrupt_Management is\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   Initialized : Boolean := False;\n-\n-   procedure Initialize is\n-      use System.OS_Interface;\n-      Status : Cond_Value_Type;\n-\n-   begin\n-      if Initialized then\n-         return;\n-      end if;\n-\n-      Initialized := True;\n-      Abort_Task_Interrupt := Interrupt_ID_0;\n-      --  Unused\n-\n-      Reserve := Reserve or Keep_Unmasked or Keep_Masked;\n-      Reserve (Interrupt_ID_0) := True;\n-\n-      Sys_Crembx\n-        (Status => Status,\n-         Prmflg => 0,\n-         Chan   => Rcv_Interrupt_Chan,\n-         Maxmsg => Interrupt_ID'Size,\n-         Bufquo => Interrupt_Bufquo,\n-         Lognam => \"GNAT_Interrupt_Mailbox\",\n-         Flags  => CMB_M_READONLY);\n-      pragma Assert ((Status and 1) = 1);\n-\n-      Sys_Assign\n-        (Status => Status,\n-         Devnam => \"GNAT_Interrupt_Mailbox\",\n-         Chan   => Snd_Interrupt_Chan,\n-         Flags  => AGN_M_WRITEONLY);\n-      pragma Assert ((Status and 1) = 1);\n-   end Initialize;\n-\n-end System.Interrupt_Management;"}, {"sha": "cc5124217caa3b3c887a33566b66b21b42ad7eb4", "filename": "gcc/ada/s-intman-vms.ads", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-intman-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-intman-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-intman-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,119 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---            S Y S T E M . I N T E R R U P T _ M A N A G E M E N T         --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha/VMS version of this package\n-\n---  This package encapsulates and centralizes information about all uses of\n---  interrupts (or signals), including the target-dependent mapping of\n---  interrupts (or signals) to exceptions.\n-\n---  PLEASE DO NOT add any with-clauses to this package\n-\n---  PLEASE DO NOT put any subprogram declarations with arguments of type\n---  Interrupt_ID into the visible part of this package.\n-\n---  The type Interrupt_ID is used to derive the type in Ada.Interrupts, and\n---  adding more operations to that type would be illegal according to the Ada\n---  Reference Manual. (This is the reason why the signals sets below are\n---  implemented as visible arrays rather than functions.)\n-\n-with System.OS_Interface;\n-\n-package System.Interrupt_Management is\n-   pragma Preelaborate;\n-\n-   type Interrupt_Mask is limited private;\n-\n-   type Interrupt_ID is new System.OS_Interface.Signal;\n-\n-   type Interrupt_Set is array (Interrupt_ID) of Boolean;\n-\n-   --  The following objects serve as constants, but are initialized in the\n-   --  body to aid portability. This permits us to use more portable names for\n-   --  interrupts, where distinct names may map to the same interrupt ID\n-   --  value. For example, suppose SIGRARE is a signal that is not defined on\n-   --  all systems, but is always reserved when it is defined. If we have the\n-   --  convention that ID zero is not used for any \"real\" signals, and SIGRARE\n-   --  = 0 when SIGRARE is not one of the locally supported signals, we can\n-   --  write:\n-   --     Reserved (SIGRARE) := true;\n-   --  Then the initialization code will be portable.\n-\n-   Abort_Task_Interrupt : Interrupt_ID;\n-   --  The interrupt that is used to implement task abort, if an interrupt is\n-   --  used for that purpose. This is one of the reserved interrupts.\n-\n-   Keep_Unmasked : Interrupt_Set := (others => False);\n-   --  Keep_Unmasked (I) is true iff the interrupt I is one that must be kept\n-   --  unmasked at all times, except (perhaps) for short critical sections.\n-   --  This includes interrupts that are mapped to exceptions (see\n-   --  System.Interrupt_Exceptions.Is_Exception), but may also include\n-   --  interrupts (e.g. timer) that need to be kept unmasked for other\n-   --  reasons. Where interrupts are implemented as OS signals, and signal\n-   --  masking is per-task, the interrupt should be unmasked in ALL TASKS.\n-\n-   Reserve : Interrupt_Set := (others => False);\n-   --  Reserve (I) is true iff the interrupt I is one that cannot be permitted\n-   --  to be attached to a user handler. The possible reasons are many. For\n-   --  example it may be mapped to an exception used to implement task abort.\n-\n-   Keep_Masked : Interrupt_Set := (others => False);\n-   --  Keep_Masked (I) is true iff the interrupt I must always be masked.\n-   --  Where interrupts are implemented as OS signals, and signal masking is\n-   --  per-task, the interrupt should be masked in ALL TASKS. There might not\n-   --  be any interrupts in this class, depending on the environment. For\n-   --  example, if interrupts are OS signals and signal masking is per-task,\n-   --  use of the sigwait operation requires the signal be masked in all tasks.\n-\n-   procedure Initialize;\n-   --  Initialize the various variables defined in this package.\n-   --  This procedure must be called before accessing any object from this\n-   --  package and can be called multiple times.\n-\n-private\n-   use type System.OS_Interface.unsigned_long;\n-\n-   type Interrupt_Mask is new System.OS_Interface.sigset_t;\n-\n-   --  Interrupts on VMS are implemented with a mailbox. A QIO read is\n-   --  registered on the Rcv channel and the interrupt occurs by registering\n-   --  a QIO write on the Snd channel. The maximum number of pending\n-   --  interrupts is arbitrarily set at 1000. One nice feature of using\n-   --  a mailbox is that it is trivially extendable to cross process\n-   --  interrupts.\n-\n-   Rcv_Interrupt_Chan : System.OS_Interface.unsigned_short := 0;\n-   Snd_Interrupt_Chan : System.OS_Interface.unsigned_short := 0;\n-   Interrupt_Mailbox  : Interrupt_ID := 0;\n-   Interrupt_Bufquo   : System.OS_Interface.unsigned_long :=\n-                          1000 * (Interrupt_ID'Size / 8);\n-\n-end System.Interrupt_Management;"}, {"sha": "7426f50a5ec6cd2fc43889c1191e171ad9bcb648", "filename": "gcc/ada/s-mastop-vms.adb", "status": "removed", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-mastop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-mastop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-mastop-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,274 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                     SYSTEM.MACHINE_STATE_OPERATIONS                      --\n---                                                                          --\n---                                 B o d y                                  --\n---                         (Version for Alpha/VMS)                          --\n---                                                                          --\n---                     Copyright (C) 2001-2012, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This version of System.Machine_State_Operations is for use on\n---  Alpha systems running VMS.\n-\n-with System.Memory;\n-with System.Aux_DEC; use System.Aux_DEC;\n-with Ada.Unchecked_Conversion;\n-\n-package body System.Machine_State_Operations is\n-\n-   subtype Cond_Value_Type is Unsigned_Longword;\n-\n-   --  Record layouts copied from Starlet\n-\n-   type ICB_Fflags_Bits_Type is record\n-      Exception_Frame : Boolean;\n-      Ast_Frame       : Boolean;\n-      Bottom_Of_Stack : Boolean;\n-      Base_Frame      : Boolean;\n-      Filler_1        : Unsigned_20;\n-   end record;\n-\n-   for ICB_Fflags_Bits_Type use record\n-      Exception_Frame at 0 range 0 .. 0;\n-      Ast_Frame       at 0 range 1 .. 1;\n-      Bottom_Of_Stack at 0 range 2 .. 2;\n-      Base_Frame      at 0 range 3 .. 3;\n-      Filler_1        at 0 range 4 .. 23;\n-   end record;\n-   for ICB_Fflags_Bits_Type'Size use 24;\n-\n-   type ICB_Hdr_Quad_Type is record\n-      Context_Length : Unsigned_Longword;\n-      Fflags_Bits    : ICB_Fflags_Bits_Type;\n-      Block_Version  : Unsigned_Byte;\n-   end record;\n-\n-   for ICB_Hdr_Quad_Type use record\n-      Context_Length at 0 range 0 .. 31;\n-      Fflags_Bits    at 4 range 0 .. 23;\n-      Block_Version  at 7 range 0 .. 7;\n-   end record;\n-   for ICB_Hdr_Quad_Type'Size use 64;\n-\n-   type Invo_Context_Blk_Type is record\n-\n-      Hdr_Quad : ICB_Hdr_Quad_Type;\n-      --  The first quadword contains:\n-      --    o  The length of the structure in bytes (a longword field)\n-      --    o  The frame flags (a 3 byte field of bits)\n-      --    o  The version number (a 1 byte field)\n-\n-      Procedure_Descriptor : Unsigned_Quadword;\n-      --  The address of the procedure descriptor for the procedure\n-\n-      Program_Counter : Integer_64;\n-      --  The current PC of a given procedure invocation\n-\n-      Processor_Status : Integer_64;\n-      --  The current PS of a given procedure invocation\n-\n-      Ireg : Unsigned_Quadword_Array (0 .. 30);\n-      Freg : Unsigned_Quadword_Array (0 .. 30);\n-      --  The register contents areas. 31 for scalars, 31 for float\n-\n-      System_Defined : Unsigned_Quadword_Array (0 .. 1);\n-      --  The following is an \"internal\" area that's reserved for use by\n-      --  the operating system. It's size may vary over time.\n-\n-      --  Chfctx_Addr : Unsigned_Quadword;\n-      --  Defined as a comment since it overlaps other fields\n-\n-      Filler_1             : String (1 .. 0);\n-      --  Align to octaword\n-   end record;\n-\n-   for Invo_Context_Blk_Type use record\n-      Hdr_Quad             at   0 range 0 .. 63;\n-      Procedure_Descriptor at   8 range 0 .. 63;\n-      Program_Counter      at  16 range 0 .. 63;\n-      Processor_Status     at  24 range 0 .. 63;\n-      Ireg                 at  32 range 0 .. 1983;\n-      Freg                 at 280 range 0 .. 1983;\n-      System_Defined       at 528 range 0 .. 127;\n-\n-      --  Component representation spec(s) below are defined as\n-      --  comments since they overlap other fields\n-\n-      --  Chfctx_Addr at 528 range 0 .. 63;\n-\n-      Filler_1 at 544 range 0 .. -1;\n-   end record;\n-   for Invo_Context_Blk_Type'Size use 4352;\n-\n-   subtype Invo_Handle_Type is Unsigned_Longword;\n-\n-   type Invo_Handle_Access_Type is access all Invo_Handle_Type;\n-\n-   function Fetch is new Fetch_From_Address (Code_Loc);\n-\n-   function To_Invo_Handle_Access is new Ada.Unchecked_Conversion\n-     (Machine_State, Invo_Handle_Access_Type);\n-\n-   function To_Machine_State is new Ada.Unchecked_Conversion\n-     (System.Address, Machine_State);\n-\n-   ----------------------------\n-   -- Allocate_Machine_State --\n-   ----------------------------\n-\n-   function Allocate_Machine_State return Machine_State is\n-   begin\n-      return To_Machine_State\n-        (Memory.Alloc (Invo_Handle_Type'Max_Size_In_Storage_Elements));\n-   end Allocate_Machine_State;\n-\n-   ----------------\n-   -- Fetch_Code --\n-   ----------------\n-\n-   function Fetch_Code (Loc : Code_Loc) return Code_Loc is\n-   begin\n-      --  The starting address is in the second longword pointed to by Loc\n-\n-      return Fetch (System.Aux_DEC.\"+\" (Loc, 8));\n-   end Fetch_Code;\n-\n-   ------------------------\n-   -- Free_Machine_State --\n-   ------------------------\n-\n-   procedure Free_Machine_State (M : in out Machine_State) is\n-   begin\n-      Memory.Free (Address (M));\n-      M := Machine_State (Null_Address);\n-   end Free_Machine_State;\n-\n-   ------------------\n-   -- Get_Code_Loc --\n-   ------------------\n-\n-   function Get_Code_Loc (M : Machine_State) return Code_Loc is\n-      procedure Get_Invo_Context (\n-         Result       : out Unsigned_Longword; -- return value\n-         Invo_Handle  : Invo_Handle_Type;\n-         Invo_Context : out Invo_Context_Blk_Type);\n-\n-      pragma Import (External, Get_Invo_Context);\n-\n-      pragma Import_Valued_Procedure (Get_Invo_Context, \"LIB$GET_INVO_CONTEXT\",\n-         (Unsigned_Longword, Invo_Handle_Type, Invo_Context_Blk_Type),\n-         (Value, Value, Reference));\n-\n-      Asm_Call_Size : constant := 4;\n-      --  Under VMS a call\n-      --  asm instruction takes 4 bytes. So we must remove this amount.\n-\n-      ICB : Invo_Context_Blk_Type;\n-      Status : Cond_Value_Type;\n-\n-   begin\n-      Get_Invo_Context (Status, To_Invo_Handle_Access (M).all, ICB);\n-\n-      if (Status and 1) /= 1 then\n-         return Code_Loc (System.Null_Address);\n-      end if;\n-\n-      return Code_Loc (ICB.Program_Counter - Asm_Call_Size);\n-   end Get_Code_Loc;\n-\n-   --------------------------\n-   -- Machine_State_Length --\n-   --------------------------\n-\n-   function Machine_State_Length\n-     return System.Storage_Elements.Storage_Offset\n-   is\n-      use System.Storage_Elements;\n-\n-   begin\n-      return Invo_Handle_Type'Size / 8;\n-   end Machine_State_Length;\n-\n-   ---------------\n-   -- Pop_Frame --\n-   ---------------\n-\n-   procedure Pop_Frame (M : Machine_State) is\n-      procedure Get_Prev_Invo_Handle (\n-         Result : out Invo_Handle_Type; -- return value\n-         ICB    : Invo_Handle_Type);\n-\n-      pragma Import (External, Get_Prev_Invo_Handle);\n-\n-      pragma Import_Valued_Procedure\n-        (Get_Prev_Invo_Handle, \"LIB$GET_PREV_INVO_HANDLE\",\n-         (Invo_Handle_Type, Invo_Handle_Type),\n-         (Value, Value));\n-\n-      Prev_Handle : aliased Invo_Handle_Type;\n-\n-   begin\n-      Get_Prev_Invo_Handle (Prev_Handle, To_Invo_Handle_Access (M).all);\n-      To_Invo_Handle_Access (M).all := Prev_Handle;\n-   end Pop_Frame;\n-\n-   -----------------------\n-   -- Set_Machine_State --\n-   -----------------------\n-\n-   procedure Set_Machine_State (M : Machine_State) is\n-\n-      procedure Get_Curr_Invo_Context\n-        (Invo_Context : out Invo_Context_Blk_Type);\n-\n-      pragma Import (External, Get_Curr_Invo_Context);\n-\n-      pragma Import_Valued_Procedure\n-        (Get_Curr_Invo_Context, \"LIB$GET_CURR_INVO_CONTEXT\",\n-         (Invo_Context_Blk_Type),\n-         (Reference));\n-\n-      procedure Get_Invo_Handle (\n-         Result       : out Invo_Handle_Type; -- return value\n-         Invo_Context : Invo_Context_Blk_Type);\n-\n-      pragma Import (External, Get_Invo_Handle);\n-\n-      pragma Import_Valued_Procedure (Get_Invo_Handle, \"LIB$GET_INVO_HANDLE\",\n-         (Invo_Handle_Type, Invo_Context_Blk_Type),\n-         (Value, Reference));\n-\n-      ICB         : Invo_Context_Blk_Type;\n-      Invo_Handle : aliased Invo_Handle_Type;\n-\n-   begin\n-      Get_Curr_Invo_Context (ICB);\n-      Get_Invo_Handle (Invo_Handle, ICB);\n-      To_Invo_Handle_Access (M).all := Invo_Handle;\n-      Pop_Frame (M, System.Null_Address);\n-   end Set_Machine_State;\n-\n-end System.Machine_State_Operations;"}, {"sha": "7a08f7d07994679b20e521fe0483fdd577649742", "filename": "gcc/ada/s-memory-vms_64.adb", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-memory-vms_64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-memory-vms_64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-memory-vms_64.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,230 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                         S Y S T E M . M E M O R Y                        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VMS 64 bit implementation of this package\n-\n---  This implementation assumes that the underlying malloc/free/realloc\n---  implementation is thread safe, and thus, no additional lock is required.\n---  Note that we still need to defer abort because on most systems, an\n---  asynchronous signal (as used for implementing asynchronous abort of\n---  task) cannot safely be handled while malloc is executing.\n-\n---  If you are not using Ada constructs containing the \"abort\" keyword, then\n---  you can remove the calls to Abort_Defer.all and Abort_Undefer.all from\n---  this unit.\n-\n-pragma Compiler_Unit_Warning;\n-\n-with Ada.Exceptions;\n-with System.Soft_Links;\n-with System.Parameters;\n-with System.CRTL;\n-\n-package body System.Memory is\n-\n-   use Ada.Exceptions;\n-   use System.Soft_Links;\n-\n-   function c_malloc (Size : System.CRTL.size_t) return System.Address\n-    renames System.CRTL.malloc;\n-\n-   procedure c_free (Ptr : System.Address)\n-     renames System.CRTL.free;\n-\n-   function c_realloc\n-     (Ptr : System.Address; Size : System.CRTL.size_t) return System.Address\n-     renames System.CRTL.realloc;\n-\n-   Gnat_Heap_Size : Integer;\n-   pragma Import (C, Gnat_Heap_Size, \"__gl_heap_size\");\n-   --  Set by Feature logical GNAT$NO_MALLOC_64 and/or Binder switch -Hnn\n-\n-   -----------\n-   -- Alloc --\n-   -----------\n-\n-   function Alloc (Size : size_t) return System.Address is\n-      Result      : System.Address;\n-      Actual_Size : size_t := Size;\n-\n-   begin\n-      if Gnat_Heap_Size = 32 then\n-         return Alloc32 (Size);\n-      end if;\n-\n-      if Size = size_t'Last then\n-         Raise_Exception (Storage_Error'Identity, \"object too large\");\n-      end if;\n-\n-      --  Change size from zero to non-zero. We still want a proper pointer\n-      --  for the zero case because pointers to zero length objects have to\n-      --  be distinct, but we can't just go ahead and allocate zero bytes,\n-      --  since some malloc's return zero for a zero argument.\n-\n-      if Size = 0 then\n-         Actual_Size := 1;\n-      end if;\n-\n-      if Parameters.No_Abort then\n-         Result := c_malloc (System.CRTL.size_t (Actual_Size));\n-      else\n-         Abort_Defer.all;\n-         Result := c_malloc (System.CRTL.size_t (Actual_Size));\n-         Abort_Undefer.all;\n-      end if;\n-\n-      if Result = System.Null_Address then\n-         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n-      end if;\n-\n-      return Result;\n-   end Alloc;\n-\n-   -------------\n-   -- Alloc32 --\n-   -------------\n-\n-   function Alloc32 (Size : size_t) return System.Address is\n-      Result      : System.Address;\n-      Actual_Size : size_t := Size;\n-\n-   begin\n-      if Size = size_t'Last then\n-         Raise_Exception (Storage_Error'Identity, \"object too large\");\n-      end if;\n-\n-      --  Change size from zero to non-zero. We still want a proper pointer\n-      --  for the zero case because pointers to zero length objects have to\n-      --  be distinct, but we can't just go ahead and allocate zero bytes,\n-      --  since some malloc's return zero for a zero argument.\n-\n-      if Size = 0 then\n-         Actual_Size := 1;\n-      end if;\n-\n-      if Parameters.No_Abort then\n-         Result := C_malloc32 (Actual_Size);\n-      else\n-         Abort_Defer.all;\n-         Result := C_malloc32 (Actual_Size);\n-         Abort_Undefer.all;\n-      end if;\n-\n-      if Result = System.Null_Address then\n-         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n-      end if;\n-\n-      return Result;\n-   end Alloc32;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Ptr : System.Address) is\n-   begin\n-      if Parameters.No_Abort then\n-         c_free (Ptr);\n-      else\n-         Abort_Defer.all;\n-         c_free (Ptr);\n-         Abort_Undefer.all;\n-      end if;\n-   end Free;\n-\n-   -------------\n-   -- Realloc --\n-   -------------\n-\n-   function Realloc\n-     (Ptr  : System.Address;\n-      Size : size_t)\n-      return System.Address\n-   is\n-      Result      : System.Address;\n-      Actual_Size : constant size_t := Size;\n-\n-   begin\n-      if Gnat_Heap_Size = 32 then\n-         return Realloc32 (Ptr, Size);\n-      end if;\n-\n-      if Size = size_t'Last then\n-         Raise_Exception (Storage_Error'Identity, \"object too large\");\n-      end if;\n-\n-      if Parameters.No_Abort then\n-         Result := c_realloc (Ptr, System.CRTL.size_t (Actual_Size));\n-      else\n-         Abort_Defer.all;\n-         Result := c_realloc (Ptr, System.CRTL.size_t (Actual_Size));\n-         Abort_Undefer.all;\n-      end if;\n-\n-      if Result = System.Null_Address then\n-         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n-      end if;\n-\n-      return Result;\n-   end Realloc;\n-\n-   ---------------\n-   -- Realloc32 --\n-   ---------------\n-\n-   function Realloc32\n-     (Ptr  : System.Address;\n-      Size : size_t)\n-      return System.Address\n-   is\n-      Result      : System.Address;\n-      Actual_Size : constant size_t := Size;\n-\n-   begin\n-      if Size = size_t'Last then\n-         Raise_Exception (Storage_Error'Identity, \"object too large\");\n-      end if;\n-\n-      if Parameters.No_Abort then\n-         Result := C_realloc32 (Ptr, Actual_Size);\n-      else\n-         Abort_Defer.all;\n-         Result := C_realloc32 (Ptr, Actual_Size);\n-         Abort_Undefer.all;\n-      end if;\n-\n-      if Result = System.Null_Address then\n-         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n-      end if;\n-\n-      return Result;\n-   end Realloc32;\n-end System.Memory;"}, {"sha": "464446a8b2e18322cde5b3ce885b0e1691d23573", "filename": "gcc/ada/s-memory-vms_64.ads", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-memory-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-memory-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-memory-vms_64.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,129 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                         S Y S T E M . M E M O R Y                        --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides the low level memory allocation/deallocation\n---  mechanisms used by GNAT for VMS 64 bit.\n-\n---  To provide an alternate implementation, simply recompile the modified\n---  body of this package with gnatmake -u -a -g s-memory.adb and make sure\n---  that the ali and object files for this unit are found in the object\n---  search path.\n-\n---  This unit may be used directly from an application program by providing\n---  an appropriate WITH, and the interface can be expected to remain stable.\n-\n-pragma Compiler_Unit_Warning;\n-\n-package System.Memory is\n-   pragma Elaborate_Body;\n-\n-   type size_t is mod 2 ** Standard'Address_Size;\n-   --  Note: the reason we redefine this here instead of using the\n-   --  definition in Interfaces.C is that we do not want to drag in\n-   --  all of Interfaces.C just because System.Memory is used.\n-\n-   function Alloc (Size : size_t) return System.Address;\n-   --  This is the low level allocation routine. Given a size in storage\n-   --  units, it returns the address of a maximally aligned block of\n-   --  memory. The implementation of this routine is guaranteed to be\n-   --  task safe, and also aborts are deferred if necessary.\n-   --\n-   --  If size_t is set to size_t'Last on entry, then a Storage_Error\n-   --  exception is raised with a message \"object too large\".\n-   --\n-   --  If size_t is set to zero on entry, then a minimal (but non-zero)\n-   --  size block is allocated.\n-   --\n-   --  Note: this is roughly equivalent to the standard C malloc call\n-   --  with the additional semantics as described above.\n-\n-   function Alloc32 (Size : size_t) return System.Address;\n-   --  Equivalent to Alloc except on VMS 64 bit where it invokes\n-   --  32 bit malloc.\n-\n-   procedure Free (Ptr : System.Address);\n-   --  This is the low level free routine. It frees a block previously\n-   --  allocated with a call to Alloc. As in the case of Alloc, this\n-   --  call is guaranteed task safe, and aborts are deferred.\n-   --\n-   --  Note: this is roughly equivalent to the standard C free call\n-   --  with the additional semantics as described above.\n-\n-   function Realloc\n-     (Ptr  : System.Address;\n-      Size : size_t) return System.Address;\n-   --  This is the low level reallocation routine. It takes an existing\n-   --  block address returned by a previous call to Alloc or Realloc,\n-   --  and reallocates the block. The size can either be increased or\n-   --  decreased. If possible the reallocation is done in place, so that\n-   --  the returned result is the same as the value of Ptr on entry.\n-   --  However, it may be necessary to relocate the block to another\n-   --  address, in which case the information is copied to the new\n-   --  block, and the old block is freed. The implementation of this\n-   --  routine is guaranteed to be task safe, and also aborts are\n-   --  deferred as necessary.\n-   --\n-   --  If size_t is set to size_t'Last on entry, then a Storage_Error\n-   --  exception is raised with a message \"object too large\".\n-   --\n-   --  If size_t is set to zero on entry, then a minimal (but non-zero)\n-   --  size block is allocated.\n-   --\n-   --  Note: this is roughly equivalent to the standard C realloc call\n-   --  with the additional semantics as described above.\n-\n-   function Realloc32\n-     (Ptr  : System.Address;\n-      Size : size_t) return System.Address;\n-   --  Equivalent to Realloc except on VMS 64 bit where it invokes\n-   --  32 bit realloc.\n-\n-private\n-\n-   --  The following names are used from the generated compiler code\n-\n-   pragma Export (C, Alloc,   \"__gnat_malloc\");\n-   pragma Export (C, Alloc32, \"__gnat_malloc32\");\n-   pragma Export (C, Free,    \"__gnat_free\");\n-   pragma Export (C, Realloc, \"__gnat_realloc\");\n-   pragma Export (C, Realloc32, \"__gnat_realloc32\");\n-\n-   function C_malloc32 (Size : size_t) return System.Address;\n-   pragma Import (C, C_malloc32, \"_malloc32\");\n-   --  An alias for malloc for allocating 32bit memory on 64bit VMS\n-\n-   function C_realloc32\n-     (Ptr  : System.Address;\n-      Size : size_t) return System.Address;\n-   pragma Import (C, C_realloc32, \"_realloc32\");\n-   --  An alias for realloc for allocating 32bit memory on 64bit VMS\n-\n-end System.Memory;"}, {"sha": "ae8fc38c98441530122fec016a5233e71bf7b659", "filename": "gcc/ada/s-osinte-vms.adb", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osinte-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osinte-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,59 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2012, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by children of System.\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-with Interfaces.C; use Interfaces.C;\n-\n-package body System.OS_Interface is\n-\n-   -----------------\n-   -- sched_yield --\n-   -----------------\n-\n-   function sched_yield return int is\n-      procedure sched_yield_base;\n-      pragma Import (C, sched_yield_base, \"PTHREAD_YIELD_NP\");\n-\n-   begin\n-      sched_yield_base;\n-      return 0;\n-   end sched_yield;\n-\n-end System.OS_Interface;"}, {"sha": "2b2b135d0e9e3b06d120cc7a636a377eedfeb3bf", "filename": "gcc/ada/s-osinte-vms.ads", "status": "removed", "additions": 0, "deletions": 660, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osinte-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osinte-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,660 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by the tasking run-time (libgnarl).\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Interfaces.C;\n-\n-with Ada.Unchecked_Conversion;\n-\n-with System.Aux_DEC;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   --  pragma Linker_Options (\"--for-linker=/threads_enable\");\n-   --  Enable upcalls and multiple kernel threads.\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------------------------\n-   -- Signals (Interrupt IDs) --\n-   -----------------------------\n-\n-   --  Type signal has an arbitrary limit of 31\n-\n-   Max_Interrupt : constant := 31;\n-   type Signal is new unsigned range 0 .. Max_Interrupt;\n-   for Signal'Size use unsigned'Size;\n-\n-   type sigset_t is array (Signal) of Boolean;\n-   pragma Pack (sigset_t);\n-\n-   --  Interrupt_Number_Type\n-   --  Unsigned long integer denoting the number of an interrupt\n-\n-   subtype Interrupt_Number_Type is unsigned_long;\n-\n-   --  OpenVMS system services return values of type Cond_Value_Type\n-\n-   subtype Cond_Value_Type is unsigned_long;\n-   subtype Short_Cond_Value_Type is unsigned_short;\n-\n-   type IO_Status_Block_Type is record\n-      Status   : Short_Cond_Value_Type;\n-      Count    : unsigned_short;\n-      Dev_Info : unsigned_long;\n-   end record;\n-\n-   type AST_Handler is access procedure (Param : Address);\n-   pragma Convention (C, AST_Handler);\n-   No_AST_Handler : constant AST_Handler := null;\n-\n-   CMB_M_READONLY  : constant := 16#00000001#;\n-   CMB_M_WRITEONLY : constant := 16#00000002#;\n-   AGN_M_READONLY  : constant := 16#00000001#;\n-   AGN_M_WRITEONLY : constant := 16#00000002#;\n-\n-   IO_WRITEVBLK : constant := 48;  --  WRITE VIRTUAL BLOCK\n-   IO_READVBLK  : constant := 49;  --  READ VIRTUAL BLOCK\n-\n-   ----------------\n-   -- Sys_Assign --\n-   ----------------\n-   --\n-   --  Assign I/O Channel\n-   --\n-   --  Status = returned status\n-   --  Devnam = address  of  device  name  or  logical  name   string\n-   --               descriptor\n-   --  Chan   = address of word to receive channel number assigned\n-   --  Acmode = access mode associated with channel\n-   --  Mbxnam = address of mailbox logical name string descriptor, if\n-   --               mailbox associated with device\n-   --  Flags  = optional channel flags longword for specifying options\n-   --           for the $ASSIGN operation\n-   --\n-\n-   procedure Sys_Assign\n-     (Status : out Cond_Value_Type;\n-      Devnam : String;\n-      Chan   : out unsigned_short;\n-      Acmode : unsigned_short := 0;\n-      Mbxnam : String := String'Null_Parameter;\n-      Flags  : unsigned_long := 0);\n-   pragma Import (External, Sys_Assign);\n-   pragma Import_Valued_Procedure\n-     (Sys_Assign, \"SYS$ASSIGN\",\n-      (Cond_Value_Type, String,         unsigned_short,\n-       unsigned_short,  String,         unsigned_long),\n-      (Value,           Descriptor (s), Reference,\n-       Value,           Descriptor (s), Value),\n-      Flags);\n-\n-   ----------------\n-   -- Sys_Cantim --\n-   ----------------\n-   --\n-   --  Cancel Timer\n-   --\n-   --  Status  = returned status\n-   --  Reqidt  = ID of timer to be cancelled\n-   --  Acmode  = Access mode\n-   --\n-   procedure Sys_Cantim\n-     (Status : out Cond_Value_Type;\n-      Reqidt : Address;\n-      Acmode : unsigned);\n-   pragma Import (External, Sys_Cantim);\n-   pragma Import_Valued_Procedure\n-     (Sys_Cantim, \"SYS$CANTIM\",\n-      (Cond_Value_Type, Address, unsigned),\n-      (Value,           Value,   Value));\n-\n-   ----------------\n-   -- Sys_Crembx --\n-   ----------------\n-   --\n-   --  Create mailbox\n-   --\n-   --     Status  = returned status\n-   --     Prmflg  = permanent flag\n-   --     Chan    = channel\n-   --     Maxmsg  = maximum message\n-   --     Bufquo  = buufer quote\n-   --     Promsk  = protection mast\n-   --     Acmode  = access mode\n-   --     Lognam  = logical name\n-   --     Flags   = flags\n-   --\n-   procedure Sys_Crembx\n-     (Status : out Cond_Value_Type;\n-      Prmflg : unsigned_char;\n-      Chan   : out unsigned_short;\n-      Maxmsg : unsigned_long := 0;\n-      Bufquo : unsigned_long := 0;\n-      Promsk : unsigned_short := 0;\n-      Acmode : unsigned_short := 0;\n-      Lognam : String;\n-      Flags  : unsigned_long := 0);\n-   pragma Import (External, Sys_Crembx);\n-   pragma Import_Valued_Procedure\n-     (Sys_Crembx, \"SYS$CREMBX\",\n-      (Cond_Value_Type, unsigned_char,  unsigned_short,\n-       unsigned_long,   unsigned_long,  unsigned_short,\n-       unsigned_short,  String,         unsigned_long),\n-      (Value,           Value,          Reference,\n-       Value,           Value,          Value,\n-       Value,           Descriptor (s), Value));\n-\n-   -------------\n-   -- Sys_QIO --\n-   -------------\n-   --\n-   --    Queue I/O\n-   --\n-   --     Status = Returned status of call\n-   --     EFN    = event flag to be set when I/O completes\n-   --     Chan   = channel\n-   --     Func   = function\n-   --     Iosb   = I/O status block\n-   --     Astadr = system trap to be generated when I/O completes\n-   --     Astprm = AST parameter\n-   --     P1-6   = optional parameters\n-\n-   procedure Sys_QIO\n-     (Status : out Cond_Value_Type;\n-      EFN    : unsigned_long := 0;\n-      Chan   : unsigned_short;\n-      Func   : unsigned_long := 0;\n-      Iosb   : out IO_Status_Block_Type;\n-      Astadr : AST_Handler := No_AST_Handler;\n-      Astprm : Address := Null_Address;\n-      P1     : unsigned_long := 0;\n-      P2     : unsigned_long := 0;\n-      P3     : unsigned_long := 0;\n-      P4     : unsigned_long := 0;\n-      P5     : unsigned_long := 0;\n-      P6     : unsigned_long := 0);\n-\n-   procedure Sys_QIO\n-     (Status : out Cond_Value_Type;\n-      EFN    : unsigned_long := 0;\n-      Chan   : unsigned_short;\n-      Func   : unsigned_long := 0;\n-      Iosb   : Address := Null_Address;\n-      Astadr : AST_Handler := No_AST_Handler;\n-      Astprm : Address := Null_Address;\n-      P1     : unsigned_long := 0;\n-      P2     : unsigned_long := 0;\n-      P3     : unsigned_long := 0;\n-      P4     : unsigned_long := 0;\n-      P5     : unsigned_long := 0;\n-      P6     : unsigned_long := 0);\n-\n-   pragma Import (External, Sys_QIO);\n-   pragma Import_Valued_Procedure\n-     (Sys_QIO, \"SYS$QIO\",\n-      (Cond_Value_Type,      unsigned_long, unsigned_short, unsigned_long,\n-       IO_Status_Block_Type, AST_Handler,   Address,\n-       unsigned_long,        unsigned_long, unsigned_long,\n-       unsigned_long,        unsigned_long, unsigned_long),\n-      (Value,                Value,         Value,          Value,\n-       Reference,            Value,         Value,\n-       Value,                Value,         Value,\n-       Value,                Value,         Value));\n-\n-   pragma Import_Valued_Procedure\n-     (Sys_QIO, \"SYS$QIO\",\n-      (Cond_Value_Type, unsigned_long, unsigned_short, unsigned_long,\n-       Address,         AST_Handler,   Address,\n-       unsigned_long,   unsigned_long, unsigned_long,\n-       unsigned_long,   unsigned_long, unsigned_long),\n-      (Value,           Value,         Value,          Value,\n-       Value,           Value,         Value,\n-       Value,           Value,         Value,\n-       Value,           Value,         Value));\n-\n-   ----------------\n-   -- Sys_Setimr --\n-   ----------------\n-   --\n-   --    Set Timer\n-   --\n-   --     Status = Returned status of call\n-   --     EFN    = event flag to be set when timer expires\n-   --     Tim    = expiration time\n-   --     AST    = system trap to be generated when timer expires\n-   --     Redidt = returned ID of timer (e.g. to cancel timer)\n-   --     Flags  = flags\n-   --\n-   procedure Sys_Setimr\n-     (Status : out Cond_Value_Type;\n-      EFN    : unsigned_long;\n-      Tim    : Long_Integer;\n-      AST    : AST_Handler;\n-      Reqidt : Address;\n-      Flags  : unsigned_long);\n-   pragma Import (External, Sys_Setimr);\n-   pragma Import_Valued_Procedure\n-     (Sys_Setimr, \"SYS$SETIMR\",\n-      (Cond_Value_Type, unsigned_long,     Long_Integer,\n-       AST_Handler,     Address,           unsigned_long),\n-      (Value,           Value,             Reference,\n-       Value,           Value,             Value));\n-\n-   Interrupt_ID_0   : constant  := 0;\n-   Interrupt_ID_1   : constant  := 1;\n-   Interrupt_ID_2   : constant  := 2;\n-   Interrupt_ID_3   : constant  := 3;\n-   Interrupt_ID_4   : constant  := 4;\n-   Interrupt_ID_5   : constant  := 5;\n-   Interrupt_ID_6   : constant  := 6;\n-   Interrupt_ID_7   : constant  := 7;\n-   Interrupt_ID_8   : constant  := 8;\n-   Interrupt_ID_9   : constant  := 9;\n-   Interrupt_ID_10  : constant  := 10;\n-   Interrupt_ID_11  : constant  := 11;\n-   Interrupt_ID_12  : constant  := 12;\n-   Interrupt_ID_13  : constant  := 13;\n-   Interrupt_ID_14  : constant  := 14;\n-   Interrupt_ID_15  : constant  := 15;\n-   Interrupt_ID_16  : constant  := 16;\n-   Interrupt_ID_17  : constant  := 17;\n-   Interrupt_ID_18  : constant  := 18;\n-   Interrupt_ID_19  : constant  := 19;\n-   Interrupt_ID_20  : constant  := 20;\n-   Interrupt_ID_21  : constant  := 21;\n-   Interrupt_ID_22  : constant  := 22;\n-   Interrupt_ID_23  : constant  := 23;\n-   Interrupt_ID_24  : constant  := 24;\n-   Interrupt_ID_25  : constant  := 25;\n-   Interrupt_ID_26  : constant  := 26;\n-   Interrupt_ID_27  : constant  := 27;\n-   Interrupt_ID_28  : constant  := 28;\n-   Interrupt_ID_29  : constant  := 29;\n-   Interrupt_ID_30  : constant  := 30;\n-   Interrupt_ID_31  : constant  := 31;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EINTR  : constant := 4;   --  Interrupted system call\n-   EAGAIN : constant := 11;  --  No more processes\n-   ENOMEM : constant := 12;  --  Not enough core\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 1;\n-   SCHED_RR    : constant := 2;\n-   SCHED_OTHER : constant := 3;\n-   SCHED_BG    : constant := 4;\n-   SCHED_LFI   : constant := 5;\n-   SCHED_LRR   : constant := 6;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill);\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid);\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-   pragma Convention (C, Thread_Body);\n-\n-   function Thread_Body_Access is new\n-     Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_JOINABLE     : constant := 0;\n-   PTHREAD_CREATE_DETACHED     : constant := 1;\n-\n-   PTHREAD_CANCEL_DISABLE      : constant := 0;\n-   PTHREAD_CANCEL_ENABLE       : constant := 1;\n-\n-   PTHREAD_CANCEL_DEFERRED     : constant := 0;\n-   PTHREAD_CANCEL_ASYNCHRONOUS : constant := 1;\n-\n-   --  Don't use ERRORCHECK mutexes, they don't work when a thread is not\n-   --  the owner.  AST's, at least, unlock others threads mutexes. Even\n-   --  if the error is ignored, they don't work.\n-   PTHREAD_MUTEX_NORMAL_NP     : constant := 0;\n-   PTHREAD_MUTEX_RECURSIVE_NP  : constant := 1;\n-   PTHREAD_MUTEX_ERRORCHECK_NP : constant := 2;\n-\n-   PTHREAD_INHERIT_SCHED       : constant := 0;\n-   PTHREAD_EXPLICIT_SCHED      : constant := 1;\n-\n-   function pthread_cancel (thread : pthread_t) return int;\n-   pragma Import (C, pthread_cancel, \"PTHREAD_CANCEL\");\n-\n-   procedure pthread_testcancel;\n-   pragma Import (C, pthread_testcancel, \"PTHREAD_TESTCANCEL\");\n-\n-   function pthread_setcancelstate\n-     (newstate : int; oldstate : access int) return int;\n-   pragma Import (C, pthread_setcancelstate, \"PTHREAD_SETCANCELSTATE\");\n-\n-   function pthread_setcanceltype\n-     (newtype : int; oldtype : access int) return int;\n-   pragma Import (C, pthread_setcanceltype, \"PTHREAD_SETCANCELTYPE\");\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function pthread_lock_global_np return int;\n-   pragma Import (C, pthread_lock_global_np, \"PTHREAD_LOCK_GLOBAL_NP\");\n-\n-   function pthread_unlock_global_np return int;\n-   pragma Import (C, pthread_unlock_global_np, \"PTHREAD_UNLOCK_GLOBAL_NP\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"PTHREAD_MUTEXATTR_INIT\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"PTHREAD_MUTEXATTR_DESTROY\");\n-\n-   function pthread_mutexattr_settype_np\n-     (attr      : access pthread_mutexattr_t;\n-      mutextype : int) return int;\n-   pragma Import (C, pthread_mutexattr_settype_np,\n-                     \"PTHREAD_MUTEXATTR_SETTYPE_NP\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"PTHREAD_MUTEX_INIT\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"PTHREAD_MUTEX_DESTROY\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"PTHREAD_MUTEX_LOCK\");\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"PTHREAD_MUTEX_UNLOCK\");\n-\n-   function pthread_mutex_setname_np\n-     (attr : access pthread_mutex_t;\n-      name : System.Address;\n-      mbz  : System.Address) return int;\n-   pragma Import (C, pthread_mutex_setname_np, \"PTHREAD_MUTEX_SETNAME_NP\");\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"PTHREAD_CONDATTR_INIT\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"PTHREAD_CONDATTR_DESTROY\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"PTHREAD_COND_INIT\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"PTHREAD_COND_DESTROY\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"PTHREAD_COND_SIGNAL\");\n-\n-   function pthread_cond_signal_int_np\n-     (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal_int_np,\n-                  \"PTHREAD_COND_SIGNAL_INT_NP\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"PTHREAD_COND_WAIT\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr : access pthread_mutexattr_t; protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol,\n-                     \"PTHREAD_MUTEXATTR_SETPROTOCOL\");\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-   for struct_sched_param'Size use 8 * 4;\n-   pragma Convention (C, struct_sched_param);\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Import (C, pthread_setschedparam, \"PTHREAD_SETSCHEDPARAM\");\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"PTHREAD_ATTR_SETSCOPE\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr            : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched,\n-                     \"PTHREAD_ATTR_SETINHERITSCHED\");\n-\n-   function pthread_attr_setschedpolicy\n-     (attr : access pthread_attr_t; policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy,\n-                     \"PTHREAD_ATTR_SETSCHEDPOLICY\");\n-\n-   function pthread_attr_setschedparam\n-     (attr        : access pthread_attr_t;\n-      sched_param : int) return int;\n-   pragma Import (C, pthread_attr_setschedparam, \"PTHREAD_ATTR_SETSCHEDPARAM\");\n-\n-   function pthread_attr_setname_np\n-     (attr : access pthread_attr_t;\n-      name : System.Address;\n-      mbz  : System.Address) return int;\n-   pragma Import (C, pthread_attr_setname_np, \"PTHREAD_ATTR_SETNAME_NP\");\n-\n-   function sched_yield return int;\n-\n-   --------------------------\n-   -- P1003.1c  Section 16 --\n-   --------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"PTHREAD_ATTR_INIT\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"PTHREAD_ATTR_DESTROY\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Import (C, pthread_attr_setdetachstate,\n-                     \"PTHREAD_ATTR_SETDETACHSTATE\");\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"PTHREAD_ATTR_SETSTACKSIZE\");\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"PTHREAD_CREATE\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"PTHREAD_EXIT\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"PTHREAD_SELF\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return  int;\n-   pragma Import (C, pthread_setspecific, \"PTHREAD_SETSPECIFIC\");\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Import (C, pthread_getspecific, \"PTHREAD_GETSPECIFIC\");\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-   pragma Convention (C, destructor_pointer);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Import (C, pthread_key_create, \"PTHREAD_KEY_CREATE\");\n-\n-private\n-\n-   type pid_t is new int;\n-\n-   type pthreadLongAddr_p is mod 2 ** Long_Integer'Size;\n-\n-   type pthreadLongAddr_t is mod 2 ** Long_Integer'Size;\n-   type pthreadLongAddr_t_ptr is mod 2 ** Long_Integer'Size;\n-\n-   type pthreadLongString_t is mod 2 ** Long_Integer'Size;\n-\n-   type pthreadLongUint_t is mod 2 ** Long_Integer'Size;\n-   type pthreadLongUint_array is array (Natural range <>)\n-     of pthreadLongUint_t;\n-\n-   type pthread_t is mod 2 ** Long_Integer'Size;\n-\n-   type pthread_cond_t is record\n-      state    : unsigned;\n-      valid    : unsigned;\n-      name     : pthreadLongString_t;\n-      arg      : unsigned;\n-      sequence : unsigned;\n-      block    : pthreadLongAddr_t_ptr;\n-   end record;\n-   for pthread_cond_t'Size use 8 * 32;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_attr_t is record\n-      valid    : long;\n-      name     : pthreadLongString_t;\n-      arg      : pthreadLongUint_t;\n-      reserved : pthreadLongUint_array (0 .. 18);\n-   end record;\n-   for pthread_attr_t'Size use 8 * 176;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_mutex_t is record\n-      lock     : unsigned;\n-      valid    : unsigned;\n-      name     : pthreadLongString_t;\n-      arg      : unsigned;\n-      sequence : unsigned;\n-      block    : pthreadLongAddr_p;\n-      owner    : unsigned;\n-      depth    : unsigned;\n-   end record;\n-   for pthread_mutex_t'Size use 8 * 40;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_mutexattr_t is record\n-      valid    : long;\n-      reserved : pthreadLongUint_array (0 .. 14);\n-   end record;\n-   for pthread_mutexattr_t'Size use 8 * 128;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type pthread_condattr_t is record\n-      valid    : long;\n-      reserved : pthreadLongUint_array (0 .. 12);\n-   end record;\n-   for pthread_condattr_t'Size use 8 * 112;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_key_t is new unsigned;\n-\n-   pragma Inline (pthread_self);\n-\n-end System.OS_Interface;"}, {"sha": "5fa499bd13f7339725a3bab2a733b05190bc066a", "filename": "gcc/ada/s-osprim-vms.adb", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osprim-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osprim-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,209 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                  S Y S T E M . O S _ P R I M I T I V E S                 --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1998-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS/Alpha version of this file\n-\n-with System.Aux_DEC;\n-\n-package body System.OS_Primitives is\n-\n-   --------------------------------------\n-   -- Local functions and declarations --\n-   --------------------------------------\n-\n-   function Get_GMToff return Integer;\n-   pragma Import (C, Get_GMToff, \"get_gmtoff\");\n-   --  Get the offset from GMT for this timezone\n-\n-   function VMS_Epoch_Offset return Long_Integer;\n-   pragma Inline (VMS_Epoch_Offset);\n-   --  The offset between the Unix Epoch and the VMS Epoch\n-\n-   subtype Cond_Value_Type is System.Aux_DEC.Unsigned_Longword;\n-   --  Condition Value return type\n-\n-   ----------------------\n-   -- VMS_Epoch_Offset --\n-   ----------------------\n-\n-   function VMS_Epoch_Offset return Long_Integer is\n-   begin\n-      return 10_000_000 * (3_506_716_800 + Long_Integer (Get_GMToff));\n-   end VMS_Epoch_Offset;\n-\n-   ----------------\n-   -- Sys_Schdwk --\n-   ----------------\n-   --\n-   --  Schedule Wakeup\n-   --\n-   --  status = returned status\n-   --  pidadr = address of process id to be woken up\n-   --  prcnam = name of process to be woken up\n-   --  daytim = time to wake up\n-   --  reptim = repetition interval of wakeup calls\n-   --\n-\n-   procedure Sys_Schdwk\n-     (\n-      Status : out Cond_Value_Type;\n-      Pidadr : Address := Null_Address;\n-      Prcnam : String := String'Null_Parameter;\n-      Daytim : Long_Integer;\n-      Reptim : Long_Integer := Long_Integer'Null_Parameter\n-     );\n-\n-   pragma Import (External, Sys_Schdwk);\n-   --  VMS system call to schedule a wakeup event\n-   pragma Import_Valued_Procedure\n-     (Sys_Schdwk, \"SYS$SCHDWK\",\n-      (Cond_Value_Type, Address, String,         Long_Integer, Long_Integer),\n-      (Value,           Value,   Descriptor (S), Reference,    Reference)\n-     );\n-\n-   ----------------\n-   -- Sys_Gettim --\n-   ----------------\n-   --\n-   --  Get System Time\n-   --\n-   --  status = returned status\n-   --  tim    = current system time\n-   --\n-\n-   procedure Sys_Gettim\n-     (\n-      Status : out Cond_Value_Type;\n-      Tim    : out OS_Time\n-     );\n-   --  VMS system call to get the current system time\n-   pragma Import (External, Sys_Gettim);\n-   pragma Import_Valued_Procedure\n-     (Sys_Gettim, \"SYS$GETTIM\",\n-      (Cond_Value_Type, OS_Time),\n-      (Value,           Reference)\n-     );\n-\n-   ---------------\n-   -- Sys_Hiber --\n-   ---------------\n-\n-   --  Hibernate (until woken up)\n-\n-   --  status = returned status\n-\n-   procedure Sys_Hiber (Status : out Cond_Value_Type);\n-   --  VMS system call to hibernate the current process\n-   pragma Import (External, Sys_Hiber);\n-   pragma Import_Valued_Procedure\n-     (Sys_Hiber, \"SYS$HIBER\",\n-      (Cond_Value_Type),\n-      (Value)\n-     );\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   function OS_Clock return OS_Time is\n-      Status : Cond_Value_Type;\n-      T      : OS_Time;\n-   begin\n-      Sys_Gettim (Status, T);\n-      return (T);\n-   end OS_Clock;\n-\n-   -----------\n-   -- Clock --\n-   -----------\n-\n-   function Clock return Duration is\n-   begin\n-      return To_Duration (OS_Clock, Absolute_Calendar);\n-   end Clock;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize is\n-   begin\n-      null;\n-   end Initialize;\n-\n-   ---------------------\n-   -- Monotonic_Clock --\n-   ---------------------\n-\n-   function Monotonic_Clock return Duration renames Clock;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   procedure Timed_Delay\n-     (Time : Duration;\n-      Mode : Integer)\n-   is\n-      Sleep_Time : OS_Time;\n-      Status     : Cond_Value_Type;\n-      pragma Unreferenced (Status);\n-\n-   begin\n-      Sleep_Time := To_OS_Time (Time, Mode);\n-      Sys_Schdwk (Status => Status, Daytim => Sleep_Time);\n-      Sys_Hiber (Status);\n-   end Timed_Delay;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (T : OS_Time; Mode : Integer) return Duration is\n-      pragma Warnings (Off, Mode);\n-   begin\n-      return Duration'Fixed_Value (T - VMS_Epoch_Offset) * 100;\n-   end To_Duration;\n-\n-   ----------------\n-   -- To_OS_Time --\n-   ----------------\n-\n-   function To_OS_Time (D : Duration; Mode : Integer) return OS_Time is\n-   begin\n-      if Mode = Relative then\n-         return -(Long_Integer'Integer_Value (D) / 100);\n-      else\n-         return Long_Integer'Integer_Value (D) / 100 + VMS_Epoch_Offset;\n-      end if;\n-   end To_OS_Time;\n-\n-end System.OS_Primitives;"}, {"sha": "3b4ed328c8e1fa7de1a131caf4e451644e88253c", "filename": "gcc/ada/s-osprim-vms.ads", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osprim-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-osprim-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,110 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                  S Y S T E M . O S _ P R I M I T I V E S                 --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1998-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package provides low level primitives used to implement clock and\n---  delays in non tasking applications on Alpha/VMS.\n-\n---  The choice of the real clock/delay implementation (depending on whether\n---  tasking is involved or not) is done via soft links (see s-soflin.ads)\n-\n---  NEVER add any dependency to tasking packages here\n-\n-package System.OS_Primitives is\n-   pragma Preelaborate;\n-\n-   subtype OS_Time is Long_Integer;\n-   --  System time on VMS is used for performance reasons.\n-   --  Note that OS_Time is *not* the same as Ada.Calendar.Time, the\n-   --  difference being that relative OS_Time is negative, but relative\n-   --  Calendar.Time is positive.\n-   --  See Ada.Calendar.Delays for more information on VMS Time.\n-\n-   Max_Sensible_Delay : constant Duration :=\n-                          Duration'Min (183 * 24 * 60 * 60.0,\n-                                        Duration'Last);\n-   --  Max of half a year delay, needed to prevent exceptions for large delay\n-   --  values. It seems unlikely that any test will notice this restriction,\n-   --  except in the case of applications setting the clock at run time (see\n-   --  s-tastim.adb). Also note that a larger value might cause problems (e.g\n-   --  overflow, or more likely OS limitation in the primitives used). In the\n-   --  case where half a year is too long (which occurs in high integrity mode\n-   --  with 32-bit words, and possibly on some specific ports of GNAT),\n-   --  Duration'Last is used instead.\n-\n-   procedure Initialize;\n-   --  Initialize global settings related to this package. This procedure\n-   --  should be called before any other subprograms in this package. Note\n-   --  that this procedure can be called several times.\n-\n-   function OS_Clock return OS_Time;\n-   --  Returns \"absolute\" time, represented as an offset\n-   --  relative to \"the Epoch\", which is Nov 17, 1858 on VMS.\n-\n-   function Clock return Duration;\n-   pragma Inline (Clock);\n-   --  Returns \"absolute\" time, represented as an offset relative to \"the\n-   --  Epoch\", which is Jan 1, 1970 00:00:00 UTC on UNIX systems. This\n-   --  implementation is affected by system's clock changes.\n-\n-   function Monotonic_Clock return Duration;\n-   pragma Inline (Monotonic_Clock);\n-   --  Returns \"absolute\" time, represented as an offset relative to \"the Unix\n-   --  Epoch\", which is Jan 1, 1970 00:00:00 UTC. This clock implementation is\n-   --  immune to the system's clock changes.\n-\n-   Relative          : constant := 0;\n-   Absolute_Calendar : constant := 1;\n-   Absolute_RT       : constant := 2;\n-   --  Values for Mode call below. Note that the compiler (exp_ch9.adb) relies\n-   --  on these values. So any change here must be reflected in corresponding\n-   --  changes in the compiler.\n-\n-   procedure Timed_Delay (Time : Duration; Mode : Integer);\n-   --  Implements the semantics of the delay statement when no tasking is used\n-   --  in the application.\n-   --\n-   --    Mode is one of the three values above\n-   --\n-   --    Time is a relative or absolute duration value, depending on Mode.\n-   --\n-   --  Note that currently Ada.Real_Time always uses the tasking run time,\n-   --  so this procedure should never be called with Mode set to Absolute_RT.\n-   --  This may change in future or bare board implementations.\n-\n-   function To_Duration (T : OS_Time; Mode : Integer) return Duration;\n-   --  Convert VMS system time to Duration\n-   --  Mode is one of the three values above\n-\n-   function To_OS_Time (D : Duration; Mode : Integer) return OS_Time;\n-   --  Convert Duration to VMS system time\n-   --  Mode is one of the three values above\n-\n-end System.OS_Primitives;"}, {"sha": "1e7161fbe16729d1e936f56f83d8b22c7df60173", "filename": "gcc/ada/s-parame-vms-alpha.ads", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-parame-vms-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-parame-vms-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-alpha.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,215 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . P A R A M E T E R S                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS Alpha version\n-\n---  This package defines some system dependent parameters for GNAT. These\n---  are values that are referenced by the runtime library and are therefore\n---  relevant to the target machine.\n-\n---  The parameters whose value is defined in the spec are not generally\n---  expected to be changed. If they are changed, it will be necessary to\n---  recompile the run-time library.\n-\n---  The parameters which are defined by functions can be changed by modifying\n---  the body of System.Parameters in file s-parame.adb. A change to this body\n---  requires only rebinding and relinking of the application.\n-\n---  Note: do not introduce any pragma Inline statements into this unit, since\n---  otherwise the relinking and rebinding capability would be deactivated.\n-\n-package System.Parameters is\n-   pragma Pure;\n-\n-   ---------------------------------------\n-   -- Task And Stack Allocation Control --\n-   ---------------------------------------\n-\n-   type Task_Storage_Size is new Integer;\n-   --  Type used in tasking units for task storage size\n-\n-   type Size_Type is new Task_Storage_Size;\n-   --  Type used to provide task storage size to runtime\n-\n-   Unspecified_Size : constant Size_Type := Size_Type'First;\n-   --  Value used to indicate that no size type is set\n-\n-   subtype Percentage is Size_Type range -1 .. 100;\n-   Dynamic : constant Size_Type := -1;\n-   --  The secondary stack ratio is a constant between 0 and 100 which\n-   --  determines the percentage of the allocated task stack that is\n-   --  used by the secondary stack (the rest being the primary stack).\n-   --  The special value of minus one indicates that the secondary\n-   --  stack is to be allocated from the heap instead.\n-\n-   Sec_Stack_Percentage : constant Percentage := Dynamic;\n-   --  This constant defines the handling of the secondary stack\n-\n-   Sec_Stack_Dynamic : constant Boolean := Sec_Stack_Percentage = Dynamic;\n-   --  Convenient Boolean for testing for dynamic secondary stack\n-\n-   function Default_Stack_Size return Size_Type;\n-   --  Default task stack size used if none is specified\n-\n-   function Minimum_Stack_Size return Size_Type;\n-   --  Minimum task stack size permitted\n-\n-   function Adjust_Storage_Size (Size : Size_Type) return Size_Type;\n-   --  Given the storage size stored in the TCB, return the Storage_Size\n-   --  value required by the RM for the Storage_Size attribute. The\n-   --  required adjustment is as follows:\n-   --\n-   --    when Size = Unspecified_Size, return Default_Stack_Size\n-   --    when Size < Minimum_Stack_Size, return Minimum_Stack_Size\n-   --    otherwise return given Size\n-\n-   Default_Env_Stack_Size : constant Size_Type := 8_192_000;\n-   --  Assumed size of the environment task, if no other information\n-   --  is available. This value is used when stack checking is\n-   --  enabled and no GNAT_STACK_LIMIT environment variable is set.\n-\n-   Stack_Grows_Down  : constant Boolean := True;\n-   --  This constant indicates whether the stack grows up (False) or\n-   --  down (True) in memory as functions are called. It is used for\n-   --  proper implementation of the stack overflow check.\n-\n-   ----------------------------------------------\n-   -- Characteristics of types in Interfaces.C --\n-   ----------------------------------------------\n-\n-   long_bits : constant := 32;\n-   --  Number of bits in type long and unsigned_long. The normal convention\n-   --  is that this is the same as type Long_Integer, but this is not true\n-   --  of all targets. For example, in OpenVMS long /= Long_Integer.\n-\n-   ptr_bits  : constant := 32;\n-   subtype C_Address is System.Address\n-     range -2 ** (ptr_bits - 1) .. 2 ** (ptr_bits - 1) - 1;\n-   for C_Address'Object_Size use ptr_bits;\n-   --  Number of bits in Interfaces.C pointers, normally a standard address,\n-   --  except on 64-bit VMS where they are 32-bit addresses, for compatibility\n-   --  with legacy code. System.Aux_DEC.Short_Address can't be used because of\n-   --  elaboration circularity.\n-\n-   C_Malloc_Linkname : constant String := \"__gnat_malloc32\";\n-   --  Name of runtime function used to allocate such a pointer\n-\n-   ----------------------------------------------\n-   -- Behavior of Pragma Finalize_Storage_Only --\n-   ----------------------------------------------\n-\n-   --  Garbage_Collected is a Boolean constant whose value indicates the\n-   --  effect of the pragma Finalize_Storage_Entry on a controlled type.\n-\n-   --    Garbage_Collected = False\n-\n-   --      The system releases all storage on program termination only,\n-   --      but not other garbage collection occurs, so finalization calls\n-   --      are omitted only for outer level objects can be omitted if\n-   --      pragma Finalize_Storage_Only is used.\n-\n-   --    Garbage_Collected = True\n-\n-   --      The system provides full garbage collection, so it is never\n-   --      necessary to release storage for controlled objects for which\n-   --      a pragma Finalize_Storage_Only is used.\n-\n-   Garbage_Collected : constant Boolean := False;\n-   --  The storage mode for this system (release on program exit)\n-\n-   ---------------------\n-   -- Tasking Profile --\n-   ---------------------\n-\n-   --  In the following sections, constant parameters are defined to\n-   --  allow some optimizations and fine tuning within the tasking run time\n-   --  based on restrictions on the tasking features.\n-\n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := True;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n-   -------------------\n-   -- Task Abortion --\n-   -------------------\n-\n-   No_Abort : constant Boolean := False;\n-   --  This constant indicates whether abort statements and asynchronous\n-   --  transfer of control (ATC) are disallowed. If set to True, it is\n-   --  assumed that neither construct is used, and the run time does not\n-   --  need to defer/undefer abort and check for pending actions at\n-   --  completion points. A value of True for No_Abort corresponds to:\n-   --  pragma Restrictions (No_Abort_Statements);\n-   --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n-\n-   ---------------------\n-   -- Task Attributes --\n-   ---------------------\n-\n-   Max_Attribute_Count : constant := 32;\n-   --  Number of task attributes stored in the task control block\n-\n-   --------------------\n-   -- Runtime Traces --\n-   --------------------\n-\n-   Runtime_Traces : constant Boolean := False;\n-   --  This constant indicates whether the runtime outputs traces to a\n-   --  predefined output or not (True means that traces are output).\n-   --  See System.Traces for more details.\n-\n-   -----------------------\n-   -- Task Image Length --\n-   -----------------------\n-\n-   Max_Task_Image_Length : constant := 256;\n-   --  This constant specifies the maximum length of a task's image\n-\n-   ------------------------------\n-   -- Exception Message Length --\n-   ------------------------------\n-\n-   Default_Exception_Msg_Max_Length : constant := 512;\n-   --  This constant specifies the maximum number of characters to allow in an\n-   --  exception message (see RM 11.4.1(18)). The value for VMS exceeds the\n-   --  default minimum of 200 to allow for the length of chained VMS condition\n-   --  handling messages.\n-\n-end System.Parameters;"}, {"sha": "0f18f3dcf2877dc0ffcab9d827d4f020f9594a12", "filename": "gcc/ada/s-parame-vms-ia64.ads", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-parame-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-parame-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-ia64.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,215 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . P A R A M E T E R S                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Integrity OpenVMS version\n-\n---  This package defines some system dependent parameters for GNAT. These\n---  are values that are referenced by the runtime library and are therefore\n---  relevant to the target machine.\n-\n---  The parameters whose value is defined in the spec are not generally\n---  expected to be changed. If they are changed, it will be necessary to\n---  recompile the run-time library.\n-\n---  The parameters which are defined by functions can be changed by modifying\n---  the body of System.Parameters in file s-parame.adb. A change to this body\n---  requires only rebinding and relinking of the application.\n-\n---  Note: do not introduce any pragma Inline statements into this unit, since\n---  otherwise the relinking and rebinding capability would be deactivated.\n-\n-package System.Parameters is\n-   pragma Pure;\n-\n-   ---------------------------------------\n-   -- Task And Stack Allocation Control --\n-   ---------------------------------------\n-\n-   type Task_Storage_Size is new Integer;\n-   --  Type used in tasking units for task storage size\n-\n-   type Size_Type is new Task_Storage_Size;\n-   --  Type used to provide task storage size to runtime\n-\n-   Unspecified_Size : constant Size_Type := Size_Type'First;\n-   --  Value used to indicate that no size type is set\n-\n-   subtype Percentage is Size_Type range -1 .. 100;\n-   Dynamic : constant Size_Type := -1;\n-   --  The secondary stack ratio is a constant between 0 and 100 which\n-   --  determines the percentage of the allocated task stack that is\n-   --  used by the secondary stack (the rest being the primary stack).\n-   --  The special value of minus one indicates that the secondary\n-   --  stack is to be allocated from the heap instead.\n-\n-   Sec_Stack_Percentage : constant Percentage := Dynamic;\n-   --  This constant defines the handling of the secondary stack\n-\n-   Sec_Stack_Dynamic : constant Boolean := Sec_Stack_Percentage = Dynamic;\n-   --  Convenient Boolean for testing for dynamic secondary stack\n-\n-   function Default_Stack_Size return Size_Type;\n-   --  Default task stack size used if none is specified\n-\n-   function Minimum_Stack_Size return Size_Type;\n-   --  Minimum task stack size permitted\n-\n-   function Adjust_Storage_Size (Size : Size_Type) return Size_Type;\n-   --  Given the storage size stored in the TCB, return the Storage_Size\n-   --  value required by the RM for the Storage_Size attribute. The\n-   --  required adjustment is as follows:\n-   --\n-   --    when Size = Unspecified_Size, return Default_Stack_Size\n-   --    when Size < Minimum_Stack_Size, return Minimum_Stack_Size\n-   --    otherwise return given Size\n-\n-   Default_Env_Stack_Size : constant Size_Type := 8_192_000;\n-   --  Assumed size of the environment task, if no other information\n-   --  is available. This value is used when stack checking is\n-   --  enabled and no GNAT_STACK_LIMIT environment variable is set.\n-\n-   Stack_Grows_Down  : constant Boolean := True;\n-   --  This constant indicates whether the stack grows up (False) or\n-   --  down (True) in memory as functions are called. It is used for\n-   --  proper implementation of the stack overflow check.\n-\n-   ----------------------------------------------\n-   -- Characteristics of types in Interfaces.C --\n-   ----------------------------------------------\n-\n-   long_bits : constant := 32;\n-   --  Number of bits in type long and unsigned_long. The normal convention\n-   --  is that this is the same as type Long_Integer, but this is not true\n-   --  of all targets. For example, in OpenVMS long /= Long_Integer.\n-\n-   ptr_bits  : constant := 32;\n-   subtype C_Address is System.Address\n-     range -2 ** (ptr_bits - 1) .. 2 ** (ptr_bits - 1) - 1;\n-   for C_Address'Object_Size use ptr_bits;\n-   --  Number of bits in Interfaces.C pointers, normally a standard address,\n-   --  except on 64-bit VMS where they are 32-bit addresses, for compatibility\n-   --  with legacy code. System.Aux_DEC.Short_Address can't be used because of\n-   --  elaboration circularity.\n-\n-   C_Malloc_Linkname : constant String := \"__gnat_malloc32\";\n-   --  Name of runtime function used to allocate such a pointer\n-\n-   ----------------------------------------------\n-   -- Behavior of Pragma Finalize_Storage_Only --\n-   ----------------------------------------------\n-\n-   --  Garbage_Collected is a Boolean constant whose value indicates the\n-   --  effect of the pragma Finalize_Storage_Entry on a controlled type.\n-\n-   --    Garbage_Collected = False\n-\n-   --      The system releases all storage on program termination only,\n-   --      but not other garbage collection occurs, so finalization calls\n-   --      are omitted only for outer level objects can be omitted if\n-   --      pragma Finalize_Storage_Only is used.\n-\n-   --    Garbage_Collected = True\n-\n-   --      The system provides full garbage collection, so it is never\n-   --      necessary to release storage for controlled objects for which\n-   --      a pragma Finalize_Storage_Only is used.\n-\n-   Garbage_Collected : constant Boolean := False;\n-   --  The storage mode for this system (release on program exit)\n-\n-   ---------------------\n-   -- Tasking Profile --\n-   ---------------------\n-\n-   --  In the following sections, constant parameters are defined to\n-   --  allow some optimizations and fine tuning within the tasking run time\n-   --  based on restrictions on the tasking features.\n-\n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := False;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n-   -------------------\n-   -- Task Abortion --\n-   -------------------\n-\n-   No_Abort : constant Boolean := False;\n-   --  This constant indicates whether abort statements and asynchronous\n-   --  transfer of control (ATC) are disallowed. If set to True, it is\n-   --  assumed that neither construct is used, and the run time does not\n-   --  need to defer/undefer abort and check for pending actions at\n-   --  completion points. A value of True for No_Abort corresponds to:\n-   --  pragma Restrictions (No_Abort_Statements);\n-   --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n-\n-   ---------------------\n-   -- Task Attributes --\n-   ---------------------\n-\n-   Max_Attribute_Count : constant := 32;\n-   --  Number of task attributes stored in the task control block\n-\n-   --------------------\n-   -- Runtime Traces --\n-   --------------------\n-\n-   Runtime_Traces : constant Boolean := False;\n-   --  This constant indicates whether the runtime outputs traces to a\n-   --  predefined output or not (True means that traces are output).\n-   --  See System.Traces for more details.\n-\n-   -----------------------\n-   -- Task Image Length --\n-   -----------------------\n-\n-   Max_Task_Image_Length : constant := 256;\n-   --  This constant specifies the maximum length of a task's image\n-\n-   ------------------------------\n-   -- Exception Message Length --\n-   ------------------------------\n-\n-   Default_Exception_Msg_Max_Length : constant := 512;\n-   --  This constant specifies the maximum number of characters to allow in an\n-   --  exception message (see RM 11.4.1(18)). The value for VMS exceeds the\n-   --  default minimum of 200 to allow for the length of chained VMS condition\n-   --  handling messages.\n-\n-end System.Parameters;"}, {"sha": "713edaef79f81715c79f40c8cf23401ceecdc4aa", "filename": "gcc/ada/s-ransee-vms.adb", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-ransee-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-ransee-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-ransee-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,51 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                   S Y S T E M . R A N D O M _ S E E D                    --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2011-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  Version used on OpenVMS systems, where Clock accuracy is too low for\n---  RM A.5.2(45).\n-\n-with Interfaces; use Interfaces;\n-\n-package body System.Random_Seed is\n-\n-   function Sys_Rpcc_64 return Unsigned_64;\n-   pragma Import (C, Sys_Rpcc_64, \"SYS$RPCC_64\");\n-\n-   --------------\n-   -- Get_Seed --\n-   --------------\n-\n-   function Get_Seed return Interfaces.Unsigned_64 is\n-   begin\n-      return Sys_Rpcc_64;\n-   end Get_Seed;\n-\n-end System.Random_Seed;"}, {"sha": "b111f31a7a0434fa5b8d99534eb4636093aaea4a", "filename": "gcc/ada/s-taasde.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fs-taasde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fs-taasde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taasde.adb?ref=f9648959b41d5c443702c809676056f1f39c56de", "patch": "@@ -153,9 +153,9 @@ package body System.Tasking.Async_Delays is\n       STI.Undefer_Abort_Nestable (D.Self_Id);\n    end Cancel_Async_Delay;\n \n-   ---------------------------\n-   -- Enqueue_Time_Duration --\n-   ---------------------------\n+   ----------------------\n+   -- Enqueue_Duration --\n+   ----------------------\n \n    function Enqueue_Duration\n      (T : Duration;"}, {"sha": "53034cad012318297913418c2cb1fd29ac48aab9", "filename": "gcc/ada/s-taprop-vms.adb", "status": "removed", "additions": 0, "deletions": 1278, "changes": 1278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-taprop-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-taprop-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,1278 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---         Copyright (C) 1992-2012, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/Alpha version of this package\n-\n---  This package contains all the GNULL primitives that interface directly with\n---  the underlying OS.\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during tasking\n---  operations. It causes infinite loops and other problems.\n-\n-with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-\n-with System.Tasking.Debug;\n-with System.OS_Primitives;\n-with System.Soft_Links;\n-with System.Aux_DEC;\n-\n-package body System.Task_Primitives.Operations is\n-\n-   use System.Tasking.Debug;\n-   use System.Tasking;\n-   use Interfaces.C;\n-   use System.OS_Interface;\n-   use System.Parameters;\n-   use System.OS_Primitives;\n-   use type System.OS_Primitives.OS_Time;\n-\n-   package SSL renames System.Soft_Links;\n-\n-   ----------------\n-   -- Local Data --\n-   ----------------\n-\n-   --  The followings are logically constants, but need to be initialized\n-   --  at run time.\n-\n-   Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at\n-   --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n-\n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_Id associated with a thread\n-\n-   Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task\n-\n-   Time_Slice_Val : Integer;\n-   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n-\n-   Dispatching_Policy : Character;\n-   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n-\n-   Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads)\n-\n-   --------------------\n-   -- Local Packages --\n-   --------------------\n-\n-   package Specific is\n-\n-      procedure Initialize (Environment_Task : Task_Id);\n-      pragma Inline (Initialize);\n-      --  Initialize various data needed by this package\n-\n-      function Is_Valid_Task return Boolean;\n-      pragma Inline (Is_Valid_Task);\n-      --  Does executing thread have a TCB?\n-\n-      procedure Set (Self_Id : Task_Id);\n-      pragma Inline (Set);\n-      --  Set the self id for the current task\n-\n-      function Self return Task_Id;\n-      pragma Inline (Self);\n-      --  Return a pointer to the Ada Task Control Block of the calling task\n-\n-   end Specific;\n-\n-   package body Specific is separate;\n-   --  The body of this package is target specific\n-\n-   ----------------------------------\n-   -- ATCB allocation/deallocation --\n-   ----------------------------------\n-\n-   package body ATCB_Allocation is separate;\n-   --  The body of this package is shared across several targets\n-\n-   ---------------------------------\n-   -- Support for foreign threads --\n-   ---------------------------------\n-\n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n-   --  Allocate and Initialize a new ATCB for the current Thread\n-\n-   function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_Id is separate;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function To_Task_Id is\n-     new Ada.Unchecked_Conversion\n-       (System.Task_Primitives.Task_Address, Task_Id);\n-\n-   function To_Address is\n-     new Ada.Unchecked_Conversion\n-       (Task_Id, System.Task_Primitives.Task_Address);\n-\n-   procedure Timer_Sleep_AST (ID : Address);\n-   pragma Convention (C, Timer_Sleep_AST);\n-   --  Signal the condition variable when AST fires\n-\n-   procedure Timer_Sleep_AST (ID : Address) is\n-      Result : Interfaces.C.int;\n-      pragma Warnings (Off, Result);\n-      Self_ID : constant Task_Id := To_Task_Id (ID);\n-   begin\n-      Self_ID.Common.LL.AST_Pending := False;\n-      Result := pthread_cond_signal_int_np (Self_ID.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Timer_Sleep_AST;\n-\n-   -----------------\n-   -- Stack_Guard --\n-   -----------------\n-\n-   --  The underlying thread system sets a guard page at the bottom of a thread\n-   --  stack, so nothing is needed.\n-   --  ??? Check the comment above\n-\n-   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (On);\n-   begin\n-      null;\n-   end Stack_Guard;\n-\n-   --------------------\n-   -- Get_Thread_Id  --\n-   --------------------\n-\n-   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n-   begin\n-      return T.Common.LL.Thread;\n-   end Get_Thread_Id;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   function Self return Task_Id renames Specific.Self;\n-\n-   ---------------------\n-   -- Initialize_Lock --\n-   ---------------------\n-\n-   --  Note: mutexes and cond_variables needed per-task basis are initialized\n-   --  in Initialize_TCB and the Storage_Error is handled. Other mutexes (such\n-   --  as RTS_Lock, Memory_Lock...) used in RTS is initialized before any\n-   --  status change of RTS. Therefore raising Storage_Error in the following\n-   --  routines should be able to be handled safely.\n-\n-   procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n-      L    : not null access Lock)\n-   is\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      L.Prio_Save := 0;\n-      L.Prio := Interfaces.C.int (Prio);\n-\n-      Result := pthread_mutex_init (L.L'Access, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_Lock;\n-\n-   procedure Initialize_Lock\n-     (L     : not null access RTS_Lock;\n-      Level : Lock_Level)\n-   is\n-      pragma Unreferenced (Level);\n-\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n---      Don't use, see comment in s-osinte.ads about ERRORCHECK mutexes???\n---      Result := pthread_mutexattr_settype_np\n---        (Attributes'Access, PTHREAD_MUTEX_ERRORCHECK_NP);\n---      pragma Assert (Result = 0);\n-\n---      Result := pthread_mutexattr_setprotocol\n---        (Attributes'Access, PTHREAD_PRIO_PROTECT);\n---      pragma Assert (Result = 0);\n-\n---      Result := pthread_mutexattr_setprioceiling\n---         (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n---      pragma Assert (Result = 0);\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_Lock;\n-\n-   -------------------\n-   -- Finalize_Lock --\n-   -------------------\n-\n-   procedure Finalize_Lock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L.L'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   procedure Finalize_Lock (L : not null access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   ----------------\n-   -- Write_Lock --\n-   ----------------\n-\n-   procedure Write_Lock\n-     (L                 : not null access Lock;\n-      Ceiling_Violation : out Boolean)\n-   is\n-      Self_ID        : constant Task_Id := Self;\n-      All_Tasks_Link : constant Task_Id := Self.Common.All_Tasks_Link;\n-      Current_Prio   : System.Any_Priority;\n-      Result         : Interfaces.C.int;\n-\n-   begin\n-      Current_Prio := Get_Priority (Self_ID);\n-\n-      --  If there is no other tasks, no need to check priorities\n-\n-      if All_Tasks_Link /= Null_Task\n-        and then L.Prio < Interfaces.C.int (Current_Prio)\n-      then\n-         Ceiling_Violation := True;\n-         return;\n-      end if;\n-\n-      Result := pthread_mutex_lock (L.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      Ceiling_Violation := False;\n---  Why is this commented out ???\n---      L.Prio_Save := Interfaces.C.int (Current_Prio);\n---      Set_Priority (Self_ID, System.Any_Priority (L.Prio));\n-   end Write_Lock;\n-\n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   procedure Write_Lock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   ---------------\n-   -- Read_Lock --\n-   ---------------\n-\n-   procedure Read_Lock\n-     (L                 : not null access Lock;\n-      Ceiling_Violation : out Boolean)\n-   is\n-   begin\n-      Write_Lock (L, Ceiling_Violation);\n-   end Read_Lock;\n-\n-   ------------\n-   -- Unlock --\n-   ------------\n-\n-   procedure Unlock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_unlock (L.L'Access);\n-      pragma Assert (Result = 0);\n-   end Unlock;\n-\n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   -----------------\n-   -- Set_Ceiling --\n-   -----------------\n-\n-   --  Dynamic priority ceilings are not supported by the underlying system\n-\n-   procedure Set_Ceiling\n-     (L    : not null access Lock;\n-      Prio : System.Any_Priority)\n-   is\n-      pragma Unreferenced (L, Prio);\n-   begin\n-      null;\n-   end Set_Ceiling;\n-\n-   -----------\n-   -- Sleep --\n-   -----------\n-\n-   procedure Sleep\n-     (Self_ID : Task_Id;\n-      Reason  : System.Tasking.Task_States)\n-   is\n-      pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result :=\n-        pthread_cond_wait\n-          (cond  => Self_ID.Common.LL.CV'Access,\n-           mutex => (if Single_Lock\n-                     then Single_RTS_Lock'Access\n-                     else Self_ID.Common.LL.L'Access));\n-\n-      --  EINTR is not considered a failure\n-\n-      pragma Assert (Result = 0 or else Result = EINTR);\n-\n-      if Self_ID.Deferral_Level = 0\n-        and then Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n-      then\n-         Unlock (Self_ID);\n-         raise Standard'Abort_Signal;\n-      end if;\n-   end Sleep;\n-\n-   -----------------\n-   -- Timed_Sleep --\n-   -----------------\n-\n-   procedure Timed_Sleep\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes;\n-      Reason   : System.Tasking.Task_States;\n-      Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Sleep_Time : OS_Time;\n-      Result     : Interfaces.C.int;\n-      Status     : Cond_Value_Type;\n-\n-      --  The body below requires more comments ???\n-\n-   begin\n-      Timedout := False;\n-      Yielded := False;\n-\n-      Sleep_Time := To_OS_Time (Time, Mode);\n-\n-      if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level then\n-         return;\n-      end if;\n-\n-      Self_ID.Common.LL.AST_Pending := True;\n-\n-      Sys_Setimr\n-       (Status, 0, Sleep_Time,\n-        Timer_Sleep_AST'Access, To_Address (Self_ID), 0);\n-\n-      if (Status and 1) /= 1 then\n-         raise Storage_Error;\n-      end if;\n-\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-         pragma Assert (Result = 0);\n-\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Yielded := True;\n-\n-      if not Self_ID.Common.LL.AST_Pending then\n-         Timedout := True;\n-      else\n-         Sys_Cantim (Status, To_Address (Self_ID), 0);\n-         pragma Assert ((Status and 1) = 1);\n-      end if;\n-   end Timed_Sleep;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   procedure Timed_Delay\n-     (Self_ID : Task_Id;\n-      Time    : Duration;\n-      Mode    : ST.Delay_Modes)\n-   is\n-      Sleep_Time : OS_Time;\n-      Result     : Interfaces.C.int;\n-      Status     : Cond_Value_Type;\n-      Yielded    : Boolean := False;\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n-      --  More comments required in body below ???\n-\n-      Write_Lock (Self_ID);\n-\n-      if Time /= 0.0 or else Mode /= Relative then\n-         Sleep_Time := To_OS_Time (Time, Mode);\n-\n-         if Mode = Relative or else OS_Clock <= Sleep_Time then\n-            Self_ID.Common.State := Delay_Sleep;\n-            Self_ID.Common.LL.AST_Pending := True;\n-\n-            Sys_Setimr\n-             (Status, 0, Sleep_Time,\n-              Timer_Sleep_AST'Access, To_Address (Self_ID), 0);\n-\n-            --  Comment following test\n-\n-            if (Status and 1) /= 1 then\n-               raise Storage_Error;\n-            end if;\n-\n-            loop\n-               if Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level then\n-                  Sys_Cantim (Status, To_Address (Self_ID), 0);\n-                  pragma Assert ((Status and 1) = 1);\n-                  exit;\n-               end if;\n-\n-               Result :=\n-                 pthread_cond_wait\n-                   (cond  => Self_ID.Common.LL.CV'Access,\n-                    mutex => (if Single_Lock\n-                              then Single_RTS_Lock'Access\n-                              else Self_ID.Common.LL.L'Access));\n-               pragma Assert (Result = 0);\n-\n-               Yielded := True;\n-\n-               exit when not Self_ID.Common.LL.AST_Pending;\n-            end loop;\n-\n-            Self_ID.Common.State := Runnable;\n-         end if;\n-      end if;\n-\n-      Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n-      if not Yielded then\n-         Result := sched_yield;\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Timed_Delay;\n-\n-   ---------------------\n-   -- Monotonic_Clock --\n-   ---------------------\n-\n-   function Monotonic_Clock return Duration\n-     renames System.OS_Primitives.Monotonic_Clock;\n-\n-   -------------------\n-   -- RT_Resolution --\n-   -------------------\n-\n-   function RT_Resolution return Duration is\n-   begin\n-      --  Document origin of this magic constant ???\n-      return 10#1.0#E-3;\n-   end RT_Resolution;\n-\n-   ------------\n-   -- Wakeup --\n-   ------------\n-\n-   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n-      pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Wakeup;\n-\n-   -----------\n-   -- Yield --\n-   -----------\n-\n-   procedure Yield (Do_Yield : Boolean := True) is\n-      Result : Interfaces.C.int;\n-      pragma Unreferenced (Result);\n-   begin\n-      if Do_Yield then\n-         Result := sched_yield;\n-      end if;\n-   end Yield;\n-\n-   ------------------\n-   -- Set_Priority --\n-   ------------------\n-\n-   procedure Set_Priority\n-     (T                   : Task_Id;\n-      Prio                : System.Any_Priority;\n-      Loss_Of_Inheritance : Boolean := False)\n-   is\n-      pragma Unreferenced (Loss_Of_Inheritance);\n-\n-      Result : Interfaces.C.int;\n-      Param  : aliased struct_sched_param;\n-\n-      function Get_Policy (Prio : System.Any_Priority) return Character;\n-      pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n-      --  Get priority specific dispatching policy\n-\n-      Priority_Specific_Policy : constant Character := Get_Policy (Prio);\n-      --  Upper case first character of the policy name corresponding to the\n-      --  task as set by a Priority_Specific_Dispatching pragma.\n-\n-   begin\n-      T.Common.Current_Priority := Prio;\n-      Param.sched_priority := Interfaces.C.int (Underlying_Priorities (Prio));\n-\n-      if Dispatching_Policy = 'R'\n-        or else Priority_Specific_Policy = 'R'\n-        or else Time_Slice_Val > 0\n-      then\n-         Result :=\n-           pthread_setschedparam\n-             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n-\n-      elsif Dispatching_Policy = 'F'\n-        or else Priority_Specific_Policy = 'F'\n-        or else Time_Slice_Val = 0\n-      then\n-         Result :=\n-           pthread_setschedparam\n-             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n-\n-      else\n-         --  SCHED_OTHER priorities are restricted to the range 8 - 15.\n-         --  Since the translation from Underlying priorities results\n-         --  in a range of 16 - 31, dividing by 2 gives the correct result.\n-\n-         Param.sched_priority := Param.sched_priority / 2;\n-         Result :=\n-           pthread_setschedparam\n-             (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n-      end if;\n-\n-      pragma Assert (Result = 0);\n-   end Set_Priority;\n-\n-   ------------------\n-   -- Get_Priority --\n-   ------------------\n-\n-   function Get_Priority (T : Task_Id) return System.Any_Priority is\n-   begin\n-      return T.Common.Current_Priority;\n-   end Get_Priority;\n-\n-   ----------------\n-   -- Enter_Task --\n-   ----------------\n-\n-   procedure Enter_Task (Self_ID : Task_Id) is\n-   begin\n-      Self_ID.Common.LL.Thread := pthread_self;\n-      Specific.Set (Self_ID);\n-   end Enter_Task;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;\n-\n-   -----------------------------\n-   -- Register_Foreign_Thread --\n-   -----------------------------\n-\n-   function Register_Foreign_Thread return Task_Id is\n-   begin\n-      if Is_Valid_Task then\n-         return Self;\n-      else\n-         return Register_Foreign_Thread (pthread_self);\n-      end if;\n-   end Register_Foreign_Thread;\n-\n-   --------------------\n-   -- Initialize_TCB --\n-   --------------------\n-\n-   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-\n-   begin\n-      --  More comments required in body below ???\n-\n-      if not Single_Lock then\n-         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-         if Result = 0 then\n-            Result :=\n-              pthread_mutex_init\n-                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n-            pragma Assert (Result = 0 or else Result = ENOMEM);\n-         end if;\n-\n-         if Result /= 0 then\n-            Succeeded := False;\n-            return;\n-         end if;\n-\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = 0 then\n-         Result :=\n-           pthread_cond_init\n-             (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-      end if;\n-\n-      if Result = 0 then\n-         Succeeded := True;\n-\n-      else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n-\n-         Succeeded := False;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_TCB;\n-\n-   -----------------\n-   -- Create_Task --\n-   -----------------\n-\n-   procedure Create_Task\n-     (T          : Task_Id;\n-      Wrapper    : System.Address;\n-      Stack_Size : System.Parameters.Size_Type;\n-      Priority   : System.Any_Priority;\n-      Succeeded  : out Boolean)\n-   is\n-      Attributes : aliased pthread_attr_t;\n-      Result     : Interfaces.C.int;\n-\n-      function Thread_Body_Access is new\n-        Ada.Unchecked_Conversion (System.Aux_DEC.Short_Address, Thread_Body);\n-\n-      Task_Name : String (1 .. System.Parameters.Max_Task_Image_Length + 1);\n-\n-   begin\n-      --  Since the initial signal mask of a thread is inherited from the\n-      --  creator, we need to set our local signal mask to mask all signals\n-      --  during the creation operation, to make sure the new thread is\n-      --  not disturbed by signals before it has set its own Task_Id.\n-\n-      Result := pthread_attr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result := pthread_attr_setdetachstate\n-        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n-      pragma Assert (Result = 0);\n-\n-      Result := pthread_attr_setstacksize\n-        (Attributes'Access, Interfaces.C.size_t (Stack_Size));\n-      pragma Assert (Result = 0);\n-\n-      --  This call may be unnecessary, not sure. ???\n-\n-      Result :=\n-        pthread_attr_setinheritsched\n-          (Attributes'Access, PTHREAD_EXPLICIT_SCHED);\n-      pragma Assert (Result = 0);\n-\n-      if T.Common.Task_Image_Len > 0 then\n-\n-         --  Set thread name to ease debugging\n-\n-         Task_Name (1 .. T.Common.Task_Image_Len) :=\n-           T.Common.Task_Image (1 .. T.Common.Task_Image_Len);\n-         Task_Name (T.Common.Task_Image_Len + 1) := ASCII.NUL;\n-\n-         Result := pthread_attr_setname_np\n-           (Attributes'Access, Task_Name'Address, Null_Address);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      --  Note: the use of Unrestricted_Access in the following call is needed\n-      --  because otherwise we have an error of getting a access-to-volatile\n-      --  value which points to a non-volatile object. But in this case it is\n-      --  safe to do this, since we know we have no problems with aliasing and\n-      --  Unrestricted_Access bypasses this check.\n-\n-      Result :=\n-        pthread_create\n-          (T.Common.LL.Thread'Unrestricted_Access,\n-           Attributes'Access,\n-           Thread_Body_Access (Wrapper),\n-           To_Address (T));\n-\n-      --  ENOMEM is a valid run-time error -- do not shut down\n-\n-      pragma Assert (Result = 0\n-        or else Result = EAGAIN or else Result = ENOMEM);\n-\n-      Succeeded := Result = 0;\n-\n-      Result := pthread_attr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-\n-      if Succeeded then\n-         Set_Priority (T, Priority);\n-      end if;\n-   end Create_Task;\n-\n-   ------------------\n-   -- Finalize_TCB --\n-   ------------------\n-\n-   procedure Finalize_TCB (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-\n-      if T.Known_Tasks_Index /= -1 then\n-         Known_Tasks (T.Known_Tasks_Index) := null;\n-      end if;\n-\n-      ATCB_Allocation.Free_ATCB (T);\n-   end Finalize_TCB;\n-\n-   ---------------\n-   -- Exit_Task --\n-   ---------------\n-\n-   procedure Exit_Task is\n-   begin\n-      null;\n-   end Exit_Task;\n-\n-   ----------------\n-   -- Abort_Task --\n-   ----------------\n-\n-   procedure Abort_Task (T : Task_Id) is\n-   begin\n-      --  Interrupt Server_Tasks may be waiting on an event flag\n-\n-      if T.Common.State = Interrupt_Server_Blocked_On_Event_Flag then\n-         Wakeup (T, Interrupt_Server_Blocked_On_Event_Flag);\n-      end if;\n-   end Abort_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (S : in out Suspension_Object) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-      Result     : Interfaces.C.int;\n-   begin\n-      --  Initialize internal state (always to False (D.10 (6)))\n-\n-      S.State := False;\n-      S.Waiting := False;\n-\n-      --  Initialize internal mutex\n-\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Initialize internal condition variable\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         if Result = ENOMEM then\n-            raise Storage_Error;\n-         end if;\n-      end if;\n-\n-      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         if Result = ENOMEM then\n-            Result := pthread_condattr_destroy (Cond_Attr'Access);\n-            pragma Assert (Result = 0);\n-\n-            raise Storage_Error;\n-         end if;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      --  Destroy internal mutex\n-\n-      Result := pthread_mutex_destroy (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Destroy internal condition variable\n-\n-      Result := pthread_cond_destroy (S.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize;\n-\n-   -------------------\n-   -- Current_State --\n-   -------------------\n-\n-   function Current_State (S : Suspension_Object) return Boolean is\n-   begin\n-      --  We do not want to use lock on this read operation. State is marked\n-      --  as Atomic so that we ensure that the value retrieved is correct.\n-\n-      return S.State;\n-   end Current_State;\n-\n-   ---------------\n-   -- Set_False --\n-   ---------------\n-\n-   procedure Set_False (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      S.State := False;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      SSL.Abort_Undefer.all;\n-   end Set_False;\n-\n-   --------------\n-   -- Set_True --\n-   --------------\n-\n-   procedure Set_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  If there is already a task waiting on this suspension object then\n-      --  we resume it, leaving the state of the suspension object to False,\n-      --  as specified in (RM D.10(9)), otherwise leave state set to True.\n-\n-      if S.Waiting then\n-         S.Waiting := False;\n-         S.State := False;\n-\n-         Result := pthread_cond_signal (S.CV'Access);\n-         pragma Assert (Result = 0);\n-\n-      else\n-         S.State := True;\n-      end if;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      SSL.Abort_Undefer.all;\n-   end Set_True;\n-\n-   ------------------------\n-   -- Suspend_Until_True --\n-   ------------------------\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      if S.Waiting then\n-\n-         --  Program_Error must be raised upon calling Suspend_Until_True\n-         --  if another task is already waiting on that suspension object\n-         --  (RM D.10(10)).\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         SSL.Abort_Undefer.all;\n-\n-         raise Program_Error;\n-\n-      else\n-         --  Suspend the task if the state is False. Otherwise, the task\n-         --  continues its execution, and the state of the suspension object\n-         --  is set to False (ARM D.10 par. 9).\n-\n-         if S.State then\n-            S.State := False;\n-         else\n-            S.Waiting := True;\n-\n-            loop\n-               --  Loop in case pthread_cond_wait returns earlier than expected\n-               --  (e.g. in case of EINTR caused by a signal).\n-\n-               Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n-               pragma Assert (Result = 0 or else Result = EINTR);\n-\n-               exit when not S.Waiting;\n-            end loop;\n-         end if;\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         SSL.Abort_Undefer.all;\n-      end if;\n-   end Suspend_Until_True;\n-\n-   ----------------\n-   -- Check_Exit --\n-   ----------------\n-\n-   --  Dummy version\n-\n-   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_Exit;\n-\n-   --------------------\n-   -- Check_No_Locks --\n-   --------------------\n-\n-   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_No_Locks;\n-\n-   ----------------------\n-   -- Environment_Task --\n-   ----------------------\n-\n-   function Environment_Task return Task_Id is\n-   begin\n-      return Environment_Task_Id;\n-   end Environment_Task;\n-\n-   --------------\n-   -- Lock_RTS --\n-   --------------\n-\n-   procedure Lock_RTS is\n-   begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Lock_RTS;\n-\n-   ----------------\n-   -- Unlock_RTS --\n-   ----------------\n-\n-   procedure Unlock_RTS is\n-   begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Unlock_RTS;\n-\n-   ------------------\n-   -- Suspend_Task --\n-   ------------------\n-\n-   function Suspend_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (Thread_Self);\n-   begin\n-      return False;\n-   end Suspend_Task;\n-\n-   -----------------\n-   -- Resume_Task --\n-   -----------------\n-\n-   function Resume_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (Thread_Self);\n-   begin\n-      return False;\n-   end Resume_Task;\n-\n-   --------------------\n-   -- Stop_All_Tasks --\n-   --------------------\n-\n-   procedure Stop_All_Tasks is\n-   begin\n-      null;\n-   end Stop_All_Tasks;\n-\n-   ---------------\n-   -- Stop_Task --\n-   ---------------\n-\n-   function Stop_Task (T : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (T);\n-   begin\n-      return False;\n-   end Stop_Task;\n-\n-   -------------------\n-   -- Continue_Task --\n-   -------------------\n-\n-   function Continue_Task (T : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (T);\n-   begin\n-      return False;\n-   end Continue_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-\n-      --  The DEC Ada facility code defined in Starlet\n-      Ada_Facility : constant := 49;\n-\n-      function DBGEXT (Control_Block : System.Address)\n-        return System.Aux_DEC.Unsigned_Word;\n-      --  DBGEXT is imported  from s-tasdeb.adb and its parameter re-typed\n-      --  as Address to avoid having a VMS specific s-tasdeb.ads.\n-      pragma Import (C, DBGEXT);\n-      pragma Import_Function (DBGEXT, \"GNAT$DBGEXT\");\n-\n-      type Facility_Type is range 0 .. 65535;\n-\n-      procedure Debug_Register\n-        (ADBGEXT    : System.Address;\n-         ATCB_Key   : pthread_key_t;\n-         Facility   : Facility_Type;\n-         Std_Prolog : Integer);\n-      pragma Import (C, Debug_Register, \"CMA$DEBUG_REGISTER\");\n-   begin\n-      Environment_Task_Id := Environment_Task;\n-\n-      --  Initialize the lock used to synchronize chain of all ATCBs\n-\n-      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n-\n-      Specific.Initialize (Environment_Task);\n-\n-      --  Pass the context key on to CMA along with the other parameters\n-      Debug_Register\n-       (\n-        DBGEXT'Address,    --  Our DEBUG handling entry point\n-        ATCB_Key,          --  CMA context key for our Ada TCB's\n-        Ada_Facility,      --  Out facility code\n-        0                  --  False, we don't have the std TCB prolog\n-       );\n-\n-      --  Make environment task known here because it doesn't go through\n-      --  Activate_Tasks, which does it for all other tasks.\n-\n-      Known_Tasks (Known_Tasks'First) := Environment_Task;\n-      Environment_Task.Known_Tasks_Index := Known_Tasks'First;\n-\n-      Enter_Task (Environment_Task);\n-   end Initialize;\n-\n-   -----------------------\n-   -- Set_Task_Affinity --\n-   -----------------------\n-\n-   procedure Set_Task_Affinity (T : ST.Task_Id) is\n-      pragma Unreferenced (T);\n-\n-   begin\n-      --  Setting task affinity is not supported by the underlying system\n-\n-      null;\n-   end Set_Task_Affinity;\n-end System.Task_Primitives.Operations;"}, {"sha": "0ef6322f517937e099932afa185ff6c4a6cd35cb", "filename": "gcc/ada/s-tasdeb-vms.adb", "status": "removed", "additions": 0, "deletions": 2159, "changes": 2159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tasdeb-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tasdeb-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasdeb-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,2159 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n---                                                                          --\n---                  S Y S T E M . T A S K I N G . D E B U G                 --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 2008-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  OpenVMS Version\n-\n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n-with System.Aux_DEC;\n-with System.CRTL;\n-with System.Task_Primitives.Operations;\n-package body System.Tasking.Debug is\n-\n-   package OSI renames System.OS_Interface;\n-   package STPO renames System.Task_Primitives.Operations;\n-\n-   use System.Aux_DEC;\n-\n-   --  Condition value type\n-\n-   subtype Cond_Value_Type is Unsigned_Longword;\n-\n-   type Trace_Flag_Set is array (Character) of Boolean;\n-\n-   Trace_On : Trace_Flag_Set := ('A' .. 'Z' => False, others => True);\n-\n-   --  Print_Routine fuction codes\n-\n-   type Print_Functions is\n-     (No_Print, Print_Newline, Print_Control,\n-      Print_String, Print_Symbol, Print_FAO);\n-   for Print_Functions use\n-     (No_Print => 0, Print_Newline => 1, Print_Control => 2,\n-      Print_String => 3, Print_Symbol => 4, Print_FAO => 5);\n-\n-   --  Counted ascii type declarations\n-\n-   subtype Count_Type is Natural range 0 .. 255;\n-   for Count_Type'Object_Size use 8;\n-\n-   type ASCIC (Count : Count_Type) is record\n-      Text  : String (1 .. Count);\n-   end record;\n-\n-   for ASCIC use record\n-      Count at 0 range 0 .. 7;\n-   end record;\n-   pragma Pack (ASCIC);\n-\n-   type AASCIC is access ASCIC;\n-   for AASCIC'Size use 32;\n-\n-   type AASCIC_Array is array (Positive range <>) of AASCIC;\n-\n-   type ASCIC127 is record\n-      Count : Count_Type;\n-      Text  : String (1 .. 127);\n-   end record;\n-\n-   for ASCIC127 use record\n-      Count at 0 range 0 .. 7;\n-      Text  at 1 range 0 .. 127 * 8 - 1;\n-   end record;\n-\n-   --  DEBUG Event record types used to signal DEBUG about Ada events\n-\n-   type Debug_Event_Record is record\n-      Code     : Unsigned_Word; --  Event code that uniquely identifies event\n-      Flags    : Bit_Array_8;   --  Flag bits\n-      --                            Bit 0: This event allows a parameter list\n-      --                            Bit 1: Parameters are address expressions\n-      Sentinal : Unsigned_Byte; --  Sentinal valuye: Always K_EVENT_SENT\n-      TS_Kind  : Unsigned_Byte; --  DST type specification: Always K_TS_TASK\n-      DType    : Unsigned_Byte; --  DTYPE of parameter if of atomic data type\n-      --                            Always K_DTYPE_TASK\n-      MBZ      : Unsigned_Byte; --  Unused (must be zero)\n-      Minchr   : Count_Type;    --  Minimum chars needed to identify event\n-      Name     : ASCIC (31);    --  Event name uppercase only\n-      Help     : AASCIC;        --  Event description\n-   end record;\n-\n-   for Debug_Event_Record use record\n-      Code     at 0 range 0 .. 15;\n-      Flags    at 2 range 0 .. 7;\n-      Sentinal at 3 range 0 .. 7;\n-      TS_Kind  at 4 range 0 .. 7;\n-      Dtype    at 5 range 0 .. 7;\n-      MBZ      at 6 range 0 .. 7;\n-      Minchr   at 7 range 0 .. 7;\n-      Name     at 8 range 0 .. 32 * 8 - 1;\n-      Help     at 40 range 0 .. 31;\n-   end record;\n-\n-   type Ada_Event_Control_Block_Type is record\n-      Code      : Unsigned_Word;     --  Reserved and defined by DEBUG\n-      Unused1   : Unsigned_Byte;     --  Reserved and defined by DEBUG\n-      Sentinal  : Unsigned_Byte;     --  Reserved and defined by DEBUG\n-      Facility  : Unsigned_Word;     --  Reserved and defined by DEBUG\n-      Flags     : Unsigned_Word;     --  Reserved and defined by DEBUG\n-      Value     : Unsigned_Longword; --  Reserved and defined by DEBUG\n-      Unused2   : Unsigned_Longword; --  Reserved and defined by DEBUG\n-      Sigargs   : Unsigned_Longword;\n-      P1        : Unsigned_Longword;\n-      Sub_Event : Unsigned_Longword;\n-   end record;\n-\n-   for Ada_Event_Control_Block_Type use record\n-      Code      at 0 range 0 .. 15;\n-      Unused1   at 2 range 0 .. 7;\n-      Sentinal  at 3 range 0 .. 7;\n-      Facility  at 4 range 0 .. 15;\n-      Flags     at 6 range 0 .. 15;\n-      Value     at 8 range 0 .. 31;\n-      Unused2   at 12 range 0 .. 31;\n-      Sigargs   at 16 range 0 .. 31;\n-      P1        at 20 range 0 .. 31;\n-      Sub_Event at 24 range 0 .. 31;\n-   end record;\n-\n-   type Ada_Event_Control_Block_Access is access Ada_Event_Control_Block_Type;\n-   for Ada_Event_Control_Block_Access'Size use 32;\n-\n-   --  Print_Routine_Type with max optional parameters\n-\n-   type Print_Routine_Type is access procedure\n-     (Print_Function    : Print_Functions;\n-      Print_Subfunction : Print_Functions;\n-      P1                : Unsigned_Longword := 0;\n-      P2                : Unsigned_Longword := 0;\n-      P3                : Unsigned_Longword := 0;\n-      P4                : Unsigned_Longword := 0;\n-      P5                : Unsigned_Longword := 0;\n-      P6                : Unsigned_Longword := 0);\n-   for Print_Routine_Type'Size use 32;\n-\n-   ---------------\n-   -- Constants --\n-   ---------------\n-\n-   --  These are used to obtain and convert task values\n-   K_CVT_VALUE_NUM  : constant := 1;\n-   K_CVT_NUM_VALUE  : constant := 2;\n-   K_NEXT_TASK      : constant := 3;\n-\n-   --  These are used to ask ADA to display task information\n-   K_SHOW_TASK     : constant := 4;\n-   K_SHOW_STAT     : constant := 5;\n-   K_SHOW_DEADLOCK : constant := 6;\n-\n-   --  These are used to get and set various attributes of one or more tasks\n-   --    Task state\n-   --  K_GET_STATE  : constant := 7;\n-   --  K_GET_ACTIVE : constant := 8;\n-   --  K_SET_ACTIVE : constant := 9;\n-   K_SET_ABORT  : constant := 10;\n-   --  K_SET_HOLD   : constant := 11;\n-\n-   --    Task priority\n-   K_GET_PRIORITY      : constant := 12;\n-   K_SET_PRIORITY      : constant := 13;\n-   K_RESTORE_PRIORITY  : constant := 14;\n-\n-   --    Task registers\n-   --  K_GET_REGISTERS     : constant := 15;\n-   --  K_SET_REGISTERS     : constant := 16;\n-\n-   --  These are used to control definable events\n-   K_ENABLE_EVENT   : constant := 17;\n-   K_DISABLE_EVENT  : constant := 18;\n-   K_ANNOUNCE_EVENT : constant := 19;\n-\n-   --  These are used to control time-slicing.\n-   --  K_SHOW_TIME_SLICE : constant := 20;\n-   --  K_SET_TIME_SLICE  : constant := 21;\n-\n-   --  This is used to symbolize task stack addresses.\n-   --  K_SYMBOLIZE_ADDRESS : constant := 22;\n-\n-   K_GET_CALLER : constant := 23;\n-   --  This is used to obtain the task value of the caller task\n-\n-   --  Miscellaneous functions - see below for details\n-\n-   K_CLEANUP_EVENT  : constant := 24;\n-   K_SHOW_EVENT_DEF : constant := 25;\n-   --  K_CHECK_TASK_STACK : constant := 26;  --  why commented out ???\n-\n-   --  This is used to obtain the DBGEXT-interface revision level\n-   --  K_GET_DBGEXT_REV : constant := 27; -- why commented out ???\n-\n-   K_GET_STATE_1 : constant := 28;\n-   --  This is used to obtain additional state info, primarily for PCA\n-\n-   K_FIND_EVENT_BY_CODE : constant := 29;\n-   K_FIND_EVENT_BY_NAME : constant := 30;\n-   --  These are used to search for user-defined event entries\n-\n-   --  This is used to stop task schedulding. Why commented out ???\n-   --  K_STOP_ALL_OTHER_TASKS : constant := 31;\n-\n-   --  Debug event constants\n-\n-   K_TASK_NOT_EXIST  : constant := 3;\n-   K_SUCCESS         : constant := 1;\n-   K_EVENT_SENT      : constant := 16#9A#;\n-   K_TS_TASK         : constant := 18;\n-   K_DTYPE_TASK      : constant := 44;\n-\n-   --  Status signal constants\n-\n-   SS_BADPARAM       : constant := 20;\n-   SS_NORMAL         : constant := 1;\n-\n-   --  Miscellaneous mask constants\n-\n-   V_EVNT_ALL        : constant := 0;\n-   V_Full_Display    : constant := 11;\n-   V_Suppress_Header : constant := 13;\n-\n-   --  CMA constants (why are some commented out???)\n-\n-   CMA_C_DEBGET_GUARDSIZE     : constant := 1;\n-   CMA_C_DEBGET_IS_HELD       : constant := 2;\n---   CMA_C_DEBGET_IS_INITIAL    : constant := 3;\n---   CMA_C_DEBGET_NUMBER        : constant := 4;\n-   CMA_C_DEBGET_STACKPTR      : constant := 5;\n-   CMA_C_DEBGET_STACK_BASE    : constant := 6;\n-   CMA_C_DEBGET_STACK_TOP     : constant := 7;\n-   CMA_C_DEBGET_SCHED_STATE   : constant := 8;\n-   CMA_C_DEBGET_YELLOWSIZE    : constant := 9;\n---   CMA_C_DEBGET_BASE_PRIO     : constant := 10;\n---   CMA_C_DEBGET_REGS          : constant := 11;\n---   CMA_C_DEBGET_ALT_PENDING   : constant := 12;\n---   CMA_C_DEBGET_ALT_A_ENABLE  : constant := 13;\n---   CMA_C_DEBGET_ALT_G_ENABLE  : constant := 14;\n---   CMA_C_DEBGET_SUBSTATE      : constant := 15;\n---   CMA_C_DEBGET_OBJECT_ADDR   : constant := 16;\n---   CMA_C_DEBGET_THKIND        : constant := 17;\n---   CMA_C_DEBGET_DETACHED      : constant := 18;\n-   CMA_C_DEBGET_TCB_SIZE      : constant := 19;\n---   CMA_C_DEBGET_START_PC      : constant := 20;\n---   CMA_C_DEBGET_NEXT_PC       : constant := 22;\n---   CMA_C_DEBGET_POLICY        : constant := 23;\n---   CMA_C_DEBGET_STACK_YELLOW  : constant := 24;\n---   CMA_C_DEBGET_STACK_DEFAULT : constant := 25;\n-\n-   --  Miscellaneous counted ascii constants\n-\n-   Star     : constant AASCIC := new ASCIC'(2, (\"* \"));\n-   NoStar   : constant AASCIC := new ASCIC'(2, (\"  \"));\n-   Hold     : constant AASCIC := new ASCIC'(4, (\"HOLD\"));\n-   NoHold   : constant AASCIC := new ASCIC'(4, (\"    \"));\n-   Header   : constant AASCIC := new ASCIC '\n-     (60, (\"  task id     pri hold state   substate          task object\"));\n-   Empty_Text : constant AASCIC := new ASCIC (0);\n-\n-   --  DEBUG Ada tasking states equated to their GNAT tasking equivalents\n-\n-   Ada_State_Invalid_State     : constant AASCIC :=\n-     new ASCIC'(17, \"Invalid state    \");\n---   Ada_State_Abnormal          : constant AASCIC :=\n---     new ASCIC'(17, \"Abnormal         \");\n-   Ada_State_Aborting          : constant AASCIC :=\n-     new ASCIC'(17, \"Aborting         \"); --  Aborting (new)\n---   Ada_State_Completed_Abn     : constant AASCIC :=\n---     new ASCIC'(17, \"Completed  [abn] \");\n---   Ada_State_Completed_Exc     : constant AASCIC :=\n---     new ASCIC'(17, \"Completed  [exc] \");\n-   Ada_State_Completed         : constant AASCIC :=\n-     new ASCIC'(17, \"Completed        \"); --  Master_Completion_Sleep\n-   Ada_State_Runnable          : constant AASCIC :=\n-     new ASCIC'(17, \"Runnable         \"); --  Runnable\n-   Ada_State_Activating        : constant AASCIC :=\n-     new ASCIC'(17, \"Activating       \");\n-   Ada_State_Accept            : constant AASCIC :=\n-     new ASCIC'(17, \"Accept           \"); --  Acceptor_Sleep\n-   Ada_State_Select_or_Delay   : constant AASCIC :=\n-     new ASCIC'(17, \"Select or delay  \"); --  Acceptor_Delay_Sleep\n-   Ada_State_Select_or_Term    : constant AASCIC :=\n-     new ASCIC'(17, \"Select or term.  \"); -- Terminate_Alternative\n-   Ada_State_Select_or_Abort   : constant AASCIC :=\n-     new ASCIC'(17, \"Select or abort  \"); --  Async_Select_Sleep (new)\n---   Ada_State_Select            : constant AASCIC :=\n---     new ASCIC'(17, \"Select           \");\n-   Ada_State_Activating_Tasks  : constant AASCIC :=\n-     new ASCIC'(17, \"Activating tasks \"); --  Activator_Sleep\n-   Ada_State_Delay             : constant AASCIC :=\n-     new ASCIC'(17, \"Delay            \"); --  AST_Pending\n---   Ada_State_Dependents        : constant AASCIC :=\n---     new ASCIC'(17, \"Dependents       \");\n-   Ada_State_Entry_Call        : constant AASCIC :=\n-     new ASCIC'(17, \"Entry call       \"); --  Entry_Caller_Sleep\n-   Ada_State_Cond_Entry_Call   : constant AASCIC :=\n-     new ASCIC'(17, \"Cond. entry call \"); --  Call.Mode.Conditional_Call\n-   Ada_State_Timed_Entry_Call  : constant AASCIC :=\n-     new ASCIC'(17, \"Timed entry call \"); --  Call.Mode.Timed_Call\n-   Ada_State_Async_Entry_Call  : constant AASCIC :=\n-     new ASCIC'(17, \"Async entry call \"); --  Call.Mode.Asynchronous_Call (new)\n---   Ada_State_Dependents_Exc    : constant AASCIC :=\n---     new ASCIC'(17, \"Dependents [exc] \");\n-   Ada_State_IO_or_AST         : constant AASCIC :=\n-     new ASCIC'(17, \"I/O or AST       \"); --  AST_Server_Sleep\n---   Ada_State_Shared_Resource   : constant AASCIC :=\n---     new ASCIC'(17, \"Shared resource  \");\n-   Ada_State_Not_Yet_Activated : constant AASCIC :=\n-     new ASCIC'(17, \"Not yet activated\"); --  Unactivated\n---   Ada_State_Terminated_Abn    : constant AASCIC :=\n---     new ASCIC'(17, \"Terminated [abn] \");\n---   Ada_State_Terminated_Exc    : constant AASCIC :=\n---     new ASCIC'(17, \"Terminated [exc] \");\n-   Ada_State_Terminated        : constant AASCIC :=\n-     new ASCIC'(17, \"Terminated       \"); --  Terminated\n-   Ada_State_Server            : constant AASCIC :=\n-     new ASCIC'(17, \"Server           \"); --  Servers\n-   Ada_State_Async_Hold        : constant AASCIC :=\n-     new ASCIC'(17, \"Async_Hold       \"); --  Async_Hold\n-\n-   --  Task state counted ascii constants\n-\n-   Debug_State_Emp : constant AASCIC := new ASCIC'(5, \"     \");\n-   Debug_State_Run : constant AASCIC := new ASCIC'(5, \"RUN  \");\n-   Debug_State_Rea : constant AASCIC := new ASCIC'(5, \"READY\");\n-   Debug_State_Sus : constant AASCIC := new ASCIC'(5, \"SUSP \");\n-   Debug_State_Ter : constant AASCIC := new ASCIC'(5, \"TERM \");\n-\n-   --  Priority order of event display\n-\n-   Global_Event_Display_Order : constant array (Event_Kind_Type)\n-     of Event_Kind_Type := (\n-      Debug_Event_Abort_Terminated,\n-      Debug_Event_Activating,\n-      Debug_Event_Dependents_Exception,\n-      Debug_Event_Exception_Terminated,\n-      Debug_Event_Handled,\n-      Debug_Event_Handled_Others,\n-      Debug_Event_Preempted,\n-      Debug_Event_Rendezvous_Exception,\n-      Debug_Event_Run,\n-      Debug_Event_Suspended,\n-      Debug_Event_Terminated);\n-\n-   --  Constant array defining all debug events\n-\n-   Event_Directory : constant array (Event_Kind_Type)\n-     of Debug_Event_Record := (\n-      (Debug_Event_Activating,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       2,\n-       (31, \"ACTIVATING                     \"),\n-       new ASCIC'(41, \"!_a task is about to begin its activation\")),\n-\n-      (Debug_Event_Run,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       2,\n-       (31, \"RUN                            \"),\n-       new ASCIC'(24, \"!_a task is about to run\")),\n-\n-      (Debug_Event_Suspended,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"SUSPENDED                      \"),\n-       new ASCIC'(33, \"!_a task is about to be suspended\")),\n-\n-      (Debug_Event_Preempted,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"PREEMPTED                      \"),\n-       new ASCIC'(33, \"!_a task is about to be preempted\")),\n-\n-      (Debug_Event_Terminated,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"TERMINATED                     \"),\n-       new ASCIC'(57,\n-        \"!_a task is terminating (including by abort or exception)\")),\n-\n-      (Debug_Event_Abort_Terminated,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       2,\n-       (31, \"ABORT_TERMINATED               \"),\n-       new ASCIC'(40, \"!_a task is terminating because of abort\")),\n-\n-      (Debug_Event_Exception_Terminated,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"EXCEPTION_TERMINATED           \"),\n-       new ASCIC'(47, \"!_a task is terminating because of an exception\")),\n-\n-      (Debug_Event_Rendezvous_Exception,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       3,\n-       (31, \"RENDEZVOUS_EXCEPTION           \"),\n-       new ASCIC'(49, \"!_an exception is propagating out of a rendezvous\")),\n-\n-      (Debug_Event_Handled,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"HANDLED                        \"),\n-       new ASCIC'(37, \"!_an exception is about to be handled\")),\n-\n-      (Debug_Event_Dependents_Exception,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"DEPENDENTS_EXCEPTION           \"),\n-       new ASCIC'(64,\n-        \"!_an exception is about to cause a task to await dependent tasks\")),\n-\n-      (Debug_Event_Handled_Others,\n-       (False, False, False, False, False, False, False, True),\n-       K_EVENT_SENT,\n-       K_TS_TASK,\n-       K_DTYPE_TASK,\n-       0,\n-       1,\n-       (31, \"HANDLED_OTHERS                 \"),\n-       new ASCIC'(58,\n-        \"!_an exception is about to be handled in an OTHERS handler\")));\n-\n-   --  Help on events displayed in DEBUG\n-\n-   Event_Def_Help : constant AASCIC_Array := (\n-     new ASCIC'(0,  \"\"),\n-     new ASCIC'(65,\n-      \"  The general forms of commands to set a breakpoint or tracepoint\"),\n-     new ASCIC'(22, \"  on an Ada event are:\"),\n-     new ASCIC'(73, \"    SET BREAK/EVENT=event [task[, ... ]] \" &\n-                    \"[WHEN(expr)] [DO(comnd[; ... ])]\"),\n-     new ASCIC'(73, \"    SET TRACE/EVENT=event [task[, ... ]] \" &\n-                    \"[WHEN(expr)] [DO(comnd[; ... ])]\"),\n-     new ASCIC'(0,  \"\"),\n-     new ASCIC'(65,\n-      \"  If tasks are specified, the breakpoint will trigger only if the\"),\n-     new ASCIC'(40, \"  event occurs for those specific tasks.\"),\n-     new ASCIC'(0,  \"\"),\n-     new ASCIC'(39, \"  Ada event names and their definitions\"),\n-     new ASCIC'(0,  \"\"));\n-\n-   -----------------------\n-   -- Package Variables --\n-   -----------------------\n-\n-   AC_Buffer : ASCIC127;\n-\n-   Events_Enabled_Count : Integer := 0;\n-\n-   Print_Routine_Bufsiz : constant := 132;\n-   Print_Routine_Bufcnt : Integer := 0;\n-   Print_Routine_Linbuf : String (1 .. Print_Routine_Bufsiz);\n-\n-   Global_Task_Debug_Events : Debug_Event_Array :=\n-     (False, False, False, False, False, False, False, False,\n-      False, False, False, False, False, False, False, False);\n-   --  Global table of task debug events set by the debugger\n-\n-   --------------------------\n-   -- Exported Subprograms --\n-   --------------------------\n-\n-   procedure Default_Print_Routine\n-     (Print_Function    : Print_Functions;\n-      Print_Subfunction : Print_Functions;\n-      P1                : Unsigned_Longword := 0;\n-      P2                : Unsigned_Longword := 0;\n-      P3                : Unsigned_Longword := 0;\n-      P4                : Unsigned_Longword := 0;\n-      P5                : Unsigned_Longword := 0;\n-      P6                : Unsigned_Longword := 0);\n-   --  The default print routine if not overridden.\n-   --  Print_Function determines option argument formatting.\n-   --  Print_Subfunction buffers output if No_Print, calls Put_Output if\n-   --  Print_Newline\n-\n-   pragma Export_Procedure\n-     (Default_Print_Routine,\n-      Mechanism => (Value, Value, Reference, Reference, Reference));\n-\n-   --------------------------\n-   -- Imported Subprograms --\n-   --------------------------\n-\n-   procedure Debug_Get\n-     (Thread_Id : OSI.Thread_Id;\n-      Item_Req  : Unsigned_Word;\n-      Out_Buff  : System.Address;\n-      Buff_Siz  : Unsigned_Word);\n-\n-   procedure Debug_Get\n-     (Thread_Id : OSI.Thread_Id;\n-      Item_Req  : Unsigned_Word;\n-      Out_Buff  : Unsigned_Longword;\n-      Buff_Siz  : Unsigned_Word);\n-   pragma Import (External, Debug_Get);\n-\n-   pragma Import_Procedure (Debug_Get, \"CMA$DEBUG_GET\",\n-     (OSI.Thread_Id, Unsigned_Word, System.Address, Unsigned_Word),\n-     (Reference, Value, Reference, Value));\n-\n-   pragma Import_Procedure (Debug_Get, \"CMA$DEBUG_GET\",\n-     (OSI.Thread_Id, Unsigned_Word, Unsigned_Longword, Unsigned_Word),\n-     (Reference, Value, Reference, Value));\n-\n-   procedure FAOL\n-     (Status : out Cond_Value_Type;\n-      Ctrstr : String;\n-      Outlen : out Unsigned_Word;\n-      Outbuf : out String;\n-      Prmlst : Unsigned_Longword_Array);\n-   pragma Import (External, FAOL);\n-\n-   pragma Import_Valued_Procedure (FAOL, \"SYS$FAOL\",\n-     (Cond_Value_Type, String, Unsigned_Word, String, Unsigned_Longword_Array),\n-     (Value, Descriptor (S), Reference, Descriptor (S), Reference));\n-\n-   procedure Put_Output (\n-     Status         : out Cond_Value_Type;\n-     Message_String : String);\n-\n-   procedure Put_Output (Message_String : String);\n-   pragma Import (External, Put_Output);\n-\n-   pragma Import_Valued_Procedure (Put_Output, \"LIB$PUT_OUTPUT\",\n-     (Cond_Value_Type, String),\n-     (Value, Short_Descriptor (S)));\n-\n-   pragma Import_Procedure (Put_Output, \"LIB$PUT_OUTPUT\",\n-     (String),\n-     (Short_Descriptor (S)));\n-\n-   procedure Signal\n-     (Condition_Value     : Cond_Value_Type;\n-      Number_Of_Arguments : Integer := Integer'Null_Parameter;\n-      FAO_Argument_1      : Unsigned_Longword :=\n-                              Unsigned_Longword'Null_Parameter);\n-   pragma Import (External, Signal);\n-\n-   pragma Import_Procedure (Signal, \"LIB$SIGNAL\",\n-      (Cond_Value_Type, Integer, Unsigned_Longword),\n-      (Value, Value, Value),\n-       Number_Of_Arguments);\n-\n-   ----------------------------\n-   -- Generic Instantiations --\n-   ----------------------------\n-\n-   function Fetch is new Fetch_From_Address (Unsigned_Longword);\n-   pragma Unreferenced (Fetch);\n-\n-   procedure Free is new Ada.Unchecked_Deallocation\n-     (Object => Ada_Event_Control_Block_Type,\n-      Name   => Ada_Event_Control_Block_Access);\n-\n-   function To_AASCIC is new\n-     Ada.Unchecked_Conversion (Unsigned_Longword, AASCIC);\n-\n-   function To_Addr is new\n-     Ada.Unchecked_Conversion (Task_Procedure_Access, Address);\n-   pragma Unreferenced (To_Addr);\n-\n-   function To_EVCB is new\n-     Ada.Unchecked_Conversion\n-      (Unsigned_Longword, Ada_Event_Control_Block_Access);\n-\n-   function To_Integer is new\n-     Ada.Unchecked_Conversion (Task_Id, System.Task_Primitives.Task_Address);\n-\n-   function To_Print_Routine_Type is new\n-     Ada.Unchecked_Conversion (Short_Address, Print_Routine_Type);\n-\n-   --  Optional argumements passed to Print_Routine have to be\n-   --  Unsigned_Longwords so define the required Unchecked_Conversions\n-\n-   function To_UL is new\n-     Ada.Unchecked_Conversion (AASCIC, Unsigned_Longword);\n-\n-   function To_UL is new\n-     Ada.Unchecked_Conversion (Integer, Unsigned_Longword);\n-\n-   function To_UL is new\n-     Ada.Unchecked_Conversion (Task_Id, Unsigned_Longword);\n-\n-   pragma Warnings (Off); --  Different sizes\n-   function To_UL is new\n-     Ada.Unchecked_Conversion (Task_Entry_Index, Unsigned_Longword);\n-   pragma Warnings (On);\n-\n-   function To_UL is new\n-     Ada.Unchecked_Conversion (Short_Address, Unsigned_Longword);\n-\n-   function To_UL is new\n-     Ada.Unchecked_Conversion\n-      (Ada_Event_Control_Block_Access, Unsigned_Longword);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   subtype Function_Codes is System.Aux_DEC.Unsigned_Word range 1 .. 31;\n-   --  The 31 function codes sent by the debugger needed to implement\n-   --  tasking support, enumerated below.\n-\n-   type Register_Array is array (Natural range 0 .. 16) of\n-     System.Aux_DEC.Unsigned_Longword;\n-   --  The register array is a holdover from VAX and not used\n-   --  on Alpha or I64 but is kept as a filler below.\n-\n-   type DBGEXT_Control_Block (Function_Code : Function_Codes) is record\n-      Facility_ID         : System.Aux_DEC.Unsigned_Word;\n-      --  For GNAT use the \"Ada\" facility ID\n-      Status              : System.Aux_DEC.Unsigned_Longword;\n-      --  Successful or otherwise returned status\n-      Flags               : System.Aux_DEC.Bit_Array_32;\n-      --   Used to flag event as global\n-      Print_Routine       : System.Aux_DEC.Short_Address;\n-      --  The print subprogram the caller wants to use for output\n-      Event_Code_or_EVCB  : System.Aux_DEC.Unsigned_Longword;\n-      --  Dual use Event Code or EVent Control Block\n-      Event_Value_or_Name : System.Aux_DEC.Unsigned_Longword;\n-      --  Dual use Event Value or Event Name string pointer\n-      Event_Entry         : System.Aux_DEC.Unsigned_Longword;\n-      Task_Value          : Task_Id;\n-      Task_Number         : Integer;\n-      Ada_Flags           : System.Aux_DEC.Bit_Array_32;\n-      Priority            : System.Aux_DEC.Bit_Array_32;\n-      Active_Registers    : System.Aux_DEC.Short_Address;\n-\n-      case Function_Code is\n-         when K_GET_STATE_1 =>\n-            Base_Priority       : System.Aux_DEC.Bit_Array_32;\n-            Task_Type_Name      : System.Aux_DEC.Short_Address;\n-            Creation_PC         : System.Aux_DEC.Short_Address;\n-            Parent_Task_ID      : Task_Id;\n-\n-         when others =>\n-            Ignored_Unused      : Register_Array;\n-\n-      end case;\n-   end record;\n-\n-   for DBGEXT_Control_Block use record\n-      Function_Code       at 0  range 0 .. 15;\n-      Facility_ID         at 2  range 0 .. 15;\n-      Status              at 4  range 0 .. 31;\n-      Flags               at 8  range 0 .. 31;\n-      Print_Routine       at 12 range 0 .. 31;\n-      Event_Code_or_EVCB  at 16 range 0 .. 31;\n-      Event_Value_or_Name at 20 range 0 .. 31;\n-      Event_Entry         at 24 range 0 .. 31;\n-      Task_Value          at 28 range 0 .. 31;\n-      Task_Number         at 32 range 0 .. 31;\n-      Ada_Flags           at 36 range 0 .. 31;\n-      Priority            at 40 range 0 .. 31;\n-      Active_Registers    at 44 range 0 .. 31;\n-      Ignored_Unused      at 48 range 0 .. 17 * 32 - 1;\n-      Base_Priority       at 48 range 0 .. 31;\n-      Task_Type_Name      at 52 range 0 .. 31;\n-      Creation_PC         at 56 range 0 .. 31;\n-      Parent_Task_ID      at 60 range 0 .. 31;\n-   end record;\n-\n-   type DBGEXT_Control_Block_Access is access all DBGEXT_Control_Block;\n-\n-   function DBGEXT (Control_Block : DBGEXT_Control_Block_Access)\n-     return System.Aux_DEC.Unsigned_Word;\n-   --  Exported to s-taprop.adb to avoid having a VMS specific s-tasdeb.ads\n-   pragma Convention (C, DBGEXT);\n-   pragma Export_Function (DBGEXT, \"GNAT$DBGEXT\");\n-   --  This routine is called by CMA when VMS DEBUG wants the Gnat RTL\n-   --  to give it some assistance (primarily when tasks are debugged).\n-   --\n-   --  The single parameter is an \"external control block\". On input to\n-   --  the Gnat RTL this control block determines the debugging function\n-   --  to be performed, and supplies parameters.  This routine cases on\n-   --  the function code, and calls the appropriate Gnat RTL routine,\n-   --  which returns values by modifying the external control block.\n-\n-   procedure Announce_Event\n-      (Event_EVCB    : Unsigned_Longword;\n-       Print_Routine : Print_Routine_Type := Default_Print_Routine'Access);\n-   --  Announce the occurence of a DEBUG tasking event\n-\n-   procedure Cleanup_Event (Event_EVCB : Unsigned_Longword);\n-   --  After DEBUG has processed an event that has signalled, the signaller\n-   --  must cleanup. Cleanup consists of freeing the event control block.\n-\n-   procedure Disable_Event\n-      (Flags       : Bit_Array_32;\n-       Event_Value : Unsigned_Longword;\n-       Event_Code  : Unsigned_Longword;\n-       Status      : out Cond_Value_Type);\n-   --  Disable a DEBUG tasking event\n-\n-   function DoAC (S : String) return Address;\n-   --  Convert a string to the address of an internal buffer containing\n-   --  the counted ASCII.\n-\n-   procedure Enable_Event\n-      (Flags       : Bit_Array_32;\n-       Event_Value : Unsigned_Longword;\n-       Event_Code  : Unsigned_Longword;\n-       Status      : out Cond_Value_Type);\n-   --  Enable a requested DEBUG tasking event\n-\n-   procedure Find_Event_By_Code\n-      (Event_Code  : Unsigned_Longword;\n-       Event_Entry : out Unsigned_Longword;\n-       Status      : out Cond_Value_Type);\n-   --  Convert an event code to the address of the event entry\n-\n-   procedure Find_Event_By_Name\n-      (Event_Name  : Unsigned_Longword;\n-       Event_Entry : out Unsigned_Longword;\n-       Status      : out Cond_Value_Type);\n-   --  Find an event entry given the event name\n-\n-   procedure List_Entry_Waiters\n-     (Task_Value      : Task_Id;\n-      Full_Display    : Boolean := False;\n-      Suppress_Header : Boolean := False;\n-      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access);\n-   --  List information about tasks waiting on an entry\n-\n-   procedure Put (S : String);\n-   --  Display S on standard output\n-\n-   procedure Put_Line (S : String := \"\");\n-   --  Display S on standard output with an additional line terminator\n-\n-   procedure Show_Event\n-      (Print_Routine : Print_Routine_Type := Default_Print_Routine'Access);\n-   --  Show what events are available\n-\n-   procedure Show_One_Task\n-     (Task_Value      : Task_Id;\n-      Full_Display    : Boolean := False;\n-      Suppress_Header : Boolean := False;\n-      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access);\n-   --  Display information about one task\n-\n-   procedure Show_Rendezvous\n-     (Task_Value      : Task_Id;\n-      Ada_State       : AASCIC := Empty_Text;\n-      Full_Display    : Boolean := False;\n-      Suppress_Header : Boolean := False;\n-      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access);\n-   --  Display information about a task rendezvous\n-\n-   procedure Trace_Output (Message_String : String);\n-   --  Call Put_Output if Trace_on (\"VMS\")\n-\n-   procedure Write (Fd : Integer; S : String; Count : Integer);\n-\n-   --------------------\n-   -- Announce_Event --\n-   --------------------\n-\n-   procedure Announce_Event\n-      (Event_EVCB    : Unsigned_Longword;\n-       Print_Routine : Print_Routine_Type := Default_Print_Routine'Access)\n-   is\n-      EVCB : constant Ada_Event_Control_Block_Access := To_EVCB (Event_EVCB);\n-\n-      Event_Kind : constant Event_Kind_Type :=\n-                     (if EVCB.Sub_Event /= 0\n-                      then Event_Kind_Type (EVCB.Sub_Event)\n-                      else Event_Kind_Type (EVCB.Code));\n-\n-      TI : constant String := \"   Task %TASK !UI is \";\n-      --  Announce prefix\n-\n-   begin\n-      Trace_Output (\"Announce called\");\n-\n-      case Event_Kind is\n-         when Debug_Event_Activating =>\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (TI & \"about to begin its activation\")),\n-              EVCB.Value);\n-         when Debug_Event_Exception_Terminated =>\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (TI & \"terminating because of an exception\")),\n-              EVCB.Value);\n-         when Debug_Event_Run =>\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (TI & \"about to run\")),\n-              EVCB.Value);\n-         when Debug_Event_Abort_Terminated =>\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (TI & \"terminating because of abort\")),\n-              EVCB.Value);\n-         when Debug_Event_Terminated =>\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (TI & \"terminating normally\")),\n-              EVCB.Value);\n-         when others => null;\n-      end case;\n-   end Announce_Event;\n-\n-   -------------------\n-   -- Cleanup_Event --\n-   -------------------\n-\n-   procedure Cleanup_Event (Event_EVCB  : Unsigned_Longword) is\n-      EVCB : Ada_Event_Control_Block_Access := To_EVCB (Event_EVCB);\n-   begin\n-      Free (EVCB);\n-   end Cleanup_Event;\n-\n-   ------------------------\n-   -- Continue_All_Tasks --\n-   ------------------------\n-\n-   procedure Continue_All_Tasks is\n-   begin\n-      null; --  VxWorks\n-   end Continue_All_Tasks;\n-\n-   ------------\n-   -- DBGEXT --\n-   ------------\n-\n-   function DBGEXT\n-     (Control_Block : DBGEXT_Control_Block_Access)\n-      return System.Aux_DEC.Unsigned_Word\n-   is\n-      Print_Routine : Print_Routine_Type := Default_Print_Routine'Access;\n-   begin\n-      Trace_Output (\"DBGEXT called\");\n-\n-      if Control_Block.Print_Routine /= Address_Zero then\n-         Print_Routine := To_Print_Routine_Type (Control_Block.Print_Routine);\n-      end if;\n-\n-      case Control_Block.Function_Code is\n-\n-         --  Convert a task value to a task number.\n-         --  The output results are stored in the CONTROL_BLOCK.\n-\n-         when K_CVT_VALUE_NUM =>\n-            Trace_Output (\"DBGEXT param 1 - CVT Value to NUM\");\n-            Control_Block.Task_Number :=\n-              Control_Block.Task_Value.Known_Tasks_Index + 1;\n-            Control_Block.Status := K_SUCCESS;\n-            Trace_Output (\"Task Number: \");\n-            Trace_Output (Integer'Image (Control_Block.Task_Number));\n-            return SS_NORMAL;\n-\n-         --  Convert a task number to a task value.\n-         --  The output results are stored in the CONTROL_BLOCK.\n-\n-         when K_CVT_NUM_VALUE =>\n-            Trace_Output (\"DBGEXT param 2 - CVT NUM to Value\");\n-            Trace_Output (\"Task Number: \");\n-            Trace_Output (Integer'Image (Control_Block.Task_Number));\n-            Control_Block.Task_Value :=\n-              Known_Tasks (Control_Block.Task_Number - 1);\n-            Control_Block.Status := K_SUCCESS;\n-            Trace_Output (\"Task Value: \");\n-            Trace_Output (Unsigned_Longword'Image\n-              (To_UL (Control_Block.Task_Value)));\n-            return SS_NORMAL;\n-\n-         --  Obtain the \"next\" task after a specified task.\n-         --  ??? To do: If specified check the PRIORITY, STATE, and HOLD\n-         --  fields to restrict the selection of the next task.\n-         --  The output results are stored in the CONTROL_BLOCK.\n-\n-         when K_NEXT_TASK =>\n-            Trace_Output (\"DBGEXT param 3 - Next Task\");\n-            Trace_Output (\"Task Value: \");\n-            Trace_Output (Unsigned_Longword'Image\n-              (To_UL (Control_Block.Task_Value)));\n-\n-            if Control_Block.Task_Value = null then\n-               Control_Block.Task_Value := Known_Tasks (Known_Tasks'First);\n-            else\n-               Control_Block.Task_Value :=\n-                 Known_Tasks (Control_Block.Task_Value.Known_Tasks_Index + 1);\n-            end if;\n-\n-            if Control_Block.Task_Value = null then\n-               Control_Block.Task_Value := Known_Tasks (Known_Tasks'First);\n-            end if;\n-\n-            Control_Block.Status := K_SUCCESS;\n-            return SS_NORMAL;\n-\n-         --  Display the state of a task. The FULL bit is checked to decide if\n-         --  a full or brief task display is desired. The output results are\n-         --  stored in the CONTROL_BLOCK.\n-\n-         when K_SHOW_TASK =>\n-            Trace_Output (\"DBGEXT param 4 - Show Task\");\n-\n-            if Control_Block.Task_Value = null then\n-               Control_Block.Status := K_TASK_NOT_EXIST;\n-            else\n-               Show_One_Task\n-                 (Control_Block.Task_Value,\n-                  Control_Block.Ada_Flags (V_Full_Display),\n-                  Control_Block.Ada_Flags (V_Suppress_Header),\n-                  Print_Routine);\n-\n-               Control_Block.Status := K_SUCCESS;\n-            end if;\n-\n-            return SS_NORMAL;\n-\n-         --  Enable a requested DEBUG tasking event\n-\n-         when K_ENABLE_EVENT =>\n-            Trace_Output (\"DBGEXT param 17 - Enable Event\");\n-            Enable_Event\n-              (Control_Block.Flags,\n-               Control_Block.Event_Value_or_Name,\n-               Control_Block.Event_Code_or_EVCB,\n-               Control_Block.Status);\n-\n-            return SS_NORMAL;\n-\n-         --  Disable a DEBUG tasking event\n-\n-         when K_DISABLE_EVENT =>\n-            Trace_Output (\"DBGEXT param 18 - Disable Event\");\n-            Disable_Event\n-              (Control_Block.Flags,\n-               Control_Block.Event_Value_or_Name,\n-               Control_Block.Event_Code_or_EVCB,\n-               Control_Block.Status);\n-\n-            return SS_NORMAL;\n-\n-         --  Announce the occurence of a DEBUG tasking event\n-\n-         when K_ANNOUNCE_EVENT =>\n-            Trace_Output (\"DBGEXT param 19 - Announce Event\");\n-            Announce_Event\n-              (Control_Block.Event_Code_or_EVCB,\n-               Print_Routine);\n-\n-            Control_Block.Status := K_SUCCESS;\n-            return SS_NORMAL;\n-\n-         --  After DEBUG has processed an event that has signalled,\n-         --  the signaller must cleanup.\n-         --  Cleanup consists of freeing the event control block.\n-\n-         when K_CLEANUP_EVENT =>\n-            Trace_Output (\"DBGEXT param 24 - Cleanup Event\");\n-            Cleanup_Event (Control_Block.Event_Code_or_EVCB);\n-\n-            Control_Block.Status := K_SUCCESS;\n-            return SS_NORMAL;\n-\n-         --  Show what events are available\n-\n-         when K_SHOW_EVENT_DEF =>\n-            Trace_Output (\"DBGEXT param 25 - Show Event Def\");\n-            Show_Event (Print_Routine);\n-\n-            Control_Block.Status := K_SUCCESS;\n-            return SS_NORMAL;\n-\n-         --  Convert an event code to the address of the event entry\n-\n-         when K_FIND_EVENT_BY_CODE =>\n-            Trace_Output (\"DBGEXT param 29 - Find Event by Code\");\n-            Find_Event_By_Code\n-              (Control_Block.Event_Code_or_EVCB,\n-               Control_Block.Event_Entry,\n-               Control_Block.Status);\n-\n-            return SS_NORMAL;\n-\n-         --  Find an event entry given the event name\n-\n-         when K_FIND_EVENT_BY_NAME =>\n-            Trace_Output (\"DBGEXT param 30 - Find Event by Name\");\n-            Find_Event_By_Name\n-              (Control_Block.Event_Value_or_Name,\n-               Control_Block.Event_Entry,\n-               Control_Block.Status);\n-            return SS_NORMAL;\n-\n-         --  ??? To do: Implement priority events\n-         --  Get, set or restore a task's priority\n-\n-         when K_GET_PRIORITY or K_SET_PRIORITY or K_RESTORE_PRIORITY =>\n-            Trace_Output (\"DBGEXT priority param - Not yet implemented\");\n-            Trace_Output (Function_Codes'Image\n-             (Control_Block.Function_Code));\n-            return SS_BADPARAM;\n-\n-         --  ??? To do: Implement show statistics event\n-         --  Display task statistics\n-\n-         when K_SHOW_STAT =>\n-            Trace_Output (\"DBGEXT show stat param - Not yet implemented\");\n-            Trace_Output (Function_Codes'Image\n-             (Control_Block.Function_Code));\n-            return SS_BADPARAM;\n-\n-         --  ??? To do: Implement get caller event\n-         --  Obtain the caller of a task in a rendezvous. If no rendezvous,\n-         --  null is returned\n-\n-         when K_GET_CALLER =>\n-            Trace_Output (\"DBGEXT get caller param - Not yet implemented\");\n-            Trace_Output (Function_Codes'Image\n-             (Control_Block.Function_Code));\n-            return SS_BADPARAM;\n-\n-         --  ??? To do: Implement set terminate event\n-         --  Terminate a task\n-\n-         when K_SET_ABORT =>\n-            Trace_Output (\"DBGEXT set terminate param - Not yet implemented\");\n-            Trace_Output (Function_Codes'Image\n-             (Control_Block.Function_Code));\n-            return SS_BADPARAM;\n-\n-         --  ??? To do: Implement show deadlock event\n-         --  Detect a deadlock\n-\n-         when K_SHOW_DEADLOCK =>\n-            Trace_Output (\"DBGEXT show deadlock param - Not yet implemented\");\n-            Trace_Output (Function_Codes'Image\n-             (Control_Block.Function_Code));\n-            return SS_BADPARAM;\n-\n-         when others =>\n-            Trace_Output (\"DBGEXT bad param: \");\n-            Trace_Output (Function_Codes'Image\n-             (Control_Block.Function_Code));\n-            return SS_BADPARAM;\n-\n-      end case;\n-   end DBGEXT;\n-\n-   ---------------------------\n-   -- Default_Print_Routine --\n-   ---------------------------\n-\n-   procedure Default_Print_Routine\n-     (Print_Function    : Print_Functions;\n-      Print_Subfunction : Print_Functions;\n-      P1                : Unsigned_Longword := 0;\n-      P2                : Unsigned_Longword := 0;\n-      P3                : Unsigned_Longword := 0;\n-      P4                : Unsigned_Longword := 0;\n-      P5                : Unsigned_Longword := 0;\n-      P6                : Unsigned_Longword := 0)\n-   is\n-      Status    : Cond_Value_Type;\n-      Linlen    : Unsigned_Word;\n-      Item_List : Unsigned_Longword_Array (1 .. 17) :=\n-        (1 .. 17 => 0);\n-   begin\n-\n-      case Print_Function is\n-         when Print_Control | Print_String =>\n-            null;\n-\n-         --  Formatted Ascii Output\n-\n-         when Print_FAO =>\n-            Item_List (1) := P2;\n-            Item_List (2) := P3;\n-            Item_List (3) := P4;\n-            Item_List (4) := P5;\n-            Item_List (5) := P6;\n-            FAOL\n-              (Status,\n-               To_AASCIC (P1).Text,\n-               Linlen,\n-               Print_Routine_Linbuf\n-                 (1 + Print_Routine_Bufcnt .. Print_Routine_Bufsiz),\n-               Item_List);\n-\n-            Print_Routine_Bufcnt := Print_Routine_Bufcnt + Integer (Linlen);\n-\n-         --  Symbolic output\n-\n-         when Print_Symbol =>\n-            Item_List (1) := P1;\n-            FAOL\n-              (Status,\n-               \"!XI\",\n-               Linlen,\n-               Print_Routine_Linbuf\n-                 (1 + Print_Routine_Bufcnt .. Print_Routine_Bufsiz),\n-               Item_List);\n-\n-            Print_Routine_Bufcnt := Print_Routine_Bufcnt + Integer (Linlen);\n-\n-         when others =>\n-            null;\n-      end case;\n-\n-      case Print_Subfunction is\n-\n-         --  Output buffer with a terminating newline\n-\n-         when Print_Newline =>\n-            Put_Output (Status,\n-              Print_Routine_Linbuf (1 .. Print_Routine_Bufcnt));\n-            Print_Routine_Bufcnt := 0;\n-\n-         --  Buffer the output\n-\n-         when No_Print =>\n-            null;\n-\n-         when others =>\n-            null;\n-      end case;\n-\n-   end Default_Print_Routine;\n-\n-   -------------------\n-   -- Disable_Event --\n-   -------------------\n-\n-   procedure Disable_Event\n-      (Flags       : Bit_Array_32;\n-       Event_Value : Unsigned_Longword;\n-       Event_Code  : Unsigned_Longword;\n-       Status      : out Cond_Value_Type)\n-   is\n-      Task_Value : Task_Id;\n-      Task_Index : constant Integer := Integer (Event_Value) - 1;\n-   begin\n-\n-      Events_Enabled_Count := Events_Enabled_Count - 1;\n-\n-      if Flags (V_EVNT_ALL) then\n-         Global_Task_Debug_Events (Integer (Event_Code)) := False;\n-         Status := K_SUCCESS;\n-      else\n-         if Task_Index in Known_Tasks'Range then\n-            Task_Value := Known_Tasks (Task_Index);\n-            if Task_Value /= null then\n-               Task_Value.Common.Debug_Events (Integer (Event_Code)) := False;\n-               Status := K_SUCCESS;\n-            else\n-               Status := K_TASK_NOT_EXIST;\n-            end if;\n-         else\n-            Status := K_TASK_NOT_EXIST;\n-         end if;\n-      end if;\n-\n-      --  Keep count of events for efficiency\n-\n-      if Events_Enabled_Count <= 0 then\n-         Events_Enabled_Count := 0;\n-         Global_Task_Debug_Event_Set := False;\n-      end if;\n-\n-   end Disable_Event;\n-\n-   ----------\n-   -- DoAC --\n-   ----------\n-\n-   function DoAC (S : String) return Address is\n-   begin\n-      AC_Buffer.Count := S'Length;\n-      AC_Buffer.Text (1 .. AC_Buffer.Count) := S;\n-      return AC_Buffer'Address;\n-   end DoAC;\n-\n-   ------------------\n-   -- Enable_Event --\n-   ------------------\n-\n-   procedure Enable_Event\n-      (Flags       : Bit_Array_32;\n-       Event_Value : Unsigned_Longword;\n-       Event_Code  : Unsigned_Longword;\n-       Status      : out Cond_Value_Type)\n-   is\n-      Task_Value : Task_Id;\n-      Task_Index : constant Integer := Integer (Event_Value) - 1;\n-\n-   begin\n-      --  At least one event enabled, any and all events will cause a\n-      --  condition to be raised and checked. Major tasking slowdown.\n-\n-      Global_Task_Debug_Event_Set := True;\n-      Events_Enabled_Count := Events_Enabled_Count + 1;\n-\n-      if Flags (V_EVNT_ALL) then\n-         Global_Task_Debug_Events (Integer (Event_Code)) := True;\n-         Status := K_SUCCESS;\n-      else\n-         if Task_Index in Known_Tasks'Range then\n-            Task_Value := Known_Tasks (Task_Index);\n-            if Task_Value /= null then\n-               Task_Value.Common.Debug_Events (Integer (Event_Code)) := True;\n-               Status := K_SUCCESS;\n-            else\n-               Status := K_TASK_NOT_EXIST;\n-            end if;\n-         else\n-            Status := K_TASK_NOT_EXIST;\n-         end if;\n-      end if;\n-\n-   end Enable_Event;\n-\n-   ------------------------\n-   -- Find_Event_By_Code --\n-   ------------------------\n-\n-   procedure Find_Event_By_Code\n-      (Event_Code  : Unsigned_Longword;\n-       Event_Entry : out Unsigned_Longword;\n-       Status      : out Cond_Value_Type)\n-   is\n-      K_SUCCESS       : constant := 1;\n-      K_NO_SUCH_EVENT : constant := 9;\n-\n-   begin\n-      Trace_Output (\"Looking for Event: \");\n-      Trace_Output (Unsigned_Longword'Image (Event_Code));\n-\n-      for I in Event_Kind_Type'Range loop\n-         if Event_Code = Unsigned_Longword (Event_Directory (I).Code) then\n-            Event_Entry := To_UL (Event_Directory (I)'Address);\n-            Trace_Output (\"Found Event # \");\n-            Trace_Output (Integer'Image (I));\n-            Status := K_SUCCESS;\n-            return;\n-         end if;\n-      end loop;\n-\n-      Status := K_NO_SUCH_EVENT;\n-   end Find_Event_By_Code;\n-\n-   ------------------------\n-   -- Find_Event_By_Name --\n-   ------------------------\n-\n-   procedure Find_Event_By_Name\n-      (Event_Name  : Unsigned_Longword;\n-       Event_Entry : out Unsigned_Longword;\n-       Status      : out Cond_Value_Type)\n-   is\n-      K_SUCCESS       : constant := 1;\n-      K_NO_SUCH_EVENT : constant := 9;\n-\n-      Event_Name_Cstr : constant ASCIC := To_AASCIC (Event_Name).all;\n-   begin\n-      Trace_Output (\"Looking for Event: \");\n-      Trace_Output (Event_Name_Cstr.Text);\n-\n-      for I in Event_Kind_Type'Range loop\n-         if Event_Name_Cstr.Count >= Event_Directory (I).Minchr\n-            and then Event_Name_Cstr.Count <= Event_Directory (I).Name.Count\n-            and then Event_Name_Cstr.Text (1 .. Event_Directory (I).Minchr) =\n-                Event_Directory (I).Name.Text (1 .. Event_Directory (I).Minchr)\n-         then\n-            Event_Entry := To_UL (Event_Directory (I)'Address);\n-            Trace_Output (\"Found Event # \");\n-            Trace_Output (Integer'Image (I));\n-            Status := K_SUCCESS;\n-            return;\n-         end if;\n-      end loop;\n-\n-      Status := K_NO_SUCH_EVENT;\n-   end Find_Event_By_Name;\n-\n-   --------------------\n-   -- Get_User_State --\n-   --------------------\n-\n-   function Get_User_State return Long_Integer is\n-   begin\n-      return STPO.Self.User_State;\n-   end Get_User_State;\n-\n-   ------------------------\n-   -- List_Entry_Waiters --\n-   ------------------------\n-\n-   procedure List_Entry_Waiters\n-     (Task_Value      : Task_Id;\n-      Full_Display    : Boolean := False;\n-      Suppress_Header : Boolean := False;\n-      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access)\n-   is\n-      pragma Unreferenced (Suppress_Header);\n-\n-      Entry_Call : Entry_Call_Link;\n-      Have_Some  : Boolean := False;\n-   begin\n-      if not Full_Display then\n-         return;\n-      end if;\n-\n-      if Task_Value.Entry_Queues'Length > 0 then\n-         Print_Routine (Print_FAO, Print_Newline,\n-           To_UL (DoAC (\"        Waiting entry callers:\")));\n-      end if;\n-      for I in Task_Value.Entry_Queues'Range loop\n-         Entry_Call := Task_Value.Entry_Queues (I).Head;\n-         if Entry_Call /= null then\n-            Have_Some := True;\n-\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (\"          Waiters for entry !UI:\")),\n-              To_UL (I));\n-\n-            loop\n-               declare\n-                  Task_Image : ASCIC :=\n-                   (Entry_Call.Self.Common.Task_Image_Len,\n-                    Entry_Call.Self.Common.Task_Image\n-                      (1 .. Entry_Call.Self.Common.Task_Image_Len));\n-               begin\n-                  Print_Routine (Print_FAO, Print_Newline,\n-                    To_UL (DoAC (\"              %TASK !UI, type: !AC\")),\n-                    To_UL (Entry_Call.Self.Known_Tasks_Index + 1),\n-                    To_UL (Task_Image'Address));\n-                  if Entry_Call = Task_Value.Entry_Queues (I).Tail then\n-                     exit;\n-                  end if;\n-                  Entry_Call := Entry_Call.Next;\n-               end;\n-            end loop;\n-         end if;\n-      end loop;\n-      if not Have_Some then\n-         Print_Routine (Print_FAO, Print_Newline,\n-           To_UL (DoAC (\"          none.\")));\n-      end if;\n-   end List_Entry_Waiters;\n-\n-   ----------------\n-   -- List_Tasks --\n-   ----------------\n-\n-   procedure List_Tasks is\n-      C : Task_Id;\n-   begin\n-      C := All_Tasks_List;\n-\n-      while C /= null loop\n-         Print_Task_Info (C);\n-         C := C.Common.All_Tasks_Link;\n-      end loop;\n-   end List_Tasks;\n-\n-   ------------------------\n-   -- Print_Current_Task --\n-   ------------------------\n-\n-   procedure Print_Current_Task is\n-   begin\n-      Print_Task_Info (STPO.Self);\n-   end Print_Current_Task;\n-\n-   ---------------------\n-   -- Print_Task_Info --\n-   ---------------------\n-\n-   procedure Print_Task_Info (T : Task_Id) is\n-      Entry_Call : Entry_Call_Link;\n-      Parent     : Task_Id;\n-\n-   begin\n-      if T = null then\n-         Put_Line (\"null task\");\n-         return;\n-      end if;\n-\n-      Put (T.Common.Task_Image (1 .. T.Common.Task_Image_Len) & \": \" &\n-           Task_States'Image (T.Common.State));\n-\n-      Parent := T.Common.Parent;\n-\n-      if Parent = null then\n-         Put (\", parent: <none>\");\n-      else\n-         Put (\", parent: \" &\n-              Parent.Common.Task_Image (1 .. Parent.Common.Task_Image_Len));\n-      end if;\n-\n-      Put (\", prio:\" & T.Common.Current_Priority'Img);\n-\n-      if not T.Callable then\n-         Put (\", not callable\");\n-      end if;\n-\n-      if T.Aborting then\n-         Put (\", aborting\");\n-      end if;\n-\n-      if T.Deferral_Level /= 0 then\n-         Put (\", abort deferred\");\n-      end if;\n-\n-      if T.Common.Call /= null then\n-         Entry_Call := T.Common.Call;\n-         Put (\", serving:\");\n-\n-         while Entry_Call /= null loop\n-            Put (To_Integer (Entry_Call.Self)'Img);\n-            Entry_Call := Entry_Call.Acceptor_Prev_Call;\n-         end loop;\n-      end if;\n-\n-      if T.Open_Accepts /= null then\n-         Put (\", accepting:\");\n-\n-         for J in T.Open_Accepts'Range loop\n-            Put (T.Open_Accepts (J).S'Img);\n-         end loop;\n-\n-         if T.Terminate_Alternative then\n-            Put (\" or terminate\");\n-         end if;\n-      end if;\n-\n-      if T.User_State /= 0 then\n-         Put (\", state:\" & T.User_State'Img);\n-      end if;\n-\n-      Put_Line;\n-   end Print_Task_Info;\n-\n-   ---------\n-   -- Put --\n-   ---------\n-\n-   procedure Put (S : String) is\n-   begin\n-      Write (2, S, S'Length);\n-   end Put;\n-\n-   --------------\n-   -- Put_Line --\n-   --------------\n-\n-   procedure Put_Line (S : String := \"\") is\n-   begin\n-      Write (2, S & ASCII.LF, S'Length + 1);\n-   end Put_Line;\n-\n-   ----------------------\n-   -- Resume_All_Tasks --\n-   ----------------------\n-\n-   procedure Resume_All_Tasks (Thread_Self : OS_Interface.Thread_Id) is\n-      pragma Unreferenced (Thread_Self);\n-   begin\n-      null; --  VxWorks\n-   end Resume_All_Tasks;\n-\n-   ---------------\n-   -- Set_Trace --\n-   ---------------\n-\n-   procedure Set_Trace (Flag  : Character; Value : Boolean := True) is\n-   begin\n-      Trace_On (Flag) := Value;\n-   end Set_Trace;\n-\n-   --------------------\n-   -- Set_User_State --\n-   --------------------\n-\n-   procedure Set_User_State (Value : Long_Integer) is\n-   begin\n-      STPO.Self.User_State := Value;\n-   end Set_User_State;\n-\n-   ----------------\n-   -- Show_Event --\n-   ----------------\n-\n-   procedure Show_Event\n-      (Print_Routine : Print_Routine_Type := Default_Print_Routine'Access)\n-   is\n-   begin\n-      for I in Event_Def_Help'Range loop\n-         Print_Routine (Print_FAO, Print_Newline, To_UL (Event_Def_Help (I)));\n-      end loop;\n-\n-      for I in Event_Kind_Type'Range loop\n-         Print_Routine (Print_FAO, Print_Newline,\n-           To_UL (Event_Directory\n-                   (Global_Event_Display_Order (I)).Name'Address));\n-         Print_Routine (Print_FAO, Print_Newline,\n-           To_UL (Event_Directory (Global_Event_Display_Order (I)).Help));\n-      end loop;\n-   end Show_Event;\n-\n-   --------------------\n-   -- Show_One_Task --\n-   --------------------\n-\n-   procedure Show_One_Task\n-     (Task_Value      : Task_Id;\n-      Full_Display    : Boolean := False;\n-      Suppress_Header : Boolean := False;\n-      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access)\n-   is\n-      Task_SP            : System.Address := Address_Zero;\n-      Stack_Base         : System.Address := Address_Zero;\n-      Stack_Top          : System.Address := Address_Zero;\n-      TCB_Size           : Unsigned_Longword := 0;\n-      CMA_TCB_Size       : Unsigned_Longword := 0;\n-      Stack_Guard_Size   : Unsigned_Longword := 0;\n-      Total_Task_Storage : Unsigned_Longword := 0;\n-      Stack_In_Use       : Unsigned_Longword := 0;\n-      Reserved_Size      : Unsigned_Longword := 0;\n-      Hold_Flag          : Unsigned_Longword := 0;\n-      Sched_State        : Unsigned_Longword := 0;\n-      User_Prio          : Unsigned_Longword := 0;\n-      Stack_Size         : Unsigned_Longword := 0;\n-      Run_State          : Boolean := False;\n-      Rea_State          : Boolean := False;\n-      Sus_State          : Boolean := False;\n-      Ter_State          : Boolean := False;\n-\n-      Current_Flag : AASCIC := NoStar;\n-      Hold_String  : AASCIC := NoHold;\n-      Ada_State    : AASCIC := Ada_State_Invalid_State;\n-      Debug_State  : AASCIC := Debug_State_Emp;\n-\n-      Ada_State_Len   : constant Unsigned_Longword := 17;\n-      Debug_State_Len : constant Unsigned_Longword := 5;\n-\n-      Entry_Call : Entry_Call_Record;\n-\n-   begin\n-\n-      --  Initialize local task info variables\n-\n-      Task_SP := Address_Zero;\n-      Stack_Base := Address_Zero;\n-      Stack_Top := Address_Zero;\n-      CMA_TCB_Size := 0;\n-      Stack_Guard_Size := 0;\n-      Reserved_Size := 0;\n-      Hold_Flag := 0;\n-      Sched_State := 0;\n-      TCB_Size := Unsigned_Longword (Task_Id'Size);\n-\n-      if not Suppress_Header or else Full_Display then\n-         Print_Routine (Print_FAO, Print_Newline, To_UL (Empty_Text));\n-         Print_Routine (Print_FAO, Print_Newline, To_UL (Header));\n-      end if;\n-\n-      Trace_Output (\"Show_One_Task Task Value: \");\n-      Trace_Output (Unsigned_Longword'Image (To_UL (Task_Value)));\n-\n-      --  Callback to DEBUG to get some task info\n-\n-      if Task_Value.Common.State /= Terminated then\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_STACKPTR,\n-            Task_SP,\n-            8);\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_TCB_SIZE,\n-            CMA_TCB_Size,\n-            4);\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_GUARDSIZE,\n-            Stack_Guard_Size,\n-            4);\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_YELLOWSIZE,\n-            Reserved_Size,\n-            4);\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_STACK_BASE,\n-            Stack_Base,\n-            8);\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_STACK_TOP,\n-            Stack_Top,\n-            8);\n-\n-         Stack_Size := Unsigned_Longword (Stack_Base - Stack_Top)\n-           - Reserved_Size - Stack_Guard_Size;\n-         Stack_In_Use := Unsigned_Longword (Stack_Base - Task_SP) + 4;\n-         Total_Task_Storage := TCB_Size + Stack_Size + Stack_Guard_Size\n-           + Reserved_Size + CMA_TCB_Size;\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_IS_HELD,\n-            Hold_Flag,\n-            4);\n-\n-         Hold_String := (if Hold_Flag /= 0 then Hold else NoHold);\n-\n-         Debug_Get\n-           (STPO.Get_Thread_Id (Task_Value),\n-            CMA_C_DEBGET_SCHED_STATE,\n-            Sched_State,\n-            4);\n-      end if;\n-\n-      Run_State := False;\n-      Rea_State := False;\n-      Sus_State := Task_Value.Common.State = Unactivated;\n-      Ter_State := Task_Value.Common.State = Terminated;\n-\n-      if not Ter_State then\n-         Run_State := Sched_State = 0;\n-         Rea_State := Sched_State = 1;\n-         Sus_State := Sched_State /= 0 and Sched_State /= 1;\n-      end if;\n-\n-      --  Set the debug state\n-\n-      if Run_State then\n-         Debug_State := Debug_State_Run;\n-      elsif Rea_State then\n-         Debug_State := Debug_State_Rea;\n-      elsif Sus_State then\n-         Debug_State := Debug_State_Sus;\n-      elsif Ter_State then\n-         Debug_State := Debug_State_Ter;\n-      end if;\n-\n-      Trace_Output (\"Before case State: \");\n-      Trace_Output (Task_States'Image (Task_Value.Common.State));\n-\n-      --  Set the Ada state\n-\n-      case Task_Value.Common.State is\n-         when Unactivated =>\n-            Ada_State := Ada_State_Not_Yet_Activated;\n-\n-         when Activating =>\n-            Ada_State := Ada_State_Activating;\n-\n-         when Runnable =>\n-            Ada_State := Ada_State_Runnable;\n-\n-         when Terminated =>\n-            Ada_State := Ada_State_Terminated;\n-\n-         when Activator_Sleep =>\n-            Ada_State := Ada_State_Activating_Tasks;\n-\n-         when Acceptor_Sleep =>\n-            Ada_State := Ada_State_Accept;\n-\n-         when Acceptor_Delay_Sleep =>\n-            Ada_State := Ada_State_Select_or_Delay;\n-\n-         when Entry_Caller_Sleep =>\n-            Entry_Call :=\n-              Task_Value.Entry_Calls (Task_Value.ATC_Nesting_Level);\n-\n-            case Entry_Call.Mode is\n-               when Simple_Call =>\n-                  Ada_State := Ada_State_Entry_Call;\n-               when Conditional_Call =>\n-                  Ada_State := Ada_State_Cond_Entry_Call;\n-               when Timed_Call =>\n-                  Ada_State := Ada_State_Timed_Entry_Call;\n-               when Asynchronous_Call =>\n-                  Ada_State := Ada_State_Async_Entry_Call;\n-            end case;\n-\n-         when Async_Select_Sleep =>\n-            Ada_State := Ada_State_Select_or_Abort;\n-\n-         when Delay_Sleep =>\n-            Ada_State := Ada_State_Delay;\n-\n-         when Master_Completion_Sleep =>\n-            Ada_State := Ada_State_Completed;\n-\n-         when Master_Phase_2_Sleep =>\n-            Ada_State := Ada_State_Completed;\n-\n-         when Interrupt_Server_Idle_Sleep |\n-              Interrupt_Server_Blocked_Interrupt_Sleep |\n-              Timer_Server_Sleep |\n-              Interrupt_Server_Blocked_On_Event_Flag =>\n-            Ada_State := Ada_State_Server;\n-\n-         when AST_Server_Sleep =>\n-            Ada_State := Ada_State_IO_or_AST;\n-\n-         when Asynchronous_Hold =>\n-            Ada_State := Ada_State_Async_Hold;\n-\n-      end case;\n-\n-      if Task_Value.Terminate_Alternative then\n-         Ada_State := Ada_State_Select_or_Term;\n-      end if;\n-\n-      if Task_Value.Aborting then\n-         Ada_State := Ada_State_Aborting;\n-      end if;\n-\n-      User_Prio := To_UL (Task_Value.Common.Current_Priority);\n-      Trace_Output (\"After user_prio\");\n-\n-      --  Flag the current task\n-\n-      Current_Flag := (if Task_Value = Self then Star else NoStar);\n-\n-      --  Show task info\n-\n-      Print_Routine (Print_FAO, No_Print, To_UL (DoAC (\"!AC%TASK !5<!UI!>\")),\n-        To_UL (Current_Flag), To_UL (Task_Value.Known_Tasks_Index + 1));\n-\n-      Print_Routine (Print_FAO, No_Print, To_UL (DoAC (\"!2UB\")), User_Prio);\n-\n-      Print_Routine (Print_FAO, No_Print, To_UL (DoAC (\" !AC !5AD !17AD \")),\n-        To_UL (Hold_String), Debug_State_Len, To_UL (Debug_State),\n-        Ada_State_Len, To_UL (Ada_State));\n-\n---      Print_Routine (Print_Symbol, Print_Newline,\n---         Fetch (To_Addr (Task_Value.Common.Task_Entry_Point)));\n-\n-      Print_Routine (Print_FAO, Print_Newline, To_UL (Empty_Text));\n-\n-      --  If /full qualfier passed, show detailed info\n-\n-      if Full_Display then\n-         Show_Rendezvous (Task_Value, Ada_State, Full_Display,\n-           Suppress_Header, Print_Routine);\n-\n-         List_Entry_Waiters (Task_Value, Full_Display,\n-           Suppress_Header, Print_Routine);\n-\n-         Print_Routine (Print_FAO, Print_Newline, To_UL (Empty_Text));\n-\n-         declare\n-            Task_Image : ASCIC := (Task_Value.Common.Task_Image_Len,\n-              Task_Value.Common.Task_Image\n-               (1 .. Task_Value.Common.Task_Image_Len));\n-         begin\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (\"        Task type:      !AC\")),\n-              To_UL (Task_Image'Address));\n-         end;\n-\n-         --  How to find Creation_PC ???\n---         Print_Routine (Print_FAO, No_Print,\n---           To_UL (DoAC (\"        Created at PC:  \")),\n---         Print_Routine (Print_FAO, Print_Newline, Creation_PC);\n-\n-         if Task_Value.Common.Parent /= null then\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (\"        Parent task:    %TASK !UI\")),\n-              To_UL (Task_Value.Common.Parent.Known_Tasks_Index + 1));\n-         else\n-            Print_Routine (Print_FAO, Print_Newline,\n-             To_UL (DoAC (\"        Parent task:    none\")));\n-         end if;\n-\n---         Print_Routine (Print_FAO, No_Print,\n---           To_UL (DoAC (\"        Start PC:       \")));\n---         Print_Routine (Print_Symbol, Print_Newline,\n---            Fetch (To_Addr (Task_Value.Common.Task_Entry_Point)));\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\n-           \"        Task control block:             Stack storage (bytes):\")));\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\n-           \"          Task value:   !10<!UI!>        RESERVED_BYTES:  !10UI\")),\n-          To_UL (Task_Value), Reserved_Size);\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\n-           \"          Entries:      !10<!UI!>        TOP_GUARD_SIZE:  !10UI\")),\n-          To_UL (Task_Value.Entry_Num), Stack_Guard_Size);\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\n-           \"          Size:         !10<!UI!>        STORAGE_SIZE:    !10UI\")),\n-          TCB_Size + CMA_TCB_Size, Stack_Size);\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\n-           \"        Stack addresses:                 Bytes in use:    !10UI\")),\n-          Stack_In_Use);\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\"          Top address:  !10<!XI!>\")),\n-          To_UL (Stack_Top));\n-\n-         Print_Routine (Print_FAO, Print_Newline,\n-          To_UL (DoAC (\n-           \"          Base address: !10<!XI!>      Total storage:     !10UI\")),\n-          To_UL (Stack_Base), Total_Task_Storage);\n-      end if;\n-\n-   end Show_One_Task;\n-\n-   ---------------------\n-   -- Show_Rendezvous --\n-   ---------------------\n-\n-   procedure Show_Rendezvous\n-     (Task_Value      : Task_Id;\n-      Ada_State       : AASCIC := Empty_Text;\n-      Full_Display    : Boolean := False;\n-      Suppress_Header : Boolean := False;\n-      Print_Routine   : Print_Routine_Type := Default_Print_Routine'Access)\n-   is\n-      pragma Unreferenced (Ada_State);\n-      pragma Unreferenced (Suppress_Header);\n-\n-      Temp_Entry  : Entry_Index;\n-      Entry_Call  : Entry_Call_Record;\n-      Called_Task : Task_Id;\n-      AWR         : constant String := \"        Awaiting rendezvous at: \";\n-      --  Common prefix\n-\n-      procedure Print_Accepts;\n-      --  Display information about task rendezvous accepts\n-\n-      procedure Print_Accepts is\n-      begin\n-         if Task_Value.Open_Accepts /= null then\n-            for I in Task_Value.Open_Accepts'Range loop\n-               Temp_Entry := Entry_Index (Task_Value.Open_Accepts (I).S);\n-               declare\n-                  Entry_Name_Image : ASCIC :=\n-                    (Task_Value.Entry_Names (Temp_Entry).all'Length,\n-                     Task_Value.Entry_Names (Temp_Entry).all);\n-               begin\n-                  Trace_Output (\"Accept at: \" & Entry_Name_Image.Text);\n-                  Print_Routine (Print_FAO, Print_Newline,\n-                    To_UL (DoAC (\"             accept at: !AC\")),\n-                    To_UL (Entry_Name_Image'Address));\n-               end;\n-            end loop;\n-         end if;\n-      end Print_Accepts;\n-   begin\n-      if not Full_Display then\n-         return;\n-      end if;\n-\n-      Trace_Output (\"Show_Rendezvous Task Value: \");\n-      Trace_Output (Unsigned_Longword'Image (To_UL (Task_Value)));\n-\n-      if Task_Value.Common.State = Acceptor_Sleep and then\n-         not Task_Value.Terminate_Alternative\n-      then\n-         if Task_Value.Open_Accepts /= null then\n-            Temp_Entry := Entry_Index (Task_Value.Open_Accepts\n-              (Task_Value.Open_Accepts'First).S);\n-            declare\n-               Entry_Name_Image : ASCIC :=\n-                 (Task_Value.Entry_Names (Temp_Entry).all'Length,\n-                  Task_Value.Entry_Names (Temp_Entry).all);\n-            begin\n-               Trace_Output (AWR & \"accept \" & Entry_Name_Image.Text);\n-               Print_Routine (Print_FAO, Print_Newline,\n-                 To_UL (DoAC (AWR & \"accept !AC\")),\n-                 To_UL (Entry_Name_Image'Address));\n-            end;\n-\n-         else\n-            Print_Routine (Print_FAO, Print_Newline,\n-              To_UL (DoAC (\"        entry name unavailable\")));\n-         end if;\n-      else\n-         case Task_Value.Common.State is\n-            when Acceptor_Sleep =>\n-               Print_Routine (Print_FAO, Print_Newline,\n-                 To_UL (DoAC (AWR & \"select with terminate.\")));\n-               Print_Accepts;\n-\n-            when Async_Select_Sleep =>\n-               Print_Routine (Print_FAO, Print_Newline,\n-                 To_UL (DoAC (AWR & \"select.\")));\n-               Print_Accepts;\n-\n-            when Acceptor_Delay_Sleep =>\n-               Print_Routine (Print_FAO, Print_Newline,\n-                 To_UL (DoAC (AWR & \"select with delay.\")));\n-               Print_Accepts;\n-\n-            when Entry_Caller_Sleep =>\n-               Entry_Call :=\n-                 Task_Value.Entry_Calls (Task_Value.ATC_Nesting_Level);\n-\n-               case Entry_Call.Mode is\n-                  when Simple_Call =>\n-                     Print_Routine (Print_FAO, Print_Newline,\n-                       To_UL (DoAC (AWR & \"entry call\")));\n-                  when Conditional_Call =>\n-                     Print_Routine (Print_FAO, Print_Newline,\n-                       To_UL (DoAC (AWR & \"entry call with else\")));\n-                  when Timed_Call =>\n-                     Print_Routine (Print_FAO, Print_Newline,\n-                       To_UL (DoAC (AWR & \"entry call with delay\")));\n-                  when Asynchronous_Call =>\n-                     Print_Routine (Print_FAO, Print_Newline,\n-                        To_UL (DoAC (AWR & \"entry call with abort\")));\n-               end case;\n-               Called_Task := Entry_Call.Called_Task;\n-               declare\n-                  Task_Image : ASCIC := (Called_Task.Common.Task_Image_Len,\n-                    Called_Task.Common.Task_Image\n-                     (1 .. Called_Task.Common.Task_Image_Len));\n-                  Entry_Name_Image : ASCIC :=\n-                    (Called_Task.Entry_Names (Entry_Call.E).all'Length,\n-                     Called_Task.Entry_Names (Entry_Call.E).all);\n-               begin\n-                  Print_Routine (Print_FAO, Print_Newline,\n-                    To_UL (DoAC\n-                     (\"        for entry !AC in %TASK !UI type !AC\")),\n-                    To_UL (Entry_Name_Image'Address),\n-                    To_UL (Called_Task.Known_Tasks_Index),\n-                    To_UL (Task_Image'Address));\n-               end;\n-\n-            when others =>\n-               return;\n-         end case;\n-      end if;\n-\n-   end Show_Rendezvous;\n-\n-   ------------------------\n-   -- Signal_Debug_Event --\n-   ------------------------\n-\n-   procedure Signal_Debug_Event\n-    (Event_Kind : Event_Kind_Type; Task_Value : Task_Id)\n-   is\n-      Do_Signal : Boolean;\n-      EVCB      : Ada_Event_Control_Block_Access;\n-\n-      EVCB_Sent    : constant := 16#9B#;\n-      Ada_Facility : constant := 49;\n-      SS_DBGEVENT  : constant := 1729;\n-   begin\n-      Do_Signal := Global_Task_Debug_Events (Event_Kind);\n-\n-      if not Do_Signal then\n-         if Task_Value /= null then\n-            Do_Signal := Do_Signal\n-              or else Task_Value.Common.Debug_Events (Event_Kind);\n-         end if;\n-      end if;\n-\n-      if Do_Signal then\n-         --  Build an a tasking event control block and signal DEBUG\n-\n-         EVCB := new Ada_Event_Control_Block_Type;\n-         EVCB.Code := Unsigned_Word (Event_Kind);\n-         EVCB.Sentinal := EVCB_Sent;\n-         EVCB.Facility := Ada_Facility;\n-\n-         if Task_Value /= null then\n-            EVCB.Value := Unsigned_Longword (Task_Value.Known_Tasks_Index + 1);\n-         else\n-            EVCB.Value := 0;\n-         end if;\n-\n-         EVCB.Sub_Event := 0;\n-         EVCB.P1 := 0;\n-         EVCB.Sigargs := 0;\n-         EVCB.Flags := 0;\n-         EVCB.Unused1 := 0;\n-         EVCB.Unused2 := 0;\n-\n-         Signal (SS_DBGEVENT, 1, To_UL (EVCB));\n-      end if;\n-   end Signal_Debug_Event;\n-\n-   --------------------\n-   -- Stop_All_Tasks --\n-   --------------------\n-\n-   procedure Stop_All_Tasks is\n-   begin\n-      null; --  VxWorks\n-   end Stop_All_Tasks;\n-\n-   ----------------------------\n-   -- Stop_All_Tasks_Handler --\n-   ----------------------------\n-\n-   procedure Stop_All_Tasks_Handler is\n-   begin\n-      null; --  VxWorks\n-   end Stop_All_Tasks_Handler;\n-\n-   -----------------------\n-   -- Suspend_All_Tasks --\n-   -----------------------\n-\n-   procedure Suspend_All_Tasks (Thread_Self : OS_Interface.Thread_Id) is\n-      pragma Unreferenced (Thread_Self);\n-   begin\n-      null; --  VxWorks\n-   end Suspend_All_Tasks;\n-\n-   ------------------------\n-   -- Task_Creation_Hook --\n-   ------------------------\n-\n-   procedure Task_Creation_Hook (Thread : OS_Interface.Thread_Id) is\n-      pragma Unreferenced (Thread);\n-   begin\n-      null; --  VxWorks\n-   end Task_Creation_Hook;\n-\n-   ---------------------------\n-   -- Task_Termination_Hook --\n-   ---------------------------\n-\n-   procedure Task_Termination_Hook is\n-   begin\n-      null; --  VxWorks\n-   end Task_Termination_Hook;\n-\n-   -----------\n-   -- Trace --\n-   -----------\n-\n-   procedure Trace\n-     (Self_Id  : Task_Id;\n-      Msg      : String;\n-      Flag     : Character;\n-      Other_Id : Task_Id := null)\n-   is\n-   begin\n-      if Trace_On (Flag) then\n-         Put (To_Integer (Self_Id)'Img &\n-              ':' & Flag & ':' &\n-              Self_Id.Common.Task_Image (1 .. Self_Id.Common.Task_Image_Len) &\n-              ':');\n-\n-         if Other_Id /= null then\n-            Put (To_Integer (Other_Id)'Img & ':');\n-         end if;\n-\n-         Put_Line (Msg);\n-      end if;\n-   end Trace;\n-\n-   ------------------\n-   -- Trace_Output --\n-   ------------------\n-\n-   procedure Trace_Output (Message_String : String) is\n-   begin\n-      if Trace_On ('V') and Trace_On ('M') and Trace_On ('S') then\n-         Put_Output (Message_String);\n-      end if;\n-   end Trace_Output;\n-\n-   -----------\n-   -- Write --\n-   -----------\n-\n-   procedure Write (Fd : Integer; S : String; Count : Integer) is\n-      Discard : System.CRTL.ssize_t;\n-      --  Ignore write errors here; this is just debugging output, and there's\n-      --  nothing to be done about errors anyway.\n-   begin\n-      Discard :=\n-        System.CRTL.write\n-          (Fd, S (S'First)'Address, System.CRTL.size_t (Count));\n-   end Write;\n-\n-end System.Tasking.Debug;"}, {"sha": "891dee28c9d6f03706fd1ec6e1b4a24a88783d97", "filename": "gcc/ada/s-taspri-vms.ads", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-taspri-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-taspri-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taspri-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,125 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a OpenVMS/Alpha version of this package\n-\n---  This package provides low-level support for most tasking features\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during tasking\n---  operations. It causes infinite loops and other problems.\n-\n-with Interfaces.C;\n-\n-with System.OS_Interface;\n-with System.Aux_DEC;\n-\n-package System.Task_Primitives is\n-   pragma Preelaborate;\n-\n-   type Lock is limited private;\n-   --  Should be used for implementation of protected objects\n-\n-   type RTS_Lock is limited private;\n-   --  Should be used inside the runtime system. The difference between Lock\n-   --  and the RTS_Lock is that the later one serves only as a semaphore so\n-   --  that do not check for ceiling violations.\n-\n-   type Suspension_Object is limited private;\n-   --  Should be used for the implementation of Ada.Synchronous_Task_Control\n-\n-   type Task_Body_Access is access procedure;\n-   --  Pointer to the task body's entry point (or possibly a wrapper\n-   --  declared local to the GNARL).\n-\n-   type Private_Data is limited private;\n-   --  Any information that the GNULLI needs maintained on a per-task basis.\n-   --  A component of this type is guaranteed to be included in the\n-   --  Ada_Task_Control_Block.\n-\n-   subtype Task_Address is System.Aux_DEC.Short_Address;\n-   --  Task_Address is the short version of address defined in System.Aux_DEC.\n-   --  To avoid dragging Aux_DEC into tasking packages a tasking specific\n-   --  subtype is defined here.\n-\n-   Task_Address_Size : constant := System.Aux_DEC.Short_Address_Size;\n-   --  The size of Task_Address\n-\n-   Alternate_Stack_Size : constant := 0;\n-   --  No alternate signal stack is used on this platform\n-\n-private\n-\n-   type Lock is record\n-      L         : aliased System.OS_Interface.pthread_mutex_t;\n-      Prio      : Interfaces.C.int;\n-      Prio_Save : Interfaces.C.int;\n-   end record;\n-\n-   type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n-\n-   type Suspension_Object is record\n-      State   : Boolean;\n-      pragma Atomic (State);\n-      --  Boolean that indicates whether the object is open. This field is\n-      --  marked Atomic to ensure that we can read its value without locking\n-      --  the access to the Suspension_Object.\n-\n-      Waiting : Boolean;\n-      --  Flag showing if there is a task already suspended on this object\n-\n-      L : aliased System.OS_Interface.pthread_mutex_t;\n-      --  Protection for ensuring mutual exclusion on the Suspension_Object\n-\n-      CV : aliased System.OS_Interface.pthread_cond_t;\n-      --  Condition variable used to queue threads until ondition is signaled\n-   end record;\n-\n-   type Private_Data is record\n-      Thread : aliased System.OS_Interface.pthread_t;\n-      pragma Atomic (Thread);\n-      --  Thread field may be updated by two different threads of control.\n-      --  (See, Enter_Task and Create_Task in s-taprop.adb). They put the\n-      --  same value (thr_self value). We do not want to use lock on those\n-      --  operations and the only thing we have to make sure is that they\n-      --  are updated in atomic fashion.\n-\n-      CV : aliased System.OS_Interface.pthread_cond_t;\n-\n-      L : aliased RTS_Lock;\n-      --  Protection for all components is lock L\n-\n-      AST_Pending : Boolean;\n-      --  Used to detect delay and sleep timeouts\n-\n-   end record;\n-\n-end System.Task_Primitives;"}, {"sha": "4f7cdad6123fae4c8b6dd6c070cc86e40bf32273", "filename": "gcc/ada/s-tpopde-vms.adb", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tpopde-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tpopde-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopde-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,161 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                  SYSTEM.TASK_PRIMITIVES.OPERATIONS.DEC                   --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 2000-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---   This package is for OpenVMS/Alpha\n-\n-with System.OS_Interface;\n-with System.Parameters;\n-with System.Tasking;\n-with Ada.Unchecked_Conversion;\n-with System.Soft_Links;\n-\n-package body System.Task_Primitives.Operations.DEC is\n-\n-   use System.OS_Interface;\n-   use System.Parameters;\n-   use System.Tasking;\n-   use System.Aux_DEC;\n-   use type Interfaces.C.int;\n-\n-   package SSL renames System.Soft_Links;\n-\n-   --  The FAB_RAB_Type specifies where the context field (the calling\n-   --  task) is stored.  Other fields defined for FAB_RAB arent' need and\n-   --  so are ignored.\n-\n-   type FAB_RAB_Type is record\n-      CTX : Unsigned_Longword;\n-   end record;\n-\n-   for FAB_RAB_Type use record\n-      CTX at 24 range 0 .. 31;\n-   end record;\n-\n-   for FAB_RAB_Type'Size use 224;\n-\n-   type FAB_RAB_Access_Type is access all FAB_RAB_Type;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function To_Unsigned_Longword is new\n-     Ada.Unchecked_Conversion (Task_Id, Unsigned_Longword);\n-\n-   function To_Task_Id is new\n-     Ada.Unchecked_Conversion (Unsigned_Longword, Task_Id);\n-\n-   function To_FAB_RAB is new\n-     Ada.Unchecked_Conversion (Address, FAB_RAB_Access_Type);\n-\n-   ---------------------------\n-   -- Interrupt_AST_Handler --\n-   ---------------------------\n-\n-   procedure Interrupt_AST_Handler (ID : Address) is\n-      Result      : Interfaces.C.int;\n-      AST_Self_ID : constant Task_Id := To_Task_Id (ID);\n-   begin\n-      Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Interrupt_AST_Handler;\n-\n-   ---------------------\n-   -- RMS_AST_Handler --\n-   ---------------------\n-\n-   procedure RMS_AST_Handler (ID : Address) is\n-      AST_Self_ID : constant Task_Id := To_Task_Id (To_FAB_RAB (ID).CTX);\n-      Result      : Interfaces.C.int;\n-\n-   begin\n-      AST_Self_ID.Common.LL.AST_Pending := False;\n-      Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end RMS_AST_Handler;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   function Self return Unsigned_Longword is\n-      Self_ID : constant Task_Id := Self;\n-   begin\n-      Self_ID.Common.LL.AST_Pending := True;\n-      return To_Unsigned_Longword (Self);\n-   end Self;\n-\n-   -------------------------\n-   -- Starlet_AST_Handler --\n-   -------------------------\n-\n-   procedure Starlet_AST_Handler (ID : Address) is\n-      Result      : Interfaces.C.int;\n-      AST_Self_ID : constant Task_Id := To_Task_Id (ID);\n-   begin\n-      AST_Self_ID.Common.LL.AST_Pending := False;\n-      Result := pthread_cond_signal_int_np (AST_Self_ID.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Starlet_AST_Handler;\n-\n-   ----------------\n-   -- Task_Synch --\n-   ----------------\n-\n-   procedure Task_Synch is\n-      Synch_Self_ID : constant Task_Id := Self;\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      else\n-         Write_Lock (Synch_Self_ID);\n-      end if;\n-\n-      SSL.Abort_Defer.all;\n-      Synch_Self_ID.Common.State := AST_Server_Sleep;\n-\n-      while Synch_Self_ID.Common.LL.AST_Pending loop\n-         Sleep (Synch_Self_ID, AST_Server_Sleep);\n-      end loop;\n-\n-      Synch_Self_ID.Common.State := Runnable;\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      else\n-         Unlock (Synch_Self_ID);\n-      end if;\n-\n-      SSL.Abort_Undefer.all;\n-   end Task_Synch;\n-\n-end System.Task_Primitives.Operations.DEC;"}, {"sha": "e690f306e7a67161aa0bf0ada22c90ebf8311cbb", "filename": "gcc/ada/s-tpopde-vms.ads", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tpopde-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tpopde-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopde-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,53 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                  SYSTEM.TASK_PRIMITIVES.OPERATIONS.DEC                   --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 2000-2011, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This package is for OpenVMS/Alpha.\n---\n-with System.Aux_DEC;\n-package System.Task_Primitives.Operations.DEC is\n-\n-   procedure Interrupt_AST_Handler (ID : Address);\n-   pragma Convention (C, Interrupt_AST_Handler);\n-   --  Handles the AST for Ada 95 Interrupts\n-\n-   procedure RMS_AST_Handler (ID : Address);\n-   --  Handles the AST for RMS_Asynch_Operations\n-\n-   function Self return System.Aux_DEC.Unsigned_Longword;\n-   --  Returns the task identification for the AST\n-\n-   procedure Starlet_AST_Handler (ID : Address);\n-   --  Handles the AST for Starlet Tasking_Services\n-\n-   procedure Task_Synch;\n-   --  Synchronizes the task after the system service completes\n-\n-end System.Task_Primitives.Operations.DEC;"}, {"sha": "42503f6cd99a3b77529f450ef0bc41cee26b6c83", "filename": "gcc/ada/s-tpopsp-vms.adb", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tpopsp-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-tpopsp-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,103 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                SYSTEM.TASK_PRIMITIVES.OPERATIONS.SPECIFIC                --\n---                                                                          --\n---                                B o d y                                   --\n---                                                                          --\n---         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a VMS version of this package where foreign threads are\n---  recognized.\n-\n-separate (System.Task_Primitives.Operations)\n-package body Specific is\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-      pragma Warnings (Off, Environment_Task);\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_key_create (ATCB_Key'Access, null);\n-      pragma Assert (Result = 0);\n-   end Initialize;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean is\n-   begin\n-      return pthread_getspecific (ATCB_Key) /= System.Null_Address;\n-   end Is_Valid_Task;\n-\n-   ---------\n-   -- Set --\n-   ---------\n-\n-   procedure Set (Self_Id : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));\n-      pragma Assert (Result = 0);\n-   end Set;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   --  To make Ada tasks and C threads interoperate better, we have added some\n-   --  functionality to Self. Suppose a C main program (with threads) calls an\n-   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n-   --  Eventually, a call will be made to self. Since the call is not coming\n-   --  from an Ada task, there will be no corresponding ATCB.\n-\n-   --  What we do in Self is to catch references that do not come from\n-   --  recognized Ada tasks, and create an ATCB for the calling thread.\n-\n-   --  The new ATCB will be \"detached\" from the normal Ada task master\n-   --  hierarchy, much like the existing implicitly created signal-server\n-   --  tasks.\n-\n-   function Self return Task_Id is\n-      Result : System.Address;\n-\n-   begin\n-      Result := pthread_getspecific (ATCB_Key);\n-\n-      --  If the key value is Null then it is a non-Ada task\n-\n-      if Result /= System.Null_Address then\n-         return To_Task_Id (Result);\n-      else\n-         return Register_Foreign_Thread;\n-      end if;\n-   end Self;\n-\n-end Specific;"}, {"sha": "51f0e682a786f1d3b529ef02d977f2d33a11bfc6", "filename": "gcc/ada/s-traent-vms.adb", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-traent-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-traent-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traent-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,65 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---              S Y S T E M . T R A C E B A C K _ E N T R I E S             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-pragma Polling (Off);\n---  We must turn polling off for this unit, because otherwise we get\n---  elaboration circularities with Ada.Exceptions.\n-\n-package body System.Traceback_Entries is\n-\n-   ------------\n-   -- PC_For --\n-   ------------\n-\n-   function PC_For (TB_Entry : Traceback_Entry) return System.Address is\n-   begin\n-      return TB_Entry.PC;\n-   end PC_For;\n-\n-   ------------\n-   -- PV_For --\n-   ------------\n-\n-   function PV_For (TB_Entry : Traceback_Entry) return System.Address is\n-   begin\n-      return TB_Entry.PV;\n-   end PV_For;\n-\n-   ------------------\n-   -- TB_Entry_For --\n-   ------------------\n-\n-   function TB_Entry_For (PC : System.Address) return Traceback_Entry is\n-   begin\n-      return (PC => PC, PV => System.Null_Address);\n-   end TB_Entry_For;\n-\n-end System.Traceback_Entries;"}, {"sha": "db327df4618e9a35369c7c68d039b4ef05a2ab6f", "filename": "gcc/ada/s-traent-vms.ads", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-traent-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-traent-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-traent-vms.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,66 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---              S Y S T E M . T R A C E B A C K _ E N T R I E S             --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2003-2014, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the Alpha/OpenVMS version of this package\n-\n-pragma Polling (Off);\n---  We must turn polling off for this unit, because otherwise we get\n---  elaboration circularities with Ada.Exceptions.\n-\n-package System.Traceback_Entries is\n-   pragma Preelaborate;\n-\n-   --  Symbolization is performed by a VMS service which requires more\n-   --  than an instruction pointer.\n-\n-   type Traceback_Entry is record\n-      PC : System.Address;  --  Program Counter\n-      PV : System.Address;  --  Procedure Value\n-   end record;\n-\n-   pragma Suppress_Initialization (Traceback_Entry);\n-\n-   Null_TB_Entry : constant Traceback_Entry :=\n-                     (PC => System.Null_Address,\n-                      PV => System.Null_Address);\n-\n-   type Tracebacks_Array is array (Positive range <>) of Traceback_Entry;\n-\n-   function PC_For (TB_Entry : Traceback_Entry) return System.Address;\n-   function PV_For (TB_Entry : Traceback_Entry) return System.Address;\n-\n-   function TB_Entry_For (PC : System.Address) return Traceback_Entry;\n-\n-end System.Traceback_Entries;"}, {"sha": "51571720b67d863c6588c80a5e64a802b4269792", "filename": "gcc/ada/s-vaflop-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 695, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-vaflop-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fs-vaflop-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vaflop-vms-alpha.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,695 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---           S Y S T E M . V A X _ F L O A T _ O P E R A T I O N S          --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1997-2012, Free Software Foundation, Inc.         --\n---                       (Version for Alpha OpenVMS)                        --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with System.IO;\n-with System.Machine_Code; use System.Machine_Code;\n-\n-package body System.Vax_Float_Operations is\n-\n-   --  Declare the functions that do the conversions between floating-point\n-   --  formats.  Call the operands IEEE float so they get passed in\n-   --  FP registers.\n-\n-   function Cvt_G_T (X : T) return T;\n-   function Cvt_T_G (X : T) return T;\n-   function Cvt_T_F (X : T) return S;\n-\n-   pragma Import (C, Cvt_G_T, \"OTS$CVT_FLOAT_G_T\");\n-   pragma Import (C, Cvt_T_G, \"OTS$CVT_FLOAT_T_G\");\n-   pragma Import (C, Cvt_T_F, \"OTS$CVT_FLOAT_T_F\");\n-\n-   --  In each of the conversion routines that are done with OTS calls,\n-   --  we define variables of the corresponding IEEE type so that they are\n-   --  passed and kept in the proper register class.\n-\n-   Debug_String_Buffer : String (1 .. 32);\n-   --  Buffer used by all Debug_String_x routines for returning result\n-\n-   ------------\n-   -- D_To_G --\n-   ------------\n-\n-   function D_To_G (X : D) return G is\n-      A, B : T;\n-      C    : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), D'Asm_Input (\"m\", X));\n-      Asm (\"cvtdg %1,%0\", T'Asm_Output (\"=f\", B), T'Asm_Input (\"f\", A));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", C), T'Asm_Input (\"f\", B));\n-      return C;\n-   end D_To_G;\n-\n-   ------------\n-   -- F_To_G --\n-   ------------\n-\n-   function F_To_G (X : F) return G is\n-      A : T;\n-      B : G;\n-   begin\n-      Asm (\"ldf %0,%1\", T'Asm_Output (\"=f\", A), F'Asm_Input (\"m\", X));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", B), T'Asm_Input (\"f\", A));\n-      return B;\n-   end F_To_G;\n-\n-   ------------\n-   -- F_To_S --\n-   ------------\n-\n-   function F_To_S (X : F) return S is\n-      A : T;\n-      B : S;\n-\n-   begin\n-      --  Because converting to a wider FP format is a no-op, we say\n-      --  A is 64-bit even though we are loading 32 bits into it.\n-\n-      Asm (\"ldf %0,%1\", T'Asm_Output (\"=f\", A), F'Asm_Input (\"m\", X));\n-\n-      B := S (Cvt_G_T (A));\n-      return B;\n-   end F_To_S;\n-\n-   ------------\n-   -- G_To_D --\n-   ------------\n-\n-   function G_To_D (X : G) return D is\n-      A, B : T;\n-      C    : D;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), G'Asm_Input (\"m\", X));\n-      Asm (\"cvtgd %1,%0\", T'Asm_Output (\"=f\", B), T'Asm_Input (\"f\", A));\n-      Asm (\"stg %1,%0\", D'Asm_Output (\"=m\", C), T'Asm_Input (\"f\", B));\n-      return C;\n-   end G_To_D;\n-\n-   ------------\n-   -- G_To_F --\n-   ------------\n-\n-   function G_To_F (X : G) return F is\n-      A : T;\n-      B : S;\n-      C : F;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), G'Asm_Input (\"m\", X));\n-      Asm (\"cvtgf %1,%0\", S'Asm_Output (\"=f\", B), T'Asm_Input (\"f\", A));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", C), S'Asm_Input (\"f\", B));\n-      return C;\n-   end G_To_F;\n-\n-   ------------\n-   -- G_To_Q --\n-   ------------\n-\n-   function G_To_Q (X : G) return Q is\n-      A : T;\n-      B : Q;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), G'Asm_Input (\"m\", X));\n-      Asm (\"cvtgq %1,%0\", Q'Asm_Output (\"=f\", B), T'Asm_Input (\"f\", A));\n-      return B;\n-   end G_To_Q;\n-\n-   ------------\n-   -- G_To_T --\n-   ------------\n-\n-   function G_To_T (X : G) return T is\n-      A, B : T;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), G'Asm_Input (\"m\", X));\n-      B := Cvt_G_T (A);\n-      return B;\n-   end G_To_T;\n-\n-   ------------\n-   -- F_To_Q --\n-   ------------\n-\n-   function F_To_Q (X : F) return Q is\n-   begin\n-      return G_To_Q (F_To_G (X));\n-   end F_To_Q;\n-\n-   ------------\n-   -- Q_To_F --\n-   ------------\n-\n-   function Q_To_F (X : Q) return F is\n-      A : S;\n-      B : F;\n-   begin\n-      Asm (\"cvtqf %1,%0\", S'Asm_Output (\"=f\", A), Q'Asm_Input (\"f\", X));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", B), S'Asm_Input (\"f\", A));\n-      return B;\n-   end Q_To_F;\n-\n-   ------------\n-   -- Q_To_G --\n-   ------------\n-\n-   function Q_To_G (X : Q) return G is\n-      A : T;\n-      B : G;\n-   begin\n-      Asm (\"cvtqg %1,%0\", T'Asm_Output (\"=f\", A), Q'Asm_Input (\"f\", X));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", B), T'Asm_Input (\"f\", A));\n-      return B;\n-   end Q_To_G;\n-\n-   ------------\n-   -- S_To_F --\n-   ------------\n-\n-   function S_To_F (X : S) return F is\n-      A : S;\n-      B : F;\n-   begin\n-      A := Cvt_T_F (T (X));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", B), S'Asm_Input (\"f\", A));\n-      return B;\n-   end S_To_F;\n-\n-   ------------\n-   -- T_To_G --\n-   ------------\n-\n-   function T_To_G (X : T) return G is\n-      A : T;\n-      B : G;\n-   begin\n-      A := Cvt_T_G (X);\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", B), T'Asm_Input (\"f\", A));\n-      return B;\n-   end T_To_G;\n-\n-   ------------\n-   -- T_To_D --\n-   ------------\n-\n-   function T_To_D (X : T) return D is\n-   begin\n-      return G_To_D (T_To_G (X));\n-   end T_To_D;\n-\n-   -----------\n-   -- Abs_F --\n-   -----------\n-\n-   function Abs_F (X : F) return F is\n-      A, B : S;\n-      C    : F;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", A), F'Asm_Input (\"m\", X));\n-      Asm (\"cpys $f31,%1,%0\", S'Asm_Output (\"=f\", B), S'Asm_Input (\"f\", A));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", C), S'Asm_Input (\"f\", B));\n-      return C;\n-   end Abs_F;\n-\n-   -----------\n-   -- Abs_G --\n-   -----------\n-\n-   function Abs_G (X : G) return G is\n-      A, B : T;\n-      C    : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), G'Asm_Input (\"m\", X));\n-      Asm (\"cpys $f31,%1,%0\", T'Asm_Output (\"=f\", B), T'Asm_Input (\"f\", A));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", C), T'Asm_Input (\"f\", B));\n-      return C;\n-   end Abs_G;\n-\n-   -----------\n-   -- Add_F --\n-   -----------\n-\n-   function Add_F (X, Y : F) return F is\n-      X1, Y1, R : S;\n-      R1        : F;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"addf %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", R1), S'Asm_Input (\"f\", R));\n-      return R1;\n-   end Add_F;\n-\n-   -----------\n-   -- Add_G --\n-   -----------\n-\n-   function Add_G (X, Y : G) return G is\n-      X1, Y1, R : T;\n-      R1        : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"addg %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", R1), T'Asm_Input (\"f\", R));\n-      return R1;\n-   end Add_G;\n-\n-   --------------------\n-   -- Debug_Output_D --\n-   --------------------\n-\n-   procedure Debug_Output_D (Arg : D) is\n-   begin\n-      System.IO.Put (D'Image (Arg));\n-   end Debug_Output_D;\n-\n-   --------------------\n-   -- Debug_Output_F --\n-   --------------------\n-\n-   procedure Debug_Output_F (Arg : F) is\n-   begin\n-      System.IO.Put (F'Image (Arg));\n-   end Debug_Output_F;\n-\n-   --------------------\n-   -- Debug_Output_G --\n-   --------------------\n-\n-   procedure Debug_Output_G (Arg : G) is\n-   begin\n-      System.IO.Put (G'Image (Arg));\n-   end Debug_Output_G;\n-\n-   --------------------\n-   -- Debug_String_D --\n-   --------------------\n-\n-   function Debug_String_D (Arg : D) return System.Address is\n-      Image_String : constant String  := D'Image (Arg) & ASCII.NUL;\n-      Image_Size   : constant Integer := Image_String'Length;\n-   begin\n-      Debug_String_Buffer (1 .. Image_Size) := Image_String;\n-      return Debug_String_Buffer (1)'Address;\n-   end Debug_String_D;\n-\n-   --------------------\n-   -- Debug_String_F --\n-   --------------------\n-\n-   function Debug_String_F (Arg : F) return System.Address is\n-      Image_String : constant String  := F'Image (Arg) & ASCII.NUL;\n-      Image_Size   : constant Integer := Image_String'Length;\n-   begin\n-      Debug_String_Buffer (1 .. Image_Size) := Image_String;\n-      return Debug_String_Buffer (1)'Address;\n-   end Debug_String_F;\n-\n-   --------------------\n-   -- Debug_String_G --\n-   --------------------\n-\n-   function Debug_String_G (Arg : G) return System.Address is\n-      Image_String : constant String  := G'Image (Arg) & ASCII.NUL;\n-      Image_Size   : constant Integer := Image_String'Length;\n-   begin\n-      Debug_String_Buffer (1 .. Image_Size) := Image_String;\n-      return Debug_String_Buffer (1)'Address;\n-   end Debug_String_G;\n-\n-   -----------\n-   -- Div_F --\n-   -----------\n-\n-   function Div_F (X, Y : F) return F is\n-      X1, Y1, R : S;\n-      R1        : F;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"divf %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", R1), S'Asm_Input (\"f\", R));\n-      return R1;\n-   end Div_F;\n-\n-   -----------\n-   -- Div_G --\n-   -----------\n-\n-   function Div_G (X, Y : G) return G is\n-      X1, Y1, R : T;\n-      R1        : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"divg %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", R1), T'Asm_Input (\"f\", R));\n-      return R1;\n-   end Div_G;\n-\n-   ----------\n-   -- Eq_F --\n-   ----------\n-\n-   function Eq_F (X, Y : F) return Boolean is\n-      X1, Y1, R : S;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"cmpgeq %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      return R /= 0.0;\n-   end Eq_F;\n-\n-   ----------\n-   -- Eq_G --\n-   ----------\n-\n-   function Eq_G (X, Y : G) return Boolean is\n-      X1, Y1, R : T;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"cmpgeq %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      return R /= 0.0;\n-   end Eq_G;\n-\n-   ----------\n-   -- Le_F --\n-   ----------\n-\n-   function Le_F (X, Y : F) return Boolean is\n-      X1, Y1, R : S;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"cmpgle %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      return R /= 0.0;\n-   end Le_F;\n-\n-   ----------\n-   -- Le_G --\n-   ----------\n-\n-   function Le_G (X, Y : G) return Boolean is\n-      X1, Y1, R : T;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"cmpgle %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      return R /= 0.0;\n-   end Le_G;\n-\n-   ----------\n-   -- Lt_F --\n-   ----------\n-\n-   function Lt_F (X, Y : F) return Boolean is\n-      X1, Y1, R : S;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"cmpglt %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      return R /= 0.0;\n-   end Lt_F;\n-\n-   ----------\n-   -- Lt_G --\n-   ----------\n-\n-   function Lt_G (X, Y : G) return Boolean is\n-      X1, Y1, R : T;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"cmpglt %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      return R /= 0.0;\n-   end Lt_G;\n-\n-   -----------\n-   -- Mul_F --\n-   -----------\n-\n-   function Mul_F (X, Y : F) return F is\n-      X1, Y1, R : S;\n-      R1        : F;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"mulf %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", R1), S'Asm_Input (\"f\", R));\n-      return R1;\n-   end Mul_F;\n-\n-   -----------\n-   -- Mul_G --\n-   -----------\n-\n-   function Mul_G (X, Y : G) return G is\n-      X1, Y1, R : T;\n-      R1        : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"mulg %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", R1), T'Asm_Input (\"f\", R));\n-      return R1;\n-   end Mul_G;\n-\n-   ----------\n-   -- Ne_F --\n-   ----------\n-\n-   function Ne_F (X, Y : F) return Boolean is\n-      X1, Y1, R : S;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"cmpgeq %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      return R = 0.0;\n-   end Ne_F;\n-\n-   ----------\n-   -- Ne_G --\n-   ----------\n-\n-   function Ne_G (X, Y : G) return Boolean is\n-      X1, Y1, R : T;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"cmpgeq %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      return R = 0.0;\n-   end Ne_G;\n-\n-   -----------\n-   -- Neg_F --\n-   -----------\n-\n-   function Neg_F (X : F) return F is\n-      A, B : S;\n-      C    : F;\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", A), F'Asm_Input (\"m\", X));\n-      Asm (\"subf $f31,%1,%0\", S'Asm_Output (\"=f\", B), S'Asm_Input (\"f\", A));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", C), S'Asm_Input (\"f\", B));\n-      return C;\n-   end Neg_F;\n-\n-   -----------\n-   -- Neg_G --\n-   -----------\n-\n-   function Neg_G (X : G) return G is\n-      A, B : T;\n-      C    : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", A), G'Asm_Input (\"m\", X));\n-      Asm (\"subg $f31,%1,%0\", T'Asm_Output (\"=f\", B), T'Asm_Input (\"f\", A));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", C), T'Asm_Input (\"f\", B));\n-      return C;\n-   end Neg_G;\n-\n-   --------\n-   -- pd --\n-   --------\n-\n-   procedure pd (Arg : D) is\n-   begin\n-      System.IO.Put_Line (D'Image (Arg));\n-   end pd;\n-\n-   --------\n-   -- pf --\n-   --------\n-\n-   procedure pf (Arg : F) is\n-   begin\n-      System.IO.Put_Line (F'Image (Arg));\n-   end pf;\n-\n-   --------\n-   -- pg --\n-   --------\n-\n-   procedure pg (Arg : G) is\n-   begin\n-      System.IO.Put_Line (G'Image (Arg));\n-   end pg;\n-\n-   --------------\n-   -- Return_D --\n-   --------------\n-\n-   function Return_D (X : D) return D is\n-      R : D;\n-   begin\n-      --  The return value is already in $f0 so we need to trick the compiler\n-      --  into thinking that we're moving X to $f0.\n-      Asm (\"cvtdg $f0,$f0\", Inputs => D'Asm_Input (\"g\", X), Clobber => \"$f0\",\n-        Volatile => True);\n-      Asm (\"stg $f0,%0\", D'Asm_Output (\"=m\", R), Volatile => True);\n-      return R;\n-   end Return_D;\n-\n-   --------------\n-   -- Return_F --\n-   --------------\n-\n-   function Return_F (X : F) return F is\n-      R : F;\n-   begin\n-      --  The return value is already in $f0 so we need to trick the compiler\n-      --  into thinking that we're moving X to $f0.\n-      Asm (\"stf $f0,%0\", F'Asm_Output (\"=m\", R), F'Asm_Input (\"g\", X),\n-        Clobber => \"$f0\", Volatile => True);\n-      return R;\n-   end Return_F;\n-\n-   --------------\n-   -- Return_G --\n-   --------------\n-\n-   function Return_G (X : G) return G is\n-      R : G;\n-   begin\n-      --  The return value is already in $f0 so we need to trick the compiler\n-      --  into thinking that we're moving X to $f0.\n-      Asm (\"stg $f0,%0\", G'Asm_Output (\"=m\", R), G'Asm_Input (\"g\", X),\n-        Clobber => \"$f0\", Volatile => True);\n-      return R;\n-   end Return_G;\n-\n-   -----------\n-   -- Sub_F --\n-   -----------\n-\n-   function Sub_F (X, Y : F) return F is\n-      X1, Y1, R : S;\n-      R1        : F;\n-\n-   begin\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", X1), F'Asm_Input (\"m\", X));\n-      Asm (\"ldf %0,%1\", S'Asm_Output (\"=f\", Y1), F'Asm_Input (\"m\", Y));\n-      Asm (\"subf %1,%2,%0\", S'Asm_Output (\"=f\", R),\n-           (S'Asm_Input (\"f\", X1), S'Asm_Input (\"f\", Y1)));\n-      Asm (\"stf %1,%0\", F'Asm_Output (\"=m\", R1), S'Asm_Input (\"f\", R));\n-      return R1;\n-   end Sub_F;\n-\n-   -----------\n-   -- Sub_G --\n-   -----------\n-\n-   function Sub_G (X, Y : G) return G is\n-      X1, Y1, R : T;\n-      R1        : G;\n-   begin\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", X1), G'Asm_Input (\"m\", X));\n-      Asm (\"ldg %0,%1\", T'Asm_Output (\"=f\", Y1), G'Asm_Input (\"m\", Y));\n-      Asm (\"subg %1,%2,%0\", T'Asm_Output (\"=f\", R),\n-           (T'Asm_Input (\"f\", X1), T'Asm_Input (\"f\", Y1)));\n-      Asm (\"stg %1,%0\", G'Asm_Output (\"=m\", R1), T'Asm_Input (\"f\", R));\n-      return R1;\n-   end Sub_G;\n-\n-   -------------\n-   -- Valid_D --\n-   -------------\n-\n-   --  For now, convert to IEEE and do Valid test on result. This is not quite\n-   --  accurate, but is good enough in practice.\n-\n-   function Valid_D (Arg : D) return Boolean is\n-      Val : constant T := G_To_T (D_To_G (Arg));\n-   begin\n-      return Val'Valid;\n-   end Valid_D;\n-\n-   -------------\n-   -- Valid_F --\n-   -------------\n-\n-   --  For now, convert to IEEE and do Valid test on result. This is not quite\n-   --  accurate, but is good enough in practice.\n-\n-   function Valid_F (Arg : F) return Boolean is\n-      Val : constant S := F_To_S (Arg);\n-   begin\n-      return Val'Valid;\n-   end Valid_F;\n-\n-   -------------\n-   -- Valid_G --\n-   -------------\n-\n-   --  For now, convert to IEEE and do Valid test on result. This is not quite\n-   --  accurate, but is good enough in practice.\n-\n-   function Valid_G (Arg : G) return Boolean is\n-      Val : constant T := G_To_T (Arg);\n-   begin\n-      return Val'Valid;\n-   end Valid_G;\n-\n-end System.Vax_Float_Operations;"}, {"sha": "f95244560fae2797e02b933723f6c28c82fc0233", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f9648959b41d5c443702c809676056f1f39c56de", "patch": "@@ -10614,15 +10614,15 @@ package body Sem_Ch13 is\n       Nam  : Name_Id) return Boolean\n    is\n       function All_Static_Case_Alternatives (L : List_Id) return Boolean;\n-      --  Given a list of case expression alternatives, returns True if\n-      --  all the alternatives are static (have all static choices, and a\n-      --  static expression).\n+      --  Given a list of case expression alternatives, returns True if all\n+      --  the alternatives are static (have all static choices, and a static\n+      --  expression).\n \n       function All_Static_Choices (L : List_Id) return Boolean;\n       --  Returns true if all elements of the list are OK static choices\n       --  as defined below for Is_Static_Choice. Used for case expression\n-      --  alternatives and for the right operand of a membership test.\n-      --  An others_choice is static if the corresponding expression is static.\n+      --  alternatives and for the right operand of a membership test. An\n+      --  others_choice is static if the corresponding expression is static.\n       --  The staticness of the bounds is checked separately.\n \n       function Is_Static_Choice (N : Node_Id) return Boolean;\n@@ -10636,10 +10636,10 @@ package body Sem_Ch13 is\n \n       function Is_Type_Ref (N : Node_Id) return Boolean;\n       pragma Inline (Is_Type_Ref);\n-      --  Returns True if N is a reference to the type for the predicate in\n-      --  the expression (i.e. if it is an identifier whose Chars field matches\n-      --  the Nam given in the call). N must not be parenthesized, if the type\n-      --  name appears in parens, this routine will return False.\n+      --  Returns True if N is a reference to the type for the predicate in the\n+      --  expression (i.e. if it is an identifier whose Chars field matches the\n+      --  Nam given in the call). N must not be parenthesized, if the type name\n+      --  appears in parens, this routine will return False.\n \n       ----------------------------------\n       -- All_Static_Case_Alternatives --"}, {"sha": "6d93a294c75cb8cc64ab1e1cd46bf2efb8cf020b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9648959b41d5c443702c809676056f1f39c56de/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f9648959b41d5c443702c809676056f1f39c56de", "patch": "@@ -4514,8 +4514,8 @@ package body Sem_Ch3 is\n \n             when Enumeration_Kind =>\n                Set_Ekind                (Id, E_Enumeration_Subtype);\n-               Set_Has_Dynamic_Predicate_Aspect (Id,\n-                                   Has_Dynamic_Predicate_Aspect (T));\n+               Set_Has_Dynamic_Predicate_Aspect\n+                                        (Id, Has_Dynamic_Predicate_Aspect (T));\n                Set_First_Literal        (Id, First_Literal (Base_Type (T)));\n                Set_Scalar_Range         (Id, Scalar_Range       (T));\n                Set_Is_Character_Type    (Id, Is_Character_Type  (T));"}, {"sha": "c33739402c3e85fbd8463c25644ed9c5321287a3", "filename": "gcc/ada/symbols-processing-vms-alpha.adb", "status": "removed", "additions": 0, "deletions": 318, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-processing-vms-alpha.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,318 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y M B O L S . P R O C E S S I N G                   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VMS Alpha version of this package\n-\n-separate (Symbols)\n-package body Processing is\n-\n-   type Number is mod 2**16;\n-   --  16 bits unsigned number for number of characters\n-\n-   EMH : constant Number := 8;\n-   --  Code for the Module Header section\n-\n-   GSD : constant Number := 10;\n-   --  Code for the Global Symbol Definition section\n-\n-   C_SYM : constant Number := 1;\n-   --  Code for a Symbol subsection\n-\n-   V_DEF_Mask  : constant Number := 2 ** 1;\n-   V_NORM_Mask : constant Number := 2 ** 6;\n-   --  Comments ???\n-\n-   B : Byte;\n-\n-   Number_Of_Characters : Natural := 0;\n-   --  The number of characters of each section\n-\n-   Native_Format : Boolean;\n-   --  True if records are decoded by the system (like on VMS)\n-\n-   Has_Pad : Boolean;\n-   --  If true, a pad byte must be skipped before reading the next record\n-\n-   --  The following variables are used by procedure Process when reading an\n-   --  object file.\n-\n-   Code   : Number := 0;\n-   Length : Natural := 0;\n-\n-   Dummy : Number;\n-\n-   Nchars : Natural := 0;\n-   Flags  : Number  := 0;\n-\n-   Symbol : String (1 .. 255);\n-   LSymb  : Natural;\n-\n-   procedure Get (N : out Number);\n-   --  Read two bytes from the object file LSB first as unsigned 16 bit number\n-\n-   procedure Get (N : out Natural);\n-   --  Read two bytes from the object file, LSByte first, as a Natural\n-\n-   ---------\n-   -- Get --\n-   ---------\n-\n-   procedure Get (N : out Number) is\n-      C : Byte;\n-      LSByte : Number;\n-   begin\n-      Read (File, C);\n-      LSByte := Byte'Pos (C);\n-      Read (File, C);\n-      N := LSByte + (256 * Byte'Pos (C));\n-   end Get;\n-\n-   procedure Get (N : out Natural) is\n-      Result : Number;\n-   begin\n-      Get (Result);\n-      N := Natural (Result);\n-   end Get;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   procedure Process\n-     (Object_File : String;\n-      Success     : out Boolean)\n-   is\n-      OK : Boolean := True;\n-\n-   begin\n-      --  Open the object file with Byte_IO. Return with Success = False if\n-      --  this fails.\n-\n-      begin\n-         Open (File, In_File, Object_File);\n-      exception\n-         when others =>\n-            Put_Line\n-              (\"*** Unable to open object file \"\"\" & Object_File & \"\"\"\");\n-            Success := False;\n-            return;\n-      end;\n-\n-      --  Assume that the object file has a correct format\n-\n-      Success := True;\n-\n-      --  Check the file format in case of cross-tool\n-\n-      Get (Code);\n-      Get (Number_Of_Characters);\n-      Get (Dummy);\n-\n-      if Code = Dummy and then Number_Of_Characters = Natural (EMH) then\n-\n-         --  Looks like a cross tool\n-\n-         Native_Format := False;\n-         Number_Of_Characters := Natural (Dummy) - 4;\n-         Has_Pad := (Number_Of_Characters mod 2) = 1;\n-\n-      elsif Code = EMH then\n-         Native_Format := True;\n-         Number_Of_Characters := Number_Of_Characters - 6;\n-         Has_Pad := False;\n-\n-      else\n-         Put_Line (\"file \"\"\" & Object_File & \"\"\" is not an object file\");\n-         Close (File);\n-         Success := False;\n-         return;\n-      end if;\n-\n-      --  Skip the EMH section\n-\n-      for J in 1 .. Number_Of_Characters loop\n-         Read (File, B);\n-      end loop;\n-\n-      --  Get the different sections one by one from the object file\n-\n-      while not End_Of_File (File) loop\n-\n-         if not Native_Format then\n-\n-            --  Skip pad byte if present\n-\n-            if Has_Pad then\n-               Get (B);\n-            end if;\n-\n-            --  Skip record length\n-\n-            Get (Dummy);\n-         end if;\n-\n-         Get (Code);\n-         Get (Number_Of_Characters);\n-\n-         if not Native_Format then\n-            if Natural (Dummy) /= Number_Of_Characters then\n-\n-               --  Format error\n-\n-               raise Constraint_Error;\n-            end if;\n-\n-            Has_Pad := (Number_Of_Characters mod 2) = 1;\n-         end if;\n-\n-         --  The header is 4 bytes length\n-\n-         Number_Of_Characters := Number_Of_Characters - 4;\n-\n-         --  If this is not a Global Symbol Definition section, skip to the\n-         --  next section.\n-\n-         if Code /= GSD then\n-            for J in 1 .. Number_Of_Characters loop\n-               Read (File, B);\n-            end loop;\n-\n-         else\n-            --  Skip over the next 4 bytes\n-\n-            Get (Dummy);\n-            Get (Dummy);\n-            Number_Of_Characters := Number_Of_Characters - 4;\n-\n-            --  Get each subsection in turn\n-\n-            loop\n-               Get (Code);\n-               Get (Nchars);\n-               Get (Dummy);\n-               Get (Flags);\n-               Number_Of_Characters := Number_Of_Characters - 8;\n-               Nchars := Nchars - 8;\n-\n-               --  If this is a symbol and the V_DEF flag is set, get symbol\n-\n-               if Code = C_SYM and then ((Flags and V_DEF_Mask) /= 0) then\n-\n-                  --  First, reach the symbol length\n-\n-                  for J in 1 .. 25 loop\n-                     Read (File, B);\n-                     Nchars := Nchars - 1;\n-                     Number_Of_Characters := Number_Of_Characters - 1;\n-                  end loop;\n-\n-                  Length := Byte'Pos (B);\n-                  LSymb := 0;\n-\n-                  --  Get the symbol characters\n-\n-                  for J in 1 .. Nchars loop\n-                     Read (File, B);\n-                     Number_Of_Characters := Number_Of_Characters - 1;\n-\n-                     if Length > 0 then\n-                        LSymb := LSymb + 1;\n-                        Symbol (LSymb) := B;\n-                        Length := Length - 1;\n-                     end if;\n-                  end loop;\n-\n-                  --  Check if it is a symbol from a generic body\n-\n-                  OK := True;\n-\n-                  for J in 1 .. LSymb - 2 loop\n-                     if Symbol (J) = 'G' and then Symbol (J + 1) = 'P'\n-                       and then Symbol (J + 2) in '0' .. '9'\n-                     then\n-                        OK := False;\n-                        exit;\n-                     end if;\n-                  end loop;\n-\n-                  if OK then\n-\n-                     --  Create the new Symbol\n-\n-                     declare\n-                        S_Data : Symbol_Data;\n-\n-                     begin\n-                        S_Data.Name := new String'(Symbol (1 .. LSymb));\n-\n-                        --  The symbol kind (Data or Procedure) depends on the\n-                        --  V_NORM flag.\n-\n-                        if (Flags and V_NORM_Mask) = 0 then\n-                           S_Data.Kind := Data;\n-                        else\n-                           S_Data.Kind := Proc;\n-                        end if;\n-\n-                        --  Put the new symbol in the table\n-\n-                        Symbol_Table.Append (Complete_Symbols, S_Data);\n-                     end;\n-                  end if;\n-\n-               else\n-                  --  As it is not a symbol subsection, skip to the next\n-                  --  subsection.\n-\n-                  for J in 1 .. Nchars loop\n-                     Read (File, B);\n-                     Number_Of_Characters := Number_Of_Characters - 1;\n-                  end loop;\n-               end if;\n-\n-               --  Exit the GSD section when number of characters reaches zero\n-\n-               exit when Number_Of_Characters = 0;\n-            end loop;\n-         end if;\n-      end loop;\n-\n-      --  The object file has been processed, close it\n-\n-      Close (File);\n-\n-   exception\n-      --  For any exception, output an error message, close the object file\n-      --  and return with Success = False.\n-\n-      when X : others =>\n-         Put_Line (\"unexpected exception raised while processing \"\"\"\n-                   & Object_File & \"\"\"\");\n-         Put_Line (Exception_Information (X));\n-         Close (File);\n-         Success := False;\n-   end Process;\n-\n-end Processing;"}, {"sha": "beb099e40b098926fb575af9016c75fe5c7d04c7", "filename": "gcc/ada/symbols-processing-vms-ia64.adb", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-processing-vms-ia64.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,430 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y M B O L S . P R O C E S S I N G                   --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2004-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VMS/IA64 version of this package\n-\n-with Ada.IO_Exceptions;\n-\n-with Ada.Unchecked_Deallocation;\n-\n-separate (Symbols)\n-package body Processing is\n-\n-   type String_Array is array (Positive range <>) of String_Access;\n-   type Strings_Ptr is access String_Array;\n-\n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (String_Array, Strings_Ptr);\n-\n-   type Section_Header is record\n-      Shname   : Integer;\n-      Shtype   : Integer;\n-      Shoffset : Integer;\n-      Shsize   : Integer;\n-      Shlink   : Integer;\n-   end record;\n-\n-   type Section_Header_Array is array (Natural range <>) of Section_Header;\n-   type Section_Header_Ptr is access Section_Header_Array;\n-\n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Section_Header_Array, Section_Header_Ptr);\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   procedure Process\n-     (Object_File : String;\n-      Success     : out Boolean)\n-   is\n-      B : Byte;\n-      W : Integer;\n-\n-      Str : String (1 .. 1000) := (others => ' ');\n-      Str_Last : Natural;\n-\n-      Strings : Strings_Ptr;\n-\n-      Shoff : Integer;\n-      Shnum : Integer;\n-      Shentsize : Integer;\n-\n-      Shname   : Integer;\n-      Shtype   : Integer;\n-      Shoffset : Integer;\n-      Shsize   : Integer;\n-      Shlink   : Integer;\n-\n-      Symtab_Index       : Natural := 0;\n-      String_Table_Index : Natural := 0;\n-\n-      End_Symtab : Integer;\n-\n-      Stname  : Integer;\n-      Stinfo  : Character;\n-      Stother : Character;\n-      Sttype  : Integer;\n-      Stbind  : Integer;\n-      Stshndx : Integer;\n-      Stvis   : Integer;\n-\n-      STV_Internal : constant := 1;\n-      STV_Hidden   : constant := 2;\n-\n-      Section_Headers : Section_Header_Ptr;\n-\n-      Offset : Natural := 0;\n-      OK     : Boolean := True;\n-\n-      procedure Get_Byte (B : out Byte);\n-      --  Read one byte from the object file\n-\n-      procedure Get_Half (H : out Integer);\n-      --  Read one half work from the object file\n-\n-      procedure Get_Word (W : out Integer);\n-      --  Read one full word from the object file\n-\n-      procedure Reset;\n-      --  Restart reading the object file\n-\n-      procedure Skip_Half;\n-      --  Read and disregard one half word from the object file\n-\n-      --------------\n-      -- Get_Byte --\n-      --------------\n-\n-      procedure Get_Byte (B : out Byte) is\n-      begin\n-         Byte_IO.Read (File, B);\n-         Offset := Offset + 1;\n-      end Get_Byte;\n-\n-      --------------\n-      -- Get_Half --\n-      --------------\n-\n-      procedure Get_Half (H : out Integer) is\n-         C1, C2 : Character;\n-      begin\n-         Get_Byte (C1); Get_Byte (C2);\n-         H :=\n-           Integer'(Character'Pos (C2)) * 256 + Integer'(Character'Pos (C1));\n-      end Get_Half;\n-\n-      --------------\n-      -- Get_Word --\n-      --------------\n-\n-      procedure Get_Word (W : out Integer) is\n-         H1, H2 : Integer;\n-      begin\n-         Get_Half (H1); Get_Half (H2);\n-         W := H2 * 256 * 256 + H1;\n-      end Get_Word;\n-\n-      -----------\n-      -- Reset --\n-      -----------\n-\n-      procedure Reset is\n-      begin\n-         Offset := 0;\n-         Byte_IO.Reset (File);\n-      end Reset;\n-\n-      ---------------\n-      -- Skip_Half --\n-      ---------------\n-\n-      procedure Skip_Half is\n-         B : Byte;\n-         pragma Unreferenced (B);\n-      begin\n-         Byte_IO.Read (File, B);\n-         Byte_IO.Read (File, B);\n-         Offset := Offset + 2;\n-      end Skip_Half;\n-\n-   --  Start of processing for Process\n-\n-   begin\n-      --  Open the object file with Byte_IO. Return with Success = False if\n-      --  this fails.\n-\n-      begin\n-         Open (File, In_File, Object_File);\n-      exception\n-         when others =>\n-            Put_Line\n-              (\"*** Unable to open object file \"\"\" & Object_File & \"\"\"\");\n-            Success := False;\n-            return;\n-      end;\n-\n-      --  Assume that the object file has a correct format\n-\n-      Success := True;\n-\n-      --  Skip ELF identification\n-\n-      while Offset < 16 loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      --  Skip e_type\n-\n-      Skip_Half;\n-\n-      --  Skip e_machine\n-\n-      Skip_Half;\n-\n-      --  Skip e_version\n-\n-      Get_Word (W);\n-\n-      --  Skip e_entry\n-\n-      for J in 1 .. 8 loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      --  Skip e_phoff\n-\n-      for J in 1 .. 8 loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      Get_Word (Shoff);\n-\n-      --  Skip upper half of Shoff\n-\n-      for J in 1 .. 4 loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      --  Skip e_flags\n-\n-      Get_Word (W);\n-\n-      --  Skip e_ehsize\n-\n-      Skip_Half;\n-\n-      --  Skip e_phentsize\n-\n-      Skip_Half;\n-\n-      --  Skip e_phnum\n-\n-      Skip_Half;\n-\n-      Get_Half (Shentsize);\n-\n-      Get_Half (Shnum);\n-\n-      Section_Headers := new Section_Header_Array (0 .. Shnum - 1);\n-\n-      --  Go to Section Headers\n-\n-      while Offset < Shoff loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      --  Reset Symtab_Index\n-\n-      Symtab_Index := 0;\n-\n-      for J in Section_Headers'Range loop\n-\n-         --  Get the data for each Section Header\n-\n-         Get_Word (Shname);\n-         Get_Word (Shtype);\n-\n-         for K in 1 .. 16 loop\n-            Get_Byte (B);\n-         end loop;\n-\n-         Get_Word (Shoffset);\n-         Get_Word (W);\n-\n-         Get_Word (Shsize);\n-         Get_Word (W);\n-\n-         Get_Word (Shlink);\n-\n-         while (Offset - Shoff) mod Shentsize /= 0 loop\n-            Get_Byte (B);\n-         end loop;\n-\n-         --  If this is the Symbol Table Section Header, record its index\n-\n-         if Shtype = 2 then\n-            Symtab_Index := J;\n-         end if;\n-\n-         Section_Headers (J) := (Shname, Shtype, Shoffset, Shsize, Shlink);\n-      end loop;\n-\n-      if Symtab_Index = 0 then\n-         Success := False;\n-         return;\n-      end if;\n-\n-      End_Symtab :=\n-        Section_Headers (Symtab_Index).Shoffset +\n-        Section_Headers (Symtab_Index).Shsize;\n-\n-      String_Table_Index := Section_Headers (Symtab_Index).Shlink;\n-      Strings :=\n-        new String_Array (1 .. Section_Headers (String_Table_Index).Shsize);\n-\n-      --  Go get the String Table section for the Symbol Table\n-\n-      Reset;\n-\n-      while Offset < Section_Headers (String_Table_Index).Shoffset loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      Offset := 0;\n-\n-      Get_Byte (B);  --  zero\n-\n-      while Offset < Section_Headers (String_Table_Index).Shsize loop\n-         Str_Last := 0;\n-\n-         loop\n-            Get_Byte (B);\n-            if B /= ASCII.NUL then\n-               Str_Last := Str_Last + 1;\n-               Str (Str_Last) := B;\n-\n-            else\n-               Strings (Offset - Str_Last - 1) :=\n-                 new String'(Str (1 .. Str_Last));\n-               exit;\n-            end if;\n-         end loop;\n-      end loop;\n-\n-      --  Go get the Symbol Table\n-\n-      Reset;\n-\n-      while Offset < Section_Headers (Symtab_Index).Shoffset loop\n-         Get_Byte (B);\n-      end loop;\n-\n-      while Offset < End_Symtab loop\n-         Get_Word (Stname);\n-         Get_Byte (Stinfo);\n-         Get_Byte (Stother);\n-         Get_Half (Stshndx);\n-         for J in 1 .. 4 loop\n-            Get_Word (W);\n-         end loop;\n-\n-         Sttype := Integer'(Character'Pos (Stinfo)) mod 16;\n-         Stbind := Integer'(Character'Pos (Stinfo)) / 16;\n-         Stvis  := Integer'(Character'Pos (Stother)) mod 4;\n-\n-         if (Sttype = 1 or else Sttype = 2)\n-              and then Stbind /= 0\n-              and then Stshndx /= 0\n-              and then Stvis /= STV_Internal\n-              and then Stvis /= STV_Hidden\n-         then\n-            --  Check if this is a symbol from a generic body\n-\n-            OK := True;\n-\n-            for J in Strings (Stname)'First .. Strings (Stname)'Last - 2 loop\n-               if Strings (Stname) (J) = 'G'\n-                 and then Strings (Stname) (J + 1) = 'P'\n-                 and then Strings (Stname) (J + 2) in '0' .. '9'\n-               then\n-                  OK := False;\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            if OK then\n-               declare\n-                  S_Data : Symbol_Data;\n-               begin\n-                  S_Data.Name := new String'(Strings (Stname).all);\n-\n-                  if Sttype = 1 then\n-                     S_Data.Kind := Data;\n-\n-                  else\n-                     S_Data.Kind := Proc;\n-                  end if;\n-\n-                  --  Put the new symbol in the table\n-\n-                  Symbol_Table.Append (Complete_Symbols, S_Data);\n-               end;\n-            end if;\n-         end if;\n-      end loop;\n-\n-      --  The object file has been processed, close it\n-\n-      Close (File);\n-\n-      --  Free the allocated memory\n-\n-      Free (Section_Headers);\n-\n-      for J in Strings'Range loop\n-         if Strings (J) /= null then\n-            Free (Strings (J));\n-         end if;\n-      end loop;\n-\n-      Free (Strings);\n-\n-   exception\n-      --  For any exception, output an error message, close the object file\n-      --  and return with Success = False.\n-\n-      when Ada.IO_Exceptions.End_Error =>\n-         Close (File);\n-\n-      when X : others =>\n-         Put_Line (\"unexpected exception raised while processing \"\"\"\n-                   & Object_File & \"\"\"\");\n-         Put_Line (Exception_Information (X));\n-         Close (File);\n-         Success := False;\n-   end Process;\n-\n-end Processing;"}, {"sha": "39c9beb3202b07265995a85ab936ce9744d81b62", "filename": "gcc/ada/symbols-vms.adb", "status": "removed", "additions": 0, "deletions": 637, "changes": 637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsymbols-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsymbols-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsymbols-vms.adb?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,637 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                              S Y M B O L S                               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2007, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the VMS version of this package\n-\n-with Ada.Exceptions;    use Ada.Exceptions;\n-with Ada.Sequential_IO;\n-with Ada.Text_IO;       use Ada.Text_IO;\n-\n-package body Symbols is\n-\n-   Case_Sensitive  : constant String := \"case_sensitive=\";\n-   Symbol_Vector   : constant String := \"SYMBOL_VECTOR=(\";\n-   Equal_Data      : constant String := \"=DATA)\";\n-   Equal_Procedure : constant String := \"=PROCEDURE)\";\n-   Gsmatch         : constant String := \"gsmatch=\";\n-   Gsmatch_Lequal  : constant String := \"gsmatch=lequal,\";\n-\n-   Symbol_File_Name : String_Access := null;\n-   --  Name of the symbol file\n-\n-   Long_Symbol_Length : constant := 100;\n-   --  Magic length of symbols, over which the lines are split\n-\n-   Sym_Policy : Policy := Autonomous;\n-   --  The symbol policy. Set by Initialize\n-\n-   Major_ID : Integer := 1;\n-   --  The Major ID. May be modified by Initialize if Library_Version is\n-   --  specified or if it is read from the reference symbol file.\n-\n-   Soft_Major_ID : Boolean := True;\n-   --  False if library version is specified in procedure Initialize.\n-   --  When True, Major_ID may be modified if found in the reference symbol\n-   --  file.\n-\n-   Minor_ID : Natural := 0;\n-   --  The Minor ID. May be modified if read from the reference symbol file\n-\n-   Soft_Minor_ID : Boolean := True;\n-   --  False if symbol policy is Autonomous, if library version is specified\n-   --  in procedure Initialize and is not the same as the major ID read from\n-   --  the reference symbol file. When True, Minor_ID may be increased in\n-   --  Compliant symbol policy.\n-\n-   subtype Byte is Character;\n-   --  Object files are stream of bytes, but some of these bytes, those for\n-   --  the names of the symbols, are ASCII characters.\n-\n-   package Byte_IO is new Ada.Sequential_IO (Byte);\n-   use Byte_IO;\n-\n-   File : Byte_IO.File_Type;\n-   --  Each object file is read as a stream of bytes (characters)\n-\n-   function Equal (Left, Right : Symbol_Data) return Boolean;\n-   --  Test for equality of symbols\n-\n-   function Image (N : Integer) return String;\n-   --  Returns the image of N, without the initial space\n-\n-   -----------\n-   -- Equal --\n-   -----------\n-\n-   function Equal (Left, Right : Symbol_Data) return Boolean is\n-   begin\n-      return Left.Name /= null and then\n-             Right.Name /= null and then\n-             Left.Name.all = Right.Name.all and then\n-             Left.Kind = Right.Kind and then\n-             Left.Present = Right.Present;\n-   end Equal;\n-\n-   -----------\n-   -- Image --\n-   -----------\n-\n-   function Image (N : Integer) return String is\n-      Result : constant String := N'Img;\n-   begin\n-      if Result (Result'First) = ' ' then\n-         return Result (Result'First + 1 .. Result'Last);\n-      else\n-         return Result;\n-      end if;\n-   end Image;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize\n-     (Symbol_File   : String;\n-      Reference     : String;\n-      Symbol_Policy : Policy;\n-      Quiet         : Boolean;\n-      Version       : String;\n-      Success       : out Boolean)\n-   is\n-      File : Ada.Text_IO.File_Type;\n-      Line : String (1 .. 2_000);\n-      Last : Natural;\n-\n-      Offset : Natural;\n-\n-   begin\n-      --  Record the symbol file name\n-\n-      Symbol_File_Name := new String'(Symbol_File);\n-\n-      --  Record the policy\n-\n-      Sym_Policy := Symbol_Policy;\n-\n-      --  Record the version (Major ID)\n-\n-      if Version = \"\" then\n-         Major_ID := 1;\n-         Soft_Major_ID := True;\n-\n-      else\n-         begin\n-            Major_ID := Integer'Value (Version);\n-            Soft_Major_ID := False;\n-\n-            if Major_ID <= 0 then\n-               raise Constraint_Error;\n-            end if;\n-\n-         exception\n-            when Constraint_Error =>\n-               if not Quiet then\n-                  Put_Line (\"Version \"\"\" & Version & \"\"\" is illegal.\");\n-                  Put_Line (\"On VMS, version must be a positive number\");\n-               end if;\n-\n-               Success := False;\n-               return;\n-         end;\n-      end if;\n-\n-      Minor_ID := 0;\n-      Soft_Minor_ID := Sym_Policy /= Autonomous;\n-\n-      --  Empty the symbol tables\n-\n-      Symbol_Table.Set_Last (Original_Symbols, 0);\n-      Symbol_Table.Set_Last (Complete_Symbols, 0);\n-\n-      --  Assume that everything will be fine\n-\n-      Success := True;\n-\n-      --  If policy is Compliant or Controlled, attempt to read the reference\n-      --  file. If policy is Restricted, attempt to read the symbol file.\n-\n-      if Sym_Policy /= Autonomous then\n-         case Sym_Policy is\n-            when Autonomous | Direct =>\n-               null;\n-\n-            when Compliant | Controlled =>\n-               begin\n-                  Open (File, In_File, Reference);\n-\n-               exception\n-                  when Ada.Text_IO.Name_Error =>\n-                     Success := False;\n-                     return;\n-\n-                  when X : others =>\n-                     if not Quiet then\n-                        Put_Line (\"could not open \"\"\" & Reference & \"\"\"\");\n-                        Put_Line (Exception_Message (X));\n-                     end if;\n-\n-                     Success := False;\n-                     return;\n-               end;\n-\n-            when Restricted =>\n-               begin\n-                  Open (File, In_File, Symbol_File);\n-\n-               exception\n-                  when Ada.Text_IO.Name_Error =>\n-                     Success := False;\n-                     return;\n-\n-                  when X : others =>\n-                     if not Quiet then\n-                        Put_Line (\"could not open \"\"\" & Symbol_File & \"\"\"\");\n-                        Put_Line (Exception_Message (X));\n-                     end if;\n-\n-                     Success := False;\n-                     return;\n-               end;\n-         end case;\n-\n-         --  Read line by line\n-\n-         while not End_Of_File (File) loop\n-            Offset := 0;\n-            loop\n-               Get_Line (File, Line (Offset + 1 .. Line'Last), Last);\n-               exit when Line (Last) /= '-';\n-\n-               if End_Of_File (File) then\n-                  if not Quiet then\n-                     Put_Line (\"symbol file \"\"\" & Reference &\n-                               \"\"\" is incorrectly formatted:\");\n-                     Put_Line (\"\"\"\" & Line (1 .. Last) & \"\"\"\");\n-                  end if;\n-\n-                  Close (File);\n-                  Success := False;\n-                  return;\n-\n-               else\n-                  Offset := Last - 1;\n-               end if;\n-            end loop;\n-\n-            --  Ignore empty lines\n-\n-            if Last = 0 then\n-               null;\n-\n-            --  Ignore lines starting with \"case_sensitive=\"\n-\n-            elsif Last > Case_Sensitive'Length\n-              and then Line (1 .. Case_Sensitive'Length) = Case_Sensitive\n-            then\n-               null;\n-\n-            --  Line starting with \"SYMBOL_VECTOR=(\"\n-\n-            elsif Last > Symbol_Vector'Length\n-              and then Line (1 .. Symbol_Vector'Length) = Symbol_Vector\n-            then\n-\n-               --  SYMBOL_VECTOR=(<symbol>=DATA)\n-\n-               if Last > Symbol_Vector'Length + Equal_Data'Length and then\n-                 Line (Last - Equal_Data'Length + 1 .. Last) = Equal_Data\n-               then\n-                  Symbol_Table.Append (Original_Symbols,\n-                    (Name =>\n-                       new String'(Line (Symbol_Vector'Length + 1 ..\n-                                         Last - Equal_Data'Length)),\n-                     Kind => Data,\n-                     Present => True));\n-\n-               --  SYMBOL_VECTOR=(<symbol>=PROCEDURE)\n-\n-               elsif Last > Symbol_Vector'Length + Equal_Procedure'Length\n-                 and then\n-                  Line (Last - Equal_Procedure'Length + 1 .. Last) =\n-                                                              Equal_Procedure\n-               then\n-                  Symbol_Table.Append (Original_Symbols,\n-                    (Name =>\n-                       new String'(Line (Symbol_Vector'Length + 1 ..\n-                                         Last - Equal_Procedure'Length)),\n-                     Kind => Proc,\n-                     Present => True));\n-\n-               --  Anything else is incorrectly formatted\n-\n-               else\n-                  if not Quiet then\n-                     Put_Line (\"symbol file \"\"\" & Reference &\n-                               \"\"\" is incorrectly formatted:\");\n-                     Put_Line (\"\"\"\" & Line (1 .. Last) & \"\"\"\");\n-                  end if;\n-\n-                  Close (File);\n-                  Success := False;\n-                  return;\n-               end if;\n-\n-            --  Lines with \"gsmatch=lequal,\" or \"gsmatch=equal,\"\n-\n-            elsif Last > Gsmatch'Length\n-              and then Line (1 .. Gsmatch'Length) = Gsmatch\n-            then\n-               declare\n-                  Start  : Positive := Gsmatch'Length + 1;\n-                  Finish : Positive := Start;\n-                  OK     : Boolean  := True;\n-                  ID     : Integer;\n-\n-               begin\n-                  --  First, look for the first coma\n-\n-                  loop\n-                     if Start >= Last - 1 then\n-                        OK := False;\n-                        exit;\n-\n-                     elsif Line (Start) = ',' then\n-                        Start := Start + 1;\n-                        exit;\n-\n-                     else\n-                        Start := Start + 1;\n-                     end if;\n-                  end loop;\n-\n-                  Finish := Start;\n-\n-                  --  If the comma is found, get the Major and the Minor IDs\n-\n-                  if OK then\n-                     loop\n-                        if Line (Finish) not in '0' .. '9'\n-                          or else Finish >= Last - 1\n-                        then\n-                           OK := False;\n-                           exit;\n-                        end if;\n-\n-                        exit when Line (Finish + 1) = ',';\n-\n-                        Finish := Finish + 1;\n-                     end loop;\n-                  end if;\n-\n-                  if OK then\n-                     ID := Integer'Value (Line (Start .. Finish));\n-                     OK := ID /= 0;\n-\n-                     --  If Soft_Major_ID is True, it means that\n-                     --  Library_Version was not specified.\n-\n-                     if Soft_Major_ID then\n-                        Major_ID := ID;\n-\n-                     --  If the Major ID in the reference file is different\n-                     --  from the Library_Version, then the Minor ID will be 0\n-                     --  because there is no point in taking the Minor ID in\n-                     --  the reference file, or incrementing it. So, we set\n-                     --  Soft_Minor_ID to False, so that we don't modify\n-                     --  the Minor_ID later.\n-\n-                     elsif Major_ID /= ID then\n-                        Soft_Minor_ID := False;\n-                     end if;\n-\n-                     Start := Finish + 2;\n-                     Finish := Start;\n-\n-                     loop\n-                        if Line (Finish) not in '0' .. '9' then\n-                           OK := False;\n-                           exit;\n-                        end if;\n-\n-                        exit when Finish = Last;\n-\n-                        Finish := Finish + 1;\n-                     end loop;\n-\n-                     --  Only set Minor_ID if Soft_Minor_ID is True (see above)\n-\n-                     if OK and then Soft_Minor_ID then\n-                        Minor_ID := Integer'Value (Line (Start .. Finish));\n-                     end if;\n-                  end if;\n-\n-                  --  If OK is not True, that means the line is not correctly\n-                  --  formatted.\n-\n-                  if not OK then\n-                     if not Quiet then\n-                        Put_Line (\"symbol file \"\"\" & Reference &\n-                                  \"\"\" is incorrectly formatted\");\n-                        Put_Line (\"\"\"\" & Line (1 .. Last) & \"\"\"\");\n-                     end if;\n-\n-                     Close (File);\n-                     Success := False;\n-                     return;\n-                  end if;\n-               end;\n-\n-            --  Anything else is incorrectly formatted\n-\n-            else\n-               if not Quiet then\n-                  Put_Line (\"unexpected line in symbol file \"\"\" &\n-                            Reference & \"\"\"\");\n-                  Put_Line (\"\"\"\" & Line (1 .. Last) & \"\"\"\");\n-               end if;\n-\n-               Close (File);\n-               Success := False;\n-               return;\n-            end if;\n-         end loop;\n-\n-         Close (File);\n-      end if;\n-   end Initialize;\n-\n-   ----------------\n-   -- Processing --\n-   ----------------\n-\n-   package body Processing is separate;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize\n-     (Quiet   : Boolean;\n-      Success : out Boolean)\n-   is\n-      File   : Ada.Text_IO.File_Type;\n-      --  The symbol file\n-\n-      S_Data : Symbol_Data;\n-      --  A symbol\n-\n-      Cur    : Positive := 1;\n-      --  Most probable index in the Complete_Symbols of the current symbol\n-      --  in Original_Symbol.\n-\n-      Found  : Boolean;\n-\n-   begin\n-      --  Nothing to be done if Initialize has never been called\n-\n-      if Symbol_File_Name = null then\n-         Success := False;\n-\n-      else\n-\n-         --  First find if the symbols in the reference symbol file are also\n-         --  in the object files. Note that this is not done if the policy is\n-         --  Autonomous, because no reference symbol file has been read.\n-\n-         --  Expect the first symbol in the symbol file to also be the first\n-         --  in Complete_Symbols.\n-\n-         Cur := 1;\n-\n-         for Index_1 in 1 .. Symbol_Table.Last (Original_Symbols) loop\n-            S_Data := Original_Symbols.Table (Index_1);\n-            Found := False;\n-\n-            First_Object_Loop :\n-            for Index_2 in Cur .. Symbol_Table.Last (Complete_Symbols) loop\n-               if Equal (S_Data, Complete_Symbols.Table (Index_2)) then\n-                  Cur := Index_2 + 1;\n-                  Complete_Symbols.Table (Index_2).Present := False;\n-                  Found := True;\n-                  exit First_Object_Loop;\n-               end if;\n-            end loop First_Object_Loop;\n-\n-            --  If the symbol could not be found between Cur and Last, try\n-            --  before Cur.\n-\n-            if not Found then\n-               Second_Object_Loop :\n-               for Index_2 in 1 .. Cur - 1 loop\n-                  if Equal (S_Data, Complete_Symbols.Table (Index_2)) then\n-                     Cur := Index_2 + 1;\n-                     Complete_Symbols.Table (Index_2).Present := False;\n-                     Found := True;\n-                     exit Second_Object_Loop;\n-                  end if;\n-               end loop Second_Object_Loop;\n-            end if;\n-\n-            --  If the symbol is not found, mark it as such in the table\n-\n-            if not Found then\n-               if (not Quiet) or else Sym_Policy = Controlled then\n-                  Put_Line (\"symbol \"\"\" & S_Data.Name.all &\n-                            \"\"\" is no longer present in the object files\");\n-               end if;\n-\n-               if Sym_Policy = Controlled or else Sym_Policy = Restricted then\n-                  Success := False;\n-                  return;\n-\n-               --  Any symbol that is undefined in the reference symbol file\n-               --  triggers an increase of the Major ID, because the new\n-               --  version of the library is no longer compatible with\n-               --  existing executables.\n-\n-               elsif Soft_Major_ID then\n-                  Major_ID := Major_ID + 1;\n-                  Minor_ID := 0;\n-                  Soft_Major_ID := False;\n-                  Soft_Minor_ID := False;\n-               end if;\n-\n-               Original_Symbols.Table (Index_1).Present := False;\n-               Free (Original_Symbols.Table (Index_1).Name);\n-\n-               if Soft_Minor_ID then\n-                  Minor_ID := Minor_ID + 1;\n-                  Soft_Minor_ID := False;\n-               end if;\n-            end if;\n-         end loop;\n-\n-         if Sym_Policy /= Restricted then\n-\n-            --  Append additional symbols, if any, to the Original_Symbols\n-            --  table.\n-\n-            for Index in 1 .. Symbol_Table.Last (Complete_Symbols) loop\n-               S_Data := Complete_Symbols.Table (Index);\n-\n-               if S_Data.Present then\n-\n-                  if Sym_Policy = Controlled then\n-                     Put_Line (\"symbol \"\"\" & S_Data.Name.all &\n-                               \"\"\" is not in the reference symbol file\");\n-                     Success := False;\n-                     return;\n-\n-                  elsif Soft_Minor_ID then\n-                     Minor_ID := Minor_ID + 1;\n-                     Soft_Minor_ID := False;\n-                  end if;\n-\n-                  Symbol_Table.Append (Original_Symbols, S_Data);\n-                  Complete_Symbols.Table (Index).Present := False;\n-               end if;\n-            end loop;\n-\n-            --  Create the symbol file\n-\n-            Create (File, Ada.Text_IO.Out_File, Symbol_File_Name.all);\n-\n-            Put (File, Case_Sensitive);\n-            Put_Line (File, \"yes\");\n-\n-            --  Put a line in the symbol file for each symbol in symbol table\n-\n-            for Index in 1 .. Symbol_Table.Last (Original_Symbols) loop\n-               if Original_Symbols.Table (Index).Present then\n-                  Put (File, Symbol_Vector);\n-\n-                  --  Split the line if symbol name length is too large\n-\n-                  if Original_Symbols.Table (Index).Name'Length >\n-                    Long_Symbol_Length\n-                  then\n-                     Put_Line (File, \"-\");\n-                  end if;\n-\n-                  Put (File, Original_Symbols.Table (Index).Name.all);\n-\n-                  if Original_Symbols.Table (Index).Name'Length >\n-                    Long_Symbol_Length\n-                  then\n-                     Put_Line (File, \"-\");\n-                  end if;\n-\n-                  if Original_Symbols.Table (Index).Kind = Data then\n-                     Put_Line (File, Equal_Data);\n-\n-                  else\n-                     Put_Line (File, Equal_Procedure);\n-                  end if;\n-\n-                  Free (Original_Symbols.Table (Index).Name);\n-               end if;\n-            end loop;\n-\n-            Put (File, Case_Sensitive);\n-            Put_Line (File, \"NO\");\n-\n-            --  Put the version IDs\n-\n-            Put (File, Gsmatch_Lequal);\n-            Put (File, Image (Major_ID));\n-            Put (File, ',');\n-            Put_Line  (File, Image (Minor_ID));\n-\n-            --  And we are done\n-\n-            Close (File);\n-\n-            --  Reset both tables\n-\n-            Symbol_Table.Set_Last (Original_Symbols, 0);\n-            Symbol_Table.Set_Last (Complete_Symbols, 0);\n-\n-            --  Clear the symbol file name\n-\n-            Free (Symbol_File_Name);\n-         end if;\n-\n-         Success := True;\n-      end if;\n-\n-   exception\n-      when X : others =>\n-         Put_Line (\"unexpected exception raised while finalizing \"\"\"\n-                   & Symbol_File_Name.all & \"\"\"\");\n-         Put_Line (Exception_Information (X));\n-         Success := False;\n-   end Finalize;\n-\n-end Symbols;"}, {"sha": "0b7f94751507e01d899ed7f804fe98c68618c6ea", "filename": "gcc/ada/system-vms-ia64.ads", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsystem-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsystem-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-vms-ia64.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,257 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---            (OpenVMS 64bit Itanium GCC_ZCX DEC Threads Version)           --\n---                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package System is\n-   pragma Pure;\n-   --  Note that we take advantage of the implementation permission to make\n-   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n-   --  2005, this is Pure in any case (AI-362).\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 0.01;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is new Long_Integer;\n-   Null_Address : constant Address;\n-   --  Although this is declared as an integer type, no arithmetic operations\n-   --  are available (see abstract declarations below), and furthermore there\n-   --  is special processing in the compiler that prevents the use of integer\n-   --  literals with this type (use To_Address to convert integer literals).\n-   --\n-   --  Conversion to and from Short_Address is however freely permitted, and\n-   --  is indeed the reason that Address is declared as an integer type.\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 64;\n-   Memory_Size  : constant := 2 ** 64;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Abstract declarations for arithmetic operations on type address.\n-   --  These declarations are needed when Address is non-private. They\n-   --  avoid excessive visibility of arithmetic operations on address\n-   --  which are typically available elsewhere (e.g. Storage_Elements)\n-   --  and which would cause excessive ambiguities in application code.\n-\n-   function \"+\"   (Left, Right : Address) return Address is abstract;\n-   function \"-\"   (Left, Right : Address) return Address is abstract;\n-   function \"/\"   (Left, Right : Address) return Address is abstract;\n-   function \"*\"   (Left, Right : Address) return Address is abstract;\n-   function \"mod\" (Left, Right : Address) return Address is abstract;\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n-   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   Max_Priority           : constant Positive := 30;\n-   Max_Interrupt_Priority : constant Positive := 31;\n-\n-   subtype Any_Priority       is Integer      range  0 .. 31;\n-   subtype Priority           is Any_Priority range  0 .. 30;\n-   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n-\n-   Default_Priority : constant Priority := 15;\n-\n-private\n-\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := True;\n-   Command_Line_Args         : constant Boolean := True;\n-   Configurable_Run_Time     : constant Boolean := False;\n-   Denorm                    : constant Boolean := True;\n-   Duration_32_Bits          : constant Boolean := False;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   OpenVMS                   : constant Boolean := True;\n-   VAX_Float                 : constant Boolean := False;\n-   Preallocated_Stacks       : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := True;\n-   Stack_Check_Probes        : constant Boolean := True;\n-   Stack_Check_Limits        : constant Boolean := False;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Atomic_Primitives : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Always_Compatible_Rep     : constant Boolean := True;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := True;\n-\n-   --------------------------\n-   -- Underlying Priorities --\n-   ---------------------------\n-\n-   --  Important note: this section of the file must come AFTER the\n-   --  definition of the system implementation parameters to ensure\n-   --  that the value of these parameters is available for analysis\n-   --  of the declarations here (using Rtsfind at compile time).\n-\n-   --  The underlying priorities table provides a generalized mechanism\n-   --  for mapping from Ada priorities to system priorities. In some\n-   --  cases a 1-1 mapping is not the convenient or optimal choice.\n-\n-   --  For DEC Threads OpenVMS, we use the full range of 31 priorities\n-   --  in the Ada model, but map them by compression onto the more limited\n-   --  range of priorities available in OpenVMS.\n-\n-   --  To replace the default values of the Underlying_Priorities mapping,\n-   --  copy this source file into your build directory, edit the file to\n-   --  reflect your desired behavior, and recompile with the command:\n-\n-   --     $ gcc -c -O3 -gnatpgn system.ads\n-\n-   --  then recompile the run-time parts that depend on this package:\n-\n-   --     $ gnatmake -a -gnatn -O3 <your application>\n-\n-   --  then force rebuilding your application if you need different options:\n-\n-   --     $ gnatmake -f <your options> <your application>\n-\n-   type Priorities_Mapping is array (Any_Priority) of Integer;\n-   pragma Suppress_Initialization (Priorities_Mapping);\n-   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars\n-\n-   Underlying_Priorities : constant Priorities_Mapping :=\n-\n-     (Priority'First => 16,\n-\n-      1  => 17,\n-      2  => 18,\n-      3  => 18,\n-      4  => 18,\n-      5  => 18,\n-      6  => 19,\n-      7  => 19,\n-      8  => 19,\n-      9  => 20,\n-      10 => 20,\n-      11 => 21,\n-      12 => 21,\n-      13 => 22,\n-      14 => 23,\n-\n-      Default_Priority   => 24,\n-\n-      16 => 25,\n-      17 => 25,\n-      18 => 25,\n-      19 => 26,\n-      20 => 26,\n-      21 => 26,\n-      22 => 27,\n-      23 => 27,\n-      24 => 27,\n-      25 => 28,\n-      26 => 28,\n-      27 => 29,\n-      28 => 29,\n-      29 => 30,\n-\n-      Priority'Last      => 30,\n-\n-      Interrupt_Priority => 31);\n-\n-   ----------------------------\n-   -- Special VMS Interfaces --\n-   ----------------------------\n-\n-   procedure Lib_Stop (Cond_Value : Integer);\n-   pragma Import (C, Lib_Stop);\n-   pragma Import_Procedure (Lib_Stop, \"LIB$STOP\", Mechanism => (Value));\n-   --  Interface to VMS condition handling. Used by RTSfind and pragma\n-   --  {Import,Export}_Exception. Put here because this is the only\n-   --  VMS specific package that doesn't drag in tasking.\n-\n-   ADA_GNAT : constant Boolean := True;\n-   pragma Export_Object (ADA_GNAT, \"ADA$GNAT\");\n-   --  Ubiquitous global symbol identifying a GNAT compiled image to VMS Debug.\n-   --  Do not remove.\n-\n-   pragma Ident (\"GNAT\"); --  Gnat_Static_Version_String\n-   --  Default ident for all VMS images.\n-\n-end System;"}, {"sha": "cc03c165968af6a99a8de29c05626e00054d7711", "filename": "gcc/ada/system-vms_64.ads", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsystem-vms_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fec4842dee0f49ce7db1f472cb0b18227b489271/gcc%2Fada%2Fsystem-vms_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-vms_64.ads?ref=fec4842dee0f49ce7db1f472cb0b18227b489271", "patch": "@@ -1,257 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---                (OpenVMS 64bit GCC_ZCX DEC Threads Version)               --\n---                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package System is\n-   pragma Pure;\n-   --  Note that we take advantage of the implementation permission to make\n-   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n-   --  2005, this is Pure in any case (AI-362).\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 0.01;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is new Long_Integer;\n-   Null_Address : constant Address;\n-   --  Although this is declared as an integer type, no arithmetic operations\n-   --  are available (see abstract declarations below), and furthermore there\n-   --  is special processing in the compiler that prevents the use of integer\n-   --  literals with this type (use To_Address to convert integer literals).\n-   --\n-   --  Conversion to and from Short_Address is however freely permitted, and\n-   --  is indeed the reason that Address is declared as an integer type.\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 64;\n-   Memory_Size  : constant := 2 ** 64;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Abstract declarations for arithmetic operations on type address.\n-   --  These declarations are needed when Address is non-private. They\n-   --  avoid excessive visibility of arithmetic operations on address\n-   --  which are typically available elsewhere (e.g. Storage_Elements)\n-   --  and which would cause excessive ambiguities in application code.\n-\n-   function \"+\"   (Left, Right : Address) return Address is abstract;\n-   function \"-\"   (Left, Right : Address) return Address is abstract;\n-   function \"/\"   (Left, Right : Address) return Address is abstract;\n-   function \"*\"   (Left, Right : Address) return Address is abstract;\n-   function \"mod\" (Left, Right : Address) return Address is abstract;\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n-   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   Max_Priority           : constant Positive := 30;\n-   Max_Interrupt_Priority : constant Positive := 31;\n-\n-   subtype Any_Priority       is Integer      range  0 .. 31;\n-   subtype Priority           is Any_Priority range  0 .. 30;\n-   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n-\n-   Default_Priority : constant Priority := 15;\n-\n-private\n-\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := True;\n-   Command_Line_Args         : constant Boolean := True;\n-   Configurable_Run_Time     : constant Boolean := False;\n-   Denorm                    : constant Boolean := False;\n-   Duration_32_Bits          : constant Boolean := False;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   OpenVMS                   : constant Boolean := True;\n-   VAX_Float                 : constant Boolean := False;\n-   Preallocated_Stacks       : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := True;\n-   Stack_Check_Probes        : constant Boolean := True;\n-   Stack_Check_Limits        : constant Boolean := False;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Atomic_Primitives : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Always_Compatible_Rep     : constant Boolean := True;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := True;\n-\n-   --------------------------\n-   -- Underlying Priorities --\n-   ---------------------------\n-\n-   --  Important note: this section of the file must come AFTER the\n-   --  definition of the system implementation parameters to ensure\n-   --  that the value of these parameters is available for analysis\n-   --  of the declarations here (using Rtsfind at compile time).\n-\n-   --  The underlying priorities table provides a generalized mechanism\n-   --  for mapping from Ada priorities to system priorities. In some\n-   --  cases a 1-1 mapping is not the convenient or optimal choice.\n-\n-   --  For DEC Threads OpenVMS, we use the full range of 31 priorities\n-   --  in the Ada model, but map them by compression onto the more limited\n-   --  range of priorities available in OpenVMS.\n-\n-   --  To replace the default values of the Underlying_Priorities mapping,\n-   --  copy this source file into your build directory, edit the file to\n-   --  reflect your desired behavior, and recompile with the command:\n-\n-   --     $ gcc -c -O3 -gnatpgn system.ads\n-\n-   --  then recompile the run-time parts that depend on this package:\n-\n-   --     $ gnatmake -a -gnatn -O3 <your application>\n-\n-   --  then force rebuilding your application if you need different options:\n-\n-   --     $ gnatmake -f <your options> <your application>\n-\n-   type Priorities_Mapping is array (Any_Priority) of Integer;\n-   pragma Suppress_Initialization (Priorities_Mapping);\n-   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars\n-\n-   Underlying_Priorities : constant Priorities_Mapping :=\n-\n-     (Priority'First => 16,\n-\n-      1  => 17,\n-      2  => 18,\n-      3  => 18,\n-      4  => 18,\n-      5  => 18,\n-      6  => 19,\n-      7  => 19,\n-      8  => 19,\n-      9  => 20,\n-      10 => 20,\n-      11 => 21,\n-      12 => 21,\n-      13 => 22,\n-      14 => 23,\n-\n-      Default_Priority   => 24,\n-\n-      16 => 25,\n-      17 => 25,\n-      18 => 25,\n-      19 => 26,\n-      20 => 26,\n-      21 => 26,\n-      22 => 27,\n-      23 => 27,\n-      24 => 27,\n-      25 => 28,\n-      26 => 28,\n-      27 => 29,\n-      28 => 29,\n-      29 => 30,\n-\n-      Priority'Last      => 30,\n-\n-      Interrupt_Priority => 31);\n-\n-   ----------------------------\n-   -- Special VMS Interfaces --\n-   ----------------------------\n-\n-   procedure Lib_Stop (Cond_Value : Integer);\n-   pragma Import (C, Lib_Stop);\n-   pragma Import_Procedure (Lib_Stop, \"LIB$STOP\", Mechanism => (Value));\n-   --  Interface to VMS condition handling. Used by RTSfind and pragma\n-   --  {Import,Export}_Exception. Put here because this is the only\n-   --  VMS specific package that doesn't drag in tasking.\n-\n-   ADA_GNAT : constant Boolean := True;\n-   pragma Export_Object (ADA_GNAT, \"ADA$GNAT\");\n-   --  Ubiquitous global symbol identifying a GNAT compiled image to VMS Debug.\n-   --  Do not remove.\n-\n-   pragma Ident (\"GNAT\"); --  Gnat_Static_Version_String\n-   --  Default ident for all VMS images.\n-\n-end System;"}]}