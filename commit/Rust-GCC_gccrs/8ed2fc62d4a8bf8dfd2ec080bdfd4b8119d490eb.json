{"sha": "8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVkMmZjNjJkNGE4YmY4ZGZkMmVjMDgwYmRmZDRiODExOWQ0OTBlYg==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-23T16:22:17Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-23T16:22:17Z"}, "message": "[AArch64] Split save restore path.\n\nFrom-SVN: r212956", "tree": {"sha": "5f7f11561d7ffb962cfca05cc962dedad94445da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f7f11561d7ffb962cfca05cc962dedad94445da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb/comments", "author": null, "committer": null, "parents": [{"sha": "0ec74a1ee358ee14658ea251d5d885863764c4a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ec74a1ee358ee14658ea251d5d885863764c4a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ec74a1ee358ee14658ea251d5d885863764c4a9"}], "stats": {"total": 110, "additions": 75, "deletions": 35}, "files": [{"sha": "c3e945ec317c99595ed1724eb22600ef350f7c05", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb", "patch": "@@ -1,3 +1,9 @@\n+2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.md: (aarch64_save_or_restore_callee_saves):\n+\tRename to aarch64_save_callee_saves, remove restore code.\n+\t(aarch64_restore_callee_saves): New function.\n+\n 2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_save_or_restore_fprs): Deleted."}, {"sha": "7e267dd98c4d5a396027a10aa755b9c7fd11968f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8ed2fc62d4a8bf8dfd2ec080bdfd4b8119d490eb", "patch": "@@ -1951,13 +1951,9 @@ aarch64_gen_load_pair (enum machine_mode mode, rtx reg1, rtx mem1, rtx reg2,\n }\n \n \n-/* offset from the stack pointer of where the saves and\n-   restore's have to happen.  */\n static void\n-aarch64_save_or_restore_callee_saves (enum machine_mode mode,\n-\t\t\t\t      HOST_WIDE_INT start_offset,\n-\t\t\t\t      unsigned start, unsigned limit,\n-\t\t\t\t      bool restore)\n+aarch64_save_callee_saves (enum machine_mode mode, HOST_WIDE_INT start_offset,\n+\t\t\t   unsigned start, unsigned limit)\n {\n   rtx insn;\n   rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n@@ -1988,18 +1984,10 @@ aarch64_save_or_restore_callee_saves (enum machine_mode mode,\n \t  rtx mem2;\n \n \t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n-\t  mem2 = gen_mem_ref (mode,\n-\t\t\t      plus_constant (Pmode, stack_pointer_rtx, offset));\n-\t  if (restore == false)\n-\t    insn = emit_insn (aarch64_gen_store_pair (mode, mem, reg, mem2,\n-\t\t\t\t\t\t      reg2));\n-\t  else\n-\t    {\n-\t      insn = emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2,\n-\t\t\t\t\t\t       mem2));\n-\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t      add_reg_note (insn, REG_CFA_RESTORE, reg2);\n-\t    }\n+\t  mem2 = gen_mem_ref (mode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\t   offset));\n+\t  insn = emit_insn (aarch64_gen_store_pair (mode, mem, reg, mem2,\n+\t\t\t\t\t\t    reg2));\n \n \t  /* The first part of a frame-related parallel insn is\n \t     always assumed to be relevant to the frame\n@@ -2009,15 +1997,64 @@ aarch64_save_or_restore_callee_saves (enum machine_mode mode,\n \t  regno = regno2;\n \t}\n       else\n+\tinsn = emit_move_insn (mem, reg);\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+static void\n+aarch64_restore_callee_saves (enum machine_mode mode,\n+\t\t\t      HOST_WIDE_INT start_offset, unsigned start,\n+\t\t\t      unsigned limit)\n+{\n+  rtx insn;\n+  rtx base_rtx = stack_pointer_rtx;\n+  rtx (*gen_mem_ref) (enum machine_mode, rtx) = (frame_pointer_needed\n+\t\t\t\t\t\t ? gen_frame_mem : gen_rtx_MEM);\n+  unsigned regno;\n+  unsigned regno2;\n+  HOST_WIDE_INT offset;\n+\n+  for (regno = aarch64_next_callee_save (start, limit);\n+       regno <= limit;\n+       regno = aarch64_next_callee_save (regno + 1, limit))\n+    {\n+      rtx reg = gen_rtx_REG (mode, regno);\n+      rtx mem;\n+\n+      offset = start_offset + cfun->machine->frame.reg_offset[regno];\n+      mem = gen_mem_ref (mode, plus_constant (Pmode, base_rtx, offset));\n+\n+      regno2 = aarch64_next_callee_save (regno + 1, limit);\n+\n+      if (regno2 <= limit\n+\t  && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n+\t      == cfun->machine->frame.reg_offset[regno2]))\n \t{\n-\t  if (restore == false)\n-\t    insn = emit_move_insn (mem, reg);\n-\t  else\n-\t    {\n-\t      insn = emit_move_insn (reg, mem);\n-\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t    }\n+\t  rtx reg2 = gen_rtx_REG (mode, regno2);\n+\t  rtx mem2;\n+\n+\t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n+\t  mem2 = gen_mem_ref (mode, plus_constant (Pmode, base_rtx, offset));\n+\t  insn = emit_insn (aarch64_gen_load_pair (mode, reg, mem, reg2,\n+\t\t\t\t\t\t   mem2));\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n+\n+\t  /* The first part of a frame-related parallel insn is\n+\t     always assumed to be relevant to the frame\n+\t     calculations; subsequent parts, are only\n+\t     frame-related if explicitly marked.  */\n+\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t  regno = regno2;\n \t}\n+      else\n+\t{\n+\t  insn = emit_move_insn (reg, mem);\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t}\n+\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n }\n@@ -2212,11 +2249,10 @@ aarch64_expand_prologue (void)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n-      aarch64_save_or_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n-\t\t\t\t\t    frame_pointer_needed\n-\t\t\t\t\t    ? R28_REGNUM : R30_REGNUM, false);\n-      aarch64_save_or_restore_callee_saves (DFmode, fp_offset, V0_REGNUM,\n-\t\t\t\t\t    V31_REGNUM, false);\n+      aarch64_save_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\t frame_pointer_needed\n+\t\t\t\t ? R28_REGNUM : R30_REGNUM);\n+      aarch64_save_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM);\n     }\n \n   /* when offset >= 512,\n@@ -2287,11 +2323,9 @@ aarch64_expand_epilogue (bool for_sibcall)\n       cfa_reg = stack_pointer_rtx;\n     }\n \n-  aarch64_save_or_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n-\t\t\t\t\tframe_pointer_needed\n-\t\t\t\t\t? R28_REGNUM : R30_REGNUM, true);\n-  aarch64_save_or_restore_callee_saves (DFmode, fp_offset, V0_REGNUM,\n-\t\t\t\t\tV31_REGNUM, true);\n+  aarch64_restore_callee_saves (DImode, fp_offset, R0_REGNUM,\n+\t\t\t\tframe_pointer_needed ? R28_REGNUM : R30_REGNUM);\n+  aarch64_restore_callee_saves (DFmode, fp_offset, V0_REGNUM, V31_REGNUM);\n \n   /* Restore the frame pointer and lr if the frame pointer is needed.  */\n   if (offset > 0)"}]}