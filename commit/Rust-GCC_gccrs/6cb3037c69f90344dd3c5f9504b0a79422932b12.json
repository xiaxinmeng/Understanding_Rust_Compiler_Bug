{"sha": "6cb3037c69f90344dd3c5f9504b0a79422932b12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiMzAzN2M2OWY5MDM0NGRkM2M1Zjk1MDRiMGE3OTQyMjkzMmIxMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T13:15:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-01T13:15:21Z"}, "message": "[multiple changes]\n\n2012-10-01  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Minimize_Eliminate_Overflow_Checks): Changes\n\tfor exponentiation.\n\t* exp_ch4.adb (Expand_N_Op_Expon): Changes for Minimize/Eliminate\n\toverflow checks.\n\t* s-bignum.adb (Compare): Fix bad precondition.\n\n2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Build_Derived_Record_Type): If the derived\n\ttype has new discriminantss that constrain inherited ones, use\n\tthe discriminant type in the original declaration to check for\n\tconformance, because in the presence of array components with a\n\tsmaller range that are constrained by the origina discriminant,\n\tthe compiler will have created a narrower subtype for that\n\tdiscriminant.\n\nFrom-SVN: r191919", "tree": {"sha": "472b8d3167f76e0ef9ed548985d556ff582c00d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/472b8d3167f76e0ef9ed548985d556ff582c00d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cb3037c69f90344dd3c5f9504b0a79422932b12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb3037c69f90344dd3c5f9504b0a79422932b12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cb3037c69f90344dd3c5f9504b0a79422932b12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cb3037c69f90344dd3c5f9504b0a79422932b12/comments", "author": null, "committer": null, "parents": [{"sha": "f619427812a37d1249b1a85434dde71b8efdc40a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f619427812a37d1249b1a85434dde71b8efdc40a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f619427812a37d1249b1a85434dde71b8efdc40a"}], "stats": {"total": 238, "additions": 192, "deletions": 46}, "files": [{"sha": "ef3d7aac19046f3f7d077609ced9ab36d4c2fe40", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6cb3037c69f90344dd3c5f9504b0a79422932b12", "patch": "@@ -1,3 +1,21 @@\n+2012-10-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Minimize_Eliminate_Overflow_Checks): Changes\n+\tfor exponentiation.\n+\t* exp_ch4.adb (Expand_N_Op_Expon): Changes for Minimize/Eliminate\n+\toverflow checks.\n+\t* s-bignum.adb (Compare): Fix bad precondition.\n+\n+2012-10-01  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Derived_Record_Type): If the derived\n+\ttype has new discriminantss that constrain inherited ones, use\n+\tthe discriminant type in the original declaration to check for\n+\tconformance, because in the presence of array components with a\n+\tsmaller range that are constrained by the origina discriminant,\n+\tthe compiler will have created a narrower subtype for that\n+\tdiscriminant.\n+\n 2012-10-01  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb (Apply_Arithmetic_Overflow_Minimized_Eliminated):"}, {"sha": "3844d1e1550dddaee784a305a726dbb0afc6bf2f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 121, "deletions": 31, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6cb3037c69f90344dd3c5f9504b0a79422932b12", "patch": "@@ -6548,7 +6548,7 @@ package body Checks is\n \n             when N_Op_Abs =>\n                Lo := Uint_0;\n-               Hi := UI_Max (UI_Abs (Rlo), UI_Abs (Rhi));\n+               Hi := UI_Max (abs Rlo, abs Rhi);\n \n             --  Addition\n \n@@ -6564,7 +6564,79 @@ package body Checks is\n             --  Exponentiation\n \n             when N_Op_Expon =>\n-               raise Program_Error;\n+\n+               --  Discard negative values for the exponent, since they will\n+               --  simply result in an exception in any case.\n+\n+               if Rhi < 0 then\n+                  Rhi := Uint_0;\n+               elsif Rlo < 0 then\n+                  Rlo := Uint_0;\n+               end if;\n+\n+               --  Estimate number of bits in result before we go computing\n+               --  giant useless bounds. Basically the number of bits in the\n+               --  result is the number of bits in the base multiplied by the\n+               --  value of the exponent. If this is big enough that the result\n+               --  definitely won't fit in Long_Long_Integer, switch to bignum\n+               --  mode immediately, and avoid computing giant bounds.\n+\n+               --  The comparison here is approximate, but conservative, it\n+               --  only clicks on cases that are sure to exceed the bounds.\n+\n+               if Num_Bits (UI_Max (abs Llo, abs Lhi)) * Rhi + 1 > 100 then\n+                  Lo := No_Uint;\n+                  Hi := No_Uint;\n+\n+               --  If right operand is zero then result is 1\n+\n+               elsif Rhi = 0 then\n+                  Lo := Uint_1;\n+                  Hi := Uint_1;\n+\n+               else\n+                  --  High bound comes either from exponentiation of largest\n+                  --  positive value to largest exponent value, or from the\n+                  --  exponentiation of most negative value to an odd exponent.\n+\n+                  declare\n+                     Hi1, Hi2 : Uint;\n+\n+                  begin\n+                     if Lhi >= 0 then\n+                        Hi1 := Lhi ** Rhi;\n+                     else\n+                        Hi1 := Uint_0;\n+                     end if;\n+\n+                     if Llo < 0 then\n+                        if Rhi mod 2 = 0 then\n+                           Hi2 := Llo ** (Rhi - 1);\n+                        else\n+                           Hi2 := Llo ** Rhi;\n+                        end if;\n+                     else\n+                        Hi2 := Uint_0;\n+                     end if;\n+\n+                     Hi := UI_Max (Hi1, Hi2);\n+                  end;\n+\n+                  --  Result can only be negative if base can be negative\n+\n+                  if Llo < 0 then\n+                     if UI_Mod (Rhi, 2) = 0 then\n+                        Lo := Llo ** (Rhi - 1);\n+                     else\n+                        Lo := Llo ** Rhi;\n+                     end if;\n+\n+                  --  Otherwise low bound is minimium ** minimum\n+\n+                  else\n+                     Lo := Llo ** Rlo;\n+                  end if;\n+               end if;\n \n             --  Negation\n \n@@ -6623,13 +6695,13 @@ package body Checks is\n \n             when others =>\n                raise Program_Error;\n-\n          end case;\n       end if;\n \n       --  Case where we do the operation in Bignum mode. This happens either\n       --  because one of our operands is in Bignum mode already, or because\n-      --  the computed bounds are outside the bounds of Long_Long_Integer.\n+      --  the computed bounds are outside the bounds of Long_Long_Integer,\n+      --  which in some cases can be indicated by Hi and Lo being No_Uint.\n \n       --  Note: we could do better here and in some cases switch back from\n       --  Bignum mode to normal mode, e.g. big mod 2 must be in the range\n@@ -6641,21 +6713,13 @@ package body Checks is\n \n       if Lo = No_Uint or else Lo < LLLo or else Hi > LLHi then\n \n-         --  In MINIMIZED mode, just give up and apply an overflow check\n+         --  In MINIMIZED mode, note that an overflow check is required\n          --  Note that we know we don't have a Bignum, since Bignums only\n          --  appear in Eliminated mode.\n \n          if Check_Mode = Minimized then\n-            pragma Assert (Lo /= No_Uint);\n             Enable_Overflow_Check (N);\n \n-            --  It's fine to just return here, we may generate an overflow\n-            --  exception, but this is the case in MINIMIZED mode where we\n-            --  can't avoid this possibility.\n-\n-            Apply_Arithmetic_Overflow_Normal (N);\n-            return;\n-\n          --  Otherwise we are in ELIMINATED mode, switch to bignum\n \n          else\n@@ -6721,38 +6785,64 @@ package body Checks is\n                    Name                   => New_Occurrence_Of (Fent, Loc),\n                    Parameter_Associations => Args));\n                Analyze_And_Resolve (N, RTE (RE_Bignum));\n+               return;\n             end;\n          end if;\n \n       --  Otherwise we are in range of Long_Long_Integer, so no overflow\n-      --  check is required, at least not yet. Adjust the operands to\n-      --  Long_Long_Integer and mark the result type as Long_Long_Integer.\n+      --  check is required, at least not yet.\n \n       else\n-         --  Convert right or only operand to Long_Long_Integer, except that\n-         --  we do not touch the exponentiation right operand.\n+         Set_Do_Overflow_Check (N, False);\n+      end if;\n \n-         if Nkind (N) /= N_Op_Expon then\n-            Convert_To_And_Rewrite (LLIB, Right_Opnd (N));\n-         end if;\n+      --  Here we will do the operation in Long_Long_Integer. We do this even\n+      --  if we know an overflow check is required, better to do this in long\n+      --  long integer mode, since we are less likely to overflow!\n \n-         --  Convert left operand to Long_Long_Integer for binary case\n+      --  Convert right or only operand to Long_Long_Integer, except that\n+      --  we do not touch the exponentiation right operand.\n \n-         if Binary then\n-            Convert_To_And_Rewrite (LLIB, Left_Opnd (N));\n-         end if;\n+      if Nkind (N) /= N_Op_Expon then\n+         Convert_To_And_Rewrite (LLIB, Right_Opnd (N));\n+      end if;\n \n-         --  Reset node to unanalyzed\n+      --  Convert left operand to Long_Long_Integer for binary case\n \n-         Set_Analyzed (N, False);\n-         Set_Etype (N, Empty);\n-         Set_Entity (N, Empty);\n-         Set_Do_Overflow_Check (N, False);\n+      if Binary then\n+         Convert_To_And_Rewrite (LLIB, Left_Opnd (N));\n+      end if;\n+\n+      --  Reset node to unanalyzed\n+\n+      Set_Analyzed (N, False);\n+      Set_Etype (N, Empty);\n+      Set_Entity (N, Empty);\n+\n+      --  Now analyze this new node\n \n-         --  Now analyze this new node with checks off (since we know that\n-         --  we do not need an overflow check).\n+      --  If no overflow check, suppress all checks\n \n+      if not Do_Overflow_Check (N) then\n          Analyze_And_Resolve (N, LLIB, Suppress => All_Checks);\n+\n+      --  If an overflow check is required, do it in normal CHECKED mode.\n+      --  That avoids an infinite recursion, makes sure we get a normal\n+      --  overflow check, and also completes expansion of Exponentiation.\n+\n+      else\n+         declare\n+            SG : constant Overflow_Check_Type :=\n+                   Scope_Suppress.Overflow_Checks_General;\n+            SA : constant Overflow_Check_Type :=\n+                   Scope_Suppress.Overflow_Checks_Assertions;\n+         begin\n+            Scope_Suppress.Overflow_Checks_General    := Checked;\n+            Scope_Suppress.Overflow_Checks_Assertions := Checked;\n+            Analyze_And_Resolve (N, LLIB);\n+            Scope_Suppress.Overflow_Checks_General    := SG;\n+            Scope_Suppress.Overflow_Checks_Assertions := SA;\n+         end;\n       end if;\n    end Minimize_Eliminate_Overflow_Checks;\n "}, {"sha": "d87dd8fd34d09ca8c9637152bc4a9f9e4d5e9a10", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=6cb3037c69f90344dd3c5f9504b0a79422932b12", "patch": "@@ -3708,7 +3708,6 @@ package body Exp_Ch4 is\n            (N      => Cnode,\n             Msg    => \"concatenation result upper bound out of range?\",\n             Reason => CE_Range_Check_Failed);\n-         --  Set_Etype (Cnode, Atyp);\n    end Expand_Concatenate;\n \n    ---------------------------------------------------\n@@ -7134,7 +7133,7 @@ package body Exp_Ch4 is\n                 Reason => PE_Unchecked_Union_Restriction));\n \n             --  Prevent Gigi from generating incorrect code by rewriting the\n-            --  equality as a standard False.\n+            --  equality as a standard False. (is this documented somewhere???)\n \n             Rewrite (N,\n               New_Occurrence_Of (Standard_False, Loc));\n@@ -7161,7 +7160,7 @@ package body Exp_Ch4 is\n                    Reason => PE_Unchecked_Union_Restriction));\n \n                --  Prevent Gigi from generating incorrect code by rewriting\n-               --  the equality as a standard False.\n+               --  the equality as a standard False (documented where???).\n \n                Rewrite (N,\n                  New_Occurrence_Of (Standard_False, Loc));\n@@ -7260,6 +7259,23 @@ package body Exp_Ch4 is\n          end;\n       end if;\n \n+      --  Normally we complete expansion of exponentiation (e.g. converting\n+      --  to multplications) right here, but there is one exception to this.\n+      --  If we have a signed integer type and the overflow checking mode\n+      --  is MINIMIZED or ELIMINATED and overflow checking is activated, then\n+      --  we don't yet want to expand, since that will intefere with handling\n+      --  of extended precision intermediate value. In this situation we just\n+      --  apply the arithmetic overflow check, and then the overflow check\n+      --  circuit will re-expand the exponentiation node in CHECKED mode.\n+\n+      if Is_Signed_Integer_Type (Rtyp)\n+        and then Overflow_Check_Mode (Typ) in Minimized_Or_Eliminated\n+        and then Do_Overflow_Check (N)\n+      then\n+         Apply_Arithmetic_Overflow_Check (N);\n+         return;\n+      end if;\n+\n       --  Test for case of known right argument\n \n       if Compile_Time_Known_Value (Exp) then\n@@ -10157,7 +10173,7 @@ package body Exp_Ch4 is\n          then\n             --  To prevent Gigi from generating illegal code, we generate a\n             --  Program_Error node, but we give it the target type of the\n-            --  conversion.\n+            --  conversion (is this requirement documented somewhere ???)\n \n             declare\n                PE : constant Node_Id := Make_Raise_Program_Error (Loc,"}, {"sha": "f8d2132ec1c66f07f20a0c33fc7ba146d3d60abd", "filename": "gcc/ada/s-bignum.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fs-bignum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fs-bignum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-bignum.adb?ref=6cb3037c69f90344dd3c5f9504b0a79422932b12", "patch": "@@ -81,7 +81,7 @@ package body System.Bignums is\n    function Compare\n      (X, Y         : Digit_Vector;\n       X_Neg, Y_Neg : Boolean) return Compare_Result\n-   with Pre => X'First = 1 and then X'Last = 1;\n+   with Pre => X'First = 1 and then Y'First = 1;\n    --  Compare (X with sign X_Neg) with (Y with sign Y_Neg), and return the\n    --  result of the signed comparison.\n "}, {"sha": "017318c80272f934d9e0ae0e5bd812c4e4045525", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cb3037c69f90344dd3c5f9504b0a79422932b12/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6cb3037c69f90344dd3c5f9504b0a79422932b12", "patch": "@@ -7541,16 +7541,38 @@ package body Sem_Ch3 is\n                --  subtype must be statically compatible with the parent\n                --  discriminant's subtype (3.7(15)).\n \n-               if Present (Corresponding_Discriminant (Discrim))\n-                 and then\n-                   not Subtypes_Statically_Compatible\n-                         (Etype (Discrim),\n-                          Etype (Corresponding_Discriminant (Discrim)))\n-               then\n-                  Error_Msg_N\n-                    (\"subtype must be compatible with parent discriminant\",\n-                     Discrim);\n-               end if;\n+               --  However, if the record contains an array constrained by\n+               --  the discriminant but with some different bound, the compiler\n+               --  attemps to create a smaller range for the discriminant type.\n+               --  (See exp_ch3.Adjust_Discriminants). In this case, where\n+               --  the discriminant type is a scalar type, the check must use\n+               --  the original discriminant type in the parent declaration.\n+\n+               declare\n+                  Corr_Disc : constant Entity_Id :=\n+                      Corresponding_Discriminant (Discrim);\n+                  Disc_Type : constant Entity_Id := Etype (Discrim);\n+                  Corr_Type : Entity_Id;\n+\n+               begin\n+                  if Present (Corr_Disc) then\n+                     if Is_Scalar_Type (Disc_Type) then\n+                        Corr_Type :=\n+                           Entity (Discriminant_Type (Parent (Corr_Disc)));\n+                     else\n+                        Corr_Type := Etype (Corr_Disc);\n+                     end if;\n+\n+                     if not\n+                        Subtypes_Statically_Compatible (Disc_Type, Corr_Type)\n+                     then\n+                        Error_Msg_N\n+                          (\"subtype must be compatible \"\n+                           & \"with parent discriminant\",\n+                           Discrim);\n+                     end if;\n+                  end if;\n+               end;\n \n                Next_Discriminant (Discrim);\n             end loop;"}]}