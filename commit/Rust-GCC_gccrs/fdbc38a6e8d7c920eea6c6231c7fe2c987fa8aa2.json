{"sha": "fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRiYzM4YTZlOGQ3YzkyMGVlYTZjNjIzMWM3ZmUyYzk4N2ZhOGFhMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-06-18T23:49:49Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-18T23:49:49Z"}, "message": "compiler, runtime: Use function descriptors.\n\nThis changes the representation of a Go value of function type\nfrom being a pointer to function code (like a C function\npointer) to being a pointer to a struct.  The first field of\nthe struct points to the function code.  The remaining fields,\nif any, are the addresses of variables referenced in enclosing\nfunctions.  For each call to a function, the address of the\nfunction descriptor is passed as the last argument.\n\nThis lets us avoid generating trampolines, and removes the use\nof writable/executable sections of the heap.\n\nFrom-SVN: r200181", "tree": {"sha": "1a7d38cd8be5484451189338ed6f4b76d8521f31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a7d38cd8be5484451189338ed6f4b76d8521f31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/comments", "author": null, "committer": null, "parents": [{"sha": "25e00ab67444a01dce446e95308521d1a73f8232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25e00ab67444a01dce446e95308521d1a73f8232", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25e00ab67444a01dce446e95308521d1a73f8232"}], "stats": {"total": 1406, "additions": 1061, "deletions": 345}, "files": [{"sha": "15df7047cd9267414a4dd60c0beed32768242f13", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -1,3 +1,9 @@\n+2013-06-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::immutable_struct): Add is_hidden\n+\tparameter.\n+\t(Gcc_backend::immutable_struct_set_init): Likewise.\n+\n 2013-05-16  Jason Merrill  <jason@redhat.com>\n \n \t* Make-lang.in (go1$(exeext)): Use link mutex."}, {"sha": "bd2d0dd0829a911f32e48f05587b85457ac49077", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -287,10 +287,10 @@ class Gcc_backend : public Backend\n \t\t     Location, Bstatement**);\n \n   Bvariable*\n-  immutable_struct(const std::string&, bool, Btype*, Location);\n+  immutable_struct(const std::string&, bool, bool, Btype*, Location);\n \n   void\n-  immutable_struct_set_init(Bvariable*, const std::string&, bool, Btype*,\n+  immutable_struct_set_init(Bvariable*, const std::string&, bool, bool, Btype*,\n \t\t\t    Location, Bexpression*);\n \n   Bvariable*\n@@ -1454,8 +1454,8 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n // Create a named immutable initialized data structure.\n \n Bvariable*\n-Gcc_backend::immutable_struct(const std::string& name, bool, Btype* btype,\n-\t\t\t      Location location)\n+Gcc_backend::immutable_struct(const std::string& name, bool, bool,\n+\t\t\t      Btype* btype, Location location)\n {\n   tree type_tree = btype->get_tree();\n   if (type_tree == error_mark_node)\n@@ -1482,7 +1482,7 @@ Gcc_backend::immutable_struct(const std::string& name, bool, Btype* btype,\n \n void\n Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n-\t\t\t\t       bool is_common, Btype*,\n+\t\t\t\t       bool is_hidden, bool is_common, Btype*,\n \t\t\t\t       Location,\n \t\t\t\t       Bexpression* initializer)\n {\n@@ -1495,7 +1495,10 @@ Gcc_backend::immutable_struct_set_init(Bvariable* var, const std::string&,\n \n   // We can't call make_decl_one_only until we set DECL_INITIAL.\n   if (!is_common)\n-    TREE_PUBLIC(decl) = 1;\n+    {\n+      if (!is_hidden)\n+\tTREE_PUBLIC(decl) = 1;\n+    }\n   else\n     {\n       make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));"}, {"sha": "ac29b03e45368bb0195c4a68a1661a5d6ff95249", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -95,7 +95,10 @@ class Backend\n \n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n-  // is provided so that the names are available.\n+  // is provided so that the names are available.  This should return\n+  // not the type of a Go function (which is a pointer to a struct)\n+  // but the type of a C function pointer (which will be used as the\n+  // type of the first field of the struct).\n   virtual Btype*\n   function_type(const Btyped_identifier& receiver,\n \t\tconst std::vector<Btyped_identifier>& parameters,\n@@ -388,18 +391,22 @@ class Backend\n \t\t     Bstatement** pstatement) = 0;\n \n   // Create a named immutable initialized data structure.  This is\n-  // used for type descriptors and map descriptors.  This returns a\n-  // Bvariable because it corresponds to an initialized const global\n-  // variable in C.\n+  // used for type descriptors, map descriptors, and function\n+  // descriptors.  This returns a Bvariable because it corresponds to\n+  // an initialized const variable in C.\n   //\n   // NAME is the name to use for the initialized global variable which\n   // this call will create.\n   //\n+  // IS_HIDDEN will be true if the descriptor should only be visible\n+  // within the current object.\n+  //\n   // IS_COMMON is true if NAME may be defined by several packages, and\n   // the linker should merge all such definitions.  If IS_COMMON is\n   // false, NAME should be defined in only one file.  In general\n   // IS_COMMON will be true for the type descriptor of an unnamed type\n-  // or a builtin type.\n+  // or a builtin type.  IS_HIDDEN and IS_COMMON will never both be\n+  // true.\n   //\n   // TYPE will be a struct type; the type of the returned expression\n   // must be a pointer to this struct type.\n@@ -409,20 +416,20 @@ class Backend\n   // address.  After calling this the frontend will call\n   // immutable_struct_set_init.\n   virtual Bvariable*\n-  immutable_struct(const std::string& name, bool is_common, Btype* type,\n-\t\t   Location) = 0;\n+  immutable_struct(const std::string& name, bool is_hidden, bool is_common,\n+\t\t   Btype* type, Location) = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n-  // The NAME, IS_COMMON, TYPE, and location parameters are the same\n-  // ones passed to immutable_struct.  INITIALIZER will be a composite\n-  // literal of type TYPE.  It will not contain any function calls or\n-  // anything else which can not be put into a read-only data section.\n-  // It may contain the address of variables created by\n+  // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are\n+  // the same ones passed to immutable_struct.  INITIALIZER will be a\n+  // composite literal of type TYPE.  It will not contain any function\n+  // calls or anything else that can not be put into a read-only data\n+  // section.  It may contain the address of variables created by\n   // immutable_struct.\n   virtual void\n   immutable_struct_set_init(Bvariable*, const std::string& name,\n-\t\t\t    bool is_common, Btype* type, Location,\n-\t\t\t    Bexpression* initializer) = 0;\n+\t\t\t    bool is_hidden, bool is_common, Btype* type,\n+\t\t\t    Location, Bexpression* initializer) = 0;\n \n   // Create a reference to a named immutable initialized data\n   // structure defined in some other package.  This will be a"}, {"sha": "9c1efb3e04373a2e240356bd45c722575e2c9924", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 412, "deletions": 93, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -1242,6 +1242,24 @@ Func_expression::do_traverse(Traverse* traverse)\n \t  : Expression::traverse(&this->closure_, traverse));\n }\n \n+// Lower a function reference.  If this reference is not called\n+// directly, make sure there is a function descriptor.\n+\n+Expression*\n+Func_expression::do_lower(Gogo* gogo, Named_object*, Statement_inserter*, int)\n+{\n+  // Make sure that the descriptor exists.  FIXME: If the function is\n+  // only ever called, and is never referenced otherwise, then we\n+  // don't need the descriptor.  We could do that with another pass\n+  // over the tree.\n+  if (this->closure_ == NULL\n+      && this->function_->is_function()\n+      && !this->function_->func_value()->is_method())\n+    this->function_->func_value()->descriptor(gogo, this->function_);\n+\n+  return this;\n+}\n+\n // Return the type of a function expression.\n \n Type*\n@@ -1255,32 +1273,29 @@ Func_expression::do_type()\n     go_unreachable();\n }\n \n-// Get the tree for a function expression without evaluating the\n-// closure.\n+// Get the tree for the code of a function expression.\n \n tree\n-Func_expression::get_tree_without_closure(Gogo* gogo)\n+Func_expression::get_code_pointer(Gogo* gogo, Named_object* no, Location loc)\n {\n   Function_type* fntype;\n-  if (this->function_->is_function())\n-    fntype = this->function_->func_value()->type();\n-  else if (this->function_->is_function_declaration())\n-    fntype = this->function_->func_declaration_value()->type();\n+  if (no->is_function())\n+    fntype = no->func_value()->type();\n+  else if (no->is_function_declaration())\n+    fntype = no->func_declaration_value()->type();\n   else\n     go_unreachable();\n \n   // Builtin functions are handled specially by Call_expression.  We\n   // can't take their address.\n   if (fntype->is_builtin())\n     {\n-      error_at(this->location(),\n+      error_at(loc,\n \t       \"invalid use of special builtin function %qs; must be called\",\n-\t       this->function_->name().c_str());\n+\t       no->message_name().c_str());\n       return error_mark_node;\n     }\n \n-  Named_object* no = this->function_;\n-\n   tree id = no->get_id(gogo);\n   if (id == error_mark_node)\n     return error_mark_node;\n@@ -1296,46 +1311,55 @@ Func_expression::get_tree_without_closure(Gogo* gogo)\n   if (fndecl == error_mark_node)\n     return error_mark_node;\n \n-  return build_fold_addr_expr_loc(this->location().gcc_location(), fndecl);\n+  return build_fold_addr_expr_loc(loc.gcc_location(), fndecl);\n }\n \n // Get the tree for a function expression.  This is used when we take\n-// the address of a function rather than simply calling it.  If the\n-// function has a closure, we must use a trampoline.\n+// the address of a function rather than simply calling it.  A func\n+// value is represented as a pointer to a block of memory.  The first\n+// word of that memory is a pointer to the function code.  The\n+// remaining parts of that memory are the addresses of variables that\n+// the function closes over.\n \n tree\n Func_expression::do_get_tree(Translate_context* context)\n {\n-  Gogo* gogo = context->gogo();\n-\n-  tree fnaddr = this->get_tree_without_closure(gogo);\n-  if (fnaddr == error_mark_node)\n-    return error_mark_node;\n-\n-  go_assert(TREE_CODE(fnaddr) == ADDR_EXPR\n-\t     && TREE_CODE(TREE_OPERAND(fnaddr, 0)) == FUNCTION_DECL);\n-  TREE_ADDRESSABLE(TREE_OPERAND(fnaddr, 0)) = 1;\n-\n-  // If there is no closure, that is all have to do.\n+  // If there is no closure, just use the function descriptor.\n   if (this->closure_ == NULL)\n-    return fnaddr;\n-\n-  go_assert(this->function_->func_value()->enclosing() != NULL);\n+    {\n+      Gogo* gogo = context->gogo();\n+      Named_object* no = this->function_;\n+      Expression* descriptor;\n+      if (no->is_function())\n+\tdescriptor = no->func_value()->descriptor(gogo, no);\n+      else if (no->is_function_declaration())\n+\t{\n+\t  if (no->func_declaration_value()->type()->is_builtin())\n+\t    {\n+\t      error_at(this->location(),\n+\t\t       (\"invalid use of special builtin function %qs; \"\n+\t\t\t\"must be called\"),\n+\t\t       no->message_name().c_str());\n+\t      return error_mark_node;\n+\t    }\n+\t  descriptor = no->func_declaration_value()->descriptor(gogo, no);\n+\t}\n+      else\n+\tgo_unreachable();\n \n-  // Get the value of the closure.  This will be a pointer to space\n-  // allocated on the heap.\n-  tree closure_tree = this->closure_->get_tree(context);\n-  if (closure_tree == error_mark_node)\n-    return error_mark_node;\n-  go_assert(POINTER_TYPE_P(TREE_TYPE(closure_tree)));\n+      tree dtree = descriptor->get_tree(context);\n+      if (dtree == error_mark_node)\n+\treturn error_mark_node;\n+      return build_fold_addr_expr_loc(this->location().gcc_location(), dtree);\n+    }\n \n-  // Now we need to build some code on the heap.  This code will load\n-  // the static chain pointer with the closure and then jump to the\n-  // body of the function.  The normal gcc approach is to build the\n-  // code on the stack.  Unfortunately we can not do that, as Go\n-  // permits us to return the function pointer.\n+  go_assert(this->function_->func_value()->enclosing() != NULL);\n \n-  return gogo->make_trampoline(fnaddr, closure_tree, this->location());\n+  // If there is a closure, then the closure is itself the function\n+  // expression.  It is a pointer to a struct whose first field points\n+  // to the function code and whose remaining fields are the addresses\n+  // of the closed-over variables.\n+  return this->closure_->get_tree(context);\n }\n \n // Ast dump for function.\n@@ -1361,6 +1385,215 @@ Expression::make_func_reference(Named_object* function, Expression* closure,\n   return new Func_expression(function, closure, location);\n }\n \n+// A function descriptor.  A function descriptor is a struct with a\n+// single field pointing to the function code.  This is used for\n+// functions without closures.\n+\n+class Func_descriptor_expression : public Expression\n+{\n+ public:\n+  Func_descriptor_expression(Named_object* fn, Named_object* dfn)\n+    : Expression(EXPRESSION_FUNC_DESCRIPTOR, fn->location()),\n+      fn_(fn), dfn_(dfn), dvar_(NULL)\n+  {\n+    go_assert(!fn->is_function() || !fn->func_value()->needs_closure());\n+  }\n+\n+  // Make the function descriptor type, so that it can be converted.\n+  static void\n+  make_func_descriptor_type();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*)\n+  { return TRAVERSE_CONTINUE; }\n+\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  { return Expression::make_func_descriptor(this->fn_, this->dfn_); }\n+\n+  bool\n+  do_is_addressable() const\n+  { return true; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context* context) const\n+  { context->ostream() << \"[descriptor \" << this->fn_->name() << \"]\"; }\n+\n+ private:\n+  // The type of all function descriptors.\n+  static Type* descriptor_type;\n+\n+  // The function for which this is the descriptor.\n+  Named_object* fn_;\n+  // The descriptor function.\n+  Named_object* dfn_;\n+  // The descriptor variable.\n+  Bvariable* dvar_;\n+};\n+\n+// All function descriptors have the same type.\n+\n+Type* Func_descriptor_expression::descriptor_type;\n+\n+void\n+Func_descriptor_expression::make_func_descriptor_type()\n+{\n+  if (Func_descriptor_expression::descriptor_type != NULL)\n+    return;\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  Type* struct_type = Type::make_builtin_struct_type(1, \"code\", uintptr_type);\n+  Func_descriptor_expression::descriptor_type =\n+    Type::make_builtin_named_type(\"functionDescriptor\", struct_type);\n+}\n+\n+Type*\n+Func_descriptor_expression::do_type()\n+{\n+  Func_descriptor_expression::make_func_descriptor_type();\n+  return Func_descriptor_expression::descriptor_type;\n+}\n+\n+// The tree for a function descriptor.\n+\n+tree\n+Func_descriptor_expression::do_get_tree(Translate_context* context)\n+{\n+  if (this->dvar_ != NULL)\n+    return var_to_tree(this->dvar_);\n+\n+  Gogo* gogo = context->gogo();\n+  Named_object* no = this->fn_;\n+  Location loc = no->location();\n+\n+  std::string var_name;\n+  if (no->package() == NULL)\n+    var_name = gogo->pkgpath_symbol();\n+  else\n+    var_name = no->package()->pkgpath_symbol();\n+  var_name.push_back('.');\n+  var_name.append(Gogo::unpack_hidden_name(no->name()));\n+  var_name.append(\"$descriptor\");\n+\n+  Btype* btype = this->type()->get_backend(gogo);\n+\n+  Bvariable* bvar;\n+  if (no->package() != NULL\n+      || Linemap::is_predeclared_location(no->location()))\n+    {\n+      bvar = context->backend()->immutable_struct_reference(var_name, btype,\n+\t\t\t\t\t\t\t    loc);\n+      go_assert(this->dfn_ == NULL);\n+    }\n+  else\n+    {\n+      Location bloc = Linemap::predeclared_location();\n+      bool is_hidden = ((no->is_function()\n+\t\t\t && no->func_value()->enclosing() != NULL)\n+\t\t\t|| Gogo::is_thunk(no));\n+      bvar = context->backend()->immutable_struct(var_name, is_hidden, false,\n+\t\t\t\t\t\t  btype, bloc);\n+      Expression_list* vals = new Expression_list();\n+      go_assert(this->dfn_ != NULL);\n+      vals->push_back(Expression::make_func_code_reference(this->dfn_, bloc));\n+      Expression* init =\n+\tExpression::make_struct_composite_literal(this->type(), vals, bloc);\n+      Translate_context bcontext(gogo, NULL, NULL, NULL);\n+      bcontext.set_is_const();\n+      Bexpression* binit = tree_to_expr(init->get_tree(&bcontext));\n+      context->backend()->immutable_struct_set_init(bvar, var_name, is_hidden,\n+\t\t\t\t\t\t    false, btype, bloc, binit);\n+    }\n+\n+  this->dvar_ = bvar;\n+  return var_to_tree(bvar);\n+}\n+\n+// Make a function descriptor expression.\n+\n+Expression*\n+Expression::make_func_descriptor(Named_object* fn, Named_object* dfn)\n+{\n+  return new Func_descriptor_expression(fn, dfn);\n+}\n+\n+// Make the function descriptor type, so that it can be converted.\n+\n+void\n+Expression::make_func_descriptor_type()\n+{\n+  Func_descriptor_expression::make_func_descriptor_type();\n+}\n+\n+// A reference to just the code of a function.\n+\n+class Func_code_reference_expression : public Expression\n+{\n+ public:\n+  Func_code_reference_expression(Named_object* function, Location location)\n+    : Expression(EXPRESSION_FUNC_CODE_REFERENCE, location),\n+      function_(function)\n+  { }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*)\n+  { return TRAVERSE_CONTINUE; }\n+\n+  Type*\n+  do_type()\n+  { return Type::make_pointer_type(Type::make_void_type()); }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return Expression::make_func_code_reference(this->function_,\n+\t\t\t\t\t\tthis->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+  void\n+  do_dump_expression(Ast_dump_context* context) const\n+  { context->ostream() << \"[raw \" << this->function_->name() << \"]\" ; }\n+\n+ private:\n+  // The function.\n+  Named_object* function_;\n+};\n+\n+// Get the tree for a reference to function code.\n+\n+tree\n+Func_code_reference_expression::do_get_tree(Translate_context* context)\n+{\n+  return Func_expression::get_code_pointer(context->gogo(), this->function_,\n+\t\t\t\t\t   this->location());\n+}\n+\n+// Make a reference to the code of a function.\n+\n+Expression*\n+Expression::make_func_code_reference(Named_object* function, Location location)\n+{\n+  return new Func_code_reference_expression(function, location);\n+}\n+\n // Class Unknown_expression.\n \n // Return the name of an unknown expression.\n@@ -8521,6 +8754,74 @@ Builtin_call_expression::do_export(Export* exp) const\n \n // Class Call_expression.\n \n+// A Go function can be viewed in a couple of different ways.  The\n+// code of a Go function becomes a backend function with parameters\n+// whose types are simply the backend representation of the Go types.\n+// If there are multiple results, they are returned as a backend\n+// struct.\n+\n+// However, when Go code refers to a function other than simply\n+// calling it, the backend type of that function is actually a struct.\n+// The first field of the struct points to the Go function code\n+// (sometimes a wrapper as described below).  The remaining fields\n+// hold addresses of closed-over variables.  This struct is called a\n+// closure.\n+\n+// There are a few cases to consider.\n+\n+// A direct function call of a known function in package scope.  In\n+// this case there are no closed-over variables, and we know the name\n+// of the function code.  We can simply produce a backend call to the\n+// function directly, and not worry about the closure.\n+\n+// A direct function call of a known function literal.  In this case\n+// we know the function code and we know the closure.  We generate the\n+// function code such that it expects an additional final argument of\n+// the closure type.  We pass the closure as the last argument, after\n+// the other arguments.\n+\n+// An indirect function call.  In this case we have a closure.  We\n+// load the pointer to the function code from the first field of the\n+// closure.  We pass the address of the closure as the last argument.\n+\n+// A call to a method of an interface.  Type methods are always at\n+// package scope, so we call the function directly, and don't worry\n+// about the closure.\n+\n+// This means that for a function at package scope we have two cases.\n+// One is the direct call, which has no closure.  The other is the\n+// indirect call, which does have a closure.  We can't simply ignore\n+// the closure, even though it is the last argument, because that will\n+// fail on targets where the function pops its arguments.  So when\n+// generating a closure for a package-scope function we set the\n+// function code pointer in the closure to point to a wrapper\n+// function.  This wrapper function accepts a final argument that\n+// points to the closure, ignores it, and calls the real function as a\n+// direct function call.  This wrapper will normally be efficient, and\n+// can often simply be a tail call to the real function.\n+\n+// We don't use GCC's static chain pointer because 1) we don't need\n+// it; 2) GCC only permits using a static chain to call a known\n+// function, so we can't use it for an indirect call anyhow.  Since we\n+// can't use it for an indirect call, we may as well not worry about\n+// using it for a direct call either.\n+\n+// We pass the closure last rather than first because it means that\n+// the function wrapper we put into a closure for a package-scope\n+// function can normally just be a tail call to the real function.\n+\n+// For method expressions we generate a wrapper that loads the\n+// receiver from the closure and then calls the method.  This\n+// unfortunately forces reshuffling the arguments, since there is a\n+// new first argument, but we can't avoid reshuffling either for\n+// method expressions or for indirect calls of package-scope\n+// functions, and since the latter are more common we reshuffle for\n+// method expressions.\n+\n+// Note that the Go code retains the Go types.  The extra final\n+// argument only appears when we convert to the backend\n+// representation.\n+\n // Traversal.\n \n int\n@@ -9129,11 +9430,21 @@ Call_expression::do_get_tree(Translate_context* context)\n   const bool has_closure = func != NULL && func->closure() != NULL;\n   const bool is_interface_method = interface_method != NULL;\n \n+  int closure_arg;\n+  if (has_closure)\n+    closure_arg = 1;\n+  else if (func != NULL)\n+    closure_arg = 0;\n+  else if (is_interface_method)\n+    closure_arg = 0;\n+  else\n+    closure_arg = 1;\n+\n   int nargs;\n   tree* args;\n   if (this->args_ == NULL || this->args_->empty())\n     {\n-      nargs = is_interface_method ? 1 : 0;\n+      nargs = (is_interface_method ? 1 : 0) + closure_arg;\n       args = nargs == 0 ? NULL : new tree[nargs];\n     }\n   else if (fntype->parameters() == NULL || fntype->parameters()->empty())\n@@ -9142,7 +9453,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       go_assert(!is_interface_method\n \t\t&& fntype->is_method()\n \t\t&& this->args_->size() == 1);\n-      nargs = 1;\n+      nargs = 1 + closure_arg;\n       args = new tree[nargs];\n       args[0] = this->args_->front()->get_tree(context);\n     }\n@@ -9153,6 +9464,7 @@ Call_expression::do_get_tree(Translate_context* context)\n       nargs = this->args_->size();\n       int i = is_interface_method ? 1 : 0;\n       nargs += i;\n+      nargs += closure_arg;\n       args = new tree[nargs];\n \n       Typed_identifier_list::const_iterator pp = params->begin();\n@@ -9173,49 +9485,79 @@ Call_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t\t       arg_val,\n \t\t\t\t\t\t       location);\n \t  if (args[i] == error_mark_node)\n-\t    {\n-\t      delete[] args;\n-\t      return error_mark_node;\n-\t    }\n+\t    return error_mark_node;\n \t}\n       go_assert(pp == params->end());\n-      go_assert(i == nargs);\n+      go_assert(i + closure_arg == nargs);\n     }\n \n-  tree rettype = TREE_TYPE(TREE_TYPE(type_to_tree(fntype->get_backend(gogo))));\n+  tree fntype_tree = type_to_tree(fntype->get_backend(gogo));\n+  if (fntype_tree == error_mark_node)\n+    return error_mark_node;\n+  go_assert(POINTER_TYPE_P(fntype_tree));\n+  if (TREE_TYPE(fntype_tree) == error_mark_node)\n+    return error_mark_node;\n+  go_assert(TREE_CODE(TREE_TYPE(fntype_tree)) == RECORD_TYPE);\n+  tree fnfield_type = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(fntype_tree)));\n+  if (fnfield_type == error_mark_node)\n+    return error_mark_node;\n+  go_assert(FUNCTION_POINTER_TYPE_P(fnfield_type));\n+  tree rettype = TREE_TYPE(TREE_TYPE(fnfield_type));\n   if (rettype == error_mark_node)\n-    {\n-      delete[] args;\n-      return error_mark_node;\n-    }\n+    return error_mark_node;\n \n   tree fn;\n-  if (has_closure)\n-    fn = func->get_tree_without_closure(gogo);\n+  if (func != NULL)\n+    {\n+      Named_object* no = func->named_object();\n+      go_assert(!no->is_function()\n+\t\t|| !no->func_value()->is_descriptor_wrapper());\n+      fn = Func_expression::get_code_pointer(gogo, no, location);\n+      if (has_closure)\n+\t{\n+\t  go_assert(closure_arg == 1 && nargs > 0);\n+\t  args[nargs - 1] = func->closure()->get_tree(context);\n+\t}\n+    }\n   else if (!is_interface_method)\n-    fn = this->fn_->get_tree(context);\n+    {\n+      tree closure_tree = this->fn_->get_tree(context);\n+      if (closure_tree == error_mark_node)\n+\treturn error_mark_node;\n+      tree fnc = fold_convert_loc(location.gcc_location(), fntype_tree,\n+\t\t\t\t  closure_tree);\n+      go_assert(POINTER_TYPE_P(TREE_TYPE(fnc))\n+\t\t&& (TREE_CODE(TREE_TYPE(TREE_TYPE(fnc)))\n+\t\t    == RECORD_TYPE));\n+      tree field = TYPE_FIELDS(TREE_TYPE(TREE_TYPE(fnc)));\n+      fn = fold_build3_loc(location.gcc_location(), COMPONENT_REF,\n+\t\t\t   TREE_TYPE(field),\n+\t\t\t   build_fold_indirect_ref_loc(location.gcc_location(),\n+\t\t\t\t\t\t       fnc),\n+\t\t\t   field, NULL_TREE);\n+      go_assert(closure_arg == 1 && nargs > 0);\n+      args[nargs - 1] = closure_tree;\n+    }      \n   else\n-    fn = this->interface_method_function(context, interface_method, &args[0]);\n-\n-  if (fn == error_mark_node || TREE_TYPE(fn) == error_mark_node)\n     {\n-      delete[] args;\n-      return error_mark_node;\n+      fn = this->interface_method_function(context, interface_method,\n+\t\t\t\t\t   &args[0]);\n+      if (fn == error_mark_node)\n+\treturn error_mark_node;\n+      go_assert(closure_arg == 0);\n     }\n \n+  if (fn == error_mark_node || TREE_TYPE(fn) == error_mark_node)\n+    return error_mark_node;\n+\n   tree fndecl = fn;\n   if (TREE_CODE(fndecl) == ADDR_EXPR)\n     fndecl = TREE_OPERAND(fndecl, 0);\n \n   // Add a type cast in case the type of the function is a recursive\n   // type which refers to itself.\n   if (!DECL_P(fndecl) || !DECL_IS_BUILTIN(fndecl))\n-    {\n-      tree fnt = type_to_tree(fntype->get_backend(gogo));\n-      if (fnt == error_mark_node)\n-\treturn error_mark_node;\n-      fn = fold_convert_loc(location.gcc_location(), fnt, fn);\n-    }\n+    fn = fold_convert_loc(location.gcc_location(), fnfield_type, fn);\n \n   // This is to support builtin math functions when using 80387 math.\n   tree excess_type = NULL_TREE;\n@@ -9259,13 +9601,6 @@ Call_expression::do_get_tree(Translate_context* context)\n \n   SET_EXPR_LOCATION(ret, location.gcc_location());\n \n-  if (has_closure)\n-    {\n-      tree closure_tree = func->closure()->get_tree(context);\n-      if (closure_tree != error_mark_node)\n-\tCALL_EXPR_STATIC_CHAIN(ret) = closure_tree;\n-    }\n-\n   // If this is a recursive function type which returns itself, as in\n   //   type F func() F\n   // we have used ptr_type_node for the return type.  Add a cast here\n@@ -9286,24 +9621,6 @@ Call_expression::do_get_tree(Translate_context* context)\n   if (this->results_ != NULL)\n     ret = this->set_results(context, ret);\n \n-  // We can't unwind the stack past a call to nil, so we need to\n-  // insert an explicit check so that the panic can be recovered.\n-  if (func == NULL)\n-    {\n-      tree compare = fold_build2_loc(location.gcc_location(), EQ_EXPR,\n-\t\t\t\t     boolean_type_node, fn,\n-\t\t\t\t     fold_convert_loc(location.gcc_location(),\n-\t\t\t\t\t\t      TREE_TYPE(fn),\n-\t\t\t\t\t\t      null_pointer_node));\n-      tree crash = build3_loc(location.gcc_location(), COND_EXPR,\n-\t\t\t      void_type_node, compare,\n-\t\t\t      gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE,\n-\t\t\t\t\t\t  location),\n-\t\t\t      NULL_TREE);\n-      ret = fold_build2_loc(location.gcc_location(), COMPOUND_EXPR,\n-\t\t\t    TREE_TYPE(ret), crash, ret);\n-    }\n-\n   this->tree_ = ret;\n \n   return ret;\n@@ -11126,8 +11443,10 @@ Selector_expression::lower_method_expression(Gogo* gogo)\n   // as their first argument.  If this is for a pointer type, we can\n   // simply reuse the existing function.  We use an internal hack to\n   // get the right type.\n-\n-  if (method != NULL && is_pointer)\n+  // FIXME: This optimization is disabled because it doesn't yet work\n+  // with function descriptors when the method expression is not\n+  // directly called.\n+  if (method != NULL && is_pointer && false)\n     {\n       Named_object* mno = (method->needs_stub_method()\n \t\t\t   ? method->stub_object()"}, {"sha": "ed3909c1bc132cf5b2bf319d5834d36f89595afa", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -67,6 +67,8 @@ class Expression\n     EXPRESSION_SET_AND_USE_TEMPORARY,\n     EXPRESSION_SINK,\n     EXPRESSION_FUNC_REFERENCE,\n+    EXPRESSION_FUNC_DESCRIPTOR,\n+    EXPRESSION_FUNC_CODE_REFERENCE,\n     EXPRESSION_UNKNOWN_REFERENCE,\n     EXPRESSION_BOOLEAN,\n     EXPRESSION_STRING,\n@@ -150,10 +152,25 @@ class Expression\n   static Expression*\n   make_sink(Location);\n \n-  // Make a reference to a function in an expression.\n+  // Make a reference to a function in an expression.  This returns a\n+  // pointer to the struct holding the address of the function\n+  // followed by any closed-over variables.\n   static Expression*\n   make_func_reference(Named_object*, Expression* closure, Location);\n \n+  // Make a function descriptor, an immutable struct with a single\n+  // field that points to the function code.  This may only be used\n+  // with functions that do not have closures.  FN is the function for\n+  // which we are making the descriptor.  DFN is the descriptor\n+  // function wrapper.\n+  static Expression*\n+  make_func_descriptor(Named_object* fn, Named_object* dfn);\n+\n+  // Make a reference to the code of a function.  This is used to set\n+  // descriptor and closure fields.\n+  static Expression*\n+  make_func_code_reference(Named_object*, Location);\n+\n   // Make a reference to an unknown name.  In a correct program this\n   // will always be lowered to a real const/var/func reference.\n   static Unknown_expression*\n@@ -523,6 +540,11 @@ class Expression\n   bool\n   is_local_variable() const;\n \n+  // Make the builtin function descriptor type, so that it can be\n+  // converted.\n+  static void\n+  make_func_descriptor_type();\n+\n   // Traverse an expression.\n   static int\n   traverse(Expression**, Traverse*);\n@@ -1484,7 +1506,7 @@ class Func_expression : public Expression\n   { }\n \n   // Return the object associated with the function.\n-  const Named_object*\n+  Named_object*\n   named_object() const\n   { return this->function_; }\n \n@@ -1494,14 +1516,17 @@ class Func_expression : public Expression\n   closure()\n   { return this->closure_; }\n \n-  // Return a tree for this function without evaluating the closure.\n-  tree\n-  get_tree_without_closure(Gogo*);\n+  // Return a tree for the code for a function.\n+  static tree\n+  get_code_pointer(Gogo*, Named_object* function, Location loc);\n \n  protected:\n   int\n   do_traverse(Traverse*);\n \n+  Expression*\n+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n+\n   Type*\n   do_type();\n \n@@ -1532,8 +1557,8 @@ class Func_expression : public Expression\n   // The function itself.\n   Named_object* function_;\n   // A closure.  This is normally NULL.  For a nested function, it may\n-  // be a heap-allocated struct holding pointers to all the variables\n-  // referenced by this function and defined in enclosing functions.\n+  // be a struct holding pointers to all the variables referenced by\n+  // this function and defined in enclosing functions.\n   Expression* closure_;\n };\n "}, {"sha": "cd54f2bdeed83f8c1395ca74b7302a795b5fa711", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 131, "deletions": 101, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -755,6 +755,18 @@ Gogo::write_globals()\n   this->build_interface_method_tables();\n \n   Bindings* bindings = this->current_bindings();\n+\n+  for (Bindings::const_declarations_iterator p = bindings->begin_declarations();\n+       p != bindings->end_declarations();\n+       ++p)\n+    {\n+      // If any function declarations needed a descriptor, make sure\n+      // we build it.\n+      Named_object* no = p->second;\n+      if (no->is_function_declaration())\n+\tno->func_declaration_value()->build_backend_descriptor(this);\n+    }\n+\n   size_t count_definitions = bindings->size_definitions();\n   size_t count = count_definitions;\n \n@@ -782,6 +794,8 @@ Gogo::write_globals()\n     {\n       Named_object* no = *p;\n \n+      go_assert(i < count);\n+\n       go_assert(!no->is_type_declaration() && !no->is_function_declaration());\n       // There is nothing to do for a package.\n       if (no->is_package())\n@@ -1255,14 +1269,47 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n   if (this->fndecl_ == NULL_TREE)\n     {\n       tree functype = type_to_tree(this->type_->get_backend(gogo));\n+\n+      if (functype != error_mark_node)\n+\t{\n+\t  // The type of a function comes back as a pointer to a\n+\t  // struct whose first field is the function, but we want the\n+\t  // real function type for a function declaration.\n+\t  go_assert(POINTER_TYPE_P(functype)\n+\t\t    && TREE_CODE(TREE_TYPE(functype)) == RECORD_TYPE);\n+\t  functype = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(functype)));\n+\t  go_assert(FUNCTION_POINTER_TYPE_P(functype));\n+\t  functype = TREE_TYPE(functype);\n+\n+\t  // In the struct, the function type always has a trailing\n+\t  // closure argument.  For the function body, we only use\n+\t  // that trailing arg if this is a function literal or if it\n+\t  // is a wrapper created to store in a descriptor.  Remove it\n+\t  // in that case.\n+\t  if (this->enclosing_ == NULL && !this->is_descriptor_wrapper_)\n+\t    {\n+\t      tree old_params = TYPE_ARG_TYPES(functype);\n+\t      go_assert(old_params != NULL_TREE\n+\t\t\t&& old_params != void_list_node);\n+\t      tree new_params = NULL_TREE;\n+\t      tree *pp = &new_params;\n+\t      while (TREE_CHAIN (old_params) != void_list_node)\n+\t\t{\n+\t\t  tree p = TREE_VALUE(old_params);\n+\t\t  go_assert(TYPE_P(p));\n+\t\t  *pp = tree_cons(NULL_TREE, p, NULL_TREE);\n+\t\t  pp = &TREE_CHAIN(*pp);\n+\t\t  old_params = TREE_CHAIN (old_params);\n+\t\t}\n+\t      *pp = void_list_node;\n+\t      functype = build_function_type(TREE_TYPE(functype), new_params);\n+\t    }\n+\t}\n+\n       if (functype == error_mark_node)\n \tthis->fndecl_ = error_mark_node;\n       else\n \t{\n-\t  // The type of a function comes back as a pointer, but we\n-\t  // want the real function type for a function declaration.\n-\t  go_assert(POINTER_TYPE_P(functype));\n-\t  functype = TREE_TYPE(functype);\n \t  tree decl = build_decl(this->location().gcc_location(), FUNCTION_DECL,\n                                  id, functype);\n \n@@ -1308,9 +1355,6 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t  DECL_CONTEXT(resdecl) = decl;\n \t  DECL_RESULT(decl) = resdecl;\n \n-\t  if (this->enclosing_ != NULL)\n-\t    DECL_STATIC_CHAIN(decl) = 1;\n-\n \t  // If a function calls the predeclared recover function, we\n \t  // can't inline it, because recover behaves differently in a\n \t  // function passed directly to defer.  If this is a recover\n@@ -1333,29 +1377,6 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t    resolve_unique_section (decl, 0, 1);\n \n \t  go_preserve_from_gc(decl);\n-\n-\t  if (this->closure_var_ != NULL)\n-\t    {\n-\t      push_struct_function(decl);\n-\n-\t      Bvariable* bvar = this->closure_var_->get_backend_variable(gogo,\n-\t\t\t\t\t\t\t\t\t no);\n-\t      tree closure_decl = var_to_tree(bvar);\n-\t      if (closure_decl == error_mark_node)\n-\t\tthis->fndecl_ = error_mark_node;\n-\t      else\n-\t\t{\n-\t\t  DECL_ARTIFICIAL(closure_decl) = 1;\n-\t\t  DECL_IGNORED_P(closure_decl) = 1;\n-\t\t  TREE_USED(closure_decl) = 1;\n-\t\t  DECL_ARG_TYPE(closure_decl) = TREE_TYPE(closure_decl);\n-\t\t  TREE_READONLY(closure_decl) = 1;\n-\n-\t\t  DECL_STRUCT_FUNCTION(decl)->static_chain_decl = closure_decl;\n-\t\t}\n-\n-\t      pop_cfun();\n-\t    }\n \t}\n     }\n   return this->fndecl_;\n@@ -1382,15 +1403,44 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n \t}\n \n       tree functype = type_to_tree(this->fntype_->get_backend(gogo));\n+\n+      if (functype != error_mark_node)\n+\t{\n+\t  // The type of a function comes back as a pointer to a\n+\t  // struct whose first field is the function, but we want the\n+\t  // real function type for a function declaration.\n+\t  go_assert(POINTER_TYPE_P(functype)\n+\t\t    && TREE_CODE(TREE_TYPE(functype)) == RECORD_TYPE);\n+\t  functype = TREE_TYPE(TYPE_FIELDS(TREE_TYPE(functype)));\n+\t  go_assert(FUNCTION_POINTER_TYPE_P(functype));\n+\t  functype = TREE_TYPE(functype);\n+\n+\t  // In the struct, the function type always has a trailing\n+\t  // closure argument.  Here we are referring to the function\n+\t  // code directly, and we know it is not a function literal,\n+\t  // and we know it is not a wrapper created to store in a\n+\t  // descriptor.  Remove that trailing argument.\n+\t  tree old_params = TYPE_ARG_TYPES(functype);\n+\t  go_assert(old_params != NULL_TREE && old_params != void_list_node);\n+\t  tree new_params = NULL_TREE;\n+\t  tree *pp = &new_params;\n+\t  while (TREE_CHAIN (old_params) != void_list_node)\n+\t    {\n+\t      tree p = TREE_VALUE(old_params);\n+\t      go_assert(TYPE_P(p));\n+\t      *pp = tree_cons(NULL_TREE, p, NULL_TREE);\n+\t      pp = &TREE_CHAIN(*pp);\n+\t      old_params = TREE_CHAIN (old_params);\n+\t    }\n+\t  *pp = void_list_node;\n+\t  functype = build_function_type(TREE_TYPE(functype), new_params);\n+\t}\n+\n       tree decl;\n       if (functype == error_mark_node)\n \tdecl = error_mark_node;\n       else\n \t{\n-\t  // The type of a function comes back as a pointer, but we\n-\t  // want the real function type for a function declaration.\n-\t  go_assert(POINTER_TYPE_P(functype));\n-\t  functype = TREE_TYPE(functype);\n \t  decl = build_decl(this->location().gcc_location(), FUNCTION_DECL, id,\n                             functype);\n \t  TREE_PUBLIC(decl) = 1;\n@@ -1599,6 +1649,32 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \t    }\n \t}\n     }\n+\n+  // The closure variable is passed last, if this is a function\n+  // literal or a descriptor wrapper.\n+  if (this->closure_var_ != NULL)\n+    {\n+      Bvariable* bvar =\n+\tthis->closure_var_->get_backend_variable(gogo, named_function);\n+      tree var_decl = var_to_tree(bvar);\n+      if (var_decl != error_mark_node)\n+\t{\n+\t  go_assert(TREE_CODE(var_decl) == PARM_DECL);\n+\t  *pp = var_decl;\n+\t  pp = &DECL_CHAIN(*pp);\n+\t}\n+    }\n+  else if (this->enclosing_ != NULL || this->is_descriptor_wrapper_)\n+    {\n+      tree parm_decl = build_decl(this->location_.gcc_location(), PARM_DECL,\n+\t\t\t\t  get_identifier(\"$closure\"),\n+\t\t\t\t  const_ptr_type_node);\n+      DECL_CONTEXT(parm_decl) = current_function_decl;\n+      DECL_ARG_TYPE(parm_decl) = const_ptr_type_node;\n+      *pp = parm_decl;\n+      pp = &DECL_CHAIN(*pp);\n+    }\n+\n   *pp = NULL_TREE;\n \n   DECL_ARGUMENTS(fndecl) = params;\n@@ -1681,6 +1757,13 @@ Function::build_tree(Gogo* gogo, Named_object* named_function)\n \n       DECL_SAVED_TREE(fndecl) = code;\n     }\n+\n+  // If we created a descriptor for the function, make sure we emit it.\n+  if (this->descriptor_ != NULL)\n+    {\n+      Translate_context context(gogo, NULL, NULL, NULL);\n+      this->descriptor_->get_tree(&context);\n+    }\n }\n \n // Build the wrappers around function code needed if the function has\n@@ -1844,6 +1927,20 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n     }\n }\n \n+// Build the descriptor for a function declaration.  This won't\n+// necessarily happen if the package has just a declaration for the\n+// function and no other reference to it, but we may still need the\n+// descriptor for references from other packages.\n+void\n+Function_declaration::build_backend_descriptor(Gogo* gogo)\n+{\n+  if (this->descriptor_ != NULL)\n+    {\n+      Translate_context context(gogo, NULL, NULL, NULL);\n+      this->descriptor_->get_tree(&context);\n+    }\n+}\n+\n // Return the integer type to use for a size.\n \n GO_EXTERN_C\n@@ -2437,70 +2534,3 @@ Gogo::receive_from_channel(tree type_tree, tree type_descriptor_tree,\n \t\t    build2(COMPOUND_EXPR, type_tree, call, tmp));\n     }\n }\n-\n-// Return the type of a function trampoline.  This is like\n-// get_trampoline_type in tree-nested.c.\n-\n-tree\n-Gogo::trampoline_type_tree()\n-{\n-  static tree type_tree;\n-  if (type_tree == NULL_TREE)\n-    {\n-      unsigned int size;\n-      unsigned int align;\n-      go_trampoline_info(&size, &align);\n-      tree t = build_index_type(build_int_cst(integer_type_node, size - 1));\n-      t = build_array_type(char_type_node, t);\n-\n-      type_tree = Gogo::builtin_struct(NULL, \"__go_trampoline\", NULL_TREE, 1,\n-\t\t\t\t       \"__data\", t);\n-      t = TYPE_FIELDS(type_tree);\n-      DECL_ALIGN(t) = align;\n-      DECL_USER_ALIGN(t) = 1;\n-\n-      go_preserve_from_gc(type_tree);\n-    }\n-  return type_tree;\n-}\n-\n-// Make a trampoline which calls FNADDR passing CLOSURE.\n-\n-tree\n-Gogo::make_trampoline(tree fnaddr, tree closure, Location location)\n-{\n-  tree trampoline_type = Gogo::trampoline_type_tree();\n-  tree trampoline_size = TYPE_SIZE_UNIT(trampoline_type);\n-\n-  closure = save_expr(closure);\n-\n-  // We allocate the trampoline using a special function which will\n-  // mark it as executable.\n-  static tree trampoline_fndecl;\n-  tree x = Gogo::call_builtin(&trampoline_fndecl,\n-\t\t\t      location,\n-\t\t\t      \"__go_allocate_trampoline\",\n-\t\t\t      2,\n-\t\t\t      ptr_type_node,\n-\t\t\t      size_type_node,\n-\t\t\t      trampoline_size,\n-\t\t\t      ptr_type_node,\n-\t\t\t      fold_convert_loc(location.gcc_location(),\n-                                               ptr_type_node, closure));\n-  if (x == error_mark_node)\n-    return error_mark_node;\n-\n-  x = save_expr(x);\n-\n-  // Initialize the trampoline.\n-  tree calldecl = builtin_decl_implicit(BUILT_IN_INIT_HEAP_TRAMPOLINE);\n-  tree ini = build_call_expr(calldecl, 3, x, fnaddr, closure);\n-\n-  // On some targets the trampoline address needs to be adjusted.  For\n-  // example, when compiling in Thumb mode on the ARM, the address\n-  // needs to have the low bit set.\n-  x = build_call_expr(builtin_decl_explicit(BUILT_IN_ADJUST_TRAMPOLINE), 1, x);\n-  x = fold_convert(TREE_TYPE(fnaddr), x);\n-\n-  return build2(COMPOUND_EXPR, TREE_TYPE(x), ini, x);\n-}"}, {"sha": "e4c21be2ddaa4ba785a797359dd6fc5c413fcf2e", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 209, "deletions": 5, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -364,7 +364,7 @@ Gogo::set_package_name(const std::string& package_name,\n       // Declare \"main\" as a function which takes no parameters and\n       // returns no value.\n       Location uloc = Linemap::unknown_location();\n-      this->declare_function(\"main\",\n+      this->declare_function(Gogo::pack_hidden_name(\"main\", false),\n \t\t\t     Type::make_function_type (NULL, NULL, NULL, uloc),\n \t\t\t     uloc);\n     }\n@@ -1599,14 +1599,23 @@ Lower_parse_tree::constant(Named_object* no, bool)\n   return TRAVERSE_CONTINUE;\n }\n \n-// Lower function closure types.  Record the function while lowering\n-// it, so that we can pass it down when lowering an expression.\n+// Lower the body of a function, and set the closure type.  Record the\n+// function while lowering it, so that we can pass it down when\n+// lowering an expression.\n \n int\n Lower_parse_tree::function(Named_object* no)\n {\n   no->func_value()->set_closure_type();\n \n+  // Make sure that every externally visible function has a\n+  // descriptor, so that packages that import this one can refer to\n+  // it.\n+  if (!Gogo::is_hidden_name(no->name())\n+      && !no->func_value()->is_method()\n+      && !no->func_value()->is_descriptor_wrapper())\n+    no->func_value()->descriptor(this->gogo_, no);\n+\n   go_assert(this->function_ == NULL);\n   this->function_ = no;\n   int t = no->func_value()->traverse(this);\n@@ -1694,6 +1703,28 @@ Lower_parse_tree::expression(Expression** pexpr)\n void\n Gogo::lower_parse_tree()\n {\n+  // Create a function descriptor for any function that is declared in\n+  // this package.  This is so that we have a descriptor for functions\n+  // written in assembly.  Gather the descriptors first so that we\n+  // don't add declarations while looping over them.\n+  std::vector<Named_object*> fndecls;\n+  Bindings* b = this->package_->bindings();\n+  for (Bindings::const_declarations_iterator p = b->begin_declarations();\n+       p != b->end_declarations();\n+       ++p)\n+    {\n+      Named_object* no = p->second;\n+      if (no->is_function_declaration()\n+\t  && !no->func_declaration_value()->type()->is_method()\n+\t  && !Linemap::is_predeclared_location(no->location()))\n+\tfndecls.push_back(no);\n+    }\n+  for (std::vector<Named_object*>::const_iterator p = fndecls.begin();\n+       p != fndecls.end();\n+       ++p)\n+    (*p)->func_declaration_value()->descriptor(this, *p);\n+  fndecls.clear();\n+\n   Lower_parse_tree lower_parse_tree(this, NULL);\n   this->traverse(&lower_parse_tree);\n }\n@@ -2643,6 +2674,13 @@ Build_recover_thunks::function(Named_object* orig_no)\n   Expression* closure = NULL;\n   if (orig_func->needs_closure())\n     {\n+      // For the new function we are creating, declare a new parameter\n+      // variable NEW_CLOSURE_NO and set it to be the closure variable\n+      // of the function.  This will be set to the closure value\n+      // passed in by the caller.  Then pass a reference to this\n+      // variable as the closure value when calling the original\n+      // function.  In other words, simply pass the closure value\n+      // through the thunk we are creating.\n       Named_object* orig_closure_no = orig_func->closure_var();\n       Variable* orig_closure_var = orig_closure_no->var_value();\n       Variable* new_var = new Variable(orig_closure_var->type(), NULL, false,\n@@ -3101,6 +3139,7 @@ Gogo::convert_named_types()\n   Map_type::make_map_descriptor_type();\n   Channel_type::make_chan_type_descriptor_type();\n   Interface_type::make_interface_type_descriptor_type();\n+  Expression::make_func_descriptor_type();\n   Type::convert_builtin_named_types(this);\n \n   Runtime::convert_types(this);\n@@ -3128,10 +3167,10 @@ Function::Function(Function_type* type, Function* enclosing, Block* block,\n \t\t   Location location)\n   : type_(type), enclosing_(enclosing), results_(NULL),\n     closure_var_(NULL), block_(block), location_(location), labels_(),\n-    local_type_count_(0), fndecl_(NULL), defer_stack_(NULL),\n+    local_type_count_(0), descriptor_(NULL), fndecl_(NULL), defer_stack_(NULL),\n     results_are_named_(false), nointerface_(false), calls_recover_(false),\n     is_recover_thunk_(false), has_recover_thunk_(false),\n-    in_unique_section_(false)\n+    in_unique_section_(false), is_descriptor_wrapper_(false)\n {\n }\n \n@@ -3206,6 +3245,7 @@ Function::closure_var()\n {\n   if (this->closure_var_ == NULL)\n     {\n+      go_assert(this->descriptor_ == NULL);\n       // We don't know the type of the variable yet.  We add fields as\n       // we find them.\n       Location loc = this->type_->location();\n@@ -3229,6 +3269,13 @@ Function::set_closure_type()\n     return;\n   Named_object* closure = this->closure_var_;\n   Struct_type* st = closure->var_value()->type()->deref()->struct_type();\n+\n+  // The first field of a closure is always a pointer to the function\n+  // code.\n+  Type* voidptr_type = Type::make_pointer_type(Type::make_void_type());\n+  st->push_field(Struct_field(Typed_identifier(\".$f\", voidptr_type,\n+\t\t\t\t\t       this->location_)));\n+\n   unsigned int index = 0;\n   for (Closure_fields::const_iterator p = this->closure_fields_.begin();\n        p != this->closure_fields_.end();\n@@ -3410,6 +3457,136 @@ Function::determine_types()\n     this->block_->determine_types();\n }\n \n+// Build a wrapper function for a function descriptor.  A function\n+// descriptor refers to a function that takes a closure as its last\n+// argument.  In this case there will be no closure, but an indirect\n+// call will pass nil as the last argument.  We need to build a\n+// wrapper function that accepts and discards that last argument, so\n+// that cases like -mrtd will work correctly.  In most cases the\n+// wrapper function will simply be a jump.\n+\n+Named_object*\n+Function::make_descriptor_wrapper(Gogo* gogo, Named_object* no,\n+\t\t\t\t  Function_type* orig_fntype)\n+{\n+  Location loc = no->location();\n+\n+  Typed_identifier_list* new_params = new Typed_identifier_list();\n+  const Typed_identifier_list* orig_params = orig_fntype->parameters();\n+  if (orig_params != NULL && !orig_params->empty())\n+    {\n+      static int count;\n+      char buf[50];\n+      for (Typed_identifier_list::const_iterator p = orig_params->begin();\n+\t   p != orig_params->end();\n+\t   ++p)\n+\t{\n+\t  snprintf(buf, sizeof buf, \"pt.%u\", count);\n+\t  ++count;\n+\t  new_params->push_back(Typed_identifier(buf, p->type(),\n+\t\t\t\t\t\t p->location()));\n+\t}\n+    }\n+  Type* vt = Type::make_pointer_type(Type::make_void_type());\n+  new_params->push_back(Typed_identifier(\"closure.0\", vt, loc));\n+\n+  const Typed_identifier_list* orig_results = orig_fntype->results();\n+  Typed_identifier_list* new_results;\n+  if (orig_results == NULL || orig_results->empty())\n+    new_results = NULL;\n+  else\n+    {\n+      new_results = new Typed_identifier_list();\n+      for (Typed_identifier_list::const_iterator p = orig_results->begin();\n+\t   p != orig_results->end();\n+\t   ++p)\n+\tnew_results->push_back(Typed_identifier(\"\", p->type(),\n+\t\t\t\t\t\tp->location()));\n+    }\n+\n+  Function_type* new_fntype = Type::make_function_type(NULL, new_params,\n+\t\t\t\t\t\t       new_results,\n+\t\t\t\t\t\t       loc);\n+\n+  std::string name = no->name() + \"$descriptorfn\";\n+  Named_object* dno = gogo->start_function(name, new_fntype, false, loc);\n+  dno->func_value()->is_descriptor_wrapper_ = true;\n+\n+  gogo->start_block(loc);\n+\n+  Expression* fn = Expression::make_func_reference(no, NULL, loc);\n+\n+  // Call the wrapper function, passing all of the arguments except\n+  // for the last one (the last argument is the ignored closure).\n+  Expression_list* args;\n+  if (orig_params == NULL || orig_params->empty())\n+    args = NULL;\n+  else\n+    {\n+      args = new Expression_list();\n+      for (Typed_identifier_list::const_iterator p = new_params->begin();\n+\t   p + 1 != new_params->end();\n+\t   ++p)\n+\t{\n+\t  Named_object* p_no = gogo->lookup(p->name(), NULL);\n+\t  go_assert(p_no != NULL\n+\t\t    && p_no->is_variable()\n+\t\t    && p_no->var_value()->is_parameter());\n+\t  args->push_back(Expression::make_var_reference(p_no, loc));\n+\t}\n+    }\n+\n+  Call_expression* call = Expression::make_call(fn, args,\n+\t\t\t\t\t\torig_fntype->is_varargs(),\n+\t\t\t\t\t\tloc);\n+  call->set_varargs_are_lowered();\n+\n+  Statement* s;\n+  if (orig_results == NULL || orig_results->empty())\n+    s = Statement::make_statement(call, true);\n+  else\n+    {\n+      Expression_list* vals = new Expression_list();\n+      size_t rc = orig_results->size();\n+      if (rc == 1)\n+\tvals->push_back(call);\n+      else\n+\t{\n+\t  for (size_t i = 0; i < rc; ++i)\n+\t    vals->push_back(Expression::make_call_result(call, i));\n+\t}\n+      s = Statement::make_return_statement(vals, loc);\n+    }\n+\n+  gogo->add_statement(s);\n+  gogo->add_block(gogo->finish_block(loc), loc);\n+  gogo->finish_function(loc);\n+\n+  return dno;\n+}\n+\n+// Return the function descriptor, the value you get when you refer to\n+// the function in Go code without calling it.\n+\n+Expression*\n+Function::descriptor(Gogo* gogo, Named_object* no)\n+{\n+  go_assert(!this->is_method());\n+  go_assert(this->closure_var_ == NULL);\n+  go_assert(!this->is_descriptor_wrapper_);\n+  if (this->descriptor_ == NULL)\n+    {\n+      Named_object* dno;\n+      if (no->package() != NULL\n+\t  || Linemap::is_predeclared_location(no->location()))\n+\tdno = NULL;\n+      else\n+\tdno = Function::make_descriptor_wrapper(gogo, no, this->type_);\n+      this->descriptor_ = Expression::make_func_descriptor(no, dno);\n+    }\n+  return this->descriptor_;\n+}\n+\n // Get a pointer to the variable representing the defer stack for this\n // function, making it if necessary.  The value of the variable is set\n // by the runtime routines to true if the function is returning,\n@@ -3940,6 +4117,27 @@ Bindings_snapshot::check_goto_defs(Location loc, const Block* block,\n     }\n }\n \n+// Class Function_declaration.\n+\n+// Return the function descriptor.\n+\n+Expression*\n+Function_declaration::descriptor(Gogo* gogo, Named_object* no)\n+{\n+  go_assert(!this->fntype_->is_method());\n+  if (this->descriptor_ == NULL)\n+    {\n+      Named_object* dno;\n+      if (no->package() != NULL\n+\t  || Linemap::is_predeclared_location(no->location()))\n+\tdno = NULL;\n+      else\n+\tdno = Function::make_descriptor_wrapper(gogo, no, this->fntype_);\n+      this->descriptor_ = Expression::make_func_descriptor(no, dno);\n+    }\n+  return this->descriptor_;\n+}\n+\n // Class Variable.\n \n Variable::Variable(Type* type, Expression* init, bool is_global,\n@@ -4755,6 +4953,12 @@ void\n Named_object::set_function_value(Function* function)\n {\n   go_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+  if (this->func_declaration_value()->has_descriptor())\n+    {\n+      Expression* descriptor =\n+\tthis->func_declaration_value()->descriptor(NULL, NULL);\n+      function->set_descriptor(descriptor);\n+    }\n   this->classification_ = NAMED_OBJECT_FUNC;\n   // FIXME: We should free the old value.\n   this->u_.func_value = function;"}, {"sha": "ec43ef67f0879fe8eecb45a22cca7552d733e5c4", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -614,10 +614,6 @@ class Gogo\n   receive_from_channel(tree type_tree, tree type_descriptor_tree, tree channel,\n \t\t       Location);\n \n-  // Make a trampoline which calls FNADDR passing CLOSURE.\n-  tree\n-  make_trampoline(tree fnaddr, tree closure, Location);\n-\n  private:\n   // During parsing, we keep a stack of functions.  Each function on\n   // the stack is one that we are currently parsing.  For each\n@@ -669,10 +665,6 @@ class Gogo\n   tree\n   ptr_go_string_constant_tree(const std::string&);\n \n-  // Return the type of a trampoline.\n-  static tree\n-  trampoline_type_tree();\n-\n   // Type used to map import names to packages.\n   typedef std::map<std::string, Package*> Imports;\n \n@@ -1046,6 +1038,12 @@ class Function\n   set_in_unique_section()\n   { this->in_unique_section_ = true; }\n \n+  // Whether this function was created as a descriptor wrapper for\n+  // another function.\n+  bool\n+  is_descriptor_wrapper() const\n+  { return this->is_descriptor_wrapper_; }\n+\n   // Swap with another function.  Used only for the thunk which calls\n   // recover.\n   void\n@@ -1059,6 +1057,26 @@ class Function\n   void\n   determine_types();\n \n+  // Return an expression for the function descriptor, given the named\n+  // object for this function.  This may only be called for functions\n+  // without a closure.  This will be an immutable struct with one\n+  // field that points to the function's code.\n+  Expression*\n+  descriptor(Gogo*, Named_object*);\n+\n+  // Set the descriptor for this function.  This is used when a\n+  // function declaration is followed by a function definition.\n+  void\n+  set_descriptor(Expression* descriptor)\n+  {\n+    go_assert(this->descriptor_ == NULL);\n+    this->descriptor_ = descriptor;\n+  }\n+\n+  // Build a descriptor wrapper function.\n+  static Named_object*\n+  make_descriptor_wrapper(Gogo*, Named_object*, Function_type*);\n+\n   // Return the function's decl given an identifier.\n   tree\n   get_or_make_decl(Gogo*, Named_object*, tree id);\n@@ -1137,6 +1155,8 @@ class Function\n   Labels labels_;\n   // The number of local types defined in this function.\n   unsigned int local_type_count_;\n+  // The function descriptor, if any.\n+  Expression* descriptor_;\n   // The function decl.\n   tree fndecl_;\n   // The defer stack variable.  A pointer to this variable is used to\n@@ -1156,6 +1176,9 @@ class Function\n   // True if this function should be put in a unique section.  This is\n   // turned on for field tracking.\n   bool in_unique_section_ : 1;\n+  // True if this is a function wrapper created to put in a function\n+  // descriptor.\n+  bool is_descriptor_wrapper_ : 1;\n };\n \n // A snapshot of the current binding state.\n@@ -1198,7 +1221,8 @@ class Function_declaration\n {\n  public:\n   Function_declaration(Function_type* fntype, Location location)\n-    : fntype_(fntype), location_(location), asm_name_(), fndecl_(NULL)\n+    : fntype_(fntype), location_(location), asm_name_(), descriptor_(NULL),\n+      fndecl_(NULL)\n   { }\n \n   Function_type*\n@@ -1218,10 +1242,27 @@ class Function_declaration\n   set_asm_name(const std::string& asm_name)\n   { this->asm_name_ = asm_name; }\n \n+  // Return an expression for the function descriptor, given the named\n+  // object for this function.  This may only be called for functions\n+  // without a closure.  This will be an immutable struct with one\n+  // field that points to the function's code.\n+  Expression*\n+  descriptor(Gogo*, Named_object*);\n+\n+  // Return true if we have created a descriptor for this declaration.\n+  bool\n+  has_descriptor() const\n+  { return this->descriptor_ != NULL; }\n+\n   // Return a decl for the function given an identifier.\n   tree\n   get_or_make_decl(Gogo*, Named_object*, tree id);\n \n+  // If there is a descriptor, build it into the backend\n+  // representation.\n+  void\n+  build_backend_descriptor(Gogo*);\n+\n   // Export a function declaration.\n   void\n   export_func(Export* exp, const std::string& name) const\n@@ -1235,6 +1276,8 @@ class Function_declaration\n   // The assembler name: this is the name to use in references to the\n   // function.  This is normally empty.\n   std::string asm_name_;\n+  // The function descriptor, if any.\n+  Expression* descriptor_;\n   // The function decl if needed.\n   tree fndecl_;\n };"}, {"sha": "b562a78ad00e982fc9de0f2dfed416cd5f6b81ba", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -2627,7 +2627,11 @@ Parse::enclosing_var_reference(Named_object* in_function, Named_object* var,\n   Named_object* this_function = this->gogo_->current_function();\n   Named_object* closure = this_function->func_value()->closure_var();\n \n-  Enclosing_var ev(var, in_function, this->enclosing_vars_.size());\n+  // The last argument to the Enclosing_var constructor is the index\n+  // of this variable in the closure.  We add 1 to the current number\n+  // of enclosed variables, because the first field in the closure\n+  // points to the function code.\n+  Enclosing_var ev(var, in_function, this->enclosing_vars_.size() + 1);\n   std::pair<Enclosing_vars::iterator, bool> ins =\n     this->enclosing_vars_.insert(ev);\n   if (ins.second)\n@@ -2882,8 +2886,9 @@ Parse::function_lit()\n // Create a closure for the nested function FUNCTION.  This is based\n // on ENCLOSING_VARS, which is a list of all variables defined in\n // enclosing functions and referenced from FUNCTION.  A closure is the\n-// address of a struct which contains the addresses of all the\n-// referenced variables.  This returns NULL if no closure is required.\n+// address of a struct which point to the real function code and\n+// contains the addresses of all the referenced variables.  This\n+// returns NULL if no closure is required.\n \n Expression*\n Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n@@ -2899,16 +2904,25 @@ Parse::create_closure(Named_object* function, Enclosing_vars* enclosing_vars,\n   for (Enclosing_vars::const_iterator p = enclosing_vars->begin();\n        p != enclosing_vars->end();\n        ++p)\n-    ev[p->index()] = *p;\n+    {\n+      // Subtract 1 because index 0 is the function code.\n+      ev[p->index() - 1] = *p;\n+    }\n \n   // Build an initializer for a composite literal of the closure's\n   // type.\n \n   Named_object* enclosing_function = this->gogo_->current_function();\n   Expression_list* initializer = new Expression_list;\n+\n+  initializer->push_back(Expression::make_func_code_reference(function,\n+\t\t\t\t\t\t\t      location));\n+\n   for (size_t i = 0; i < enclosing_var_count; ++i)\n     {\n-      go_assert(ev[i].index() == i);\n+      // Add 1 to i because the first field in the closure is a\n+      // pointer to the function code.\n+      go_assert(ev[i].index() == i + 1);\n       Named_object* var = ev[i].var();\n       Expression* ref;\n       if (ev[i].in_function() == enclosing_function)"}, {"sha": "0d3fd3c43f1dd7e1aabbf3449c9338205927f52f", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -224,11 +224,6 @@ DEF_GO_RUNTIME(NEW, \"__go_new\", P1(UINTPTR), R1(POINTER))\n DEF_GO_RUNTIME(NEW_NOPOINTERS, \"__go_new_nopointers\", P1(UINTPTR), R1(POINTER))\n \n \n-// Allocate a trampoline for a function literal.\n-DEF_GO_RUNTIME(ALLOCATE_GO_TRAMPOLINE, \"__go_allocate_trampoline\",\n-\t       P2(UINTPTR, POINTER), R1(POINTER))\n-\n-\n // Start a new goroutine.\n DEF_GO_RUNTIME(GO, \"__go_go\", P2(FUNC_PTR, POINTER), R0())\n "}, {"sha": "7e4c56181f16c50540d595efd5409d992dc121d5", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -1959,10 +1959,15 @@ Thunk_statement::is_simple(Function_type* fntype) const\n \t      && results->begin()->type()->points_to() == NULL)))\n     return false;\n \n-  // If this calls something which is not a simple function, then we\n+  // If this calls something that is not a simple function, then we\n   // need a thunk.\n   Expression* fn = this->call_->call_expression()->fn();\n-  if (fn->interface_field_reference_expression() != NULL)\n+  if (fn->func_expression() == NULL)\n+    return false;\n+\n+  // If the function uses a closure, then we need a thunk.  FIXME: We\n+  // could accept a zero argument function with a closure.\n+  if (fn->func_expression()->closure() != NULL)\n     return false;\n \n   return true;\n@@ -2502,7 +2507,11 @@ Thunk_statement::get_fn_and_arg(Expression** pfn, Expression** parg)\n \n   Call_expression* ce = this->call_->call_expression();\n \n-  *pfn = ce->fn();\n+  Expression* fn = ce->fn();\n+  Func_expression* fe = fn->func_expression();\n+  go_assert(fe != NULL);\n+  *pfn = Expression::make_func_code_reference(fe->named_object(),\n+\t\t\t\t\t      fe->location());\n \n   const Expression_list* args = ce->args();\n   if (args == NULL || args->empty())"}, {"sha": "ae25ec9434adad81b5c6be675268769f8515c00b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -1298,8 +1298,8 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   // converting INITIALIZER.\n \n   this->type_descriptor_var_ =\n-    gogo->backend()->immutable_struct(var_name, is_common, initializer_btype,\n-\t\t\t\t      loc);\n+    gogo->backend()->immutable_struct(var_name, false, is_common,\n+\t\t\t\t      initializer_btype, loc);\n   if (phash != NULL)\n     *phash = this->type_descriptor_var_;\n \n@@ -1308,7 +1308,7 @@ Type::make_type_descriptor_var(Gogo* gogo)\n   Bexpression* binitializer = tree_to_expr(initializer->get_tree(&context));\n \n   gogo->backend()->immutable_struct_set_init(this->type_descriptor_var_,\n-\t\t\t\t\t     var_name, is_common,\n+\t\t\t\t\t     var_name, false, is_common,\n \t\t\t\t\t     initializer_btype, loc,\n \t\t\t\t\t     binitializer);\n }\n@@ -1528,35 +1528,15 @@ Type::make_type_descriptor_type()\n \n       // The type descriptor type.\n \n-      Typed_identifier_list* params = new Typed_identifier_list();\n-      params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n-\n-      Typed_identifier_list* results = new Typed_identifier_list();\n-      results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n-\n-      Type* hashfn_type = Type::make_function_type(NULL, params, results, bloc);\n-\n-      params = new Typed_identifier_list();\n-      params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n-\n-      results = new Typed_identifier_list();\n-      results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n-\n-      Type* equalfn_type = Type::make_function_type(NULL, params, results,\n-\t\t\t\t\t\t    bloc);\n-\n       Struct_type* type_descriptor_type =\n \tType::make_builtin_struct_type(10,\n \t\t\t\t       \"Kind\", uint8_type,\n \t\t\t\t       \"align\", uint8_type,\n \t\t\t\t       \"fieldAlign\", uint8_type,\n \t\t\t\t       \"size\", uintptr_type,\n \t\t\t\t       \"hash\", uint32_type,\n-\t\t\t\t       \"hashfn\", hashfn_type,\n-\t\t\t\t       \"equalfn\", equalfn_type,\n+\t\t\t\t       \"hashfn\", uintptr_type,\n+\t\t\t\t       \"equalfn\", uintptr_type,\n \t\t\t\t       \"string\", pointer_string_type,\n \t\t\t\t       \"\", pointer_uncommon_type,\n \t\t\t\t       \"ptrToThis\",\n@@ -1946,8 +1926,8 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   Named_object* equal_fn;\n   this->type_functions(gogo, name, hash_fntype, equal_fntype, &hash_fn,\n \t\t       &equal_fn);\n-  vals->push_back(Expression::make_func_reference(hash_fn, NULL, bloc));\n-  vals->push_back(Expression::make_func_reference(equal_fn, NULL, bloc));\n+  vals->push_back(Expression::make_func_code_reference(hash_fn, bloc));\n+  vals->push_back(Expression::make_func_code_reference(equal_fn, bloc));\n \n   ++p;\n   go_assert(p->is_field_name(\"string\"));\n@@ -2207,7 +2187,7 @@ Type::method_constructor(Gogo*, Type* method_type,\n \n   ++p;\n   go_assert(p->is_field_name(\"tfn\"));\n-  vals->push_back(Expression::make_func_reference(no, NULL, bloc));\n+  vals->push_back(Expression::make_func_code_reference(no, bloc));\n \n   ++p;\n   go_assert(p == fields->end());\n@@ -3407,6 +3387,18 @@ Function_type::do_hash_for_method(Gogo* gogo) const\n Btype*\n Function_type::do_get_backend(Gogo* gogo)\n {\n+  // When we do anything with a function value other than call it, it\n+  // is represented as a pointer to a struct whose first field is the\n+  // actual function.  So that is what we return as the type of a Go\n+  // function.  The function stored in the first field always that\n+  // takes one additional trailing argument: the closure pointer.  For\n+  // a top-level function, this additional argument will only be\n+  // passed when invoking the function indirectly, via the struct.\n+\n+  Location loc = this->location();\n+  Btype* struct_type = gogo->backend()->placeholder_struct_type(\"\", loc);\n+  Btype* ptr_struct_type = gogo->backend()->pointer_type(struct_type);\n+\n   Backend::Btyped_identifier breceiver;\n   if (this->receiver_ != NULL)\n     {\n@@ -3422,9 +3414,15 @@ Function_type::do_get_backend(Gogo* gogo)\n     }\n \n   std::vector<Backend::Btyped_identifier> bparameters;\n-  if (this->parameters_ != NULL)\n+  size_t last;\n+  if (this->parameters_ == NULL)\n+    {\n+      bparameters.resize(1);\n+      last = 0;\n+    }\n+  else\n     {\n-      bparameters.resize(this->parameters_->size());\n+      bparameters.resize(this->parameters_->size() + 1);\n       size_t i = 0;\n       for (Typed_identifier_list::const_iterator p = this->parameters_->begin();\n \t   p != this->parameters_->end();\n@@ -3434,8 +3432,12 @@ Function_type::do_get_backend(Gogo* gogo)\n \t  bparameters[i].btype = p->type()->get_backend(gogo);\n \t  bparameters[i].location = p->location();\n \t}\n-      go_assert(i == bparameters.size());\n+      last = i;\n     }\n+  go_assert(last + 1 == bparameters.size());\n+  bparameters[last].name = \"$closure\";\n+  bparameters[last].btype = ptr_struct_type;\n+  bparameters[last].location = loc;\n \n   std::vector<Backend::Btyped_identifier> bresults;\n   if (this->results_ != NULL)\n@@ -3453,8 +3455,15 @@ Function_type::do_get_backend(Gogo* gogo)\n       go_assert(i == bresults.size());\n     }\n \n-  return gogo->backend()->function_type(breceiver, bparameters, bresults,\n-\t\t\t\t\tthis->location());\n+  Btype* fntype = gogo->backend()->function_type(breceiver, bparameters,\n+\t\t\t\t\t\t bresults, loc);\n+  std::vector<Backend::Btyped_identifier> fields(1);\n+  fields[0].name = \"code\";\n+  fields[0].btype = fntype;\n+  fields[0].location = loc;\n+  if (!gogo->backend()->set_placeholder_struct_type(struct_type, fields))\n+    return gogo->backend()->error_type();\n+  return ptr_struct_type;\n }\n \n // The type of a function type descriptor.\n@@ -6228,15 +6237,16 @@ Map_type::map_descriptor(Gogo* gogo)\n \n   std::string mangled_name = \"__go_map_\" + this->mangled_name(gogo);\n   Btype* map_descriptor_btype = map_descriptor_type->get_backend(gogo);\n-  Bvariable* bvar = gogo->backend()->immutable_struct(mangled_name, true,\n+  Bvariable* bvar = gogo->backend()->immutable_struct(mangled_name, false,\n+\t\t\t\t\t\t      true,\n \t\t\t\t\t\t      map_descriptor_btype,\n \t\t\t\t\t\t      bloc);\n \n   Translate_context context(gogo, NULL, NULL, NULL);\n   context.set_is_const();\n   Bexpression* binitializer = tree_to_expr(initializer->get_tree(&context));\n \n-  gogo->backend()->immutable_struct_set_init(bvar, mangled_name, true,\n+  gogo->backend()->immutable_struct_set_init(bvar, mangled_name, false, true,\n \t\t\t\t\t     map_descriptor_btype, bloc,\n \t\t\t\t\t     binitializer);\n "}, {"sha": "91d472931a63ce96627c19d256d7bd4a327b7779", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -523,6 +523,14 @@ class Type\n   static Type*\n   make_forward_declaration(Named_object*);\n \n+  // Make a builtin struct type from a list of fields.\n+  static Struct_type*\n+  make_builtin_struct_type(int nfields, ...);\n+\n+  // Make a builtin named type.\n+  static Named_type*\n+  make_builtin_named_type(const char* name, Type* type);\n+\n   // Traverse a type.\n   static int\n   traverse(Type*, Traverse*);\n@@ -1035,14 +1043,6 @@ class Type\n   type_descriptor_constructor(Gogo*, int runtime_type_kind, Named_type*,\n \t\t\t      const Methods*, bool only_value_methods);\n \n-  // Make a builtin struct type from a list of fields.\n-  static Struct_type*\n-  make_builtin_struct_type(int nfields, ...);\n-\n-  // Make a builtin named type.\n-  static Named_type*\n-  make_builtin_named_type(const char* name, Type* type);\n-\n   // For the benefit of child class reflection string generation.\n   void\n   append_reflection(const Type* type, Gogo* gogo, std::string* ret) const\n@@ -1796,7 +1796,7 @@ class Function_type : public Type\n   int\n   do_traverse(Traverse*);\n \n-  // A trampoline function has a pointer which matters for GC.\n+  // A function descriptor may be allocated on the heap.\n   bool\n   do_has_pointer() const\n   { return true; }"}, {"sha": "d54448c42a024a8807f1828332ccd01418fbb887", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -487,7 +487,6 @@ runtime_files = \\\n \truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n \truntime/go-traceback.c \\\n-\truntime/go-trampoline.c \\\n \truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n \truntime/go-type-error.c \\"}, {"sha": "08eae578e51d1cd17473a41f9a3cb8f8c8c362db", "filename": "libgo/Makefile.in", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -208,7 +208,7 @@ am__objects_5 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-reflect-call.lo go-reflect-map.lo go-rune.lo \\\n \tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n \tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n-\tgo-strplus.lo go-strslice.lo go-traceback.lo go-trampoline.lo \\\n+\tgo-strplus.lo go-strslice.lo go-traceback.lo \\\n \tgo-type-complex.lo go-type-eface.lo go-type-error.lo \\\n \tgo-type-float.lo go-type-identity.lo go-type-interface.lo \\\n \tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n@@ -822,7 +822,6 @@ runtime_files = \\\n \truntime/go-strplus.c \\\n \truntime/go-strslice.c \\\n \truntime/go-traceback.c \\\n-\truntime/go-trampoline.c \\\n \truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n \truntime/go-type-error.c \\\n@@ -2519,7 +2518,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strplus.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strslice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-traceback.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-trampoline.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-eface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-error.Plo@am__quote@\n@@ -2959,13 +2957,6 @@ go-traceback.lo: runtime/go-traceback.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-traceback.lo `test -f 'runtime/go-traceback.c' || echo '$(srcdir)/'`runtime/go-traceback.c\n \n-go-trampoline.lo: runtime/go-trampoline.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-trampoline.lo -MD -MP -MF $(DEPDIR)/go-trampoline.Tpo -c -o go-trampoline.lo `test -f 'runtime/go-trampoline.c' || echo '$(srcdir)/'`runtime/go-trampoline.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-trampoline.Tpo $(DEPDIR)/go-trampoline.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-trampoline.c' object='go-trampoline.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-trampoline.lo `test -f 'runtime/go-trampoline.c' || echo '$(srcdir)/'`runtime/go-trampoline.c\n-\n go-type-complex.lo: runtime/go-type-complex.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-complex.lo -MD -MP -MF $(DEPDIR)/go-type-complex.Tpo -c -o go-type-complex.lo `test -f 'runtime/go-type-complex.c' || echo '$(srcdir)/'`runtime/go-type-complex.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-complex.Tpo $(DEPDIR)/go-type-complex.Plo"}, {"sha": "5c943ff5589f53fe7a11a29bbf93869119a8472f", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -2496,7 +2496,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=3:1:0\n+libtool_VERSION=5:0:0\n \n \n # Default to --enable-multilib"}, {"sha": "002aa88675c7322f460a521bc2ce8611f5ed4e7b", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -11,7 +11,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=3:1:0\n+libtool_VERSION=5:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)"}, {"sha": "5a2ae2eee7290e6fe24e5da94d9a8b5dd20afa39", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -1891,6 +1891,7 @@ func (*inner) m() {}\n func (*outer) m() {}\n \n func TestNestedMethods(t *testing.T) {\n+\tt.Skip(\"fails on gccgo due to function wrappers\")\n \ttyp := TypeOf((*outer)(nil))\n \tif typ.NumMethod() != 1 || typ.Method(0).Func.Pointer() != ValueOf((*outer).m).Pointer() {\n \t\tt.Errorf(\"Wrong method table for outer: (m=%p)\", (*outer).m)\n@@ -1915,6 +1916,7 @@ func (i *InnerInt) M() int {\n }\n \n func TestEmbeddedMethods(t *testing.T) {\n+\t/* This part of the test fails on gccgo due to function wrappers.\n \ttyp := TypeOf((*OuterInt)(nil))\n \tif typ.NumMethod() != 1 || typ.Method(0).Func.Pointer() != ValueOf((*OuterInt).M).Pointer() {\n \t\tt.Errorf(\"Wrong method table for OuterInt: (m=%p)\", (*OuterInt).M)\n@@ -1923,6 +1925,7 @@ func TestEmbeddedMethods(t *testing.T) {\n \t\t\tt.Errorf(\"\\t%d: %s %#x\\n\", i, m.Name, m.Func.Pointer())\n \t\t}\n \t}\n+\t*/\n \n \ti := &InnerInt{3}\n \tif v := ValueOf(i).Method(0).Call(nil)[0].Int(); v != 3 {"}, {"sha": "b909177a42a98adf2b3e21801f9035bb0e4c019d", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -243,8 +243,8 @@ type rtype struct {\n \tsize       uintptr // size in bytes\n \thash       uint32  // hash of type; avoids computation in hash tables\n \n-\thashfn  func(unsafe.Pointer, uintptr)                 // hash function\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) // equality function\n+\thashfn  uintptr // hash function code\n+\tequalfn uintptr // equality function code\n \n \tstring        *string // string form; unnecessary  but undeniably useful\n \t*uncommonType         // (relatively) uncommon fields\n@@ -485,7 +485,7 @@ func (t *uncommonType) Method(i int) (m Method) {\n \tmt := p.typ\n \tm.Type = toType(mt)\n \tx := new(unsafe.Pointer)\n-\t*x = p.tfn\n+\t*x = unsafe.Pointer(&p.tfn)\n \tm.Func = Value{mt, unsafe.Pointer(x), fl | flagIndir}\n \tm.Index = i\n \treturn"}, {"sha": "f8126e676d8f5818224639df4b93d25356a60d53", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -377,7 +377,7 @@ func (v Value) call(method string, in []Value) []Value {\n \t\t\tif iface.itab == nil {\n \t\t\t\tpanic(method + \" of method on nil interface value\")\n \t\t\t}\n-\t\t\tfn = iface.itab.fun[i]\n+\t\t\tfn = unsafe.Pointer(&iface.itab.fun[i])\n \t\t\trcvr = iface.word\n \t\t} else {\n \t\t\tut := v.typ.uncommon()\n@@ -388,7 +388,7 @@ func (v Value) call(method string, in []Value) []Value {\n \t\t\tif m.pkgPath != nil {\n \t\t\t\tpanic(method + \" of unexported method\")\n \t\t\t}\n-\t\t\tfn = m.tfn\n+\t\t\tfn = unsafe.Pointer(&m.tfn)\n \t\t\tt = m.mtyp\n \t\t\trcvr = v.iword()\n \t\t}\n@@ -462,6 +462,10 @@ func (v Value) call(method string, in []Value) []Value {\n \tif v.flag&flagMethod != 0 {\n \t\tnin++\n \t}\n+\tfirstPointer := len(in) > 0 && Kind(t.In(0).(*rtype).kind) != Ptr && v.flag&flagMethod == 0 && isMethod(v.typ)\n+\tif v.flag&flagMethod == 0 && !firstPointer {\n+\t\tnin++\n+\t}\n \tparams := make([]unsafe.Pointer, nin)\n \toff := 0\n \tif v.flag&flagMethod != 0 {\n@@ -471,7 +475,6 @@ func (v Value) call(method string, in []Value) []Value {\n \t\tparams[0] = unsafe.Pointer(p)\n \t\toff = 1\n \t}\n-\tfirst_pointer := false\n \tfor i, pv := range in {\n \t\tpv.mustBeExported()\n \t\ttarg := t.In(i).(*rtype)\n@@ -483,14 +486,17 @@ func (v Value) call(method string, in []Value) []Value {\n \t\t} else {\n \t\t\tparams[off] = pv.val\n \t\t}\n-\t\tif i == 0 && Kind(targ.kind) != Ptr && v.flag&flagMethod == 0 && isMethod(v.typ) {\n+\t\tif i == 0 && firstPointer {\n \t\t\tp := new(unsafe.Pointer)\n \t\t\t*p = params[off]\n \t\t\tparams[off] = unsafe.Pointer(p)\n-\t\t\tfirst_pointer = true\n \t\t}\n \t\toff++\n \t}\n+\tif v.flag&flagMethod == 0 && !firstPointer {\n+\t\t// Closure argument.\n+\t\tparams[off] = unsafe.Pointer(&fn)\n+\t}\n \n \tret := make([]Value, nout)\n \tresults := make([]unsafe.Pointer, nout)\n@@ -509,7 +515,7 @@ func (v Value) call(method string, in []Value) []Value {\n \t\tpr = &results[0]\n \t}\n \n-\tcall(t, fn, v.flag&flagMethod != 0, first_pointer, pp, pr)\n+\tcall(t, fn, v.flag&flagMethod != 0, firstPointer, pp, pr)\n \n \treturn ret\n }\n@@ -1209,18 +1215,35 @@ func (v Value) OverflowUint(x uint64) bool {\n // code using reflect cannot obtain unsafe.Pointers\n // without importing the unsafe package explicitly.\n // It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.\n+//\n+// If v's Kind is Func, the returned pointer is an underlying\n+// code pointer, but not necessarily enough to identify a\n+// single function uniquely. The only guarantee is that the\n+// result is zero if and only if v is a nil func Value.\n func (v Value) Pointer() uintptr {\n \tk := v.kind()\n \tswitch k {\n-\tcase Chan, Func, Map, Ptr, UnsafePointer:\n-\t\tif k == Func && v.flag&flagMethod != 0 {\n+\tcase Chan, Map, Ptr, UnsafePointer:\n+\t\tp := v.val\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\tp = *(*unsafe.Pointer)(p)\n+\t\t}\n+\t\treturn uintptr(p)\n+\tcase Func:\n+\t\tif v.flag&flagMethod != 0 {\n \t\t\tpanic(\"reflect.Value.Pointer of method Value\")\n \t\t}\n \t\tp := v.val\n \t\tif v.flag&flagIndir != 0 {\n \t\t\tp = *(*unsafe.Pointer)(p)\n \t\t}\n+\t\t// Non-nil func value points at data block.\n+\t\t// First word of data block is actual code.\n+\t\tif p != nil {\n+\t\t\tp = *(*unsafe.Pointer)(p)\n+\t\t}\n \t\treturn uintptr(p)\n+\n \tcase Slice:\n \t\treturn (*SliceHeader)(v.val).Data\n \t}"}, {"sha": "6e91ef56b704120c8639a06bbbf5c48f54a1d923", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -59,9 +59,6 @@ func (f *Func) FileLine(pc uintptr) (file string, line int) {\n // implemented in symtab.c\n func funcline_go(*Func, uintptr) (string, int)\n \n-// mid returns the current OS thread (m) id.\n-func mid() uint32\n-\n // SetFinalizer sets the finalizer associated with x to f.\n // When the garbage collector finds an unreachable block\n // with an associated finalizer, it clears the association and runs"}, {"sha": "4c69a68ceeaa042fc842b1e6488aae94065cb9ab", "filename": "libgo/go/runtime/parfor_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Fruntime%2Fparfor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fgo%2Fruntime%2Fparfor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fparfor_test.go?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -13,6 +13,8 @@ import (\n \t\"unsafe\"\n )\n \n+var gdata []uint64\n+\n // Simple serial sanity test for parallelfor.\n func TestParFor(t *testing.T) {\n \tconst P = 1\n@@ -22,7 +24,12 @@ func TestParFor(t *testing.T) {\n \t\tdata[i] = i\n \t}\n \tdesc := NewParFor(P)\n+\t// Avoid making func a closure: parfor cannot invoke them.\n+\t// Since it doesn't happen in the C code, it's not worth doing\n+\t// just for the test.\n+\tgdata = data\n \tParForSetup(desc, P, N, nil, true, func(desc *ParFor, i uint32) {\n+\t\tdata := gdata\n \t\tdata[i] = data[i]*data[i] + 1\n \t})\n \tParForDo(desc)\n@@ -111,7 +118,9 @@ func TestParForParallel(t *testing.T) {\n \tP := GOMAXPROCS(-1)\n \tc := make(chan bool, P)\n \tdesc := NewParFor(uint32(P))\n+\tgdata = data\n \tParForSetup(desc, uint32(P), uint32(N), nil, false, func(desc *ParFor, i uint32) {\n+\t\tdata := gdata\n \t\tdata[i] = data[i]*data[i] + 1\n \t})\n \tfor p := 1; p < P; p++ {"}, {"sha": "83b9eba04363cbde9faf0c8394c8bfebc4c832d9", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -302,7 +302,9 @@ go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n   in_types = ((const struct __go_type_descriptor **)\n \t      func->__in.__values);\n \n-  num_args = num_params + (is_interface ? 1 : 0);\n+  num_args = (num_params\n+\t      + (is_interface ? 1 : 0)\n+\t      + (!is_interface && !is_method ? 1 : 0));\n   args = (ffi_type **) __go_alloc (num_args * sizeof (ffi_type *));\n   i = 0;\n   off = 0;\n@@ -319,6 +321,12 @@ go_func_to_cif (const struct __go_func_type *func, _Bool is_interface,\n   for (; i < num_params; ++i)\n     args[i + off] = go_type_to_ffi (in_types[i]);\n \n+  if (!is_interface && !is_method)\n+    {\n+      // There is a closure argument, a pointer.\n+      args[i + off] = &ffi_type_pointer;\n+    }\n+\n   rettype = go_func_return_ffi (func);\n \n   status = ffi_prep_cif (cif, FFI_DEFAULT_ABI, num_args, rettype, args);\n@@ -491,11 +499,24 @@ go_set_results (const struct __go_func_type *func, unsigned char *call_result,\n }\n \n /* Call a function.  The type of the function is FUNC_TYPE, and the\n-   address is FUNC_ADDR.  PARAMS is an array of parameter addresses.\n-   RESULTS is an array of result addresses.  */\n+   closure is FUNC_VAL.  PARAMS is an array of parameter addresses.\n+   RESULTS is an array of result addresses.\n+\n+   If IS_INTERFACE is true this is a call to an interface method and\n+   the first argument is the receiver, which is always a pointer.\n+   This argument, the receiver, is not described in FUNC_TYPE.\n+\n+   If IS_METHOD is true this is a call to a method expression.  The\n+   first argument is the receiver.  It is described in FUNC_TYPE, but\n+   regardless of FUNC_TYPE, it is passed as a pointer.\n+\n+   If neither IS_INTERFACE nor IS_METHOD is true then we are calling a\n+   function indirectly, and the caller is responsible for passing a\n+   trailing closure argument, a pointer, which is not described in\n+   FUNC_TYPE.  */\n \n void\n-reflect_call (const struct __go_func_type *func_type, const void *func_addr,\n+reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n \t      _Bool is_interface, _Bool is_method, void **params,\n \t      void **results)\n {\n@@ -507,7 +528,7 @@ reflect_call (const struct __go_func_type *func_type, const void *func_addr,\n \n   call_result = (unsigned char *) malloc (go_results_size (func_type));\n \n-  ffi_call (&cif, func_addr, call_result, params);\n+  ffi_call (&cif, func_val->fn, call_result, params);\n \n   /* Some day we may need to free result values if RESULTS is\n      NULL.  */\n@@ -521,7 +542,7 @@ reflect_call (const struct __go_func_type *func_type, const void *func_addr,\n \n void\n reflect_call (const struct __go_func_type *func_type __attribute__ ((unused)),\n-\t      const void *func_addr __attribute__ ((unused)),\n+\t      FuncVal *func_val __attribute__ ((unused)),\n \t      _Bool is_interface __attribute__ ((unused)),\n \t      _Bool is_method __attribute__ ((unused)),\n \t      void **params __attribute__ ((unused)),"}, {"sha": "7ebb762450e147631e96fb9f9435b83b361c8674", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -485,7 +485,7 @@ void\truntime_helpgc(int32 nproc);\n void\truntime_gchelper(void);\n \n struct __go_func_type;\n-bool\truntime_getfinalizer(void *p, bool del, void (**fn)(void*), const struct __go_func_type **ft);\n+bool\truntime_getfinalizer(void *p, bool del, FuncVal **fn, const struct __go_func_type **ft);\n void\truntime_walkfintab(void (*fn)(void*), void (*scan)(Obj));\n \n enum\n@@ -505,4 +505,3 @@ void\truntime_gc_itab_ptr(Eface*);\n void\truntime_memorydump(void);\n \n void\truntime_time_scan(void (*)(Obj));\n-void\truntime_trampoline_scan(void (*)(Obj));"}, {"sha": "407092bf39247387a9aeedc702093d87feadd015", "filename": "libgo/runtime/mfinal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fmfinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fmfinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmfinal.c?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -11,7 +11,7 @@ enum { debug = 0 };\n typedef struct Fin Fin;\n struct Fin\n {\n-\tvoid (*fn)(void*);\n+\tFuncVal *fn;\n \tconst struct __go_func_type *ft;\n };\n \n@@ -42,7 +42,7 @@ static struct {\n } fintab[TABSZ];\n \n static void\n-addfintab(Fintab *t, void *k, void (*fn)(void*), const struct __go_func_type *ft)\n+addfintab(Fintab *t, void *k, FuncVal *fn, const struct __go_func_type *ft)\n {\n \tint32 i, j;\n \n@@ -137,7 +137,7 @@ resizefintab(Fintab *tab)\n }\n \n bool\n-runtime_addfinalizer(void *p, void (*f)(void*), const struct __go_func_type *ft)\n+runtime_addfinalizer(void *p, FuncVal *f, const struct __go_func_type *ft)\n {\n \tFintab *tab;\n \tbyte *base;\n@@ -175,7 +175,7 @@ runtime_addfinalizer(void *p, void (*f)(void*), const struct __go_func_type *ft)\n // get finalizer; if del, delete finalizer.\n // caller is responsible for updating RefHasFinalizer (special) bit.\n bool\n-runtime_getfinalizer(void *p, bool del, void (**fn)(void*), const struct __go_func_type **ft)\n+runtime_getfinalizer(void *p, bool del, FuncVal **fn, const struct __go_func_type **ft)\n {\n \tFintab *tab;\n \tbool res;"}, {"sha": "88283ccab2b10a5b73ecddcf1ef6068730e48894", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -120,7 +120,7 @@ struct Workbuf\n typedef struct Finalizer Finalizer;\n struct Finalizer\n {\n-\tvoid (*fn)(void*);\n+\tFuncVal *fn;\n \tvoid *arg;\n \tconst struct __go_func_type *ft;\n };\n@@ -1130,7 +1130,6 @@ addroots(void)\n \taddroot((Obj){(byte*)&runtime_allm, sizeof runtime_allm, 0});\n \truntime_MProf_Mark(addroot);\n \truntime_time_scan(addroot);\n-\truntime_trampoline_scan(addroot);\n \n \t// MSpan.types\n \tallspans = runtime_mheap.allspans;\n@@ -1182,7 +1181,7 @@ addroots(void)\n static bool\n handlespecial(byte *p, uintptr size)\n {\n-\tvoid (*fn)(void*);\n+\tFuncVal *fn;\n \tconst struct __go_func_type *ft;\n \tFinBlock *block;\n \tFinalizer *f;\n@@ -1731,11 +1730,12 @@ runfinq(void* dummy __attribute__ ((unused)))\n \t\tfor(; fb; fb=next) {\n \t\t\tnext = fb->next;\n \t\t\tfor(i=0; i<(uint32)fb->cnt; i++) {\n-\t\t\t\tvoid *params[1];\n+\t\t\t\tvoid *params[2];\n \n \t\t\t\tf = &fb->fin[i];\n \t\t\t\tparams[0] = &f->arg;\n-\t\t\t\treflect_call(f->ft, (void*)f->fn, 0, 0, params, nil);\n+\t\t\t\tparams[1] = f;\n+\t\t\t\treflect_call(f->ft, f->fn, 0, 0, params, nil);\n \t\t\t\tf->fn = nil;\n \t\t\t\tf->arg = nil;\n \t\t\t}"}, {"sha": "65ca586eadb1a520bdf988311b929ed05966a636", "filename": "libgo/runtime/parfor.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fparfor.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fparfor.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fparfor.c?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -83,7 +83,7 @@ void runtime_parforsetup2(ParFor *, uint32, uint32, void *, bool, void *)\n void\n runtime_parforsetup2(ParFor *desc, uint32 nthr, uint32 n, void *ctx, bool wait, void *body)\n {\n-\truntime_parforsetup(desc, nthr, n, ctx, wait, (void(*)(ParFor*, uint32))body);\n+\truntime_parforsetup(desc, nthr, n, ctx, wait, *(void(**)(ParFor*, uint32))body);\n }\n \n void"}, {"sha": "959220d734cebfe18b9ad21c499327931cdc3854", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -57,6 +57,7 @@ typedef\tstruct\tG\t\tG;\n typedef\tunion\tLock\t\tLock;\n typedef\tstruct\tM\t\tM;\n typedef\tunion\tNote\t\tNote;\n+typedef\tstruct\tFuncVal\t\tFuncVal;\n typedef\tstruct\tSigTab\t\tSigTab;\n typedef\tstruct\tMCache\t\tMCache;\n typedef struct\tFixAlloc\tFixAlloc;\n@@ -147,6 +148,11 @@ struct String\n \tconst byte*\tstr;\n \tintgo\t\tlen;\n };\n+struct FuncVal\n+{\n+\tvoid\t(*fn)(void);\n+\t// variable-size, fn-specific data here\n+};\n struct\tGCStats\n {\n \t// the struct must consist of only uint64's,\n@@ -313,7 +319,7 @@ struct\tTimer\n \t// a well-behaved function and not block.\n \tint64\twhen;\n \tint64\tperiod;\n-\tvoid\t(*f)(int64, Eface);\n+\tFuncVal\t*fv;\n \tEface\targ;\n };\n \n@@ -540,7 +546,7 @@ void\truntime_printslice(Slice);\n void\truntime_printcomplex(__complex double);\n \n struct __go_func_type;\n-void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,\n+void reflect_call(const struct __go_func_type *, FuncVal *, _Bool, _Bool,\n \t\t  void **, void **)\n   __asm__ (GOSYM_PREFIX \"reflect.call\");\n \n@@ -570,7 +576,7 @@ void\tfree(void *v);\n #define PREFETCH(p) __builtin_prefetch(p)\n \n struct __go_func_type;\n-bool\truntime_addfinalizer(void*, void(*fn)(void*), const struct __go_func_type *);\n+bool\truntime_addfinalizer(void*, FuncVal *fn, const struct __go_func_type *);\n #define runtime_getcallersp(p) __builtin_frame_address(1)\n int32\truntime_mcount(void);\n int32\truntime_gcount(void);"}, {"sha": "e9f087ac88490895f6150081bd6af11f0d902973", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=fdbc38a6e8d7c920eea6c6231c7fe2c987fa8aa2", "patch": "@@ -49,13 +49,16 @@ static void siftdown(int32);\n \n // Ready the goroutine e.data.\n static void\n-ready(int64 now, Eface e)\n+ready(int64 now, Eface e, void *closure)\n {\n \tUSED(now);\n+\tUSED(closure);\n \n \truntime_ready(e.__object);\n }\n \n+static FuncVal readyv = {(void(*)(void))ready};\n+\n // Put the current goroutine to sleep for ns nanoseconds.\n void\n runtime_tsleep(int64 ns, const char *reason)\n@@ -70,7 +73,7 @@ runtime_tsleep(int64 ns, const char *reason)\n \n \tt.when = runtime_nanotime() + ns;\n \tt.period = 0;\n-\tt.f = ready;\n+\tt.fv = &readyv;\n \tt.arg.__object = g;\n \truntime_lock(&timers);\n \taddtimer(&t);\n@@ -158,7 +161,7 @@ timerproc(void* dummy __attribute__ ((unused)))\n {\n \tint64 delta, now;\n \tTimer *t;\n-\tvoid (*f)(int64, Eface);\n+\tvoid (*f)(int64, Eface, void *);\n \tEface arg;\n \n \tfor(;;) {\n@@ -184,12 +187,12 @@ timerproc(void* dummy __attribute__ ((unused)))\n \t\t\t\tsiftdown(0);\n \t\t\t\tt->i = -1;  // mark as removed\n \t\t\t}\n-\t\t\tf = t->f;\n+\t\t\tf = (void*)t->fv->fn;\n \t\t\targ = t->arg;\n \t\t\truntime_unlock(&timers);\n \t\t\tif(raceenabled)\n \t\t\t\truntime_raceacquire(t);\n-\t\t\tf(now, arg);\n+\t\t\tf(now, arg, &t->fv);\n \t\t\truntime_lock(&timers);\n \t\t}\n \t\tif(delta < 0) {"}]}