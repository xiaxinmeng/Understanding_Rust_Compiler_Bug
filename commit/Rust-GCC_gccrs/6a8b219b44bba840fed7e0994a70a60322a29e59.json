{"sha": "6a8b219b44bba840fed7e0994a70a60322a29e59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE4YjIxOWI0NGJiYTg0MGZlZDdlMDk5NGE3MGE2MDMyMmEyOWU1OQ==", "commit": {"author": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-16T07:14:21Z"}, "committer": {"name": "Adam Butcher", "email": "abutcher@gcc.gnu.org", "date": "2013-09-16T07:14:21Z"}, "message": "Support lambda templates.\n\n\t* parser.c (cp_parser_lambda_declarator_opt): Accept template parameter\n\tlist with std=c++1y or std=gnu++1y.\n\t(cp_parser_lambda_body): Don't call 'expand_or_defer_fn' for lambda call\n\toperator template to avoid adding template result to symbol table.\n\t* lambda.c (lambda_function): Return template result if call operator is\n\ta template.\n\t(maybe_add_lambda_conv_op): Move declarations to point of use.  Refactor\n\toperator call building in order to support conversion of a non-capturing\n\tlambda template to a function pointer with help from ...\n\t(prepare_op_call): ... this new function.\n\t* decl2.c (check_member_template): Don't reject lambda call operator\n\ttemplate in local [lambda] class.\n\t* pt.c (instantiate_class_template_1): Don't instantiate lambda call\n\toperator template when instantiating lambda class.\n\nFrom-SVN: r202611", "tree": {"sha": "5cae05f391ae11f9176555d4c512a76384bc6e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cae05f391ae11f9176555d4c512a76384bc6e3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a8b219b44bba840fed7e0994a70a60322a29e59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8b219b44bba840fed7e0994a70a60322a29e59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a8b219b44bba840fed7e0994a70a60322a29e59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8b219b44bba840fed7e0994a70a60322a29e59/comments", "author": null, "committer": null, "parents": [{"sha": "ff63a2f45cf4cead28be7711c83aa7d96b195031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff63a2f45cf4cead28be7711c83aa7d96b195031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff63a2f45cf4cead28be7711c83aa7d96b195031"}], "stats": {"total": 237, "additions": 201, "deletions": 36}, "files": [{"sha": "4ac9445ecc999d9879d3de39aaa95e419807a049", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6a8b219b44bba840fed7e0994a70a60322a29e59", "patch": "@@ -502,8 +502,9 @@ check_member_template (tree tmpl)\n       || (TREE_CODE (decl) == TYPE_DECL\n \t  && MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))))\n     {\n-      /* The parser rejects template declarations in local classes.  */\n-      gcc_assert (!current_function_decl);\n+      /* The parser rejects template declarations in local classes\n+\t (with the exception of generic lambdas).  */\n+      gcc_assert (!current_function_decl || LAMBDA_FUNCTION_P (decl));\n       /* The parser rejects any use of virtual in a function template.  */\n       gcc_assert (!(TREE_CODE (decl) == FUNCTION_DECL\n \t\t    && DECL_VIRTUAL_P (decl)));"}, {"sha": "b04448b548726e1e3d2b0e0465fbb616c0053e4d", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 158, "deletions": 30, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=6a8b219b44bba840fed7e0994a70a60322a29e59", "patch": "@@ -196,7 +196,7 @@ lambda_function (tree lambda)\n \t\t\t  /*protect=*/0, /*want_type=*/false,\n \t\t\t  tf_warning_or_error);\n   if (lambda)\n-    lambda = BASELINK_FUNCTIONS (lambda);\n+    lambda = STRIP_TEMPLATE (get_first_fn (lambda));\n   return lambda;\n }\n \n@@ -775,6 +775,22 @@ nonlambda_method_basetype (void)\n   return TYPE_METHOD_BASETYPE (TREE_TYPE (fn));\n }\n \n+/* Helper function for maybe_add_lambda_conv_op; build a CALL_EXPR with\n+   indicated FN and NARGS, but do not initialize the return type or any of the\n+   argument slots.  */\n+\n+static tree\n+prepare_op_call (tree fn, int nargs)\n+{\n+  tree t;\n+\n+  t = build_vl_exp (CALL_EXPR, nargs + 3);\n+  CALL_EXPR_FN (t) = fn;\n+  CALL_EXPR_STATIC_CHAIN (t) = NULL;\n+\n+  return t;\n+}\n+\n /* If the closure TYPE has a static op(), also add a conversion to function\n    pointer.  */\n \n@@ -783,33 +799,142 @@ maybe_add_lambda_conv_op (tree type)\n {\n   bool nested = (current_function_decl != NULL_TREE);\n   tree callop = lambda_function (type);\n-  tree rettype, name, fntype, fn, body, compound_stmt;\n-  tree thistype, stattype, statfn, convfn, call, arg;\n-  vec<tree, va_gc> *argvec;\n \n   if (LAMBDA_EXPR_CAPTURE_LIST (CLASSTYPE_LAMBDA_EXPR (type)) != NULL_TREE)\n     return;\n \n   if (processing_template_decl)\n     return;\n \n+  bool const generic_lambda_p\n+    = (DECL_TEMPLATE_INFO (callop)\n+    && DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (callop)) == callop);\n+\n   if (DECL_INITIAL (callop) == NULL_TREE)\n     {\n       /* If the op() wasn't instantiated due to errors, give up.  */\n       gcc_assert (errorcount || sorrycount);\n       return;\n     }\n \n-  stattype = build_function_type (TREE_TYPE (TREE_TYPE (callop)),\n-\t\t\t\t  FUNCTION_ARG_CHAIN (callop));\n+  /* Non-template conversion operators are defined directly with build_call_a\n+     and using DIRECT_ARGVEC for arguments (including 'this').  Templates are\n+     deferred and the CALL is built in-place.  In the case of a deduced return\n+     call op, the decltype expression, DECLTYPE_CALL, used as a substitute for\n+     the return type is also built in-place.  The arguments of DECLTYPE_CALL in\n+     the return expression may differ in flags from those in the body CALL.  In\n+     particular, parameter pack expansions are marked PACK_EXPANSION_LOCAL_P in\n+     the body CALL, but not in DECLTYPE_CALL.  */\n+\n+  vec<tree, va_gc> *direct_argvec = 0;\n+  tree decltype_call = 0, call = 0;\n+  tree fn_result = TREE_TYPE (TREE_TYPE (callop));\n+\n+  if (generic_lambda_p)\n+    {\n+      /* Prepare the dependent member call for the static member function\n+\t '_FUN' and, potentially, prepare another call to be used in a decltype\n+\t return expression for a deduced return call op to allow for simple\n+\t implementation of the conversion operator.  */\n+\n+      tree instance = build_nop (type, null_pointer_node);\n+      tree objfn = build_min (COMPONENT_REF, NULL_TREE,\n+\t\t\t      instance, DECL_NAME (callop), NULL_TREE);\n+      int nargs = list_length (DECL_ARGUMENTS (callop)) - 1;\n+\n+      call = prepare_op_call (objfn, nargs);\n+      if (type_uses_auto (fn_result))\n+\tdecltype_call = prepare_op_call (objfn, nargs);\n+    }\n+  else\n+    {\n+      direct_argvec = make_tree_vector ();\n+      direct_argvec->quick_push (build1 (NOP_EXPR,\n+\t\t\t\t\t TREE_TYPE (DECL_ARGUMENTS (callop)),\n+\t\t\t\t\t null_pointer_node));\n+    }\n+\n+  /* Copy CALLOP's argument list (as per 'copy_list') as FN_ARGS in order to\n+     declare the static member function \"_FUN\" below.  For each arg append to\n+     DIRECT_ARGVEC (for the non-template case) or populate the pre-allocated\n+     call args (for the template case).  If a parameter pack is found, expand\n+     it, flagging it as PACK_EXPANSION_LOCAL_P for the body call.  */\n+\n+  tree fn_args = NULL_TREE;\n+  {\n+    int ix = 0;\n+    tree src = DECL_CHAIN (DECL_ARGUMENTS (callop));\n+    tree tgt;\n+\n+    while (src)\n+      {\n+\ttree new_node = copy_node (src);\n+\n+\tif (!fn_args)\n+\t  fn_args = tgt = new_node;\n+\telse\n+\t  {\n+\t    TREE_CHAIN (tgt) = new_node;\n+\t    tgt = new_node;\n+\t  }\n+\n+\tmark_exp_read (tgt);\n+\n+\tif (generic_lambda_p)\n+\t  {\n+\t    if (DECL_PACK_P (tgt))\n+\t      {\n+\t\ttree a = make_pack_expansion (tgt);\n+\t\tif (decltype_call)\n+\t\t  CALL_EXPR_ARG (decltype_call, ix) = copy_node (a);\n+\t\tPACK_EXPANSION_LOCAL_P (a) = true;\n+\t\tCALL_EXPR_ARG (call, ix) = a;\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree a = convert_from_reference (tgt);\n+\t\tCALL_EXPR_ARG (call, ix) = a;\n+\t\tif (decltype_call)\n+\t\t  CALL_EXPR_ARG (decltype_call, ix) = copy_node (a);\n+\t      }\n+\t    ++ix;\n+\t  }\n+\telse\n+\t  vec_safe_push (direct_argvec, tgt);\n+\n+\tsrc = TREE_CHAIN (src);\n+      }\n+  }\n+\n+\n+  if (generic_lambda_p)\n+    {\n+      if (decltype_call)\n+\t{\n+\t  ++processing_template_decl;\n+\t  fn_result = finish_decltype_type\n+\t    (decltype_call, /*id_expression_or_member_access_p=*/false,\n+\t     tf_warning_or_error);\n+\t  --processing_template_decl;\n+\t}\n+    }\n+  else\n+    call = build_call_a (callop,\n+\t\t\t direct_argvec->length (),\n+\t\t\t direct_argvec->address ());\n+\n+  CALL_FROM_THUNK_P (call) = 1;\n+\n+  tree stattype = build_function_type (fn_result, FUNCTION_ARG_CHAIN (callop));\n \n   /* First build up the conversion op.  */\n \n-  rettype = build_pointer_type (stattype);\n-  name = mangle_conv_op_name_for_type (rettype);\n-  thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n-  fntype = build_method_type_directly (thistype, rettype, void_list_node);\n-  fn = convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n+  tree rettype = build_pointer_type (stattype);\n+  tree name = mangle_conv_op_name_for_type (rettype);\n+  tree thistype = cp_build_qualified_type (type, TYPE_QUAL_CONST);\n+  tree fntype = build_method_type_directly (thistype, rettype, void_list_node);\n+  tree convfn = build_lang_decl (FUNCTION_DECL, name, fntype);\n+  tree fn = convfn;\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n \n   if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n@@ -828,6 +953,9 @@ maybe_add_lambda_conv_op (tree type)\n   if (nested)\n     DECL_INTERFACE_KNOWN (fn) = 1;\n \n+  if (generic_lambda_p)\n+    fn = add_inherited_template_parms (fn, DECL_TI_TEMPLATE (callop));\n+\n   add_method (type, fn, NULL_TREE);\n \n   /* Generic thunk code fails for varargs; we'll complain in mark_used if\n@@ -841,7 +969,8 @@ maybe_add_lambda_conv_op (tree type)\n   /* Now build up the thunk to be returned.  */\n \n   name = get_identifier (\"_FUN\");\n-  fn = statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n+  tree statfn = build_lang_decl (FUNCTION_DECL, name, stattype);\n+  fn = statfn;\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n   if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn\n       && DECL_ALIGN (fn) < 2 * BITS_PER_UNIT)\n@@ -854,8 +983,8 @@ maybe_add_lambda_conv_op (tree type)\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   DECL_STATIC_FUNCTION_P (fn) = 1;\n-  DECL_ARGUMENTS (fn) = copy_list (DECL_CHAIN (DECL_ARGUMENTS (callop)));\n-  for (arg = DECL_ARGUMENTS (fn); arg; arg = DECL_CHAIN (arg))\n+  DECL_ARGUMENTS (fn) = fn_args;\n+  for (tree arg = fn_args; arg; arg = DECL_CHAIN (arg))\n     {\n       /* Avoid duplicate -Wshadow warnings.  */\n       DECL_NAME (arg) = NULL_TREE;\n@@ -864,6 +993,9 @@ maybe_add_lambda_conv_op (tree type)\n   if (nested)\n     DECL_INTERFACE_KNOWN (fn) = 1;\n \n+  if (generic_lambda_p)\n+    fn = add_inherited_template_parms (fn, DECL_TI_TEMPLATE (callop));\n+\n   add_method (type, fn, NULL_TREE);\n \n   if (nested)\n@@ -884,29 +1016,23 @@ maybe_add_lambda_conv_op (tree type)\n \t ((symtab_node) cgraph_get_create_node (statfn),\n           (symtab_node) cgraph_get_create_node (callop));\n     }\n-  body = begin_function_body ();\n-  compound_stmt = begin_compound_stmt (0);\n-\n-  arg = build1 (NOP_EXPR, TREE_TYPE (DECL_ARGUMENTS (callop)),\n-\t\tnull_pointer_node);\n-  argvec = make_tree_vector ();\n-  argvec->quick_push (arg);\n-  for (arg = DECL_ARGUMENTS (statfn); arg; arg = DECL_CHAIN (arg))\n+  tree body = begin_function_body ();\n+  tree compound_stmt = begin_compound_stmt (0);\n+  if (!generic_lambda_p)\n     {\n-      mark_exp_read (arg);\n-      vec_safe_push (argvec, arg);\n+      set_flags_from_callee (call);\n+      if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n+\tcall = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);\n     }\n-  call = build_call_a (callop, argvec->length (), argvec->address ());\n-  CALL_FROM_THUNK_P (call) = 1;\n-  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (call)))\n-    call = build_cplus_new (TREE_TYPE (call), call, tf_warning_or_error);\n   call = convert_from_reference (call);\n   finish_return_stmt (call);\n \n   finish_compound_stmt (compound_stmt);\n   finish_function_body (body);\n \n-  expand_or_defer_fn (finish_function (2));\n+  fn = finish_function (/*inline*/2);\n+  if (!generic_lambda_p)\n+    expand_or_defer_fn (fn);\n \n   /* Generate the body of the conversion op.  */\n \n@@ -922,7 +1048,9 @@ maybe_add_lambda_conv_op (tree type)\n   finish_compound_stmt (compound_stmt);\n   finish_function_body (body);\n \n-  expand_or_defer_fn (finish_function (2));\n+  fn = finish_function (/*inline*/2);\n+  if (!generic_lambda_p)\n+    expand_or_defer_fn (fn);\n \n   if (nested)\n     pop_function_context ();"}, {"sha": "d109be524448753043d1bc8338c216a91149840c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6a8b219b44bba840fed7e0994a70a60322a29e59", "patch": "@@ -8791,6 +8791,7 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n /* Parse the (optional) middle of a lambda expression.\n \n    lambda-declarator:\n+     < template-parameter-list [opt] >\n      ( parameter-declaration-clause [opt] )\n        attribute-specifier [opt]\n        mutable [opt]\n@@ -8810,9 +8811,30 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n   tree param_list = void_list_node;\n   tree attributes = NULL_TREE;\n   tree exception_spec = NULL_TREE;\n+  tree template_param_list = NULL_TREE;\n \n-  /* The lambda-declarator is optional, but must begin with an opening\n-     parenthesis if present.  */\n+  /* The template-parameter-list is optional, but must begin with\n+     an opening angle if present.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n+    {\n+      if (cxx_dialect < cxx1y)\n+\tpedwarn (parser->lexer->next_token->location, 0,\n+\t\t \"lambda templates are only available with \"\n+\t\t \"-std=c++1y or -std=gnu++1y\");\n+\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      template_param_list = cp_parser_template_parameter_list (parser);\n+\n+      cp_parser_skip_to_end_of_template_parameter_list (parser);\n+\n+      /* We just processed one more parameter list.  */\n+      ++parser->num_template_parameter_lists;\n+    }\n+\n+  /* The parameter-declaration-clause is optional (unless\n+     template-parameter-list was given), but must begin with an\n+     opening parenthesis if present.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n       cp_lexer_consume_token (parser->lexer);\n@@ -8855,6 +8877,8 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n          trailing-return-type in case of decltype.  */\n       pop_bindings_and_leave_scope ();\n     }\n+  else if (template_param_list != NULL_TREE) // generate diagnostic\n+    cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n   /* Create the function call operator.\n \n@@ -8898,6 +8922,12 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \tDECL_ARTIFICIAL (fco) = 1;\n \t/* Give the object parameter a different name.  */\n \tDECL_NAME (DECL_ARGUMENTS (fco)) = get_identifier (\"__closure\");\n+\tif (template_param_list)\n+\t  {\n+\t    fco = finish_member_template_decl (fco);\n+\t    finish_template_decl (template_param_list);\n+\t    --parser->num_template_parameter_lists;\n+\t  }\n       }\n \n     finish_member_declaration (fco);\n@@ -9020,7 +9050,11 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n     finish_lambda_scope ();\n \n     /* Finish the function and generate code for it if necessary.  */\n-    expand_or_defer_fn (finish_function (/*inline*/2));\n+    tree fn = finish_function (/*inline*/2);\n+\n+    /* Only expand if the call op is not a template.  */\n+    if (!DECL_TEMPLATE_INFO (fco))\n+      expand_or_defer_fn (fn);\n   }\n \n   parser->local_variables_forbidden_p = local_variables_forbidden_p;"}, {"sha": "564ffca486a469bf5f19326ad4fcd421eaba6268", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8b219b44bba840fed7e0994a70a60322a29e59/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6a8b219b44bba840fed7e0994a70a60322a29e59", "patch": "@@ -9142,7 +9142,9 @@ instantiate_class_template_1 (tree type)\n       tree decl = lambda_function (type);\n       if (decl)\n \t{\n-\t  instantiate_decl (decl, false, false);\n+\t  if (!DECL_TEMPLATE_INFO (decl)\n+\t      || DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (decl)) != decl)\n+\t    instantiate_decl (decl, false, false);\n \n \t  /* We need to instantiate the capture list from the template\n \t     after we've instantiated the closure members, but before we"}]}