{"sha": "eb34af89c78f8b04af925cc272e4462c0316f54b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIzNGFmODljNzhmOGIwNGFmOTI1Y2MyNzJlNDQ2MmMwMzE2ZjU0Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-03-18T20:58:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-03-18T20:58:49Z"}, "message": "tree.h (TREE_CHECK2, [...]): New macros.\n\n\t* tree.h (TREE_CHECK2, TREE_CHECK3, TREE_CHECK5): New macros.\n\t(tree_check2_failed, tree_check3_failed, tree_check5_failed): New decl.\n\t(FUNC_OR_METHOD_CHECK, SET_ARRAY_OR_VECTOR_CHECK): New macros.\n\t(REC_OR_UNION_CHECK, NUMERICAL_TYPE_CHECK): Likewise.\n\t(TYPE_VALUES, TYPE_DOMAIN, TYPE_FIELDS, TYPE_METHODS, TYPE_VFIELD):\n\tProtect with proper check.\n\t(TYPE_ARG_TYPES, TYPE_METHOD_BASETYPE, TYPE_OFFSET_BASETYPE): Likewise.\n\t(TYPE_MIN_VALUE, TYPE_MAX_VALUE): Likewise.\n\t* tree.c (type_hash_eq): Rewrite to access proper fields for each type.\n\t(tree_check2_failed, tree_check3_failed, tree_check5_failed): New.\n\t* c-typeck.c (build_array_ref): Use TYPE_DOMAIN, not TYPE_VALUES.\n\t* dwarf2out.c (gen_enumeration_type_die): Use TYPE_VALUES,\n\tnot TYPE_FIELDS.\n\n\t* cp/class.c (finish_struct_bits): Use TYPE_VFIELD and TYPE_METHODS.\n\t* cp/error.c (dump_type): Use TYPEOF_TYPE_EXPR.\n\t* cp/pt.c (tsubst): Likewise.\n\t* cp/semantics.c (finish_typeof): Likewise.\n\t* cp/search.c (dfs_unuse_fields): Handle TYPENAME_TYPE, TYPEOF_TYPE,\n\tand TEMPLATE_TYPE_PARM.\n\t* cp/typeck.c (comptypes): Use TYPE_ORIG_SIZE_TYPE, not TYPE_DOMAIN.\n\t(build_array_ref): Use TYPE_DOMAIN, not TYPE_VALUES.\n\n\t* java/java-tree.h: Changes throughout to add checking to macros\n\tand numerous whitespace changes.\n\t(VAR_OR_FIELD_CHECK): New macro.\n\t* java/jcf-write.c (get_access_flags): Use FIELD_PUBLIC, METHOD_PUBLIC,\n\tFIELD_FINAL, and METHOD_FINAL instead of CLASS_PUBLIC and CLASS_FINAL.\n\n\t* ada/ada-tree.h (TYPE_LEFT_JUSTIFIED_MODULAR_P): Add checking.\n\t(TYPE_CONTAINS_TEMPLATE_P, TYPE_OBJECT_RECORD_TYPE): Likewise.\n\t(TYPE_RM_SIZE_INT): Directly use type.values.\n\t(TREE_LOOP_ID): Clean up check.\n\t* ada/decl.c (gnat_to_gnu_entity, case E_Enumeration_Type): Use\n\tTYPE_VALUES, not TYPE_FIELDS.\n\t* ada/trans.c (convert_with_check): Delay access of bounds of basetype\n\tuntil sure is numeric.\n\nFrom-SVN: r79638", "tree": {"sha": "0875ec0eb3d6d6c3b4e1cf03f0041e6817f9baa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0875ec0eb3d6d6c3b4e1cf03f0041e6817f9baa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb34af89c78f8b04af925cc272e4462c0316f54b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb34af89c78f8b04af925cc272e4462c0316f54b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb34af89c78f8b04af925cc272e4462c0316f54b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb34af89c78f8b04af925cc272e4462c0316f54b/comments", "author": null, "committer": null, "parents": [{"sha": "2171cb855efea2f8c6b71a5ed57bf97dd358b6c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2171cb855efea2f8c6b71a5ed57bf97dd358b6c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2171cb855efea2f8c6b71a5ed57bf97dd358b6c2"}], "stats": {"total": 730, "additions": 490, "deletions": 240}, "files": [{"sha": "b6c327c9674fc82b7b9777e942d709142883a9f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1,8 +1,25 @@\n+2004-03-18  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\t\n+\t* tree.h (TREE_CHECK2, TREE_CHECK3, TREE_CHECK5): New macros.\n+\t(tree_check2_failed, tree_check3_failed, tree_check5_failed): New decl.\n+\t(FUNC_OR_METHOD_CHECK, SET_ARRAY_OR_VECTOR_CHECK): New macros.\n+\t(REC_OR_UNION_CHECK, NUMERICAL_TYPE_CHECK): Likewise.\n+\t(TYPE_VALUES, TYPE_DOMAIN, TYPE_FIELDS, TYPE_METHODS, TYPE_VFIELD):\n+\tProtect with proper check.\n+\t(TYPE_ARG_TYPES, TYPE_METHOD_BASETYPE, TYPE_OFFSET_BASETYPE): Likewise.\n+\t(TYPE_MIN_VALUE, TYPE_MAX_VALUE): Likewise.\n+\t* tree.c (type_hash_eq): Rewrite to access proper fields for each type.\n+\t(tree_check2_failed, tree_check3_failed, tree_check5_failed): New.\n+\t* c-typeck.c (build_array_ref): Use TYPE_DOMAIN, not TYPE_VALUES.\n+\t* dwarf2out.c (gen_enumeration_type_die): Use TYPE_VALUES,\n+\tnot TYPE_FIELDS.\n+\n 2004-03-18  Mostafa Hagog  <mustafa@il.ibm.com>\n \n \t* gcse.c (eliminate_partially_redundant_loads): Reject change if\n \tdest is set between beginning and current insn.\n \n+>>>>>>> 2.3204\n 2004-03-18  Mark Mitchell  <mark@codesourcery.com>\n \n \t* c-decl.c (grokdeclarator): Do not complain about redeclaring\n@@ -47,6 +64,7 @@\n         * config/rs6000/rs6000.h: Definition of DWARF_CIE_DATA_ALIGNMENT\n         macro for mixed mode.\n \n+>>>>>>> 2.3203\n 2004-03-18  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (propagate_freq): Compute correctly frequency of"}, {"sha": "c614f8f06de499747bb673b472a5e45acc4e4afa", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1,3 +1,14 @@\n+2004-03-18  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* ada-tree.h (TYPE_LEFT_JUSTIFIED_MODULAR_P): Add checking.\n+\t(TYPE_CONTAINS_TEMPLATE_P, TYPE_OBJECT_RECORD_TYPE): Likewise.\n+\t(TYPE_RM_SIZE_INT): Directly use type.values.\n+\t(TREE_LOOP_ID): Clean up check.\n+\t* decl.c (gnat_to_gnu_entity, case E_Enumeration_Type): Use\n+\tTYPE_VALUES, not TYPE_FIELDS.\n+\t* trans.c (convert_with_check): Delay access of bounds of basetype\n+\tuntil sure is numeric.\n+\n 2004-03-18  Arnaud Charlet  <charlet@act-europe.fr>\n \n \t* 5atpopsp.adb: Remove RTEMS from list of platforms using this file."}, {"sha": "78d9a56de6a5d2c30fa08ed17aebd51e58203602", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -95,7 +95,8 @@ struct lang_type GTY(())\n \n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n    a left-justified modular type (will only be true for RECORD_TYPE).  */\n-#define TYPE_LEFT_JUSTIFIED_MODULAR_P(NODE) TYPE_LANG_FLAG_1 (NODE)\n+#define TYPE_LEFT_JUSTIFIED_MODULAR_P(NODE) \\\n+  TYPE_LANG_FLAG_1 (REC_OR_UNION_CHECK (NODE))\n \n /* Nonzero in an arithmetic subtype if this is a subtype not known to the\n    front-end.  */\n@@ -107,7 +108,8 @@ struct lang_type GTY(())\n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this is the\n    type for an object whose type includes its template in addition to\n    its value (only true for RECORD_TYPE).  */\n-#define TYPE_CONTAINS_TEMPLATE_P(NODE) TYPE_LANG_FLAG_3 (NODE)\n+#define TYPE_CONTAINS_TEMPLATE_P(NODE) \\\n+  TYPE_LANG_FLAG_3 (REC_OR_UNION_CHECK (NODE))\n \n /* For INTEGER_TYPE, nonzero if this really represents a VAX\n    floating-point type.  */\n@@ -188,7 +190,7 @@ struct lang_type GTY(())\n   (TYPE_LANG_SPECIFIC (INTEGER_TYPE_CHECK (NODE)) = (struct lang_type *) (X))\n \n /* For INTEGER_TYPE, stores the RM_Size of the type.  */\n-#define TYPE_RM_SIZE_INT(NODE)\tTYPE_VALUES (INTEGER_TYPE_CHECK (NODE))\n+#define TYPE_RM_SIZE_INT(NODE)\t(INTEGER_TYPE_CHECK (NODE)->type.values)\n \n /* Likewise for ENUMERAL_TYPE.  */\n #define TYPE_RM_SIZE_ENUM(NODE)\t\\\n@@ -224,8 +226,13 @@ struct lang_type GTY(())\n   (TYPE_LANG_SPECIFIC (NODE) = (struct lang_type *)(X))\n \n /* In an UNCONSTRAINED_ARRAY_TYPE, points to the record containing both\n-   the template and object.  */\n-#define TYPE_OBJECT_RECORD_TYPE(NODE) TYPE_MIN_VALUE (NODE)\n+   the template and object.\n+\n+   ??? We also put this on an ENUMERAL_TYPE that's dummy.  Technically,\n+   this is a conflict on the minval field, but there doesn't seem to be\n+   simple fix, so we'll live with this kludge for now.  */\n+#define TYPE_OBJECT_RECORD_TYPE(NODE) \\\n+  (TREE_CHECK2 ((NODE), UNCONSTRAINED_ARRAY_TYPE, ENUMERAL_TYPE)->type.minval)\n \n /* Nonzero in a FUNCTION_DECL that represents a stubbed function\n    discriminant.  */\n@@ -277,7 +284,7 @@ struct lang_type GTY(())\n \n /* This is the loop id for a GNAT_LOOP_ID node.  */\n #define TREE_LOOP_ID(NODE) \\\n-  ((union lang_tree_node *) TREE_CHECK (NODE, GNAT_LOOP_ID))->loop_id.loop_id\n+  ((union lang_tree_node *) GNAT_LOOP_ID_CHECK (NODE))->loop_id.loop_id\n \n /* Define fields and macros for statements.\n "}, {"sha": "1ca2304e5972664b3ce81e59413b647ec2e1d88f", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1172,7 +1172,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t  gnu_value, gnu_literal_list);\n \t  }\n \n-\tTYPE_FIELDS (gnu_type) = nreverse (gnu_literal_list);\n+\tTYPE_VALUES (gnu_type) = nreverse (gnu_literal_list);\n \n \t/* Note that the bounds are updated at the end of this function\n \t   because to avoid an infinite recursion when we get the bounds of"}, {"sha": "69e80d48c280c4f6d502e756cd0368f5aeed334e", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -4714,10 +4714,6 @@ convert_with_check (Entity_Id gnat_type,\n   tree gnu_in_basetype = get_base_type (gnu_in_type);\n   tree gnu_base_type = get_base_type (gnu_type);\n   tree gnu_ada_base_type = get_ada_base_type (gnu_type);\n-  tree gnu_in_lb = TYPE_MIN_VALUE (gnu_in_basetype);\n-  tree gnu_in_ub = TYPE_MAX_VALUE (gnu_in_basetype);\n-  tree gnu_out_lb = TYPE_MIN_VALUE (gnu_base_type);\n-  tree gnu_out_ub = TYPE_MAX_VALUE (gnu_base_type);\n   tree gnu_result = gnu_expr;\n \n   /* If we are not doing any checks, the output is an integral type, and\n@@ -4745,6 +4741,10 @@ convert_with_check (Entity_Id gnat_type,\n       /* Ensure GNU_EXPR only gets evaluated once.  */\n       tree gnu_input = protect_multiple_eval (gnu_result);\n       tree gnu_cond = integer_zero_node;\n+      tree gnu_in_lb = TYPE_MIN_VALUE (gnu_in_basetype);\n+      tree gnu_in_ub = TYPE_MAX_VALUE (gnu_in_basetype);\n+      tree gnu_out_lb = TYPE_MIN_VALUE (gnu_base_type);\n+      tree gnu_out_ub = TYPE_MAX_VALUE (gnu_base_type);\n \n       /* Convert the lower bounds to signed types, so we're sure we're\n \t comparing them properly.  Likewise, convert the upper bounds"}, {"sha": "1d069a9289cdc294157b26a8528fdff2c9cec6bc", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1510,8 +1510,8 @@ build_array_ref (tree array, tree index)\n \t would get a crash in store_bit_field/extract_bit_field when trying\n \t to access a non-existent part of the register.  */\n       if (TREE_CODE (index) == INTEGER_CST\n-\t  && TYPE_VALUES (TREE_TYPE (array))\n-\t  && ! int_fits_type_p (index, TYPE_VALUES (TREE_TYPE (array))))\n+\t  && TYPE_DOMAIN (TREE_TYPE (array))\n+\t  && ! int_fits_type_p (index, TYPE_DOMAIN (TREE_TYPE (array))))\n \t{\n \t  if (!c_mark_addressable (array))\n \t    return error_mark_node;"}, {"sha": "9ce136ba44313cba151666d21c413135539d472c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1,3 +1,14 @@\n+2004-03-18  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* class.c (finish_struct_bits): Use TYPE_VFIELD and TYPE_METHODS.\n+\t* error.c (dump_type): Use TYPEOF_TYPE_EXPR.\n+\t* pt.c (tsubst): Likewise.\n+\t* semantics.c (finish_typeof): Likewise.\n+\t* search.c (dfs_unuse_fields): Handle TYPENAME_TYPE, TYPEOF_TYPE,\n+\tand TEMPLATE_TYPE_PARM.\n+\t* typeck.c (comptypes): Use TYPE_ORIG_SIZE_TYPE, not TYPE_DOMAIN.\n+\t(build_array_ref): Use TYPE_DOMAIN, not TYPE_VALUES.\n+\n 2004-03-16  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/14586"}, {"sha": "de0517f5b0946fcae2abc1bfb77792eb23bee0a1", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1422,8 +1422,8 @@ finish_struct_bits (tree t)\n       TYPE_POLYMORPHIC_P (variants) = TYPE_POLYMORPHIC_P (t);\n       TYPE_USES_VIRTUAL_BASECLASSES (variants) = TYPE_USES_VIRTUAL_BASECLASSES (t);\n       /* Copy whatever these are holding today.  */\n-      TYPE_MIN_VALUE (variants) = TYPE_MIN_VALUE (t);\n-      TYPE_MAX_VALUE (variants) = TYPE_MAX_VALUE (t);\n+      TYPE_VFIELD (variants) = TYPE_VFIELD (t);\n+      TYPE_METHODS (variants) = TYPE_METHODS (t);\n       TYPE_FIELDS (variants) = TYPE_FIELDS (t);\n       TYPE_SIZE (variants) = TYPE_SIZE (t);\n       TYPE_SIZE_UNIT (variants) = TYPE_SIZE_UNIT (t);"}, {"sha": "5b2490e76f2926957867fd4008603d82b76556ae", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -404,7 +404,7 @@ dump_type (tree t, int flags)\n \n     case TYPEOF_TYPE:\n       pp_string (cxx_pp, \"__typeof (\");\n-      dump_expr (TYPE_FIELDS (t), flags & ~TFF_EXPR_IN_PARENS);\n+      dump_expr (TYPEOF_TYPE_EXPR (t), flags & ~TFF_EXPR_IN_PARENS);\n       pp_right_paren (cxx_pp);\n       break;\n "}, {"sha": "365cb18bf6688bcf7190f88df08ccbfcd90b01cd", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -7223,8 +7223,8 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree type;\n \n-\ttype = finish_typeof (tsubst_expr (TYPE_FIELDS (t), args, complain, \n-\t\t\t\t\t   in_decl));\n+\ttype = finish_typeof (tsubst_expr (TYPEOF_TYPE_EXPR (t), args,\n+\t\t\t\t\t   complain, in_decl));\n \treturn cp_build_qualified_type_real (type,\n \t\t\t\t\t     cp_type_quals (t)\n \t\t\t\t\t     | cp_type_quals (type),"}, {"sha": "30dc0d29e45a18b6facc5b84f13f42d10f4d976a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -2249,7 +2249,16 @@ dfs_unuse_fields (tree binfo, void *data ATTRIBUTE_UNUSED)\n   tree type = TREE_TYPE (binfo);\n   tree fields;\n \n-  for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+  if (TREE_CODE (type) == TYPENAME_TYPE)\n+    fields = TYPENAME_TYPE_FULLNAME (type);\n+  else if (TREE_CODE (type) == TYPEOF_TYPE)\n+    fields = TYPEOF_TYPE_EXPR (type);\n+  else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+    fields = TEMPLATE_TYPE_PARM_INDEX (type);\n+  else\n+    fields = TYPE_FIELDS (type);\n+\n+  for (; fields; fields = TREE_CHAIN (fields))\n     {\n       if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n \tcontinue;"}, {"sha": "e7d377173bb6ca991ef12d71de86f572962e39bf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -2685,7 +2685,7 @@ finish_typeof (tree expr)\n   if (type_dependent_expression_p (expr))\n     {\n       type = make_aggr_type (TYPEOF_TYPE);\n-      TYPE_FIELDS (type) = expr;\n+      TYPEOF_TYPE_EXPR (type) = expr;\n \n       return type;\n     }"}, {"sha": "10103c8aecbb6591abc72015412988afd9e0fb7d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -953,12 +953,12 @@ comptypes (tree t1, tree t2, int strict)\n   /* If either type is the internal version of sizetype, use the\n      language version.  */\n   if (TREE_CODE (t1) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t1)\n-      && TYPE_DOMAIN (t1))\n-    t1 = TYPE_DOMAIN (t1);\n+      && TYPE_ORIG_SIZE_TYPE (t1))\n+    t1 = TYPE_ORIG_SIZE_TYPE (t1);\n \n   if (TREE_CODE (t2) == INTEGER_TYPE && TYPE_IS_SIZETYPE (t2)\n-      && TYPE_DOMAIN (t2))\n-    t2 = TYPE_DOMAIN (t2);\n+      && TYPE_ORIG_SIZE_TYPE (t2))\n+    t2 = TYPE_ORIG_SIZE_TYPE (t2);\n \n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n@@ -2197,8 +2197,8 @@ build_array_ref (tree array, tree idx)\n \t would get a crash in store_bit_field/extract_bit_field when trying\n \t to access a non-existent part of the register.  */\n       if (TREE_CODE (idx) == INTEGER_CST\n-\t  && TYPE_VALUES (TREE_TYPE (array))\n-\t  && ! int_fits_type_p (idx, TYPE_VALUES (TREE_TYPE (array))))\n+\t  && TYPE_DOMAIN (TREE_TYPE (array))\n+\t  && ! int_fits_type_p (idx, TYPE_DOMAIN (TREE_TYPE (array))))\n \t{\n \t  if (!cxx_mark_addressable (array))\n \t    return error_mark_node;"}, {"sha": "485dc2678d6e3126d10ed40b6f5e0c64a2b5e6bd", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -10860,7 +10860,7 @@ gen_enumeration_type_die (tree type, dw_die_ref context_die)\n       if (type_die->die_parent == NULL)\n \tadd_child_die (scope_die_for (type, context_die), type_die);\n \n-      for (link = TYPE_FIELDS (type);\n+      for (link = TYPE_VALUES (type);\n \t   link != NULL; link = TREE_CHAIN (link))\n \t{\n \t  dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die, link);"}, {"sha": "39e3aef3b00d50306e3ca3938bd141e00f0500b9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1,3 +1,11 @@\n+2004-03-18  Richard Kenner <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* java-tree.h: Changes throughout to add checking to macros\n+\tand numerous whitespace changes.\n+\t(VAR_OR_FIELD_CHECK): New macro.\n+\t* jcf-write.c (get_access_flags): Use FIELD_PUBLIC, METHOD_PUBLIC,\n+\tFIELD_FINAL, and METHOD_FINAL instead of CLASS_PUBLIC and CLASS_FINAL.\n+\n 2004-03-16  Per Bothner  <per@bothner.com>\n \n \t* jcf-jump.c (options):  New --print-constants option."}, {"sha": "57931b8d16e3dbd2f615904f7de600c3f1347f25", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 180, "deletions": 167, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -117,9 +117,12 @@ struct JCF;\n       FIELD_THISN (in FIELD_DECL)\n */\n \n+#define VAR_OR_FIELD_CHECK(DECL) \\\n+  TREE_CHECK3 (DECL, FIELD_DECL, VAR_DECL, PARM_DECL)\n+\n /* True if the class whose TYPE_BINFO this is has a superclass.\n    (True of all classes except Object.) */\n-#define CLASS_HAS_SUPER_FLAG(BINFO) TREE_LANG_FLAG_1(BINFO)\n+#define CLASS_HAS_SUPER_FLAG(BINFO) TREE_LANG_FLAG_1 (TREE_VEC_CHECK (BINFO))\n #define CLASS_HAS_SUPER(TYPE) CLASS_HAS_SUPER_FLAG (TYPE_BINFO (TYPE))\n \n /* Return the supertype of class TYPE, or NULL_TREE is it has none. */\n@@ -822,61 +825,63 @@ union lang_tree_node\n   (DECL_LANG_SPECIFIC(DECL)->u.f.init_calls_this)\n \n /* True when DECL (a field) is Synthetic.  */\n-#define FIELD_SYNTHETIC(DECL) DECL_LANG_FLAG_2 (DECL)\n+#define FIELD_SYNTHETIC(DECL) DECL_LANG_FLAG_2 (VAR_OR_FIELD_CHECK (DECL))\n \n /* True when DECL aliases an outer context local variable.  */\n-#define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (DECL)\n+#define FIELD_LOCAL_ALIAS(DECL) DECL_LANG_FLAG_6 (VAR_OR_FIELD_CHECK (DECL))\n \n /* True when DECL, which aliases an outer context local variable is\n    used by the inner classe */\n-#define FIELD_LOCAL_ALIAS_USED(DECL) DECL_LANG_FLAG_7 (DECL)\n+#define FIELD_LOCAL_ALIAS_USED(DECL) DECL_LANG_FLAG_7 (VAR_OR_FIELD_CHECK (DECL))\n \n /* True when DECL is a this$<n> field. Note that\n    FIELD_LOCAL_ALIAS_USED can be differentiated when tested against\n    FIELD_LOCAL_ALIAS.  */\n-#define FIELD_THISN(DECL) DECL_LANG_FLAG_7 (DECL)\n+#define FIELD_THISN(DECL) DECL_LANG_FLAG_7 (VAR_OR_FIELD_CHECK (DECL))\n \n /* In a LABEL_DECL, a TREE_VEC that saves the type_map at that point. */\n-#define LABEL_TYPE_STATE(NODE) (DECL_INITIAL (NODE))\n+#define LABEL_TYPE_STATE(NODE) (DECL_INITIAL (LABEL_DECL_CHECK (NODE)))\n \n /* In the label of a subroutine, a dummy label that records the\n    state following a merge of all the ret instructions in this subroutine. */\n #define LABEL_RETURN_LABEL(DECL) DECL_ARGUMENTS(DECL)\n \n /* In the label of a sub-routine, records the type state at return.\n- * A local may be TYPE_UNUSED, which means that the local is not\n- * used (stored to or loaded from) in this subroutine - at least for\n- * code that we have verified so far. */\n-#define LABEL_RETURN_TYPE_STATE(NODE) LABEL_TYPE_STATE (LABEL_RETURN_LABEL (NODE))\n+   A local may be TYPE_UNUSED, which means that the local is not\n+   used (stored to or loaded from) in this subroutine - at least for\n+   code that we have verified so far. */\n+#define LABEL_RETURN_TYPE_STATE(NODE) \\\n+  LABEL_TYPE_STATE (LABEL_RETURN_LABEL (NODE))\n \n /* In a TREE_VEC for a LABEL_RETURN_TYPE_STATE, notes that\n    TREE_VEC_LENGTH has been adjusted to the correct stack size. */\n-#define RETURN_MAP_ADJUSTED(NODE) TREE_LANG_FLAG_2(NODE)\n+#define RETURN_MAP_ADJUSTED(NODE) TREE_LANG_FLAG_2 (TREE_VEC_CHECK (NODE))\n \n /* In the label of a sub-routine, a chain of the return location labels. */\n #define LABEL_RETURN_LABELS(node) \\\n-  (LABEL_DECL_CHECK (LABEL_RETURN_LABEL(node))->decl.result)\n+  (LABEL_DECL_CHECK (LABEL_RETURN_LABEL (node))->decl.result)\n \n /* In a LABEL_DECL, the next pending label.\n    See pending_blocks in expr.c. */\n #define LABEL_PENDING_CHAIN(NODE) (LABEL_DECL_CHECK (NODE)->decl.result)\n \n /* In a LABEL_DECL, the corresponding bytecode program counter. */\n-#define LABEL_PC(NODE) ((NODE)->decl.u2.i)\n+#define LABEL_PC(NODE) (LABEL_DECL_CHECK (NODE)->decl.u2.i)\n \n /* Used during verification to mark the label has \"changed\". (See JVM Spec). */\n-#define LABEL_CHANGED(NODE) DECL_LANG_FLAG_6(NODE)\n+#define LABEL_CHANGED(NODE) DECL_LANG_FLAG_6 (LABEL_DECL_CHECK (NODE))\n \n /* In a LABEL_DECL, true if we have verified instructions starting here. */\n-#define LABEL_VERIFIED(NODE) (instruction_bits[LABEL_PC(NODE)]&BCODE_VERIFIED)\n+#define LABEL_VERIFIED(NODE) \\\n+  (instruction_bits[LABEL_PC (NODE)] & BCODE_VERIFIED)\n \n /* True if this code is within a subroutine (target of a jsr). */\n-#define LABEL_IN_SUBR(NODE) DECL_LANG_FLAG_4(NODE)\n+#define LABEL_IN_SUBR(NODE) DECL_LANG_FLAG_4 (LABEL_DECL_CHECK (NODE))\n /* True if this code is the start of a subroutine (target of a jsr). */\n-#define LABEL_IS_SUBR_START(NODE) DECL_LANG_FLAG_5(NODE)\n+#define LABEL_IS_SUBR_START(NODE) DECL_LANG_FLAG_5 (LABEL_DECL_CHECK (NODE))\n \n /* In a LABEL_DECL, if LABEL_IN_SUBR(NODE), points to start of subroutine. */\n-#define LABEL_SUBR_START(NODE) DECL_ABSTRACT_ORIGIN(NODE)\n+#define LABEL_SUBR_START(NODE) DECL_ABSTRACT_ORIGIN (LABEL_DECL_CHECK (NODE))\n \n /* In a LABEL_DECL that has LABEL_IS_SUBR_START, this points to the start\n    of surrounding subroutine in the case of a nested subroutine,\n@@ -885,34 +890,28 @@ union lang_tree_node\n \n /* The slot number for this local variable. */\n #define DECL_LOCAL_SLOT_NUMBER(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.slot_number)\n+  (DECL_LANG_SPECIFIC (NODE)->u.v.slot_number)\n /* The start (bytecode) pc for the valid range of this local variable. */\n-#define DECL_LOCAL_START_PC(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.start_pc)\n+#define DECL_LOCAL_START_PC(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.start_pc)\n /* The end (bytecode) pc for the valid range of this local variable. */\n-#define DECL_LOCAL_END_PC(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.end_pc)\n+#define DECL_LOCAL_END_PC(NODE)    (DECL_LANG_SPECIFIC (NODE)->u.v.end_pc)\n /* For a VAR_DECLor PARM_DECL, used to chain decls with the same\n    slot_number in decl_map. */\n-#define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.slot_chain)\n+#define DECL_LOCAL_SLOT_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->u.v.slot_chain)\n /* For a FIELD_DECL, holds the name of the access method. Used to\n    read/write the content of the field from an inner class.  */\n #define FIELD_INNER_ACCESS(DECL) \\\n-  (DECL_LANG_SPECIFIC(DECL)->u.v.am)\n+  (DECL_LANG_SPECIFIC (VAR_OR_FIELD_CHECK (DECL))->u.v.am)\n /* Safely tests whether FIELD_INNER_ACCESS exists or not. */\n #define FIELD_INNER_ACCESS_P(DECL) \\\n   DECL_LANG_SPECIFIC (DECL) && FIELD_INNER_ACCESS (DECL)\n /* True if a final variable was initialized upon its declaration,\n    or (if a field) in an initializer.  Set after definite assignment. */\n-#define DECL_FIELD_FINAL_IUD(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.final_iud)\n+#define DECL_FIELD_FINAL_IUD(NODE)  (DECL_LANG_SPECIFIC (NODE)->u.v.final_iud)\n /* The original WFL of a final variable. */\n-#define DECL_FIELD_FINAL_WFL(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.wfl)\n+#define DECL_FIELD_FINAL_WFL(NODE)  (DECL_LANG_SPECIFIC(NODE)->u.v.wfl)\n /* The class that's the owner of a dynamic binding table.  */\n-#define DECL_OWNER(NODE) \\\n-  (DECL_LANG_SPECIFIC(NODE)->u.v.owner)\n+#define DECL_OWNER(NODE)            (DECL_LANG_SPECIFIC(NODE)->u.v.owner)\n /* True if NODE is a local variable final. */\n #define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))\n /* True if NODE is a final field. */\n@@ -923,13 +922,13 @@ union lang_tree_node\n /* True if NODE is a class initialization flag. This macro accesses\n    the flag to read or set it.  */\n #define LOCAL_CLASS_INITIALIZATION_FLAG(NODE) \\\n-    (DECL_LANG_SPECIFIC(NODE)->u.v.cif)\n+    (DECL_LANG_SPECIFIC (NODE)->u.v.cif)\n /* True if NODE is a class initialization flag. */\n #define LOCAL_CLASS_INITIALIZATION_FLAG_P(NODE) \\\n     (DECL_LANG_SPECIFIC (NODE) && LOCAL_CLASS_INITIALIZATION_FLAG(NODE))\n /* True if NODE is a variable that is out of scope.  */\n #define LOCAL_VAR_OUT_OF_SCOPE_P(NODE) \\\n-    (DECL_LANG_SPECIFIC(NODE)->u.v.freed)\n+    (DECL_LANG_SPECIFIC (NODE)->u.v.freed)\n /* Create a DECL_LANG_SPECIFIC if necessary. */\n #define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n   if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n@@ -946,11 +945,11 @@ union lang_tree_node\n        && TREE_CODE (TREE_TYPE (NODE)) != POINTER_TYPE) \\\n    || TREE_CODE (NODE) == REAL_CST)\n \n-/* For a local VAR_DECL, holds the index into a words bitstring that\n-   specifies if this decl is definitively assigned.\n+/* For a local VAR_DECL or PARM_DECL, holds the index into a words bitstring\n+   that specifies if this decl is definitively assigned.\n    The value -1 means the variable has been definitely assigned (and not\n    definitely unassigned).  The value -2 means we already reported an error. */\n-#define DECL_BIT_INDEX(DECL) (DECL_CHECK (DECL)->decl.pointer_alias_set)\n+#define DECL_BIT_INDEX(DECL) VAR_OR_FIELD_CHECK (DECL)->decl.pointer_alias_set\n \n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl_func GTY(())\n@@ -1020,65 +1019,61 @@ struct lang_decl_var GTY(())\n \n /* This is what 'lang_decl' really points to.  */\n \n-enum lang_decl_desc {\n-  LANG_DECL_FUNC,\n-  LANG_DECL_VAR\n-};\n+enum lang_decl_desc {LANG_DECL_FUNC, LANG_DECL_VAR};\n \n struct lang_decl GTY(())\n {\n   enum lang_decl_desc desc;\n-  union lang_decl_u {\n-    struct lang_decl_func GTY ((tag (\"LANG_DECL_FUNC\"))) f;\n-    struct lang_decl_var GTY ((tag (\"LANG_DECL_VAR\"))) v;\n-  } GTY ((desc (\"%0.desc\"))) u;\n+  union lang_decl_u\n+    {\n+      struct lang_decl_func GTY ((tag (\"LANG_DECL_FUNC\"))) f;\n+      struct lang_decl_var GTY ((tag (\"LANG_DECL_VAR\"))) v;\n+    } GTY ((desc (\"%0.desc\"))) u;\n };\n \n /* Macro to access fields in `struct lang_type'.  */\n \n-#define TYPE_SIGNATURE(T) (TYPE_LANG_SPECIFIC(T)->signature)\n-#define TYPE_JCF(T) (TYPE_LANG_SPECIFIC(T)->jcf)\n-#define TYPE_CPOOL(T) (TYPE_LANG_SPECIFIC(T)->cpool)\n-#define TYPE_CPOOL_DATA_REF(T) (TYPE_LANG_SPECIFIC(T)->cpool_data_ref)\n-#define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T)\t\t\t\t \\\n-  if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      TYPE_LANG_SPECIFIC ((T)) \t\t\t\t\t \t \\\n-        = ggc_alloc_cleared (sizeof (struct lang_type));\t\t \\\n-    }\n-\n-#define TYPE_FINIT_STMT_LIST(T)  (TYPE_LANG_SPECIFIC(T)->finit_stmt_list)\n-#define TYPE_CLINIT_STMT_LIST(T) (TYPE_LANG_SPECIFIC(T)->clinit_stmt_list)\n-#define TYPE_II_STMT_LIST(T)     (TYPE_LANG_SPECIFIC(T)->ii_block)\n+#define TYPE_SIGNATURE(T)\t(TYPE_LANG_SPECIFIC (T)->signature)\n+#define TYPE_JCF(T)\t\t(TYPE_LANG_SPECIFIC (T)->jcf)\n+#define TYPE_CPOOL(T)\t\t(TYPE_LANG_SPECIFIC (T)->cpool)\n+#define TYPE_CPOOL_DATA_REF(T)\t(TYPE_LANG_SPECIFIC (T)->cpool_data_ref)\n+#define MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC(T) \\\n+  if (TYPE_LANG_SPECIFIC ((T)) == NULL)\t\t\\\n+     TYPE_LANG_SPECIFIC ((T))\t\t\t\\\n+     = ggc_alloc_cleared (sizeof (struct lang_type));\n+\n+#define TYPE_FINIT_STMT_LIST(T)  (TYPE_LANG_SPECIFIC (T)->finit_stmt_list)\n+#define TYPE_CLINIT_STMT_LIST(T) (TYPE_LANG_SPECIFIC (T)->clinit_stmt_list)\n+#define TYPE_II_STMT_LIST(T)     (TYPE_LANG_SPECIFIC (T)->ii_block)\n /* The decl of the synthetic method `class$' used to handle `.class'\n    for non primitive types when compiling to bytecode. */\n-#define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC(T)->dot_class)\n-#define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC(T)->package_list)\n-#define TYPE_IMPORT_LIST(T)      (TYPE_LANG_SPECIFIC(T)->import_list)\n-#define TYPE_IMPORT_DEMAND_LIST(T) (TYPE_LANG_SPECIFIC(T)->import_demand_list)\n-#define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->pic)\n-#define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n-#define TYPE_STRICTFP(T) (TYPE_LANG_SPECIFIC(T)->strictfp)\n-#define TYPE_USES_ASSERTIONS(T) (TYPE_LANG_SPECIFIC(T)->assertions)\n+#define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC (T)->dot_class)\n+#define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC (T)->package_list)\n+#define TYPE_IMPORT_LIST(T)      (TYPE_LANG_SPECIFIC (T)->import_list)\n+#define TYPE_IMPORT_DEMAND_LIST(T) (TYPE_LANG_SPECIFIC (T)->import_demand_list)\n+#define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC (T)->pic)\n+#define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC (T)->poic)\n+#define TYPE_STRICTFP(T) (TYPE_LANG_SPECIFIC (T)->strictfp)\n+#define TYPE_USES_ASSERTIONS(T) (TYPE_LANG_SPECIFIC (T)->assertions)\n \n-#define TYPE_ATABLE_METHODS(T)   (TYPE_LANG_SPECIFIC(T)->atable_methods)\n-#define TYPE_ATABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC(T)->atable_syms_decl)\n-#define TYPE_ATABLE_DECL(T)      (TYPE_LANG_SPECIFIC(T)->atable_decl)\n+#define TYPE_ATABLE_METHODS(T)   (TYPE_LANG_SPECIFIC (T)->atable_methods)\n+#define TYPE_ATABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->atable_syms_decl)\n+#define TYPE_ATABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->atable_decl)\n \n-#define TYPE_OTABLE_METHODS(T)   (TYPE_LANG_SPECIFIC(T)->otable_methods)\n-#define TYPE_OTABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC(T)->otable_syms_decl)\n-#define TYPE_OTABLE_DECL(T)      (TYPE_LANG_SPECIFIC(T)->otable_decl)\n+#define TYPE_OTABLE_METHODS(T)   (TYPE_LANG_SPECIFIC (T)->otable_methods)\n+#define TYPE_OTABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->otable_syms_decl)\n+#define TYPE_OTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->otable_decl)\n \n-#define TYPE_CTABLE_DECL(T)      (TYPE_LANG_SPECIFIC(T)->ctable_decl)\n-#define TYPE_CATCH_CLASSES(T)    (TYPE_LANG_SPECIFIC(T)->catch_classes)\n+#define TYPE_CTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->ctable_decl)\n+#define TYPE_CATCH_CLASSES(T)    (TYPE_LANG_SPECIFIC (T)->catch_classes)\n \n-#define TYPE_TO_RUNTIME_MAP(T)   (TYPE_LANG_SPECIFIC(T)->type_to_runtime_map)\n+#define TYPE_TO_RUNTIME_MAP(T)   (TYPE_LANG_SPECIFIC (T)->type_to_runtime_map)\n \n struct lang_type GTY(())\n {\n   tree signature;\n-  struct JCF * jcf;\n-  struct CPool * cpool;\n+  struct JCF *jcf;\n+  struct CPool *cpool;\n   tree cpool_data_ref;\t\t/* Cached */\n   tree finit_stmt_list;\t\t/* List of statements finit$ will use */\n   tree clinit_stmt_list;\t/* List of statements <clinit> will use  */\n@@ -1091,19 +1086,23 @@ struct lang_type GTY(())\n   tree import_list;\t\t/* Imported types, in the CU of this class */\n   tree import_demand_list;\t/* Imported types, in the CU of this class */\n \n-  tree otable_methods;          /* List of static decls referred to by this class.  */\n+  tree otable_methods;          /* List of static decls referred to by this\n+\t\t\t\t   class.  */\n   tree otable_decl;\t\t/* The static address table.  */\n   tree otable_syms_decl;\n \n-  tree atable_methods;          /* List of static decls referred to by this class.  */\n+  tree atable_methods;          /* List of static decls referred to by this\n+\t\t\t\t   class.  */\n   tree atable_decl;\t\t/* The static address table.  */\n   tree atable_syms_decl;\n \n-  tree ctable_decl;             /* The table of classes for the runtime type matcher.  */\n+  tree ctable_decl;             /* The table of classes for the runtime\n+\t\t\t\t   type matcher.  */\n   tree catch_classes;\n \n   htab_t GTY ((param_is (struct treetreehash_entry))) type_to_runtime_map;   \n-                                /* The mapping of classes to exception region markers.  */\n+                                /* The mapping of classes to exception region\n+\t\t\t\t   markers.  */\n \n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n@@ -1156,8 +1155,10 @@ extern tree build_internal_class_name (tree);\n extern tree build_constants_constructor (void);\n extern tree build_ref_from_constant_pool (int);\n extern tree build_utf8_ref (tree);\n-extern tree ident_subst (const char*, int, const char*, int, int, const char*);\n-extern tree identifier_subst (const tree, const char *, int, int, const char *);\n+extern tree ident_subst (const char *, int, const char *, int, int,\n+\t\t\t const char *);\n+extern tree identifier_subst (const tree, const char *, int, int,\n+\t\t\t      const char *);\n extern int global_bindings_p (void);\n extern int kept_level_p (void);\n extern tree getdecls (void);\n@@ -1178,12 +1179,12 @@ extern tree find_stack_slot (int index, tree type);\n extern tree build_prim_array_type (tree, HOST_WIDE_INT);\n extern tree build_java_array_type (tree, HOST_WIDE_INT);\n extern int is_compiled_class (tree);\n-extern tree mangled_classname (const char*, tree);\n+extern tree mangled_classname (const char *, tree);\n extern tree lookup_label (int);\n-extern tree pop_type_0 (tree, char**);\n+extern tree pop_type_0 (tree, char **);\n extern tree pop_type (tree);\n extern tree decode_newarray_type (int);\n-extern tree lookup_field (tree*, tree);\n+extern tree lookup_field (tree *, tree);\n extern int is_array_type_p (tree);\n extern HOST_WIDE_INT java_array_type_length (tree);\n extern int read_class (tree);\n@@ -1297,7 +1298,8 @@ extern void jcf_trim_old_input (struct JCF *);\n #ifdef BUFSIZ\n extern void jcf_print_utf8 (FILE *, const unsigned char *, int);\n extern void jcf_print_char (FILE *, int);\n-extern void jcf_print_utf8_replace (FILE *, const unsigned char *, int, int, int);\n+extern void jcf_print_utf8_replace (FILE *, const unsigned char *, int,\n+\t\t\t\t    int, int);\n extern const char* open_class (const char *, struct JCF *, int, const char *);\n #endif\n extern void java_debug_context (void);\n@@ -1349,24 +1351,27 @@ extern void gen_indirect_dispatch_tables (tree type);\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n-#define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n-#define METHOD_PRIVATE(DECL) TREE_PRIVATE (DECL)\n-#define METHOD_PROTECTED(DECL) TREE_PROTECTED (DECL)\n-#define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (DECL)\n-#define METHOD_FINAL(DECL) DECL_FINAL (DECL)\n-#define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (DECL)\n-#define METHOD_NATIVE(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.native)\n-#define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n-#define METHOD_STRICTFP(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.strictfp)\n-#define METHOD_INVISIBLE(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.invisible)\n+#define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_PRIVATE(DECL) TREE_PRIVATE (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_PROTECTED(DECL) TREE_PROTECTED (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_FINAL(DECL) DECL_FINAL (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_NATIVE(DECL) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.native)\n+#define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (FUNCTION_DECL_CHECK (DECL))\n+#define METHOD_STRICTFP(DECL) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.strictfp)\n+#define METHOD_INVISIBLE(DECL) \\\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->u.f.invisible)\n \n #define JAVA_FILE_P(NODE) TREE_LANG_FLAG_2 (NODE)\n #define CLASS_FILE_P(NODE) TREE_LANG_FLAG_3 (NODE)\n #define ZIP_FILE_P(NODE) TREE_LANG_FLAG_4 (NODE)\n \n /* Other predicates on method decls  */\n \n-#define DECL_CONSTRUCTOR_P(DECL) DECL_LANG_FLAG_7(DECL)\n+#define DECL_CONSTRUCTOR_P(DECL) DECL_LANG_FLAG_7 (FUNCTION_DECL_CHECK (DECL))\n \n #define DECL_INIT_P(DECL)   (ID_INIT_P (DECL_NAME (DECL)))\n #define DECL_FINIT_P(DECL)  (ID_FINIT_P (DECL_NAME (DECL)))\n@@ -1381,27 +1386,27 @@ extern void gen_indirect_dispatch_tables (tree type);\n #define ID_CLASSDOLLAR_P(ID) ((ID) == classdollar_identifier_node)\n #define ID_INSTINIT_P(ID) ((ID) == instinit_identifier_node)\n \n-/* Access flags etc for a variable/field (a FIELD_DECL): */\n+/* Access flags etc for variable/field (FIELD_DECL, VAR_DECL, or PARM_DECL): */\n \n-#define FIELD_PRIVATE(DECL) TREE_PRIVATE (DECL)\n-#define FIELD_PROTECTED(DECL) TREE_PROTECTED (DECL)\n-#define FIELD_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n-#define FIELD_STATIC(DECL) TREE_STATIC (DECL)\n-#define FIELD_FINAL(DECL) DECL_FINAL (DECL)\n-#define FIELD_VOLATILE(DECL) DECL_LANG_FLAG_4 (DECL)\n-#define FIELD_TRANSIENT(DECL) DECL_LANG_FLAG_5 (DECL)\n+#define FIELD_PRIVATE(DECL)\tTREE_PRIVATE (VAR_OR_FIELD_CHECK (DECL))\n+#define FIELD_PROTECTED(DECL)\tTREE_PROTECTED (VAR_OR_FIELD_CHECK (DECL))\n+#define FIELD_PUBLIC(DECL)\tDECL_LANG_FLAG_1 (VAR_OR_FIELD_CHECK (DECL))\n+#define FIELD_STATIC(DECL)\tTREE_STATIC (VAR_OR_FIELD_CHECK (DECL))\n+#define FIELD_FINAL(DECL)\tDECL_FINAL (VAR_OR_FIELD_CHECK (DECL))\n+#define FIELD_VOLATILE(DECL)\tDECL_LANG_FLAG_4 (VAR_OR_FIELD_CHECK (DECL))\n+#define FIELD_TRANSIENT(DECL)\tDECL_LANG_FLAG_5 (VAR_OR_FIELD_CHECK (DECL))\n \n /* Access flags etc for a class (a TYPE_DECL): */\n \n-#define CLASS_PUBLIC(DECL) DECL_LANG_FLAG_1 (DECL)\n-#define CLASS_FINAL(DECL) DECL_FINAL (DECL)\n-#define CLASS_INTERFACE(DECL) DECL_LANG_FLAG_4 (DECL)\n-#define CLASS_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n-#define CLASS_SUPER(DECL) DECL_LANG_FLAG_6 (DECL)\n-#define CLASS_STATIC(DECL) DECL_LANG_FLAG_7 (DECL)\n-#define CLASS_PRIVATE(DECL) (TYPE_PRIVATE_INNER_CLASS (TREE_TYPE (DECL)))\n-#define CLASS_PROTECTED(DECL) (TYPE_PROTECTED_INNER_CLASS (TREE_TYPE (DECL)))\n-#define CLASS_STRICTFP(DECL) (TYPE_STRICTFP (TREE_TYPE (DECL)))\n+#define CLASS_PUBLIC(DECL)\tDECL_LANG_FLAG_1 (TYPE_DECL_CHECK (DECL))\n+#define CLASS_FINAL(DECL)\tDECL_FINAL (TYPE_DECL_CHECK (DECL))\n+#define CLASS_INTERFACE(DECL)\tDECL_LANG_FLAG_4 (TYPE_DECL_CHECK (DECL))\n+#define CLASS_ABSTRACT(DECL)\tDECL_LANG_FLAG_5 (TYPE_DECL_CHECK (DECL))\n+#define CLASS_SUPER(DECL)\tDECL_LANG_FLAG_6 (TYPE_DECL_CHECK (DECL))\n+#define CLASS_STATIC(DECL)\tDECL_LANG_FLAG_7 (TYPE_DECL_CHECK (DECL))\n+#define CLASS_PRIVATE(DECL)\t(TYPE_PRIVATE_INNER_CLASS (TREE_TYPE (DECL)))\n+#define CLASS_PROTECTED(DECL)\t(TYPE_PROTECTED_INNER_CLASS (TREE_TYPE (DECL)))\n+#define CLASS_STRICTFP(DECL)\t(TYPE_STRICTFP (TREE_TYPE (DECL)))\n #define CLASS_USES_ASSERTIONS(DECL) (TYPE_USES_ASSERTIONS (TREE_TYPE (DECL)))\n \n /* @deprecated marker flag on methods, fields and classes */\n@@ -1412,8 +1417,8 @@ extern void gen_indirect_dispatch_tables (tree type);\n #define DECL_DEPRECATED(DECL) DECL_LANG_FLAG_0 (DECL)\n \n /* The number of virtual methods in this class's dispatch table.\n- Does not include initial two dummy entries (one points to the\n- Class object, and the other is for G++ -fvtable-thunks compatibility). */\n+   Does not include initial two dummy entries (one points to the\n+   Class object, and the other is for G++ -fvtable-thunks compatibility). */\n #define TYPE_NVIRTUALS(TYPE) TYPE_BINFO_VIRTUALS (TYPE)\n \n /* A TREE_VEC (indexed by DECL_VINDEX) containing this class's\n@@ -1482,7 +1487,7 @@ extern int linenumber_count;\n extern tree *type_map;\n \n /* Map a stack index to the type currently in that slot. */\n-#define stack_type_map (type_map+DECL_MAX_LOCALS(current_function_decl))\n+#define stack_type_map (type_map + DECL_MAX_LOCALS (current_function_decl))\n \n /* True iff TYPE takes two variable/stack slots. */\n #define TYPE_IS_WIDE(TYPE) \\\n@@ -1498,11 +1503,12 @@ extern tree *type_map;\n #define IS_ARRAY_LENGTH_ACCESS(NODE) TREE_LANG_FLAG_4 (NODE)\n \n /* If FUNCTION_TYPE or METHOD_TYPE: cache for build_java_argument_signature. */\n-#define TYPE_ARGUMENT_SIGNATURE(TYPE) TYPE_VFIELD(TYPE)\n+#define TYPE_ARGUMENT_SIGNATURE(TYPE) \\\n+  (TREE_CHECK2 (TYPE, FUNCTION_TYPE, METHOD_TYPE)->type.minval)\n \n /* Given an array type, give the type of the elements. */\n /* FIXME this use of TREE_TYPE conflicts with something or other. */\n-#define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE(ATYPE)\n+#define TYPE_ARRAY_ELEMENT(ATYPE) TREE_TYPE (ATYPE)\n \n /* True if class TYPE has been loaded (i.e. parsed plus laid out).\n    (The check for CLASS_PARSED_P is needed because of Object and Class.) */\n@@ -1519,8 +1525,7 @@ extern tree *type_map;\n #define CLASS_P(TYPE) TYPE_LANG_FLAG_4 (TYPE)\n \n /* True if class TYPE was requested (on command line) to be compiled.*/\n-#define CLASS_FROM_CURRENTLY_COMPILED_P(TYPE) \\\n-  TYPE_LANG_FLAG_5 (TYPE)\n+#define CLASS_FROM_CURRENTLY_COMPILED_P(TYPE) TYPE_LANG_FLAG_5 (TYPE)\n \n /* True if class TYPE is currently being laid out. Helps in detection\n    of inheritance cycle occurring as a side effect of performing the\n@@ -1552,15 +1557,16 @@ extern tree *type_map;\n #define COMPOUND_ASSIGN_P(EXPR) TREE_LANG_FLAG_1 (EXPR)\n \n /* True if a SWITCH_EXPR has a DEFAULT_EXPR. */\n-#define SWITCH_HAS_DEFAULT(NODE) TREE_LANG_FLAG_3 (NODE)\n+#define SWITCH_HAS_DEFAULT(NODE) TREE_LANG_FLAG_3 (SWITCH_EXPR_CHECK (NODE))\n \n /* True if EXPR (a WFL in that case) was created after the\n    reduction of PRIMARY . XXX */\n-#define PRIMARY_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n+#define PRIMARY_P(EXPR) TREE_LANG_FLAG_2 (EXPR_CHECK (EXPR))\n \n /* True if EXPR (a MODIFY_EXPR in that case) is the result of variable\n    initialization during its declaration */\n-#define MODIFY_EXPR_FROM_INITIALIZATION_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n+#define MODIFY_EXPR_FROM_INITIALIZATION_P(EXPR) \\\n+  TREE_LANG_FLAG_2 (MODIFY_EXPR_CHECK (EXPR))\n \n /* True if EXPR (a TREE_TYPE denoting a class type) has its methods\n    already checked (for redefinitions, etc, see java_check_regular_methods.) */\n@@ -1571,29 +1577,29 @@ extern tree *type_map;\n #define HAS_FINALIZER_P(EXPR) TREE_LANG_FLAG_3 (EXPR)\n \n /* True if EXPR (a LOOP_EXPR in that case) is part of a for statement */\n-#define FOR_LOOP_P(EXPR) TREE_LANG_FLAG_0 (EXPR)\n+#define FOR_LOOP_P(EXPR) TREE_LANG_FLAG_0 (EXPR_CHECK (EXPR))\n \n /* True if NODE (a RECORD_TYPE in that case) is an anonymous class.  */\n-#define ANONYMOUS_CLASS_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define ANONYMOUS_CLASS_P(NODE) TREE_LANG_FLAG_0 (RECORD_TYPE_CHECK (NODE))\n \n /* True if NODE (a RECORD_TYPE in that case) is a block local class.  */\n-#define LOCAL_CLASS_P(NODE) TREE_LANG_FLAG_1 (NODE)\n+#define LOCAL_CLASS_P(NODE) TREE_LANG_FLAG_1 (RECORD_TYPE_CHECK (NODE))\n \n /* True if NODE (a TREE_LIST) hold a pair of argument name/type\n    declared with the final modifier */\n-#define ARG_FINAL_P(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define ARG_FINAL_P(NODE) TREE_LANG_FLAG_0 (TREE_LIST_CHECK (NODE))\n \n /* True if NODE (some kind of EXPR, but not a WFL) should not give an\n    error if it is found to be unreachable.  This can only be applied\n    to those EXPRs which can be used as the update expression of a\n    `for' loop.  In particular it can't be set on a LOOP_EXPR.  */\n-#define SUPPRESS_UNREACHABLE_ERROR(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define SUPPRESS_UNREACHABLE_ERROR(NODE) TREE_LANG_FLAG_0 (EXPR_CHECK (NODE))\n \n /* True if EXPR (a WFL in that case) resolves into a package name */\n-#define RESOLVE_PACKAGE_NAME_P(WFL) TREE_LANG_FLAG_3 (WFL)\n+#define RESOLVE_PACKAGE_NAME_P(WFL) TREE_LANG_FLAG_3 (EXPR_CHECK (WFL))\n \n /* True if EXPR (a WFL in that case) resolves into a type name */\n-#define RESOLVE_TYPE_NAME_P(WFL) TREE_LANG_FLAG_4 (WFL)\n+#define RESOLVE_TYPE_NAME_P(WFL) TREE_LANG_FLAG_4 (EXPR_CHECK (WFL))\n \n /* True if STMT (a WFL in that case) holds a BREAK statement */\n #define IS_BREAK_STMT_P(WFL) TREE_LANG_FLAG_5 (WFL)\n@@ -1603,17 +1609,18 @@ extern tree *type_map;\n \n /* True if EXPR (a SAVE_EXPR in that case) had its content already\n    checked for (un)initialized local variables.  */\n-#define IS_INIT_CHECKED(EXPR) TREE_LANG_FLAG_5 (EXPR)\n+#define IS_INIT_CHECKED(EXPR) TREE_LANG_FLAG_5 (SAVE_EXPR_CHECK (EXPR))\n \n /* If set in CALL_EXPR, the receiver is 'super'. */\n-#define CALL_USING_SUPER(EXPR) TREE_LANG_FLAG_4 (EXPR)\n+#define CALL_USING_SUPER(EXPR) TREE_LANG_FLAG_4 (EXPR_CHECK (EXPR))\n \n /* True if NODE (a statement) can complete normally. */\n-#define CAN_COMPLETE_NORMALLY(NODE) TREE_LANG_FLAG_6(NODE)\n+#define CAN_COMPLETE_NORMALLY(NODE) TREE_LANG_FLAG_6 (NODE)\n \n /* True if NODE (an IDENTIFIER) bears the name of a outer field from\n    inner class access function.  */\n-#define OUTER_FIELD_ACCESS_IDENTIFIER_P(NODE) TREE_LANG_FLAG_6(NODE)\n+#define OUTER_FIELD_ACCESS_IDENTIFIER_P(NODE) \\\n+  TREE_LANG_FLAG_6 (IDENTIFIER_NODE_CHECK (NODE))\n \n /* True if NODE belongs to an inner class TYPE_DECL node.\n    Verifies that NODE as the attributes of a decl.  */\n@@ -1652,7 +1659,7 @@ extern tree *type_map;\n \n /* On a TYPE_DECL, hold the list of inner classes defined within the\n    scope of TYPE_DECL.  */\n-#define DECL_INNER_CLASS_LIST(NODE) DECL_INITIAL (NODE)\n+#define DECL_INNER_CLASS_LIST(NODE) DECL_INITIAL (TYPE_DECL_CHECK (NODE))\n \n /* Build a IDENTIFIER_NODE for a file name we're considering. Since\n    all_class_filename is a registered root, putting this identifier\n@@ -1673,47 +1680,53 @@ extern tree *type_map;\n    if compiling java.lang.Object or java.lang.Class. */\n \n #define PUSH_FIELD(RTYPE, FIELD, NAME, FTYPE) \\\n-{ tree tmp_field = build_decl (FIELD_DECL, get_identifier(NAME), FTYPE); \\\n-  if (TYPE_FIELDS (RTYPE) == NULL_TREE) TYPE_FIELDS (RTYPE) = tmp_field; \\\n-  else TREE_CHAIN(FIELD) = tmp_field; \\\n-  DECL_CONTEXT (tmp_field) = RTYPE; \\\n-  DECL_ARTIFICIAL (tmp_field) = 1; \\\n-  FIELD = tmp_field; }\n+{ tree _field = build_decl (FIELD_DECL, get_identifier ((NAME)), (FTYPE)); \\\n+  if (TYPE_FIELDS (RTYPE) == NULL_TREE)\t\\\n+    TYPE_FIELDS (RTYPE) = _field; \t\\\n+  else\t\t\t\t\t\\\n+    TREE_CHAIN(FIELD) = _field;\t\t\\\n+  DECL_CONTEXT (_field) = (RTYPE);\t\\\n+  DECL_ARTIFICIAL (_field) = 1;\t\t\\\n+  FIELD = _field; }\n \n #define FINISH_RECORD(RTYPE) layout_type (RTYPE)\n \n /* Start building a RECORD_TYPE constructor with a given TYPE in CONS. */\n-#define START_RECORD_CONSTRUCTOR(CONS, CTYPE) { \\\n-  CONS = build_constructor (CTYPE, NULL_TREE);\\\n-  TREE_CHAIN(CONS) = TYPE_FIELDS (CTYPE); }\n+#define START_RECORD_CONSTRUCTOR(CONS, CTYPE)\t\\\n+{ CONS = build_constructor ((CTYPE), NULL_TREE);\t\\\n+  TREE_CHAIN (CONS) = TYPE_FIELDS (CTYPE); }\n \n /* Append a field initializer to CONS for the dummy field for the inherited\n    fields.  The dummy field has the given VALUE, and the same type as the\n    super-class.   Must be specified before calls to PUSH_FIELD_VALUE. */\n-\n-#define PUSH_SUPER_VALUE(CONS, VALUE) {\\\n-  tree field = TREE_CHAIN(CONS);\\\n-  if (DECL_NAME (field) != NULL_TREE) abort();\\\n-  CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\\\n-  TREE_CHAIN(CONS) = TREE_CHAIN (field); }\n+#define PUSH_SUPER_VALUE(CONS, VALUE)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  tree _field = TREE_CHAIN (CONS);\t\t\t\\\n+  if (DECL_NAME (_field) != NULL_TREE)\t\t\t\\\n+    abort ();\t\t\t\t\t\t\\\n+  CONSTRUCTOR_ELTS (CONS)\t\t\t\t\\\n+    = tree_cons (_field, (VALUE), CONSTRUCTOR_ELTS (CONS)); \\\n+  TREE_CHAIN (CONS) = TREE_CHAIN (_field);\t\t\\\n+}\n \n /* Append a field initializer to CONS for a field with the given VALUE.\n    NAME is a char* string used for error checking;\n    the initializer must be specified in order. */\n-#define PUSH_FIELD_VALUE(CONS, NAME, VALUE) \t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\t\\\n-  tree field = TREE_CHAIN(CONS);\t\t\t\t\t\t\\\n-  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (field)), NAME) != 0) \t\t\\\n-    abort();\t\t\t\t\t\t\t\t\t\\\n-  CONSTRUCTOR_ELTS(CONS) = tree_cons (field, VALUE, CONSTRUCTOR_ELTS(CONS));\t\\\n-  TREE_CHAIN(CONS) = TREE_CHAIN (field); \t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\t\\\n+#define PUSH_FIELD_VALUE(CONS, NAME, VALUE) \t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  tree _field = TREE_CHAIN (CONS);\t\t\t\t\t\\\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (_field)), NAME) != 0) \t\\\n+    abort ();\t\t\t\t\t\t\t\t\\\n+  CONSTRUCTOR_ELTS (CONS)\t\t\t\t\t\t\\\n+    = tree_cons (_field, (VALUE), CONSTRUCTOR_ELTS (CONS));\t\t\\\n+  TREE_CHAIN (CONS) = TREE_CHAIN (_field); \t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n /* Finish creating a record CONSTRUCTOR CONS. */\n #define FINISH_RECORD_CONSTRUCTOR(CONS) \\\n-  CONSTRUCTOR_ELTS(CONS) = nreverse (CONSTRUCTOR_ELTS(CONS))\n+  CONSTRUCTOR_ELTS(CONS) = nreverse (CONSTRUCTOR_ELTS (CONS))\n \n /* Macros on constructors invocations.  */\n #define CALL_CONSTRUCTOR_P(NODE)\t\t\\\n@@ -1731,13 +1744,14 @@ while (0)\n    && EXPR_WFL_NODE (TREE_OPERAND (NODE, 0)) == super_identifier_node)\n \n /* Using a FINALLY_EXPR node */\n-#define FINALLY_EXPR_LABEL(NODE) TREE_OPERAND ((NODE), 0)\n-#define FINALLY_EXPR_BLOCK(NODE) TREE_OPERAND ((NODE), 1)\n+#define FINALLY_EXPR_LABEL(NODE) TREE_OPERAND (FINALLY_EXPR_CHECK (NODE), 0)\n+#define FINALLY_EXPR_BLOCK(NODE) TREE_OPERAND (FINALLY_EXPR_CHECK (NODE), 1)\n \n #define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n #define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)\n+\n /* True for an implicit block surrounding declaration not at start of {...}. */\n-#define BLOCK_IS_IMPLICIT(NODE) TREE_LANG_FLAG_1 (NODE)\n+#define BLOCK_IS_IMPLICIT(NODE) TREE_LANG_FLAG_1 (BLOCK_CHECK (NODE))\n #define BLOCK_EMPTY_P(NODE) \\\n   (TREE_CODE (NODE) == BLOCK && BLOCK_EXPR_BODY (NODE) == empty_stmt_node)\n \n@@ -1797,7 +1811,6 @@ enum\n   JV_STATE_ERROR = 12,\n \n   JV_STATE_DONE = 14\t\t/* Must be last.  */\n-\n };\n \n #undef DEBUG_JAVA_BINDING_LEVELS"}, {"sha": "dbc34c6d8fcaf5fdb50779f169df86496722dcca", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -633,10 +633,7 @@ get_access_flags (tree decl)\n {\n   int flags = 0;\n   int isfield = TREE_CODE (decl) == FIELD_DECL || TREE_CODE (decl) == VAR_DECL;\n-  if (CLASS_PUBLIC (decl))  /* same as FIELD_PUBLIC and METHOD_PUBLIC */\n-    flags |= ACC_PUBLIC;\n-  if (CLASS_FINAL (decl))  /* same as FIELD_FINAL and METHOD_FINAL */\n-    flags |= ACC_FINAL;\n+\n   if (isfield || TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       if (TREE_PROTECTED (decl))\n@@ -646,6 +643,10 @@ get_access_flags (tree decl)\n     }\n   else if (TREE_CODE (decl) == TYPE_DECL)\n     {\n+      if (CLASS_PUBLIC (decl))\n+\tflags |= ACC_PUBLIC;\n+      if (CLASS_FINAL (decl))\n+\tflags |= ACC_FINAL;\n       if (CLASS_SUPER (decl))\n \tflags |= ACC_SUPER;\n       if (CLASS_ABSTRACT (decl))\n@@ -669,6 +670,10 @@ get_access_flags (tree decl)\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n+      if (METHOD_PUBLIC (decl))\n+\tflags |= ACC_PUBLIC;\n+      if (METHOD_FINAL (decl))\n+\tflags |= ACC_FINAL;\n       if (METHOD_NATIVE (decl))\n \tflags |= ACC_NATIVE;\n       if (METHOD_STATIC (decl))\n@@ -682,6 +687,10 @@ get_access_flags (tree decl)\n     }\n   if (isfield)\n     {\n+      if (FIELD_PUBLIC (decl))\n+\tflags |= ACC_PUBLIC;\n+      if (FIELD_FINAL (decl))\n+\tflags |= ACC_FINAL;\n       if (FIELD_STATIC (decl))\n \tflags |= ACC_STATIC;\n       if (FIELD_VOLATILE (decl))"}, {"sha": "a2994e5b36ab02cbeda4c8126fc5da2586f88262", "filename": "gcc/tree.c", "status": "modified", "additions": 129, "deletions": 25, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -1798,7 +1798,6 @@ type_contains_placeholder_p (tree type)\n     {\n     case VOID_TYPE:\n     case COMPLEX_TYPE:\n-    case VECTOR_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case CHAR_TYPE:\n@@ -1818,6 +1817,7 @@ type_contains_placeholder_p (tree type)\n \n     case ARRAY_TYPE:\n     case SET_TYPE:\n+    case VECTOR_TYPE:\n       /* We're already checked the component type (TREE_TYPE), so just check\n \t the index type.  */\n       return type_contains_placeholder_p (TYPE_DOMAIN (type));\n@@ -3080,34 +3080,95 @@ type_hash_list (tree list, hashval_t hashcode)\n \n /* These are the Hashtable callback functions.  */\n \n-/* Returns true if the types are equal.  */\n+/* Returns true iff the types are equivalent.  */\n \n static int\n type_hash_eq (const void *va, const void *vb)\n {\n   const struct type_hash *a = va, *b = vb;\n-  if (a->hash == b->hash\n-      && TREE_CODE (a->type) == TREE_CODE (b->type)\n-      && TREE_TYPE (a->type) == TREE_TYPE (b->type)\n-      && attribute_list_equal (TYPE_ATTRIBUTES (a->type),\n-\t\t\t       TYPE_ATTRIBUTES (b->type))\n-      && TYPE_ALIGN (a->type) == TYPE_ALIGN (b->type)\n-      && (TYPE_MAX_VALUE (a->type) == TYPE_MAX_VALUE (b->type)\n-\t  || tree_int_cst_equal (TYPE_MAX_VALUE (a->type),\n-\t\t\t\t TYPE_MAX_VALUE (b->type)))\n-      && (TYPE_MIN_VALUE (a->type) == TYPE_MIN_VALUE (b->type)\n-\t  || tree_int_cst_equal (TYPE_MIN_VALUE (a->type),\n-\t\t\t\t TYPE_MIN_VALUE (b->type)))\n-      /* Note that TYPE_DOMAIN is TYPE_ARG_TYPES for FUNCTION_TYPE.  */\n-      && (TYPE_DOMAIN (a->type) == TYPE_DOMAIN (b->type)\n-\t  || (TYPE_DOMAIN (a->type)\n-\t      && TREE_CODE (TYPE_DOMAIN (a->type)) == TREE_LIST\n-\t      && TYPE_DOMAIN (b->type)\n-\t      && TREE_CODE (TYPE_DOMAIN (b->type)) == TREE_LIST\n-\t      && type_list_equal (TYPE_DOMAIN (a->type),\n-\t\t\t\t  TYPE_DOMAIN (b->type)))))\n-    return 1;\n-  return 0;\n+\n+  /* First test the things that are the same for all types.  */\n+  if (a->hash != b->hash\n+      || TREE_CODE (a->type) != TREE_CODE (b->type)\n+      || TREE_TYPE (a->type) != TREE_TYPE (b->type)\n+      || !attribute_list_equal (TYPE_ATTRIBUTES (a->type),\n+\t\t\t\t TYPE_ATTRIBUTES (b->type))\n+      || TYPE_ALIGN (a->type) != TYPE_ALIGN (b->type)\n+      || TYPE_MODE (a->type) != TYPE_MODE (b->type))\n+    return 0;\n+\n+  switch (TREE_CODE (a->type))\n+    {\n+    case VOID_TYPE:\n+    case COMPLEX_TYPE:\n+    case VECTOR_TYPE:\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      return 1;\n+\n+    case ENUMERAL_TYPE:\n+      if (TYPE_VALUES (a->type) != TYPE_VALUES (b->type)\n+\t  && !(TYPE_VALUES (a->type)\n+\t       && TREE_CODE (TYPE_VALUES (a->type)) == TREE_LIST\n+\t       && TYPE_VALUES (b->type)\n+\t       && TREE_CODE (TYPE_VALUES (b->type)) == TREE_LIST\n+\t       && type_list_equal (TYPE_VALUES (a->type),\n+\t\t\t\t   TYPE_VALUES (b->type))))\n+\treturn 0;\n+\n+      /* ... fall through ... */\n+\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case CHAR_TYPE:\n+      return ((TYPE_MAX_VALUE (a->type) == TYPE_MAX_VALUE (b->type)\n+\t       || tree_int_cst_equal (TYPE_MAX_VALUE (a->type),\n+\t\t\t\t      TYPE_MAX_VALUE (b->type)))\n+\t      && (TYPE_MIN_VALUE (a->type) == TYPE_MIN_VALUE (b->type)\n+\t\t  && tree_int_cst_equal (TYPE_MIN_VALUE (a->type),\n+\t\t\t\t\t TYPE_MIN_VALUE (b->type))));\n+\n+    case OFFSET_TYPE:\n+      return TYPE_OFFSET_BASETYPE (a->type) == TYPE_OFFSET_BASETYPE (b->type);\n+\n+    case METHOD_TYPE:\n+      return (TYPE_METHOD_BASETYPE (a->type) == TYPE_METHOD_BASETYPE (b->type)\n+\t      && (TYPE_ARG_TYPES (a->type) == TYPE_ARG_TYPES (b->type)\n+\t\t  || (TYPE_ARG_TYPES (a->type)\n+\t\t      && TREE_CODE (TYPE_ARG_TYPES (a->type)) == TREE_LIST\n+\t\t      && TYPE_ARG_TYPES (b->type)\n+\t\t      && TREE_CODE (TYPE_ARG_TYPES (b->type)) == TREE_LIST\n+\t\t      && type_list_equal (TYPE_ARG_TYPES (a->type),\n+\t\t\t\t\t  TYPE_ARG_TYPES (b->type)))));\n+\t\t\t\t\t\t\t\t      \n+    case ARRAY_TYPE:\n+    case SET_TYPE:\n+      return TYPE_DOMAIN (a->type) == TYPE_DOMAIN (b->type);\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      return (TYPE_FIELDS (a->type) == TYPE_FIELDS (b->type)\n+\t      || (TYPE_FIELDS (a->type)\n+\t\t  && TREE_CODE (TYPE_FIELDS (a->type)) == TREE_LIST\n+\t\t  && TYPE_FIELDS (b->type)\n+\t\t  && TREE_CODE (TYPE_FIELDS (b->type)) == TREE_LIST\n+\t\t  && type_list_equal (TYPE_FIELDS (a->type),\n+\t\t\t\t      TYPE_FIELDS (b->type))));\n+\n+    case FUNCTION_TYPE:\n+      return (TYPE_ARG_TYPES (a->type) == TYPE_ARG_TYPES (b->type)\n+\t      || (TYPE_ARG_TYPES (a->type)\n+\t\t  && TREE_CODE (TYPE_ARG_TYPES (a->type)) == TREE_LIST\n+\t\t  && TYPE_ARG_TYPES (b->type)\n+\t\t  && TREE_CODE (TYPE_ARG_TYPES (b->type)) == TREE_LIST\n+\t\t  && type_list_equal (TYPE_ARG_TYPES (a->type),\n+\t\t\t\t      TYPE_ARG_TYPES (b->type))));\n+\n+    default:\n+      return 0;\n+    }\n }\n \n /* Return the cached hash value.  */\n@@ -4894,6 +4955,7 @@ get_set_constructor_bytes (tree init, unsigned char *buffer, int wd_size)\n }\n \f\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n+\n /* Complain that the tree code of NODE does not match the expected CODE.\n    FILE, LINE, and FUNCTION are of the caller.  */\n \n@@ -4906,7 +4968,49 @@ tree_check_failed (const tree node, enum tree_code code, const char *file,\n \t\t  function, trim_filename (file), line);\n }\n \n-/* Similar to above, except that we check for a class of tree\n+/* Similar to above except that we allowed the code to be one of two\n+   different codes.  */\n+\n+void\n+tree_check2_failed (const tree node, enum tree_code code1,\n+\t\t    enum tree_code code2, const char *file,\n+\t\t    int line, const char *function)\n+{\n+  internal_error (\"tree check: expected %s or %s, have %s in %s, at %s:%d\",\n+\t\t  tree_code_name[code1], tree_code_name[code2],\n+\t\t  tree_code_name[TREE_CODE (node)],\n+\t\t  function, trim_filename (file), line);\n+}\n+\n+/* Likewise for three different codes.  */\n+\n+void\n+tree_check3_failed (const tree node, enum tree_code code1,\n+\t\t    enum tree_code code2, enum tree_code code3,\n+\t\t    const char *file, int line, const char *function)\n+{\n+  internal_error (\"tree check: expected %s, %s or %s; have %s in %s, at %s:%d\",\n+\t\t  tree_code_name[code1], tree_code_name[code2],\n+\t\t  tree_code_name[code3], tree_code_name[TREE_CODE (node)],\n+\t\t  function, trim_filename (file), line);\n+}\n+\n+/* ... and for four different codes.  */\n+\n+void\n+tree_check5_failed (const tree node, enum tree_code code1,\n+\t\t    enum tree_code code2, enum tree_code code3,\n+\t\t    enum tree_code code4, enum tree_code code5,\n+\t\t    const char *file, int line, const char *function)\n+{\n+  internal_error\n+    (\"tree check: expected %s, %s, %s, %s or %s; have %s in %s, at %s:%d\",\n+     tree_code_name[code1], tree_code_name[code2], tree_code_name[code3],\n+     tree_code_name[code4], tree_code_name[code5],\n+     tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n+}\n+\n+/* Similar to tree_check_failed, except that we check for a class of tree\n    code, given in CL.  */\n \n void"}, {"sha": "e5e710d63a4618518598b0790dc848fba687f5a8", "filename": "gcc/tree.h", "status": "modified", "additions": 77, "deletions": 17, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb34af89c78f8b04af925cc272e4462c0316f54b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=eb34af89c78f8b04af925cc272e4462c0316f54b", "patch": "@@ -307,6 +307,34 @@ struct tree_common GTY(())\n       tree_check_failed (__t, (CODE), __FILE__, __LINE__, __FUNCTION__); \\\n     __t; })\n \n+#define TREE_CHECK2(T, CODE1, CODE2) __extension__\t\t\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE2))\t\t\t\t\t\\\n+      tree_check2_failed (__t, (CODE1), (CODE2), __FILE__, __LINE__,\t\\\n+\t\t\t  __FUNCTION__);\t\t\t\t\\\n+    __t; })\n+\n+#define TREE_CHECK3(T, CODE1, CODE2, CODE3) __extension__\t\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE2)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE3))\t\t\t\t\t\\\n+      tree_check3_failed (__t, (CODE1), (CODE2), (CODE3), __FILE__,\t\\\n+\t\t\t  __LINE__, __FUNCTION__);\t\t\t\\\n+    __t; })\n+\n+#define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) __extension__\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE2)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE3)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE4)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE5))\t\t\t\t\t\\\n+      tree_check5_failed (__t, (CODE1), (CODE2), (CODE3), (CODE4),\t\\\n+\t\t\t  (CODE5), __FILE__, __LINE__, __FUNCTION__);\t\\\n+    __t; })\n+\n #define TREE_CLASS_CHECK(T, CLASS) __extension__\t\t\t\\\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n     if (TREE_CODE_CLASS (TREE_CODE(__t)) != (CLASS))\t\t\t\\\n@@ -367,6 +395,17 @@ struct tree_common GTY(())\n extern void tree_check_failed (const tree, enum tree_code,\n \t\t\t       const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n+extern void tree_check2_failed (const tree, enum tree_code, enum tree_code,\n+\t\t\t       const char *, int, const char *)\n+    ATTRIBUTE_NORETURN;\n+extern void tree_check3_failed (const tree, enum tree_code, enum tree_code,\n+\t\t\t\tenum tree_code, const char *, int,\n+\t\t\t\tconst char *)\n+    ATTRIBUTE_NORETURN;\n+extern void tree_check5_failed (const tree, enum tree_code, enum tree_code,\n+\t\t\t\tenum tree_code, enum tree_code, enum tree_code,\n+\t\t\t\tconst char *, int, const char *)\n+    ATTRIBUTE_NORETURN;\n extern void tree_class_check_failed (const tree, int,\n \t\t\t\t     const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n@@ -380,12 +419,15 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n #else /* not ENABLE_TREE_CHECKING, or not gcc */\n \n-#define TREE_CHECK(T, CODE)\t\t(T)\n-#define TREE_CLASS_CHECK(T, CODE)\t(T)\n-#define EXPR_CHECK(T)\t\t\t(T)\n-#define TREE_VEC_ELT_CHECK(T, I)\t((T)->vec.a[I])\n-#define TREE_OPERAND_CHECK(T, I)\t((T)->exp.operands[I])\n-#define TREE_OPERAND_CHECK_CODE(T, CODE, I) ((T)->exp.operands[I])\n+#define TREE_CHECK(T, CODE)\t\t\t(T)\n+#define TREE_CHECK2(T, CODE1, CODE2)\t\t(T)\n+#define TREE_CHECK3(T, CODE1, CODE2, CODE3)\t(T)\n+#define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)\n+#define TREE_CLASS_CHECK(T, CODE)\t\t(T)\n+#define EXPR_CHECK(T)\t\t\t\t(T)\n+#define TREE_VEC_ELT_CHECK(T, I)\t\t((T)->vec.a[I])\n+#define TREE_OPERAND_CHECK(T, I)\t\t((T)->exp.operands[I])\n+#define TREE_OPERAND_CHECK_CODE(T, CODE, I)\t((T)->exp.operands[I])\n #define TREE_RTL_OPERAND_CHECK(T, CODE, I)  (*(rtx *) &((T)->exp.operands[I]))\n \n #endif\n@@ -396,6 +438,17 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define DECL_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'd')\n #define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'c')\n #define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, 's')\n+#define FUNC_OR_METHOD_CHECK(T)\tTREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)\n+\n+#define SET_ARRAY_OR_VECTOR_CHECK(T) \\\n+  TREE_CHECK3 (T, ARRAY_TYPE, SET_TYPE, VECTOR_TYPE)\n+\n+#define REC_OR_UNION_CHECK(T)\t\\\n+  TREE_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)\n+\n+#define NUMERICAL_TYPE_CHECK(T)\t\t\t\t\t\\\n+  TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE,\t\\\n+\t       CHAR_TYPE, REAL_TYPE)\n \n /* In all nodes that are expressions, this is the data type of the expression.\n    In POINTER_TYPE nodes, this is the type that the pointer points to.\n@@ -945,24 +998,31 @@ struct tree_block GTY(())\n /* Define fields and accessors for nodes representing data types.  */\n \n /* See tree.def for documentation of the use of these fields.\n-   Look at the documentation of the various ..._TYPE tree codes.  */\n+   Look at the documentation of the various ..._TYPE tree codes.\n+\n+   Note that the type.values, type.minval, and type.maxval fiels are\n+   overloaded and used for different macros in different kinds of types.\n+   Each macro must check to ensure the tree node is of the proper kind of\n+   type.  Note also that some of the front-ends also overload these fields,\n+   so they must be checked as well.  */\n \n #define TYPE_UID(NODE) (TYPE_CHECK (NODE)->type.uid)\n #define TYPE_SIZE(NODE) (TYPE_CHECK (NODE)->type.size)\n #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)\n #define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)\n-#define TYPE_VALUES(NODE) (TYPE_CHECK (NODE)->type.values)\n-#define TYPE_DOMAIN(NODE) (TYPE_CHECK (NODE)->type.values)\n-#define TYPE_FIELDS(NODE) (TYPE_CHECK (NODE)->type.values)\n-#define TYPE_METHODS(NODE) (TYPE_CHECK (NODE)->type.maxval)\n-#define TYPE_VFIELD(NODE) (TYPE_CHECK (NODE)->type.minval)\n-#define TYPE_ARG_TYPES(NODE) (TYPE_CHECK (NODE)->type.values)\n-#define TYPE_METHOD_BASETYPE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n-#define TYPE_OFFSET_BASETYPE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n+#define TYPE_ORIG_SIZE_TYPE(NODE) (INTEGER_TYPE_CHECK (NODE)->type.values)\n+#define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)\n+#define TYPE_DOMAIN(NODE) (SET_ARRAY_OR_VECTOR_CHECK (NODE)->type.values)\n+#define TYPE_FIELDS(NODE) (REC_OR_UNION_CHECK (NODE)->type.values)\n+#define TYPE_METHODS(NODE) (REC_OR_UNION_CHECK (NODE)->type.maxval)\n+#define TYPE_VFIELD(NODE) (REC_OR_UNION_CHECK (NODE)->type.minval)\n+#define TYPE_ARG_TYPES(NODE) (FUNC_OR_METHOD_CHECK (NODE)->type.values)\n+#define TYPE_METHOD_BASETYPE(NODE) (FUNC_OR_METHOD_CHECK (NODE)->type.maxval)\n+#define TYPE_OFFSET_BASETYPE(NODE) (OFFSET_TYPE_CHECK (NODE)->type.maxval)\n #define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type.pointer_to)\n #define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type.reference_to)\n-#define TYPE_MIN_VALUE(NODE) (TYPE_CHECK (NODE)->type.minval)\n-#define TYPE_MAX_VALUE(NODE) (TYPE_CHECK (NODE)->type.maxval)\n+#define TYPE_MIN_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.minval)\n+#define TYPE_MAX_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.maxval)\n #define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type.precision)\n #define TYPE_SYMTAB_ADDRESS(NODE) (TYPE_CHECK (NODE)->type.symtab.address)\n #define TYPE_SYMTAB_POINTER(NODE) (TYPE_CHECK (NODE)->type.symtab.pointer)"}]}