{"sha": "dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZhMzIyNjE1M2ZiZmU0OTk5ZjJhZjZkOTE2ZmQ1OTdlMWQ1Y2UzZQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2012-10-24T22:01:50Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2012-10-24T22:01:50Z"}, "message": "re PR c++/54928 (Infinite output with after ICE with macro)\n\n2012-10-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR c++/54928\n\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc):\n\tUse diagnostic_append_note.\n\t* diagnostic.c (diagnostic_build_prefix): Make diagnostic const.\n\t(default_diagnostic_finalizer): Do not destroy prefix here.\n\t(diagnostic_report_diagnostic): Destroy it here.\n\t(diagnostic_append_note): New.\n\t* diagnostic.h (diagnostic_append_note): Declare.\n\nFrom-SVN: r192786", "tree": {"sha": "583600b9236c0cc119d94c2ca69748fab0849e77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/583600b9236c0cc119d94c2ca69748fab0849e77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/comments", "author": null, "committer": null, "parents": [{"sha": "093183112063759e754e67fc60d80458e4133692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/093183112063759e754e67fc60d80458e4133692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/093183112063759e754e67fc60d80458e4133692"}], "stats": {"total": 143, "additions": 72, "deletions": 71}, "files": [{"sha": "1052580930e0b016499b20efa720f9cd59ea84a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "patch": "@@ -1,3 +1,14 @@\n+2012-10-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR c++/54928\n+\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc):\n+\tUse diagnostic_append_note.\n+\t* diagnostic.c (diagnostic_build_prefix): Make diagnostic const.\n+\t(default_diagnostic_finalizer): Do not destroy prefix here.\n+\t(diagnostic_report_diagnostic): Destroy it here.\n+\t(diagnostic_append_note): New.\n+\t* diagnostic.h (diagnostic_append_note): Declare.\n+\n 2012-10-24  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/55055"}, {"sha": "ff210dcaed4587bc09d46e417cfb5a676df3c550", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "patch": "@@ -208,7 +208,7 @@ diagnostic_set_info (diagnostic_info *diagnostic, const char *gmsgid,\n    responsible for freeing the memory.  */\n char *\n diagnostic_build_prefix (diagnostic_context *context,\n-\t\t\t diagnostic_info *diagnostic)\n+\t\t\t const diagnostic_info *diagnostic)\n {\n   static const char *const diagnostic_kind_text[] = {\n #define DEFINE_DIAGNOSTIC_KIND(K, T) (T),\n@@ -519,10 +519,9 @@ default_diagnostic_starter (diagnostic_context *context,\n }\n \n void\n-default_diagnostic_finalizer (diagnostic_context *context,\n+default_diagnostic_finalizer (diagnostic_context *context ATTRIBUTE_UNUSED,\n \t\t\t      diagnostic_info *diagnostic ATTRIBUTE_UNUSED)\n {\n-  pp_destroy_prefix (context->printer);\n }\n \n /* Interface to specify diagnostic kind overrides.  Returns the\n@@ -759,6 +758,7 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n   pp_output_formatted_text (context->printer);\n   diagnostic_show_locus (context, diagnostic);\n   (*diagnostic_finalizer (context)) (context, diagnostic);\n+  pp_destroy_prefix (context->printer);\n   pp_newline_and_flush (context->printer);\n   diagnostic_action_after_output (context, diagnostic);\n   diagnostic->message.format_spec = saved_format_spec;\n@@ -821,6 +821,29 @@ verbatim (const char *gmsgid, ...)\n   va_end (ap);\n }\n \n+/* Add a note with text GMSGID and with LOCATION to the diagnostic CONTEXT.  */\n+void\n+diagnostic_append_note (diagnostic_context *context,\n+                        location_t location,\n+                        const char * gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+\n+  va_start (ap, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &ap, location, DK_NOTE);\n+  if (context->inhibit_notes_p)\n+    return;\n+  pp_set_prefix (context->printer,\n+                 diagnostic_build_prefix (context, &diagnostic));\n+  pp_newline (context->printer);\n+  pp_format (context->printer, &diagnostic.message);\n+  pp_output_formatted_text (context->printer);\n+  pp_destroy_prefix (context->printer);\n+  diagnostic_show_locus (context, &diagnostic);\n+  va_end(ap);\n+}\n+\n bool\n emit_diagnostic (diagnostic_t kind, location_t location, int opt,\n \t\t const char *gmsgid, ...)"}, {"sha": "e1d2146b25795a1c6615df979fb303766d0fa050", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "patch": "@@ -282,8 +282,10 @@ extern void diagnostic_set_info_translated (diagnostic_info *, const char *,\n \t\t\t\t\t    va_list *, location_t,\n \t\t\t\t\t    diagnostic_t)\n      ATTRIBUTE_GCC_DIAG(2,0);\n+extern void diagnostic_append_note (diagnostic_context *, location_t,\n+                                    const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);\n #endif\n-extern char *diagnostic_build_prefix (diagnostic_context *, diagnostic_info *);\n+extern char *diagnostic_build_prefix (diagnostic_context *, const diagnostic_info *);\n void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n void default_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n void diagnostic_set_caret_max_width (diagnostic_context *context, int value);"}, {"sha": "3eab7ec3e5d08e1c430b7e5fb69d6bd3135607a8", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 32, "deletions": 67, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfa3226153fbfe4999f2af6d916fd597e1d5ce3e/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=dfa3226153fbfe4999f2af6d916fd597e1d5ce3e", "patch": "@@ -102,7 +102,7 @@ DEF_VEC_ALLOC_O (loc_map_pair, heap);\n \n static void\n maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n-                                 diagnostic_info *diagnostic,\n+                                 const diagnostic_info *diagnostic,\n                                  source_location where)\n {\n   const struct line_map *map;\n@@ -144,14 +144,12 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n   /* Walk LOC_VEC and print the macro expansion trace, unless the\n      first macro which expansion triggered this trace was expanded\n      inside a system header.  */\n+  int saved_location_line =\n+    expand_location_to_spelling_point (diagnostic->location).line;\n+\n   if (!LINEMAP_SYSP (map))\n     FOR_EACH_VEC_ELT (loc_map_pair, loc_vec, ix, iter)\n       {\n-        source_location resolved_def_loc = 0, resolved_exp_loc = 0,\n-\t  saved_location = 0;\n-\tint resolved_def_loc_line = 0, saved_location_line = 0;\n-        diagnostic_t saved_kind;\n-        const char *saved_prefix;\n \t/* Sometimes, in the unwound macro expansion trace, we want to\n \t   print a part of the context that shows where, in the\n \t   definition of the relevant macro, is the token (we are\n@@ -174,11 +172,7 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n \t   A contrario, when the first interesting diagnostic line\n \t   points into the definition of the macro, we don't need to\n \t   display any line for that macro definition in the trace\n-\t   anymore, otherwise it'd be redundant.\n-\n-\t   This flag is true when we need to display the context of\n-\t   the macro definition.  */\n-\tbool print_definition_context_p = false;\n+\t   anymore, otherwise it'd be redundant.  */\n \n         /* Okay, now here is what we want.  For each token resulting\n            from macro expansion we want to show: 1/ where in the\n@@ -187,75 +181,46 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n \n         /* Resolve the location iter->where into the locus 1/ of the\n            comment above.  */\n-        resolved_def_loc =\n+        source_location resolved_def_loc =\n           linemap_resolve_location (line_table, iter->where,\n                                     LRK_MACRO_DEFINITION_LOCATION, NULL);\n \n \t/* Don't print trace for locations that are reserved or from\n \t   within a system header.  */\n-\t{\n-\t  const struct line_map *m = NULL;\n-\t  source_location l = linemap_resolve_location (line_table, resolved_def_loc,\n-\t\t\t\t\t\t\tLRK_SPELLING_LOCATION,\n-\t\t\t\t\t\t\t&m);\n-\t  if (l < RESERVED_LOCATION_COUNT\n-\t      || LINEMAP_SYSP (m))\n-\t    continue;\n-\n-\t  resolved_def_loc_line = SOURCE_LINE (m, l);\n-\t}\n+        const struct line_map *m = NULL;\n+        source_location l = \n+          linemap_resolve_location (line_table, resolved_def_loc,\n+                                    LRK_SPELLING_LOCATION,  &m);\n+        if (l < RESERVED_LOCATION_COUNT || LINEMAP_SYSP (m))\n+          continue;\n+        \n+\t/* We need to print the context of the macro definition only\n+\t   when the locus of the first displayed diagnostic (displayed\n+\t   before this trace) was inside the definition of the\n+\t   macro.  */\n+        int resolved_def_loc_line = SOURCE_LINE (m, l);\n+        if (ix == 0 && saved_location_line != resolved_def_loc_line)\n+          {\n+            diagnostic_append_note (context, resolved_def_loc, \n+                                    \"in definition of macro %qs\",\n+                                    linemap_map_get_macro_name (iter->map));\n+            /* At this step, as we've printed the context of the macro\n+               definition, we don't want to print the context of its\n+               expansion, otherwise, it'd be redundant.  */\n+            continue;\n+          }\n \n         /* Resolve the location of the expansion point of the macro\n            which expansion gave the token represented by def_loc.\n            This is the locus 2/ of the earlier comment.  */\n-        resolved_exp_loc =\n+        source_location resolved_exp_loc =\n           linemap_resolve_location (line_table,\n                                     MACRO_MAP_EXPANSION_POINT_LOCATION (iter->map),\n                                     LRK_MACRO_DEFINITION_LOCATION, NULL);\n \n-        saved_kind = diagnostic->kind;\n-        saved_prefix = pp_get_prefix (context->printer);\n-        saved_location = diagnostic->location;\n-\tsaved_location_line =\n-\t  expand_location_to_spelling_point (saved_location).line;\n-\n-        diagnostic->kind = DK_NOTE;\n-\n-\t/* We need to print the context of the macro definition only\n-\t   when the locus of the first displayed diagnostic (displayed\n-\t   before this trace) was inside the definition of the\n-\t   macro.  */\n-\tprint_definition_context_p =\n-\t  (ix == 0 && (saved_location_line != resolved_def_loc_line));\n-\n-\tif (print_definition_context_p)\n-\t  {\n-\t    diagnostic->location = resolved_def_loc;\n-\t    pp_set_prefix (context->printer,\n-\t\t\t   diagnostic_build_prefix (context, diagnostic));\n-\t    pp_newline (context->printer);\n-\t    pp_printf (context->printer, \"in definition of macro '%s'\",\n-\t\t       linemap_map_get_macro_name (iter->map));\n-\t    pp_destroy_prefix (context->printer);\n-\t    diagnostic_show_locus (context, diagnostic);\n-\t    /* At this step, as we've printed the context of the macro\n-\t       definition, we don't want to print the context of its\n-\t       expansion, otherwise, it'd be redundant.  */\n-\t    continue;\n-\t  }\n-\n-\tdiagnostic->location = resolved_exp_loc;\n-\tpp_set_prefix (context->printer,\n-                       diagnostic_build_prefix (context, diagnostic));\n-\tpp_newline (context->printer);\n-\tpp_printf (context->printer, \"in expansion of macro '%s'\",\n-\t\t   linemap_map_get_macro_name (iter->map));\n-        pp_destroy_prefix (context->printer);\n-        diagnostic_show_locus (context, diagnostic);\n-\n-        diagnostic->kind = saved_kind;\n-        diagnostic->location = saved_location;\n-        pp_set_prefix (context->printer, saved_prefix);\n+        diagnostic_append_note (context, resolved_exp_loc, \n+                                \"in expansion of macro %qs\",\n+                                linemap_map_get_macro_name (iter->map));\n       }\n \n   VEC_free (loc_map_pair, heap, loc_vec);"}]}