{"sha": "6bb6267173b422eb05776c3212925e57aab008e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJiNjI2NzE3M2I0MjJlYjA1Nzc2YzMyMTI5MjVlNTdhYWIwMDhlNQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-03-29T20:33:07Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2009-03-29T20:33:07Z"}, "message": "re PR fortran/38823 (Diagnose and treat (-2.0)**2.0 properly)\n\n2009-03-29  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n        PR fortran/38823\n        * gfortran.dg/power1.f90: New test.\n\n2009-03-29  Steven G. Kargl  <kargl@gcc.gnu.org>\n\n        PR fortran/38823\n        * gfortran.h: Add ARITH_PROHIBIT to arith enum.\n        expr.c (gfc_match_init_expr): Add global variable init_flag to\n        flag matching an initialization expression.\n        (check_intrinsic_op): Move no longer reachable error message to ...\n        * arith.c (arith_power): ... here.  Remove gfc_ prefix in\n        gfc_arith_power.  Use init_flag.  Allow constant folding of x**y\n        when y is REAL or COMPLEX.\n        (eval_intrinsic): Remove restriction that y in x**y must be INTEGER\n        for constant folding.\n        * gfc_power: Update gfc_arith_power to arith_power\n\nFrom-SVN: r145261", "tree": {"sha": "bab65c93c89839c430906d03c8985425a749601b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bab65c93c89839c430906d03c8985425a749601b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bb6267173b422eb05776c3212925e57aab008e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb6267173b422eb05776c3212925e57aab008e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bb6267173b422eb05776c3212925e57aab008e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bb6267173b422eb05776c3212925e57aab008e5/comments", "author": null, "committer": null, "parents": [{"sha": "615ce5fd7ac9df44ecc9820f58383569c880fb73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/615ce5fd7ac9df44ecc9820f58383569c880fb73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/615ce5fd7ac9df44ecc9820f58383569c880fb73"}], "stats": {"total": 389, "additions": 275, "deletions": 114}, "files": [{"sha": "8bdf01067a52892cab0bc011588a551f5d1fc68c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6bb6267173b422eb05776c3212925e57aab008e5", "patch": "@@ -1,3 +1,17 @@\n+2009-03-29  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/38823\n+\t* gfortran.h: Add ARITH_PROHIBIT to arith enum.\n+\texpr.c (gfc_match_init_expr): Add global variable init_flag to\n+\tflag matching an initialization expression.\n+\t(check_intrinsic_op): Move no longer reachable error message to ...\n+\t* arith.c (arith_power): ... here.  Remove gfc_ prefix in\n+\tgfc_arith_power.  Use init_flag.  Allow constant folding of x**y\n+\twhen y is REAL or COMPLEX.\n+\t(eval_intrinsic): Remove restriction that y in x**y must be INTEGER\n+\tfor constant folding.\n+\t* gfc_power: Update gfc_arith_power to arith_power\n+\n 2009-03-29  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/37423"}, {"sha": "17f2221ef8c5c5e8ad1797dafe957790d6692764", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 184, "deletions": 101, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=6bb6267173b422eb05776c3212925e57aab008e5", "patch": "@@ -932,131 +932,213 @@ complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n }\n \n \n-/* Raise a number to an integer power.  */\n+/* Raise a number to a power.  */\n \n static arith\n-gfc_arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n+arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n {\n   int power_sign;\n   gfc_expr *result;\n   arith rc;\n-\n-  gcc_assert (op2->expr_type == EXPR_CONSTANT && op2->ts.type == BT_INTEGER);\n+  extern bool init_flag;\n \n   rc = ARITH_OK;\n   result = gfc_constant_result (op1->ts.type, op1->ts.kind, &op1->where);\n-  power_sign = mpz_sgn (op2->value.integer);\n \n-  if (power_sign == 0)\n+  switch (op2->ts.type)\n     {\n-      /* Handle something to the zeroth power.  Since we're dealing\n-\t with integral exponents, there is no ambiguity in the\n-\t limiting procedure used to determine the value of 0**0.  */\n-      switch (op1->ts.type)\n+    case BT_INTEGER:\n+      power_sign = mpz_sgn (op2->value.integer);\n+\n+      if (power_sign == 0)\n \t{\n-\tcase BT_INTEGER:\n-\t  mpz_set_ui (result->value.integer, 1);\n-\t  break;\n+\t  /* Handle something to the zeroth power.  Since we're dealing\n+\t     with integral exponents, there is no ambiguity in the\n+\t     limiting procedure used to determine the value of 0**0.  */\n+\t  switch (op1->ts.type)\n+\t    {\n+\t    case BT_INTEGER:\n+\t      mpz_set_ui (result->value.integer, 1);\n+\t      break;\n \n-\tcase BT_REAL:\n-\t  mpfr_set_ui (result->value.real, 1, GFC_RND_MODE);\n-\t  break;\n+\t    case BT_REAL:\n+\t      mpfr_set_ui (result->value.real, 1, GFC_RND_MODE);\n+\t      break;\n \n-\tcase BT_COMPLEX:\n-\t  mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n-\t  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-\t  break;\n+\t    case BT_COMPLEX:\n+\t      mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n+\t      mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+\t      break;\n \n-\tdefault:\n-\t  gfc_internal_error (\"gfc_arith_power(): Bad base\");\n+\t    default:\n+\t      gfc_internal_error (\"arith_power(): Bad base\");\n+\t    }\n \t}\n-    }\n-  else\n-    {\n-      switch (op1->ts.type)\n+      else\n \t{\n-\tcase BT_INTEGER:\n-\t  {\n-\t    int power;\n-\n-\t    /* First, we simplify the cases of op1 == 1, 0 or -1.  */\n-\t    if (mpz_cmp_si (op1->value.integer, 1) == 0)\n-\t      {\n-\t\t/* 1**op2 == 1 */\n-\t\tmpz_set_si (result->value.integer, 1);\n-\t      }\n-\t    else if (mpz_cmp_si (op1->value.integer, 0) == 0)\n-\t      {\n-\t\t/* 0**op2 == 0, if op2 > 0\n-\t           0**op2 overflow, if op2 < 0 ; in that case, we\n-\t\t   set the result to 0 and return ARITH_DIV0.  */\n-\t\tmpz_set_si (result->value.integer, 0);\n-\t\tif (mpz_cmp_si (op2->value.integer, 0) < 0)\n-\t\t  rc = ARITH_DIV0;\n-\t      }\n-\t    else if (mpz_cmp_si (op1->value.integer, -1) == 0)\n+\t  switch (op1->ts.type)\n+\t    {\n+\t    case BT_INTEGER:\n \t      {\n-\t\t/* (-1)**op2 == (-1)**(mod(op2,2)) */\n-\t\tunsigned int odd = mpz_fdiv_ui (op2->value.integer, 2);\n-\t\tif (odd)\n-\t\t  mpz_set_si (result->value.integer, -1);\n+\t\tint power;\n+\n+\t\t/* First, we simplify the cases of op1 == 1, 0 or -1.  */\n+\t\tif (mpz_cmp_si (op1->value.integer, 1) == 0)\n+\t\t  {\n+\t\t    /* 1**op2 == 1 */\n+\t\t    mpz_set_si (result->value.integer, 1);\n+\t\t  }\n+\t\telse if (mpz_cmp_si (op1->value.integer, 0) == 0)\n+\t\t  {\n+\t\t    /* 0**op2 == 0, if op2 > 0\n+\t               0**op2 overflow, if op2 < 0 ; in that case, we\n+\t\t       set the result to 0 and return ARITH_DIV0.  */\n+\t\t    mpz_set_si (result->value.integer, 0);\n+\t\t    if (mpz_cmp_si (op2->value.integer, 0) < 0)\n+\t\t      rc = ARITH_DIV0;\n+\t\t  }\n+\t\telse if (mpz_cmp_si (op1->value.integer, -1) == 0)\n+\t\t  {\n+\t\t    /* (-1)**op2 == (-1)**(mod(op2,2)) */\n+\t\t    unsigned int odd = mpz_fdiv_ui (op2->value.integer, 2);\n+\t\t    if (odd)\n+\t\t      mpz_set_si (result->value.integer, -1);\n+\t\t    else\n+\t\t      mpz_set_si (result->value.integer, 1);\n+\t\t  }\n+\t\t/* Then, we take care of op2 < 0.  */\n+\t\telse if (mpz_cmp_si (op2->value.integer, 0) < 0)\n+\t\t  {\n+\t\t    /* if op2 < 0, op1**op2 == 0  because abs(op1) > 1.  */\n+\t\t    mpz_set_si (result->value.integer, 0);\n+\t\t  }\n+\t\telse if (gfc_extract_int (op2, &power) != NULL)\n+\t\t  {\n+\t\t    /* If op2 doesn't fit in an int, the exponentiation will\n+\t\t       overflow, because op2 > 0 and abs(op1) > 1.  */\n+\t\t    mpz_t max;\n+\t\t    int i;\n+\t\t    i = gfc_validate_kind (BT_INTEGER, result->ts.kind, false);\n+\n+\t\t    if (gfc_option.flag_range_check)\n+\t\t      rc = ARITH_OVERFLOW;\n+\n+\t\t    /* Still, we want to give the same value as the\n+\t\t       processor.  */\n+\t\t    mpz_init (max);\n+\t\t    mpz_add_ui (max, gfc_integer_kinds[i].huge, 1);\n+\t\t    mpz_mul_ui (max, max, 2);\n+\t\t    mpz_powm (result->value.integer, op1->value.integer,\n+\t\t\t      op2->value.integer, max);\n+\t\t    mpz_clear (max);\n+\t\t  }\n \t\telse\n-\t\t  mpz_set_si (result->value.integer, 1);\n-\t      }\n-\t    /* Then, we take care of op2 < 0.  */\n-\t    else if (mpz_cmp_si (op2->value.integer, 0) < 0)\n-\t      {\n-\t\t/* if op2 < 0, op1**op2 == 0  because abs(op1) > 1.  */\n-\t\tmpz_set_si (result->value.integer, 0);\n+\t\t  mpz_pow_ui (result->value.integer, op1->value.integer,\n+\t\t\t      power);\n \t      }\n-\t    else if (gfc_extract_int (op2, &power) != NULL)\n+\t      break;\n+\n+\t    case BT_REAL:\n+\t      mpfr_pow_z (result->value.real, op1->value.real,\n+\t\t\t  op2->value.integer, GFC_RND_MODE);\n+\t      break;\n+\n+\t    case BT_COMPLEX:\n \t      {\n-\t\t/* If op2 doesn't fit in an int, the exponentiation will\n-\t\t   overflow, because op2 > 0 and abs(op1) > 1.  */\n-\t\tmpz_t max;\n-\t\tint i = gfc_validate_kind (BT_INTEGER, result->ts.kind, false);\n-\n-\t\tif (gfc_option.flag_range_check)\n-\t\t  rc = ARITH_OVERFLOW;\n-\n-\t\t/* Still, we want to give the same value as the processor.  */\n-\t\tmpz_init (max);\n-\t\tmpz_add_ui (max, gfc_integer_kinds[i].huge, 1);\n-\t\tmpz_mul_ui (max, max, 2);\n-\t\tmpz_powm (result->value.integer, op1->value.integer,\n-\t\t\t  op2->value.integer, max);\n-\t\tmpz_clear (max);\n+\t\tmpz_t apower;\n+\n+\t\t/* Compute op1**abs(op2)  */\n+\t\tmpz_init (apower);\n+\t\tmpz_abs (apower, op2->value.integer);\n+\t\tcomplex_pow (result, op1, apower);\n+\t\tmpz_clear (apower);\n+\n+\t\t/* If (op2 < 0), compute the inverse.  */\n+\t\tif (power_sign < 0)\n+\t\t  complex_reciprocal (result);\n \t      }\n-\t    else\n-\t      mpz_pow_ui (result->value.integer, op1->value.integer, power);\n-\t  }\n-\t  break;\n+\t      break;\n \n-\tcase BT_REAL:\n-\t  mpfr_pow_z (result->value.real, op1->value.real, op2->value.integer,\n-\t\t      GFC_RND_MODE);\n-\t  break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      break;\n+\n+    case BT_REAL:\n+\n+      if (init_flag)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \"\n+\t\t\t      \"exponent in an initialization \"\n+\t\t\t      \"expression at %L\", &op2->where) == FAILURE)\n+\t    return ARITH_PROHIBIT;\n+\t}\n \n-\tcase BT_COMPLEX:\n+      if (mpfr_cmp_si (op1->value.real, 0) < 0)\n+\t{\n+\t  gfc_error (\"Raising a negative REAL at %L to \"\n+\t\t     \"a REAL power is prohibited\", &op1->where);\n+\t  gfc_free (result);\n+\t  return ARITH_PROHIBIT;\n+\t}\n+\n+\tmpfr_pow (result->value.real, op1->value.real, op2->value.real,\n+\t\t  GFC_RND_MODE);\n+      break;\n+\n+    case BT_COMPLEX:\n+      {\n+\tmpfr_t x, y, r, t;\n+\n+\tif (init_flag)\n \t  {\n-\t    mpz_t apower;\n+\t    if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \"\n+\t\t\t\t\"exponent in an initialization \"\n+\t\t\t\t\"expression at %L\", &op2->where) == FAILURE)\n+\t      return ARITH_PROHIBIT;\n+\t  }\n \n-\t    /* Compute op1**abs(op2)  */\n-\t    mpz_init (apower);\n-\t    mpz_abs (apower, op2->value.integer);\n-\t    complex_pow (result, op1, apower);\n-\t    mpz_clear (apower);\n+\tgfc_set_model (op1->value.complex.r);\n \n-\t    /* If (op2 < 0), compute the inverse.  */\n-\t    if (power_sign < 0)\n-\t      complex_reciprocal (result);\n+\tmpfr_init (r);\n \n+\tmpfr_hypot (r, op1->value.complex.r, op1->value.complex.i,\n+\t\t    GFC_RND_MODE);\n+\tif (mpfr_cmp_si (r, 0) == 0)\n+\t  {\n+\t    mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n+\t    mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n+\t    mpfr_clear (r);\n \t    break;\n \t  }\n-\n-\tdefault:\n-\t  break;\n-\t}\n+\tmpfr_log (r, r, GFC_RND_MODE);\n+\n+\tmpfr_init (t);\n+\n+\tmpfr_atan2 (t, op1->value.complex.i, op1->value.complex.r, \n+\t\t    GFC_RND_MODE);\n+\n+\tmpfr_init (x);\n+\tmpfr_init (y);\n+\n+\tmpfr_mul (x, op2->value.complex.r, r, GFC_RND_MODE);\n+\tmpfr_mul (y, op2->value.complex.i, t, GFC_RND_MODE);\n+\tmpfr_sub (x, x, y, GFC_RND_MODE);\n+\tmpfr_exp (x, x, GFC_RND_MODE);\n+\n+\tmpfr_mul (y, op2->value.complex.r, t, GFC_RND_MODE);\n+\tmpfr_mul (t, op2->value.complex.i, r, GFC_RND_MODE);\n+\tmpfr_add (y, y, t, GFC_RND_MODE);\n+\tmpfr_cos (t, y, GFC_RND_MODE);\n+\tmpfr_sin (y, y, GFC_RND_MODE);\n+\tmpfr_mul (result->value.complex.r, x, t, GFC_RND_MODE);\n+\tmpfr_mul (result->value.complex.i, x, y, GFC_RND_MODE);\n+\tmpfr_clears (r, t, x, y, NULL);\n+      }\n+      break;\n+    default:\n+      gfc_internal_error (\"arith_power(): unknown type\");\n     }\n \n   if (rc == ARITH_OK)\n@@ -1695,10 +1777,6 @@ eval_intrinsic (gfc_intrinsic_op op,\n       gfc_internal_error (\"eval_intrinsic(): Bad operator\");\n     }\n \n-  /* Try to combine the operators.  */\n-  if (op == INTRINSIC_POWER && op2->ts.type != BT_INTEGER)\n-    goto runtime;\n-\n   if (op1->expr_type != EXPR_CONSTANT\n       && (op1->expr_type != EXPR_ARRAY\n \t  || !gfc_is_constant_expr (op1) || !gfc_expanded_ac (op1)))\n@@ -1715,8 +1793,13 @@ eval_intrinsic (gfc_intrinsic_op op,\n   else\n     rc = reduce_binary (eval.f3, op1, op2, &result);\n \n+\n+  /* Something went wrong.  */\n+  if (op == INTRINSIC_POWER && rc == ARITH_PROHIBIT)\n+    return NULL;\n+\n   if (rc != ARITH_OK)\n-    { /* Something went wrong.  */\n+    {\n       gfc_error (gfc_arith_error (rc), &op1->where);\n       return NULL;\n     }\n@@ -1908,7 +1991,7 @@ gfc_divide (gfc_expr *op1, gfc_expr *op2)\n gfc_expr *\n gfc_power (gfc_expr *op1, gfc_expr *op2)\n {\n-  return eval_intrinsic_f3 (INTRINSIC_POWER, gfc_arith_power, op1, op2);\n+  return eval_intrinsic_f3 (INTRINSIC_POWER, arith_power, op1, op2);\n }\n \n "}, {"sha": "8dec53f3244c2d2e1d4e116d5ae979f932c6e77e", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=6bb6267173b422eb05776c3212925e57aab008e5", "patch": "@@ -1938,16 +1938,6 @@ check_intrinsic_op (gfc_expr *e, gfc_try (*check_function) (gfc_expr *))\n       if (!numeric_type (et0 (op1)) || !numeric_type (et0 (op2)))\n \tgoto not_numeric;\n \n-      if (e->value.op.op == INTRINSIC_POWER\n-\t  && check_function == check_init_expr && et0 (op2) != BT_INTEGER)\n-\t{\n-\t  if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \"\n-\t\t\t      \"exponent in an initialization \"\n-\t\t\t      \"expression at %L\", &op2->where)\n-\t      == FAILURE)\n-\t    return FAILURE;\n-\t}\n-\n       break;\n \n     case INTRINSIC_CONCAT:\n@@ -2424,7 +2414,11 @@ gfc_reduce_init_expr (gfc_expr *expr)\n \n \n /* Match an initialization expression.  We work by first matching an\n-   expression, then reducing it to a constant.  */\n+   expression, then reducing it to a constant.  The reducing it to \n+   constant part requires a global variable to flag the prohibition\n+   of a non-integer exponent in -std=f95 mode.  */\n+\n+bool init_flag = false;\n \n match\n gfc_match_init_expr (gfc_expr **result)\n@@ -2435,18 +2429,25 @@ gfc_match_init_expr (gfc_expr **result)\n \n   expr = NULL;\n \n+  init_flag = true;\n+\n   m = gfc_match_expr (&expr);\n   if (m != MATCH_YES)\n-    return m;\n+    {\n+      init_flag = false;\n+      return m;\n+    }\n \n   t = gfc_reduce_init_expr (expr);\n   if (t != SUCCESS)\n     {\n       gfc_free_expr (expr);\n+      init_flag = false;\n       return MATCH_ERROR;\n     }\n \n   *result = expr;\n+  init_flag = false;\n \n   return MATCH_YES;\n }"}, {"sha": "3a7f98a87925b973502bd7fa3c76fcc1ef1c0410", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6bb6267173b422eb05776c3212925e57aab008e5", "patch": "@@ -199,7 +199,7 @@ gfc_intrinsic_op;\n /* Arithmetic results.  */\n typedef enum\n { ARITH_OK = 1, ARITH_OVERFLOW, ARITH_UNDERFLOW, ARITH_NAN,\n-  ARITH_DIV0, ARITH_INCOMMENSURATE, ARITH_ASYMMETRIC\n+  ARITH_DIV0, ARITH_INCOMMENSURATE, ARITH_ASYMMETRIC, ARITH_PROHIBIT\n }\n arith;\n "}, {"sha": "6061a23893b2106f9377dbb9870f33d382e8ddf8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6bb6267173b422eb05776c3212925e57aab008e5", "patch": "@@ -1,3 +1,8 @@\n+2009-03-29  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/38823\n+\t* gfortran.dg/power1.f90: New test.\n+\n 2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/456"}, {"sha": "50dbac2756dcc5e40155bff105eb54ee04eb83cb", "filename": "gcc/testsuite/gfortran.dg/power1.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpower1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bb6267173b422eb05776c3212925e57aab008e5/gcc%2Ftestsuite%2Fgfortran.dg%2Fpower1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpower1.f90?ref=6bb6267173b422eb05776c3212925e57aab008e5", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+! Test fix for PR fortran/38823.\n+program power\n+\n+   implicit none\n+\n+   integer, parameter :: &\n+   &  s = kind(1.e0), &\n+   &  d = kind(1.d0), &\n+   &  e = max(selected_real_kind(precision(1.d0)+1), d)\n+\n+  real(s),    parameter :: ris = 2.e0_s**2\n+  real(d),    parameter :: rid = 2.e0_d**2\n+  real(e),    parameter :: rie = 2.e0_e**2 \n+  complex(s), parameter :: cis = (2.e0_s,1.e0_s)**2\n+  complex(d), parameter :: cid = (2.e0_d,1.e0_d)**2\n+  complex(e), parameter :: cie = (2.e0_e,1.e0_e)**2\n+\n+  real(s),    parameter :: rrs = 2.e0_s**2.e0\n+  real(d),    parameter :: rrd = 2.e0_d**2.e0\n+  real(e),    parameter :: rre = 2.e0_e**2.e0\n+  complex(s), parameter :: crs = (2.e0_s,1.e0_s)**2.e0\n+  complex(d), parameter :: crd = (2.e0_d,1.e0_d)**2.e0\n+  complex(e), parameter :: cre = (2.e0_e,1.e0_e)**2.e0\n+\n+  real(s),    parameter :: rds = 2.e0_s**2.e0_d\n+  real(d),    parameter :: rdd = 2.e0_d**2.e0_d\n+  real(e),    parameter :: rde = 2.e0_e**2.e0_d\n+  complex(s), parameter :: cds = (2.e0_s,1.e0_s)**2.e0_d\n+  complex(d), parameter :: cdd = (2.e0_d,1.e0_d)**2.e0_d\n+  complex(e), parameter :: cde = (2.e0_e,1.e0_e)**2.e0_d\n+\n+  real(s), parameter :: eps_s = 1.e-5_s\n+  real(d), parameter :: eps_d = 1.e-10_d\n+  real(e), parameter :: eps_e = 1.e-10_e\n+\n+  if (abs(ris - 4) > eps_s) call abort\n+  if (abs(rid - 4) > eps_d) call abort\n+  if (abs(rie - 4) > eps_e) call abort\n+  if (abs(real(cis, s) - 3) > eps_s .or. abs(aimag(cis) - 4) > eps_s) call abort\n+  if (abs(real(cid, d) - 3) > eps_d .or. abs(aimag(cid) - 4) > eps_d) call abort\n+  if (abs(real(cie, e) - 3) > eps_e .or. abs(aimag(cie) - 4) > eps_e) call abort\n+\n+  if (abs(rrs - 4) > eps_s) call abort\n+  if (abs(rrd - 4) > eps_d) call abort\n+  if (abs(rre - 4) > eps_e) call abort\n+  if (abs(real(crs, s) - 3) > eps_s .or. abs(aimag(crs) - 4) > eps_s) call abort\n+  if (abs(real(crd, d) - 3) > eps_d .or. abs(aimag(crd) - 4) > eps_d) call abort\n+  if (abs(real(cre, e) - 3) > eps_e .or. abs(aimag(cre) - 4) > eps_e) call abort\n+\n+  if (abs(rds - 4) > eps_s) call abort\n+  if (abs(rdd - 4) > eps_d) call abort\n+  if (abs(rde - 4) > eps_e) call abort\n+  if (abs(real(cds, s) - 3) > eps_s .or. abs(aimag(cds) - 4) > eps_s) call abort\n+  if (abs(real(cdd, d) - 3) > eps_d .or. abs(aimag(cdd) - 4) > eps_d) call abort\n+  if (abs(real(cde, e) - 3) > eps_e .or. abs(aimag(cde) - 4) > eps_e) call abort\n+\n+end program power"}]}