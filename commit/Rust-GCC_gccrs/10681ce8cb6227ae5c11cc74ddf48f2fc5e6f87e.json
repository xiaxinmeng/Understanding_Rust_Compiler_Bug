{"sha": "10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2ODFjZThjYjYyMjdhZTVjMTFjYzc0ZGRmNDhmMmZjNWU2Zjg3ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:22:09Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:22:09Z"}, "message": "[13/46] Make STMT_VINFO_RELATED_STMT a stmt_vec_info\n\nThis patch changes STMT_VINFO_RELATED_STMT from a gimple stmt to a\nstmt_vec_info.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_stmt_vec_info::related_stmt): Change from\n\ta gimple stmt to a stmt_vec_info.\n\t(is_pattern_stmt_p): Update accordingly.\n\t* tree-vect-data-refs.c (vect_preserves_scalar_order_p): Likewise.\n\t(vect_record_grouped_load_vectors): Likewise.\n\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Likewise.\n\t(vect_fixup_reduc_chain, vect_update_vf_for_slp): Likewise.\n\t(vect_model_reduction_cost): Likewise.\n\t(vect_create_epilog_for_reduction): Likewise.\n\t(vectorizable_reduction, vectorizable_induction): Likewise.\n\t* tree-vect-patterns.c (vect_init_pattern_stmt): Likewise.\n\tReturn the stmt_vec_info for the pattern statement.\n\t(vect_set_pattern_stmt): Update use of STMT_VINFO_RELATED_STMT.\n\t(vect_split_statement, vect_mark_pattern_stmts): Likewise.\n\t* tree-vect-slp.c (vect_detect_hybrid_slp_stmts): Likewise.\n\t(vect_detect_hybrid_slp, vect_get_slp_defs): Likewise.\n\t* tree-vect-stmts.c (vect_mark_relevant): Likewise.\n\t(vect_get_vec_def_for_operand_1, vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call, vect_analyze_stmt, new_stmt_vec_info)\n\t(free_stmt_vec_info, vect_is_simple_use): Likewise.\n\nFrom-SVN: r263128", "tree": {"sha": "35855509f186bc71e3434bad3b0a5ae381027fc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35855509f186bc71e3434bad3b0a5ae381027fc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1bd72966309ac459a55e2bc64ad355272d402f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1bd72966309ac459a55e2bc64ad355272d402f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1bd72966309ac459a55e2bc64ad355272d402f5"}], "stats": {"total": 253, "additions": 128, "deletions": 125}, "files": [{"sha": "cd6f8212a66fe02a04b46d6c2a9763862bfa9082", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -1,3 +1,26 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::related_stmt): Change from\n+\ta gimple stmt to a stmt_vec_info.\n+\t(is_pattern_stmt_p): Update accordingly.\n+\t* tree-vect-data-refs.c (vect_preserves_scalar_order_p): Likewise.\n+\t(vect_record_grouped_load_vectors): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vf_for_stmt): Likewise.\n+\t(vect_fixup_reduc_chain, vect_update_vf_for_slp): Likewise.\n+\t(vect_model_reduction_cost): Likewise.\n+\t(vect_create_epilog_for_reduction): Likewise.\n+\t(vectorizable_reduction, vectorizable_induction): Likewise.\n+\t* tree-vect-patterns.c (vect_init_pattern_stmt): Likewise.\n+\tReturn the stmt_vec_info for the pattern statement.\n+\t(vect_set_pattern_stmt): Update use of STMT_VINFO_RELATED_STMT.\n+\t(vect_split_statement, vect_mark_pattern_stmts): Likewise.\n+\t* tree-vect-slp.c (vect_detect_hybrid_slp_stmts): Likewise.\n+\t(vect_detect_hybrid_slp, vect_get_slp_defs): Likewise.\n+\t* tree-vect-stmts.c (vect_mark_relevant): Likewise.\n+\t(vect_get_vec_def_for_operand_1, vectorizable_call): Likewise.\n+\t(vectorizable_simd_clone_call, vect_analyze_stmt, new_stmt_vec_info)\n+\t(free_stmt_vec_info, vect_is_simple_use): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_finish_replace_stmt): Return a stmt_vec_info"}, {"sha": "70dd4667b1dcae5befd5b5ebc3c1b07597493d71", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -213,10 +213,10 @@ vect_preserves_scalar_order_p (gimple *stmt_a, gimple *stmt_b)\n      current position (but could happen earlier).  Reordering is therefore\n      only possible if the first access is a write.  */\n   if (is_pattern_stmt_p (stmtinfo_a))\n-    stmt_a = STMT_VINFO_RELATED_STMT (stmtinfo_a);\n+    stmtinfo_a = STMT_VINFO_RELATED_STMT (stmtinfo_a);\n   if (is_pattern_stmt_p (stmtinfo_b))\n-    stmt_b = STMT_VINFO_RELATED_STMT (stmtinfo_b);\n-  gimple *earlier_stmt = get_earlier_stmt (stmt_a, stmt_b);\n+    stmtinfo_b = STMT_VINFO_RELATED_STMT (stmtinfo_b);\n+  gimple *earlier_stmt = get_earlier_stmt (stmtinfo_a, stmtinfo_b);\n   return !DR_IS_WRITE (STMT_VINFO_DATA_REF (vinfo_for_stmt (earlier_stmt)));\n }\n \n@@ -6359,8 +6359,10 @@ vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n void\n vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n {\n-  gimple *first_stmt = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n-  gimple *next_stmt, *new_stmt;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n+  gimple *first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+  gimple *next_stmt;\n   unsigned int i, gap_count;\n   tree tmp_data_ref;\n \n@@ -6389,29 +6391,28 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n \n       while (next_stmt)\n         {\n-\t  new_stmt = SSA_NAME_DEF_STMT (tmp_data_ref);\n+\t  stmt_vec_info new_stmt_info = vinfo->lookup_def (tmp_data_ref);\n \t  /* We assume that if VEC_STMT is not NULL, this is a case of multiple\n \t     copies, and we put the new vector statement in the first available\n \t     RELATED_STMT.  */\n \t  if (!STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)))\n-\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)) = new_stmt;\n+\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)) = new_stmt_info;\n \t  else\n             {\n               if (!DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n                 {\n \t\t  gimple *prev_stmt =\n \t\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n-\t\t  gimple *rel_stmt =\n-\t\t    STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt));\n-\t          while (rel_stmt)\n+\t\t  stmt_vec_info rel_stmt_info\n+\t\t    = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt));\n+\t\t  while (rel_stmt_info)\n \t\t    {\n-\t\t      prev_stmt = rel_stmt;\n-\t\t      rel_stmt =\n-                        STMT_VINFO_RELATED_STMT (vinfo_for_stmt (rel_stmt));\n+\t\t      prev_stmt = rel_stmt_info;\n+\t\t      rel_stmt_info = STMT_VINFO_RELATED_STMT (rel_stmt_info);\n \t\t    }\n \n-  \t          STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt)) =\n-                    new_stmt;\n+\t\t  STMT_VINFO_RELATED_STMT (vinfo_for_stmt (prev_stmt))\n+\t\t    = new_stmt_info;\n                 }\n             }\n "}, {"sha": "bf9e205b2dcd15356333953de5395a1e0a26b210", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 44, "deletions": 52, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -226,7 +226,7 @@ vect_determine_vf_for_stmt (stmt_vec_info stmt_info, poly_uint64 *vf,\n       && STMT_VINFO_RELATED_STMT (stmt_info))\n     {\n       gimple *pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n-      stmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n \n       /* If a pattern statement has def stmts, analyze them too.  */\n       for (gimple_stmt_iterator si = gsi_start (pattern_def_seq);\n@@ -654,23 +654,23 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n static void\n vect_fixup_reduc_chain (gimple *stmt)\n {\n-  gimple *firstp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n-  gimple *stmtp;\n-  gcc_assert (!REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (firstp))\n-\t      && REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n-  REDUC_GROUP_SIZE (vinfo_for_stmt (firstp))\n-    = REDUC_GROUP_SIZE (vinfo_for_stmt (stmt));\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  stmt_vec_info firstp = STMT_VINFO_RELATED_STMT (stmt_info);\n+  stmt_vec_info stmtp;\n+  gcc_assert (!REDUC_GROUP_FIRST_ELEMENT (firstp)\n+\t      && REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n+  REDUC_GROUP_SIZE (firstp) = REDUC_GROUP_SIZE (stmt_info);\n   do\n     {\n       stmtp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n-      REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmtp)) = firstp;\n+      REDUC_GROUP_FIRST_ELEMENT (stmtp) = firstp;\n       stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n       if (stmt)\n-\tREDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmtp))\n+\tREDUC_GROUP_NEXT_ELEMENT (stmtp)\n \t  = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n     }\n   while (stmt);\n-  STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmtp)) = vect_reduction_def;\n+  STMT_VINFO_DEF_TYPE (stmtp) = vect_reduction_def;\n }\n \n /* Fixup scalar cycles that now have their stmts detected as patterns.  */\n@@ -1436,14 +1436,10 @@ vect_update_vf_for_slp (loop_vec_info loop_vinfo)\n       for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);\n \t   gsi_next (&si))\n \t{\n-\t  gimple *stmt = gsi_stmt (si);\n \t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (gsi_stmt (si));\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n \t      && STMT_VINFO_RELATED_STMT (stmt_info))\n-\t    {\n-\t      stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-\t      stmt_info = vinfo_for_stmt (stmt);\n-\t    }\n+\t    stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n \t  if ((STMT_VINFO_RELEVANT_P (stmt_info)\n \t       || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (stmt_info)))\n \t      && !PURE_SLP_STMT (stmt_info))\n@@ -2247,7 +2243,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n \t    {\n \t      gimple *pattern_def_seq = STMT_VINFO_PATTERN_DEF_SEQ (stmt_info);\n-\t      stmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+\t      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n \t      STMT_SLP_TYPE (stmt_info) = loop_vect;\n \t      for (gimple_stmt_iterator pi = gsi_start (pattern_def_seq);\n \t\t   !gsi_end_p (pi); gsi_next (&pi))\n@@ -3836,7 +3832,6 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n   enum tree_code code;\n   optab optab;\n   tree vectype;\n-  gimple *orig_stmt;\n   machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n@@ -3852,12 +3847,12 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n   mode = TYPE_MODE (vectype);\n-  orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  stmt_vec_info orig_stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n \n-  if (!orig_stmt)\n-    orig_stmt = STMT_VINFO_STMT (stmt_info);\n+  if (!orig_stmt_info)\n+    orig_stmt_info = stmt_info;\n \n-  code = gimple_assign_rhs_code (orig_stmt);\n+  code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n \n   if (reduction_type == EXTRACT_LAST_REDUCTION\n       || reduction_type == FOLD_LEFT_REDUCTION)\n@@ -3902,7 +3897,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n      We have a reduction operator that will reduce the vector in one statement.\n      Also requires scalar extract.  */\n \n-  if (!loop || !nested_in_vect_loop_p (loop, orig_stmt))\n+  if (!loop || !nested_in_vect_loop_p (loop, orig_stmt_info))\n     {\n       if (reduc_fn != IFN_LAST)\n \t{\n@@ -3953,7 +3948,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t{\n \t  int vec_size_in_bits = tree_to_uhwi (TYPE_SIZE (vectype));\n \t  tree bitsize =\n-\t    TYPE_SIZE (TREE_TYPE (gimple_assign_lhs (orig_stmt)));\n+\t    TYPE_SIZE (TREE_TYPE (gimple_assign_lhs (orig_stmt_info->stmt)));\n \t  int element_bitsize = tree_to_uhwi (bitsize);\n \t  int nelements = vec_size_in_bits / element_bitsize;\n \n@@ -4447,7 +4442,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n-  gimple *use_stmt, *orig_stmt, *reduction_phi = NULL;\n+  gimple *use_stmt, *reduction_phi = NULL;\n   bool nested_in_vect_loop = false;\n   auto_vec<gimple *> new_phis;\n   auto_vec<gimple *> inner_phis;\n@@ -4726,7 +4721,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n           else\n \t    {\n \t      def = vect_get_vec_def_for_stmt_copy (dt, def);\n-\t      STMT_VINFO_RELATED_STMT (prev_phi_info) = phi;\n+\t      STMT_VINFO_RELATED_STMT (prev_phi_info) = phi_info;\n \t    }\n \n           SET_PHI_ARG_DEF (phi, single_exit (loop)->dest_idx, def);\n@@ -4758,7 +4753,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      SET_PHI_ARG_DEF (outer_phi, single_exit (loop)->dest_idx,\n \t\t\t       PHI_RESULT (phi));\n \t      stmt_vec_info outer_phi_info = loop_vinfo->add_stmt (outer_phi);\n-\t      STMT_VINFO_RELATED_STMT (prev_phi_info) = outer_phi;\n+\t      STMT_VINFO_RELATED_STMT (prev_phi_info) = outer_phi_info;\n \t      prev_phi_info = outer_phi_info;\n \t    }\n \t}\n@@ -4775,27 +4770,26 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n          Otherwise (it is a regular reduction) - the tree-code and scalar-def\n          are taken from STMT.  */\n \n-  orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-  if (!orig_stmt)\n+  stmt_vec_info orig_stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n+  if (!orig_stmt_info)\n     {\n       /* Regular reduction  */\n-      orig_stmt = stmt;\n+      orig_stmt_info = stmt_info;\n     }\n   else\n     {\n       /* Reduction pattern  */\n-      stmt_vec_info stmt_vinfo = vinfo_for_stmt (orig_stmt);\n-      gcc_assert (STMT_VINFO_IN_PATTERN_P (stmt_vinfo));\n-      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_vinfo) == stmt);\n+      gcc_assert (STMT_VINFO_IN_PATTERN_P (orig_stmt_info));\n+      gcc_assert (STMT_VINFO_RELATED_STMT (orig_stmt_info) == stmt_info);\n     }\n \n-  code = gimple_assign_rhs_code (orig_stmt);\n+  code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n   /* For MINUS_EXPR the initial vector is [init_val,0,...,0], therefore,\n      partial results are added and not subtracted.  */\n   if (code == MINUS_EXPR) \n     code = PLUS_EXPR;\n   \n-  scalar_dest = gimple_assign_lhs (orig_stmt);\n+  scalar_dest = gimple_assign_lhs (orig_stmt_info->stmt);\n   scalar_type = TREE_TYPE (scalar_dest);\n   scalar_results.create (group_size); \n   new_scalar_dest = vect_create_destination_var (scalar_dest, NULL);\n@@ -5613,10 +5607,11 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n         {\n \t  gimple *current_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[k];\n \n-          orig_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (current_stmt));\n-          /* SLP statements can't participate in patterns.  */\n-          gcc_assert (!orig_stmt);\n-          scalar_dest = gimple_assign_lhs (current_stmt);\n+\t  orig_stmt_info\n+\t    = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (current_stmt));\n+\t  /* SLP statements can't participate in patterns.  */\n+\t  gcc_assert (!orig_stmt_info);\n+\t  scalar_dest = gimple_assign_lhs (current_stmt);\n         }\n \n       phis.create (3);\n@@ -6097,8 +6092,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   enum tree_code cond_reduc_op_code = ERROR_MARK;\n   tree scalar_type;\n   bool is_simple_use;\n-  gimple *orig_stmt;\n-  stmt_vec_info orig_stmt_info = NULL;\n   int i;\n   int ncopies;\n   int epilog_copies;\n@@ -6229,7 +6222,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t      if (j == 0)\n \t\t\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_phi;\n \t\t      else\n-\t\t\tSTMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi;\n+\t\t\tSTMT_VINFO_RELATED_STMT (prev_phi_info) = new_phi_info;\n \t\t      prev_phi_info = new_phi_info;\n \t\t    }\n \t\t}\n@@ -6259,10 +6252,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n      the STMT_VINFO_RELATED_STMT field records the last stmt in\n      the original sequence that constitutes the pattern.  */\n \n-  orig_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n-  if (orig_stmt)\n+  stmt_vec_info orig_stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n+  if (orig_stmt_info)\n     {\n-      orig_stmt_info = vinfo_for_stmt (orig_stmt);\n       gcc_assert (STMT_VINFO_IN_PATTERN_P (orig_stmt_info));\n       gcc_assert (!STMT_VINFO_IN_PATTERN_P (stmt_info));\n     }\n@@ -6393,7 +6385,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  return false;\n \t}\n \n-      if (orig_stmt)\n+      if (orig_stmt_info)\n \treduc_def_stmt = STMT_VINFO_REDUC_DEF (orig_stmt_info);\n       else\n \treduc_def_stmt = STMT_VINFO_REDUC_DEF (stmt_info);\n@@ -6414,7 +6406,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* For pattern recognized stmts, orig_stmt might be a reduction,\n \t but some helper statements for the pattern might not, or\n \t might be COND_EXPRs with reduction uses in the condition.  */\n-      gcc_assert (orig_stmt);\n+      gcc_assert (orig_stmt_info);\n       return false;\n     }\n \n@@ -6548,10 +6540,10 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  if (orig_stmt)\n-    gcc_assert (tmp == orig_stmt\n+  if (orig_stmt_info)\n+    gcc_assert (tmp == orig_stmt_info\n \t\t|| (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp))\n-\t\t    == orig_stmt));\n+\t\t    == orig_stmt_info));\n   else\n     /* We changed STMT to be the first stmt in reduction chain, hence we\n        check that in this case the first element in the chain is STMT.  */\n@@ -6673,13 +6665,13 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   vect_reduction_type reduction_type\n     = STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info);\n-  if (orig_stmt\n+  if (orig_stmt_info\n       && (reduction_type == TREE_CODE_REDUCTION\n \t  || reduction_type == FOLD_LEFT_REDUCTION))\n     {\n       /* This is a reduction pattern: get the vectype from the type of the\n          reduction variable, and get the tree-code from orig_stmt.  */\n-      orig_code = gimple_assign_rhs_code (orig_stmt);\n+      orig_code = gimple_assign_rhs_code (orig_stmt_info->stmt);\n       gcc_assert (vectype_out);\n       vec_mode = TYPE_MODE (vectype_out);\n     }\n@@ -7757,7 +7749,7 @@ vectorizable_induction (gimple *phi,\n  \n \t  gsi_insert_before (&si, new_stmt, GSI_SAME_STMT);\n \t  new_stmt_info = loop_vinfo->add_stmt (new_stmt);\n-\t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt;\n+\t  STMT_VINFO_RELATED_STMT (prev_stmt_vinfo) = new_stmt_info;\n \t  prev_stmt_vinfo = new_stmt_info;\n \t}\n     }"}, {"sha": "6fce980e6010a42b494db8c9d460369a82abd86d", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -94,10 +94,11 @@ vect_pattern_detected (const char *name, gimple *stmt)\n     }\n }\n \n-/* Associate pattern statement PATTERN_STMT with ORIG_STMT_INFO.\n-   Set its vector type to VECTYPE if it doesn't have one already.  */\n+/* Associate pattern statement PATTERN_STMT with ORIG_STMT_INFO and\n+   return the pattern statement's stmt_vec_info.  Set its vector type to\n+   VECTYPE if it doesn't have one already.  */\n \n-static void\n+static stmt_vec_info\n vect_init_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n \t\t\ttree vectype)\n {\n@@ -107,11 +108,12 @@ vect_init_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n     pattern_stmt_info = orig_stmt_info->vinfo->add_stmt (pattern_stmt);\n   gimple_set_bb (pattern_stmt, gimple_bb (orig_stmt_info->stmt));\n \n-  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = orig_stmt_info->stmt;\n+  STMT_VINFO_RELATED_STMT (pattern_stmt_info) = orig_stmt_info;\n   STMT_VINFO_DEF_TYPE (pattern_stmt_info)\n     = STMT_VINFO_DEF_TYPE (orig_stmt_info);\n   if (!STMT_VINFO_VECTYPE (pattern_stmt_info))\n     STMT_VINFO_VECTYPE (pattern_stmt_info) = vectype;\n+  return pattern_stmt_info;\n }\n \n /* Set the pattern statement of ORIG_STMT_INFO to PATTERN_STMT.\n@@ -123,8 +125,8 @@ vect_set_pattern_stmt (gimple *pattern_stmt, stmt_vec_info orig_stmt_info,\n \t\t       tree vectype)\n {\n   STMT_VINFO_IN_PATTERN_P (orig_stmt_info) = true;\n-  STMT_VINFO_RELATED_STMT (orig_stmt_info) = pattern_stmt;\n-  vect_init_pattern_stmt (pattern_stmt, orig_stmt_info, vectype);\n+  STMT_VINFO_RELATED_STMT (orig_stmt_info)\n+    = vect_init_pattern_stmt (pattern_stmt, orig_stmt_info, vectype);\n }\n \n /* Add NEW_STMT to STMT_INFO's pattern definition statements.  If VECTYPE\n@@ -634,8 +636,7 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n     {\n       /* STMT2_INFO is part of a pattern.  Get the statement to which\n \t the pattern is attached.  */\n-      stmt_vec_info orig_stmt2_info\n-\t= vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt2_info));\n+      stmt_vec_info orig_stmt2_info = STMT_VINFO_RELATED_STMT (stmt2_info);\n       vect_init_pattern_stmt (stmt1, orig_stmt2_info, vectype);\n \n       if (dump_enabled_p ())\n@@ -659,7 +660,7 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n \t}\n \n       gimple_seq *def_seq = &STMT_VINFO_PATTERN_DEF_SEQ (orig_stmt2_info);\n-      if (STMT_VINFO_RELATED_STMT (orig_stmt2_info) == stmt2_info->stmt)\n+      if (STMT_VINFO_RELATED_STMT (orig_stmt2_info) == stmt2_info)\n \t/* STMT2_INFO is the actual pattern statement.  Add STMT1\n \t   to the end of the definition sequence.  */\n \tgimple_seq_add_stmt_without_update (def_seq, stmt1);\n@@ -4754,8 +4755,7 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n \t}\n \n       /* Switch to the statement that ORIG replaces.  */\n-      orig_stmt_info\n-\t= vinfo_for_stmt (STMT_VINFO_RELATED_STMT (orig_stmt_info));\n+      orig_stmt_info = STMT_VINFO_RELATED_STMT (orig_stmt_info);\n \n       /* We shouldn't be replacing the main pattern statement.  */\n       gcc_assert (STMT_VINFO_RELATED_STMT (orig_stmt_info) != orig_stmt);"}, {"sha": "c7af18b9b9a0cfcd65b15c9fb8f2db29e5f8d319", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -2327,7 +2327,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n          original stmt for immediate uses.  */\n       if (! STMT_VINFO_IN_PATTERN_P (stmt_vinfo)\n \t  && STMT_VINFO_RELATED_STMT (stmt_vinfo))\n-\tstmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+\tstmt = STMT_VINFO_RELATED_STMT (stmt_vinfo)->stmt;\n       tree def;\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \tdef = gimple_phi_result (stmt);\n@@ -2341,7 +2341,7 @@ vect_detect_hybrid_slp_stmts (slp_tree node, unsigned i, slp_vect_type stype)\n \t      continue;\n \t    if (STMT_VINFO_IN_PATTERN_P (use_vinfo)\n \t\t&& STMT_VINFO_RELATED_STMT (use_vinfo))\n-\t      use_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (use_vinfo));\n+\t      use_vinfo = STMT_VINFO_RELATED_STMT (use_vinfo);\n \t    if (!STMT_SLP_TYPE (use_vinfo)\n \t\t&& (STMT_VINFO_RELEVANT (use_vinfo)\n \t\t    || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo)))\n@@ -2446,7 +2446,7 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n \t      memset (&wi, 0, sizeof (wi));\n \t      wi.info = loop_vinfo;\n \t      gimple_stmt_iterator gsi2\n-\t\t= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+\t\t= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info)->stmt);\n \t      walk_gimple_stmt (&gsi2, vect_detect_hybrid_slp_2,\n \t\t\t\tvect_detect_hybrid_slp_1, &wi);\n \t      walk_gimple_seq (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),\n@@ -3612,7 +3612,7 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \t  if (SLP_TREE_DEF_TYPE (child) == vect_internal_def)\n \t    {\n \t      gimple *first_def = SLP_TREE_SCALAR_STMTS (child)[0];\n-\t      gimple *related\n+\t      stmt_vec_info related\n \t\t= STMT_VINFO_RELATED_STMT (vinfo_for_stmt (first_def));\n \t      tree first_def_op;\n \n@@ -3622,7 +3622,8 @@ vect_get_slp_defs (vec<tree> ops, slp_tree slp_node,\n \t\tfirst_def_op = gimple_get_lhs (first_def);\n \t      if (operand_equal_p (oprnd, first_def_op, 0)\n \t\t  || (related\n-\t\t      && operand_equal_p (oprnd, gimple_get_lhs (related), 0)))\n+\t\t      && operand_equal_p (oprnd,\n+\t\t\t\t\t  gimple_get_lhs (related->stmt), 0)))\n \t\t{\n \t\t  /* The number of vector defs is determined by the number of\n \t\t     vector statements in the node from which we get those"}, {"sha": "8bddeca0315dd1ad6d31132528213c2322d198ac", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -202,7 +202,6 @@ vect_mark_relevant (vec<gimple *> *worklist, gimple *stmt,\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   enum vect_relevant save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n   bool save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n-  gimple *pattern_stmt;\n \n   if (dump_enabled_p ())\n     {\n@@ -222,17 +221,16 @@ vect_mark_relevant (vec<gimple *> *worklist, gimple *stmt,\n \t as relevant/live because it's not going to be vectorized.\n \t Instead mark the pattern-stmt that replaces it.  */\n \n-      pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"last stmt in pattern. don't mark\"\n \t\t\t \" relevant/live.\\n\");\n-      stmt_info = vinfo_for_stmt (pattern_stmt);\n-      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n+      stmt_vec_info old_stmt_info = stmt_info;\n+      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n+      gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == old_stmt_info);\n       save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n       save_live_p = STMT_VINFO_LIVE_P (stmt_info);\n-      stmt = pattern_stmt;\n+      stmt = stmt_info->stmt;\n     }\n \n   STMT_VINFO_LIVE_P (stmt_info) |= live_p;\n@@ -1489,8 +1487,8 @@ vect_get_vec_def_for_operand_1 (gimple *def_stmt, enum vect_def_type dt)\n         if (!vec_stmt\n             && STMT_VINFO_IN_PATTERN_P (def_stmt_info)\n             && !STMT_VINFO_RELEVANT (def_stmt_info))\n-          vec_stmt = STMT_VINFO_VEC_STMT (vinfo_for_stmt (\n-                       STMT_VINFO_RELATED_STMT (def_stmt_info)));\n+\t  vec_stmt = (STMT_VINFO_VEC_STMT\n+\t\t      (STMT_VINFO_RELATED_STMT (def_stmt_info)));\n         gcc_assert (vec_stmt);\n \tif (gimple_code (vec_stmt) == GIMPLE_PHI)\n \t  vec_oprnd = PHI_RESULT (vec_stmt);\n@@ -3635,7 +3633,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     return true;\n \n   if (is_pattern_stmt_p (stmt_info))\n-    stmt_info = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n+    stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n   lhs = gimple_get_lhs (stmt_info->stmt);\n \n   gassign *new_stmt\n@@ -4370,7 +4368,7 @@ vectorizable_simd_clone_call (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       type = TREE_TYPE (scalar_dest);\n       if (is_pattern_stmt_p (stmt_info))\n-\tlhs = gimple_call_lhs (STMT_VINFO_RELATED_STMT (stmt_info));\n+\tlhs = gimple_call_lhs (STMT_VINFO_RELATED_STMT (stmt_info)->stmt);\n       else\n \tlhs = gimple_call_lhs (stmt);\n       new_stmt = gimple_build_assign (lhs, build_zero_cst (type));\n@@ -9420,7 +9418,6 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n   bool ok;\n-  gimple *pattern_stmt;\n   gimple_seq pattern_def_seq;\n \n   if (dump_enabled_p ())\n@@ -9482,18 +9479,18 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n      traversal, don't analyze pattern stmts instead, the pattern stmts\n      already will be part of SLP instance.  */\n \n-  pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+  stmt_vec_info pattern_stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n   if (!STMT_VINFO_RELEVANT_P (stmt_info)\n       && !STMT_VINFO_LIVE_P (stmt_info))\n     {\n       if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n-          && pattern_stmt\n-          && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n-              || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+\t  && pattern_stmt_info\n+\t  && (STMT_VINFO_RELEVANT_P (pattern_stmt_info)\n+\t      || STMT_VINFO_LIVE_P (pattern_stmt_info)))\n         {\n           /* Analyze PATTERN_STMT instead of the original stmt.  */\n-          stmt = pattern_stmt;\n-          stmt_info = vinfo_for_stmt (pattern_stmt);\n+\t  stmt = pattern_stmt_info->stmt;\n+\t  stmt_info = pattern_stmt_info;\n           if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location,\n@@ -9511,9 +9508,9 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n     }\n   else if (STMT_VINFO_IN_PATTERN_P (stmt_info)\n \t   && node == NULL\n-           && pattern_stmt\n-           && (STMT_VINFO_RELEVANT_P (vinfo_for_stmt (pattern_stmt))\n-               || STMT_VINFO_LIVE_P (vinfo_for_stmt (pattern_stmt))))\n+\t   && pattern_stmt_info\n+\t   && (STMT_VINFO_RELEVANT_P (pattern_stmt_info)\n+\t       || STMT_VINFO_LIVE_P (pattern_stmt_info)))\n     {\n       /* Analyze PATTERN_STMT too.  */\n       if (dump_enabled_p ())\n@@ -9523,7 +9520,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node,\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n         }\n \n-      if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node,\n+      if (!vect_analyze_stmt (pattern_stmt_info, need_to_vectorize, node,\n \t\t\t      node_instance, cost_vec))\n         return false;\n    }\n@@ -9855,7 +9852,6 @@ new_stmt_vec_info (gimple *stmt, vec_info *vinfo)\n   STMT_VINFO_VEC_STMT (res) = NULL;\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_IN_PATTERN_P (res) = false;\n-  STMT_VINFO_RELATED_STMT (res) = NULL;\n   STMT_VINFO_PATTERN_DEF_SEQ (res) = NULL;\n   STMT_VINFO_DATA_REF (res) = NULL;\n   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n@@ -9936,16 +9932,14 @@ free_stmt_vec_info (gimple *stmt)\n \t      release_ssa_name (lhs);\n \t    free_stmt_vec_info (seq_stmt);\n \t  }\n-      stmt_vec_info patt_info\n-\t= vinfo_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n-      if (patt_info)\n+      stmt_vec_info patt_stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n+      if (patt_stmt_info)\n \t{\n-\t  gimple *patt_stmt = STMT_VINFO_STMT (patt_info);\n-\t  gimple_set_bb (patt_stmt, NULL);\n-\t  tree lhs = gimple_get_lhs (patt_stmt);\n+\t  gimple_set_bb (patt_stmt_info->stmt, NULL);\n+\t  tree lhs = gimple_get_lhs (patt_stmt_info->stmt);\n \t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t    release_ssa_name (lhs);\n-\t  free_stmt_vec_info (patt_stmt);\n+\t  free_stmt_vec_info (patt_stmt_info);\n \t}\n     }\n \n@@ -10143,8 +10137,8 @@ vect_is_simple_use (tree operand, vec_info *vinfo, enum vect_def_type *dt,\n \t{\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_vinfo))\n \t    {\n-\t      def_stmt = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n-\t      stmt_vinfo = vinfo_for_stmt (def_stmt);\n+\t      stmt_vinfo = STMT_VINFO_RELATED_STMT (stmt_vinfo);\n+\t      def_stmt = stmt_vinfo->stmt;\n \t    }\n \t  switch (gimple_code (def_stmt))\n \t    {"}, {"sha": "fb7b592f07e0e5989ed5b8155b5067807c1c677b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=10681ce8cb6227ae5c11cc74ddf48f2fc5e6f87e", "patch": "@@ -847,7 +847,7 @@ struct _stmt_vec_info {\n         related_stmt of the \"pattern stmt\" points back to this stmt (which is\n         the last stmt in the original sequence of stmts that constitutes the\n         pattern).  */\n-  gimple *related_stmt;\n+  stmt_vec_info related_stmt;\n \n   /* Used to keep a sequence of def stmts of a pattern stmt if such exists.\n      The sequence is attached to the original statement rather than the\n@@ -1189,16 +1189,8 @@ get_later_stmt (gimple *stmt1, gimple *stmt2)\n static inline bool\n is_pattern_stmt_p (stmt_vec_info stmt_info)\n {\n-  gimple *related_stmt;\n-  stmt_vec_info related_stmt_info;\n-\n-  related_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n-  if (related_stmt\n-      && (related_stmt_info = vinfo_for_stmt (related_stmt))\n-      && STMT_VINFO_IN_PATTERN_P (related_stmt_info))\n-    return true;\n-\n-  return false;\n+  stmt_vec_info related_stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n+  return related_stmt_info && STMT_VINFO_IN_PATTERN_P (related_stmt_info);\n }\n \n /* Return true if BB is a loop header.  */"}]}