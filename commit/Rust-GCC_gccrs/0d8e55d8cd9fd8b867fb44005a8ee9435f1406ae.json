{"sha": "0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ4ZTU1ZDhjZDlmZDhiODY3ZmI0NDAwNWE4ZWU5NDM1ZjE0MDZhZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-09-15T22:47:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-15T22:47:10Z"}, "message": "combine.c (make_extraction): If no mode is specified for an operand of insv...\n\n        * combine.c (make_extraction): If no mode is specified for\n        an operand of insv, extv, or extzv, default it to word_mode.\n        (simplify_comparison): Similarly.\n        * expmed.c (store_bit_field): Similarly.\n        (extract_bit_field): Similarly.\n        * function.c (fixup_var_regs_1): Similarly.\n        * recog.c (validate_replace_rtx_1): Similarly.\n        * mips.md (extv, extzv, insv expanders): Default modes for most\n        operands.  Handle TARGET_64BIT.\n        (movdi_uld, movdi_usd): New patterns.\n\nFrom-SVN: r22439", "tree": {"sha": "ed903d8c350727df2bf1f53c6551d8a874814869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed903d8c350727df2bf1f53c6551d8a874814869"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/comments", "author": null, "committer": null, "parents": [{"sha": "54d65918774e3854206d61c82dbb39d2241eb603", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54d65918774e3854206d61c82dbb39d2241eb603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54d65918774e3854206d61c82dbb39d2241eb603"}], "stats": {"total": 344, "additions": 273, "deletions": 71}, "files": [{"sha": "a4f4e38ceb56d3f5117b9dc0d3a37484111dbdc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "patch": "@@ -1,5 +1,16 @@\n Tue Sep 15 22:59:52 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* combine.c (make_extraction): If no mode is specified for\n+\tan operand of insv, extv, or extzv, default it to word_mode.\n+\t(simplify_comparison): Similarly.\n+\t* expmed.c (store_bit_field): Similarly.\n+\t(extract_bit_field): Similarly.\n+\t* function.c (fixup_var_regs_1): Similarly.\n+\t* recog.c (validate_replace_rtx_1): Similarly.\n+\t* mips.md (extv, extzv, insv expanders): Default modes for most\n+\toperands.  Handle TARGET_64BIT.\n+\t(movdi_uld, movdi_usd): New patterns.\n+\n \t* pa.c (emit_move_sequence): Do not replace a pseudo with its\n \tequivalent memory location unless we have been provided a scratch\n \tregister.  Similarly do not call find_replacement unless a"}, {"sha": "024cb51e48bf3ab407cebd57e87d691ebbb075b7", "filename": "gcc/combine.c", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "patch": "@@ -5605,27 +5605,45 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n #ifdef HAVE_insv\n   if (in_dest)\n     {\n-      wanted_inner_reg_mode = insn_operand_mode[(int) CODE_FOR_insv][0];\n-      pos_mode = insn_operand_mode[(int) CODE_FOR_insv][2];\n-      extraction_mode = insn_operand_mode[(int) CODE_FOR_insv][3];\n+      wanted_inner_reg_mode\n+\t= (insn_operand_mode[(int) CODE_FOR_insv][0] == VOIDmode\n+\t   ? word_mode\n+\t   : insn_operand_mode[(int) CODE_FOR_insv][0]);\n+      pos_mode = (insn_operand_mode[(int) CODE_FOR_insv][2] == VOIDmode\n+\t\t  ? word_mode : insn_operand_mode[(int) CODE_FOR_insv][2]);\n+      extraction_mode = (insn_operand_mode[(int) CODE_FOR_insv][3] == VOIDmode\n+\t\t\t ? word_mode\n+\t\t\t : insn_operand_mode[(int) CODE_FOR_insv][3]);\n     }\n #endif\n \n #ifdef HAVE_extzv\n   if (! in_dest && unsignedp)\n     {\n-      wanted_inner_reg_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n-      pos_mode = insn_operand_mode[(int) CODE_FOR_extzv][3];\n-      extraction_mode = insn_operand_mode[(int) CODE_FOR_extzv][0];\n+      wanted_inner_reg_mode\n+\t= (insn_operand_mode[(int) CODE_FOR_extzv][1] == VOIDmode\n+\t   ? word_mode\n+\t   : insn_operand_mode[(int) CODE_FOR_extzv][1]);\n+      pos_mode = (insn_operand_mode[(int) CODE_FOR_extzv][3] == VOIDmode\n+\t\t  ? word_mode : insn_operand_mode[(int) CODE_FOR_extzv][3]);\n+      extraction_mode = (insn_operand_mode[(int) CODE_FOR_extzv][0] == VOIDmode\n+\t\t\t ? word_mode\n+\t\t\t : insn_operand_mode[(int) CODE_FOR_extzv][0]);\n     }\n #endif\n \n #ifdef HAVE_extv\n   if (! in_dest && ! unsignedp)\n     {\n-      wanted_inner_reg_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n-      pos_mode = insn_operand_mode[(int) CODE_FOR_extv][3];\n-      extraction_mode = insn_operand_mode[(int) CODE_FOR_extv][0];\n+      wanted_inner_reg_mode\n+\t= (insn_operand_mode[(int) CODE_FOR_extv][1] == VOIDmode\n+\t   ? word_mode\n+\t   : insn_operand_mode[(int) CODE_FOR_extv][1]);\n+      pos_mode = (insn_operand_mode[(int) CODE_FOR_extv][3] == VOIDmode\n+\t\t  ? word_mode : insn_operand_mode[(int) CODE_FOR_extv][3]);\n+      extraction_mode = (insn_operand_mode[(int) CODE_FOR_extv][0] == VOIDmode\n+\t\t\t ? word_mode\n+\t\t\t : insn_operand_mode[(int) CODE_FOR_extv][0]);\n     }\n #endif\n \n@@ -9762,12 +9780,16 @@ simplify_comparison (code, pop0, pop1)\n \t      && (i = exact_log2 (INTVAL (XEXP (op0, 0)))) >= 0)\n \t    {\n \t      if (BITS_BIG_ENDIAN)\n+\t\t{\n #ifdef HAVE_extzv\n-\t\ti = (GET_MODE_BITSIZE\n-\t\t     (insn_operand_mode[(int) CODE_FOR_extzv][1]) - 1 - i);\n+\t\t  mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t\t  if (mode == VOIDmode)\n+\t\t    mode = word_mode;\n+\t\t  i = (GET_MODE_BITSIZE (mode) - 1 - i);\n #else\n-\t        i = BITS_PER_WORD - 1 - i;\n+\t          i = BITS_PER_WORD - 1 - i;\n #endif\n+\t\t}\n \n \t      op0 = XEXP (op0, 2);\n \t      op1 = GEN_INT (i);"}, {"sha": "17bd10f8288371eb64c3fb3089f90449aeb0c280", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 148, "deletions": 30, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "patch": "@@ -4224,24 +4224,30 @@ move\\\\t%0,%z4\\\\n\\\\\n \n ;; Bit field extract patterns which use lwl/lwr.\n \n-;; ??? There should be DImode variants for 64 bit code, but the current\n-;; bitfield scheme can't handle that.  We would need to add new optabs\n-;; in order to make that work.\n-\n ;; ??? There could be HImode variants for the ulh/ulhu/ush macros.\n ;; It isn't clear whether this will give better code.\n \n+;; Only specify the mode operand 1, the rest are assumed to be word_mode.\n (define_expand \"extv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(sign_extract (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t      (match_operand 2 \"immediate_operand\" \"\")\n+\t\t      (match_operand 3 \"immediate_operand\" \"\")))]\n   \"!TARGET_MIPS16\"\n   \"\n {\n-  /* If this isn't a 32 bit field, and it doesn't start on a byte boundary\n-     then fail.  */\n-  if (INTVAL (operands[2]) != 32 || (INTVAL (operands[3]) % 8) != 0)\n+  /* If the field does not start on a byte boundary, then fail.  */\n+  if (INTVAL (operands[3]) % 8 != 0) \n+    FAIL;\n+\n+  /* MIPS I and MIPS II can only handle a 32bit field.  */\n+  if (!TARGET_64BIT && INTVAL (operands[2]) != 32)\n+    FAIL;\n+\n+  /* MIPS III and MIPS IV can handle both 32bit and 64bit fields.  */\n+  if (TARGET_64BIT\n+      && INTVAL (operands[2]) != 64\n+      && INTVAL (operands[2]) != 32)\n     FAIL;\n \n   /* This can happen for a 64 bit target, when extracting a value from\n@@ -4253,22 +4259,43 @@ move\\\\t%0,%z4\\\\n\\\\\n   /* Change the mode to BLKmode for aliasing purposes.  */\n   operands[1] = change_address (operands[1], BLKmode, XEXP (operands[1], 0));\n \n-  /* Otherwise, emit a lwl/lwr pair to load the value.  */\n-  emit_insn (gen_movsi_ulw (operands[0], operands[1]));\n+  /* Otherwise, emit a l[wd]l/l[wd]r pair to load the value.  */\n+  if (INTVAL (operands[2]) == 64)\n+    emit_insn (gen_movdi_uld (operands[0], operands[1]));\n+  else\n+    {\n+      if (TARGET_64BIT)\n+\t{\n+\t  operands[0] = gen_lowpart (SImode, operands[0]);\n+\t  if (operands[0] == NULL_RTX)\n+\t    FAIL;\n+\t}\n+      emit_insn (gen_movsi_ulw (operands[0], operands[1]));\n+    }\n   DONE;\n }\")\n \n+;; Only specify the mode operand 1, the rest are assumed to be word_mode.\n (define_expand \"extzv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"\")))]\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(zero_extract (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t      (match_operand 2 \"immediate_operand\" \"\")\n+\t\t      (match_operand 3 \"immediate_operand\" \"\")))]\n   \"!TARGET_MIPS16\"\n   \"\n {\n-  /* If this isn't a 32 bit field, and it doesn't start on a byte boundary\n-     then fail.  */\n-  if (INTVAL (operands[2]) != 32 || (INTVAL (operands[3]) % 8) != 0)\n+  /* If the field does not start on a byte boundary, then fail.  */\n+  if (INTVAL (operands[3]) % 8 != 0) \n+    FAIL;\n+\n+  /* MIPS I and MIPS II can only handle a 32bit field.  */\n+  if (!TARGET_64BIT && INTVAL (operands[2]) != 32)\n+    FAIL;\n+\n+  /* MIPS III and MIPS IV can handle both 32bit and 64bit fields.  */\n+  if (TARGET_64BIT\n+      && INTVAL (operands[2]) != 64\n+      && INTVAL (operands[2]) != 32)\n     FAIL;\n \n   /* This can happen for a 64 bit target, when extracting a value from\n@@ -4281,21 +4308,42 @@ move\\\\t%0,%z4\\\\n\\\\\n   operands[1] = change_address (operands[1], BLKmode, XEXP (operands[1], 0));\n \n   /* Otherwise, emit a lwl/lwr pair to load the value.  */\n-  emit_insn (gen_movsi_ulw (operands[0], operands[1]));\n+  if (INTVAL (operands[2]) == 64)\n+    emit_insn (gen_movdi_uld (operands[0], operands[1]));\n+  else\n+    {\n+      if (TARGET_64BIT)\n+\t{\n+\t  operands[0] = gen_lowpart (SImode, operands[0]);\n+\t  if (operands[0] == NULL_RTX)\n+\t    FAIL;\n+\t}\n+      emit_insn (gen_movsi_ulw (operands[0], operands[1]));\n+    }\n   DONE;\n }\")\n \n+;; Only specify the mode operands 0, the rest are assumed to be word_mode.\n (define_expand \"insv\"\n-  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"\"))\n-\t(match_operand:SI 3 \"register_operand\" \"\"))]\n+  [(set (zero_extract (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t      (match_operand 1 \"immediate_operand\" \"\")\n+\t\t      (match_operand 2 \"immediate_operand\" \"\"))\n+\t(match_operand 3 \"register_operand\" \"\"))]\n   \"!TARGET_MIPS16\"\n   \"\n {\n-  /* If this isn't a 32 bit field, and it doesn't start on a byte boundary\n-     then fail.  */\n-  if (INTVAL (operands[1]) != 32 || (INTVAL (operands[2]) % 8) != 0)\n+  /* If the field does not start on a byte boundary, then fail.  */\n+  if (INTVAL (operands[2]) % 8 != 0) \n+    FAIL;\n+\n+  /* MIPS I and MIPS II can only handle a 32bit field.  */\n+  if (!TARGET_64BIT && INTVAL (operands[1]) != 32)\n+    FAIL;\n+\n+  /* MIPS III and MIPS IV can handle both 32bit and 64bit fields.  */\n+  if (TARGET_64BIT\n+      && INTVAL (operands[1]) != 64\n+      && INTVAL (operands[1]) != 32)\n     FAIL;\n \n   /* This can happen for a 64 bit target, when storing into a 32 bit union\n@@ -4307,8 +4355,19 @@ move\\\\t%0,%z4\\\\n\\\\\n   /* Change the mode to BLKmode for aliasing purposes.  */\n   operands[0] = change_address (operands[0], BLKmode, XEXP (operands[0], 0));\n \n-  /* Otherwise, emit a swl/swr pair to load the value.  */\n-  emit_insn (gen_movsi_usw (operands[0], operands[3]));\n+  /* Otherwise, emit a s[wd]l/s[wd]r pair to load the value.  */\n+  if (INTVAL (operands[1]) == 64)\n+    emit_insn (gen_movdi_usd (operands[0], operands[3]));\n+  else\n+    {\n+      if (TARGET_64BIT)\n+\t{\n+\t  operands[3] = gen_lowpart (SImode, operands[3]);\n+\t  if (operands[3] == NULL_RTX)\n+\t    FAIL;\n+\t}\n+      emit_insn (gen_movsi_usw (operands[0], operands[3]));\n+    }\n   DONE;\n }\")\n \n@@ -4369,6 +4428,65 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"2,4\")])\n \n+;; Bit field extract patterns which use ldl/ldr.\n+\n+;; unaligned double word moves generated by the bit field patterns\n+\n+(define_insn \"movdi_uld\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=&d,&d\")\n+\t(unspec:DI [(match_operand:BLK 1 \"general_operand\" \"R,o\")] 0))]\n+  \"\"\n+  \"*\n+{\n+  rtx offset = const0_rtx;\n+  rtx addr = XEXP (operands[1], 0);\n+  rtx mem_addr = eliminate_constant_term (addr, &offset);\n+  char *ret;\n+\n+  if (TARGET_STATS)\n+    mips_count_memory_refs (operands[1], 2);\n+\n+  /* The stack/frame pointers are always aligned, so we can convert\n+     to the faster lw if we are referencing an aligned stack location.  */\n+\n+  if ((INTVAL (offset) & 7) == 0\n+      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n+    ret = \\\"ld\\\\t%0,%1\\\";\n+  else\n+    ret = \\\"uld\\\\t%0,%1\\\";\n+\n+  return mips_fill_delay_slot (ret, DELAY_LOAD, operands, insn);\n+}\"\n+  [(set_attr \"type\"\t\"load,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,4\")])\n+\n+(define_insn \"movdi_usd\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=R,o\")\n+\t(unspec:BLK [(match_operand:DI 1 \"reg_or_0_operand\" \"dJ,dJ\")] 1))]\n+  \"\"\n+  \"*\n+{\n+  rtx offset = const0_rtx;\n+  rtx addr = XEXP (operands[0], 0);\n+  rtx mem_addr = eliminate_constant_term (addr, &offset);\n+\n+  if (TARGET_STATS)\n+    mips_count_memory_refs (operands[0], 2);\n+\n+  /* The stack/frame pointers are always aligned, so we can convert\n+     to the faster sw if we are referencing an aligned stack location.  */\n+\n+  if ((INTVAL (offset) & 7) == 0\n+      && (mem_addr == stack_pointer_rtx || mem_addr == frame_pointer_rtx))\n+    return \\\"sd\\\\t%1,%0\\\";\n+\n+  return \\\"usd\\\\t%z1,%0\\\";\n+}\"\n+  [(set_attr \"type\"\t\"store\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,4\")])\n+\n ;; These two patterns support loading addresses with two instructions instead\n ;; of using the macro instruction la.\n "}, {"sha": "730d904a1cf71567889c94914f6b82e1216307a4", "filename": "gcc/expmed.c", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "patch": "@@ -211,10 +211,10 @@ negate_rtx (mode, x)\n /* ??? Note that there are two different ideas here for how\n    to determine the size to count bits within, for a register.\n    One is BITS_PER_WORD, and the other is the size of operand 3\n-   of the insv pattern.  (The latter assumes that an n-bit machine\n-   will be able to insert bit fields up to n bits wide.)\n-   It isn't certain that either of these is right.\n-   extract_bit_field has the same quandary.  */\n+   of the insv pattern.\n+\n+   If operand 3 of the insv pattern is VOIDmode, then we will use BITS_PER_WORD\n+   else, we use the mode of operand 3.  */\n \n rtx\n store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n@@ -230,6 +230,14 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   register int offset = bitnum / unit;\n   register int bitpos = bitnum % unit;\n   register rtx op0 = str_rtx;\n+#ifdef HAVE_insv\n+  int insv_bitsize;\n+\n+  if (insn_operand_mode[(int) CODE_FOR_insv][3] == VOIDmode)\n+    insv_bitsize = GET_MODE_BITSIZE (word_mode);\n+  else\n+    insv_bitsize = GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_insv][3]);\n+#endif\n \n   if (GET_CODE (str_rtx) == MEM && ! MEM_IN_STRUCT_P (str_rtx))\n     abort ();\n@@ -400,21 +408,22 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       && GET_MODE (value) != BLKmode\n       && !(bitsize == 1 && GET_CODE (value) == CONST_INT)\n       /* Ensure insv's size is wide enough for this field.  */\n-      && (GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_insv][3])\n-\t  >= bitsize)\n+      && (insv_bitsize >= bitsize)\n       && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n-\t    && (bitsize + bitpos\n-\t\t> GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_insv][3]))))\n+\t    && (bitsize + bitpos > insv_bitsize)))\n     {\n       int xbitpos = bitpos;\n       rtx value1;\n       rtx xop0 = op0;\n       rtx last = get_last_insn ();\n       rtx pat;\n-      enum machine_mode maxmode\n-\t= insn_operand_mode[(int) CODE_FOR_insv][3];\n-\n+      enum machine_mode maxmode;\n       int save_volatile_ok = volatile_ok;\n+\n+      maxmode = insn_operand_mode[(int) CODE_FOR_insv][3];\n+      if (maxmode == VOIDmode)\n+\tmaxmode = word_mode;\n+\n       volatile_ok = 1;\n \n       /* If this machine's insv can only insert into a register, copy OP0\n@@ -894,6 +903,27 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   register rtx op0 = str_rtx;\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n+#ifdef HAVE_extv\n+  int extv_bitsize;\n+#endif\n+#ifdef HAVE_extzv\n+  int extzv_bitsize;\n+#endif\n+\n+#ifdef HAVE_extv\n+  if (insn_operand_mode[(int) CODE_FOR_extv][0] == VOIDmode)\n+    extv_bitsize = GET_MODE_BITSIZE (word_mode);\n+  else\n+    extv_bitsize = GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extv][0]);\n+#endif\n+\n+#ifdef HAVE_extzv\n+  if (insn_operand_mode[(int) CODE_FOR_extzv][0] == VOIDmode)\n+    extzv_bitsize = GET_MODE_BITSIZE (word_mode);\n+  else\n+    extzv_bitsize\n+      = GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extzv][0]);\n+#endif\n \n   /* Discount the part of the structure before the desired byte.\n      We need to know how many bytes are safe to reference after it.  */\n@@ -1073,11 +1103,9 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     {\n #ifdef HAVE_extzv\n       if (HAVE_extzv\n-\t  && (GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extzv][0])\n-\t      >= bitsize)\n+\t  && (extzv_bitsize >= bitsize)\n \t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n-\t\t&& (bitsize + bitpos\n-\t\t    > GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extzv][0]))))\n+\t\t&& (bitsize + bitpos > extzv_bitsize)))\n \t{\n \t  int xbitpos = bitpos, xoffset = offset;\n \t  rtx bitsize_rtx, bitpos_rtx;\n@@ -1087,8 +1115,11 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  rtx xspec_target = spec_target;\n \t  rtx xspec_target_subreg = spec_target_subreg;\n \t  rtx pat;\n-\t  enum machine_mode maxmode\n-\t    = insn_operand_mode[(int) CODE_FOR_extzv][0];\n+\t  enum machine_mode maxmode;\n+\n+\t  maxmode = insn_operand_mode[(int) CODE_FOR_extzv][0];\n+\t  if (maxmode == VOIDmode)\n+\t    maxmode = word_mode;\n \n \t  if (GET_CODE (xop0) == MEM)\n \t    {\n@@ -1213,11 +1244,9 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     {\n #ifdef HAVE_extv\n       if (HAVE_extv\n-\t  && (GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extv][0])\n-\t      >= bitsize)\n+\t  && (extv_bitsize >= bitsize)\n \t  && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG)\n-\t\t&& (bitsize + bitpos\n-\t\t    > GET_MODE_BITSIZE (insn_operand_mode[(int) CODE_FOR_extv][0]))))\n+\t\t&& (bitsize + bitpos > extv_bitsize)))\n \t{\n \t  int xbitpos = bitpos, xoffset = offset;\n \t  rtx bitsize_rtx, bitpos_rtx;\n@@ -1226,8 +1255,11 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  rtx xspec_target = spec_target;\n \t  rtx xspec_target_subreg = spec_target_subreg;\n \t  rtx pat;\n-\t  enum machine_mode maxmode\n-\t    = insn_operand_mode[(int) CODE_FOR_extv][0];\n+\t  enum machine_mode maxmode;\n+\n+\t  maxmode = insn_operand_mode[(int) CODE_FOR_extv][0];\n+\t  if (maxmode == VOIDmode)\n+\t    maxmode = word_mode;\n \n \t  if (GET_CODE (xop0) == MEM)\n \t    {"}, {"sha": "c75648dbf3095851750dd46e7bbfbd4bca980b34", "filename": "gcc/function.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "patch": "@@ -1975,11 +1975,19 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n #ifdef HAVE_extzv\n \t      if (GET_CODE (x) == ZERO_EXTRACT)\n-\t\twanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t\t{\n+\t\t  wanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t\t  if (wanted_mode == VOIDmode)\n+\t\t    wanted_mode = word_mode;\n+\t\t}\n #endif\n #ifdef HAVE_extv\n \t      if (GET_CODE (x) == SIGN_EXTRACT)\n-\t\twanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+\t\t{\n+\t\t  wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+\t\t  if (wanted_mode == VOIDmode)\n+\t\t    wanted_mode = word_mode;\n+\t\t}\n #endif\n \t      /* If we have a narrower mode, we can do something.  */\n \t      if (wanted_mode != VOIDmode\n@@ -2168,11 +2176,14 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \t\t&& ! mode_dependent_address_p (XEXP (tem, 0))\n \t\t&& ! MEM_VOLATILE_P (tem))\n \t      {\n-\t\tenum machine_mode wanted_mode\n-\t\t  = insn_operand_mode[(int) CODE_FOR_insv][0];\n+\t\tenum machine_mode wanted_mode;\n \t\tenum machine_mode is_mode = GET_MODE (tem);\n \t\tHOST_WIDE_INT pos = INTVAL (XEXP (outerdest, 2));\n \n+\t\twanted_mode = insn_operand_mode[(int) CODE_FOR_insv][0];\n+\t\tif (wanted_mode == VOIDmode)\n+\t\t  wanted_mode = word_mode;\n+\n \t\t/* If we have a narrower mode, we can do something.  */\n \t\tif (GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t\t  {"}, {"sha": "9f6a1eaf669a6d9405dc3ea9b3fb1f8e579315fd", "filename": "gcc/recog.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0d8e55d8cd9fd8b867fb44005a8ee9435f1406ae", "patch": "@@ -484,11 +484,19 @@ validate_replace_rtx_1 (loc, from, to, object)\n \n #ifdef HAVE_extzv\n \t  if (code == ZERO_EXTRACT)\n-\t    wanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t    {\n+\t      wanted_mode = insn_operand_mode[(int) CODE_FOR_extzv][1];\n+\t      if (wanted_mode == VOIDmode)\n+\t\twanted_mode = word_mode;\n+\t    }\n #endif\n #ifdef HAVE_extv\n \t  if (code == SIGN_EXTRACT)\n-\t    wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+\t    {\n+\t      wanted_mode = insn_operand_mode[(int) CODE_FOR_extv][1];\n+\t      if (wanted_mode == VOIDmode)\n+\t\twanted_mode = word_mode;\n+\t    }\n #endif\n \n \t  /* If we have a narrower mode, we can do something.  */"}]}