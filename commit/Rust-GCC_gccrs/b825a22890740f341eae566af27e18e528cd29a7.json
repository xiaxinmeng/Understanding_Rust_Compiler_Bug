{"sha": "b825a22890740f341eae566af27e18e528cd29a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyNWEyMjg5MDc0MGYzNDFlYWU1NjZhZjI3ZTE4ZTUyOGNkMjlhNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-06-04T22:06:10Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-06-04T22:08:32Z"}, "message": "Implement a solution for PR middle-end/10138 and PR middle-end/95136.\n\nPR middle-end/10138 - warn for uninitialized arrays passed as const arguments\nPR middle-end/95136 - missing -Wuninitialized on an array access with a variable offset\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/10138\n\tPR middle-end/95136\n\t* c-attribs.c (append_access_attrs): Handle attr_access::none.\n\t(handle_access_attribute): Same.\n\ngcc/ChangeLog:\n\n\tPR middle-end/10138\n\tPR middle-end/95136\n\t* attribs.c (init_attr_rdwr_indices): Move function here.\n\t* attribs.h (rdwr_access_hash, rdwr_map): Define.\n\t(attr_access): Add 'none'.\n\t(init_attr_rdwr_indices): Declared function.\n\t* builtins.c (warn_for_access)): New function.\n\t(check_access): Call it.\n\t* builtins.h (checK-access): Add an optional argument.\n\t* calls.c (rdwr_access_hash, rdwr_map): Move to attribs.h.\n\t(init_attr_rdwr_indices): Declare extern.\n\t(append_attrname): Handle attr_access::none.\n\t(maybe_warn_rdwr_sizes): Same.\n\t(initialize_argument_information): Update comments.\n\t* doc/extend.texi (attribute access): Document 'none'.\n\t* tree-ssa-uninit.c (struct wlimits): New.\n\t(maybe_warn_operand): New function.\n\t(maybe_warn_pass_by_reference): Same.\n\t(warn_uninitialized_vars): Refactor code into maybe_warn_operand.\n\tAlso call for function calls.\n\t(pass_late_warn_uninitialized::execute): Adjust comments.\n\t(execute_early_warn_uninitialized): Same.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/10138\n\tPR middle-end/95136\n\t* c-c++-common/Wsizeof-pointer-memaccess1.c: Prune out valid\n\tWuninitialized.\n\t* c-c++-common/uninit-pr51010.c: Adjust expected warning format.\n\t* c-c++-common/goacc/uninit-dim-clause.c: Same.\n\t* c-c++-common/goacc/uninit-firstprivate-clause.c: Same.\n\t* c-c++-common/goacc/uninit-if-clause.c: Same.\n\t* c-c++-common/gomp/pr70550-1.c: Same.\n\t* c-c++-common/gomp/pr70550-2.c: Adjust.\n\t* g++.dg/20090107-1.C: Same.\n\t* g++.dg/20090121-1.C: Same.\n\t* g++.dg/ext/attr-access.C: Avoid -Wuninitialized.\n\t* gcc.dg/tree-ssa/forwprop-6.c: Prune out -Wuninitialized.\n\t* gcc.dg/Warray-bounds-52.c: Prune out valid -Wuninitialized.\n\t* gcc.dg/Warray-bounds-53.c: Same.\n\t* gcc.dg/Warray-bounds-54.c: Same.\n\t* gcc.dg/Wstringop-overflow-33.c: New test.\n\t* gcc.dg/attr-access-none.c: New test.\n\t* gcc.dg/attr-access-read-only.c: Adjust.\n\t* gcc.dg/attr-access-read-write.c: Same.\n\t* gcc.dg/attr-access-write-only.c: Same.\n\t* gcc.dg/pr71581.c: Adjust text of expected warning.\n\t* gcc.dg/uninit-15.c: Same.\n\t* gcc.dg/uninit-32.c: New test.\n\t* gcc.dg/uninit-33.c: New test.\n\t* gcc.dg/uninit-34.c: New test.\n\t* gcc.dg/uninit-36.c: New test.\n\t* gcc.dg/uninit-B-O0.c: Adjust text of expected warning.\n\t* gcc.dg/uninit-I-O0.c: Same.\n\t* gcc.dg/uninit-pr19430-O0.c: Same.\n\t* gcc.dg/uninit-pr19430.c: Same.\n\t* gcc.dg/uninit-pr95136.c: New test.\n\t* gfortran.dg/assignment_4.f90: Expect -Wuninitialized.\n\t* gfortran.dg/goacc/uninit-dim-clause.f95: Adjust text of expected\n\twarning.\n\t* gfortran.dg/goacc/uninit-firstprivate-clause.f95\n\t* gfortran.dg/goacc/uninit-if-clause.f95\n\t* gfortran.dg/pr66545_2.f90", "tree": {"sha": "b614b6b24e6395784b9eb80af79352ce9bca555f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b614b6b24e6395784b9eb80af79352ce9bca555f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b825a22890740f341eae566af27e18e528cd29a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b825a22890740f341eae566af27e18e528cd29a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b825a22890740f341eae566af27e18e528cd29a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b825a22890740f341eae566af27e18e528cd29a7/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cbc99d18dc411ac3fdef94e22ce86859806e63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbc99d18dc411ac3fdef94e22ce86859806e63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cbc99d18dc411ac3fdef94e22ce86859806e63c"}], "stats": {"total": 1882, "additions": 1566, "deletions": 316}, "files": [{"sha": "71dae123af841303d6f3c3f2ad5ca68a1eefc9ca", "filename": "gcc/attribs.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -2017,6 +2017,65 @@ maybe_diag_alias_attributes (tree alias, tree target)\n     }\n }\n \n+/* Initialize a mapping for a call to function FNDECL declared with\n+   attribute access.  Each attribute positional operand inserts one\n+   entry into the mapping with the operand number as the key.  */\n+\n+void\n+init_attr_rdwr_indices (rdwr_map *rwm, tree fntype)\n+{\n+  if (!fntype)\n+    return;\n+\n+  for (tree access = TYPE_ATTRIBUTES (fntype);\n+       (access = lookup_attribute (\"access\", access));\n+       access = TREE_CHAIN (access))\n+    {\n+      /* The TREE_VALUE of an attribute is a TREE_LIST whose TREE_VALUE\n+\t is the attribute argument's value.  */\n+      tree mode = TREE_VALUE (access);\n+      gcc_assert (TREE_CODE (mode) == TREE_LIST);\n+      mode = TREE_VALUE (mode);\n+      gcc_assert (TREE_CODE (mode) == STRING_CST);\n+\n+      const char *modestr = TREE_STRING_POINTER (mode);\n+      for (const char *m = modestr; *m; )\n+\t{\n+\t  attr_access acc = { };\n+\n+\t  switch (*m)\n+\t    {\n+\t    case 'r': acc.mode = acc.read_only; break;\n+\t    case 'w': acc.mode = acc.write_only; break;\n+\t    case 'x': acc.mode = acc.read_write; break;\n+\t    case '-': acc.mode = acc.none; break;\n+\t    default: gcc_unreachable ();\n+\t    }\n+\n+\t  char *end;\n+\t  acc.ptrarg = strtoul (++m, &end, 10);\n+\t  m = end;\n+\t  if (*m == ',')\n+\t    {\n+\t      acc.sizarg = strtoul (++m, &end, 10);\n+\t      m = end;\n+\t    }\n+\t  else\n+\t    acc.sizarg = UINT_MAX;\n+\n+\t  acc.ptr = NULL_TREE;\n+\t  acc.size = NULL_TREE;\n+\n+\t  /* Unconditionally add an entry for the required pointer\n+\t     operand of the attribute, and one for the optional size\n+\t     operand when it's specified.  */\n+\t  rwm->put (acc.ptrarg, acc);\n+\t  if (acc.sizarg != UINT_MAX)\n+\t    rwm->put (acc.sizarg, acc);\n+\t}\n+    }\n+}\n+\n \n #if CHECKING_P\n "}, {"sha": "dea0b6c44e683c6b1d1c87fd97d38b23e676998f", "filename": "gcc/attribs.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -234,8 +234,18 @@ struct attr_access\n   unsigned sizarg;\n \n   /* The access mode.  */\n-  enum access_mode { read_only, write_only, read_write };\n+  enum access_mode { none, read_only, write_only, read_write };\n   access_mode mode;\n };\n \n+/* Used to define rdwr_map below.  */\n+struct rdwr_access_hash: int_hash<int, -1> { };\n+\n+/* A mapping between argument number corresponding to attribute access\n+   mode (read_only, write_only, or read_write) and operands.  */\n+struct attr_access;\n+typedef hash_map<rdwr_access_hash, attr_access> rdwr_map;\n+\n+extern void init_attr_rdwr_indices (rdwr_map *, tree);\n+\n #endif // GCC_ATTRIBS_H"}, {"sha": "667d36c940ba3faca6730908abbbaa2173c00897", "filename": "gcc/builtins.c", "status": "modified", "additions": 90, "deletions": 36, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -3310,6 +3310,90 @@ determine_block_size (tree len, rtx len_rtx,\n \t\t\t  GET_MODE_MASK (GET_MODE (len_rtx)));\n }\n \n+/* For an expression EXP issue an access warning controlled by option OPT\n+   with access to a region SLEN bytes in size in the RANGE of sizes.  */\n+\n+static bool\n+warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n+\t\t tree slen, bool access)\n+{\n+  bool warned = false;\n+\n+  if (access)\n+    {\n+      if (tree_int_cst_equal (range[0], range[1]))\n+\twarned = (func\n+\t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%K%qD reading %E byte from a region of size %E\",\n+\t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\n+\t\t\t       exp, func, range[0], slen)\n+\t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t       \"%Kreading %E byte from a region of size %E\",\n+\t\t\t       \"%Kreading %E bytes from a region of size %E\",\n+\t\t\t       exp, range[0], slen));\n+      else if (tree_int_cst_sign_bit (range[1]))\n+\t{\n+\t  /* Avoid printing the upper bound if it's invalid.  */\n+\t  warned = (func\n+\t\t    ? warning_at (loc, opt,\n+\t\t\t\t  \"%K%qD reading %E or more bytes from a region \"\n+\t\t\t\t  \"of size %E\",\n+\t\t\t\t  exp, func, range[0], slen)\n+\t\t    : warning_at (loc, opt,\n+\t\t\t\t  \"%Kreading %E or more bytes from a region \"\n+\t\t\t\t  \"of size %E\",\n+\t\t\t\t  exp, range[0], slen));\n+\t}\n+      else\n+\twarned = (func\n+\t\t  ? warning_at (loc, opt,\n+\t\t\t\t\"%K%qD reading between %E and %E bytes from \"\n+\t\t\t\t\"a region of size %E\",\n+\t\t\t\texp, func, range[0], range[1], slen)\n+\t\t  : warning_at (loc, opt,\n+\t\t\t\t\"%Kreading between %E and %E bytes from \"\n+\t\t\t\t\"a region of size %E\",\n+\t\t\t\texp, range[0], range[1], slen));\n+\n+      return warned;\n+    }\n+\n+  if (tree_int_cst_equal (range[0], range[1]))\n+    warned = (func\n+\t      ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t   \"%K%qD epecting %E byte in a region of size %E\",\n+\t\t\t   \"%K%qD expecting %E bytes in a region of size %E\",\n+\t\t\t   exp, func, range[0], slen)\n+\t      : warning_n (loc, opt, tree_to_uhwi (range[0]),\n+\t\t\t   \"%Kexpecting %E byte in a region of size %E\",\n+\t\t\t   \"%Kexpecting %E bytes in a region of size %E\",\n+\t\t\t   exp, range[0], slen));\n+  else if (tree_int_cst_sign_bit (range[1]))\n+    {\n+      /* Avoid printing the upper bound if it's invalid.  */\n+      warned = (func\n+\t\t? warning_at (loc, opt,\n+\t\t\t      \"%K%qD expecting %E or more bytes in a region \"\n+\t\t\t      \"of size %E\",\n+\t\t\t      exp, func, range[0], slen)\n+\t\t: warning_at (loc, opt,\n+\t\t\t      \"%Kexpecting %E or more bytes in a region \"\n+\t\t\t      \"of size %E\",\n+\t\t\t      exp, range[0], slen));\n+    }\n+  else\n+    warned = (func\n+\t      ? warning_at (loc, opt,\n+\t\t\t    \"%K%qD expecting between %E and %E bytes in \"\n+\t\t\t    \"a region of size %E\",\n+\t\t\t    exp, func, range[0], range[1], slen)\n+\t      : warning_at (loc, opt,\n+\t\t\t    \"%Kexpectting between %E and %E bytes in \"\n+\t\t\t    \"a region of size %E\",\n+\t\t\t    exp, range[0], range[1], slen));\n+  return warned;\n+}\n+\n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n    the operation does not lead to buffer overflow or read past the end.\n@@ -3336,12 +3420,16 @@ determine_block_size (tree len, rtx len_rtx,\n    When DSTWRITE is null LEN is checked to verify that it doesn't exceed\n    SIZE_MAX.\n \n+   ACCESS is true for accesses, false for simple size checks in calls\n+   to functions that neither read from nor write to the region.\n+\n    If the call is successfully verified as safe return true, otherwise\n    return false.  */\n \n bool\n check_access (tree exp, tree, tree, tree dstwrite,\n-\t      tree maxread, tree srcstr, tree dstsize)\n+\t      tree maxread, tree srcstr, tree dstsize,\n+\t      bool access /* = true */)\n {\n   int opt = OPT_Wstringop_overflow_;\n \n@@ -3649,44 +3737,10 @@ check_access (tree exp, tree, tree, tree dstwrite,\n       if (TREE_NO_WARNING (exp))\n \treturn false;\n \n-      bool warned = false;\n       location_t loc = tree_nonartificial_location (exp);\n       loc = expansion_point_location_if_in_system_header (loc);\n \n-      if (tree_int_cst_equal (range[0], range[1]))\n-\twarned = (func\n-\t\t  ? warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t\t       \"%K%qD reading %E byte from a region of size %E\",\n-\t\t\t       \"%K%qD reading %E bytes from a region of size %E\",\n-\t\t\t       exp, func, range[0], slen)\n-\t\t  : warning_n (loc, opt, tree_to_uhwi (range[0]),\n-\t\t\t       \"%Kreading %E byte from a region of size %E\",\n-\t\t\t       \"%Kreading %E bytes from a region of size %E\",\n-\t\t\t       exp, range[0], slen));\n-      else if (tree_int_cst_sign_bit (range[1]))\n-\t{\n-\t  /* Avoid printing the upper bound if it's invalid.  */\n-\t  warned = (func\n-\t\t    ? warning_at (loc, opt,\n-\t\t\t\t  \"%K%qD reading %E or more bytes from a region \"\n-\t\t\t\t  \"of size %E\",\n-\t\t\t\t  exp, func, range[0], slen)\n-\t\t    : warning_at (loc, opt,\n-\t\t\t\t  \"%Kreading %E or more bytes from a region \"\n-\t\t\t\t  \"of size %E\",\n-\t\t\t\t  exp, range[0], slen));\n-\t}\n-      else\n-\twarned = (func\n-\t\t  ? warning_at (loc, opt,\n-\t\t\t\t\"%K%qD reading between %E and %E bytes from \"\n-\t\t\t\t\"a region of size %E\",\n-\t\t\t\texp, func, range[0], range[1], slen)\n-\t\t  : warning_at (loc, opt,\n-\t\t\t\t\"%Kreading between %E and %E bytes from \"\n-\t\t\t\t\"a region of size %E\",\n-\t\t\t\texp, range[0], range[1], slen));\n-      if (warned)\n+      if (warn_for_access (loc, func, exp, opt, range, slen, access))\n \tTREE_NO_WARNING (exp) = true;\n \n       return false;"}, {"sha": "73e85d66e9b7d165b5d871cc28131efec505772a", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -156,7 +156,8 @@ bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n extern void warn_string_no_nul (location_t, const char *, tree, tree);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern bool builtin_with_linkage_p (tree);\n-extern bool check_access (tree, tree, tree, tree, tree, tree, tree);\n+extern bool check_access (tree, tree, tree, tree, tree, tree, tree,\n+\t\t\t  bool = true);\n \n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "193c4cd7cd0de75553c1e4a31592a627b5db06e7", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -3875,14 +3875,17 @@ append_access_attrs (tree t, tree attrs, const char *attrstr,\n \t  /* Found a matching positional argument.  */\n \t  if (*attrspec != pos[-1])\n \t    {\n+\t      const char* const modestr\n+\t\t= (pos[-1] == 'r'\n+\t\t   ? \"read_only\"\n+\t\t   : (pos[-1] == 'w'\n+\t\t      ? \"write_only\"\n+\t\t      : (pos[-1] == 'x' ? \"read_write\" : \"none\")));\n \t      /* Mismatch in access mode.  */\n \t      auto_diagnostic_group d;\n \t      if (warning (OPT_Wattributes,\n \t\t\t   \"attribute %qs mismatch with mode %qs\",\n-\t\t\t   attrstr,\n-\t\t\t   (pos[-1] == 'r'\n-\t\t\t    ? \"read_only\"\n-\t\t\t    : (pos[-1] == 'w' ? \"write_only\" : \"read_write\")))\n+\t\t\t   attrstr, modestr)\n \t\t  && DECL_P (t))\n \t\tinform (DECL_SOURCE_LOCATION (t),\n \t\t\t\"previous declaration here\");\n@@ -4014,13 +4017,14 @@ handle_access_attribute (tree *node, tree name, tree args,\n \tps += 2;\n     }\n \n-  const bool read_only = strncmp (ps, \"read_only\", 9) == 0;\n-  const bool write_only = strncmp (ps, \"write_only\", 10) == 0;\n-  if (!read_only && !write_only && strncmp (ps, \"read_write\", 10))\n+  const bool read_only = !strncmp (ps, \"read_only\", 9);\n+  const bool write_only = !strncmp (ps, \"write_only\", 10);\n+  const bool read_write = !strncmp (ps, \"read_write\", 10);\n+  if (!read_only && !write_only && !read_write && strncmp (ps, \"none\", 4))\n     {\n       error (\"attribute %qE invalid mode %qs; expected one of \"\n-\t     \"%qs, %qs, or %qs\", name, access_str,\n-\t     \"read_only\", \"read_write\", \"write_only\");\n+\t     \"%qs, %qs, %qs, or %qs\", name, access_str,\n+\t     \"read_only\", \"read_write\", \"write_only\", \"none\");\n       return NULL_TREE;\n     }\n \n@@ -4145,9 +4149,9 @@ handle_access_attribute (tree *node, tree name, tree args,\n       }\n   }\n \n-  if (!read_only)\n+  if (read_write || write_only)\n     {\n-      /* A read_write and write_only modes must reference non-const\n+      /* Read_write and write_only modes must reference non-const\n \t arguments.  */\n       if (TYPE_READONLY (TREE_TYPE (argtypes[0])))\n \t{\n@@ -4178,7 +4182,8 @@ handle_access_attribute (tree *node, tree name, tree args,\n   /* Verify that the new attribute doesn't conflict with any existing\n      attributes specified on previous declarations of the same type\n      and if not, concatenate the two.  */\n-  const char code = read_only ? 'r' : write_only ? 'w' : 'x';\n+  const char code\n+    = read_only ? 'r' : write_only ? 'w' : read_write ? 'x' : '-';\n   tree new_attrs = append_access_attrs (node[0], attrs, attrstr, code, idxs);\n   if (!new_attrs)\n     return NULL_TREE;"}, {"sha": "d1c9c0b159a89d06d59dd63581d479ead7421283", "filename": "gcc/calls.c", "status": "modified", "additions": 11, "deletions": 72, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -1865,70 +1865,6 @@ maybe_complain_about_tail_call (tree call_expr, const char *reason)\n   error_at (EXPR_LOCATION (call_expr), \"cannot tail-call: %s\", reason);\n }\n \n-/* Used to define rdwr_map below.  */\n-struct rdwr_access_hash: int_hash<int, -1> { };\n-\n-/* A mapping between argument number corresponding to attribute access\n-   mode (read_only, write_only, or read_write) and operands.  */\n-typedef hash_map<rdwr_access_hash, attr_access> rdwr_map;\n-\n-/* Initialize a mapping for a call to function FNDECL declared with\n-   attribute access.  Each attribute positional operand inserts one\n-   entry into the mapping with the operand number as the key.  */\n-\n-static void\n-init_attr_rdwr_indices (rdwr_map *rwm, tree fntype)\n-{\n-  if (!fntype)\n-    return;\n-\n-  for (tree access = TYPE_ATTRIBUTES (fntype);\n-       (access = lookup_attribute (\"access\", access));\n-       access = TREE_CHAIN (access))\n-    {\n-      /* The TREE_VALUE of an attribute is a TREE_LIST whose TREE_VALUE\n-\t is the attribute argument's value.  */\n-      tree mode = TREE_VALUE (access);\n-      gcc_assert (TREE_CODE (mode) == TREE_LIST);\n-      mode = TREE_VALUE (mode);\n-      gcc_assert (TREE_CODE (mode) == STRING_CST);\n-\n-      const char *modestr = TREE_STRING_POINTER (mode);\n-      for (const char *m = modestr; *m; )\n-\t{\n-\t  attr_access acc = { };\n-\n-\t  switch (*m)\n-\t    {\n-\t    case 'r': acc.mode = acc.read_only; break;\n-\t    case 'w': acc.mode = acc.write_only; break;\n-\t    default: acc.mode = acc.read_write; break;\n-\t    }\n-\n-\t  char *end;\n-\t  acc.ptrarg = strtoul (++m, &end, 10);\n-\t  m = end;\n-\t  if (*m == ',')\n-\t    {\n-\t      acc.sizarg = strtoul (++m, &end, 10);\n-\t      m = end;\n-\t    }\n-\t  else\n-\t    acc.sizarg = UINT_MAX;\n-\n-\t  acc.ptr = NULL_TREE;\n-\t  acc.size = NULL_TREE;\n-\n-\t  /* Unconditionally add an entry for the required pointer\n-\t     operand of the attribute, and one for the optional size\n-\t     operand when it's specified.  */\n-\t  rwm->put (acc.ptrarg, acc);\n-\t  if (acc.sizarg != UINT_MAX)\n-\t    rwm->put (acc.sizarg, acc);\n-\t}\n-    }\n-}\n-\n /* Returns the type of the argument ARGNO to function with type FNTYPE\n    or null when the typoe cannot be determined or no such argument exists.  */\n \n@@ -1959,11 +1895,13 @@ append_attrname (const std::pair<int, attr_access> &access,\n      appends the attribute pointer operand even when none was specified.  */\n   size_t len = strlen (attrstr);\n \n-  const char *atname\n+  const char* const atname\n     = (access.second.mode == attr_access::read_only\n        ? \"read_only\"\n        : (access.second.mode == attr_access::write_only\n-\t  ? \"write_only\" : \"read_write\"));\n+\t  ? \"write_only\"\n+\t  : (access.second.mode == attr_access::read_write\n+\t     ? \"read_write\" : \"none\")));\n \n   const char *sep = len ? \", \" : \"\";\n \n@@ -2131,11 +2069,13 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree exp)\n \t  /* For read-only and read-write attributes also set the source\n \t     size.  */\n \t  srcsize = objsize;\n-\t  if (access.second.mode == attr_access::read_only)\n+\t  if (access.second.mode == attr_access::read_only\n+\t      || access.second.mode == attr_access::none)\n \t    {\n \t      /* For a read-only attribute there is no destination so\n \t\t clear OBJSIZE.  This emits \"reading N bytes\" kind of\n-\t\t diagnostics instead of the \"writing N bytes\" kind.  */\n+\t\t diagnostics instead of the \"writing N bytes\" kind,\n+\t\t unless MODE is none.  */\n \t      objsize = NULL_TREE;\n \t    }\n \t}\n@@ -2145,7 +2085,7 @@ maybe_warn_rdwr_sizes (rdwr_map *rwm, tree exp)\n \t diagnosed.  */\n       TREE_NO_WARNING (exp) = false;\n       check_access (exp, NULL_TREE, NULL_TREE, size, /*maxread=*/ NULL_TREE,\n-\t\t    srcsize, objsize);\n+\t\t    srcsize, objsize, access.second.mode != attr_access::none);\n \n       if (TREE_NO_WARNING (exp))\n \t/* If check_access issued a warning above, append the relevant\n@@ -2285,8 +2225,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n   /* Array for up to the two attribute alloc_size arguments.  */\n   tree alloc_args[] = { NULL_TREE, NULL_TREE };\n \n-  /* Map of attribute read_only, write_only, or read_write specifications\n-     for function arguments.  */\n+  /* Map of attribute accewss specifications for function arguments.  */\n   rdwr_map rdwr_idx;\n   init_attr_rdwr_indices (&rdwr_idx, fntype);\n \n@@ -2559,7 +2498,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n      nul-terminated strings.  */\n   maybe_warn_nonstring_arg (fndecl, exp);\n \n-  /* Check read_only, write_only, and read_write arguments.  */\n+  /* Check attribute access arguments.  */\n   maybe_warn_rdwr_sizes (&rdwr_idx, exp);\n }\n "}, {"sha": "e656e66a80c225d259c57f6d3136074d259fb29d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -2497,8 +2497,8 @@ may be diagnosed by warnings such as @option{-Wstringop-overflow},\n The @code{access} attribute specifies that a function to whose by-reference\n arguments the attribute applies accesses the referenced object according to\n @var{access-mode}.  The @var{access-mode} argument is required and must be\n-one of three names: @code{read_only}, @code{read_write}, or @code{write_only}.\n-The remaining two are positional arguments.\n+one of four names: @code{read_only}, @code{read_write}, @code{write_only},\n+or @code{none}.  The remaining two are positional arguments.\n \n The required @var{ref-index} positional argument  denotes a function\n argument of pointer (or in C++, reference) type that is subject to\n@@ -2555,6 +2555,14 @@ __attribute__ ((access (write_only, 1), access (read_only, 2))) char* strcpy (ch\n __attribute__ ((access (write_only, 1, 2), access (read_write, 3))) int fgets (char*, int, FILE*);\n @end smallexample\n \n+The access mode @code{none} specifies that the pointer to which it applies\n+is not used to access the referenced object at all.  Unless the pointer is\n+null the pointed-to object must exist and have at least the size as denoted\n+by the @var{size-index} argument.  The object need not be initialized.\n+The mode is intended to be used as a means to help validate the expected\n+object size, for example in functions that call @code{__builtin_object_size}.\n+@xref{Object Size Checking}.\n+\n @item alias (\"@var{target}\")\n @cindex @code{alias} function attribute\n The @code{alias} attribute causes the declaration to be emitted as an alias"}, {"sha": "c4127b805abd73ca10bbae45c723f788a6a9e10e", "filename": "gcc/testsuite/c-c++-common/Wsizeof-pointer-memaccess1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWsizeof-pointer-memaccess1.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -161,3 +161,5 @@ f4 (char x[64], char *y, __builtin_va_list ap)\n   snprintf (p, sizeof (buf), \"%s\", y);\n   vsnprintf (p, sizeof (buf), \"%s\", ap);\n }\n+\n+/* { dg-prune-output \"-Wuninitialized\" } */"}, {"sha": "827dac715198adefa3f626d65065cd9dfa2dbb2f", "filename": "gcc/testsuite/c-c++-common/goacc/uninit-dim-clause.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-dim-clause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-dim-clause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-dim-clause.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -4,26 +4,26 @@ void acc_parallel()\n {\n   int i, j, k;\n \n-  #pragma acc parallel num_gangs(i) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc parallel num_gangs(i) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc parallel num_workers(j) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc parallel num_workers(j) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc parallel vector_length(k) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc parallel vector_length(k) /* { dg-warning \"is used uninitialized\" } */\n   ;\n }\n \n void acc_kernels()\n {\n   int i, j, k;\n \n-  #pragma acc kernels num_gangs(i) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc kernels num_gangs(i) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc kernels num_workers(j) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc kernels num_workers(j) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc kernels vector_length(k) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc kernels vector_length(k) /* { dg-warning \"is used uninitialized\" } */\n   ;\n }"}, {"sha": "334567d33372aa9e9018d8e0266cc1be4687a806", "filename": "gcc/testsuite/c-c++-common/goacc/uninit-firstprivate-clause.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-firstprivate-clause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-firstprivate-clause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-firstprivate-clause.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -18,7 +18,7 @@ foo2 (void)\n {\n   int i;\n \n-#pragma acc parallel firstprivate (i) /* { dg-warning \"is used uninitialized in this function\" } */\n+#pragma acc parallel firstprivate (i) /* { dg-warning \"is used uninitialized\" } */\n   {\n     i = 1;\n   }"}, {"sha": "7f78d7296810af1d07ea925f59bbaa7bafed3ff5", "filename": "gcc/testsuite/c-c++-common/goacc/uninit-if-clause.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-if-clause.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-if-clause.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgoacc%2Funinit-if-clause.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -11,28 +11,28 @@ main (void)\n   bool b, b2, b3, b4;\n   int i, i2;\n \n-  #pragma acc parallel if(l) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc parallel if(l) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc parallel if(b) /* { dg-warning \"is used uninitialized in this function\" \"\" { xfail c++ } } */\n+  #pragma acc parallel if(b) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n   ;\n \n-  #pragma acc kernels if(l2) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc kernels if(l2) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc kernels if(b2) /* { dg-warning \"is used uninitialized in this function\" \"\" { xfail c++ } } */\n+  #pragma acc kernels if(b2) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n   ;\n \n-  #pragma acc data if(l3) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc data if(l3) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc data if(b3) /* { dg-warning \"is used uninitialized in this function\" \"\" { xfail c++ } } */\n+  #pragma acc data if(b3) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n   ;\n \n-  #pragma acc update if(l4) self(i) /* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma acc update if(l4) self(i) /* { dg-warning \"is used uninitialized\" } */\n   ;\n \n-  #pragma acc update if(b4) self(i2) /* { dg-warning \"is used uninitialized in this function\" \"\" { xfail c++ } } */\n+  #pragma acc update if(b4) self(i2) /* { dg-warning \"is used uninitialized\" \"\" { xfail c++ } } */\n   ;\n \n }"}, {"sha": "d0d2fa53e0374e09141e45b61bfcfbc71e26d27c", "filename": "gcc/testsuite/c-c++-common/gomp/pr70550-1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr70550-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr70550-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr70550-1.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -16,63 +16,63 @@ foo (void)\n {\n   {\n     int i;\n-    #pragma omp target defaultmap(tofrom:scalar)\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+    #pragma omp target defaultmap(tofrom:scalar)\t/* { dg-bogus \"is used uninitialized\" } */\n     {\n       i = 26;\n       bar (i);\n     }\n   }\n   {\n     T j;\n-    #pragma omp target defaultmap(tofrom:scalar)\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+    #pragma omp target defaultmap(tofrom:scalar)\t/* { dg-bogus \"is used uninitialized\" } */\n     {\n       j = 37;\n       bar (j);\n     }\n   }\n   {\n     int i;\n-    #pragma omp target\t\t\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+    #pragma omp target\t\t\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n     {\n       i = 26;\n       bar (i);\n     }\n   }\n   {\n     T j;\n-    #pragma omp target\t\t\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+    #pragma omp target\t\t\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n     {\n       j = 37;\n       bar (j);\n     }\n   }\n   {\n     int i;\n-    #pragma omp target firstprivate (i)\t\t\t/* { dg-warning \"is used uninitialized in this function\" } */\n+    #pragma omp target firstprivate (i)\t\t\t/* { dg-warning \"is used uninitialized\" } */\n     {\n       i = 26;\n       bar (i);\n     }\n   }\n   {\n     T j;\n-    #pragma omp target firstprivate (j)\t\t\t/* { dg-warning \"is used uninitialized in this function\" } */\n+    #pragma omp target firstprivate (j)\t\t\t/* { dg-warning \"is used uninitialized\" } */\n     {\n       j = 37;\n       bar (j);\n     }\n   }\n   {\n     int i;\n-    #pragma omp target private (i)\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+    #pragma omp target private (i)\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n     {\n       i = 26;\n       bar (i);\n     }\n   }\n   {\n     T j;\n-    #pragma omp target private (j)\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+    #pragma omp target private (j)\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n     {\n       j = 37;\n       bar (j);"}, {"sha": "936d907deb87cc00bb127be1179377691670e4ee", "filename": "gcc/testsuite/c-c++-common/gomp/pr70550-2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr70550-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr70550-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr70550-2.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -8,45 +8,45 @@ void\n foo (void)\n {\n   int i, j, k, l, m, n, o, p, q;\n-  #pragma omp task\t\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+  #pragma omp task\t\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n   {\n     i = 2;\n     bar (i);\n   }\n-  #pragma omp taskloop\t\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+  #pragma omp taskloop\t\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n   for (j = 0; j < 10; j++)\n     {\n       k = 7;\n       bar (k);\n     }\n-  #pragma omp task firstprivate (l)\t\t/* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma omp task firstprivate (l)\t\t/* { dg-warning \"is used uninitialized\" } */\n   {\n     l = 2;\n     bar (l);\n   }\n-  #pragma omp taskloop firstprivate (m)\t\t/* { dg-warning \"is used uninitialized in this function\" } */\n+  #pragma omp taskloop firstprivate (m)\t\t/* { dg-warning \"is used uninitialized\" } */\n   for (j = 0; j < 10; j++)\n     {\n       m = 7;\n       bar (m);\n     }\n-  #pragma omp task shared (n)\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+  #pragma omp task shared (n)\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n   {\n     n = 2;\n     bar (n);\n   }\n-  #pragma omp taskloop shared (o)\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+  #pragma omp taskloop shared (o)\t\t/* { dg-bogus \"is used uninitialized\" } */\n   for (j = 0; j < 10; j++)\n     {\n       o = 7;\n       bar (o);\n     }\n-  #pragma omp task private (p)\t\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+  #pragma omp task private (p)\t\t\t/* { dg-bogus \"is used uninitialized\" } */\n   {\n     p = 2;\n     bar (p);\n   }\n-  #pragma omp taskloop shared (q)\t\t/* { dg-bogus \"is used uninitialized in this function\" } */\n+  #pragma omp taskloop shared (q)\t\t/* { dg-bogus \"is used uninitialized\" } */\n   for (j = 0; j < 10; j++)\n     {\n       q = 7;"}, {"sha": "9fd1ea3a2626a85396c1870b13f3f22e32d4f439", "filename": "gcc/testsuite/c-c++-common/uninit-pr51010.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funinit-pr51010.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funinit-pr51010.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Funinit-pr51010.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -4,10 +4,10 @@\n int f (int j)\n {\n   int a [10];\n-  return a [j]; /* { dg-warning \"a\\\\\\[j\\\\\\]. is used uninitialized\" } */\n+  return a [j]; /* { dg-warning \"a|a\\\\\\[j\\\\\\]. is used uninitialized\" } */\n }\n int g (int j)\n {\n   int a [10];\n-  return a [j+1]; /* { dg-warning \"a\\\\\\[<unknown>\\\\\\]. is used uninitialized\" } */\n+  return a [j+1]; /* { dg-warning \"a|a\\\\\\[<unknown>\\\\\\]. is used uninitialized\" } */\n }"}, {"sha": "80b88f02dcc11304f8ce32c42d75b7c4d3d91249", "filename": "gcc/testsuite/g++.dg/20090107-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090107-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090107-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090107-1.C?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -6,7 +6,7 @@ template <typename T> struct Q1 { typedef int x; };\n template <typename T> struct Q2 {\n   typename Q1<T>::x f() {\n     int k;\n-    return k; /* { dg-warning \"'k' is used uninitialized in this function\" }  */\n+    return k; /* { dg-warning \"'k' is used uninitialized\" }  */\n   }\n };\n int foo() { return Q2<int>().f(); }"}, {"sha": "9d70fb3601b9a74102cd50153154e16e48db0c75", "filename": "gcc/testsuite/g++.dg/20090121-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090121-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090121-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2F20090121-1.C?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -7,7 +7,7 @@ private:\n   int y;\n \n public:\n-  A () { int x; y = x + 1; } /* { dg-warning \"'x' is used uninitialized in this function\" }  */\n+  A () { int x; y = x + 1; } /* { dg-warning \"'x' is used uninitialized\" }  */\n   int get_y () { return y; }\n };\n "}, {"sha": "3b9c1a36e30369102de4ac2eecf2d1b2c53eb863", "filename": "gcc/testsuite/g++.dg/ext/attr-access.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-access.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-access.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-access.C?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -39,7 +39,7 @@ void call_rop1_ror2_O0 (void)\n \n void call_rdwrp1_rdwrr2_O0 (void)\n {\n-  int32_t x[1];\n+  int32_t x[1] = { };\n \n   rdwrp1_rdwrr2 (x, x[0]);\n   rdwrp1_rdwrr2 (x, x[1]);        // { dg-warning \"writing 4 bytes into a region of size 0\" }\n@@ -78,7 +78,7 @@ void call_rop1_ror2_O1 (void)\n \n void call_rdwrp1_rdwrr2_O1 (void)\n {\n-  int32_t x[1];\n+  int32_t x[1] = { };\n   int32_t *p0 = x, &r0 = x[0];\n   int32_t *p1 = (int32_t*)((char*)p0 + 1);\n   int32_t &r2 = *(int32_t*)((char*)p1 + 1);"}, {"sha": "729ad45d6ac2074579665fc44a61d008a80a599f", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-52.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -95,3 +95,6 @@ void ptr_idx_range (void)\n   i = SR (3, 4);\n   T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of 'int\\\\\\[3]'\" }\n }\n+\n+/* Some of the invalid accesses above also trigger -Wuninitialized.\n+   { dg-prune-output \"\\\\\\[-Wuninitialized\" }  */"}, {"sha": "80db314b3933c450b2859c43115c2d097cdd0e22", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-53.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-53.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -95,3 +95,6 @@ void ptr_idx_range (void)\n   i = SR (3, 4);\n   T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of 'int\\\\\\[3]'\" }\n }\n+\n+/* Some of the invalid accesses above also trigger -Wuninitialized.\n+   { dg-prune-output \"\\\\\\[-Wuninitialized\" }  */"}, {"sha": "5df5710c1d9ae332722422a97dff95bb63aa6c22", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-54.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-54.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -10,9 +10,9 @@ int f0 (void)\n   return p[2];      // { dg-warning \"-Warray-bounds\" }\n }\n \n-int f1 (void)\n+int f1 (int j)\n {\n-  int i;\n+  int i = j;\n   int *p = &i;\n   return p[2];      // { dg-warning \"-Warray-bounds\" }\n }\n@@ -22,3 +22,5 @@ int f2 (int i)\n   int *p = &i;\n   return p[2];      // { dg-warning \"-Warray-bounds\" }\n }\n+\n+/* { dg-prune-output \"-Wuninitialized\" } */"}, {"sha": "cb8aeb9b5d9212bee5d6caece6ed93f3abc75459", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-33.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-33.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,40 @@\n+/* PR middle-end/82456 - missing -Wstringop-overflow on strcpy reading past\n+   the end of an array\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void fcst (char *d)\n+{\n+  char a[2] = \"0\";\n+\n+  __builtin_strcpy (d, a + 3);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+}\n+\n+void frng (char *d, int i)\n+{\n+  char a[2] = \"0\";\n+\n+  if (i < 3)\n+    i = 3;\n+\n+  __builtin_strcpy (d, a + i);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+}\n+\n+void gcst (char *d)\n+{\n+  char a[2] = \"0\";\n+\n+  __builtin_strcpy (d, a + 2);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+}\n+\n+void grng (char *d, int i)\n+{\n+  char a[2] = \"0\";\n+\n+  if (i < 2)\n+    i = 2;\n+\n+  __builtin_strcpy (d, a + i);    // { dg-warning \"\\\\\\[-W(array-bounds|stringop-overflow)\" }\n+}\n+\n+/* { dg-prune-output \"-Wuninitialized\" } */"}, {"sha": "d983f2fac06e77b5fcb8ac46b5500905dac89279", "filename": "gcc/testsuite/gcc.dg/attr-access-none.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-none.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,38 @@\n+/* Test to verify the handling of attribute access (none).\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -ftrack-macro-expansion=0\" } */\n+\n+int __attribute__ ((access (none, 1)))\n+fnone_pv1 (void*);\n+\n+void nowarn_fnone_pv1 (void)\n+{\n+  int x;\n+  fnone_pv1 (&x);\n+}\n+\n+\n+int __attribute__ ((access (none, 1)))\n+fnone_pcv1 (const void*);\n+\n+void nowarn_fnone_pcv1 (void)\n+{\n+  char a[2];\n+  fnone_pcv1 (a);\n+}\n+\n+\n+int __attribute__ ((access (none, 1, 2)))\n+fnone_pcv1_2 (const void*, int);  // { dg-message \"in a call to function 'fnone_pcv1_2' declared with attribute 'none \\\\\\(1, 2\\\\\\)'\" }\n+\n+void nowarn_fnone_pcv1_2 (void)\n+{\n+  char a[2];\n+  fnone_pcv1_2 (a, 2);\n+}\n+\n+void warn_fnone_pcv1_2 (void)\n+{\n+  char a[3];\n+  fnone_pcv1_2 (a, 4);        // { dg-warning \"expecting 4 bytes in a region of size 3\" }\n+}"}, {"sha": "71175d05ca556c451f30ff43c6a81fe721d8c3cc", "filename": "gcc/testsuite/gcc.dg/attr-access-read-only.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-only.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -11,7 +11,7 @@ int  __attribute__ ((access ()))\n access___v (void);     // { dg-error \"wrong number of arguments specified for 'access' attribute\" }\n \n int  __attribute__ ((access (rdonly)))\n-rdonly_spelling (void);   // { dg-error \"attribute .access. invalid mode 'rdonly'; expected one of 'read_only', 'read_write', or 'write_only'\" }\n+rdonly_spelling (void);   // { dg-error \"attribute .access. invalid mode 'rdonly'; expected one of 'read_only', 'read_write', 'write_only', or 'none'\" }\n \n int  __attribute__ ((access (read_only)))\n rdonly_v_all (void);   // { dg-error \"attribute .access\\\\(read_only\\\\). missing an argument\" }"}, {"sha": "849d9f1cf67a6ea2984cad5346cc80b6617f6704", "filename": "gcc/testsuite/gcc.dg/attr-access-read-write.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-read-write.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -10,7 +10,7 @@ int  __attribute__ ((access ()))\n access___v (void);     /* { dg-error \"wrong number of arguments specified for 'access' attribute\" } */\n \n int  __attribute__ ((access (rdwr)))\n-rdwr_spelling (void);   /* { dg-error \"attribute .access. invalid mode 'rdwr'; expected one of 'read_only', 'read_write', or 'write_only'\" } */\n+rdwr_spelling (void);   /* { dg-error \"attribute .access. invalid mode 'rdwr'; expected one of 'read_only', 'read_write', 'write_only', or 'none'\" } */\n \n int  __attribute__ ((access (read_write)))\n rdwr_v_all (void);   /* { dg-error \"attribute .access\\\\(read_write\\\\). missing an argument\" } */"}, {"sha": "2718b0db4564f0b99ec6d19e43e638a7b9fa0ed2", "filename": "gcc/testsuite/gcc.dg/attr-access-write-only.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-write-only.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-write-only.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-access-write-only.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -11,7 +11,7 @@ int  __attribute__ ((access ()))\n access___v (void);     // { dg-error \"wrong number of arguments specified for 'access' attribute\" }\n \n int  __attribute__ ((access (wronly)))\n-wronly_spelling (void);   // { dg-error \"attribute .access. invalid mode 'wronly'; expected one of 'read_only', 'read_write', or 'write_only'\" }\n+wronly_spelling (void);   // { dg-error \"attribute .access. invalid mode 'wronly'; expected one of 'read_only', 'read_write', 'write_only', or 'none'\" }\n \n int  __attribute__ ((access (read_only)))\n wronly_v_all (void);   // { dg-error \"attribute .access\\\\(read_only\\\\). missing an argument\" }"}, {"sha": "dd71dde9eac7318887ea0eb16991cc607f1feb46", "filename": "gcc/testsuite/gcc.dg/pr71581.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr71581.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Fpr71581.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr71581.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -6,19 +6,19 @@ _Complex float\n f1 (void)\n {\n   float x;\n-  return x;\t/* { dg-warning \"is used uninitialized in this function\" } */\n+  return x;\t/* { dg-warning \"is used uninitialized\" } */\n }\n \n _Complex double\n f2 (void)\n {\n   double x;\n-  return x;\t/* { dg-warning \"is used uninitialized in this function\" } */\n+  return x;\t/* { dg-warning \"is used uninitialized\" } */\n }\n \n _Complex int\n f3 (void)\n {\n   int x;\n-  return x;\t/* { dg-warning \"is used uninitialized in this function\" } */\n+  return x;\t/* { dg-warning \"is used uninitialized\" } */\n }"}, {"sha": "24b1767975bfe869553c990b5bb1f84f9a718622", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-6.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-6.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -25,3 +25,6 @@ void f(void)\n    value-numbering, removing the load altogether.\n    ???  We now do this after CPP re-writes a into SSA form.  */\n /* { dg-final { scan-tree-dump-times \"VIEW_CONVERT_EXPR\" 1 \"ccp1\" } } */\n+\n+/* The invalid access above may also trigger -Wuninitialized.\n+   { dg-prune-output \"-Wuninitialized\" } */"}, {"sha": "8ee10c27aba17cde00a37a51039011d9e4084036", "filename": "gcc/testsuite/gcc.dg/uninit-15.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-15.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -10,7 +10,7 @@\n inline int\n foo (int i)\n {\n-  if (i) /* { dg-warning \"used uninitialized in this function\" \"\" } */\n+  if (i) /* { dg-warning \"used uninitialized\" } */\n     return 1;\n   return 0;\n }"}, {"sha": "cdc05128dfdc9dc961d1b04662362614bd516694", "filename": "gcc/testsuite/gcc.dg/uninit-32.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-32.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,312 @@\n+/* PR middle-end/10138 - warn for uninitialized arrays passed as const*\n+   arguments\n+   { dg-do compile }\n+   { dg-options \"-O -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* alloca (size_t);\n+void* malloc (size_t);\n+void* realloc (void*, size_t);\n+\n+void fpi (int*);\n+void fpci (const int*);\n+void fpcv (const void*);\n+\n+\n+void nowarn_scalar_fpi (void)\n+{\n+  int x;\n+  fpi (&x);\n+}\n+\n+void nowarn_scalar_plus_cst_fpi (void)\n+{\n+  int x;\n+  // This deserves a warning other than -Wuninitialized.\n+  fpi (&x + 1);\n+}\n+\n+void nowarn_scalar_plus_var_fpi (int i)\n+{\n+  int x;\n+  // Same as above, this deserves a warning other than -Wuninitialized.\n+  fpi (&x + i);\n+}\n+\n+void nowarn_array_assign_fpci (void)\n+{\n+  int a[2];\n+  a[0] = 0;\n+  fpci (a);\n+}\n+\n+void nowarn_array_assign_plus_cst_fpci (void)\n+{\n+  int a[4];\n+  a[1] = 0;\n+  a[2] = 1;\n+  fpci (a + 1);\n+}\n+\n+void nowarn_array_init_fpci (void)\n+{\n+  int a[4] = { 0 };\n+  fpci (a);\n+}\n+\n+void nowarn_array_compound_fpi (void)\n+{\n+  fpi ((int[2]){ 1 });\n+}\n+\n+void nowarn_array_compound_fpci (void)\n+{\n+  fpci ((int[3]){ 1 });\n+}\n+\n+void warn_array_fpci (void)\n+{\n+  int a[4];                   // { dg-message \"declared here\" }\"\n+  fpci (a);                   // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_array_plus_cst_fpci (void)\n+{\n+  int a[4];\n+  fpci (a + 1);               // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_array_plus_var_fpci (int i)\n+{\n+  int a[4];\n+  fpci (a + i);               // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void nowarn_array_end_fpci (void)\n+{\n+  int a[4];\n+  /* This should be diagnosed by a warning other than -Wuninitialized\n+     because the just-past-the-end pointer cannot be dereferenced and\n+     the function doesn't take any other pointer to tell where the start\n+     of the array is.  -Wuninitialized isn't appropriate because there\n+     is nothing to initialize at that offset.  */\n+  fpci (a + 4);\n+}\n+\n+void warn_matrix_fpcv (void)\n+{\n+  int a[2][2];\n+  fpci (a[1]);                // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_scalar_fpcv (void)\n+{\n+  int i;\n+  fpci (&i);                  // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_scalar_plus_cst_fpcv (void)\n+{\n+  int x;\n+  /* Same as above, this deserves a warning other than -Wuninitialized\n+     for passing the function a past-the-end pointer with no other\n+     argument.  */\n+  fpci (&x + 1);\n+}\n+\n+void warn_scalar_plus_var_fpcv (int i)\n+{\n+  int x;\n+  fpci (&x + i);              // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void nowarn_struct_assign_fpci (void)\n+{\n+  struct { int a, b; } s;\n+  s.a = 0;\n+  fpci (&s.a);\n+}\n+\n+void warn_struct_assign_fpci (void)\n+{\n+  struct { int a, b; } s;\n+  s.a = 0;\n+  fpci (&s.b);                // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void nowarn_struct_init_fpci (void)\n+{\n+  struct { int a, b; } s = { 0 };\n+  fpci (&s.a);\n+  fpci (&s.b);\n+}\n+\n+void nowarn_struct_compound_fpci (void)\n+{\n+  struct S { int a, b; };\n+  fpci (&(struct S){ }.a);\n+  fpci (&(struct S){ }.b);\n+}\n+\n+/* Verify that passing a just-past-the-end pointer to a const pointer\n+   argument to a function that takes another argument is not diagnosed\n+   since the two arguments together could outline a range.  */\n+void nowarn_fp_p (void)\n+{\n+  extern void fpi_pci (int*, const int*);\n+\n+  {\n+    int i;\n+    fpi_pci (&i, &i + 1);\n+  }\n+  {\n+    int j;\n+    fpi_pci (&j + 1, &j + 1);\n+  }\n+\n+  extern void fpc_pcc (char*, const char*);\n+\n+  {\n+    char a[2];\n+    fpc_pcc (a, a + 2);\n+  }\n+  {\n+    char a[3];\n+    fpc_pcc (a, a + 3);\n+  }\n+\n+  extern void fpcc_pcc (const char*, const char*);\n+\n+  {\n+    char a[4];\n+    fpcc_pcc (a + 4, a + 4);\n+  }\n+}\n+\n+\n+/* Verify passing addresses of empty uninitialized objects doesn't\n+   trigger a warning.  */\n+void nowarn_fpcEmpty (void)\n+{\n+  struct Empty { };\n+  extern void fpcEmpty (const struct Empty*);\n+\n+  /* Since Empty has no members warning for it isn't really necessary.\n+     See also PR 38908.  */\n+  struct Empty s;\n+  fpcEmpty (&s);\n+}\n+\n+\n+/* Verify passing addresses of uninitialized objects to functions\n+   declared without a proptotype doesn't trigger a warning.  */\n+void nowarn_noproto (void)\n+{\n+  extern void fnoproto ();\n+  int i, a[2];\n+\n+  fnoproto (&i, a, a + 2);\n+}\n+\n+\n+/* Verify passing addresses of uninitialized objects to variadic\n+   functions doesn't trigger a warning.  */\n+void nowarn_vararg (void)\n+{\n+  extern void fvararg (int, ...);\n+\n+  int i, a[2];\n+\n+  fvararg (0, &i, a, a + 2);\n+}\n+\n+\n+void nowarn_alloca_assign_fpci (unsigned n)\n+{\n+  int *p = (int*)alloca (n);\n+  p[0] = 0;\n+  fpci (p);\n+}\n+\n+void nowarn_alloca_assign_plus_cst_fpci (unsigned n)\n+{\n+  int *p = (int*)alloca (n);\n+  p[1] = 0;\n+  p[2] = 1;\n+  fpci (p + 1);\n+}\n+\n+void warn_alloca_fpci (unsigned n)\n+{\n+  int *p = (int*)alloca (n);\n+  fpci (p);                   // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_alloca_assign_plus_cst_fpci (unsigned n)\n+{\n+  int *p = (int*)alloca (n);\n+  p[1] = 0;\n+  p[2] = 1;\n+  fpci (p + 3);               // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+\n+void nowarn_vla_assign_fpci (unsigned n)\n+{\n+  int a[n];\n+  a[0] = 0;\n+  fpci (a);\n+}\n+\n+void nowarn_vla_assign_plus_cst_fpci (unsigned n)\n+{\n+  int vla[n];\n+  vla[1] = 0;\n+  vla[2] = 1;\n+  fpci (vla + 1);\n+}\n+\n+void warn_vla_fpci (unsigned n)\n+{\n+  int vla[n];                 // { dg-message \"declared here\" \"pr?????\" { xfail *-*-* } }\"\n+  fpci (vla);                 // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_vla_assign_plus_cst_fpci (unsigned n)\n+{\n+  int vla[n];                 // { dg-message \"declared here\" \"pr?????\" { xfail *-*-* } }\"\n+  vla[1] = 0;\n+  vla[2] = 1;\n+  fpci (vla + 3);             // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+\n+void nowarn_malloc_assign_fpci (unsigned n)\n+{\n+  int *p = (int*)malloc (n);\n+  p[0] = 0;\n+  fpci (p);\n+}\n+\n+void nowarn_malloc_assign_plus_cst_fpci (unsigned n)\n+{\n+  int *p = (int*)malloc (n);\n+  p[1] = 0;\n+  p[2] = 1;\n+  fpci (p + 1);\n+}\n+\n+void warn_malloc_fpci (unsigned n)\n+{\n+  int *p = (int*)malloc (n);\n+  fpci (p);                   // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}\n+\n+void warn_malloc_assign_plus_cst_fpci (unsigned n)\n+{\n+  int *p = (int*)malloc (n);  // { dg-message \"allocated here\" \"pr?????\" { xfail *-*-* } }\"\n+  p[1] = 0;\n+  p[2] = 1;\n+  fpci (p + 3);               // { dg-warning \"\\\\\\[-Wmaybe-uninitialized\" }\n+}"}, {"sha": "a45f18dd6ce1d3eb8d5849d356883a5494eb8551", "filename": "gcc/testsuite/gcc.dg/uninit-33.c", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-33.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,145 @@\n+/* PR middle-end/10138 - warn for uninitialized arrays passed as const*\n+   arguments\n+   Verify that passing pointers to uninitialized objects to arguments\n+   to functions declared with attribute access is diagnosed where expected.\n+   { dg-do compile }\n+   { dg-options \"-O -Wall\" } */\n+\n+#define RO(...) __attribute__ ((access (read_only, __VA_ARGS__)))\n+#define RW(...) __attribute__ ((access (read_write, __VA_ARGS__)))\n+#define WO(...) __attribute__ ((access (write_only, __VA_ARGS__)))\n+\n+RO (1) void fpri (int*);      // { dg-message \"in a call to 'fpri' declared with attribute 'access \\\\\\(read_only, 1\\\\\\)' here\" }\n+\n+RO (1) void fpcri (const int*);\n+\n+RO (1, 2) void fpcri1_2 (const int*, int);\n+\n+\n+void warn_scalar_fpri (void)\n+{\n+  int i;                      // { dg-message \"declared here\" }\n+  fpri (&i);                  // { dg-warning \"'i' is used uninitialized\" }\n+}\n+\n+void nowarn_scalar_plus_fpri (void)\n+{\n+  int i;\n+  /* This gets a -Wstringop-overflow for reading past the end but not\n+     -Wuninitialized because there's nothing to initialize there.  */\n+  fpri (&i + 1);              // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+void nowarn_array_assign_fpcri (void)\n+{\n+  int a[2];\n+  a[0] = 0;\n+  fpcri (a);\n+}\n+\n+void nowarn_array_init_fpcri (void)\n+{\n+  int a[4] = { 0 };\n+  fpcri (a);\n+}\n+\n+void nowarn_array_compound_fpri (void)\n+{\n+  fpri ((int[2]){ 0 });\n+}\n+\n+void nowarn_array_compound_fpcri (void)\n+{\n+  fpcri ((int[3]){ 1 });\n+}\n+\n+void warn_scalar_fpcri (void)\n+{\n+  int i;\n+  fpcri (&i);                 // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void warn_array_fpcri (void)\n+{\n+  int a[4];\n+  fpcri (a);                  // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void warn_array_plus_cst_fpcri (void)\n+{\n+  int a[4];\n+  fpcri (a + 1);              // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void warn_array_plus_var_fpcri (int i)\n+{\n+  int a[4];\n+  fpcri (a + i);              // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void nowarn_struct_assign_fpcri (void)\n+{\n+  struct { int a, b; } s;\n+  s.a = 0;\n+  fpcri (&s.a);\n+}\n+\n+void warn_struct_assign_fpcri (void)\n+{\n+  struct { int a, b; } s;\n+  s.a = 0;\n+  fpcri (&s.b);               // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void nowarn_struct_init_fpcri (void)\n+{\n+  struct { int a, b; } s = { 0 };\n+  fpcri (&s.a);\n+  fpcri (&s.b);\n+}\n+\n+void nowarn_struct_compound_fpcri (void)\n+{\n+  struct S { int a, b; };\n+  fpcri (&(struct S){ }.a);\n+  fpcri (&(struct S){ }.b);\n+}\n+\n+\n+void nowarn_scalar_fpcri1_2 (void)\n+{\n+  int i;\n+  fpcri1_2 (&i, 0);\n+}\n+\n+void nowarn_array_assign_fpcri1_2 (void)\n+{\n+  int a[2];\n+  a[0] = 0;\n+  fpcri1_2 (a, 1);\n+}\n+\n+void nowarn_array_assign_fpcri1_2_plus_cst (void)\n+{\n+  int a[3];\n+  a[1] = 0;\n+  fpcri1_2 (a + 1, 1);\n+}\n+\n+void nowarn_array_init_fpcri1_2 (void)\n+{\n+  int a[4] = { 0 };\n+  fpcri1_2 (a, 2);\n+}\n+\n+void warn_array_fpcri1_2_rd1 (void)\n+{\n+  int a[4];\n+  fpcri1_2 (a, 1);            // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void warn_array_fpcri1_2_rd2 (void)\n+{\n+  int a[4];\n+  fpcri1_2 (a, 2);            // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}"}, {"sha": "9de618347ebcc778f229ba0ce00c6fed9775cfae", "filename": "gcc/testsuite/gcc.dg/uninit-34.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-34.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,58 @@\n+/* PR middle-end/10138 - warn for uninitialized arrays passed as const*\n+   arguments\n+   Verify that passing pointers to uninitialized objects to arguments\n+   to functions declared with attribute access is diagnosed where expected.\n+   { dg-do compile }\n+   { dg-options \"-O -Wall\" } */\n+\n+#define RW(...) __attribute__ ((access (read_write, __VA_ARGS__)))\n+\n+RW (1) RW (3) void\n+f4pi (int*, int*, int*, int*);    // { dg-message \"in a call to 'f4pi' declared with attribute 'access \\\\\\(read_write, \\[13\\]\\\\\\)'\" }\n+\n+\n+void nowarn_scalar (void)\n+{\n+  int i1 = 0, i2, i3 = 1, i4;\n+  f4pi (&i1, &i2, &i3, &i4);\n+}\n+\n+void warn_scalar_1 (void)\n+{\n+  int i1;                         // { dg-message \"declared here\" }\n+  int i2, i3 = 1, i4;\n+\n+  f4pi (&i1, &i2, &i3, &i4);      // { dg-warning \"'i1' may be used uninitialized\" }\n+}\n+\n+void warn_scalar_2 (void)\n+{\n+  int j1 = 0, j2, j4;\n+  int j3;\n+\n+  f4pi (&j1, &j2, &j3, &j4);      // { dg-warning \"'j3' may be used uninitialized\" }\n+}\n+\n+\n+void nowarn_array_init (void)\n+{\n+  int a1[4] = { 0 }, a2[5], a3[6] = { 0 }, a4[7];\n+\n+  f4pi (a1, a2, a3, a4);\n+}\n+\n+void warn_array_1 (void)\n+{\n+  int a1[4];                  // { dg-message \"'a1' declared here\" }\n+  int a2[5], a3[6] = { 0 }, a4[7];\n+\n+  f4pi (a1, a2, a3, a4);      // { dg-warning \"'a1' may be used uninitialized\" }\n+}\n+\n+void warn_array_2 (void)\n+{\n+  int a1[4] = { 0 }, a2[5], a4[7];\n+  int a3[6];                  // { dg-message \"'a3' declared here\" }\n+\n+  f4pi (a1, a2, a3, a4);      // { dg-warning \"'a3' may be used uninitialized\" }\n+}"}, {"sha": "9524e7ad1b98432f92b12bd8cd03c7891917dfee", "filename": "gcc/testsuite/gcc.dg/uninit-36.c", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-36.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,237 @@\n+/* PR middle-end/10138 - warn for uninitialized arrays passed as const*\n+   arguments\n+   Verify that passing pointers to uninitialized objects to const\n+   arguments to built-ins is diagnosed where expected.\n+   { dg-do compile }\n+   { dg-options \"-O -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* alloca (size_t);\n+void* malloc (size_t);\n+void* realloc (void*, size_t);\n+\n+void* memcpy (void*, const void*, size_t);\n+char* strcpy (char*, const char*);\n+size_t strlen (const char*);\n+\n+void sink (void*);\n+\n+void nowarn_array_memcpy (void *d, unsigned n)\n+{\n+  int a[2];\n+  /* Diagnose this?  */\n+  memcpy (d, a, n /* Non-constant to avoid folding into MEM_REF.  */);\n+}\n+\n+void nowarn_array_plus_cst_memcpy (void *d, unsigned n)\n+{\n+  int a[3];\n+  /* Diagnose this?  */\n+  memcpy (d, a + 1, n);\n+}\n+\n+void nowarn_array_plus_var_memcpy (void *d, unsigned n, int i)\n+{\n+  int a[4];\n+  /* Diagnose this?  */\n+  memcpy (d, a + i, n);\n+}\n+\n+void nowarn_array_assign_memcpy (char *d, unsigned n)\n+{\n+  int a[3];\n+  a[1] = 3;\n+  memcpy (d, a, n);\n+}\n+\n+void nowarn_array_init_memcpy (char *d, unsigned n)\n+{\n+  int a[4] = { 0 };\n+  memcpy (d, a, n);\n+}\n+\n+void nowarn_array_compound_memcpy (void *d, unsigned n)\n+{\n+  memcpy (d, (int[2]){ 0 }, n);\n+}\n+\n+void nowarn_struct_assign_memcpy (void *d, unsigned n)\n+{\n+  struct S { int a, b, c, d; } s;\n+  s.b = 1;\n+  s.d = 2;\n+  memcpy (d, &s, n);\n+}\n+\n+\n+void nowarn_array_init_strcpy (char *d[], unsigned n)\n+{\n+  char a[8] = \"012\";\n+\n+  strcpy (d[0], a);\n+  strcpy (d[1], a + 1);\n+  strcpy (d[1], a + 2);\n+  strcpy (d[1], a + 3);\n+  strcpy (d[1], a + 4);\n+  strcpy (d[1], a + 5);\n+  strcpy (d[1], a + 6);\n+  strcpy (d[1], a + 7);\n+}\n+\n+\n+void nowarn_array_assign_strcpy (char *d[], unsigned n)\n+{\n+  char a[8];\n+  a[0] = '0';\n+  a[1] = '1';\n+  a[2] = '2';\n+  a[3] = '\\0';\n+\n+  strcpy (d[0], a);\n+  strcpy (d[1], a + 1);\n+  strcpy (d[1], a + 2);\n+  strcpy (d[1], a + 3);\n+}\n+\n+void warn_array_plus_cst_strcpy (char *d, unsigned n)\n+{\n+  char a[8];\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  a[3] = '\\0';\n+\n+  strcpy (d, a + 4);          // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+  strcpy (d, a + 5);          // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+  strcpy (d, a + 6);          // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+  strcpy (d, a + 7);          // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+void nowarn_array_plus_var_strcpy (char *d, int i)\n+{\n+  char a[8];\n+  a[0] = '1';\n+  a[1] = '2';\n+  a[2] = '3';\n+  a[3] = '\\0';\n+\n+  strcpy (d, a + i);\n+}\n+\n+\n+size_t nowarn_array_assign_strlen (const char *s)\n+{\n+  char a[8];\n+  a[0] = s[0];\n+  a[1] = s[1];\n+  a[2] = s[2];\n+  a[3] = s[3];\n+\n+  size_t n = 0;\n+\n+  n += strlen (a);\n+  n += strlen (a + 1);\n+  n += strlen (a + 2);\n+  n += strlen (a + 3);\n+  return n;\n+}\n+\n+size_t warn_array_plus_cst_strlen (const char *s)\n+{\n+  char a[8];\n+  a[0] = s[0];\n+  a[1] = s[1];\n+  a[2] = s[2];\n+  a[3] = s[3];\n+\n+  return strlen (a + 4);      // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+size_t nowarn_array_plus_var_strlen (const char *s, int i)\n+{\n+  char a[8];\n+  a[0] = s[0];\n+  a[1] = s[1];\n+  a[2] = s[2];\n+  a[3] = s[3];\n+\n+  return strlen (a + i);\n+}\n+\n+\n+size_t nowarn_alloca_assign_strlen (int i)\n+{\n+  char *p = (char*)alloca (8);\n+  p[i] = '\\0';\n+  return strlen (p);\n+}\n+\n+size_t nowarn_alloca_escape_strlen (int i)\n+{\n+  char *p = (char*)alloca (8);\n+  sink (p);\n+  return strlen (p);\n+}\n+\n+size_t warn_alloca_strlen (void)\n+{\n+  char *p = (char*)alloca (8);\n+  return strlen (p);          // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+\n+size_t nowarn_malloc_assign_strlen (int i)\n+{\n+  char *p = (char*)malloc (8);\n+  p[i] = '\\0';\n+  return strlen (p);\n+}\n+\n+size_t nowarn_malloc_escape_strlen (int i)\n+{\n+  char *p = (char*)malloc (8);\n+  sink (p);\n+  return strlen (p);\n+}\n+\n+size_t warn_malloc_strlen (void)\n+{\n+  char *p = (char*)malloc (8);\n+  return strlen (p);          // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}\n+\n+\n+size_t nowarn_realloc_strlen (void *p)\n+{\n+  char *q = (char*)realloc (p, 8);\n+  return strlen (q);\n+}\n+\n+\n+size_t nowarn_vla_assign_strlen (int n, int i)\n+{\n+  char vla[n];\n+  vla[i] = '\\0';\n+  return strlen (vla);\n+}\n+\n+size_t nowarn_vla_strcpy_strlen (int n, const char *s, int i)\n+{\n+  char vla[n];\n+  strcpy (vla, s);\n+  return strlen (vla + i);\n+}\n+\n+size_t nowarn_vla_escape_strlen (int n, int i)\n+{\n+  char vla[n];\n+  sink (vla);\n+  return strlen (vla);\n+}\n+\n+size_t warn_vla_strlen (unsigned n)\n+{\n+  char vla[n];\n+  return strlen (vla);        // { dg-warning \"\\\\\\[-Wuninitialized\" }\n+}"}, {"sha": "b01e4fa945a33d1f294590d7d04ee37cfea0686f", "filename": "gcc/testsuite/gcc.dg/uninit-B-O0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-B-O0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-B-O0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-B-O0.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -9,7 +9,7 @@ void\n baz (void)\n {\n   int i;\n-  if (i) /* { dg-warning \"'i' is used uninitialized in this function\" } */\n+  if (i) /* { dg-warning \"'i' is used uninitialized\" } */\n     bar (i);\n   foo (&i);\n }"}, {"sha": "e4b68ba47b12b04d25fb2d6611868c661a2f8f3e", "filename": "gcc/testsuite/gcc.dg/uninit-I-O0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I-O0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I-O0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I-O0.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -4,5 +4,5 @@\n int sys_msgctl (void)\n {\n   struct { int mode; } setbuf;\n-  return setbuf.mode; /* { dg-warning \"'setbuf\\.mode' is used uninitialized in this function\" } */\n+  return setbuf.mode; /* { dg-warning \"'setbuf\\.mode' is used uninitialized\" } */\n }"}, {"sha": "e9e264deb5a46a8a0b1f9f0abd68bf8d0111bfeb", "filename": "gcc/testsuite/gcc.dg/uninit-pr19430-O0.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr19430-O0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr19430-O0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr19430-O0.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -6,7 +6,7 @@ extern void baz (int *);\n int\n foo (int i)\n {\n-  int j; /* { dg-warning \"'j' may be used uninitialized in this function\" \"uninitialized\" { xfail *-*-* } } */\n+  int j; /* { dg-warning \"'j' may be used uninitialized\" \"uninitialized\" { xfail *-*-* } } */\n \n   if (bar (i)) {\n     baz (&j);\n@@ -18,7 +18,7 @@ foo (int i)\n \n int foo2( void ) {\n   int rc;\n-  return rc; /* { dg-warning \"'rc' is used uninitialized in this function\" } */\n+  return rc; /* { dg-warning \"'rc' is used uninitialized\" } */\n   *&rc = 0;\n }\n \n@@ -27,16 +27,16 @@ void frob(int *pi);\n \n int main(void)\n {\n-  int i; \n-  printf(\"i = %d\\n\", i); /* { dg-warning \"'i' is used uninitialized in this function\" } */\n+  int i;\n+  printf(\"i = %d\\n\", i); /* { dg-warning \"'i' is used uninitialized\" } */\n   frob(&i);\n \n   return 0;\n }\n \n void foo3(int*);\n-void bar3(void) { \n-  int x; \n-  if(x) /* { dg-warning \"'x' is used uninitialized in this function\" } */\n-    foo3(&x); \n+void bar3(void) {\n+  int x;\n+  if(x) /* { dg-warning \"'x' is used uninitialized\" } */\n+    foo3(&x);\n }"}, {"sha": "417cdc6331444b24ae13e0f69034450eb6a4cc11", "filename": "gcc/testsuite/gcc.dg/uninit-pr19430.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr19430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr19430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr19430.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -5,9 +5,9 @@ extern void baz (int *);\n int\n foo (int i)\n {\n-  int j; /* { dg-warning \"'j' may be used uninitialized in this function\" \"uninitialized\" { xfail *-*-* } } */\n+  int j; /* { dg-warning \"'j' may be used uninitialized\" \"uninitialized\" { xfail *-*-* } } */\n \n-  if (bar (i)) { \n+  if (bar (i)) {\n     baz (&j);\n   } else {\n   }\n@@ -19,7 +19,7 @@ foo (int i)\n \n int foo2( void ) {\n   int rc;\n-  return rc;  /* { dg-warning \"'rc' is used uninitialized in this function\" } */\n+  return rc;  /* { dg-warning \"'rc' is used uninitialized\" } */\n   *&rc = 0;\n }\n \n@@ -28,16 +28,16 @@ void frob(int *pi);\n \n int main(void)\n {\n-  int i; \n-  printf(\"i = %d\\n\", i); /* { dg-warning \"'i' is used uninitialized in this function\" } */\n+  int i;\n+  printf(\"i = %d\\n\", i); /* { dg-warning \"'i' is used uninitialized\" } */\n   frob(&i);\n \n   return 0;\n }\n \n void foo3(int*);\n-void bar3(void) { \n-  int x; \n-  if(x) /* { dg-warning \"'x' is used uninitialized in this function\" \"uninitialized\" } */\n-    foo3(&x); \n+void bar3(void) {\n+  int x;\n+  if(x) /* { dg-warning \"'x' is used uninitialized\" \"uninitialized\" } */\n+    foo3(&x);\n }"}, {"sha": "47d16c5bbbacffd8b09e3e3a4a1470d666e541aa", "filename": "gcc/testsuite/gcc.dg/uninit-pr95136.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr95136.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr95136.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr95136.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -0,0 +1,63 @@\n+/* PR middle-end/95136 - missing -Wuninitialized on an array access with\n+   a variable offset\n+   { dg-do compile }\n+   { dg-options \"-O -Wall\" } */\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+NOIPA int a1_addr_varidx_plus_cst (int i)\n+{\n+  int a[4];              // { dg-message \"'a' declared here\" }\n+  int *p = &a[i + 1];\n+  return *p;             // { dg-warning \"'a|a\\\\\\[<unknown>]' is used uninitialized\" }\n+}\n+\n+NOIPA int a1_plus_addr_varidx_cst (int i)\n+{\n+  int a[4];              // { dg-message \"'a' declared here\" }\n+  int *p = &a[i] + 1;\n+  return *p;             // { dg-warning \"'a' is used uninitialized\" }\n+}\n+\n+NOIPA int a1_plus_addr_cstidx_var (int i)\n+{\n+  int a[4];              // { dg-message \"'a' declared here\" }\n+  int *p = &a[1] + i;\n+  return *p;             // { dg-warning \"'a' is used uninitialized\" }\n+}\n+\n+NOIPA int a1_plus_addr_varidx_var (int i, int j)\n+{\n+  int a[4];              // { dg-message \"'a' declared here\" }\n+  int *p = &a[i] + j;\n+  return *p;             // { dg-warning \"'a' is used uninitialized\" }\n+}\n+\n+\n+NOIPA int a2_addr_varidx_plus_cst (int i, int j)\n+{\n+  int a[4][4];           // { dg-message \"'a' declared here\" }\n+  int *p = &a[i + 1][j + 1];\n+  return *p;             // { dg-warning \"'a|a\\\\\\[<unknown>]\\\\\\[<unknown>]' is used uninitialized\" }\n+}\n+\n+NOIPA int a2_plus_addr_varidx_cst (int i, int j)\n+{\n+  int a[4][4];           // { dg-message \"'a' declared here\" }\n+  int *p = &a[i][j] + 1;\n+  return *p;             // { dg-warning \"'a' is used uninitialized\" }\n+}\n+\n+NOIPA int a2_plus_addr_cstidx_var (int i)\n+{\n+  int a[4][4];           // { dg-message \"'a' declared here\" }\n+  int *p = &a[1][1] + i;\n+  return *p;             // { dg-warning \"'a' is used uninitialized\" }\n+}\n+\n+NOIPA int a2_plus_addr_varidx_var (int i, int j, int k)\n+{\n+  int a[4][4];           // { dg-message \"'a' declared here\" }\n+  int *p = &a[i][j] + k;\n+  return *p;             // { dg-warning \"'a' is used uninitialized\" }\n+}"}, {"sha": "37fdbca9178fe6daf5282c8be2ff9f9e89329f61", "filename": "gcc/testsuite/gfortran.dg/assignment_4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fassignment_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fassignment_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassignment_4.f90?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -12,5 +12,5 @@\n   logical :: r\n   type(event), pointer :: myEvent\n   allocate(myEvent)\n-  r=myEvent%task()\n+  r=myEvent%task()  ! { dg-warning \"uninitialized\" }\n end "}, {"sha": "c77d47a390023de942549c0941d98e659157b41e", "filename": "gcc/testsuite/gfortran.dg/goacc/uninit-dim-clause.f95", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-dim-clause.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-dim-clause.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-dim-clause.f95?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -4,26 +4,26 @@ subroutine acc_parallel\n   implicit none\n   integer :: i, j, k\n \n-  !$acc parallel num_gangs(i) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc parallel num_gangs(i) ! { dg-warning \"is used uninitialized\" }\n   !$acc end parallel\n \n-  !$acc parallel num_workers(j) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc parallel num_workers(j) ! { dg-warning \"is used uninitialized\" }\n   !$acc end parallel\n \n-  !$acc parallel vector_length(k) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc parallel vector_length(k) ! { dg-warning \"is used uninitialized\" }\n   !$acc end parallel\n end subroutine acc_parallel\n \n subroutine acc_kernels\n   implicit none\n   integer :: i, j, k\n \n-  !$acc kernels num_gangs(i) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc kernels num_gangs(i) ! { dg-warning \"is used uninitialized\" }\n   !$acc end kernels\n \n-  !$acc kernels num_workers(j) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc kernels num_workers(j) ! { dg-warning \"is used uninitialized\" }\n   !$acc end kernels\n \n-  !$acc kernels vector_length(k) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc kernels vector_length(k) ! { dg-warning \"is used uninitialized\" }\n   !$acc end kernels\n end subroutine acc_kernels"}, {"sha": "cd5d189a1aa55346c87fa73ee0526f0f141855a1", "filename": "gcc/testsuite/gfortran.dg/goacc/uninit-firstprivate-clause.f95", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-firstprivate-clause.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-firstprivate-clause.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-firstprivate-clause.f95?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -12,7 +12,7 @@ end subroutine test\n subroutine test2\n   INTEGER :: i\n \n-  !$acc parallel firstprivate (i) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc parallel firstprivate (i) ! { dg-warning \"is used uninitialized\" }\n   i = 1\n   !$acc end parallel\n end subroutine test2"}, {"sha": "73eb4ee1de1dbb6651cc250fc7b75b0f01dc1495", "filename": "gcc/testsuite/gfortran.dg/goacc/uninit-if-clause.f95", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-if-clause.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-if-clause.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Funinit-if-clause.f95?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -6,15 +6,15 @@ program test\n   logical :: b, b2, b3, b4\n   integer :: data, data2\n \n-  !$acc parallel if(b) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc parallel if(b) ! { dg-warning \"is used uninitialized\" }\n   !$acc end parallel\n \n-  !$acc kernels if(b2) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc kernels if(b2) ! { dg-warning \"is used uninitialized\" }\n   !$acc end kernels\n \n-  !$acc data if(b3) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc data if(b3) ! { dg-warning \"is used uninitialized\" }\n   !$acc end data\n \n-  !$acc update if(b4) self(data2) ! { dg-warning \"is used uninitialized in this function\" }\n+  !$acc update if(b4) self(data2) ! { dg-warning \"is used uninitialized\" }\n \n end program test"}, {"sha": "c15a2b365111b1d6edd94a58c6717abf3c518dcd", "filename": "gcc/testsuite/gfortran.dg/pr66545_2.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66545_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66545_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr66545_2.f90?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -11,13 +11,13 @@ end program foo\n subroutine p1\n    complex :: c5\n    complex :: c6\n-   c5 = (c5)      ! { dg-warning \"used uninitialized in this\" }\n-   c6 = c6        ! { dg-warning \"used uninitialized in this\" }\n+   c5 = (c5)      ! { dg-warning \"used uninitialized\" }\n+   c6 = c6        ! { dg-warning \"used uninitialized\" }\n end subroutine p1\n \n subroutine q1\n    real :: r5\n    real :: r6\n-   r5 = (r5)   ! { dg-warning \"used uninitialized in this\" }\n-   r6 = r6     ! { dg-warning \"used uninitialized in this\" }\n+   r5 = (r5)   ! { dg-warning \"used uninitialized\" }\n+   r6 = r6     ! { dg-warning \"used uninitialized\" }\n end subroutine q1"}, {"sha": "2f0ff724cde5c1e5940b21336295b81bf5d73794", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 379, "deletions": 111, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b825a22890740f341eae566af27e18e528cd29a7/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=b825a22890740f341eae566af27e18e528cd29a7", "patch": "@@ -33,6 +33,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa.h\"\n #include \"tree-cfg.h\"\n #include \"cfghooks.h\"\n+#include \"attribs.h\"\n+#include \"builtins.h\"\n+#include \"calls.h\"\n \n /* This implements the pass that does predicate aware warning on uses of\n    possibly uninitialized variables.  The pass first collects the set of\n@@ -217,19 +220,373 @@ check_defs (ao_ref *ref, tree vdef, void *data_)\n   return true;\n }\n \n+/* Counters and limits controlling the the depth of analysis and\n+   strictness of the warning.  */\n+struct wlimits\n+{\n+  /* Number of VDEFs encountered.  */\n+  unsigned int vdef_cnt;\n+  /* Number of statements examined by walk_aliased_vdefs.  */\n+  unsigned int oracle_cnt;\n+  /* Limit on the number of statements visited by walk_aliased_vdefs.  */\n+  unsigned limit;\n+  /* Set when basic block with statement is executed unconditionally.  */\n+  bool always_executed;\n+  /* Set to issue -Wmaybe-uninitialized.  */\n+  bool wmaybe_uninit;\n+};\n+\n+/* Determine if REF references an uninitialized operand and diagnose\n+   it if so.  */\n+\n+static tree\n+maybe_warn_operand (ao_ref &ref, gimple *stmt, tree lhs, tree rhs,\n+\t\t    wlimits &wlims)\n+{\n+  bool has_bit_insert = false;\n+  use_operand_p luse_p;\n+  imm_use_iterator liter;\n+\n+  if (TREE_NO_WARNING (rhs))\n+    return NULL_TREE;\n+\n+  /* Do not warn if the base was marked so or this is a\n+     hard register var.  */\n+  tree base = ao_ref_base (&ref);\n+  if ((VAR_P (base)\n+       && DECL_HARD_REGISTER (base))\n+      || TREE_NO_WARNING (base))\n+    return NULL_TREE;\n+\n+  /* Do not warn if the access is fully outside of the variable.  */\n+  poly_int64 decl_size;\n+  if (DECL_P (base)\n+      && ((known_size_p (ref.size)\n+\t   && known_eq (ref.max_size, ref.size)\n+\t   && known_le (ref.offset + ref.size, 0))\n+\t  || (known_ge (ref.offset, 0)\n+\t      && DECL_SIZE (base)\n+\t      && poly_int_tree_p (DECL_SIZE (base), &decl_size)\n+\t      && known_le (decl_size, ref.offset))))\n+    return NULL_TREE;\n+\n+  /* Do not warn if the result of the access is then used for\n+     a BIT_INSERT_EXPR. */\n+  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+    FOR_EACH_IMM_USE_FAST (luse_p, liter, lhs)\n+      {\n+\tgimple *use_stmt = USE_STMT (luse_p);\n+\t/* BIT_INSERT_EXPR first operand should not be considered\n+\t   a use for the purpose of uninit warnings.  */\n+\tif (gassign *ass = dyn_cast <gassign *> (use_stmt))\n+\t  {\n+\t    if (gimple_assign_rhs_code (ass) == BIT_INSERT_EXPR\n+\t\t&& luse_p->use == gimple_assign_rhs1_ptr (ass))\n+\t      {\n+\t\thas_bit_insert = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+\n+  if (has_bit_insert)\n+    return NULL_TREE;\n+\n+  /* Limit the walking to a constant number of stmts after\n+     we overcommit quadratic behavior for small functions\n+     and O(n) behavior.  */\n+  if (wlims.oracle_cnt > 128 * 128\n+      && wlims.oracle_cnt > wlims.vdef_cnt * 2)\n+    wlims.limit = 32;\n+\n+  check_defs_data data;\n+  bool fentry_reached = false;\n+  data.found_may_defs = false;\n+  tree use = gimple_vuse (stmt);\n+  if (!use)\n+    return NULL_TREE;\n+  int res = walk_aliased_vdefs (&ref, use,\n+\t\t\t\tcheck_defs, &data, NULL,\n+\t\t\t\t&fentry_reached, wlims.limit);\n+  if (res == -1)\n+    {\n+      wlims.oracle_cnt += wlims.limit;\n+      return NULL_TREE;\n+    }\n+\n+  wlims.oracle_cnt += res;\n+  if (data.found_may_defs)\n+    return NULL_TREE;\n+\n+  bool found_alloc = false;\n+\n+  if (fentry_reached)\n+    {\n+      if (TREE_CODE (base) == MEM_REF)\n+\tbase = TREE_OPERAND (base, 0);\n+\n+      /* Follow the chain of SSA_NAME assignments looking for an alloca\n+\t call (or VLA) or malloc/realloc, or for decls.  If any is found\n+\t (and in the latter case, the operand is a local variable) issue\n+\t a warning.  */\n+      while (TREE_CODE (base) == SSA_NAME)\n+\t{\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (base);\n+\n+\t  if (is_gimple_call (def_stmt)\n+\t      && gimple_call_builtin_p (def_stmt))\n+\t    {\n+\t      /* Detect uses of uninitialized alloca/VLAs.  */\n+\t      tree fndecl = gimple_call_fndecl (def_stmt);\n+\t      const built_in_function fncode = DECL_FUNCTION_CODE (fndecl);\n+\t      if (fncode == BUILT_IN_ALLOCA\n+\t\t  || fncode  == BUILT_IN_ALLOCA_WITH_ALIGN\n+\t\t  || fncode  == BUILT_IN_MALLOC)\n+\t\tfound_alloc = true;\n+\t      break;\n+\t    }\n+\n+\t  if (!is_gimple_assign (def_stmt))\n+\t    break;\n+\n+\t  tree_code code = gimple_assign_rhs_code (def_stmt);\n+\t  if (code != ADDR_EXPR && code != POINTER_PLUS_EXPR)\n+\t    break;\n+\n+\t  base = gimple_assign_rhs1 (def_stmt);\n+\t  if (TREE_CODE (base) == ADDR_EXPR)\n+\t    base = TREE_OPERAND (base, 0);\n+\n+\t  if (DECL_P (base)\n+\t      || TREE_CODE (base) == COMPONENT_REF)\n+\t    rhs = base;\n+\n+\t  if (TREE_CODE (base) == MEM_REF)\n+\t    base = TREE_OPERAND (base, 0);\n+\n+\t  if (tree ba = get_base_address (base))\n+\t    base = ba;\n+\t}\n+\n+      /* Replace the RHS expression with BASE so that it\n+\t refers to it in the diagnostic (instead of to\n+\t '<unknown>').  */\n+      if (DECL_P (base)\n+\t  && EXPR_P (rhs)\n+\t  && TREE_CODE (rhs) != COMPONENT_REF)\n+\trhs = base;\n+    }\n+\n+  /* Do not warn if it can be initialized outside this function.\n+     If we did not reach function entry then we found killing\n+     clobbers on all paths to entry.  */\n+  if (!found_alloc\n+      && fentry_reached\n+      /* ???  We'd like to use ref_may_alias_global_p but that\n+\t excludes global readonly memory and thus we get bogus\n+\t warnings from p = cond ? \"a\" : \"b\" for example.  */\n+      && (!VAR_P (base)\n+\t  || is_global_var (base)))\n+    return NULL_TREE;\n+\n+  /* Strip the address-of expression from arrays passed to functions. */\n+  if (TREE_CODE (rhs) == ADDR_EXPR)\n+    rhs = TREE_OPERAND (rhs, 0);\n+\n+  /* Check again since RHS may have changed above.  */\n+  if (TREE_NO_WARNING (rhs))\n+    return NULL_TREE;\n+\n+  /* Avoid warning about empty types such as structs with no members.\n+     The first_field() test is important for C++ where the predicate\n+     alone isn't always sufficient.  */\n+  tree rhstype = TREE_TYPE (rhs);\n+  if (TYPE_EMPTY_P (rhstype)\n+      || (RECORD_OR_UNION_TYPE_P (rhstype)\n+\t  && (!first_field (rhstype)\n+\t      || default_is_empty_record (rhstype))))\n+    return NULL_TREE;\n+\n+  bool warned = false;\n+  /* We didn't find any may-defs so on all paths either\n+     reached function entry or a killing clobber.  */\n+  location_t location\n+    = linemap_resolve_location (line_table, gimple_location (stmt),\n+\t\t\t\tLRK_SPELLING_LOCATION, NULL);\n+  if (wlims.always_executed)\n+    {\n+      if (warning_at (location, OPT_Wuninitialized,\n+\t\t      \"%G%qE is used uninitialized\", stmt, rhs))\n+\t{\n+\t  /* ???  This is only effective for decls as in\n+\t     gcc.dg/uninit-B-O0.c.  Avoid doing this for maybe-uninit\n+\t     uses or accesses by functions as it may hide important\n+\t     locations.  */\n+\t  if (lhs)\n+\t    TREE_NO_WARNING (rhs) = 1;\n+\t  warned = true;\n+\t}\n+    }\n+  else if (wlims.wmaybe_uninit)\n+    warned = warning_at (location, OPT_Wmaybe_uninitialized,\n+\t\t\t \"%G%qE may be used uninitialized\", stmt, rhs);\n+\n+  return warned ? base : NULL_TREE;\n+}\n+\n+\n+/* Diagnose passing addresses of uninitialized objects to either const\n+   pointer arguments to functions, or to functions declared with attribute\n+   access implying read access to those objects.  */\n+\n+static void\n+maybe_warn_pass_by_reference (gimple *stmt, wlimits &wlims)\n+{\n+  if (!wlims.wmaybe_uninit)\n+    return;\n+\n+  unsigned nargs = gimple_call_num_args (stmt);\n+  if (!nargs)\n+    return;\n+\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  tree fntype = gimple_call_fntype (stmt);\n+  if (!fntype)\n+    return;\n+\n+  const built_in_function fncode\n+    = (fndecl && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+       ? DECL_FUNCTION_CODE (fndecl) : (built_in_function)BUILT_IN_LAST);\n+\n+  if (fncode == BUILT_IN_MEMCPY || fncode == BUILT_IN_MEMMOVE)\n+    /* Avoid diagnosing calls to raw memory functions (this is overly\n+       permissive; consider tightening it up).  */\n+    return;\n+\n+  /* Save the current warning setting and replace it either a \"maybe\"\n+     when passing addresses of uninitialized variables to const-qualified\n+     pointers or arguments declared with attribute read_write, or with\n+     a \"certain\" when passing them to arguments declared with attribute\n+     read_only.  */\n+  const bool save_always_executed = wlims.always_executed;\n+\n+  /* Map of attribute access specifications for function arguments.  */\n+  rdwr_map rdwr_idx;\n+  init_attr_rdwr_indices (&rdwr_idx, fntype);\n+\n+  tree argtype;\n+  unsigned argno = 0;\n+  function_args_iterator it;\n+\n+  FOREACH_FUNCTION_ARGS (fntype, argtype, it)\n+    {\n+      ++argno;\n+\n+      if (!POINTER_TYPE_P (argtype))\n+\tcontinue;\n+\n+      tree access_size = NULL_TREE;\n+      attr_access *access = rdwr_idx.get (argno - 1);\n+      if (access)\n+\t{\n+\t  if (access->mode == attr_access::none\n+\t      || access->mode == attr_access::write_only)\n+\t    continue;\n+\t  if (save_always_executed && access->mode == attr_access::read_only)\n+\t    /* Attribute read_only arguments imply read access.  */\n+\t    wlims.always_executed = true;\n+\t  else\n+\t    /* Attribute read_write arguments are documented as requiring\n+\t       initialized objects but it's expected that aggregates may\n+\t       be only partially initialized regardless.  */\n+\t    wlims.always_executed = false;\n+\n+\t  if (access->sizarg < nargs)\n+\t    access_size = gimple_call_arg (stmt, access->sizarg);\n+\t}\n+      else if (!TYPE_READONLY (TREE_TYPE (argtype)))\n+\tcontinue;\n+      else if (save_always_executed && fncode != BUILT_IN_LAST)\n+\t/* Const-qualified arguments to built-ins imply read access.  */\n+\twlims.always_executed = true;\n+      else\n+\t/* Const-qualified arguments to ordinary functions imply a likely\n+\t   (but not definitive) read access.  */\n+\twlims.always_executed = false;\n+\n+      tree arg = gimple_call_arg (stmt, argno - 1);\n+\n+      ao_ref ref;\n+      ao_ref_init_from_ptr_and_size (&ref, arg, access_size);\n+      tree argbase = maybe_warn_operand (ref, stmt, NULL_TREE, arg, wlims);\n+      if (!argbase)\n+\tcontinue;\n+\n+      if (access)\n+\t{\n+\t  const char* const mode = (access->mode == attr_access::read_only\n+\t\t\t\t    ? \"read_only\" : \"read_write\");\n+\t  char attrstr[80];\n+\t  int n = sprintf (attrstr, \"access (%s, %u\", mode, argno);\n+\t  if (access->sizarg < UINT_MAX)\n+\t    sprintf (attrstr + n, \", %u)\", access->sizarg);\n+\t  else\n+\t    strcpy (attrstr + n, \")\");\n+\n+\t  if (fndecl)\n+\t    {\n+\t      location_t loc = DECL_SOURCE_LOCATION (fndecl);\n+\t      inform (loc, \"in a call to %qD declared \"\n+\t\t      \"with attribute %<access (%s, %u)%> here\",\n+\t\t      fndecl, mode, argno);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Handle calls through function pointers.  */\n+\t      location_t loc = gimple_location (stmt);\n+\t      inform (loc, \"in a call to %qT declared with \"\n+\t\t      \"attribute %<access (%s, %u)%>\",\n+\t\t      fntype, mode, argno);\n+\t    }\n+\t}\n+      else if (fndecl)\n+\t{\n+\t  location_t loc = DECL_SOURCE_LOCATION (fndecl);\n+\t  inform (loc, \"by argument %u of type %qT to %qD declared here\",\n+\t\t  argno, argtype, fndecl);\n+\t}\n+      else\n+\t{\n+\t  /* Handle calls through function pointers.  */\n+\t  location_t loc = gimple_location (stmt);\n+\t  inform (loc, \"by argument %u of type %qT to %qT\",\n+\t\t  argno, argtype, fntype);\n+\t}\n+\n+      if (DECL_P (argbase))\n+\t{\n+\t  location_t loc = DECL_SOURCE_LOCATION (argbase);\n+\t  inform (loc, \"%qD declared here\", argbase);\n+\t}\n+    }\n+\n+  wlims.always_executed = save_always_executed;\n+}\n+\n+\n static unsigned int\n-warn_uninitialized_vars (bool warn_possibly_uninitialized)\n+warn_uninitialized_vars (bool wmaybe_uninit)\n {\n+  /* Counters and limits controlling the the depth of the warning.  */\n+  wlimits wlims = { };\n+  wlims.wmaybe_uninit = wmaybe_uninit;\n+\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n-  unsigned int vdef_cnt = 0;\n-  unsigned int oracle_cnt = 0;\n-  unsigned limit = 0;\n-\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       basic_block succ = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-      bool always_executed = dominated_by_p (CDI_POST_DOMINATORS, succ, bb);\n+      wlims.always_executed = dominated_by_p (CDI_POST_DOMINATORS, succ, bb);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n@@ -253,131 +610,42 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t\t    continue;\n \t\t}\n \t      use = USE_FROM_PTR (use_p);\n-\t      if (always_executed)\n+\t      if (wlims.always_executed)\n \t\twarn_uninit (OPT_Wuninitialized, use, SSA_NAME_VAR (use),\n \t\t\t     SSA_NAME_VAR (use),\n-\t\t\t     \"%qD is used uninitialized in this function\", stmt,\n+\t\t\t     \"%qD is used uninitialized\", stmt,\n \t\t\t     UNKNOWN_LOCATION);\n-\t      else if (warn_possibly_uninitialized)\n+\t      else if (wmaybe_uninit)\n \t\twarn_uninit (OPT_Wmaybe_uninitialized, use, SSA_NAME_VAR (use),\n \t\t\t     SSA_NAME_VAR (use),\n-\t\t\t     \"%qD may be used uninitialized in this function\",\n+\t\t\t     \"%qD may be used uninitialized\",\n \t\t\t     stmt, UNKNOWN_LOCATION);\n \t    }\n \n \t  /* For limiting the alias walk below we count all\n \t     vdefs in the function.  */\n \t  if (gimple_vdef (stmt))\n-\t    vdef_cnt++;\n+\t    wlims.vdef_cnt++;\n \n-\t  if (gimple_assign_load_p (stmt)\n-\t      && gimple_has_location (stmt))\n+\t  if (is_gimple_call (stmt))\n+\t    maybe_warn_pass_by_reference (stmt, wlims);\n+\t  else if (gimple_assign_load_p (stmt)\n+\t\t   && gimple_has_location (stmt))\n \t    {\n \t      tree rhs = gimple_assign_rhs1 (stmt);\n \t      tree lhs = gimple_assign_lhs (stmt);\n-\t      bool has_bit_insert = false;\n-\t      use_operand_p luse_p;\n-\t      imm_use_iterator liter;\n-\n-\t      if (TREE_NO_WARNING (rhs))\n-\t\tcontinue;\n \n \t      ao_ref ref;\n \t      ao_ref_init (&ref, rhs);\n-\n-\t      /* Do not warn if the base was marked so or this is a\n-\t         hard register var.  */\n-\t      tree base = ao_ref_base (&ref);\n-\t      if ((VAR_P (base)\n-\t\t   && DECL_HARD_REGISTER (base))\n-\t\t  || TREE_NO_WARNING (base))\n-\t\tcontinue;\n-\n-\t      /* Do not warn if the access is fully outside of the\n-\t         variable.  */\n-\t      poly_int64 decl_size;\n-\t      if (DECL_P (base)\n-\t\t  && known_size_p (ref.size)\n-\t\t  && ((known_eq (ref.max_size, ref.size)\n-\t\t       && known_le (ref.offset + ref.size, 0))\n-\t\t      || (known_ge (ref.offset, 0)\n-\t\t\t  && DECL_SIZE (base)\n-\t\t\t  && poly_int_tree_p (DECL_SIZE (base), &decl_size)\n-\t\t\t  && known_le (decl_size, ref.offset))))\n-\t\tcontinue;\n-\n-\t      /* Do not warn if the access is then used for a BIT_INSERT_EXPR. */\n-\t      if (TREE_CODE (lhs) == SSA_NAME)\n-\t        FOR_EACH_IMM_USE_FAST (luse_p, liter, lhs)\n-\t\t  {\n-\t\t    gimple *use_stmt = USE_STMT (luse_p);\n-                    /* BIT_INSERT_EXPR first operand should not be considered\n-\t\t       a use for the purpose of uninit warnings.  */\n-\t\t    if (gassign *ass = dyn_cast <gassign *> (use_stmt))\n-\t\t      {\n-\t\t\tif (gimple_assign_rhs_code (ass) == BIT_INSERT_EXPR\n-\t\t\t    && luse_p->use == gimple_assign_rhs1_ptr (ass))\n-\t\t\t  {\n-\t\t\t    has_bit_insert = true;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\t      if (has_bit_insert)\n-\t\tcontinue;\n-\n-\t      /* Limit the walking to a constant number of stmts after\n-\t         we overcommit quadratic behavior for small functions\n-\t\t and O(n) behavior.  */\n-\t      if (oracle_cnt > 128 * 128\n-\t\t  && oracle_cnt > vdef_cnt * 2)\n-\t\tlimit = 32;\n-\t      check_defs_data data;\n-\t      bool fentry_reached = false;\n-\t      data.found_may_defs = false;\n-\t      use = gimple_vuse (stmt);\n-\t      int res = walk_aliased_vdefs (&ref, use,\n-\t\t\t\t\t    check_defs, &data, NULL,\n-\t\t\t\t\t    &fentry_reached, limit);\n-\t      if (res == -1)\n-\t\t{\n-\t\t  oracle_cnt += limit;\n-\t\t  continue;\n-\t\t}\n-\t      oracle_cnt += res;\n-\t      if (data.found_may_defs)\n-\t\tcontinue;\n-\t      /* Do not warn if it can be initialized outside this function.\n-\t         If we did not reach function entry then we found killing\n-\t\t clobbers on all paths to entry.  */\n-\t      if (fentry_reached\n-\t\t  /* ???  We'd like to use ref_may_alias_global_p but that\n-\t\t     excludes global readonly memory and thus we get bougs\n-\t\t     warnings from p = cond ? \"a\" : \"b\" for example.  */\n-\t\t  && (!VAR_P (base)\n-\t\t      || is_global_var (base)))\n+\t      tree var = maybe_warn_operand (ref, stmt, lhs, rhs, wlims);\n+\t      if (!var)\n \t\tcontinue;\n \n-\t      /* We didn't find any may-defs so on all paths either\n-\t         reached function entry or a killing clobber.  */\n-\t      location_t location\n-\t\t= linemap_resolve_location (line_table, gimple_location (stmt),\n-\t\t\t\t\t    LRK_SPELLING_LOCATION, NULL);\n-\t      if (always_executed)\n+\t      if (DECL_P (var))\n \t\t{\n-\t\t  if (warning_at (location, OPT_Wuninitialized,\n-\t\t\t\t  \"%qE is used uninitialized in this function\",\n-\t\t\t\t  rhs))\n-\t\t    /* ???  This is only effective for decls as in\n-\t\t       gcc.dg/uninit-B-O0.c.  Avoid doing this for\n-\t\t       maybe-uninit uses as it may hide important\n-\t\t       locations.  */\n-\t\t    TREE_NO_WARNING (rhs) = 1;\n+\t\t  location_t loc = DECL_SOURCE_LOCATION (var);\n+\t\t  inform (loc, \"%qD declared here\", var);\n \t\t}\n-\t      else if (warn_possibly_uninitialized)\n-\t\twarning_at (location, OPT_Wmaybe_uninitialized,\n-\t\t\t    \"%qE may be used uninitialized in this function\",\n-\t\t\t    rhs);\n \t    }\n \t}\n     }\n@@ -2665,7 +2933,7 @@ pass_late_warn_uninitialized::execute (function *fun)\n   /* Re-do the plain uninitialized variable check, as optimization may have\n      straightened control flow.  Do this first so that we don't accidentally\n      get a \"may be\" warning when we'd have seen an \"is\" warning later.  */\n-  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/1);\n+  warn_uninitialized_vars (/*warn_maybe_uninitialized=*/1);\n \n   timevar_push (TV_TREE_UNINIT);\n \n@@ -2735,7 +3003,7 @@ execute_early_warn_uninitialized (void)\n      optimization we need to warn here about \"may be uninitialized\".  */\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n-  warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n+  warn_uninitialized_vars (/*warn_maybe_uninitialized=*/!optimize);\n \n   /* Post-dominator information cannot be reliably updated.  Free it\n      after the use.  */"}]}