{"sha": "bc4071dd66fd4d093dc3fe3592ea879c2996868b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0MDcxZGQ2NmZkNGQwOTNkYzNmZTM1OTJlYTg3OWMyOTk2ODY4Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-01-04T16:33:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2006-01-04T16:33:38Z"}, "message": "directives.c (struct pragma_entry): Add is_deferred.\n\nlibcpp/\n\t* directives.c (struct pragma_entry): Add is_deferred.  Add ident\n\tentry to value union.\n\t(end_directive): Don't eat the line if in_deferred_pragma.\n\t(run_directive): Remove pragma hacks.\n\t(insert_pragma_entry): Remove.\n\t(new_pragma_entry): New.\n\t(register_pragma_1): Split out of register_pragma.  Only handle\n\tthe lookup tree and return the new entry.\n\t(cpp_register_pragma): Fill in the pragma entry here.\n\t(cpp_register_deferred_pragma): New.\n\t(register_pragma_internal): New.\n\t(_cpp_init_internal_pragmas): Use register_pragma_internal.\n\t(do_pragma): Allow pragma expansion after namespace.  For deferred\n\tpragmas, don't slurp the line into a string.\n\t(destringize_and_run): Save tokens for deferred pragmas.\n\t(cpp_handle_deferred_pragma): Remove.\n\t* macro.c (builtin_macro): Remove pragma token hack.\n\t(_cpp_push_token_context): Rename from push_token_context and export.\n\t* internal.h (struct lexer_state): Add pragma_allow_expansion.\n\t(_cpp_push_token_context): Declare.\n\t* lex.c (_cpp_lex_token): Allow _cpp_handle_directive to return\n\ta token.  Update the line number correctly if so.\n\t(_cpp_lex_direct): Emit CPP_PRAGMA_EOL tokens.\n\t(cpp_token_val_index): Return CPP_TOKEN_FLD_PRAGMA for pragmas.\n\t* include/cpplib.h (PRAGMA_EOL): New.\n\t(CPP_TOKEN_FLD_PRAGMA): New.\n\t(struct cpp_token): Add val.pragma.\n\t(struct cpp_options): Remove defer_pragmas.\n\t(cpp_handle_deferred_pragma): Remove.\n\t(cpp_register_deferred_pragma): Declare.\n\ngcc/\n\t* c-lex.c (c_lex_with_flags) <CPP_PRAGMA>: Smuggle pragma id\n\tvia integer constant.\n\t(pragma_lex): Remove.\n\t* c-pch.c (c_common_pch_pragma): Accept the name as an argument,\n\trather than parsing it.\n\t* c-pragma.c (handle_pragma_weak, handle_pragma_redefine_extname,\n\thandle_pragma_extern_prefix): Add %< %> quotes.\n\t(registered_pragmas): New.\n\t(c_register_pragma_1): New.\n\t(c_register_pragma): Use it.\n\t(c_register_pragma_with_expansion): Likewise.\n\t(c_invoke_pragma_handler): New.\n\t(init_pragma): Use cpp_register_deferred_pragma directly for\n\tpch_preprocess.\n\t* c-pragma.h (enum pragma_kind): New.\n\t(pragma_handler): New.\n\t(c_invoke_pragma_handler): Declare.\n\t* c-common.c (c_parse_error): Pretty print CPP_PRAGMA and\n\tCPP_PRAGMA_EOL.\n\t* c-common.h (c_common_pch_pragma): Update decl.\n\t* Makefile.in (c-parser.o): Update dependencies.\n\t(GTFILES): Add c-pragma.h.\n\t* c-parser.c (struct c_token): Add pragma_kind.\n\t(struct c_parser): Add in_pragma.\n\t(c_lex_one_token): Always initialize keyword and pragma_kind.\n\tExtract data for CPP_PRAGMA.\n\t(c_parser_peek_2nd_token): Deny CPP_PRAGMA_EOL.\n\t(c_parser_consume_token): Don't allow CPP_PRAGMA unless errors.\n\tDon't allow CPP_PRAGMA_EOL if in_pragma.\n\t(c_parser_consume_pragma): New.\n\t(c_parser_skip_until_found): Stop on CPP_PRAGMA_EOL.\n\t(c_parser_skip_to_end_of_parameter): Likewise.\n\t(c_parser_skip_to_end_of_block_or_statement): Likewise.\n\t(c_parser_skip_to_pragma_eol): New.\n\t(c_parser_external_declaration): Handle CPP_PRAGMA.\n\t(c_parser_compound_statement_nostart): Likewise.\n\t(c_parser_statement_after_labels): Likewise.\n\t(c_parser_pragma): New.\n\t(pragma_lex): Likewise.\n\t(c_parser_pragma_pch_preprocess): New.\n\t(c_parser_new): Merge into ...\n\t(c_parse_file): ... here.  Call c_parser_pragma_pch_preprocess.\n\ngcc/cp/\n\t* lex.c (handle_pragma_java_exceptions): Fix whitespace.\n\t* parser.c (struct cp_token): Add pragma_kind.\n\t(eof_token): Update to match.\n\t(struct cp_lexer): Add in_pragma; rearrange next for better packing.\n\t(cp_parser_initial_pragma): New.\n\t(cp_lexer_new_main): Use it.  Don't bother clearing\n\tc_lex_return_raw_strings.\n\t(cp_lexer_get_preprocessor_token): Always initialize keyword\n\tand pragma_kind fields.  Handle CPP_PRAGMA.\n\t(cp_lexer_consume_token): Don't allow CPP_PRAGMA_EOL when \n\tin_pragma is set.\n\t(cp_lexer_handle_pragma): Remove.  Update callers to cp_parser_pragma.\n\t(cp_lexer_print_token) <CPP_PRAGMA>: Don't print as a string.\n\t(cp_parser_skip_to_pragma_eol): New.\n\t(cp_parser_error): Use it.\n\t(cp_parser_skip_to_closing_parenthesis): Stop at CPP_PRAGMA_EOL;\n\trearrange with switch statement.\n\t(cp_parser_skip_to_end_of_statement): Likewise.\n\t(cp_parser_skip_to_end_of_block_or_statement): Likewise.\n\t(cp_parser_skip_to_closing_brace): Likewise.\n\t(cp_parser_skip_until_found): Likewise.\n\t(cp_parser_statement): Add in_compound argument; update callers.\n\tUse it to decide how to handle pragma parsing.\n\t(cp_parser_labeled_statement): Add in_compound argument; pass\n\tit on to cp_parser_statement.\n\t(cp_parser_statement_seq_opt): Stop at CPP_PRAGMA_EOL.\n\t(cp_parser_declaration_seq_opt): Likewise.\n\t(cp_parser_parameter_declaration): Likewise.\n\t(cp_parser_member_specification_opt): Likewise.\n\t(cp_parser_function_definition_after_decl): Likewise.\n\t(cp_parser_cache_group): Handle CPP_PRAGMA/CPP_PRAGMA_EOL pairs.\n\t(cp_parser_pragma): New.\n\t(pragma_lex): New.\n\ngcc/testsuite/\n\t* g++.dg/parse/pragma2.C: Update expected error lines.\n\nFrom-SVN: r109336", "tree": {"sha": "665a7e61be294c2530782e0d9fbb6a33d6ef62ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/665a7e61be294c2530782e0d9fbb6a33d6ef62ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc4071dd66fd4d093dc3fe3592ea879c2996868b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4071dd66fd4d093dc3fe3592ea879c2996868b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4071dd66fd4d093dc3fe3592ea879c2996868b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4071dd66fd4d093dc3fe3592ea879c2996868b/comments", "author": null, "committer": null, "parents": [{"sha": "59bb84ef39a86a30c2f0280eb2176ee73a9e4cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59bb84ef39a86a30c2f0280eb2176ee73a9e4cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59bb84ef39a86a30c2f0280eb2176ee73a9e4cb9"}], "stats": {"total": 1484, "additions": 989, "deletions": 495}, "files": [{"sha": "a9a6e927f9e032f9fbfc9112a9e0dec07c021f87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -1,3 +1,49 @@\n+2006-01-04  Richard Henderson  <rth@redhat.com>\n+\n+\tMerge from gomp branch:\n+\t* c-lex.c (c_lex_with_flags) <CPP_PRAGMA>: Smuggle pragma id\n+\tvia integer constant.\n+\t(pragma_lex): Remove.\n+\t* c-pch.c (c_common_pch_pragma): Accept the name as an argument,\n+\trather than parsing it.\n+\t* c-pragma.c (handle_pragma_weak, handle_pragma_redefine_extname,\n+\thandle_pragma_extern_prefix): Add %< %> quotes.\n+\t(registered_pragmas): New.\n+\t(c_register_pragma_1): New.\n+\t(c_register_pragma): Use it.\n+\t(c_register_pragma_with_expansion): Likewise.\n+\t(c_invoke_pragma_handler): New.\n+\t(init_pragma): Use cpp_register_deferred_pragma directly for\n+\tpch_preprocess.\n+\t* c-pragma.h (enum pragma_kind): New.\n+\t(pragma_handler): New.\n+\t(c_invoke_pragma_handler): Declare.\n+\t* c-common.c (c_parse_error): Pretty print CPP_PRAGMA and\n+\tCPP_PRAGMA_EOL.\n+\t* c-common.h (c_common_pch_pragma): Update decl.\n+\t* Makefile.in (c-parser.o): Update dependencies.\n+\t(GTFILES): Add c-pragma.h.\n+\t* c-parser.c (struct c_token): Add pragma_kind.\n+\t(struct c_parser): Add in_pragma.\n+\t(c_lex_one_token): Always initialize keyword and pragma_kind.\n+\tExtract data for CPP_PRAGMA.\n+\t(c_parser_peek_2nd_token): Deny CPP_PRAGMA_EOL.\n+\t(c_parser_consume_token): Don't allow CPP_PRAGMA unless errors.\n+\tDon't allow CPP_PRAGMA_EOL if in_pragma.\n+\t(c_parser_consume_pragma): New.\n+\t(c_parser_skip_until_found): Stop on CPP_PRAGMA_EOL.\n+\t(c_parser_skip_to_end_of_parameter): Likewise.\n+\t(c_parser_skip_to_end_of_block_or_statement): Likewise.\n+\t(c_parser_skip_to_pragma_eol): New.\n+\t(c_parser_external_declaration): Handle CPP_PRAGMA.\n+\t(c_parser_compound_statement_nostart): Likewise.\n+\t(c_parser_statement_after_labels): Likewise.\n+\t(c_parser_pragma): New.\n+\t(pragma_lex): Likewise.\n+\t(c_parser_pragma_pch_preprocess): New.\n+\t(c_parser_new): Merge into ...\n+\t(c_parse_file): ... here.  Call c_parser_pragma_pch_preprocess.\n+\n 2005-01-04  Jeff Law  <law@redhat.com>\n \n \tPR ada/24994"}, {"sha": "82e5de26e9b32702fd872a22aeb2237eb1f2188d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -1516,7 +1516,8 @@ c-errors.o: c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TM_P_H)\n c-parser.o : c-parser.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(GGC_H) $(TIMEVAR_H) $(C_TREE_H) input.h $(FLAGS_H) toplev.h output.h \\\n-    $(CPPLIB_H) gt-c-parser.h langhooks.h $(C_COMMON_H) $(C_PRAGMA_H)\n+    $(CPPLIB_H) gt-c-parser.h langhooks.h $(C_COMMON_H) $(C_PRAGMA_H) \\\n+    vec.h $(TARGET_H)\n \n srcextra: gcc.srcextra lang.srcextra\n \n@@ -2811,6 +2812,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-profile.c $(srcdir)/tree-nested.c \\\n   $(srcdir)/ipa-reference.c $(srcdir)/tree-ssa-structalias.h \\\n   $(srcdir)/tree-ssa-structalias.c \\\n+  $(srcdir)/c-pragma.h \\\n   $(srcdir)/targhooks.c $(out_file) \\\n   @all_gtfiles@\n "}, {"sha": "2a7c1e777d34931ebe008b3b178dbf3f0c4c3351", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -5803,6 +5803,10 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)\n       free (message);\n       message = NULL;\n     }\n+  else if (token == CPP_PRAGMA)\n+    message = catenate_messages (gmsgid, \" before %<#pragma%>\");\n+  else if (token == CPP_PRAGMA_EOL)\n+    message = catenate_messages (gmsgid, \" before end of line\");\n   else if (token < N_TTYPES)\n     {\n       message = catenate_messages (gmsgid, \" before %qs token\");"}, {"sha": "735250f8011c63f6ffa4d351b020b4dc21ed089d", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -854,7 +854,7 @@ extern void c_common_read_pch (cpp_reader *pfile, const char *name, int fd,\n \t\t\t       const char *orig);\n extern void c_common_write_pch (void);\n extern void c_common_no_more_pch (void);\n-extern void c_common_pch_pragma (cpp_reader *pfile);\n+extern void c_common_pch_pragma (cpp_reader *pfile, const char *);\n extern void c_common_print_pch_checksum (FILE *f);\n \n /* In *-checksum.c */"}, {"sha": "44e63d738161ea878bcced909bbf82624fbded6c", "filename": "gcc/c-lex.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -458,11 +458,11 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n \t  type = lex_string (tok, value, false);\n \t  break;\n \t}\n+      *value = build_string (tok->val.str.len, (char *) tok->val.str.text);\n+      break;\n       \n-      /* FALLTHROUGH */\n-\n     case CPP_PRAGMA:\n-      *value = build_string (tok->val.str.len, (char *) tok->val.str.text);\n+      *value = build_int_cst (NULL, tok->val.pragma);\n       break;\n \n       /* These tokens should not be visible outside cpplib.  */\n@@ -490,13 +490,6 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n   return type;\n }\n \n-enum cpp_ttype\n-pragma_lex (tree *value)\n-{\n-  location_t loc;\n-  return c_lex_with_flags (value, &loc, NULL);\n-}\n-\n /* Returns the narrowest C-visible unsigned type, starting with the\n    minimum specified by FLAGS, that can fit HIGH:LOW, or itk_none if\n    there isn't one.  */"}, {"sha": "eff5b8323479ded1969b7b0d511339aa34dc9758", "filename": "gcc/c-parser.c", "status": "modified", "additions": 205, "deletions": 39, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -42,6 +42,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"rtl.h\"\n #include \"langhooks.h\"\n #include \"input.h\"\n #include \"cpplib.h\"\n@@ -53,6 +54,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"toplev.h\"\n #include \"ggc.h\"\n #include \"c-common.h\"\n+#include \"vec.h\"\n+#include \"target.h\"\n \n \f\n /* Miscellaneous data and functions needed for the parser.  */\n@@ -266,6 +269,9 @@ typedef struct c_token GTY (())\n   /* If this token is a keyword, this value indicates which keyword.\n      Otherwise, this value is RID_MAX.  */\n   ENUM_BITFIELD (rid) keyword : 8;\n+  /* If this token is a CPP_PRAGMA, this indicates the pragma that\n+     was seen.  Otherwise it is PRAGMA_NONE.  */\n+  ENUM_BITFIELD (pragma_kind) pragma_kind : 7;\n   /* True if this token is from a system header.  */\n   BOOL_BITFIELD in_system_header : 1;\n   /* The value associated with this token, if any.  */\n@@ -287,21 +293,34 @@ typedef struct c_parser GTY(())\n      c_parser_error sets this flag.  It should clear this flag when\n      enough tokens have been consumed to recover from the error.  */\n   BOOL_BITFIELD error : 1;\n+  /* True if we're processing a pragma, and shouldn't automatically\n+     consume CPP_PRAGMA_EOL.  */\n+  BOOL_BITFIELD in_pragma : 1;\n } c_parser;\n \n+\n+/* The actual parser and external interface.  ??? Does this need to be\n+   garbage-collected?  */\n+\n+static GTY (()) c_parser *the_parser;\n+\n+\n /* Read in and lex a single token, storing it in *TOKEN.  */\n \n static void\n c_lex_one_token (c_token *token)\n {\n   timevar_push (TV_LEX);\n+\n   token->type = c_lex_with_flags (&token->value, &token->location, NULL);\n+  token->id_kind = C_ID_NONE;\n+  token->keyword = RID_MAX;\n+  token->pragma_kind = PRAGMA_NONE;\n   token->in_system_header = in_system_header;\n+\n   switch (token->type)\n     {\n     case CPP_NAME:\n-      token->id_kind = C_ID_NONE;\n-      token->keyword = RID_MAX;\n       {\n \ttree decl;\n \n@@ -358,13 +377,12 @@ c_lex_one_token (c_token *token)\n \t\tbreak;\n \t      }\n \t  }\n+        token->id_kind = C_ID_ID;\n       }\n-      token->id_kind = C_ID_ID;\n       break;\n     case CPP_AT_NAME:\n       /* This only happens in Objective-C; it must be a keyword.  */\n       token->type = CPP_KEYWORD;\n-      token->id_kind = C_ID_NONE;\n       token->keyword = C_RID_CODE (token->value);\n       break;\n     case CPP_COLON:\n@@ -374,12 +392,13 @@ c_lex_one_token (c_token *token)\n       /* These tokens may affect the interpretation of any identifiers\n \t following, if doing Objective-C.  */\n       OBJC_NEED_RAW_IDENTIFIER (0);\n-      token->id_kind = C_ID_NONE;\n-      token->keyword = RID_MAX;\n+      break;\n+    case CPP_PRAGMA:\n+      /* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */\n+      token->pragma_kind = TREE_INT_CST_LOW (token->value);\n+      token->value = NULL;\n       break;\n     default:\n-      token->id_kind = C_ID_NONE;\n-      token->keyword = RID_MAX;\n       break;\n     }\n   timevar_pop (TV_LEX);\n@@ -582,6 +601,7 @@ c_parser_peek_2nd_token (c_parser *parser)\n     return &parser->tokens[1];\n   gcc_assert (parser->tokens_avail == 1);\n   gcc_assert (parser->tokens[0].type != CPP_EOF);\n+  gcc_assert (parser->tokens[0].type != CPP_PRAGMA_EOL);\n   c_lex_one_token (&parser->tokens[1]);\n   parser->tokens_avail = 2;\n   return &parser->tokens[1];\n@@ -592,16 +612,30 @@ c_parser_peek_2nd_token (c_parser *parser)\n static void\n c_parser_consume_token (c_parser *parser)\n {\n+  gcc_assert (parser->tokens_avail >= 1);\n+  gcc_assert (parser->tokens[0].type != CPP_EOF);\n+  gcc_assert (!parser->in_pragma || parser->tokens[0].type != CPP_PRAGMA_EOL);\n+  gcc_assert (parser->error || parser->tokens[0].type != CPP_PRAGMA);\n   if (parser->tokens_avail == 2)\n     parser->tokens[0] = parser->tokens[1];\n-  else\n-    {\n-      gcc_assert (parser->tokens_avail == 1);\n-      gcc_assert (parser->tokens[0].type != CPP_EOF);\n-    }\n   parser->tokens_avail--;\n }\n \n+/* Expect the current token to be a #pragma.  Consume it and remember\n+   that we've begun parsing a pragma.  */\n+\n+static void\n+c_parser_consume_pragma (c_parser *parser)\n+{\n+  gcc_assert (!parser->in_pragma);\n+  gcc_assert (parser->tokens_avail >= 1);\n+  gcc_assert (parser->tokens[0].type == CPP_PRAGMA);\n+  if (parser->tokens_avail == 2)\n+    parser->tokens[0] = parser->tokens[1];\n+  parser->tokens_avail--;\n+  parser->in_pragma = true;\n+}\n+\n /* Update the globals input_location and in_system_header from\n    TOKEN.  */\n static inline void\n@@ -614,23 +648,6 @@ c_parser_set_source_position_from_token (c_token *token)\n     }\n }\n \n-/* Allocate a new parser.  */\n-\n-static c_parser *\n-c_parser_new (void)\n-{\n-  /* Use local storage to lex the first token because loading a PCH\n-     file may cause garbage collection.  */\n-  c_parser tparser;\n-  c_parser *ret;\n-  memset (&tparser, 0, sizeof tparser);\n-  c_lex_one_token (&tparser.tokens[0]);\n-  tparser.tokens_avail = 1;\n-  ret = GGC_NEW (c_parser);\n-  memcpy (ret, &tparser, sizeof tparser);\n-  return ret;\n-}\n-\n /* Issue a diagnostic of the form\n       FILE:LINE: MESSAGE before TOKEN\n    where TOKEN is the next token in the input stream of PARSER.\n@@ -732,9 +749,12 @@ c_parser_skip_until_found (c_parser *parser,\n \t  c_parser_consume_token (parser);\n \t  break;\n \t}\n+\n       /* If we've run out of tokens, stop.  */\n       if (token->type == CPP_EOF)\n \treturn;\n+      if (token->type == CPP_PRAGMA_EOL && parser->in_pragma)\n+\treturn;\n       if (token->type == CPP_OPEN_BRACE\n \t  || token->type == CPP_OPEN_PAREN\n \t  || token->type == CPP_OPEN_SQUARE)\n@@ -769,6 +789,8 @@ c_parser_skip_to_end_of_parameter (c_parser *parser)\n       /* If we've run out of tokens, stop.  */\n       if (token->type == CPP_EOF)\n \treturn;\n+      if (token->type == CPP_PRAGMA_EOL && parser->in_pragma)\n+\treturn;\n       if (token->type == CPP_OPEN_BRACE\n \t  || token->type == CPP_OPEN_PAREN\n \t  || token->type == CPP_OPEN_SQUARE)\n@@ -803,6 +825,8 @@ c_parser_skip_to_end_of_block_or_statement (c_parser *parser)\n       /* If we've run out of tokens, stop.  */\n       if (token->type == CPP_EOF)\n \treturn;\n+      if (token->type == CPP_PRAGMA_EOL && parser->in_pragma)\n+\treturn;\n       /* If the next token is a ';', we have reached the end of the\n \t statement.  */\n       if (token->type == CPP_SEMICOLON && !nesting_depth)\n@@ -828,6 +852,31 @@ c_parser_skip_to_end_of_block_or_statement (c_parser *parser)\n   parser->error = false;\n }\n \n+/* Expect to be at the end of the pragma directive and consume an\n+   end of line marker.  */\n+\n+static void\n+c_parser_skip_to_pragma_eol (c_parser *parser)\n+{\n+  gcc_assert (parser->in_pragma);\n+  parser->in_pragma = false;\n+\n+  if (!c_parser_require (parser, CPP_PRAGMA_EOL, \"expected end of line\"))\n+    while (true)\n+      {\n+\tc_token *token = c_parser_peek_token (parser);\n+\tif (token->type == CPP_EOF)\n+\t  break;\n+\tif (token->type == CPP_PRAGMA_EOL)\n+\t  {\n+\t    c_parser_consume_token (parser);\n+\t    break;\n+\t  }\n+\tc_parser_consume_token (parser);\n+      }\n+\n+  parser->error = false;\n+}\n \n /* Save the warning flags which are controlled by __extension__.  */\n \n@@ -932,6 +981,9 @@ static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static tree c_parser_expr_list (c_parser *, bool);\n \n+enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n+static bool c_parser_pragma (c_parser *, enum pragma_context);\n+\n /* These Objective-C parser functions are only ever called when\n    compiling Objective-C.  */\n static void c_parser_objc_class_definition (c_parser *);\n@@ -1063,6 +1115,9 @@ c_parser_external_declaration (c_parser *parser)\n \tpedwarn (\"ISO C does not allow extra %<;%> outside of a function\");\n       c_parser_consume_token (parser);\n       break;\n+    case CPP_PRAGMA:\n+      c_parser_pragma (parser, pragma_external);\n+      break;\n     case CPP_PLUS:\n     case CPP_MINUS:\n       if (c_dialect_objc ())\n@@ -1082,6 +1137,7 @@ c_parser_external_declaration (c_parser *parser)\n     }\n }\n \n+\n /* Parse a declaration or function definition (C90 6.5, 6.7.1, C99\n    6.7, 6.9.1).  If FNDEF_OK is true, a function definition is\n    accepted; otherwise (old-style parameter declarations) only other\n@@ -1142,6 +1198,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n   tree prefix_attrs;\n   tree all_prefix_attrs;\n   bool diagnosed_no_specs = false;\n+\n   specs = build_null_declspecs ();\n   c_parser_declspecs (parser, specs, true, true, start_attr_ok);\n   if (parser->error)\n@@ -1808,6 +1865,12 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t      c_parser_consume_token (parser);\n \t      break;\n \t    }\n+\t  /* Accept #pragmas at struct scope.  */\n+\t  if (c_parser_next_token_is (parser, CPP_PRAGMA))\n+\t    {\n+\t      c_parser_pragma (parser, pragma_external);\n+\t      continue;\n+\t    }\n \t  /* Parse some comma-separated declarations, but not the\n \t     trailing semicolon if any.  */\n \t  decls = c_parser_struct_declaration (parser);\n@@ -3268,11 +3331,6 @@ c_parser_compound_statement_nostart (c_parser *parser)\n   while (c_parser_next_token_is_not (parser, CPP_CLOSE_BRACE))\n     {\n       location_t loc = c_parser_peek_token (parser)->location;\n-      if (c_parser_next_token_is (parser, CPP_EOF))\n-\t{\n-\t  c_parser_error (parser, \"expected declaration or statement\");\n-\t  return;\n-\t}\n       if (c_parser_next_token_is_keyword (parser, RID_CASE)\n \t  || c_parser_next_token_is_keyword (parser, RID_DEFAULT)\n \t  || (c_parser_next_token_is (parser, CPP_NAME)\n@@ -3325,6 +3383,21 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  else\n \t    goto statement;\n \t}\n+      else if (c_parser_next_token_is (parser, CPP_PRAGMA))\n+\t{\n+\t  /* External pragmas, and some omp pragmas, are not associated\n+\t     with regular c code, and so are not to be considered statements\n+\t     syntactically.  This ensures that the user doesn't put them\n+\t     places that would turn into syntax errors if the directive\n+\t     were ignored.  */\n+\t  if (c_parser_pragma (parser, pragma_compound))\n+\t    last_label = false, last_stmt = true;\n+\t}\n+      else if (c_parser_next_token_is (parser, CPP_EOF))\n+\t{\n+\t  c_parser_error (parser, \"expected declaration or statement\");\n+\t  return;\n+\t}\n       else\n \t{\n \tstatement:\n@@ -3578,6 +3651,9 @@ c_parser_statement_after_labels (c_parser *parser)\n       c_parser_error (parser, \"expected statement\");\n       c_parser_consume_token (parser);\n       break;\n+    case CPP_PRAGMA:\n+      c_parser_pragma (parser, pragma_stmt);\n+      break;\n     default:\n     expr_stmt:\n       stmt = c_finish_expr_stmt (c_parser_expression_conv (parser).value);\n@@ -5558,6 +5634,12 @@ c_parser_objc_class_instance_variables (c_parser *parser)\n \t  objc_set_visibility (1);\n \t  continue;\n \t}\n+      else if (c_parser_next_token_is (parser, CPP_PRAGMA))\n+\t{\n+\t  c_parser_pragma (parser, pragma_external);\n+\t  continue;\n+\t}\n+\n       /* Parse some comma-separated declarations.  */\n       decls = c_parser_struct_declaration (parser);\n       {\n@@ -6262,17 +6344,101 @@ c_parser_objc_keywordexpr (c_parser *parser)\n }\n \n \f\n-/* The actual parser and external interface.  ??? Does this need to be\n-   garbage-collected?  */\n+/* Handle pragmas.  ALLOW_STMT is true if we're within the context of\n+   a function and such pragmas are to be allowed.  Returns true if we\n+   actually parsed such a pragma.  */\n \n-static GTY (()) c_parser *the_parser;\n+static bool\n+c_parser_pragma (c_parser *parser, enum pragma_context context ATTRIBUTE_UNUSED)\n+{\n+  unsigned int id;\n+\n+  id = c_parser_peek_token (parser)->pragma_kind;\n+  gcc_assert (id != PRAGMA_NONE);\n+\n+  switch (id)\n+    {\n+    case PRAGMA_GCC_PCH_PREPROCESS:\n+      c_parser_error (parser, \"%<#pragma GCC pch_preprocess%> must be first\");\n+      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n+      return false;\n+\n+    default:\n+      gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n+      break;\n+    }\n+\n+  c_parser_consume_pragma (parser);\n+  c_invoke_pragma_handler (id);\n \n+  /* Skip to EOL, but suppress any error message.  Those will have been \n+     generated by the handler routine through calling error, as opposed\n+     to calling c_parser_error.  */\n+  parser->error = true;\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  return false;\n+}\n+\n+/* The interface the pragma parsers have to the lexer.  */\n+\n+enum cpp_ttype\n+pragma_lex (tree *value)\n+{\n+  c_token *tok = c_parser_peek_token (the_parser);\n+  enum cpp_ttype ret = tok->type;\n+\n+  *value = tok->value;\n+  if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)\n+    ret = CPP_EOF;\n+  else\n+    {\n+      if (ret == CPP_KEYWORD)\n+\tret = CPP_NAME;\n+      c_parser_consume_token (the_parser);\n+    }\n+\n+  return ret;\n+}\n+\n+static void\n+c_parser_pragma_pch_preprocess (c_parser *parser)\n+{\n+  tree name = NULL;\n+\n+  c_parser_consume_pragma (parser);\n+  if (c_parser_next_token_is (parser, CPP_STRING))\n+    {\n+      name = c_parser_peek_token (parser)->value;\n+      c_parser_consume_token (parser);\n+    }\n+  else\n+    c_parser_error (parser, \"expected string literal\");\n+  c_parser_skip_to_pragma_eol (parser);\n+\n+  if (name)\n+    c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n+}\n+\f\n /* Parse a single source file.  */\n \n void\n c_parse_file (void)\n {\n-  the_parser = c_parser_new ();\n+  /* Use local storage to begin.  If the first token is a pragma, parse it.\n+     If it is #pragma GCC pch_preprocess, then this will load a PCH file\n+     which will cause garbage collection.  */\n+  c_parser tparser;\n+\n+  memset (&tparser, 0, sizeof tparser);\n+  the_parser = &tparser;\n+\n+  if (c_parser_peek_token (&tparser)->pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)\n+    c_parser_pragma_pch_preprocess (&tparser);\n+\n+  the_parser = GGC_NEW (c_parser);\n+  *the_parser = tparser;\n+\n   c_parser_translation_unit (the_parser);\n   the_parser = NULL;\n }"}, {"sha": "37c8c30da9c47a776c5867372741da8a3aed97ee", "filename": "gcc/c-pch.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -441,27 +441,17 @@ c_common_no_more_pch (void)\n #endif\n \n void\n-c_common_pch_pragma (cpp_reader *pfile)\n+c_common_pch_pragma (cpp_reader *pfile, const char *name)\n {\n-  tree name_t;\n-  const char *name;\n   int fd;\n \n-  if (pragma_lex (&name_t) != CPP_STRING)\n-    {\n-      error (\"malformed #pragma GCC pch_preprocess, ignored\");\n-      return;\n-    }\n-\n   if (!cpp_get_options (pfile)->preprocessed)\n     {\n       error (\"pch_preprocess pragma should only be used with -fpreprocessed\");\n       inform (\"use #include instead\");\n       return;\n     }\n \n-  name = TREE_STRING_POINTER (name_t);\n-  \n   fd = open (name, O_RDONLY | O_BINARY, 0666);\n   if (fd == -1)\n     fatal_error (\"%s: couldn%'t open PCH file: %m\", name);"}, {"sha": "e2a46773a9551057e13ef5832ca8854d99130aaa", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"vec.h\"\n #include \"target.h\"\n \n+\n #define GCC_BAD(gmsgid) \\\n   do { warning (OPT_Wpragmas, gmsgid); return; } while (0)\n #define GCC_BAD2(gmsgid, arg) \\\n@@ -343,7 +344,7 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n       t = pragma_lex (&x);\n     }\n   if (t != CPP_EOF)\n-    warning (OPT_Wpragmas, \"junk at end of #pragma weak\");\n+    warning (OPT_Wpragmas, \"junk at end of %<#pragma weak%>\");\n \n   decl = identifier_global_value (name);\n   if (decl && DECL_P (decl))\n@@ -416,7 +417,7 @@ handle_pragma_redefine_extname (cpp_reader * ARG_UNUSED (dummy))\n     GCC_BAD (\"malformed #pragma redefine_extname, ignored\");\n   t = pragma_lex (&x);\n   if (t != CPP_EOF)\n-    warning (OPT_Wpragmas, \"junk at end of #pragma redefine_extname\");\n+    warning (OPT_Wpragmas, \"junk at end of %<#pragma redefine_extname%>\");\n \n   if (!flag_mudflap && !targetm.handle_pragma_redefine_extname)\n     {\n@@ -484,7 +485,7 @@ handle_pragma_extern_prefix (cpp_reader * ARG_UNUSED (dummy))\n     GCC_BAD (\"malformed #pragma extern_prefix, ignored\");\n   t = pragma_lex (&x);\n   if (t != CPP_EOF)\n-    warning (OPT_Wpragmas, \"junk at end of #pragma extern_prefix\");\n+    warning (OPT_Wpragmas, \"junk at end of %<#pragma extern_prefix%>\");\n \n   if (targetm.handle_pragma_extern_prefix)\n     /* Note that the length includes the null terminator.  */\n@@ -667,26 +668,65 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n \n #endif\n \n+/* A vector of registered pragma callbacks.  */\n+\n+DEF_VEC_O (pragma_handler);\n+DEF_VEC_ALLOC_O (pragma_handler, heap);\n+\n+static VEC(pragma_handler, heap) *registered_pragmas;\n+\n /* Front-end wrappers for pragma registration to avoid dragging\n    cpplib.h in almost everywhere.  */\n+\n+static void\n+c_register_pragma_1 (const char *space, const char *name,\n+\t\t     pragma_handler handler, bool allow_expansion)\n+{\n+  unsigned id;\n+\n+  VEC_safe_push (pragma_handler, heap, registered_pragmas, &handler);\n+  id = VEC_length (pragma_handler, registered_pragmas);\n+  id += PRAGMA_FIRST_EXTERNAL - 1;\n+\n+  /* The C++ front end allocates 6 bits in cp_token; the C front end\n+     allocates 7 bits in c_token.  At present this is sufficient.  */\n+  gcc_assert (id < 64);\n+\n+  cpp_register_deferred_pragma (parse_in, space, name, id,\n+\t\t\t\tallow_expansion, false);\n+}\n+\n void\n-c_register_pragma (const char *space, const char *name,\n-\t\t   void (*handler) (struct cpp_reader *))\n+c_register_pragma (const char *space, const char *name, pragma_handler handler)\n {\n-  cpp_register_pragma (parse_in, space, name, handler, 0);\n+  c_register_pragma_1 (space, name, handler, false);\n }\n \n void\n c_register_pragma_with_expansion (const char *space, const char *name,\n-\t\t\t\t  void (*handler) (struct cpp_reader *))\n+\t\t\t\t  pragma_handler handler)\n+{\n+  c_register_pragma_1 (space, name, handler, true);\n+}\n+\n+void\n+c_invoke_pragma_handler (unsigned int id)\n {\n-  cpp_register_pragma (parse_in, space, name, handler, 1);\n+  pragma_handler handler;\n+\n+  id -= PRAGMA_FIRST_EXTERNAL;\n+  handler = *VEC_index (pragma_handler, registered_pragmas, id);\n+\n+  handler (parse_in);\n }\n \n /* Set up front-end pragmas.  */\n void\n init_pragma (void)\n {\n+  cpp_register_deferred_pragma (parse_in, \"GCC\", \"pch_preprocess\",\n+\t\t\t\tPRAGMA_GCC_PCH_PREPROCESS, false, false);\n+\n #ifdef HANDLE_PRAGMA_PACK\n #ifdef HANDLE_PRAGMA_PACK_WITH_EXPANSION\n   c_register_pragma_with_expansion (0, \"pack\", handle_pragma_pack);\n@@ -704,8 +744,6 @@ init_pragma (void)\n   c_register_pragma (0, \"redefine_extname\", handle_pragma_redefine_extname);\n   c_register_pragma (0, \"extern_prefix\", handle_pragma_extern_prefix);\n \n-  c_register_pragma (\"GCC\", \"pch_preprocess\", c_common_pch_pragma);\n-\n #ifdef REGISTER_TARGET_PRAGMAS\n   REGISTER_TARGET_PRAGMAS ();\n #endif"}, {"sha": "98765555ef4b2b924152359961eed271e615e341", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -24,6 +24,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include <cpplib.h> /* For enum cpp_ttype.  */\n \n+/* Pragma identifiers built in to the front end parsers.  Identifiers\n+   for anciliary handlers will follow these.  */\n+typedef enum pragma_kind {\n+  PRAGMA_NONE = 0,\n+\n+  PRAGMA_GCC_PCH_PREPROCESS,\n+\n+  PRAGMA_FIRST_EXTERNAL\n+} pragma_kind;\n+\n /* Cause the `yydebug' variable to be defined.  */\n #define YYDEBUG 1\n extern int yydebug;\n@@ -53,18 +63,23 @@ extern struct cpp_reader* parse_in;\n \n extern void init_pragma (void);\n \n-/* Front-end wrappers for pragma registration to avoid dragging\n-   cpplib.h in almost everywhere.  */\n-extern void c_register_pragma (const char *, const char *,\n-\t\t\t       void (*) (struct cpp_reader *));\n+/* Front-end wrappers for pragma registration.  */\n+typedef void (*pragma_handler)(struct cpp_reader *);\n+extern void c_register_pragma (const char *, const char *, pragma_handler);\n extern void c_register_pragma_with_expansion (const char *, const char *,\n-\t\t\t\t\t      void (*) (struct cpp_reader *));\n+\t\t\t\t\t      pragma_handler);\n+extern void c_invoke_pragma_handler (unsigned int);\n+\n extern void maybe_apply_pragma_weak (tree);\n extern void maybe_apply_pending_pragma_weaks (void);\n extern tree maybe_apply_renaming_pragma (tree, tree);\n extern void add_to_renaming_pragma_list (tree, tree);\n \n extern enum cpp_ttype pragma_lex (tree *);\n+\n+/* This is not actually available to pragma parsers.  It's merely a\n+   convenient location to declare this function for c-lex, after\n+   having enum cpp_ttype declared.  */\n extern enum cpp_ttype c_lex_with_flags (tree *, location_t *, unsigned char *);\n \n /* If 1, then lex strings into the execution character set.  "}, {"sha": "1dbf6004e9a4eedf0007b12a678ff182d5a263e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -1,4 +1,41 @@\n-2002-01-04  Dirk Mueller <dmueller@suse.com>\n+2006-01-04  Richard Henderson  <rth@redhat.com>\n+\n+\tMerge from gomp branch.\n+\t* lex.c (handle_pragma_java_exceptions): Fix whitespace.\n+\t* parser.c (struct cp_token): Add pragma_kind.\n+\t(eof_token): Update to match.\n+\t(struct cp_lexer): Add in_pragma; rearrange next for better packing.\n+\t(cp_parser_initial_pragma): New.\n+\t(cp_lexer_new_main): Use it.  Don't bother clearing\n+\tc_lex_return_raw_strings.\n+\t(cp_lexer_get_preprocessor_token): Always initialize keyword\n+\tand pragma_kind fields.  Handle CPP_PRAGMA.\n+\t(cp_lexer_consume_token): Don't allow CPP_PRAGMA_EOL when \n+\tin_pragma is set.\n+\t(cp_lexer_handle_pragma): Remove.  Update callers to cp_parser_pragma.\n+\t(cp_lexer_print_token) <CPP_PRAGMA>: Don't print as a string.\n+\t(cp_parser_skip_to_pragma_eol): New.\n+\t(cp_parser_error): Use it.\n+\t(cp_parser_skip_to_closing_parenthesis): Stop at CPP_PRAGMA_EOL;\n+\trearrange with switch statement.\n+\t(cp_parser_skip_to_end_of_statement): Likewise.\n+\t(cp_parser_skip_to_end_of_block_or_statement): Likewise.\n+\t(cp_parser_skip_to_closing_brace): Likewise.\n+\t(cp_parser_skip_until_found): Likewise.\n+\t(cp_parser_statement): Add in_compound argument; update callers.\n+\tUse it to decide how to handle pragma parsing.\n+\t(cp_parser_labeled_statement): Add in_compound argument; pass\n+\tit on to cp_parser_statement.\n+\t(cp_parser_statement_seq_opt): Stop at CPP_PRAGMA_EOL.\n+\t(cp_parser_declaration_seq_opt): Likewise.\n+\t(cp_parser_parameter_declaration): Likewise.\n+\t(cp_parser_member_specification_opt): Likewise.\n+\t(cp_parser_function_definition_after_decl): Likewise.\n+\t(cp_parser_cache_group): Handle CPP_PRAGMA/CPP_PRAGMA_EOL pairs.\n+\t(cp_parser_pragma): New.\n+\t(pragma_lex): New.\n+\n+2006-01-04  Dirk Mueller <dmueller@suse.com>\n \n \t* decl.c (finish_constructor_body): create simple\n \tcompound stmt instead of a if(1) { } construct."}, {"sha": "a8004326564a8b39d02c2564d3453b9acc0e03b8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -580,7 +580,7 @@ handle_pragma_implementation (cpp_reader* dfile ATTRIBUTE_UNUSED )\n \n /* Indicate that this file uses Java-personality exception handling.  */\n static void\n-handle_pragma_java_exceptions (cpp_reader* dfile ATTRIBUTE_UNUSED )\n+handle_pragma_java_exceptions (cpp_reader* dfile ATTRIBUTE_UNUSED)\n {\n   tree x;\n   if (pragma_lex (&x) != CPP_EOF)"}, {"sha": "86763eb42bdfbf513168c982478c025a6ae6f5d5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 333, "deletions": 169, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -55,6 +55,8 @@ typedef struct cp_token GTY (())\n   ENUM_BITFIELD (rid) keyword : 8;\n   /* Token flags.  */\n   unsigned char flags;\n+  /* Identifier for the pragma.  */\n+  ENUM_BITFIELD (pragma_kind) pragma_kind : 6;\n   /* True if this token is from a system header.  */\n   BOOL_BITFIELD in_system_header : 1;\n   /* True if this token is from a context where it is implicitly extern \"C\" */\n@@ -76,7 +78,7 @@ DEF_VEC_ALLOC_P (cp_token_position,heap);\n \n static const cp_token eof_token =\n {\n-  CPP_EOF, RID_MAX, 0, 0, 0, false, NULL_TREE,\n+  CPP_EOF, RID_MAX, 0, PRAGMA_NONE, 0, 0, false, NULL_TREE,\n #if USE_MAPPED_LOCATION\n   0\n #else\n@@ -112,11 +114,15 @@ typedef struct cp_lexer GTY (())\n      tokens.  */\n   VEC(cp_token_position,heap) *GTY ((skip)) saved_tokens;\n \n+  /* The next lexer in a linked list of lexers.  */\n+  struct cp_lexer *next;\n+\n   /* True if we should output debugging information.  */\n   bool debugging_p;\n \n-  /* The next lexer in a linked list of lexers.  */\n-  struct cp_lexer *next;\n+  /* True if we're in the context of parsing a pragma, and should not\n+     increment past the end-of-line marker.  */\n+  bool in_pragma;\n } cp_lexer;\n \n /* cp_token_cache is a range of tokens.  There is no need to represent\n@@ -166,8 +172,6 @@ static void cp_lexer_purge_token\n   (cp_lexer *);\n static void cp_lexer_purge_tokens_after\n   (cp_lexer *, cp_token_position);\n-static void cp_lexer_handle_pragma\n-  (cp_lexer *);\n static void cp_lexer_save_tokens\n   (cp_lexer *);\n static void cp_lexer_commit_tokens\n@@ -196,6 +200,9 @@ static void cp_lexer_stop_debugging\n static cp_token_cache *cp_token_cache_new\n   (cp_token *, cp_token *);\n \n+static void cp_parser_initial_pragma\n+  (cp_token *);\n+\n /* Manifest constants.  */\n #define CP_LEXER_BUFFER_SIZE 10000\n #define CP_SAVED_TOKEN_STACK 5\n@@ -244,17 +251,12 @@ cp_lexer_new_main (void)\n   size_t space;\n   cp_token *buffer;\n \n-  /* It's possible that lexing the first token will load a PCH file,\n-     which is a GC collection point.  So we have to grab the first\n-     token before allocating any memory.  Pragmas must not be deferred\n-     as -fpch-preprocess can generate a pragma to load the PCH file in\n-     the preprocessed output used by -save-temps.  */\n-  cp_lexer_get_preprocessor_token (NULL, &first_token);\n-\n-  /* Tell cpplib we want CPP_PRAGMA tokens.  */\n-  cpp_get_options (parse_in)->defer_pragmas = true;\n+  /* It's possible that parsing the first pragma will load a PCH file,\n+     which is a GC collection point.  So we have to do that before\n+     allocating any memory.  */\n+  cp_parser_initial_pragma (&first_token);\n \n-  /* Tell pragma_lex not to merge string constants.  */\n+  /* Tell c_lex_with_flags not to merge string constants.  */\n   c_lex_return_raw_strings = true;\n \n   c_common_no_more_pch ();\n@@ -296,11 +298,6 @@ cp_lexer_new_main (void)\n   lexer->last_token = pos;\n   lexer->next_token = lexer->buffer_length ? buffer : (cp_token *)&eof_token;\n \n-  /* Pragma processing (via cpp_handle_deferred_pragma) may result in\n-     direct calls to pragma_lex.  Those callers all expect pragma_lex\n-     to do string constant concatenation.  */\n-  c_lex_return_raw_strings = false;\n-\n   /* Subsequent preprocessor diagnostics should use compiler\n      diagnostic functions to get the compiler source location.  */\n   cpp_get_options (parse_in)->client_diagnostic = true;\n@@ -395,6 +392,8 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n    /* Get a new token from the preprocessor.  */\n   token->type\n     = c_lex_with_flags (&token->value, &token->location, &token->flags);\n+  token->keyword = RID_MAX;\n+  token->pragma_kind = PRAGMA_NONE;\n   token->in_system_header = in_system_header;\n \n   /* On some systems, some header files are surrounded by an\n@@ -442,8 +441,12 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \tdefault: token->keyword = C_RID_CODE (token->value);\n \t}\n     }\n-  else\n-    token->keyword = RID_MAX;\n+  else if (token->type == CPP_PRAGMA)\n+    {\n+      /* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */\n+      token->pragma_kind = TREE_INT_CST_LOW (token->value);\n+      token->value = NULL;\n+    }\n }\n \n /* Update the globals input_location and in_system_header from TOKEN.  */\n@@ -553,6 +556,7 @@ cp_lexer_consume_token (cp_lexer* lexer)\n   cp_token *token = lexer->next_token;\n \n   gcc_assert (token != &eof_token);\n+  gcc_assert (!lexer->in_pragma || token->type != CPP_PRAGMA_EOL);\n \n   do\n     {\n@@ -630,25 +634,6 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)\n     }\n }\n \n-/* Consume and handle a pragma token.  */\n-static void\n-cp_lexer_handle_pragma (cp_lexer *lexer)\n-{\n-  cpp_string s;\n-  cp_token *token = cp_lexer_consume_token (lexer);\n-  gcc_assert (token->type == CPP_PRAGMA);\n-  gcc_assert (token->value);\n-\n-  s.len = TREE_STRING_LENGTH (token->value);\n-  s.text = (const unsigned char *) TREE_STRING_POINTER (token->value);\n-\n-  cpp_handle_deferred_pragma (parse_in, &s);\n-\n-  /* Clearing token->value here means that we will get an ICE if we\n-     try to process this #pragma again (which should be impossible).  */\n-  token->value = NULL;\n-}\n-\n /* Begin saving tokens.  All tokens consumed after this point will be\n    preserved.  */\n \n@@ -731,7 +716,6 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-    case CPP_PRAGMA:\n       fprintf (stream, \" \\\"%s\\\"\", TREE_STRING_POINTER (token->value));\n       break;\n \n@@ -1463,9 +1447,9 @@ static tree cp_parser_builtin_offsetof\n /* Statements [gram.stmt.stmt]  */\n \n static void cp_parser_statement\n-  (cp_parser *, tree);\n+  (cp_parser *, tree, bool);\n static tree cp_parser_labeled_statement\n-  (cp_parser *, tree);\n+  (cp_parser *, tree, bool);\n static tree cp_parser_expression_statement\n   (cp_parser *, tree);\n static tree cp_parser_compound_statement\n@@ -1685,6 +1669,10 @@ static bool cp_parser_extension_opt\n static void cp_parser_label_declaration\n   (cp_parser *);\n \n+enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n+static bool cp_parser_pragma\n+  (cp_parser *, enum pragma_context);\n+\n /* Objective-C++ Productions */\n \n static tree cp_parser_objc_message_receiver\n@@ -1828,6 +1816,8 @@ static void cp_parser_skip_to_closing_brace\n   (cp_parser *);\n static void cp_parser_skip_until_found\n   (cp_parser *, enum cpp_ttype, const char *);\n+static void cp_parser_skip_to_pragma_eol\n+  (cp_parser*, cp_token *);\n static bool cp_parser_error_occurred\n   (cp_parser *);\n static bool cp_parser_allow_gnu_extensions_p\n@@ -1888,12 +1878,14 @@ cp_parser_error (cp_parser* parser, const char* message)\n       /* This diagnostic makes more sense if it is tagged to the line\n \t of the token we just peeked at.  */\n       cp_lexer_set_source_position_from_token (token);\n+\n       if (token->type == CPP_PRAGMA)\n \t{\n \t  error (\"%<#pragma%> is not allowed here\");\n-\t  cp_lexer_purge_token (parser->lexer);\n+\t  cp_parser_skip_to_pragma_eol (parser, token);\n \t  return;\n \t}\n+\n       c_parse_error (message,\n \t\t     /* Because c_parser_error does not understand\n \t\t\tCPP_KEYWORD, keywords are treated like\n@@ -2187,70 +2179,62 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n {\n   unsigned paren_depth = 0;\n   unsigned brace_depth = 0;\n-  int result;\n \n   if (recovering && !or_comma\n       && cp_parser_uncommitted_to_tentative_parse_p (parser))\n     return 0;\n \n   while (true)\n     {\n-      cp_token *token;\n+      cp_token * token = cp_lexer_peek_token (parser->lexer);\n \n-      /* If we've run out of tokens, then there is no closing `)'.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+      switch (token->type)\n \t{\n-\t  result = 0;\n-\t  break;\n-\t}\n+\tcase CPP_EOF:\n+\tcase CPP_PRAGMA_EOL:\n+\t  /* If we've run out of tokens, then there is no closing `)'.  */\n+\t  return 0;\n \n-      token = cp_lexer_peek_token (parser->lexer);\n+\tcase CPP_SEMICOLON:\n+\t  /* This matches the processing in skip_to_end_of_statement.  */\n+\t  if (!brace_depth)\n+\t    return 0;\n+\t  break;\n \n-      /* This matches the processing in skip_to_end_of_statement.  */\n-      if (token->type == CPP_SEMICOLON && !brace_depth)\n-\t{\n-\t  result = 0;\n+\tcase CPP_OPEN_BRACE:\n+\t  ++brace_depth;\n \t  break;\n-\t}\n-      if (token->type == CPP_OPEN_BRACE)\n-\t++brace_depth;\n-      if (token->type == CPP_CLOSE_BRACE)\n-\t{\n+\tcase CPP_CLOSE_BRACE:\n \t  if (!brace_depth--)\n-\t    {\n-\t      result = 0;\n-\t      break;\n-\t    }\n-\t}\n-      if (recovering && or_comma && token->type == CPP_COMMA\n-\t  && !brace_depth && !paren_depth)\n-\t{\n-\t  result = -1;\n+\t    return 0;\n \t  break;\n-\t}\n \n-      if (!brace_depth)\n-\t{\n-\t  /* If it is an `(', we have entered another level of nesting.  */\n-\t  if (token->type == CPP_OPEN_PAREN)\n+\tcase CPP_COMMA:\n+\t  if (recovering && or_comma && !brace_depth && !paren_depth)\n+\t    return -1;\n+\t  break;\n+\n+\tcase CPP_OPEN_PAREN:\n+\t  if (!brace_depth)\n \t    ++paren_depth;\n-\t  /* If it is a `)', then we might be done.  */\n-\t  else if (token->type == CPP_CLOSE_PAREN && !paren_depth--)\n+\t  break;\n+\n+\tcase CPP_CLOSE_PAREN:\n+\t  if (!brace_depth && !paren_depth--)\n \t    {\n \t      if (consume_paren)\n \t\tcp_lexer_consume_token (parser->lexer);\n-\t      {\n-\t\tresult = 1;\n-\t\tbreak;\n-\t      }\n+\t      return 1;\n \t    }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n \n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n-\n-  return result;\n }\n \n /* Consume tokens until we reach the end of the current statement.\n@@ -2264,31 +2248,34 @@ cp_parser_skip_to_end_of_statement (cp_parser* parser)\n \n   while (true)\n     {\n-      cp_token *token;\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If we've run out of tokens, stop.  */\n-      if (token->type == CPP_EOF)\n-\tbreak;\n-      /* If the next token is a `;', we have reached the end of the\n-\t statement.  */\n-      if (token->type == CPP_SEMICOLON && !nesting_depth)\n-\tbreak;\n-      /* If the next token is a non-nested `}', then we have reached\n-\t the end of the current block.  */\n-      if (token->type == CPP_CLOSE_BRACE)\n+      switch (token->type)\n \t{\n-\t  /* If this is a non-nested `}', stop before consuming it.\n+\tcase CPP_EOF:\n+\tcase CPP_PRAGMA_EOL:\n+\t  /* If we've run out of tokens, stop.  */\n+\t  return;\n+\n+\tcase CPP_SEMICOLON:\n+\t  /* If the next token is a `;', we have reached the end of the\n+\t     statement.  */\n+\t  if (!nesting_depth)\n+\t    return;\n+\t  break;\n+\n+\tcase CPP_CLOSE_BRACE:\n+\t  /* If this is a non-nested '}', stop before consuming it.\n \t     That way, when confronted with something like:\n \n \t       { 3 + }\n \n-\t     we stop before consuming the closing `}', even though we\n+\t     we stop before consuming the closing '}', even though we\n \t     have not yet reached a `;'.  */\n \t  if (nesting_depth == 0)\n-\t    break;\n-\t  /* If it is the closing `}' for a block that we have\n+\t    return;\n+\n+\t  /* If it is the closing '}' for a block that we have\n \t     scanned, stop -- but only after consuming the token.\n \t     That way given:\n \n@@ -2301,13 +2288,17 @@ cp_parser_skip_to_end_of_statement (cp_parser* parser)\n \t  if (--nesting_depth == 0)\n \t    {\n \t      cp_lexer_consume_token (parser->lexer);\n-\t      break;\n+\t      return;\n \t    }\n+\n+\tcase CPP_OPEN_BRACE:\n+\t  ++nesting_depth;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n-      /* If it the next token is a `{', then we are entering a new\n-\t block.  Consume the entire block.  */\n-      else if (token->type == CPP_OPEN_BRACE)\n-\t++nesting_depth;\n+\n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n@@ -2344,15 +2335,12 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n     {\n       cp_token *token = cp_lexer_peek_token (parser->lexer);\n \n-      if (token->type == CPP_EOF)\n-\tbreak;\n-\n       switch (token->type)\n \t{\n \tcase CPP_EOF:\n+\tcase CPP_PRAGMA_EOL:\n \t  /* If we've run out of tokens, stop.  */\n-\t  nesting_depth = -1;\n-\t  continue;\n+\t  return;\n \n \tcase CPP_SEMICOLON:\n \t  /* Stop if this is an unnested ';'. */\n@@ -2379,7 +2367,6 @@ cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n \n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n-\n     }\n }\n \n@@ -2393,26 +2380,56 @@ cp_parser_skip_to_closing_brace (cp_parser *parser)\n \n   while (true)\n     {\n-      cp_token *token;\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+      switch (token->type)\n+\t{\n+\tcase CPP_EOF:\n+\tcase CPP_PRAGMA_EOL:\n+\t  /* If we've run out of tokens, stop.  */\n+\t  return;\n+\n+\tcase CPP_CLOSE_BRACE:\n+\t  /* If the next token is a non-nested `}', then we have reached\n+\t     the end of the current block.  */\n+\t  if (nesting_depth-- == 0)\n+\t    return;\n+\t  break;\n+\n+\tcase CPP_OPEN_BRACE:\n+\t  /* If it the next token is a `{', then we are entering a new\n+\t     block.  Consume the entire block.  */\n+\t  ++nesting_depth;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n \n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      /* If we've run out of tokens, stop.  */\n-      if (token->type == CPP_EOF)\n-\tbreak;\n-      /* If the next token is a non-nested `}', then we have reached\n-\t the end of the current block.  */\n-      if (token->type == CPP_CLOSE_BRACE && nesting_depth-- == 0)\n-\tbreak;\n-      /* If it the next token is a `{', then we are entering a new\n-\t block.  Consume the entire block.  */\n-      else if (token->type == CPP_OPEN_BRACE)\n-\t++nesting_depth;\n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n }\n \n+/* Consume tokens until we reach the end of the pragma.  The PRAGMA_TOK\n+   parameter is the PRAGMA token, allowing us to purge the entire pragma\n+   sequence.  */\n+\n+static void\n+cp_parser_skip_to_pragma_eol (cp_parser* parser, cp_token *pragma_tok)\n+{\n+  cp_token *token;\n+\n+  parser->lexer->in_pragma = false;\n+\n+  do\n+    token = cp_lexer_consume_token (parser->lexer);\n+  while (token->type != CPP_PRAGMA_EOL && token->type != CPP_EOF);\n+\n+  /* Ensure that the pragma is not parsed again.  */\n+  cp_lexer_purge_tokens_after (parser->lexer, pragma_tok);\n+}\n+\n /* This is a simple wrapper around make_typename_type. When the id is\n    an unresolved identifier node, we can provide a superior diagnostic\n    using cp_parser_diagnose_invalid_type_name.  */\n@@ -6005,15 +6022,20 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n      iteration-statement\n      jump-statement\n      declaration-statement\n-     try-block  */\n+     try-block\n+\n+  IN_COMPOUND is true when the statement is nested inside a \n+  cp_parser_compound_statement; this matters for certain pragmas.  */\n \n static void\n-cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n+cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n+\t\t     bool in_compound)\n {\n   tree statement;\n   cp_token *token;\n   location_t statement_location;\n \n+ restart:\n   /* There is no statement yet.  */\n   statement = NULL_TREE;\n   /* Peek at the next token.  */\n@@ -6030,8 +6052,8 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n \t{\n \tcase RID_CASE:\n \tcase RID_DEFAULT:\n-\t  statement = cp_parser_labeled_statement (parser,\n-\t\t\t\t\t\t   in_statement_expr);\n+\t  statement = cp_parser_labeled_statement (parser, in_statement_expr,\n+\t\t\t\t\t\t   in_compound);\n \t  break;\n \n \tcase RID_IF:\n@@ -6077,7 +6099,8 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n \t labeled-statement.  */\n       token = cp_lexer_peek_nth_token (parser->lexer, 2);\n       if (token->type == CPP_COLON)\n-\tstatement = cp_parser_labeled_statement (parser, in_statement_expr);\n+\tstatement = cp_parser_labeled_statement (parser, in_statement_expr,\n+\t\t\t\t\t\t in_compound);\n     }\n   /* Anything that starts with a `{' must be a compound-statement.  */\n   else if (token->type == CPP_OPEN_BRACE)\n@@ -6086,7 +6109,15 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n      a statement all its own.  */\n   else if (token->type == CPP_PRAGMA)\n     {\n-      cp_lexer_handle_pragma (parser->lexer);\n+      /* Only certain OpenMP pragmas are attached to statements, and thus\n+\t are considered statements themselves.  All others are not.  In\n+\t the context of a compound, accept the pragma as a \"statement\" and\n+\t return so that we can check for a close brace.  Otherwise we \n+\t require a real statement and must go back and read one.  */\n+      if (in_compound)\n+\tcp_parser_pragma (parser, pragma_compound);\n+      else if (!cp_parser_pragma (parser, pragma_stmt))\n+\tgoto restart;\n       return;\n     }\n   else if (token->type == CPP_EOF)\n@@ -6132,10 +6163,14 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr)\n      case constant-expression ... constant-expression : statement\n \n    Returns the new CASE_LABEL_EXPR, for a `case' or `default' label.\n-   For an ordinary label, returns a LABEL_EXPR.  */\n+   For an ordinary label, returns a LABEL_EXPR.\n+\n+   IN_COMPOUND is as for cp_parser_statement: true when we're nested\n+   inside a compound.  */\n \n static tree\n-cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr)\n+cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr,\n+\t\t\t     bool in_compound)\n {\n   cp_token *token;\n   tree statement = error_mark_node;\n@@ -6178,20 +6213,21 @@ cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr)\n \telse\n \t  expr_hi = NULL_TREE;\n \n-\tif (!parser->in_switch_statement_p)\n-\t  error (\"case label %qE not within a switch statement\", expr);\n-\telse\n+\tif (parser->in_switch_statement_p)\n \t  statement = finish_case_label (expr, expr_hi);\n+\telse\n+\t  error (\"case label %qE not within a switch statement\", expr);\n       }\n       break;\n \n     case RID_DEFAULT:\n       /* Consume the `default' token.  */\n       cp_lexer_consume_token (parser->lexer);\n-      if (!parser->in_switch_statement_p)\n-\terror (\"case label not within a switch statement\");\n-      else\n+\n+      if (parser->in_switch_statement_p)\n \tstatement = finish_case_label (NULL_TREE, NULL_TREE);\n+      else\n+\terror (\"case label not within a switch statement\");\n       break;\n \n     default:\n@@ -6203,7 +6239,7 @@ cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr)\n   /* Require the `:' token.  */\n   cp_parser_require (parser, CPP_COLON, \"`:'\");\n   /* Parse the labeled statement.  */\n-  cp_parser_statement (parser, in_statement_expr);\n+  cp_parser_statement (parser, in_statement_expr, in_compound);\n \n   /* Return the label, in the case of a `case' or `default' label.  */\n   return statement;\n@@ -6285,13 +6321,16 @@ cp_parser_statement_seq_opt (cp_parser* parser, tree in_statement_expr)\n   /* Scan statements until there aren't any more.  */\n   while (true)\n     {\n+      cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n       /* If we're looking at a `}', then we've run out of statements.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE)\n-\t  || cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+      if (token->type == CPP_CLOSE_BRACE\n+\t  || token->type == CPP_EOF\n+\t  || token->type == CPP_PRAGMA_EOL)\n \tbreak;\n \n       /* Parse the statement.  */\n-      cp_parser_statement (parser, in_statement_expr);\n+      cp_parser_statement (parser, in_statement_expr, true);\n     }\n }\n \n@@ -6788,7 +6827,7 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser)\n       /* Create a compound-statement.  */\n       statement = begin_compound_stmt (0);\n       /* Parse the dependent-statement.  */\n-      cp_parser_statement (parser, false);\n+      cp_parser_statement (parser, NULL_TREE, false);\n       /* Finish the dummy compound-statement.  */\n       finish_compound_stmt (statement);\n     }\n@@ -6810,13 +6849,13 @@ cp_parser_already_scoped_statement (cp_parser* parser)\n {\n   /* If the token is a `{', then we must take special action.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))\n-    cp_parser_statement (parser, false);\n+    cp_parser_statement (parser, NULL_TREE, false);\n   else\n     {\n       /* Avoid calling cp_parser_compound_statement, so that we\n \t don't create a new scope.  Do everything else by hand.  */\n       cp_parser_require (parser, CPP_OPEN_BRACE, \"`{'\");\n-      cp_parser_statement_seq_opt (parser, false);\n+      cp_parser_statement_seq_opt (parser, NULL_TREE);\n       cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n     }\n }\n@@ -6839,7 +6878,8 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n       token = cp_lexer_peek_token (parser->lexer);\n \n       if (token->type == CPP_CLOSE_BRACE\n-\t  || token->type == CPP_EOF)\n+\t  || token->type == CPP_EOF\n+\t  || token->type == CPP_PRAGMA_EOL)\n \tbreak;\n \n       if (token->type == CPP_SEMICOLON)\n@@ -6871,7 +6911,7 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t     A nested declaration cannot, so this is done here and not\n \t     in cp_parser_declaration.  (A #pragma at block scope is\n \t     handled in cp_parser_statement.)  */\n-\t  cp_lexer_handle_pragma (parser->lexer);\n+\t  cp_parser_pragma (parser, pragma_external);\n \t  continue;\n \t}\n \n@@ -12207,6 +12247,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \n \t\t  /* If we run out of tokens, issue an error message.  */\n \t\tcase CPP_EOF:\n+\t\tcase CPP_PRAGMA_EOL:\n \t\t  error (\"file ends in default argument\");\n \t\t  done = true;\n \t\t  break;\n@@ -13242,7 +13283,9 @@ cp_parser_member_specification_opt (cp_parser* parser)\n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       /* If it's a `}', or EOF then we've seen all the members.  */\n-      if (token->type == CPP_CLOSE_BRACE || token->type == CPP_EOF)\n+      if (token->type == CPP_CLOSE_BRACE\n+\t  || token->type == CPP_EOF\n+\t  || token->type == CPP_PRAGMA_EOL)\n \tbreak;\n \n       /* See if this token is a keyword.  */\n@@ -13264,7 +13307,7 @@ cp_parser_member_specification_opt (cp_parser* parser)\n \t  /* Accept #pragmas at class scope.  */\n \t  if (token->type == CPP_PRAGMA)\n \t    {\n-\t      cp_lexer_handle_pragma (parser->lexer);\n+\t      cp_parser_pragma (parser, pragma_external);\n \t      break;\n \t    }\n \n@@ -15185,9 +15228,15 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n       /* Issue an error message.  */\n       error (\"named return values are no longer supported\");\n       /* Skip tokens until we reach the start of the function body.  */\n-      while (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE)\n-\t     && cp_lexer_next_token_is_not (parser->lexer, CPP_EOF))\n-\tcp_lexer_consume_token (parser->lexer);\n+      while (true)\n+\t{\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\t  if (token->type == CPP_OPEN_BRACE\n+\t      || token->type == CPP_EOF\n+\t      || token->type == CPP_PRAGMA_EOL)\n+\t    break;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n     }\n   /* The `extern' in `extern \"C\" void f () { ... }' does not apply to\n      anything declared inside `f'.  */\n@@ -16002,27 +16051,38 @@ cp_parser_skip_until_found (cp_parser* parser,\n     {\n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n-      /* If we've reached the token we want, consume it and\n-\t stop.  */\n+\n+      /* If we've reached the token we want, consume it and stop.  */\n       if (token->type == type && !nesting_depth)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n \t  return;\n \t}\n-      /* If we've run out of tokens, stop.  */\n-      if (token->type == CPP_EOF)\n-\treturn;\n-      if (token->type == CPP_OPEN_BRACE\n-\t  || token->type == CPP_OPEN_PAREN\n-\t  || token->type == CPP_OPEN_SQUARE)\n-\t++nesting_depth;\n-      else if (token->type == CPP_CLOSE_BRACE\n-\t       || token->type == CPP_CLOSE_PAREN\n-\t       || token->type == CPP_CLOSE_SQUARE)\n+\n+      switch (token->type)\n \t{\n+\tcase CPP_EOF:\n+\tcase CPP_PRAGMA_EOL:\n+\t  /* If we've run out of tokens, stop.  */\n+\t  return;\n+\n+\tcase CPP_OPEN_BRACE:\n+\tcase CPP_OPEN_PAREN:\n+\tcase CPP_OPEN_SQUARE:\n+\t  ++nesting_depth;\n+\t  break;\n+\n+\tcase CPP_CLOSE_BRACE:\n+\tcase CPP_CLOSE_PAREN:\n+\tcase CPP_CLOSE_SQUARE:\n \t  if (nesting_depth-- == 0)\n \t    return;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n+\n       /* Consume this token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n@@ -16241,7 +16301,9 @@ cp_parser_cache_group (cp_parser *parser,\n \t  && cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n \treturn;\n       /* If we've reached the end of the file, stop.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_EOF)\n+\t  || (end != CPP_PRAGMA_EOL\n+\t      && cp_lexer_next_token_is (parser->lexer, CPP_PRAGMA_EOL)))\n \treturn;\n       /* Consume the next token.  */\n       token = cp_lexer_consume_token (parser->lexer);\n@@ -16254,6 +16316,8 @@ cp_parser_cache_group (cp_parser *parser,\n \t}\n       else if (token->type == CPP_OPEN_PAREN)\n \tcp_parser_cache_group (parser, CPP_CLOSE_PAREN, depth + 1);\n+      else if (token->type == CPP_PRAGMA)\n+\tcp_parser_cache_group (parser, CPP_PRAGMA_EOL, depth + 1);\n       else if (token->type == end)\n \treturn;\n     }\n@@ -16990,7 +17054,7 @@ cp_parser_objc_interstitial_code (cp_parser* parser)\n     cp_parser_linkage_specification (parser);\n   /* Handle #pragma, if any.  */\n   else if (token->type == CPP_PRAGMA)\n-    cp_lexer_handle_pragma (parser->lexer);\n+    cp_parser_pragma (parser, pragma_external);\n   /* Allow stray semicolons.  */\n   else if (token->type == CPP_SEMICOLON)\n     cp_lexer_consume_token (parser->lexer);\n@@ -17482,11 +17546,111 @@ cp_parser_objc_statement (cp_parser * parser) {\n \n   return error_mark_node;\n }\n-\f\n /* The parser.  */\n \n static GTY (()) cp_parser *the_parser;\n \n+\f\n+/* Special handling for the first token or line in the file.  The first\n+   thing in the file might be #pragma GCC pch_preprocess, which loads a\n+   PCH file, which is a GC collection point.  So we need to handle this\n+   first pragma without benefit of an existing lexer structure.\n+\n+   Always returns one token to the caller in *FIRST_TOKEN.  This is \n+   either the true first token of the file, or the first token after\n+   the initial pragma.  */\n+\n+static void\n+cp_parser_initial_pragma (cp_token *first_token)\n+{\n+  tree name = NULL;\n+\n+  cp_lexer_get_preprocessor_token (NULL, first_token);\n+  if (first_token->pragma_kind != PRAGMA_GCC_PCH_PREPROCESS)\n+    return;\n+\n+  cp_lexer_get_preprocessor_token (NULL, first_token);\n+  if (first_token->type == CPP_STRING)\n+    {\n+      name = first_token->value;\n+\n+      cp_lexer_get_preprocessor_token (NULL, first_token);\n+      if (first_token->type != CPP_PRAGMA_EOL)\n+\terror (\"junk at end of %<#pragma GCC pch_preprocess%>\");\n+    }\n+  else\n+    error (\"expected string literal\");\n+\n+  /* Skip to the end of the pragma.  */\n+  while (first_token->type != CPP_PRAGMA_EOL && first_token->type != CPP_EOF)\n+    cp_lexer_get_preprocessor_token (NULL, first_token);\n+\n+  /* Read one more token to return to our caller.  */\n+  cp_lexer_get_preprocessor_token (NULL, first_token);\n+\n+  /* Now actually load the PCH file.  */\n+  if (name)\n+    c_common_pch_pragma (parse_in, TREE_STRING_POINTER (name));\n+}\n+\n+/* Normal parsing of a pragma token.  Here we can (and must) use the\n+   regular lexer.  */\n+\n+static bool\n+cp_parser_pragma (cp_parser *parser, enum pragma_context context ATTRIBUTE_UNUSED)\n+{\n+  cp_token *pragma_tok;\n+  unsigned int id;\n+\n+  pragma_tok = cp_lexer_consume_token (parser->lexer);\n+  gcc_assert (pragma_tok->type == CPP_PRAGMA);\n+  parser->lexer->in_pragma = true;\n+\n+  id = pragma_tok->pragma_kind;\n+  switch (id)\n+    {\n+    case PRAGMA_GCC_PCH_PREPROCESS:\n+      error (\"%<#pragma GCC pch_preprocess%> must be first\");\n+      break;\n+\n+    default:\n+      gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n+      c_invoke_pragma_handler (id);\n+      break;\n+    }\n+\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  return false;\n+}\n+\n+/* The interface the pragma parsers have to the lexer.  */\n+\n+enum cpp_ttype\n+pragma_lex (tree *value)\n+{\n+  cp_token *tok;\n+  enum cpp_ttype ret;\n+\n+  tok = cp_lexer_peek_token (the_parser->lexer);\n+\n+  ret = tok->type;\n+  *value = tok->value;\n+\n+  if (ret == CPP_PRAGMA_EOL || ret == CPP_EOF)\n+    ret = CPP_EOF;\n+  else if (ret == CPP_STRING)\n+    *value = cp_parser_string_literal (the_parser, false, false);\n+  else\n+    {\n+      cp_lexer_consume_token (the_parser->lexer);\n+      if (ret == CPP_KEYWORD)\n+\tret = CPP_NAME;\n+    }\n+\n+  return ret;\n+}\n+\n+\f\n /* External interface.  */\n \n /* Parse one entire translation unit.  */"}, {"sha": "07b9a0df5f73f90273e9e36b6ee07ae6852696f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -1,3 +1,8 @@\n+2006-01-04  Richard Henderson  <rth@redhat.com>\n+\n+\tMerge from gomp branch.\n+\t* g++.dg/parse/pragma2.C: Update expected error lines.\n+\n 2006-01-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/other/i386-2.C: New test."}, {"sha": "c5616ff74f53e49d2141e8a71a7eda4a32fae2c2", "filename": "gcc/testsuite/g++.dg/parse/pragma2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fpragma2.C?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -2,7 +2,7 @@\n \n // Ideally, the #pragma error would come one line further down, but it\n // does not.\n-int f(int x, // { dg-error \"not allowed here\" }\n-#pragma interface \n+int f(int x,\n+#pragma interface  // { dg-error \"not allowed here\" }\n       // The parser gets confused and issues an error on the next line.\n       int y); // { dg-bogus \"\" \"\" { xfail *-*-* } } "}, {"sha": "ad6653572cd16efc9c87af104f2d0183b8b06558", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -1,3 +1,38 @@\n+2006-01-04  Dmitry Kurochkin <dmitry.kurochkin@gmail.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\tMerge from gomp branch:\n+\t* directives.c (struct pragma_entry): Add is_deferred.  Add ident\n+\tentry to value union.\n+\t(end_directive): Don't eat the line if in_deferred_pragma.\n+\t(run_directive): Remove pragma hacks.\n+\t(insert_pragma_entry): Remove.\n+\t(new_pragma_entry): New.\n+\t(register_pragma_1): Split out of register_pragma.  Only handle\n+\tthe lookup tree and return the new entry.\n+\t(cpp_register_pragma): Fill in the pragma entry here.\n+\t(cpp_register_deferred_pragma): New.\n+\t(register_pragma_internal): New.\n+\t(_cpp_init_internal_pragmas): Use register_pragma_internal.\n+\t(do_pragma): Allow pragma expansion after namespace.  For deferred\n+\tpragmas, don't slurp the line into a string.\n+\t(destringize_and_run): Save tokens for deferred pragmas.\n+\t(cpp_handle_deferred_pragma): Remove.\n+\t* macro.c (builtin_macro): Remove pragma token hack.\n+\t(_cpp_push_token_context): Rename from push_token_context and export.\n+\t* internal.h (struct lexer_state): Add pragma_allow_expansion.\n+\t(_cpp_push_token_context): Declare.\n+\t* lex.c (_cpp_lex_token): Allow _cpp_handle_directive to return\n+\ta token.  Update the line number correctly if so.\n+\t(_cpp_lex_direct): Emit CPP_PRAGMA_EOL tokens.\n+\t(cpp_token_val_index): Return CPP_TOKEN_FLD_PRAGMA for pragmas.\n+\t* include/cpplib.h (PRAGMA_EOL): New.\n+\t(CPP_TOKEN_FLD_PRAGMA): New.\n+\t(struct cpp_token): Add val.pragma.\n+\t(struct cpp_options): Remove defer_pragmas.\n+\t(cpp_handle_deferred_pragma): Remove.\n+\t(cpp_register_deferred_pragma): Declare.\n+\n 2006-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/25294\n@@ -19,7 +54,7 @@\n \t(cpp_classify_number): Disallow hexadecimal DFP constants.\n \n 2005-11-14  Gerald Pfeifer  <gerald@pfeifer.com>\n-            Ian Lance Taylor  <ian@airs.com>\n+\t    Ian Lance Taylor  <ian@airs.com>\n \n \t* include/cpplib.h (struct cpp_callbacks): Annotate error with\n \tATTRIBUTE_FPTR_PRINTF(3,0) instead of ATTRIBUTE_PRINTF(3,0)."}, {"sha": "0eea67d133c81d54c373f1268cb53af78cae5111", "filename": "libcpp/directives.c", "status": "modified", "additions": 202, "deletions": 210, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -1,7 +1,6 @@\n /* CPP Library. (Directive handling.)\n    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Per Bothner, 1994-95.\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n@@ -46,11 +45,13 @@ struct pragma_entry\n   struct pragma_entry *next;\n   const cpp_hashnode *pragma;\t/* Name and length.  */\n   bool is_nspace;\n-  bool allow_expansion;\n   bool is_internal;\n+  bool is_deferred;\n+  bool allow_expansion;\n   union {\n     pragma_cb handler;\n     struct pragma_entry *space;\n+    unsigned int ident;\n   } u;\n };\n \n@@ -106,13 +107,6 @@ static int undefine_macros (cpp_reader *, cpp_hashnode *, void *);\n static void do_include_common (cpp_reader *, enum include_type);\n static struct pragma_entry *lookup_pragma_entry (struct pragma_entry *,\n                                                  const cpp_hashnode *);\n-static struct pragma_entry *insert_pragma_entry (cpp_reader *,\n-                                                 struct pragma_entry **,\n-                                                 const cpp_hashnode *,\n-                                                 pragma_cb,\n-\t\t\t\t\t\t bool, bool);\n-static void register_pragma (cpp_reader *, const char *, const char *,\n-\t\t\t     pragma_cb, bool, bool);\n static int count_registered_pragmas (struct pragma_entry *);\n static char ** save_registered_pragmas (struct pragma_entry *, char **);\n static char ** restore_registered_pragmas (cpp_reader *, struct pragma_entry *,\n@@ -278,7 +272,9 @@ start_directive (cpp_reader *pfile)\n static void\n end_directive (cpp_reader *pfile, int skip_line)\n {\n-  if (CPP_OPTION (pfile, traditional))\n+  if (pfile->state.in_deferred_pragma)\n+    ;\n+  else if (CPP_OPTION (pfile, traditional))\n     {\n       /* Revert change of prepare_directive_trad.  */\n       pfile->state.prevent_expansion--;\n@@ -491,9 +487,6 @@ run_directive (cpp_reader *pfile, int dir_no, const char *buf, size_t count)\n {\n   cpp_push_buffer (pfile, (const uchar *) buf, count,\n \t\t   /* from_stage3 */ true);\n-  /* Disgusting hack.  */\n-  if (dir_no == T_PRAGMA && pfile->buffer->prev)\n-    pfile->buffer->file = pfile->buffer->prev->file;\n   start_directive (pfile);\n \n   /* This is a short-term fix to prevent a leading '#' being\n@@ -505,8 +498,6 @@ run_directive (cpp_reader *pfile, int dir_no, const char *buf, size_t count)\n     prepare_directive_trad (pfile);\n   pfile->directive->handler (pfile);\n   end_directive (pfile, 1);\n-  if (dir_no == T_PRAGMA)\n-    pfile->buffer->file = NULL;\n   _cpp_pop_buffer (pfile);\n }\n \n@@ -1040,86 +1031,97 @@ lookup_pragma_entry (struct pragma_entry *chain, const cpp_hashnode *pragma)\n   return chain;\n }\n \n-/* Create and insert a pragma entry for NAME at the beginning of a\n-   singly-linked CHAIN.  If handler is NULL, it is a namespace,\n-   otherwise it is a pragma and its handler.  If INTERNAL is true\n-   this pragma is being inserted by libcpp itself. */\n+/* Create and insert a blank pragma entry at the beginning of a\n+   singly-linked CHAIN.  */\n static struct pragma_entry *\n-insert_pragma_entry (cpp_reader *pfile, struct pragma_entry **chain,\n-\t\t     const cpp_hashnode *pragma, pragma_cb handler,\n-\t\t     bool allow_expansion, bool internal)\n+new_pragma_entry (cpp_reader *pfile, struct pragma_entry **chain)\n {\n   struct pragma_entry *new_entry;\n \n   new_entry = (struct pragma_entry *)\n     _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n-  new_entry->pragma = pragma;\n-  if (handler)\n-    {\n-      new_entry->is_nspace = 0;\n-      new_entry->u.handler = handler;\n-    }\n-  else\n-    {\n-      new_entry->is_nspace = 1;\n-      new_entry->u.space = NULL;\n-    }\n \n-  new_entry->allow_expansion = allow_expansion;\n-  new_entry->is_internal = internal;\n+  memset (new_entry, 0, sizeof (struct pragma_entry));\n   new_entry->next = *chain;\n+\n   *chain = new_entry;\n   return new_entry;\n }\n \n /* Register a pragma NAME in namespace SPACE.  If SPACE is null, it\n-   goes in the global namespace.  HANDLER is the handler it will call,\n-   which must be non-NULL.  If ALLOW_EXPANSION is set, allow macro\n-   expansion while parsing pragma NAME.  INTERNAL is true if this is a\n-   pragma registered by cpplib itself, false if it is registered via\n-   cpp_register_pragma */\n-static void\n-register_pragma (cpp_reader *pfile, const char *space, const char *name,\n-\t\t pragma_cb handler, bool allow_expansion, bool internal)\n+   goes in the global namespace.  */\n+static struct pragma_entry *\n+register_pragma_1 (cpp_reader *pfile, const char *space, const char *name,\n+\t\t   bool allow_name_expansion)\n {\n   struct pragma_entry **chain = &pfile->pragmas;\n   struct pragma_entry *entry;\n   const cpp_hashnode *node;\n \n-  if (!handler)\n-    abort ();\n-\n   if (space)\n     {\n       node = cpp_lookup (pfile, U space, strlen (space));\n       entry = lookup_pragma_entry (*chain, node);\n       if (!entry)\n-\tentry = insert_pragma_entry (pfile, chain, node, NULL, \n-\t\t\t\t     allow_expansion, internal);\n+\t{\n+\t  entry = new_pragma_entry (pfile, chain);\n+\t  entry->pragma = node;\n+\t  entry->is_nspace = true;\n+\t  entry->allow_expansion = allow_name_expansion;\n+\t}\n       else if (!entry->is_nspace)\n \tgoto clash;\n+      else if (entry->allow_expansion != allow_name_expansion)\n+\t{\n+\t  cpp_error (pfile, CPP_DL_ICE,\n+\t\t     \"registering pragmas in namespace \\\"%s\\\" with mismatched \"\n+\t\t     \"name expansion\", space);\n+\t  return NULL;\n+\t}\n       chain = &entry->u.space;\n     }\n+  else if (allow_name_expansion)\n+    {\n+      cpp_error (pfile, CPP_DL_ICE,\n+\t\t \"registering pragma \\\"%s\\\" with name expansion \"\n+\t\t \"and no namespace\", name);\n+      return NULL;\n+    }\n \n   /* Check for duplicates.  */\n   node = cpp_lookup (pfile, U name, strlen (name));\n   entry = lookup_pragma_entry (*chain, node);\n-  if (entry)\n+  if (entry == NULL)\n     {\n-      if (entry->is_nspace)\n-\tclash:\n-\tcpp_error (pfile, CPP_DL_ICE,\n-\t\t \"registering \\\"%s\\\" as both a pragma and a pragma namespace\",\n-\t\t NODE_NAME (node));\n-      else if (space)\n-\tcpp_error (pfile, CPP_DL_ICE, \"#pragma %s %s is already registered\",\n-\t\t   space, name);\n-      else\n-\tcpp_error (pfile, CPP_DL_ICE, \"#pragma %s is already registered\", name);\n+      entry = new_pragma_entry (pfile, chain);\n+      entry->pragma = node;\n+      return entry;\n     }\n+\n+  if (entry->is_nspace)\n+    clash:\n+    cpp_error (pfile, CPP_DL_ICE,\n+\t       \"registering \\\"%s\\\" as both a pragma and a pragma namespace\",\n+\t       NODE_NAME (node));\n+  else if (space)\n+    cpp_error (pfile, CPP_DL_ICE, \"#pragma %s %s is already registered\",\n+\t       space, name);\n   else\n-    insert_pragma_entry (pfile, chain, node, handler, allow_expansion, \n-\t\t\t internal);\n+    cpp_error (pfile, CPP_DL_ICE, \"#pragma %s is already registered\", name);\n+\n+  return NULL;\n+}\n+\n+/* Register a cpplib internal pragma SPACE NAME with HANDLER.  */\n+static void\n+register_pragma_internal (cpp_reader *pfile, const char *space,\n+\t\t\t  const char *name, pragma_cb handler)\n+{\n+  struct pragma_entry *entry;\n+\n+  entry = register_pragma_1 (pfile, space, name, false);\n+  entry->is_internal = true;\n+  entry->u.handler = handler;\n }\n \n /* Register a pragma NAME in namespace SPACE.  If SPACE is null, it\n@@ -1131,22 +1133,53 @@ void\n cpp_register_pragma (cpp_reader *pfile, const char *space, const char *name,\n \t\t     pragma_cb handler, bool allow_expansion)\n {\n-  register_pragma (pfile, space, name, handler, allow_expansion, false);\n+  struct pragma_entry *entry;\n+\n+  if (!handler)\n+    {\n+      cpp_error (pfile, CPP_DL_ICE, \"registering pragma with NULL handler\");\n+      return;\n+    }\n+\n+  entry = register_pragma_1 (pfile, space, name, false);\n+  if (entry)\n+    {\n+      entry->allow_expansion = allow_expansion;\n+      entry->u.handler = handler;\n+    }\n }\n \n+/* Similarly, but create mark the pragma for deferred processing.\n+   When found, a CPP_PRAGMA token will be insertted into the stream\n+   with IDENT in the token->u.pragma slot.  */\n+void\n+cpp_register_deferred_pragma (cpp_reader *pfile, const char *space,\n+\t\t\t      const char *name, unsigned int ident,\n+\t\t\t      bool allow_expansion, bool allow_name_expansion)\n+{\n+  struct pragma_entry *entry;\n+\n+  entry = register_pragma_1 (pfile, space, name, allow_name_expansion);\n+  if (entry)\n+    {\n+      entry->is_deferred = true;\n+      entry->allow_expansion = allow_expansion;\n+      entry->u.ident = ident;\n+    }\n+}  \n+\n /* Register the pragmas the preprocessor itself handles.  */\n void\n _cpp_init_internal_pragmas (cpp_reader *pfile)\n {\n   /* Pragmas in the global namespace.  */\n-  register_pragma (pfile, 0, \"once\", do_pragma_once, false, true);\n+  register_pragma_internal (pfile, 0, \"once\", do_pragma_once);\n \n   /* New GCC-specific pragmas should be put in the GCC namespace.  */\n-  register_pragma (pfile, \"GCC\", \"poison\", do_pragma_poison, false, true);\n-  register_pragma (pfile, \"GCC\", \"system_header\", do_pragma_system_header, \n-\t\t   false, true);\n-  register_pragma (pfile, \"GCC\", \"dependency\", do_pragma_dependency, \n-\t\t   false, true);\n+  register_pragma_internal (pfile, \"GCC\", \"poison\", do_pragma_poison);\n+  register_pragma_internal (pfile, \"GCC\", \"system_header\",\n+\t\t\t    do_pragma_system_header);\n+  register_pragma_internal (pfile, \"GCC\", \"dependency\", do_pragma_dependency);\n }\n \n /* Return the number of registered pragmas in PE.  */\n@@ -1224,23 +1257,16 @@ _cpp_restore_pragma_names (cpp_reader *pfile, char **saved)\n    front end.  C99 defines three pragmas and says that no macro\n    expansion is to be performed on them; whether or not macro\n    expansion happens for other pragmas is implementation defined.\n-   This implementation never macro-expands the text after #pragma.\n-\n-   The library user has the option of deferring execution of\n-   #pragmas not handled by cpplib, in which case they are converted\n-   to CPP_PRAGMA tokens and inserted into the output stream.  */\n+   This implementation allows for a mix of both, since GCC did not\n+   traditionally macro expand its (few) pragmas, whereas OpenMP\n+   specifies that macro expansion should happen.  */\n static void\n do_pragma (cpp_reader *pfile)\n {\n   const struct pragma_entry *p = NULL;\n   const cpp_token *token, *pragma_token = pfile->cur_token;\n   unsigned int count = 1;\n \n-  /* Save the current position so that defer_pragmas mode can\n-     copy the entire current line to a string.  It will not work\n-     to use _cpp_backup_tokens as that does not reverse buffer->cur.  */\n-  const uchar *line_start = CPP_BUFFER (pfile)->cur;\n-\n   pfile->state.prevent_expansion++;\n \n   token = cpp_get_token (pfile);\n@@ -1249,101 +1275,46 @@ do_pragma (cpp_reader *pfile)\n       p = lookup_pragma_entry (pfile->pragmas, token->val.node);\n       if (p && p->is_nspace)\n \t{\n-\t  count = 2;\n+\t  bool allow_name_expansion = p->allow_expansion;\n+\t  if (allow_name_expansion)\n+\t    pfile->state.prevent_expansion--;\n \t  token = cpp_get_token (pfile);\n \t  if (token->type == CPP_NAME)\n \t    p = lookup_pragma_entry (p->u.space, token->val.node);\n \t  else\n \t    p = NULL;\n+\t  if (allow_name_expansion)\n+\t    pfile->state.prevent_expansion++;\n+\t  count = 2;\n \t}\n     }\n \n   if (p)\n     {\n-      if (p->is_internal || !CPP_OPTION (pfile, defer_pragmas))\n+      if (p->is_deferred)\n+\t{\n+\t  pfile->directive_result.src_loc = pragma_token->src_loc;\n+\t  pfile->directive_result.type = CPP_PRAGMA;\n+\t  pfile->directive_result.flags = pragma_token->flags;\n+\t  pfile->directive_result.val.pragma = p->u.ident;\n+\t  pfile->state.in_deferred_pragma = true;\n+\t  pfile->state.pragma_allow_expansion = p->allow_expansion;\n+\t  if (!p->allow_expansion)\n+\t    pfile->state.prevent_expansion++;\n+\t}\n+      else\n \t{\n-\t  /* Since the handler below doesn't get the line number, that it\n-\t     might need for diagnostics, make sure it has the right\n+\t  /* Since the handler below doesn't get the line number, that\n+\t     it might need for diagnostics, make sure it has the right\n \t     numbers in place.  */\n \t  if (pfile->cb.line_change)\n \t    (*pfile->cb.line_change) (pfile, pragma_token, false);\n-\t  /* Never expand macros if handling a deferred pragma, since\n-\t     the macro definitions now applicable may be different\n-\t     from those at the point the pragma appeared.  */\n-\t  if (p->allow_expansion && !pfile->state.in_deferred_pragma)\n+\t  if (p->allow_expansion)\n \t    pfile->state.prevent_expansion--;\n \t  (*p->u.handler) (pfile);\n-\t  if (p->allow_expansion && !pfile->state.in_deferred_pragma)\n+\t  if (p->allow_expansion)\n \t    pfile->state.prevent_expansion++;\n \t}\n-      else\n-\t{\n-\t  /* Squirrel away the pragma text.  Pragmas are\n-\t     newline-terminated. */\n-\t  const uchar *line_end;\n-\t  uchar *s, c, cc;\n-\t  cpp_string body;\n-\t  cpp_token *ptok;\n-\n-\t  for (line_end = line_start; (c = *line_end) != '\\n'; line_end++)\n-\t    if (c == '\"' || c == '\\'')\n-\t      {\n-\t\t/* Skip over string literal.  */\n-\t\tdo\n-\t\t  {\n-\t\t    cc = *++line_end;\n-\t\t    if (cc == '\\\\' && line_end[1] != '\\n')\n-\t\t      line_end++;\n-\t\t    else if (cc == '\\n')\n-\t\t      {\n-\t\t\tline_end--;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\twhile (cc != c);\n-\t      }\n-\t    else if (c == '/')\n-\t      {\n-\t\tif (line_end[1] == '*')\n-\t\t  {\n-\t\t    /* Skip over C block comment, unless it is multi-line.\n-\t\t       When encountering multi-line block comment, terminate\n-\t\t       the pragma token right before that block comment.  */\n-\t\t    const uchar *le = line_end + 2;\n-\t\t    while (*le != '\\n')\n-\t\t      if (*le++ == '*' && *le == '/')\n-\t\t\t{\n-\t\t\t  line_end = le;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    if (line_end < le)\n-\t\t      break;\n-\t\t  }\n-\t\telse if (line_end[1] == '/'\n-\t\t\t && (CPP_OPTION (pfile, cplusplus_comments)\n-\t\t\t     || cpp_in_system_header (pfile)))\n-\t\t  {\n-\t\t    line_end += 2;\n-\t\t    while (*line_end != '\\n')\n-\t\t      line_end++;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\n-\t  body.len = (line_end - line_start) + 1;\n-\t  s = _cpp_unaligned_alloc (pfile, body.len + 1);\n-\t  memcpy (s, line_start, body.len - 1);\n-\t  s[body.len - 1] = '\\n';\n-\t  s[body.len] = '\\0';\n-\t  body.text = s;\n-\n-\t  /* Create a CPP_PRAGMA token.  */\n-\t  ptok = &pfile->directive_result;\n-\t  ptok->src_loc = pragma_token->src_loc;\n-\t  ptok->type = CPP_PRAGMA;\n-\t  ptok->flags = pragma_token->flags | NO_EXPAND;\n-\t  ptok->val.str = body;\n-\t}\n     }\n   else if (pfile->cb.def_pragma)\n     {\n@@ -1490,6 +1461,11 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in)\n {\n   const unsigned char *src, *limit;\n   char *dest, *result;\n+  cpp_context *saved_context;\n+  cpp_token *saved_cur_token;\n+  tokenrun *saved_cur_run;\n+  cpp_token *toks;\n+  int count;\n \n   dest = result = (char *) alloca (in->len - 1);\n   src = in->text + 1 + (in->text[0] == 'L');\n@@ -1511,36 +1487,81 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in)\n \n      Something like line-at-a-time lexing should remove the need for\n      this.  */\n-  {\n-    cpp_context *saved_context = pfile->context;\n-    cpp_token *saved_cur_token = pfile->cur_token;\n-    tokenrun *saved_cur_run = pfile->cur_run;\n-\n-    pfile->context = XNEW (cpp_context);\n-    pfile->context->macro = 0;\n-    pfile->context->prev = 0;\n-    run_directive (pfile, T_PRAGMA, result, dest - result);\n-    XDELETE (pfile->context);\n-    pfile->context = saved_context;\n-    pfile->cur_token = saved_cur_token;\n-    pfile->cur_run = saved_cur_run;\n-  }\n+  saved_context = pfile->context;\n+  saved_cur_token = pfile->cur_token;\n+  saved_cur_run = pfile->cur_run;\n \n-  /* See above comment.  For the moment, we'd like\n+  pfile->context = XNEW (cpp_context);\n+  pfile->context->macro = 0;\n+  pfile->context->prev = 0;\n \n-     token1 _Pragma (\"foo\") token2\n+  /* Inline run_directive, since we need to delay the _cpp_pop_buffer\n+     until we've read all of the tokens that we want.  */\n+  cpp_push_buffer (pfile, (const uchar *) result, dest - result,\n+\t\t   /* from_stage3 */ true);\n+  /* ??? Antique Disgusting Hack.  What does this do?  */\n+  if (pfile->buffer->prev)\n+    pfile->buffer->file = pfile->buffer->prev->file;\n \n-     to be output as\n+  start_directive (pfile);\n+  _cpp_clean_line (pfile);\n+  do_pragma (pfile);\n+  end_directive (pfile, 1);\n \n-\t\ttoken1\n-\t\t# 7 \"file.c\"\n-\t\t#pragma foo\n-\t\t# 7 \"file.c\"\n-\t\t\t       token2\n+  /* We always insert at least one token, the directive result.  It'll\n+     either be a CPP_PADDING or a CPP_PRAGMA.  In the later case, we \n+     need to insert *all* of the tokens, including the CPP_PRAGMA_EOL.  */\n+\n+  /* If we're not handling the pragma internally, read all of the tokens from\n+     the string buffer now, while the string buffer is still installed.  */\n+  /* ??? Note that the token buffer allocated here is leaked.  It's not clear\n+     to me what the true lifespan of the tokens are.  It would appear that\n+     the lifespan is the entire parse of the main input stream, in which case\n+     this may not be wrong.  */\n+  if (pfile->directive_result.type == CPP_PRAGMA)\n+    {\n+      int maxcount;\n+\n+      count = 1;\n+      maxcount = 50;\n+      toks = XNEWVEC (cpp_token, maxcount);\n+      toks[0] = pfile->directive_result;\n \n-      Getting the line markers is a little tricky.  */\n-  if (pfile->cb.line_change)\n-    pfile->cb.line_change (pfile, pfile->cur_token, false);\n+      do\n+\t{\n+\t  if (count == maxcount)\n+\t    {\n+\t      maxcount = maxcount * 3 / 2;\n+\t      toks = XRESIZEVEC (cpp_token, toks, maxcount);\n+\t    }\n+\t  toks[count++] = *cpp_get_token (pfile);\n+\t}\n+      while (toks[count-1].type != CPP_PRAGMA_EOL);\n+    }\n+  else\n+    {\n+      count = 1;\n+      toks = XNEW (cpp_token);\n+      toks[0] = pfile->directive_result;\n+\n+      /* If we handled the entire pragma internally, make sure we get the\n+\t line number correct for the next token.  */\n+      if (pfile->cb.line_change)\n+\tpfile->cb.line_change (pfile, pfile->cur_token, false);\n+    }\n+\n+  /* Finish inlining run_directive.  */\n+  pfile->buffer->file = NULL;\n+  _cpp_pop_buffer (pfile);\n+\n+  /* Reset the old macro state before ...  */\n+  XDELETE (pfile->context);\n+  pfile->context = saved_context;\n+  pfile->cur_token = saved_cur_token;\n+  pfile->cur_run = saved_cur_run;\n+\n+  /* ... inserting the new tokens we collected.  */\n+  _cpp_push_token_context (pfile, NULL, toks, count);\n }\n \n /* Handle the _Pragma operator.  */\n@@ -1557,35 +1578,6 @@ _cpp_do__Pragma (cpp_reader *pfile)\n \t       \"_Pragma takes a parenthesized string literal\");\n }\n \n-/* Handle a pragma that the front end deferred until now. */\n-void\n-cpp_handle_deferred_pragma (cpp_reader *pfile, const cpp_string *s)\n-{\n-  cpp_context *saved_context = pfile->context;\n-  cpp_token *saved_cur_token = pfile->cur_token;\n-  tokenrun *saved_cur_run = pfile->cur_run;\n-  bool saved_defer_pragmas = CPP_OPTION (pfile, defer_pragmas);\n-  void (*saved_line_change) (cpp_reader *, const cpp_token *, int)\n-    = pfile->cb.line_change;\n-\n-  pfile->context = XNEW (cpp_context);\n-  pfile->context->macro = 0;\n-  pfile->context->prev = 0;\n-  pfile->cb.line_change = NULL;\n-  pfile->state.in_deferred_pragma = true;\n-  CPP_OPTION (pfile, defer_pragmas) = false;\n-\n-  run_directive (pfile, T_PRAGMA, (const char *)s->text, s->len);\n-\n-  XDELETE (pfile->context);\n-  pfile->context = saved_context;\n-  pfile->cur_token = saved_cur_token;\n-  pfile->cur_run = saved_cur_run;\n-  pfile->cb.line_change = saved_line_change;\n-  pfile->state.in_deferred_pragma = false;\n-  CPP_OPTION (pfile, defer_pragmas) = saved_defer_pragmas;\n-}\n-\n /* Handle #ifdef.  */\n static void\n do_ifdef (cpp_reader *pfile)"}, {"sha": "f1b5eab93e2831d5314810fb005373a554462fe1", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -134,7 +134,8 @@ struct _cpp_file;\n   TK(COMMENT,\t\tLITERAL) /* Only if output comments.  */\t\\\n \t\t\t\t /* SPELL_LITERAL happens to DTRT.  */\t\\\n   TK(MACRO_ARG,\t\tNONE)\t /* Macro argument.  */\t\t\t\\\n-  TK(PRAGMA,\t\tNONE)\t /* Only if deferring pragmas */\t\\\n+  TK(PRAGMA,\t\tNONE)\t /* Only for deferred pragmas.  */\t\\\n+  TK(PRAGMA_EOL,\tNONE)\t /* End-of-line for deferred pragmas.  */ \\\n   TK(PADDING,\t\tNONE)\t /* Whitespace for -E.\t*/\n \n #define OP(e, s) CPP_ ## e,\n@@ -182,6 +183,7 @@ enum cpp_token_fld_kind {\n   CPP_TOKEN_FLD_SOURCE,\n   CPP_TOKEN_FLD_STR,\n   CPP_TOKEN_FLD_ARG_NO,\n+  CPP_TOKEN_FLD_PRAGMA,\n   CPP_TOKEN_FLD_NONE\n };\n \n@@ -211,6 +213,9 @@ struct cpp_token GTY(())\n \n     /* Argument no. for a CPP_MACRO_ARG.  */\n     unsigned int GTY ((tag (\"CPP_TOKEN_FLD_ARG_NO\"))) arg_no;\n+\n+    /* Caller-supplied identifier for a CPP_PRAGMA.  */\n+    unsigned int GTY ((tag (\"CPP_TOKEN_FLD_PRAGMA\"))) pragma;\n   } GTY ((desc (\"cpp_token_val_index (&%1)\"))) val;\n };\n \n@@ -434,10 +439,6 @@ struct cpp_options\n   /* Nonzero means __STDC__ should have the value 0 in system headers.  */\n   unsigned char stdc_0_in_system_headers;\n \n-  /* True means return pragmas as tokens rather than processing\n-     them directly. */\n-  bool defer_pragmas;\n-\n   /* True means error callback should be used for diagnostics.  */\n   bool client_diagnostic;\n };\n@@ -673,7 +674,8 @@ extern unsigned char *cpp_spell_token (cpp_reader *, const cpp_token *,\n \t\t\t\t       unsigned char *, bool);\n extern void cpp_register_pragma (cpp_reader *, const char *, const char *,\n \t\t\t\t void (*) (cpp_reader *), bool);\n-extern void cpp_handle_deferred_pragma (cpp_reader *, const cpp_string *);\n+extern void cpp_register_deferred_pragma (cpp_reader *, const char *,\n+\t\t\t\t\t  const char *, unsigned, bool, bool);\n extern int cpp_avoid_paste (cpp_reader *, const cpp_token *,\n \t\t\t    const cpp_token *);\n extern const cpp_token *cpp_get_token (cpp_reader *);"}, {"sha": "8ac1103c2d7d2f1289ab5480b12e3bbaf99176c0", "filename": "libcpp/internal.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -205,9 +205,6 @@ struct lexer_state\n   /* Nonzero to prevent macro expansion.  */\n   unsigned char prevent_expansion;\n \n-  /* Nonzero when handling a deferred pragma.  */\n-  unsigned char in_deferred_pragma;\n-\n   /* Nonzero when parsing arguments to a function-like macro.  */\n   unsigned char parsing_args;\n \n@@ -217,6 +214,12 @@ struct lexer_state\n \n   /* Nonzero to skip evaluating part of an expression.  */\n   unsigned int skip_eval;\n+\n+  /* Nonzero when handling a deferred pragma.  */\n+  unsigned char in_deferred_pragma;\n+\n+  /* Nonzero if the deferred pragma being handled allows macro expansion.  */\n+  unsigned char pragma_allow_expansion;\n };\n \n /* Special nodes - identifiers with predefined significance.  */\n@@ -496,7 +499,10 @@ extern bool _cpp_arguments_ok (cpp_reader *, cpp_macro *, const cpp_hashnode *,\n \t\t\t       unsigned int);\n extern const unsigned char *_cpp_builtin_macro_text (cpp_reader *,\n \t\t\t\t\t\t     cpp_hashnode *);\n-int _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);\n+extern int _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);\n+extern void _cpp_push_token_context (cpp_reader *, cpp_hashnode *,\n+\t\t\t\t     const cpp_token *, unsigned int);\n+\n /* In identifiers.c */\n extern void _cpp_init_hashtable (cpp_reader *, hash_table *);\n extern void _cpp_destroy_hashtable (cpp_reader *);"}, {"sha": "cae9b0376636b6c5e6066246eeb43dcef6b965ca", "filename": "libcpp/lex.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -767,24 +767,24 @@ _cpp_lex_token (cpp_reader *pfile)\n \t      /* 6.10.3 p 11: Directives in a list of macro arguments\n \t\t gives undefined behavior.  This implementation\n \t\t handles the directive as normal.  */\n-\t      && pfile->state.parsing_args != 1\n-\t      && _cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n+\t      && pfile->state.parsing_args != 1)\n \t    {\n-\t      if (pfile->directive_result.type == CPP_PADDING)\n-\t\tcontinue;\n-\t      else\n+\t      if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n \t\t{\n+\t\t  if (pfile->directive_result.type == CPP_PADDING)\n+\t\t    continue;\n \t\t  result = &pfile->directive_result;\n-\t\t  break;\n \t\t}\n \t    }\n+\t  else if (pfile->state.in_deferred_pragma)\n+\t    result = &pfile->directive_result;\n \n \t  if (pfile->cb.line_change && !pfile->state.skipping)\n \t    pfile->cb.line_change (pfile, result, pfile->state.parsing_args);\n \t}\n \n       /* We don't skip tokens in directives.  */\n-      if (pfile->state.in_directive)\n+      if (pfile->state.in_directive || pfile->state.in_deferred_pragma)\n \tbreak;\n \n       /* Outside a directive, invalidate controlling macros.  At file\n@@ -878,6 +878,14 @@ _cpp_lex_direct (cpp_reader *pfile)\n   buffer = pfile->buffer;\n   if (buffer->need_line)\n     {\n+      if (pfile->state.in_deferred_pragma)\n+\t{\n+\t  result->type = CPP_PRAGMA_EOL;\n+\t  pfile->state.in_deferred_pragma = false;\n+\t  if (!pfile->state.pragma_allow_expansion)\n+\t    pfile->state.prevent_expansion--;\n+\t  return result;\n+\t}\n       if (!_cpp_get_fresh_line (pfile))\n \t{\n \t  result->type = CPP_EOF;\n@@ -1697,7 +1705,7 @@ cpp_token_val_index (cpp_token *tok)\n       else if (tok->type == CPP_PADDING)\n \treturn CPP_TOKEN_FLD_SOURCE;\n       else if (tok->type == CPP_PRAGMA)\n-\treturn CPP_TOKEN_FLD_STR;\n+\treturn CPP_TOKEN_FLD_PRAGMA;\n       /* else fall through */\n     default:\n       return CPP_TOKEN_FLD_NONE;"}, {"sha": "2f1a97497a1a1f047336e266c327ac02bc0cd678", "filename": "libcpp/macro.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4071dd66fd4d093dc3fe3592ea879c2996868b/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=bc4071dd66fd4d093dc3fe3592ea879c2996868b", "patch": "@@ -42,8 +42,6 @@ struct macro_arg\n \n static int enter_macro_context (cpp_reader *, cpp_hashnode *);\n static int builtin_macro (cpp_reader *, cpp_hashnode *);\n-static void push_token_context (cpp_reader *, cpp_hashnode *,\n-\t\t\t\tconst cpp_token *, unsigned int);\n static void push_ptoken_context (cpp_reader *, cpp_hashnode *, _cpp_buff *,\n \t\t\t\t const cpp_token **, unsigned int);\n static _cpp_buff *collect_args (cpp_reader *, const cpp_hashnode *);\n@@ -261,13 +259,6 @@ builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n \treturn 0;\n \n       _cpp_do__Pragma (pfile);\n-      if (pfile->directive_result.type == CPP_PRAGMA) \n-\t{\n-\t  cpp_token *tok = _cpp_temp_token (pfile);\n-\t  *tok = pfile->directive_result;\n-\t  push_token_context (pfile, NULL, tok, 1);\n-\t}\n-\n       return 1;\n     }\n \n@@ -282,7 +273,7 @@ builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n \n   /* Set pfile->cur_token as required by _cpp_lex_direct.  */\n   pfile->cur_token = _cpp_temp_token (pfile);\n-  push_token_context (pfile, NULL, _cpp_lex_direct (pfile), 1);\n+  _cpp_push_token_context (pfile, NULL, _cpp_lex_direct (pfile), 1);\n   if (pfile->buffer->cur != pfile->buffer->rlimit)\n     cpp_error (pfile, CPP_DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n \t       NODE_NAME (node));\n@@ -480,7 +471,7 @@ paste_all_tokens (cpp_reader *pfile, const cpp_token *lhs)\n   while (rhs->flags & PASTE_LEFT);\n \n   /* Put the resulting token in its own context.  */\n-  push_token_context (pfile, NULL, lhs, 1);\n+  _cpp_push_token_context (pfile, NULL, lhs, 1);\n }\n \n /* Returns TRUE if the number of arguments ARGC supplied in an\n@@ -694,7 +685,7 @@ funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node)\n \t too difficult.  We re-insert it in its own context.  */\n       _cpp_backup_tokens (pfile, 1);\n       if (padding)\n-\tpush_token_context (pfile, NULL, padding, 1);\n+\t_cpp_push_token_context (pfile, NULL, padding, 1);\n     }\n \n   return NULL;\n@@ -750,7 +741,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n       macro->used = 1;\n \n       if (macro->paramc == 0)\n-\tpush_token_context (pfile, node, macro->exp.tokens, macro->count);\n+\t_cpp_push_token_context (pfile, node, macro->exp.tokens, macro->count);\n \n       return 1;\n     }\n@@ -943,9 +934,9 @@ push_ptoken_context (cpp_reader *pfile, cpp_hashnode *macro, _cpp_buff *buff,\n }\n \n /* Push a list of tokens.  */\n-static void\n-push_token_context (cpp_reader *pfile, cpp_hashnode *macro,\n-\t\t    const cpp_token *first, unsigned int count)\n+void\n+_cpp_push_token_context (cpp_reader *pfile, cpp_hashnode *macro,\n+\t\t\t const cpp_token *first, unsigned int count)\n {\n   cpp_context *context = next_context (pfile);\n "}]}