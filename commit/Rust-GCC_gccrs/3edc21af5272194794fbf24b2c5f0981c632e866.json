{"sha": "3edc21af5272194794fbf24b2c5f0981c632e866", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VkYzIxYWY1MjcyMTk0Nzk0ZmJmMjRiMmM1ZjA5ODFjNjMyZTg2Ng==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-05-14T20:06:23Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-10-26T11:06:32Z"}, "message": "x86: Add cmpmemsi for -minline-all-stringops\n\nWe used to expand memcmp to \"repz cmpsb\" via cmpstrnsi. \u00a0It was changed\nby\n\ncommit 9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f\nAuthor: Nick Clifton <nickc@redhat.com>\nDate:   Fri Aug 12 16:26:11 2011 +0000\n\n    builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi pattern.\n\n            * builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi\n            pattern.\n            * doc/md.texi (cmpstrn): Note that the comparison stops if both\n            fetched bytes are zero.\n            (cmpstr): Likewise.\n            (cmpmem): Note that the comparison does not stop if both of the\n            fetched bytes are zero.\n\nDuplicate the cmpstrn pattern for cmpmem.  The only difference is that\nthe length argument of cmpmem is guaranteed to be less than or equal to\nlengths of 2 memory areas.  Since \"repz cmpsb\" can be much slower than\nmemcmp function implemented with vector instruction, see\n\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=43052\n\nexpand cmpmem to \"repz cmpsb\" only for -minline-all-stringops.\n\ngcc/\n\n\tPR target/95151\n\t* config/i386/i386-expand.c (ix86_expand_cmpstrn_or_cmpmem): New\n\tfunction.\n\t* config/i386/i386-protos.h (ix86_expand_cmpstrn_or_cmpmem): New\n\tprototype.\n\t* config/i386/i386.md (cmpmemsi): New pattern.\n\ngcc/testsuite/\n\n\tPR target/95151\n\t* gcc.target/i386/pr95151-1.c: New test.\n\t* gcc.target/i386/pr95151-2.c: Likewise.\n\t* gcc.target/i386/pr95151-3.c: Likewise.\n\t* gcc.target/i386/pr95151-4.c: Likewise.", "tree": {"sha": "23b6727ef2438fb38d4043d62fef5a7066e0d897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23b6727ef2438fb38d4043d62fef5a7066e0d897"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3edc21af5272194794fbf24b2c5f0981c632e866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edc21af5272194794fbf24b2c5f0981c632e866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3edc21af5272194794fbf24b2c5f0981c632e866", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3edc21af5272194794fbf24b2c5f0981c632e866/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19534269d899c4810b7b12e00cc4b1deb9e7b495", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19534269d899c4810b7b12e00cc4b1deb9e7b495", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19534269d899c4810b7b12e00cc4b1deb9e7b495"}], "stats": {"total": 225, "additions": 162, "deletions": 63}, "files": [{"sha": "bd83a8eb98104b9c7c63007cc25f9982e8b0769d", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -7673,6 +7673,90 @@ ix86_expand_set_or_cpymem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n   return true;\n }\n \n+/* Expand cmpstrn or memcmp.  */\n+\n+bool\n+ix86_expand_cmpstrn_or_cmpmem (rtx result, rtx src1, rtx src2,\n+\t\t\t       rtx length, rtx align, bool is_cmpstrn)\n+{\n+  if (optimize_insn_for_size_p () && !TARGET_INLINE_ALL_STRINGOPS)\n+    return false;\n+\n+  /* Can't use this if the user has appropriated ecx, esi or edi.  */\n+  if (fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n+    return false;\n+\n+  if (is_cmpstrn)\n+    {\n+      /* For strncmp, length is the maximum length, which can be larger\n+\t than actual string lengths.  We can expand the cmpstrn pattern\n+\t to \"repz cmpsb\" only if one of the strings is a constant so\n+\t that expand_builtin_strncmp() can write the length argument to\n+\t be the minimum of the const string length and the actual length\n+\t argument.  Otherwise, \"repz cmpsb\" may pass the 0 byte.  */\n+      tree t1 = MEM_EXPR (src1);\n+      tree t2 = MEM_EXPR (src2);\n+      if (!((t1 && TREE_CODE (t1) == MEM_REF\n+\t     && TREE_CODE (TREE_OPERAND (t1, 0)) == ADDR_EXPR\n+\t     && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (t1, 0), 0))\n+\t\t == STRING_CST))\n+\t    || (t2 && TREE_CODE (t2) == MEM_REF\n+\t\t&& TREE_CODE (TREE_OPERAND (t2, 0)) == ADDR_EXPR\n+\t\t&& (TREE_CODE (TREE_OPERAND (TREE_OPERAND (t2, 0), 0))\n+\t\t    == STRING_CST))))\n+\treturn false;\n+    }\n+  else\n+    {\n+      /* Expand memcmp to \"repz cmpsb\" only for -minline-all-stringops\n+\t since \"repz cmpsb\" can be much slower than memcmp function\n+\t implemented with vector instructions, see\n+\n+\t https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43052\n+       */\n+      if (!TARGET_INLINE_ALL_STRINGOPS)\n+\treturn false;\n+    }\n+\n+  rtx addr1 = copy_addr_to_reg (XEXP (src1, 0));\n+  rtx addr2 = copy_addr_to_reg (XEXP (src2, 0));\n+  if (addr1 != XEXP (src1, 0))\n+    src1 = replace_equiv_address_nv (src1, addr1);\n+  if (addr2 != XEXP (src2, 0))\n+    src2 = replace_equiv_address_nv (src2, addr2);\n+\n+  /* NB: Make a copy of the data length to avoid changing the original\n+     data length by cmpstrnqi patterns.  */\n+  length = ix86_zero_extend_to_Pmode (length);\n+  rtx lengthreg = gen_reg_rtx (Pmode);\n+  emit_move_insn (lengthreg, length);\n+\n+  /* If we are testing strict equality, we can use known alignment to\n+     good advantage.  This may be possible with combine, particularly\n+     once cc0 is dead.  */\n+  if (CONST_INT_P (length))\n+    {\n+      if (length == const0_rtx)\n+\t{\n+\t  emit_move_insn (result, const0_rtx);\n+\t  return true;\n+\t}\n+      emit_insn (gen_cmpstrnqi_nz_1 (addr1, addr2, lengthreg, align,\n+\t\t\t\t     src1, src2));\n+    }\n+  else\n+    {\n+      emit_insn (gen_cmp_1 (Pmode, lengthreg, lengthreg));\n+      emit_insn (gen_cmpstrnqi_1 (addr1, addr2, lengthreg, align,\n+\t\t\t\t  src1, src2));\n+    }\n+\n+  rtx out = gen_lowpart (QImode, result);\n+  emit_insn (gen_cmpintqi (out));\n+  emit_move_insn (result, gen_rtx_SIGN_EXTEND (SImode, out));\n+\n+  return true;\n+}\n \n /* Expand the appropriate insns for doing strlen if not just doing\n    repnz; scasb"}, {"sha": "69e2b321bd8afabbefdcf4b3562b9fdef8a32a1d", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -71,6 +71,7 @@ extern int avx_vperm2f128_parallel (rtx par, machine_mode mode);\n extern bool ix86_expand_strlen (rtx, rtx, rtx, rtx);\n extern bool ix86_expand_set_or_cpymem (rtx, rtx, rtx, rtx, rtx, rtx,\n \t\t\t\t       rtx, rtx, rtx, rtx, bool);\n+extern bool ix86_expand_cmpstrn_or_cmpmem (rtx, rtx, rtx, rtx, rtx, bool);\n \n extern bool constant_address_p (rtx);\n extern bool legitimate_pic_operand_p (rtx);"}, {"sha": "751801daa6fc67287d9f96bc81ed72207d3a73c1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 21, "deletions": 63, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -18115,6 +18115,22 @@\n \t  (const_string \"*\")))\n    (set_attr \"mode\" \"QI\")])\n \n+(define_expand \"cmpmemsi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+        (compare:SI (match_operand:BLK 1 \"memory_operand\" \"\")\n+                    (match_operand:BLK 2 \"memory_operand\" \"\") ) )\n+   (use (match_operand 3 \"general_operand\"))\n+   (use (match_operand 4 \"immediate_operand\"))]\n+  \"\"\n+{\n+  if (ix86_expand_cmpstrn_or_cmpmem (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3],\n+\t\t\t\t     operands[4], false))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n (define_expand \"cmpstrnsi\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(compare:SI (match_operand:BLK 1 \"general_operand\")\n@@ -18123,70 +18139,12 @@\n    (use (match_operand 4 \"immediate_operand\"))]\n   \"\"\n {\n-  rtx addr1, addr2, countreg, align, out;\n-\n-  if (optimize_insn_for_size_p () && !TARGET_INLINE_ALL_STRINGOPS)\n-    FAIL;\n-\n-  /* Can't use this if the user has appropriated ecx, esi or edi.  */\n-  if (fixed_regs[CX_REG] || fixed_regs[SI_REG] || fixed_regs[DI_REG])\n-    FAIL;\n-\n-  /* One of the strings must be a constant.  If so, expand_builtin_strncmp()\n-     will have rewritten the length arg to be the minimum of the const string\n-     length and the actual length arg.  If both strings are the same and\n-     shorter than the length arg, repz cmpsb will not stop at the 0 byte and\n-     will incorrectly base the results on chars past the 0 byte.  */\n-  tree t1 = MEM_EXPR (operands[1]);\n-  tree t2 = MEM_EXPR (operands[2]);\n-  if (!((t1 && TREE_CODE (t1) == MEM_REF\n-         && TREE_CODE (TREE_OPERAND (t1, 0)) == ADDR_EXPR\n-         && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t1, 0), 0)) == STRING_CST)\n-      || (t2 && TREE_CODE (t2) == MEM_REF\n-          && TREE_CODE (TREE_OPERAND (t2, 0)) == ADDR_EXPR\n-          && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t2, 0), 0)) == STRING_CST)))\n-    FAIL;\n-\n-  addr1 = copy_addr_to_reg (XEXP (operands[1], 0));\n-  addr2 = copy_addr_to_reg (XEXP (operands[2], 0));\n-  if (addr1 != XEXP (operands[1], 0))\n-    operands[1] = replace_equiv_address_nv (operands[1], addr1);\n-  if (addr2 != XEXP (operands[2], 0))\n-    operands[2] = replace_equiv_address_nv (operands[2], addr2);\n-\n-  /* NB: Make a copy of the data length to avoid changing the original\n-     data length by cmpstrnqi patterns.  */\n-  rtx count = ix86_zero_extend_to_Pmode (operands[3]);\n-  countreg = gen_reg_rtx (Pmode);\n-  emit_move_insn (countreg, count);\n-\n-  /* %%% Iff we are testing strict equality, we can use known alignment\n-     to good advantage.  This may be possible with combine, particularly\n-     once cc0 is dead.  */\n-  align = operands[4];\n-\n-  if (CONST_INT_P (operands[3]))\n-    {\n-      if (operands[3] == const0_rtx)\n-\t{\n-\t  emit_move_insn (operands[0], const0_rtx);\n-\t  DONE;\n-\t}\n-      emit_insn (gen_cmpstrnqi_nz_1 (addr1, addr2, countreg, align,\n-\t\t\t\t     operands[1], operands[2]));\n-    }\n+  if (ix86_expand_cmpstrn_or_cmpmem (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3],\n+\t\t\t\t     operands[4], true))\n+    DONE;\n   else\n-    {\n-      emit_insn (gen_cmp_1 (Pmode, countreg, countreg));\n-      emit_insn (gen_cmpstrnqi_1 (addr1, addr2, countreg, align,\n-\t\t\t\t  operands[1], operands[2]));\n-    }\n-\n-  out = gen_lowpart (QImode, operands[0]);\n-  emit_insn (gen_cmpintqi (out));\n-  emit_move_insn (operands[0], gen_rtx_SIGN_EXTEND (SImode, out));\n-\n-  DONE;\n+    FAIL;\n })\n \n ;; Produce a tri-state integer (-1, 0, 1) from condition codes."}, {"sha": "54a7510042ad7b17765cb49c3d0347d42e5f3fcb", "filename": "gcc/testsuite/gcc.target/i386/pr95151-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-1.c?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -minline-all-stringops\" } */\n+\n+struct foo\n+{\n+  char array[257];\n+};\n+\n+extern struct foo x;\n+\n+int\n+func (struct foo i)\n+{\n+  return __builtin_memcmp (&x, &i, sizeof (x)) ? 1 : 2;\n+}\n+\n+/* { dg-final { scan-assembler-not \"call\\[\\\\t \\]*_?memcmp\" } } */"}, {"sha": "8f9d8ee1bf4aaaf3ac42ce0ee53b738f3715caad", "filename": "gcc/testsuite/gcc.target/i386/pr95151-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-2.c?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -minline-all-stringops\" } */\n+\n+int\n+func (void *d, void *s, unsigned int l)\n+{\n+  return __builtin_memcmp (d, s, l) ? 1 : 2;\n+}\n+\n+/* { dg-final { scan-assembler-not \"call\\[\\\\t \\]*_?memcmp\" } } */"}, {"sha": "14cbdec4c933dab74df1ba99a0e15d3f9bb0947f", "filename": "gcc/testsuite/gcc.target/i386/pr95151-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-3.c?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-inline-all-stringops\" } */\n+\n+struct foo\n+{\n+  char array[257];\n+};\n+\n+extern struct foo x;\n+\n+int\n+func (struct foo i)\n+{\n+  return __builtin_memcmp (&x, &i, sizeof (x)) ? 1 : 2;\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[\\\\t \\]*_?memcmp\" } } */\n+/* { dg-final { scan-assembler-not \"cmpsb\" } } */"}, {"sha": "c93b2b60c5b22d51c02d6eee5cb38c30c2c769e0", "filename": "gcc/testsuite/gcc.target/i386/pr95151-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3edc21af5272194794fbf24b2c5f0981c632e866/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr95151-4.c?ref=3edc21af5272194794fbf24b2c5f0981c632e866", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-inline-all-stringops\" } */\n+\n+int\n+func (void *d, void *s, unsigned int l)\n+{\n+  return __builtin_memcmp (d, s, l) ? 1 : 2;\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[\\\\t \\]*_?memcmp\" } } */\n+/* { dg-final { scan-assembler-not \"cmpsb\" } } */"}]}