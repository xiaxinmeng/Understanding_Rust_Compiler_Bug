{"sha": "f85d24870891e785a86e1c394ca559953b262d2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg1ZDI0ODcwODkxZTc4NWE4NmUxYzM5NGNhNTU5OTUzYjI2MmQyZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-21T23:59:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-21T23:59:49Z"}, "message": "lto.c (iterative_hash_canonical_type): Always recurse for pointers.\n\n\n\t* lto.c (iterative_hash_canonical_type): Always recurse for pointers.\n\t(gimple_register_canonical_type_1): Check that pointers do not get\n\tcanonical types.\n\t(gimple_register_canonical_type): Do not register pointers.\n\n\t* tree.c (build_pointer_type_for_mode,build_reference_type_for_mode):\n\tIn LTO we do not compute TYPE_CANONICAL of pointers.\n\t(gimple_canonical_types_compatible_p): Improve coments; sanity check\n\tthat pointers do not have canonical type that would make us believe\n\tthey are different.\n\t* alias.c (get_alias_set): Do structural type equality on pointers;\n\tenable pointer path for LTO; also glob pointer to vector with pointer\n\tto vector element; glob pointers and references for LTO; do more strict\n\tsanity checking about build_pointer_type returning the canonical type\n\twhich is also the main variant.\n\t(record_component_aliases): When component type is pointer and we\n\tdo LTO; record void_type_node alias set.\n\nFrom-SVN: r230715", "tree": {"sha": "8ce584973badca7655229ceeb55de6f4eed7e8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce584973badca7655229ceeb55de6f4eed7e8d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f85d24870891e785a86e1c394ca559953b262d2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f85d24870891e785a86e1c394ca559953b262d2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f85d24870891e785a86e1c394ca559953b262d2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f85d24870891e785a86e1c394ca559953b262d2d/comments", "author": null, "committer": null, "parents": [{"sha": "feb391fc5d47f7bd3860fe192a7a73531cbde77f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb391fc5d47f7bd3860fe192a7a73531cbde77f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb391fc5d47f7bd3860fe192a7a73531cbde77f"}], "stats": {"total": 154, "additions": 126, "deletions": 28}, "files": [{"sha": "00db0ba305fcef0d69b835fc5497662823347c5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f85d24870891e785a86e1c394ca559953b262d2d", "patch": "@@ -1,3 +1,18 @@\n+2015-11-21  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.c (build_pointer_type_for_mode,build_reference_type_for_mode):\n+\tIn LTO we do not compute TYPE_CANONICAL of pointers.\n+\t(gimple_canonical_types_compatible_p): Improve coments; sanity check\n+\tthat pointers do not have canonical type that would make us believe\n+\tthey are different.\n+\t* alias.c (get_alias_set): Do structural type equality on pointers;\n+\tenable pointer path for LTO; also glob pointer to vector with pointer\n+\tto vector element; glob pointers and references for LTO; do more strict\n+\tsanity checking about build_pointer_type returning the canonical type\n+\twhich is also the main variant.\n+\t(record_component_aliases): When component type is pointer and we\n+\tdo LTO; record void_type_node alias set.\n+\n 2015-11-21  Nathan Sidwell  <nathan@acm.org>\n \n \t* config/nvptx/nvptx.md (clz<mode>2): Use operand 1 for type."}, {"sha": "f3f79869a8bbeec48ccb37d642de046517e3b199", "filename": "gcc/alias.c", "status": "modified", "additions": 75, "deletions": 20, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f85d24870891e785a86e1c394ca559953b262d2d", "patch": "@@ -869,13 +869,23 @@ get_alias_set (tree t)\n       set = lang_hooks.get_alias_set (t);\n       if (set != -1)\n \treturn set;\n-      return 0;\n+      /* Handle structure type equality for pointer types.  This is easy\n+\t to do, because the code bellow ignore canonical types on these anyway.\n+\t This is important for LTO, where TYPE_CANONICAL for pointers can not\n+\t be meaningfuly computed by the frotnend.  */\n+      if (!POINTER_TYPE_P (t))\n+\t{\n+\t  /* In LTO we set canonical types for all types where it makes\n+\t     sense to do so.  Double check we did not miss some type.  */\n+\t  gcc_checking_assert (!in_lto_p || !type_with_alias_set_p (t));\n+          return 0;\n+\t}\n+    }\n+  else\n+    {\n+      t = TYPE_CANONICAL (t);\n+      gcc_checking_assert (!TYPE_STRUCTURAL_EQUALITY_P (t));\n     }\n-\n-  t = TYPE_CANONICAL (t);\n-\n-  /* The canonical type should not require structural equality checks.  */\n-  gcc_checking_assert (!TYPE_STRUCTURAL_EQUALITY_P (t));\n \n   /* If this is a type with a known alias set, return it.  */\n   if (TYPE_ALIAS_SET_KNOWN_P (t))\n@@ -952,20 +962,23 @@ get_alias_set (tree t)\n      ptr_type_node but that is a bad idea, because it prevents disabiguations\n      in between pointers.  For Firefox this accounts about 20% of all\n      disambiguations in the program.  */\n-  else if (POINTER_TYPE_P (t) && t != ptr_type_node && !in_lto_p)\n+  else if (POINTER_TYPE_P (t) && t != ptr_type_node)\n     {\n       tree p;\n       auto_vec <bool, 8> reference;\n \n       /* Unnest all pointers and references.\n-         We also want to make pointer to array equivalent to pointer to its\n-         element. So skip all array types, too.  */\n+\t We also want to make pointer to array/vector equivalent to pointer to\n+\t its element (see the reasoning above). Skip all those types, too.  */\n       for (p = t; POINTER_TYPE_P (p)\n-\t   || (TREE_CODE (p) == ARRAY_TYPE && !TYPE_NONALIASED_COMPONENT (p));\n+\t   || (TREE_CODE (p) == ARRAY_TYPE && !TYPE_NONALIASED_COMPONENT (p))\n+\t   || TREE_CODE (p) == VECTOR_TYPE;\n \t   p = TREE_TYPE (p))\n \t{\n \t  if (TREE_CODE (p) == REFERENCE_TYPE)\n-\t    reference.safe_push (true);\n+\t    /* In LTO we want languages that use references to be compatible\n+ \t       with languages that use pointers.  */\n+\t    reference.safe_push (true && !in_lto_p);\n \t  if (TREE_CODE (p) == POINTER_TYPE)\n \t    reference.safe_push (false);\n \t}\n@@ -981,7 +994,7 @@ get_alias_set (tree t)\n \tset = get_alias_set (ptr_type_node);\n       else\n \t{\n-\t  /* Rebuild pointer type from starting from canonical types using\n+\t  /* Rebuild pointer type starting from canonical types using\n \t     unqualified pointers and references only.  This way all such\n \t     pointers will have the same alias set and will conflict with\n \t     each other.\n@@ -998,9 +1011,15 @@ get_alias_set (tree t)\n \t\tp = build_reference_type (p);\n \t      else\n \t\tp = build_pointer_type (p);\n-\t      p = TYPE_CANONICAL (TYPE_MAIN_VARIANT (p));\n+\t      gcc_checking_assert (p == TYPE_MAIN_VARIANT (p));\n+\t      /* build_pointer_type should always return the canonical type.\n+\t\t For LTO TYPE_CANOINCAL may be NULL, because we do not compute\n+\t\t them.  Be sure that frontends do not glob canonical types of\n+\t\t pointers in unexpected way and that p == TYPE_CANONICAL (p)\n+\t\t in all other cases.  */\n+\t      gcc_checking_assert (!TYPE_CANONICAL (p)\n+\t\t\t\t   || p == TYPE_CANONICAL (p));\n \t    }\n-          gcc_checking_assert (TYPE_CANONICAL (p) == p);\n \n \t  /* Assign the alias set to both p and t.\n \t     We can not call get_alias_set (p) here as that would trigger\n@@ -1015,11 +1034,12 @@ get_alias_set (tree t)\n \t    }\n \t}\n     }\n-  /* In LTO the rules above needs to be part of canonical type machinery.\n-     For now just punt.  */\n-  else if (POINTER_TYPE_P (t)\n-\t   && t != TYPE_CANONICAL (ptr_type_node) && in_lto_p)\n-    set = get_alias_set (TYPE_CANONICAL (ptr_type_node));\n+  /* Alias set of ptr_type_node is special and serve as universal pointer which\n+     is TBAA compatible with every other pointer type.  Be sure we have the\n+     alias set built even for LTO which otherwise keeps all TYPE_CANONICAL\n+     of pointer types NULL.  */\n+  else if (t == ptr_type_node)\n+    set = new_alias_set ();\n \n   /* Otherwise make a new alias set for this type.  */\n   else\n@@ -1155,7 +1175,42 @@ record_component_aliases (tree type)\n     case QUAL_UNION_TYPE:\n       for (field = TYPE_FIELDS (type); field != 0; field = DECL_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL && !DECL_NONADDRESSABLE_P (field))\n-\t  record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));\n+\t  {\n+\t    /* LTO type merging does not make any difference between \n+\t       component pointer types.  We may have\n+\n+\t       struct foo {int *a;};\n+\n+\t       as TYPE_CANONICAL of \n+\n+\t       struct bar {float *a;};\n+\n+\t       Because accesses to int * and float * do not alias, we would get\n+\t       false negative when accessing the same memory location by\n+\t       float ** and bar *. We thus record the canonical type as:\n+\n+\t       struct {void *a;};\n+\n+\t       void * is special cased and works as a universal pointer type.\n+\t       Accesses to it conflicts with accesses to any other pointer\n+\t       type.  */\n+\t    tree t = TREE_TYPE (field);\n+\t    if (in_lto_p)\n+\t      {\n+\t\t/* VECTOR_TYPE and ARRAY_TYPE share the alias set with their\n+\t\t   element type and that type has to be normalized to void *,\n+\t\t   too, in the case it is a pointer. */\n+\t\twhile ((TREE_CODE (t) == ARRAY_TYPE\n+\t\t\t&& (!COMPLETE_TYPE_P (t)\n+\t\t\t    || TYPE_NONALIASED_COMPONENT (t)))\n+\t\t       || TREE_CODE (t) == VECTOR_TYPE)\n+\t\t  t = TREE_TYPE (t);\n+\t\tif (POINTER_TYPE_P (t))\n+\t\t  t = ptr_type_node;\n+\t      }\n+\t   \n+\t    record_alias_subset (superset, get_alias_set (t));\n+\t  }\n       break;\n \n     case COMPLEX_TYPE:"}, {"sha": "410533710ae8c124b355c2bbcbac11da6ddd67b1", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=f85d24870891e785a86e1c394ca559953b262d2d", "patch": "@@ -1,4 +1,11 @@\n-2015-11-11  Jan Hubicka  <hubicka@ucw.cz>\n+2015-11-21  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (iterative_hash_canonical_type): Always recurse for pointers.\n+\t(gimple_register_canonical_type_1): Check that pointers do not get\n+\tcanonical types.\n+\t(gimple_register_canonical_type): Do not register pointers.\n+\n+2015-11-21  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c (warn_type_compatibility_p): Do not set ODR mismatch\n \tflag for types that are not ODR; fix loop walking parameters."}, {"sha": "26614912e3b9bf84bb3d23dc36acb45a7d9d109f", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=f85d24870891e785a86e1c394ca559953b262d2d", "patch": "@@ -388,8 +388,13 @@ iterative_hash_canonical_type (tree type, inchash::hash &hstate)\n \n   /* All type variants have same TYPE_CANONICAL.  */\n   type = TYPE_MAIN_VARIANT (type);\n+\n+  /* We do not compute TYPE_CANONICAl of POINTER_TYPE because the aliasing\n+     code never use it anyway.  */\n+  if (POINTER_TYPE_P (type))\n+    v = hash_canonical_type (type);\n   /* An already processed type.  */\n-  if (TYPE_CANONICAL (type))\n+  else if (TYPE_CANONICAL (type))\n     {\n       type = TYPE_CANONICAL (type);\n       v = gimple_canonical_type_hash (type);\n@@ -437,7 +442,9 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n {\n   void **slot;\n \n-  gcc_checking_assert (TYPE_P (t) && !TYPE_CANONICAL (t));\n+  gcc_checking_assert (TYPE_P (t) && !TYPE_CANONICAL (t)\n+\t\t       && type_with_alias_set_p (t)\n+\t\t       && !POINTER_TYPE_P (t));\n \n   slot = htab_find_slot_with_hash (gimple_canonical_types, t, hash, INSERT);\n   if (*slot)\n@@ -470,7 +477,7 @@ gimple_register_canonical_type_1 (tree t, hashval_t hash)\n static void\n gimple_register_canonical_type (tree t)\n {\n-  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t))\n+  if (TYPE_CANONICAL (t) || !type_with_alias_set_p (t) || POINTER_TYPE_P (t))\n     return;\n \n   /* Canonical types are same among all complete variants.  */"}, {"sha": "779fe9386a27b2b09b66c06e52eddc30b072b8a8", "filename": "gcc/tree.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f85d24870891e785a86e1c394ca559953b262d2d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f85d24870891e785a86e1c394ca559953b262d2d", "patch": "@@ -7919,7 +7919,8 @@ build_pointer_type_for_mode (tree to_type, machine_mode mode,\n   TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (to_type);\n   TYPE_POINTER_TO (to_type) = t;\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (to_type))\n+  /* During LTO we do not set TYPE_CANONICAL of pointers and references.  */\n+  if (TYPE_STRUCTURAL_EQUALITY_P (to_type) || in_lto_p)\n     SET_TYPE_STRUCTURAL_EQUALITY (t);\n   else if (TYPE_CANONICAL (to_type) != to_type || could_alias)\n     TYPE_CANONICAL (t)\n@@ -7987,7 +7988,8 @@ build_reference_type_for_mode (tree to_type, machine_mode mode,\n   TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (to_type);\n   TYPE_REFERENCE_TO (to_type) = t;\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (to_type))\n+  /* During LTO we do not set TYPE_CANONICAL of pointers and references.  */\n+  if (TYPE_STRUCTURAL_EQUALITY_P (to_type) || in_lto_p)\n     SET_TYPE_STRUCTURAL_EQUALITY (t);\n   else if (TYPE_CANONICAL (to_type) != to_type || could_alias)\n     TYPE_CANONICAL (t)\n@@ -13224,7 +13226,9 @@ type_with_interoperable_signedness (const_tree type)\n    TBAA is concerned.  \n    This function is used both by lto.c canonical type merging and by the\n    verifier.  If TRUST_TYPE_CANONICAL we do not look into structure of types\n-   that have TYPE_CANONICAL defined and assume them equivalent.  */\n+   that have TYPE_CANONICAL defined and assume them equivalent.  This is useful\n+   only for LTO because only in these cases TYPE_CANONICAL equivalence\n+   correspond to one defined by gimple_canonical_types_compatible_p.  */\n \n bool\n gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n@@ -13265,9 +13269,19 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n \t      || (type_with_alias_set_p (t1) && type_with_alias_set_p (t2)));\n   /* If the types have been previously registered and found equal\n      they still are.  */\n+\n   if (TYPE_CANONICAL (t1) && TYPE_CANONICAL (t2)\n       && trust_type_canonical)\n-    return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n+    {\n+      /* Do not use TYPE_CANONICAL of pointer types.  For LTO streamed types\n+\t they are always NULL, but they are set to non-NULL for types\n+\t constructed by build_pointer_type and variants.  In this case the\n+\t TYPE_CANONICAL is more fine grained than the equivalnce we test (where\n+\t all pointers are considered equal.  Be sure to not return false\n+\t negatives.  */\n+      gcc_checking_assert (!POINTER_TYPE_P (t1) && !POINTER_TYPE_P (t2));\n+      return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n+    }\n \n   /* Can't be the same type if the types don't have the same code.  */\n   enum tree_code code = tree_code_for_canonical_type_merging (TREE_CODE (t1));"}]}