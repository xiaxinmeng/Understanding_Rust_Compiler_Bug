{"sha": "b9850b3d44898c346b98e702eef0363b47fd0cbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk4NTBiM2Q0NDg5OGMzNDZiOThlNzAyZWVmMDM2M2I0N2ZkMGNiYg==", "commit": {"author": {"name": "Chris Burdess", "email": "dog@gnu.org", "date": "2005-04-21T06:17:03Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-21T06:17:03Z"}, "message": "CRLFInputStream.java: Rewrite to return CRLF-delimited chunks.\n\n2005-04-21  Chris Burdess  <dog@gnu.org>\n\n\t* gnu/java/net/CRLFInputStream.java: Rewrite to return\n\tCRLF-delimited chunks.\n\nFrom-SVN: r98493", "tree": {"sha": "f01d50243627d6d8e181d80f81e535c2734a4793", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f01d50243627d6d8e181d80f81e535c2734a4793"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9850b3d44898c346b98e702eef0363b47fd0cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9850b3d44898c346b98e702eef0363b47fd0cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9850b3d44898c346b98e702eef0363b47fd0cbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9850b3d44898c346b98e702eef0363b47fd0cbb/comments", "author": null, "committer": null, "parents": [{"sha": "d3e53108dde9a1c1826fbd227339bbc51a84909f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e53108dde9a1c1826fbd227339bbc51a84909f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e53108dde9a1c1826fbd227339bbc51a84909f"}], "stats": {"total": 134, "additions": 54, "deletions": 80}, "files": [{"sha": "d031f2b668505e955ea391a7ce9a228e7f6d085e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9850b3d44898c346b98e702eef0363b47fd0cbb/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9850b3d44898c346b98e702eef0363b47fd0cbb/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b9850b3d44898c346b98e702eef0363b47fd0cbb", "patch": "@@ -1,3 +1,8 @@\n+2005-04-21  Chris Burdess  <dog@gnu.org>\n+\n+\t* gnu/java/net/CRLFInputStream.java: Rewrite to return\n+\tCRLF-delimited chunks.\n+\n 2005-04-20  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n \n \t* java/net/URI.java:"}, {"sha": "927201c926636d755a54f1f637f15e3a0e642dfa", "filename": "libjava/gnu/java/net/CRLFInputStream.java", "status": "modified", "additions": 49, "deletions": 80, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9850b3d44898c346b98e702eef0363b47fd0cbb/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9850b3d44898c346b98e702eef0363b47fd0cbb/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FCRLFInputStream.java?ref=b9850b3d44898c346b98e702eef0363b47fd0cbb", "patch": "@@ -38,6 +38,7 @@\n \n package gnu.java.net;\n \n+import java.io.BufferedInputStream;\n import java.io.FilterInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -60,23 +61,15 @@\n    */\n   public static final int LF = 10;\n \n-  /**\n-   * Buffer.\n-   */\n-  protected int buf = -1;\n-\n-  /**\n-   * Buffer at time of mark.\n-   */\n-  protected int markBuf = -1;\n+  private boolean doReset;\n \n   /**\n    * Constructs a CR/LF input stream connected to the specified input\n    * stream.\n    */\n   public CRLFInputStream(InputStream in)\n   {\n-    super(in);\n+    super(in.markSupported() ? in : new BufferedInputStream(in));\n   }\n \n   /**\n@@ -87,24 +80,18 @@ public CRLFInputStream(InputStream in)\n   public int read()\n     throws IOException\n   {\n-    int c;\n-    if (buf != -1)\n+    int c = in.read();\n+    if (c == CR)\n       {\n-        c = buf;\n-        buf = -1;\n-        return c;\n-      }\n-    else\n-      {\n-        c = super.read();\n-        if (c == CR)\n+        in.mark(1);\n+        int d = in.read();\n+        if (d == LF)\n           {\n-            buf = super.read();\n-            if (buf == LF)\n-              {\n-                c = buf;\n-                buf = -1;\n-              }\n+            c = d;\n+          }\n+        else\n+          {\n+            in.reset();\n           }\n       }\n     return c;\n@@ -131,75 +118,57 @@ public int read(byte[] b)\n   public int read(byte[] b, int off, int len)\n     throws IOException\n   {\n-    int shift = 0;\n-    if (buf != -1)\n+    in.mark(len + 1);\n+    int l = in.read(b, off, len);\n+    if (l > 0)\n       {\n-        // Push buf onto start of byte array\n-        b[off] = (byte) buf;\n-        off++;\n-        len--;\n-        buf = -1;\n-        shift++;\n+        int i = indexOfCRLF(b, off, l);\n+        if (doReset)\n+          {\n+            in.reset();\n+            if (i != -1)\n+              {\n+                l = in.read(b, off, i + 1); // read to CR\n+                in.read(); // skip LF\n+                b[i] = LF; // fix CR as LF\n+              }\n+            else\n+              {\n+                l = in.read(b, off, len); // CR(s) but no LF\n+              }\n+          }\n       }\n-    int l = super.read(b, off, len);\n-    l = removeCRLF(b, off - shift, l);\n     return l;\n   }\n \n-  /**\n-   * Indicates whether this stream supports the mark and reset methods.\n-   */\n-  public boolean markSupported()\n-  {\n-    return in.markSupported();\n-  }\n-\n-  /**\n-   * Marks the current position in this stream.\n-   */\n-  public void mark(int readlimit)\n-  {\n-    in.mark(readlimit);\n-    markBuf = buf;\n-  }\n-\n-  /**\n-   * Repositions this stream to the position at the time the mark method was\n-   * called.\n-   */\n-  public void reset()\n+  private int indexOfCRLF(byte[] b, int off, int len)\n     throws IOException\n   {\n-    in.reset();\n-    buf = markBuf;\n-  }\n-\n-  private int removeCRLF(byte[] b, int off, int len)\n-  {\n-    int end = off + len;\n-    for (int i = off; i < end; i++)\n+    doReset = false;\n+    int lm1 = len - 1;\n+    for (int i = off; i < len; i++)\n       {\n         if (b[i] == CR)\n           {\n-            if (i + 1 == end)\n+            int d;\n+            if (i == lm1)\n               {\n-                // This is the last byte, impossible to determine whether CRLF\n-                buf = CR;\n-                len--;\n+                d = in.read();\n+                doReset = true;\n               }\n-            else if (b[i + 1] == LF)\n+            else\n               {\n-                // Shift left\n-                end--;\n-                for (int j = i; j < end; j++)\n-                  {\n-                    b[j] = b[j + 1];\n-                  }\n-                  len--;\n-                  end = off + len;\n+                d = b[i + 1];\n+              }\n+            if (d == LF)\n+              {\n+                doReset = true;\n+                return i;\n               }\n           }\n       }\n-    return len;\n+    return -1;\n   }\n+\n }\n+"}]}