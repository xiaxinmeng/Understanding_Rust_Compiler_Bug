{"sha": "30f9cd05c6a101d6ec4c9e4487e6393195ed0c45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBmOWNkMDVjNmExMDFkNmVjNGM5ZTQ0ODdlNjM5MzE5NWVkMGM0NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-24T19:16:36Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-07-24T19:16:36Z"}, "message": "re PR fortran/31205 (aliased operator assignment produces wrong result)\n\n2007-07-24 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/31205\n\tPR fortran/32842\n\t* trans-expr.c (gfc_conv_function_call): Remove the default\n\tinitialization of intent(out) derived types.\n\t* symbol.c (gfc_lval_expr_from_sym): New function.\n\t* matchexp.c (gfc_get_parentheses): Return argument, if it is\n\tcharacter and posseses a ref.\n\t* gfortran.h : Add prototype for gfc_lval_expr_from_sym.\n\t* resolve.c (has_default_initializer): Move higher up in file.\n\t(resolve_code): On detecting an interface assignment, check\n\tif the rhs and the lhs are the same symbol.  If this is so,\n\tenclose the rhs in parenetheses to generate a temporary and\n\tprevent any possible aliasing.\n\t(apply_default_init): Remove code making the lval and call\n\tgfc_lval_expr_from_sym instead.\n\t(resolve_operator): Give a parentheses expression a type-\n\tspec if it has no type.\n\t* trans-decl.c (gfc_trans_deferred_vars): Apply the a default\n\tinitializer, if any, to an intent(out) derived type, using\n\tgfc_lval_expr_from_sym and gfc_trans_assignment.  Check if\n\tthe dummy is present.\n\n\n2007-07-24 Paul Thomas <pault@gcc.gnu.org>\n\n\tPR fortran/31205\n\t* gfortran.dg/alloc_comp_basics_1.f90 : Restore number of\n\t\"deallocates\" to 24, since patch has code rid of much spurious\n\tcode.\n\t* gfortran.dg/interface_assignment_1.f90 : New test.\n\n\tPR fortran/32842\n\t* gfortran.dg/interface_assignment_2.f90 : New test.\n\nFrom-SVN: r126886", "tree": {"sha": "b9d7a81ed4436258359f8fd5b4bfab4cd86b6c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9d7a81ed4436258359f8fd5b4bfab4cd86b6c24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45/comments", "author": null, "committer": null, "parents": [{"sha": "08113c7398f734fdabf27af9d143af83ebde3767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08113c7398f734fdabf27af9d143af83ebde3767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08113c7398f734fdabf27af9d143af83ebde3767"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "6740ba14003b2f3258d86686db96b45d41d90c8c", "filename": "gcc/testsuite/gfortran.dg/interface_assignment_1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_1.f90?ref=30f9cd05c6a101d6ec4c9e4487e6393195ed0c45", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! Checks the fix for PR31205, in which temporaries were not\n+! written for the interface assignment and the parentheses below.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+MODULE TT\n+ TYPE data_type\n+   INTEGER :: I=2\n+ END TYPE data_type\n+ INTERFACE ASSIGNMENT (=)\n+   MODULE PROCEDURE set\n+ END INTERFACE\n+CONTAINS\n+  PURE SUBROUTINE set(x1,x2)\n+    TYPE(data_type), INTENT(IN) :: x2\n+    TYPE(data_type), INTENT(OUT) :: x1\n+    CALL S1(x1,x2)\n+  END SUBROUTINE\n+  PURE SUBROUTINE S1(x1,x2)\n+    TYPE(data_type), INTENT(IN) :: x2\n+    TYPE(data_type), INTENT(OUT) :: x1\n+    x1%i=x2%i\n+  END SUBROUTINE\n+END MODULE\n+\n+USE TT\n+TYPE(data_type) :: D,E\n+\n+D%I=4\n+D=D\n+\n+E%I=4\n+CALL set(E,(E))\n+\n+IF (D%I.NE.4) call abort ()\n+IF (4.NE.E%I) call abort ()\n+END\n+! { dg-final { cleanup-modules \"TT\" } }"}, {"sha": "8d7484b31bf668f07971794ff2bfdc82da3d1874", "filename": "gcc/testsuite/gfortran.dg/interface_assignment_2.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f9cd05c6a101d6ec4c9e4487e6393195ed0c45/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finterface_assignment_2.f90?ref=30f9cd05c6a101d6ec4c9e4487e6393195ed0c45", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do run }\n+! Checks the fix for PR32842, in which the interface assignment\n+! below caused a segfault.  This testcase is reduced from vst_2.f95\n+! in the iso_varying_string testsuite, from Lawrie Schonfelder\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module iso_varying_string\n+  implicit none\n+  integer, parameter :: GET_BUFFER_LEN = 256\n+  type varying_string\n+     character(LEN=1), dimension(:), allocatable :: chars\n+  end type varying_string\n+  interface assignment(=)\n+     module procedure op_assign_VS_CH\n+  end interface assignment(=)\n+contains\n+  elemental subroutine op_assign_VS_CH (var, expr)\n+    type(varying_string), intent(out) :: var\n+    character(LEN=*), intent(in)      :: expr\n+    var = var_str(expr)\n+  end subroutine op_assign_VS_CH\n+  elemental function var_str (chr) result (string)\n+    character(LEN=*), intent(in) :: chr\n+    type(varying_string)         :: string\n+    integer                      :: length\n+    integer                      :: i_char\n+    length = LEN(chr)\n+    ALLOCATE(string%chars(length))\n+    forall(i_char = 1:length)\n+       string%chars(i_char) = chr(i_char:i_char)\n+    end forall\n+  end function var_str\n+end module iso_varying_string\n+\n+PROGRAM VST_2\n+  USE ISO_VARYING_STRING\n+  IMPLICIT NONE\n+  CHARACTER(LEN=5)     :: char_arb(2)\n+  CHARACTER(LEN=1)     :: char_elm(10)\n+  equivalence (char_arb, char_elm)\n+  type(VARYING_STRING) :: str_ara(2)\n+  char_arb(1)= \"Hello\"\n+  char_arb(2)= \"World\"\n+  str_ara = char_arb\n+  if (any (str_ara(1)%chars(1:5) .ne. char_elm(1:5))) call abort\n+  if (any (str_ara(2)%chars(1:5) .ne. char_elm(6:10))) call abort\n+END PROGRAM VST_2\n+! { dg-final { cleanup-modules \"iso_varying_string\" } }"}]}