{"sha": "1ef39479434ce54879e46926d1ac1c12009c5c07", "node_id": "C_kwDOANBUbNoAKDFlZjM5NDc5NDM0Y2U1NDg3OWU0NjkyNmQxYWMxYzEyMDA5YzVjMDc", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-03-29T12:35:53Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-03-30T16:52:24Z"}, "message": "gccrs: Fix handling of generic arguments for lifetimes only\n\nWe might have generics that are only for lifetimes this is a bad error\ncheck. We can simply rely on the function to marshall the HIR generics\narguements for the type system to do the error handling for us which will\nbe more acurate anyway.\n\nFixes #2043 #2039\n\ngcc/rust/ChangeLog:\n\n\t* resolve/rust-ast-resolve-item.cc (ResolveTraitItems::visit):\n\tadd check for reference marker and type's in self params\n\t(ResolveItem::visit): likewise\n\t* typecheck/rust-hir-type-check-path.cc (TypeCheckExpr::resolve_root_path):\n\tremove bad generics check\n\t(TypeCheckExpr::resolve_segments): likewise\n\t* typecheck/rust-hir-type-check-type.cc (TypeCheckType::resolve_root_path): likewise\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/const_generics_5.rs: update test case\n\t* rust/compile/issue-2043.rs: New test.\n\t* rust/compile/issue-2039.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "7e317d9daab85ca97416f1f752ad74f91493566a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e317d9daab85ca97416f1f752ad74f91493566a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ef39479434ce54879e46926d1ac1c12009c5c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef39479434ce54879e46926d1ac1c12009c5c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ef39479434ce54879e46926d1ac1c12009c5c07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ef39479434ce54879e46926d1ac1c12009c5c07/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cc5c9360c9454f7aa20717b6cfcc7085836233b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cc5c9360c9454f7aa20717b6cfcc7085836233b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cc5c9360c9454f7aa20717b6cfcc7085836233b"}], "stats": {"total": 100, "additions": 46, "deletions": 54}, "files": [{"sha": "9758984a235a7ea610b1e3025c66fae4de0f061c", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=1ef39479434ce54879e46926d1ac1c12009c5c07", "patch": "@@ -142,13 +142,8 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n \n   if (self_param.has_type ())\n     {\n-      if (self_param.get_has_ref ())\n-\t{\n-\t  // FIXME is this true?\n-\t  rust_error_at (\n-\t    self_param.get_locus (),\n-\t    \"it is not possible to mark self as reference and specify type\");\n-\t}\n+      // This shouldn't happen the parser should already error for this\n+      rust_assert (!self_param.get_has_ref ());\n       ResolveType::go (self_param.get_type ().get ());\n     }\n   else\n@@ -655,13 +650,8 @@ ResolveItem::visit (AST::Method &method)\n \n   if (self_param.has_type ())\n     {\n-      if (self_param.get_has_ref ())\n-\t{\n-\t  // FIXME is this true?\n-\t  rust_error_at (\n-\t    self_param.get_locus (),\n-\t    \"it is not possible to mark self as reference and specify type\");\n-\t}\n+      // This shouldn't happen the parser should already error for this\n+      rust_assert (!self_param.get_has_ref ());\n       ResolveType::go (self_param.get_type ().get ());\n     }\n   else"}, {"sha": "68ff995f108898f62d2cf9c6df7ab8f065b7ce72", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=1ef39479434ce54879e46926d1ac1c12009c5c07", "patch": "@@ -280,14 +280,6 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       // turbo-fish segment path::<ty>\n       if (seg.has_generic_args ())\n \t{\n-\t  if (!lookup->has_subsititions_defined ())\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"substitutions not supported for %s\",\n-\t\t\t     root_tyty->as_string ().c_str ());\n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\n \t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n \t\t\t\t\t &seg.get_generic_args ());\n \t  if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n@@ -456,13 +448,6 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \n       if (seg.has_generic_args ())\n \t{\n-\t  if (!tyseg->has_subsititions_defined ())\n-\t    {\n-\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n-\t\t\t     tyseg->as_string ().c_str ());\n-\t      return;\n-\t    }\n-\n \t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n \t\t\t\t\t&seg.get_generic_args ());\n \t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "dad0c410ebb1c52b05ed88e3203afb609c95ad1e", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=1ef39479434ce54879e46926d1ac1c12009c5c07", "patch": "@@ -398,17 +398,10 @@ TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n \t  HIR::TypePathSegmentGeneric *generic_segment\n \t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n \n-\t  if (!lookup->has_subsititions_defined ())\n-\t    {\n-\t      rust_error_at (path.get_locus (),\n-\t\t\t     \"TypePath %s declares generic arguments but the \"\n-\t\t\t     \"type %s does not have any\",\n-\t\t\t     path.as_string ().c_str (),\n-\t\t\t     lookup->as_string ().c_str ());\n-\t      return new TyTy::ErrorType (lookup->get_ref ());\n-\t    }\n \t  lookup = SubstMapper::Resolve (lookup, path.get_locus (),\n \t\t\t\t\t &generic_segment->get_generic_args ());\n+\t  if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return new TyTy::ErrorType (seg->get_mappings ().get_hirid ());\n \t}\n       else if (lookup->needs_generic_substitutions ())\n \t{\n@@ -494,13 +487,6 @@ TypeCheckType::resolve_segments (\n \t  HIR::TypePathSegmentGeneric *generic_segment\n \t    = static_cast<HIR::TypePathSegmentGeneric *> (seg.get ());\n \n-\t  if (!tyseg->has_subsititions_defined ())\n-\t    {\n-\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n-\t\t\t     tyseg->as_string ().c_str ());\n-\t      return new TyTy::ErrorType (expr_id);\n-\t    }\n-\n \t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n \t\t\t\t\t&generic_segment->get_generic_args ());\n \t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "685229eabd21cbc6e8fab660d58d0ec08dfabf60", "filename": "gcc/testsuite/rust/compile/const_generics_5.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_5.rs?ref=1ef39479434ce54879e46926d1ac1c12009c5c07", "patch": "@@ -1,15 +1,12 @@\n-// bogus errors but shows the type checking system needs to support const\n-// generics with defaults\n-\n+// { dg-options \"-w\" }\n struct Foo<const N: usize = { 14 }>;\n \n const M: usize = 15;\n-type N = Foo<3>; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+type N = Foo<3>;\n \n fn main() {\n-    let _: Foo<15> = Foo; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n-    let _: Foo<{ M }> = Foo; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n-    let _: Foo<M> = Foo; // { dg-error \"TypePath Foo<> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n-\n-    let _: Foo<N> = Foo; // { dg-error \"TypePath Foo<N> declares generic arguments but the type Foo{Foo {}} does not have any\" }\n+    let _: Foo<15> = Foo;\n+    let _: Foo<{ M }> = Foo;\n+    let _: Foo<M> = Foo;\n+    // let _: Foo<N> = Foo; this causes an ICE we need to do const generics\n }"}, {"sha": "70eb0ee3f6d8cb731b5f49e05b48a2d3e57ff357", "filename": "gcc/testsuite/rust/compile/issue-2039.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2039.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2039.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2039.rs?ref=1ef39479434ce54879e46926d1ac1c12009c5c07", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options \"-w\" }\n+pub struct Lexer<'a> {\n+    input: &'a str,\n+}\n+\n+impl<'a> Lexer<'a> {\n+    pub fn new(input: &'a str) -> Lexer<'a> {\n+        Lexer { input: input }\n+    }\n+}\n+\n+struct Parser<'a> {\n+    lexer: &'a mut Lexer<'a>,\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub fn new(lexer: &'a mut Lexer) -> Parser<'a> {\n+        Parser { lexer: lexer }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "efa1ded75305d9c29c37e428e11abf7bf53656ba", "filename": "gcc/testsuite/rust/compile/issue-2043.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2043.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ef39479434ce54879e46926d1ac1c12009c5c07/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2043.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2043.rs?ref=1ef39479434ce54879e46926d1ac1c12009c5c07", "patch": "@@ -0,0 +1,12 @@\n+struct Foo<'a> {\n+    // { dg-warning \"struct is never constructed: .Foo.\" \"\" { target *-*-* } .-1 }\n+    data: &'a [u8],\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn bar(self: &mut Foo<'a>) {}\n+    // { dg-warning \"associated function is never used: .bar.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+fn main() {}"}]}