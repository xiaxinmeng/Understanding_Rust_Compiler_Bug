{"sha": "f898abd71d235affbcba72b8584d9feca5a3a18e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5OGFiZDcxZDIzNWFmZmJjYmE3MmI4NTg0ZDlmZWNhNWEzYTE4ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-16T00:00:32Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-16T00:00:32Z"}, "message": "(redundant_insn): Renamed from redundant_insn_p; all callers changed.\n\nFrom-SVN: r8447", "tree": {"sha": "94c570c8a584a128a1edc882a98cc6bae993bfa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94c570c8a584a128a1edc882a98cc6bae993bfa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f898abd71d235affbcba72b8584d9feca5a3a18e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f898abd71d235affbcba72b8584d9feca5a3a18e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f898abd71d235affbcba72b8584d9feca5a3a18e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f898abd71d235affbcba72b8584d9feca5a3a18e/comments", "author": null, "committer": null, "parents": [{"sha": "5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5317d2f8b42652dbd7acf1eea432c8adc56ecca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5317d2f8b42652dbd7acf1eea432c8adc56ecca5"}], "stats": {"total": 19, "additions": 9, "deletions": 10}, "files": [{"sha": "ec21a3503824f31d1371319a4ff4257fb252c751", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f898abd71d235affbcba72b8584d9feca5a3a18e/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f898abd71d235affbcba72b8584d9feca5a3a18e/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=f898abd71d235affbcba72b8584d9feca5a3a18e", "patch": "@@ -244,7 +244,7 @@ static rtx steal_delay_list_from_fallthrough PROTO((rtx, rtx, rtx, rtx,\n \t\t\t\t\t\t    struct resources *,\n \t\t\t\t\t\t    int, int *, int *));\n static void try_merge_delay_insns PROTO((rtx, rtx));\n-static rtx redundant_insn_p\tPROTO((rtx, rtx, rtx));\n+static rtx redundant_insn\tPROTO((rtx, rtx, rtx));\n static int own_thread_p\t\tPROTO((rtx, rtx, int));\n static int find_basic_block\tPROTO((rtx));\n static void update_block\tPROTO((rtx, rtx));\n@@ -1621,7 +1621,7 @@ steal_delay_list_from_target (insn, condition, seq, delay_list,\n \n       /* If this insn was already done (usually in a previous delay slot),\n \t pretend we put it in our delay slot.  */\n-      if (redundant_insn_p (trial, insn, new_delay_list))\n+      if (redundant_insn (trial, insn, new_delay_list))\n \tcontinue;\n \n       /* We will end up re-vectoring this branch, so compute flags\n@@ -1711,7 +1711,7 @@ steal_delay_list_from_fallthrough (insn, condition, seq,\n \tbreak;\n \n       /* If this insn was already done, we don't need it.  */\n-      if (redundant_insn_p (trial, insn, delay_list))\n+      if (redundant_insn (trial, insn, delay_list))\n \t{\n \t  delete_from_delay_slot (trial);\n \t  continue;\n@@ -1924,7 +1924,7 @@ try_merge_delay_insns (insn, thread)\n    gain in rare cases.  */\n \n static rtx\n-redundant_insn_p (insn, target, delay_list)\n+redundant_insn (insn, target, delay_list)\n      rtx insn;\n      rtx target;\n      rtx delay_list;\n@@ -3312,7 +3312,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t  /* If TRIAL is redundant with some insn before INSN, we don't\n \t     actually need to add it to the delay list; we can merely pretend\n \t     we did.  */\n-\t  if (prior_insn = redundant_insn_p (trial, insn, delay_list))\n+\t  if (prior_insn = redundant_insn (trial, insn, delay_list))\n \t    {\n \t      if (own_thread)\n \t\t{\n@@ -3408,8 +3408,7 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t\t\t     && ! insn_sets_resource_p (new_thread, &needed, 1)\n \t\t\t     && ! insn_references_resource_p (new_thread,\n \t\t\t\t\t\t\t      &set, 1)\n-\t\t\t     && redundant_insn_p (new_thread, insn,\n-\t\t\t\t\t\t  delay_list))\n+\t\t\t     && redundant_insn (new_thread, insn, delay_list))\n \t\t\tnew_thread = next_active_insn (new_thread);\n \t\t      break;\n \t\t    }\n@@ -3827,7 +3826,7 @@ relax_delay_slots (first)\n       /* See if the first insn in the delay slot is redundant with some\n \t previous insn.  Remove it from the delay slot if so; then set up\n \t to reprocess this insn.  */\n-      if (redundant_insn_p (XVECEXP (pat, 0, 1), delay_insn, 0))\n+      if (redundant_insn (XVECEXP (pat, 0, 1), delay_insn, 0))\n \t{\n \t  delete_from_delay_slot (XVECEXP (pat, 0, 1));\n \t  next = prev_active_insn (next);\n@@ -3862,7 +3861,7 @@ relax_delay_slots (first)\n \t     insn, redirect the jump to the following insn process again.  */\n \t  trial = next_active_insn (target_label);\n \t  if (trial && GET_CODE (PATTERN (trial)) != SEQUENCE\n-\t      && redundant_insn_p (trial, insn, 0))\n+\t      && redundant_insn (trial, insn, 0))\n \t    {\n \t      trial = next_active_insn (trial);\n \t      if (trial == 0)\n@@ -3881,7 +3880,7 @@ relax_delay_slots (first)\n \t      && GET_CODE (XVECEXP (PATTERN (trial), 0, 0)) == JUMP_INSN\n \t      && (simplejump_p (XVECEXP (PATTERN (trial), 0, 0))\n \t\t  || GET_CODE (PATTERN (XVECEXP (PATTERN (trial), 0, 0))) == RETURN)\n-\t      && redundant_insn_p (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n+\t      && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n \t    {\n \t      target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n \t      if (target_label == 0)"}]}