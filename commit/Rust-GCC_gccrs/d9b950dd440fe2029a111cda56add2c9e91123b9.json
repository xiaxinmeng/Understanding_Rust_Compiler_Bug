{"sha": "d9b950dd440fe2029a111cda56add2c9e91123b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliOTUwZGQ0NDBmZTIwMjlhMTExY2RhNTZhZGQyYzllOTExMjNiOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-06-06T17:11:30Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-06-06T17:11:30Z"}, "message": "Selftest framework\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add function-tests.o,\n\thash-map-tests.o, hash-set-tests.o, rtl-tests.o,\n\tselftest-run-tests.o.\n\t(OBJS-libcommon): Add selftest.o.\n\t(OBJS-libcommon-target): Add selftest.o.\n\t(all.internal): Add \"selftest\".\n\t(all.cross): Likewise.\n\t(selftest): New phony target.\n\t(s-selftest): New target.\n\t(selftest-gdb): New phony target.\n\t(COLLECT2_OBJS): Add selftest.o.\n\t* bitmap.c: Include \"selftest.h\".\n\t(selftest::test_gc_alloc): New function.\n\t(selftest::test_set_range): New function.\n\t(selftest::test_clear_bit_in_middle): New function.\n\t(selftest::test_copying): New function.\n\t(selftest::test_bitmap_single_bit_set_p): New function.\n\t(selftest::bitmap_c_tests): New function.\n\t* common.opt (fself-test): New.\n\t* diagnostic-show-locus.c: Include \"selftest.h\".\n\t(make_range): New function.\n\t(test_range_contains_point_for_single_point): New function.\n\t(test_range_contains_point_for_single_line): New function.\n\t(test_range_contains_point_for_multiple_lines): New function.\n\t(assert_eq): New function.\n\t(test_get_line_width_without_trailing_whitespace): New function.\n\t(selftest::diagnostic_show_locus_c_tests): New function.\n\t* et-forest.c: Include \"selftest.h\".\n\t(selftest::test_single_node): New function.\n\t(selftest::test_simple_tree): New function.\n\t(selftest::test_disconnected_nodes): New function.\n\t(selftest::et_forest_c_tests): New function.\n\t* fold-const.c: Include \"selftest.h\".\n\t(selftest::assert_binop_folds_to_const): New function.\n\t(selftest::assert_binop_folds_to_nonlvalue): New function.\n\t(selftest::test_arithmetic_folding): New function.\n\t(selftest::fold_const_c_tests): New function.\n\t* function-tests.c: New file.\n\t* gimple.c: Include \"selftest.h\".\n\tInclude \"gimple-pretty-print.h\".\n\t(selftest::verify_gimple_pp): New function.\n\t(selftest::test_assign_single): New function.\n\t(selftest::test_assign_binop): New function.\n\t(selftest::test_nop_stmt): New function.\n\t(selftest::test_return_stmt): New function.\n\t(selftest::test_return_without_value): New function.\n\t(selftest::gimple_c_tests): New function.\n\t* hash-map-tests.c: New file.\n\t* hash-set-tests.c: New file.\n\t* input.c: Include \"selftest.h\".\n\t(selftest::assert_loceq): New function.\n\t(selftest::test_accessing_ordinary_linemaps): New function.\n\t(selftest::test_unknown_location): New function.\n\t(selftest::test_builtins): New function.\n\t(selftest::test_reading_source_line): New function.\n\t(selftest::input_c_tests): New function.\n\t* rtl-tests.c: New file.\n\t* selftest-run-tests.c: New file.\n\t* selftest.c: New file.\n\t* selftest.h: New file.\n\t* spellcheck.c: Include \"selftest.h\".\n\t(selftest::levenshtein_distance_unit_test_oneway): New function,\n\tadapted from testsuite/gcc.dg/plugin/levenshtein_plugin.c.\n\t(selftest::levenshtein_distance_unit_test): Likewise.\n\t(selftest::spellcheck_c_tests): Likewise.\n\t* toplev.c: Include selftest.h.\n\t(toplev::run_self_tests): New.\n\t(toplev::main): Handle -fself-test.\n\t* toplev.h (toplev::run_self_tests): New.\n\t* tree.c: Include \"selftest.h\".\n\t(selftest::test_integer_constants): New function.\n\t(selftest::test_identifiers): New function.\n\t(selftest::test_labels): New function.\n\t(selftest::tree_c_tests): New function.\n\t* tree-cfg.c: Include \"selftest.h\".\n\t(selftest::push_fndecl): New function.\n\t(selftest::test_linear_chain): New function.\n\t(selftest::test_diamond): New function.\n\t(selftest::test_fully_connected): New function.\n\t(selftest::tree_cfg_c_tests): New function.\n\t* vec.c: Include \"selftest.h\".\n\t(selftest::safe_push_range): New function.\n\t(selftest::test_quick_push): New function.\n\t(selftest::test_safe_push): New function.\n\t(selftest::test_truncate): New function.\n\t(selftest::test_safe_grow_cleared): New function.\n\t(selftest::test_pop): New function.\n\t(selftest::test_safe_insert): New function.\n\t(selftest::test_ordered_remove): New function.\n\t(selftest::test_unordered_remove): New function.\n\t(selftest::test_block_remove): New function.\n\t(selftest::reverse_cmp): New function.\n\t(selftest::test_qsort): New function.\n\t(selftest::vec_c_tests): New function.c.\n\t* wide-int.cc: Include selftest.h and wide-int-print.h.\n\t(selftest::from_int <wide_int>): New function.\n\t(selftest::from_int <offset_int>): New function.\n\t(selftest::from_int <widest_int>): New function.\n\t(selftest::assert_deceq): New function.\n\t(selftest::assert_hexeq): New function.\n\t(selftest::test_printing <VALUE_TYPE>): New function template.\n\t(selftest::test_ops <VALUE_TYPE>): New function template.\n\t(selftest::test_comparisons <VALUE_TYPE>): New function template.\n\t(selftest::run_all_wide_int_tests <VALUE_TYPE>): New function\n\ttemplate.\n\t(selftest::wide_int_cc_tests): New function.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/levenshtein-test-1.c: Delete.\n\t* gcc.dg/plugin/levenshtein_plugin.c: Delete.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Remove the\n\tabove.\n\nFrom-SVN: r237144", "tree": {"sha": "63fc70ab85f16020285e16504429ce186042a4da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63fc70ab85f16020285e16504429ce186042a4da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b950dd440fe2029a111cda56add2c9e91123b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b950dd440fe2029a111cda56add2c9e91123b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b950dd440fe2029a111cda56add2c9e91123b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b950dd440fe2029a111cda56add2c9e91123b9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbc6221fe5aa38017bb5818aa28257360b15f3b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc6221fe5aa38017bb5818aa28257360b15f3b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbc6221fe5aa38017bb5818aa28257360b15f3b6"}], "stats": {"total": 2957, "additions": 2878, "deletions": 79}, "files": [{"sha": "68a7b78f4b658dd73774fe0ed531402f4c370730", "filename": "gcc/ChangeLog", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -1,3 +1,112 @@\n+2016-06-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add function-tests.o,\n+\thash-map-tests.o, hash-set-tests.o, rtl-tests.o,\n+\tselftest-run-tests.o.\n+\t(OBJS-libcommon): Add selftest.o.\n+\t(OBJS-libcommon-target): Add selftest.o.\n+\t(all.internal): Add \"selftest\".\n+\t(all.cross): Likewise.\n+\t(selftest): New phony target.\n+\t(s-selftest): New target.\n+\t(selftest-gdb): New phony target.\n+\t(COLLECT2_OBJS): Add selftest.o.\n+\t* bitmap.c: Include \"selftest.h\".\n+\t(selftest::test_gc_alloc): New function.\n+\t(selftest::test_set_range): New function.\n+\t(selftest::test_clear_bit_in_middle): New function.\n+\t(selftest::test_copying): New function.\n+\t(selftest::test_bitmap_single_bit_set_p): New function.\n+\t(selftest::bitmap_c_tests): New function.\n+\t* common.opt (fself-test): New.\n+\t* diagnostic-show-locus.c: Include \"selftest.h\".\n+\t(make_range): New function.\n+\t(test_range_contains_point_for_single_point): New function.\n+\t(test_range_contains_point_for_single_line): New function.\n+\t(test_range_contains_point_for_multiple_lines): New function.\n+\t(assert_eq): New function.\n+\t(test_get_line_width_without_trailing_whitespace): New function.\n+\t(selftest::diagnostic_show_locus_c_tests): New function.\n+\t* et-forest.c: Include \"selftest.h\".\n+\t(selftest::test_single_node): New function.\n+\t(selftest::test_simple_tree): New function.\n+\t(selftest::test_disconnected_nodes): New function.\n+\t(selftest::et_forest_c_tests): New function.\n+\t* fold-const.c: Include \"selftest.h\".\n+\t(selftest::assert_binop_folds_to_const): New function.\n+\t(selftest::assert_binop_folds_to_nonlvalue): New function.\n+\t(selftest::test_arithmetic_folding): New function.\n+\t(selftest::fold_const_c_tests): New function.\n+\t* function-tests.c: New file.\n+\t* gimple.c: Include \"selftest.h\".\n+\tInclude \"gimple-pretty-print.h\".\n+\t(selftest::verify_gimple_pp): New function.\n+\t(selftest::test_assign_single): New function.\n+\t(selftest::test_assign_binop): New function.\n+\t(selftest::test_nop_stmt): New function.\n+\t(selftest::test_return_stmt): New function.\n+\t(selftest::test_return_without_value): New function.\n+\t(selftest::gimple_c_tests): New function.\n+\t* hash-map-tests.c: New file.\n+\t* hash-set-tests.c: New file.\n+\t* input.c: Include \"selftest.h\".\n+\t(selftest::assert_loceq): New function.\n+\t(selftest::test_accessing_ordinary_linemaps): New function.\n+\t(selftest::test_unknown_location): New function.\n+\t(selftest::test_builtins): New function.\n+\t(selftest::test_reading_source_line): New function.\n+\t(selftest::input_c_tests): New function.\n+\t* rtl-tests.c: New file.\n+\t* selftest-run-tests.c: New file.\n+\t* selftest.c: New file.\n+\t* selftest.h: New file.\n+\t* spellcheck.c: Include \"selftest.h\".\n+\t(selftest::levenshtein_distance_unit_test_oneway): New function,\n+\tadapted from testsuite/gcc.dg/plugin/levenshtein_plugin.c.\n+\t(selftest::levenshtein_distance_unit_test): Likewise.\n+\t(selftest::spellcheck_c_tests): Likewise.\n+\t* toplev.c: Include selftest.h.\n+\t(toplev::run_self_tests): New.\n+\t(toplev::main): Handle -fself-test.\n+\t* toplev.h (toplev::run_self_tests): New.\n+\t* tree.c: Include \"selftest.h\".\n+\t(selftest::test_integer_constants): New function.\n+\t(selftest::test_identifiers): New function.\n+\t(selftest::test_labels): New function.\n+\t(selftest::tree_c_tests): New function.\n+\t* tree-cfg.c: Include \"selftest.h\".\n+\t(selftest::push_fndecl): New function.\n+\t(selftest::test_linear_chain): New function.\n+\t(selftest::test_diamond): New function.\n+\t(selftest::test_fully_connected): New function.\n+\t(selftest::tree_cfg_c_tests): New function.\n+\t* vec.c: Include \"selftest.h\".\n+\t(selftest::safe_push_range): New function.\n+\t(selftest::test_quick_push): New function.\n+\t(selftest::test_safe_push): New function.\n+\t(selftest::test_truncate): New function.\n+\t(selftest::test_safe_grow_cleared): New function.\n+\t(selftest::test_pop): New function.\n+\t(selftest::test_safe_insert): New function.\n+\t(selftest::test_ordered_remove): New function.\n+\t(selftest::test_unordered_remove): New function.\n+\t(selftest::test_block_remove): New function.\n+\t(selftest::reverse_cmp): New function.\n+\t(selftest::test_qsort): New function.\n+\t(selftest::vec_c_tests): New function.c.\n+\t* wide-int.cc: Include selftest.h and wide-int-print.h.\n+\t(selftest::from_int <wide_int>): New function.\n+\t(selftest::from_int <offset_int>): New function.\n+\t(selftest::from_int <widest_int>): New function.\n+\t(selftest::assert_deceq): New function.\n+\t(selftest::assert_hexeq): New function.\n+\t(selftest::test_printing <VALUE_TYPE>): New function template.\n+\t(selftest::test_ops <VALUE_TYPE>): New function template.\n+\t(selftest::test_comparisons <VALUE_TYPE>): New function template.\n+\t(selftest::run_all_wide_int_tests <VALUE_TYPE>): New function\n+\ttemplate.\n+\t(selftest::wide_int_cc_tests): New function.\n+\n 2016-06-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR middle-end/37780"}, {"sha": "fdcc42aa309480660209d2830fd6e2d6d293e1de", "filename": "gcc/Makefile.in", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -1264,6 +1264,7 @@ OBJS = \\\n \tfold-const.o \\\n \tfold-const-call.o \\\n \tfunction.o \\\n+\tfunction-tests.o \\\n \tfwprop.o \\\n \tgcc-rich-location.o \\\n \tgcse.o \\\n@@ -1299,6 +1300,8 @@ OBJS = \\\n \tgraphite-sese-to-poly.o \\\n \tgtype-desc.o \\\n \thaifa-sched.o \\\n+\thash-map-tests.o \\\n+\thash-set-tests.o \\\n \thsa.o \\\n \thsa-gen.o \\\n \thsa-regalloc.o \\\n@@ -1399,6 +1402,7 @@ OBJS = \\\n \tresource.o \\\n \trtl-chkp.o \\\n \trtl-error.o \\\n+\trtl-tests.o \\\n \trtl.o \\\n \trtlhash.o \\\n \trtlanal.o \\\n@@ -1411,6 +1415,7 @@ OBJS = \\\n \tsel-sched-ir.o \\\n \tsel-sched-dump.o \\\n \tsel-sched.o \\\n+\tselftest-run-tests.o \\\n \tsese.o \\\n \tshrink-wrap.o \\\n \tsimplify-rtx.o \\\n@@ -1543,13 +1548,14 @@ OBJS = \\\n # no target dependencies.\n OBJS-libcommon = diagnostic.o diagnostic-color.o diagnostic-show-locus.o \\\n \tpretty-print.o intl.o \\\n-\tvec.o input.o version.o hash-table.o ggc-none.o memory-block.o\n+\tvec.o input.o version.o hash-table.o ggc-none.o memory-block.o \\\n+\tselftest.o\n \n # Objects in libcommon-target.a, used by drivers and by the core\n # compiler and containing target-dependent code.\n OBJS-libcommon-target = $(common_out_object_file) prefix.o params.o \\\n \topts.o opts-common.o options.o vec.o hooks.o common/common-targhooks.o \\\n-\thash-table.o file-find.o spellcheck.o\n+\thash-table.o file-find.o spellcheck.o selftest.o\n \n # This lists all host objects for the front ends.\n ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))\n@@ -1816,10 +1822,10 @@ config.status: $(srcdir)/configure $(srcdir)/config.gcc\n quickstrap: all\n \tcd $(toplevel_builddir) && $(MAKE) all-target-libgcc\n \n-all.internal: start.encap rest.encap doc\n+all.internal: start.encap rest.encap doc selftest\n # This is what to compile if making a cross-compiler.\n all.cross: native gcc-cross$(exeext) cpp$(exeext) specs \\\n-\tlibgcc-support lang.all.cross doc @GENINSRC@ srcextra\n+\tlibgcc-support lang.all.cross doc selftest @GENINSRC@ srcextra\n # This is what must be made before installing GCC and converting libraries.\n start.encap: native xgcc$(exeext) cpp$(exeext) specs \\\n \tlibgcc-support lang.start.encap @GENINSRC@ srcextra\n@@ -1839,6 +1845,21 @@ endif\n # This does the things that can't be done on the host machine.\n rest.cross: specs\n \n+# Run the selftests during the build once we have a driver and a cc1,\n+# so that self-test failures are caught as early as possible.\n+# Use \"s-selftest\" to ensure that we only run the selftests if the\n+# driver or cc1 change.\n+.PHONY: selftest\n+selftest: s-selftest\n+s-selftest: $(GCC_PASSES) cc1$(exeext) stmp-int-hdrs\n+\t$(GCC_FOR_TARGET) -xc -S -c /dev/null -fself-test\n+\t$(STAMP) $@\n+\n+# Convenience method for running selftests under gdb:\n+.PHONY: selftest-gdb\n+selftest-gdb: $(GCC_PASSES) cc1$(exeext) stmp-int-hdrs\n+\t$(GCC_FOR_TARGET) -xc -S -c /dev/null -fself-test -wrapper gdb,--args\n+\n # Recompile all the language-independent object files.\n # This is used only if the user explicitly asks for it.\n compilations: $(BACKEND)\n@@ -1986,7 +2007,7 @@ gcc-nm.c: gcc-ar.c\n \tcp $^ $@\n \n COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o \\\n-  collect-utils.o file-find.o hash-table.o\n+  collect-utils.o file-find.o hash-table.o selftest.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this."}, {"sha": "6206535a8ea9f9a0203f00a4b60c5a1378181065", "filename": "gcc/bitmap.c", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"bitmap.h\"\n+#include \"selftest.h\"\n \n /* Memory allocation statistics purpose instance.  */\n mem_alloc_description<bitmap_usage> bitmap_mem_desc;\n@@ -2162,5 +2163,117 @@ debug (const bitmap_head *ptr)\n     fprintf (stderr, \"<nil>\\n\");\n }\n \n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for bitmaps.  */\n+\n+/* Freshly-created bitmaps ought to be empty.  */\n+\n+static void\n+test_gc_alloc ()\n+{\n+  bitmap b = bitmap_gc_alloc ();\n+  ASSERT_TRUE (bitmap_empty_p (b));\n+}\n+\n+/* Verify bitmap_set_range.  */\n+\n+static void\n+test_set_range ()\n+{\n+  bitmap b = bitmap_gc_alloc ();\n+  ASSERT_TRUE (bitmap_empty_p (b));\n+\n+  bitmap_set_range (b, 7, 5);\n+  ASSERT_FALSE (bitmap_empty_p (b));\n+  ASSERT_EQ (5, bitmap_count_bits (b));\n+\n+  /* Verify bitmap_bit_p at the boundaries.  */\n+  ASSERT_FALSE (bitmap_bit_p (b, 6));\n+  ASSERT_TRUE (bitmap_bit_p (b, 7));\n+  ASSERT_TRUE (bitmap_bit_p (b, 11));\n+  ASSERT_FALSE (bitmap_bit_p (b, 12));\n+}\n+\n+/* Verify splitting a range into two pieces using bitmap_clear_bit.  */\n+\n+static void\n+test_clear_bit_in_middle ()\n+{\n+  bitmap b = bitmap_gc_alloc ();\n+\n+  /* Set b to [100..200].  */\n+  bitmap_set_range (b, 100, 100);\n+  ASSERT_EQ (100, bitmap_count_bits (b));\n+\n+  /* Clear a bit in the middle.  */\n+  bool changed = bitmap_clear_bit (b, 150);\n+  ASSERT_TRUE (changed);\n+  ASSERT_EQ (99, bitmap_count_bits (b));\n+  ASSERT_TRUE (bitmap_bit_p (b, 149));\n+  ASSERT_FALSE (bitmap_bit_p (b, 150));\n+  ASSERT_TRUE (bitmap_bit_p (b, 151));\n+}\n+\n+/* Verify bitmap_copy.  */\n+\n+static void\n+test_copying ()\n+{\n+  bitmap src = bitmap_gc_alloc ();\n+  bitmap_set_range (src, 40, 10);\n+\n+  bitmap dst = bitmap_gc_alloc ();\n+  ASSERT_FALSE (bitmap_equal_p (src, dst));\n+  bitmap_copy (dst, src);\n+  ASSERT_TRUE (bitmap_equal_p (src, dst));\n+\n+  /* Verify that we can make them unequal again...  */\n+  bitmap_set_range (src, 70, 5);\n+  ASSERT_FALSE (bitmap_equal_p (src, dst));\n+\n+  /* ...and that changing src after the copy didn't affect\n+     the other: */\n+  ASSERT_FALSE (bitmap_bit_p (dst, 70));\n+}\n+\n+/* Verify bitmap_single_bit_set_p.  */\n+\n+static void\n+test_bitmap_single_bit_set_p ()\n+{\n+  bitmap b = bitmap_gc_alloc ();\n+\n+  ASSERT_FALSE (bitmap_single_bit_set_p (b));\n+\n+  bitmap_set_range (b, 42, 1);\n+  ASSERT_TRUE (bitmap_single_bit_set_p (b));\n+  ASSERT_EQ (42, bitmap_first_set_bit (b));\n+\n+  bitmap_set_range (b, 1066, 1);\n+  ASSERT_FALSE (bitmap_single_bit_set_p (b));\n+  ASSERT_EQ (42, bitmap_first_set_bit (b));\n+\n+  bitmap_clear_range (b, 0, 100);\n+  ASSERT_TRUE (bitmap_single_bit_set_p (b));\n+  ASSERT_EQ (1066, bitmap_first_set_bit (b));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+bitmap_c_tests ()\n+{\n+  test_gc_alloc ();\n+  test_set_range ();\n+  test_clear_bit_in_middle ();\n+  test_copying ();\n+  test_bitmap_single_bit_set_p ();\n+}\n+\n+} // namespace selftest\n+#endif /* CHECKING_P */\n \n #include \"gt-bitmap.h\""}, {"sha": "632dd311fba3a94cb22c3bf7ffbb0919a6533bdc", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -2066,6 +2066,10 @@ fselective-scheduling2\n Common Report Var(flag_selective_scheduling2) Optimization\n Run selective scheduling after reload.\n \n+fself-test\n+Common Undocumented Var(flag_self_test)\n+Run self-tests.\n+\n fsel-sched-pipelining\n Common Report Var(flag_sel_sched_pipelining) Init(0) Optimization\n Perform software pipelining of inner loops during selective scheduling."}, {"sha": "7aab658b697c73977e1d7ac5895ea8528da6e6bc", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backtrace.h\"\n #include \"diagnostic.h\"\n #include \"diagnostic-color.h\"\n+#include \"selftest.h\"\n \n #ifdef HAVE_TERMIOS_H\n # include <termios.h>\n@@ -442,6 +443,123 @@ layout_range::contains_point (int row, int column) const\n   return column <= m_finish.m_column;\n }\n \n+#if CHECKING_P\n+\n+/* A helper function for testing layout_range::contains_point.  */\n+\n+static layout_range\n+make_range (int start_line, int start_col, int end_line, int end_col)\n+{\n+  const expanded_location start_exploc\n+    = {\"test.c\", start_line, start_col, NULL, false};\n+  const expanded_location finish_exploc\n+    = {\"test.c\", end_line, end_col, NULL, false};\n+  return layout_range (&start_exploc, &finish_exploc, false,\n+\t\t       &start_exploc);\n+}\n+\n+/* Selftests for layout_range::contains_point.  */\n+\n+/* Selftest for layout_range::contains_point where the layout_range\n+   is a range with start==end i.e. a single point.  */\n+\n+static void\n+test_range_contains_point_for_single_point ()\n+{\n+  layout_range point = make_range (7, 10, 7, 10);\n+\n+  /* Before the line. */\n+  ASSERT_FALSE (point.contains_point (6, 1));\n+\n+  /* On the line, but before start.  */\n+  ASSERT_FALSE (point.contains_point (7, 9));\n+\n+  /* At the point.  */\n+  ASSERT_TRUE (point.contains_point (7, 10));\n+\n+  /* On the line, after the point.  */\n+  ASSERT_FALSE (point.contains_point (7, 11));\n+\n+  /* After the line.  */\n+  ASSERT_FALSE (point.contains_point (8, 1));\n+}\n+\n+/* Selftest for layout_range::contains_point where the layout_range\n+   is the single-line range shown as \"Example A\" above.  */\n+\n+static void\n+test_range_contains_point_for_single_line ()\n+{\n+  layout_range example_a = make_range (2, 22, 2, 38);\n+\n+  /* Before the line. */\n+  ASSERT_FALSE (example_a.contains_point (1, 1));\n+\n+  /* On the line, but before start.  */\n+  ASSERT_FALSE (example_a.contains_point (2, 21));\n+\n+  /* On the line, at the start.  */\n+  ASSERT_TRUE (example_a.contains_point (2, 22));\n+\n+  /* On the line, within the range.  */\n+  ASSERT_TRUE (example_a.contains_point (2, 23));\n+\n+  /* On the line, at the end.  */\n+  ASSERT_TRUE (example_a.contains_point (2, 38));\n+\n+  /* On the line, after the end.  */\n+  ASSERT_FALSE (example_a.contains_point (2, 39));\n+\n+  /* After the line.  */\n+  ASSERT_FALSE (example_a.contains_point (2, 39));\n+}\n+\n+/* Selftest for layout_range::contains_point where the layout_range\n+   is the multi-line range shown as \"Example B\" above.  */\n+\n+static void\n+test_range_contains_point_for_multiple_lines ()\n+{\n+  layout_range example_b = make_range (3, 14, 5, 8);\n+\n+  /* Before first line. */\n+  ASSERT_FALSE (example_b.contains_point (1, 1));\n+\n+  /* On the first line, but before start.  */\n+  ASSERT_FALSE (example_b.contains_point (3, 13));\n+\n+  /* At the start.  */\n+  ASSERT_TRUE (example_b.contains_point (3, 14));\n+\n+  /* On the first line, within the range.  */\n+  ASSERT_TRUE (example_b.contains_point (3, 15));\n+\n+  /* On an interior line.\n+     The column number should not matter; try various boundary\n+     values.  */\n+  ASSERT_TRUE (example_b.contains_point (4, 1));\n+  ASSERT_TRUE (example_b.contains_point (4, 7));\n+  ASSERT_TRUE (example_b.contains_point (4, 8));\n+  ASSERT_TRUE (example_b.contains_point (4, 9));\n+  ASSERT_TRUE (example_b.contains_point (4, 13));\n+  ASSERT_TRUE (example_b.contains_point (4, 14));\n+  ASSERT_TRUE (example_b.contains_point (4, 15));\n+\n+  /* On the final line, before the end.  */\n+  ASSERT_TRUE (example_b.contains_point (5, 7));\n+\n+  /* On the final line, at the end.  */\n+  ASSERT_TRUE (example_b.contains_point (5, 8));\n+\n+  /* On the final line, after the end.  */\n+  ASSERT_FALSE (example_b.contains_point (5, 9));\n+\n+  /* After the line.  */\n+  ASSERT_FALSE (example_b.contains_point (6, 1));\n+}\n+\n+#endif /* #if CHECKING_P */\n+\n /* Given a source line LINE of length LINE_WIDTH, determine the width\n    without any trailing whitespace.  */\n \n@@ -465,6 +583,34 @@ get_line_width_without_trailing_whitespace (const char *line, int line_width)\n   return result;\n }\n \n+#if CHECKING_P\n+\n+/* A helper function for testing get_line_width_without_trailing_whitespace.  */\n+\n+static void\n+assert_eq (const char *line, int expected_width)\n+{\n+  int actual_value\n+    = get_line_width_without_trailing_whitespace (line, strlen (line));\n+  ASSERT_EQ (actual_value, expected_width);\n+}\n+\n+/* Verify that get_line_width_without_trailing_whitespace is sane for\n+   various inputs.  It is not required to handle newlines.  */\n+\n+static void\n+test_get_line_width_without_trailing_whitespace ()\n+{\n+  assert_eq (\"\", 0);\n+  assert_eq (\" \", 0);\n+  assert_eq (\"\\t\", 0);\n+  assert_eq (\"hello world\", 11);\n+  assert_eq (\"hello world     \", 11);\n+  assert_eq (\"hello world     \\t\\t  \", 11);\n+}\n+\n+#endif /* #if CHECKING_P */\n+\n /* Helper function for layout's ctor, for sanitizing locations relative\n    to the primary location within a diagnostic.\n \n@@ -1171,3 +1317,23 @@ diagnostic_show_locus (diagnostic_context * context,\n \n   pp_set_prefix (context->printer, saved_prefix);\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+diagnostic_show_locus_c_tests ()\n+{\n+  test_range_contains_point_for_single_point ();\n+  test_range_contains_point_for_single_line ();\n+  test_range_contains_point_for_multiple_lines ();\n+\n+  test_get_line_width_without_trailing_whitespace ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "766a1a3f35b239bfa373da2d736b9732d0223e45", "filename": "gcc/et-forest.c", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -27,6 +27,7 @@ License along with libiberty; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"alloc-pool.h\"\n #include \"et-forest.h\"\n+#include \"selftest.h\"\n \n /* We do not enable this with CHECKING_P, since it is awfully slow.  */\n #undef DEBUG_ET\n@@ -764,3 +765,120 @@ et_root (struct et_node *node)\n \n   return r->of;\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for et-forest.c.  */\n+\n+/* Perform sanity checks for a tree consisting of a single node.  */\n+\n+static void\n+test_single_node ()\n+{\n+  void *test_data = (void *)0xcafebabe;\n+\n+  et_node *n = et_new_tree (test_data);\n+  ASSERT_EQ (n->data, test_data);\n+  ASSERT_EQ (n, et_root (n));\n+  et_free_tree (n);\n+}\n+\n+/* Test of this tree:\n+       a\n+      / \\\n+     /   \\\n+    b     c\n+   / \\    |\n+  d   e   f.  */\n+\n+static void\n+test_simple_tree ()\n+{\n+  et_node *a = et_new_tree (NULL);\n+  et_node *b = et_new_tree (NULL);\n+  et_node *c = et_new_tree (NULL);\n+  et_node *d = et_new_tree (NULL);\n+  et_node *e = et_new_tree (NULL);\n+  et_node *f = et_new_tree (NULL);\n+\n+  et_set_father (b, a);\n+  et_set_father (c, a);\n+  et_set_father (d, b);\n+  et_set_father (e, b);\n+  et_set_father (f, c);\n+\n+  ASSERT_TRUE (et_below (a, a));\n+  ASSERT_TRUE (et_below (b, a));\n+  ASSERT_TRUE (et_below (c, a));\n+  ASSERT_TRUE (et_below (d, a));\n+  ASSERT_TRUE (et_below (e, a));\n+  ASSERT_TRUE (et_below (f, a));\n+\n+  ASSERT_FALSE (et_below (a, b));\n+  ASSERT_TRUE (et_below (b, b));\n+  ASSERT_FALSE (et_below (c, b));\n+  ASSERT_TRUE (et_below (d, b));\n+  ASSERT_TRUE (et_below (e, b));\n+  ASSERT_FALSE (et_below (f, b));\n+\n+  ASSERT_FALSE (et_below (a, c));\n+  ASSERT_FALSE (et_below (b, c));\n+  ASSERT_TRUE (et_below (c, c));\n+  ASSERT_FALSE (et_below (d, c));\n+  ASSERT_FALSE (et_below (e, c));\n+  ASSERT_TRUE (et_below (f, c));\n+\n+  ASSERT_FALSE (et_below (a, d));\n+  ASSERT_FALSE (et_below (b, d));\n+  ASSERT_FALSE (et_below (c, d));\n+  ASSERT_TRUE (et_below (d, d));\n+  ASSERT_FALSE (et_below (e, d));\n+  ASSERT_FALSE (et_below (f, d));\n+\n+  ASSERT_FALSE (et_below (a, e));\n+  ASSERT_FALSE (et_below (b, e));\n+  ASSERT_FALSE (et_below (c, e));\n+  ASSERT_FALSE (et_below (d, e));\n+  ASSERT_TRUE (et_below (e, e));\n+  ASSERT_FALSE (et_below (f, e));\n+\n+  ASSERT_FALSE (et_below (a, f));\n+  ASSERT_FALSE (et_below (b, f));\n+  ASSERT_FALSE (et_below (c, f));\n+  ASSERT_FALSE (et_below (d, f));\n+  ASSERT_FALSE (et_below (e, f));\n+  ASSERT_TRUE (et_below (f, f));\n+\n+  et_free_tree_force (a);\n+}\n+\n+/* Verify that two disconnected nodes are unrelated.  */\n+\n+static void\n+test_disconnected_nodes ()\n+{\n+  et_node *a = et_new_tree (NULL);\n+  et_node *b = et_new_tree (NULL);\n+\n+  ASSERT_FALSE (et_below (a, b));\n+  ASSERT_FALSE (et_below (b, a));\n+\n+  et_free_tree (a);\n+  et_free_tree (b);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+et_forest_c_tests ()\n+{\n+  test_single_node ();\n+  test_simple_tree ();\n+  test_disconnected_nodes ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "0efa9d5b0b1dd338a324c5a75ddc5b7a8545a013", "filename": "gcc/fold-const.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -76,6 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"case-cfn-macros.h\"\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n+#include \"selftest.h\"\n \n #ifndef LOAD_EXTEND_OP\n #define LOAD_EXTEND_OP(M) UNKNOWN\n@@ -14496,3 +14497,82 @@ c_getstr (tree src)\n \n   return TREE_STRING_POINTER (src) + tree_to_uhwi (offset_node);\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Helper functions for writing tests of folding trees.  */\n+\n+/* Verify that the binary op (LHS CODE RHS) folds to CONSTANT.  */\n+\n+static void\n+assert_binop_folds_to_const (tree lhs, enum tree_code code, tree rhs,\n+\t\t\t     tree constant)\n+{\n+  ASSERT_EQ (constant, fold_build2 (code, TREE_TYPE (lhs), lhs, rhs));\n+}\n+\n+/* Verify that the binary op (LHS CODE RHS) folds to an NON_LVALUE_EXPR\n+   wrapping WRAPPED_EXPR.  */\n+\n+static void\n+assert_binop_folds_to_nonlvalue (tree lhs, enum tree_code code, tree rhs,\n+\t\t\t\t tree wrapped_expr)\n+{\n+  tree result = fold_build2 (code, TREE_TYPE (lhs), lhs, rhs);\n+  ASSERT_NE (wrapped_expr, result);\n+  ASSERT_EQ (NON_LVALUE_EXPR, TREE_CODE (result));\n+  ASSERT_EQ (wrapped_expr, TREE_OPERAND (result, 0));\n+}\n+\n+/* Verify that various arithmetic binary operations are folded\n+   correctly.  */\n+\n+static void\n+test_arithmetic_folding ()\n+{\n+  tree type = integer_type_node;\n+  tree x = create_tmp_var_raw (type, \"x\");\n+  tree zero = build_zero_cst (type);\n+  tree one = build_int_cst (type, 1);\n+\n+  /* Addition.  */\n+  /* 1 <-- (0 + 1) */\n+  assert_binop_folds_to_const (zero, PLUS_EXPR, one,\n+\t\t\t       one);\n+  assert_binop_folds_to_const (one, PLUS_EXPR, zero,\n+\t\t\t       one);\n+\n+  /* (nonlvalue)x <-- (x + 0) */\n+  assert_binop_folds_to_nonlvalue (x, PLUS_EXPR, zero,\n+\t\t\t\t   x);\n+\n+  /* Subtraction.  */\n+  /* 0 <-- (x - x) */\n+  assert_binop_folds_to_const (x, MINUS_EXPR, x,\n+\t\t\t       zero);\n+  assert_binop_folds_to_nonlvalue (x, MINUS_EXPR, zero,\n+\t\t\t\t   x);\n+\n+  /* Multiplication.  */\n+  /* 0 <-- (x * 0) */\n+  assert_binop_folds_to_const (x, MULT_EXPR, zero,\n+\t\t\t       zero);\n+\n+  /* (nonlvalue)x <-- (x * 1) */\n+  assert_binop_folds_to_nonlvalue (x, MULT_EXPR, one,\n+\t\t\t\t   x);\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+fold_const_c_tests ()\n+{\n+  test_arithmetic_folding ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "c8188e769fa03ae6ee4bade3bc08364819b9e907", "filename": "gcc/function-tests.c", "status": "added", "additions": 658, "deletions": 0, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ffunction-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ffunction-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction-tests.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,658 @@\n+/* Unit tests for function-handling.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"opts.h\"\n+#include \"signop.h\"\n+#include \"hash-set.h\"\n+#include \"fixed-value.h\"\n+#include \"alias.h\"\n+#include \"flags.h\"\n+#include \"symtab.h\"\n+#include \"tree-core.h\"\n+#include \"stor-layout.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"rtl.h\"\n+#include \"predict.h\"\n+#include \"vec.h\"\n+#include \"hashtab.h\"\n+#include \"hash-set.h\"\n+#include \"machmode.h\"\n+#include \"hard-reg-set.h\"\n+#include \"input.h\"\n+#include \"function.h\"\n+#include \"dominance.h\"\n+#include \"cfg.h\"\n+#include \"cfganal.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimple-expr.h\"\n+#include \"toplev.h\"\n+#include \"print-tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimplify.h\"\n+#include \"tree-cfg.h\"\n+#include \"basic-block.h\"\n+#include \"double-int.h\"\n+#include \"alias.h\"\n+#include \"symtab.h\"\n+#include \"wide-int.h\"\n+#include \"inchash.h\"\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"stor-layout.h\"\n+#include \"stmt.h\"\n+#include \"hash-table.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"context.h\"\n+#include \"hash-map.h\"\n+#include \"plugin-api.h\"\n+#include \"ipa-ref.h\"\n+#include \"cgraph.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Helper function for selftests of function-creation.  */\n+\n+static tree\n+make_fndecl (tree return_type,\n+\t     const char *name,\n+\t     vec <tree> &param_types,\n+\t     bool is_variadic = false)\n+{\n+  tree fn_type;\n+  if (is_variadic)\n+    fn_type = build_varargs_function_type_array (return_type,\n+\t\t\t\t\t\t param_types.length (),\n+\t\t\t\t\t\t param_types.address ());\n+  else\n+    fn_type = build_function_type_array (return_type,\n+\t\t\t\t\t param_types.length (),\n+\t\t\t\t\t param_types.address ());\n+  /* FIXME: this uses input_location: */\n+  tree fndecl = build_fn_decl (name, fn_type);\n+\n+  return fndecl;\n+}\n+\n+/* Verify creating a function declaration equivalent to the following\n+     int test_fndecl_int_void (void);\n+   C declaration.  */\n+\n+static void\n+test_fndecl_int_void ()\n+{\n+  auto_vec <tree> param_types;\n+  const char *name = \"test_fndecl_int_void\";\n+  tree fndecl = make_fndecl (integer_type_node,\n+\t\t\t     name,\n+\t\t\t     param_types);\n+  ASSERT_TRUE (fndecl != NULL);\n+\n+  /* Verify name of decl.  */\n+  tree declname = DECL_NAME (fndecl);\n+  ASSERT_TRUE (declname != NULL);\n+  ASSERT_EQ (IDENTIFIER_NODE, TREE_CODE (declname));\n+  /* We expect it to use a *copy* of the string we passed in.  */\n+  const char *identifier_ptr = IDENTIFIER_POINTER (declname);\n+  ASSERT_NE (name, identifier_ptr);\n+  ASSERT_EQ (0, strcmp (\"test_fndecl_int_void\", identifier_ptr));\n+\n+  /* Verify type of fndecl.  */\n+  ASSERT_EQ (FUNCTION_DECL, TREE_CODE (fndecl));\n+  tree fntype = TREE_TYPE (fndecl);\n+  ASSERT_EQ (FUNCTION_TYPE, TREE_CODE (fntype));\n+\n+  /* Verify return type.  */\n+  ASSERT_EQ (integer_type_node, TREE_TYPE (fntype));\n+\n+  /* Verify \"void\" args.  */\n+  tree argtypes = TYPE_ARG_TYPES (fntype);\n+  ASSERT_EQ (TREE_LIST, TREE_CODE (argtypes));\n+  ASSERT_EQ (void_type_node, TREE_VALUE (argtypes));\n+  ASSERT_EQ (NULL, TREE_CHAIN (argtypes));\n+}\n+\n+/* Verify creating a function declaration equivalent to the following\n+     float test_fndecl_float_intchar (int, char);\n+   C declaration.  */\n+\n+static void\n+test_fndecl_float_intchar ()\n+{\n+  auto_vec <tree> param_types;\n+  param_types.safe_push (integer_type_node);\n+  param_types.safe_push (char_type_node);\n+  const char *name = \"test_fndecl_float_intchar\";\n+  tree fndecl = make_fndecl (float_type_node,\n+\t\t\t     name,\n+\t\t\t     param_types);\n+  ASSERT_TRUE (fndecl != NULL);\n+\n+  /* Verify name of decl.  */\n+  tree declname = DECL_NAME (fndecl);\n+  ASSERT_TRUE (declname != NULL);\n+  ASSERT_EQ (IDENTIFIER_NODE, TREE_CODE (declname));\n+  /* We expect it to use a *copy* of the string we passed in.  */\n+  const char *identifier_ptr = IDENTIFIER_POINTER (declname);\n+  ASSERT_NE (name, identifier_ptr);\n+  ASSERT_EQ (0, strcmp (name, identifier_ptr));\n+\n+  /* Verify type of fndecl.  */\n+  ASSERT_EQ (FUNCTION_DECL, TREE_CODE (fndecl));\n+  tree fntype = TREE_TYPE (fndecl);\n+  ASSERT_EQ (FUNCTION_TYPE, TREE_CODE (fntype));\n+\n+  /* Verify return type.  */\n+  ASSERT_EQ (float_type_node, TREE_TYPE (fntype));\n+\n+  /* Verify \"(int, char)\" args.  */\n+  tree arg0 = TYPE_ARG_TYPES (fntype);\n+  ASSERT_EQ (TREE_LIST, TREE_CODE (arg0));\n+  ASSERT_EQ (integer_type_node, TREE_VALUE (arg0));\n+  tree arg1 = TREE_CHAIN (arg0);\n+  ASSERT_TRUE (arg1 != NULL);\n+  ASSERT_EQ (TREE_LIST, TREE_CODE (arg1));\n+  ASSERT_EQ (char_type_node, TREE_VALUE (arg1));\n+  tree argterm = TREE_CHAIN (arg1);\n+  ASSERT_TRUE (argterm != NULL);\n+  ASSERT_EQ (TREE_LIST, TREE_CODE (argterm));\n+  ASSERT_EQ (void_type_node, TREE_VALUE (argterm));\n+  ASSERT_EQ (NULL, TREE_CHAIN (argterm));\n+}\n+\n+/* The test cases using these helper functions take a trivial function:\n+\n+     int test_fn (void) { return 42; }\n+\n+   and test various conversions done to it:\n+\n+   - gimplification\n+   - construction of the CFG\n+   - conversion to SSA form\n+   - expansion to RTL form\n+\n+   In avoid having one overlong test case, this is broken\n+   up into separate test cases for each stage, with helper functions\n+   to minimize code duplication.\n+\n+   Another approach would be to attempt to directly construct a function\n+   in the appropriate representation at each stage, though presumably\n+   that would exhibit different kinds of failure compared to this\n+   approach.  */\n+\n+/* Construct this function:\n+   int test_fn (void) { return 42; }\n+   in generic tree form.  Return the fndecl.  */\n+\n+static tree\n+build_trivial_generic_function ()\n+{\n+  auto_vec <tree> param_types;\n+  tree fndecl = make_fndecl (integer_type_node,\n+\t\t\t     \"test_fn\",\n+\t\t\t     param_types);\n+  ASSERT_TRUE (fndecl != NULL);\n+\n+  /* Populate the function.  */\n+  tree retval = build_decl (UNKNOWN_LOCATION, RESULT_DECL,\n+\t\t\t    NULL_TREE, integer_type_node);\n+  DECL_ARTIFICIAL (retval) = 1;\n+  DECL_IGNORED_P (retval) = 1;\n+  DECL_RESULT (fndecl) = retval;\n+\n+  /* Create a BIND_EXPR, and within it, a statement list.  */\n+  tree stmt_list = alloc_stmt_list ();\n+  tree_stmt_iterator stmt_iter = tsi_start (stmt_list);\n+  tree block = make_node (BLOCK);\n+  tree bind_expr\n+    = build3 (BIND_EXPR, void_type_node, NULL, stmt_list, block);\n+\n+  tree modify_retval = build2 (MODIFY_EXPR,\n+\t\t\t       integer_type_node,\n+\t\t\t       retval,\n+\t\t\t       build_int_cst (integer_type_node, 42));\n+  tree return_stmt = build1 (RETURN_EXPR,\n+\t\t\t     integer_type_node,\n+\t\t\t     modify_retval);\n+  tsi_link_after (&stmt_iter, return_stmt, TSI_CONTINUE_LINKING);\n+\n+  DECL_INITIAL (fndecl) = block;\n+\n+  /* how to add to function? the following appears to be how to\n+     set the body of a fndecl: */\n+  DECL_SAVED_TREE(fndecl) = bind_expr;\n+\n+  /* Ensure that locals appear in the debuginfo.  */\n+  BLOCK_VARS (block) = BIND_EXPR_VARS (bind_expr);\n+\n+  return fndecl;\n+}\n+\n+/* Construct this function:\n+     int test_fn (void) { return 42; }\n+   in \"high gimple\" form.  Return the fndecl.  */\n+\n+static tree\n+build_trivial_high_gimple_function ()\n+{\n+  /* Construct a trivial function, and gimplify it: */\n+  tree fndecl = build_trivial_generic_function ();\n+  gimplify_function_tree (fndecl);\n+  return fndecl;\n+}\n+\n+/* Build a CFG for a function in gimple form.  */\n+\n+static void\n+build_cfg (tree fndecl)\n+{\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+  ASSERT_EQ (fndecl, fun->decl);\n+\n+  /* We first have to lower control flow; for our trivial test function\n+     this gives us:\n+\t test_fn ()\n+\t {\n+\t   D.56 = 42;\n+\t   goto <D.57>;\n+\t   <D.57>:\n+\t   return D.56;\n+\t }\n+  */\n+  gimple_opt_pass *lower_cf_pass = make_pass_lower_cf (g);\n+  push_cfun (fun);\n+  lower_cf_pass->execute (fun);\n+  pop_cfun ();\n+\n+  /* We can now convert to CFG form; for our trivial test function this\n+     gives us:\n+\t test_fn ()\n+\t {\n+\t   <bb 2>:\n+\t   D.56 = 42;\n+\t   return D.56;\n+\t }\n+  */\n+  gimple_opt_pass *build_cfg_pass = make_pass_build_cfg (g);\n+  push_cfun (fun);\n+  build_cfg_pass->execute (fun);\n+  pop_cfun ();\n+}\n+\n+/* Convert a gimple+CFG function to SSA form.  */\n+\n+static void\n+convert_to_ssa (tree fndecl)\n+{\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+  ASSERT_EQ (fndecl, fun->decl);\n+\n+  gimple_opt_pass *build_ssa_pass = make_pass_build_ssa (g);\n+  push_cfun (fun);\n+  build_ssa_pass->execute (fun);\n+  pop_cfun ();\n+}\n+\n+/* Assuming we have a simple 3-block CFG like this:\n+     [ENTRY] -> [block2] -> [EXIT]\n+   get the \"real\" basic block (block 2).  */\n+\n+static basic_block\n+get_real_block (function *fun)\n+{\n+  ASSERT_TRUE (fun->cfg != NULL);\n+  ASSERT_EQ (3, n_basic_blocks_for_fn (fun));\n+  basic_block bb2 = (*fun->cfg->x_basic_block_info)[2];\n+  ASSERT_TRUE (bb2 != NULL);\n+  return bb2;\n+}\n+\n+/* Verify that we have a simple 3-block CFG: the two \"fake\" ones, and\n+   a \"real\" one:\n+     [ENTRY] -> [block2] -> [EXIT].  */\n+\n+static void\n+verify_three_block_cfg (function *fun)\n+{\n+  ASSERT_TRUE (fun->cfg != NULL);\n+  ASSERT_EQ (3, n_basic_blocks_for_fn (fun));\n+  ASSERT_EQ (2, n_edges_for_fn (fun));\n+\n+  /* The \"fake\" basic blocks.  */\n+  basic_block entry = ENTRY_BLOCK_PTR_FOR_FN (fun);\n+  ASSERT_TRUE (entry != NULL);\n+  ASSERT_EQ (ENTRY_BLOCK, entry->index);\n+\n+  basic_block exit = EXIT_BLOCK_PTR_FOR_FN (fun);\n+  ASSERT_TRUE (exit != NULL);\n+  ASSERT_EQ (EXIT_BLOCK, exit->index);\n+\n+  /* The \"real\" basic block.  */\n+  basic_block bb2 = get_real_block (fun);\n+  ASSERT_TRUE (bb2 != NULL);\n+  ASSERT_EQ (2, bb2->index);\n+\n+  /* Verify connectivity.  */\n+  ASSERT_EQ (NULL, entry->preds);\n+  ASSERT_EQ (1, entry->succs->length ());\n+\n+  edge from_entry_to_bb2 = (*entry->succs)[0];\n+  ASSERT_EQ (entry, from_entry_to_bb2->src);\n+  ASSERT_EQ (bb2, from_entry_to_bb2->dest);\n+\n+  ASSERT_EQ (1, bb2->preds->length ());\n+  ASSERT_EQ (from_entry_to_bb2, (*bb2->preds)[0]);\n+  ASSERT_EQ (1, bb2->succs->length ());\n+\n+  edge from_bb2_to_exit = (*bb2->succs)[0];\n+  ASSERT_EQ (bb2, from_bb2_to_exit->src);\n+  ASSERT_EQ (exit, from_bb2_to_exit->dest);\n+\n+  ASSERT_EQ (1, exit->preds->length ());\n+  ASSERT_EQ (from_bb2_to_exit, (*exit->preds)[0]);\n+  ASSERT_EQ (NULL, exit->succs);\n+}\n+\n+/* As above, but additionally verify the gimple statements are sane.  */\n+\n+static void\n+verify_three_block_gimple_cfg (function *fun)\n+{\n+  verify_three_block_cfg (fun);\n+\n+  /* The \"fake\" basic blocks should be flagged as gimple, but with have no\n+     statements.  */\n+  basic_block entry = ENTRY_BLOCK_PTR_FOR_FN (fun);\n+  ASSERT_TRUE (entry != NULL);\n+  ASSERT_EQ (0, entry->flags & BB_RTL);\n+  ASSERT_EQ (NULL, bb_seq (entry));\n+\n+  basic_block exit = EXIT_BLOCK_PTR_FOR_FN (fun);\n+  ASSERT_TRUE (exit != NULL);\n+  ASSERT_EQ (0, entry->flags & BB_RTL);\n+  ASSERT_EQ (NULL, bb_seq (exit));\n+\n+  /* The \"real\" basic block should be flagged as gimple, and have one\n+     or more statements.  */\n+  basic_block bb2 = get_real_block (fun);\n+  ASSERT_TRUE (bb2 != NULL);\n+  ASSERT_EQ (0, entry->flags & BB_RTL);\n+  ASSERT_TRUE (bb_seq (bb2) != NULL);\n+}\n+\n+/* As above, but additionally verify the RTL insns are sane.  */\n+\n+static void\n+verify_three_block_rtl_cfg (function *fun)\n+{\n+  verify_three_block_cfg (fun);\n+\n+  /* The \"fake\" basic blocks should be flagged as RTL, but with no\n+     insns.  */\n+  basic_block entry = ENTRY_BLOCK_PTR_FOR_FN (fun);\n+  ASSERT_TRUE (entry != NULL);\n+  ASSERT_EQ (BB_RTL, entry->flags & BB_RTL);\n+  ASSERT_EQ (NULL, BB_HEAD (entry));\n+\n+  basic_block exit = EXIT_BLOCK_PTR_FOR_FN (fun);\n+  ASSERT_TRUE (exit != NULL);\n+  ASSERT_EQ (BB_RTL, entry->flags & BB_RTL);\n+  ASSERT_EQ (NULL, BB_HEAD (exit));\n+\n+  /* The \"real\" basic block should be flagged as RTL, and have one\n+     or more insns.  */\n+  basic_block bb2 = get_real_block (fun);\n+  ASSERT_TRUE (bb2 != NULL);\n+  ASSERT_EQ (BB_RTL, entry->flags & BB_RTL);\n+  ASSERT_TRUE (BB_HEAD (bb2) != NULL);\n+}\n+\n+/* Test converting our trivial function:\n+     int test_fn (void) { return 42; }\n+   to gimple form.  */\n+\n+static void\n+test_gimplification ()\n+{\n+  tree fndecl = build_trivial_generic_function ();\n+\n+  /* Convert to gimple: */\n+  gimplify_function_tree (fndecl);\n+\n+  /* Verify that we got gimple out of it.  */\n+\n+  /* The function is now in GIMPLE form but the CFG has not been\n+     built yet.  */\n+\n+  /* We should have a struct function for the decl.  */\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+  ASSERT_EQ (fndecl, fun->decl);\n+\n+  /* We expect a GIMPLE_BIND, with two gimple statements within it:\n+       tmp = 42;\n+       return tmp;  */\n+\n+  gimple_seq seq_fn_body = gimple_body (fndecl);\n+  ASSERT_TRUE (seq_fn_body != NULL);\n+  gimple *bind_stmt = gimple_seq_first_stmt (seq_fn_body);\n+  ASSERT_EQ (GIMPLE_BIND, gimple_code (bind_stmt));\n+  ASSERT_EQ (NULL, bind_stmt->next);\n+\n+  gimple_seq seq_bind_body = gimple_bind_body (as_a <gbind *> (bind_stmt));\n+\n+  /* Verify that we have the 2 statements we expect.  */\n+  ASSERT_TRUE (seq_bind_body != NULL);\n+  gimple *stmt1 = gimple_seq_first_stmt (seq_bind_body);\n+  ASSERT_TRUE (stmt1 != NULL);\n+  ASSERT_EQ (GIMPLE_ASSIGN, gimple_code (stmt1));\n+  gimple *stmt2 = stmt1->next;\n+  ASSERT_TRUE (stmt2 != NULL);\n+  ASSERT_EQ (stmt1, stmt2->prev);\n+  ASSERT_EQ (GIMPLE_RETURN, gimple_code (stmt2));\n+}\n+\n+/* Test of building a CFG for a function in high gimple form.  */\n+\n+static void\n+test_building_cfg ()\n+{\n+  /* Construct a trivial function, and gimplify it: */\n+  tree fndecl = build_trivial_high_gimple_function ();\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+\n+  /* Build a CFG.  */\n+  build_cfg (fndecl);\n+\n+  /* The CFG-building code constructs a 4-block cfg (with\n+     ENTRY and EXIT):\n+       test_fn ()\n+       {\n+         <bb 2>:\n+\t D.65 = 42;\n+\n+\t <bb 3>:\n+\t return D.65;\n+       }\n+     and then ought to merge blocks 2 and 3 in cleanup_tree_cfg.\n+\n+     Hence we should end up with a simple 3-block cfg, the two \"fake\" ones,\n+     and a \"real\" one:\n+       [ENTRY] -> [block2] -> [EXIT]\n+     with code like this:\n+\t test_fn ()\n+\t {\n+\t   <bb 2>:\n+\t   D.56 = 42;\n+\t   return D.56;\n+\t }\n+  */\n+  verify_three_block_gimple_cfg (fun);\n+\n+  /* Verify the statements within the \"real\" block.  */\n+  basic_block bb2 = get_real_block (fun);\n+  gimple *stmt_a = gimple_seq_first_stmt (bb_seq (bb2));\n+  ASSERT_EQ (GIMPLE_ASSIGN, gimple_code (stmt_a));\n+  gimple *stmt_b = stmt_a->next;\n+  ASSERT_EQ (GIMPLE_RETURN, gimple_code (stmt_b));\n+  ASSERT_EQ (NULL, stmt_b->next);\n+}\n+\n+/* Test of conversion of gimple to SSA form.  */\n+\n+static void\n+test_conversion_to_ssa ()\n+{\n+  /* As above, construct a trivial function, gimplify it, and build a CFG: */\n+  tree fndecl = build_trivial_high_gimple_function ();\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+  build_cfg (fndecl);\n+\n+  convert_to_ssa (fndecl);\n+\n+  verify_three_block_gimple_cfg (fun);\n+\n+  /* For out trivial test function we should now have something like\n+     this:\n+       test_fn ()\n+       {\n+\t <bb 2>:\n+\t _1 = 42;\n+\t return _1;\n+       }\n+  */\n+  basic_block bb2 = get_real_block (fun);\n+  gimple *stmt_a = gimple_seq_first_stmt (bb_seq (bb2));\n+  ASSERT_EQ (GIMPLE_ASSIGN, gimple_code (stmt_a));\n+\n+  gimple *stmt_b = stmt_a->next;\n+  ASSERT_EQ (GIMPLE_RETURN, gimple_code (stmt_b));\n+  ASSERT_EQ (NULL, stmt_b->next);\n+\n+  greturn *return_stmt = as_a <greturn *> (stmt_b);\n+  ASSERT_EQ (SSA_NAME, TREE_CODE (gimple_return_retval (return_stmt)));\n+}\n+\n+/* Test of expansion from gimple-ssa to RTL.  */\n+\n+static void\n+test_expansion_to_rtl ()\n+{\n+  /* As above, construct a trivial function, gimplify it, build a CFG,\n+     and convert to SSA: */\n+  tree fndecl = build_trivial_high_gimple_function ();\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+  build_cfg (fndecl);\n+  convert_to_ssa (fndecl);\n+\n+  /* We need a cgraph_node for it.  */\n+  cgraph_node::get_create (fndecl);\n+  /* Normally, cgraph_node::expand () would call\n+     init_function_start (and a bunch of other stuff),\n+     and invoke the expand pass, but it also runs\n+     all of the other passes.  So just do the minimum\n+     needed to get from gimple-SSA to RTL.  */\n+  rtl_opt_pass *expand_pass = make_pass_expand (g);\n+  push_cfun (fun);\n+  init_function_start (fndecl);\n+  expand_pass->execute (fun);\n+  pop_cfun ();\n+\n+  /* On x86_64, I get this:\n+       (note 3 1 2 2 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+       (note 2 3 5 2 NOTE_INSN_FUNCTION_BEG)\n+       (insn 5 2 6 2 (set (reg:SI 87 [ D.59 ])\n+\t\t\t  (const_int 42 [0x2a])) -1 (nil))\n+       (insn 6 5 10 2 (set (reg:SI 88 [ <retval> ])\n+\t\t\t   (reg:SI 87 [ D.59 ])) -1 (nil))\n+       (insn 10 6 11 2 (set (reg/i:SI 0 ax)\n+\t\t\t    (reg:SI 88 [ <retval> ])) -1 (nil))\n+       (insn 11 10 0 2 (use (reg/i:SI 0 ax)) -1 (nil))\n+\n+     On cr16-elf I get this:\n+       (note 4 1 2 2 [bb 2] NOTE_INSN_BASIC_BLOCK)\n+       (insn 2 4 3 2 (set (reg:SI 24)\n+\t    (reg/f:SI 16 virtual-incoming-args)) -1\n+\t  (nil))\n+       (note 3 2 6 2 NOTE_INSN_FUNCTION_BEG)\n+       (insn 6 3 7 2 (set (reg:HI 22 [ _1 ])\n+\t    (const_int 42 [0x2a])) -1\n+\t (nil))\n+       (insn 7 6 11 2 (set (reg:HI 23 [ <retval> ])\n+\t   (reg:HI 22 [ _1 ])) -1\n+\t (nil))\n+       (insn 11 7 12 2 (set (reg/i:HI 0 r0)\n+\t   (reg:HI 23 [ <retval> ])) -1\n+\t (nil))\n+       (insn 12 11 0 2 (use (reg/i:HI 0 r0)) -1\n+\t (nil)).  */\n+  verify_three_block_rtl_cfg (fun);\n+\n+  /* Verify as much of the RTL as we can whilst avoiding\n+     target-specific behavior.  */\n+  basic_block bb2 = get_real_block (fun);\n+\n+  /* Expect a NOTE_INSN_BASIC_BLOCK... */\n+  rtx_insn *insn = BB_HEAD (bb2);\n+  ASSERT_TRUE (insn != NULL);\n+  ASSERT_EQ (NOTE, insn->code);\n+  ASSERT_EQ (NOTE_INSN_BASIC_BLOCK, NOTE_KIND (insn));\n+  ASSERT_EQ (bb2, NOTE_BASIC_BLOCK (insn));\n+\n+  /* ...etc; any further checks are likely to over-specify things\n+     and run us into target dependencies.  */\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+function_tests_c_tests ()\n+{\n+  test_fndecl_int_void ();\n+  test_fndecl_float_intchar ();\n+  test_gimplification ();\n+  test_building_cfg ();\n+  test_conversion_to_ssa ();\n+  test_expansion_to_rtl ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "178c1d3a517d586358e374b1348468091cb707e5", "filename": "gcc/gimple.c", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-walk.h\"\n #include \"gimplify.h\"\n #include \"target.h\"\n+#include \"selftest.h\"\n+#include \"gimple-pretty-print.h\"\n \n \n /* All the tuples have their operand vector (if present) at the very bottom\n@@ -3022,3 +3024,138 @@ maybe_remove_unused_call_args (struct function *fn, gimple *stmt)\n       update_stmt_fn (fn, stmt);\n     }\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for core gimple structures.  */\n+\n+/* Verify that STMT is pretty-printed as EXPECTED.\n+   Helper function for selftests.  */\n+\n+static void\n+verify_gimple_pp (const char *expected, gimple *stmt)\n+{\n+  pretty_printer pp;\n+  pp_gimple_stmt_1 (&pp, stmt, 0 /* spc */, 0 /* flags */);\n+  ASSERT_STREQ (expected, pp_formatted_text (&pp));\n+}\n+\n+/* Build a GIMPLE_ASSIGN equivalent to\n+     tmp = 5;\n+   and verify various properties of it.  */\n+\n+static void\n+test_assign_single ()\n+{\n+  tree type = integer_type_node;\n+  tree lhs = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t get_identifier (\"tmp\"),\n+\t\t\t type);\n+  tree rhs = build_int_cst (type, 5);\n+  gassign *stmt = gimple_build_assign (lhs, rhs);\n+  verify_gimple_pp (\"tmp = 5;\", stmt);\n+\n+  ASSERT_TRUE (is_gimple_assign (stmt));\n+  ASSERT_EQ (lhs, gimple_assign_lhs (stmt));\n+  ASSERT_EQ (lhs, gimple_get_lhs (stmt));\n+  ASSERT_EQ (rhs, gimple_assign_rhs1 (stmt));\n+  ASSERT_EQ (NULL, gimple_assign_rhs2 (stmt));\n+  ASSERT_EQ (NULL, gimple_assign_rhs3 (stmt));\n+  ASSERT_TRUE (gimple_assign_single_p (stmt));\n+  ASSERT_EQ (INTEGER_CST, gimple_assign_rhs_code (stmt));\n+}\n+\n+/* Build a GIMPLE_ASSIGN equivalent to\n+     tmp = a * b;\n+   and verify various properties of it.  */\n+\n+static void\n+test_assign_binop ()\n+{\n+  tree type = integer_type_node;\n+  tree lhs = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t get_identifier (\"tmp\"),\n+\t\t\t type);\n+  tree a = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t       get_identifier (\"a\"),\n+\t\t       type);\n+  tree b = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n+\t\t       get_identifier (\"b\"),\n+\t\t       type);\n+  gassign *stmt = gimple_build_assign (lhs, MULT_EXPR, a, b);\n+  verify_gimple_pp (\"tmp = a * b;\", stmt);\n+\n+  ASSERT_TRUE (is_gimple_assign (stmt));\n+  ASSERT_EQ (lhs, gimple_assign_lhs (stmt));\n+  ASSERT_EQ (lhs, gimple_get_lhs (stmt));\n+  ASSERT_EQ (a, gimple_assign_rhs1 (stmt));\n+  ASSERT_EQ (b, gimple_assign_rhs2 (stmt));\n+  ASSERT_EQ (NULL, gimple_assign_rhs3 (stmt));\n+  ASSERT_FALSE (gimple_assign_single_p (stmt));\n+  ASSERT_EQ (MULT_EXPR, gimple_assign_rhs_code (stmt));\n+}\n+\n+/* Build a GIMPLE_NOP and verify various properties of it.  */\n+\n+static void\n+test_nop_stmt ()\n+{\n+  gimple *stmt = gimple_build_nop ();\n+  verify_gimple_pp (\"GIMPLE_NOP\", stmt);\n+  ASSERT_EQ (GIMPLE_NOP, gimple_code (stmt));\n+  ASSERT_EQ (NULL, gimple_get_lhs (stmt));\n+  ASSERT_FALSE (gimple_assign_single_p (stmt));\n+}\n+\n+/* Build a GIMPLE_RETURN equivalent to\n+     return 7;\n+   and verify various properties of it.  */\n+\n+static void\n+test_return_stmt ()\n+{\n+  tree type = integer_type_node;\n+  tree val = build_int_cst (type, 7);\n+  greturn *stmt = gimple_build_return (val);\n+  verify_gimple_pp (\"return 7;\", stmt);\n+\n+  ASSERT_EQ (GIMPLE_RETURN, gimple_code (stmt));\n+  ASSERT_EQ (NULL, gimple_get_lhs (stmt));\n+  ASSERT_EQ (val, gimple_return_retval (stmt));\n+  ASSERT_FALSE (gimple_assign_single_p (stmt));\n+}\n+\n+/* Build a GIMPLE_RETURN equivalent to\n+     return;\n+   and verify various properties of it.  */\n+\n+static void\n+test_return_without_value ()\n+{\n+  greturn *stmt = gimple_build_return (NULL);\n+  verify_gimple_pp (\"return;\", stmt);\n+\n+  ASSERT_EQ (GIMPLE_RETURN, gimple_code (stmt));\n+  ASSERT_EQ (NULL, gimple_get_lhs (stmt));\n+  ASSERT_EQ (NULL, gimple_return_retval (stmt));\n+  ASSERT_FALSE (gimple_assign_single_p (stmt));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+gimple_c_tests ()\n+{\n+  test_assign_single ();\n+  test_assign_binop ();\n+  test_nop_stmt ();\n+  test_return_stmt ();\n+  test_return_without_value ();\n+}\n+\n+} // namespace selftest\n+\n+\n+#endif /* CHECKING_P */"}, {"sha": "fd1bb952fcddac41fe89a4a69ed7d23b9f6c3eed", "filename": "gcc/hash-map-tests.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fhash-map-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fhash-map-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map-tests.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,93 @@\n+/* Unit tests for hash-map.h.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"opts.h\"\n+#include \"signop.h\"\n+#include \"hash-set.h\"\n+#include \"fixed-value.h\"\n+#include \"alias.h\"\n+#include \"flags.h\"\n+#include \"symtab.h\"\n+#include \"tree-core.h\"\n+#include \"stor-layout.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Construct a hash_map <const char *, int> and verify that\n+   various operations work correctly.  */\n+\n+static void\n+test_map_of_strings_to_int ()\n+{\n+  hash_map <const char *, int> m;\n+\n+  const char *ostrich = \"ostrich\";\n+  const char *elephant = \"elephant\";\n+  const char *ant = \"ant\";\n+  const char *spider = \"spider\";\n+  const char *millipede = \"Illacme plenipes\";\n+  const char *eric = \"half a bee\";\n+\n+  /* A fresh hash_map should be empty.  */\n+  ASSERT_EQ (0, m.elements ());\n+  ASSERT_EQ (NULL, m.get (ostrich));\n+\n+  /* Populate the hash_map.  */\n+  ASSERT_EQ (false, m.put (ostrich, 2));\n+  ASSERT_EQ (false, m.put (elephant, 4));\n+  ASSERT_EQ (false, m.put (ant, 6));\n+  ASSERT_EQ (false, m.put (spider, 8));\n+  ASSERT_EQ (false, m.put (millipede, 750));\n+  ASSERT_EQ (false, m.put (eric, 3));\n+\n+  /* Verify that we can recover the stored values.  */\n+  ASSERT_EQ (6, m.elements ());\n+  ASSERT_EQ (2, *m.get (ostrich));\n+  ASSERT_EQ (4, *m.get (elephant));\n+  ASSERT_EQ (6, *m.get (ant));\n+  ASSERT_EQ (8, *m.get (spider));\n+  ASSERT_EQ (750, *m.get (millipede));\n+  ASSERT_EQ (3, *m.get (eric));\n+\n+  /* Verify removing an item.  */\n+  m.remove (eric);\n+  ASSERT_EQ (5, m.elements ());\n+  ASSERT_EQ (NULL, m.get (eric));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+hash_map_tests_c_tests ()\n+{\n+  test_map_of_strings_to_int ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "db408f293e2b4b3b05c3ee16462f5557c3b21771", "filename": "gcc/hash-set-tests.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fhash-set-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fhash-set-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set-tests.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,69 @@\n+/* Unit tests for hash-set.h.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"opts.h\"\n+#include \"signop.h\"\n+#include \"hash-set.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Construct a hash_set <const char *> and verify that various operations\n+   work correctly.  */\n+\n+static void\n+test_set_of_strings ()\n+{\n+  hash_set <const char *> s;\n+  ASSERT_EQ (0, s.elements ());\n+\n+  const char *red = \"red\";\n+  const char *green = \"green\";\n+  const char *blue = \"blue\";\n+\n+  ASSERT_EQ (false, s.contains (red));\n+\n+  /* Populate the hash_set.  */\n+  ASSERT_EQ (false, s.add (red));\n+  ASSERT_EQ (false, s.add (green));\n+  ASSERT_EQ (false, s.add (blue));\n+\n+  /* Verify that the values are now within the set.  */\n+  ASSERT_EQ (true, s.contains (red));\n+  ASSERT_EQ (true, s.contains (green));\n+  ASSERT_EQ (true, s.contains (blue));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+hash_set_tests_c_tests ()\n+{\n+  test_set_of_strings ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "0b340a8ed9d150af160fe219ceb3db6917a50e70", "filename": "gcc/input.c", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"intl.h\"\n #include \"diagnostic-core.h\"\n+#include \"selftest.h\"\n \n /* This is a cache used by get_next_line to store the content of a\n    file to be searched for file lines.  */\n@@ -1136,3 +1137,118 @@ dump_location_info (FILE *stream)\n   dump_labelled_location_range (stream, \"AD-HOC LOCATIONS\",\n \t\t\t\tMAX_SOURCE_LOCATION + 1, UINT_MAX);\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests of location handling.  */\n+\n+/* Verify the result of LOCATION_FILE/LOCATION_LINE/LOCATION_COLUMN\n+   on LOC.  */\n+\n+static void\n+assert_loceq (const char *exp_filename, int exp_linenum, int exp_colnum,\n+\t      location_t loc)\n+{\n+  ASSERT_STREQ (exp_filename, LOCATION_FILE (loc));\n+  ASSERT_EQ (exp_linenum, LOCATION_LINE (loc));\n+  ASSERT_EQ (exp_colnum, LOCATION_COLUMN (loc));\n+}\n+\n+/* Verify basic operation of ordinary linemaps.  */\n+\n+static void\n+test_accessing_ordinary_linemaps ()\n+{\n+  /* Build a simple linemap describing some locations. */\n+  linemap_add (line_table, LC_ENTER, false, \"foo.c\", 0);\n+\n+  linemap_line_start (line_table, 1, 100);\n+  location_t loc_a = linemap_position_for_column (line_table, 1);\n+  location_t loc_b = linemap_position_for_column (line_table, 23);\n+\n+  linemap_line_start (line_table, 2, 100);\n+  location_t loc_c = linemap_position_for_column (line_table, 1);\n+  location_t loc_d = linemap_position_for_column (line_table, 17);\n+\n+  /* Example of a very long line.  */\n+  linemap_line_start (line_table, 3, 2000);\n+  location_t loc_e = linemap_position_for_column (line_table, 700);\n+\n+  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+\n+  /* Multiple files.  */\n+  linemap_add (line_table, LC_ENTER, false, \"bar.c\", 0);\n+  linemap_line_start (line_table, 1, 200);\n+  location_t loc_f = linemap_position_for_column (line_table, 150);\n+  linemap_add (line_table, LC_LEAVE, false, NULL, 0);\n+\n+  /* Verify that we can recover the location info.  */\n+  assert_loceq (\"foo.c\", 1, 1, loc_a);\n+  assert_loceq (\"foo.c\", 1, 23, loc_b);\n+  assert_loceq (\"foo.c\", 2, 1, loc_c);\n+  assert_loceq (\"foo.c\", 2, 17, loc_d);\n+  assert_loceq (\"foo.c\", 3, 700, loc_e);\n+  assert_loceq (\"bar.c\", 1, 150, loc_f);\n+\n+  ASSERT_FALSE (is_location_from_builtin_token (loc_a));\n+}\n+\n+/* Verify various properties of UNKNOWN_LOCATION.  */\n+\n+static void\n+test_unknown_location ()\n+{\n+  ASSERT_EQ (NULL, LOCATION_FILE (UNKNOWN_LOCATION));\n+  ASSERT_EQ (0, LOCATION_LINE (UNKNOWN_LOCATION));\n+  ASSERT_EQ (0, LOCATION_COLUMN (UNKNOWN_LOCATION));\n+}\n+\n+/* Verify various properties of BUILTINS_LOCATION.  */\n+\n+static void\n+test_builtins ()\n+{\n+  assert_loceq (\"<built-in>\", 0, 0, BUILTINS_LOCATION);\n+  ASSERT_PRED1 (is_location_from_builtin_token, BUILTINS_LOCATION);\n+}\n+\n+/* Verify reading of input files (e.g. for caret-based diagnostics).  */\n+\n+static void\n+test_reading_source_line ()\n+{\n+  /* We will read *this* source file, using __FILE__.\n+     Here is some specific text to read and test for:\n+     The quick brown fox jumps over the lazy dog.  */\n+  const int linenum_after_test_message = __LINE__;\n+  const int linenum = linenum_after_test_message - 1;\n+\n+  int line_size;\n+  const char *source_line = location_get_source_line (__FILE__, linenum, &line_size);\n+  ASSERT_TRUE (source_line != NULL);\n+  ASSERT_EQ (53, line_size);\n+  if (!strncmp (\"     The quick brown fox jumps over the lazy dog.  */\",\n+\t       source_line, line_size))\n+    ::selftest::pass (__FILE__, __LINE__,\n+\t\t      \"source_line matched expected value\");\n+  else\n+    ::selftest::fail (__FILE__, __LINE__,\n+\t\t      \"source_line did not match expected value\");\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+input_c_tests ()\n+{\n+  test_accessing_ordinary_linemaps ();\n+  test_unknown_location ();\n+  test_builtins ();\n+  test_reading_source_line ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */"}, {"sha": "3e9ebae02bbcd1b5a2365ecca91754017f7c9694", "filename": "gcc/rtl-tests.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Frtl-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Frtl-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-tests.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,117 @@\n+/* Unit tests for RTL-handling.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"opts.h\"\n+#include \"signop.h\"\n+#include \"hash-set.h\"\n+#include \"fixed-value.h\"\n+#include \"alias.h\"\n+#include \"flags.h\"\n+#include \"symtab.h\"\n+#include \"tree-core.h\"\n+#include \"stor-layout.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"stor-layout.h\"\n+#include \"rtl.h\"\n+#include \"pretty-print.h\"\n+#include \"cfgbuild.h\"\n+#include \"print-rtl.h\"\n+#include \"selftest.h\"\n+#include \"function.h\"\n+#include \"emit-rtl.h\"\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Verify that PAT is printed as EXPECTED.  Helper function for\n+   selftests.  */\n+\n+static void\n+verify_print_pattern (const char *expected, rtx pat)\n+{\n+  pretty_printer pp;\n+  print_pattern (&pp, pat, 1);\n+  ASSERT_STREQ (expected, pp_formatted_text (&pp));\n+}\n+\n+/* Unit testing of \"single_set\".  */\n+\n+static void\n+test_single_set ()\n+{\n+  /* A label is not a SET.  */\n+  ASSERT_EQ (NULL_RTX, single_set (gen_label_rtx ()));\n+\n+  /* An unconditional jump insn is a single SET.  */\n+  rtx set_pc = gen_rtx_SET (pc_rtx,\n+\t\t\t    gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t       gen_label_rtx ()));\n+  rtx_insn *jump_insn = emit_jump_insn (set_pc);\n+  ASSERT_EQ (set_pc, single_set (jump_insn));\n+\n+  /* etc */\n+}\n+\n+/* Construct an unconditional jump to a label, and verify that\n+   various properties of it are sane.  */\n+\n+static void\n+test_uncond_jump ()\n+{\n+  rtx_insn *label = gen_label_rtx ();\n+  rtx jump_pat = gen_rtx_SET (pc_rtx,\n+\t\t\t      gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t label));\n+  ASSERT_EQ (SET, jump_pat->code);\n+  ASSERT_EQ (LABEL_REF, SET_SRC (jump_pat)->code);\n+  ASSERT_EQ (label, LABEL_REF_LABEL (SET_SRC (jump_pat)));\n+  ASSERT_EQ (PC, SET_DEST (jump_pat)->code);\n+\n+  verify_print_pattern (\"pc=L0\", jump_pat);\n+\n+  rtx_insn *jump_insn = emit_jump_insn (jump_pat);\n+  ASSERT_FALSE (any_condjump_p (jump_insn));\n+  ASSERT_TRUE (any_uncondjump_p (jump_insn));\n+  ASSERT_TRUE (pc_set (jump_insn));\n+  ASSERT_TRUE (simplejump_p (jump_insn));\n+  ASSERT_TRUE (onlyjump_p (jump_insn));\n+  ASSERT_TRUE (control_flow_insn_p (jump_insn));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+rtl_tests_c_tests ()\n+{\n+  test_single_set ();\n+  test_uncond_jump ();\n+\n+  /* Purge state.  */\n+  set_first_insn (NULL);\n+  set_last_insn (NULL);\n+}\n+\n+} // namespace selftest\n+#endif /* #if CHECKING_P */"}, {"sha": "ab334aac6407a0222e78b27f27cb643ce90bd47c", "filename": "gcc/selftest-run-tests.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,77 @@\n+/* Implementation of selftests.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"selftest.h\"\n+\n+/* This function needed to be split out from selftest.c as it references\n+   tests from the whole source tree, and so is within\n+   OBJS in Makefile.in, whereas selftest.o is within OBJS-libcommon.\n+   This allows us to embed tests within files in OBJS-libcommon without\n+   introducing a dependency on objects within OBJS.  */\n+\n+#if CHECKING_P\n+\n+/* Run all tests, aborting if any fail.  */\n+\n+void\n+selftest::run_tests ()\n+{\n+  long start_time = get_run_time ();\n+\n+  /* Run all the tests, in hand-coded order of (approximate) dependencies:\n+     run the tests for lowest-level code first.  */\n+\n+  /* Low-level data structures.  */\n+  bitmap_c_tests ();\n+  et_forest_c_tests ();\n+  hash_map_tests_c_tests ();\n+  hash_set_tests_c_tests ();\n+  vec_c_tests ();\n+  wide_int_cc_tests ();\n+\n+  /* Mid-level data structures.  */\n+  input_c_tests ();\n+  tree_c_tests ();\n+  gimple_c_tests ();\n+  rtl_tests_c_tests ();\n+\n+  /* Higher-level tests, or for components that other selftests don't\n+     rely on.  */\n+  diagnostic_show_locus_c_tests ();\n+  fold_const_c_tests ();\n+  spellcheck_c_tests ();\n+  tree_cfg_c_tests ();\n+\n+  /* This one relies on most of the above.  */\n+  function_tests_c_tests ();\n+\n+  /* Finished running tests.  */\n+  long finish_time = get_run_time ();\n+  long elapsed_time = finish_time - start_time;\n+\n+  fprintf (stderr,\n+\t   \"-fself-test: %i pass(es) in %ld.%06ld seconds\\n\",\n+\t   num_passes,\n+\t   elapsed_time / 1000000, elapsed_time % 1000000);\n+}\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "de804df9f3e47576b0eaa9a1f9f06e1792898d75", "filename": "gcc/selftest.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,47 @@\n+/* A self-testing framework, for use by -fself-test.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"selftest.h\"\n+\n+#if CHECKING_P\n+\n+int selftest::num_passes;\n+\n+/* Record the successful outcome of some aspect of a test.  */\n+\n+void\n+selftest::pass (const char */*file*/, int /*line*/, const char */*msg*/)\n+{\n+  num_passes++;\n+}\n+\n+/* Report the failed outcome of some aspect of a test and abort.  */\n+\n+void\n+selftest::fail (const char *file, int line, const char *msg)\n+{\n+  fprintf (stderr,\"%s:%i: FAIL: %s\\n\", file, line, msg);\n+  /* TODO: add calling function name as well?  */\n+  abort ();\n+}\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "a1d3074b7de594660969c5644a77b12c570b6e67", "filename": "gcc/selftest.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -0,0 +1,153 @@\n+/* A self-testing framework, for use by -fself-test.\n+   Copyright (C) 2015-2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SELFTEST_H\n+#define GCC_SELFTEST_H\n+\n+/* The selftest code should entirely disappear in a production\n+   configuration, hence we guard all of it with #if CHECKING_P.  */\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* The entrypoint for running all tests.  */\n+\n+extern void run_tests ();\n+\n+/* Record the successful outcome of some aspect of the test.  */\n+\n+extern void pass (const char *file, int line, const char *msg);\n+\n+/* Report the failed outcome of some aspect of the test and abort.  */\n+\n+extern void fail (const char *file, int line, const char *msg);\n+\n+/* Declarations for specific families of tests (by source file), in\n+   alphabetical order.  */\n+extern void bitmap_c_tests ();\n+extern void diagnostic_show_locus_c_tests ();\n+extern void et_forest_c_tests ();\n+extern void fold_const_c_tests ();\n+extern void function_tests_c_tests ();\n+extern void gimple_c_tests ();\n+extern void hash_map_tests_c_tests ();\n+extern void hash_set_tests_c_tests ();\n+extern void input_c_tests ();\n+extern void rtl_tests_c_tests ();\n+extern void spellcheck_c_tests ();\n+extern void tree_c_tests ();\n+extern void tree_cfg_c_tests ();\n+extern void vec_c_tests ();\n+extern void wide_int_cc_tests ();\n+\n+extern int num_passes;\n+\n+} /* end of namespace selftest.  */\n+\n+/* Macros for writing tests.  */\n+\n+/* Evaluate EXPR and coerce to bool, calling\n+   ::selftest::pass if it is true,\n+   ::selftest::fail if it false.  */\n+\n+#define ASSERT_TRUE(EXPR)\t\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_TRUE (\" #EXPR \")\";\t\t\\\n+  bool actual = (EXPR);\t\t\t\t\t\\\n+  if (actual)\t\t\t\t\t\t\\\n+    ::selftest::pass (__FILE__, __LINE__, desc);\t\\\n+  else\t\t\t\t\t\t\t\\\n+    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Evaluate EXPR and coerce to bool, calling\n+   ::selftest::pass if it is false,\n+   ::selftest::fail if it true.  */\n+\n+#define ASSERT_FALSE(EXPR)\t\t\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_FALSE (\" #EXPR \")\";\t\t\\\n+  bool actual = (EXPR);\t\t\t\t\t\\\n+  if (actual)\t\t\t\t\t\t\t\\\n+    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+/* Evaluate EXPECTED and ACTUAL and compare them with ==, calling\n+   ::selftest::pass if they are equal,\n+   ::selftest::fail if they are non-equal.  */\n+\n+#define ASSERT_EQ(EXPECTED, ACTUAL)\t\t\t       \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n+  const char *desc = \"ASSERT_EQ (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n+  if ((EXPECTED) == (ACTUAL))\t\t\t\t       \\\n+    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t       \\\n+  else\t\t\t\t\t\t\t       \\\n+    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t       \\\n+  SELFTEST_END_STMT\n+\n+/* Evaluate EXPECTED and ACTUAL and compare them with !=, calling\n+   ::selftest::pass if they are non-equal,\n+   ::selftest::fail if they are equal.  */\n+\n+#define ASSERT_NE(EXPECTED, ACTUAL)\t\t\t       \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n+  const char *desc = \"ASSERT_NE (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n+  if ((EXPECTED) != (ACTUAL))\t\t\t\t       \\\n+    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t       \\\n+  else\t\t\t\t\t\t\t       \\\n+    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t       \\\n+  SELFTEST_END_STMT\n+\n+/* Evaluate EXPECTED and ACTUAL and compare them with strcmp, calling\n+   ::selftest::pass if they are equal,\n+   ::selftest::fail if they are non-equal.  */\n+\n+#define ASSERT_STREQ(EXPECTED, ACTUAL)\t\t\t       \\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n+  const char *desc = \"ASSERT_STREQ (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n+  const char *expected_ = (EXPECTED);\t\t\t\t  \\\n+  const char *actual_ = (ACTUAL);\t\t\t\t  \\\n+  if (0 == strcmp (expected_, actual_))\t\t\t\t  \\\n+    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t       \\\n+  else\t\t\t\t\t\t\t       \\\n+    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t       \\\n+  SELFTEST_END_STMT\n+\n+/* Evaluate PRED1 (VAL1), calling ::selftest::pass if it is true,\n+   ::selftest::fail if it is false.  */\n+\n+#define ASSERT_PRED1(PRED1, VAL1)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_PRED1 (\" #PRED1 \", \" #VAL1 \")\";\t\\\n+  bool actual = (PRED1) (VAL1);\t\t\t\t\\\n+  if (actual)\t\t\t\t\t\t\\\n+    ::selftest::pass (__FILE__, __LINE__, desc);\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    ::selftest::fail (__FILE__, __LINE__, desc);\t\t\t\\\n+  SELFTEST_END_STMT\n+\n+#define SELFTEST_BEGIN_STMT do {\n+#define SELFTEST_END_STMT   } while (0)\n+\n+#endif /* #if CHECKING_P */\n+\n+#endif /* GCC_SELFTEST_H */"}, {"sha": "ceb60168bf167ea00759ead506e5dbf395017670", "filename": "gcc/spellcheck.c", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fspellcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fspellcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"spellcheck.h\"\n+#include \"selftest.h\"\n \n /* The Levenshtein distance is an \"edit-distance\": the minimal\n    number of one-character insertions, removals or substitutions\n@@ -165,3 +166,60 @@ find_closest_string (const char *target,\n \n   return best_candidate;\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests.  */\n+\n+/* Verify that the levenshtein_distance (A, B) equals the expected\n+   value.  */\n+\n+static void\n+levenshtein_distance_unit_test_oneway (const char *a, const char *b,\n+\t\t\t\t       edit_distance_t expected)\n+{\n+  edit_distance_t actual = levenshtein_distance (a, b);\n+  ASSERT_EQ (actual, expected);\n+}\n+\n+/* Verify that both\n+     levenshtein_distance (A, B)\n+   and\n+     levenshtein_distance (B, A)\n+   equal the expected value, to ensure that the function is symmetric.  */\n+\n+static void\n+levenshtein_distance_unit_test (const char *a, const char *b,\n+\t\t\t\tedit_distance_t expected)\n+{\n+  levenshtein_distance_unit_test_oneway (a, b, expected);\n+  levenshtein_distance_unit_test_oneway (b, a, expected);\n+}\n+\n+/* Verify levenshtein_distance for a variety of pairs of pre-canned\n+   inputs, comparing against known-good values.  */\n+\n+void\n+spellcheck_c_tests ()\n+{\n+  levenshtein_distance_unit_test (\"\", \"nonempty\", strlen (\"nonempty\"));\n+  levenshtein_distance_unit_test (\"saturday\", \"sunday\", 3);\n+  levenshtein_distance_unit_test (\"foo\", \"m_foo\", 2);\n+  levenshtein_distance_unit_test (\"hello_world\", \"HelloWorld\", 3);\n+  levenshtein_distance_unit_test\n+    (\"the quick brown fox jumps over the lazy dog\", \"dog\", 40);\n+  levenshtein_distance_unit_test\n+    (\"the quick brown fox jumps over the lazy dog\",\n+     \"the quick brown dog jumps over the lazy fox\",\n+     4);\n+  levenshtein_distance_unit_test\n+    (\"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\",\n+     \"All your base are belong to us\",\n+     44);\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "15a771679439c31f8742924c56b6ad86ae695164", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -1,3 +1,10 @@\n+2016-06-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/levenshtein-test-1.c: Delete.\n+\t* gcc.dg/plugin/levenshtein_plugin.c: Delete.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Remove the\n+\tabove.\n+\n 2016-06-06  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR middle-end/37780"}, {"sha": "ac49992780d2fcb4562823ef7441b081cacf8e7b", "filename": "gcc/testsuite/gcc.dg/plugin/levenshtein-test-1.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc6221fe5aa38017bb5818aa28257360b15f3b6/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc6221fe5aa38017bb5818aa28257360b15f3b6/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein-test-1.c?ref=dbc6221fe5aa38017bb5818aa28257360b15f3b6", "patch": "@@ -1,9 +0,0 @@\n-/* Placeholder C source file for unit-testing gcc/spellcheck.c.  */\n-/* { dg-do compile } */\n-/* { dg-options \"-O\" } */\n-\n-int\n-main (int argc, char **argv)\n-{\n-  return 0;\n-}"}, {"sha": "3e7dc7889305a422eddd6de8760fd1dc0499a2e3", "filename": "gcc/testsuite/gcc.dg/plugin/levenshtein_plugin.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbc6221fe5aa38017bb5818aa28257360b15f3b6/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbc6221fe5aa38017bb5818aa28257360b15f3b6/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein_plugin.c?ref=dbc6221fe5aa38017bb5818aa28257360b15f3b6", "patch": "@@ -1,64 +0,0 @@\n-/* Plugin for unittesting gcc/spellcheck.h.  */\n-\n-#include \"config.h\"\n-#include \"gcc-plugin.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"spellcheck.h\"\n-#include \"diagnostic.h\"\n-\n-int plugin_is_GPL_compatible;\n-\n-static void\n-levenshtein_distance_unit_test_oneway (const char *a, const char *b,\n-\t\t\t\t       edit_distance_t expected)\n-{\n-  edit_distance_t actual = levenshtein_distance (a, b);\n-  if (actual != expected)\n-    error (\"levenshtein_distance (\\\"%s\\\", \\\"%s\\\") : expected: %i got %i\",\n-\t   a, b, expected, actual);\n-}\n-\n-\n-static void\n-levenshtein_distance_unit_test (const char *a, const char *b,\n-\t\t\t\tedit_distance_t expected)\n-{\n-  /* Run every test both ways to ensure it's symmetric.  */\n-  levenshtein_distance_unit_test_oneway (a, b, expected);\n-  levenshtein_distance_unit_test_oneway (b, a, expected);\n-}\n-\n-/* Callback handler for the PLUGIN_FINISH event; run\n-   levenshtein_distance unit tests here.  */\n-\n-static void\n-on_finish (void */*gcc_data*/, void */*user_data*/)\n-{\n-  levenshtein_distance_unit_test (\"\", \"nonempty\", strlen (\"nonempty\"));\n-  levenshtein_distance_unit_test (\"saturday\", \"sunday\", 3);\n-  levenshtein_distance_unit_test (\"foo\", \"m_foo\", 2);\n-  levenshtein_distance_unit_test (\"hello_world\", \"HelloWorld\", 3);\n-  levenshtein_distance_unit_test\n-    (\"the quick brown fox jumps over the lazy dog\", \"dog\", 40);\n-  levenshtein_distance_unit_test\n-    (\"the quick brown fox jumps over the lazy dog\",\n-     \"the quick brown dog jumps over the lazy fox\",\n-     4);\n-  levenshtein_distance_unit_test\n-    (\"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\",\n-     \"All your base are belong to us\",\n-     44);\n-}\n-\n-int\n-plugin_init (struct plugin_name_args *plugin_info,\n-\t     struct plugin_gcc_version */*version*/)\n-{\n-  register_callback (plugin_info->base_name,\n-\t\t     PLUGIN_FINISH,\n-\t\t     on_finish,\n-\t\t     NULL); /* void *user_data */\n-\n-  return 0;\n-}"}, {"sha": "be2ac8dcfcb7a266cf1defbe5ff732f0de4eaf50", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -70,7 +70,6 @@ set plugin_test_list [list \\\n \t  diagnostic-test-expressions-1.c } \\\n     { diagnostic_plugin_show_trees.c \\\n \t  diagnostic-test-show-trees-1.c } \\\n-    { levenshtein_plugin.c levenshtein-test-1.c } \\\n     { location_overflow_plugin.c \\\n \t  location-overflow-test-1.c \\\n \t  location-overflow-test-2.c } \\"}, {"sha": "543b8a3dc72a67c42e73673d814eeb9e4a157bb6", "filename": "gcc/toplev.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -87,6 +87,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"xcoffout.h\"\t\t/* Needed for external data declarations. */\n #endif\n \n+#include \"selftest.h\"\n+\n static void general_init (const char *, bool);\n static void do_compile ();\n static void process_options (void);\n@@ -2031,6 +2033,27 @@ toplev::start_timevars ()\n   timevar_start (TV_TOTAL);\n }\n \n+/* Handle -fself-test.   */\n+\n+void\n+toplev::run_self_tests ()\n+{\n+#if CHECKING_P\n+  /* Reset some state.  */\n+  input_location = UNKNOWN_LOCATION;\n+  bitmap_obstack_initialize (NULL);\n+\n+  /* Run the tests; any failures will lead to an abort of the process.\n+     Use \"make selftests-gdb\" to run under the debugger.  */\n+  ::selftest::run_tests ();\n+\n+  /* Cleanup.  */\n+  bitmap_obstack_release (NULL);\n+#else\n+  inform (UNKNOWN_LOCATION, \"self-tests are not enabled in this build\");\n+#endif /* #if CHECKING_P */\n+}\n+\n /* Entry point of cc1, cc1plus, jc1, f771, etc.\n    Exit code is FATAL_EXIT_CODE if can't open files or if there were\n    any errors, or SUCCESS_EXIT_CODE if compilation succeeded.\n@@ -2098,6 +2121,9 @@ toplev::main (int argc, char **argv)\n   if (warningcount || errorcount || werrorcount)\n     print_ignored_options ();\n \n+  if (flag_self_test)\n+    run_self_tests ();\n+\n   /* Invoke registered plugin callbacks if any.  Some plugins could\n      emit some diagnostics here.  */\n   invoke_plugin_callbacks (PLUGIN_FINISH, NULL);"}, {"sha": "06923cf0c94e3ababebfb0f017d87c8d8a0e66ae", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -42,6 +42,8 @@ class toplev\n \n   void start_timevars ();\n \n+  void run_self_tests ();\n+\n   bool m_use_TV_TOTAL;\n   bool m_init_signals;\n };"}, {"sha": "40e524bba9c340a4ada46b582e69fac41ced51c4", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"gimplify.h\"\n #include \"attribs.h\"\n+#include \"selftest.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -9195,3 +9196,280 @@ gt_pch_nx (edge_def *e, gt_pointer_operator op, void *cookie)\n     op (&(e->insns.r), cookie);\n   op (&(block), cookie);\n }\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Helper function for CFG selftests: create a dummy function decl\n+   and push it as cfun.  */\n+\n+static tree\n+push_fndecl (const char *name)\n+{\n+  tree fn_type = build_function_type_array (integer_type_node, 0, NULL);\n+  /* FIXME: this uses input_location: */\n+  tree fndecl = build_fn_decl (name, fn_type);\n+  tree retval = build_decl (UNKNOWN_LOCATION, RESULT_DECL,\n+\t\t\t    NULL_TREE, integer_type_node);\n+  DECL_RESULT (fndecl) = retval;\n+  push_struct_function (fndecl);\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+  ASSERT_TRUE (fun != NULL);\n+  init_empty_tree_cfg_for_function (fun);\n+  ASSERT_EQ (2, n_basic_blocks_for_fn (fun));\n+  ASSERT_EQ (0, n_edges_for_fn (fun));\n+  return fndecl;\n+}\n+\n+/* These tests directly create CFGs.\n+   Compare with the static fns within tree-cfg.c:\n+     - build_gimple_cfg\n+     - make_blocks: calls create_basic_block (seq, bb);\n+     - make_edges.   */\n+\n+/* Verify a simple cfg of the form:\n+     ENTRY -> A -> B -> C -> EXIT.  */\n+\n+static void\n+test_linear_chain ()\n+{\n+  gimple_register_cfg_hooks ();\n+\n+  tree fndecl = push_fndecl (\"cfg_test_linear_chain\");\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+\n+  /* Create some empty blocks.  */\n+  basic_block bb_a = create_empty_bb (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+  basic_block bb_b = create_empty_bb (bb_a);\n+  basic_block bb_c = create_empty_bb (bb_b);\n+\n+  ASSERT_EQ (5, n_basic_blocks_for_fn (fun));\n+  ASSERT_EQ (0, n_edges_for_fn (fun));\n+\n+  /* Create some edges: a simple linear chain of BBs.  */\n+  make_edge (ENTRY_BLOCK_PTR_FOR_FN (fun), bb_a, EDGE_FALLTHRU);\n+  make_edge (bb_a, bb_b, 0);\n+  make_edge (bb_b, bb_c, 0);\n+  make_edge (bb_c, EXIT_BLOCK_PTR_FOR_FN (fun), 0);\n+\n+  /* Verify the edges.  */\n+  ASSERT_EQ (4, n_edges_for_fn (fun));\n+  ASSERT_EQ (NULL, ENTRY_BLOCK_PTR_FOR_FN (fun)->preds);\n+  ASSERT_EQ (1, ENTRY_BLOCK_PTR_FOR_FN (fun)->succs->length ());\n+  ASSERT_EQ (1, bb_a->preds->length ());\n+  ASSERT_EQ (1, bb_a->succs->length ());\n+  ASSERT_EQ (1, bb_b->preds->length ());\n+  ASSERT_EQ (1, bb_b->succs->length ());\n+  ASSERT_EQ (1, bb_c->preds->length ());\n+  ASSERT_EQ (1, bb_c->succs->length ());\n+  ASSERT_EQ (1, EXIT_BLOCK_PTR_FOR_FN (fun)->preds->length ());\n+  ASSERT_EQ (NULL, EXIT_BLOCK_PTR_FOR_FN (fun)->succs);\n+\n+  /* Verify the dominance information\n+     Each BB in our simple chain should be dominated by the one before\n+     it.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  ASSERT_EQ (bb_a, get_immediate_dominator (CDI_DOMINATORS, bb_b));\n+  ASSERT_EQ (bb_b, get_immediate_dominator (CDI_DOMINATORS, bb_c));\n+  vec<basic_block> dom_by_b = get_dominated_by (CDI_DOMINATORS, bb_b);\n+  ASSERT_EQ (1, dom_by_b.length ());\n+  ASSERT_EQ (bb_c, dom_by_b[0]);\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  /* Similarly for post-dominance: each BB in our chain is post-dominated\n+     by the one after it.  */\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  ASSERT_EQ (bb_b, get_immediate_dominator (CDI_POST_DOMINATORS, bb_a));\n+  ASSERT_EQ (bb_c, get_immediate_dominator (CDI_POST_DOMINATORS, bb_b));\n+  vec<basic_block> postdom_by_b = get_dominated_by (CDI_POST_DOMINATORS, bb_b);\n+  ASSERT_EQ (1, postdom_by_b.length ());\n+  ASSERT_EQ (bb_a, postdom_by_b[0]);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  pop_cfun ();\n+}\n+\n+/* Verify a simple CFG of the form:\n+     ENTRY\n+       |\n+       A\n+      / \\\n+     /t  \\f\n+    B     C\n+     \\   /\n+      \\ /\n+       D\n+       |\n+      EXIT.  */\n+\n+static void\n+test_diamond ()\n+{\n+  gimple_register_cfg_hooks ();\n+\n+  tree fndecl = push_fndecl (\"cfg_test_diamond\");\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+\n+  /* Create some empty blocks.  */\n+  basic_block bb_a = create_empty_bb (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+  basic_block bb_b = create_empty_bb (bb_a);\n+  basic_block bb_c = create_empty_bb (bb_a);\n+  basic_block bb_d = create_empty_bb (bb_b);\n+\n+  ASSERT_EQ (6, n_basic_blocks_for_fn (fun));\n+  ASSERT_EQ (0, n_edges_for_fn (fun));\n+\n+  /* Create the edges.  */\n+  make_edge (ENTRY_BLOCK_PTR_FOR_FN (fun), bb_a, EDGE_FALLTHRU);\n+  make_edge (bb_a, bb_b, EDGE_TRUE_VALUE);\n+  make_edge (bb_a, bb_c, EDGE_FALSE_VALUE);\n+  make_edge (bb_b, bb_d, 0);\n+  make_edge (bb_c, bb_d, 0);\n+  make_edge (bb_d, EXIT_BLOCK_PTR_FOR_FN (fun), 0);\n+\n+  /* Verify the edges.  */\n+  ASSERT_EQ (6, n_edges_for_fn (fun));\n+  ASSERT_EQ (1, bb_a->preds->length ());\n+  ASSERT_EQ (2, bb_a->succs->length ());\n+  ASSERT_EQ (1, bb_b->preds->length ());\n+  ASSERT_EQ (1, bb_b->succs->length ());\n+  ASSERT_EQ (1, bb_c->preds->length ());\n+  ASSERT_EQ (1, bb_c->succs->length ());\n+  ASSERT_EQ (2, bb_d->preds->length ());\n+  ASSERT_EQ (1, bb_d->succs->length ());\n+\n+  /* Verify the dominance information.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  ASSERT_EQ (bb_a, get_immediate_dominator (CDI_DOMINATORS, bb_b));\n+  ASSERT_EQ (bb_a, get_immediate_dominator (CDI_DOMINATORS, bb_c));\n+  ASSERT_EQ (bb_a, get_immediate_dominator (CDI_DOMINATORS, bb_d));\n+  vec<basic_block> dom_by_a = get_dominated_by (CDI_DOMINATORS, bb_a);\n+  ASSERT_EQ (3, dom_by_a.length ()); /* B, C, D, in some order.  */\n+  vec<basic_block> dom_by_b = get_dominated_by (CDI_DOMINATORS, bb_b);\n+  ASSERT_EQ (0, dom_by_b.length ());\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  /* Similarly for post-dominance.  */\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  ASSERT_EQ (bb_d, get_immediate_dominator (CDI_POST_DOMINATORS, bb_a));\n+  ASSERT_EQ (bb_d, get_immediate_dominator (CDI_POST_DOMINATORS, bb_b));\n+  ASSERT_EQ (bb_d, get_immediate_dominator (CDI_POST_DOMINATORS, bb_c));\n+  vec<basic_block> postdom_by_d = get_dominated_by (CDI_POST_DOMINATORS, bb_d);\n+  ASSERT_EQ (3, postdom_by_d.length ()); /* A, B, C in some order.  */\n+  vec<basic_block> postdom_by_b = get_dominated_by (CDI_POST_DOMINATORS, bb_b);\n+  ASSERT_EQ (0, postdom_by_b.length ());\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  pop_cfun ();\n+}\n+\n+/* Verify that we can handle a CFG containing a \"complete\" aka\n+   fully-connected subgraph (where A B C D below all have edges\n+   pointing to each other node, also to themselves).\n+   e.g.:\n+     ENTRY  EXIT\n+       |    ^\n+       |   /\n+       |  /\n+       | /\n+       V/\n+       A<--->B\n+       ^^   ^^\n+       | \\ / |\n+       |  X  |\n+       | / \\ |\n+       VV   VV\n+       C<--->D\n+*/\n+\n+static void\n+test_fully_connected ()\n+{\n+  gimple_register_cfg_hooks ();\n+\n+  tree fndecl = push_fndecl (\"cfg_fully_connected\");\n+  function *fun = DECL_STRUCT_FUNCTION (fndecl);\n+\n+  const int n = 4;\n+\n+  /* Create some empty blocks.  */\n+  auto_vec <basic_block> subgraph_nodes;\n+  for (int i = 0; i < n; i++)\n+    subgraph_nodes.safe_push (create_empty_bb (ENTRY_BLOCK_PTR_FOR_FN (fun)));\n+\n+  ASSERT_EQ (n + 2, n_basic_blocks_for_fn (fun));\n+  ASSERT_EQ (0, n_edges_for_fn (fun));\n+\n+  /* Create the edges.  */\n+  make_edge (ENTRY_BLOCK_PTR_FOR_FN (fun), subgraph_nodes[0], EDGE_FALLTHRU);\n+  make_edge (subgraph_nodes[0], EXIT_BLOCK_PTR_FOR_FN (fun), 0);\n+  for (int i = 0; i < n; i++)\n+    for (int j = 0; j < n; j++)\n+      make_edge (subgraph_nodes[i], subgraph_nodes[j], 0);\n+\n+  /* Verify the edges.  */\n+  ASSERT_EQ (2 + (n * n), n_edges_for_fn (fun));\n+  /* The first one is linked to ENTRY/EXIT as well as itself and\n+     everything else.  */\n+  ASSERT_EQ (n + 1, subgraph_nodes[0]->preds->length ());\n+  ASSERT_EQ (n + 1, subgraph_nodes[0]->succs->length ());\n+  /* The other ones in the subgraph are linked to everything in\n+     the subgraph (including themselves).  */\n+  for (int i = 1; i < n; i++)\n+    {\n+      ASSERT_EQ (n, subgraph_nodes[i]->preds->length ());\n+      ASSERT_EQ (n, subgraph_nodes[i]->succs->length ());\n+    }\n+\n+  /* Verify the dominance information.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  /* The initial block in the subgraph should be dominated by ENTRY.  */\n+  ASSERT_EQ (ENTRY_BLOCK_PTR_FOR_FN (fun),\n+\t     get_immediate_dominator (CDI_DOMINATORS,\n+\t\t\t\t      subgraph_nodes[0]));\n+  /* Every other block in the subgraph should be dominated by the\n+     initial block.  */\n+  for (int i = 1; i < n; i++)\n+    ASSERT_EQ (subgraph_nodes[0],\n+\t       get_immediate_dominator (CDI_DOMINATORS,\n+\t\t\t\t\tsubgraph_nodes[i]));\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  /* Similarly for post-dominance.  */\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  /* The initial block in the subgraph should be postdominated by EXIT.  */\n+  ASSERT_EQ (EXIT_BLOCK_PTR_FOR_FN (fun),\n+\t     get_immediate_dominator (CDI_POST_DOMINATORS,\n+\t\t\t\t      subgraph_nodes[0]));\n+  /* Every other block in the subgraph should be postdominated by the\n+     initial block, since that leads to EXIT.  */\n+  for (int i = 1; i < n; i++)\n+    ASSERT_EQ (subgraph_nodes[0],\n+\t       get_immediate_dominator (CDI_POST_DOMINATORS,\n+\t\t\t\t\tsubgraph_nodes[i]));\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  pop_cfun ();\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+tree_cfg_c_tests ()\n+{\n+  test_linear_chain ();\n+  test_diamond ();\n+  test_fully_connected ();\n+}\n+\n+} // namespace selftest\n+\n+/* TODO: test the dominator/postdominator logic with various graphs/nodes:\n+   - loop\n+   - nested loops\n+   - switch statement (a block with many out-edges)\n+   - something that jumps to itself\n+   - etc  */\n+\n+#endif /* CHECKING_P */"}, {"sha": "fd0e6921bfd754c0cf9e6bd01f39b432166a6dfa", "filename": "gcc/tree.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"print-tree.h\"\n #include \"ipa-utils.h\"\n+#include \"selftest.h\"\n \n /* Tree code classes.  */\n \n@@ -14203,4 +14204,65 @@ combined_fn_name (combined_fn fn)\n     return internal_fn_name (as_internal_fn (fn));\n }\n \n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for tree.  */\n+\n+/* Verify that integer constants are sane.  */\n+\n+static void\n+test_integer_constants ()\n+{\n+  ASSERT_TRUE (integer_type_node != NULL);\n+  ASSERT_TRUE (build_int_cst (integer_type_node, 0) != NULL);\n+\n+  tree type = integer_type_node;\n+\n+  tree zero = build_zero_cst (type);\n+  ASSERT_EQ (INTEGER_CST, TREE_CODE (zero));\n+  ASSERT_EQ (type, TREE_TYPE (zero));\n+\n+  tree one = build_int_cst (type, 1);\n+  ASSERT_EQ (INTEGER_CST, TREE_CODE (one));\n+  ASSERT_EQ (type, TREE_TYPE (zero));\n+}\n+\n+/* Verify identifiers.  */\n+\n+static void\n+test_identifiers ()\n+{\n+  tree identifier = get_identifier (\"foo\");\n+  ASSERT_EQ (3, IDENTIFIER_LENGTH (identifier));\n+  ASSERT_STREQ (\"foo\", IDENTIFIER_POINTER (identifier));\n+}\n+\n+/* Verify LABEL_DECL.  */\n+\n+static void\n+test_labels ()\n+{\n+  tree identifier = get_identifier (\"err\");\n+  tree label_decl = build_decl (UNKNOWN_LOCATION, LABEL_DECL,\n+\t\t\t\tidentifier, void_type_node);\n+  ASSERT_EQ (-1, LABEL_DECL_UID (label_decl));\n+  ASSERT_FALSE (FORCED_LABEL (label_decl));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+tree_c_tests ()\n+{\n+  test_integer_constants ();\n+  test_identifiers ();\n+  test_labels ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* CHECKING_P */\n+\n #include \"gt-tree.h\""}, {"sha": "fd200ea904bfc0414e88ff7bb9fc0174bcd1ed26", "filename": "gcc/vec.c", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"hash-table.h\"\n+#include \"selftest.h\"\n \n /* vNULL is an empty type with a template cast operation that returns\n    a zero-initialized vec<T, A, L> instance.  Use this when you want\n@@ -188,3 +189,194 @@ dump_vec_loc_statistics (void)\n {\n   vec_mem_desc.dump (VEC_ORIGIN);\n }\n+\n+#ifndef GENERATOR_FILE\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests.  */\n+\n+/* Call V.safe_push for all ints from START up to, but not including LIMIT.\n+   Helper function for selftests.  */\n+\n+static void\n+safe_push_range (vec <int>&v, int start, int limit)\n+{\n+  for (int i = start; i < limit; i++)\n+    v.safe_push (i);\n+}\n+\n+/* Verify that vec::quick_push works correctly.  */\n+\n+static void\n+test_quick_push ()\n+{\n+  auto_vec <int> v;\n+  ASSERT_EQ (0, v.length ());\n+  v.reserve (3);\n+  ASSERT_EQ (0, v.length ());\n+  ASSERT_TRUE (v.space (3));\n+  v.quick_push (5);\n+  v.quick_push (6);\n+  v.quick_push (7);\n+  ASSERT_EQ (3, v.length ());\n+  ASSERT_EQ (5, v[0]);\n+  ASSERT_EQ (6, v[1]);\n+  ASSERT_EQ (7, v[2]);\n+}\n+\n+/* Verify that vec::safe_push works correctly.  */\n+\n+static void\n+test_safe_push ()\n+{\n+  auto_vec <int> v;\n+  ASSERT_EQ (0, v.length ());\n+  v.safe_push (5);\n+  v.safe_push (6);\n+  v.safe_push (7);\n+  ASSERT_EQ (3, v.length ());\n+  ASSERT_EQ (5, v[0]);\n+  ASSERT_EQ (6, v[1]);\n+  ASSERT_EQ (7, v[2]);\n+}\n+\n+/* Verify that vec::truncate works correctly.  */\n+\n+static void\n+test_truncate ()\n+{\n+  auto_vec <int> v;\n+  ASSERT_EQ (0, v.length ());\n+  safe_push_range (v, 0, 10);\n+  ASSERT_EQ (10, v.length ());\n+\n+  v.truncate (5);\n+  ASSERT_EQ (5, v.length ());\n+}\n+\n+/* Verify that vec::safe_grow_cleared works correctly.  */\n+\n+static void\n+test_safe_grow_cleared ()\n+{\n+  auto_vec <int> v;\n+  ASSERT_EQ (0, v.length ());\n+  v.safe_grow_cleared (50);\n+  ASSERT_EQ (50, v.length ());\n+  ASSERT_EQ (0, v[0]);\n+  ASSERT_EQ (0, v[49]);\n+}\n+\n+/* Verify that vec::pop works correctly.  */\n+\n+static void\n+test_pop ()\n+{\n+  auto_vec <int> v;\n+  safe_push_range (v, 5, 20);\n+  ASSERT_EQ (15, v.length ());\n+\n+  int last = v.pop ();\n+  ASSERT_EQ (19, last);\n+  ASSERT_EQ (14, v.length ());\n+}\n+\n+/* Verify that vec::safe_insert works correctly.  */\n+\n+static void\n+test_safe_insert ()\n+{\n+  auto_vec <int> v;\n+  safe_push_range (v, 0, 10);\n+  v.safe_insert (5, 42);\n+  ASSERT_EQ (4, v[4]);\n+  ASSERT_EQ (42, v[5]);\n+  ASSERT_EQ (5, v[6]);\n+  ASSERT_EQ (11, v.length ());\n+}\n+\n+/* Verify that vec::ordered_remove works correctly.  */\n+\n+static void\n+test_ordered_remove ()\n+{\n+  auto_vec <int> v;\n+  safe_push_range (v, 0, 10);\n+  v.ordered_remove (5);\n+  ASSERT_EQ (4, v[4]);\n+  ASSERT_EQ (6, v[5]);\n+  ASSERT_EQ (9, v.length ());\n+}\n+\n+/* Verify that vec::unordered_remove works correctly.  */\n+\n+static void\n+test_unordered_remove ()\n+{\n+  auto_vec <int> v;\n+  safe_push_range (v, 0, 10);\n+  v.unordered_remove (5);\n+  ASSERT_EQ (9, v.length ());\n+}\n+\n+/* Verify that vec::block_remove works correctly.  */\n+\n+static void\n+test_block_remove ()\n+{\n+  auto_vec <int> v;\n+  safe_push_range (v, 0, 10);\n+  v.block_remove (5, 3);\n+  ASSERT_EQ (3, v[3]);\n+  ASSERT_EQ (4, v[4]);\n+  ASSERT_EQ (8, v[5]);\n+  ASSERT_EQ (9, v[6]);\n+  ASSERT_EQ (7, v.length ());\n+}\n+\n+/* Comparator for use by test_qsort.  */\n+\n+static int\n+reverse_cmp (const void *p_i, const void *p_j)\n+{\n+  return *(const int *)p_j - *(const int *)p_i;\n+}\n+\n+/* Verify that vec::qsort works correctly.  */\n+\n+static void\n+test_qsort ()\n+{\n+  auto_vec <int> v;\n+  safe_push_range (v, 0, 10);\n+  v.qsort (reverse_cmp);\n+  ASSERT_EQ (9, v[0]);\n+  ASSERT_EQ (8, v[1]);\n+  ASSERT_EQ (1, v[8]);\n+  ASSERT_EQ (0, v[9]);\n+  ASSERT_EQ (10, v.length ());\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+vec_c_tests ()\n+{\n+  test_quick_push ();\n+  test_safe_push ();\n+  test_truncate ();\n+  test_safe_grow_cleared ();\n+  test_pop ();\n+  test_safe_insert ();\n+  test_ordered_remove ();\n+  test_unordered_remove ();\n+  test_block_remove ();\n+  test_qsort ();\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */\n+#endif /* #ifndef GENERATOR_FILE */"}, {"sha": "30d355fdb8914fa9dca142a7eb72e3ab765e7098", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b950dd440fe2029a111cda56add2c9e91123b9/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=d9b950dd440fe2029a111cda56add2c9e91123b9", "patch": "@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"tree.h\"\n+#include \"selftest.h\"\n+#include \"wide-int-print.h\"\n \n \n #define HOST_BITS_PER_HALF_WIDE_INT 32\n@@ -2144,3 +2146,171 @@ template void generic_wide_int <wide_int_ref_storage <false> >::dump () const;\n template void generic_wide_int <wide_int_ref_storage <true> >::dump () const;\n template void offset_int::dump () const;\n template void widest_int::dump () const;\n+\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* Selftests for wide ints.  We run these multiple times, once per type.  */\n+\n+/* Helper function for building a test value.  */\n+\n+template <class VALUE_TYPE>\n+static VALUE_TYPE\n+from_int (int i);\n+\n+/* Specializations of the fixture for each wide-int type.  */\n+\n+/* Specialization for VALUE_TYPE == wide_int.  */\n+\n+template <>\n+wide_int\n+from_int (int i)\n+{\n+  return wi::shwi (i, 32);\n+}\n+\n+/* Specialization for VALUE_TYPE == offset_int.  */\n+\n+template <>\n+offset_int\n+from_int (int i)\n+{\n+  return offset_int (i);\n+}\n+\n+/* Specialization for VALUE_TYPE == widest_int.  */\n+\n+template <>\n+widest_int\n+from_int (int i)\n+{\n+  return widest_int (i);\n+}\n+\n+/* Verify that print_dec (WI, ..., SGN) gives the expected string\n+   representation (using base 10).  */\n+\n+static void\n+assert_deceq (const char *expected, const wide_int_ref &wi, signop sgn)\n+{\n+  char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+  print_dec (wi, buf, sgn);\n+  ASSERT_STREQ (expected, buf);\n+}\n+\n+/* Likewise for base 16.  */\n+\n+static void\n+assert_hexeq (const char *expected, const wide_int_ref &wi)\n+{\n+  char buf[WIDE_INT_PRINT_BUFFER_SIZE];\n+  print_hex (wi, buf);\n+  ASSERT_STREQ (expected, buf);\n+}\n+\n+/* Test cases.  */\n+\n+/* Verify that print_dec and print_hex work for VALUE_TYPE.  */\n+\n+template <class VALUE_TYPE>\n+static void\n+test_printing ()\n+{\n+  VALUE_TYPE a = from_int<VALUE_TYPE> (42);\n+  assert_deceq (\"42\", a, SIGNED);\n+  assert_hexeq (\"0x2a\", a);\n+}\n+\n+/* Verify that various operations work correctly for VALUE_TYPE,\n+   unary and binary, using both function syntax, and\n+   overloaded-operators.  */\n+\n+template <class VALUE_TYPE>\n+static void\n+test_ops ()\n+{\n+  VALUE_TYPE a = from_int<VALUE_TYPE> (7);\n+  VALUE_TYPE b = from_int<VALUE_TYPE> (3);\n+\n+  /* Using functions.  */\n+  assert_deceq (\"-7\", wi::neg (a), SIGNED);\n+  assert_deceq (\"10\", wi::add (a, b), SIGNED);\n+  assert_deceq (\"4\", wi::sub (a, b), SIGNED);\n+  assert_deceq (\"-4\", wi::sub (b, a), SIGNED);\n+  assert_deceq (\"21\", wi::mul (a, b), SIGNED);\n+\n+  /* Using operators.  */\n+  assert_deceq (\"-7\", -a, SIGNED);\n+  assert_deceq (\"10\", a + b, SIGNED);\n+  assert_deceq (\"4\", a - b, SIGNED);\n+  assert_deceq (\"-4\", b - a, SIGNED);\n+  assert_deceq (\"21\", a * b, SIGNED);\n+}\n+\n+/* Verify that various comparisons work correctly for VALUE_TYPE.  */\n+\n+template <class VALUE_TYPE>\n+static void\n+test_comparisons ()\n+{\n+  VALUE_TYPE a = from_int<VALUE_TYPE> (7);\n+  VALUE_TYPE b = from_int<VALUE_TYPE> (3);\n+\n+  /* == */\n+  ASSERT_TRUE (wi::eq_p (a, a));\n+  ASSERT_FALSE (wi::eq_p (a, b));\n+\n+  /* != */\n+  ASSERT_TRUE (wi::ne_p (a, b));\n+  ASSERT_FALSE (wi::ne_p (a, a));\n+\n+  /* < */\n+  ASSERT_FALSE (wi::lts_p (a, a));\n+  ASSERT_FALSE (wi::lts_p (a, b));\n+  ASSERT_TRUE (wi::lts_p (b, a));\n+\n+  /* <= */\n+  ASSERT_TRUE (wi::les_p (a, a));\n+  ASSERT_FALSE (wi::les_p (a, b));\n+  ASSERT_TRUE (wi::les_p (b, a));\n+\n+  /* > */\n+  ASSERT_FALSE (wi::gts_p (a, a));\n+  ASSERT_TRUE (wi::gts_p (a, b));\n+  ASSERT_FALSE (wi::gts_p (b, a));\n+\n+  /* >= */\n+  ASSERT_TRUE (wi::ges_p (a, a));\n+  ASSERT_TRUE (wi::ges_p (a, b));\n+  ASSERT_FALSE (wi::ges_p (b, a));\n+\n+  /* comparison */\n+  ASSERT_EQ (-1, wi::cmps (b, a));\n+  ASSERT_EQ (0, wi::cmps (a, a));\n+  ASSERT_EQ (1, wi::cmps (a, b));\n+}\n+\n+/* Run all of the selftests, using the given VALUE_TYPE.  */\n+\n+template <class VALUE_TYPE>\n+static void run_all_wide_int_tests ()\n+{\n+  test_printing <VALUE_TYPE> ();\n+  test_ops <VALUE_TYPE> ();\n+  test_comparisons <VALUE_TYPE> ();\n+}\n+\n+/* Run all of the selftests within this file, for all value types.  */\n+\n+void\n+wide_int_cc_tests ()\n+{\n+ run_all_wide_int_tests <wide_int> ();\n+ run_all_wide_int_tests <offset_int> ();\n+ run_all_wide_int_tests <widest_int> ();\n+}\n+\n+} // namespace selftest\n+#endif /* CHECKING_P */"}]}