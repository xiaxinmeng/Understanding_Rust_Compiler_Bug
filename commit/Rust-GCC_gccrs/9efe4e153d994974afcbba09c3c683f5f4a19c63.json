{"sha": "9efe4e153d994974afcbba09c3c683f5f4a19c63", "node_id": "C_kwDOANBUbNoAKDllZmU0ZTE1M2Q5OTQ5NzRhZmNiYmEwOWMzYzY4M2Y1ZjRhMTljNjM", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-07-26T15:02:21Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-07-31T02:56:36Z"}, "message": "c++: constexpr, empty base after non-empty [PR106369]\n\nHere the CONSTRUCTOR we were providing for D{} had an entry for the B base\nsubobject at offset 0 following the entry for the C base, causing\noutput_constructor_regular_field to ICE due to going backwards.  It might be\nnice for that function to be more tolerant of empty fields, but it also\nseems reasonable for the front end to prune the useless entry.\n\n\tPR c++/106369\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (reduced_constant_expression_p): Return false\n\tif a CONSTRUCTOR initializes an empty field.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/constexpr-lambda27.C: New test.", "tree": {"sha": "fb0fb733b166e3c5c6215b2366dc0fc3c63827b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb0fb733b166e3c5c6215b2366dc0fc3c63827b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9efe4e153d994974afcbba09c3c683f5f4a19c63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9efe4e153d994974afcbba09c3c683f5f4a19c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9efe4e153d994974afcbba09c3c683f5f4a19c63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9efe4e153d994974afcbba09c3c683f5f4a19c63/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ef2c9aa5b351efa9b751de4f10180427cd0fe70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ef2c9aa5b351efa9b751de4f10180427cd0fe70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ef2c9aa5b351efa9b751de4f10180427cd0fe70"}], "stats": {"total": 34, "additions": 33, "deletions": 1}, "files": [{"sha": "5e0d3399172202b5d68386b5132bd08ce0e4bebd", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9efe4e153d994974afcbba09c3c683f5f4a19c63/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9efe4e153d994974afcbba09c3c683f5f4a19c63/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=9efe4e153d994974afcbba09c3c683f5f4a19c63", "patch": "@@ -3081,7 +3081,13 @@ reduced_constant_expression_p (tree t)\n \t     element.  */\n \t  if (!reduced_constant_expression_p (e.value))\n \t    return false;\n-\t  /* Empty class field may or may not have an initializer.  */\n+\t  /* We want to remove initializers for empty fields in a struct to\n+\t     avoid confusing output_constructor.  */\n+\t  if (is_empty_field (e.index)\n+\t      && TREE_CODE (TREE_TYPE (t)) == RECORD_TYPE)\n+\t    return false;\n+\t  /* Check for non-empty fields between initialized fields when\n+\t     CONSTRUCTOR_NO_CLEARING.  */\n \t  for (; field && e.index != field;\n \t       field = next_subobject_field (DECL_CHAIN (field)))\n \t    if (!is_really_empty_class (TREE_TYPE (field),"}, {"sha": "24e2e9b6c989e50325e5d782f0231b587a3bbe46", "filename": "gcc/testsuite/g++.dg/cpp1z/constexpr-lambda27.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9efe4e153d994974afcbba09c3c683f5f4a19c63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9efe4e153d994974afcbba09c3c683f5f4a19c63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fconstexpr-lambda27.C?ref=9efe4e153d994974afcbba09c3c683f5f4a19c63", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/106369\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  int a[256];\n+  constexpr int &operator[] (int n) noexcept { return a[n]; }\n+  constexpr const int &operator[] (int n) const noexcept { return a[n]; }\n+};\n+struct B {};\n+template <typename T>\n+struct C {\n+  constexpr T &foo (const char x) noexcept { c = T::d[x]; return static_cast<T &>(*this); }\n+  int c;\n+};\n+struct D : public C<D>, public B\n+{\n+  D () noexcept = default;\n+  static constexpr char e[9] { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I' };\n+  static constexpr A d = [] () constexpr {\n+    A f {};\n+    for (int i = 0; i < 9; ++i)\n+      f[e[i]] = 1;\n+    return f;\n+  } ();\n+};\n+constexpr auto g = D{}.foo ('E');"}]}