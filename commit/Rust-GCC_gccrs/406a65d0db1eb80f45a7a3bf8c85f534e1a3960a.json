{"sha": "406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA2YTY1ZDBkYjFlYjgwZjQ1YTdhM2JmOGM4NWY1MzRlMWEzOTYwYQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-07-12T00:48:02Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-07-12T00:48:02Z"}, "message": "diagnostic.c (save_output_state): Remove.\n\n2000-07-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n\t* diagnostic.c (save_output_state): Remove.\n\t(restore_output_state): Likewise.\n\t(clear_text_info): New function.\n\t(clear_diagnostic_info): Likewise.\n\t(output_text_length, is_starting_newline, output_prefix,\n\tline_wrap_cutoff, ideal_line_wrap_cutoff, prefix_was_emitted_for,\n\tprefixing_policy, output_buffer_ptr_to_format_args): New macros\n\t(set_real_maximum_length, output_set_maximum_length,\n\toutput_set_prefix, output_get_prefix, output_set_maximum_length,\n\toutput_destroy_prefix, init_output_buffer,\n\treshape_diagnostic_buffer, output_space_left, output_emit_prefix,\n\toutput_add_newline, output_add_character, output_add_space,\n\toutput_append_r, output_append, wrap_text, output_format,\n\toutput_do_printf, output_printf, output_do_verbatim,\n\toutput_verbatim, verbatim): Use them.\n\t(output_clear): Split into cleat_text_info and\n\tclear_diagnostic_info.\n\t(struct output_state): Move to...\n\n\t* diagnostic.h: ...Here\n\t(struct output_buffer): Adjust.\n\nFrom-SVN: r34975", "tree": {"sha": "c38523617f116875125b603865e8c328df959454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c38523617f116875125b603865e8c328df959454"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/comments", "author": null, "committer": null, "parents": [{"sha": "7bb41c5a6ab011b1e2d24481b3cf8e839ea597af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bb41c5a6ab011b1e2d24481b3cf8e839ea597af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bb41c5a6ab011b1e2d24481b3cf8e839ea597af"}], "stats": {"total": 364, "additions": 190, "deletions": 174}, "files": [{"sha": "16ba4b332801061b77af8d297078ccd581ed1678", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "patch": "@@ -1,3 +1,27 @@\n+2000-07-12  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* diagnostic.c (save_output_state): Remove.\n+\t(restore_output_state): Likewise.\n+\t(clear_text_info): New function.\n+\t(clear_diagnostic_info): Likewise.\n+\t(output_text_length, is_starting_newline, output_prefix,\n+\tline_wrap_cutoff, ideal_line_wrap_cutoff, prefix_was_emitted_for,\n+\tprefixing_policy, output_buffer_ptr_to_format_args): New macros\n+\t(set_real_maximum_length, output_set_maximum_length,\n+\toutput_set_prefix, output_get_prefix, output_set_maximum_length, \n+\toutput_destroy_prefix, init_output_buffer,\n+\treshape_diagnostic_buffer, output_space_left, output_emit_prefix,\n+\toutput_add_newline, output_add_character, output_add_space,\n+\toutput_append_r, output_append, wrap_text, output_format,\n+\toutput_do_printf, output_printf, output_do_verbatim,\n+\toutput_verbatim, verbatim): Use them.\n+\t(output_clear): Split into cleat_text_info and\n+\tclear_diagnostic_info.\n+\t(struct output_state): Move to...\n+\n+\t* diagnostic.h: ...Here\n+\t(struct output_buffer): Adjust. \n+\t\n 2000-07-11  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpplex.c (parse_name): No longer inline (premature optimization)."}, {"sha": "6e95e560c87ebcca80cde29cee8c655409b6f14d", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 138, "deletions": 153, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "patch": "@@ -1,5 +1,6 @@\n /* Language-independent diagnostic subroutines for the GNU C compiler\n    Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n This file is part of GNU CC.\n \n@@ -42,27 +43,23 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free  free\n \n-#define diagnostic_args diagnostic_buffer->format_args\n-#define diagnostic_msg diagnostic_buffer->cursor\n-\n #define output_formatted_integer(BUFFER, FORMAT, INTEGER) \\\n   do {                                                    \\\n     sprintf (digit_buffer, FORMAT, INTEGER);              \\\n     output_add_string (BUFFER, digit_buffer);             \\\n   } while (0)\n \n-/* This data structure serves to save/restore an output_buffer state.  */\n-typedef struct\n-{\n-  const char *prefix;\n-  int maximum_length;\n-  int ideal_maximum_length;\n-  int emitted_prefix_p;\n-  int prefixing_rule;\n-  const char *cursor;\n-  va_list format_args;\n-} output_state;\n+#define output_text_length(BUFFER) (BUFFER)->line_length\n+#define is_starting_newline(BUFFER) (output_text_length (BUFFER) == 0)\n+#define output_prefix(BUFFER) (BUFFER)->state.prefix\n+#define line_wrap_cutoff(BUFFER) (BUFFER)->state.maximum_length\n+#define ideal_line_wrap_cutoff(BUFFER) (BUFFER)->state.ideal_maximum_length\n+#define prefix_was_emitted_for(BUFFER) (BUFFER)->state.emitted_prefix_p\n+#define prefixing_policy(BUFFER) (BUFFER)->state.prefixing_rule\n+#define output_buffer_ptr_to_format_args(BUFFER) (BUFFER)->state.format_args\n \n+#define diagnostic_args output_buffer_ptr_to_format_args (diagnostic_buffer)\n+#define diagnostic_msg output_buffer_text_cursor (diagnostic_buffer)\n \n /* Prototypes. */\n static int doing_line_wrapping PARAMS ((void));\n@@ -104,10 +101,6 @@ static void vsorry PARAMS ((const char *, va_list));\n static void report_file_and_line PARAMS ((const char *, int, int));\n static void vnotice PARAMS ((FILE *, const char *, va_list));\n static void set_real_maximum_length PARAMS ((output_buffer *));\n-\n-static void save_output_state PARAMS ((const output_buffer *, output_state *));\n-static void restore_output_state PARAMS ((const output_state *,\n-                                          output_buffer *));\n                                           \n static void output_unsigned_decimal PARAMS ((output_buffer *, unsigned int));\n static void output_long_decimal PARAMS ((output_buffer *, long int));\n@@ -122,6 +115,8 @@ static void output_append_r PARAMS ((output_buffer *, const char *, int));\n static void wrap_text PARAMS ((output_buffer *, const char *, const char *));\n static void maybe_wrap_text PARAMS ((output_buffer *, const char *,\n                                      const char *));\n+static void clear_text_info PARAMS ((output_buffer *));\n+static void clear_diagnostic_info PARAMS ((output_buffer *));\n \n extern int rtl_dump_and_exit;\n extern int inhibit_warnings;\n@@ -197,15 +192,15 @@ int\n output_is_line_wrapping (buffer)\n      output_buffer *buffer;\n {\n-  return buffer->ideal_maximum_length > 0;\n+  return ideal_line_wrap_cutoff (buffer) > 0;\n }\n \n /* Return BUFFER's prefix.  */\n const char *\n output_get_prefix (buffer)\n      const output_buffer *buffer;\n {\n-  return buffer->prefix;\n+  return output_prefix (buffer);\n }\n \n /* Subroutine of output_set_maximum_length.  Set up BUFFER's\n@@ -216,16 +211,17 @@ set_real_maximum_length (buffer)\n {\n   /* If we're told not to wrap lines then do the obvious thing.  */\n   if (! output_is_line_wrapping (buffer))\n-    buffer->maximum_length = buffer->ideal_maximum_length;\n+    line_wrap_cutoff (buffer) = ideal_line_wrap_cutoff (buffer);\n   else\n     {\n-      int prefix_length = buffer->prefix ? strlen (buffer->prefix) : 0;\n+      int prefix_length =\n+        output_prefix (buffer) ? strlen (output_prefix (buffer)) : 0;\n       /* If the prefix is ridiculously too long, output at least\n          32 characters.  */\n-      if (buffer->ideal_maximum_length - prefix_length < 32)\n-        buffer->maximum_length = buffer->ideal_maximum_length + 32;\n+      if (ideal_line_wrap_cutoff (buffer) - prefix_length < 32)\n+        line_wrap_cutoff (buffer) = ideal_line_wrap_cutoff (buffer) + 32;\n       else\n-        buffer->maximum_length = buffer->ideal_maximum_length;\n+        line_wrap_cutoff (buffer) = ideal_line_wrap_cutoff (buffer);\n     }\n }\n \n@@ -236,7 +232,7 @@ output_set_maximum_length (buffer, length)\n      output_buffer *buffer;\n      int length;\n {\n-  buffer->ideal_maximum_length = length;\n+ ideal_line_wrap_cutoff (buffer) = length;\n   set_real_maximum_length (buffer);\n }\n \n@@ -246,9 +242,9 @@ output_set_prefix (buffer, prefix)\n      output_buffer *buffer;\n      const char *prefix;\n {\n-  buffer->prefix = prefix;\n+  output_prefix (buffer) = prefix;\n   set_real_maximum_length (buffer);\n-  buffer->emitted_prefix_p = 0;\n+  prefix_was_emitted_for (buffer) = 0;\n }\n \n /* Free BUFFER's prefix, a previously malloc()'d string.  */\n@@ -257,13 +253,32 @@ void\n output_destroy_prefix (buffer)\n      output_buffer *buffer;\n {\n-  if (buffer->prefix)\n+  if (output_prefix (buffer) != NULL)\n     {\n-      free ((char *) buffer->prefix);\n-      buffer->prefix = NULL;\n+      free ((char *) output_prefix (buffer));\n+      output_prefix (buffer) = NULL;\n     }\n }\n \n+/* Zero out any text output so far in BUFFER.  */\n+static void\n+clear_text_info (buffer)\n+     output_buffer *buffer;\n+{\n+  obstack_free (&buffer->obstack, obstack_base (&buffer->obstack));\n+  output_text_length (buffer) = 0;\n+}\n+\n+/* Zero out any diagnostic data used so far by BUFFER.  */\n+static void\n+clear_diagnostic_info (buffer)\n+     output_buffer *buffer;\n+{\n+  output_buffer_text_cursor (buffer) = NULL;\n+  output_buffer_ptr_to_format_args (buffer) = NULL;\n+  prefix_was_emitted_for (buffer) = 0;\n+}\n+\n /* Construct an output BUFFER with PREFIX and of MAXIMUM_LENGTH\n    characters per line.  */\n void\n@@ -273,13 +288,11 @@ init_output_buffer (buffer, prefix, maximum_length)\n      int maximum_length;\n {\n   obstack_init (&buffer->obstack);\n-  buffer->ideal_maximum_length = maximum_length;\n-  buffer->line_length = 0;\n+  ideal_line_wrap_cutoff (buffer) = maximum_length;\n+  prefixing_policy (buffer) = current_prefixing_rule;\n   output_set_prefix (buffer, prefix);\n-  buffer->emitted_prefix_p = 0;\n-  buffer->prefixing_rule = current_prefixing_rule;\n-  \n-  buffer->cursor = NULL;\n+  output_text_length (buffer) = 0;\n+  clear_diagnostic_info (buffer);  \n }\n \n /* Initialize BUFFER with a NULL prefix and current diagnostic message\n@@ -296,8 +309,9 @@ default_initialize_buffer (buffer)\n void\n reshape_diagnostic_buffer ()\n {\n-  diagnostic_buffer->ideal_maximum_length = diagnostic_message_length_per_line;\n-  diagnostic_buffer->prefixing_rule = current_prefixing_rule;\n+  ideal_line_wrap_cutoff (diagnostic_buffer) =\n+    diagnostic_message_length_per_line;\n+  prefixing_policy (diagnostic_buffer) = current_prefixing_rule;\n   set_real_maximum_length (diagnostic_buffer);\n }\n \n@@ -306,10 +320,8 @@ void\n output_clear (buffer)\n      output_buffer *buffer;\n {\n-  obstack_free (&buffer->obstack, obstack_base (&buffer->obstack));\n-  buffer->line_length = 0;\n-  buffer->cursor = NULL;\n-  buffer->emitted_prefix_p = 0;\n+  clear_text_info (buffer);\n+  clear_diagnostic_info (buffer);\n }\n \n /* Finishes to construct a NULL-terminated character string representing\n@@ -328,33 +340,33 @@ int\n output_space_left (buffer)\n      const output_buffer *buffer;\n {\n-  return buffer->maximum_length - buffer->line_length;\n+  return line_wrap_cutoff (buffer) - output_text_length (buffer);\n }\n \n /* Write out BUFFER's prefix.  */\n void\n output_emit_prefix (buffer)\n      output_buffer *buffer;\n {\n-  if (buffer->prefix)\n+  if (output_prefix (buffer) != NULL)\n     {\n-      switch (buffer->prefixing_rule)\n+      switch (prefixing_policy (buffer))\n         {\n         default:\n         case DIAGNOSTICS_SHOW_PREFIX_NEVER:\n           break;\n \n         case DIAGNOSTICS_SHOW_PREFIX_ONCE:\n-          if (buffer->emitted_prefix_p)\n+          if (prefix_was_emitted_for (buffer))\n             break;\n-          else\n-            buffer->emitted_prefix_p = 1;\n-          /* Fall through.  */\n+          /* Else fall through.  */\n \n         case DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE:\n-          buffer->line_length += strlen (buffer->prefix);\n-          obstack_grow\n-            (&buffer->obstack, buffer->prefix, buffer->line_length);\n+          {\n+            int prefix_length = strlen (output_prefix (buffer));\n+            output_append_r (buffer, output_prefix (buffer), prefix_length);\n+            prefix_was_emitted_for (buffer) = 1;\n+          }\n           break;\n         }\n     }\n@@ -366,7 +378,7 @@ output_add_newline (buffer)\n      output_buffer *buffer;\n {\n   obstack_1grow (&buffer->obstack, '\\n');\n-  buffer->line_length = 0;\n+  output_text_length (buffer) = 0;\n }\n \n /* Appends a character to BUFFER.  */\n@@ -378,7 +390,7 @@ output_add_character (buffer, c)\n   if (output_is_line_wrapping (buffer) && output_space_left (buffer) <= 0)\n     output_add_newline (buffer);\n   obstack_1grow (&buffer->obstack, c);\n-  ++buffer->line_length;\n+  ++output_text_length (buffer);\n }\n \n /* Adds a space to BUFFER.  */\n@@ -392,7 +404,7 @@ output_add_space (buffer)\n       return;\n     }\n   obstack_1grow (&buffer->obstack, ' ');\n-  ++buffer->line_length;\n+  ++output_text_length (buffer);\n }\n \n /* These functions format an INTEGER into BUFFER as suggested by their\n@@ -470,12 +482,12 @@ output_append_r (buffer, start, length)\n      int length;\n {\n   obstack_grow (&buffer->obstack, start, length);\n-  buffer->line_length += length;\n+  output_text_length (buffer) += length;\n }\n \n /* Append a string deliminated by START and END to BUFFER.  No wrapping is\n-   done.  However, if beginning a new line then emit BUFFER->PREFIX and\n-   skip any leading whitespace if appropriate.  The caller must ensure\n+   done.  However, if beginning a new line then emit output_prefix (BUFFER)\n+   and skip any leading whitespace if appropriate.  The caller must ensure\n    that it is safe to do so.  */\n void\n output_append (buffer, start, end)\n@@ -484,7 +496,7 @@ output_append (buffer, start, end)\n      const char *end;\n {\n   /* Emit prefix and skip whitespace if we're starting a new line.  */\n-  if (buffer->line_length == 0)\n+  if (is_starting_newline (buffer))\n     {\n       output_emit_prefix (buffer);\n       if (output_is_line_wrapping (buffer))\n@@ -561,12 +573,12 @@ output_to_stream (buffer, file)\n {\n   const char *text = output_finish (buffer);\n   fputs (text, file);\n-  output_clear (buffer);\n+  clear_text_info (buffer);\n }\n \n-/* Format a message pointed to by BUFFER->CURSOR using BUFFER->CURSOR\n-   as appropriate.  The following format specifiers are recognized as\n-   being language independent:\n+/* Format a message pointed to by output_buffer_text_cursor (BUFFER) using\n+   output_buffer_format_args (BUFFER) as appropriate.  The following format\n+   specifiers are recognized as  being language independent:\n    %d, %i: (signed) integer in base ten.\n    %u: unsigned integer in base ten.\n    %o: (signed) integer in base eight.\n@@ -580,75 +592,85 @@ static void\n output_format (buffer)\n      output_buffer *buffer;\n {\n-  for (; *buffer->cursor; ++buffer->cursor)\n+  for (; *output_buffer_text_cursor (buffer);\n+       ++output_buffer_text_cursor (buffer))\n     {\n       int long_integer = 0;\n       /* Ignore text.  */\n       {\n-        const char *p = buffer->cursor;\n+        const char *p = output_buffer_text_cursor (buffer);\n         while (*p && *p != '%')\n           ++p;\n-        maybe_wrap_text (buffer, buffer->cursor, p);\n-        buffer->cursor = p;\n+        maybe_wrap_text (buffer, output_buffer_text_cursor (buffer), p);\n+        output_buffer_text_cursor (buffer) = p;\n       }\n-      if (!*buffer->cursor)\n+      if (!*output_buffer_text_cursor (buffer))\n         break;\n \n       /* We got a '%'.  Let's see what happens. Record whether we're\n          parsing a long integer format specifier.  */\n-      if (*++buffer->cursor == 'l')\n+      if (*++output_buffer_text_cursor (buffer) == 'l')\n         {\n           long_integer = 1;\n-          ++buffer->cursor;\n+          ++output_buffer_text_cursor (buffer);\n         }\n \n       /* Handle %c, %d, %i, %ld, %li, %lo, %lu, %lx, %o, %s, %u,\n          %x, %.*s; %%.  And nothing else.  Front-ends should install\n          printers to grok language specific format specifiers.  */\n-      switch (*buffer->cursor)\n+      switch (*output_buffer_text_cursor (buffer))\n         {\n         case 'c':\n           output_add_character\n-            (buffer, va_arg (buffer->format_args, int));\n+            (buffer, va_arg (output_buffer_format_args (buffer), int));\n           break;\n           \n         case 'd':\n         case 'i':\n           if (long_integer)\n             output_long_decimal\n-              (buffer, va_arg (buffer->format_args, long int));\n+              (buffer, va_arg (output_buffer_format_args (buffer), long int));\n           else\n-            output_decimal (buffer, va_arg (buffer->format_args, int));\n+            output_decimal\n+              (buffer, va_arg (output_buffer_format_args (buffer), int));\n           break;\n \n         case 'o':\n           if (long_integer)\n-            output_long_octal\n-              (buffer, va_arg (buffer->format_args, unsigned long int));\n+            output_long_octal (buffer,\n+                               va_arg (output_buffer_format_args (buffer),\n+                                       unsigned long int));\n           else\n-            output_octal (buffer, va_arg (buffer->format_args, unsigned int));\n+            output_octal (buffer,\n+                          va_arg (output_buffer_format_args (buffer),\n+                                  unsigned int));\n           break;\n \n         case 's':\n-          output_add_string\n-            (buffer, va_arg (buffer->format_args, const char *));\n+          output_add_string (buffer,\n+                             va_arg (output_buffer_format_args (buffer),\n+                                     const char *));\n           break;\n \n         case 'u':\n           if (long_integer)\n             output_long_unsigned_decimal\n-              (buffer, va_arg (buffer->format_args, long unsigned int));\n+              (buffer, va_arg (output_buffer_format_args (buffer),\n+                               long unsigned int));\n           else\n             output_unsigned_decimal\n-              (buffer, va_arg (buffer->format_args, unsigned int));\n+              (buffer, va_arg (output_buffer_format_args (buffer),\n+                               unsigned int));\n           \n         case 'x':\n           if (long_integer)\n             output_long_hexadecimal\n-              (buffer, va_arg (buffer->format_args, unsigned long int));\n+              (buffer, va_arg (output_buffer_format_args (buffer),\n+                               unsigned long int));\n           else\n             output_hexadecimal\n-              (buffer, va_arg (buffer->format_args, unsigned int));\n+              (buffer, va_arg (output_buffer_format_args (buffer),\n+                               unsigned int));\n           break;\n \n         case '%':\n@@ -660,12 +682,12 @@ output_format (buffer)\n             int n;\n             const char *s;\n             /* We handle no precision specifier but `%.*s'.  */\n-            if (*++buffer->cursor != '*')\n+            if (*++output_buffer_text_cursor (buffer) != '*')\n               abort ();\n-            else if (*++buffer->cursor != 's')\n+            else if (*++output_buffer_text_cursor (buffer) != 's')\n               abort();\n-            n = va_arg (buffer->format_args, int);\n-            s = va_arg (buffer->format_args, const char *);\n+            n = va_arg (output_buffer_format_args (buffer), int);\n+            s = va_arg (output_buffer_format_args (buffer), const char *);\n             output_append (buffer, s, s + n);\n           }\n           break;\n@@ -750,7 +772,8 @@ output_do_printf (buffer, msgid)\n      output_buffer *buffer;\n      const char *msgid;\n {\n-  char *message = vbuild_message_string (msgid, buffer->format_args);\n+  char *message = vbuild_message_string (msgid,\n+                                         output_buffer_format_args (buffer));\n \n   output_add_string (buffer, message);\n   free (message);\n@@ -767,20 +790,18 @@ output_printf VPARAMS ((struct output_buffer *buffer, const char *msgid, ...))\n   const char *msgid;\n #endif\n   va_list ap;\n-  va_list old_args;\n+  va_list *old_args;\n \n   VA_START (ap, msgid);\n #ifndef ANSI_PROTOTYPES\n-  buffer = va_arg (ap, struct output_buffer *);\n+  buffer = va_arg (ap, output_buffer *);\n   msgid = va_arg (ap, const char *);\n #endif\n-  va_copy (old_args, buffer->format_args);\n-\n-  va_copy (buffer->format_args, ap);\n+  old_args = output_buffer_ptr_to_format_args (buffer);\n+  output_buffer_ptr_to_format_args (buffer) = &ap;\n   output_do_printf (buffer, msgid);\n-  va_end (buffer->format_args);\n-\n-  va_copy (buffer->format_args, old_args);\n+  output_buffer_ptr_to_format_args (buffer) = old_args;\n+  va_end (ap);\n }\n \n \n@@ -794,20 +815,20 @@ line_wrapper_printf VPARAMS ((FILE *file, const char *msgid, ...))\n   FILE *file;\n   const char *msgid;\n #endif\n+  va_list ap;\n   output_buffer buffer;\n-  \n-  default_initialize_buffer (&buffer);\n-  VA_START (buffer.format_args, msgid);\n+\n+  VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  file = va_arg (buffer.format_args, FILE *);\n-  msgid = va_arg (buffer.format_args, const char *);\n+  file = va_arg (ap, FILE *);\n+  msgid = va_arg (ap, const char *);\n #endif  \n-\n+  default_initialize_buffer (&buffer);\n+  output_buffer_ptr_to_format_args (&buffer) = &ap;\n   output_do_printf (&buffer, msgid);\n   output_to_stream (&buffer, file);\n-\n-  va_end (buffer.format_args);\n+  va_end (ap);\n }\n \n \n@@ -823,12 +844,11 @@ vline_wrapper_message_with_location (file, line, warn, msgid, ap)\n   \n   init_output_buffer (&buffer, context_as_prefix (file, line, warn),\n \t\t      diagnostic_message_length_per_line);\n-  va_copy (buffer.format_args, ap);\n+  output_buffer_ptr_to_format_args (&buffer) = &ap;\n   output_do_printf (&buffer, msgid);\n   output_to_stream (&buffer, stderr);\n-\n-  output_destroy_prefix (&buffer);\n   fputc ('\\n', stderr);\n+  output_destroy_prefix (&buffer);\n }\n \n \n@@ -964,9 +984,8 @@ v_message_with_decl (decl, warn, msgid, ap)\n     {\n       if (doing_line_wrapping ())\n         {\n-\t  va_copy (buffer.format_args, ap);\n+          output_buffer_ptr_to_format_args (&buffer) = &ap;\n           output_do_printf (&buffer, p);\n-          va_copy (ap, buffer.format_args);\n         }\n       else\n         vfprintf (stderr, p, ap);\n@@ -1726,36 +1745,6 @@ warning VPARAMS ((const char *msgid, ...))\n   va_end (ap);\n }\n \n-/* Save BUFFER's STATE.  */\n-static void\n-save_output_state (buffer, state)\n-     const output_buffer *buffer;\n-     output_state *state;\n-{\n-  state->prefix = buffer->prefix;\n-  state->maximum_length = buffer->maximum_length;\n-  state->ideal_maximum_length = buffer->ideal_maximum_length;\n-  state->emitted_prefix_p = buffer->emitted_prefix_p;\n-  state->prefixing_rule = buffer->prefixing_rule;\n-  state->cursor = buffer->cursor;\n-  va_copy (state->format_args, buffer->format_args);\n-}\n-\n-/* Restore BUFFER's previously saved STATE.  */\n-static void\n-restore_output_state (state, buffer)\n-     const output_state *state;\n-     output_buffer *buffer;\n-{\n-  buffer->prefix = state->prefix;\n-  buffer->maximum_length = state->maximum_length;\n-  buffer->ideal_maximum_length = state->ideal_maximum_length;\n-  buffer->emitted_prefix_p = state->emitted_prefix_p;\n-  buffer->prefixing_rule = state->prefixing_rule;\n-  buffer->cursor = state->cursor;\n-  va_copy (buffer->format_args, state->format_args);\n-}\n-\n /* Flush diagnostic_buffer content on stderr.  */\n static void\n finish_diagnostic ()\n@@ -1773,17 +1762,15 @@ output_do_verbatim (buffer, msg, args)\n      const char *msg;\n      va_list args;\n {\n-  output_state os;\n+  output_state os = buffer->state;\n \n-  save_output_state (buffer, &os);\n-  buffer->prefix = NULL;\n-  buffer->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n-  buffer->cursor = msg;\n-  va_copy (buffer->format_args, args);\n+  output_prefix (buffer) = NULL;\n+  prefixing_policy (buffer) = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n+  output_buffer_text_cursor (buffer) = msg;\n+  output_buffer_ptr_to_format_args (buffer) = &args;\n   output_set_maximum_length (buffer, 0);\n   output_format (buffer);\n-  va_end (buffer->format_args);\n-  restore_output_state (&os, buffer);\n+  buffer->state = os;\n }\n \n /* Output MESSAGE verbatim into BUFFER.  */\n@@ -1837,11 +1824,10 @@ report_diagnostic (msg, args, file, line, warn)\n      int line;\n      int warn;\n {\n-  output_state os;\n+  output_state os = diagnostic_buffer->state;\n \n-  save_output_state (diagnostic_buffer, &os);\n   diagnostic_msg = msg;\n-  va_copy (diagnostic_args, args);\n+  diagnostic_args = &args;\n   if (count_error (warn))\n     {\n       report_error_function (file);\n@@ -1851,6 +1837,5 @@ report_diagnostic (msg, args, file, line, warn)\n       finish_diagnostic();\n       output_destroy_prefix (diagnostic_buffer);\n     }\n-  va_end (diagnostic_args);\n-  restore_output_state (&os, diagnostic_buffer);\n+  diagnostic_buffer->state = os;\n }"}, {"sha": "a81aa8abb80b50f7d062d85e8ed62426954e6f1d", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/406a65d0db1eb80f45a7a3bf8c85f534e1a3960a/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=406a65d0db1eb80f45a7a3bf8c85f534e1a3960a", "patch": "@@ -36,18 +36,11 @@ typedef struct output_buffer output_buffer;\n    everything goes well. */\n typedef int (*printer_fn) PARAMS ((output_buffer *));\n \n-/* The output buffer datatype.  This is best seen as an abstract datatype.  */\n-struct output_buffer\n+/* This data structure encapulates an output_buffer's state.  */\n+typedef struct\n {\n-  /* Internal data.  These fields should not be accessed directly by\n-     front-ends.  */\n-\n-  /* The obstack where the text is built up.  */  \n-  struct obstack obstack;\n   /* The prefix for each new line.   */\n   const char *prefix;\n-  /* The amount of characters output so far.  */  \n-  int line_length;\n   /* The real upper bound of number of characters per line, taking into\n      accompt the case of a very very looong prefix.  */  \n   int maximum_length;\n@@ -62,25 +55,39 @@ struct output_buffer\n      o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit current PREFIX each time\n        a physical line is started.  */\n   int prefixing_rule;\n-\n-  /* Public fields.  These are used by front-ends to extract formats and\n-     arguments from the variable argument-list passed to output_format.  */\n-\n   /* The current char to output.  Updated by front-end (*format_map) when\n      it is called to report front-end printer for a specified format.  */  \n   const char *cursor;\n-  /* Variable argument-list for formatting.  */  \n-  va_list format_args;\n+  /* A pointer to the variable argument-list for formatting.  */  \n+  va_list *format_args;\n+} output_state;\n+\n+/* The output buffer datatype.  This is best seen as an abstract datatype.  */\n+struct output_buffer\n+{\n+  /* Internal data.  These fields should not be accessed directly by\n+     front-ends.  */\n+\n+  /* The obstack where the text is built up.  */  \n+  struct obstack obstack;\n+  /* The amount of characters output so far.  */  \n+  int line_length;\n+  /* The current state of the buffer.  */\n+  output_state state;\n };\n \n-/* If non-NULL, this function formats data in the BUFFER.\n-   BUFFER->CURSOR points to a format code.  LANG_PRINTER should\n-   call output_add_string (and related functions) to add data to\n+#define output_buffer_text_cursor(BUFFER) (BUFFER)->state.cursor\n+#define output_buffer_format_args(BUFFER) *((BUFFER)->state.format_args)\n+\n+/* If non-NULL, this function formats data in the BUFFER. When called,\n+   output_buffer_text_cursor (BUFFER) points to a format code.  LANG_PRINTER\n+   should call output_add_string (and related functions) to add data to\n    the BUFFER.  LANG_PRINTER can read arguments from\n-   BUFFER->FORMAT_ARGS using VA_ARG.  If the BUFFER needs\n+   output_buffer_format_args (BUFFER) using VA_ARG.  If the BUFFER needs\n    additional characters from the format string, it should advance\n-   the BUFFER->CURSOR as it goes.  When LANG_PRINTER returns,\n-   BUFFER->CURSOR should point to the last character processed.  */\n+   the output_buffer_text_cursor (BUFFER) as it goes.  When LANG_PRINTER\n+   returns, output_buffer_text_cursor (BUFFER) should point to the last\n+   character processed.  */\n \n extern printer_fn lang_printer;\n "}]}