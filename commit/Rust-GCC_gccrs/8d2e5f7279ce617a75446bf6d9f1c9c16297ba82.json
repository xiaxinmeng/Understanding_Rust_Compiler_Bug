{"sha": "8d2e5f7279ce617a75446bf6d9f1c9c16297ba82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyZTVmNzI3OWNlNjE3YTc1NDQ2YmY2ZDlmMWM5YzE2Mjk3YmE4Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2003-07-13T23:21:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2003-07-13T23:21:23Z"}, "message": "expr.c (expand_expr, [...]): If reg...\n\n\t* expr.c (expand_expr, case COMPONENT_REF): If reg, copy OP0 to MEM\n\tboth if OFFSET specified and if result BLKmode for ARRAY_RANGE_REF.\n\nFrom-SVN: r69308", "tree": {"sha": "623cc0afc03bac4f2da57b9e8f91fc43b0d56eb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/623cc0afc03bac4f2da57b9e8f91fc43b0d56eb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82/comments", "author": null, "committer": null, "parents": [{"sha": "1116457a0df4a09fae9daffa1fa143748962f61c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1116457a0df4a09fae9daffa1fa143748962f61c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1116457a0df4a09fae9daffa1fa143748962f61c"}], "stats": {"total": 63, "additions": 35, "deletions": 28}, "files": [{"sha": "5fe687dba4d3182bffa09a20ef32e5e33a1c5a65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d2e5f7279ce617a75446bf6d9f1c9c16297ba82", "patch": "@@ -1,3 +1,8 @@\n+2003-07-13  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (expand_expr, case COMPONENT_REF): If reg, copy OP0 to MEM\n+\tboth if OFFSET specified and if result BLKmode for ARRAY_RANGE_REF.\n+\n 2003-07-13  Nathanael Nerode  <neroden@gcc.gnu.org>\n \n \tPR other/11123"}, {"sha": "1b7eab178d8291c883b745568a13c5d390f3b744", "filename": "gcc/expr.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2e5f7279ce617a75446bf6d9f1c9c16297ba82/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8d2e5f7279ce617a75446bf6d9f1c9c16297ba82", "patch": "@@ -7440,39 +7440,41 @@ expand_expr (tree exp, rtx target, enum machine_mode tmode, enum expand_modifier\n \t      op0 = validize_mem (force_const_mem (mode, op0));\n \t  }\n \n+ \t/* Otherwise, if this object not in memory and we either have an\n+ \t   offset or a BLKmode result, put it there.  This case can't occur in\n+ \t   C, but can in Ada if we have unchecked conversion of an expression\n+ \t   from a scalar type to an array or record type or for an\n+ \t   ARRAY_RANGE_REF whose type is BLKmode.  */\n+\telse if (GET_CODE (op0) != MEM\n+\t\t && (offset != 0\n+\t\t     || (code == ARRAY_RANGE_REF && mode == BLKmode)))\n+\t  {\n+\t    /* If the operand is a SAVE_EXPR, we can deal with this by\n+\t       forcing the SAVE_EXPR into memory.  */\n+\t    if (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR)\n+\t      {\n+\t\tput_var_into_stack (TREE_OPERAND (exp, 0),\n+\t\t\t\t    /*rescan=*/true);\n+\t\top0 = SAVE_EXPR_RTL (TREE_OPERAND (exp, 0));\n+\t      }\n+\t    else\n+\t      {\n+\t\ttree nt\n+\t\t  = build_qualified_type (TREE_TYPE (tem),\n+\t\t\t\t\t  (TYPE_QUALS (TREE_TYPE (tem))\n+\t\t\t\t\t   | TYPE_QUAL_CONST));\n+\t\trtx memloc = assign_temp (nt, 1, 1, 1);\n+\t\t\n+\t\temit_move_insn (memloc, op0);\n+\t\top0 = memloc;\n+\t      }\n+\t  }\n+\n \tif (offset != 0)\n \t  {\n \t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,\n \t\t\t\t\t  EXPAND_SUM);\n \n-\t    /* If this object is in a register, put it into memory.\n-\t       This case can't occur in C, but can in Ada if we have\n-\t       unchecked conversion of an expression from a scalar type to\n-\t       an array or record type.  */\n-\t    if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n-\t\t|| GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF)\n-\t      {\n-\t\t/* If the operand is a SAVE_EXPR, we can deal with this by\n-\t\t   forcing the SAVE_EXPR into memory.  */\n-\t\tif (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR)\n-\t\t  {\n-\t\t    put_var_into_stack (TREE_OPERAND (exp, 0),\n-\t\t\t\t\t/*rescan=*/true);\n-\t\t    op0 = SAVE_EXPR_RTL (TREE_OPERAND (exp, 0));\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    tree nt\n-\t\t      = build_qualified_type (TREE_TYPE (tem),\n-\t\t\t\t\t      (TYPE_QUALS (TREE_TYPE (tem))\n-\t\t\t\t\t       | TYPE_QUAL_CONST));\n-\t\t    rtx memloc = assign_temp (nt, 1, 1, 1);\n-\n-\t\t    emit_move_insn (memloc, op0);\n-\t\t    op0 = memloc;\n-\t\t  }\n-\t      }\n-\n \t    if (GET_CODE (op0) != MEM)\n \t      abort ();\n "}]}