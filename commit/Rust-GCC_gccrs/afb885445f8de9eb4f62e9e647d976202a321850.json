{"sha": "afb885445f8de9eb4f62e9e647d976202a321850", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZiODg1NDQ1ZjhkZTllYjRmNjJlOWU2NDdkOTc2MjAyYTMyMTg1MA==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-03-12T15:36:33Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-11T09:53:33Z"}, "message": "[Ada] Missing accessibility error on object in type conversion\n\n2020-06-11  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* sem_util.adb (Expand_N_Attribute_Reference): Use original\n\tnodes where required to avoid looking at the expanded tree.", "tree": {"sha": "c39a7d0eccd7d8492a1277c5984276197175fac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c39a7d0eccd7d8492a1277c5984276197175fac0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afb885445f8de9eb4f62e9e647d976202a321850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb885445f8de9eb4f62e9e647d976202a321850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afb885445f8de9eb4f62e9e647d976202a321850", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb885445f8de9eb4f62e9e647d976202a321850/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57f57ad106d93f469ef881784b976eefc3d29a00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57f57ad106d93f469ef881784b976eefc3d29a00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57f57ad106d93f469ef881784b976eefc3d29a00"}], "stats": {"total": 76, "additions": 43, "deletions": 33}, "files": [{"sha": "92dd39452d1312699a588e5a84aa509a79a2e8ba", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afb885445f8de9eb4f62e9e647d976202a321850/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afb885445f8de9eb4f62e9e647d976202a321850/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=afb885445f8de9eb4f62e9e647d976202a321850", "patch": "@@ -23175,18 +23175,20 @@ package body Sem_Util is\n \n       --  Local variables\n \n-      E : Entity_Id;\n+      E        : Entity_Id;\n+      Orig_Obj : constant Node_Id := Original_Node (Obj);\n+      Orig_Pre : Node_Id;\n \n    --  Start of processing for Object_Access_Level\n \n    begin\n-      if Nkind (Obj) = N_Defining_Identifier\n-        or else Is_Entity_Name (Obj)\n+      if Nkind (Orig_Obj) = N_Defining_Identifier\n+        or else Is_Entity_Name (Orig_Obj)\n       then\n-         if Nkind (Obj) = N_Defining_Identifier then\n-            E := Obj;\n+         if Nkind (Orig_Obj) = N_Defining_Identifier then\n+            E := Orig_Obj;\n          else\n-            E := Entity (Obj);\n+            E := Entity (Orig_Obj);\n          end if;\n \n          if Is_Prival (E) then\n@@ -23220,14 +23222,17 @@ package body Sem_Util is\n             return Scope_Depth (Enclosing_Dynamic_Scope (E));\n          end if;\n \n-      elsif Nkind_In (Obj, N_Indexed_Component, N_Selected_Component) then\n-         if Is_Access_Type (Etype (Prefix (Obj))) then\n-            return Type_Access_Level (Etype (Prefix (Obj)));\n+      elsif Nkind_In (Orig_Obj, N_Indexed_Component, N_Selected_Component) then\n+         Orig_Pre := Original_Node (Prefix (Orig_Obj));\n+\n+         if Is_Access_Type (Etype (Orig_Pre)) then\n+            return Type_Access_Level (Etype (Prefix (Orig_Obj)));\n          else\n-            return Object_Access_Level (Prefix (Obj));\n+            return Object_Access_Level (Prefix (Orig_Obj));\n          end if;\n \n-      elsif Nkind (Obj) = N_Explicit_Dereference then\n+      elsif Nkind (Orig_Obj) = N_Explicit_Dereference then\n+         Orig_Pre := Original_Node (Prefix (Orig_Obj));\n \n          --  If the prefix is a selected access discriminant then we make a\n          --  recursive call on the prefix, which will in turn check the level\n@@ -23239,46 +23244,48 @@ package body Sem_Util is\n          --  otherwise expansion will already have transformed the prefix into\n          --  a temporary.\n \n-         if Nkind (Prefix (Obj)) = N_Selected_Component\n-           and then Ekind (Etype (Prefix (Obj))) = E_Anonymous_Access_Type\n+         if Nkind (Orig_Pre) = N_Selected_Component\n+           and then Ekind (Etype (Orig_Pre)) = E_Anonymous_Access_Type\n            and then\n-             Ekind (Entity (Selector_Name (Prefix (Obj)))) = E_Discriminant\n+             Ekind (Entity (Selector_Name (Orig_Pre))) = E_Discriminant\n            and then\n              (not Has_Implicit_Dereference\n-                    (Entity (Selector_Name (Prefix (Obj))))\n+                    (Entity (Selector_Name (Orig_Pre)))\n                or else Nkind (Parent (Obj)) /= N_Selected_Component)\n          then\n-            return Object_Access_Level (Prefix (Obj));\n+            return Object_Access_Level (Prefix (Orig_Obj));\n \n          --  Detect an interface conversion in the context of a dispatching\n          --  call. Use the original form of the conversion to find the access\n          --  level of the operand.\n \n-         elsif Is_Interface (Etype (Obj))\n-           and then Is_Interface_Conversion (Prefix (Obj))\n-           and then Nkind (Original_Node (Obj)) = N_Type_Conversion\n+         elsif Is_Interface (Etype (Orig_Obj))\n+           and then Is_Interface_Conversion (Orig_Pre)\n+           and then Nkind (Orig_Obj) = N_Type_Conversion\n          then\n-            return Object_Access_Level (Original_Node (Obj));\n+            return Object_Access_Level (Orig_Obj);\n \n-         elsif not Comes_From_Source (Obj) then\n+         elsif not Comes_From_Source (Orig_Obj) then\n             declare\n-               Ref : constant Node_Id := Reference_To (Obj);\n+               Ref : constant Node_Id := Reference_To (Orig_Obj);\n             begin\n                if Present (Ref) then\n                   return Object_Access_Level (Ref);\n                else\n-                  return Type_Access_Level (Etype (Prefix (Obj)));\n+                  return Type_Access_Level (Etype (Prefix (Orig_Obj)));\n                end if;\n             end;\n \n          else\n-            return Type_Access_Level (Etype (Prefix (Obj)));\n+            return Type_Access_Level (Etype (Prefix (Orig_Obj)));\n          end if;\n \n-      elsif Nkind_In (Obj, N_Type_Conversion, N_Unchecked_Type_Conversion) then\n-         return Object_Access_Level (Expression (Obj));\n+      elsif Nkind_In (Orig_Obj, N_Type_Conversion,\n+                                N_Unchecked_Type_Conversion)\n+      then\n+         return Object_Access_Level (Expression (Orig_Obj));\n \n-      elsif Nkind (Obj) = N_Function_Call then\n+      elsif Nkind (Orig_Obj) = N_Function_Call then\n \n          --  Function results are objects, so we get either the access level of\n          --  the function or, in the case of an indirect call, the level of the\n@@ -23289,10 +23296,10 @@ package body Sem_Util is\n          --  compiled with -gnat95. ???)\n \n          if Ada_Version < Ada_2005 then\n-            if Is_Entity_Name (Name (Obj)) then\n-               return Subprogram_Access_Level (Entity (Name (Obj)));\n+            if Is_Entity_Name (Name (Orig_Obj)) then\n+               return Subprogram_Access_Level (Entity (Name (Orig_Obj)));\n             else\n-               return Type_Access_Level (Etype (Prefix (Name (Obj))));\n+               return Type_Access_Level (Etype (Prefix (Name (Orig_Obj))));\n             end if;\n \n          --  For Ada 2005, the level of the result object of a function call is\n@@ -23392,20 +23399,23 @@ package body Sem_Util is\n             --  Start of processing for Return_Master_Scope_Depth_Of_Call\n \n             begin\n+               --  Expanded code may have clobbered the scoping data from the\n+               --  original object node - so use the expanded one.\n+\n                return Innermost_Master_Scope_Depth (Obj);\n             end Return_Master_Scope_Depth_Of_Call;\n          end if;\n \n       --  For convenience we handle qualified expressions, even though they\n       --  aren't technically object names.\n \n-      elsif Nkind (Obj) = N_Qualified_Expression then\n-         return Object_Access_Level (Expression (Obj));\n+      elsif Nkind (Orig_Obj) = N_Qualified_Expression then\n+         return Object_Access_Level (Expression (Orig_Obj));\n \n       --  Ditto for aggregates. They have the level of the temporary that\n       --  will hold their value.\n \n-      elsif Nkind (Obj) = N_Aggregate then\n+      elsif Nkind (Orig_Obj) = N_Aggregate then\n          return Object_Access_Level (Current_Scope);\n \n       --  Otherwise return the scope level of Standard. (If there are cases"}]}