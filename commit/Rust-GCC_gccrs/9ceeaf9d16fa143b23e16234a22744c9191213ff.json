{"sha": "9ceeaf9d16fa143b23e16234a22744c9191213ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNlZWFmOWQxNmZhMTQzYjIzZTE2MjM0YTIyNzQ0YzkxOTEyMTNmZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:49:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-10T14:49:04Z"}, "message": "[multiple changes]\n\n2014-10-10  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb, sem_attr.adb: Minor reformatting.\n\n2014-10-10  Johannes Kanig  <kanig@adacore.com>\n\n\t* a-cfdlli.ads, a-cfhama.ads, a-cfhase.ads, a-cforma.ads,\n\ta-cforse.ads, a-cofove.ads: add \"Default_Initial_Condition\"\n\tto container type.\n\n2014-10-10  Vincent Celier  <celier@adacore.com>\n\n\t* prj-conf.adb (Do_Autoconf): In Codepeer mode, do not try to get\n\tany configuration switches from the project file.\n\n2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Build_Wrapper): Renamed as Build_Operator_Wrapper.\n\t(Build_Function_Wrapper): New function, to construct a wrapper\n\tfunction for actuals that are functions with an arbitrary\n\tnumber of parameters. Used in GNATProve mode to simplify proof\n\tpropagation in instantiations.\n\nFrom-SVN: r216092", "tree": {"sha": "11a99217237ee63bd01d9d3a2e417bcc54bb787f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11a99217237ee63bd01d9d3a2e417bcc54bb787f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ceeaf9d16fa143b23e16234a22744c9191213ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ceeaf9d16fa143b23e16234a22744c9191213ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ceeaf9d16fa143b23e16234a22744c9191213ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ceeaf9d16fa143b23e16234a22744c9191213ff/comments", "author": null, "committer": null, "parents": [{"sha": "4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1429b2dd3fafdb24f9cd324cfd063b13b275d8"}], "stats": {"total": 340, "additions": 223, "deletions": 117}, "files": [{"sha": "4e232959bc8b84cdac8e9b97c565dba73a66d6e1", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -1,3 +1,26 @@\n+2014-10-10  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb, sem_attr.adb: Minor reformatting.\n+\n+2014-10-10  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* a-cfdlli.ads, a-cfhama.ads, a-cfhase.ads, a-cforma.ads,\n+\ta-cforse.ads, a-cofove.ads: add \"Default_Initial_Condition\"\n+\tto container type.\n+\n+2014-10-10  Vincent Celier  <celier@adacore.com>\n+\n+\t* prj-conf.adb (Do_Autoconf): In Codepeer mode, do not try to get\n+\tany configuration switches from the project file.\n+\n+2014-10-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Build_Wrapper): Renamed as Build_Operator_Wrapper.\n+\t(Build_Function_Wrapper): New function, to construct a wrapper\n+\tfunction for actuals that are functions with an arbitrary\n+\tnumber of parameters. Used in GNATProve mode to simplify proof\n+\tpropagation in instantiations.\n+\n 2014-10-10  Robert Dewar  <dewar@adacore.com>\n \n \t* freeze.adb, gnat1drv.adb, sem_ch13.adb: Minor reformatting and"}, {"sha": "98f28e4a8b1450527b2ecb767113708dce802fc0", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -69,7 +69,8 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element);\n+                  Element     => Element),\n+     Default_Initial_Condition;\n    pragma Preelaborable_Initialization (List);\n \n    type Cursor is private;"}, {"sha": "976160b860907f796037d3ae79a430684ce82587", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -74,7 +74,8 @@ package Ada.Containers.Formal_Hashed_Maps is\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element);\n+                  Element     => Element),\n+     Default_Initial_Condition;\n    pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;"}, {"sha": "670d720d5d793a54cb05a76beba0ee72597b9c55", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -76,7 +76,8 @@ package Ada.Containers.Formal_Hashed_Sets is\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element);\n+                  Element     => Element),\n+     Default_Initial_Condition;\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;"}, {"sha": "51e40a2ea2e45604819d591fe0fbe932212f3643", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -78,7 +78,8 @@ package Ada.Containers.Formal_Ordered_Maps is\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element);\n+                  Element     => Element),\n+     Default_Initial_Condition;\n    pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;"}, {"sha": "b3e9ff566194e1c1b078b5b85ce7d8334d6c5d26", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -77,7 +77,8 @@ package Ada.Containers.Formal_Ordered_Sets is\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element);\n+                  Element     => Element),\n+     Default_Initial_Condition;\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;"}, {"sha": "f5b9b64347b404b6db07f4091a4b54e1afc5aadf", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -81,7 +81,8 @@ package Ada.Containers.Formal_Vectors is\n      Iterable => (First       => First,\n                   Next        => Next,\n                   Has_Element => Has_Element,\n-                  Element     => Element);\n+                  Element     => Element),\n+     Default_Initial_Condition;\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);"}, {"sha": "0489baee199a6f13632b937ccb960f81df738747", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -1858,11 +1858,10 @@ package body Freeze is\n       --  package. Recurse on inner generic packages.\n \n       function Freeze_Profile (E : Entity_Id) return Boolean;\n-      --  Freeze formals and return type of subprogram.\n-      --  If some type in the profile is a limited view, freezing of the entity\n-      --  will take place elsewhere, and the function returns False.\n-      --  This routine will be modified if and when we can implement AI05-019\n-      --  efficiently.\n+      --  Freeze formals and return type of subprogram. If some type in the\n+      --  profile is a limited view, freezing of the entity will take place\n+      --  elsewhere, and the function returns False. This routine will be\n+      --  modified if and when we can implement AI05-019 efficiently ???\n \n       procedure Freeze_Record_Type (Rec : Entity_Id);\n       --  Freeze record type, including freezing component types, and freezing\n@@ -2557,8 +2556,8 @@ package body Freeze is\n                          Attribute_Name => Name_Range_Length);\n                      Analyze_And_Resolve (Ilen);\n \n-                     --  No attempt is made to check number of elements\n-                     --  if not compile time known.\n+                     --  No attempt is made to check number of elements if not\n+                     --  compile time known.\n \n                      if Nkind (Ilen) /= N_Integer_Literal then\n                         Elmts := Uint_0;\n@@ -2601,9 +2600,9 @@ package body Freeze is\n             end if;\n          end if;\n \n-         --  If any of the index types was an enumeration type with a\n-         --  non-standard rep clause, then we indicate that the array type\n-         --  is always packed (even if it is not bit packed).\n+         --  If any of the index types was an enumeration type with a non-\n+         --  standard rep clause, then we indicate that the array type is\n+         --  always packed (even if it is not bit packed).\n \n          if Non_Standard_Enum then\n             Set_Has_Non_Standard_Rep (Base_Type (Arr));\n@@ -2704,9 +2703,9 @@ package body Freeze is\n          while Present (Formal) loop\n             F_Type := Etype (Formal);\n \n-            --  AI05-0151: incomplete types can appear in a profile.\n-            --  By the time the entity is frozen, the full view must\n-            --  be available, unless it is a limited view.\n+            --  AI05-0151: incomplete types can appear in a profile. By the\n+            --  time the entity is frozen, the full view must be available,\n+            --  unless it is a limited view.\n \n             if Is_Incomplete_Type (F_Type)\n               and then Present (Full_View (F_Type))\n@@ -2724,12 +2723,11 @@ package body Freeze is\n               and then not Is_Generic_Type (F_Type)\n               and then not Is_Derived_Type (F_Type)\n             then\n-               --  If the type of a formal is incomplete, subprogram\n-               --  is being frozen prematurely. Within an instance\n-               --  (but not within a wrapper package) this is an\n-               --  artifact of our need to regard the end of an\n-               --  instantiation as a freeze point. Otherwise it is\n-               --  a definite error.\n+               --  If the type of a formal is incomplete, subprogram is being\n+               --  frozen prematurely. Within an instance (but not within a\n+               --  wrapper package) this is an artifact of our need to regard\n+               --  the end of an instantiation as a freeze point. Otherwise it\n+               --  is a definite error.\n \n                if In_Instance then\n                   Set_Is_Frozen (E, False);\n@@ -2741,13 +2739,12 @@ package body Freeze is\n                then\n                   Error_Msg_Node_1 := F_Type;\n                   Error_Msg\n-                    (\"type& must be fully defined before this point\",\n-                      Loc);\n+                    (\"type & must be fully defined before this point\", Loc);\n                end if;\n             end if;\n \n-            --  Check suspicious parameter for C function. These tests\n-            --  apply only to exported/imported subprograms.\n+            --  Check suspicious parameter for C function. These tests apply\n+            --  only to exported/imported subprograms.\n \n             if Warn_On_Export_Import\n               and then Comes_From_Source (E)\n@@ -2780,28 +2777,31 @@ package body Freeze is\n                  and then not Has_Size_Clause (F_Type)\n                  and then VM_Target = No_VM\n                then\n-                  Error_Msg_N (\"& is an 8-bit Ada Boolean?x?\", Formal);\n-                  Error_Msg_N (\"\\use appropriate corresponding type in C \"\n+                  Error_Msg_N\n+                    (\"& is an 8-bit Ada Boolean?x?\", Formal);\n+                  Error_Msg_N\n+                    (\"\\use appropriate corresponding type in C \"\n                      & \"(e.g. char)?x?\", Formal);\n \n                --  Check suspicious tagged type\n \n                elsif (Is_Tagged_Type (F_Type)\n-                       or else (Is_Access_Type (F_Type)\n-                                  and then\n-                                    Is_Tagged_Type\n-                                      (Designated_Type (F_Type))))\n+                       or else\n+                        (Is_Access_Type (F_Type)\n+                          and then Is_Tagged_Type (Designated_Type (F_Type))))\n                  and then Convention (E) = Convention_C\n                then\n-                  Error_Msg_N (\"?x?& involves a tagged type which does not \"\n+                  Error_Msg_N\n+                    (\"?x?& involves a tagged type which does not \"\n                      & \"correspond to any C type!\", Formal);\n \n                --  Check wrong convention subprogram pointer\n \n                elsif Ekind (F_Type) = E_Access_Subprogram_Type\n                  and then not Has_Foreign_Convention (F_Type)\n                then\n-                  Error_Msg_N (\"?x?subprogram pointer & should \"\n+                  Error_Msg_N\n+                    (\"?x?subprogram pointer & should \"\n                      & \"have foreign convention!\", Formal);\n                   Error_Msg_Sloc := Sloc (F_Type);\n                   Error_Msg_NE\n@@ -2814,8 +2814,8 @@ package body Freeze is\n                Error_Msg_Qual_Level := 0;\n             end if;\n \n-            --  Check for unconstrained array in exported foreign\n-            --  convention case.\n+            --  Check for unconstrained array in exported foreign convention\n+            --  case.\n \n             if Has_Foreign_Convention (E)\n               and then not Is_Imported (E)\n@@ -2830,17 +2830,16 @@ package body Freeze is\n             then\n                Error_Msg_Qual_Level := 1;\n \n-               --  If this is an inherited operation, place the\n-               --  warning on the derived type declaration, rather\n-               --  than on the original subprogram.\n+               --  If this is an inherited operation, place the warning on\n+               --  the derived type declaration, rather than on the original\n+               --  subprogram.\n \n                if Nkind (Original_Node (Parent (E))) = N_Full_Type_Declaration\n                then\n                   Warn_Node := Parent (E);\n \n                   if Formal = First_Formal (E) then\n-                     Error_Msg_NE\n-                       (\"??in inherited operation&\", Warn_Node, E);\n+                     Error_Msg_NE (\"??in inherited operation&\", Warn_Node, E);\n                   end if;\n                else\n                   Warn_Node := Formal;\n@@ -2987,8 +2986,7 @@ package body Freeze is\n             end if;\n \n             --  Give warning for suspicious return of a result of an\n-            --  unconstrained array type in a foreign convention\n-            --  function.\n+            --  unconstrained array type in a foreign convention function.\n \n             if Has_Foreign_Convention (E)\n \n@@ -2997,19 +2995,18 @@ package body Freeze is\n               and then Is_Array_Type (R_Type)\n               and then not Is_Constrained (R_Type)\n \n-              --  Exclude imported routines, the warning does not\n-              --  belong on the import, but rather on the routine\n-              --  definition.\n+              --  Exclude imported routines, the warning does not belong on\n+              --  the import, but rather on the routine definition.\n \n               and then not Is_Imported (E)\n \n-              --  Exclude VM case, since both .NET and JVM can handle\n-              --  return of unconstrained arrays without a problem.\n+              --  Exclude VM case, since both .NET and JVM can handle return\n+              --  of unconstrained arrays without a problem.\n \n               and then VM_Target = No_VM\n \n-              --  Check that general warning is enabled, and that it\n-              --  is not suppressed for this particular case.\n+              --  Check that general warning is enabled, and that it is not\n+              --  suppressed for this particular case.\n \n               and then Warn_On_Export_Import\n               and then not Has_Warnings_Off (E)"}, {"sha": "fe1be8fcff89f385b09bf24382d6380cce6c8817", "filename": "gcc/ada/prj-conf.adb", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fprj-conf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fprj-conf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-conf.adb?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -172,7 +172,7 @@ package body Prj.Conf is\n    begin\n       if Config_File = Empty_Node then\n \n-         --  Create a dummy config file is none was found\n+         --  Create a dummy config file if none was found\n \n          Name_Len := Auto_Cgpr'Length;\n          Name_Buffer (1 .. Name_Len) := Auto_Cgpr;\n@@ -587,7 +587,7 @@ package body Prj.Conf is\n           or else\n             (Tgt_Name /= No_Name\n               and then (Length_Of_Name (Tgt_Name) = 0\n-                          or else Target = Get_Name_String (Tgt_Name)));\n+                         or else Target = Get_Name_String (Tgt_Name)));\n \n       if not OK then\n          if Autoconf_Specified then\n@@ -931,7 +931,8 @@ package body Prj.Conf is\n \n          declare\n             Obj_Dir         : constant String := Name_Buffer (1 .. Name_Len);\n-            Config_Switches : Argument_List_Access;\n+            Config_Switches : Argument_List_Access :=\n+                                new Argument_List'(1 .. 0 => null);\n             Db_Switches     : Argument_List_Access;\n             Args            : Argument_List (1 .. 5);\n             Arg_Last        : Positive;\n@@ -979,10 +980,13 @@ package body Prj.Conf is\n                end case;\n             end if;\n \n-            --  Get the config switches. This should be done only now, as some\n-            --  runtimes may have been found if the Builder switches.\n+            --  If not in Codepeer mode, get the config switches. This should\n+            --  be done only now, as some runtimes may have been found if the\n+            --  Builder switches.\n \n-            Config_Switches := Get_Config_Switches;\n+            if not CodePeer_Mode then\n+               Config_Switches := Get_Config_Switches;\n+            end if;\n \n             --  Get eventual --db switches\n \n@@ -1082,12 +1086,11 @@ package body Prj.Conf is\n                Write_Eol;\n \n             elsif not Quiet_Output then\n+\n                --  Display no message if we are creating auto.cgpr, unless in\n-               --  verbose mode\n+               --  verbose mode.\n \n-               if Config_File_Name'Length > 0\n-                 or else Verbose_Mode\n-               then\n+               if Config_File_Name'Length > 0 or else Verbose_Mode then\n                   Write_Str (\"creating \");\n                   Write_Str (Simple_Name (Args (3).all));\n                   Write_Eol;\n@@ -1300,8 +1303,7 @@ package body Prj.Conf is\n                Config_Command : constant String :=\n                                   \"--config=\" & Get_Name_String (Name);\n \n-               Runtime_Name   : constant String :=\n-                                  Runtime_Name_For (Name);\n+               Runtime_Name : constant String := Runtime_Name_For (Name);\n \n             begin\n                if Variable = Nil_Variable_Value\n@@ -1321,14 +1323,14 @@ package body Prj.Conf is\n                      if Is_Absolute_Path (Compiler_Command) then\n                         Result (Count) :=\n                           new String'\n-                            (Config_Command & \",,\" & Runtime_Name & \",\" &\n-                             Containing_Directory (Compiler_Command) & \",\" &\n-                             Simple_Name (Compiler_Command));\n+                            (Config_Command & \",,\" & Runtime_Name & \",\"\n+                             & Containing_Directory (Compiler_Command) & \",\"\n+                             & Simple_Name (Compiler_Command));\n                      else\n                         Result (Count) :=\n                           new String'\n-                            (Config_Command & \",,\" & Runtime_Name & \",,\" &\n-                             Compiler_Command);\n+                            (Config_Command & \",,\" & Runtime_Name & \",,\"\n+                             & Compiler_Command);\n                      end if;\n                   end;\n                end if;\n@@ -1350,20 +1352,14 @@ package body Prj.Conf is\n \n       begin\n          Variable :=\n-           Value_Of\n-             (Name_Source_Dirs,\n-              Project.Decl.Attributes,\n-              Shared);\n+           Value_Of (Name_Source_Dirs, Project.Decl.Attributes, Shared);\n \n          if Variable = Nil_Variable_Value\n            or else Variable.Default\n            or else Variable.Values /= Nil_String\n          then\n             Variable :=\n-              Value_Of\n-                (Name_Source_Files,\n-                 Project.Decl.Attributes,\n-                 Shared);\n+              Value_Of (Name_Source_Files, Project.Decl.Attributes, Shared);\n             return Variable = Nil_Variable_Value\n               or else Variable.Default\n               or else Variable.Values /= Nil_String;\n@@ -1373,9 +1369,13 @@ package body Prj.Conf is\n          end if;\n       end Might_Have_Sources;\n \n+      --  Local Variables\n+\n       Success             : Boolean;\n       Config_Project_Node : Project_Node_Id := Empty_Node;\n \n+   --  Start of processing for Get_Or_Create_Configuration_File\n+\n    begin\n       pragma Assert (Prj.Env.Is_Initialized (Env.Project_Path));\n \n@@ -1472,9 +1472,7 @@ package body Prj.Conf is\n             On_New_Tree_Loaded     => null);\n       end if;\n \n-      if Config_Project_Node = Empty_Node\n-        or else Config = No_Project\n-      then\n+      if Config_Project_Node = Empty_Node or else Config = No_Project then\n          Raise_Invalid_Config\n            (\"processing of configuration project \"\"\"\n             & Config_File_Path.all & \"\"\" failed\");\n@@ -1606,7 +1604,6 @@ package body Prj.Conf is\n          Implicit_Project  => Implicit_Project);\n \n       if User_Project_Node = Empty_Node then\n-         User_Project_Node := Empty_Node;\n          return;\n       end if;\n "}, {"sha": "56c1e6dd1c933f3e8f44f0a847f7cd1c5df588ba", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -11021,7 +11021,6 @@ package body Sem_Attr is\n \n                else\n                   Assoc := First (Component_Associations (Aggr));\n-\n                   while Present (Assoc) loop\n                      Comp := First (Choices (Assoc));\n                      Expr := Expression (Assoc);"}, {"sha": "d88dcc29afdf442f3b8077cef92e649026f13acb", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 118, "deletions": 34, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ceeaf9d16fa143b23e16234a22744c9191213ff/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=9ceeaf9d16fa143b23e16234a22744c9191213ff", "patch": "@@ -954,10 +954,19 @@ package body Sem_Ch12 is\n       --  In Ada 2005, indicates partial parameterization of a formal\n       --  package. As usual an other association must be last in the list.\n \n-      function Build_Wrapper\n+      function Build_Function_Wrapper\n         (Formal : Entity_Id;\n          Actual : Entity_Id := Empty) return Node_Id;\n-      --  In GNATProve mode, create a wrapper function for actuals that are\n+      --  In GNATprove mode, create a wrapper function for actuals that are\n+      --  functions with any number of formal parameters, in order to propagate\n+      --  their contract to the renaming declarations generated for them.\n+      --  If the actual is absent, the formal has a default, and the name of\n+      --  the function is that of the formal.\n+\n+      function Build_Operator_Wrapper\n+        (Formal : Entity_Id;\n+         Actual : Entity_Id := Empty) return Node_Id;\n+      --  In GNATprove mode, create a wrapper function for actuals that are\n       --  operators, in order to propagate their contract to the renaming\n       --  declarations generated for them. If the actual is absent, this is\n       --  a formal with a default, and the name of the operator is that of the\n@@ -1010,11 +1019,84 @@ package body Sem_Ch12 is\n       --  anonymous types, the presence a formal equality will introduce an\n       --  implicit declaration for the corresponding inequality.\n \n-      -------------------\n-      -- Build_Wrapper --\n-      -------------------\n+      ----------------------------\n+      -- Build_Function_Wrapper --\n+      ----------------------------\n \n-      function Build_Wrapper\n+      function Build_Function_Wrapper\n+        (Formal : Entity_Id;\n+         Actual : Entity_Id := Empty) return Node_Id\n+      is\n+         Loc       : constant Source_Ptr := Sloc (I_Node);\n+         Actuals   : List_Id;\n+         Decl      : Node_Id;\n+         Func_Name : Node_Id;\n+         Func      : Entity_Id;\n+         N_Parms   : Natural;\n+         Profile   : List_Id;\n+         Spec      : Node_Id;\n+         F         : Entity_Id;\n+         New_F     : Entity_Id;\n+\n+      begin\n+         --  If there is no actual, the formal has a default and is retrieved\n+         --  by name. Otherwise the wrapper encloses a call to the actual.\n+\n+         if No (Actual) then\n+            Func_Name := Make_Identifier (Loc, Chars (Formal));\n+         else\n+            Func_Name := New_Occurrence_Of (Entity (Actual), Loc);\n+         end if;\n+\n+         Func := Make_Defining_Identifier (Loc, Chars (Formal));\n+         Set_Ekind (Func, E_Function);\n+         Set_Is_Generic_Actual_Subprogram (Func);\n+\n+         Actuals := New_List;\n+         Profile := New_List;\n+\n+         F := First_Formal (Formal);\n+         N_Parms := 0;\n+         while Present (F) loop\n+\n+            --  Create new formal for profile of wrapper, and add a reference\n+            --  to it in the list of actuals for the enclosing call.\n+\n+            New_F := Make_Temporary\n+                       (Loc, Character'Val (Character'Pos ('A') + N_Parms));\n+            Append_To (Profile,\n+              Make_Parameter_Specification (Loc,\n+              Defining_Identifier => New_F,\n+              Parameter_Type      =>\n+                Make_Identifier (Loc, Chars => Chars (Etype (F)))));\n+\n+            Append_To (Actuals, New_Occurrence_Of (New_F, Loc));\n+            Next_Formal (F);\n+            N_Parms := N_Parms + 1;\n+         end loop;\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => Func,\n+             Parameter_Specifications => Profile,\n+             Result_Definition        =>\n+               Make_Identifier (Loc, Chars (Etype (Formal))));\n+         Decl :=\n+           Make_Expression_Function (Loc,\n+             Specification => Spec,\n+             Expression    =>\n+               Make_Function_Call (Loc,\n+                 Name                   => Func_Name,\n+                 Parameter_Associations => Actuals));\n+\n+         return Decl;\n+      end Build_Function_Wrapper;\n+\n+      ----------------------------\n+      -- Build_Operator_Wrapper --\n+      ----------------------------\n+\n+      function Build_Operator_Wrapper\n         (Formal : Entity_Id;\n          Actual : Entity_Id := Empty) return Node_Id\n       is\n@@ -1029,8 +1111,7 @@ package body Sem_Ch12 is\n          Func    : Entity_Id;\n          Op_Name : Name_Id;\n          Spec    : Node_Id;\n-\n-         L, R   : Node_Id;\n+         L, R    : Node_Id;\n \n       begin\n          if No (Actual) then\n@@ -1089,52 +1170,52 @@ package body Sem_Ch12 is\n \n          elsif Is_Binary then\n             if Op_Name = Name_Op_And then\n-               Expr := Make_Op_And (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_And      (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Or then\n-               Expr := Make_Op_Or (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Or       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Xor then\n-               Expr := Make_Op_Xor (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Xor      (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Eq then\n-               Expr := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Eq       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Ne then\n-               Expr := Make_Op_Ne (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Ne       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Le then\n-               Expr := Make_Op_Le (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Le       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Gt then\n-               Expr := Make_Op_Gt (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Gt       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Ge then\n-               Expr := Make_Op_Ge (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Ge       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Lt then\n-               Expr := Make_Op_Lt (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Lt       (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Add then\n-               Expr := Make_Op_Add (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Add      (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Subtract then\n                Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Concat then\n-               Expr := Make_Op_Concat (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Concat   (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Multiply then\n                Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Divide then\n-               Expr := Make_Op_Divide (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Divide   (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Mod then\n-               Expr := Make_Op_Mod (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Mod      (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Rem then\n-               Expr := Make_Op_Rem (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Rem      (Loc, Left_Opnd => L, Right_Opnd => R);\n             elsif Op_Name = Name_Op_Expon then\n-               Expr := Make_Op_Expon (Loc, Left_Opnd => L, Right_Opnd => R);\n+               Expr := Make_Op_Expon    (Loc, Left_Opnd => L, Right_Opnd => R);\n             end if;\n \n          --  Unary operators\n \n          else\n             if Op_Name = Name_Op_Add then\n-               Expr := Make_Op_Plus (Loc, Right_Opnd => L);\n+               Expr := Make_Op_Plus  (Loc, Right_Opnd => L);\n             elsif Op_Name = Name_Op_Subtract then\n                Expr := Make_Op_Minus (Loc, Right_Opnd => L);\n             elsif Op_Name = Name_Op_Abs then\n-               Expr := Make_Op_Abs (Loc, Right_Opnd => L);\n+               Expr := Make_Op_Abs   (Loc, Right_Opnd => L);\n             elsif Op_Name = Name_Op_Not then\n-               Expr := Make_Op_Not (Loc, Right_Opnd => L);\n+               Expr := Make_Op_Not   (Loc, Right_Opnd => L);\n             end if;\n          end if;\n \n@@ -1151,7 +1232,7 @@ package body Sem_Ch12 is\n              Expression    => Expr);\n \n          return Decl;\n-      end Build_Wrapper;\n+      end Build_Operator_Wrapper;\n \n       ----------------------------------------\n       -- Check_Overloaded_Formal_Subprogram --\n@@ -1694,13 +1775,13 @@ package body Sem_Ch12 is\n \n                               Append_To\n                                 (Assoc,\n-                                 Build_Wrapper\n+                                 Build_Operator_Wrapper\n                                    (Defining_Entity (Analyzed_Formal), Match));\n \n                            else\n                               Append_To (Assoc,\n-                                         Instantiate_Formal_Subprogram\n-                                           (Formal, Match, Analyzed_Formal));\n+                                 Build_Function_Wrapper\n+                                   (Defining_Entity (Analyzed_Formal), Match));\n                            end if;\n \n                         --  Ditto if formal is an operator with a default.\n@@ -1710,15 +1791,15 @@ package body Sem_Ch12 is\n                                                     N_Defining_Operator_Symbol\n                         then\n                            Append_To (Assoc,\n-                             Build_Wrapper\n+                             Build_Operator_Wrapper\n                                (Defining_Entity (Analyzed_Formal)));\n \n                         --  Otherwise create renaming declaration.\n \n                         else\n                            Append_To (Assoc,\n-                             Instantiate_Formal_Subprogram\n-                               (Formal, Match, Analyzed_Formal));\n+                             Build_Function_Wrapper\n+                               (Defining_Entity (Analyzed_Formal)));\n                         end if;\n \n                      else\n@@ -9552,10 +9633,13 @@ package body Sem_Ch12 is\n \n       Loc := Sloc (Defining_Unit_Name (New_Spec));\n \n-      --  Create new entity for the actual (New_Copy_Tree does not)\n+      --  Create new entity for the actual (New_Copy_Tree does not), and\n+      --  indicate that it is an actual.\n \n       Set_Defining_Unit_Name\n         (New_Spec, Make_Defining_Identifier (Loc, Chars (Formal_Sub)));\n+      Set_Ekind (Defining_Unit_Name (New_Spec), Ekind (Analyzed_S));\n+      Set_Is_Generic_Actual_Subprogram (Defining_Unit_Name (New_Spec));\n \n       --  Create new entities for the each of the formals in the specification\n       --  of the renaming declaration built for the actual."}]}