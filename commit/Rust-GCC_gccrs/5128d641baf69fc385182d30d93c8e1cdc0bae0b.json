{"sha": "5128d641baf69fc385182d30d93c8e1cdc0bae0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTEyOGQ2NDFiYWY2OWZjMzg1MTgyZDMwZDkzYzhlMWNkYzBiYWUwYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-12-13T17:51:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-12-13T17:51:47Z"}, "message": "trans.c (can_be_lower_p): New predicate.\n\n\t* gcc-interface/trans.c (can_be_lower_p): New predicate.\n\t(Loop_Statement_to_gnu): Do not generate the entry condition if we know\n\tthat it will be true.\n\nFrom-SVN: r167757", "tree": {"sha": "2ce50550802f8f614e5092b81dede6d4ee6c84cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ce50550802f8f614e5092b81dede6d4ee6c84cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5128d641baf69fc385182d30d93c8e1cdc0bae0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5128d641baf69fc385182d30d93c8e1cdc0bae0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5128d641baf69fc385182d30d93c8e1cdc0bae0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5128d641baf69fc385182d30d93c8e1cdc0bae0b/comments", "author": null, "committer": null, "parents": [{"sha": "1643b12f56f9346abdc4b5b27b80eeece2bd437e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1643b12f56f9346abdc4b5b27b80eeece2bd437e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1643b12f56f9346abdc4b5b27b80eeece2bd437e"}], "stats": {"total": 43, "additions": 36, "deletions": 7}, "files": [{"sha": "a42758d52bd31e287b34edd6cd012989679b70b6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5128d641baf69fc385182d30d93c8e1cdc0bae0b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5128d641baf69fc385182d30d93c8e1cdc0bae0b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5128d641baf69fc385182d30d93c8e1cdc0bae0b", "patch": "@@ -1,3 +1,9 @@\n+2010-12-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (can_be_lower_p): New predicate.\n+\t(Loop_Statement_to_gnu): Do not generate the entry condition if we know\n+\tthat it will be true.\n+\n 2010-12-03  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc-interface/lang.opt (k8): New option."}, {"sha": "8a15c2d0517f23ad28e65a87662b8934a255b09d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5128d641baf69fc385182d30d93c8e1cdc0bae0b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5128d641baf69fc385182d30d93c8e1cdc0bae0b/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=5128d641baf69fc385182d30d93c8e1cdc0bae0b", "patch": "@@ -2130,6 +2130,26 @@ can_equal_max_val_p (tree val, tree type, bool reverse)\n   return can_equal_min_or_max_val_p (val, type, !reverse);\n }\n \n+/* Return true if VAL1 can be lower than VAL2.  */\n+\n+static bool\n+can_be_lower_p (tree val1, tree val2)\n+{\n+  if (TREE_CODE (val1) == NOP_EXPR)\n+    val1 = TYPE_MIN_VALUE (TREE_TYPE (TREE_OPERAND (val1, 0)));\n+\n+  if (TREE_CODE (val1) != INTEGER_CST)\n+    return true;\n+\n+  if (TREE_CODE (val2) == NOP_EXPR)\n+    val2 = TYPE_MAX_VALUE (TREE_TYPE (TREE_OPERAND (val2, 0)));\n+\n+  if (TREE_CODE (val2) != INTEGER_CST)\n+    return true;\n+\n+  return tree_int_cst_lt (val1, val2);\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Loop_Statement,\n    to a GCC tree, which is returned.  */\n \n@@ -2297,16 +2317,19 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \tLOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt) = 1;\n \n       /* If we use the BOTTOM_COND, we can turn the test into an inequality\n-\t test but we have to add an ENTRY_COND to protect the empty loop.  */\n+\t test but we may have to add ENTRY_COND to protect the empty loop.  */\n       if (LOOP_STMT_BOTTOM_COND_P (gnu_loop_stmt))\n \t{\n \t  test_code = NE_EXPR;\n-\t  gnu_cond_expr\n-\t    = build3 (COND_EXPR, void_type_node,\n-\t\t      build_binary_op (LE_EXPR, boolean_type_node,\n-\t\t\t\t       gnu_low, gnu_high),\n-\t\t      NULL_TREE, alloc_stmt_list ());\n-\t  set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n+\t  if (can_be_lower_p (gnu_high, gnu_low))\n+\t    {\n+\t      gnu_cond_expr\n+\t\t= build3 (COND_EXPR, void_type_node,\n+\t\t\t  build_binary_op (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t   gnu_low, gnu_high),\n+\t\t\t  NULL_TREE, alloc_stmt_list ());\n+\t      set_expr_location_from_node (gnu_cond_expr, gnat_loop_spec);\n+\t    }\n \t}\n \n       /* Open a new nesting level that will surround the loop to declare the"}]}