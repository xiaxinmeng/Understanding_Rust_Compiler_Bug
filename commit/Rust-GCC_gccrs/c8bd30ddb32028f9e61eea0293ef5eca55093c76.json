{"sha": "c8bd30ddb32028f9e61eea0293ef5eca55093c76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzhiZDMwZGRiMzIwMjhmOWU2MWVlYTAyOTNlZjVlY2E1NTA5M2M3Ng==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-09-24T19:42:34Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-09-24T19:42:34Z"}, "message": "boost_shared_ptr.h (shared_ptr<>::shared_ptr(const __shared_ptr<>&), [...]): Remove.\n\n2006-09-24  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/boost_shared_ptr.h (shared_ptr<>::shared_ptr(const\n\t__shared_ptr<>&), shared_ptr(const __weak_ptr<>&),\n\tshared_ptr(const __shared_ptr<>&, __static_cast_tag),\n\tshared_ptr(const __shared_ptr<>&, __const_cast_tag),\n\tshared_ptr(const __shared_ptr<>&, __dynamic_cast_tag),\n\tweak_ptr<>::weak_ptr(const __shared_ptr<>&), weak_ptr(const\n\t__weak_ptr<>&)): Remove.\n\t(shared_ptr<>::shared_ptr(const shared_ptr<>&),\n\tshared_ptr(const weak_ptr<>&), shared_ptr(const shared_ptr<>&,\n\t__static_cast_tag), shared_ptr(const shared_ptr<>&,\n\t__const_cast_tag), shared_ptr(const shared_ptr<>&,\n\t__dynamic_cast_tag), static_pointer_cast(const shared_ptr<>&),\n\tconst_pointer_cast(const shared_ptr<>&), dynamic_pointer_cast(const\n\tshared_ptr<>&), weak_ptr<>::weak_ptr(const shared_ptr<>&),\n\tweak_ptr(const weak_ptr<>&), weak_ptr<>::lock(), \n\t__enable_shared_from_this_helper(const __shared_count<>&, const\n\tenable_shared_from_this<>*, const _Tp2*)): Add. \n\t(class enable_shared_from_this): Add.\n\t* testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/\n\t1.cc: New.\n\t* testsuite/tr1/2_general_utilities/memory/shared_ptr/casts/1.cc:\n\tLikewise.\n\t* testsuite/tr1/2_general_utilities/memory/weak_ptr/lock/1.cc:\n\tLikewise.\n\n\t* include/tr1/boost_shared_ptr.h: Further formatting and\n\tuglification fixes.\n\nFrom-SVN: r117184", "tree": {"sha": "65129d2ef631e22884afdbfafd2befca2efa8c89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65129d2ef631e22884afdbfafd2befca2efa8c89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8bd30ddb32028f9e61eea0293ef5eca55093c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8bd30ddb32028f9e61eea0293ef5eca55093c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8bd30ddb32028f9e61eea0293ef5eca55093c76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8bd30ddb32028f9e61eea0293ef5eca55093c76/comments", "author": null, "committer": null, "parents": [{"sha": "af17634547724868eb034351d63f2e29cce4d7b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af17634547724868eb034351d63f2e29cce4d7b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af17634547724868eb034351d63f2e29cce4d7b3"}], "stats": {"total": 727, "additions": 482, "deletions": 245}, "files": [{"sha": "0c09db148cecd94d7b9fb468dcf945e7299b6745", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=c8bd30ddb32028f9e61eea0293ef5eca55093c76", "patch": "@@ -1,3 +1,33 @@\n+2006-09-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/boost_shared_ptr.h (shared_ptr<>::shared_ptr(const\n+\t__shared_ptr<>&), shared_ptr(const __weak_ptr<>&),\n+\tshared_ptr(const __shared_ptr<>&, __static_cast_tag),\n+\tshared_ptr(const __shared_ptr<>&, __const_cast_tag),\n+\tshared_ptr(const __shared_ptr<>&, __dynamic_cast_tag),\n+\tweak_ptr<>::weak_ptr(const __shared_ptr<>&), weak_ptr(const\n+\t__weak_ptr<>&)): Remove.\n+\t(shared_ptr<>::shared_ptr(const shared_ptr<>&),\n+\tshared_ptr(const weak_ptr<>&), shared_ptr(const shared_ptr<>&,\n+\t__static_cast_tag), shared_ptr(const shared_ptr<>&,\n+\t__const_cast_tag), shared_ptr(const shared_ptr<>&,\n+\t__dynamic_cast_tag), static_pointer_cast(const shared_ptr<>&),\n+\tconst_pointer_cast(const shared_ptr<>&), dynamic_pointer_cast(const\n+\tshared_ptr<>&), weak_ptr<>::weak_ptr(const shared_ptr<>&),\n+\tweak_ptr(const weak_ptr<>&), weak_ptr<>::lock(), \n+\t__enable_shared_from_this_helper(const __shared_count<>&, const\n+\tenable_shared_from_this<>*, const _Tp2*)): Add. \n+\t(class enable_shared_from_this): Add.\n+\t* testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/\n+\t1.cc: New.\n+\t* testsuite/tr1/2_general_utilities/memory/shared_ptr/casts/1.cc:\n+\tLikewise.\n+\t* testsuite/tr1/2_general_utilities/memory/weak_ptr/lock/1.cc:\n+\tLikewise.\n+\n+\t* include/tr1/boost_shared_ptr.h: Further formatting and\n+\tuglification fixes.\n+\n 2006-09-22  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/29134 (vector<bool> bits)"}, {"sha": "39d11894d05082c248074626d6b7fdd74f369fc8", "filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h", "status": "modified", "additions": 331, "deletions": 245, "changes": 576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h?ref=c8bd30ddb32028f9e61eea0293ef5eca55093c76", "patch": "@@ -46,7 +46,7 @@\n \n // GCC Note:  based on version 1.32.0 of the Boost library.\n \n-/** @file boost_memory.h\n+/** @file boost_shared_ptr.h\n  *  This is an internal header file, included by other library headers.\n  *  You should not attempt to use it directly.\n  */\n@@ -100,11 +100,13 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     { };\n \n   template<>\n-    class _Mutex_base<_S_mutex> : public __gnu_cxx::__mutex\n+    class _Mutex_base<_S_mutex>\n+    : public __gnu_cxx::__mutex\n     { };\n \n   template<_Lock_policy _Lp = __default_lock_policy>\n-    class _Sp_counted_base : public _Mutex_base<_Lp>\n+    class _Sp_counted_base\n+    : public _Mutex_base<_Lp>\n     {\n     public:  \n       _Sp_counted_base() : _M_use_count(1), _M_weak_count(1) { }\n@@ -116,70 +118,71 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       // Called when _M_use_count drops to zero, to release the resources\n       // managed by *this.\n       virtual void\n-      dispose() = 0; // nothrow\n+      _M_dispose() = 0; // nothrow\n       \n       // Called when _M_weak_count drops to zero.\n       virtual void\n-      destroy() // nothrow\n+      _M_destroy() // nothrow\n       { delete this; }\n       \n       virtual void*\n-      get_deleter(const std::type_info&) = 0;\n-      \n+      _M_get_deleter(const std::type_info&) = 0;\n+\n       void\n-      add_ref_copy()\n+      _M_add_ref_copy()\n       { __gnu_cxx::__atomic_add(&_M_use_count, 1); }\n   \n       void\n-      add_ref_lock();\n+      _M_add_ref_lock();\n       \n       void\n-      release() // nothrow\n+      _M_release() // nothrow\n       {\n \tif (__gnu_cxx::__exchange_and_add(&_M_use_count, -1) == 1)\n \t  {\n-\t    dispose();\n+\t    _M_dispose();\n #ifdef __GTHREADS\t\n \t    _GLIBCXX_READ_MEM_BARRIER;\n \t    _GLIBCXX_WRITE_MEM_BARRIER;\n #endif\n \t    if (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n-\t      destroy();\n+\t      _M_destroy();\n \t  }\n       }\n   \n       void\n-      weak_add_ref() // nothrow\n+      _M_weak_add_ref() // nothrow\n       { __gnu_cxx::__atomic_add(&_M_weak_count, 1); }\n-  \n+\n       void\n-      weak_release() // nothrow\n+      _M_weak_release() // nothrow\n       {\n \tif (__gnu_cxx::__exchange_and_add(&_M_weak_count, -1) == 1)\n \t  {\n #ifdef __GTHREADS\n \t    _GLIBCXX_READ_MEM_BARRIER;\n \t    _GLIBCXX_WRITE_MEM_BARRIER;\n #endif\n-\t    destroy();\n+\t    _M_destroy();\n \t  }\n       }\n   \n       long\n-      use_count() const // nothrow\n+      _M_get_use_count() const // nothrow\n       { return _M_use_count; }  // XXX is this MT safe? \n       \n     private:  \n       _Sp_counted_base(_Sp_counted_base const&);\n       _Sp_counted_base& operator=(_Sp_counted_base const&);\n-      \n-      _Atomic_word _M_use_count;        // #shared\n-      _Atomic_word _M_weak_count;       // #weak + (#shared != 0)\n+\n+      _Atomic_word  _M_use_count;     // #shared\n+      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n     };\n \n   template<>\n     inline void\n-    _Sp_counted_base<_S_single>::add_ref_lock()\n+    _Sp_counted_base<_S_single>::\n+    _M_add_ref_lock()\n     {\n       if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n \t{\n@@ -191,7 +194,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n #ifdef __GTHREADS\n   template<>\n     inline void\n-    _Sp_counted_base<_S_mutex>::add_ref_lock()\n+    _Sp_counted_base<_S_mutex>::\n+    _M_add_ref_lock()\n     {\n       __gnu_cxx::__scoped_lock sentry(*this);\n       if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n@@ -204,7 +208,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n   template<> \n     inline void\n-    _Sp_counted_base<_S_atomic>::add_ref_lock()\n+    _Sp_counted_base<_S_atomic>::\n+    _M_add_ref_lock()\n     {\n       // Perform lock-free add-if-not-zero operation.\n       _Atomic_word __count;\n@@ -227,44 +232,40 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     public:\n       /**\n        *  @brief   \n-       *  @pre     d(p) must not throw.\n+       *  @pre     __d(__p) must not throw.\n        */\n       _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n       : _M_ptr(__p), _M_del(__d) { }\n     \n       virtual void\n-      dispose() // nothrow\n+      _M_dispose() // nothrow\n       { _M_del(_M_ptr); }\n       \n       virtual void*\n-      get_deleter(const std::type_info& __ti)\n+      _M_get_deleter(const std::type_info& __ti)\n       { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n       \n     private:\n       _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n       _Sp_counted_base_impl& operator=(const _Sp_counted_base_impl&);\n       \n-      _Ptr     _M_ptr; // copy constructor must not throw\n-      _Deleter _M_del; // copy constructor must not throw\n+      _Ptr      _M_ptr;  // copy constructor must not throw\n+      _Deleter  _M_del;  // copy constructor must not throw\n     };\n \n   template<_Lock_policy _Lp = __default_lock_policy>\n-    class weak_count;\n+    class __weak_count;\n \n   template<_Lock_policy _Lp = __default_lock_policy>\n-    class shared_count\n+    class __shared_count\n     {\n-    private:  \n-      _Sp_counted_base<_Lp>* _M_pi;\n-  \n-      friend class weak_count<_Lp>;\n-  \n     public: \n-      shared_count() : _M_pi(0) // nothrow\n+      __shared_count()\n+      : _M_pi(0) // nothrow\n       { }\n   \n       template<typename _Ptr, typename _Deleter>\n-        shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n+        __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n         {\n \t  try\n \t    {\n@@ -276,197 +277,217 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t      __throw_exception_again;\n \t    }\n \t}\n-      \n+\n       // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n       template<typename _Tp>\n         explicit\n-        shared_count(std::auto_ptr<_Tp>& __r)\n+        __shared_count(std::auto_ptr<_Tp>& __r)\n \t: _M_pi(new _Sp_counted_base_impl<_Tp*,\n \t\t_Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n         { __r.release(); }\n   \n-      // Throw bad_weak_ptr when __r.use_count() == 0.\n-      explicit shared_count(const weak_count<_Lp>& __r);\n+      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n+      explicit\n+      __shared_count(const __weak_count<_Lp>& __r);\n   \n-      ~shared_count() // nothrow\n+      ~__shared_count() // nothrow\n       {\n \tif (_M_pi != 0)\n-\t  _M_pi->release();\n+\t  _M_pi->_M_release();\n       }\n       \n-      shared_count(const shared_count& __r)\n+      __shared_count(const __shared_count& __r)\n       : _M_pi(__r._M_pi) // nothrow\n       {\n \tif (_M_pi != 0)\n-\t  _M_pi->add_ref_copy();\n+\t  _M_pi->_M_add_ref_copy();\n       }\n   \n-      shared_count&\n-      operator=(const shared_count& __r) // nothrow\n+      __shared_count&\n+      operator=(const __shared_count& __r) // nothrow\n       {\n \t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n \tif (__tmp != _M_pi)\n \t  {\n \t    if (__tmp != 0)\n-\t      __tmp->add_ref_copy();\n+\t      __tmp->_M_add_ref_copy();\n \t    if (_M_pi != 0)\n-\t      _M_pi->release();\n+\t      _M_pi->_M_release();\n \t    _M_pi = __tmp;\n \t  }\n \treturn *this;\n       }\n   \n       void\n-      swap(shared_count& __r) // nothrow\n+      _M_swap(__shared_count& __r) // nothrow\n       {\n \t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n \t__r._M_pi = _M_pi;\n \t_M_pi = __tmp;\n       }\n   \n       long\n-      use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-      \n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n       bool\n-      unique() const // nothrow\n-      { return this->use_count() == 1; }\n+      _M_unique() const // nothrow\n+      { return this->_M_get_use_count() == 1; }\n       \n       friend inline bool\n-      operator==(const shared_count& __a, const shared_count& __b)\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n       { return __a._M_pi == __b._M_pi; }\n   \n       friend inline bool\n-      operator<(const shared_count& __a, const shared_count& __b)\n+      operator<(const __shared_count& __a, const __shared_count& __b)\n       { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n   \n       void*\n-      get_deleter(const std::type_info& __ti) const\n-      { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n+      _M_get_deleter(const std::type_info& __ti) const\n+      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n+\n+    private:\n+      friend class __weak_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n     };\n \n   template<_Lock_policy _Lp>\n-    class weak_count\n+    class __weak_count\n     {\n-    private:  \n-      _Sp_counted_base<_Lp>* _M_pi;\n-      \n-      friend class shared_count<_Lp>;\n-      \n-    public:  \n-      weak_count()\n+    public:\n+      __weak_count()\n       : _M_pi(0) // nothrow\n       { }\n   \n-      weak_count(const shared_count<_Lp>& __r)\n+      __weak_count(const __shared_count<_Lp>& __r)\n       : _M_pi(__r._M_pi) // nothrow\n       {\n \tif (_M_pi != 0)\n-\t  _M_pi->weak_add_ref();\n+\t  _M_pi->_M_weak_add_ref();\n       }\n       \n-      weak_count(const weak_count<_Lp>& __r)\n+      __weak_count(const __weak_count<_Lp>& __r)\n       : _M_pi(__r._M_pi) // nothrow\n       {\n \tif (_M_pi != 0)\n-\t  _M_pi->weak_add_ref();\n+\t  _M_pi->_M_weak_add_ref();\n       }\n       \n-      ~weak_count() // nothrow\n+      ~__weak_count() // nothrow\n       {\n \tif (_M_pi != 0)\n-\t  _M_pi->weak_release();\n+\t  _M_pi->_M_weak_release();\n       }\n       \n-      weak_count<_Lp>&\n-      operator=(const shared_count<_Lp>& __r) // nothrow\n+      __weak_count<_Lp>&\n+      operator=(const __shared_count<_Lp>& __r) // nothrow\n       {\n \t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n \tif (__tmp != 0)\n-\t  __tmp->weak_add_ref();\n+\t  __tmp->_M_weak_add_ref();\n \tif (_M_pi != 0)\n-\t  _M_pi->weak_release();\n+\t  _M_pi->_M_weak_release();\n \t_M_pi = __tmp;  \n \treturn *this;\n       }\n       \n-      weak_count<_Lp>&\n-      operator=(const weak_count<_Lp>& __r) // nothrow\n+      __weak_count<_Lp>&\n+      operator=(const __weak_count<_Lp>& __r) // nothrow\n       {\n-\t_Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n \tif (__tmp != 0)\n-\t  __tmp->weak_add_ref();\n+\t  __tmp->_M_weak_add_ref();\n \tif (_M_pi != 0)\n-\t  _M_pi->weak_release();\n+\t  _M_pi->_M_weak_release();\n \t_M_pi = __tmp;\n \treturn *this;\n       }\n-  \n+\n       void\n-      swap(weak_count<_Lp>& __r) // nothrow\n+      _M_swap(__weak_count<_Lp>& __r) // nothrow\n       {\n-\t_Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n+\t_Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n \t__r._M_pi = _M_pi;\n \t_M_pi = __tmp;\n       }\n   \n       long\n-      use_count() const // nothrow\n-      { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n-      \n+      _M_get_use_count() const // nothrow\n+      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n+\n       friend inline bool\n-      operator==(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n+      operator==(const __weak_count<_Lp>& __a, const __weak_count<_Lp>& __b)\n       { return __a._M_pi == __b._M_pi; }\n       \n       friend inline bool\n-      operator<(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n+      operator<(const __weak_count<_Lp>& __a, const __weak_count<_Lp>& __b)\n       { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n+\n+    private:\n+      friend class __shared_count<_Lp>;\n+\n+      _Sp_counted_base<_Lp>*  _M_pi;\n     };\n \n   template<_Lock_policy _Lp>\n     inline\n-    shared_count<_Lp>::\n-    shared_count(const weak_count<_Lp>& __r)\n+    __shared_count<_Lp>::\n+    __shared_count(const __weak_count<_Lp>& __r)\n     : _M_pi(__r._M_pi)\n     {\n       if (_M_pi != 0)\n-\t_M_pi->add_ref_lock();\n+\t_M_pi->_M_add_ref_lock();\n       else\n \t__throw_bad_weak_ptr();\n     }\n   \n \n-  // Forward decls.\n+  // Forward declarations.\n   template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n     class __shared_ptr;\n   \n   template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n     class __weak_ptr;\n \n-  template<typename _Tp, _Lock_policy _Lp>\n+  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n     class __enable_shared_from_this;\n \n-  struct __static_cast_tag { };\n-  struct __const_cast_tag { };\n-  struct __dynamic_cast_tag { };\n-  struct __polymorphic_cast_tag { };\n+  template<typename _Tp>\n+    class shared_ptr;\n+  \n+  template<typename _Tp>\n+    class weak_ptr;\n \n+  template<typename _Tp>\n+    class enable_shared_from_this;\n \n   // Support for enable_shared_from_this.\n \n   // Friend of __enable_shared_from_this.\n   template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n     void\n-    __enable_shared_from_this_helper(const shared_count<_Lp>&,\n+    __enable_shared_from_this_helper(const __shared_count<_Lp>&,\n \t\t\t\t     const __enable_shared_from_this<_Tp1,\n \t\t\t\t     _Lp>*, const _Tp2*);\n \n+  // Friend of enable_shared_from_this.\n+  template<typename _Tp1, typename _Tp2>\n+    void\n+    __enable_shared_from_this_helper(const __shared_count<>&,\n+\t\t\t\t     const enable_shared_from_this<_Tp1>*,\n+\t\t\t\t     const _Tp2*);\n+\n   template<_Lock_policy _Lp>\n     inline void\n-    __enable_shared_from_this_helper(const shared_count<_Lp>&, ...)\n+    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...)\n     { }\n \n \n+  struct __static_cast_tag { };\n+  struct __const_cast_tag { };\n+  struct __dynamic_cast_tag { };\n+\n   /**\n    *  @class shared_ptr <tr1/memory>\n    *\n@@ -487,10 +508,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       : _M_ptr(0), _M_refcount() // never throws\n       { }\n \n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a p.\n-       *  @param  p  A pointer that is convertible to element_type*.\n-       *  @post   use_count() == 1 && get() == p\n-       *  @throw  std::bad_alloc, in which case @c delete @a p is called.\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p.\n+       *  @param  __p  A pointer that is convertible to element_type*.\n+       *  @post   use_count() == 1 && get() == __p\n+       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n        */\n       template<typename _Tp1>\n         explicit\n@@ -499,49 +520,49 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n         {\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n \t  // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n-\t  __enable_shared_from_this_helper( _M_refcount, __p, __p );\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n \t}\n \n       //\n-      // Requirements: D's copy constructor and destructor must not throw\n+      // Requirements: _Deleter' copy constructor and destructor must not throw\n       //\n-      // __shared_ptr will release p by calling d(p)\n+      // __shared_ptr will release __p by calling __d(__p)\n       //\n-      /** @brief  Construct a %__shared_ptr that owns the pointer @a p\n-       *          and the deleter @a d.\n-       *  @param  p  A pointer.\n-       *  @param  d  A deleter.\n-       *  @post   use_count() == 1 && get() == p\n-       *  @throw  std::bad_alloc, in which case @a d(p) is called.\n+      /** @brief  Construct a %__shared_ptr that owns the pointer @a __p\n+       *          and the deleter @a __d.\n+       *  @param  __p  A pointer.\n+       *  @param  __d  A deleter.\n+       *  @post   use_count() == 1 && get() == __p\n+       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n        */\n       template<typename _Tp1, typename _Deleter>\n         __shared_ptr(_Tp1* __p, _Deleter __d)\n \t: _M_ptr(__p), _M_refcount(__p, __d)\n         {\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // TODO requires D is CopyConstructible and d(p) well-formed\n-\t  __enable_shared_from_this_helper( _M_refcount, __p, __p );\n+\t  // TODO requires _Deleter CopyConstructible and __d(__p) well-formed\n+\t  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n \t}\n       \n       //  generated copy constructor, assignment, destructor are fine.\n       \n-      /** @brief  If @a r is empty, constructs an empty %__shared_ptr;\n+      /** @brief  If @a __r is empty, constructs an empty %__shared_ptr;\n        *          otherwise construct a %__shared_ptr that shares ownership\n-       *          with @a r.\n-       *  @param  r  A %__shared_ptr.\n-       *  @post   get() == r.get() && use_count() == r.use_count()\n+       *          with @a __r.\n+       *  @param  __r  A %__shared_ptr.\n+       *  @post   get() == __r.get() && use_count() == __r.use_count()\n        *  @throw  std::bad_alloc, in which case \n        */\n       template<typename _Tp1>\n         __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n \t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n         { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n-      /** @brief  Constructs a %__shared_ptr that shares ownership with @a r\n-       *          and stores a copy of the pointer stored in @a r.\n-       *  @param  r  A weak_ptr.\n-       *  @post   use_count() == r.use_count()\n-       *  @throw  bad_weak_ptr when r.expired(),\n+      /** @brief  Constructs a %__shared_ptr that shares ownership with @a __r\n+       *          and stores a copy of the pointer stored in @a __r.\n+       *  @param  __r  A weak_ptr.\n+       *  @post   use_count() == __r.use_count()\n+       *  @throw  bad_weak_ptr when __r.expired(),\n        *          in which case the constructor has no effect.\n        */\n       template<typename _Tp1>\n@@ -550,24 +571,24 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t: _M_refcount(__r._M_refcount) // may throw\n         {\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t  // It is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n+\t  // It is now safe to copy __r._M_ptr, as _M_refcount(__r._M_refcount)\n \t  // did not throw.\n \t  _M_ptr = __r._M_ptr;\n \t}\n \n       /**\n-       * @post use_count() == 1 and r.get() == 0\n+       * @post use_count() == 1 and __r.get() == 0\n        */\n       template<typename _Tp1>\n         explicit\n         __shared_ptr(std::auto_ptr<_Tp1>& __r)\n \t: _M_ptr(__r.get()), _M_refcount()\n         {\n-\t  // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n-\t  // delete r.release() well-formed\n-\t  _Tp1 * __tmp = __r.get();\n-\t  _M_refcount = shared_count<_Lp>(__r);\n-\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp );\n+\t  // TODO requires __r.release() convertible to _Tp*, _Tp1 is complete,\n+\t  // delete __r.release() well-formed\n+\t  _Tp1* __tmp = __r.get();\n+\t  _M_refcount = __shared_count<_Lp>(__r);\n+\t  __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);\n \t}\n \n       template<typename _Tp1>\n@@ -588,15 +609,15 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  _M_refcount(__r._M_refcount)\n         {\n \t  if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n-\t    _M_refcount = shared_count<_Lp>();\n+\t    _M_refcount = __shared_count<_Lp>();\n \t}\n       \n       template<typename _Tp1>\n         __shared_ptr&\n         operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n         {\n \t  _M_ptr = __r._M_ptr;\n-\t  _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n+\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn't throw\n \t  return *this;\n \t}\n \n@@ -623,10 +644,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       template<typename _Tp1, typename _Deleter>\n         void\n-        reset(_Tp1 * __p, _Deleter __d)\n+        reset(_Tp1* __p, _Deleter __d)\n         { __shared_ptr(__p, __d).swap(*this); }\n \n-      // Allow instantiation when _Tp is [cv-qual] void.\n+      // Allow class instantiation when _Tp is [cv-qual] void.\n       typename add_reference<_Tp>::type\n       operator*() const // never throws\n       {\n@@ -655,23 +676,23 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       bool\n       unique() const // never throws\n-      { return _M_refcount.unique(); }\n+      { return _M_refcount._M_unique(); }\n \n       long\n       use_count() const // never throws\n-      { return _M_refcount.use_count(); }\n+      { return _M_refcount._M_get_use_count(); }\n \n       void\n       swap(__shared_ptr<_Tp, _Lp>& __other) // never throws\n       {\n \tstd::swap(_M_ptr, __other._M_ptr);\n-\t_M_refcount.swap(__other._M_refcount);\n+\t_M_refcount._M_swap(__other._M_refcount);\n       }\n \n     private:\n       void*\n       _M_get_deleter(const std::type_info& __ti) const\n-      { return _M_refcount.get_deleter(__ti); }\n+      { return _M_refcount._M_get_deleter(__ti); }\n \n       template<typename _Tp1, _Lock_policy _Lp1>\n         bool\n@@ -700,8 +721,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n         operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n         { return __a._M_less(__b); }\n \n-      _Tp*         \t        _M_ptr;         // Contained pointer.\n-      shared_count<_Lp> \t_M_refcount;    // Reference counter.\n+      _Tp*         \t   _M_ptr;         // Contained pointer.\n+      __shared_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n \n   // 2.2.3.8 shared_ptr specialized algorithms.\n@@ -712,7 +733,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n   // 2.2.3.9 shared_ptr casts\n   /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<T>(static_cast<T*>(r.get()))</code>\n+   *           <code>shared_ptr<_Tp, _Lp>(static_cast<_Tp*>(__r.get()))</code>\n    *           will eventually result in undefined behaviour,\n    *           attempting to delete the same object twice.\n    */\n@@ -722,7 +743,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n \n   /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n+   *           <code>shared_ptr<_Tp, _Lp>(const_cast<_Tp*>(__r.get()))</code>\n    *           will eventually result in undefined behaviour,\n    *           attempting to delete the same object twice.\n    */\n@@ -732,7 +753,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n \n   /** @warning The seemingly equivalent\n-   *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n+   *           <code>shared_ptr<_Tp, _Lp>(dynamic_cast<_Tp*>(__r.get()))</code>\n    *           will eventually result in undefined behaviour,\n    *           attempting to delete the same object twice.\n    */\n@@ -764,31 +785,32 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     public:\n       typedef _Tp element_type;\n       \n-      __weak_ptr() : _M_ptr(0), _M_refcount() // never throws\n+      __weak_ptr()\n+      : _M_ptr(0), _M_refcount() // never throws\n       { }\n \n       // Generated copy constructor, assignment, destructor are fine.\n       \n       // The \"obvious\" converting constructor implementation:\n       //\n-      //  template<class Y>\n-      //    __weak_ptr(__weak_ptr<Y> const & r)\n-      //    : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n+      //  template<typename _Tp1>\n+      //    __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n+      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n       //    { }\n       //\n       // has a serious problem.\n       //\n-      //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n-      //  conversion may require access to *r._M_ptr (virtual inheritance).\n+      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n+      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n       //\n       // It is not possible to avoid spurious access violations since\n-      // in multithreaded programs r._M_ptr may be invalidated at any point.\n+      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n       template<typename _Tp1>\n         __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n \t: _M_refcount(__r._M_refcount) // never throws\n         {\n \t  __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-\t    _M_ptr = __r.lock().get();\n+\t  _M_ptr = __r.lock().get();\n \t}\n \n       template<typename _Tp1>\n@@ -821,12 +843,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t// Optimization: avoid throw overhead.\n \tif (expired())\n \t  return __shared_ptr<element_type, _Lp>();\n-      \n+\n \ttry\n \t  {\n \t    return __shared_ptr<element_type, _Lp>(*this);\n \t  }\n-\tcatch (const bad_weak_ptr&)\n+\tcatch(const bad_weak_ptr&)\n \t  {\n \t    // Q: How can we get here?\n \t    // A: Another thread may have invalidated r after the\n@@ -844,11 +866,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       long\n       use_count() const // never throws\n-      { return _M_refcount.use_count(); }\n+      { return _M_refcount._M_get_use_count(); }\n \n       bool\n       expired() const // never throws\n-      { return _M_refcount.use_count() == 0; }\n+      { return _M_refcount._M_get_use_count() == 0; }\n       \n       void\n       reset() // never throws\n@@ -858,45 +880,46 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       swap(__weak_ptr& __s) // never throws\n       {\n \tstd::swap(_M_ptr, __s._M_ptr);\n-\t_M_refcount.swap(__s._M_refcount);\n+\t_M_refcount._M_swap(__s._M_refcount);\n       }\n \n     private:\n-      template<typename _Tp1>\n-        bool\n-        _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n-        { return _M_refcount < __rhs._M_refcount; }\n-\n       // Used by __enable_shared_from_this.\n       void\n-      _M_assign(_Tp* __ptr, const shared_count<_Lp>& __refcount)\n+      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount)\n       {\n \t_M_ptr = __ptr;\n \t_M_refcount = __refcount;\n       }\n \n+      template<typename _Tp1>\n+        bool\n+        _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n+        { return _M_refcount < __rhs._M_refcount; }\n+\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+      friend class __enable_shared_from_this<_Tp, _Lp>;\n+      friend class enable_shared_from_this<_Tp>;\n+\n       // Friend injected into namespace and found by ADL.\n       template<typename _Tp1>\n         friend inline bool\n         operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, _Lp>& __rhs)\n         { return __lhs._M_less(__rhs); }\n-      \n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n-      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n-      friend class __enable_shared_from_this<_Tp, _Lp>;\n-      \n-      _Tp*       \t\t_M_ptr;           // Contained pointer.\n-      weak_count<_Lp> \t        _M_refcount;      // Reference counter.\n+\n+      _Tp*       \t _M_ptr;         // Contained pointer.\n+      __weak_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n \n   // 2.2.4.7 weak_ptr specialized algorithms.\n   template<typename _Tp, _Lock_policy _Lp>\n-    void\n+    inline void\n     swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n     { __a.swap(__b); }\n \n \n-  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n+  template<typename _Tp, _Lock_policy _Lp>\n     class __enable_shared_from_this\n     {\n     protected:\n@@ -913,146 +936,209 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     public:\n       __shared_ptr<_Tp, _Lp>\n       shared_from_this()\n-      {\n-\t__shared_ptr<_Tp, _Lp> __p(this->_M_weak_this);\n-\treturn __p;\n-      }\n-      \n+      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }\n+\n       __shared_ptr<const _Tp, _Lp>\n       shared_from_this() const\n-      {\n-\t__shared_ptr<const _Tp, _Lp> __p(this->_M_weak_this);\n-\treturn __p;\n-      }\n-      \n+      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }\n+\n     private:\n       template<typename _Tp1>\n         void\n-        _M_weak_assign(_Tp1* __p, const shared_count<_Lp>& __n) const\n+        _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const\n         { _M_weak_this._M_assign(__p, __n); }\n \n       template<typename _Tp1>\n         friend void\n-        __enable_shared_from_this_helper(const shared_count<_Lp>& __pn,\n+        __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,\n \t\t\t\t\t const __enable_shared_from_this* __pe,\n \t\t\t\t\t const _Tp1* __px)\n         {\n \t  if (__pe != 0)\n \t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n \t}\n-      \n-      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;\n-    };\n-\n-  template<typename _Tp>\n-    class shared_ptr;\n-\n-  // The actual TR1 weak_ptr, with forwarding constructors and\n-  // assignment operators.\n-  template<typename _Tp>\n-    class weak_ptr : public __weak_ptr<_Tp>\n-    {\n-    public:\n-      weak_ptr()\n-      : __weak_ptr<_Tp>() { }\n-      \n-      template<typename _Tp1>\n-        weak_ptr(const __weak_ptr<_Tp1>& __r)\n-\t: __weak_ptr<_Tp>(__r) { }\n-    \n-      template<typename _Tp1>\n-        weak_ptr(const __shared_ptr<_Tp1>& __r)\n-\t: __weak_ptr<_Tp>(__r) { }\n-\n-      template<typename _Tp1>\n-        weak_ptr&\n-        operator=(const weak_ptr<_Tp1>& __r) // never throws\n-        {\n-\t  this->__weak_ptr<_Tp>::operator=(__r);\n-\t  return *this;\n-\t}\n \n-      template<typename _Tp1>\n-        weak_ptr&\n-        operator=(const shared_ptr<_Tp1>& __r) // never throws\n-        {\n-\t  this->__weak_ptr<_Tp>::operator=(__r);\n-\t  return *this;\n-\t}\n+      mutable __weak_ptr<_Tp, _Lp>  _M_weak_this;\n     };\n \n+\n   // The actual TR1 shared_ptr, with forwarding constructors and\n   // assignment operators.\n   template<typename _Tp>\n-    class shared_ptr : public __shared_ptr<_Tp>\n+    class shared_ptr\n+    : public __shared_ptr<_Tp>\n     {\n     public:\n-      shared_ptr() : __shared_ptr<_Tp>() { }\n-      \n+      shared_ptr()\n+      : __shared_ptr<_Tp>() { }\n+\n       template<typename _Tp1>\n         explicit\n         shared_ptr(_Tp1* __p)\n \t: __shared_ptr<_Tp>(__p) { }\n-    \n+\n       template<typename _Tp1, typename _Deleter>\n         shared_ptr(_Tp1* __p, _Deleter __d)\n \t: __shared_ptr<_Tp>(__p, __d) { }\n-    \n+\n       template<typename _Tp1>\n-        shared_ptr(const __shared_ptr<_Tp1>& __r)\n+        shared_ptr(const shared_ptr<_Tp1>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n-    \n+\n       template<typename _Tp1>\n         explicit\n-        shared_ptr(const __weak_ptr<_Tp1>& __r)\n+        shared_ptr(const weak_ptr<_Tp1>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n-    \n+\n       template<typename _Tp1>\n         explicit\n         shared_ptr(std::auto_ptr<_Tp1>& __r)\n \t: __shared_ptr<_Tp>(__r) { }\n \n       template<typename _Tp1>\n-        shared_ptr(const __shared_ptr<_Tp1>& __r, __static_cast_tag)\n+        shared_ptr(const shared_ptr<_Tp1>& __r, __static_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __static_cast_tag()) { }\n \n       template<typename _Tp1>\n-        shared_ptr(const __shared_ptr<_Tp1>& __r, __const_cast_tag)\n+        shared_ptr(const shared_ptr<_Tp1>& __r, __const_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __const_cast_tag()) { }\n-    \n+\n       template<typename _Tp1>\n-        shared_ptr(const __shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n+        shared_ptr(const shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n \t: __shared_ptr<_Tp>(__r, __dynamic_cast_tag()) { }\n \n-      // Additional non-base assignment operators to avoid excessive errors.\n       template<typename _Tp1>\n         shared_ptr&\n-        operator=(std::auto_ptr<_Tp1>& __r)\n+        operator=(const shared_ptr<_Tp1>& __r) // never throws\n         {\n \t  this->__shared_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n \n       template<typename _Tp1>\n         shared_ptr&\n-        operator=(const shared_ptr<_Tp1>& __r) // never throws\n+        operator=(std::auto_ptr<_Tp1>& __r)\n         {\n \t  this->__shared_ptr<_Tp>::operator=(__r);\n \t  return *this;\n \t}\n     };\n \n+  template<typename _Tp, typename _Tp1>\n+    shared_ptr<_Tp>\n+    static_pointer_cast(const shared_ptr<_Tp1>& __r)\n+    { return shared_ptr<_Tp>(__r, __static_cast_tag()); }\n+\n+  template<typename _Tp, typename _Tp1>\n+    shared_ptr<_Tp>\n+    const_pointer_cast(const shared_ptr<_Tp1>& __r)\n+    { return shared_ptr<_Tp>(__r, __const_cast_tag()); }\n+\n+  template<typename _Tp, typename _Tp1>\n+    shared_ptr<_Tp>\n+    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)\n+    { return shared_ptr<_Tp>(__r, __dynamic_cast_tag()); }\n+\n+\n+  // The actual TR1 weak_ptr, with forwarding constructors and\n+  // assignment operators.\n+  template<typename _Tp>\n+    class weak_ptr\n+    : public __weak_ptr<_Tp>\n+    {\n+    public:\n+      weak_ptr()\n+      : __weak_ptr<_Tp>() { }\n+      \n+      template<typename _Tp1>\n+        weak_ptr(const weak_ptr<_Tp1>& __r)\n+\t: __weak_ptr<_Tp>(__r) { }\n+\n+      template<typename _Tp1>\n+        weak_ptr(const shared_ptr<_Tp1>& __r)\n+\t: __weak_ptr<_Tp>(__r) { }\n+\n+      template<typename _Tp1>\n+        weak_ptr&\n+        operator=(const weak_ptr<_Tp1>& __r) // never throws\n+        {\n+\t  this->__weak_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n+\n+      template<typename _Tp1>\n+        weak_ptr&\n+        operator=(const shared_ptr<_Tp1>& __r) // never throws\n+        {\n+\t  this->__weak_ptr<_Tp>::operator=(__r);\n+\t  return *this;\n+\t}\n+\n+      shared_ptr<_Tp>\n+      lock() const // never throws\n+      {\n+#ifdef __GTHREADS\n+\tif (this->expired())\n+\t  return shared_ptr<_Tp>();\n+\n+\ttry\n+\t  {\n+\t    return shared_ptr<_Tp>(*this);\n+\t  }\n+\tcatch(const bad_weak_ptr&)\n+\t  {\n+\t    return shared_ptr<_Tp>();\n+\t  }\n+#else\n+\treturn this->expired() ? shared_ptr<_Tp>()\n+\t                       : shared_ptr<_Tp>(*this);\n+#endif\n+      }\n+    };\n+\n+\n   template<typename _Tp>\n-    class enable_shared_from_this : public __enable_shared_from_this<_Tp>\n+    class enable_shared_from_this\n     {\n     protected:\n-      enable_shared_from_this()\n-      : __enable_shared_from_this<_Tp>() { }\n+      enable_shared_from_this() { }\n       \n-      enable_shared_from_this(const enable_shared_from_this&)\n-      : __enable_shared_from_this<_Tp>(enable_shared_from_this<_Tp>()) { }\n+      enable_shared_from_this(const enable_shared_from_this&) { }\n+\n+      enable_shared_from_this&\n+      operator=(const enable_shared_from_this&)\n+      { return *this; }\n+\n+      ~enable_shared_from_this() { }\n+\n+    public:\n+      shared_ptr<_Tp>\n+      shared_from_this()\n+      { return shared_ptr<_Tp>(this->_M_weak_this); }\n+\n+      shared_ptr<const _Tp>\n+      shared_from_this() const\n+      { return shared_ptr<const _Tp>(this->_M_weak_this); }\n+\n+    private:\n+      template<typename _Tp1>\n+        void\n+        _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const\n+        { _M_weak_this._M_assign(__p, __n); }\n+\n+      template<typename _Tp1>\n+        friend void\n+        __enable_shared_from_this_helper(const __shared_count<>& __pn,\n+\t\t\t\t\t const enable_shared_from_this* __pe,\n+\t\t\t\t\t const _Tp1* __px)\n+        {\n+\t  if (__pe != 0)\n+\t    __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n+\t}\n+\n+      mutable weak_ptr<_Tp>  _M_weak_this;\n     };\n-  \n+\n _GLIBCXX_END_NAMESPACE\n } // namespace std\n "}, {"sha": "2d1ebad4cedfa2c4c45d9cbde3c39456d58c00eb", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/enable_shared_from_this/1.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fenable_shared_from_this%2F1.cc?ref=c8bd30ddb32028f9e61eea0293ef5eca55093c76", "patch": "@@ -0,0 +1,39 @@\n+// 2006-09-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 2.2.5 Template class enable_shared_from_this [tr.util.smartptr.enab]\n+\n+#include <tr1/memory>\n+#include <testsuite_tr1.h>\n+\n+// { dg-do compile }\n+\n+struct X : public std::tr1::enable_shared_from_this<X>\n+{\n+};\n+\n+int main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::tr1::shared_ptr;\n+\n+  shared_ptr<X> spx(new X);\n+  check_ret_type<shared_ptr<X> >(spx->shared_from_this());\n+}"}, {"sha": "8851f254b4d0a187b4f8032763717f5547fb2e13", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/shared_ptr/casts/1.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcasts%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcasts%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fshared_ptr%2Fcasts%2F1.cc?ref=c8bd30ddb32028f9e61eea0293ef5eca55093c76", "patch": "@@ -0,0 +1,46 @@\n+// 2006-09-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// TR1 2.2.3.9 shared_ptr casts [tr.util.smartptr.shared.cast]\n+\n+#include <tr1/memory>\n+#include <testsuite_tr1.h>\n+\n+// { dg-do compile }\n+\n+struct MyP { virtual ~MyP() { }; };\n+struct MyDP : MyP { };\n+\n+int main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::tr1::shared_ptr;\n+  using std::tr1::static_pointer_cast;\n+  using std::tr1::const_pointer_cast;\n+  using std::tr1::dynamic_pointer_cast;\n+\n+  shared_ptr<double> spd;\n+  shared_ptr<const int> spci;\n+  shared_ptr<MyP> spa;\n+\n+  check_ret_type<shared_ptr<void> >(static_pointer_cast<void>(spd));\n+  check_ret_type<shared_ptr<int> >(const_pointer_cast<int>(spci));\n+  check_ret_type<shared_ptr<MyDP> >(static_pointer_cast<MyDP>(spa));  \n+}"}, {"sha": "0367b3100591599c0cd5399da89159a2250b0069", "filename": "libstdc++-v3/testsuite/tr1/2_general_utilities/memory/weak_ptr/lock/1.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fweak_ptr%2Flock%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8bd30ddb32028f9e61eea0293ef5eca55093c76/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fweak_ptr%2Flock%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F2_general_utilities%2Fmemory%2Fweak_ptr%2Flock%2F1.cc?ref=c8bd30ddb32028f9e61eea0293ef5eca55093c76", "patch": "@@ -0,0 +1,36 @@\n+// 2006-09-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// TR1 2.2.4 Template class weak_ptr [tr.util.smartptr.weak]\n+\n+#include <tr1/memory>\n+#include <testsuite_tr1.h>\n+\n+// { dg-do compile }\n+\n+int main()\n+{\n+  using __gnu_test::check_ret_type;\n+  using std::tr1::weak_ptr;\n+  using std::tr1::shared_ptr;\n+\n+  weak_ptr<int> wp;\n+  check_ret_type<shared_ptr<int> >(wp.lock());\n+}"}]}