{"sha": "b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ3YjVlMDg5YmNhMWQ1YTNmZjJkNzIyNThiZWE2YjU0NmY4NTVjZg==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2006-02-16T21:03:16Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2006-02-16T21:03:16Z"}, "message": "nested_struct2.c: Remove ffi_type_mylong definition.\n\n2006-02-16  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* testsuite/libffi.call/nested_struct2.c: Remove ffi_type_mylong\n\tdefinition.\n\t* testsuite/libffi.call/ffitest.h: Add ffi_type_mylong definition\n\there to be used by other test cases too.\n\n\t* testsuite/libffi.call/nested_struct10.c: New test case.\n\t* testsuite/libffi.call/nested_struct9.c: Likewise.\n\t* testsuite/libffi.call/nested_struct8.c: Likewise.\n\t* testsuite/libffi.call/nested_struct7.c: Likewise.\n\t* testsuite/libffi.call/nested_struct6.c: Likewise.\n\t* testsuite/libffi.call/nested_struct5.c: Likewise.\n\t* testsuite/libffi.call/nested_struct4.c: Likewise.\n\nFrom-SVN: r111151", "tree": {"sha": "47c1bfaa187a86c4f186f486eb0f9abb5da3d334", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47c1bfaa187a86c4f186f486eb0f9abb5da3d334"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/comments", "author": null, "committer": null, "parents": [{"sha": "8afa305af66aa8586d68aec324304499ee9a3da2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afa305af66aa8586d68aec324304499ee9a3da2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afa305af66aa8586d68aec324304499ee9a3da2"}], "stats": {"total": 953, "additions": 942, "deletions": 11}, "files": [{"sha": "737b566261228cf5ee8a65c4e1449505551665a7", "filename": "libffi/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -1,3 +1,18 @@\n+2006-02-16  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* testsuite/libffi.call/nested_struct2.c: Remove ffi_type_mylong\n+\tdefinition.\n+\t* testsuite/libffi.call/ffitest.h: Add ffi_type_mylong definition\n+\there to be used by other test cases too.\n+\n+\t* testsuite/libffi.call/nested_struct10.c: New test case.\n+\t* testsuite/libffi.call/nested_struct9.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct8.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct7.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct6.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct5.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct4.c: Likewise.\n+\n 2006-01-21  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* configure.ac: Enable libffi for sparc64-*-freebsd*."}, {"sha": "45c0564966fa6ed89771eeeb9f08d98c090f354b", "filename": "libffi/testsuite/libffi.call/ffitest.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -9,6 +9,16 @@\n \n #define CHECK(x) !(x) ? abort() : 0\n \n+/* Define our own long for easier handling on multilib targets.  */\n+#if LONG_MAX == 2147483647\n+#define ffi_type_mylong ffi_type_uint32\n+#else\n+#if LONG_MAX == 9223372036854775807\n+#define ffi_type_mylong ffi_type_uint64\n+#else\n+#error \"Error, size LONG not defined as expected\"\n+#endif\n+#endif\n \n /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n    file open.  */"}, {"sha": "37897d018c1da9d17ec85a8862b1a3da72fa556e", "filename": "libffi/testsuite/libffi.call/nested_struct10.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,141 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  unsigned long long a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  unsigned char y;\n+  struct A x;\n+  unsigned int z;\n+} B;\n+\n+typedef struct C {\n+  unsigned long long d;\n+  unsigned char e;\n+} C;\n+\n+static B B_fn(struct A b2, struct B b3, struct C b4)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a + b3.z + b4.d;\n+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;\n+  result.y = b2.b + b3.x.b + b4.e;\n+\n+  printf(\"%d %d %d %d %d %d %d %d: %d %d %d\\n\", (int)b2.a, b2.b,\n+\t (int)b3.x.a, b3.x.b, b3.y, b3.z, (int)b4.d, b4.e,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+  struct C b2;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+  b2 = *(struct C*)(args[2]);\n+\n+  *(B*)resp = B_fn(b0, b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[4];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[4];\n+  ffi_type* cls_struct_fields2[3];\n+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n+  ffi_type* dbl_arg_types[4];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  cls_struct_type2.size = 0;\n+  cls_struct_type2.alignment = 0;\n+  cls_struct_type2.type = FFI_TYPE_STRUCT;\n+  cls_struct_type2.elements = cls_struct_fields2;\n+\n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = { 99, {12LL , 127}, 255};\n+  struct C g_dbl = { 2LL, 9};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uint64;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &ffi_type_uchar;\n+  cls_struct_fields1[1] = &cls_struct_type;\n+  cls_struct_fields1[2] = &ffi_type_uint32;\n+  cls_struct_fields1[3] = NULL;\n+\n+  cls_struct_fields2[0] = &ffi_type_uint64;\n+  cls_struct_fields2[1] = &ffi_type_uchar;\n+  cls_struct_fields2[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = &cls_struct_type2;\n+  dbl_arg_types[3] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99 255 2 9: 270 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99 255 2 9: 270 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + f_dbl.z + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  exit(0);\n+}"}, {"sha": "2972422ad2e4d734769d87a15fa0aae29350562a", "filename": "libffi/testsuite/libffi.call/nested_struct2.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -9,16 +9,6 @@\n /* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n #include \"ffitest.h\"\n \n-#if LONG_MAX == 2147483647\n-#define ffi_type_mylong ffi_type_uint32\n-#else\n-#if LONG_MAX == 9223372036854775807\n-#define ffi_type_mylong ffi_type_uint64\n-#else\n-#error \"Error, size LONG not defined as expected\"\n-#endif\n-#endif\n-\n typedef struct A {\n   unsigned long a;\n   unsigned char b;\n@@ -115,13 +105,13 @@ int main (void)\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n \n-\n   CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n \n   res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n   /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n   CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n   CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n   CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n   exit(0);\n }"}, {"sha": "d6e21d6c0ce76aec7562d56e70cb25908515a4ad", "filename": "libffi/testsuite/libffi.call/nested_struct4.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,119 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  double a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+static B B_fn(struct A b2, struct B b3)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a;\n+  result.x.b = b2.b + b3.x.b + b3.y;\n+  result.y = b2.b + b3.x.b;\n+\n+  printf(\"%d %d %d %d %d: %d %d %d\\n\", (int)b2.a, b2.b,\n+\t (int)b3.x.a, b3.x.b, b3.y,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+\n+  *(B*)resp = B_fn(b0, b1);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type cls_struct_type, cls_struct_type1;\n+  ffi_type* dbl_arg_types[3];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  struct A e_dbl = { 1.0, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+  exit(0);\n+}"}, {"sha": "79d67eedf618f083113fcd06f341136c681f68a4", "filename": "libffi/testsuite/libffi.call/nested_struct5.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,120 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  long double a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+static B B_fn(struct A b2, struct B b3)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a;\n+  result.x.b = b2.b + b3.x.b + b3.y;\n+  result.y = b2.b + b3.x.b;\n+\n+  printf(\"%d %d %d %d %d: %d %d %d\\n\", (int)b2.a, b2.b,\n+\t (int)b3.x.a, b3.x.b, b3.y,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+\n+  *(B*)resp = B_fn(b0, b1);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type cls_struct_type, cls_struct_type1;\n+  ffi_type* dbl_arg_types[3];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  struct A e_dbl = { 1.0, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_longdouble;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+  exit(0);\n+}"}, {"sha": "feb58b332345b0dce55b0d4c8ba5f1c84bcbcacb", "filename": "libffi/testsuite/libffi.call/nested_struct6.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,139 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  double a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+typedef struct C {\n+  long d;\n+  unsigned char e;\n+} C;\n+\n+static B B_fn(struct A b2, struct B b3, struct C b4)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a + b4.d;\n+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;\n+  result.y = b2.b + b3.x.b + b4.e;\n+\n+  printf(\"%d %d %d %d %d %d %d: %d %d %d\\n\", (int)b2.a, b2.b,\n+\t (int)b3.x.a, b3.x.b, b3.y, (int)b4.d, b4.e,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+  struct C b2;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+  b2 = *(struct C*)(args[2]);\n+\n+  *(B*)resp = B_fn(b0, b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[4];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type* cls_struct_fields2[3];\n+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n+  ffi_type* dbl_arg_types[4];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  cls_struct_type2.size = 0;\n+  cls_struct_type2.alignment = 0;\n+  cls_struct_type2.type = FFI_TYPE_STRUCT;\n+  cls_struct_type2.elements = cls_struct_fields2;\n+\n+  struct A e_dbl = { 1.0, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+  struct C g_dbl = { 2, 9};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_double;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+  cls_struct_fields2[0] = &ffi_type_mylong;\n+  cls_struct_fields2[1] = &ffi_type_uchar;\n+  cls_struct_fields2[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = &cls_struct_type2;\n+  dbl_arg_types[3] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99 2 9: 15 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99 2 9: 15 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  exit(0);\n+}"}, {"sha": "fa745de73809c6b6e4bdf6a681fe0eda45acca2a", "filename": "libffi/testsuite/libffi.call/nested_struct7.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,119 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  unsigned long long a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+static B B_fn(struct A b2, struct B b3)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a;\n+  result.x.b = b2.b + b3.x.b + b3.y;\n+  result.y = b2.b + b3.x.b;\n+\n+  printf(\"%d %d %d %d %d: %d %d %d\\n\", (int)b2.a, b2.b,\n+\t (int)b3.x.a, b3.x.b, b3.y,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+\n+  *(B*)resp = B_fn(b0, b1);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[3];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type cls_struct_type, cls_struct_type1;\n+  ffi_type* dbl_arg_types[3];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uint64;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B))(pcl))(e_dbl, f_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99: 13 233 134\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b));\n+\n+  exit(0);\n+}"}, {"sha": "5c231dead2ed548ac5fce580ce69e2a0fe5314de", "filename": "libffi/testsuite/libffi.call/nested_struct8.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,139 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  unsigned long long a;\n+  unsigned char b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+typedef struct C {\n+  unsigned long long d;\n+  unsigned char e;\n+} C;\n+\n+static B B_fn(struct A b2, struct B b3, struct C b4)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a + b4.d;\n+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;\n+  result.y = b2.b + b3.x.b + b4.e;\n+\n+  printf(\"%d %d %d %d %d %d %d: %d %d %d\\n\", (int)b2.a, b2.b,\n+\t (int)b3.x.a, b3.x.b, b3.y, (int)b4.d, b4.e,\n+\t (int)result.x.a, result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+  struct C b2;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+  b2 = *(struct C*)(args[2]);\n+\n+  *(B*)resp = B_fn(b0, b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[4];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type* cls_struct_fields2[3];\n+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n+  ffi_type* dbl_arg_types[4];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  cls_struct_type2.size = 0;\n+  cls_struct_type2.alignment = 0;\n+  cls_struct_type2.type = FFI_TYPE_STRUCT;\n+  cls_struct_type2.elements = cls_struct_fields2;\n+\n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = {{12LL , 127}, 99};\n+  struct C g_dbl = { 2LL, 9};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uint64;\n+  cls_struct_fields[1] = &ffi_type_uchar;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+  cls_struct_fields2[0] = &ffi_type_uint64;\n+  cls_struct_fields2[1] = &ffi_type_uchar;\n+  cls_struct_fields2[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = &cls_struct_type2;\n+  dbl_arg_types[3] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99 2 9: 15 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99 2 9: 15 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  exit(0);\n+}"}, {"sha": "4a3e9e31b038a31cd59bc7e5b96007f0394cec1c", "filename": "libffi/testsuite/libffi.call/nested_struct9.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b47b5e089bca1d5a3ff2d72258bea6b546f855cf/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c?ref=b47b5e089bca1d5a3ff2d72258bea6b546f855cf", "patch": "@@ -0,0 +1,139 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck structure passing with different structure size.\n+\t\tContains structs as parameter of the struct itself.\n+\t\tSample taken from Alan Modras patch to src/prep_cif.c.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\t<andreast@gcc.gnu.org> 20051010\t */\n+\n+/* { dg-do run { xfail mips64*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  unsigned char a;\n+  unsigned long long b;\n+} A;\n+\n+typedef struct B {\n+  struct A x;\n+  unsigned char y;\n+} B;\n+\n+typedef struct C {\n+  unsigned long d;\n+  unsigned char e;\n+} C;\n+\n+static B B_fn(struct A b2, struct B b3, struct C b4)\n+{\n+  struct B result;\n+\n+  result.x.a = b2.a + b3.x.a + b4.d;\n+  result.x.b = b2.b + b3.x.b + b3.y + b4.e;\n+  result.y = b2.b + b3.x.b + b4.e;\n+\n+  printf(\"%d %d %d %d %d %d %d: %d %d %d\\n\", b2.a, (int)b2.b,\n+\t b3.x.a, (int)b3.x.b, b3.y, (int)b4.d, b4.e,\n+\t result.x.a, (int)result.x.b, result.y);\n+\n+  return result;\n+}\n+\n+static void\n+B_gn(ffi_cif* cif __attribute__((unused)), void* resp, void** args,\n+     void* userdata __attribute__((unused)))\n+{\n+  struct A b0;\n+  struct B b1;\n+  struct C b2;\n+\n+  b0 = *(struct A*)(args[0]);\n+  b1 = *(struct B*)(args[1]);\n+  b2 = *(struct C*)(args[2]);\n+\n+  *(B*)resp = B_fn(b0, b1, b2);\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args_dbl[4];\n+  ffi_type* cls_struct_fields[3];\n+  ffi_type* cls_struct_fields1[3];\n+  ffi_type* cls_struct_fields2[3];\n+  ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n+  ffi_type* dbl_arg_types[4];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n+  cls_struct_type1.size = 0;\n+  cls_struct_type1.alignment = 0;\n+  cls_struct_type1.type = FFI_TYPE_STRUCT;\n+  cls_struct_type1.elements = cls_struct_fields1;\n+\n+  cls_struct_type2.size = 0;\n+  cls_struct_type2.alignment = 0;\n+  cls_struct_type2.type = FFI_TYPE_STRUCT;\n+  cls_struct_type2.elements = cls_struct_fields2;\n+\n+  struct A e_dbl = { 1, 7LL};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+  struct C g_dbl = { 2, 9};\n+\n+  struct B res_dbl;\n+\n+  cls_struct_fields[0] = &ffi_type_uchar;\n+  cls_struct_fields[1] = &ffi_type_uint64;\n+  cls_struct_fields[2] = NULL;\n+\n+  cls_struct_fields1[0] = &cls_struct_type;\n+  cls_struct_fields1[1] = &ffi_type_uchar;\n+  cls_struct_fields1[2] = NULL;\n+\n+  cls_struct_fields2[0] = &ffi_type_mylong;\n+  cls_struct_fields2[1] = &ffi_type_uchar;\n+  cls_struct_fields2[2] = NULL;\n+\n+\n+  dbl_arg_types[0] = &cls_struct_type;\n+  dbl_arg_types[1] = &cls_struct_type1;\n+  dbl_arg_types[2] = &cls_struct_type2;\n+  dbl_arg_types[3] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 3, &cls_struct_type1,\n+\t\t     dbl_arg_types) == FFI_OK);\n+\n+  args_dbl[0] = &e_dbl;\n+  args_dbl[1] = &f_dbl;\n+  args_dbl[2] = &g_dbl;\n+  args_dbl[3] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(B_fn), &res_dbl, args_dbl);\n+  /* { dg-output \"1 7 12 127 99 2 9: 15 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, B_gn, NULL) == FFI_OK);\n+\n+  res_dbl = ((B(*)(A, B, C))(pcl))(e_dbl, f_dbl, g_dbl);\n+  /* { dg-output \"\\n1 7 12 127 99 2 9: 15 242 143\" } */\n+  CHECK( res_dbl.x.a == (e_dbl.a + f_dbl.x.a + g_dbl.d));\n+  CHECK( res_dbl.x.b == (e_dbl.b + f_dbl.x.b + f_dbl.y + g_dbl.e));\n+  CHECK( res_dbl.y == (e_dbl.b + f_dbl.x.b + g_dbl.e));\n+\n+  exit(0);\n+}"}]}