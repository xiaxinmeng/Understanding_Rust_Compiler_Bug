{"sha": "8260c194b7ee859e189226d198f84defc373f8d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI2MGMxOTRiN2VlODU5ZTE4OTIyNmQxOThmODRkZWZjMzczZjhkMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-02T06:11:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-02T06:11:30Z"}, "message": "alpha.c (struct alpha_rtx_cost_data): Add int_div.\n\n        * config/alpha/alpha.c (struct alpha_rtx_cost_data): Add int_div.\n        (alpha_rtx_cost_data): Update to match.\n        (alpha_rtx_cost_size): New.\n        (alpha_rtx_costs): Honor optimize_size.\n\nFrom-SVN: r84014", "tree": {"sha": "4ef589ebb05634b4a13fe5da61c5a0a216a5231f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef589ebb05634b4a13fe5da61c5a0a216a5231f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8260c194b7ee859e189226d198f84defc373f8d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8260c194b7ee859e189226d198f84defc373f8d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8260c194b7ee859e189226d198f84defc373f8d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8260c194b7ee859e189226d198f84defc373f8d2/comments", "author": null, "committer": null, "parents": [{"sha": "6429e3bef352c9dc940977d3079f025f3268a8b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6429e3bef352c9dc940977d3079f025f3268a8b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6429e3bef352c9dc940977d3079f025f3268a8b9"}], "stats": {"total": 66, "additions": 51, "deletions": 15}, "files": [{"sha": "28db08a6a9152852942f6e65ba78edc272509401", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8260c194b7ee859e189226d198f84defc373f8d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8260c194b7ee859e189226d198f84defc373f8d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8260c194b7ee859e189226d198f84defc373f8d2", "patch": "@@ -1,3 +1,10 @@\n+2004-07-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (struct alpha_rtx_cost_data): Add int_div.\n+\t(alpha_rtx_cost_data): Update to match.\n+\t(alpha_rtx_cost_size): New.\n+\t(alpha_rtx_costs): Honor optimize_size.\n+\n 2004-07-01  Richard Henderson  <rth@redhat.com>\n \n         * gimple-low.c (lower_function_body): Don't reset_block_changes here."}, {"sha": "66c8df184f76ce0abc5e22e992ab38d8090d7dc8", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8260c194b7ee859e189226d198f84defc373f8d2/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8260c194b7ee859e189226d198f84defc373f8d2/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=8260c194b7ee859e189226d198f84defc373f8d2", "patch": "@@ -137,6 +137,7 @@ struct alpha_rtx_cost_data\n   unsigned char int_mult_di;\n   unsigned char int_shift;\n   unsigned char int_cmov;\n+  unsigned short int_div;\n };\n \n static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n@@ -150,6 +151,7 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n     COSTS_N_INSNS (23),\t\t/* int_mult_di */\n     COSTS_N_INSNS (2),\t\t/* int_shift */\n     COSTS_N_INSNS (2),\t\t/* int_cmov */\n+    COSTS_N_INSNS (70),\t\t/* int_div */\n   },\n   { /* EV5 */\n     COSTS_N_INSNS (4),\t\t/* fp_add */\n@@ -160,6 +162,7 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n     COSTS_N_INSNS (12),\t\t/* int_mult_di */\n     COSTS_N_INSNS (1) + 1,\t/* int_shift */\n     COSTS_N_INSNS (1),\t\t/* int_cmov */\n+    COSTS_N_INSNS (45),\t\t/* int_div */\n   },\n   { /* EV6 */\n     COSTS_N_INSNS (4),\t\t/* fp_add */\n@@ -170,9 +173,28 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n     COSTS_N_INSNS (7),\t\t/* int_mult_di */\n     COSTS_N_INSNS (1),\t\t/* int_shift */\n     COSTS_N_INSNS (2),\t\t/* int_cmov */\n+    COSTS_N_INSNS (25),\t\t/* int_div */\n   },\n };\n \n+/* Similar but tuned for code size instead of execution latency.  The\n+   extra +N is fractional cost tuning based on latency.  It's used to\n+   encourage use of cheaper insns like shift, but only if there's just\n+   one of them.  */\n+\n+static struct alpha_rtx_cost_data const alpha_rtx_cost_size =\n+{\n+  COSTS_N_INSNS (1),\t\t/* fp_add */\n+  COSTS_N_INSNS (1),\t\t/* fp_mult */\n+  COSTS_N_INSNS (1),\t\t/* fp_div_sf */\n+  COSTS_N_INSNS (1) + 1,\t/* fp_div_df */\n+  COSTS_N_INSNS (1) + 1,\t/* int_mult_si */\n+  COSTS_N_INSNS (1) + 2,\t/* int_mult_di */\n+  COSTS_N_INSNS (1),\t\t/* int_shift */\n+  COSTS_N_INSNS (1),\t\t/* int_cmov */\n+  COSTS_N_INSNS (6),\t\t/* int_div */\n+};\n+\n /* Get the number of args of a function in one of two ways.  */\n #if TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK\n #define NUM_ARGS current_function_args_info.num_args\n@@ -2103,15 +2125,21 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n+  const struct alpha_rtx_cost_data *cost_data;\n+\n+  if (optimize_size)\n+    cost_data = &alpha_rtx_cost_size;\n+  else\n+    cost_data = &alpha_rtx_cost_data[alpha_cpu];\n \n   switch (code)\n     {\n+    case CONST_INT:\n       /* If this is an 8-bit constant, return zero since it can be used\n \t nearly anywhere with no cost.  If it is a valid operand for an\n \t ADD or AND, likewise return 0 if we know it will be used in that\n \t context.  Otherwise, return 2 since it might be used there later.\n \t All other constants take at least two insns.  */\n-    case CONST_INT:\n       if (INTVAL (x) >= 0 && INTVAL (x) < 256)\n \t{\n \t  *total = 0;\n@@ -2140,16 +2168,17 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t*total = COSTS_N_INSNS (1 + (outer_code != MEM));\n       else if (tls_symbolic_operand_type (x))\n \t/* Estimate of cost for call_pal rduniq.  */\n+\t/* ??? How many insns do we emit here?  More than one...  */\n \t*total = COSTS_N_INSNS (15);\n       else\n \t/* Otherwise we do a load from the GOT.  */\n-\t*total = COSTS_N_INSNS (alpha_memory_latency);\n+\t*total = COSTS_N_INSNS (optimize_size ? 1 : alpha_memory_latency);\n       return true;\n     \n     case PLUS:\n     case MINUS:\n       if (float_mode_p)\n-\t*total = alpha_rtx_cost_data[alpha_cpu].fp_add;\n+\t*total = cost_data->fp_add;\n       else if (GET_CODE (XEXP (x, 0)) == MULT\n \t       && const48_operand (XEXP (XEXP (x, 0), 1), VOIDmode))\n \t{\n@@ -2161,11 +2190,11 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case MULT:\n       if (float_mode_p)\n-\t*total = alpha_rtx_cost_data[alpha_cpu].fp_mult;\n+\t*total = cost_data->fp_mult;\n       else if (mode == DImode)\n-\t*total = alpha_rtx_cost_data[alpha_cpu].int_mult_di;\n+\t*total = cost_data->int_mult_di;\n       else\n-\t*total = alpha_rtx_cost_data[alpha_cpu].int_mult_si;\n+\t*total = cost_data->int_mult_si;\n       return false;\n \n     case ASHIFT:\n@@ -2179,30 +2208,30 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n \n     case ASHIFTRT:\n     case LSHIFTRT:\n-      *total = alpha_rtx_cost_data[alpha_cpu].int_shift;\n+      *total = cost_data->int_shift;\n       return false;\n \n     case IF_THEN_ELSE:\n       if (float_mode_p)\n-        *total = alpha_rtx_cost_data[alpha_cpu].fp_add;\n+        *total = cost_data->fp_add;\n       else\n-        *total = alpha_rtx_cost_data[alpha_cpu].int_cmov;\n+        *total = cost_data->int_cmov;\n       return false;\n \n     case DIV:\n     case UDIV:\n     case MOD:\n     case UMOD:\n       if (!float_mode_p)\n-\t*total = COSTS_N_INSNS (70);\t/* ??? */\n+\t*total = cost_data->int_div;\n       else if (mode == SFmode)\n-        *total = alpha_rtx_cost_data[alpha_cpu].fp_div_sf;\n+        *total = cost_data->fp_div_sf;\n       else\n-        *total = alpha_rtx_cost_data[alpha_cpu].fp_div_df;\n+        *total = cost_data->fp_div_df;\n       return false;\n \n     case MEM:\n-      *total = COSTS_N_INSNS (alpha_memory_latency);\n+      *total = COSTS_N_INSNS (optimize_size ? 1 : alpha_memory_latency);\n       return true;\n \n     case NEG:\n@@ -2216,7 +2245,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case ABS:\n       if (! float_mode_p)\n \t{\n-\t  *total = COSTS_N_INSNS (1) + alpha_rtx_cost_data[alpha_cpu].int_cmov;\n+\t  *total = COSTS_N_INSNS (1) + cost_data->int_cmov;\n \t  return false;\n \t}\n       /* FALLTHRU */\n@@ -2227,7 +2256,7 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case UNSIGNED_FIX:\n     case FLOAT_EXTEND:\n     case FLOAT_TRUNCATE:\n-      *total = alpha_rtx_cost_data[alpha_cpu].fp_add;\n+      *total = cost_data->fp_add;\n       return false;\n \n     default:"}]}