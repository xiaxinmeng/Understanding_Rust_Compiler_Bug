{"sha": "bedf03a298f87b43f02eaee57542fbd10228ec08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkZjAzYTI5OGY4N2I0M2YwMmVhZWU1NzU0MmZiZDEwMjI4ZWMwOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-10-03T15:56:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-10-03T15:56:29Z"}, "message": "Implement P0840, language support for empty objects.\n\n\tThe [[no_unique_address]] attribute on a non-static data member\n\tenables the equivalent of the empty base optimization.\n\ngcc/cp/\n\t* tree.c (handle_no_unique_addr_attribute): New.\n\t(cxx_attribute_table): Add [[no_unique_address]].\n\t* class.c (field_poverlapping_p): New.\n\t(layout_class_type): Check it.  Adjust DECL_SIZE of potentially\n\toverlapping fields.\n\t(layout_empty_base_or_field): Rename from layout_empty_base, handle\n\tFIELD_DECL as well.\n\t(build_base_field, record_subobject_offsets): Adjust.\nc-family/\n\t* c-lex.c (c_common_has_attribute): Add no_unique_address.\n\nFrom-SVN: r264813", "tree": {"sha": "b89298bfa67ef964fcefa62e3d8b27bfd7807c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b89298bfa67ef964fcefa62e3d8b27bfd7807c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bedf03a298f87b43f02eaee57542fbd10228ec08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bedf03a298f87b43f02eaee57542fbd10228ec08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bedf03a298f87b43f02eaee57542fbd10228ec08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bedf03a298f87b43f02eaee57542fbd10228ec08/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "749c0e1d8b2c8dbc54af3365af506b3e1986e754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/749c0e1d8b2c8dbc54af3365af506b3e1986e754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/749c0e1d8b2c8dbc54af3365af506b3e1986e754"}], "stats": {"total": 386, "additions": 333, "deletions": 53}, "files": [{"sha": "f2c1f0988f919e914c138e63d6ea8a3edb24e161", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -1,3 +1,7 @@\n+2018-10-01  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-lex.c (c_common_has_attribute): Add no_unique_address.\n+\n 2018-10-01  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* c-ada-spec.c (get_underlying_decl): Get to the main type variant."}, {"sha": "78a132484fc8df176d5913b7e0951587ad1875cf", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -356,6 +356,8 @@ c_common_has_attribute (cpp_reader *pfile)\n \t\t       || is_attribute_p (\"nodiscard\", attr_name)\n \t\t       || is_attribute_p (\"fallthrough\", attr_name))\n \t\tresult = 201603;\n+\t      else if (is_attribute_p (\"no_unique_address\", attr_name))\n+\t\tresult = 20180312;\n \t      if (result)\n \t\tattr_name = NULL_TREE;\n \t    }"}, {"sha": "40fa94fee4e4562f251feb2ced31eb901e7572c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -1,3 +1,15 @@\n+2018-10-03  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0840, language support for empty objects.\n+\t* tree.c (handle_no_unique_addr_attribute): New.\n+\t(cxx_attribute_table): Add [[no_unique_address]].\n+\t* class.c (field_poverlapping_p): New.\n+\t(layout_class_type): Check it.  Adjust DECL_SIZE of potentially\n+\toverlapping fields.\n+\t(layout_empty_base_or_field): Rename from layout_empty_base, handle\n+\tFIELD_DECL as well.\n+\t(build_base_field, record_subobject_offsets): Adjust.\n+\n 2018-10-03  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/86109"}, {"sha": "1789d1ecb70ad34a9637fc5198a3169af5bb533e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 127, "deletions": 53, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -180,8 +180,6 @@ static tree build_vtable (tree, tree, tree);\n static void initialize_vtable (tree, vec<constructor_elt, va_gc> *);\n static void layout_nonempty_base_or_field (record_layout_info,\n \t\t\t\t\t   tree, tree, splay_tree);\n-static tree end_of_class (tree, int);\n-static bool layout_empty_base (record_layout_info, tree, tree, splay_tree);\n static void accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n \t\t\t\t   vec<constructor_elt, va_gc> **);\n static void dfs_accumulate_vtbl_inits (tree, tree, tree, tree, tree,\n@@ -202,7 +200,6 @@ static int record_subobject_offset (tree, tree, splay_tree);\n static int check_subobject_offset (tree, tree, splay_tree);\n static int walk_subobject_offsets (tree, subobject_offset_fn,\n \t\t\t\t   tree, splay_tree, tree, int);\n-static void record_subobject_offsets (tree, tree, splay_tree, bool);\n static int layout_conflict_p (tree, tree, splay_tree, int);\n static int splay_tree_compare_integer_csts (splay_tree_key k1,\n \t\t\t\t\t    splay_tree_key k2);\n@@ -3960,20 +3957,52 @@ walk_subobject_offsets (tree type,\n   return 0;\n }\n \n-/* Record all of the empty subobjects of TYPE (either a type or a\n-   binfo).  If IS_DATA_MEMBER is true, then a non-static data member\n-   is being placed at OFFSET; otherwise, it is a base class that is\n-   being placed at OFFSET.  */\n+/* Return true iff FIELD_DECL DECL is potentially overlapping.  */\n+\n+static bool\n+field_poverlapping_p (tree decl)\n+{\n+  /* Base fields are actually potentially overlapping, but C++ bases go through\n+     a different code path based on binfos, and ObjC++ base fields are laid out\n+     in objc-act, so we don't want layout_class_type to mess with them.  */\n+  if (DECL_FIELD_IS_BASE (decl))\n+    {\n+      gcc_checking_assert (c_dialect_objc ());\n+      return false;\n+    }\n+\n+  return lookup_attribute (\"no_unique_address\",\n+\t\t\t   DECL_ATTRIBUTES (decl));\n+}\n+\n+/* Record all of the empty subobjects of DECL_OR_BINFO.  */\n \n static void\n-record_subobject_offsets (tree type,\n-\t\t\t  tree offset,\n-\t\t\t  splay_tree offsets,\n-\t\t\t  bool is_data_member)\n+record_subobject_offsets (tree decl_or_binfo,\n+\t\t\t  splay_tree offsets)\n {\n+  tree type, offset;\n+  bool overlapping, vbases_p;\n+\n+  if (DECL_P (decl_or_binfo))\n+    {\n+      tree decl = decl_or_binfo;\n+      type = TREE_TYPE (decl);\n+      offset = byte_position (decl);\n+      overlapping = field_poverlapping_p (decl);\n+      vbases_p = true;\n+    }\n+  else\n+    {\n+      type = BINFO_TYPE (decl_or_binfo);\n+      offset = BINFO_OFFSET (decl_or_binfo);\n+      overlapping = true;\n+      vbases_p = false;\n+    }\n+\n   tree max_offset;\n   /* If recording subobjects for a non-static data member or a\n-     non-empty base class , we do not need to record offsets beyond\n+     non-empty base class, we do not need to record offsets beyond\n      the size of the biggest empty class.  Additional data members\n      will go at the end of the class.  Additional base classes will go\n      either at offset zero (if empty, in which case they cannot\n@@ -3985,13 +4014,13 @@ record_subobject_offsets (tree type,\n      other empty classes might later be placed) or at the end of the\n      class (where other objects might then be placed, so other empty\n      subobjects might later overlap).  */\n-  if (is_data_member\n-      || !is_empty_class (BINFO_TYPE (type)))\n+  if (!overlapping\n+      || !is_empty_class (type))\n     max_offset = sizeof_biggest_empty_class;\n   else\n     max_offset = NULL_TREE;\n   walk_subobject_offsets (type, record_subobject_offset, offset,\n-\t\t\t  offsets, max_offset, is_data_member);\n+\t\t\t  offsets, max_offset, vbases_p);\n }\n \n /* Returns nonzero if any of the empty subobjects of TYPE (located at\n@@ -4151,55 +4180,80 @@ empty_base_at_nonzero_offset_p (tree type,\n    type.  Return nonzero iff we added it at the end.  */\n \n static bool\n-layout_empty_base (record_layout_info rli, tree binfo,\n-\t\t   tree eoc, splay_tree offsets)\n+layout_empty_base_or_field (record_layout_info rli, tree binfo_or_decl,\n+\t\t\t    splay_tree offsets)\n {\n   tree alignment;\n-  tree basetype = BINFO_TYPE (binfo);\n   bool atend = false;\n+  tree binfo = NULL_TREE;\n+  tree decl = NULL_TREE;\n+  tree type;\n+  if (TREE_CODE (binfo_or_decl) == TREE_BINFO)\n+    {\n+      binfo = binfo_or_decl;\n+      type = BINFO_TYPE (binfo);\n+    }\n+  else\n+    {\n+      decl = binfo_or_decl;\n+      type = TREE_TYPE (decl);\n+    }\n \n-  /* This routine should only be used for empty classes.  */\n-  gcc_assert (is_empty_class (basetype));\n-  alignment = ssize_int (CLASSTYPE_ALIGN_UNIT (basetype));\n+  /* On some platforms (ARM), even empty classes will not be\n+     byte-aligned.  */\n+  tree eoc = round_up_loc (input_location,\n+\t\t\t   rli_size_unit_so_far (rli),\n+\t\t\t   CLASSTYPE_ALIGN_UNIT (type));\n \n-  if (!integer_zerop (BINFO_OFFSET (binfo)))\n-    propagate_binfo_offsets\n-      (binfo, size_diffop_loc (input_location,\n-\t\t\t       size_zero_node, BINFO_OFFSET (binfo)));\n+  /* This routine should only be used for empty classes.  */\n+  gcc_assert (is_empty_class (type));\n+  alignment = size_int (CLASSTYPE_ALIGN_UNIT (type));\n \n   /* This is an empty base class.  We first try to put it at offset\n      zero.  */\n-  if (layout_conflict_p (binfo,\n-\t\t\t BINFO_OFFSET (binfo),\n+  tree offset = size_zero_node;\n+  if (layout_conflict_p (type,\n+\t\t\t offset,\n \t\t\t offsets,\n \t\t\t /*vbases_p=*/0))\n     {\n       /* That didn't work.  Now, we move forward from the next\n \t available spot in the class.  */\n       atend = true;\n-      propagate_binfo_offsets (binfo, fold_convert (ssizetype, eoc));\n+      offset = eoc;\n       while (1)\n \t{\n-\t  if (!layout_conflict_p (binfo,\n-\t\t\t\t  BINFO_OFFSET (binfo),\n+\t  if (!layout_conflict_p (type,\n+\t\t\t\t  offset,\n \t\t\t\t  offsets,\n \t\t\t\t  /*vbases_p=*/0))\n \t    /* We finally found a spot where there's no overlap.  */\n \t    break;\n \n \t  /* There's overlap here, too.  Bump along to the next spot.  */\n-\t  propagate_binfo_offsets (binfo, alignment);\n+\t  offset = size_binop (PLUS_EXPR, offset, alignment);\n \t}\n     }\n \n-  if (CLASSTYPE_USER_ALIGN (basetype))\n+  if (CLASSTYPE_USER_ALIGN (type))\n     {\n-      rli->record_align = MAX (rli->record_align, CLASSTYPE_ALIGN (basetype));\n+      rli->record_align = MAX (rli->record_align, CLASSTYPE_ALIGN (type));\n       if (warn_packed)\n-\trli->unpacked_align = MAX (rli->unpacked_align, CLASSTYPE_ALIGN (basetype));\n+\trli->unpacked_align = MAX (rli->unpacked_align, CLASSTYPE_ALIGN (type));\n       TYPE_USER_ALIGN (rli->t) = 1;\n     }\n \n+  if (binfo)\n+    /* Adjust BINFO_OFFSET (binfo) to be exactly OFFSET.  */\n+    propagate_binfo_offsets (binfo,\n+\t\t\t     size_diffop (offset, BINFO_OFFSET (binfo)));\n+  else\n+    {\n+      DECL_FIELD_OFFSET (decl) = offset;\n+      DECL_FIELD_BIT_OFFSET (decl) = bitsize_zero_node;\n+      SET_DECL_OFFSET_ALIGN (decl, BITS_PER_UNIT);\n+    }\n+\n   return atend;\n }\n \n@@ -4277,15 +4331,7 @@ build_base_field (record_layout_info rli, tree binfo,\n     }\n   else\n     {\n-      tree eoc;\n-      bool atend;\n-\n-      /* On some platforms (ARM), even empty classes will not be\n-\t byte-aligned.  */\n-      eoc = round_up_loc (input_location,\n-\t\t      rli_size_unit_so_far (rli),\n-\t\t      CLASSTYPE_ALIGN_UNIT (basetype));\n-      atend = layout_empty_base (rli, binfo, eoc, offsets);\n+      bool atend = layout_empty_base_or_field (rli, binfo, offsets);\n       /* A nearly-empty class \"has no proper base class that is empty,\n \t not morally virtual, and at an offset other than zero.\"  */\n       if (!BINFO_VIRTUAL_P (binfo) && CLASSTYPE_NEARLY_EMPTY_P (t))\n@@ -4323,10 +4369,7 @@ build_base_field (record_layout_info rli, tree binfo,\n     }\n \n   /* Record the offsets of BINFO and its base subobjects.  */\n-  record_subobject_offsets (binfo,\n-\t\t\t    BINFO_OFFSET (binfo),\n-\t\t\t    offsets,\n-\t\t\t    /*is_data_member=*/false);\n+  record_subobject_offsets (binfo, offsets);\n \n   return next_field;\n }\n@@ -5886,10 +5929,11 @@ end_of_base (tree binfo)\n \n /* Returns the offset of the byte just past the end of the base class\n    with the highest offset in T.  If INCLUDE_VIRTUALS_P is zero, then\n-   only non-virtual bases are included.  */\n+   only non-virtual bases are included.  If INCLUDE_FIELDS_P is true,\n+   then also consider non-static data members.  */\n \n static tree\n-end_of_class (tree t, int include_virtuals_p)\n+end_of_class (tree t, bool include_virtuals_p, bool include_fields_p = false)\n {\n   tree result = size_zero_node;\n   vec<tree, va_gc> *vbases;\n@@ -5912,6 +5956,16 @@ end_of_class (tree t, int include_virtuals_p)\n \tresult = offset;\n     }\n \n+  if (include_fields_p)\n+    for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n+      if (TREE_CODE (field) == FIELD_DECL)\n+\t{\n+\t  offset = size_binop (PLUS_EXPR, DECL_FIELD_OFFSET (field),\n+\t\t\t       DECL_SIZE_UNIT (field));\n+\t  if (tree_int_cst_lt (result, offset))\n+\t    result = offset;\n+\t}\n+\n   if (include_virtuals_p)\n     for (vbases = CLASSTYPE_VBASECLASSES (t), i = 0;\n \t vec_safe_iterate (vbases, i, &base_binfo); i++)\n@@ -6098,6 +6152,27 @@ layout_class_type (tree t, tree *virtuals_p)\n \n       padding = NULL_TREE;\n \n+      bool might_overlap = field_poverlapping_p (field);\n+\n+      if (might_overlap && CLASS_TYPE_P (type)\n+\t  && CLASSTYPE_NON_LAYOUT_POD_P (type))\n+\t{\n+\t  /* if D is a potentially-overlapping data member, update sizeof(C) to\n+\t     max (sizeof(C), offset(D)+max (nvsize(D), dsize(D))).  */\n+\t  tree nvsize = CLASSTYPE_SIZE_UNIT (type);\n+\t  tree dsize = end_of_class (type, /*vbases*/true, /*fields*/true);\n+\t  if (tree_int_cst_le (dsize, nvsize))\n+\t    {\n+\t      DECL_SIZE_UNIT (field) = nvsize;\n+\t      DECL_SIZE (field) = CLASSTYPE_SIZE (type);\n+\t    }\n+\t  else\n+\t    {\n+\t      DECL_SIZE_UNIT (field) = dsize;\n+\t      DECL_SIZE (field) = bit_from_pos (dsize, bitsize_zero_node);\n+\t    }\n+\t}\n+\n       /* If this field is a bit-field whose width is greater than its\n \t type, then there are some special rules for allocating\n \t it.  */\n@@ -6164,15 +6239,14 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  /* We must also reset the DECL_MODE of the field.  */\n \t  SET_DECL_MODE (field, TYPE_MODE (type));\n \t}\n+      else if (might_overlap && is_empty_class (type))\n+\tlayout_empty_base_or_field (rli, field, empty_base_offsets);\n       else\n \tlayout_nonempty_base_or_field (rli, field, NULL_TREE,\n \t\t\t\t       empty_base_offsets);\n \n       /* Remember the location of any empty classes in FIELD.  */\n-      record_subobject_offsets (TREE_TYPE (field),\n-\t\t\t\tbyte_position(field),\n-\t\t\t\tempty_base_offsets,\n-\t\t\t\t/*is_data_member=*/true);\n+      record_subobject_offsets (field, empty_base_offsets);\n \n       /* If a bit-field does not immediately follow another bit-field,\n \t and yet it starts in the middle of a byte, we have failed to"}, {"sha": "e74b79c44e06236daccc7eaf1e2daaac81b2e2a9", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -4428,6 +4428,31 @@ handle_nodiscard_attribute (tree *node, tree name, tree /*args*/,\n   return NULL_TREE;\n }\n \n+/* Handle a C++2a \"no_unique_address\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+handle_no_unique_addr_attribute (tree* node,\n+\t\t\t\t tree name,\n+\t\t\t\t tree /*args*/,\n+\t\t\t\t int /*flags*/,\n+\t\t\t\t bool* no_add_attrs)\n+{\n+  if (TREE_CODE (*node) != FIELD_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute can only be applied to \"\n+\t       \"non-static data members\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_C_BIT_FIELD (*node))\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute cannot be applied to \"\n+\t       \"a bit-field\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Table of valid C++ attributes.  */\n const struct attribute_spec cxx_attribute_table[] =\n {\n@@ -4449,6 +4474,8 @@ const struct attribute_spec std_attribute_table[] =\n     handle_unused_attribute, NULL },\n   { \"nodiscard\", 0, 0, false, false, false, false,\n     handle_nodiscard_attribute, NULL },\n+  { \"no_unique_address\", 0, 0, true, false, false, false,\n+    handle_no_unique_addr_attribute, NULL },\n   { NULL, 0, 0, false, false, false, false, NULL, NULL }\n };\n "}, {"sha": "8cc10a9fb0f42e5897e190b31a5f6cd9cb59b67e", "filename": "gcc/testsuite/g++.dg/abi/empty4.C", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty4.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -37,6 +37,16 @@ struct B\n   B (long c) {m = c;}\n };\n \n+#if __cpp_attributes\n+struct B2\n+{\n+  [[no_unique_address]] Inter empty;\n+  NonPod m;\n+\n+  B2 (long c) {m = c;}\n+};\n+#endif\n+\n struct C : NonPod, Inter\n {\n   C (long c) : NonPod (c), Inter () {}\n@@ -65,6 +75,7 @@ int main ()\n   if (b2.m.m != 0x32333435)\n     return 2;\t// we copied padding, which clobbered b2.m.m\n   \n+  {\n   B c (0x12131415);\n   was = c.m.m;\n   c = 0x22232425;\n@@ -76,6 +87,22 @@ int main ()\n \n   if (c.m.m != 0x22232425)\n     return 4;\n+  }\n+#if __cpp_attributes\n+  {\n+  B2 c (0x12131415);\n+  was = c.m.m;\n+  c = 0x22232425;\n+  if (was != now)\n+    return 3;\n+  \n+  B2 d (0x32333435);\n+  c.empty = d.empty;\n+\n+  if (c.m.m != 0x22232425)\n+    return 4;\n+  }    \n+#endif\n \n   C e (0x32333435);\n "}, {"sha": "9ad66d91f61043e7c5b9e83a970726d0fa6bf6f5", "filename": "gcc/testsuite/g++.dg/abi/empty5.C", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty5.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -9,9 +9,20 @@ struct B {\n \n struct C : public B, public A {};\n \n+#if __cpp_attributes\n+struct C2 : public B\n+{\n+  [[no_unique_address]] A a;\n+} c2;\n+#endif\n+\n C c;\n \n int main () {\n   if ((void*) (A*) &c != &c)\n     return 1;\n+#if __cpp_attributes\n+  if ((void*)&c2.a != &c2)\n+    return 2;\n+#endif\n }"}, {"sha": "6d7954ec291b133235a2db874d098b322a15235d", "filename": "gcc/testsuite/g++.dg/abi/empty8.C", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fempty8.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -5,10 +5,20 @@ struct E1 {};\n struct E2 : public E1 {};\n struct S1 { int i; };\n struct S2 : public S1, E2 {};\n+#if __cpp_attributes\n+struct S22 : public S1\n+{\n+  [[no_unique_address]] E2 e2;\n+} s22;\n+#endif\n \n S2 s2;\n \n int main () {\n   if ((char *)(E2*) &s2 != (char *)&s2)\n     return 1;\n+#if __cpp_attributes\n+  if ((char *)&s22.e2 != (char *)&s22)\n+    return 2;\n+#endif\n }"}, {"sha": "853726dd4b0cf609d3a8f0ea612a731dc50317f5", "filename": "gcc/testsuite/g++.dg/abi/no_unique_address1.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address1.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do run { target c++2a } }\n+\n+struct B { };\n+\n+struct A\n+{\n+  [[no_unique_address]] B b;\n+  int i;\n+};\n+\n+struct C\n+{\n+  B b;\n+  int i;\n+};\n+\n+struct D: B { };\n+\n+struct E\n+{\n+  B b [[no_unique_address]];\n+  D d [[no_unique_address]];\n+};\n+\n+constexpr bool same (void *x, void *y) { return x == y; }\n+\n+int main()\n+{\n+  A a;\n+  if (!same(&a.b, &a.i))\n+    __builtin_abort();\n+  C c;\n+  if (same(&c.b, &c.i))\n+    __builtin_abort();\n+  E e;\n+  if (same (&e.b, &e.d))\n+    __builtin_abort();\n+}"}, {"sha": "bef6d5b43be56033673d4feaab85e02945ad2d79", "filename": "gcc/testsuite/g++.dg/abi/no_unique_address2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address2.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A\n+{\n+  virtual void f();\n+  char c;\n+};\n+\n+struct B1 : A\n+{\n+  char c2;\n+};\n+\n+struct B2\n+{\n+  A a [[no_unique_address]];\n+  char c2;\n+};\n+\n+struct C\n+{\n+  char c;\n+};\n+\n+struct D: virtual C\n+{\n+  virtual void f();\n+};\n+\n+struct B3: D\n+{\n+  char c2;\n+};\n+\n+struct B4\n+{\n+  D d [[no_unique_address]];\n+  char c2;\n+};\n+\n+#define SA(X) static_assert ((X), #X)\n+SA (sizeof (B2) == sizeof (B1));\n+SA (sizeof (B3) == sizeof (B4));"}, {"sha": "0bda77777e5d6bae9ef757183a55102aa8152a13", "filename": "gcc/testsuite/g++.dg/abi/no_unique_address3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fno_unique_address3.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target c++11 } }\n+\n+struct A {\n+  unsigned char i : 1;\n+};\n+\n+struct B: A\n+{\n+  unsigned char j : 7;\n+};\n+\n+struct B2\n+{\n+  [[no_unique_address]] A a;\n+  unsigned char j : 7;\n+};\n+\n+#define SA(X) static_assert ((X), #X)\n+SA (sizeof (B) == sizeof (B2));"}, {"sha": "dd019393f28319c3782eebe463e3a3603fbc515f", "filename": "gcc/testsuite/g++.dg/cpp2a/no_unique_address1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bedf03a298f87b43f02eaee57542fbd10228ec08/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fno_unique_address1.C?ref=bedf03a298f87b43f02eaee57542fbd10228ec08", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++2a } }\n+\n+[[no_unique_address]] struct B { }; // { dg-warning \"attribute\" }\n+[[no_unique_address]] int i;\t    // { dg-warning \"attribute\" }\n+[[no_unique_address]] void f();\t    // { dg-warning \"attribute\" }\n+\n+struct A\n+{\n+  [[no_unique_address]] B b;\n+  [[no_unique_address]] void f();   // { dg-warning \"attribute\" }\n+  [[no_unique_address]] static B c; // { dg-warning \"attribute\" }\n+  int i;\n+};"}]}