{"sha": "7313607478c11e9455a32fb0dbfd7867e04ea96a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMxMzYwNzQ3OGMxMWU5NDU1YTMyZmIwZGJmZDc4NjdlMDRlYTk2YQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-11-07T10:55:43Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-11-07T10:55:43Z"}, "message": "Remove gimple_call_types_likely_match_p (PR 70929)\n\n2019-11-07  Martin Jambor  <mjambor@suse.cz>\n\n\tPR lto/70929\n\t* cif-code.def (MISMATCHED_ARGUMENTS): Removed.\n\t* cgraph.h (gimple_check_call_matching_types): Remove\n\t* cgraph.c (gimple_check_call_args): Likewise.\n\t(gimple_check_call_matching_types): Likewise.\n\t(symbol_table::create_edge): Do not call\n\tgimple_check_call_matching_types.\n\t(cgraph_edge::make_direct): Likewise.\n\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n\t* value-prof.h (check_ic_target): Remove.\n\t* value-prof.c (check_ic_target): Remove.\n\t(gimple_ic_transform): Do nat call check_ic_target.\n\t* auto-profile.c (function_instance::find_icall_target_map): Likewise.\n\t(afdo_indirect_call): Likewise.\n\t* ipa-prop.c (update_indirect_edges_after_inlining): Do not call\n\tgimple_check_call_matching_types.\n\t* ipa-inline.c (early_inliner): Likewise.\n\n\ttestsuite/\n\t* g++.dg/lto/pr70929_[01].C: New test.\n\t* gcc.dg/winline-10.c: Adjust for the fact that inlining happens.\n\nFrom-SVN: r277920", "tree": {"sha": "9d440c3b3504f391067881779bf98569f28ecf21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d440c3b3504f391067881779bf98569f28ecf21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7313607478c11e9455a32fb0dbfd7867e04ea96a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7313607478c11e9455a32fb0dbfd7867e04ea96a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7313607478c11e9455a32fb0dbfd7867e04ea96a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7313607478c11e9455a32fb0dbfd7867e04ea96a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0775830a79bad1cdaa8fe279da7cbed123f696b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0775830a79bad1cdaa8fe279da7cbed123f696b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0775830a79bad1cdaa8fe279da7cbed123f696b6"}], "stats": {"total": 252, "additions": 61, "deletions": 191}, "files": [{"sha": "4f5662dde25dce3190ce6d39fdbc2f146ad2b801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -1,3 +1,23 @@\n+2019-11-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR lto/70929\n+\t* cif-code.def (MISMATCHED_ARGUMENTS): Removed.\n+\t* cgraph.h (gimple_check_call_matching_types): Remove\n+\t* cgraph.c (gimple_check_call_args): Likewise.\n+\t(gimple_check_call_matching_types): Likewise.\n+\t(symbol_table::create_edge): Do not call\n+\tgimple_check_call_matching_types.\n+\t(cgraph_edge::make_direct): Likewise.\n+\t(cgraph_edge::redirect_call_stmt_to_callee): Likewise.\n+\t* value-prof.h (check_ic_target): Remove.\n+\t* value-prof.c (check_ic_target): Remove.\n+\t(gimple_ic_transform): Do nat call check_ic_target.\n+\t* auto-profile.c (function_instance::find_icall_target_map): Likewise.\n+\t(afdo_indirect_call): Likewise.\n+\t* ipa-prop.c (update_indirect_edges_after_inlining): Do not call\n+\tgimple_check_call_matching_types.\n+\t* ipa-inline.c (early_inliner): Likewise.\n+\n 2019-11-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.md (arm_<simd32_op>): New define_expand."}, {"sha": "4d8fb525cb172e3f0950b636003e84833dd2f5ec", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -606,8 +606,6 @@ function_instance::find_icall_target_map (gcall *stmt,\n           get_identifier (afdo_string_table->get_name (callee)));\n       if (node == NULL)\n         continue;\n-      if (!check_ic_target (stmt, node))\n-        continue;\n       (*map)[callee] = iter->second->total_count ();\n       ret += iter->second->total_count ();\n     }\n@@ -1034,7 +1032,7 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n       print_generic_expr (dump_file, direct_call->decl, TDF_SLIM);\n     }\n \n-  if (direct_call == NULL || !check_ic_target (stmt, direct_call))\n+  if (direct_call == NULL)\n     {\n       if (dump_file)\n         fprintf (dump_file, \" not transforming\\n\");"}, {"sha": "6ba650e27bcfbc5b956ea28371ae8803318c61db", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 136, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -881,19 +881,8 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   edge->can_throw_external\n     = call_stmt ? stmt_can_throw_external (DECL_STRUCT_FUNCTION (caller->decl),\n \t\t\t\t\t   call_stmt) : false;\n-  if (call_stmt\n-      && callee && callee->decl\n-      && !gimple_check_call_matching_types (call_stmt, callee->decl,\n-\t\t\t\t\t    false))\n-    {\n-      edge->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n-      edge->call_stmt_cannot_inline_p = true;\n-    }\n-  else\n-    {\n-      edge->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n-      edge->call_stmt_cannot_inline_p = false;\n-    }\n+  edge->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n+  edge->call_stmt_cannot_inline_p = false;\n \n   if (opt_for_fn (edge->caller->decl, flag_devirtualize)\n       && call_stmt && DECL_STRUCT_FUNCTION (caller->decl))\n@@ -1255,13 +1244,6 @@ cgraph_edge::make_direct (cgraph_node *callee)\n   /* Insert to callers list of the new callee.  */\n   edge->set_callee (callee);\n \n-  if (call_stmt\n-      && !gimple_check_call_matching_types (call_stmt, callee->decl, false))\n-    {\n-      call_stmt_cannot_inline_p = true;\n-      inline_failed = CIF_MISMATCHED_ARGUMENTS;\n-    }\n-\n   /* We need to re-determine the inlining status of the edge.  */\n   initialize_inline_failed (edge);\n   return edge;\n@@ -1290,28 +1272,9 @@ cgraph_edge::redirect_call_stmt_to_callee (void)\n \t substitution), forget about speculating.  */\n       if (decl)\n \te = e->resolve_speculation (decl);\n-      /* If types do not match, speculation was likely wrong. \n-         The direct edge was possibly redirected to the clone with a different\n-\t signature.  We did not update the call statement yet, so compare it \n-\t with the reference that still points to the proper type.  */\n-      else if (!gimple_check_call_matching_types (e->call_stmt,\n-\t\t\t\t\t\t  ref->referred->decl,\n-\t\t\t\t\t\t  true))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Not expanding speculative call of %s -> %s\\n\"\n-\t\t     \"Type mismatch.\\n\",\n-\t\t     e->caller->dump_name (),\n-\t\t     e->callee->dump_name ());\n-\t  e = e->resolve_speculation ();\n-\t  /* We are producing the final function body and will throw away the\n-\t     callgraph edges really soon.  Reset the counts/frequencies to\n-\t     keep verifier happy in the case of roundoff errors.  */\n-\t  e->count = gimple_bb (e->call_stmt)->count;\n-\t}\n-      /* Expand speculation into GIMPLE code.  */\n       else\n \t{\n+\t  /* Expand speculation into GIMPLE code.  */\n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file,\n@@ -3638,102 +3601,6 @@ cgraph_node::get_fun () const\n   return fun;\n }\n \n-/* Verify if the type of the argument matches that of the function\n-   declaration.  If we cannot verify this or there is a mismatch,\n-   return false.  */\n-\n-static bool\n-gimple_check_call_args (gimple *stmt, tree fndecl, bool args_count_match)\n-{\n-  tree parms, p;\n-  unsigned int i, nargs;\n-\n-  /* Calls to internal functions always match their signature.  */\n-  if (gimple_call_internal_p (stmt))\n-    return true;\n-\n-  nargs = gimple_call_num_args (stmt);\n-\n-  /* Get argument types for verification.  */\n-  if (fndecl)\n-    parms = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-  else\n-    parms = TYPE_ARG_TYPES (gimple_call_fntype (stmt));\n-\n-  /* Verify if the type of the argument matches that of the function\n-     declaration.  If we cannot verify this or there is a mismatch,\n-     return false.  */\n-  if (fndecl && DECL_ARGUMENTS (fndecl))\n-    {\n-      for (i = 0, p = DECL_ARGUMENTS (fndecl);\n-\t   i < nargs;\n-\t   i++, p = DECL_CHAIN (p))\n-\t{\n-\t  tree arg;\n-\t  /* We cannot distinguish a varargs function from the case\n-\t     of excess parameters, still deferring the inlining decision\n-\t     to the callee is possible.  */\n-\t  if (!p)\n-\t    break;\n-\t  arg = gimple_call_arg (stmt, i);\n-\t  if (p == error_mark_node\n-\t      || DECL_ARG_TYPE (p) == error_mark_node\n-\t      || arg == error_mark_node\n-\t      || (!types_compatible_p (DECL_ARG_TYPE (p), TREE_TYPE (arg))\n-\t\t  && !fold_convertible_p (DECL_ARG_TYPE (p), arg)))\n-            return false;\n-\t}\n-      if (args_count_match && p)\n-\treturn false;\n-    }\n-  else if (parms)\n-    {\n-      for (i = 0, p = parms; i < nargs; i++, p = TREE_CHAIN (p))\n-\t{\n-\t  tree arg;\n-\t  /* If this is a varargs function defer inlining decision\n-\t     to callee.  */\n-\t  if (!p)\n-\t    break;\n-\t  arg = gimple_call_arg (stmt, i);\n-\t  if (TREE_VALUE (p) == error_mark_node\n-\t      || arg == error_mark_node\n-\t      || TREE_CODE (TREE_VALUE (p)) == VOID_TYPE\n-\t      || (!types_compatible_p (TREE_VALUE (p), TREE_TYPE (arg))\n-\t\t  && !fold_convertible_p (TREE_VALUE (p), arg)))\n-            return false;\n-\t}\n-    }\n-  else\n-    {\n-      if (nargs != 0)\n-        return false;\n-    }\n-  return true;\n-}\n-\n-/* Verify if the type of the argument and lhs of CALL_STMT matches\n-   that of the function declaration CALLEE. If ARGS_COUNT_MATCH is\n-   true, the arg count needs to be the same.\n-   If we cannot verify this or there is a mismatch, return false.  */\n-\n-bool\n-gimple_check_call_matching_types (gimple *call_stmt, tree callee,\n-\t\t\t\t  bool args_count_match)\n-{\n-  tree lhs;\n-\n-  if ((DECL_RESULT (callee)\n-       && !DECL_BY_REFERENCE (DECL_RESULT (callee))\n-       && (lhs = gimple_call_lhs (call_stmt)) != NULL_TREE\n-       && !useless_type_conversion_p (TREE_TYPE (DECL_RESULT (callee)),\n-                                      TREE_TYPE (lhs))\n-       && !fold_convertible_p (TREE_TYPE (DECL_RESULT (callee)), lhs))\n-      || !gimple_check_call_args (call_stmt, callee, args_count_match))\n-    return false;\n-  return true;\n-}\n-\n /* Reset all state within cgraph.c so that we can rerun the compiler\n    within the same process.  For use by toplev::finalize.  */\n "}, {"sha": "8989f3119acbeb5f26f655bb6fce6494202630fd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -2445,8 +2445,6 @@ bool cgraph_function_possibly_inlined_p (tree);\n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n \n-extern bool gimple_check_call_matching_types (gimple *, tree, bool);\n-\n /* In cgraphunit.c  */\n void cgraphunit_c_finalize (void);\n "}, {"sha": "a154f24f13d61fa6fa318c6d8d584efcea3853a6", "filename": "gcc/cif-code.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -95,10 +95,6 @@ DEFCIFCODE(NEVER_CALL, CIF_FINAL_NORMAL,\n DEFCIFCODE(NOT_DECLARED_INLINED, CIF_FINAL_NORMAL,\n \t   N_(\"function not declared inline and code size would grow\"))\n \n-/* Caller and callee disagree on the arguments.  */\n-DEFCIFCODE(MISMATCHED_ARGUMENTS, CIF_FINAL_ERROR,\n-\t   N_(\"mismatched arguments\"))\n-\n /* Caller and callee disagree on the arguments.  */\n DEFCIFCODE(LTO_MISMATCHED_DECLARATIONS, CIF_FINAL_ERROR,\n \t   N_(\"mismatched declarations during linktime optimization\"))"}, {"sha": "9f47239bc0361086aa551a1e3279fa5e52049fda", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -2913,14 +2913,6 @@ early_inliner (function *fun)\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n-\n-\t      if (edge->callee->decl\n-\t\t  && !gimple_check_call_matching_types (\n-\t\t      edge->call_stmt, edge->callee->decl, false))\n-\t\t{\n- \t\t  edge->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n-\t\t  edge->call_stmt_cannot_inline_p = true;\n-\t\t}\n \t    }\n \t  if (iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS) - 1)\n \t    ipa_update_overall_fn_summary (node);"}, {"sha": "ff6f25a94eac668130868967b98ca808e79f4e5e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -3492,11 +3492,6 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n       else if (new_direct_edge)\n \t{\n \t  new_direct_edge->indirect_inlining_edge = 1;\n-\t  if (new_direct_edge->call_stmt)\n-\t    new_direct_edge->call_stmt_cannot_inline_p\n-\t      = !gimple_check_call_matching_types (\n-\t\t  new_direct_edge->call_stmt,\n-\t\t  new_direct_edge->callee->decl, false);\n \t  if (new_edges)\n \t    {\n \t      new_edges->safe_push (new_direct_edge);"}, {"sha": "07d3a5f16480e2330f3564db6180e23c9fca86a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -1,3 +1,9 @@\n+2019-11-07  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR lto/70929\n+\t* g++.dg/lto/pr70929_[01].C: New test.\n+\t* gcc.dg/winline-10.c: Adjust for the fact that inlining happens.\n+\n 2019-11-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/arm/acle/simd32.c: Update test."}, {"sha": "c96fb1c743ad493dda61114292eee5ab3c27fdaa", "filename": "gcc/testsuite/g++.dg/lto/pr70929_0.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr70929_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr70929_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr70929_0.C?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -0,0 +1,18 @@\n+// { dg-lto-do run }\n+// { dg-lto-options { \"-O3 -flto\" } }\n+\n+struct s\n+{\n+  int a;\n+  s() {a=1;}\n+  ~s() {}\n+};\n+int t(struct s s);\n+int main()\n+{\n+  s s;\n+  int v=t(s);\n+  if (!__builtin_constant_p (v))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "b33aa8f35f034578b5c15fb96ac32c7ad4ce9a41", "filename": "gcc/testsuite/g++.dg/lto/pr70929_1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr70929_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr70929_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr70929_1.C?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -0,0 +1,10 @@\n+struct s\n+{\n+  int a;\n+  s() {a=1;}\n+  ~s() {}\n+};\n+int t(struct s s)\n+{\n+  return s.a;\n+}"}, {"sha": "2df5addaebcc9e2b1941c521c32c38cf5a266d40", "filename": "gcc/testsuite/gcc.dg/winline-10.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-10.c?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -1,17 +1,17 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Winline\" } */\n+/* { dg-options \"-O2 -Winline -fopt-info-optimized-inline=stderr\" } */\n \n struct s { int a; };\n \n-inline void f (x)\t/* { dg-warning \"inlining .* mismatched arg\" } */\n+inline void f (x)\n      int x;\n {\n   asm (\"\");\n }\n \n void g (struct s x)\n {\n-  f (x); \t\t/* { dg-message \"called from here\" } */\n+  f (x); \t\t/* { dg-optimized \"Inlining f.* into g\" } */\n }\n \n void f (int x);\t\t/* { dg-warning \"follows non-prototype definition\" } */"}, {"sha": "789309c533eb0f74533f5921fffe5ba86a0e84b5", "filename": "gcc/value-prof.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7313607478c11e9455a32fb0dbfd7867e04ea96a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=7313607478c11e9455a32fb0dbfd7867e04ea96a", "patch": "@@ -1245,25 +1245,6 @@ find_func_by_profile_id (int profile_id)\n     return NULL;\n }\n \n-/* Perform sanity check on the indirect call target. Due to race conditions,\n-   false function target may be attributed to an indirect call site. If the\n-   call expression type mismatches with the target function's type, expand_call\n-   may ICE. Here we only do very minimal sanity check just to make compiler happy.\n-   Returns true if TARGET is considered ok for call CALL_STMT.  */\n-\n-bool\n-check_ic_target (gcall *call_stmt, struct cgraph_node *target)\n-{\n-   if (gimple_check_call_matching_types (call_stmt, target->decl, true))\n-     return true;\n-\n-   if (dump_enabled_p ())\n-     dump_printf_loc (MSG_MISSED_OPTIMIZATION, call_stmt,\n-                      \"Skipping target %s with mismatching types for icall\\n\",\n-                      target->name ());\n-   return false;\n-}\n-\n /* Do transformation\n \n   if (actual_callee_address == address_of_most_common_function/method)\n@@ -1456,17 +1437,6 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)\n       return false;\n     }\n \n-  if (!check_ic_target (stmt, direct_call))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, stmt,\n-\t\t\t \"Indirect call -> direct call %T => %T \"\n-\t\t\t \"transformation skipped because of type mismatch: %G\",\n-\t\t\t gimple_call_fn (stmt), direct_call->decl, stmt);\n-      gimple_remove_histogram_value (cfun, stmt, histogram);\n-      return false;\n-    }\n-\n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,"}]}