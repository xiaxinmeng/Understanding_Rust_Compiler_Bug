{"sha": "965eec1676035e748a44bc0069f1b046c40a470c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY1ZWVjMTY3NjAzNWU3NDhhNDRiYzAwNjlmMWIwNDZjNDBhNDcwYw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@verizon.net", "date": "2005-10-25T01:32:33Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2005-10-25T01:32:33Z"}, "message": "re PR libfortran/24224 (Generalized internal array IO not implemented.)\n\n2005-10-24  Jerry DeLisle  <jvdelisle@verizon.net>\n\n        PR libgfortran/24224\n        * libgfortran.h: Remove array stride error code.\n        * runtime/error.c: Remove array stride error.\n        * io/io.h: Change name of 'nml_loop_spec' to 'array_loop_spec' to be\n        generic.  Add pointer to array_loop_spec and rank to gfc_unit\n        structure.\n        * io/list_read.c: Revise nml_loop_spec references to array_loop_spec.\n        * io/transfer.c (init_loop_spec): New function to initialize\n        an array_loop_spec.\n        (next_array_record): New function to return the index to the next array\n        record by incrementing through the array_loop_spec.\n        (next_record_r): Use new function.\n        (next_record_w): Use new function.\n        (finalize_transfer): Free memory allocated for array_loop_spec.\n        * io/unit.c (get_array_unit_len): Delete this function. Use new\n        function init_loop_spec to initialize the array_loop_spec.\n\nFrom-SVN: r105878", "tree": {"sha": "d242a60a28c0bf664df869ac41dcd94a07afc1a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d242a60a28c0bf664df869ac41dcd94a07afc1a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/965eec1676035e748a44bc0069f1b046c40a470c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965eec1676035e748a44bc0069f1b046c40a470c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965eec1676035e748a44bc0069f1b046c40a470c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965eec1676035e748a44bc0069f1b046c40a470c/comments", "author": null, "committer": null, "parents": [{"sha": "8c4b4e67fb0a519a7d3b6a344bafe395197a1764", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4b4e67fb0a519a7d3b6a344bafe395197a1764", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4b4e67fb0a519a7d3b6a344bafe395197a1764"}], "stats": {"total": 248, "additions": 168, "deletions": 80}, "files": [{"sha": "e56e855614e64110c006111f71bec80f9847b7b4", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=965eec1676035e748a44bc0069f1b046c40a470c", "patch": "@@ -1,3 +1,22 @@\n+2005-10-24  Jerry DeLisle  <jvdelisle@verizon.net>\n+\n+        PR libgfortran/24224\n+        * libgfortran.h: Remove array stride error code.\n+        * runtime/error.c: Remove array stride error.\n+        * io/io.h: Change name of 'nml_loop_spec' to 'array_loop_spec' to be\n+        generic.  Add pointer to array_loop_spec and rank to gfc_unit\n+        structure.\n+        * io/list_read.c: Revise nml_loop_spec references to array_loop_spec.\n+        * io/transfer.c (init_loop_spec): New function to initialize\n+        an array_loop_spec.\n+        (next_array_record): New function to return the index to the next array\n+        record by incrementing through the array_loop_spec. \n+        (next_record_r): Use new function.\n+        (next_record_w): Use new function.\n+        (finalize_transfer): Free memory allocated for array_loop_spec.\n+        * io/unit.c (get_array_unit_len): Delete this function. Use new\n+        function init_loop_spec to initialize the array_loop_spec.  \n+\n 2005-10-24  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/24416"}, {"sha": "90ee36cd73fb3da444c4ea7ad2794670a09b7a03", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=965eec1676035e748a44bc0069f1b046c40a470c", "patch": "@@ -78,28 +78,12 @@ stream;\n #define sread(s, buf, nbytes) ((s)->read)(s, buf, nbytes)\n #define swrite(s, buf, nbytes) ((s)->write)(s, buf, nbytes)\n \n-/* Representation of a namelist object in libgfortran\n-\n-   Namelist Records\n-      &GROUPNAME  OBJECT=value[s] [,OBJECT=value[s]].../\n-     or\n-      &GROUPNAME  OBJECT=value[s] [,OBJECT=value[s]]...&END\n-\n-   The object can be a fully qualified, compound name for an instrinsic\n-   type, derived types or derived type components.  So, a substring\n-   a(:)%b(4)%ch(2:4)(1:7) has to be treated correctly in namelist\n-   read. Hence full information about the structure of the object has\n-   to be available to list_read.c and write.\n-\n-   These requirements are met by the following data structures.\n-\n-   nml_loop_spec contains the variables for the loops over index ranges\n+/* The array_loop_spec contains the variables for the loops over index ranges\n    that are encountered.  Since the variables can be negative, ssize_t\n    is used.  */\n \n-typedef struct nml_loop_spec\n+typedef struct array_loop_spec\n {\n-\n   /* Index counter for this dimension.  */\n   ssize_t idx;\n \n@@ -112,10 +96,25 @@ typedef struct nml_loop_spec\n   /* Step for the index counter.  */\n   ssize_t step;\n }\n-nml_loop_spec;\n+array_loop_spec;\n+\n+/* Representation of a namelist object in libgfortran\n \n-/* namelist_info type contains all the scalar information about the\n-   object and arrays of descriptor_dimension and nml_loop_spec types for\n+   Namelist Records\n+      &GROUPNAME  OBJECT=value[s] [,OBJECT=value[s]].../\n+     or\n+      &GROUPNAME  OBJECT=value[s] [,OBJECT=value[s]]...&END\n+\n+   The object can be a fully qualified, compound name for an instrinsic\n+   type, derived types or derived type components.  So, a substring\n+   a(:)%b(4)%ch(2:4)(1:7) has to be treated correctly in namelist\n+   read. Hence full information about the structure of the object has\n+   to be available to list_read.c and write.\n+\n+   These requirements are met by the following data structures.\n+\n+   namelist_info type contains all the scalar information about the\n+   object and arrays of descriptor_dimension and array_loop_spec types for\n    arrays.  */\n \n typedef struct namelist_type\n@@ -146,7 +145,7 @@ typedef struct namelist_type\n   index_type string_length;\n \n   descriptor_dimension * dim;\n-  nml_loop_spec * ls;\n+  array_loop_spec * ls;\n   struct namelist_type * next;\n }\n namelist_info;\n@@ -306,10 +305,10 @@ unit_flags;\n typedef struct gfc_unit\n {\n   int unit_number;\n-\n   stream *s;\n-\n-  struct gfc_unit *left, *right;\t/* Treap links.  */\n+  \n+  /* Treap links.  */\n+  struct gfc_unit *left, *right;\n   int priority;\n \n   int read_bad, current_record;\n@@ -319,15 +318,20 @@ typedef struct gfc_unit\n \n   unit_mode  mode;\n   unit_flags flags;\n-  gfc_offset recl, last_record, maxrec, bytes_left;\n-\n+  \n   /* recl           -- Record length of the file.\n      last_record    -- Last record number read or written\n      maxrec         -- Maximum record number in a direct access file\n      bytes_left     -- Bytes left in current record.  */\n+  gfc_offset recl, last_record, maxrec, bytes_left;\n \n+  /* For traversing arrays */\n+  array_loop_spec *ls;\n+  int rank;\n+  \n+  /* Filename is allocated at the end of the structure.  */  \n   int file_len;\n-  char file[1];\t      /* Filename is allocated at the end of the structure.  */\n+  char file[1];\n }\n gfc_unit;\n \n@@ -533,9 +537,6 @@ internal_proto(is_internal_unit);\n extern int is_array_io (void);\n internal_proto(is_array_io);\n \n-extern gfc_offset get_array_unit_len (gfc_array_char *);\n-internal_proto(get_array_unit_len);\n-\n extern gfc_unit *find_unit (int);\n internal_proto(find_unit);\n \n@@ -583,6 +584,12 @@ internal_proto(read_block);\n extern void *write_block (int);\n internal_proto(write_block);\n \n+extern gfc_offset next_array_record (array_loop_spec *);\n+internal_proto(next_array_record);\n+\n+extern gfc_offset init_loop_spec (gfc_array_char *desc, array_loop_spec *ls);\n+internal_proto(init_loop_spec);\n+\n extern void next_record (int);\n internal_proto(next_record);\n "}, {"sha": "95cb12659acee64754e9b3625b521f085b87bf12", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=965eec1676035e748a44bc0069f1b046c40a470c", "patch": "@@ -1469,7 +1469,7 @@ void namelist_read (void)\n       static void nml_untouch_nodes (void)\n       static namelist_info * find_nml_node (char * var_name)\n       static int nml_parse_qualifier(descriptor_dimension * ad,\n-\t\t\t\t     nml_loop_spec * ls, int rank)\n+\t\t\t\t     array_loop_spec * ls, int rank)\n       static void nml_touch_nodes (namelist_info * nl)\n       static int nml_read_obj (namelist_info * nl, index_type offset)\n calls:\n@@ -1500,7 +1500,7 @@ static index_type chigh;\n \n static try\n nml_parse_qualifier(descriptor_dimension * ad,\n-\t\t    nml_loop_spec * ls, int rank)\n+\t\t    array_loop_spec * ls, int rank)\n {\n   int dim;\n   int indx;\n@@ -2222,7 +2222,7 @@ nml_get_obj_data (void)\n   if (c == '(' && nl->type == GFC_DTYPE_CHARACTER)\n     {\n       descriptor_dimension chd[1] = { {1, clow, nl->string_length} };\n-      nml_loop_spec ind[1] = { {1, clow, nl->string_length, 1} };\n+      array_loop_spec ind[1] = { {1, clow, nl->string_length, 1} };\n \n       if (nml_parse_qualifier (chd, ind, 1) == FAILURE)\n \t{"}, {"sha": "391885b5e3c6ad180d977bc0c47ee78597b38a65", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 99, "deletions": 14, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=965eec1676035e748a44bc0069f1b046c40a470c", "patch": "@@ -258,7 +258,7 @@ read_block (int *length)\n \n       *length = current_unit->bytes_left;\n     }\n-    \n+\n   if (current_unit->flags.form == FORM_FORMATTED &&\n       current_unit->flags.access == ACCESS_SEQUENTIAL)\n     return read_sf (length);\t/* Special case.  */\n@@ -1450,6 +1450,60 @@ data_transfer_init (int read_flag)\n     formatted_transfer (0, NULL, 0, 1);\n }\n \n+/* Initialize an array_loop_spec given the array descriptor.  The function\n+   returns the index of the last element of the array.  */\n+   \n+gfc_offset\n+init_loop_spec (gfc_array_char *desc, array_loop_spec *ls)\n+{\n+  int rank = GFC_DESCRIPTOR_RANK(desc);\n+  int i;\n+  gfc_offset index; \n+\n+  index = 1;\n+  for (i=0; i<rank; i++)\n+    {\n+      ls[i].idx = 1;\n+      ls[i].start = desc->dim[i].lbound;\n+      ls[i].end = desc->dim[i].ubound;\n+      ls[i].step = desc->dim[i].stride;\n+      \n+      index += (desc->dim[i].ubound - desc->dim[i].lbound)\n+                      * desc->dim[i].stride;\n+    }\n+  return index;\n+}\n+\n+/* Determine the index to the next record in an internal unit array by\n+   by incrementing through the array_loop_spec.  TODO:  Implement handling\n+   negative strides. */\n+   \n+gfc_offset\n+next_array_record ( array_loop_spec * ls )\n+{\n+  int i, carry;\n+  gfc_offset index;\n+  \n+  carry = 1;\n+  index = 0;\n+  \n+  for (i = 0; i < current_unit->rank; i++)\n+    {\n+      if (carry)\n+        {\n+          ls[i].idx++;\n+          if (ls[i].idx > ls[i].end)\n+            {\n+              ls[i].idx = ls[i].start;\n+              carry = 1;\n+            }\n+          else\n+            carry = 0;\n+        }\n+      index = index + (ls[i].idx - 1) * ls[i].step;\n+    }\n+  return index;\n+}\n \n /* Space to the next record for read mode.  If the file is not\n    seekable, we read MAX_READ chunks until we get to the right\n@@ -1460,8 +1514,8 @@ data_transfer_init (int read_flag)\n static void\n next_record_r (void)\n {\n-  int rlength, length, bytes_left;\n-  gfc_offset new;\n+  gfc_offset new, record;\n+  int bytes_left, rlength, length;\n   char *p;\n \n   switch (current_mode ())\n@@ -1516,11 +1570,27 @@ next_record_r (void)\n \n       if (is_internal_unit())\n \t{\n-\t  bytes_left = (int) current_unit->bytes_left;\n-\t  p = salloc_r (current_unit->s, &bytes_left);\n-\t  if (p != NULL)\n+\t  if (is_array_io())\n+\t  {\n+            record =  next_array_record (current_unit->ls);   \n+                 \n+            /* Now seek to this record.  */\n+            record = record * current_unit->recl;\n+            if (sseek (current_unit->s, record) == FAILURE)\n+              {\n+                generate_error (ERROR_OS, NULL);\n+                break;\n+              }\n \t    current_unit->bytes_left = current_unit->recl;\n-\t  break;\n+          }\n+        else  \n+          {\n+\t    bytes_left = (int) current_unit->bytes_left;\n+\t    p = salloc_r (current_unit->s, &bytes_left);\n+\t    if (p != NULL)\n+\t      current_unit->bytes_left = current_unit->recl;\n+\t  } \n+\tbreak;\n \t}\n       else do\n \t{\n@@ -1553,8 +1623,8 @@ next_record_r (void)\n static void\n next_record_w (void)\n {\n-  gfc_offset c, m;\n-  int length, bytes_left;\n+  gfc_offset c, m, record;\n+  int bytes_left, length;\n   char *p;\n \n   /* Zero counters for X- and T-editing.  */\n@@ -1633,6 +1703,18 @@ next_record_w (void)\n \t\t  return;\n \t\t}\n               memset(p, ' ', bytes_left);\n+              \n+              /* Now that the current record has been padded out,\n+                 determine where the next record in the array is. */\n+                 \n+              record =  next_array_record (current_unit->ls);   \n+               \n+              /* Now seek to this record */\n+              record = record * current_unit->recl;\n+              \n+              if (sseek (current_unit->s, record) == FAILURE)\n+                goto io_error;\n+                \n               current_unit->bytes_left = current_unit->recl;\n \t    }\n \t  else\n@@ -1672,7 +1754,6 @@ next_record_w (void)\n     }\n }\n \n-\n /* Position to the next record, which means moving to the end of the\n    current record.  This can happen under several different\n    conditions.  If the done flag is not set, we get ready to process\n@@ -1711,7 +1792,7 @@ next_record (int done)\n \n /* Finalize the current data transfer.  For a nonadvancing transfer,\n    this means advancing to the next record.  For internal units close the\n-   steam associated with the unit.  */\n+   stream associated with the unit.  */\n \n static void\n finalize_transfer (void)\n@@ -1766,7 +1847,11 @@ finalize_transfer (void)\n   sfree (current_unit->s);\n \n   if (is_internal_unit ())\n-    sclose (current_unit->s);\n+    {\n+      if (is_array_io() && current_unit->ls != NULL)\n+        free_mem (current_unit->ls);\n+      sclose (current_unit->s);\n+    }\n }\n \n \n@@ -1957,8 +2042,8 @@ st_set_nml_var (void * var_addr, char * var_name, GFC_INTEGER_4 len,\n     {\n       nml->dim = (descriptor_dimension*)\n \t\t   get_mem (nml->var_rank * sizeof (descriptor_dimension));\n-      nml->ls = (nml_loop_spec*)\n-\t\t  get_mem (nml->var_rank * sizeof (nml_loop_spec));\n+      nml->ls = (array_loop_spec*)\n+\t\t  get_mem (nml->var_rank * sizeof (array_loop_spec));\n     }\n   else\n     {"}, {"sha": "c22d59376ee011cd200822cbdff4ac5c8a0af52f", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=965eec1676035e748a44bc0069f1b046c40a470c", "patch": "@@ -244,32 +244,6 @@ find_unit (int n)\n   return p;\n }\n \n-\n-/* get_array_unit_len()-- return the number of records in the array. */\n-\n-gfc_offset\n-get_array_unit_len (gfc_array_char *desc)\n-{\n-  gfc_offset record_count;\n-  int i, rank, stride;\n-  rank = GFC_DESCRIPTOR_RANK(desc);\n-  record_count = stride = 1;\n-  for (i=0;i<rank;++i)\n-    {\n-      /* Check that array is contiguous */\n-      \n-      if (desc->dim[i].stride != stride)\n-\t{\n-\t  generate_error (ERROR_ARRAY_STRIDE, NULL);\n-\t  return 0;\n-\t}\n-      stride *= desc->dim[i].ubound;\n-      record_count *= desc->dim[i].ubound;\n-    }\n-  return record_count;\n-}\n-\n- \n /* get_unit()-- Returns the unit structure associated with the integer\n  * unit or the internal file. */\n \n@@ -279,8 +253,15 @@ get_unit (int read_flag __attribute__ ((unused)))\n   if (ioparm.internal_unit != NULL)\n     {\n       internal_unit.recl = ioparm.internal_unit_len;\n-      if (is_array_io()) ioparm.internal_unit_len *=\n-\t\t\t   get_array_unit_len(ioparm.internal_unit_desc);\n+      if (is_array_io())\n+      {\n+        internal_unit.rank = GFC_DESCRIPTOR_RANK(ioparm.internal_unit_desc);\n+        internal_unit.ls = (array_loop_spec*)\n+          get_mem (internal_unit.rank * sizeof (array_loop_spec));\n+        ioparm.internal_unit_len *=\n+\t  init_loop_spec (ioparm.internal_unit_desc, internal_unit.ls);\n+      }\n+        \n       internal_unit.s =\n \topen_internal (ioparm.internal_unit, ioparm.internal_unit_len);\n       internal_unit.bytes_left = internal_unit.recl;"}, {"sha": "cdaa54255c2adcd39138168d471d4f5cf0089caf", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/965eec1676035e748a44bc0069f1b046c40a470c/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=965eec1676035e748a44bc0069f1b046c40a470c", "patch": "@@ -427,10 +427,6 @@ translate_error (int code)\n       p = \"Numeric overflow on read\";\n       break;\n \n-    case ERROR_ARRAY_STRIDE:\n-      p = \"Array unit stride must be 1\";\n-      break;\n-\n     default:\n       p = \"Unknown error code\";\n       break;"}]}