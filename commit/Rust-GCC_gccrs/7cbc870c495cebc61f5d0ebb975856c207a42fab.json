{"sha": "7cbc870c495cebc61f5d0ebb975856c207a42fab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NiYzg3MGM0OTVjZWJjNjFmNWQwZWJiOTc1ODU2YzIwN2E0MmZhYg==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-07-05T09:05:45Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-02T06:11:57Z"}, "message": "Enable _Float16 type for TARGET_SSE2 and above.\n\ngcc/ChangeLog:\n\n\t* config/i386/i386-modes.def (FLOAT_MODE): Define ieee HFmode.\n\t* config/i386/i386.c (enum x86_64_reg_class): Add\n\tX86_64_SSEHF_CLASS.\n\t(merge_classes): Handle X86_64_SSEHF_CLASS.\n\t(examine_argument): Ditto.\n\t(construct_container): Ditto.\n\t(classify_argument): Ditto, and set HFmode/HCmode to\n\tX86_64_SSEHF_CLASS.\n\t(function_value_32): Return _FLoat16/Complex Float16 by\n\t%xmm0.\n\t(function_value_64): Return _Float16/Complex Float16 by SSE\n\tregister.\n\t(ix86_print_operand): Handle CONST_DOUBLE HFmode.\n\t(ix86_secondary_reload): Require gpr as intermediate register\n\tto store _Float16 from sse register when sse4 is not\n\tavailable.\n\t(ix86_libgcc_floating_mode_supported_p): Enable _FLoat16 under\n\tsse2.\n\t(ix86_scalar_mode_supported_p): Ditto.\n\t(TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P): Defined.\n\t* config/i386/i386.h (VALID_SSE2_REG_MODE): Add HFmode.\n\t(VALID_INT_MODE_P): Add HFmode and HCmode.\n\t* config/i386/i386.md (*pushhf_rex64): New define_insn.\n\t(*pushhf): Ditto.\n\t(*movhf_internal): Ditto.\n\t* doc/extend.texi (Half-Precision Floating Point): Documemt\n\t_Float16 for x86.\n\ngcc/lto/ChangeLog:\n\n\t* lto-lang.c (lto_type_for_mode): Return float16_type_node\n\twhen mode == TYPE_MODE (float16_type_node).\n\ngcc/testsuite/ChangeLog\n\n\t* gcc.target/i386/sse2-float16-1.c: New test.\n\t* gcc.target/i386/sse2-float16-2.c: Ditto.\n\t* gcc.target/i386/sse2-float16-3.c: Ditto.\n\t* gcc.target/i386/float16-5.c: New test.", "tree": {"sha": "dc0987718dc7d33ca83bacaa77ced32361ff548e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc0987718dc7d33ca83bacaa77ced32361ff548e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cbc870c495cebc61f5d0ebb975856c207a42fab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbc870c495cebc61f5d0ebb975856c207a42fab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cbc870c495cebc61f5d0ebb975856c207a42fab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cbc870c495cebc61f5d0ebb975856c207a42fab/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42d2d2a20f2bb59928bc895ec9f46503a1b5c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e42d2d2a20f2bb59928bc895ec9f46503a1b5c73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e42d2d2a20f2bb59928bc895ec9f46503a1b5c73"}], "stats": {"total": 277, "additions": 269, "deletions": 8}, "files": [{"sha": "9232f59a9252d65c7bc42cc26c4f983031d78ae2", "filename": "gcc/config/i386/i386-modes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-modes.def?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n \n FRACTIONAL_FLOAT_MODE (XF, 80, 12, ieee_extended_intel_96_format);\n FLOAT_MODE (TF, 16, ieee_quad_format);\n+FLOAT_MODE (HF, 2, ieee_half_format);\n \n /* In ILP32 mode, XFmode has size 12 and alignment 4.\n    In LP64 mode, XFmode has size and alignment 16.  */"}, {"sha": "bfefbd718bbb621352fd6953d1dab7b423a24066", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -387,6 +387,7 @@ enum x86_64_reg_class\n     X86_64_INTEGER_CLASS,\n     X86_64_INTEGERSI_CLASS,\n     X86_64_SSE_CLASS,\n+    X86_64_SSEHF_CLASS,\n     X86_64_SSESF_CLASS,\n     X86_64_SSEDF_CLASS,\n     X86_64_SSEUP_CLASS,\n@@ -2027,8 +2028,10 @@ merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)\n     return X86_64_MEMORY_CLASS;\n \n   /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */\n-  if ((class1 == X86_64_INTEGERSI_CLASS && class2 == X86_64_SSESF_CLASS)\n-      || (class2 == X86_64_INTEGERSI_CLASS && class1 == X86_64_SSESF_CLASS))\n+  if ((class1 == X86_64_INTEGERSI_CLASS\n+       && (class2 == X86_64_SSESF_CLASS || class2 == X86_64_SSEHF_CLASS))\n+      || (class2 == X86_64_INTEGERSI_CLASS\n+\t  && (class1 == X86_64_SSESF_CLASS || class1 == X86_64_SSEHF_CLASS)))\n     return X86_64_INTEGERSI_CLASS;\n   if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS\n       || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)\n@@ -2182,6 +2185,8 @@ classify_argument (machine_mode mode, const_tree type,\n \t    /* The partial classes are now full classes.  */\n \t    if (subclasses[0] == X86_64_SSESF_CLASS && bytes != 4)\n \t      subclasses[0] = X86_64_SSE_CLASS;\n+\t    if (subclasses[0] == X86_64_SSEHF_CLASS && bytes != 2)\n+\t      subclasses[0] = X86_64_SSE_CLASS;\n \t    if (subclasses[0] == X86_64_INTEGERSI_CLASS\n \t\t&& !((bit_offset % 64) == 0 && bytes == 4))\n \t      subclasses[0] = X86_64_INTEGER_CLASS;\n@@ -2354,6 +2359,12 @@ classify_argument (machine_mode mode, const_tree type,\n       gcc_unreachable ();\n     case E_CTImode:\n       return 0;\n+    case E_HFmode:\n+      if (!(bit_offset % 64))\n+\tclasses[0] = X86_64_SSEHF_CLASS;\n+      else\n+\tclasses[0] = X86_64_SSE_CLASS;\n+      return 1;\n     case E_SFmode:\n       if (!(bit_offset % 64))\n \tclasses[0] = X86_64_SSESF_CLASS;\n@@ -2371,6 +2382,15 @@ classify_argument (machine_mode mode, const_tree type,\n       classes[0] = X86_64_SSE_CLASS;\n       classes[1] = X86_64_SSEUP_CLASS;\n       return 2;\n+    case E_HCmode:\n+      classes[0] = X86_64_SSE_CLASS;\n+      if (!(bit_offset % 64))\n+\treturn 1;\n+      else\n+\t{\n+\t  classes[1] = X86_64_SSEHF_CLASS;\n+\t  return 2;\n+\t}\n     case E_SCmode:\n       classes[0] = X86_64_SSE_CLASS;\n       if (!(bit_offset % 64))\n@@ -2485,6 +2505,7 @@ examine_argument (machine_mode mode, const_tree type, int in_return,\n \t(*int_nregs)++;\n \tbreak;\n       case X86_64_SSE_CLASS:\n+      case X86_64_SSEHF_CLASS:\n       case X86_64_SSESF_CLASS:\n       case X86_64_SSEDF_CLASS:\n \t(*sse_nregs)++;\n@@ -2584,13 +2605,14 @@ construct_container (machine_mode mode, machine_mode orig_mode,\n \n   /* First construct simple cases.  Avoid SCmode, since we want to use\n      single register to pass this type.  */\n-  if (n == 1 && mode != SCmode)\n+  if (n == 1 && mode != SCmode && mode != HCmode)\n     switch (regclass[0])\n       {\n       case X86_64_INTEGER_CLASS:\n       case X86_64_INTEGERSI_CLASS:\n \treturn gen_rtx_REG (mode, intreg[0]);\n       case X86_64_SSE_CLASS:\n+      case X86_64_SSEHF_CLASS:\n       case X86_64_SSESF_CLASS:\n       case X86_64_SSEDF_CLASS:\n \tif (mode != BLKmode)\n@@ -2687,6 +2709,14 @@ construct_container (machine_mode mode, machine_mode orig_mode,\n \t\t\t\t   GEN_INT (i*8));\n \t    intreg++;\n \t    break;\n+\t  case X86_64_SSEHF_CLASS:\n+\t    exp [nexps++]\n+\t      = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t   gen_rtx_REG (HFmode,\n+\t\t\t\t\t\tGET_SSE_REGNO (sse_regno)),\n+\t\t\t\t   GEN_INT (i*8));\n+\t    sse_regno++;\n+\t    break;\n \t  case X86_64_SSESF_CLASS:\n \t    exp [nexps++]\n \t      = gen_rtx_EXPR_LIST (VOIDmode,\n@@ -3907,6 +3937,19 @@ function_value_32 (machine_mode orig_mode, machine_mode mode,\n     /* Most things go in %eax.  */\n     regno = AX_REG;\n \n+  /* Return _Float16/_Complex _Foat16 by sse register.  */\n+  if (mode == HFmode)\n+    regno = FIRST_SSE_REG;\n+  if (mode == HCmode)\n+    {\n+      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc(1));\n+      XVECEXP (ret, 0, 0)\n+\t= gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t     gen_rtx_REG (SImode, FIRST_SSE_REG),\n+\t\t\t     GEN_INT (0));\n+      return ret;\n+    }\n+\n   /* Override FP return register with %xmm0 for local functions when\n      SSE math is enabled or for functions with sseregparm attribute.  */\n   if ((fn || fntype) && (mode == SFmode || mode == DFmode))\n@@ -3943,6 +3986,8 @@ function_value_64 (machine_mode orig_mode, machine_mode mode,\n \n       switch (mode)\n \t{\n+\tcase E_HFmode:\n+\tcase E_HCmode:\n \tcase E_SFmode:\n \tcase E_SCmode:\n \tcase E_DFmode:\n@@ -13455,6 +13500,15 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t  (file, addr, MEM_ADDR_SPACE (x), code == 'p' || code == 'P');\n     }\n \n+  else if (CONST_DOUBLE_P (x) && GET_MODE (x) == HFmode)\n+    {\n+      long l = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (x),\n+\t\t\t       REAL_MODE_FORMAT (HFmode));\n+      if (ASSEMBLER_DIALECT == ASM_ATT)\n+\tputc ('$', file);\n+      fprintf (file, \"0x%04x\", (unsigned int) l);\n+    }\n+\n   else if (CONST_DOUBLE_P (x) && GET_MODE (x) == SFmode)\n     {\n       long l;\n@@ -19107,6 +19161,16 @@ ix86_secondary_reload (bool in_p, rtx x, reg_class_t rclass,\n       return NO_REGS;\n     }\n \n+  /* Require movement to gpr, and then store to memory.  */\n+  if (mode == HFmode\n+      && !TARGET_SSE4_1\n+      && SSE_CLASS_P (rclass)\n+      && !in_p && MEM_P (x))\n+    {\n+      sri->extra_cost = 1;\n+      return GENERAL_REGS;\n+    }\n+\n   /* This condition handles corner case where an expression involving\n      pointers gets vectorized.  We're trying to use the address of a\n      stack slot as a vector initializer.\n@@ -21781,10 +21845,27 @@ ix86_scalar_mode_supported_p (scalar_mode mode)\n     return default_decimal_float_supported_p ();\n   else if (mode == TFmode)\n     return true;\n+  else if (mode == HFmode && TARGET_SSE2)\n+    return true;\n   else\n     return default_scalar_mode_supported_p (mode);\n }\n \n+/* Implement TARGET_LIBGCC_FLOATING_POINT_MODE_SUPPORTED_P - return TRUE\n+   if MODE is HFmode, and punt to the generic implementation otherwise.  */\n+\n+static bool\n+ix86_libgcc_floating_mode_supported_p (scalar_float_mode mode)\n+{\n+  /* NB: Always return TRUE for HFmode so that the _Float16 type will\n+     be defined by the C front-end for AVX512FP16 intrinsics.  We will\n+     issue an error in ix86_expand_move for HFmode if AVX512FP16 isn't\n+     enabled.  */\n+  return ((mode == HFmode && TARGET_SSE2)\n+\t  ? true\n+\t  : default_libgcc_floating_mode_supported_p (mode));\n+}\n+\n /* Implements target hook vector_mode_supported_p.  */\n static bool\n ix86_vector_mode_supported_p (machine_mode mode)\n@@ -24067,6 +24148,10 @@ ix86_run_selftests (void)\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P ix86_scalar_mode_supported_p\n \n+#undef TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P\n+#define TARGET_LIBGCC_FLOATING_MODE_SUPPORTED_P\t\\\n+ix86_libgcc_floating_mode_supported_p\n+\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P ix86_vector_mode_supported_p\n "}, {"sha": "f671dae923664f6bd05aa4f91e2ebcb3d62baaf8", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -1025,7 +1025,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define VALID_SSE2_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode\t\\\n    || (MODE) == V4QImode || (MODE) == V2HImode || (MODE) == V1SImode\t\\\n-   || (MODE) == V2DImode || (MODE) == DFmode)\n+   || (MODE) == V2DImode || (MODE) == DFmode || (MODE) == HFmode)\n \n #define VALID_SSE_REG_MODE(MODE)\t\t\t\t\t\\\n   ((MODE) == V1TImode || (MODE) == TImode\t\t\t\t\\\n@@ -1054,6 +1054,7 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n    || (MODE) == CQImode || (MODE) == CHImode\t\t\t\t\\\n    || (MODE) == CSImode || (MODE) == CDImode\t\t\t\t\\\n    || (MODE) == SDmode || (MODE) == DDmode\t\t\t\t\\\n+   || (MODE) == HFmode || (MODE) == HCmode\t\t\t\t\\\n    || (MODE) == V4QImode || (MODE) == V2HImode || (MODE) == V1SImode\t\\\n    || (TARGET_64BIT\t\t\t\t\t\t\t\\\n        && ((MODE) == TImode || (MODE) == CTImode\t\t\t\\"}, {"sha": "0cd151ce4e5d900e2576f978e495c334dd1cd301", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -1226,6 +1226,9 @@\n ;; All x87 floating point modes\n (define_mode_iterator X87MODEF [SF DF XF])\n \n+;; All x87 floating point modes plus HF\n+(define_mode_iterator X87MODEFH [SF DF XF HF])\n+\n ;; All SSE floating point modes\n (define_mode_iterator SSEMODEF [SF DF TF])\n (define_mode_attr ssevecmodef [(SF \"V4SF\") (DF \"V2DF\") (TF \"TF\")])\n@@ -3134,6 +3137,32 @@\n   operands[0] = replace_equiv_address (operands[0], stack_pointer_rtx);\n })\n \n+(define_insn \"*pushhf_rex64\"\n+  [(set (match_operand:HF 0 \"push_operand\" \"=X,X\")\n+\t(match_operand:HF 1 \"nonmemory_no_elim_operand\" \"r,x\"))]\n+  \"TARGET_64BIT\"\n+{\n+  /* Anything else should be already split before reg-stack.  */\n+  gcc_assert (which_alternative == 0);\n+  return \"push{q}\\t%q1\";\n+}\n+  [(set_attr \"isa\"  \"*,sse4\")\n+   (set_attr \"type\" \"push,multi\")\n+   (set_attr \"mode\" \"DI,TI\")])\n+\n+(define_insn \"*pushhf\"\n+  [(set (match_operand:HF 0 \"push_operand\" \"=X,X\")\n+\t(match_operand:HF 1 \"general_no_elim_operand\" \"rmF,x\"))]\n+  \"!TARGET_64BIT\"\n+{\n+  /* Anything else should be already split before reg-stack.  */\n+  gcc_assert (which_alternative == 0);\n+  return \"push{l}\\t%k1\";\n+}\n+  [(set_attr \"isa\"  \"*,sse4\")\n+   (set_attr \"type\" \"push,multi\")\n+   (set_attr \"mode\" \"SI,TI\")])\n+\n (define_insn \"*pushsf_rex64\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=X,X,X\")\n \t(match_operand:SF 1 \"nonmemory_no_elim_operand\" \"f,rF,v\"))]\n@@ -3162,10 +3191,11 @@\n    (set_attr \"unit\" \"i387,*,*\")\n    (set_attr \"mode\" \"SF,SI,SF\")])\n \n+(define_mode_iterator MODESH [SF HF])\n ;; %%% Kill this when call knows how to work this out.\n (define_split\n-  [(set (match_operand:SF 0 \"push_operand\")\n-\t(match_operand:SF 1 \"any_fp_register_operand\"))]\n+  [(set (match_operand:MODESH 0 \"push_operand\")\n+\t(match_operand:MODESH 1 \"any_fp_register_operand\"))]\n   \"reload_completed\"\n   [(set (reg:P SP_REG) (plus:P (reg:P SP_REG) (match_dup 2)))\n    (set (match_dup 0) (match_dup 1))]\n@@ -3213,8 +3243,8 @@\n   \"ix86_expand_move (TFmode, operands); DONE;\")\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:X87MODEF 0 \"nonimmediate_operand\")\n-\t(match_operand:X87MODEF 1 \"general_operand\"))]\n+  [(set (match_operand:X87MODEFH 0 \"nonimmediate_operand\")\n+\t(match_operand:X87MODEFH 1 \"general_operand\"))]\n   \"\"\n   \"ix86_expand_move (<MODE>mode, operands); DONE;\")\n \n@@ -3650,6 +3680,86 @@\n \t   ]\n \t   (const_string \"*\")))])\n \n+(define_insn \"*movhf_internal\"\n+ [(set (match_operand:HF 0 \"nonimmediate_operand\"\n+\t \"=?r,?m,v,v,?r,m,?v,v\")\n+       (match_operand:HF 1 \"general_operand\"\n+\t \"rmF,rF,C,v, v,v, r,m\"))]\n+ \"!(MEM_P (operands[0]) && MEM_P (operands[1]))\n+  && (lra_in_progress\n+      || reload_completed\n+      || !CONST_DOUBLE_P (operands[1])\n+      || (TARGET_SSE && TARGET_SSE_MATH\n+\t  && standard_sse_constant_p (operands[1], HFmode) == 1)\n+      || memory_operand (operands[0], HFmode))\"\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_IMOV:\n+      return \"mov{w}\\t{%1, %0|%0, %1}\";\n+\n+    case TYPE_SSELOG1:\n+      return standard_sse_constant_opcode (insn, operands);\n+\n+    case TYPE_SSEMOV:\n+      return ix86_output_ssemov (insn, operands);\n+\n+    case TYPE_SSELOG:\n+      if (SSE_REG_P (operands[0]))\n+\treturn MEM_P (operands[1])\n+\t       ? \"pinsrw\\t{$0, %1, %0|%0, %1, 0}\"\n+\t       : \"pinsrw\\t{$0, %k1, %0|%0, %k1, 0}\";\n+      else\n+\treturn MEM_P (operands[1])\n+\t       ? \"pextrw\\t{$0, %1, %0|%0, %1, 0}\"\n+\t       : \"pextrw\\t{$0, %1, %k0|%k0, %k1, 0}\";\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+  [(set (attr \"isa\")\n+\t(cond [(eq_attr \"alternative\" \"2,3,4,6,7\")\n+\t\t (const_string \"sse2\")\n+\t       (eq_attr \"alternative\" \"5\")\n+\t\t (const_string \"sse4\")\n+\t      ]\n+\t      (const_string \"*\")))\n+   (set (attr \"type\")\n+\t(cond [(eq_attr \"alternative\" \"0,1\")\n+\t\t (const_string \"imov\")\n+\t       (eq_attr \"alternative\" \"2\")\n+\t\t (const_string \"sselog1\")\n+\t       (eq_attr \"alternative\" \"4,5,6,7\")\n+\t\t (const_string \"sselog\")\n+\t      ]\n+\t      (const_string \"ssemov\")))\n+   (set (attr \"memory\")\n+\t(cond [(eq_attr \"alternative\" \"4,6\")\n+\t\t (const_string \"none\")\n+\t       (eq_attr \"alternative\" \"5\")\n+\t\t (const_string \"store\")\n+\t       (eq_attr \"alternative\" \"7\")\n+\t\t (const_string \"load\")\n+\t      ]\n+\t      (const_string \"*\")))\n+   (set (attr \"prefix\")\n+\t(cond [(eq_attr \"alternative\" \"0,1\")\n+\t\t (const_string \"orig\")\n+\t      ]\n+\t      (const_string \"maybe_vex\")))\n+   (set (attr \"mode\")\n+\t(cond [(eq_attr \"alternative\" \"0,1\")\n+\t\t (const_string \"HI\")\n+\t       (eq_attr \"alternative\" \"2\")\n+\t\t (const_string \"V4SF\")\n+\t       (eq_attr \"alternative\" \"4,5,6,7\")\n+\t\t (const_string \"TI\")\n+\t       (eq_attr \"alternative\" \"3\")\n+\t\t (const_string \"SF\")\n+\t      ]\n+\t      (const_string \"*\")))])\n+\n (define_split\n   [(set (match_operand 0 \"any_fp_register_operand\")\n \t(match_operand 1 \"memory_operand\"))]"}, {"sha": "7fb22ed80632319c9d1eb77c051102b05a71dd3d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -1102,6 +1102,7 @@ typedef _Complex float __attribute__((mode(IC))) _Complex_ibm128;\n @section Half-Precision Floating Point\n @cindex half-precision floating point\n @cindex @code{__fp16} data type\n+@cindex @code{__Float16} data type\n \n On ARM and AArch64 targets, GCC supports half-precision (16-bit) floating\n point via the @code{__fp16} type defined in the ARM C Language Extensions.\n@@ -1150,6 +1151,18 @@ calls.\n It is recommended that portable code use the @code{_Float16} type defined\n by ISO/IEC TS 18661-3:2015.  @xref{Floating Types}.\n \n+On x86 targets with @code{target(\"sse2\")} and above, GCC supports half-precision\n+(16-bit) floating point via the @code{_Float16} type which is defined by\n+18661-3:2015. For C++, x86 provide a builtin type named @code{_Float16}\n+which contains same data format as C.\n+\n+Without @option{-mavx512fp16}, @code{_Float16} type is storage only, all\n+operations will be emulated by software emulation and the @code{float}\n+instructions. The default behavior for @code{FLT_EVAL_METHOD} is to keep\n+the intermediate result of the operation as 32-bit precision. This may lead\n+to inconsistent behavior between software emulation and AVX512-FP16\n+instructions.\n+\n @node Decimal Float\n @section Decimal Floating Types\n @cindex decimal floating types"}, {"sha": "92f499643b5195149a0d8ef0f2d7e07f979ab9d0", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -992,6 +992,9 @@ lto_type_for_mode (machine_mode mode, int unsigned_p)\n     return unsigned_p ? unsigned_intTI_type_node : intTI_type_node;\n #endif\n \n+  if (float16_type_node && mode == TYPE_MODE (float16_type_node))\n+    return float16_type_node;\n+\n   if (mode == TYPE_MODE (float_type_node))\n     return float_type_node;\n "}, {"sha": "ebc0af1490b224fcc9f853836d08e08e423ad296", "filename": "gcc/testsuite/gcc.target/i386/float16-5.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffloat16-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffloat16-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffloat16-5.c?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-msse2 -O2\" } */\n+_Float16\n+foo (int a)\n+{\n+  union {\n+    int a;\n+    _Float16 b;\n+  }c;\n+  c.a = a;\n+  return c.b;\n+}"}, {"sha": "1b645eb499da7f3c3b404f236d5a1f34da59e96f", "filename": "gcc/testsuite/gcc.target/i386/sse2-float16-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-1.c?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mno-sse2\" } */\n+\n+_Float16/* { dg-error \"is not supported on this target\" } */\n+foo (_Float16 x) /* { dg-error \"is not supported on this target\" } */\n+{\n+  return x;\n+}"}, {"sha": "3da7683fc31fc796111efc17624469b55043ab38", "filename": "gcc/testsuite/gcc.target/i386/sse2-float16-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-2.c?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-avx512f\" } */\n+\n+union flt\n+{\n+  _Float16 flt;\n+  short s;\n+};\n+\n+_Float16\n+foo (union flt x)\n+{\n+  return x.flt;\n+}\n+\n+/* { dg-final { scan-assembler {(?n)pinsrw[\\t ].*%xmm0} } } */"}, {"sha": "60ff9d4ab80e53c40de1e86ce859d18a156a56da", "filename": "gcc/testsuite/gcc.target/i386/sse2-float16-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cbc870c495cebc61f5d0ebb975856c207a42fab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-float16-3.c?ref=7cbc870c495cebc61f5d0ebb975856c207a42fab", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-avx512f\" } */\n+\n+#include<complex.h>\n+\n+_Complex _Float16\n+foo (_Complex _Float16 x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler {(?n)movd[\\t ].*%xmm0} } } */"}]}