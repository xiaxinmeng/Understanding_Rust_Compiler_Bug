{"sha": "c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQxMDBlYWVhM2FjZDFhMGQ4ODA1MGFkNzIxZjM2NDcwYTBhNmU1ZA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2014-12-11T15:13:33Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2014-12-11T15:13:33Z"}, "message": "re PR fortran/44054 (Handle -Werror, -Werror=, -fdiagnostics-show-option, !GCC$ diagnostic (pragmas) and color)\n\ngcc/ChangeLog:\n\n2014-12-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* diagnostic.c (diagnostic_action_after_output): Make it extern.\n\tTake diagnostic_t argument instead of diagnostic_info. Count also\n\tDK_WERROR towards max_errors.\n\t(diagnostic_report_diagnostic): Update call according to the above.\n\t(error_recursion): Likewise.\n\t* diagnostic.h (diagnostic_action_after_output): Declare.\n\t* pretty-print.c (pp_formatted_text_data): Delete.\n\t(pp_append_r): Call output_buffer_append_r.\n\t(pp_formatted_text): Call output_buffer_formatted_text.\n\t(pp_last_position_in_text): Call output_buffer_last_position_in_text.\n\t* pretty-print.h (output_buffer_formatted_text): New.\n\t(output_buffer_append_r): New.\n\t(output_buffer_last_position_in_text): New.\n\ngcc/fortran/ChangeLog:\n\n2014-12-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* error.c (pp_error_buffer): New static variable.\n\t(pp_warning_buffer): Make it a pointer.\n\t(gfc_output_buffer_empty_p): New.\n\t(gfc_error_init_1): Call gfc_buffer_error.\n\t(gfc_buffer_error): Do not use pp_warning_buffer.flush_p as the\n\tbuffered_p flag.\n\t(gfc_clear_warning): Likewise.\n\t(gfc_warning_check): Call gfc_clear_warning. Only check the new\n\tpp_warning_buffer if the old warning_buffer was empty. Call\n\tdiagnostic_action_after_output.\n\t(gfc_error_1): Renamed from gfc_error.\n\t(gfc_error): New.\n\t(gfc_clear_error): Clear also pp_error_buffer.\n\t(gfc_error_flag_test): Check also pp_error_buffer.\n\t(gfc_error_check): Likewise. Only check the new pp_error_buffer\n\tif the old error_buffer was empty.\n\t(gfc_move_output_buffer_from_to): New.\n\t(gfc_push_error): Use it here. Take also an output_buffer as argument.\n\t(gfc_pop_error): Likewise.\n\t(gfc_free_error): Likewise.\n\t(gfc_diagnostics_init): Use XNEW and placement-new to init\n\tpp_error_buffer and pp_warning_buffer. Set flush_p to false for\n\tboth pp_warning_buffer and pp_error_buffer.\n\n\t* Update gfc_push_error, gfc_pop_error and gfc_free_error calls\n\taccording to the above changes.\n\t* Use gfc_error_1 for all gfc_error calls that use multiple\n\tlocations.\n\t* Use %qs instead of '%s' for many gfc_error calls.\n\nFrom-SVN: r218627", "tree": {"sha": "6688e37de9262fa9b6efc826ef89c8b02ae776ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6688e37de9262fa9b6efc826ef89c8b02ae776ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/comments", "author": null, "committer": null, "parents": [{"sha": "217d0904fab9c653eeefe27d94cb73f5516c4d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/217d0904fab9c653eeefe27d94cb73f5516c4d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/217d0904fab9c653eeefe27d94cb73f5516c4d83"}], "stats": {"total": 1274, "additions": 730, "deletions": 544}, "files": [{"sha": "d68906701e225d5c1fed046a32dbaff60abece83", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -1,3 +1,20 @@\n+2014-12-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR fortran/44054\n+\t* diagnostic.c (diagnostic_action_after_output): Make it extern.\n+\tTake diagnostic_t argument instead of diagnostic_info. Count also\n+\tDK_WERROR towards max_errors.\n+\t(diagnostic_report_diagnostic): Update call according to the above.\n+\t(error_recursion): Likewise.\n+\t* diagnostic.h (diagnostic_action_after_output): Declare.\n+\t* pretty-print.c (pp_formatted_text_data): Delete.\n+\t(pp_append_r): Call output_buffer_append_r.\n+\t(pp_formatted_text): Call output_buffer_formatted_text.\n+\t(pp_last_position_in_text): Call output_buffer_last_position_in_text.\n+\t* pretty-print.h (output_buffer_formatted_text): New.\n+\t(output_buffer_append_r): New.\n+\t(output_buffer_last_position_in_text): New.\n+\n 2014-12-11  Kyrylo Tkachov  kyrylo.tkachov@arm.com\n \n \t* config/aarch64/aarch64.c (aarch64_parse_extension): Update error"}, {"sha": "7cbdb797aed87ff53eeb1359689e2ef2d371051d", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -51,8 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n /* Prototypes.  */\n static void error_recursion (diagnostic_context *) ATTRIBUTE_NORETURN;\n \n-static void diagnostic_action_after_output (diagnostic_context *,\n-\t\t\t\t\t    diagnostic_info *);\n static void real_abort (void) ATTRIBUTE_NORETURN;\n \n /* Name of program invoked, sans directories.  */\n@@ -483,11 +481,11 @@ bt_err_callback (void *data ATTRIBUTE_UNUSED, const char *msg, int errnum)\n \n /* Take any action which is expected to happen after the diagnostic\n    is written out.  This function does not always return.  */\n-static void\n+void\n diagnostic_action_after_output (diagnostic_context *context,\n-\t\t\t\tdiagnostic_info *diagnostic)\n+\t\t\t\tdiagnostic_t diag_kind)\n {\n-  switch (diagnostic->kind)\n+  switch (diag_kind)\n     {\n     case DK_DEBUG:\n     case DK_NOTE:\n@@ -507,7 +505,8 @@ diagnostic_action_after_output (diagnostic_context *context,\n \t}\n       if (context->max_errors != 0\n \t  && ((unsigned) (diagnostic_kind_count (context, DK_ERROR)\n-\t\t\t  + diagnostic_kind_count (context, DK_SORRY))\n+\t\t\t  + diagnostic_kind_count (context, DK_SORRY)\n+\t\t\t  + diagnostic_kind_count (context, DK_WERROR))\n \t      >= context->max_errors))\n \t{\n \t  fnotice (stderr,\n@@ -864,7 +863,7 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n   (*diagnostic_starter (context)) (context, diagnostic);\n   pp_output_formatted_text (context->printer);\n   (*diagnostic_finalizer (context)) (context, diagnostic);\n-  diagnostic_action_after_output (context, diagnostic);\n+  diagnostic_action_after_output (context, diagnostic->kind);\n   diagnostic->message.format_spec = saved_format_spec;\n   diagnostic->x_data = NULL;\n \n@@ -1264,18 +1263,15 @@ fnotice (FILE *file, const char *cmsgid, ...)\n static void\n error_recursion (diagnostic_context *context)\n {\n-  diagnostic_info diagnostic;\n-\n   if (context->lock < 3)\n     pp_newline_and_flush (context->printer);\n \n   fnotice (stderr,\n \t   \"Internal compiler error: Error reporting routines re-entered.\\n\");\n \n   /* Call diagnostic_action_after_output to get the \"please submit a bug\n-     report\" message.  It only looks at the kind field of diagnostic_info.  */\n-  diagnostic.kind = DK_ICE;\n-  diagnostic_action_after_output (context, &diagnostic);\n+     report\" message.  */\n+  diagnostic_action_after_output (context, DK_ICE);\n \n   /* Do not use gcc_unreachable here; that goes through internal_error\n      and therefore would cause infinite recursion.  */"}, {"sha": "e699db826be73b07ab89f795e3e21ac03e52de76", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -294,6 +294,7 @@ extern char *diagnostic_build_prefix (diagnostic_context *, const diagnostic_inf\n void default_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n void default_diagnostic_finalizer (diagnostic_context *, diagnostic_info *);\n void diagnostic_set_caret_max_width (diagnostic_context *context, int value);\n+void diagnostic_action_after_output (diagnostic_context *, diagnostic_t);\n \n void diagnostic_file_cache_fini (void);\n "}, {"sha": "554474c3fc42bda819607ddfdbcc6fcc14321c70", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -1,3 +1,36 @@\n+2014-12-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR fortran/44054\n+\t* error.c (pp_error_buffer): New static variable.\n+\t(pp_warning_buffer): Make it a pointer.\n+\t(gfc_output_buffer_empty_p): New.\n+\t(gfc_error_init_1): Call gfc_buffer_error.\n+\t(gfc_buffer_error): Do not use pp_warning_buffer.flush_p as the\n+\tbuffered_p flag.\n+\t(gfc_clear_warning): Likewise.\n+\t(gfc_warning_check): Call gfc_clear_warning. Only check the new\n+\tpp_warning_buffer if the old warning_buffer was empty. Call\n+\tdiagnostic_action_after_output.\n+\t(gfc_error_1): Renamed from gfc_error.\n+\t(gfc_error): New.\n+\t(gfc_clear_error): Clear also pp_error_buffer.\n+\t(gfc_error_flag_test): Check also pp_error_buffer.\n+\t(gfc_error_check): Likewise. Only check the new pp_error_buffer\n+\tif the old error_buffer was empty.\n+\t(gfc_move_output_buffer_from_to): New.\n+\t(gfc_push_error): Use it here. Take also an output_buffer as argument.\n+\t(gfc_pop_error): Likewise.\n+\t(gfc_free_error): Likewise.\n+\t(gfc_diagnostics_init): Use XNEW and placement-new to init\n+\tpp_error_buffer and pp_warning_buffer. Set flush_p to false for\n+\tboth pp_warning_buffer and pp_error_buffer.\n+\n+\t* Update gfc_push_error, gfc_pop_error and gfc_free_error calls\n+\taccording to the above changes.\n+\t* Use gfc_error_1 for all gfc_error calls that use multiple\n+\tlocations.\n+\t* Use %qs instead of '%s' for many gfc_error calls.\n+\n 2014-12-11  Tobias Burnus  <burnus@net-b.de>\n \t    Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n "}, {"sha": "63945477188baefb5a9022e17a33c7212fcab40c", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -1915,17 +1915,17 @@ arith_error (arith rc, gfc_typespec *from, gfc_typespec *to, locus *where)\n       break;\n     case ARITH_OVERFLOW:\n       gfc_error (\"Arithmetic overflow converting %s to %s at %L. This check \"\n-\t\t \"can be disabled with the option -fno-range-check\",\n+\t\t \"can be disabled with the option %<-fno-range-check%>\",\n \t\t gfc_typename (from), gfc_typename (to), where);\n       break;\n     case ARITH_UNDERFLOW:\n       gfc_error (\"Arithmetic underflow converting %s to %s at %L. This check \"\n-\t\t \"can be disabled with the option -fno-range-check\",\n+\t\t \"can be disabled with the option %<-fno-range-check%>\",\n \t\t gfc_typename (from), gfc_typename (to), where);\n       break;\n     case ARITH_NAN:\n       gfc_error (\"Arithmetic NaN converting %s to %s at %L. This check \"\n-\t\t \"can be disabled with the option -fno-range-check\",\n+\t\t \"can be disabled with the option %<-fno-range-check%>\",\n \t\t gfc_typename (from), gfc_typename (to), where);\n       break;\n     case ARITH_DIV0:"}, {"sha": "e27ca014059bfa53a503c55e14afd2c614f2bb42", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -100,7 +100,7 @@ match_subscript (gfc_array_ref *ar, int init, bool match_star)\n \n   if (star)\n     {\n-      gfc_error (\"Unexpected '*' in coarray subscript at %C\");\n+      gfc_error (\"Unexpected %<*%> in coarray subscript at %C\");\n       return MATCH_ERROR;\n     }\n \n@@ -246,15 +246,15 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n       if (gfc_match_char (',') != MATCH_YES)\n \t{\n \t  if (gfc_match_char ('*') == MATCH_YES)\n-\t    gfc_error (\"Unexpected '*' for codimension %d of %d at %C\",\n+\t    gfc_error (\"Unexpected %<*%> for codimension %d of %d at %C\",\n \t\t       ar->codimen + 1, corank);\n \t  else\n \t    gfc_error (\"Invalid form of coarray reference at %C\");\n \t  return MATCH_ERROR;\n \t}\n       else if (ar->dimen_type[ar->codimen + ar->dimen] == DIMEN_STAR)\n \t{\n-\t  gfc_error (\"Unexpected '*' for codimension %d of %d at %C\",\n+\t  gfc_error (\"Unexpected %<*%> for codimension %d of %d at %C\",\n \t\t     ar->codimen + 1, corank);\n \t  return MATCH_ERROR;\n \t}\n@@ -313,7 +313,7 @@ resolve_array_bound (gfc_expr *e, int check_constant)\n   if (check_constant && !gfc_is_constant_expr (e))\n     {\n       if (e->expr_type == EXPR_VARIABLE)\n-\tgfc_error (\"Variable '%s' at %L in this context must be constant\",\n+\tgfc_error (\"Variable %qs at %L in this context must be constant\",\n \t\t   e->symtree->n.sym->name, &e->where);\n       else\n \tgfc_error (\"Expression at %L in this context must be constant\",\n@@ -752,7 +752,7 @@ gfc_set_array_spec (gfc_symbol *sym, gfc_array_spec *as, locus *error_loc)\n   if ((sym->as->type == AS_ASSUMED_RANK && as->corank)\n       || (as->type == AS_ASSUMED_RANK && sym->as->corank))\n     {\n-      gfc_error (\"The assumed-rank array '%s' at %L shall not have a \"\n+      gfc_error (\"The assumed-rank array %qs at %L shall not have a \"\n \t\t \"codimension\", sym->name, error_loc);\n       return false;\n     }\n@@ -912,7 +912,7 @@ check_duplicate_iterator (gfc_constructor_base base, gfc_symbol *master)\n \n       if (c->iterator->var->symtree->n.sym == master)\n \t{\n-\t  gfc_error (\"DO-iterator '%s' at %L is inside iterator of the \"\n+\t  gfc_error (\"DO-iterator %qs at %L is inside iterator of the \"\n \t\t     \"same name\", master->name, &c->where);\n \n \t  return 1;\n@@ -1662,7 +1662,7 @@ gfc_expand_constructor (gfc_expr *e, bool fatal)\n \t{\n \t  gfc_error (\"The number of elements in the array constructor \"\n \t\t     \"at %L requires an increase of the allowed %d \"\n-\t\t     \"upper limit.   See -fmax-array-constructor \"\n+\t\t     \"upper limit.   See %<-fmax-array-constructor%> \"\n \t\t     \"option\", &e->where,\n \t\t     gfc_option.flag_max_array_constructor);\n \t  return false;"}, {"sha": "ef40e669f172634ee117c241da501d309f6f6f5e", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -43,7 +43,7 @@ scalar_check (gfc_expr *e, int n)\n   if (e->rank == 0)\n     return true;\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a scalar\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be a scalar\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where);\n \n@@ -59,7 +59,7 @@ type_check (gfc_expr *e, int n, bt type)\n   if (e->ts.type == type)\n     return true;\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be %s\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be %s\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where, gfc_basic_typename (type));\n \n@@ -86,7 +86,7 @@ numeric_check (gfc_expr *e, int n)\n       return true;\n     }\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a numeric type\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be a numeric type\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where);\n \n@@ -101,7 +101,7 @@ int_or_real_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_INTEGER && e->ts.type != BT_REAL)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n \t\t \"or REAL\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &e->where);\n       return false;\n@@ -118,7 +118,7 @@ real_or_complex_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_REAL && e->ts.type != BT_COMPLEX)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be REAL \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be REAL \"\n \t\t \"or COMPLEX\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &e->where);\n       return false;\n@@ -135,7 +135,7 @@ int_or_proc_check (gfc_expr *e, int n)\n {\n   if (e->ts.type != BT_INTEGER && e->ts.type != BT_PROCEDURE)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n \t\t \"or PROCEDURE\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &e->where);\n       return false;\n@@ -164,7 +164,7 @@ kind_check (gfc_expr *k, int n, bt type)\n \n   if (!gfc_check_init_expr (k))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a constant\",\n \t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t\t &k->where);\n       return false;\n@@ -192,7 +192,7 @@ double_check (gfc_expr *d, int n)\n \n   if (d->ts.kind != gfc_default_double_kind)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be double \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be double \"\n \t\t \"precision\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &d->where);\n       return false;\n@@ -215,7 +215,7 @@ coarray_check (gfc_expr *e, int n)\n \n   if (!gfc_is_coarray (e))\n     {\n-      gfc_error (\"Expected coarray variable as '%s' argument to the %s \"\n+      gfc_error (\"Expected coarray variable as %qs argument to the %s \"\n                  \"intrinsic at %L\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &e->where);\n       return false;\n@@ -232,7 +232,7 @@ logical_array_check (gfc_expr *array, int n)\n {\n   if (array->ts.type != BT_LOGICAL || array->rank == 0)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a logical \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a logical \"\n \t\t \"array\", gfc_current_intrinsic_arg[n]->name,\n \t\t gfc_current_intrinsic, &array->where);\n       return false;\n@@ -258,7 +258,7 @@ array_check (gfc_expr *e, int n)\n   if (e->rank != 0 && e->ts.type != BT_PROCEDURE)\n     return true;\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be an array\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be an array\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where);\n \n@@ -279,7 +279,7 @@ nonnegative_check (const char *arg, gfc_expr *expr)\n       gfc_extract_int (expr, &i);\n       if (i < 0)\n \t{\n-\t  gfc_error (\"'%s' at %L must be nonnegative\", arg, &expr->where);\n+\t  gfc_error (\"%qs at %L must be nonnegative\", arg, &expr->where);\n \t  return false;\n \t}\n     }\n@@ -311,7 +311,7 @@ less_than_bitsize1 (const char *arg1, gfc_expr *expr1, const char *arg2,\n \t  if (i2 > gfc_integer_kinds[i3].bit_size)\n \t    {\n \t      gfc_error (\"The absolute value of SHIFT at %L must be less \"\n-\t\t\t \"than or equal to BIT_SIZE('%s')\",\n+\t\t\t \"than or equal to BIT_SIZE(%qs)\",\n \t\t\t &expr2->where, arg1);\n \t      return false;\n \t    }\n@@ -321,8 +321,8 @@ less_than_bitsize1 (const char *arg1, gfc_expr *expr1, const char *arg2,\n \t{\n \t  if (i2 > gfc_integer_kinds[i3].bit_size)\n \t    {\n-\t      gfc_error (\"'%s' at %L must be less than \"\n-\t\t\t \"or equal to BIT_SIZE('%s')\",\n+\t      gfc_error (\"%qs at %L must be less than \"\n+\t\t\t \"or equal to BIT_SIZE(%qs)\",\n \t\t\t arg2, &expr2->where, arg1);\n \t      return false;\n \t    }\n@@ -331,7 +331,7 @@ less_than_bitsize1 (const char *arg1, gfc_expr *expr1, const char *arg2,\n \t{\n \t  if (i2 >= gfc_integer_kinds[i3].bit_size)\n \t    {\n-\t      gfc_error (\"'%s' at %L must be less than BIT_SIZE('%s')\",\n+\t      gfc_error (\"%qs at %L must be less than BIT_SIZE(%qs)\",\n \t\t\t arg2, &expr2->where, arg1);\n \t      return false;\n \t    }\n@@ -358,7 +358,7 @@ less_than_bitsizekind (const char *arg, gfc_expr *expr, int k)\n \n   if (val > gfc_integer_kinds[i].bit_size)\n     {\n-      gfc_error (\"'%s' at %L must be less than or equal to the BIT_SIZE of \"\n+      gfc_error (\"%qs at %L must be less than or equal to the BIT_SIZE of \"\n \t\t \"INTEGER(KIND=%d)\", arg, &expr->where, k);\n       return false;\n     }\n@@ -385,7 +385,7 @@ less_than_bitsize2 (const char *arg1, gfc_expr *expr1, const char *arg2,\n       if (i2 > gfc_integer_kinds[i3].bit_size)\n \t{\n \t  gfc_error (\"'%s + %s' at %L must be less than or equal \"\n-\t\t     \"to BIT_SIZE('%s')\",\n+\t\t     \"to BIT_SIZE(%qs)\",\n \t\t     arg2, arg3, &expr2->where, arg1);\n \t  return false;\n \t}\n@@ -402,8 +402,8 @@ same_type_check (gfc_expr *e, int n, gfc_expr *f, int m)\n   if (gfc_compare_types (&e->ts, &f->ts))\n     return true;\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same type \"\n-\t     \"and kind as '%s'\", gfc_current_intrinsic_arg[m]->name,\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be the same type \"\n+\t     \"and kind as %qs\", gfc_current_intrinsic_arg[m]->name,\n \t     gfc_current_intrinsic, &f->where,\n \t     gfc_current_intrinsic_arg[n]->name);\n \n@@ -419,7 +419,7 @@ rank_check (gfc_expr *e, int n, int rank)\n   if (e->rank == rank)\n     return true;\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank %d\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be of rank %d\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where, rank);\n \n@@ -434,7 +434,7 @@ nonoptional_check (gfc_expr *e, int n)\n {\n   if (e->expr_type == EXPR_VARIABLE && e->symtree->n.sym->attr.optional)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be OPTIONAL\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must not be OPTIONAL\",\n \t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t\t &e->where);\n     }\n@@ -455,7 +455,7 @@ allocatable_check (gfc_expr *e, int n)\n   attr = gfc_variable_attr (e, NULL);\n   if (!attr.allocatable || attr.associate_var)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be ALLOCATABLE\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be ALLOCATABLE\",\n \t\t gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t\t &e->where);\n       return false;\n@@ -473,7 +473,7 @@ kind_value_check (gfc_expr *e, int n, int k)\n   if (e->ts.kind == k)\n     return true;\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of kind %d\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be of kind %d\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n \t     &e->where, k);\n \n@@ -511,7 +511,7 @@ variable_check (gfc_expr *e, int n, bool allow_proc)\n \n       if (!ref)\n \t{\n-\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L cannot be \"\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L cannot be \"\n \t\t     \"INTENT(IN)\", gfc_current_intrinsic_arg[n]->name,\n \t\t     gfc_current_intrinsic, &e->where);\n \t  return false;\n@@ -532,7 +532,7 @@ variable_check (gfc_expr *e, int n, bool allow_proc)\n \t  return true;\n     }\n \n-  gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a variable\",\n+  gfc_error (\"%qs argument of %qs intrinsic at %L must be a variable\",\n \t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic, &e->where);\n \n   return false;\n@@ -581,7 +581,7 @@ dim_corank_check (gfc_expr *dim, gfc_expr *array)\n   if (mpz_cmp_ui (dim->value.integer, 1) < 0\n       || mpz_cmp_ui (dim->value.integer, corank) > 0)\n     {\n-      gfc_error (\"'dim' argument of '%s' intrinsic at %L is not a valid \"\n+      gfc_error (\"'dim' argument of %qs intrinsic at %L is not a valid \"\n \t\t \"codimension index\", gfc_current_intrinsic, &dim->where);\n \n       return false;\n@@ -631,7 +631,7 @@ dim_rank_check (gfc_expr *dim, gfc_expr *array, int allow_assumed)\n   if (mpz_cmp_ui (dim->value.integer, 1) < 0\n       || mpz_cmp_ui (dim->value.integer, rank) > 0)\n     {\n-      gfc_error (\"'dim' argument of '%s' intrinsic at %L is not a valid \"\n+      gfc_error (\"'dim' argument of %qs intrinsic at %L is not a valid \"\n \t\t \"dimension index\", gfc_current_intrinsic, &dim->where);\n \n       return false;\n@@ -856,7 +856,7 @@ gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n \n   if (a->ts.type != p->ts.type)\n     {\n-      gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L must \"\n+      gfc_error (\"%qs and %qs arguments of %qs intrinsic at %L must \"\n \t\t \"have the same type\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &p->where);\n@@ -901,7 +901,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n \n   if (!attr1.pointer && !attr1.proc_pointer)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a POINTER\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &pointer->where);\n       return false;\n@@ -910,7 +910,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n   /* F2008, C1242.  */\n   if (attr1.pointer && gfc_is_coindexed (pointer))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be \"\n \t\t \"coindexed\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &pointer->where);\n       return false;\n@@ -928,7 +928,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n     attr2 = gfc_expr_attr (target);\n   else\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a pointer \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a pointer \"\n \t\t \"or target VARIABLE or FUNCTION\",\n \t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &target->where);\n@@ -937,7 +937,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n \n   if (attr1.pointer && !attr2.pointer && !attr2.target)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a POINTER \"\n \t\t \"or a TARGET\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &target->where);\n       return false;\n@@ -946,7 +946,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n   /* F2008, C1242.  */\n   if (attr1.pointer && gfc_is_coindexed (target))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be \"\n \t\t \"coindexed\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &target->where);\n       return false;\n@@ -974,7 +974,7 @@ gfc_check_associated (gfc_expr *pointer, gfc_expr *target)\n null_arg:\n \n   gfc_error (\"NULL pointer at %L is not permitted as actual argument \"\n-\t     \"of '%s' intrinsic function\", where, gfc_current_intrinsic);\n+\t     \"of %qs intrinsic function\", where, gfc_current_intrinsic);\n   return false;\n \n }\n@@ -1031,7 +1031,7 @@ gfc_check_atomic (gfc_expr *atom, int atom_no, gfc_expr *value, int val_no,\n \n   if (atom->ts.type != value->ts.type)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall have the same \"\n+      gfc_error_1 (\"'%s' argument of '%s' intrinsic at %L shall have the same \"\n \t\t \"type as '%s' at %L\", gfc_current_intrinsic_arg[val_no]->name,\n \t\t gfc_current_intrinsic, &value->where,\n \t\t gfc_current_intrinsic_arg[atom_no]->name, &atom->where);\n@@ -1377,7 +1377,7 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n \n       if (x->ts.type == BT_COMPLEX)\n \t{\n-\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be \"\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L must not be \"\n \t\t     \"present if 'x' is COMPLEX\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &y->where);\n@@ -1386,7 +1386,7 @@ gfc_check_cmplx (gfc_expr *x, gfc_expr *y, gfc_expr *kind)\n \n       if (y->ts.type == BT_COMPLEX)\n \t{\n-\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must have a type \"\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L must have a type \"\n \t\t     \"of either REAL or INTEGER\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &y->where);\n@@ -1575,7 +1575,7 @@ gfc_check_co_reduce (gfc_expr *a, gfc_expr *op, gfc_expr *result_image,\n \n   if (!gfc_compare_types (&a->ts, &sym->result->ts))\n     {\n-      gfc_error (\"A argument at %L has type %s but the function passed as \"\n+      gfc_error_1 (\"A argument at %L has type %s but the function passed as \"\n \t\t \"OPERATOR at %L returns %s\",\n \t\t &a->where, gfc_typename (&a->ts), &op->where,\n \t\t gfc_typename (&sym->result->ts));\n@@ -1655,16 +1655,16 @@ gfc_check_co_reduce (gfc_expr *a, gfc_expr *op, gfc_expr *result_image,\n \t  && ((formal_size1 && actual_size != formal_size1)\n \t       || (formal_size2 && actual_size != formal_size2)))\n \t{\n-\t  gfc_error (\"The character length of the A argument at %L and of the \"\n-\t\t     \"arguments of the OPERATOR at %L shall be the same\",\n+\t  gfc_error_1 (\"The character length of the A argument at %L and of the \"\n+\t\t       \"arguments of the OPERATOR at %L shall be the same\",\n \t\t     &a->where, &op->where);\n \t  return false;\n \t}\n       if (actual_size && result_size && actual_size != result_size)\n \t{\n-\t  gfc_error (\"The character length of the A argument at %L and of the \"\n-\t\t     \"function result of the OPERATOR at %L shall be the same\",\n-\t\t     &a->where, &op->where);\n+\t  gfc_error_1 (\"The character length of the A argument at %L and of the \"\n+\t\t       \"function result of the OPERATOR at %L shall be the same\",\n+\t\t       &a->where, &op->where);\n \t  return false;\n \t}\n     }\n@@ -1680,10 +1680,10 @@ gfc_check_co_minmax (gfc_expr *a, gfc_expr *result_image, gfc_expr *stat,\n   if (a->ts.type != BT_INTEGER && a->ts.type != BT_REAL\n       && a->ts.type != BT_CHARACTER)\n     {\n-       gfc_error (\"'%s' argument of '%s' intrinsic at %L shall be of type \"\n-\t\t  \"integer, real or character\",\n-\t\t  gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n-\t\t  &a->where);\n+       gfc_error_1 (\"'%s' argument of '%s' intrinsic at %L shall be of type \"\n+\t\t    \"integer, real or character\",\n+\t\t    gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t    &a->where);\n        return false;\n     }\n   return check_co_collective (a, result_image, stat, errmsg, false);\n@@ -1775,7 +1775,7 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n \t      {\n \t\tif (!identical_dimen_shape (array, i, shift, j))\n \t\t  {\n-\t\t    gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n+\t\t    gfc_error (\"%qs argument of %qs intrinsic at %L has \"\n \t\t\t       \"invalid shape in dimension %d (%ld/%ld)\",\n \t\t\t       gfc_current_intrinsic_arg[1]->name,\n \t\t\t       gfc_current_intrinsic, &shift->where, i + 1,\n@@ -1790,7 +1790,7 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n     }\n   else\n     {\n-      gfc_error (\"'%s' argument of intrinsic '%s' at %L of must have rank \"\n+      gfc_error (\"%qs argument of intrinsic %qs at %L of must have rank \"\n \t\t \"%d or be a scalar\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &shift->where, array->rank - 1);\n       return false;\n@@ -1834,7 +1834,7 @@ gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n \n       if (x->ts.type == BT_COMPLEX)\n \t{\n-\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be \"\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L must not be \"\n \t\t     \"present if 'x' is COMPLEX\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &y->where);\n@@ -1843,7 +1843,7 @@ gfc_check_dcmplx (gfc_expr *x, gfc_expr *y)\n \n       if (y->ts.type == BT_COMPLEX)\n \t{\n-\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must have a type \"\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L must have a type \"\n \t\t     \"of either REAL or INTEGER\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &y->where);\n@@ -1893,7 +1893,7 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n       break;\n \n     default:\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be numeric \"\n \t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &vector_a->where);\n       return false;\n@@ -1907,7 +1907,7 @@ gfc_check_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n \n   if (! identical_dimen_shape (vector_a, 0, vector_b, 0))\n     {\n-      gfc_error (\"Different shape for arguments '%s' and '%s' at %L for \"\n+      gfc_error (\"Different shape for arguments %qs and %qs at %L for \"\n \t\t \"intrinsic 'dot_product'\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic_arg[1]->name, &vector_a->where);\n       return false;\n@@ -1926,15 +1926,15 @@ gfc_check_dprod (gfc_expr *x, gfc_expr *y)\n \n   if (x->ts.kind != gfc_default_real_kind)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be default \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be default \"\n \t\t \"real\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &x->where);\n       return false;\n     }\n \n   if (y->ts.kind != gfc_default_real_kind)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be default \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be default \"\n \t\t \"real\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &y->where);\n       return false;\n@@ -1955,8 +1955,8 @@ gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n \n   if (i->is_boz && j->is_boz)\n     {\n-      gfc_error (\"'I' at %L and 'J' at %L cannot both be BOZ literal \"\n-\t\t \"constants\", &i->where, &j->where);\n+      gfc_error_1 (\"'I' at %L and 'J' at %L cannot both be BOZ literal \"\n+\t\t   \"constants\", &i->where, &j->where);\n       return false;\n     }\n \n@@ -2025,7 +2025,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t      {\n \t\tif (!identical_dimen_shape (array, i, shift, j))\n \t\t  {\n-\t\t    gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n+\t\t    gfc_error (\"%qs argument of %qs intrinsic at %L has \"\n \t\t\t       \"invalid shape in dimension %d (%ld/%ld)\",\n \t\t\t       gfc_current_intrinsic_arg[1]->name,\n \t\t\t       gfc_current_intrinsic, &shift->where, i + 1,\n@@ -2040,7 +2040,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n     }\n   else\n     {\n-      gfc_error (\"'%s' argument of intrinsic '%s' at %L of must have rank \"\n+      gfc_error (\"%qs argument of intrinsic %qs at %L of must have rank \"\n \t\t \"%d or be a scalar\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &shift->where, array->rank - 1);\n       return false;\n@@ -2068,7 +2068,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n \t}\n       else\n \t{\n-\t  gfc_error (\"'%s' argument of intrinsic '%s' at %L of must have \"\n+\t  gfc_error (\"%qs argument of intrinsic %qs at %L of must have \"\n \t\t     \"rank %d or be a scalar\",\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t     &shift->where, array->rank - 1);\n@@ -2369,8 +2369,8 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n \n   if (string->ts.kind != substring->ts.kind)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be the same \"\n-\t\t \"kind as '%s'\", gfc_current_intrinsic_arg[1]->name,\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be the same \"\n+\t\t \"kind as %qs\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &substring->where,\n \t\t gfc_current_intrinsic_arg[0]->name);\n       return false;\n@@ -2471,9 +2471,9 @@ gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n \n \t      if (i2 > i3)\n \t\t{\n-\t\t  gfc_error (\"The absolute value of SHIFT at %L must be less \"\n-\t\t\t     \"than or equal to SIZE at %L\", &shift->where,\n-\t\t\t     &size->where);\n+\t\t  gfc_error_1 (\"The absolute value of SHIFT at %L must be less \"\n+\t\t\t       \"than or equal to SIZE at %L\", &shift->where,\n+\t\t\t       &size->where);\n \t\t  return false;\n \t\t}\n \t     }\n@@ -2532,7 +2532,7 @@ gfc_check_kind (gfc_expr *x)\n {\n   if (x->ts.type == BT_DERIVED)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a \"\n \t\t \"non-derived type\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &x->where);\n       return false;\n@@ -2743,7 +2743,7 @@ min_max_args (gfc_actual_arglist *args)\n \n   if (args == NULL || args->next == NULL)\n     {\n-      gfc_error (\"Intrinsic '%s' at %L must have at least two arguments\",\n+      gfc_error (\"Intrinsic %qs at %L must have at least two arguments\",\n \t\t gfc_current_intrinsic, gfc_current_intrinsic_where);\n       return false;\n     }\n@@ -2791,7 +2791,7 @@ min_max_args (gfc_actual_arglist *args)\n \n   if (!a1 || !a2)\n     {\n-      gfc_error (\"Missing '%s' argument to the %s intrinsic at %L\",\n+      gfc_error (\"Missing %qs argument to the %s intrinsic at %L\",\n \t         !a1 ? \"a1\" : \"a2\", gfc_current_intrinsic,\n \t\t gfc_current_intrinsic_where);\n       return false;\n@@ -2806,12 +2806,12 @@ min_max_args (gfc_actual_arglist *args)\n   return true;\n \n duplicate:\n-  gfc_error (\"Duplicate argument '%s' at %L to intrinsic %s\", arg->name,\n+  gfc_error (\"Duplicate argument %qs at %L to intrinsic %s\", arg->name,\n \t     &arg->expr->where, gfc_current_intrinsic);\n   return false;\n \n unknown:\n-  gfc_error (\"Unknown argument '%s' at %L to intrinsic %s\", arg->name,\n+  gfc_error (\"Unknown argument %qs at %L to intrinsic %s\", arg->name,\n \t     &arg->expr->where, gfc_current_intrinsic);\n   return false;\n }\n@@ -2840,7 +2840,7 @@ check_rest (bt type, int kind, gfc_actual_arglist *arglist)\n \t    }\n \t  else\n \t    {\n-\t      gfc_error (\"'a%d' argument of '%s' intrinsic at %L must be \"\n+\t      gfc_error (\"'a%d' argument of %qs intrinsic at %L must be \"\n \t\t\t \"%s(%d)\", n, gfc_current_intrinsic, &x->where,\n \t\t\t gfc_basic_typename (type), kind);\n \t      return false;\n@@ -2878,7 +2878,7 @@ gfc_check_min_max (gfc_actual_arglist *arg)\n     }\n   else if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n     {\n-      gfc_error (\"'a1' argument of '%s' intrinsic at %L must be INTEGER, \"\n+      gfc_error (\"'a1' argument of %qs intrinsic at %L must be INTEGER, \"\n \t\t \"REAL or CHARACTER\", gfc_current_intrinsic, &x->where);\n       return false;\n     }\n@@ -2928,15 +2928,15 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n {\n   if ((matrix_a->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_a->ts))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be numeric \"\n \t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &matrix_a->where);\n       return false;\n     }\n \n   if ((matrix_b->ts.type != BT_LOGICAL) && !gfc_numeric_ts (&matrix_b->ts))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be numeric \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be numeric \"\n \t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &matrix_b->where);\n       return false;\n@@ -2945,7 +2945,7 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n   if ((matrix_a->ts.type == BT_LOGICAL && gfc_numeric_ts (&matrix_b->ts))\n       || (gfc_numeric_ts (&matrix_a->ts) && matrix_b->ts.type == BT_LOGICAL))\n     {\n-      gfc_error (\"Argument types of '%s' intrinsic at %L must match (%s/%s)\",\n+      gfc_error (\"Argument types of %qs intrinsic at %L must match (%s/%s)\",\n \t\t gfc_current_intrinsic, &matrix_a->where,\n \t\t gfc_typename(&matrix_a->ts), gfc_typename(&matrix_b->ts));\n        return false;\n@@ -2959,8 +2959,8 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n       /* Check for case matrix_a has shape(m), matrix_b has shape (m, k).  */\n       if (!identical_dimen_shape (matrix_a, 0, matrix_b, 0))\n \t{\n-\t  gfc_error (\"Different shape on dimension 1 for arguments '%s' \"\n-\t\t     \"and '%s' at %L for intrinsic matmul\",\n+\t  gfc_error (\"Different shape on dimension 1 for arguments %qs \"\n+\t\t     \"and %qs at %L for intrinsic matmul\",\n \t\t     gfc_current_intrinsic_arg[0]->name,\n \t\t     gfc_current_intrinsic_arg[1]->name, &matrix_a->where);\n \t  return false;\n@@ -2978,16 +2978,16 @@ gfc_check_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n \t - matrix_a has shape (n,m) and matrix_b has shape (m).  */\n       if (!identical_dimen_shape (matrix_a, 1, matrix_b, 0))\n \t{\n-\t  gfc_error (\"Different shape on dimension 2 for argument '%s' and \"\n-\t\t     \"dimension 1 for argument '%s' at %L for intrinsic \"\n+\t  gfc_error (\"Different shape on dimension 2 for argument %qs and \"\n+\t\t     \"dimension 1 for argument %qs at %L for intrinsic \"\n \t\t     \"matmul\", gfc_current_intrinsic_arg[0]->name,\n \t\t     gfc_current_intrinsic_arg[1]->name, &matrix_a->where);\n \t  return false;\n \t}\n       break;\n \n     default:\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of rank \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be of rank \"\n \t\t \"1 or 2\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &matrix_a->where);\n       return false;\n@@ -3162,7 +3162,7 @@ gfc_check_transf_bit_intrins (gfc_actual_arglist *ap)\n {\n   if (ap->expr->ts.type != BT_INTEGER)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER\",\n                  gfc_current_intrinsic_arg[0]->name,\n                  gfc_current_intrinsic, &ap->expr->where);\n       return false;\n@@ -3337,7 +3337,7 @@ gfc_check_null (gfc_expr *mold)\n \n   if (!attr.pointer && !attr.proc_pointer && !attr.allocatable)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a POINTER, \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a POINTER, \"\n \t\t \"ALLOCATABLE or procedure pointer\",\n \t\t gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &mold->where);\n@@ -3352,7 +3352,7 @@ gfc_check_null (gfc_expr *mold)\n   /* F2008, C1242.  */\n   if (gfc_is_coindexed (mold))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be \"\n \t\t \"coindexed\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &mold->where);\n       return false;\n@@ -3424,9 +3424,9 @@ gfc_check_pack (gfc_expr *array, gfc_expr *mask, gfc_expr *vector)\n \n \t  if (mpz_get_si (vector_size) < mask_true_values)\n \t    {\n-\t      gfc_error (\"'%s' argument of '%s' intrinsic at %L must \"\n+\t      gfc_error (\"%qs argument of %qs intrinsic at %L must \"\n \t\t\t \"provide at least as many elements as there \"\n-\t\t\t \"are .TRUE. values in '%s' (%ld/%d)\",\n+\t\t\t \"are .TRUE. values in %qs (%ld/%d)\",\n \t\t\t gfc_current_intrinsic_arg[2]->name,\n \t\t\t gfc_current_intrinsic, &vector->where,\n \t\t\t gfc_current_intrinsic_arg[1]->name,\n@@ -3482,15 +3482,15 @@ gfc_check_present (gfc_expr *a)\n   sym = a->symtree->n.sym;\n   if (!sym->attr.dummy)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of a \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be of a \"\n \t\t \"dummy variable\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &a->where);\n       return false;\n     }\n \n   if (!sym->attr.optional)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be of \"\n \t\t \"an OPTIONAL dummy variable\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &a->where);\n@@ -3509,8 +3509,8 @@ gfc_check_present (gfc_expr *a)\n \t       || (a->ref->u.ar.type == AR_ELEMENT\n \t\t   && a->ref->u.ar.as->rank == 0))))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must not be a \"\n-\t\t \"subobject of '%s'\", gfc_current_intrinsic_arg[0]->name,\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must not be a \"\n+\t\t \"subobject of %qs\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &a->where, sym->name);\n       return false;\n     }\n@@ -3671,7 +3671,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \n   if (shape_size <= 0)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L is empty\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L is empty\",\n \t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &shape->where);\n       return false;\n@@ -3695,7 +3695,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \t  gfc_extract_int (e, &extent);\n \t  if (extent < 0)\n \t    {\n-\t      gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n+\t      gfc_error (\"%qs argument of %qs intrinsic at %L has \"\n \t\t\t \"negative element (%d)\",\n \t\t\t gfc_current_intrinsic_arg[1]->name,\n \t\t\t gfc_current_intrinsic, &e->where, extent);\n@@ -3735,7 +3735,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \n \t  if (order_size != shape_size)\n \t    {\n-\t      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t      gfc_error (\"%qs argument of %qs intrinsic at %L \"\n \t\t\t \"has wrong number of elements (%d/%d)\",\n \t\t\t gfc_current_intrinsic_arg[3]->name,\n \t\t\t gfc_current_intrinsic, &order->where,\n@@ -3753,7 +3753,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \n \t      if (dim < 1 || dim > order_size)\n \t\t{\n-\t\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+\t\t  gfc_error (\"%qs argument of %qs intrinsic at %L \"\n \t\t\t     \"has out-of-range dimension (%d)\",\n \t\t\t     gfc_current_intrinsic_arg[3]->name,\n \t\t\t     gfc_current_intrinsic, &e->where, dim);\n@@ -3762,7 +3762,7 @@ gfc_check_reshape (gfc_expr *source, gfc_expr *shape,\n \n \t      if (perm[dim-1] != 0)\n \t\t{\n-\t\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L has \"\n+\t\t  gfc_error (\"%qs argument of %qs intrinsic at %L has \"\n \t\t\t     \"invalid permutation of dimensions (dimension \"\n \t\t\t     \"'%d' duplicated)\",\n \t\t\t     gfc_current_intrinsic_arg[3]->name,\n@@ -3815,7 +3815,7 @@ gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n {\n   if (a->ts.type != BT_DERIVED && a->ts.type != BT_CLASS)\n     {\n-        gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+        gfc_error (\"%qs argument of %qs intrinsic at %L \"\n \t\t   \"cannot be of type %s\",\n \t\t   gfc_current_intrinsic_arg[0]->name,\n \t\t   gfc_current_intrinsic,\n@@ -3825,7 +3825,7 @@ gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n \n   if (!(gfc_type_is_extensible (a->ts.u.derived) || UNLIMITED_POLY (a)))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L \"\n \t\t \"must be of an extensible type\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &a->where);\n@@ -3834,7 +3834,7 @@ gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n \n   if (b->ts.type != BT_DERIVED && b->ts.type != BT_CLASS)\n     {\n-        gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+        gfc_error (\"%qs argument of %qs intrinsic at %L \"\n \t\t   \"cannot be of type %s\",\n \t\t   gfc_current_intrinsic_arg[0]->name,\n \t\t   gfc_current_intrinsic,\n@@ -3844,7 +3844,7 @@ gfc_check_same_type_as (gfc_expr *a, gfc_expr *b)\n \n   if (!(gfc_type_is_extensible (b->ts.u.derived) || UNLIMITED_POLY (b)))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L \"\n \t\t \"must be of an extensible type\",\n \t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &b->where);\n@@ -4086,7 +4086,7 @@ gfc_check_sizeof (gfc_expr *arg)\n {\n   if (arg->ts.type == BT_PROCEDURE)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be a procedure\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be a procedure\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &arg->where);\n       return false;\n@@ -4099,7 +4099,7 @@ gfc_check_sizeof (gfc_expr *arg)\n \t      && arg->symtree->n.sym->as->type != AS_DEFERRED\n \t      && arg->symtree->n.sym->as->type != AS_ASSUMED_RANK)))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be TYPE(*)\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be TYPE(*)\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &arg->where);\n       return false;\n@@ -4110,7 +4110,7 @@ gfc_check_sizeof (gfc_expr *arg)\n       && arg->symtree->n.sym->as->type == AS_ASSUMED_SIZE && arg->ref\n       && arg->ref->type == REF_ARRAY && arg->ref->u.ar.type == AR_FULL)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be an \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be an \"\n \t\t \"assumed-size array\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &arg->where);\n       return false;\n@@ -4229,7 +4229,7 @@ gfc_check_c_sizeof (gfc_expr *arg)\n \n   if (!is_c_interoperable (arg, &msg, false, false))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be an \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be an \"\n \t\t \"interoperable data entity: %s\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &arg->where, msg);\n@@ -4238,7 +4238,7 @@ gfc_check_c_sizeof (gfc_expr *arg)\n \n   if (arg->ts.type == BT_ASSUMED)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be \"\n \t\t \"TYPE(*)\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &arg->where);\n@@ -4250,7 +4250,7 @@ gfc_check_c_sizeof (gfc_expr *arg)\n       && arg->symtree->n.sym->as->type == AS_ASSUMED_SIZE && arg->ref\n       && arg->ref->type == REF_ARRAY && arg->ref->u.ar.type == AR_FULL)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be an \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be an \"\n \t\t \"assumed-size array\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &arg->where);\n       return false;\n@@ -4449,7 +4449,7 @@ gfc_check_c_funloc (gfc_expr *x)\n       for (ns = gfc_current_ns; ns; ns = ns->parent)\n \tif (x->symtree->n.sym == ns->proc_name)\n \t  {\n-\t    gfc_error (\"Function result '%s' at %L is invalid as X argument \"\n+\t    gfc_error (\"Function result %qs at %L is invalid as X argument \"\n \t\t       \"to C_FUNLOC\", x->symtree->n.sym->name, &x->where);\n \t    return false;\n \t  }\n@@ -4575,7 +4575,7 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n {\n   if (source->rank >= GFC_MAX_DIMENSIONS)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be less \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be less \"\n \t\t \"than rank %d\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &source->where, GFC_MAX_DIMENSIONS);\n \n@@ -4594,7 +4594,7 @@ gfc_check_spread (gfc_expr *source, gfc_expr *dim, gfc_expr *ncopies)\n       && (mpz_cmp_ui (dim->value.integer, 1) < 0\n \t  || mpz_cmp_ui (dim->value.integer, source->rank + 1) > 0))\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L is not a valid \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L is not a valid \"\n \t\t \"dimension index\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &dim->where);\n       return false;\n@@ -5189,9 +5189,9 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \n       if (mpz_get_si (vector_size) < mask_true_count)\n \t{\n-\t  gfc_error (\"'%s' argument of '%s' intrinsic at %L must \"\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L must \"\n \t\t     \"provide at least as many elements as there \"\n-\t\t     \"are .TRUE. values in '%s' (%ld/%d)\",\n+\t\t     \"are .TRUE. values in %qs (%ld/%d)\",\n \t\t     gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t     &vector->where, gfc_current_intrinsic_arg[1]->name,\n \t\t     mpz_get_si (vector_size), mask_true_count);\n@@ -5203,8 +5203,8 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n \n   if (mask->rank != field->rank && field->rank != 0)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must have \"\n-\t\t \"the same rank as '%s' or be a scalar\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must have \"\n+\t\t \"the same rank as %qs or be a scalar\",\n \t\t gfc_current_intrinsic_arg[2]->name, gfc_current_intrinsic,\n \t\t &field->where, gfc_current_intrinsic_arg[1]->name);\n       return false;\n@@ -5216,7 +5216,7 @@ gfc_check_unpack (gfc_expr *vector, gfc_expr *mask, gfc_expr *field)\n       for (i = 0; i < field->rank; i++)\n \tif (! identical_dimen_shape (mask, i, field, i))\n \t{\n-\t  gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L \"\n+\t  gfc_error (\"%qs and %qs arguments of %qs intrinsic at %L \"\n \t\t     \"must have identical shape.\",\n \t\t     gfc_current_intrinsic_arg[2]->name,\n \t\t     gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n@@ -5474,7 +5474,7 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n \n       if (gfc_array_size (put, &put_size)\n \t  && mpz_get_ui (put_size) < kiss_size)\n-\tgfc_error (\"Size of '%s' argument of '%s' intrinsic at %L \"\n+\tgfc_error (\"Size of %qs argument of %qs intrinsic at %L \"\n \t\t   \"too small (%i/%i)\",\n \t\t   gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t   where, (int) mpz_get_ui (put_size), kiss_size);\n@@ -5506,7 +5506,7 @@ gfc_check_random_seed (gfc_expr *size, gfc_expr *put, gfc_expr *get)\n \n        if (gfc_array_size (get, &get_size)\n  \t  && mpz_get_ui (get_size) < kiss_size)\n-\tgfc_error (\"Size of '%s' argument of '%s' intrinsic at %L \"\n+\tgfc_error (\"Size of %qs argument of %qs intrinsic at %L \"\n \t\t   \"too small (%i/%i)\",\n \t\t   gfc_current_intrinsic_arg[2]->name, gfc_current_intrinsic,\n \t\t   where, (int) mpz_get_ui (get_size), kiss_size);\n@@ -5817,7 +5817,7 @@ gfc_check_getarg (gfc_expr *pos, gfc_expr *value)\n \n   if (pos->ts.kind > gfc_default_integer_kind)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be of a kind \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be of a kind \"\n \t\t \"not wider than the default kind (%d)\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &pos->where, gfc_default_integer_kind);\n@@ -6169,23 +6169,23 @@ gfc_check_and (gfc_expr *i, gfc_expr *j)\n {\n   if (i->ts.type != BT_INTEGER && i->ts.type != BT_LOGICAL)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n \t\t \"or LOGICAL\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &i->where);\n       return false;\n     }\n \n   if (j->ts.type != BT_INTEGER && j->ts.type != BT_LOGICAL)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be INTEGER \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be INTEGER \"\n \t\t \"or LOGICAL\", gfc_current_intrinsic_arg[1]->name,\n \t\t gfc_current_intrinsic, &j->where);\n       return false;\n     }\n \n   if (i->ts.type != j->ts.type)\n     {\n-      gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L must \"\n+      gfc_error (\"%qs and %qs arguments of %qs intrinsic at %L must \"\n \t\t \"have the same type\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &j->where);\n@@ -6207,15 +6207,15 @@ gfc_check_storage_size (gfc_expr *a, gfc_expr *kind)\n {\n   if (a->ts.type == BT_ASSUMED)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be TYPE(*)\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be TYPE(*)\",\n \t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n \t\t &a->where);\n       return false;\n     }\n \n   if (a->ts.type == BT_PROCEDURE)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L shall not be a \"\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall not be a \"\n \t\t \"procedure\", gfc_current_intrinsic_arg[0]->name,\n \t\t gfc_current_intrinsic, &a->where);\n       return false;\n@@ -6232,7 +6232,7 @@ gfc_check_storage_size (gfc_expr *a, gfc_expr *kind)\n \n   if (kind->expr_type != EXPR_CONSTANT)\n     {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be a constant\",\n+      gfc_error (\"%qs argument of %qs intrinsic at %L must be a constant\",\n \t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n \t\t &kind->where);\n       return false;"}, {"sha": "513002221ce1e977dc51768e663e36ba32db8bfb", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -666,7 +666,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n \t up to 255 extension levels.  */\n       if (ts->u.derived->attr.extension == 255)\n \t{\n-\t  gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n+\t  gfc_error (\"Maximum extension level reached with type %qs at %L\",\n \t\t     ts->u.derived->name, &ts->u.derived->declared_at);\n \treturn false;\n \t}\n@@ -2686,7 +2686,7 @@ find_typebound_proc_uop (gfc_symbol* derived, bool* t,\n \t  && res->n.tb->access == ACCESS_PRIVATE)\n \t{\n \t  if (where)\n-\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n+\t    gfc_error (\"%qs of %qs is PRIVATE at %L\",\n \t\t       name, derived->name, where);\n \t  if (t)\n \t    *t = false;\n@@ -2760,7 +2760,7 @@ gfc_find_typebound_intrinsic_op (gfc_symbol* derived, bool* t,\n \t  && res->access == ACCESS_PRIVATE)\n \t{\n \t  if (where)\n-\t    gfc_error (\"'%s' of '%s' is PRIVATE at %L\",\n+\t    gfc_error (\"%qs of %qs is PRIVATE at %L\",\n \t\t       gfc_op2string (op), derived->name, where);\n \t  if (t)\n \t    *t = false;"}, {"sha": "5d0651ee58189e86556c4e83a1718811fd9a636a", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -253,9 +253,9 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \n \t  if (init && expr->expr_type != EXPR_ARRAY)\n \t    {\n-\t      gfc_error (\"'%s' at %L already is initialized at %L\",\n-\t\t\t lvalue->symtree->n.sym->name, &lvalue->where,\n-\t\t\t &init->where);\n+\t      gfc_error_1 (\"'%s' at %L already is initialized at %L\",\n+\t\t\t   lvalue->symtree->n.sym->name, &lvalue->where,\n+\t\t\t   &init->where);\n \t      goto abort;\n \t    }\n "}, {"sha": "c6b46b9488c07e3bc2d1ae72a361bef8f3d1b9d7", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -261,7 +261,7 @@ var_element (gfc_data_variable *new_var)\n   if (!sym->attr.function && gfc_current_ns->parent\n       && gfc_current_ns->parent == sym->ns)\n     {\n-      gfc_error (\"Host associated variable '%s' may not be in the DATA \"\n+      gfc_error (\"Host associated variable %qs may not be in the DATA \"\n \t\t \"statement at %C\", sym->name);\n       return MATCH_ERROR;\n     }\n@@ -379,7 +379,7 @@ match_data_constant (gfc_expr **result)\n       || (sym->attr.flavor != FL_PARAMETER\n \t  && (!dt_sym || dt_sym->attr.flavor != FL_DERIVED)))\n     {\n-      gfc_error (\"Symbol '%s' must be a PARAMETER in DATA statement at %C\",\n+      gfc_error (\"Symbol %qs must be a PARAMETER in DATA statement at %C\",\n \t\t name);\n       return MATCH_ERROR;\n     }\n@@ -1017,15 +1017,15 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t    {\n \t      /* Make personalized messages to give better feedback.  */\n \t      if (sym->ts.type == BT_DERIVED)\n-\t\tgfc_error (\"Variable '%s' at %L is a dummy argument to the \"\n-\t\t\t   \"BIND(C) procedure '%s' but is not C interoperable \"\n-\t\t\t   \"because derived type '%s' is not C interoperable\",\n+\t\tgfc_error (\"Variable %qs at %L is a dummy argument to the \"\n+\t\t\t   \"BIND(C) procedure %qs but is not C interoperable \"\n+\t\t\t   \"because derived type %qs is not C interoperable\",\n \t\t\t   sym->name, &(sym->declared_at),\n \t\t\t   sym->ns->proc_name->name,\n \t\t\t   sym->ts.u.derived->name);\n \t      else if (sym->ts.type == BT_CLASS)\n-\t\tgfc_error (\"Variable '%s' at %L is a dummy argument to the \"\n-\t\t\t   \"BIND(C) procedure '%s' but is not C interoperable \"\n+\t\tgfc_error (\"Variable %qs at %L is a dummy argument to the \"\n+\t\t\t   \"BIND(C) procedure %qs but is not C interoperable \"\n \t\t\t   \"because it is polymorphic\",\n \t\t\t   sym->name, &(sym->declared_at),\n \t\t\t   sym->ns->proc_name->name);\n@@ -1046,9 +1046,9 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT\n                   || mpz_cmp_si (cl->length->value.integer, 1) != 0)\n \t\t{\n-\t\t  gfc_error (\"Character argument '%s' at %L \"\n+\t\t  gfc_error (\"Character argument %qs at %L \"\n \t\t\t     \"must be length 1 because \"\n-                             \"procedure '%s' is BIND(C)\",\n+                             \"procedure %qs is BIND(C)\",\n \t\t\t     sym->name, &sym->declared_at,\n                              sym->ns->proc_name->name);\n \t\t  retval = false;\n@@ -1076,17 +1076,17 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \n \t  if ((sym->attr.allocatable || sym->attr.pointer) && !sym->as)\n \t    {\n-\t      gfc_error (\"Scalar variable '%s' at %L with POINTER or \"\n-\t\t\t \"ALLOCATABLE in procedure '%s' with BIND(C) is not yet\"\n+\t      gfc_error (\"Scalar variable %qs at %L with POINTER or \"\n+\t\t\t \"ALLOCATABLE in procedure %qs with BIND(C) is not yet\"\n \t\t\t \" supported\", sym->name, &(sym->declared_at),\n \t\t\t sym->ns->proc_name->name);\n \t      retval = false;\n \t    }\n \n \t  if (sym->attr.optional == 1 && sym->attr.value)\n \t    {\n-\t      gfc_error (\"Variable '%s' at %L cannot have both the OPTIONAL \"\n-\t\t\t \"and the VALUE attribute because procedure '%s' \"\n+\t      gfc_error (\"Variable %qs at %L cannot have both the OPTIONAL \"\n+\t\t\t \"and the VALUE attribute because procedure %qs \"\n \t\t\t \"is BIND(C)\", sym->name, &(sym->declared_at),\n \t\t\t sym->ns->proc_name->name);\n \t      retval = false;\n@@ -1323,7 +1323,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n       && sym->value != NULL\n       && *initp != NULL)\n     {\n-      gfc_error (\"Initializer not allowed for PARAMETER '%s' at %C\",\n+      gfc_error (\"Initializer not allowed for PARAMETER %qs at %C\",\n \t\t sym->name);\n       return false;\n     }\n@@ -1343,7 +1343,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t initializer.  */\n       if (sym->attr.data)\n \t{\n-\t  gfc_error (\"Variable '%s' at %C with an initializer already \"\n+\t  gfc_error (\"Variable %qs at %C with an initializer already \"\n \t\t     \"appears in a DATA statement\", sym->name);\n \t  return false;\n \t}\n@@ -1783,7 +1783,7 @@ check_function_name (char *name)\n \t  && strcmp (block->result->name, \"ppr@\") != 0\n \t  && strcmp (block->name, name) == 0)\n \t{\n-\t  gfc_error (\"Function name '%s' not allowed at %C\", name);\n+\t  gfc_error (\"Function name %qs not allowed at %C\", name);\n \t  return false;\n \t}\n     }\n@@ -1850,7 +1850,7 @@ variable_decl (int elem)\n       if (as->type == AS_IMPLIED_SHAPE && current_attr.flavor != FL_PARAMETER)\n \t{\n \t  m = MATCH_ERROR;\n-\t  gfc_error (\"Non-PARAMETER symbol '%s' at %L can't be implied-shape\",\n+\t  gfc_error (\"Non-PARAMETER symbol %qs at %L can't be implied-shape\",\n \t\t     name, &var_locus);\n \t  goto cleanup;\n \t}\n@@ -2819,7 +2819,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       gfc_get_ha_symbol (name, &sym);\n       if (sym->generic && gfc_find_symbol (dt_name, NULL, 0, &dt_sym))\n \t{\n-\t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t  gfc_error (\"Type name %qs at %C is ambiguous\", name);\n \t  return MATCH_ERROR;\n \t}\n       if (sym->generic && !dt_sym)\n@@ -2832,7 +2832,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       gfc_find_symbol (name, NULL, iface, &sym);\n       if (sym && sym->generic && gfc_find_symbol (dt_name, NULL, 1, &dt_sym))\n \t{\n-\t  gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t  gfc_error (\"Type name %qs at %C is ambiguous\", name);\n \t  return MATCH_ERROR;\n \t}\n       if (sym && sym->generic && !dt_sym)\n@@ -2847,9 +2847,9 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n        && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))\n       || sym->attr.subroutine)\n     {\n-      gfc_error (\"Type name '%s' at %C conflicts with previously declared \"\n-\t         \"entity at %L, which has the same name\", name,\n-\t\t &sym->declared_at);\n+      gfc_error_1 (\"Type name '%s' at %C conflicts with previously declared \"\n+\t\t   \"entity at %L, which has the same name\", name,\n+\t\t   &sym->declared_at);\n       return MATCH_ERROR;\n     }\n \n@@ -3274,21 +3274,21 @@ gfc_match_import (void)\n \t  if (gfc_current_ns->parent !=  NULL\n \t      && gfc_find_symbol (name, gfc_current_ns->parent, 1, &sym))\n \t    {\n-\t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t       gfc_error (\"Type name %qs at %C is ambiguous\", name);\n \t       return MATCH_ERROR;\n \t    }\n \t  else if (!sym && gfc_current_ns->proc_name->ns->parent !=  NULL\n \t\t   && gfc_find_symbol (name,\n \t\t\t\t       gfc_current_ns->proc_name->ns->parent,\n \t\t\t\t       1, &sym))\n \t    {\n-\t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t       gfc_error (\"Type name %qs at %C is ambiguous\", name);\n \t       return MATCH_ERROR;\n \t    }\n \n \t  if (sym == NULL)\n \t    {\n-\t      gfc_error (\"Cannot IMPORT '%s' from host scoping unit \"\n+\t      gfc_error (\"Cannot IMPORT %qs from host scoping unit \"\n \t\t\t \"at %C - does not exist.\", name);\n \t      return MATCH_ERROR;\n \t    }\n@@ -4064,13 +4064,13 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t  else\n \t    {\n               if (tmp_sym->ts.type == BT_DERIVED || ts->type == BT_DERIVED)\n-                gfc_error (\"Type declaration '%s' at %L is not C \"\n+                gfc_error (\"Type declaration %qs at %L is not C \"\n                            \"interoperable but it is BIND(C)\",\n                            tmp_sym->name, &(tmp_sym->declared_at));\n               else if (warn_c_binding_type)\n                 gfc_warning (OPT_Wc_binding_type, \"Variable %qs at %L \"\n                              \"may not be a C interoperable \"\n-                             \"kind but it is bind(c)\",\n+                             \"kind but it is BIND(C)\",\n                              tmp_sym->name, &(tmp_sym->declared_at));\n \t    }\n \t}\n@@ -4080,7 +4080,7 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t semantically no reason for the attribute.  */\n       if (is_in_common == 1 && tmp_sym->attr.is_bind_c == 1)\n \t{\n-\t  gfc_error (\"Variable '%s' in common block '%s' at \"\n+\t  gfc_error (\"Variable %qs in common block %qs at \"\n \t\t     \"%L cannot be declared with BIND(C) \"\n \t\t     \"since it is not a global\",\n \t\t     tmp_sym->name, com_block->name,\n@@ -4094,15 +4094,15 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t{\n \t  if (tmp_sym->attr.pointer == 1)\n \t    {\n-\t      gfc_error (\"Variable '%s' at %L cannot have both the \"\n+\t      gfc_error (\"Variable %qs at %L cannot have both the \"\n \t\t\t \"POINTER and BIND(C) attributes\",\n \t\t\t tmp_sym->name, &(tmp_sym->declared_at));\n \t      retval = false;\n \t    }\n \n \t  if (tmp_sym->attr.allocatable == 1)\n \t    {\n-\t      gfc_error (\"Variable '%s' at %L cannot have both the \"\n+\t      gfc_error (\"Variable %qs at %L cannot have both the \"\n \t\t\t \"ALLOCATABLE and BIND(C) attributes\",\n \t\t\t tmp_sym->name, &(tmp_sym->declared_at));\n \t      retval = false;\n@@ -4114,15 +4114,15 @@ verify_bind_c_sym (gfc_symbol *tmp_sym, gfc_typespec *ts,\n \t scalar value.  The previous tests in this function made sure\n \t the type is interoperable.  */\n       if (bind_c_function && tmp_sym->as != NULL)\n-\tgfc_error (\"Return type of BIND(C) function '%s' at %L cannot \"\n+\tgfc_error (\"Return type of BIND(C) function %qs at %L cannot \"\n \t\t   \"be an array\", tmp_sym->name, &(tmp_sym->declared_at));\n \n       /* BIND(C) functions can not return a character string.  */\n       if (bind_c_function && tmp_sym->ts.type == BT_CHARACTER)\n \tif (tmp_sym->ts.u.cl == NULL || tmp_sym->ts.u.cl->length == NULL\n \t    || tmp_sym->ts.u.cl->length->expr_type != EXPR_CONSTANT\n \t    || mpz_cmp_si (tmp_sym->ts.u.cl->length->value.integer, 1) != 0)\n-\t  gfc_error (\"Return type of BIND(C) function '%s' at %L cannot \"\n+\t  gfc_error (\"Return type of BIND(C) function %qs at %L cannot \"\n \t\t\t \"be a character string\", tmp_sym->name,\n \t\t\t &(tmp_sym->declared_at));\n     }\n@@ -4597,7 +4597,7 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n       if (gfc_new_block != NULL && sym != NULL\n \t  && strcmp (sym->name, gfc_new_block->name) == 0)\n \t{\n-\t  gfc_error (\"Name '%s' at %C is the name of the procedure\",\n+\t  gfc_error (\"Name %qs at %C is the name of the procedure\",\n \t\t     sym->name);\n \t  m = MATCH_ERROR;\n \t  goto cleanup;\n@@ -4626,7 +4626,7 @@ gfc_match_formal_arglist (gfc_symbol *progname, int st_flag, int null_flag)\n \t  for (q = p->next; q; q = q->next)\n \t    if (p->sym == q->sym)\n \t      {\n-\t\tgfc_error (\"Duplicate symbol '%s' in formal argument list \"\n+\t\tgfc_error (\"Duplicate symbol %qs in formal argument list \"\n \t\t\t   \"at %C\", p->sym->name);\n \n \t\tm = MATCH_ERROR;\n@@ -5001,7 +5001,7 @@ match_procedure_decl (void)\n \t{\n           if (sym->ts.type != BT_UNKNOWN)\n \t    {\n-\t      gfc_error (\"Procedure '%s' at %L already has basic type of %s\",\n+\t      gfc_error (\"Procedure %qs at %L already has basic type of %s\",\n \t\t\t sym->name, &gfc_current_locus,\n \t\t\t gfc_basic_typename (sym->ts.type));\n \t      return MATCH_ERROR;\n@@ -6277,7 +6277,7 @@ gfc_match_end (gfc_statement *st)\n       if (!block_name)\n \treturn MATCH_YES;\n \n-      gfc_error (\"Expected block name of '%s' in %s statement at %L\",\n+      gfc_error (\"Expected block name of %qs in %s statement at %L\",\n \t\t block_name, gfc_ascii_statement (*st), &old_loc);\n \n       return MATCH_ERROR;\n@@ -6303,15 +6303,15 @@ gfc_match_end (gfc_statement *st)\n \n   if (strcmp (name, block_name) != 0 && strcmp (block_name, \"ppr@\") != 0)\n     {\n-      gfc_error (\"Expected label '%s' for %s statement at %C\", block_name,\n+      gfc_error (\"Expected label %qs for %s statement at %C\", block_name,\n \t\t gfc_ascii_statement (*st));\n       goto cleanup;\n     }\n   /* Procedure pointer as function result.  */\n   else if (strcmp (block_name, \"ppr@\") == 0\n \t   && strcmp (name, gfc_current_block ()->ns->proc_name->name) != 0)\n     {\n-      gfc_error (\"Expected label '%s' for %s statement at %C\",\n+      gfc_error (\"Expected label %qs for %s statement at %C\",\n \t\t gfc_current_block ()->ns->proc_name->name,\n \t\t gfc_ascii_statement (*st));\n       goto cleanup;\n@@ -7315,7 +7315,7 @@ gfc_match_volatile (void)\n \t     for variable in a BLOCK which is defined outside of the BLOCK.  */\n \t  if (sym->ns != gfc_current_ns && sym->attr.codimension)\n \t    {\n-\t      gfc_error (\"Specifying VOLATILE for coarray variable '%s' at \"\n+\t      gfc_error (\"Specifying VOLATILE for coarray variable %qs at \"\n \t\t\t \"%C, which is use-/host-associated\", sym->name);\n \t      return MATCH_ERROR;\n \t    }\n@@ -7531,27 +7531,27 @@ check_extended_derived_type (char *name)\n   /* F08:C428.  */\n   if (!extended)\n     {\n-      gfc_error (\"Symbol '%s' at %C has not been previously defined\", name);\n+      gfc_error (\"Symbol %qs at %C has not been previously defined\", name);\n       return NULL;\n     }\n \n   if (extended->attr.flavor != FL_DERIVED)\n     {\n-      gfc_error (\"'%s' in EXTENDS expression at %C is not a \"\n+      gfc_error (\"%qs in EXTENDS expression at %C is not a \"\n \t\t \"derived type\", name);\n       return NULL;\n     }\n \n   if (extended->attr.is_bind_c)\n     {\n-      gfc_error (\"'%s' cannot be extended at %C because it \"\n+      gfc_error (\"%qs cannot be extended at %C because it \"\n \t\t \"is BIND(C)\", extended->name);\n       return NULL;\n     }\n \n   if (extended->attr.sequence)\n     {\n-      gfc_error (\"'%s' cannot be extended at %C because it \"\n+      gfc_error (\"%qs cannot be extended at %C because it \"\n \t\t \"is a SEQUENCE type\", extended->name);\n       return NULL;\n     }\n@@ -7682,7 +7682,7 @@ gfc_match_derived_decl (void)\n   /* Make sure the name is not the name of an intrinsic type.  */\n   if (gfc_is_intrinsic_typename (name))\n     {\n-      gfc_error (\"Type name '%s' at %C cannot be the same as an intrinsic \"\n+      gfc_error (\"Type name %qs at %C cannot be the same as an intrinsic \"\n \t\t \"type\", name);\n       return MATCH_ERROR;\n     }\n@@ -7692,7 +7692,7 @@ gfc_match_derived_decl (void)\n \n   if (!gensym->attr.generic && gensym->ts.type != BT_UNKNOWN)\n     {\n-      gfc_error (\"Derived type name '%s' at %C already has a basic type \"\n+      gfc_error (\"Derived type name %qs at %C already has a basic type \"\n \t\t \"of %s\", gensym->name, gfc_typename (&gensym->ts));\n       return MATCH_ERROR;\n     }\n@@ -7709,7 +7709,7 @@ gfc_match_derived_decl (void)\n \n   if (sym && (sym->components != NULL || sym->attr.zero_comp))\n     {\n-      gfc_error (\"Derived type definition of '%s' at %C has already been \"\n+      gfc_error (\"Derived type definition of %qs at %C has already been \"\n                  \"defined\", sym->name);\n       return MATCH_ERROR;\n     }\n@@ -7780,7 +7780,7 @@ gfc_match_derived_decl (void)\n \t{\n \t  /* Since the extension field is 8 bit wide, we can only have\n \t     up to 255 extension levels.  */\n-\t  gfc_error (\"Maximum extension level reached with type '%s' at %L\",\n+\t  gfc_error (\"Maximum extension level reached with type %qs at %L\",\n \t\t     extended->name, &extended->declared_at);\n \t  return MATCH_ERROR;\n \t}\n@@ -8375,7 +8375,7 @@ match_procedure_in_type (void)\n       /* If the binding is DEFERRED, check that the containing type is ABSTRACT.  */\n       if (tb.deferred && !block->attr.abstract)\n \t{\n-\t  gfc_error (\"Type '%s' containing DEFERRED binding at %C \"\n+\t  gfc_error (\"Type %qs containing DEFERRED binding at %C \"\n \t\t     \"is not ABSTRACT\", block->name);\n \t  return MATCH_ERROR;\n \t}\n@@ -8386,8 +8386,8 @@ match_procedure_in_type (void)\n       stree = gfc_find_symtree (ns->tb_sym_root, name);\n       if (stree && stree->n.tb)\n \t{\n-\t  gfc_error (\"There is already a procedure with binding name '%s' for \"\n-\t\t     \"the derived type '%s' at %C\", name, block->name);\n+\t  gfc_error (\"There is already a procedure with binding name %qs for \"\n+\t\t     \"the derived type %qs at %C\", name, block->name);\n \t  return MATCH_ERROR;\n \t}\n \n@@ -8536,15 +8536,15 @@ gfc_match_generic (void)\n \t{\n \t  gcc_assert (op_type == INTERFACE_GENERIC);\n \t  gfc_error (\"There's already a non-generic procedure with binding name\"\n-\t\t     \" '%s' for the derived type '%s' at %C\",\n+\t\t     \" %qs for the derived type %qs at %C\",\n \t\t     bind_name, block->name);\n \t  goto error;\n \t}\n \n       if (tb->access != tbattr.access)\n \t{\n \t  gfc_error (\"Binding at %C must have the same access as already\"\n-\t\t     \" defined binding '%s'\", bind_name);\n+\t\t     \" defined binding %qs\", bind_name);\n \t  goto error;\n \t}\n     }\n@@ -8602,8 +8602,8 @@ gfc_match_generic (void)\n       for (target = tb->u.generic; target; target = target->next)\n \tif (target_st == target->specific_st)\n \t  {\n-\t    gfc_error (\"'%s' already defined as specific binding for the\"\n-\t\t       \" generic '%s' at %C\", name, bind_name);\n+\t    gfc_error (\"%qs already defined as specific binding for the\"\n+\t\t       \" generic %qs at %C\", name, bind_name);\n \t    goto error;\n \t  }\n \n@@ -8711,7 +8711,7 @@ gfc_match_final_decl (void)\n \n       if (gfc_get_symbol (name, module_ns, &sym))\n \t{\n-\t  gfc_error (\"Unknown procedure name \\\"%s\\\" at %C\", name);\n+\t  gfc_error (\"Unknown procedure name %qs at %C\", name);\n \t  return MATCH_ERROR;\n \t}\n \n@@ -8724,7 +8724,7 @@ gfc_match_final_decl (void)\n       for (f = block->f2k_derived->finalizers; f; f = f->next)\n \tif (f->proc_sym == sym)\n \t  {\n-\t    gfc_error (\"'%s' at %C is already defined as FINAL procedure!\",\n+\t    gfc_error (\"%qs at %C is already defined as FINAL procedure!\",\n \t\t       name);\n \t    return MATCH_ERROR;\n \t  }"}, {"sha": "f7a6a6b243cf682847c5025c39994e95de99e7fc", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 128, "deletions": 23, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -34,6 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-color.h\"\n #include \"tree-diagnostic.h\" /* tree_diagnostics_defaults */\n \n+#include <new> /* For placement-new */\n+\n static int suppress_errors = 0;\n \n static bool warnings_not_errors = false;\n@@ -44,13 +46,18 @@ static gfc_error_buf error_buffer, warning_buffer, *cur_error_buffer;\n \n /* True if the error/warnings should be buffered.  */\n static bool buffered_p;\n-\n /* These are always buffered buffers (.flush_p == false) to be used by\n    the pretty-printer.  */\n-static output_buffer pp_warning_buffer;\n+static output_buffer *pp_error_buffer, *pp_warning_buffer;\n static int warningcount_buffered, werrorcount_buffered;\n \n-#include <new> /* For placement-new */\n+/* Return true if there output_buffer is empty.  */\n+\n+static bool\n+gfc_output_buffer_empty_p (const output_buffer * buf)\n+{\n+  return output_buffer_last_position_in_text (buf) == NULL;\n+}\n \n /* Go one level deeper suppressing errors.  */\n \n@@ -99,7 +106,6 @@ void\n gfc_buffer_error (bool flag)\n {\n   buffered_p = flag;\n-  pp_warning_buffer.flush_p = !flag;\n }\n \n \n@@ -843,11 +849,11 @@ gfc_warning (int opt, const char *gmsgid, va_list ap)\n   pretty_printer *pp = global_dc->printer;\n   output_buffer *tmp_buffer = pp->buffer;\n \n-  gfc_clear_pp_buffer (&pp_warning_buffer);\n+  gfc_clear_pp_buffer (pp_warning_buffer);\n \n   if (buffered_p)\n     {\n-      pp->buffer = &pp_warning_buffer;\n+      pp->buffer = pp_warning_buffer;\n       global_dc->fatal_errors = false;\n       /* To prevent -fmax-errors= triggering.  */\n       --werrorcount;\n@@ -1248,10 +1254,9 @@ gfc_clear_warning (void)\n {\n   warning_buffer.flag = 0;\n \n-  gfc_clear_pp_buffer (&pp_warning_buffer);\n+  gfc_clear_pp_buffer (pp_warning_buffer);\n   warningcount_buffered = 0;\n   werrorcount_buffered = 0;\n-  pp_warning_buffer.flush_p = false;\n }\n \n \n@@ -1266,29 +1271,32 @@ gfc_warning_check (void)\n       warnings++;\n       if (warning_buffer.message != NULL)\n \tfputs (warning_buffer.message, stderr);\n-      warning_buffer.flag = 0;\n+      gfc_clear_warning ();\n     }\n-\n   /* This is for the new diagnostics machinery.  */\n-  pretty_printer *pp = global_dc->printer;\n-  output_buffer *tmp_buffer = pp->buffer;\n-  pp->buffer = &pp_warning_buffer;\n-  if (pp_last_position_in_text (pp) != NULL)\n+  else if (! gfc_output_buffer_empty_p (pp_warning_buffer))\n     {\n+      pretty_printer *pp = global_dc->printer;\n+      output_buffer *tmp_buffer = pp->buffer;\n+      pp->buffer = pp_warning_buffer;\n       pp_really_flush (pp);\n-      pp_warning_buffer.flush_p = true;\n       warningcount += warningcount_buffered;\n       werrorcount += werrorcount_buffered;\n+      gcc_assert (warningcount_buffered + werrorcount_buffered == 1);\n+      diagnostic_action_after_output (global_dc, \n+\t\t\t\t      warningcount_buffered \n+\t\t\t\t      ? DK_WARNING : DK_ERROR);\n+      pp->buffer = tmp_buffer;\n     }\n-\n-  pp->buffer = tmp_buffer;\n }\n \n \n /* Issue an error.  */\n+/* Use gfc_error instead, unless two locations are used in the same\n+   warning or for scanner.c, if the location is not properly set up.  */\n \n void\n-gfc_error (const char *gmsgid, ...)\n+gfc_error_1 (const char *gmsgid, ...)\n {\n   va_list argp;\n \n@@ -1336,6 +1344,59 @@ gfc_error (const char *gmsgid, ...)\n   }\n }\n \n+/* Issue an error.  */\n+/* This function uses the common diagnostics, but does not support\n+   two locations; when being used in scanner.c, ensure that the location\n+   is properly setup. Otherwise, use gfc_error_1.   */\n+\n+void\n+gfc_error (const char *gmsgid, ...)\n+{\n+  va_list argp;\n+  va_start (argp, gmsgid);\n+\n+  if (warnings_not_errors)\n+    {\n+      gfc_warning (/*opt=*/0, gmsgid, argp);\n+      va_end (argp);\n+      return;\n+    }\n+\n+  if (suppress_errors)\n+    {\n+      va_end (argp);\n+      return;\n+    }\n+\n+  diagnostic_info diagnostic;\n+  bool fatal_errors = global_dc->fatal_errors;\n+  pretty_printer *pp = global_dc->printer;\n+  output_buffer *tmp_buffer = pp->buffer;\n+\n+  gfc_clear_pp_buffer (pp_error_buffer);\n+\n+  if (buffered_p)\n+    {\n+      pp->buffer = pp_error_buffer;\n+      global_dc->fatal_errors = false;\n+      /* To prevent -fmax-errors= triggering, we decrease it before\n+\t report_diagnostic increases it.  */\n+      --errorcount; \n+    }\n+\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_ERROR);\n+  report_diagnostic (&diagnostic);\n+\n+  if (buffered_p)\n+    {\n+      pp->buffer = tmp_buffer;\n+      global_dc->fatal_errors = fatal_errors;\n+    }\n+  \n+  va_end (argp);\n+}\n+\n+\n \n /* Immediate error.  */\n /* Use gfc_error_now instead, unless two locations are used in the same\n@@ -1393,6 +1454,7 @@ gfc_clear_error (void)\n {\n   error_buffer.flag = 0;\n   warnings_not_errors = false;\n+  gfc_clear_pp_buffer (pp_error_buffer);\n }\n \n \n@@ -1401,7 +1463,8 @@ gfc_clear_error (void)\n bool\n gfc_error_flag_test (void)\n {\n-  return error_buffer.flag;\n+  return error_buffer.flag \n+    || !gfc_output_buffer_empty_p (pp_error_buffer);\n }\n \n \n@@ -1418,34 +1481,69 @@ gfc_error_check (void)\n       if (error_buffer.message != NULL)\n \tfputs (error_buffer.message, stderr);\n       error_buffer.flag = 0;\n+      gfc_clear_pp_buffer (pp_error_buffer);\n \n       gfc_increment_error_count();\n \n       if (flag_fatal_errors)\n \texit (FATAL_EXIT_CODE);\n     }\n+  /* This is for the new diagnostics machinery.  */\n+  else if (! gfc_output_buffer_empty_p (pp_error_buffer))\n+    {\n+      error_raised = true;\n+      pretty_printer *pp = global_dc->printer;\n+      output_buffer *tmp_buffer = pp->buffer;\n+      pp->buffer = pp_error_buffer;\n+      pp_really_flush (pp);\n+      ++errorcount;\n+      gcc_assert (gfc_output_buffer_empty_p (pp_error_buffer));\n+      diagnostic_action_after_output (global_dc, DK_ERROR);\n+      pp->buffer = tmp_buffer;\n+    }\n \n   return error_raised;\n }\n \n+/* Move the text buffered from FROM to TO, then clear\n+   FROM. Independently if there was text in FROM, TO is also\n+   cleared. */\n+\n+static void\n+gfc_move_output_buffer_from_to (output_buffer *from, output_buffer *to)\n+{\n+  gfc_clear_pp_buffer (to);\n+  /* We make sure this is always buffered.  */\n+  to->flush_p = false;\n+\n+  if (! gfc_output_buffer_empty_p (from))\n+    {\n+      const char *str = output_buffer_formatted_text (from);\n+      output_buffer_append_r (to, str, strlen (str));\n+      gfc_clear_pp_buffer (from);\n+    }\n+}\n \n /* Save the existing error state.  */\n \n void\n-gfc_push_error (gfc_error_buf *err)\n+gfc_push_error (output_buffer *buffer_err, gfc_error_buf *err)\n {\n   err->flag = error_buffer.flag;\n   if (error_buffer.flag)\n     err->message = xstrdup (error_buffer.message);\n \n   error_buffer.flag = 0;\n+\n+  /* This part uses the common diagnostics.  */\n+  gfc_move_output_buffer_from_to (pp_error_buffer, buffer_err);\n }\n \n \n /* Restore a previous pushed error state.  */\n \n void\n-gfc_pop_error (gfc_error_buf *err)\n+gfc_pop_error (output_buffer *buffer_err, gfc_error_buf *err)\n {\n   error_buffer.flag = err->flag;\n   if (error_buffer.flag)\n@@ -1455,16 +1553,20 @@ gfc_pop_error (gfc_error_buf *err)\n       memcpy (error_buffer.message, err->message, len);\n       free (err->message);\n     }\n+  /* This part uses the common diagnostics.  */\n+  gfc_move_output_buffer_from_to (buffer_err, pp_error_buffer);\n }\n \n \n /* Free a pushed error state, but keep the current error state.  */\n \n void\n-gfc_free_error (gfc_error_buf *err)\n+gfc_free_error (output_buffer *buffer_err, gfc_error_buf *err)\n {\n   if (err->flag)\n     free (err->message);\n+\n+  gfc_clear_pp_buffer (buffer_err);\n }\n \n \n@@ -1495,7 +1597,10 @@ gfc_diagnostics_init (void)\n   diagnostic_finalizer (global_dc) = gfc_diagnostic_finalizer;\n   diagnostic_format_decoder (global_dc) = gfc_format_decoder;\n   global_dc->caret_char = '^';\n-  new (&pp_warning_buffer) output_buffer ();\n+  pp_warning_buffer = new (XNEW (output_buffer)) output_buffer ();\n+  pp_warning_buffer->flush_p = false;\n+  pp_error_buffer = new (XNEW (output_buffer)) output_buffer ();\n+  pp_error_buffer->flush_p = false;\n }\n \n void"}, {"sha": "bfe83560a07f1531fc933183d04cf41bdd57aad9", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -2204,9 +2204,9 @@ check_alloc_comp_init (gfc_expr *e)\n       if (comp->attr.allocatable\n           && ctor->expr->expr_type != EXPR_NULL)\n         {\n-\t  gfc_error(\"Invalid initialization expression for ALLOCATABLE \"\n-\t            \"component '%s' in structure constructor at %L\",\n-\t            comp->name, &ctor->expr->where);\n+\t  gfc_error (\"Invalid initialization expression for ALLOCATABLE \"\n+\t\t     \"component %qs in structure constructor at %L\",\n+\t\t     comp->name, &ctor->expr->where);\n \t  return false;\n \t}\n     }\n@@ -2315,7 +2315,7 @@ check_inquiry (gfc_expr *e, int not_restricted)\n \t    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL\n \t\t|| ap->expr->symtree->n.sym->ts.deferred))\n \t  {\n-\t    gfc_error (\"Assumed or deferred character length variable '%s' \"\n+\t    gfc_error (\"Assumed or deferred character length variable %qs \"\n \t\t\t\" in constant expression at %L\",\n \t\t\tap->expr->symtree->n.sym->name,\n \t\t\t&ap->expr->where);\n@@ -2381,8 +2381,8 @@ check_transformational (gfc_expr *e)\n \n   if (functions[i] == NULL)\n     {\n-      gfc_error(\"transformational intrinsic '%s' at %L is not permitted \"\n-\t\t\"in an initialization expression\", name, &e->where);\n+      gfc_error (\"transformational intrinsic %qs at %L is not permitted \"\n+\t\t \"in an initialization expression\", name, &e->where);\n       return MATCH_ERROR;\n     }\n \n@@ -2481,7 +2481,7 @@ gfc_check_init_expr (gfc_expr *e)\n \tif (!gfc_is_intrinsic (sym, 0, e->where)\n \t    || (m = gfc_intrinsic_func_interface (e, 0)) != MATCH_YES)\n \t  {\n-\t    gfc_error (\"Function '%s' in initialization expression at %L \"\n+\t    gfc_error (\"Function %qs in initialization expression at %L \"\n \t\t       \"must be an intrinsic function\",\n \t\t       e->symtree->n.sym->name, &e->where);\n \t    break;\n@@ -2493,7 +2493,7 @@ gfc_check_init_expr (gfc_expr *e)\n \t    && (m = check_transformational (e)) == MATCH_NO\n \t    && (m = check_elemental (e)) == MATCH_NO)\n \t  {\n-\t    gfc_error (\"Intrinsic function '%s' at %L is not permitted \"\n+\t    gfc_error (\"Intrinsic function %qs at %L is not permitted \"\n \t\t       \"in an initialization expression\",\n \t\t       e->symtree->n.sym->name, &e->where);\n \t    m = MATCH_ERROR;\n@@ -2528,8 +2528,8 @@ gfc_check_init_expr (gfc_expr *e)\n \t     is invalid.  */\n \t  if (!e->symtree->n.sym->value)\n \t    {\n-\t      gfc_error(\"PARAMETER '%s' is used at %L before its definition \"\n-\t\t\t\"is complete\", e->symtree->n.sym->name, &e->where);\n+\t      gfc_error (\"PARAMETER %qs is used at %L before its definition \"\n+\t\t\t \"is complete\", e->symtree->n.sym->name, &e->where);\n \t      t = false;\n \t    }\n \t  else\n@@ -2548,25 +2548,25 @@ gfc_check_init_expr (gfc_expr *e)\n \t  switch (e->symtree->n.sym->as->type)\n \t    {\n \t      case AS_ASSUMED_SIZE:\n-\t\tgfc_error (\"Assumed size array '%s' at %L is not permitted \"\n+\t\tgfc_error (\"Assumed size array %qs at %L is not permitted \"\n \t\t\t   \"in an initialization expression\",\n \t\t\t   e->symtree->n.sym->name, &e->where);\n \t\tbreak;\n \n \t      case AS_ASSUMED_SHAPE:\n-\t\tgfc_error (\"Assumed shape array '%s' at %L is not permitted \"\n+\t\tgfc_error (\"Assumed shape array %qs at %L is not permitted \"\n \t\t\t   \"in an initialization expression\",\n \t\t\t   e->symtree->n.sym->name, &e->where);\n \t\tbreak;\n \n \t      case AS_DEFERRED:\n-\t\tgfc_error (\"Deferred array '%s' at %L is not permitted \"\n+\t\tgfc_error (\"Deferred array %qs at %L is not permitted \"\n \t\t\t   \"in an initialization expression\",\n \t\t\t   e->symtree->n.sym->name, &e->where);\n \t\tbreak;\n \n \t      case AS_EXPLICIT:\n-\t\tgfc_error (\"Array '%s' at %L is a variable, which does \"\n+\t\tgfc_error (\"Array %qs at %L is a variable, which does \"\n \t\t\t   \"not reduce to a constant expression\",\n \t\t\t   e->symtree->n.sym->name, &e->where);\n \t\tbreak;\n@@ -2576,7 +2576,7 @@ gfc_check_init_expr (gfc_expr *e)\n \t  }\n \t}\n       else\n-\tgfc_error (\"Parameter '%s' at %L has not been declared or is \"\n+\tgfc_error (\"Parameter %qs at %L has not been declared or is \"\n \t\t   \"a variable, which does not reduce to a constant \"\n \t\t   \"expression\", e->symtree->n.sym->name, &e->where);\n \n@@ -2729,28 +2729,28 @@ external_spec_function (gfc_expr *e)\n \n   if (f->attr.proc == PROC_ST_FUNCTION)\n     {\n-      gfc_error (\"Specification function '%s' at %L cannot be a statement \"\n+      gfc_error (\"Specification function %qs at %L cannot be a statement \"\n \t\t \"function\", f->name, &e->where);\n       return false;\n     }\n \n   if (f->attr.proc == PROC_INTERNAL)\n     {\n-      gfc_error (\"Specification function '%s' at %L cannot be an internal \"\n+      gfc_error (\"Specification function %qs at %L cannot be an internal \"\n \t\t \"function\", f->name, &e->where);\n       return false;\n     }\n \n   if (!f->attr.pure && !f->attr.elemental)\n     {\n-      gfc_error (\"Specification function '%s' at %L must be PURE\", f->name,\n+      gfc_error (\"Specification function %qs at %L must be PURE\", f->name,\n \t\t &e->where);\n       return false;\n     }\n \n   if (f->attr.recursive)\n     {\n-      gfc_error (\"Specification function '%s' at %L cannot be RECURSIVE\",\n+      gfc_error (\"Specification function %qs at %L cannot be RECURSIVE\",\n \t\t f->name, &e->where);\n       return false;\n     }\n@@ -2884,21 +2884,21 @@ check_restricted (gfc_expr *e)\n       if (sym->attr.dummy && sym->ns == gfc_current_ns\n \t  && sym->ns->proc_name && sym->ns->proc_name->attr.elemental)\n \t{\n-\t  gfc_error (\"Dummy argument '%s' not allowed in expression at %L\",\n+\t  gfc_error (\"Dummy argument %qs not allowed in expression at %L\",\n \t\t     sym->name, &e->where);\n \t  break;\n \t}\n \n       if (sym->attr.optional)\n \t{\n-\t  gfc_error (\"Dummy argument '%s' at %L cannot be OPTIONAL\",\n+\t  gfc_error (\"Dummy argument %qs at %L cannot be OPTIONAL\",\n \t\t     sym->name, &e->where);\n \t  break;\n \t}\n \n       if (sym->attr.intent == INTENT_OUT)\n \t{\n-\t  gfc_error (\"Dummy argument '%s' at %L cannot be INTENT(OUT)\",\n+\t  gfc_error (\"Dummy argument %qs at %L cannot be INTENT(OUT)\",\n \t\t     sym->name, &e->where);\n \t  break;\n \t}\n@@ -2929,7 +2929,7 @@ check_restricted (gfc_expr *e)\n \t  break;\n \t}\n \n-      gfc_error (\"Variable '%s' cannot appear in the expression at %L\",\n+      gfc_error (\"Variable %qs cannot appear in the expression at %L\",\n \t\t sym->name, &e->where);\n       /* Prevent a repetition of the error.  */\n       e->error = 1;\n@@ -2992,7 +2992,7 @@ gfc_specification_expr (gfc_expr *e)\n       && !gfc_pure (e->symtree->n.sym)\n       && (!comp || !comp->attr.pure))\n     {\n-      gfc_error (\"Function '%s' at %L must be PURE\",\n+      gfc_error (\"Function %qs at %L must be PURE\",\n \t\t e->symtree->n.sym->name, &e->where);\n       /* Prevent repeat error messages.  */\n       e->symtree->n.sym->attr.pure = 1;\n@@ -3138,7 +3138,7 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \n       if (bad_proc)\n \t{\n-\t  gfc_error (\"'%s' at %L is not a VALUE\", sym->name, &lvalue->where);\n+\t  gfc_error (\"%qs at %L is not a VALUE\", sym->name, &lvalue->where);\n \t  return false;\n \t}\n     }\n@@ -3331,7 +3331,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   if (lhs_attr.flavor == FL_PROCEDURE && lhs_attr.use_assoc\n       && !lhs_attr.proc_pointer)\n     {\n-      gfc_error (\"'%s' in the pointer assignment at %L cannot be an \"\n+      gfc_error (\"%qs in the pointer assignment at %L cannot be an \"\n \t\t \"l-value since it is a procedure\",\n \t\t lvalue->symtree->n.sym->name, &lvalue->where);\n       return false;\n@@ -3354,7 +3354,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \n \t  if (ref->u.ar.type != AR_SECTION)\n \t    {\n-\t      gfc_error (\"Expected bounds specification for '%s' at %L\",\n+\t      gfc_error (\"Expected bounds specification for %qs at %L\",\n \t\t\t lvalue->symtree->n.sym->name, &lvalue->where);\n \t      return false;\n \t    }\n@@ -3461,7 +3461,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      for (ns = gfc_current_ns; ns; ns = ns->parent)\n \t\tif (sym == ns->proc_name)\n \t\t  {\n-\t\t    gfc_error (\"Function result '%s' is invalid as proc-target \"\n+\t\t    gfc_error (\"Function result %qs is invalid as proc-target \"\n \t\t\t       \"in procedure pointer assignment at %L\",\n \t\t\t       sym->name, &rvalue->where);\n \t\t    return false;\n@@ -3470,7 +3470,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t}\n       if (attr.abstract)\n \t{\n-\t  gfc_error (\"Abstract interface '%s' is invalid \"\n+\t  gfc_error (\"Abstract interface %qs is invalid \"\n \t\t     \"in procedure pointer assignment at %L\",\n \t\t     rvalue->symtree->name, &rvalue->where);\n \t  return false;\n@@ -3480,7 +3480,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t{\n \t  if (attr.proc == PROC_ST_FUNCTION)\n \t    {\n-\t      gfc_error (\"Statement function '%s' is invalid \"\n+\t      gfc_error (\"Statement function %qs is invalid \"\n \t\t\t \"in procedure pointer assignment at %L\",\n \t\t\t rvalue->symtree->name, &rvalue->where);\n \t      return false;\n@@ -3493,15 +3493,15 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t  if (attr.intrinsic && gfc_intrinsic_actual_ok (rvalue->symtree->name,\n \t\t\t\t\t\t\t attr.subroutine) == 0)\n \t    {\n-\t      gfc_error (\"Intrinsic '%s' at %L is invalid in procedure pointer \"\n+\t      gfc_error (\"Intrinsic %qs at %L is invalid in procedure pointer \"\n \t\t\t \"assignment\", rvalue->symtree->name, &rvalue->where);\n \t      return false;\n \t    }\n \t}\n       /* Check for F08:C730.  */\n       if (attr.elemental && !attr.intrinsic)\n \t{\n-\t  gfc_error (\"Nonintrinsic elemental procedure '%s' is invalid \"\n+\t  gfc_error (\"Nonintrinsic elemental procedure %qs is invalid \"\n \t\t     \"in procedure pointer assignment at %L\",\n \t\t     rvalue->symtree->name, &rvalue->where);\n \t  return false;\n@@ -3580,14 +3580,14 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       if (s1->attr.if_source == IFSRC_UNKNOWN\n \t  && gfc_explicit_interface_required (s2, err, sizeof(err)))\n \t{\n-\t  gfc_error (\"Explicit interface required for '%s' at %L: %s\",\n+\t  gfc_error (\"Explicit interface required for %qs at %L: %s\",\n \t\t     s1->name, &lvalue->where, err);\n \t  return false;\n \t}\n       if (s2->attr.if_source == IFSRC_UNKNOWN\n \t  && gfc_explicit_interface_required (s1, err, sizeof(err)))\n \t{\n-\t  gfc_error (\"Explicit interface required for '%s' at %L: %s\",\n+\t  gfc_error (\"Explicit interface required for %qs at %L: %s\",\n \t\t     s2->name, &rvalue->where, err);\n \t  return false;\n \t}\n@@ -3604,7 +3604,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       if (!s2->attr.intrinsic && s2->attr.if_source == IFSRC_UNKNOWN\n \t  && !s2->attr.external && !s2->attr.subroutine && !s2->attr.function)\n \t{\n-\t  gfc_error (\"Procedure pointer target '%s' at %L must be either an \"\n+\t  gfc_error (\"Procedure pointer target %qs at %L must be either an \"\n \t\t     \"intrinsic, host or use associated, referenced or have \"\n \t\t     \"the EXTERNAL attribute\", s2->name, &rvalue->where);\n \t  return false;\n@@ -4758,7 +4758,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n   if (!pointer && sym->attr.flavor == FL_PARAMETER)\n     {\n       if (context)\n-\tgfc_error (\"Named constant '%s' in variable definition context (%s)\"\n+\tgfc_error (\"Named constant %qs in variable definition context (%s)\"\n \t\t   \" at %L\", sym->name, context, &e->where);\n       return false;\n     }\n@@ -4767,7 +4767,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.proc_pointer))\n     {\n       if (context)\n-\tgfc_error (\"'%s' in variable definition context (%s) at %L is not\"\n+\tgfc_error (\"%qs in variable definition context (%s) at %L is not\"\n \t\t   \" a variable\", sym->name, context, &e->where);\n       return false;\n     }\n@@ -4820,15 +4820,15 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (pointer && is_pointer)\n \t{\n \t  if (context)\n-\t    gfc_error (\"Dummy argument '%s' with INTENT(IN) in pointer\"\n+\t    gfc_error (\"Dummy argument %qs with INTENT(IN) in pointer\"\n \t\t       \" association context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n \t  return false;\n \t}\n       if (!pointer && !is_pointer && !sym->attr.pointer)\n \t{\n \t  if (context)\n-\t    gfc_error (\"Dummy argument '%s' with INTENT(IN) in variable\"\n+\t    gfc_error (\"Dummy argument %qs with INTENT(IN) in variable\"\n \t\t       \" definition context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n \t  return false;\n@@ -4841,15 +4841,15 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (pointer && is_pointer)\n \t{\n \t  if (context)\n-\t    gfc_error (\"Variable '%s' is PROTECTED and can not appear in a\"\n+\t    gfc_error (\"Variable %qs is PROTECTED and can not appear in a\"\n \t\t       \" pointer association context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n \t  return false;\n \t}\n       if (!pointer && !is_pointer)\n \t{\n \t  if (context)\n-\t    gfc_error (\"Variable '%s' is PROTECTED and can not appear in a\"\n+\t    gfc_error (\"Variable %qs is PROTECTED and can not appear in a\"\n \t\t       \" variable definition context (%s) at %L\",\n \t\t       sym->name, context, &e->where);\n \t  return false;\n@@ -4861,7 +4861,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n   if (!pointer && !own_scope && gfc_pure (NULL) && gfc_impure_variable (sym))\n     {\n       if (context)\n-\tgfc_error (\"Variable '%s' can not appear in a variable definition\"\n+\tgfc_error (\"Variable %qs can not appear in a variable definition\"\n \t\t   \" context (%s) at %L in PURE procedure\",\n \t\t   sym->name, context, &e->where);\n       return false;\n@@ -4920,11 +4920,11 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t  if (context)\n \t    {\n \t      if (assoc->target->expr_type == EXPR_VARIABLE)\n-\t\tgfc_error (\"'%s' at %L associated to vector-indexed target can\"\n+\t\tgfc_error (\"%qs at %L associated to vector-indexed target can\"\n \t\t\t   \" not be used in a variable definition context (%s)\",\n \t\t\t   name, &e->where, context);\n \t      else\n-\t\tgfc_error (\"'%s' at %L associated to expression can\"\n+\t\tgfc_error (\"%qs at %L associated to expression can\"\n \t\t\t   \" not be used in a variable definition context (%s)\",\n \t\t\t   name, &e->where, context);\n \t    }\n@@ -4935,7 +4935,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (!gfc_check_vardef_context (assoc->target, pointer, false, false, NULL))\n \t{\n \t  if (context)\n-\t    gfc_error (\"Associate-name '%s' can not appear in a variable\"\n+\t    gfc_error_1 (\"Associate-name '%s' can not appear in a variable\"\n \t\t       \" definition context (%s) at %L because its target\"\n \t\t       \" at %L can not, either\",\n \t\t       name, context, &e->where,"}, {"sha": "9d96b85fbd3e2a9d787c65ef46c1f7ba1990e056", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -2682,6 +2682,7 @@ bool gfc_warning_now (int opt, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n void gfc_clear_warning (void);\n void gfc_warning_check (void);\n \n+void gfc_error_1 (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_error (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_error_now_1 (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_error_now (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n@@ -2698,9 +2699,10 @@ bool gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n #define gfc_syntax_error(ST)\t\\\n   gfc_error (\"Syntax error in %s statement at %C\", gfc_ascii_statement (ST));\n \n-void gfc_push_error (gfc_error_buf *);\n-void gfc_pop_error (gfc_error_buf *);\n-void gfc_free_error (gfc_error_buf *);\n+#include \"pretty-print.h\" /* For output_buffer.  */\n+void gfc_push_error (output_buffer *, gfc_error_buf *);\n+void gfc_pop_error (output_buffer *, gfc_error_buf *);\n+void gfc_free_error (output_buffer *, gfc_error_buf *);\n \n void gfc_get_errors (int *, int *);\n void gfc_errors_to_warnings (bool);"}, {"sha": "5f6ed834c0576aba1288db488d3fd5bf7720ee32", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -219,7 +219,7 @@ gfc_match_interface (void)\n \n       if (sym->attr.dummy)\n \t{\n-\t  gfc_error (\"Dummy procedure '%s' at %C cannot have a \"\n+\t  gfc_error (\"Dummy procedure %qs at %C cannot have a \"\n \t\t     \"generic interface\", sym->name);\n \t  return MATCH_ERROR;\n \t}\n@@ -1561,10 +1561,10 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \t  && p->sym->attr.flavor != FL_DERIVED)\n \t{\n \t  if (p->sym->attr.external)\n-\t    gfc_error (\"Procedure '%s' in %s at %L has no explicit interface\",\n+\t    gfc_error (\"Procedure %qs in %s at %L has no explicit interface\",\n \t\t       p->sym->name, interface_name, &p->sym->declared_at);\n \t  else\n-\t    gfc_error (\"Procedure '%s' in %s at %L is neither function nor \"\n+\t    gfc_error (\"Procedure %qs in %s at %L is neither function nor \"\n \t\t       \"subroutine\", p->sym->name, interface_name,\n \t\t      &p->sym->declared_at);\n \t  return 1;\n@@ -1645,7 +1645,7 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \t\t\t\t       generic_flag, 0, NULL, 0, NULL, NULL))\n \t  {\n \t    if (referenced)\n-\t      gfc_error (\"Ambiguous interfaces '%s' and '%s' in %s at %L\",\n+\t      gfc_error (\"Ambiguous interfaces %qs and %qs in %s at %L\",\n \t\t\t p->sym->name, q->sym->name, interface_name,\n \t\t\t &p->where);\n \t    else if (!p->sym->attr.use_assoc && q->sym->attr.use_assoc)\n@@ -1687,7 +1687,7 @@ check_sym_interfaces (gfc_symbol *sym)\n \t      && (p->sym->attr.if_source != IFSRC_DECL\n \t\t  || p->sym->attr.procedure))\n \t    {\n-\t      gfc_error (\"'%s' at %L is not a module procedure\",\n+\t      gfc_error (\"%qs at %L is not a module procedure\",\n \t\t\t p->sym->name, &p->where);\n \t      return;\n \t    }\n@@ -1892,21 +1892,21 @@ argument_rank_mismatch (const char *name, locus *where,\n   if (rank2 == -1)\n     {\n       gfc_error (\"The assumed-rank array at %L requires that the dummy argument\"\n-\t\t \" '%s' has assumed-rank\", where, name);\n+\t\t \" %qs has assumed-rank\", where, name);\n     }\n   else if (rank1 == 0)\n     {\n-      gfc_error (\"Rank mismatch in argument '%s' at %L \"\n+      gfc_error (\"Rank mismatch in argument %qs at %L \"\n \t\t \"(scalar and rank-%d)\", name, where, rank2);\n     }\n   else if (rank2 == 0)\n     {\n-      gfc_error (\"Rank mismatch in argument '%s' at %L \"\n+      gfc_error (\"Rank mismatch in argument %qs at %L \"\n \t\t \"(rank-%d and scalar)\", name, where, rank1);\n     }\n   else\n     {\n-      gfc_error (\"Rank mismatch in argument '%s' at %L \"\n+      gfc_error (\"Rank mismatch in argument %qs at %L \"\n \t\t \"(rank-%d and rank-%d)\", name, where, rank1, rank2);\n     }\n }\n@@ -1956,7 +1956,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t\t\t   sizeof(err), NULL, NULL))\n \t{\n \t  if (where)\n-\t    gfc_error (\"Interface mismatch in dummy procedure '%s' at %L: %s\",\n+\t    gfc_error (\"Interface mismatch in dummy procedure %qs at %L: %s\",\n \t\t       formal->name, &actual->where, err);\n \t  return 0;\n \t}\n@@ -1981,7 +1981,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       && !gfc_is_simply_contiguous (actual, true))\n     {\n       if (where)\n-\tgfc_error (\"Actual argument to contiguous pointer dummy '%s' at %L \"\n+\tgfc_error (\"Actual argument to contiguous pointer dummy %qs at %L \"\n \t\t   \"must be simply contiguous\", formal->name, &actual->where);\n       return 0;\n     }\n@@ -1996,7 +1996,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t\t\t\t CLASS_DATA (actual)->ts.u.derived)))\n     {\n       if (where)\n-\tgfc_error (\"Type mismatch in argument '%s' at %L; passed %s to %s\",\n+\tgfc_error (\"Type mismatch in argument %qs at %L; passed %s to %s\",\n \t\t   formal->name, &actual->where, gfc_typename (&actual->ts),\n \t\t   gfc_typename (&formal->ts));\n       return 0;\n@@ -2006,7 +2006,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n     {\n       if (where)\n \tgfc_error (\"Assumed-type actual argument at %L requires that dummy \"\n-\t\t   \"argument '%s' is of assumed type\", &actual->where,\n+\t\t   \"argument %qs is of assumed type\", &actual->where,\n \t\t   formal->name);\n       return 0;\n     }\n@@ -2021,7 +2021,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       if (actual->ts.type != BT_CLASS)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument to '%s' at %L must be polymorphic\",\n+\t    gfc_error (\"Actual argument to %qs at %L must be polymorphic\",\n \t\t\tformal->name, &actual->where);\n \t  return 0;\n \t}\n@@ -2034,7 +2034,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t\t\t\t CLASS_DATA (formal)->ts.u.derived))\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument to '%s' at %L must have the same \"\n+\t    gfc_error (\"Actual argument to %qs at %L must have the same \"\n \t\t       \"declared type\", formal->name, &actual->where);\n \t  return 0;\n \t}\n@@ -2049,7 +2049,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  ||CLASS_DATA (formal)->attr.class_pointer))\n     {\n       if (where)\n-\tgfc_error (\"Actual argument to '%s' at %L must be unlimited \"\n+\tgfc_error (\"Actual argument to %qs at %L must be unlimited \"\n \t\t   \"polymorphic since the formal argument is a \"\n \t\t   \"pointer or allocatable unlimited polymorphic \"\n \t\t   \"entity [F2008: 12.5.2.5]\", formal->name,\n@@ -2060,7 +2060,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if (formal->attr.codimension && !gfc_is_coarray (actual))\n     {\n       if (where)\n-\tgfc_error (\"Actual argument to '%s' at %L must be a coarray\",\n+\tgfc_error (\"Actual argument to %qs at %L must be a coarray\",\n \t\t       formal->name, &actual->where);\n       return 0;\n     }\n@@ -2079,7 +2079,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t      && actual->symtree->n.sym->as->corank != formal->as->corank))\n \t{\n \t  if (where)\n-\t    gfc_error (\"Corank mismatch in argument '%s' at %L (%d and %d)\",\n+\t    gfc_error (\"Corank mismatch in argument %qs at %L (%d and %d)\",\n \t\t   formal->name, &actual->where, formal->as->corank,\n \t\t   last ? last->u.c.component->as->corank\n \t\t\t: actual->symtree->n.sym->as->corank);\n@@ -2096,7 +2096,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  && !gfc_is_simply_contiguous (actual, true))\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument to '%s' at %L must be simply \"\n+\t    gfc_error (\"Actual argument to %qs at %L must be simply \"\n \t\t       \"contiguous\", formal->name, &actual->where);\n \t  return 0;\n \t}\n@@ -2110,7 +2110,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \n     \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument to non-INTENT(INOUT) dummy '%s' at %L, \"\n+\t    gfc_error (\"Actual argument to non-INTENT(INOUT) dummy %qs at %L, \"\n \t\t       \"which is LOCK_TYPE or has a LOCK_TYPE component\",\n \t\t       formal->name, &actual->where);\n \t  return 0;\n@@ -2128,7 +2128,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  || formal->attr.contiguous))\n     {\n       if (where)\n-\tgfc_error (\"Dummy argument '%s' has to be a pointer, assumed-shape or \"\n+\tgfc_error (\"Dummy argument %qs has to be a pointer, assumed-shape or \"\n \t\t   \"assumed-rank array without CONTIGUOUS attribute - as actual\"\n \t\t   \" argument at %L is not simply contiguous and both are \"\n \t\t   \"ASYNCHRONOUS or VOLATILE\", formal->name, &actual->where);\n@@ -2142,7 +2142,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t{\n \t  if (where)\n \t    gfc_error (\"Passing coarray at %L to allocatable, noncoarray, \"\n-\t\t       \"INTENT(OUT) dummy argument '%s'\", &actual->where,\n+\t\t       \"INTENT(OUT) dummy argument %qs\", &actual->where,\n \t\t       formal->name);\n \t    return 0;\n \t}\n@@ -2211,7 +2211,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if (actual->ts.type == BT_CLASS && actual->expr_type != EXPR_NULL)\n     {\n       if (where)\n-\tgfc_error (\"Polymorphic scalar passed to array dummy argument '%s' \"\n+\tgfc_error (\"Polymorphic scalar passed to array dummy argument %qs \"\n \t\t   \"at %L\", formal->name, &actual->where);\n       return 0;\n     }\n@@ -2221,7 +2221,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n     {\n       if (where)\n \tgfc_error (\"Element of assumed-shaped or pointer \"\n-\t\t   \"array passed to array dummy argument '%s' at %L\",\n+\t\t   \"array passed to array dummy argument %qs at %L\",\n \t\t   formal->name, &actual->where);\n       return 0;\n     }\n@@ -2234,14 +2234,14 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t  if (where)\n \t    gfc_error (\"Extension: Scalar non-default-kind, non-C_CHAR-kind \"\n \t\t       \"CHARACTER actual argument with array dummy argument \"\n-\t\t       \"'%s' at %L\", formal->name, &actual->where);\n+\t\t       \"%qs at %L\", formal->name, &actual->where);\n \t  return 0;\n \t}\n \n       if (where && (gfc_option.allow_std & GFC_STD_F2003) == 0)\n \t{\n \t  gfc_error (\"Fortran 2003: Scalar CHARACTER actual argument with \"\n-\t\t     \"array dummy argument '%s' at %L\",\n+\t\t     \"array dummy argument %qs at %L\",\n \t\t     formal->name, &actual->where);\n \t  return 0;\n \t}\n@@ -2555,15 +2555,15 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (f == NULL)\n \t    {\n \t      if (where)\n-\t\tgfc_error (\"Keyword argument '%s' at %L is not in \"\n+\t\tgfc_error (\"Keyword argument %qs at %L is not in \"\n \t\t\t   \"the procedure\", a->name, &a->expr->where);\n \t      return 0;\n \t    }\n \n \t  if (new_arg[i] != NULL)\n \t    {\n \t      if (where)\n-\t\tgfc_error (\"Keyword argument '%s' at %L is already associated \"\n+\t\tgfc_error (\"Keyword argument %qs at %L is already associated \"\n \t\t\t   \"with another actual argument\", a->name,\n \t\t\t   &a->expr->where);\n \t      return 0;\n@@ -2620,11 +2620,11 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t  || (f->sym->ts.type != BT_CLASS && f->sym->attr.allocatable)\n \t\t  || (f->sym->ts.type == BT_CLASS\n \t\t\t && CLASS_DATA (f->sym)->attr.allocatable)))\n-\t    gfc_error (\"Unexpected NULL() intrinsic at %L to dummy '%s'\",\n+\t    gfc_error (\"Unexpected NULL() intrinsic at %L to dummy %qs\",\n \t\t       where, f->sym->name);\n \t  else if (where)\n \t    gfc_error (\"Fortran 2008: Null pointer at %L to non-pointer \"\n-\t\t       \"dummy '%s'\", where, f->sym->name);\n+\t\t       \"dummy %qs\", where, f->sym->name);\n \n \t  return 0;\n \t}\n@@ -2690,7 +2690,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Actual argument at %L to allocatable or \"\n-\t\t       \"pointer dummy argument '%s' must have a deferred \"\n+\t\t       \"pointer dummy argument %qs must have a deferred \"\n \t\t       \"length type parameter if and only if the dummy has one\",\n \t\t       &a->expr->where, f->sym->name);\n \t  return 0;\n@@ -2730,7 +2730,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t       || gfc_is_proc_ptr_comp (a->expr)))\n \t{\n \t  if (where)\n-\t    gfc_error (\"Expected a procedure pointer for argument '%s' at %L\",\n+\t    gfc_error (\"Expected a procedure pointer for argument %qs at %L\",\n \t\t       f->sym->name, &a->expr->where);\n \t  return 0;\n \t}\n@@ -2741,7 +2741,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  && gfc_expr_attr (a->expr).flavor != FL_PROCEDURE)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Expected a procedure for argument '%s' at %L\",\n+\t    gfc_error (\"Expected a procedure for argument %qs at %L\",\n \t\t       f->sym->name, &a->expr->where);\n \t  return 0;\n \t}\n@@ -2755,7 +2755,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t  && a->expr->ref->u.ar.type == AR_FULL)))\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument for '%s' cannot be an assumed-size\"\n+\t    gfc_error (\"Actual argument for %qs cannot be an assumed-size\"\n \t\t       \" array at %L\", f->sym->name, where);\n \t  return 0;\n \t}\n@@ -2764,7 +2764,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  && compare_pointer (f->sym, a->expr) == 0)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument for '%s' must be a pointer at %L\",\n+\t    gfc_error (\"Actual argument for %qs must be a pointer at %L\",\n \t\t       f->sym->name, &a->expr->where);\n \t  return 0;\n \t}\n@@ -2775,7 +2775,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Fortran 2008: Non-pointer actual argument at %L to \"\n-\t\t       \"pointer dummy '%s'\", &a->expr->where,f->sym->name);\n+\t\t       \"pointer dummy %qs\", &a->expr->where,f->sym->name);\n \t  return 0;\n \t}\n \n@@ -2785,7 +2785,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Coindexed actual argument at %L to pointer \"\n-\t\t       \"dummy '%s'\",\n+\t\t       \"dummy %qs\",\n \t\t       &a->expr->where, f->sym->name);\n \t  return 0;\n \t}\n@@ -2798,7 +2798,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Coindexed actual argument at %L to allocatable \"\n-\t\t       \"dummy '%s' requires INTENT(IN)\",\n+\t\t       \"dummy %qs requires INTENT(IN)\",\n \t\t       &a->expr->where, f->sym->name);\n \t  return 0;\n \t}\n@@ -2812,7 +2812,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Coindexed ASYNCHRONOUS or VOLATILE actual argument at \"\n-\t\t       \"%L requires that dummy '%s' has neither \"\n+\t\t       \"%L requires that dummy %qs has neither \"\n \t\t       \"ASYNCHRONOUS nor VOLATILE\", &a->expr->where,\n \t\t       f->sym->name);\n \t  return 0;\n@@ -2826,7 +2826,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t{\n \t  if (where)\n \t    gfc_error (\"Coindexed actual argument at %L with allocatable \"\n-\t\t       \"ultimate component to dummy '%s' requires either VALUE \"\n+\t\t       \"ultimate component to dummy %qs requires either VALUE \"\n \t\t       \"or INTENT(IN)\", &a->expr->where, f->sym->name);\n \t  return 0;\n \t}\n@@ -2837,7 +2837,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t   && !full_array)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual CLASS array argument for '%s' must be a full \"\n+\t    gfc_error (\"Actual CLASS array argument for %qs must be a full \"\n \t\t       \"array at %L\", f->sym->name, &a->expr->where);\n \t  return 0;\n \t}\n@@ -2847,7 +2847,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  && compare_allocatable (f->sym, a->expr) == 0)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Actual argument for '%s' must be ALLOCATABLE at %L\",\n+\t    gfc_error (\"Actual argument for %qs must be ALLOCATABLE at %L\",\n \t\t       f->sym->name, &a->expr->where);\n \t  return 0;\n \t}\n@@ -2879,7 +2879,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t    gfc_error (\"Array-section actual argument with vector \"\n \t\t       \"subscripts at %L is incompatible with INTENT(OUT), \"\n \t\t       \"INTENT(INOUT), VOLATILE or ASYNCHRONOUS attribute \"\n-\t\t       \"of the dummy argument '%s'\",\n+\t\t       \"of the dummy argument %qs\",\n \t\t       &a->expr->where, f->sym->name);\n \t  return 0;\n \t}\n@@ -2896,7 +2896,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Assumed-shape actual argument at %L is \"\n \t\t       \"incompatible with the non-assumed-shape \"\n-\t\t       \"dummy argument '%s' due to VOLATILE attribute\",\n+\t\t       \"dummy argument %qs due to VOLATILE attribute\",\n \t\t       &a->expr->where,f->sym->name);\n \t  return 0;\n \t}\n@@ -2908,7 +2908,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Array-section actual argument at %L is \"\n \t\t       \"incompatible with the non-assumed-shape \"\n-\t\t       \"dummy argument '%s' due to VOLATILE attribute\",\n+\t\t       \"dummy argument %qs due to VOLATILE attribute\",\n \t\t       &a->expr->where,f->sym->name);\n \t  return 0;\n \t}\n@@ -2927,7 +2927,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  if (where)\n \t    gfc_error (\"Pointer-array actual argument at %L requires \"\n \t\t       \"an assumed-shape or pointer-array dummy \"\n-\t\t       \"argument '%s' due to VOLATILE attribute\",\n+\t\t       \"argument %qs due to VOLATILE attribute\",\n \t\t       &a->expr->where,f->sym->name);\n \t  return 0;\n \t}\n@@ -2955,7 +2955,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n       if (!f->sym->attr.optional)\n \t{\n \t  if (where)\n-\t    gfc_error (\"Missing actual argument for argument '%s' at %L\",\n+\t    gfc_error (\"Missing actual argument for argument %qs at %L\",\n \t\t       f->sym->name, where);\n \t  return 0;\n \t}\n@@ -3226,7 +3226,7 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t   && gfc_is_coindexed (expr))\n \t {\n \t   gfc_error (\"Coindexed polymorphic actual argument at %L is passed \"\n-\t\t      \"polymorphic dummy argument '%s'\",\n+\t\t      \"polymorphic dummy argument %qs\",\n \t\t\t &expr->where, f->sym->name);\n \t   return false;\n \t }\n@@ -3253,7 +3253,7 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n     {\n       if (sym->ns->has_implicit_none_export && sym->attr.proc == PROC_UNKNOWN)\n \t{\n-\t  gfc_error (\"Procedure '%s' called at %L is not explicitly declared\",\n+\t  gfc_error (\"Procedure %qs called at %L is not explicitly declared\",\n \t\t     sym->name, where);\n \t  return false;\n \t}\n@@ -3273,24 +3273,24 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \n       if (sym->attr.pointer)\n \t{\n-\t  gfc_error(\"The pointer object '%s' at %L must have an explicit \"\n-\t\t    \"function interface or be declared as array\",\n-\t\t    sym->name, where);\n+\t  gfc_error (\"The pointer object %qs at %L must have an explicit \"\n+\t\t     \"function interface or be declared as array\",\n+\t\t     sym->name, where);\n \t  return false;\n \t}\n \n       if (sym->attr.allocatable && !sym->attr.external)\n \t{\n-\t  gfc_error(\"The allocatable object '%s' at %L must have an explicit \"\n-\t\t    \"function interface or be declared as array\",\n-\t\t    sym->name, where);\n+\t  gfc_error (\"The allocatable object %qs at %L must have an explicit \"\n+\t\t     \"function interface or be declared as array\",\n+\t\t     sym->name, where);\n \t  return false;\n \t}\n \n       if (sym->attr.allocatable)\n \t{\n-\t  gfc_error(\"Allocatable function '%s' at %L must have an explicit \"\n-\t\t    \"function interface\", sym->name, where);\n+\t  gfc_error (\"Allocatable function %qs at %L must have an explicit \"\n+\t\t     \"function interface\", sym->name, where);\n \t  return false;\n \t}\n \n@@ -3299,8 +3299,8 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t  /* Skip g77 keyword extensions like %VAL, %REF, %LOC.  */\n \t  if (a->name != NULL && a->name[0] != '%')\n \t    {\n-\t      gfc_error(\"Keyword argument requires explicit interface \"\n-\t\t\t\"for procedure '%s' at %L\", sym->name, &a->expr->where);\n+\t      gfc_error (\"Keyword argument requires explicit interface \"\n+\t\t\t \"for procedure %qs at %L\", sym->name, &a->expr->where);\n \t      break;\n \t    }\n \n@@ -3321,9 +3321,9 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t\t   && a->expr->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n \t\t  || gfc_expr_attr (a->expr).lock_comp))\n \t    {\n-\t      gfc_error(\"Actual argument of LOCK_TYPE or with LOCK_TYPE \"\n-\t\t\t\"component at %L requires an explicit interface for \"\n-\t\t\t\"procedure '%s'\", &a->expr->where, sym->name);\n+\t      gfc_error (\"Actual argument of LOCK_TYPE or with LOCK_TYPE \"\n+\t\t\t \"component at %L requires an explicit interface for \"\n+\t\t\t \"procedure %qs\", &a->expr->where, sym->name);\n \t      break;\n \t    }\n \n@@ -3387,9 +3387,9 @@ gfc_ppc_use (gfc_component *comp, gfc_actual_arglist **ap, locus *where)\n \t  /* Skip g77 keyword extensions like %VAL, %REF, %LOC.  */\n \t  if (a->name != NULL && a->name[0] != '%')\n \t    {\n-\t      gfc_error(\"Keyword argument requires explicit interface \"\n-\t\t\t\"for procedure pointer component '%s' at %L\",\n-\t\t\tcomp->name, &a->expr->where);\n+\t      gfc_error (\"Keyword argument requires explicit interface \"\n+\t\t\t \"for procedure pointer component %qs at %L\",\n+\t\t\t comp->name, &a->expr->where);\n \t      break;\n \t    }\n \t}\n@@ -3913,7 +3913,7 @@ gfc_check_new_interface (gfc_interface *base, gfc_symbol *new_sym, locus loc)\n     {\n       if (ip->sym == new_sym)\n \t{\n-\t  gfc_error (\"Entity '%s' at %L is already present in the interface\",\n+\t  gfc_error (\"Entity %qs at %L is already present in the interface\",\n \t\t     new_sym->name, &loc);\n \t  return false;\n \t}\n@@ -4124,7 +4124,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n   /* If the overwritten procedure is GENERIC, this is an error.  */\n   if (old->n.tb->is_generic)\n     {\n-      gfc_error (\"Can't overwrite GENERIC '%s' at %L\",\n+      gfc_error (\"Can't overwrite GENERIC %qs at %L\",\n \t\t old->name, &proc->n.tb->where);\n       return false;\n     }\n@@ -4136,23 +4136,23 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n   /* Check that overridden binding is not NON_OVERRIDABLE.  */\n   if (old->n.tb->non_overridable)\n     {\n-      gfc_error (\"'%s' at %L overrides a procedure binding declared\"\n+      gfc_error (\"%qs at %L overrides a procedure binding declared\"\n \t\t \" NON_OVERRIDABLE\", proc->name, &where);\n       return false;\n     }\n \n   /* It's an error to override a non-DEFERRED procedure with a DEFERRED one.  */\n   if (!old->n.tb->deferred && proc->n.tb->deferred)\n     {\n-      gfc_error (\"'%s' at %L must not be DEFERRED as it overrides a\"\n+      gfc_error (\"%qs at %L must not be DEFERRED as it overrides a\"\n \t\t \" non-DEFERRED binding\", proc->name, &where);\n       return false;\n     }\n \n   /* If the overridden binding is PURE, the overriding must be, too.  */\n   if (old_target->attr.pure && !proc_target->attr.pure)\n     {\n-      gfc_error (\"'%s' at %L overrides a PURE procedure and must also be PURE\",\n+      gfc_error (\"%qs at %L overrides a PURE procedure and must also be PURE\",\n \t\t proc->name, &where);\n       return false;\n     }\n@@ -4161,13 +4161,13 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n      is not, the overriding must not be either.  */\n   if (old_target->attr.elemental && !proc_target->attr.elemental)\n     {\n-      gfc_error (\"'%s' at %L overrides an ELEMENTAL procedure and must also be\"\n+      gfc_error (\"%qs at %L overrides an ELEMENTAL procedure and must also be\"\n \t\t \" ELEMENTAL\", proc->name, &where);\n       return false;\n     }\n   if (!old_target->attr.elemental && proc_target->attr.elemental)\n     {\n-      gfc_error (\"'%s' at %L overrides a non-ELEMENTAL procedure and must not\"\n+      gfc_error (\"%qs at %L overrides a non-ELEMENTAL procedure and must not\"\n \t\t \" be ELEMENTAL, either\", proc->name, &where);\n       return false;\n     }\n@@ -4176,7 +4176,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n      SUBROUTINE.  */\n   if (old_target->attr.subroutine && !proc_target->attr.subroutine)\n     {\n-      gfc_error (\"'%s' at %L overrides a SUBROUTINE and must also be a\"\n+      gfc_error (\"%qs at %L overrides a SUBROUTINE and must also be a\"\n \t\t \" SUBROUTINE\", proc->name, &where);\n       return false;\n     }\n@@ -4187,7 +4187,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       if (!proc_target->attr.function)\n \t{\n-\t  gfc_error (\"'%s' at %L overrides a FUNCTION and must also be a\"\n+\t  gfc_error (\"%qs at %L overrides a FUNCTION and must also be a\"\n \t\t     \" FUNCTION\", proc->name, &where);\n \t  return false;\n \t}\n@@ -4196,7 +4196,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t\t\t\t\t sizeof(err)))\n \t{\n \t  gfc_error (\"Result mismatch for the overriding procedure \"\n-\t\t     \"'%s' at %L: %s\", proc->name, &where, err);\n+\t\t     \"%qs at %L: %s\", proc->name, &where, err);\n \t  return false;\n \t}\n     }\n@@ -4206,7 +4206,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n   if (old->n.tb->access == ACCESS_PUBLIC\n       && proc->n.tb->access == ACCESS_PRIVATE)\n     {\n-      gfc_error (\"'%s' at %L overrides a PUBLIC procedure and must not be\"\n+      gfc_error (\"%qs at %L overrides a PUBLIC procedure and must not be\"\n \t\t \" PRIVATE\", proc->name, &where);\n       return false;\n     }\n@@ -4236,7 +4236,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n       /* Check that the names correspond.  */\n       if (strcmp (proc_formal->sym->name, old_formal->sym->name))\n \t{\n-\t  gfc_error (\"Dummy argument '%s' of '%s' at %L should be named '%s' as\"\n+\t  gfc_error (\"Dummy argument %qs of %qs at %L should be named %qs as\"\n \t\t     \" to match the corresponding argument of the overridden\"\n \t\t     \" procedure\", proc_formal->sym->name, proc->name, &where,\n \t\t     old_formal->sym->name);\n@@ -4248,15 +4248,15 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n \t\t\t\t\tcheck_type, err, sizeof(err)))\n \t{\n \t  gfc_error (\"Argument mismatch for the overriding procedure \"\n-\t\t     \"'%s' at %L: %s\", proc->name, &where, err);\n+\t\t     \"%qs at %L: %s\", proc->name, &where, err);\n \t  return false;\n \t}\n \n       ++argpos;\n     }\n   if (proc_formal || old_formal)\n     {\n-      gfc_error (\"'%s' at %L must have the same number of formal arguments as\"\n+      gfc_error (\"%qs at %L must have the same number of formal arguments as\"\n \t\t \" the overridden procedure\", proc->name, &where);\n       return false;\n     }\n@@ -4265,7 +4265,7 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n      NOPASS.  */\n   if (old->n.tb->nopass && !proc->n.tb->nopass)\n     {\n-      gfc_error (\"'%s' at %L overrides a NOPASS binding and must also be\"\n+      gfc_error (\"%qs at %L overrides a NOPASS binding and must also be\"\n \t\t \" NOPASS\", proc->name, &where);\n       return false;\n     }\n@@ -4276,14 +4276,14 @@ gfc_check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n     {\n       if (proc->n.tb->nopass)\n \t{\n-\t  gfc_error (\"'%s' at %L overrides a binding with PASS and must also be\"\n+\t  gfc_error (\"%qs at %L overrides a binding with PASS and must also be\"\n \t\t     \" PASS\", proc->name, &where);\n \t  return false;\n \t}\n \n       if (proc_pass_arg != old_pass_arg)\n \t{\n-\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be at\"\n+\t  gfc_error (\"Passed-object dummy argument of %qs at %L must be at\"\n \t\t     \" the same position as the passed-object dummy argument of\"\n \t\t     \" the overridden procedure\", proc->name, &where);\n \t  return false;"}, {"sha": "5abd02d6b464fbaf49d8b0d18736668ed1b2444d", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -3815,7 +3815,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n   if (a == NULL)\n     goto do_sort;\n \n-  gfc_error (\"Too many arguments in call to '%s' at %L\", name, where);\n+  gfc_error (\"Too many arguments in call to %qs at %L\", name, where);\n   return false;\n \n keywords:\n@@ -3833,14 +3833,14 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n \t    gfc_error (\"The argument list functions %%VAL, %%LOC or %%REF \"\n \t\t       \"are not allowed in this context at %L\", where);\n \t  else\n-\t    gfc_error (\"Can't find keyword named '%s' in call to '%s' at %L\",\n+\t    gfc_error (\"Can't find keyword named %qs in call to %qs at %L\",\n \t\t       a->name, name, where);\n \t  return false;\n \t}\n \n       if (f->actual != NULL)\n \t{\n-\t  gfc_error (\"Argument '%s' appears twice in call to '%s' at %L\",\n+\t  gfc_error (\"Argument %qs appears twice in call to %qs at %L\",\n \t\t     f->name, name, where);\n \t  return false;\n \t}\n@@ -3854,7 +3854,7 @@ sort_actual (const char *name, gfc_actual_arglist **ap,\n     {\n       if (f->actual == NULL && f->optional == 0)\n \t{\n-\t  gfc_error (\"Missing actual argument '%s' in call to '%s' at %L\",\n+\t  gfc_error (\"Missing actual argument %qs in call to %qs at %L\",\n \t\t     f->name, name, where);\n \t  return false;\n \t}\n@@ -3926,7 +3926,7 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n       if (!gfc_compare_types (&ts, &actual->expr->ts))\n \t{\n \t  if (error_flag)\n-\t    gfc_error (\"Type of argument '%s' in call to '%s' at %L should \"\n+\t    gfc_error (\"Type of argument %qs in call to %qs at %L should \"\n \t\t       \"be %s, not %s\", gfc_current_intrinsic_arg[i]->name,\n \t\t       gfc_current_intrinsic, &actual->expr->where,\n \t\t       gfc_typename (&formal->ts),\n@@ -4534,14 +4534,14 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n \n   if (gfc_do_concurrent_flag && !isym->pure)\n     {\n-      gfc_error (\"Subroutine call to intrinsic '%s' in DO CONCURRENT \"\n+      gfc_error (\"Subroutine call to intrinsic %qs in DO CONCURRENT \"\n \t\t \"block at %L is not PURE\", name, &c->loc);\n       return MATCH_ERROR;\n     }\n \n   if (!isym->pure && gfc_pure (NULL))\n     {\n-      gfc_error (\"Subroutine call to intrinsic '%s' at %L is not PURE\", name,\n+      gfc_error (\"Subroutine call to intrinsic %qs at %L is not PURE\", name,\n \t\t &c->loc);\n       return MATCH_ERROR;\n     }"}, {"sha": "e3226083bb9e4dd89caa038da2ce81fff48749d7", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -3548,7 +3548,7 @@ gfc_match_allocate (void)\n \t  /* The next 2 conditionals check C631.  */\n \t  if (ts.type != BT_UNKNOWN)\n \t    {\n-\t      gfc_error (\"SOURCE tag at %L conflicts with the typespec at %L\",\n+\t      gfc_error_1 (\"SOURCE tag at %L conflicts with the typespec at %L\",\n \t\t\t &tmp->where, &old_locus);\n \t      goto cleanup;\n \t    }\n@@ -3585,7 +3585,7 @@ gfc_match_allocate (void)\n \t  /* Check F08:C637.  */\n \t  if (ts.type != BT_UNKNOWN)\n \t    {\n-\t      gfc_error (\"MOLD tag at %L conflicts with the typespec at %L\",\n+\t      gfc_error_1 (\"MOLD tag at %L conflicts with the typespec at %L\",\n \t\t\t &tmp->where, &old_locus);\n \t      goto cleanup;\n \t    }\n@@ -3611,7 +3611,7 @@ gfc_match_allocate (void)\n   /* Check F08:C637.  */\n   if (source && mold)\n     {\n-      gfc_error (\"MOLD tag at %L conflicts with SOURCE tag at %L\",\n+      gfc_error_1 (\"MOLD tag at %L conflicts with SOURCE tag at %L\",\n \t\t  &mold->where, &source->where);\n       goto cleanup;\n     }\n@@ -4315,7 +4315,7 @@ gfc_match_common (void)\n \n \t  if (sym->attr.in_common)\n \t    {\n-\t      gfc_error (\"Symbol '%s' at %C is already in a COMMON block\",\n+\t      gfc_error (\"Symbol %qs at %C is already in a COMMON block\",\n \t\t\t sym->name);\n \t      goto cleanup;\n \t    }\n@@ -4838,7 +4838,9 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n match\n gfc_match_st_function (void)\n {\n-  gfc_error_buf old_error;\n+  gfc_error_buf old_error_1;\n+  output_buffer old_error;\n+\n   gfc_symbol *sym;\n   gfc_expr *expr;\n   match m;\n@@ -4847,7 +4849,7 @@ gfc_match_st_function (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  gfc_push_error (&old_error);\n+  gfc_push_error (&old_error, &old_error_1);\n \n   if (!gfc_add_procedure (&sym->attr, PROC_ST_FUNCTION, sym->name, NULL))\n     goto undo_error;\n@@ -4859,7 +4861,8 @@ gfc_match_st_function (void)\n   if (m == MATCH_NO)\n     goto undo_error;\n \n-  gfc_free_error (&old_error);\n+  gfc_free_error (&old_error, &old_error_1);\n+\n   if (m == MATCH_ERROR)\n     return m;\n \n@@ -4877,7 +4880,7 @@ gfc_match_st_function (void)\n   return MATCH_YES;\n \n undo_error:\n-  gfc_pop_error (&old_error);\n+  gfc_pop_error (&old_error, &old_error_1);\n   return MATCH_NO;\n }\n "}, {"sha": "b0309fc6bb2e51da6b12924afc49d61d42f898ce", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -2326,31 +2326,31 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t      {\n \t\tbool bad = false;\n \t\tif (n->sym->attr.threadprivate)\n-\t\t  gfc_error (\"THREADPRIVATE object '%s' in %s clause at %L\",\n+\t\t  gfc_error (\"THREADPRIVATE object %qs in %s clause at %L\",\n \t\t\t     n->sym->name, name, where);\n \t\tif (n->sym->attr.cray_pointee)\n-\t\t  gfc_error (\"Cray pointee '%s' in %s clause at %L\",\n+\t\t  gfc_error (\"Cray pointee %qs in %s clause at %L\",\n \t\t\t    n->sym->name, name, where);\n \t\tif (n->sym->attr.associate_var)\n-\t\t  gfc_error (\"ASSOCIATE name '%s' in %s clause at %L\",\n+\t\t  gfc_error (\"ASSOCIATE name %qs in %s clause at %L\",\n \t\t\t     n->sym->name, name, where);\n \t\tif (list != OMP_LIST_PRIVATE)\n \t\t  {\n \t\t    if (n->sym->attr.proc_pointer && list == OMP_LIST_REDUCTION)\n-\t\t      gfc_error (\"Procedure pointer '%s' in %s clause at %L\",\n+\t\t      gfc_error (\"Procedure pointer %qs in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t    if (n->sym->attr.pointer && list == OMP_LIST_REDUCTION)\n-\t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n+\t\t      gfc_error (\"POINTER object %qs in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t    if (n->sym->attr.cray_pointer && list == OMP_LIST_REDUCTION)\n-\t\t      gfc_error (\"Cray pointer '%s' in %s clause at %L\",\n+\t\t      gfc_error (\"Cray pointer %qs in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t  }\n \t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n-\t\t  gfc_error (\"Assumed size array '%s' in %s clause at %L\",\n+\t\t  gfc_error (\"Assumed size array %qs in %s clause at %L\",\n \t\t\t     n->sym->name, name, where);\n \t\tif (n->sym->attr.in_namelist && list != OMP_LIST_REDUCTION)\n-\t\t  gfc_error (\"Variable '%s' in %s clause is used in \"\n+\t\t  gfc_error (\"Variable %qs in %s clause is used in \"\n \t\t\t     \"NAMELIST statement at %L\",\n \t\t\t     n->sym->name, name, where);\n \t\tif (n->sym->attr.pointer && n->sym->attr.intent == INTENT_IN)\n@@ -2360,7 +2360,7 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t    case OMP_LIST_LASTPRIVATE:\n \t\t    case OMP_LIST_LINEAR:\n \t\t    /* case OMP_LIST_REDUCTION: */\n-\t\t      gfc_error (\"INTENT(IN) POINTER '%s' in %s clause at %L\",\n+\t\t      gfc_error (\"INTENT(IN) POINTER %qs in %s clause at %L\",\n \t\t\t\t n->sym->name, name, where);\n \t\t      break;\n \t\t    default:\n@@ -2475,22 +2475,22 @@ resolve_omp_clauses (gfc_code *code, locus *where,\n \t\t    break;\n \t\t  case OMP_LIST_LINEAR:\n \t\t    if (n->sym->ts.type != BT_INTEGER)\n-\t\t      gfc_error (\"LINEAR variable '%s' must be INTEGER \"\n+\t\t      gfc_error (\"LINEAR variable %qs must be INTEGER \"\n \t\t\t\t \"at %L\", n->sym->name, where);\n \t\t    else if (!code && !n->sym->attr.value)\n-\t\t      gfc_error (\"LINEAR dummy argument '%s' must have VALUE \"\n+\t\t      gfc_error (\"LINEAR dummy argument %qs must have VALUE \"\n \t\t\t\t \"attribute at %L\", n->sym->name, where);\n \t\t    else if (n->expr)\n \t\t      {\n \t\t\tgfc_expr *expr = n->expr;\n \t\t\tif (!gfc_resolve_expr (expr)\n \t\t\t    || expr->ts.type != BT_INTEGER\n \t\t\t    || expr->rank != 0)\n-\t\t\t  gfc_error (\"'%s' in LINEAR clause at %L requires \"\n+\t\t\t  gfc_error (\"%qs in LINEAR clause at %L requires \"\n \t\t\t\t     \"a scalar integer linear-step expression\",\n \t\t\t\t     n->sym->name, where);\n \t\t\telse if (!code && expr->expr_type != EXPR_CONSTANT)\n-\t\t\t  gfc_error (\"'%s' in LINEAR clause at %L requires \"\n+\t\t\t  gfc_error (\"%qs in LINEAR clause at %L requires \"\n \t\t\t\t     \"a constant integer linear-step expression\",\n \t\t\t\t     n->sym->name, where);\n \t\t      }\n@@ -2931,7 +2931,7 @@ resolve_omp_atomic (gfc_code *code)\n \t  else if (expr_references_sym (arg->expr, var, NULL))\n \t    {\n \t      gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must \"\n-\t\t\t \"not reference '%s' at %L\",\n+\t\t\t \"not reference %qs at %L\",\n \t\t\t var->name, &arg->expr->where);\n \t      return;\n \t    }\n@@ -2946,7 +2946,7 @@ resolve_omp_atomic (gfc_code *code)\n       if (var_arg == NULL)\n \t{\n \t  gfc_error (\"First or last !$OMP ATOMIC intrinsic argument must \"\n-\t\t     \"be '%s' at %L\", var->name, &expr2->where);\n+\t\t     \"be %qs at %L\", var->name, &expr2->where);\n \t  return;\n \t}\n \n@@ -3414,7 +3414,7 @@ gfc_resolve_omp_declare_simd (gfc_namespace *ns)\n     {\n       if (ods->proc_name != ns->proc_name)\n \tgfc_error (\"!$OMP DECLARE SIMD should refer to containing procedure \"\n-\t\t   \"'%s' at %L\", ns->proc_name->name, &ods->where);\n+\t\t   \"%qs at %L\", ns->proc_name->name, &ods->where);\n       if (ods->clauses)\n \tresolve_omp_clauses (NULL, &ods->where, ods->clauses, ns);\n     }"}, {"sha": "970815ec8a0739604c3f79a40ce08012944dad2b", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -107,13 +107,14 @@ match_word_omp_simd (const char *str, match (*subr) (void), locus *old_locus,\n static void\n use_modules (void)\n {\n-  gfc_error_buf old_error;\n+  gfc_error_buf old_error_1;\n+  output_buffer old_error;\n \n-  gfc_push_error (&old_error);\n+  gfc_push_error (&old_error, &old_error_1);\n   gfc_buffer_error (false);\n   gfc_use_modules ();\n   gfc_buffer_error (true);\n-  gfc_pop_error (&old_error);\n+  gfc_pop_error (&old_error, &old_error_1);\n   gfc_commit_symbols ();\n   gfc_warning_check ();\n   gfc_current_ns->old_cl_list = gfc_current_ns->cl_list;\n@@ -2202,7 +2203,7 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)\n \n order:\n   if (!silent)\n-    gfc_error (\"%s statement at %C cannot follow %s statement at %L\",\n+    gfc_error_1 (\"%s statement at %C cannot follow %s statement at %L\",\n \t       gfc_ascii_statement (st),\n \t       gfc_ascii_statement (p->last_statement), &p->where);\n \n@@ -2579,7 +2580,7 @@ parse_derived (void)\n \t\t   \"subcomponent exists)\", c->name, &c->loc, sym->name);\n \n       if (sym->attr.lock_comp && coarray && !lock_type)\n-\tgfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n+\tgfc_error_1 (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n \t\t   \"subcomponent of type LOCK_TYPE must have a codimension or \"\n \t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n \t\t   \"not have a codimension as %s at %L has a codimension or a \"\n@@ -3281,7 +3282,7 @@ parse_if_block (void)\n \tcase ST_ELSEIF:\n \t  if (seen_else)\n \t    {\n-\t      gfc_error (\"ELSE IF statement at %C cannot follow ELSE \"\n+\t      gfc_error_1 (\"ELSE IF statement at %C cannot follow ELSE \"\n \t\t\t \"statement at %L\", &else_locus);\n \n \t      reject_statement ();\n@@ -4674,10 +4675,10 @@ gfc_global_used (gfc_gsymbol *sym, locus *where)\n     }\n \n   if (sym->binding_label)\n-    gfc_error (\"Global binding name '%s' at %L is already being used as a %s \"\n+    gfc_error_1 (\"Global binding name '%s' at %L is already being used as a %s \"\n \t       \"at %L\", sym->binding_label, where, name, &sym->where);\n   else\n-    gfc_error (\"Global name '%s' at %L is already being used as a %s at %L\",\n+    gfc_error_1 (\"Global name '%s' at %L is already being used as a %s at %L\",\n \t       sym->name, where, name, &sym->where);\n }\n "}, {"sha": "a9bf65840fe6ba2ecf3f5ac200bb1aecd36a1711", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -1274,7 +1274,8 @@ static match\n match_complex_constant (gfc_expr **result)\n {\n   gfc_expr *e, *real, *imag;\n-  gfc_error_buf old_error;\n+  gfc_error_buf old_error_1;\n+  output_buffer old_error;\n   gfc_typespec target;\n   locus old_loc;\n   int kind;\n@@ -1287,18 +1288,18 @@ match_complex_constant (gfc_expr **result)\n   if (m != MATCH_YES)\n     return m;\n \n-  gfc_push_error (&old_error);\n+  gfc_push_error (&old_error, &old_error_1);\n \n   m = match_complex_part (&real);\n   if (m == MATCH_NO)\n     {\n-      gfc_free_error (&old_error);\n+      gfc_free_error (&old_error, &old_error_1);\n       goto cleanup;\n     }\n \n   if (gfc_match_char (',') == MATCH_NO)\n     {\n-      gfc_pop_error (&old_error);\n+      gfc_pop_error (&old_error, &old_error_1);\n       m = MATCH_NO;\n       goto cleanup;\n     }\n@@ -1310,10 +1311,10 @@ match_complex_constant (gfc_expr **result)\n \n   if (m == MATCH_ERROR)\n     {\n-      gfc_free_error (&old_error);\n+      gfc_free_error (&old_error, &old_error_1);\n       goto cleanup;\n     }\n-  gfc_pop_error (&old_error);\n+  gfc_pop_error (&old_error, &old_error_1);\n \n   m = match_complex_part (&imag);\n   if (m == MATCH_NO)\n@@ -2493,7 +2494,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n \t  gcc_assert (comp_iter);\n \t  if (!strcmp (comp_iter->name, comp_tail->name))\n \t    {\n-\t      gfc_error (\"Component '%s' is initialized twice in the structure\"\n+\t      gfc_error (\"Component %qs is initialized twice in the structure\"\n \t\t\t \" constructor at %L!\", comp_tail->name,\n \t\t\t comp_tail->val ? &comp_tail->where\n \t\t\t\t\t: &gfc_current_locus);"}, {"sha": "32709437a2e5f673a322e15c308010520356fc89", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -469,24 +469,24 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t\t  && CLASS_DATA (sym)->attr.class_pointer))\n \t    {\n-\t      gfc_error (\"Argument '%s' of elemental procedure at %L cannot \"\n+\t      gfc_error (\"Argument %qs of elemental procedure at %L cannot \"\n \t\t\t \"have the POINTER attribute\", sym->name,\n \t\t\t &sym->declared_at);\n \t      continue;\n \t    }\n \n \t  if (sym->attr.flavor == FL_PROCEDURE)\n \t    {\n-\t      gfc_error (\"Dummy procedure '%s' not allowed in elemental \"\n-\t\t\t \"procedure '%s' at %L\", sym->name, proc->name,\n+\t      gfc_error (\"Dummy procedure %qs not allowed in elemental \"\n+\t\t\t \"procedure %qs at %L\", sym->name, proc->name,\n \t\t\t &sym->declared_at);\n \t      continue;\n \t    }\n \n \t  /* Fortran 2008 Corrigendum 1, C1290a.  */\n \t  if (sym->attr.intent == INTENT_UNKNOWN && !sym->attr.value)\n \t    {\n-\t      gfc_error (\"Argument '%s' of elemental procedure '%s' at %L must \"\n+\t      gfc_error (\"Argument %qs of elemental procedure %qs at %L must \"\n \t\t\t \"have its INTENT specified or have the VALUE \"\n \t\t\t \"attribute\", sym->name, proc->name,\n \t\t\t &sym->declared_at);\n@@ -499,7 +499,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t{\n \t  if (sym->as != NULL)\n \t    {\n-\t      gfc_error (\"Argument '%s' of statement function at %L must \"\n+\t      gfc_error (\"Argument %qs of statement function at %L must \"\n \t\t\t \"be scalar\", sym->name, &sym->declared_at);\n \t      continue;\n \t    }\n@@ -509,7 +509,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      gfc_charlen *cl = sym->ts.u.cl;\n \t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT)\n \t\t{\n-\t\t  gfc_error (\"Character-valued argument '%s' of statement \"\n+\t\t  gfc_error (\"Character-valued argument %qs of statement \"\n \t\t\t     \"function at %L must have constant length\",\n \t\t\t     sym->name, &sym->declared_at);\n \t\t  continue;\n@@ -567,10 +567,10 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n       if (!t && !sym->result->attr.untyped)\n \t{\n \t  if (sym->result == sym)\n-\t    gfc_error (\"Contained function '%s' at %L has no IMPLICIT type\",\n+\t    gfc_error (\"Contained function %qs at %L has no IMPLICIT type\",\n \t\t       sym->name, &sym->declared_at);\n \t  else if (!sym->result->attr.proc_pointer)\n-\t    gfc_error (\"Result '%s' of contained function '%s' at %L has \"\n+\t    gfc_error (\"Result %qs of contained function %qs at %L has \"\n \t\t       \"no IMPLICIT type\", sym->result->name, sym->name,\n \t\t       &sym->result->declared_at);\n \t  sym->result->attr.untyped = 1;\n@@ -594,7 +594,7 @@ resolve_contained_fntype (gfc_symbol *sym, gfc_namespace *ns)\n \t  gcc_assert (ns->parent && ns->parent->proc_name);\n \t  module_proc = (ns->parent->proc_name->attr.flavor == FL_MODULE);\n \n-\t  gfc_error (\"Character-valued %s '%s' at %L must not be\"\n+\t  gfc_error (\"Character-valued %s %qs at %L must not be\"\n \t\t     \" assumed length\",\n \t\t     module_proc ? _(\"module procedure\")\n \t\t\t\t : _(\"internal function\"),\n@@ -984,7 +984,7 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t      || (!common_root->n.common->binding_label\n \t\t  && gsym->binding_label)))\n \t{\n-\t  gfc_error (\"In Fortran 2003 COMMON '%s' block at %L is a global \"\n+\t  gfc_error_1 (\"In Fortran 2003 COMMON '%s' block at %L is a global \"\n \t\t     \"identifier and must thus have the same binding name \"\n \t\t     \"as the same-named COMMON block at %L: %s vs %s\",\n \t\t     common_root->n.common->name, &common_root->n.common->where,\n@@ -998,15 +998,15 @@ resolve_common_blocks (gfc_symtree *common_root)\n       if (gsym && gsym->type != GSYM_COMMON\n \t  && !common_root->n.common->binding_label)\n \t{\n-\t  gfc_error (\"COMMON block '%s' at %L uses the same global identifier \"\n+\t  gfc_error_1 (\"COMMON block '%s' at %L uses the same global identifier \"\n \t\t     \"as entity at %L\",\n \t\t     common_root->n.common->name, &common_root->n.common->where,\n \t\t     &gsym->where);\n \t  return;\n \t}\n       if (gsym && gsym->type != GSYM_COMMON)\n \t{\n-\t  gfc_error (\"Fortran 2008: COMMON block '%s' with binding label at \"\n+\t  gfc_error_1 (\"Fortran 2008: COMMON block '%s' with binding label at \"\n \t\t     \"%L sharing the identifier with global non-COMMON-block \"\n \t\t     \"entity at %L\", common_root->n.common->name,\n \t\t     &common_root->n.common->where, &gsym->where);\n@@ -1028,7 +1028,7 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t\t\t       common_root->n.common->binding_label);\n       if (gsym && gsym->type != GSYM_COMMON)\n \t{\n-\t  gfc_error (\"COMMON block at %L with binding label %s uses the same \"\n+\t  gfc_error_1 (\"COMMON block at %L with binding label %s uses the same \"\n \t\t     \"global identifier as entity at %L\",\n \t\t     &common_root->n.common->where,\n \t\t     common_root->n.common->binding_label, &gsym->where);\n@@ -1049,15 +1049,15 @@ resolve_common_blocks (gfc_symtree *common_root)\n     return;\n \n   if (sym->attr.flavor == FL_PARAMETER)\n-    gfc_error (\"COMMON block '%s' at %L is used as PARAMETER at %L\",\n+    gfc_error_1 (\"COMMON block '%s' at %L is used as PARAMETER at %L\",\n \t       sym->name, &common_root->n.common->where, &sym->declared_at);\n \n   if (sym->attr.external)\n-    gfc_error (\"COMMON block '%s' at %L can not have the EXTERNAL attribute\",\n+    gfc_error (\"COMMON block %qs at %L can not have the EXTERNAL attribute\",\n \t       sym->name, &common_root->n.common->where);\n \n   if (sym->attr.intrinsic)\n-    gfc_error (\"COMMON block '%s' at %L is also an intrinsic procedure\",\n+    gfc_error (\"COMMON block %qs at %L is also an intrinsic procedure\",\n \t       sym->name, &common_root->n.common->where);\n   else if (sym->attr.result\n \t   || gfc_is_function_return_value (sym, gfc_current_ns))\n@@ -1171,7 +1171,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t  else if (comp->attr.pointer && cons->expr->ts.type != BT_UNKNOWN)\n \t    {\n \t      gfc_error (\"The element in the structure constructor at %L, \"\n-\t\t\t \"for pointer component '%s', is %s but should be %s\",\n+\t\t\t \"for pointer component %qs, is %s but should be %s\",\n \t\t\t &cons->expr->where, comp->name,\n \t\t\t gfc_basic_typename (cons->expr->ts.type),\n \t\t\t gfc_basic_typename (comp->ts.type));\n@@ -1256,7 +1256,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t{\n \t  t = false;\n \t  gfc_error (\"The NULL in the structure constructor at %L is \"\n-\t\t     \"being applied to component '%s', which is neither \"\n+\t\t     \"being applied to component %qs, which is neither \"\n \t\t     \"a POINTER nor ALLOCATABLE\", &cons->expr->where,\n \t\t     comp->name);\n \t}\n@@ -1290,7 +1290,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t\t\t\t\t     err, sizeof (err), NULL, NULL))\n \t    {\n \t      gfc_error (\"Interface mismatch for procedure-pointer component \"\n-\t\t\t \"'%s' in structure constructor at %L: %s\",\n+\t\t\t \"%qs in structure constructor at %L: %s\",\n \t\t\t comp->name, &cons->expr->where, err);\n \t      return false;\n \t    }\n@@ -1306,7 +1306,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t{\n \t  t = false;\n \t  gfc_error (\"The element in the structure constructor at %L, \"\n-\t\t     \"for pointer component '%s' should be a POINTER or \"\n+\t\t     \"for pointer component %qs should be a POINTER or \"\n \t\t     \"a TARGET\", &cons->expr->where, comp->name);\n \t}\n \n@@ -1335,7 +1335,7 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t{\n \t  t = false;\n \t  gfc_error (\"Invalid expression in the structure constructor for \"\n-\t\t     \"pointer component '%s' at %L in PURE procedure\",\n+\t\t     \"pointer component %qs at %L in PURE procedure\",\n \t\t     comp->name, &cons->expr->where);\n \t}\n \n@@ -1461,7 +1461,7 @@ check_assumed_size_reference (gfc_symbol *sym, gfc_expr *e)\n     {\n       gfc_error (\"The upper bound in the last dimension must \"\n \t\t \"appear in the reference to the assumed size \"\n-\t\t \"array '%s' at %L\", sym->name, &e->where);\n+\t\t \"array %qs at %L\", sym->name, &e->where);\n       return true;\n     }\n   return false;\n@@ -1521,11 +1521,11 @@ count_specific_procs (gfc_expr *e)\n       }\n \n   if (n > 1)\n-    gfc_error (\"'%s' at %L is ambiguous\", e->symtree->n.sym->name,\n+    gfc_error (\"%qs at %L is ambiguous\", e->symtree->n.sym->name,\n \t       &e->where);\n \n   if (n == 0)\n-    gfc_error (\"GENERIC procedure '%s' is not allowed as an actual \"\n+    gfc_error (\"GENERIC procedure %qs is not allowed as an actual \"\n \t       \"argument at %L\", sym->name, &e->where);\n \n   return n;\n@@ -1659,7 +1659,7 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)\n     {\n       if (sym->ts.type != BT_UNKNOWN && !sym->attr.implicit_type)\n \t{\n-\t  gfc_error (\"Intrinsic subroutine '%s' at %L shall not have a type\"\n+\t  gfc_error (\"Intrinsic subroutine %qs at %L shall not have a type\"\n \t\t      \" specifier\", sym->name, &sym->declared_at);\n \t  return false;\n \t}\n@@ -1670,7 +1670,7 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)\n     }\n   else\n     {\n-      gfc_error (\"'%s' declared INTRINSIC at %L does not exist\", sym->name,\n+      gfc_error (\"%qs declared INTRINSIC at %L does not exist\", sym->name,\n \t\t &sym->declared_at);\n       return false;\n     }\n@@ -1683,7 +1683,7 @@ gfc_resolve_intrinsic (gfc_symbol *sym, locus *loc)\n   /* Check it is actually available in the standard settings.  */\n   if (!gfc_check_intrinsic_standard (isym, &symstd, false, sym->declared_at))\n     {\n-      gfc_error (\"The intrinsic '%s' declared INTRINSIC at %L is not\"\n+      gfc_error (\"The intrinsic %qs declared INTRINSIC at %L is not\"\n \t\t \" available in the current standard settings but %s.  Use\"\n \t\t \" an appropriate -std=* option or enable -fall-intrinsics\"\n \t\t \" in order to use it.\",\n@@ -1800,15 +1800,15 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \n \t  if (sym->attr.proc == PROC_ST_FUNCTION)\n \t    {\n-\t      gfc_error (\"Statement function '%s' at %L is not allowed as an \"\n+\t      gfc_error (\"Statement function %qs at %L is not allowed as an \"\n \t\t\t \"actual argument\", sym->name, &e->where);\n \t    }\n \n \t  actual_ok = gfc_intrinsic_actual_ok (sym->name,\n \t\t\t\t\t       sym->attr.subroutine);\n \t  if (sym->attr.intrinsic && actual_ok == 0)\n \t    {\n-\t      gfc_error (\"Intrinsic '%s' at %L is not allowed as an \"\n+\t      gfc_error (\"Intrinsic %qs at %L is not allowed as an \"\n \t\t\t \"actual argument\", sym->name, &e->where);\n \t    }\n \n@@ -1823,7 +1823,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \n \t  if (sym->attr.elemental && !sym->attr.intrinsic)\n \t    {\n-\t      gfc_error (\"ELEMENTAL non-INTRINSIC procedure '%s' is not \"\n+\t      gfc_error (\"ELEMENTAL non-INTRINSIC procedure %qs is not \"\n \t\t\t \"allowed as an actual argument at %L\", sym->name,\n \t\t\t &e->where);\n \t    }\n@@ -1851,7 +1851,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t      if (isym == NULL || !isym->specific)\n \t\t{\n \t\t  gfc_error (\"Unable to find a specific INTRINSIC procedure \"\n-\t\t\t     \"for the reference '%s' at %L\", sym->name,\n+\t\t\t     \"for the reference %qs at %L\", sym->name,\n \t\t\t     &e->where);\n \t\t  goto cleanup;\n \t\t}\n@@ -1872,7 +1872,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \n       if (gfc_find_sym_tree (sym->name, sym->ns->parent, 1, &parent_st))\n \t{\n-\t  gfc_error (\"Symbol '%s' at %L is ambiguous\", sym->name, &e->where);\n+\t  gfc_error (\"Symbol %qs at %L is ambiguous\", sym->name, &e->where);\n \t  goto cleanup;\n \t}\n \n@@ -2139,8 +2139,8 @@ resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n \t   || eformal->sym->attr.intent == INTENT_INOUT)\n \t  && arg->expr && arg->expr->rank == 0)\n \t{\n-\t  gfc_error (\"Actual argument at %L for INTENT(%s) dummy '%s' of \"\n-\t\t     \"ELEMENTAL subroutine '%s' is a scalar, but another \"\n+\t  gfc_error (\"Actual argument at %L for INTENT(%s) dummy %qs of \"\n+\t\t     \"ELEMENTAL subroutine %qs is a scalar, but another \"\n \t\t     \"actual argument is an array\", &arg->expr->where,\n \t\t     (eformal->sym->attr.intent == INTENT_OUT) ? \"OUT\"\n \t\t     : \"INOUT\", eformal->sym->name, esym->name);\n@@ -2416,7 +2416,7 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n \n       if (sym->attr.function && !gfc_compare_types (&sym->ts, &def_sym->ts))\n \t{\n-\t  gfc_error (\"Return type mismatch of function '%s' at %L (%s/%s)\",\n+\t  gfc_error (\"Return type mismatch of function %qs at %L (%s/%s)\",\n \t\t     sym->name, &sym->declared_at, gfc_typename (&sym->ts),\n \t\t     gfc_typename (&def_sym->ts));\n \t  goto done;\n@@ -2425,7 +2425,7 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n       if (sym->attr.if_source == IFSRC_UNKNOWN\n \t  && gfc_explicit_interface_required (def_sym, reason, sizeof(reason)))\n \t{\n-\t  gfc_error (\"Explicit interface required for '%s' at %L: %s\",\n+\t  gfc_error (\"Explicit interface required for %qs at %L: %s\",\n \t\t     sym->name, &sym->declared_at, reason);\n \t  goto done;\n \t}\n@@ -2437,7 +2437,7 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n       if (!gfc_compare_interfaces (sym, def_sym, sym->name, 0, 1,\n \t\t\t\t   reason, sizeof(reason), NULL, NULL))\n \t{\n-\t  gfc_error (\"Interface mismatch in global procedure '%s' at %L: %s \",\n+\t  gfc_error (\"Interface mismatch in global procedure %qs at %L: %s \",\n \t\t    sym->name, &sym->declared_at, reason);\n \t  goto done;\n \t}\n@@ -2545,7 +2545,7 @@ resolve_generic_f (gfc_expr *expr)\n      that possesses a matching interface.  14.1.2.4  */\n   if (sym  && !intr && !gfc_is_intrinsic (sym, 0, expr->where))\n     {\n-      gfc_error (\"There is no specific function for the generic '%s' \"\n+      gfc_error (\"There is no specific function for the generic %qs \"\n \t\t \"at %L\", expr->symtree->n.sym->name, &expr->where);\n       return false;\n     }\n@@ -2563,7 +2563,7 @@ resolve_generic_f (gfc_expr *expr)\n     return true;\n \n   if (m == MATCH_NO)\n-    gfc_error (\"Generic function '%s' at %L is not consistent with a \"\n+    gfc_error (\"Generic function %qs at %L is not consistent with a \"\n \t       \"specific intrinsic interface\", expr->symtree->n.sym->name,\n \t       &expr->where);\n \n@@ -2601,7 +2601,7 @@ resolve_specific_f0 (gfc_symbol *sym, gfc_expr *expr)\n       if (m == MATCH_YES)\n \treturn MATCH_YES;\n       if (m == MATCH_NO)\n-\tgfc_error (\"Function '%s' at %L is INTRINSIC but is not compatible \"\n+\tgfc_error (\"Function %qs at %L is INTRINSIC but is not compatible \"\n \t\t   \"with an intrinsic\", sym->name, &expr->where);\n \n       return MATCH_ERROR;\n@@ -2652,7 +2652,7 @@ resolve_specific_f (gfc_expr *expr)\n \tbreak;\n     }\n \n-  gfc_error (\"Unable to resolve the specific function '%s' at %L\",\n+  gfc_error (\"Unable to resolve the specific function %qs at %L\",\n \t     expr->symtree->n.sym->name, &expr->where);\n \n   return true;\n@@ -2708,7 +2708,7 @@ resolve_unknown_f (gfc_expr *expr)\n \n       if (ts->type == BT_UNKNOWN)\n \t{\n-\t  gfc_error (\"Function '%s' at %L has no IMPLICIT type\",\n+\t  gfc_error (\"Function %qs at %L has no IMPLICIT type\",\n \t\t     sym->name, &expr->where);\n \t  return false;\n \t}\n@@ -2829,15 +2829,15 @@ resolve_function (gfc_expr *expr)\n \n   if (sym && (sym->attr.flavor == FL_VARIABLE || sym->attr.subroutine))\n     {\n-      gfc_error (\"'%s' at %L is not a function\", sym->name, &expr->where);\n+      gfc_error (\"%qs at %L is not a function\", sym->name, &expr->where);\n       return false;\n     }\n \n   /* If this ia a deferred TBP with an abstract interface (which may\n      of course be referenced), expr->value.function.esym will be set.  */\n   if (sym && sym->attr.abstract && !expr->value.function.esym)\n     {\n-      gfc_error (\"ABSTRACT INTERFACE '%s' must not be referenced at %L\",\n+      gfc_error (\"ABSTRACT INTERFACE %qs must not be referenced at %L\",\n \t\t sym->name, &expr->where);\n       return false;\n     }\n@@ -2880,7 +2880,7 @@ resolve_function (gfc_expr *expr)\n       && !sym->attr.contained)\n     {\n       /* Internal procedures are taken care of in resolve_contained_fntype.  */\n-      gfc_error (\"Function '%s' is declared CHARACTER(*) and cannot \"\n+      gfc_error (\"Function %qs is declared CHARACTER(*) and cannot \"\n \t\t \"be used at %L since it is not a dummy argument\",\n \t\t sym->name, &expr->where);\n       return false;\n@@ -2934,7 +2934,7 @@ resolve_function (gfc_expr *expr)\n       && expr->value.function.esym\n       && ! gfc_elemental (expr->value.function.esym))\n     {\n-      gfc_error (\"User defined non-ELEMENTAL function '%s' at %L not allowed \"\n+      gfc_error (\"User defined non-ELEMENTAL function %qs at %L not allowed \"\n \t\t \"in WORKSHARE construct\", expr->value.function.esym->name,\n \t\t &expr->where);\n       t = false;\n@@ -2988,21 +2988,21 @@ resolve_function (gfc_expr *expr)\n     {\n       if (forall_flag)\n \t{\n-\t  gfc_error (\"Reference to non-PURE function '%s' at %L inside a \"\n+\t  gfc_error (\"Reference to non-PURE function %qs at %L inside a \"\n \t\t     \"FORALL %s\", name, &expr->where,\n \t\t     forall_flag == 2 ? \"mask\" : \"block\");\n \t  t = false;\n \t}\n       else if (gfc_do_concurrent_flag)\n \t{\n-\t  gfc_error (\"Reference to non-PURE function '%s' at %L inside a \"\n+\t  gfc_error (\"Reference to non-PURE function %qs at %L inside a \"\n \t\t     \"DO CONCURRENT %s\", name, &expr->where,\n \t\t     gfc_do_concurrent_flag == 2 ? \"mask\" : \"block\");\n \t  t = false;\n \t}\n       else if (gfc_pure (NULL))\n \t{\n-\t  gfc_error (\"Function reference to '%s' at %L is to a non-PURE \"\n+\t  gfc_error (\"Function reference to %qs at %L is to a non-PURE \"\n \t\t     \"procedure within a PURE procedure\", name, &expr->where);\n \t  t = false;\n \t}\n@@ -3020,11 +3020,11 @@ resolve_function (gfc_expr *expr)\n       if (is_illegal_recursion (esym, gfc_current_ns))\n       {\n \tif (esym->attr.entry && esym->ns->entries)\n-\t  gfc_error (\"ENTRY '%s' at %L cannot be called recursively, as\"\n-\t\t     \" function '%s' is not RECURSIVE\",\n+\t  gfc_error (\"ENTRY %qs at %L cannot be called recursively, as\"\n+\t\t     \" function %qs is not RECURSIVE\",\n \t\t     esym->name, &expr->where, esym->ns->entries->sym->name);\n \telse\n-\t  gfc_error (\"Function '%s' at %L cannot be called recursively, as it\"\n+\t  gfc_error (\"Function %qs at %L cannot be called recursively, as it\"\n \t\t     \" is not RECURSIVE\", esym->name, &expr->where);\n \n \tt = false;\n@@ -3063,13 +3063,13 @@ pure_subroutine (gfc_code *c, gfc_symbol *sym)\n     return;\n \n   if (forall_flag)\n-    gfc_error (\"Subroutine call to '%s' in FORALL block at %L is not PURE\",\n+    gfc_error (\"Subroutine call to %qs in FORALL block at %L is not PURE\",\n \t       sym->name, &c->loc);\n   else if (gfc_do_concurrent_flag)\n-    gfc_error (\"Subroutine call to '%s' in DO CONCURRENT block at %L is not \"\n+    gfc_error (\"Subroutine call to %qs in DO CONCURRENT block at %L is not \"\n \t       \"PURE\", sym->name, &c->loc);\n   else if (gfc_pure (NULL))\n-    gfc_error (\"Subroutine call to '%s' at %L is not PURE\", sym->name,\n+    gfc_error (\"Subroutine call to %qs at %L is not PURE\", sym->name,\n \t       &c->loc);\n \n   gfc_unset_implicit_pure (NULL);\n@@ -3134,7 +3134,7 @@ resolve_generic_s (gfc_code *c)\n \n   if (!gfc_is_intrinsic (sym, 1, c->loc))\n     {\n-      gfc_error (\"There is no specific subroutine for the generic '%s' at %L\",\n+      gfc_error (\"There is no specific subroutine for the generic %qs at %L\",\n \t\t sym->name, &c->loc);\n       return false;\n     }\n@@ -3143,7 +3143,7 @@ resolve_generic_s (gfc_code *c)\n   if (m == MATCH_YES)\n     return true;\n   if (m == MATCH_NO)\n-    gfc_error (\"Generic subroutine '%s' at %L is not consistent with an \"\n+    gfc_error (\"Generic subroutine %qs at %L is not consistent with an \"\n \t       \"intrinsic subroutine interface\", sym->name, &c->loc);\n \n   return false;\n@@ -3178,7 +3178,7 @@ resolve_specific_s0 (gfc_code *c, gfc_symbol *sym)\n       if (m == MATCH_YES)\n \treturn MATCH_YES;\n       if (m == MATCH_NO)\n-\tgfc_error (\"Subroutine '%s' at %L is INTRINSIC but is not compatible \"\n+\tgfc_error (\"Subroutine %qs at %L is INTRINSIC but is not compatible \"\n \t\t   \"with an intrinsic\", sym->name, &c->loc);\n \n       return MATCH_ERROR;\n@@ -3222,7 +3222,7 @@ resolve_specific_s (gfc_code *c)\n     }\n \n   sym = c->symtree->n.sym;\n-  gfc_error (\"Unable to resolve the specific subroutine '%s' at %L\",\n+  gfc_error (\"Unable to resolve the specific subroutine %qs at %L\",\n \t     sym->name, &c->loc);\n \n   return false;\n@@ -3282,7 +3282,7 @@ resolve_call (gfc_code *c)\n \n   if (csym && csym->ts.type != BT_UNKNOWN)\n     {\n-      gfc_error (\"'%s' at %L has a type, which is not consistent with \"\n+      gfc_error_1 (\"'%s' at %L has a type, which is not consistent with \"\n \t\t \"the CALL at %L\", csym->name, &csym->declared_at, &c->loc);\n       return false;\n     }\n@@ -3311,7 +3311,7 @@ resolve_call (gfc_code *c)\n     {\n       if (csym->attr.abstract)\n \t{\n-\t  gfc_error (\"ABSTRACT INTERFACE '%s' must not be referenced at %L\",\n+\t  gfc_error (\"ABSTRACT INTERFACE %qs must not be referenced at %L\",\n \t\t    csym->name, &c->loc);\n \t  return false;\n \t}\n@@ -3321,11 +3321,11 @@ resolve_call (gfc_code *c)\n       if (is_illegal_recursion (csym, gfc_current_ns))\n \t{\n \t  if (csym->attr.entry && csym->ns->entries)\n-\t    gfc_error (\"ENTRY '%s' at %L cannot be called recursively, \"\n-\t\t       \"as subroutine '%s' is not RECURSIVE\",\n+\t    gfc_error (\"ENTRY %qs at %L cannot be called recursively, \"\n+\t\t       \"as subroutine %qs is not RECURSIVE\",\n \t\t       csym->name, &c->loc, csym->ns->entries->sym->name);\n \t  else\n-\t    gfc_error (\"SUBROUTINE '%s' at %L cannot be called recursively, \"\n+\t    gfc_error (\"SUBROUTINE %qs at %L cannot be called recursively, \"\n \t\t       \"as it is not RECURSIVE\", csym->name, &c->loc);\n \n \t  t = false;\n@@ -3402,7 +3402,7 @@ compare_shapes (gfc_expr *op1, gfc_expr *op2)\n \t{\n \t  if (mpz_cmp (op1->shape[i], op2->shape[i]) != 0)\n \t   {\n-\t     gfc_error (\"Shapes for operands at %L and %L are not conformable\",\n+\t     gfc_error_1 (\"Shapes for operands at %L and %L are not conformable\",\n \t\t\t &op1->where, &op2->where);\n \t     t = false;\n \t     break;\n@@ -6676,7 +6676,7 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n \n \t  if (mpz_cmp (e1->shape[i], s) != 0)\n \t    {\n-\t      gfc_error (\"Source-expr at %L and allocate-object at %L must \"\n+\t      gfc_error_1 (\"Source-expr at %L and allocate-object at %L must \"\n \t\t\t \"have the same shape\", &e1->where, &e2->where);\n \t      mpz_clear (s);\n    \t      return false;\n@@ -6834,8 +6834,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       /* Check F03:C631.  */\n       if (!gfc_type_compatible (&e->ts, &code->expr3->ts))\n \t{\n-\t  gfc_error (\"Type of entity at %L is type incompatible with \"\n-\t\t      \"source-expr at %L\", &e->where, &code->expr3->where);\n+\t  gfc_error_1 (\"Type of entity at %L is type incompatible with \"\n+\t\t       \"source-expr at %L\", &e->where, &code->expr3->where);\n \t  goto failure;\n \t}\n \n@@ -6846,7 +6846,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       /* Check F03:C633.  */\n       if (code->expr3->ts.kind != e->ts.kind && !unlimited)\n \t{\n-\t  gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n+\t  gfc_error_1 (\"The allocate-object at %L and the source-expr at %L \"\n \t\t      \"shall have the same kind type parameter\",\n \t\t      &e->where, &code->expr3->where);\n \t  goto failure;\n@@ -6860,7 +6860,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t\t  && code->expr3->ts.u.derived->intmod_sym_id\n \t\t     == ISOFORTRAN_LOCK_TYPE)))\n \t{\n-\t  gfc_error (\"The source-expr at %L shall neither be of type \"\n+\t  gfc_error_1 (\"The source-expr at %L shall neither be of type \"\n \t\t     \"LOCK_TYPE nor have a LOCK_TYPE component if \"\n \t\t      \"allocate-object at %L is a coarray\",\n \t\t      &code->expr3->where, &e->where);\n@@ -7204,20 +7204,20 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \t\t{\n \t\t  if (pr == NULL && qr == NULL)\n \t\t    {\n-\t\t      gfc_error (\"Allocate-object at %L also appears at %L\",\n-\t\t\t\t &pe->where, &qe->where);\n+\t\t      gfc_error_1 (\"Allocate-object at %L also appears at %L\",\n+\t\t\t\t   &pe->where, &qe->where);\n \t\t      break;\n \t\t    }\n \t\t  else if (pr != NULL && qr == NULL)\n \t\t    {\n-\t\t      gfc_error (\"Allocate-object at %L is subobject of\"\n-\t\t\t\t \" object at %L\", &pe->where, &qe->where);\n+\t\t      gfc_error_1 (\"Allocate-object at %L is subobject of\"\n+\t\t\t\t   \" object at %L\", &pe->where, &qe->where);\n \t\t      break;\n \t\t    }\n \t\t  else if (pr == NULL && qr != NULL)\n \t\t    {\n-\t\t      gfc_error (\"Allocate-object at %L is subobject of\"\n-\t\t\t\t \" object at %L\", &qe->where, &pe->where);\n+\t\t      gfc_error_1 (\"Allocate-object at %L is subobject of\"\n+\t\t\t\t   \" object at %L\", &qe->where, &pe->where);\n \t\t      break;\n \t\t    }\n \t\t  /* Here, pr != NULL && qr != NULL  */\n@@ -7420,7 +7420,7 @@ check_case_overlap (gfc_case *list)\n \t\t\t element in the list.  Either way, we must\n \t\t\t issue an error and get the next case from P.  */\n \t\t      /* FIXME: Sort P and Q by line number.  */\n-\t\t      gfc_error (\"CASE label at %L overlaps with CASE \"\n+\t\t      gfc_error_1 (\"CASE label at %L overlaps with CASE \"\n \t\t\t\t \"label at %L\", &p->where, &q->where);\n \t\t      overlap_seen = 1;\n \t\t      e = p;\n@@ -7658,7 +7658,7 @@ resolve_select (gfc_code *code, bool select_type)\n \t    {\n \t      if (default_case != NULL)\n \t\t{\n-\t\t  gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n+\t\t  gfc_error_1 (\"The DEFAULT CASE at %L cannot be followed \"\n \t\t\t     \"by a second DEFAULT CASE at %L\",\n \t\t\t     &default_case->where, &cp->where);\n \t\t  t = false;\n@@ -8028,7 +8028,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t  /* Check F03:C818.  */\n \t  if (default_case)\n \t    {\n-\t      gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n+\t      gfc_error_1 (\"The DEFAULT CASE at %L cannot be followed \"\n \t\t\t \"by a second DEFAULT CASE at %L\",\n \t\t\t &default_case->ext.block.case_list->where, &c->where);\n \t      error++;\n@@ -8586,7 +8586,7 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \n   if (label->defined != ST_LABEL_TARGET && label->defined != ST_LABEL_DO_TARGET)\n     {\n-      gfc_error (\"Statement at %L is not a valid branch target statement \"\n+      gfc_error_1 (\"Statement at %L is not a valid branch target statement \"\n \t\t \"for the branch statement at %L\", &label->where, &code->loc);\n       return;\n     }\n@@ -8612,11 +8612,11 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \t{\n \t  if (stack->current->op == EXEC_CRITICAL\n \t      && bitmap_bit_p (stack->reachable_labels, label->value))\n-\t    gfc_error (\"GOTO statement at %L leaves CRITICAL construct for \"\n+\t    gfc_error_1 (\"GOTO statement at %L leaves CRITICAL construct for \"\n \t\t      \"label at %L\", &code->loc, &label->where);\n \t  else if (stack->current->op == EXEC_DO_CONCURRENT\n \t\t   && bitmap_bit_p (stack->reachable_labels, label->value))\n-\t    gfc_error (\"GOTO statement at %L leaves DO CONCURRENT construct \"\n+\t    gfc_error_1 (\"GOTO statement at %L leaves DO CONCURRENT construct \"\n \t\t      \"for label at %L\", &code->loc, &label->where);\n \t}\n \n@@ -8635,13 +8635,13 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \t{\n \t  /* Note: A label at END CRITICAL does not leave the CRITICAL\n \t     construct as END CRITICAL is still part of it.  */\n-\t  gfc_error (\"GOTO statement at %L leaves CRITICAL construct for label\"\n+\t  gfc_error_1 (\"GOTO statement at %L leaves CRITICAL construct for label\"\n \t\t      \" at %L\", &code->loc, &label->where);\n \t  return;\n \t}\n       else if (stack->current->op == EXEC_DO_CONCURRENT)\n \t{\n-\t  gfc_error (\"GOTO statement at %L leaves DO CONCURRENT construct for \"\n+\t  gfc_error_1 (\"GOTO statement at %L leaves DO CONCURRENT construct for \"\n \t\t     \"label at %L\", &code->loc, &label->where);\n \t  return;\n \t}\n@@ -10001,7 +10001,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t\tgfc_error (\"ASSIGNED GOTO statement at %L requires an \"\n \t\t\t   \"INTEGER variable\", &code->expr1->where);\n \t      else if (code->expr1->symtree->n.sym->attr.assign != 1)\n-\t\tgfc_error (\"Variable '%s' has not been assigned a target \"\n+\t\tgfc_error (\"Variable %qs has not been assigned a target \"\n \t\t\t   \"label at %L\", code->expr1->symtree->n.sym->name,\n \t\t\t   &code->expr1->where);\n \t    }\n@@ -10386,7 +10386,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n \n   if (sym->attr.flavor == FL_VARIABLE && gsym->type != GSYM_UNKNOWN)\n     {\n-      gfc_error (\"Variable %s with binding label %s at %L uses the same global \"\n+      gfc_error_1 (\"Variable %s with binding label %s at %L uses the same global \"\n \t\t \"identifier as entity at %L\", sym->name,\n \t\t sym->binding_label, &sym->declared_at, &gsym->where);\n       /* Clear the binding label to prevent checking multiple times.  */\n@@ -10399,8 +10399,8 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n     {\n       /* This can only happen if the variable is defined in a module - if it\n \t isn't the same module, reject it.  */\n-      gfc_error (\"Variable %s from module %s with binding label %s at %L uses \"\n-\t\t \"the same global identifier as entity at %L from module %s\",\n+      gfc_error_1 (\"Variable %s from module %s with binding label %s at %L uses \"\n+\t\t   \"the same global identifier as entity at %L from module %s\",\n \t\t sym->name, module, sym->binding_label,\n \t\t &sym->declared_at, &gsym->where, gsym->mod_name);\n       sym->binding_label = NULL;\n@@ -10416,7 +10416,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n       /* Print an error if the procedure is defined multiple times; we have to\n \t exclude references to the same procedure via module association or\n \t multiple checks for the same procedure.  */\n-      gfc_error (\"Procedure %s with binding label %s at %L uses the same \"\n+      gfc_error_1 (\"Procedure %s with binding label %s at %L uses the same \"\n \t\t \"global identifier as entity at %L\", sym->name,\n \t\t sym->binding_label, &sym->declared_at, &gsym->where);\n       sym->binding_label = NULL;\n@@ -10916,7 +10916,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n \ts = gfc_find_dt_in_generic (s);\n       if (s && s->attr.flavor != FL_DERIVED)\n \t{\n-\t  gfc_error (\"The type '%s' cannot be host associated at %L \"\n+\t  gfc_error_1 (\"The type '%s' cannot be host associated at %L \"\n \t\t     \"because it is blocked by an incompatible object \"\n \t\t     \"of the same name declared at %L\",\n \t\t     sym->ts.u.derived->name, &sym->declared_at,\n@@ -12335,7 +12335,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  && c->attr.codimension\n \t  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))\n \t{\n-\t  gfc_error (\"Coarray component '%s' at %L must be allocatable with \"\n+\t  gfc_error (\"Coarray component %qs at %L must be allocatable with \"\n \t\t     \"deferred shape\", c->name, &c->loc);\n \t  return false;\n \t}\n@@ -12344,7 +12344,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n       if (c->attr.codimension && c->ts.type == BT_DERIVED\n \t  && c->ts.u.derived->ts.is_iso_c)\n \t{\n-\t  gfc_error (\"Component '%s' at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n+\t  gfc_error (\"Component %qs at %L of TYPE(C_PTR) or TYPE(C_FUNPTR) \"\n \t\t     \"shall not be a coarray\", c->name, &c->loc);\n \t  return false;\n \t}\n@@ -12354,7 +12354,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  && (c->attr.codimension || c->attr.pointer || c->attr.dimension\n \t      || c->attr.allocatable))\n \t{\n-\t  gfc_error (\"Component '%s' at %L with coarray component \"\n+\t  gfc_error (\"Component %qs at %L with coarray component \"\n \t\t     \"shall be a nonpointer, nonallocatable scalar\",\n \t\t     c->name, &c->loc);\n \t  return false;\n@@ -12363,7 +12363,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n       /* F2008, C448.  */\n       if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))\n \t{\n-\t  gfc_error (\"Component '%s' at %L has the CONTIGUOUS attribute but \"\n+\t  gfc_error (\"Component %qs at %L has the CONTIGUOUS attribute but \"\n \t\t     \"is not an array pointer\", c->name, &c->loc);\n \t  return false;\n \t}\n@@ -12456,8 +12456,8 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \n \t      if (!me_arg)\n \t\t{\n-\t\t  gfc_error (\"Procedure pointer component '%s' with PASS(%s) \"\n-\t\t\t     \"at %L has no argument '%s'\", c->name,\n+\t\t  gfc_error (\"Procedure pointer component %qs with PASS(%s) \"\n+\t\t\t     \"at %L has no argument %qs\", c->name,\n \t\t\t     c->tb->pass_arg, &c->loc, c->tb->pass_arg);\n \t\t  c->tb->error = 1;\n \t\t  return false;\n@@ -12470,7 +12470,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      c->tb->pass_arg_num = 1;\n \t      if (!c->ts.interface->formal)\n \t\t{\n-\t\t  gfc_error (\"Procedure pointer component '%s' with PASS at %L \"\n+\t\t  gfc_error (\"Procedure pointer component %qs with PASS at %L \"\n \t\t\t     \"must have at least one argument\",\n \t\t\t     c->name, &c->loc);\n \t\t  c->tb->error = 1;\n@@ -12486,8 +12486,8 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      || (me_arg->ts.type == BT_CLASS\n \t\t  && CLASS_DATA (me_arg)->ts.u.derived != sym))\n \t    {\n-\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L must be of\"\n-\t\t\t \" the derived type '%s'\", me_arg->name, c->name,\n+\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L must be of\"\n+\t\t\t \" the derived type %qs\", me_arg->name, c->name,\n \t\t\t me_arg->name, &c->loc, sym->name);\n \t      c->tb->error = 1;\n \t      return false;\n@@ -12496,7 +12496,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  /* Check for C453.  */\n \t  if (me_arg->attr.dimension)\n \t    {\n-\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L \"\n+\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n \t\t\t \"must be scalar\", me_arg->name, c->name, me_arg->name,\n \t\t\t &c->loc);\n \t      c->tb->error = 1;\n@@ -12505,7 +12505,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \n \t  if (me_arg->attr.pointer)\n \t    {\n-\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L \"\n+\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n \t\t\t \"may not have the POINTER attribute\", me_arg->name,\n \t\t\t c->name, me_arg->name, &c->loc);\n \t      c->tb->error = 1;\n@@ -12514,15 +12514,15 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \n \t  if (me_arg->attr.allocatable)\n \t    {\n-\t      gfc_error (\"Argument '%s' of '%s' with PASS(%s) at %L \"\n+\t      gfc_error (\"Argument %qs of %qs with PASS(%s) at %L \"\n \t\t\t \"may not be ALLOCATABLE\", me_arg->name, c->name,\n \t\t\t me_arg->name, &c->loc);\n \t      c->tb->error = 1;\n \t      return false;\n \t    }\n \n \t  if (gfc_type_is_extensible (sym) && me_arg->ts.type != BT_CLASS)\n-\t    gfc_error (\"Non-polymorphic passed-object dummy argument of '%s'\"\n+\t    gfc_error (\"Non-polymorphic passed-object dummy argument of %qs\"\n \t\t       \" at %L\", c->name, &c->loc);\n \n \t}\n@@ -12551,7 +12551,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n       if (super_type && !sym->attr.is_class\n \t  && gfc_find_typebound_proc (super_type, NULL, c->name, true, NULL))\n \t{\n-\t  gfc_error (\"Component '%s' of '%s' at %L has the same name as an\"\n+\t  gfc_error (\"Component %qs of %qs at %L has the same name as an\"\n \t\t     \" inherited type-bound procedure\",\n \t\t     c->name, sym->name, &c->loc);\n \t  return false;\n@@ -12564,7 +12564,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t     || (!resolve_charlen(c->ts.u.cl))\n \t     || !gfc_is_constant_expr (c->ts.u.cl->length))\n \t   {\n-\t     gfc_error (\"Character length of component '%s' needs to \"\n+\t     gfc_error (\"Character length of component %qs needs to \"\n \t\t\t\"be a constant specification expression at %L\",\n \t\t\tc->name,\n \t\t\tc->ts.u.cl->length ? &c->ts.u.cl->length->where : &c->loc);\n@@ -12575,7 +12575,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n       if (c->ts.type == BT_CHARACTER && c->ts.deferred\n \t  && !c->attr.pointer && !c->attr.allocatable)\n \t{\n-\t  gfc_error (\"Character component '%s' of '%s' at %L with deferred \"\n+\t  gfc_error (\"Character component %qs of %qs at %L with deferred \"\n \t\t     \"length must be a POINTER or ALLOCATABLE\",\n \t\t     c->name, sym->name, &c->loc);\n \t  return false;\n@@ -12641,7 +12641,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  && c->attr.pointer && c->ts.u.derived->components == NULL\n \t  && !c->ts.u.derived->attr.zero_comp)\n \t{\n-\t  gfc_error (\"The pointer component '%s' of '%s' at %L is a type \"\n+\t  gfc_error (\"The pointer component %qs of %qs at %L is a type \"\n \t\t     \"that has not been declared\", c->name, sym->name,\n \t\t     &c->loc);\n \t  return false;\n@@ -12653,7 +12653,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  && !CLASS_DATA (c)->ts.u.derived->attr.zero_comp\n \t  && !UNLIMITED_POLY (c))\n \t{\n-\t  gfc_error (\"The pointer component '%s' of '%s' at %L is a type \"\n+\t  gfc_error (\"The pointer component %qs of %qs at %L is a type \"\n \t\t     \"that has not been declared\", c->name, sym->name,\n \t\t     &c->loc);\n \t  return false;\n@@ -12665,7 +12665,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t      || !(CLASS_DATA (c)->attr.class_pointer\n \t\t   || CLASS_DATA (c)->attr.allocatable)))\n \t{\n-\t  gfc_error (\"Component '%s' with CLASS at %L must be allocatable \"\n+\t  gfc_error (\"Component %qs with CLASS at %L must be allocatable \"\n \t\t     \"or pointer\", c->name, &c->loc);\n \t  /* Prevent a recurrence of the error.  */\n \t  c->ts.type = BT_UNKNOWN;\n@@ -13317,7 +13317,7 @@ resolve_symbol (gfc_symbol *sym)\n       if (sym->ns->proc_name->attr.flavor != FL_MODULE &&\n           sym->attr.in_common == 0)\n \t{\n-\t  gfc_error (\"Variable '%s' at %L cannot be BIND(C) because it \"\n+\t  gfc_error (\"Variable %qs at %L cannot be BIND(C) because it \"\n \t\t     \"is neither a COMMON block nor declared at the \"\n \t\t     \"module level scope\", sym->name, &(sym->declared_at));\n \t  t = false;"}, {"sha": "6a37036fb7d6a7b1652c24395e7db4edfb8ebdf4", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -2045,6 +2045,7 @@ load_file (const char *realfilename, const char *displayedname, bool initial)\n       b = XCNEWVAR (gfc_linebuf, gfc_linebuf_header_size\n \t\t    + (len + 1) * sizeof (gfc_char_t));\n \n+\n       b->location\n \t= linemap_line_start (line_table, current_file->line++, len);\n       /* ??? We add the location for the maximum column possible here,"}, {"sha": "aab144a3ea448b082d5d1e2a04a6b40b01ac895d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -1701,18 +1701,18 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n   if (type != BT_UNKNOWN && !(sym->attr.function && sym->attr.implicit_type))\n     {\n       if (sym->attr.use_assoc)\n-\tgfc_error (\"Symbol '%s' at %L conflicts with symbol from module '%s', \"\n+\tgfc_error_1 (\"Symbol '%s' at %L conflicts with symbol from module '%s', \"\n \t\t   \"use-associated at %L\", sym->name, where, sym->module,\n \t\t   &sym->declared_at);\n       else\n-\tgfc_error (\"Symbol '%s' at %L already has basic type of %s\", sym->name,\n+\tgfc_error (\"Symbol %qs at %L already has basic type of %s\", sym->name,\n \t\t where, gfc_basic_typename (type));\n       return false;\n     }\n \n   if (sym->attr.procedure && sym->ts.interface)\n     {\n-      gfc_error (\"Procedure '%s' at %L may not have basic type of %s\",\n+      gfc_error (\"Procedure %qs at %L may not have basic type of %s\",\n \t\t sym->name, where, gfc_basic_typename (ts->type));\n       return false;\n     }\n@@ -1895,7 +1895,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n     {\n       if (strcmp (p->name, name) == 0)\n \t{\n-\t  gfc_error (\"Component '%s' at %C already declared at %L\",\n+\t  gfc_error_1 (\"Component '%s' at %C already declared at %L\",\n \t\t     name, &p->loc);\n \t  return false;\n \t}\n@@ -1906,7 +1906,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n   if (sym->attr.extension\n \t&& gfc_find_component (sym->components->ts.u.derived, name, true, true))\n     {\n-      gfc_error (\"Component '%s' at %C already in the parent type \"\n+      gfc_error_1 (\"Component '%s' at %C already in the parent type \"\n \t\t \"at %L\", name, &sym->components->ts.u.derived->declared_at);\n       return false;\n     }\n@@ -2061,7 +2061,7 @@ gfc_find_component (gfc_symbol *sym, const char *name,\n \t   && !is_parent_comp))\n \t{\n \t  if (!silent)\n-\t    gfc_error (\"Component '%s' at %C is a PRIVATE component of '%s'\",\n+\t    gfc_error (\"Component %qs at %C is a PRIVATE component of %qs\",\n \t\t       name, sym->name);\n \t  return NULL;\n \t}\n@@ -2079,7 +2079,7 @@ gfc_find_component (gfc_symbol *sym, const char *name,\n     }\n \n   if (p == NULL && !silent)\n-    gfc_error (\"'%s' at %C is not a member of the '%s' structure\",\n+    gfc_error (\"%qs at %C is not a member of the %qs structure\",\n \t       name, sym->name);\n \n   return p;\n@@ -2218,7 +2218,7 @@ gfc_define_st_label (gfc_st_label *lp, gfc_sl_type type, locus *label_locus)\n   labelno = lp->value;\n \n   if (lp->defined != ST_LABEL_UNKNOWN)\n-    gfc_error (\"Duplicate statement label %d at %L and %L\", labelno,\n+    gfc_error_1 (\"Duplicate statement label %d at %L and %L\", labelno,\n \t       &lp->where, label_locus);\n   else\n     {\n@@ -2628,10 +2628,10 @@ ambiguous_symbol (const char *name, gfc_symtree *st)\n {\n \n   if (st->n.sym->module)\n-    gfc_error (\"Name '%s' at %C is an ambiguous reference to '%s' \"\n-\t       \"from module '%s'\", name, st->n.sym->name, st->n.sym->module);\n+    gfc_error (\"Name %qs at %C is an ambiguous reference to %qs \"\n+\t       \"from module %qs\", name, st->n.sym->name, st->n.sym->module);\n   else\n-    gfc_error (\"Name '%s' at %C is an ambiguous reference to '%s' \"\n+    gfc_error (\"Name %qs at %C is an ambiguous reference to %qs \"\n \t       \"from current program unit\", name, st->n.sym->name);\n }\n \n@@ -2852,7 +2852,7 @@ gfc_get_sym_tree (const char *name, gfc_namespace *ns, gfc_symtree **result,\n \t  && (ns->has_import_set || p->attr.imported)))\n \t{\n \t  /* Symbol is from another namespace.  */\n-\t  gfc_error (\"Symbol '%s' at %C has already been host associated\",\n+\t  gfc_error (\"Symbol %qs at %C has already been host associated\",\n \t\t     name);\n \t  return 2;\n \t}\n@@ -3895,7 +3895,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n          J3/04-007, Section 15.2.3, C1505.\t*/\n       if (curr_comp->attr.pointer != 0)\n         {\n-          gfc_error (\"Component '%s' at %L cannot have the \"\n+          gfc_error_1 (\"Component '%s' at %L cannot have the \"\n                      \"POINTER attribute because it is a member \"\n                      \"of the BIND(C) derived type '%s' at %L\",\n                      curr_comp->name, &(curr_comp->loc),\n@@ -3905,7 +3905,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n \n       if (curr_comp->attr.proc_pointer != 0)\n \t{\n-\t  gfc_error (\"Procedure pointer component '%s' at %L cannot be a member\"\n+\t  gfc_error_1 (\"Procedure pointer component '%s' at %L cannot be a member\"\n \t\t     \" of the BIND(C) derived type '%s' at %L\", curr_comp->name,\n \t\t     &curr_comp->loc, derived_sym->name,\n \t\t     &derived_sym->declared_at);\n@@ -3916,7 +3916,7 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n          J3/04-007, Section 15.2.3, C1505.\t*/\n       if (curr_comp->attr.allocatable != 0)\n         {\n-          gfc_error (\"Component '%s' at %L cannot have the \"\n+          gfc_error_1 (\"Component '%s' at %L cannot have the \"\n                      \"ALLOCATABLE attribute because it is a member \"\n                      \"of the BIND(C) derived type '%s' at %L\",\n                      curr_comp->name, &(curr_comp->loc),"}, {"sha": "a7d89c28988b448cc8be2ca073b0aba9d56e13b8", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -908,7 +908,7 @@ confirm_condition (segment_info *s1, gfc_equiv *eq1, segment_info *s2,\n   offset2 = calculate_offset (eq2->expr);\n \n   if (s1->offset + offset1 != s2->offset + offset2)\n-    gfc_error (\"Inconsistent equivalence rules involving '%s' at %L and \"\n+    gfc_error_1 (\"Inconsistent equivalence rules involving '%s' at %L and \"\n \t       \"'%s' at %L\", s1->sym->name, &s1->sym->declared_at,\n \t       s2->sym->name, &s2->sym->declared_at);\n }"}, {"sha": "0dbda9b1b99dfea4db8a5ddb17ede4bb9993ad87", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -55,9 +55,6 @@ output_buffer::~output_buffer ()\n   obstack_free (&formatted_obstack, NULL);\n }\n \n-/* A pointer to the formatted diagnostic message.  */\n-#define pp_formatted_text_data(PP) \\\n-   ((const char *) obstack_base (pp_buffer (PP)->obstack))\n \n /* Format an integer given by va_arg (ARG, type-specifier T) where\n    type-specifier is a precision modifier as indicated by PREC.  F is\n@@ -225,8 +222,7 @@ pp_maybe_wrap_text (pretty_printer *pp, const char *start, const char *end)\n static inline void\n pp_append_r (pretty_printer *pp, const char *start, int length)\n {\n-  obstack_grow (pp_buffer (pp)->obstack, start, length);\n-  pp_buffer (pp)->line_length += length;\n+  output_buffer_append_r (pp_buffer (pp), start, length);\n }\n \n /* Insert enough spaces into the output area of PRETTY-PRINTER to bring\n@@ -826,21 +822,15 @@ pp_append_text (pretty_printer *pp, const char *start, const char *end)\n const char *\n pp_formatted_text (pretty_printer *pp)\n {\n-  obstack_1grow (pp_buffer (pp)->obstack, '\\0');\n-  return pp_formatted_text_data (pp);\n+  return output_buffer_formatted_text (pp_buffer (pp));\n }\n \n /*  Return a pointer to the last character emitted in PRETTY-PRINTER's\n     output area.  A NULL pointer means no character available.  */\n const char *\n pp_last_position_in_text (const pretty_printer *pp)\n {\n-  const char *p = NULL;\n-  struct obstack *text = pp_buffer (pp)->obstack;\n-\n-  if (obstack_base (text) != obstack_next_free (text))\n-    p = ((const char *) obstack_next_free (text)) - 1;\n-  return p;\n+  return output_buffer_last_position_in_text (pp_buffer (pp));\n }\n \n /* Return the amount of characters PRETTY-PRINTER can accept to"}, {"sha": "3b72d597ec831e6b88809e323982ac515490f242", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -107,6 +107,38 @@ struct output_buffer\n   bool flush_p;\n };\n \n+/* Finishes constructing a NULL-terminated character string representing\n+   the buffered text.  */\n+static inline const char *\n+output_buffer_formatted_text (output_buffer *buff)\n+{\n+  obstack_1grow (buff->obstack, '\\0');\n+  return (const char *) obstack_base (buff->obstack);\n+}\n+\n+/* Append to the output buffer a string specified by its\n+   STARTing character and LENGTH.  */\n+static inline void\n+output_buffer_append_r (output_buffer *buff, const char *start, int length)\n+{\n+  obstack_grow (buff->obstack, start, length);\n+  buff->line_length += length;\n+}\n+\n+/*  Return a pointer to the last character emitted in the\n+    output_buffer.  A NULL pointer means no character available.  */\n+static inline const char *\n+output_buffer_last_position_in_text (const output_buffer *buff)\n+{\n+  const char *p = NULL;\n+  struct obstack *text = buff->obstack;\n+\n+  if (obstack_base (text) != obstack_next_free (text))\n+    p = ((const char *) obstack_next_free (text)) - 1;\n+  return p;\n+}\n+\n+\n /* The type of pretty-printer flags passed to clients.  */\n typedef unsigned int pp_flags;\n "}, {"sha": "c6a1932746d189b8ed1dc3bea9c7a1008b38ac95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4100eaea3acd1a0d88050ad721f36470a0a6e5d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c4100eaea3acd1a0d88050ad721f36470a0a6e5d", "patch": "@@ -1,3 +1,7 @@\n+2014-12-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+        * gfortran.dg/do_iterator.f90: Remove bogus dg-warning.\n+\n 2014-12-11  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm_neon.h (vrndqn_f32): Rename to..."}]}