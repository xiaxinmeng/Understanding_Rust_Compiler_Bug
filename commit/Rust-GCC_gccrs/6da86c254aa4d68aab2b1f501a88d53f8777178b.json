{"sha": "6da86c254aa4d68aab2b1f501a88d53f8777178b", "node_id": "C_kwDOANBUbNoAKDZkYTg2YzI1NGFhNGQ2OGFhYjJiMWY1MDFhODhkNTNmODc3NzE3OGI", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2022-01-28T09:35:07Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2022-01-28T09:35:07Z"}, "message": "Revert \"Prevent malicious descriptor stacking for scalar components.\"\n\nBreaks bootstrap.\n\nThis reverts commit c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7.", "tree": {"sha": "96e5220e2ebd90102251f7e3752d3b9326f791a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e5220e2ebd90102251f7e3752d3b9326f791a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6da86c254aa4d68aab2b1f501a88d53f8777178b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da86c254aa4d68aab2b1f501a88d53f8777178b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da86c254aa4d68aab2b1f501a88d53f8777178b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da86c254aa4d68aab2b1f501a88d53f8777178b/comments", "author": null, "committer": null, "parents": [{"sha": "c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7"}], "stats": {"total": 148, "additions": 43, "deletions": 105}, "files": [{"sha": "2f0c8a4d412a71ebce72792e63e1da990103da8a", "filename": "gcc/fortran/trans-array.cc", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da86c254aa4d68aab2b1f501a88d53f8777178b/gcc%2Ffortran%2Ftrans-array.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da86c254aa4d68aab2b1f501a88d53f8777178b/gcc%2Ffortran%2Ftrans-array.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.cc?ref=6da86c254aa4d68aab2b1f501a88d53f8777178b", "patch": "@@ -9102,10 +9102,6 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\tcontinue;\n \t    }\n \n-\t  /* Do not broadcast a caf_token.  These are local to the image.  */\n-\t  if (attr->caf_token)\n-\t    continue;\n-\n \t  add_when_allocated = NULL_TREE;\n \t  if (cmp_has_alloc_comps\n \t      && !c->attr.pointer && !c->attr.proc_pointer)\n@@ -9138,69 +9134,52 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  if (attr->dimension)\n \t    {\n \t      tmp = gfc_get_element_type (TREE_TYPE (comp));\n-\t      if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n-\t\tubound = GFC_TYPE_ARRAY_SIZE (TREE_TYPE (comp));\n-\t      else\n-\t\tubound = gfc_full_array_size (&tmpblock, comp,\n-\t\t\t\t\t      c->ts.type == BT_CLASS\n-\t\t\t\t\t      ? CLASS_DATA (c)->as->rank\n-\t\t\t\t\t      : c->as->rank);\n+\t      ubound = gfc_full_array_size (&tmpblock, comp,\n+\t\t\t\t\t    c->ts.type == BT_CLASS\n+\t\t\t\t\t    ? CLASS_DATA (c)->as->rank\n+\t\t\t\t\t    : c->as->rank);\n \t    }\n \t  else\n \t    {\n \t      tmp = TREE_TYPE (comp);\n \t      ubound = build_int_cst (gfc_array_index_type, 1);\n \t    }\n \n-\t  /* Treat strings like arrays.  Or the other way around, do not\n-\t   * generate an additional array layer for scalar components.  */\n-\t  if (attr->dimension || c->ts.type == BT_CHARACTER)\n-\t    {\n-\t      cdesc = gfc_get_array_type_bounds (tmp, 1, 0, &gfc_index_one_node,\n-\t\t\t\t\t\t &ubound, 1,\n-\t\t\t\t\t\t GFC_ARRAY_ALLOCATABLE, false);\n+\t  cdesc = gfc_get_array_type_bounds (tmp, 1, 0, &gfc_index_one_node,\n+\t\t\t\t\t     &ubound, 1,\n+\t\t\t\t\t     GFC_ARRAY_ALLOCATABLE, false);\n \n-\t      cdesc = gfc_create_var (cdesc, \"cdesc\");\n-\t      DECL_ARTIFICIAL (cdesc) = 1;\n+\t  cdesc = gfc_create_var (cdesc, \"cdesc\");\n+\t  DECL_ARTIFICIAL (cdesc) = 1;\n \n-\t      gfc_add_modify (&tmpblock, gfc_conv_descriptor_dtype (cdesc),\n-\t\t\t      gfc_get_dtype_rank_type (1, tmp));\n-\t      gfc_conv_descriptor_lbound_set (&tmpblock, cdesc,\n-\t\t\t\t\t      gfc_index_zero_node,\n-\t\t\t\t\t      gfc_index_one_node);\n-\t      gfc_conv_descriptor_stride_set (&tmpblock, cdesc,\n-\t\t\t\t\t      gfc_index_zero_node,\n-\t\t\t\t\t      gfc_index_one_node);\n-\t      gfc_conv_descriptor_ubound_set (&tmpblock, cdesc,\n-\t\t\t\t\t      gfc_index_zero_node, ubound);\n-\t    }\n+\t  gfc_add_modify (&tmpblock, gfc_conv_descriptor_dtype (cdesc),\n+\t\t\t  gfc_get_dtype_rank_type (1, tmp));\n+\t  gfc_conv_descriptor_lbound_set (&tmpblock, cdesc,\n+\t\t\t\t\t  gfc_index_zero_node,\n+\t\t\t\t\t  gfc_index_one_node);\n+\t  gfc_conv_descriptor_stride_set (&tmpblock, cdesc,\n+\t\t\t\t\t  gfc_index_zero_node,\n+\t\t\t\t\t  gfc_index_one_node);\n+\t  gfc_conv_descriptor_ubound_set (&tmpblock, cdesc,\n+\t\t\t\t\t  gfc_index_zero_node, ubound);\n \n \t  if (attr->dimension)\n-\t    {\n-\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n-\t\tcomp = gfc_conv_descriptor_data_get (comp);\n-\t      else\n-\t\tcomp = gfc_build_addr_expr (NULL_TREE, comp);\n-\t    }\n+\t    comp = gfc_conv_descriptor_data_get (comp);\n \t  else\n \t    {\n \t      gfc_se se;\n \n \t      gfc_init_se (&se, NULL);\n \n \t      comp = gfc_conv_scalar_to_descriptor (&se, comp,\n-\t\t\t\t\t\t     c->ts.type == BT_CLASS\n-\t\t\t\t\t\t     ? CLASS_DATA (c)->attr\n-\t\t\t\t\t\t     : c->attr);\n-\t      if (c->ts.type == BT_CHARACTER)\n-\t\tcomp = gfc_build_addr_expr (NULL_TREE, comp);\n+\t      \t\t\t\t\t    c->ts.type == BT_CLASS\n+\t      \t\t\t\t\t    ? CLASS_DATA (c)->attr\n+\t      \t\t\t\t\t    : c->attr);\n+\t      comp = gfc_build_addr_expr (NULL_TREE, comp);\n \t      gfc_add_block_to_block (&tmpblock, &se.pre);\n \t    }\n \n-\t  if (attr->dimension || c->ts.type == BT_CHARACTER)\n-\t    gfc_conv_descriptor_data_set (&tmpblock, cdesc, comp);\n-\t  else\n-\t    cdesc = comp;\n+\t  gfc_conv_descriptor_data_set (&tmpblock, cdesc, comp);\n \n \t  tree fndecl;\n "}, {"sha": "da854fad89dcad54c44cee21492dc18917fc30be", "filename": "gcc/fortran/trans-intrinsic.cc", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da86c254aa4d68aab2b1f501a88d53f8777178b/gcc%2Ffortran%2Ftrans-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da86c254aa4d68aab2b1f501a88d53f8777178b/gcc%2Ffortran%2Ftrans-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.cc?ref=6da86c254aa4d68aab2b1f501a88d53f8777178b", "patch": "@@ -11212,31 +11212,24 @@ conv_co_collective (gfc_code *code)\n       return gfc_finish_block (&block);\n     }\n \n-  gfc_symbol *derived = code->ext.actual->expr->ts.type == BT_DERIVED\n-    ? code->ext.actual->expr->ts.u.derived : NULL;\n-\n   /* Handle the array.  */\n   gfc_init_se (&argse, NULL);\n-  if (!derived || !derived->attr.alloc_comp\n-      || code->resolved_isym->id != GFC_ISYM_CO_BROADCAST)\n+  if (code->ext.actual->expr->rank == 0)\n     {\n-      if (code->ext.actual->expr->rank == 0)\n-\t{\n-\t  symbol_attribute attr;\n-\t  gfc_clear_attr (&attr);\n-\t  gfc_init_se (&argse, NULL);\n-\t  gfc_conv_expr (&argse, code->ext.actual->expr);\n-\t  gfc_add_block_to_block (&block, &argse.pre);\n-\t  gfc_add_block_to_block (&post_block, &argse.post);\n-\t  array = gfc_conv_scalar_to_descriptor (&argse, argse.expr, attr);\n-\t  array = gfc_build_addr_expr (NULL_TREE, array);\n-\t}\n-      else\n-\t{\n-\t  argse.want_pointer = 1;\n-\t  gfc_conv_expr_descriptor (&argse, code->ext.actual->expr);\n-\t  array = argse.expr;\n-\t}\n+      symbol_attribute attr;\n+      gfc_clear_attr (&attr);\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr (&argse, code->ext.actual->expr);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      gfc_add_block_to_block (&post_block, &argse.post);\n+      array = gfc_conv_scalar_to_descriptor (&argse, argse.expr, attr);\n+      array = gfc_build_addr_expr (NULL_TREE, array);\n+    }\n+  else\n+    {\n+      argse.want_pointer = 1;\n+      gfc_conv_expr_descriptor (&argse, code->ext.actual->expr);\n+      array = argse.expr;\n     }\n \n   gfc_add_block_to_block (&block, &argse.pre);\n@@ -11297,6 +11290,9 @@ conv_co_collective (gfc_code *code)\n       gcc_unreachable ();\n     }\n \n+  gfc_symbol *derived = code->ext.actual->expr->ts.type == BT_DERIVED\n+    ? code->ext.actual->expr->ts.u.derived : NULL;\n+\n   if (derived && derived->attr.alloc_comp\n       && code->resolved_isym->id == GFC_ISYM_CO_BROADCAST)\n     /* The derived type has the attribute 'alloc_comp'.  */"}, {"sha": "c83899de0e5bf3dc7577032ebc64796f70e099a6", "filename": "gcc/testsuite/gfortran.dg/coarray_collectives_18.f90", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_collectives_18.f90?ref=c9c48ab7bad9fe5e096076e56a60ce0a5a2b65f7", "patch": "@@ -1,37 +0,0 @@\n-! { dg-do compile }\n-! { dg-additional-options \"-fdump-tree-original -fcoarray=lib\" }\n-!\n-! PR 103970\n-! Test case inspired by code submitted by Damian Rousson\n-\n-program main\n-\n-  implicit none\n-\n-  type foo_t\n-    integer i\n-    integer, allocatable :: j\n-  end type\n-\n-  type(foo_t) foo\n-  integer, parameter :: source_image = 1\n-\n-  if (this_image() == source_image)  then\n-    foo = foo_t(2,3)\n-  else\n-    allocate(foo%j)\n-  end if\n-  call co_broadcast(foo, source_image)\n-\n-  if ((foo%i /= 2) .or. (foo%j /= 3))  error stop 1\n-  sync all\n-\n-end program\n-\n-! Wrong code generation produced too many temp descriptors\n-! leading to stacked descriptors handed to the co_broadcast.\n-! This lead to access to non exsitant memory in opencoarrays.\n-! In single image mode just checking for reduced number of\n-! descriptors is possible, i.e., execute always works.\n-! { dg-final { scan-tree-dump-times \"desc\\\\.\\[0-9\\]+\" 12 \"original\" } }\n-"}]}