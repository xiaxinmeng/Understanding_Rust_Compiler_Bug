{"sha": "9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWVmYjQ5OTNjYmJlOGNhMGVlMWFlNTBlNDcyYWM3YmViNThmMTNmMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-19T17:27:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-19T17:27:58Z"}, "message": "mn10300: Explicitly represent MDR in multiply and divide.\n\nNote that the mulsidi3_internal pattern is structured so\nas to let the lower-subregs pass fully split the result.\n\nFrom-SVN: r169008", "tree": {"sha": "19eff32a2b06c80a809819ea8346239153f15c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19eff32a2b06c80a809819ea8346239153f15c00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1/comments", "author": null, "committer": null, "parents": [{"sha": "c25a21f58196ce9746f137ad7e95858e5836f01a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25a21f58196ce9746f137ad7e95858e5836f01a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25a21f58196ce9746f137ad7e95858e5836f01a"}], "stats": {"total": 285, "additions": 169, "deletions": 116}, "files": [{"sha": "e2bda22f2e4168eae983539d905b87b8d9589463", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "patch": "@@ -1,5 +1,20 @@\n 2011-01-19  Richard Henderson  <rth@redhat.com>\n \n+\t* config/mn10300/mn10300.md (UNSPEC_EXT): New.\n+\t(throughput_42_latency_43): New reservation.\n+\t(mulsidi3, umulsidi3): New expanders.\n+\t(mulsidi3_internal): Rewrite from old mulsidi3 pattern.  Expose\n+\tthe MDR register to allocation; separately allocate the low and\n+\thigh parts of the DImode result.\n+\t(umulsidi3_internal): Similarly.\n+\t(*am33_mulsi3, *mn10300_mulsi3): Merge into ...\n+\t(*mulsi3): ... here.  Clobber MDR as a scratch as necessary.\n+\t(udivsi3, umodsi3): Remove.\n+\t(udivmodsi4, divmodsi4): New expanders.\n+\t(*udivmodsi4): Rename from udivmodsi4.  Expose MDR properly.\n+\t(*divmodsi4): Simiarly.\n+\t(ext_internal): New.\n+\n \t* config/mn10300/constraints.md (\"z\"): New constraint.\n \t* config/mn10300/mn10300.h (MDR_REGNUM): Remove.\n \t(FIXED_REGISTERS): Don't fix MDR."}, {"sha": "bc68ca5d8fdcd7af6f3650eab741cad716037e9e", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 154, "deletions": 116, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=9efb4993cbbe8ca0ee1ae50e472ac7beb58f13f1", "patch": "@@ -38,6 +38,7 @@\n   (UNSPEC_PLT\t\t4)\n   (UNSPEC_GOTSYM_OFF\t5)\n \n+  (UNSPEC_EXT\t\t6)\n   (UNSPEC_BSCH\t\t7)\n ])\n \n@@ -167,6 +168,8 @@\n   (eq_attr \"timings\" \"4040\") \"throughput*40\")\n (define_insn_reservation \"throughput_41_latency_42\" 42\n   (eq_attr \"timings\" \"4142\") \"throughput*41,nothing\")\n+(define_insn_reservation \"throughput_42_latency_43\" 44\n+  (eq_attr \"timings\" \"4243\") \"throughput*42,nothing\")\n (define_insn_reservation \"throughput_43_latency_44\" 44\n   (eq_attr \"timings\" \"4344\") \"throughput*43,nothing\")\n (define_insn_reservation \"throughput_45_latency_46\" 46\n@@ -748,148 +751,183 @@\n ;; MULTIPLY INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"mulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=dax\")\n-        (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n-                 (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"mul %1,%2,%H0,%L0\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 24) (const_int 23)))]\n-)\n+;; ??? Note that AM33 has a third multiply variant that puts the high part\n+;; into the MDRQ register, however this variant also constrains the inputs\n+;; to be in DATA_REGS and thus isn't as helpful as it might be considering\n+;; the existance of the 4-operand multiply.  Nor is there a set of divide\n+;; insns that use MDRQ.  Given that there is an IMM->MDRQ insn, this would\n+;; have been very handy for starting udivmodsi4...\n+\n+(define_expand \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+                 (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))]\n+  \"\"\n+{\n+  emit_insn (gen_mulsidi3_internal (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t    gen_highpart (SImode, operands[0]),\n+\t\t\t\t    operands[1], operands[2]));\n+  DONE;\n+})\n \n-(define_insn \"umulsidi3\"\n-  [(set (match_operand:DI                          0 \"register_operand\" \"=dax\")\n-        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n-                 (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"mulu %1,%2,%H0,%L0\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-\t\t\t\t       (const_int 24) (const_int 23)))]\n+(define_insn \"mulsidi3_internal\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=D,r\")\n+\t(mult:SI (match_operand:SI 2 \"register_operand\" \"%0,r\")\n+\t\t (match_operand:SI 3 \"register_operand\" \" D,r\")))\n+   (set (match_operand:SI          1 \"register_operand\" \"=z,r\")\n+\t(truncate:SI\n+\t  (ashiftrt:DI\n+\t    (mult:DI (sign_extend:DI (match_dup 2))\n+\t\t     (sign_extend:DI (match_dup 3)))\n+\t    (const_int 32))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+{\n+  if (which_alternative == 1)\n+    return \"mul %2,%3,%1,%0\";\n+  else if (TARGET_MULT_BUG)\n+    return \"nop\\;nop\\;mul %3,%0\";\n+  else\n+    return \"mul %3,%0\";\n+}\n+  [(set_attr \"isa\" \"*,am33\")\n+   (set (attr \"timings\")\n+        (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 24) (const_int 23)))]\n )\n \n-(define_expand \"mulsi3\"\n-  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n-\t\t   (mult:SI (match_operand:SI 1 \"register_operand\")\n-\t\t\t    (match_operand:SI 2 \"register_operand\")))\n-\t      (clobber (reg:CC CC_REG))\n-\t     ])\n-  ]\n+(define_expand \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"\"))\n+                 (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"\"))))\n+   (clobber (reg:CC CC_REG))]\n   \"\"\n-  \"\")\n+{\n+  emit_insn (gen_umulsidi3_internal (gen_lowpart (SImode, operands[0]),\n+\t\t\t\t     gen_highpart (SImode, operands[0]),\n+\t\t\t\t     operands[1], operands[2]));\n+  DONE;\n+})\n \n-(define_insn \"*am33_mulsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=dx,!dax\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dx,daxi\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n-  \"TARGET_AM33\"\n-  \"*\n+(define_insn \"umulsidi3_internal\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=D,r\")\n+\t(mult:SI (match_operand:SI 2 \"register_operand\" \"%0,r\")\n+\t\t (match_operand:SI 3 \"register_operand\" \" D,r\")))\n+   (set (match_operand:SI          1 \"register_operand\" \"=z,r\")\n+\t(truncate:SI\n+\t  (lshiftrt:DI\n+\t    (mult:DI (zero_extend:DI (match_dup 2))\n+\t\t     (zero_extend:DI (match_dup 3)))\n+\t    (const_int 32))))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n {\n-  if (TARGET_MULT_BUG)\n-    return \\\"nop\\;nop\\;mul %2,%0\\\";\n+  if (which_alternative == 1)\n+    return \"mulu %2,%3,%1,%0\";\n+  else if (TARGET_MULT_BUG)\n+    return \"nop\\;nop\\;mulu %3,%0\";\n   else\n-    return \\\"mul %2,%0\\\";\n-}\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 24) (const_int 23)))]\n+    return \"mulu %3,%0\";\n+}\n+  [(set_attr \"isa\" \"*,am33\")\n+   (set (attr \"timings\")\n+        (if_then_else (eq_attr \"cpu\" \"am34\") (const_int 24) (const_int 23)))]\n )\n \n-(define_insn \"*mn10300_mulsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"dx\")))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+(define_expand \"mulsi3\"\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\"  \"\")\n+\t\t   (mult:SI (match_operand:SI 1 \"register_operand\"  \"\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+\t      (clobber (match_scratch:SI      3 \"\"))\n+\t      (clobber (reg:CC CC_REG))])]\n   \"\"\n-  \"*\n-{\n-  if (TARGET_MULT_BUG)\n-    return \\\"nop\\;nop\\;mul %2,%0\\\";\n-  else\n-    return \\\"mul %2,%0\\\";\n-}\"\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-  \t      \t\t \t       (const_int 24) (const_int 23)))]\n )\n \n-;; ??? This pattern causes too-high register pressure for MN103.\n-;; ??? To be fixed by exposing the MDR register properly.\n-(define_insn \"udivmodsi4\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=D\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"D\")))\n-   (set (match_operand:SI          3 \"register_operand\" \"=&d\")\n-\t(umod:SI (match_dup 1) (match_dup 2)))\n+(define_insn \"*mulsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=D, r,r\")\n+\t(mult:SI (match_operand:SI 2 \"register_operand\"  \"%0, 0,r\")\n+\t\t (match_operand:SI 3 \"nonmemory_operand\" \" D,ri,r\")))\n+   (clobber (match_scratch:SI      1                     \"=z, z,r\"))\n    (clobber (reg:CC CC_REG))]\n-  \"TARGET_AM33\"\n+  \"\"\n {\n-  output_asm_insn (\"clr %3\\;ext %3\", operands);\n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \"divu %2,%0\";\n+  if (which_alternative == 2)\n+    return \"mul %2,%3,%1,%0\";\n+  else if (TARGET_MULT_BUG)\n+    return \"nop\\;nop\\;mul %3,%0\";\n   else\n-    return \"divu %2,%0\\;mov mdr,%3\";\n+    return \"mul %3,%0\";\n }\n-  ;; Timings:  AM33   AM34\n-  ;;  SUB       1/1    1/1\n-  ;;  MOV       1/1    1/1\n-  ;;  DIVU     38/39  42/43\n-  ;;  MOV       1/1    1/1\n-  ;;  --------------------\n-  ;;  total    41/42  45/46  (worst case sceanario)\n-  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-  \t      \t\t \t       (const_int 4546) (const_int 4142)))]\n+  [(set_attr \"isa\" \"*,am33,am33\")\n+   (set (attr \"timings\")\n+\t(if_then_else (eq_attr \"cpu\" \"am34\") (const_int 24) (const_int 23)))]\n )\n \n-;; ??? In the meantime MN103 can use these two patterns,\n-;; which reduce the register pressure by one.\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=&d\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n-   (clobber (reg:CC CC_REG))]\n-  \"!TARGET_AM33\"\n-  \"clr %0\\;ext %0\\;mov %1,%0\\;divu %2,%0\"\n-  [(set_attr \"timings\" \"4142\")]\n+(define_expand \"udivmodsi4\"\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n+\t\t   (udiv:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\")))\n+\t      (set (match_operand:SI          3 \"register_operand\")\n+\t\t   (umod:SI (match_dup 1) (match_dup 2)))\n+\t      (use (const_int 0))\n+\t      (clobber (reg:CC CC_REG))])]\n+  \"\"\n )\n \n-(define_insn \"umodsi3\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=&d\")\n-\t(umod:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n+;; Note the trick to get reload to put the zero into the MDR register,\n+;; rather than exposing the load early and letting CSE or someone try\n+;; to share the zeros between division insns.  Which tends to result\n+;; in sequences like 0->r0->d0->mdr.\n+\n+(define_insn \"*udivmodsi4\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=D\")\n+\t(udiv:SI (match_operand:SI 2 \"register_operand\" \" 0\")\n+\t\t (match_operand:SI 3 \"register_operand\" \" D\")))\n+   (set (match_operand:SI          1 \"register_operand\" \"=z\")\n+\t(umod:SI (match_dup 2) (match_dup 3)))\n+   (use (match_operand:SI          4 \"nonmemory_operand\" \" 1\"))\n    (clobber (reg:CC CC_REG))]\n-  \"!TARGET_AM33\"\n-  \"clr %0\\;ext %0\\;mov %1,%0\\;divu %2,%0\\;mov mdr,%0\"\n-  [(set_attr \"timings\" \"4142\")]\n+  \"\"\n+  \"divu %3,%0\"\n+  [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n+  \t      \t\t \t       (const_int 3839) (const_int 4243)))]\n )\n \n-(define_insn \"divmodsi4\"\n-  [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n-\t(div:SI (match_operand:SI  1 \"register_operand\"  \"0\")\n-\t\t (match_operand:SI 2 \"register_operand\"  \"dx\")))\n-   (set (match_operand:SI          3 \"register_operand\" \"=d\")\n-\t(mod:SI (match_dup 1) (match_dup 2)))\n-   (clobber (reg:CC CC_REG))\n-  ]\n+(define_expand \"divmodsi4\"\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\" \"\")\n+\t\t   (div:SI (match_operand:SI  1 \"register_operand\" \"\")\n+\t\t\t   (match_operand:SI  2 \"register_operand\" \"\")))\n+\t      (set (match_operand:SI          3 \"register_operand\" \"\")\n+\t\t   (mod:SI (match_dup 1) (match_dup 2)))\n+\t      (use (match_dup 4))\n+\t      (clobber (reg:CC CC_REG))])]\n   \"\"\n-  \"*\n {\n-  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n-    return \\\"ext %0\\;div %2,%0\\\";\n-  else\n-    return \\\"ext %0\\;div %2,%0\\;mov mdr,%3\\\";\n-}\"\n-  ;; Timings:  AM33   AM34\n-  ;;  EXT       1/1    1/1\n-  ;;  DIV      38/39  42/43\n-  ;;  --------------------\n-  ;;  total    39/40  43/44  (worst case sceanario)\n+  operands[4] = gen_reg_rtx (SImode);\n+  emit_insn (gen_ext_internal (operands[4], operands[1]));\n+})\n+\n+;; ??? Ideally we'd represent this via shift, but it seems like adding a\n+;; special-case pattern for (ashiftrt x 31) is just as likely to result\n+;; in poor register allocation choices.\n+(define_insn \"ext_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"D\")] UNSPEC_EXT))]\n+  \"\"\n+  \"ext %1\"\n+)\n+\n+(define_insn \"*divmodsi4\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=D\")\n+\t(div:SI (match_operand:SI  2 \"register_operand\" \" 0\")\n+\t\t(match_operand:SI  3 \"register_operand\" \" D\")))\n+   (set (match_operand:SI          1 \"register_operand\" \"=z\")\n+\t(mod:SI (match_dup 2) (match_dup 3)))\n+   (use (match_operand:SI          4 \"register_operand\" \" 1\"))\n+   (clobber (reg:CC CC_REG))]\n+  \"\"\n+  \"div %3,%0\";\n   [(set (attr \"timings\") (if_then_else (eq_attr \"cpu\" \"am34\")\n-  \t      \t\t \t       (const_int 4344) (const_int 3940)))]\n+  \t      \t\t \t       (const_int 3839) (const_int 4243)))]\n )\n \n \f"}]}