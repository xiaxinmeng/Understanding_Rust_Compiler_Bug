{"sha": "11d10beb5762c48de90a004368df2c2863b33d7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFkMTBiZWI1NzYyYzQ4ZGU5MGEwMDQzNjhkZjJjMjg2M2IzM2Q3YQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2017-02-01T11:41:48Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2017-02-01T11:41:48Z"}, "message": "PR libstdc++/79254 simplify exception-safety in copy assignment\n\n\tPR libstdc++/79254\n\t* config/abi/pre/gnu.ver: Remove recently added symbols.\n\t* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI]\n\t(basic_string::_M_copy_assign): Remove.\n\t(basic_string::operator=(const basic_string&)): Don't dispatch to\n\t_M_copy_assign. If source object is small just deallocate, otherwise\n\tperform new allocation before making any changes.\n\t* include/bits/basic_string.tcc [_GLIBCXX_USE_CXX11_ABI]\n\t(basic_string::_M_copy_assign(const basic_string&, true_type)):\n\tRemove.\n\t* testsuite/21_strings/basic_string/allocator/char/copy_assign.cc:\n\tTest cases where the allocators are equal or the string is small.\n\t* testsuite/21_strings/basic_string/allocator/wchar_t/copy_assign.cc:\n\tLikewise.\n\nFrom-SVN: r245085", "tree": {"sha": "aab5154423488af538040a2d8a5b37c2dcb566bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aab5154423488af538040a2d8a5b37c2dcb566bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11d10beb5762c48de90a004368df2c2863b33d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d10beb5762c48de90a004368df2c2863b33d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11d10beb5762c48de90a004368df2c2863b33d7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d10beb5762c48de90a004368df2c2863b33d7a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0deb9925478be3738a87f40902c829d867f8f79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0deb9925478be3738a87f40902c829d867f8f79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0deb9925478be3738a87f40902c829d867f8f79"}], "stats": {"total": 146, "additions": 65, "deletions": 81}, "files": [{"sha": "979ded4aeab17e33c3089a3639775dc063bfa8ff", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=11d10beb5762c48de90a004368df2c2863b33d7a", "patch": "@@ -1,3 +1,20 @@\n+2017-02-01  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/79254\n+\t* config/abi/pre/gnu.ver: Remove recently added symbols.\n+\t* include/bits/basic_string.h [_GLIBCXX_USE_CXX11_ABI]\n+\t(basic_string::_M_copy_assign): Remove.\n+\t(basic_string::operator=(const basic_string&)): Don't dispatch to\n+\t_M_copy_assign. If source object is small just deallocate, otherwise\n+\tperform new allocation before making any changes.\n+\t* include/bits/basic_string.tcc [_GLIBCXX_USE_CXX11_ABI]\n+\t(basic_string::_M_copy_assign(const basic_string&, true_type)):\n+\tRemove.\n+\t* testsuite/21_strings/basic_string/allocator/char/copy_assign.cc:\n+\tTest cases where the allocators are equal or the string is small.\n+\t* testsuite/21_strings/basic_string/allocator/wchar_t/copy_assign.cc:\n+\tLikewise.\n+\n 2017-01-30  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement LWG 2825, LWG 2756 breaks class template argument"}, {"sha": "268fb9479a9e6475b77b884768b3141beafb695f", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=11d10beb5762c48de90a004368df2c2863b33d7a", "patch": "@@ -1955,9 +1955,6 @@ GLIBCXX_3.4.23 {\n     _ZNSsC[12]ERKSs[jmy]RKSaIcE;\n     _ZNSbIwSt11char_traitsIwESaIwEEC[12]ERKS2_mRKS1_;\n \n-    # basic_string<C, T, A>::_M_copy_assign(const basic_string&, {true,false}_type)\n-    _ZNSt7__cxx1112basic_stringI[cw]St11char_traitsI[cw]ESaI[cw]EE14_M_copy_assign*;\n-\n #ifndef HAVE_EXCEPTION_PTR_SINCE_GCC46\n     # std::future symbols are exported in the first version to support\n     # std::exception_ptr"}, {"sha": "981ffc5984a5adc9fdc1e3d7cdd04485cd361035", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=11d10beb5762c48de90a004368df2c2863b33d7a", "patch": "@@ -393,15 +393,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       void\n       _M_erase(size_type __pos, size_type __n);\n \n-#if __cplusplus >= 201103L\n-      void\n-      _M_copy_assign(const basic_string& __str, /* pocca = */ true_type);\n-\n-      void\n-      _M_copy_assign(const basic_string& __str, /* pocca = */ false_type)\n-      { this->_M_assign(__str); }\n-#endif\n-\n     public:\n       // Construct/copy/destroy:\n       // NB: We overload ctors in some cases instead of using default\n@@ -636,12 +627,35 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       operator=(const basic_string& __str)\n       {\n #if __cplusplus >= 201103L\n-\t_M_copy_assign(__str,\n-\t    typename _Alloc_traits::propagate_on_container_copy_assignment());\n-#else\n-\tthis->_M_assign(__str);\n+\tif (_Alloc_traits::_S_propagate_on_copy_assign())\n+\t  {\n+\t    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()\n+\t\t&& _M_get_allocator() != __str._M_get_allocator())\n+\t      {\n+\t\t// Propagating allocator cannot free existing storage so must\n+\t\t// deallocate it before replacing current allocator.\n+\t\tif (__str.size() <= _S_local_capacity)\n+\t\t  {\n+\t\t    _M_destroy(_M_allocated_capacity);\n+\t\t    _M_data(_M_local_data());\n+\t\t    _M_set_length(0);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    const auto __len = __str.size();\n+\t\t    auto __alloc = __str._M_get_allocator();\n+\t\t    // If this allocation throws there are no effects:\n+\t\t    auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);\n+\t\t    _M_destroy(_M_allocated_capacity);\n+\t\t    _M_data(__ptr);\n+\t\t    _M_capacity(__len);\n+\t\t    _M_set_length(__len);\n+\t\t  }\n+\t      }\n+\t    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());\n+\t  }\n #endif\n-\treturn *this;\n+\treturn this->assign(__str);\n       }\n \n       /**"}, {"sha": "41b7fa196b0be530325b3faab5d627ca09c46042", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=11d10beb5762c48de90a004368df2c2863b33d7a", "patch": "@@ -275,70 +275,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-#if __cplusplus >= 201103L\n-  template<typename _CharT, typename _Traits, typename _Alloc>\n-    void\n-    basic_string<_CharT, _Traits, _Alloc>::\n-    _M_copy_assign(const basic_string& __str, true_type)\n-    {\n-      struct _Guard // RAII type for strong exception-safety guarantee.\n-      {\n-\t// Takes ownership of string's original state.\n-\t_Guard(basic_string* __self)\n-\t: _M_self(__self), _M_alloc(std::move(__self->_M_get_allocator())),\n-\t  _M_ptr(__self->_M_data()),\n-\t  _M_capacity(__self->_M_allocated_capacity), _M_len(__self->length())\n-\t{\n-\t  __self->_M_data(__self->_M_local_data());\n-\t  __self->_M_length(0);\n-\t}\n-\n-\t// Restores string's original state if _M_release() was not called.\n-\t~_Guard()\n-\t{\n-\t  if (_M_ptr)\n-\t    {\n-\t      _M_self->_M_get_allocator() = std::move(_M_alloc);\n-\t      _M_self->_M_data(_M_ptr);\n-\t      _M_self->_M_capacity(_M_capacity);\n-\t      _M_self->_M_length(_M_len);\n-\t    }\n-\t}\n-\n-\t_Guard(const _Guard&) = delete;\n-\t_Guard& operator=(const _Guard&) = delete;\n-\n-\tvoid _M_release()\n-\t{\n-\t  // Original state can be freed now.\n-\t  _Alloc_traits::deallocate(_M_alloc, _M_ptr, _M_capacity + 1);\n-\t  _M_ptr = nullptr;\n-\t}\n-\n-\tbasic_string*\t_M_self;\n-\tallocator_type\t_M_alloc;\n-\tpointer\t\t_M_ptr;\n-\tsize_type\t_M_capacity;\n-\tsize_type\t_M_len;\n-      };\n-\n-      if (!_Alloc_traits::_S_always_equal() && !_M_is_local()\n-\t  && _M_get_allocator() != __str._M_get_allocator())\n-\t{\n-\t  // The propagating allocator cannot free existing storage.\n-\t  _Guard __guard(this);\n-\t  _M_get_allocator() = __str._M_get_allocator();\n-\t  this->_M_assign(__str);\n-\t  __guard._M_release();\n-\t}\n-      else\n-\t{\n-\t  _M_get_allocator() = __str._M_get_allocator();\n-\t  this->_M_assign(__str);\n-\t}\n-    }\n-#endif\n-\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     basic_string<_CharT, _Traits, _Alloc>::"}, {"sha": "bea221dd8e21147b6767e051d9b26b472cae04a1", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/allocator/char/copy_assign.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fchar%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fchar%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fchar%2Fcopy_assign.cc?ref=11d10beb5762c48de90a004368df2c2863b33d7a", "patch": "@@ -121,6 +121,16 @@ void test03()\n   VERIFY( caught );\n   VERIFY( v1 == s1 );\n   VERIFY( v1.get_allocator() == a1 );\n+\n+  throw_alloc::set_limit(1); // Allow one more allocation (and no more).\n+  test_type v3(s1, a1);\n+  // No allocation when allocators are equal and capacity is sufficient:\n+  VERIFY( v1.capacity() >= v3.size() );\n+  v1 = v3;\n+  // No allocation when the contents fit in the small-string buffer:\n+  v2 = \"sso\";\n+  v1 = v2;\n+  VERIFY( v1.get_allocator() == a2 );\n }\n \n int main()"}, {"sha": "e83c4c5e193b665a77153bec54fc4bac158a53b6", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/allocator/wchar_t/copy_assign.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fwchar_t%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d10beb5762c48de90a004368df2c2863b33d7a/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fwchar_t%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fwchar_t%2Fcopy_assign.cc?ref=11d10beb5762c48de90a004368df2c2863b33d7a", "patch": "@@ -121,6 +121,16 @@ void test03()\n   VERIFY( caught );\n   VERIFY( v1 == s1 );\n   VERIFY( v1.get_allocator() == a1 );\n+\n+  throw_alloc::set_limit(1); // Allow one more allocation (and no more).\n+  test_type v3(s1, a1);\n+  // No allocation when allocators are equal and capacity is sufficient:\n+  VERIFY( v1.capacity() >= v3.size() );\n+  v1 = v3;\n+  // No allocation when the contents fit in the small-string buffer:\n+  v2 = L\"sso\";\n+  v1 = v2;\n+  VERIFY( v1.get_allocator() == a2 );\n }\n \n int main()"}]}