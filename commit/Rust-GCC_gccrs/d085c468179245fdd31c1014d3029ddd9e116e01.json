{"sha": "d085c468179245fdd31c1014d3029ddd9e116e01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4NWM0NjgxNzkyNDVmZGQzMWMxMDE0ZDMwMjlkZGQ5ZTExNmUwMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2015-11-18T12:26:43Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2015-11-18T12:26:43Z"}, "message": "regrename.h (struct du_head): Add target_data_1 and target_data_2 fields.\n\n\t* regrename.h (struct du_head): Add target_data_1 and target_data_2\n\tfields.\n\t* regrename.c (create_new_chain): Clear entire struct after allocating.\n\n\t* config/i386/i386.opt (mmitigate-rop): New option.\n\t* doc/invoke.texi (mmitigate-rop): Document.\n\t* config/i386/i386.c: Include \"regrename.h\".\n\t(ix86_rop_should_change_byte_p, reg_encoded_number,\n\tix86_get_modrm_for_rop, set_rop_modrm_reg_bits, ix86_mitigate_rop): New\n\tstatic functions.\n\t(ix86_reorg): Call ix86_mitigate_rop if -fmitigate-rop.\n\t* config/i386/i386.md (attr \"modrm_class\"): New.\n\t(cmp<mode>_ccno_1, mov<mode>_xor, movstrict<mode>_xor,\n\tx86_mov<mode>cc_0_m1. x86_mov<mode>cc_0_m1_se)\n\t(x86_mov<mode>cc_0_m1_neg): Override modrm_class attribute.\n\nFrom-SVN: r230543", "tree": {"sha": "cecf7a6e31ae97795e1eef1f83c8bb4b39867e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cecf7a6e31ae97795e1eef1f83c8bb4b39867e0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d085c468179245fdd31c1014d3029ddd9e116e01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d085c468179245fdd31c1014d3029ddd9e116e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d085c468179245fdd31c1014d3029ddd9e116e01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d085c468179245fdd31c1014d3029ddd9e116e01/comments", "author": null, "committer": null, "parents": [{"sha": "98f84050d6e2dd79bf85a1876f3f9ebae41bf926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f84050d6e2dd79bf85a1876f3f9ebae41bf926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f84050d6e2dd79bf85a1876f3f9ebae41bf926"}], "stats": {"total": 376, "additions": 371, "deletions": 5}, "files": [{"sha": "abf01d336f75fcebcea889144af59a491c0372db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -1,3 +1,21 @@\n+2015-11-18  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\t* regrename.h (struct du_head): Add target_data_1 and target_data_2\n+\tfields.\n+\t* regrename.c (create_new_chain): Clear entire struct after allocating.\n+\n+\t* config/i386/i386.opt (mmitigate-rop): New option.\n+\t* doc/invoke.texi (mmitigate-rop): Document.\n+\t* config/i386/i386.c: Include \"regrename.h\".\n+\t(ix86_rop_should_change_byte_p, reg_encoded_number,\n+\tix86_get_modrm_for_rop, set_rop_modrm_reg_bits, ix86_mitigate_rop): New\n+\tstatic functions.\n+\t(ix86_reorg): Call ix86_mitigate_rop if -fmitigate-rop.\n+\t* config/i386/i386.md (attr \"modrm_class\"): New.\n+\t(cmp<mode>_ccno_1, mov<mode>_xor, movstrict<mode>_xor,\n+\tx86_mov<mode>cc_0_m1. x86_mov<mode>cc_0_m1_se)\n+\t(x86_mov<mode>cc_0_m1_neg): Override modrm_class attribute.\n+\n 2015-11-18  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \tPR target/68405"}, {"sha": "83749d59f3eabe0ec015d10300096e1c005520f4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -74,6 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-chkp.h\"\n #include \"dbgcnt.h\"\n #include \"case-cfn-macros.h\"\n+#include \"regrename.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -3974,6 +3975,15 @@ ix86_debug_options (void)\n   return;\n }\n \n+/* Return true if T is one of the bytes we should avoid with\n+   -fmitigate-rop.  */\n+\n+static bool\n+ix86_rop_should_change_byte_p (int t)\n+{\n+  return t == 0xc2 || t == 0xc3 || t == 0xca || t == 0xcb;\n+}\n+\n static const char *stringop_alg_names[] = {\n #define DEF_ENUM\n #define DEF_ALG(alg, name) #name,\n@@ -27303,6 +27313,100 @@ ix86_instantiate_decls (void)\n       instantiate_decl_rtl (s->rtl);\n }\n \f\n+/* Return the number used for encoding REG, in the range 0..7.  */\n+\n+static int\n+reg_encoded_number (rtx reg)\n+{\n+  unsigned regno = REGNO (reg);\n+  switch (regno)\n+    {\n+    case AX_REG:\n+      return 0;\n+    case CX_REG:\n+      return 1;\n+    case DX_REG:\n+      return 2;\n+    case BX_REG:\n+      return 3;\n+    case SP_REG:\n+      return 4;\n+    case BP_REG:\n+      return 5;\n+    case SI_REG:\n+      return 6;\n+    case DI_REG:\n+      return 7;\n+    default:\n+      break;\n+    }\n+  if (IN_RANGE (regno, FIRST_STACK_REG, LAST_STACK_REG))\n+    return regno - FIRST_STACK_REG;\n+  if (IN_RANGE (regno, FIRST_SSE_REG, LAST_SSE_REG))\n+    return regno - FIRST_SSE_REG;\n+  if (IN_RANGE (regno, FIRST_MMX_REG, LAST_MMX_REG))\n+    return regno - FIRST_MMX_REG;\n+  if (IN_RANGE (regno, FIRST_REX_SSE_REG, LAST_REX_SSE_REG))\n+    return regno - FIRST_REX_SSE_REG;\n+  if (IN_RANGE (regno, FIRST_REX_INT_REG, LAST_REX_INT_REG))\n+    return regno - FIRST_REX_INT_REG;\n+  if (IN_RANGE (regno, FIRST_MASK_REG, LAST_MASK_REG))\n+    return regno - FIRST_MASK_REG;\n+  if (IN_RANGE (regno, FIRST_BND_REG, LAST_BND_REG))\n+    return regno - FIRST_BND_REG;\n+  return -1;\n+}\n+\n+/* Given an insn INSN with NOPERANDS OPERANDS, return the modr/m byte used\n+   in its encoding if it could be relevant for ROP mitigation, otherwise\n+   return -1.  If POPNO0 and POPNO1 are nonnull, store the operand numbers\n+   used for calculating it into them.  */\n+\n+static int\n+ix86_get_modrm_for_rop (rtx_insn *insn, rtx *operands, int noperands,\n+\t\t\tint *popno0 = 0, int *popno1 = 0)\n+{\n+  if (asm_noperands (PATTERN (insn)) >= 0)\n+    return -1;\n+  int has_modrm = get_attr_modrm (insn);\n+  if (!has_modrm)\n+    return -1;\n+  enum attr_modrm_class cls = get_attr_modrm_class (insn);\n+  rtx op0, op1;\n+  switch (cls)\n+    {\n+    case MODRM_CLASS_OP02:\n+      gcc_assert (noperands >= 3);\n+      if (popno0)\n+\t{\n+\t  *popno0 = 0;\n+\t  *popno1 = 2;\n+\t}\n+      op0 = operands[0];\n+      op1 = operands[2];\n+      break;\n+    case MODRM_CLASS_OP01:\n+      gcc_assert (noperands >= 2);\n+      if (popno0)\n+\t{\n+\t  *popno0 = 0;\n+\t  *popno1 = 1;\n+\t}\n+      op0 = operands[0];\n+      op1 = operands[1];\n+      break;\n+    default:\n+      return -1;\n+    }\n+  if (REG_P (op0) && REG_P (op1))\n+    {\n+      int enc0 = reg_encoded_number (op0);\n+      int enc1 = reg_encoded_number (op1);\n+      return 0xc0 + (enc1 << 3) + enc0;\n+    }\n+  return -1;\n+}\n+\n /* Check whether x86 address PARTS is a pc-relative address.  */\n \n static bool\n@@ -45098,6 +45202,215 @@ ix86_seh_fixup_eh_fallthru (void)\n     }\n }\n \n+/* Given a register number BASE, the lowest of a group of registers, update\n+   regsets IN and OUT with the registers that should be avoided in input\n+   and output operands respectively when trying to avoid generating a modr/m\n+   byte for -fmitigate-rop.  */\n+\n+static void\n+set_rop_modrm_reg_bits (int base, HARD_REG_SET &in, HARD_REG_SET &out)\n+{\n+  SET_HARD_REG_BIT (out, base);\n+  SET_HARD_REG_BIT (out, base + 1);\n+  SET_HARD_REG_BIT (in, base + 2);\n+  SET_HARD_REG_BIT (in, base + 3);\n+}\n+\n+/* Called if -fmitigate_rop is in effect.  Try to rewrite instructions so\n+   that certain encodings of modr/m bytes do not occur.  */\n+static void\n+ix86_mitigate_rop (void)\n+{\n+  HARD_REG_SET input_risky;\n+  HARD_REG_SET output_risky;\n+  HARD_REG_SET inout_risky;\n+\n+  CLEAR_HARD_REG_SET (output_risky);\n+  CLEAR_HARD_REG_SET (input_risky);\n+  SET_HARD_REG_BIT (output_risky, AX_REG);\n+  SET_HARD_REG_BIT (output_risky, CX_REG);\n+  SET_HARD_REG_BIT (input_risky, BX_REG);\n+  SET_HARD_REG_BIT (input_risky, DX_REG);\n+  set_rop_modrm_reg_bits (FIRST_SSE_REG, input_risky, output_risky);\n+  set_rop_modrm_reg_bits (FIRST_REX_INT_REG, input_risky, output_risky);\n+  set_rop_modrm_reg_bits (FIRST_REX_SSE_REG, input_risky, output_risky);\n+  set_rop_modrm_reg_bits (FIRST_EXT_REX_SSE_REG, input_risky, output_risky);\n+  set_rop_modrm_reg_bits (FIRST_MASK_REG, input_risky, output_risky);\n+  set_rop_modrm_reg_bits (FIRST_BND_REG, input_risky, output_risky);\n+  COPY_HARD_REG_SET (inout_risky, input_risky);\n+  IOR_HARD_REG_SET (inout_risky, output_risky);\n+\n+  compute_bb_for_insn ();\n+  df_note_add_problem ();\n+  df_analyze ();\n+\n+  regrename_init (true);\n+  regrename_analyze (NULL);\n+\n+  auto_vec<du_head_p> cands;\n+  \n+  for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      if (GET_CODE (PATTERN (insn)) == USE\n+\t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\tcontinue;\n+\n+      extract_insn (insn);\n+\n+      int opno0, opno1;\n+      int modrm = ix86_get_modrm_for_rop (insn, recog_data.operand,\n+\t\t\t\t\t  recog_data.n_operands, &opno0,\n+\t\t\t\t\t  &opno1);\n+\n+      if (!ix86_rop_should_change_byte_p (modrm))\n+\tcontinue;\n+\n+      insn_rr_info *info = &insn_rr[INSN_UID (insn)];\n+\n+      /* This happens when regrename has to fail a block.  */\n+      if (!info->op_info)\n+\tcontinue;\n+\n+      if (info->op_info[opno0].n_chains != 0)\n+\t{\n+\t  gcc_assert (info->op_info[opno0].n_chains == 1);\n+\t  du_head_p op0c;\n+\t  op0c = regrename_chain_from_id (info->op_info[opno0].heads[0]->id);\n+\t  if (op0c->target_data_1 + op0c->target_data_2 == 0\n+\t      && !op0c->cannot_rename)\n+\t    cands.safe_push (op0c);\n+\n+\t  op0c->target_data_1++;\n+\t}\n+      if (info->op_info[opno1].n_chains != 0)\n+\t{\n+\t  gcc_assert (info->op_info[opno1].n_chains == 1);\n+\t  du_head_p op1c;\n+\t  op1c = regrename_chain_from_id (info->op_info[opno1].heads[0]->id);\n+\t  if (op1c->target_data_1 + op1c->target_data_2 == 0\n+\t      && !op1c->cannot_rename)\n+\t    cands.safe_push (op1c);\n+\n+\t  op1c->target_data_2++;\n+\t}\n+    }\n+\n+  int i;\n+  du_head_p head;\n+  FOR_EACH_VEC_ELT (cands, i, head)\n+    {\n+      int old_reg, best_reg;\n+      HARD_REG_SET unavailable;\n+\n+      CLEAR_HARD_REG_SET (unavailable);\n+      if (head->target_data_1)\n+\tIOR_HARD_REG_SET (unavailable, output_risky);\n+      if (head->target_data_2)\n+\tIOR_HARD_REG_SET (unavailable, input_risky);\n+\n+      int n_uses;\n+      reg_class superclass = regrename_find_superclass (head, &n_uses,\n+\t\t\t\t\t\t\t&unavailable);\n+      old_reg = head->regno;\n+      best_reg = find_rename_reg (head, superclass, &unavailable,\n+\t\t\t\t  old_reg, false);\n+      bool ok = regrename_do_replace (head, best_reg);\n+      gcc_assert (ok);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Chain %d renamed as %s in %s\\n\", head->id,\n+\t\t reg_names[best_reg], reg_class_names[superclass]);\n+\n+    }\n+  \n+  regrename_finish ();\n+\n+  df_analyze ();\n+\n+  basic_block bb;\n+  regset_head live;\n+\n+  INIT_REG_SET (&live);\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      rtx_insn *insn;\n+\n+      COPY_REG_SET (&live, DF_LR_OUT (bb));\n+      df_simulate_initialize_backwards (bb, &live);\n+\n+      FOR_BB_INSNS_REVERSE (bb, insn)\n+\t{\n+\t  if (!NONDEBUG_INSN_P (insn))\n+\t    continue;\n+\n+\t  df_simulate_one_insn_backwards (bb, insn, &live);\n+\n+\t  if (GET_CODE (PATTERN (insn)) == USE\n+\t      || GET_CODE (PATTERN (insn)) == CLOBBER)\n+\t    continue;\n+\n+\t  extract_insn (insn);\n+\t  constrain_operands_cached (insn, reload_completed);\n+\t  int opno0, opno1;\n+\t  int modrm = ix86_get_modrm_for_rop (insn, recog_data.operand,\n+\t\t\t\t\t      recog_data.n_operands, &opno0,\n+\t\t\t\t\t      &opno1);\n+\t  if (modrm < 0\n+\t      || !ix86_rop_should_change_byte_p (modrm)\n+\t      || opno0 == opno1)\n+\t    continue;\n+\n+\t  rtx oldreg = recog_data.operand[opno1];\n+\t  preprocess_constraints (insn);\n+\t  const operand_alternative *alt = which_op_alt ();\n+\n+\t  int i;\n+\t  for (i = 0; i < recog_data.n_operands; i++)\n+\t    if (i != opno1\n+\t\t&& alt[i].earlyclobber\n+\t\t&& reg_overlap_mentioned_p (recog_data.operand[i],\n+\t\t\t\t\t    oldreg))\n+\t      break;\n+\n+\t  if (i < recog_data.n_operands)\n+\t    continue;\n+\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"attempting to fix modrm byte in insn %d:\"\n+\t\t     \" reg %d class %s\", INSN_UID (insn), REGNO (oldreg),\n+\t\t     reg_class_names[alt[opno1].cl]);\n+\n+\t  HARD_REG_SET unavailable;\n+\t  REG_SET_TO_HARD_REG_SET (unavailable, &live);\n+\t  SET_HARD_REG_BIT (unavailable, REGNO (oldreg));\n+\t  IOR_COMPL_HARD_REG_SET (unavailable, call_used_reg_set);\n+\t  IOR_HARD_REG_SET (unavailable, fixed_reg_set);\n+\t  IOR_HARD_REG_SET (unavailable, output_risky);\n+\t  IOR_COMPL_HARD_REG_SET (unavailable,\n+\t\t\t\t  reg_class_contents[alt[opno1].cl]);\n+\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t      if (!TEST_HARD_REG_BIT (unavailable, i))\n+\t\tbreak;\n+\t  if (i == FIRST_PSEUDO_REGISTER)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \", none available\\n\");\n+\t      continue;\n+\t    }\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" -> %d\\n\", i);\n+\t  rtx newreg = gen_rtx_REG (recog_data.operand_mode[opno1], i);\n+\t  validate_change (insn, recog_data.operand_loc[opno1], newreg, false);\n+\t  insn = emit_insn_before (gen_move_insn (newreg, oldreg), insn);\n+\t}\n+    }\n+}\n+\n /* Implement machine specific optimizations.  We implement padding of returns\n    for K8 CPUs and pass to avoid 4 jumps in the single 16 byte window.  */\n static void\n@@ -45107,6 +45420,9 @@ ix86_reorg (void)\n      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */\n   compute_bb_for_insn ();\n \n+  if (flag_mitigate_rop)\n+    ix86_mitigate_rop ();\n+  \n   if (TARGET_SEH && current_function_has_exception_handlers ())\n     ix86_seh_fixup_eh_fallthru ();\n "}, {"sha": "39b058f82c742ab493ecde66f200e73fb29bcd94", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -637,6 +637,19 @@\n \t ]\n \t (const_int 1)))\n \n+(define_attr \"modrm_class\" \"none,incdec,op0,op01,op02,pushpop,unknown\"\n+  (cond [(eq_attr \"modrm\" \"0\")\n+\t   (const_string \"none\")\n+\t (eq_attr \"type\" \"alu,imul,ishift\")\n+\t   (const_string \"op02\")\n+\t (eq_attr \"type\" \"imov,imovx,lea,alu1,icmp\")\n+\t   (const_string \"op01\")\n+\t (eq_attr \"type\" \"incdec\")\n+\t   (const_string \"incdec\")\n+\t (eq_attr \"type\" \"push,pop\")\n+\t   (const_string \"pushpop\")]\n+\t (const_string \"unknown\")))\n+\n ;; The (bounding maximum) length of an instruction in bytes.\n ;; ??? fistp and frndint are in fact fldcw/{fistp,frndint}/fldcw sequences.\n ;; Later we may want to split them and compute proper length as for\n@@ -1235,6 +1248,7 @@\n    cmp{<imodesuffix>}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"test,icmp\")\n    (set_attr \"length_immediate\" \"0,1\")\n+   (set_attr \"modrm_class\" \"op0,unknown\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"*cmp<mode>_1\"\n@@ -1942,6 +1956,7 @@\n   \"reload_completed\"\n   \"xor{l}\\t%k0, %k0\"\n   [(set_attr \"type\" \"alu1\")\n+   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"mode\" \"SI\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -2713,6 +2728,7 @@\n   \"reload_completed\"\n   \"xor{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu1\")\n+   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"length_immediate\" \"0\")])\n \n@@ -16847,6 +16863,7 @@\n   ; Since we don't have the proper number of operands for an alu insn,\n   ; fill in all the blanks.\n   [(set_attr \"type\" \"alu\")\n+   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"use_carry\" \"1\")\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"memory\" \"none\")\n@@ -16864,6 +16881,7 @@\n   \"\"\n   \"sbb{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu\")\n+   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"use_carry\" \"1\")\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"memory\" \"none\")\n@@ -16879,6 +16897,7 @@\n   \"\"\n   \"sbb{<imodesuffix>}\\t%0, %0\"\n   [(set_attr \"type\" \"alu\")\n+   (set_attr \"modrm_class\" \"op0\")\n    (set_attr \"use_carry\" \"1\")\n    (set_attr \"pent_pair\" \"pu\")\n    (set_attr \"memory\" \"none\")"}, {"sha": "2723c22213b1b1a87718c48c765a1cf5ff12489d", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -889,3 +889,7 @@ Enum(stack_protector_guard) String(tls) Value(SSP_TLS)\n \n EnumValue\n Enum(stack_protector_guard) String(global) Value(SSP_GLOBAL)\n+\n+mmitigate-rop\n+Target Var(flag_mitigate_rop) Init(0)\n+Attempt to avoid generating instruction sequences containing ret bytes."}, {"sha": "7cef176fdc989c481186bf190ffd83b4dd855376", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -1116,7 +1116,8 @@ See RS/6000 and PowerPC Options.\n -m32 -m64 -mx32 -m16 -miamcu -mlarge-data-threshold=@var{num} @gol\n -msse2avx -mfentry -mrecord-mcount -mnop-mcount -m8bit-idiv @gol\n -mavx256-split-unaligned-load -mavx256-split-unaligned-store @gol\n--malign-data=@var{type} -mstack-protector-guard=@var{guard}}\n+-malign-data=@var{type} -mstack-protector-guard=@var{guard} @gol\n+-mmitigate-rop}\n \n @emph{x86 Windows Options}\n @gccoptlist{-mconsole -mcygwin -mno-cygwin -mdll @gol\n@@ -23708,6 +23709,13 @@ locations are @samp{global} for global canary or @samp{tls} for per-thread\n canary in the TLS block (the default).  This option has effect only when\n @option{-fstack-protector} or @option{-fstack-protector-all} is specified.\n \n+@item -mmitigate-rop\n+@opindex mmitigate-rop\n+Try to avoid generating code sequences that contain unintended return\n+opcodes, to mitigate against certain forms of attack. At the moment,\n+this option is limited in what it can do and should not be relied\n+on to provide serious protection.\n+\n @end table\n \n These @samp{-m} switches are supported in addition to the above"}, {"sha": "e2a1e83c7ea01fc59888dadf9a57f7fdc4ba5fca", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -227,13 +227,10 @@ create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n   struct du_chain *this_du;\n   int nregs;\n \n+  memset (head, 0, sizeof *head);\n   head->next_chain = open_chains;\n   head->regno = this_regno;\n   head->nregs = this_nregs;\n-  head->need_caller_save_reg = 0;\n-  head->cannot_rename = 0;\n-  head->renamed = 0;\n-  head->tied_chain = NULL;\n \n   id_to_chain.safe_push (head);\n   head->id = current_id++;"}, {"sha": "6fdaff1df24a5f6ad9afba02d9bdce89dd44f622", "filename": "gcc/regrename.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fregrename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d085c468179245fdd31c1014d3029ddd9e116e01/gcc%2Fregrename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.h?ref=d085c468179245fdd31c1014d3029ddd9e116e01", "patch": "@@ -49,6 +49,10 @@ struct du_head\n   unsigned int cannot_rename:1;\n   /* Nonzero if the chain has already been renamed.  */\n   unsigned int renamed:1;\n+\n+  /* Fields for use by target code.  */\n+  unsigned int target_data_1;\n+  unsigned int target_data_2;\n };\n \n typedef struct du_head *du_head_p;"}]}