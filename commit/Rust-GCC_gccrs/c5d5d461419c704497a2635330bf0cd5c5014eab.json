{"sha": "c5d5d461419c704497a2635330bf0cd5c5014eab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVkNWQ0NjE0MTljNzA0NDk3YTI2MzUzMzBiZjBjZDVjNTAxNGVhYg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-02-14T20:08:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-14T20:08:39Z"}, "message": "except.c (start_catch_handler): Use emit_cmp_and_jump_insns.\n\n        * except.c (start_catch_handler): Use emit_cmp_and_jump_insns.\n        * explow.c (probe_stack_range): Likewise.\n        * expmed.c (do_cmp_and_jump): Likewise.\n        * expr.c (store_expr, expand_expr, expand_builtin): Likewise.\n        (do_tablejump): Likewise.\n        * stmt.c (expand_expr_stmt, expand_end_case): Likewise.\n        (do_jump_if_equal, emit_case_nodes): Likewise.\n        * optabs.c (emit_cmp_and_jump_insns): Clarify comments.  If UNSIGNEDP,\n        then convert comparison to an unsigned code before emitting the jump.\n        (expand_float, expand_fix): Use emit_cmp_and_jump_insns.\n\nFrom-SVN: r25205", "tree": {"sha": "c29b256d986d0f06f6c18f5de1ad3725b91cd3e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c29b256d986d0f06f6c18f5de1ad3725b91cd3e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5d5d461419c704497a2635330bf0cd5c5014eab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d5d461419c704497a2635330bf0cd5c5014eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5d5d461419c704497a2635330bf0cd5c5014eab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5d5d461419c704497a2635330bf0cd5c5014eab/comments", "author": null, "committer": null, "parents": [{"sha": "d4ddd7b97734bcfa0aa968b50d9d3439d4f302c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ddd7b97734bcfa0aa968b50d9d3439d4f302c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ddd7b97734bcfa0aa968b50d9d3439d4f302c3"}], "stats": {"total": 219, "additions": 116, "deletions": 103}, "files": [{"sha": "a6e9718da520f9f66a42805215bb24d52a66c30a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -1,3 +1,16 @@\n+Sun Feb 14 21:03:28 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* except.c (start_catch_handler): Use emit_cmp_and_jump_insns.\n+\t* explow.c (probe_stack_range): Likewise.\n+\t* expmed.c (do_cmp_and_jump): Likewise.\n+\t* expr.c (store_expr, expand_expr, expand_builtin): Likewise.\n+\t(do_tablejump): Likewise.\n+\t* stmt.c (expand_expr_stmt, expand_end_case): Likewise.\n+\t(do_jump_if_equal, emit_case_nodes): Likewise.\n+\t* optabs.c (emit_cmp_and_jump_insns): Clarify comments.  If UNSIGNEDP,\n+\tthen convert comparison to an unsigned code before emitting the jump.\n+\t(expand_float, expand_fix): Use emit_cmp_and_jump_insns.\n+\n Sun Feb 14 02:24:15 PST 1999 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "ae8fea178ffd4286f09dfb3d8687c40cdb043a48", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -1767,9 +1767,9 @@ start_catch_handler (rtime)\n                                           0, SImode, 1, rtime_address, Pmode);\n \n       /* Did the function return true? */\n-      emit_cmp_insn (call_rtx, const0_rtx, EQ, NULL_RTX,\n-                                                GET_MODE (call_rtx), 0 ,0);\n-      emit_jump_insn (gen_beq (catchstack.top->entry->false_label));\n+      emit_cmp_and_jump_insns (call_rtx, const0_rtx, EQ, NULL_RTX,\n+                               GET_MODE (call_rtx), 0, 0,\n+\t\t\t       catchstack.top->entry->false_label);\n     }\n }\n "}, {"sha": "04c8b80f581799b2769b37775958d62dfb377db3", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -1445,8 +1445,8 @@ probe_stack_range (first, size)\n \tabort ();\n \n       emit_label (test_lab);\n-      emit_cmp_insn (test_addr, last_addr, CMP_OPCODE, NULL_RTX, Pmode, 1, 0);\n-      emit_jump_insn ((*bcc_gen_fctn[(int) CMP_OPCODE]) (loop_lab));\n+      emit_cmp_and_jump_insns (test_addr, last_addr, CMP_OPCODE,\n+\t\t\t       NULL_RTX, Pmode, 1, 0, loop_lab);\n       emit_jump (end_lab);\n       emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n       emit_label (end_lab);"}, {"sha": "cf3bbbd5a0d9667de9b8a88624471f65e6f9145b", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -4574,9 +4574,6 @@ do_cmp_and_jump (arg1, arg2, op, mode, label)\n     }\n   else\n     {\n-      emit_cmp_insn(arg1, arg2, op, NULL_RTX, mode, 0, 0);\n-      if (bcc_gen_fctn[(int) op] == 0)\n-\tabort ();\n-      emit_jump_insn ((*bcc_gen_fctn[(int) op]) (label));\n+      emit_cmp_and_jump_insns (arg1, arg2, op, NULL_RTX, mode, 0, 0, label);\n     }\n }"}, {"sha": "63d9155d8acabb86d04ddbb39fc4cd8eaa82fb14", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -3784,10 +3784,9 @@ store_expr (exp, target, want_value)\n \t\t\t\t       copy_size_rtx, NULL_RTX, 0,\n \t\t\t\t       OPTAB_LIB_WIDEN);\n \n-\t\t  emit_cmp_insn (size, const0_rtx, LT, NULL_RTX,\n-\t\t\t\t GET_MODE (size), 0, 0);\n \t\t  label = gen_label_rtx ();\n-\t\t  emit_jump_insn (gen_blt (label));\n+\t\t  emit_cmp_and_jump_insns (size, const0_rtx, LT, NULL_RTX,\n+\t\t\t\t\t   GET_MODE (size), 0, 0, label);\n \t\t}\n \n \t      if (size != const0_rtx)\n@@ -6653,17 +6652,15 @@ expand_expr (exp, target, tmode, modifier)\n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (lo_r) == CONST_INT))\n \t  {\n-\t    emit_cmp_insn (index_val, lo_r, LT, NULL_RTX,\n-\t\t\t   GET_MODE (index_val), iunsignedp, 0);\n-\t    emit_jump_insn (gen_blt (op1));\n+\t    emit_cmp_and_jump_insns (index_val, lo_r, LT, NULL_RTX,\n+\t\t\t\t     GET_MODE (index_val), iunsignedp, 0, op1);\n \t  }\n \n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (hi_r) == CONST_INT))\n \t  {\n-\t    emit_cmp_insn (index_val, hi_r, GT, NULL_RTX,\n-\t\t\t   GET_MODE (index_val), iunsignedp, 0);\n-\t    emit_jump_insn (gen_bgt (op1));\n+\t    emit_cmp_and_jump_insns (index_val, hi_r, GT, NULL_RTX,\n+\t\t\t\t     GET_MODE (index_val), iunsignedp, 0, op1);\n \t  }\n \n \t/* Calculate the element number of bit zero in the first word\n@@ -7361,9 +7358,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    temp = copy_to_reg (temp);\n \n \t  op1 = gen_label_rtx ();\n-\t  emit_cmp_insn (temp, const0_rtx, EQ, NULL_RTX,\n-\t\t\t GET_MODE (temp), unsignedp, 0);\n-\t  emit_jump_insn (gen_beq (op1));\n+\t  emit_cmp_and_jump_insns (temp, const0_rtx, EQ, NULL_RTX,\n+\t\t\t\t   GET_MODE (temp), unsignedp, 0, op1);\n \t  emit_move_insn (temp, const1_rtx);\n \t  emit_label (op1);\n \t  return temp;\n@@ -8709,8 +8705,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \t  /* Test the result; if it is NaN, set errno=EDOM because\n \t     the argument was not in the domain.  */\n-\t  emit_cmp_insn (target, target, EQ, 0, GET_MODE (target), 0, 0);\n-\t  emit_jump_insn (gen_beq (lab1));\n+\t  emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n+\t\t\t\t   0, 0, lab1);\n \n #ifdef TARGET_EDOM\n \t  {\n@@ -11562,8 +11558,8 @@ do_tablejump (index, mode, range, table_label, default_label)\n      or equal to the minimum value of the range and less than or equal to\n      the maximum value of the range.  */\n \n-  emit_cmp_insn (index, range, GTU, NULL_RTX, mode, 1, 0);\n-  emit_jump_insn (gen_bgtu (default_label));\n+  emit_cmp_and_jump_insns (index, range, GTU, NULL_RTX, mode, 1,\n+\t\t\t   0, default_label);\n \n   /* If index is in range, it must fit in Pmode.\n      Convert to Pmode so we can index with it.  */"}, {"sha": "1422793b3f3baf058b361c6f0764be99ef308688", "filename": "gcc/optabs.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -2941,16 +2941,18 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n    constant and Y is not a constant, then the comparison is swapped to\n    ensure that the comparison RTL has the canonical form.\n \n-   MODE is the mode of the inputs (in case they are const_int).\n-   UNSIGNEDP nonzero says that X and Y are unsigned;\n-   this matters if they need to be widened.\n+   UNSIGNEDP nonzero says that X and Y are unsigned; this matters if they\n+   need to be widened by emit_cmp_insn.  UNSIGNEDP is also used to select\n+   the proper branch condition code.\n \n-   If they have mode BLKmode, then SIZE specifies the size of both X and Y,\n-   and ALIGN specifies the known shared alignment of X and Y.\n+   If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y,\n+   and ALIGN specifies the known shared alignment of X and Y. \n \n-   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n-   It is ignored for fixed-point and block comparisons;\n-   it is used only for floating-point comparisons.  */\n+   MODE is the mode of the inputs (in case they are const_int).\n+\n+   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  It will\n+   be passed unchanged to emit_cmp_insn, then potentially converted into an\n+   unsigned variant based on UNSIGNEDP to select a proper jump instruction.  */\n \n void\n emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n@@ -2978,6 +2980,9 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n       op1 = y;\n     }\n   emit_cmp_insn (op0, op1, comparison, size, mode, unsignedp, align);\n+\n+  if (unsignedp)\n+    comparison = unsigned_condition (comparison);\n   emit_jump_insn ((*bcc_gen_fctn[(int) comparison]) (label));\n }\n \n@@ -3701,8 +3706,8 @@ expand_float (to, from, unsignedp)\n \t correct its value by 2**bitwidth.  */\n \n       do_pending_stack_adjust ();\n-      emit_cmp_insn (from, const0_rtx, GE, NULL_RTX, GET_MODE (from), 0, 0);\n-      emit_jump_insn (gen_bge (label));\n+      emit_cmp_and_jump_insns (from, const0_rtx, GE, NULL_RTX, GET_MODE (from),\n+\t\t\t        0, 0, label);\n \n       /* On SCO 3.2.1, ldexp rejects values outside [0.5, 1).\n \t Rather than setting up a dconst_dot_5, let's hope SCO\n@@ -3909,8 +3914,8 @@ expand_fix (to, from, unsignedp)\n \n \t  /* See if we need to do the subtraction.  */\n \t  do_pending_stack_adjust ();\n-\t  emit_cmp_insn (from, limit, GE, NULL_RTX, GET_MODE (from), 0, 0);\n-\t  emit_jump_insn (gen_bge (lab1));\n+\t  emit_cmp_and_jump_insns (from, limit, GE, NULL_RTX, GET_MODE (from),\n+\t\t\t\t   0, 0, lab1);\n \n \t  /* If not, do the signed \"fix\" and branch around fixup code.  */\n \t  expand_fix (to, from, 0);"}, {"sha": "8d4351ac3294a3bbf6d023737aba92b3784417ce", "filename": "gcc/stmt.c", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5d5d461419c704497a2635330bf0cd5c5014eab/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c5d5d461419c704497a2635330bf0cd5c5014eab", "patch": "@@ -1714,12 +1714,12 @@ expand_expr_stmt (exp)\n \t  rtx lab = gen_label_rtx ();\n \t  \n \t  /* Compare the value with itself to reference it.  */\n-\t  emit_cmp_insn (last_expr_value, last_expr_value, EQ,\n-\t\t\t expand_expr (TYPE_SIZE (last_expr_type),\n-\t\t\t\t      NULL_RTX, VOIDmode, 0),\n-\t\t\t BLKmode, 0,\n-\t\t\t TYPE_ALIGN (last_expr_type) / BITS_PER_UNIT);\n-\t  emit_jump_insn ((*bcc_gen_fctn[(int) EQ]) (lab));\n+\t  emit_cmp_and_jump_insns (last_expr_value, last_expr_value, EQ,\n+\t\t\t\t   expand_expr (TYPE_SIZE (last_expr_type),\n+\t\t\t\t\t\tNULL_RTX, VOIDmode, 0),\n+\t\t\t\t   BLKmode, 0,\n+\t\t\t\t   TYPE_ALIGN (last_expr_type) / BITS_PER_UNIT,\n+\t\t\t\t   lab);\n \t  emit_label (lab);\n \t}\n     }\n@@ -5188,8 +5188,8 @@ expand_end_case (orig_index)\n \t\t\t\t      index_expr, minval);\n \t\t  minval = integer_zero_node;\n \t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n-\t\t  emit_cmp_insn (rangertx, index, LTU, NULL_RTX, omode, 1, 0);\n-\t\t  emit_jump_insn (gen_bltu (default_label));\n+\t\t  emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n+\t\t\t\t\t   omode, 1, 0, default_label);\n \t\t  /* Now we can safely truncate.  */\n \t\t  index = convert_to_mode (index_mode, index, 0);\n \t\t}\n@@ -5358,8 +5358,8 @@ do_jump_if_equal (op1, op2, label, unsignedp)\n       enum machine_mode mode = GET_MODE (op1);\n       if (mode == VOIDmode)\n \tmode = GET_MODE (op2);\n-      emit_cmp_insn (op1, op2, EQ, NULL_RTX, mode, unsignedp, 0);\n-      emit_jump_insn (gen_beq (label));\n+      emit_cmp_and_jump_insns (op1, op2, EQ, NULL_RTX, mode, unsignedp,\n+\t\t\t       0, label);\n     }\n }\n \f\n@@ -5768,10 +5768,6 @@ emit_case_nodes (index, node, default_label, index_type)\n   /* If INDEX has an unsigned type, we must make unsigned branches.  */\n   int unsignedp = TREE_UNSIGNED (index_type);\n   typedef rtx rtx_fn ();\n-  rtx_fn *gen_bgt_pat = unsignedp ? gen_bgtu : gen_bgt;\n-  rtx_fn *gen_bge_pat = unsignedp ? gen_bgeu : gen_bge;\n-  rtx_fn *gen_blt_pat = unsignedp ? gen_bltu : gen_blt;\n-  rtx_fn *gen_ble_pat = unsignedp ? gen_bleu : gen_ble;\n   enum machine_mode mode = GET_MODE (index);\n \n   /* See if our parents have already tested everything for us.\n@@ -5797,20 +5793,19 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  if (node_is_bounded (node->right, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n-\n-\t      emit_jump_insn ((*gen_bgt_pat) (label_rtx (node->right->code_label)));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t        GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t\tlabel_rtx (node->right->code_label));\n \t      emit_case_nodes (index, node->left, default_label, index_type);\n \t    }\n \n \t  else if (node_is_bounded (node->left, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     LT, NULL_RTX, mode, unsignedp, 0);\n-\t      emit_jump_insn ((*gen_blt_pat) (label_rtx (node->left->code_label)));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       label_rtx (node->left->code_label));\n \t      emit_case_nodes (index, node->right, default_label, index_type);\n \t    }\n \n@@ -5823,10 +5818,10 @@ emit_case_nodes (index, node, default_label, index_type)\n \t\t= build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n \t      /* See if the value is on the right.  */\n-\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n-\t      emit_jump_insn ((*gen_bgt_pat) (label_rtx (test_label)));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       label_rtx (test_label));\n \n \t      /* Value must be on the left.\n \t\t Handle the left-hand subtree.  */\n@@ -5854,10 +5849,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t    {\n \t      if (!node_has_low_bound (node, index_type))\n \t\t{\n-\t\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t     VOIDmode, 0),\n-\t\t\t\t LT, NULL_RTX, mode, unsignedp, 0);\n-\t\t  emit_jump_insn ((*gen_blt_pat) (default_label));\n+\t\t  emit_cmp_and_jump_insns (index, expand_expr (node->high,\n+\t\t\t\t\t\t\t       NULL_RTX,\n+\t\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t\t\t\t   LT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t\t   default_label);\n \t\t}\n \n \t      emit_case_nodes (index, node->right, default_label, index_type);\n@@ -5894,10 +5890,11 @@ emit_case_nodes (index, node, default_label, index_type)\n \t    {\n \t      if (!node_has_high_bound (node, index_type))\n \t\t{\n-\t\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t     VOIDmode, 0),\n-\t\t\t\t GT, NULL_RTX, mode, unsignedp, 0);\n-\t\t  emit_jump_insn ((*gen_bgt_pat) (default_label));\n+\t\t  emit_cmp_and_jump_insns (index, expand_expr (node->high,\n+\t\t\t\t\t\t\t       NULL_RTX,\n+\t\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t\t\t\t   GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t\t   default_label);\n \t\t}\n \n \t      emit_case_nodes (index, node->left, default_label, index_type);\n@@ -5927,28 +5924,32 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     then handle the two subtrees.  */\n \t  tree test_label = 0;\n \n-\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t     VOIDmode, 0),\n-\t\t\t GT, NULL_RTX, mode, unsignedp, 0);\n \n \t  if (node_is_bounded (node->right, index_type))\n \t    /* Right hand node is fully bounded so we can eliminate any\n \t       testing and branch directly to the target code.  */\n-\t    emit_jump_insn ((*gen_bgt_pat) (label_rtx (node->right->code_label)));\n+\t    emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t\t     GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t     label_rtx (node->right->code_label));\n \t  else\n \t    {\n \t      /* Right hand node requires testing.\n \t\t Branch to a label where we will handle it later.  */\n \n \t      test_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t      emit_jump_insn ((*gen_bgt_pat) (label_rtx (test_label)));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       label_rtx (test_label));\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n-\t  emit_cmp_insn (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n-\t\t\t GE, NULL_RTX, mode, unsignedp, 0);\n-\t  emit_jump_insn ((*gen_bge_pat) (label_rtx (node->code_label)));\n+\t  emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t\t\t   GE, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t   label_rtx (node->code_label));\n \n \t  /* Handle the left-hand subtree.  */\n \t  emit_case_nodes (index, node->left, default_label, index_type);\n@@ -5972,18 +5973,18 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     if they are possible.  */\n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     LT, NULL_RTX, mode, unsignedp, 0);\n-\t      emit_jump_insn ((*gen_blt_pat) (default_label));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       default_label);\n \t    }\n \n \t  /* Value belongs to this node or to the right-hand subtree.  */\n \n-\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t     VOIDmode, 0),\n-\t\t\t LE, NULL_RTX, mode, unsignedp, 0);\n-\t  emit_jump_insn ((*gen_ble_pat) (label_rtx (node->code_label)));\n+\t  emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t\t\t   LE, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t   label_rtx (node->code_label));\n \n \t  emit_case_nodes (index, node->right, default_label, index_type);\n \t}\n@@ -5994,17 +5995,18 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     if they are possible.  */\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n-\t      emit_jump_insn ((*gen_bgt_pat) (default_label));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       default_label);\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n-\t  emit_cmp_insn (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n-\t\t\t GE, NULL_RTX, mode, unsignedp, 0);\n-\t  emit_jump_insn ((*gen_bge_pat) (label_rtx (node->code_label)));\n+\t  emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t\t\t   GE, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t   label_rtx (node->code_label));\n \n \t  emit_case_nodes (index, node->left, default_label, index_type);\n \t}\n@@ -6017,18 +6019,18 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n-\t      emit_jump_insn ((*gen_bgt_pat) (default_label));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       default_label);\n \t    }\n \n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     LT, NULL_RTX, mode, unsignedp, 0);\n-\t      emit_jump_insn ((*gen_blt_pat) (default_label));\n+\t      emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       default_label);\n \t    }\n \n \t  emit_jump (label_rtx (node->code_label));"}]}