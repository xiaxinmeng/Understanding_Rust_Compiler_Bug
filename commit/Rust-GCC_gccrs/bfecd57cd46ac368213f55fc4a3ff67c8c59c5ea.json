{"sha": "bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlY2Q1N2NkNDZhYzM2ODIxM2Y1NWZjNGEzZmY2N2M4YzU5YzVlYQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-04T15:32:31Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-04T15:32:31Z"}, "message": "extend.texi (Java Exceptions): Remove.\n\n\t* doc/extend.texi (Java Exceptions): Remove.\n\t(java_interface): Remove.\ncp/\n\t* cp-tree.h (enum cp_tree_index): Remove CPTI_JAVA_*,\n\tCPTI_LANG_NAME_JAVA and CPTI_JCLASS.\n\t(java_byte_type_node, java_short_type_node, java_int_type_node,\n\tjava_long_type_node, java_float_type_node, java_double_type_node,\n\tjava_char_type_node, java_boolean_type_node, lang_name_java,\n\tjclass_node): Remove.\n\t(enum languages): Remove lang_java.\n\t(TYPE_FOR_JAVA): Remove.\n\t(struct lang_type_class): Remove java_interface bit-field.\n\t(TYPE_JAVA_INTERFACE): Remove.\n\t(pragma_java_exceptions): Remove.\n\t(check_java_method, build_java_class_ref): Remove prototypes.\n\t* name-lookup.c (pushtag_1): Don't set TYPE_FOR_JAVA.\n\t* decl2.c (acceptable_java_type, check_java_method): Remove.\n\t(import_export_decl): Remove TYPE_FOR_JAVA handling.\n\t(build_java_method_aliases): Remove.\n\t(c_parse_final_cleanups): Don't call build_java_method_aliases.\n\t(possibly_inlined_p): Don't test pragma_java_exceptions.\n\t* init.c (build_new_1): Remove TYPE_FOR_JAVA handling.\n\t(build_java_class_ref): Remove.\n\t* pt.c (maybe_new_partial_specialization, lookup_template_class_1,\n\tinstantiate_class_template_1): Don't copy TYPE_FOR_JAVA.\n\t* except.c (eh_type_info): Remove java type handling.\n\t(decl_is_java_type, choose_personality_routine): Remove.\n\t(initialize_handler_parm): Don't call choose_personality_routine.\n\t(expand_start_catch_block): Don't handle java types.\n\t(build_throw): Likewise.\n\t* cp-lang.c (cp_eh_personality): Don't handle pragma_java_exceptions.\n\t* typeck.c (structural_comptypes): Don't compare TYPE_FOR_JAVA.\n\t* call.c (build_over_call): Don't handle TYPE_JAVA_INTERFACE.\n\t(java_iface_lookup_fn): Remove.\n\t(build_java_interface_fn_ref): Remove.\n\t* tree.c (cxx_attribute_table): Remove java_interface.\n\t(handle_java_interface_attribute): Remove.\n\t* lex.c (pragma_java_exceptions): Remove.\n\t(init_cp_pragma): Don't register GCC java_exceptions pragma.\n\t(handle_pragma_java_exceptions): Remove.\n\t(retrofit_lang_decl): Don't handle lang_name_java.\n\t* method.c (implicitly_declare_fn): Don't handle TYPE_FOR_JAVA.\n\t* error.c (language_to_string): Don't handle lang_java.\n\t* decl.c (record_builtin_java_type): Remove.\n\t(initialize_predefined_identifiers): Remove Java.\n\t(cxx_init_decl_processing): Remove java_*_type_node.\n\t(cp_finish_decl): Don't handle TYPE_FOR_JAVA.\n\t(grokfndecl): Likewise.\n\t(check_special_function_return_type): Likewise.\n\t(grokdeclarator): Don't set TYPE_FOR_JAVA.\n\t(grokparms): Don't handle TYPE_FOR_JAVA.\n\t(xref_basetypes): Likewise.\n\t(check_function_type): Likewise.\n\t(finish_constructor_body): Likewise.\n\t* mangle.c (write_builtin_type): Don't handle TYPE_FOR_JAVA\n\tand java_*_type_node.\n\t(write_bare_function_type): Don't handle TYPE_FOR_JAVA.\n\t(write_java_integer_type_codes): Remove.\n\t* class.c (add_method): Don't handle TYPE_FOR_JAVA.\n\t(add_implicitly_declared_members, determine_key_method,\n\tfinish_struct_1): Likewise.\n\t(push_lang_context): Don't handle lang_name_java.\ntestsuite/\n\t* g++.dg/other/java3.C: Remove.\n\t* g++.dg/other/java1.C: Remove.\n\t* g++.dg/other/error12.C: Remove.\n\t* g++.dg/other/java2.C: Remove.\n\t* g++.dg/warn/Wnvdtor.C: Remove.\n\t* g++.dg/lookup/java1.C: Remove.\n\t* g++.dg/lookup/java2.C: Remove.\n\t* g++.dg/ext/pr34829.C: Remove.\n\t* g++.dg/ext/java-3.C: Remove.\n\t* g++.dg/ext/java-1.C: Remove.\n\t* g++.dg/ext/java-2.C: Remove.\n\t* g++.old-deja/g++.oliva/dwarf2.C: Remove.\n\nFrom-SVN: r240750", "tree": {"sha": "67b42e486b9999f08c29028115ba5ebbee98254b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67b42e486b9999f08c29028115ba5ebbee98254b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe8b1e839ca91a61440288049a868944346eef4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe8b1e839ca91a61440288049a868944346eef4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe8b1e839ca91a61440288049a868944346eef4b"}], "stats": {"total": 1443, "additions": 193, "deletions": 1250}, "files": [{"sha": "8aa75ab867b79c91e221b7af89157861de669221", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -1,3 +1,8 @@\n+2016-10-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* doc/extend.texi (Java Exceptions): Remove.\n+\t(java_interface): Remove.\n+\n 2016-10-04  Doug Gilmore  <doug.gilmore@imgtec.com>\n \n \tPR tree-optimization/77808"}, {"sha": "48edc6e03efb41780c4e5bb6ba097a6d7a498c9b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -1,3 +1,65 @@\n+2016-10-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-tree.h (enum cp_tree_index): Remove CPTI_JAVA_*,\n+\tCPTI_LANG_NAME_JAVA and CPTI_JCLASS.\n+\t(java_byte_type_node, java_short_type_node, java_int_type_node,\n+\tjava_long_type_node, java_float_type_node, java_double_type_node,\n+\tjava_char_type_node, java_boolean_type_node, lang_name_java,\n+\tjclass_node): Remove.\n+\t(enum languages): Remove lang_java.\n+\t(TYPE_FOR_JAVA): Remove.\n+\t(struct lang_type_class): Remove java_interface bit-field.\n+\t(TYPE_JAVA_INTERFACE): Remove.\n+\t(pragma_java_exceptions): Remove.\n+\t(check_java_method, build_java_class_ref): Remove prototypes.\n+\t* name-lookup.c (pushtag_1): Don't set TYPE_FOR_JAVA.\n+\t* decl2.c (acceptable_java_type, check_java_method): Remove.\n+\t(import_export_decl): Remove TYPE_FOR_JAVA handling.\n+\t(build_java_method_aliases): Remove.\n+\t(c_parse_final_cleanups): Don't call build_java_method_aliases.\n+\t(possibly_inlined_p): Don't test pragma_java_exceptions.\n+\t* init.c (build_new_1): Remove TYPE_FOR_JAVA handling.\n+\t(build_java_class_ref): Remove.\n+\t* pt.c (maybe_new_partial_specialization, lookup_template_class_1,\n+\tinstantiate_class_template_1): Don't copy TYPE_FOR_JAVA.\n+\t* except.c (eh_type_info): Remove java type handling.\n+\t(decl_is_java_type, choose_personality_routine): Remove.\n+\t(initialize_handler_parm): Don't call choose_personality_routine.\n+\t(expand_start_catch_block): Don't handle java types.\n+\t(build_throw): Likewise.\n+\t* cp-lang.c (cp_eh_personality): Don't handle pragma_java_exceptions.\n+\t* typeck.c (structural_comptypes): Don't compare TYPE_FOR_JAVA.\n+\t* call.c (build_over_call): Don't handle TYPE_JAVA_INTERFACE.\n+\t(java_iface_lookup_fn): Remove.\n+\t(build_java_interface_fn_ref): Remove.\n+\t* tree.c (cxx_attribute_table): Remove java_interface.\n+\t(handle_java_interface_attribute): Remove.\n+\t* lex.c (pragma_java_exceptions): Remove.\n+\t(init_cp_pragma): Don't register GCC java_exceptions pragma.\n+\t(handle_pragma_java_exceptions): Remove.\n+\t(retrofit_lang_decl): Don't handle lang_name_java.\n+\t* method.c (implicitly_declare_fn): Don't handle TYPE_FOR_JAVA.\n+\t* error.c (language_to_string): Don't handle lang_java.\n+\t* decl.c (record_builtin_java_type): Remove.\n+\t(initialize_predefined_identifiers): Remove Java.\n+\t(cxx_init_decl_processing): Remove java_*_type_node.\n+\t(cp_finish_decl): Don't handle TYPE_FOR_JAVA.\n+\t(grokfndecl): Likewise.\n+\t(check_special_function_return_type): Likewise.\n+\t(grokdeclarator): Don't set TYPE_FOR_JAVA.\n+\t(grokparms): Don't handle TYPE_FOR_JAVA.\n+\t(xref_basetypes): Likewise.\n+\t(check_function_type): Likewise.\n+\t(finish_constructor_body): Likewise.\n+\t* mangle.c (write_builtin_type): Don't handle TYPE_FOR_JAVA\n+\tand java_*_type_node.\n+\t(write_bare_function_type): Don't handle TYPE_FOR_JAVA.\n+\t(write_java_integer_type_codes): Remove.\n+\t* class.c (add_method): Don't handle TYPE_FOR_JAVA.\n+\t(add_implicitly_declared_members, determine_key_method,\n+\tfinish_struct_1): Likewise.\n+\t(push_lang_context): Don't handle lang_name_java.\n+\n 2016-10-03  Marek Polacek  <polacek@redhat.com>\n \n \tCore 903"}, {"sha": "8c5cb20eccbac1a9e8b181cf492d21bc075d162e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 66, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -146,7 +146,6 @@ static int joust (struct z_candidate *, struct z_candidate *, bool,\n \t\t  tsubst_flags_t);\n static int compare_ics (conversion *, conversion *);\n static tree build_over_call (struct z_candidate *, int, tsubst_flags_t);\n-static tree build_java_interface_fn_ref (tree, tree);\n #define convert_like(CONV, EXPR, COMPLAIN)\t\t\t\\\n   convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0,\t\t\\\n \t\t     /*issue_conversion_warnings=*/true,\t\\\n@@ -7935,10 +7934,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (TREE_SIDE_EFFECTS (argarray[0]))\n \targarray[0] = save_expr (argarray[0]);\n       t = build_pointer_type (TREE_TYPE (fn));\n-      if (DECL_CONTEXT (fn) && TYPE_JAVA_INTERFACE (DECL_CONTEXT (fn)))\n-\tfn = build_java_interface_fn_ref (fn, argarray[0]);\n-      else\n-\tfn = build_vfn_ref (argarray[0], DECL_VINDEX (fn));\n+      fn = build_vfn_ref (argarray[0], DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n   else\n@@ -8045,67 +8041,6 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n   return convert_from_reference (fn);\n }\n \n-static GTY(()) tree java_iface_lookup_fn;\n-\n-/* Make an expression which yields the address of the Java interface\n-   method FN.  This is achieved by generating a call to libjava's\n-   _Jv_LookupInterfaceMethodIdx().  */\n-\n-static tree\n-build_java_interface_fn_ref (tree fn, tree instance)\n-{\n-  tree lookup_fn, method, idx;\n-  tree klass_ref, iface, iface_ref;\n-  int i;\n-\n-  if (!java_iface_lookup_fn)\n-    {\n-      tree ftype = build_function_type_list (ptr_type_node,\n-\t\t\t\t\t     ptr_type_node, ptr_type_node,\n-\t\t\t\t\t     java_int_type_node, NULL_TREE);\n-      java_iface_lookup_fn\n-\t= add_builtin_function (\"_Jv_LookupInterfaceMethodIdx\", ftype,\n-\t\t\t\t0, NOT_BUILT_IN, NULL, NULL_TREE);\n-    }\n-\n-  /* Look up the pointer to the runtime java.lang.Class object for `instance'.\n-     This is the first entry in the vtable.  */\n-  klass_ref = build_vtbl_ref (cp_build_indirect_ref (instance, RO_NULL, \n-                                                     tf_warning_or_error),\n-\t\t\t      integer_zero_node);\n-\n-  /* Get the java.lang.Class pointer for the interface being called.  */\n-  iface = DECL_CONTEXT (fn);\n-  iface_ref = lookup_field (iface, get_identifier (\"class$\"), 0, false);\n-  if (!iface_ref || !VAR_P (iface_ref)\n-      || DECL_CONTEXT (iface_ref) != iface)\n-    {\n-      error (\"could not find class$ field in java interface type %qT\",\n-\t\tiface);\n-      return error_mark_node;\n-    }\n-  iface_ref = build_address (iface_ref);\n-  iface_ref = convert (build_pointer_type (iface), iface_ref);\n-\n-  /* Determine the itable index of FN.  */\n-  i = 1;\n-  for (method = TYPE_METHODS (iface); method; method = DECL_CHAIN (method))\n-    {\n-      if (!DECL_VIRTUAL_P (method))\n-\tcontinue;\n-      if (fn == method)\n-\tbreak;\n-      i++;\n-    }\n-  idx = build_int_cst (NULL_TREE, i);\n-\n-  lookup_fn = build1 (ADDR_EXPR,\n-\t\t      build_pointer_type (TREE_TYPE (java_iface_lookup_fn)),\n-\t\t      java_iface_lookup_fn);\n-  return build_call_nary (ptr_type_node, lookup_fn,\n-\t\t\t  3, klass_ref, iface_ref, idx);\n-}\n-\n /* Returns the value to use for the in-charge parameter when making a\n    call to a function with the indicated NAME.\n "}, {"sha": "34d10ba5cde6bd15cd17820ad3069c3761e5ed01", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -1047,19 +1047,7 @@ add_method (tree type, tree method, tree using_decl)\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n     slot = CLASSTYPE_CONSTRUCTOR_SLOT;\n   else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n-    {\n-      slot = CLASSTYPE_DESTRUCTOR_SLOT;\n-\n-      if (TYPE_FOR_JAVA (type))\n-\t{\n-\t  if (!DECL_ARTIFICIAL (method))\n-\t    error (\"Java class %qT cannot have a destructor\", type);\n-\t  else if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t    error (\"Java class %qT cannot have an implicit non-trivial \"\n-\t\t   \"destructor\",\n-\t\t   type);\n-\t}\n-    }\n+    slot = CLASSTYPE_DESTRUCTOR_SLOT;\n   else\n     {\n       tree m;\n@@ -3349,17 +3337,8 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \n   /* Destructor.  */\n   if (!CLASSTYPE_DESTRUCTORS (t))\n-    {\n-      /* In general, we create destructors lazily.  */\n-      CLASSTYPE_LAZY_DESTRUCTOR (t) = 1;\n-\n-      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n-\t  && TYPE_FOR_JAVA (t))\n-\t/* But if this is a Java class, any non-trivial destructor is\n-\t   invalid, even if compiler-generated.  Therefore, if the\n-\t   destructor is non-trivial we create it now.  */\n-\tlazily_declare_fn (sfk_destructor, t);\n-    }\n+    /* In general, we create destructors lazily.  */\n+    CLASSTYPE_LAZY_DESTRUCTOR (t) = 1;\n \n   /* [class.ctor]\n \n@@ -3382,7 +3361,7 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \n      If a class definition does not explicitly declare a copy\n      constructor, one is declared implicitly.  */\n-  if (! TYPE_HAS_COPY_CTOR (t) && ! TYPE_FOR_JAVA (t))\n+  if (! TYPE_HAS_COPY_CTOR (t))\n     {\n       TYPE_HAS_COPY_CTOR (t) = 1;\n       TYPE_HAS_CONST_COPY_CTOR (t) = !cant_have_const_cctor;\n@@ -3395,7 +3374,7 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n      when it is needed.  For now, just record whether or not the type\n      of the parameter to the assignment operator will be a const or\n      non-const reference.  */\n-  if (!TYPE_HAS_COPY_ASSIGN (t) && !TYPE_FOR_JAVA (t))\n+  if (!TYPE_HAS_COPY_ASSIGN (t))\n     {\n       TYPE_HAS_COPY_ASSIGN (t) = 1;\n       TYPE_HAS_CONST_COPY_ASSIGN (t) = !cant_have_const_assignment;\n@@ -6653,8 +6632,7 @@ determine_key_method (tree type)\n {\n   tree method;\n \n-  if (TYPE_FOR_JAVA (type)\n-      || processing_template_decl\n+  if (processing_template_decl\n       || CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n       || CLASSTYPE_INTERFACE_KNOWN (type))\n     return;\n@@ -7095,9 +7073,7 @@ finish_struct_1 (tree t)\n   /* Build the VTT for T.  */\n   build_vtt (t);\n \n-  /* This warning does not make sense for Java classes, since they\n-     cannot have destructors.  */\n-  if (!TYPE_FOR_JAVA (t) && warn_nonvdtor\n+  if (warn_nonvdtor\n       && TYPE_POLYMORPHIC_P (t) && accessible_nvdtor_p (t)\n       && !CLASSTYPE_FINAL (t))\n     warning (OPT_Wnon_virtual_dtor,\n@@ -7832,29 +7808,9 @@ push_lang_context (tree name)\n   vec_safe_push (current_lang_base, current_lang_name);\n \n   if (name == lang_name_cplusplus)\n-    {\n-      current_lang_name = name;\n-    }\n-  else if (name == lang_name_java)\n-    {\n-      current_lang_name = name;\n-      /* DECL_IGNORED_P is initially set for these types, to avoid clutter.\n-\t (See record_builtin_java_type in decl.c.)  However, that causes\n-\t incorrect debug entries if these types are actually used.\n-\t So we re-enable debug output after extern \"Java\".  */\n-      DECL_IGNORED_P (TYPE_NAME (java_byte_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_short_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_int_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_long_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_float_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_double_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_char_type_node)) = 0;\n-      DECL_IGNORED_P (TYPE_NAME (java_boolean_type_node)) = 0;\n-    }\n+    current_lang_name = name;\n   else if (name == lang_name_c)\n-    {\n-      current_lang_name = name;\n-    }\n+    current_lang_name = name;\n   else\n     error (\"language string %<\\\"%E\\\"%> not recognized\", name);\n }"}, {"sha": "e1b473728046fe73e45b4c89f14afe23560a1c31", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -137,10 +137,7 @@ static tree\n cp_eh_personality (void)\n {\n   if (!cp_eh_personality_decl)\n-    {\n-      const char *lang = (pragma_java_exceptions ? \"gcj\" : \"gxx\");\n-      cp_eh_personality_decl = build_personality_function (lang);\n-    }\n+    cp_eh_personality_decl = build_personality_function (\"gxx\");\n \n   return cp_eh_personality_decl;\n }"}, {"sha": "85702c53a412d6e91badf17af07c3d433a32db29", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 44, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -201,7 +201,6 @@ operator == (const cp_expr &lhs, tree rhs)\n    1: TYPE_HAS_USER_CONSTRUCTOR.\n    2: TYPE_HAS_LATE_RETURN_TYPE (in FUNCTION_TYPE, METHOD_TYPE)\n       TYPE_PTRMEMFUNC_FLAG (in RECORD_TYPE)\n-   3: TYPE_FOR_JAVA.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n    5: CLASS_TYPE_P (in RECORD_TYPE and UNION_TYPE)\n       ENUM_FIXED_UNDERLYING_TYPE_P (in ENUMERAL_TYPE)\n@@ -1083,15 +1082,6 @@ union GTY((desc (\"cp_tree_node_structure (&%h)\"),\n \f\n enum cp_tree_index\n {\n-    CPTI_JAVA_BYTE_TYPE,\n-    CPTI_JAVA_SHORT_TYPE,\n-    CPTI_JAVA_INT_TYPE,\n-    CPTI_JAVA_LONG_TYPE,\n-    CPTI_JAVA_FLOAT_TYPE,\n-    CPTI_JAVA_DOUBLE_TYPE,\n-    CPTI_JAVA_CHAR_TYPE,\n-    CPTI_JAVA_BOOLEAN_TYPE,\n-\n     CPTI_WCHAR_DECL,\n     CPTI_VTABLE_ENTRY_TYPE,\n     CPTI_DELTA_TYPE,\n@@ -1129,12 +1119,10 @@ enum cp_tree_index\n \n     CPTI_LANG_NAME_C,\n     CPTI_LANG_NAME_CPLUSPLUS,\n-    CPTI_LANG_NAME_JAVA,\n \n     CPTI_EMPTY_EXCEPT_SPEC,\n     CPTI_NOEXCEPT_TRUE_SPEC,\n     CPTI_NOEXCEPT_FALSE_SPEC,\n-    CPTI_JCLASS,\n     CPTI_TERMINATE,\n     CPTI_CALL_UNEXPECTED,\n     CPTI_ATEXIT_FN_PTR_TYPE,\n@@ -1154,15 +1142,6 @@ enum cp_tree_index\n \n extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n-#define java_byte_type_node\t\tcp_global_trees[CPTI_JAVA_BYTE_TYPE]\n-#define java_short_type_node\t\tcp_global_trees[CPTI_JAVA_SHORT_TYPE]\n-#define java_int_type_node\t\tcp_global_trees[CPTI_JAVA_INT_TYPE]\n-#define java_long_type_node\t\tcp_global_trees[CPTI_JAVA_LONG_TYPE]\n-#define java_float_type_node\t\tcp_global_trees[CPTI_JAVA_FLOAT_TYPE]\n-#define java_double_type_node\t\tcp_global_trees[CPTI_JAVA_DOUBLE_TYPE]\n-#define java_char_type_node\t\tcp_global_trees[CPTI_JAVA_CHAR_TYPE]\n-#define java_boolean_type_node\t\tcp_global_trees[CPTI_JAVA_BOOLEAN_TYPE]\n-\n #define wchar_decl_node\t\t\tcp_global_trees[CPTI_WCHAR_DECL]\n #define vtable_entry_type\t\tcp_global_trees[CPTI_VTABLE_ENTRY_TYPE]\n /* The type used to represent an offset by which to adjust the `this'\n@@ -1222,16 +1201,12 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define std_identifier\t\t\tcp_global_trees[CPTI_STD_IDENTIFIER]\n #define lang_name_c\t\t\tcp_global_trees[CPTI_LANG_NAME_C]\n #define lang_name_cplusplus\t\tcp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n-#define lang_name_java\t\t\tcp_global_trees[CPTI_LANG_NAME_JAVA]\n \n /* Exception specifier used for throw().  */\n #define empty_except_spec\t\tcp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n #define noexcept_true_spec\t\tcp_global_trees[CPTI_NOEXCEPT_TRUE_SPEC]\n #define noexcept_false_spec\t\tcp_global_trees[CPTI_NOEXCEPT_FALSE_SPEC]\n \n-/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*).  */\n-#define jclass_node\t\t\tcp_global_trees[CPTI_JCLASS]\n-\n /* The declaration for `std::terminate'.  */\n #define terminate_node\t\t\tcp_global_trees[CPTI_TERMINATE]\n \n@@ -1549,7 +1524,7 @@ extern bool statement_code_p[MAX_TREE_CODES];\n \n #define STATEMENT_CODE_P(CODE) statement_code_p[(int) (CODE)]\n \n-enum languages { lang_c, lang_cplusplus, lang_java };\n+enum languages { lang_c, lang_cplusplus };\n \n /* Macros to make error reporting functions' lives easier.  */\n #define TYPE_LINKAGE_IDENTIFIER(NODE) \\\n@@ -1599,9 +1574,6 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define OVERLOAD_TYPE_P(T) \\\n   (CLASS_TYPE_P (T) || TREE_CODE (T) == ENUMERAL_TYPE)\n \n-/* True if this a \"Java\" type, defined in 'extern \"Java\"'.  */\n-#define TYPE_FOR_JAVA(NODE) TYPE_LANG_FLAG_3 (NODE)\n-\n /* True if this type is dependent.  This predicate is only valid if\n    TYPE_DEPENDENT_P_VALID is true.  */\n #define TYPE_DEPENDENT_P(NODE) TYPE_LANG_FLAG_0 (NODE)\n@@ -1715,28 +1687,27 @@ struct GTY(()) lang_type_class {\n   unsigned diamond_shaped : 1;\n   unsigned repeated_base : 1;\n   unsigned being_defined : 1;\n-  unsigned java_interface : 1;\n   unsigned debug_requested : 1;\n   unsigned fields_readonly : 1;\n+  unsigned ptrmemfunc_flag : 1;\n \n   unsigned use_template : 2;\n-  unsigned ptrmemfunc_flag : 1;\n   unsigned was_anonymous : 1;\n   unsigned lazy_default_ctor : 1;\n   unsigned lazy_copy_ctor : 1;\n   unsigned lazy_copy_assign : 1;\n   unsigned lazy_destructor : 1;\n-\n   unsigned has_const_copy_ctor : 1;\n+\n   unsigned has_complex_copy_ctor : 1;\n   unsigned has_complex_copy_assign : 1;\n   unsigned non_aggregate : 1;\n   unsigned has_complex_dflt : 1;\n   unsigned has_list_ctor : 1;\n   unsigned non_std_layout : 1;\n   unsigned is_literal : 1;\n-\n   unsigned lazy_move_ctor : 1;\n+\n   unsigned lazy_move_assign : 1;\n   unsigned has_complex_move_ctor : 1;\n   unsigned has_complex_move_assign : 1;\n@@ -1749,7 +1720,7 @@ struct GTY(()) lang_type_class {\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 3;\n+  unsigned dummy : 4;\n \n   tree primary_base;\n   vec<tree_pair_s, va_gc> *vcall_indices;\n@@ -2011,11 +1982,6 @@ struct GTY(()) lang_type {\n #define CLASSTYPE_ALIGN_UNIT(NODE) \\\n   (CLASSTYPE_ALIGN (NODE) / BITS_PER_UNIT)\n \n-/* True if this a Java interface type, declared with\n-   '__attribute__ ((java_interface))'.  */\n-#define TYPE_JAVA_INTERFACE(NODE) \\\n-  (LANG_TYPE_CLASS_CHECK (NODE)->java_interface)\n-\n /* A vec<tree> of virtual functions which cannot be inherited by\n    derived classes.  When deriving from this type, the derived\n    class must provide its own definition for each of these functions.  */\n@@ -5542,9 +5508,6 @@ concept_template_p (tree t)\n    e.g  \"int f(void)\".  */\n extern cp_parameter_declarator *no_parameters;\n \n-/* True if we saw \"#pragma GCC java_exceptions\".  */\n-extern bool pragma_java_exceptions;\n-\n /* in call.c */\n extern bool check_dtor_name\t\t\t(tree, tree);\n int magic_varargs_p\t\t\t\t(tree);\n@@ -5844,7 +5807,6 @@ extern tree cxx_maybe_build_cleanup\t\t(tree, tsubst_flags_t);\n /* in decl2.c */\n extern void note_mangling_alias\t\t\t(tree, tree);\n extern void generate_mangling_aliases\t\t(void);\n-extern bool check_java_method\t\t\t(tree);\n extern tree build_memfn_type\t\t\t(tree, tree, cp_cv_quals, cp_ref_qualifier);\n extern tree build_pointer_ptrmemfn_type\t(tree);\n extern tree change_return_type\t\t\t(tree, tree);\n@@ -5988,7 +5950,6 @@ extern tree build_vec_delete\t\t\t(tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree create_temporary_var\t\t(tree);\n extern void initialize_vtbl_ptrs\t\t(tree);\n-extern tree build_java_class_ref\t\t(tree);\n extern tree scalar_constant_value\t\t(tree);\n extern tree decl_really_constant_value\t\t(tree);\n extern int diagnose_uninitialized_cst_or_ref_member (tree, bool, bool);"}, {"sha": "c8f766618d137e4c7e4c5b16c9dfb0ba2fbf8ef1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 119, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -77,7 +77,6 @@ static void bad_specifiers (tree, enum bad_spec_place, int, int, int, int,\n \t\t\t    int);\n static void check_for_uninitialized_const_var (tree);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n-static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types);\n static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n@@ -3892,53 +3891,6 @@ record_builtin_type (enum rid rid_index,\n     debug_hooks->type_decl (tdecl, 0);\n }\n \n-/* Record one of the standard Java types.\n- * Declare it as having the given NAME.\n- * If SIZE > 0, it is the size of one of the integral types;\n- * otherwise it is the negative of the size of one of the other types.  */\n-\n-static tree\n-record_builtin_java_type (const char* name, int size)\n-{\n-  tree type, decl;\n-  if (size > 0)\n-    {\n-      type = build_nonstandard_integer_type (size, 0);\n-      type = build_distinct_type_copy (type);\n-    }\n-  else if (size > -32)\n-    {\n-      tree stype;\n-      /* \"__java_char\" or \"\"__java_boolean\".  */\n-      type = build_nonstandard_integer_type (-size, 1);\n-      type = build_distinct_type_copy (type);\n-      /* Get the signed type cached and attached to the unsigned type,\n-\t so it doesn't get garbage-collected at \"random\" times,\n-\t causing potential codegen differences out of different UIDs\n-\t and different alias set numbers.  */\n-      stype = build_nonstandard_integer_type (-size, 0);\n-      stype = build_distinct_type_copy (stype);\n-      TREE_CHAIN (type) = stype;\n-      /*if (size == -1)\tTREE_SET_CODE (type, BOOLEAN_TYPE);*/\n-    }\n-  else\n-    { /* \"__java_float\" or \"\"__java_double\".  */\n-      type = make_node (REAL_TYPE);\n-      TYPE_PRECISION (type) = - size;\n-      layout_type (type);\n-    }\n-  record_builtin_type (RID_MAX, name, type);\n-  decl = TYPE_NAME (type);\n-\n-  /* Suppress generate debug symbol entries for these types,\n-     since for normal C++ they are just clutter.\n-     However, push_lang_context undoes this if extern \"Java\" is seen.  */\n-  DECL_IGNORED_P (decl) = 1;\n-\n-  TYPE_FOR_JAVA (type) = 1;\n-  return type;\n-}\n-\n /* Push a type into the namespace so that the back ends ignore it.  */\n \n static void\n@@ -3979,7 +3931,6 @@ initialize_predefined_identifiers (void)\n   static const predefined_identifier predefined_identifiers[] = {\n     { \"C++\", &lang_name_cplusplus, 0 },\n     { \"C\", &lang_name_c, 0 },\n-    { \"Java\", &lang_name_java, 0 },\n     /* Some of these names have a trailing space so that it is\n        impossible for them to conflict with names written by users.  */\n     { \"__ct \", &ctor_identifier, 1 },\n@@ -4051,15 +4002,6 @@ cxx_init_decl_processing (void)\n \n   c_common_nodes_and_builtins ();\n \n-  java_byte_type_node = record_builtin_java_type (\"__java_byte\", 8);\n-  java_short_type_node = record_builtin_java_type (\"__java_short\", 16);\n-  java_int_type_node = record_builtin_java_type (\"__java_int\", 32);\n-  java_long_type_node = record_builtin_java_type (\"__java_long\", 64);\n-  java_float_type_node = record_builtin_java_type (\"__java_float\", -32);\n-  java_double_type_node = record_builtin_java_type (\"__java_double\", -64);\n-  java_char_type_node = record_builtin_java_type (\"__java_char\", -16);\n-  java_boolean_type_node = record_builtin_java_type (\"__java_boolean\", -1);\n-\n   integer_two_node = build_int_cst (NULL_TREE, 2);\n \n   record_builtin_type (RID_BOOL, \"bool\", boolean_type_node);\n@@ -6962,20 +6904,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t     is *not* defined.  */\n \t  && (!DECL_EXTERNAL (decl) || init))\n \t{\n-\t  if (TYPE_FOR_JAVA (type) && MAYBE_CLASS_TYPE_P (type))\n-\t    {\n-\t      tree jclass\n-\t\t= IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jclass\"));\n-\t      /* Allow libjava/prims.cc define primitive classes.  */\n-\t      if (init != NULL_TREE\n-\t\t  || jclass == NULL_TREE\n-\t\t  || TREE_CODE (jclass) != TYPE_DECL\n-\t\t  || !POINTER_TYPE_P (TREE_TYPE (jclass))\n-\t\t  || !same_type_ignoring_top_level_qualifiers_p\n-\t\t\t\t\t(type, TREE_TYPE (TREE_TYPE (jclass))))\n-\t\terror (\"Java object %qD not allocated with %<new%>\", decl);\n-\t      init = NULL_TREE;\n-\t    }\n \t  cleanups = make_tree_vector ();\n \t  init = check_initializer (decl, init, flags, &cleanups);\n \n@@ -7019,9 +6947,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t   so that we can decide later to emit debug info for them.  */\n \trecord_types_used_by_current_var_decl (decl);\n     }\n-  else if (TREE_CODE (decl) == FIELD_DECL\n-\t   && TYPE_FOR_JAVA (type) && MAYBE_CLASS_TYPE_P (type))\n-    error (\"non-static data member %qD has Java class type\", decl);\n \n   /* Add this declaration to the statement-tree.  This needs to happen\n      after the call to check_initializer so that the DECL_EXPR for a\n@@ -8384,9 +8309,7 @@ grokfndecl (tree ctype,\n \tcheck_main_parameter_types (decl);\n     }\n \n-  if (ctype != NULL_TREE\n-      && (! TYPE_FOR_JAVA (ctype) || check_java_method (decl))\n-      && check)\n+  if (ctype != NULL_TREE && check)\n     {\n       tree old_decl = check_classfn (ctype, decl,\n \t\t\t\t     (processing_template_decl\n@@ -9236,7 +9159,7 @@ check_special_function_return_type (special_function_kind sfk,\n \terror_at (smallest_type_quals_location (type_quals, locations),\n \t\t  \"qualifiers are not allowed on constructor declaration\");\n \n-      if (targetm.cxx.cdtor_returns_this () && !TYPE_FOR_JAVA (optype))\n+      if (targetm.cxx.cdtor_returns_this ())\n \ttype = build_pointer_type (optype);\n       else\n \ttype = void_type_node;\n@@ -9250,10 +9173,8 @@ check_special_function_return_type (special_function_kind sfk,\n \t\t  \"qualifiers are not allowed on destructor declaration\");\n \n       /* We can't use the proper return type here because we run into\n-\t problems with ambiguous bases and covariant returns.\n-\t Java classes are left unchanged because (void *) isn't a valid\n-\t Java type, and we don't want to change the Java ABI.  */\n-      if (targetm.cxx.cdtor_returns_this () && !TYPE_FOR_JAVA (optype))\n+\t problems with ambiguous bases and covariant returns.  */\n+      if (targetm.cxx.cdtor_returns_this ())\n \ttype = build_pointer_type (void_type_node);\n       else\n \ttype = void_type_node;\n@@ -10826,11 +10747,6 @@ grokdeclarator (const cp_declarator *declarator,\n     {\n       tree decl;\n \n-      /* Note that the grammar rejects storage classes\n-\t in typenames, fields or parameters.  */\n-      if (current_lang_name == lang_name_java)\n-\tTYPE_FOR_JAVA (type) = 1;\n-\n       /* This declaration:\n \n \t   typedef void f(int) const;\n@@ -11898,16 +11814,6 @@ grokparms (tree parmlist, tree *parms)\n \t  TREE_TYPE (decl) = error_mark_node;\n \t}\n \n-      if (type != error_mark_node\n-\t  && TYPE_FOR_JAVA (type)\n-\t  && MAYBE_CLASS_TYPE_P (type))\n-\t{\n-\t  error (\"parameter %qD has Java class type\", decl);\n-\t  type = error_mark_node;\n-\t  TREE_TYPE (decl) = error_mark_node;\n-\t  init = NULL_TREE;\n-\t}\n-\n       if (type != error_mark_node)\n \t{\n \t  if (deprecated_state != DEPRECATED_SUPPRESS)\n@@ -13108,21 +13014,14 @@ xref_basetypes (tree ref, tree base_list)\n     }\n \n   if (max_bases > 1)\n-    {\n-      if (TYPE_FOR_JAVA (ref))\n-\terror (\"Java class %qT cannot have multiple bases\", ref);\n-      else\n-\twarning (OPT_Wmultiple_inheritance,\n-\t\t \"%qT defined with multiple direct bases\", ref);\n-    }\n+    warning (OPT_Wmultiple_inheritance,\n+\t     \"%qT defined with multiple direct bases\", ref);\n \n   if (max_vbases)\n     {\n       vec_alloc (CLASSTYPE_VBASECLASSES (ref), max_vbases);\n \n-      if (TYPE_FOR_JAVA (ref))\n-\terror (\"Java class %qT cannot have virtual bases\", ref);\n-      else if (max_dvbases)\n+      if (max_dvbases)\n \twarning (OPT_Wvirtual_inheritance,\n \t\t \"%qT defined with direct virtual base\", ref);\n     }\n@@ -13147,9 +13046,6 @@ xref_basetypes (tree ref, tree base_list)\n \t  goto dropped_base;\n \t}\n \n-      if (TYPE_FOR_JAVA (basetype) && (current_lang_depth () == 0))\n-\tTYPE_FOR_JAVA (ref) = 1;\n-\n       base_binfo = NULL_TREE;\n       if (CLASS_TYPE_P (basetype) && !dependent_scope_p (basetype))\n \t{\n@@ -13924,15 +13820,11 @@ check_function_type (tree decl, tree current_function_parms)\n   if (dependent_type_p (return_type)\n       || type_uses_auto (return_type))\n     return;\n-  if (!COMPLETE_OR_VOID_TYPE_P (return_type)\n-      || (TYPE_FOR_JAVA (return_type) && MAYBE_CLASS_TYPE_P (return_type)))\n+  if (!COMPLETE_OR_VOID_TYPE_P (return_type))\n     {\n       tree args = TYPE_ARG_TYPES (fntype);\n \n-      if (!COMPLETE_OR_VOID_TYPE_P (return_type))\n-\terror (\"return type %q#T is incomplete\", return_type);\n-      else\n-\terror (\"return type has Java class type %q#T\", return_type);\n+      error (\"return type %q#T is incomplete\", return_type);\n \n       /* Make it return void instead.  */\n       if (TREE_CODE (fntype) == METHOD_TYPE)\n@@ -14587,8 +14479,7 @@ finish_constructor_body (void)\n   tree val;\n   tree exprstmt;\n \n-  if (targetm.cxx.cdtor_returns_this ()\n-      && (! TYPE_FOR_JAVA (current_class_type)))\n+  if (targetm.cxx.cdtor_returns_this ())\n     {\n       /* Any return from a constructor will end up here.  */\n       add_stmt (build_stmt (input_location, LABEL_EXPR, cdtor_label));"}, {"sha": "5a04bc7e31edf294d9ad8615dc691d874059b3f3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 119, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -63,7 +63,6 @@ typedef struct priority_info_s {\n \n static void mark_vtable_entries (tree);\n static bool maybe_emit_vtables (tree);\n-static bool acceptable_java_type (tree);\n static tree start_objects (int, int);\n static void finish_objects (int, int, tree);\n static tree start_static_storage_duration_function (unsigned);\n@@ -541,80 +540,6 @@ check_member_template (tree tmpl)\n     error (\"template declaration of %q#D\", decl);\n }\n \n-/* Return true iff TYPE is a valid Java parameter or return type.  */\n-\n-static bool\n-acceptable_java_type (tree type)\n-{\n-  if (type == error_mark_node)\n-    return false;\n-\n-  if (VOID_TYPE_P (type) || TYPE_FOR_JAVA (type))\n-    return true;\n-  if (TYPE_PTR_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      type = TREE_TYPE (type);\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\t{\n-\t  tree args;  int i;\n-\t  if (! TYPE_FOR_JAVA (type))\n-\t    return false;\n-\t  if (! CLASSTYPE_TEMPLATE_INFO (type))\n-\t    return true;\n-\t  args = CLASSTYPE_TI_ARGS (type);\n-\t  i = TREE_VEC_LENGTH (args);\n-\t  while (--i >= 0)\n-\t    {\n-\t      type = TREE_VEC_ELT (args, i);\n-\t      if (TYPE_PTR_P (type))\n-\t\ttype = TREE_TYPE (type);\n-\t      if (! TYPE_FOR_JAVA (type))\n-\t\treturn false;\n-\t    }\n-\t  return true;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* For a METHOD in a Java class CTYPE, return true if\n-   the parameter and return types are valid Java types.\n-   Otherwise, print appropriate error messages, and return false.  */\n-\n-bool\n-check_java_method (tree method)\n-{\n-  bool jerr = false;\n-  tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (method));\n-  tree ret_type = TREE_TYPE (TREE_TYPE (method));\n-\n-  if (!acceptable_java_type (ret_type))\n-    {\n-      error (\"Java method %qD has non-Java return type %qT\",\n-\t     method, ret_type);\n-      jerr = true;\n-    }\n-\n-  arg_types = TREE_CHAIN (arg_types);\n-  if (DECL_HAS_IN_CHARGE_PARM_P (method))\n-    arg_types = TREE_CHAIN (arg_types);\n-  if (DECL_HAS_VTT_PARM_P (method))\n-    arg_types = TREE_CHAIN (arg_types);\n-\n-  for (; arg_types != NULL_TREE; arg_types = TREE_CHAIN (arg_types))\n-    {\n-      tree type = TREE_VALUE (arg_types);\n-      if (!acceptable_java_type (type))\n-\t{\n-          if (type != error_mark_node)\n-\t    error (\"Java method %qD has non-Java parameter type %qT\",\n-\t\t   method, type);\n-\t  jerr = true;\n-\t}\n-    }\n-  return !jerr;\n-}\n-\n /* Sanity check: report error if this function FUNCTION is not\n    really a member of the class (CTYPE) it is supposed to belong to.\n    TEMPLATE_PARMS is used to specify the template parameters of a member\n@@ -2873,10 +2798,8 @@ import_export_decl (tree decl)\n     {\n       class_type = DECL_CONTEXT (decl);\n       import_export_class (class_type);\n-      if (TYPE_FOR_JAVA (class_type))\n-\timport_p = true;\n-      else if (CLASSTYPE_INTERFACE_KNOWN (class_type)\n-\t       && CLASSTYPE_INTERFACE_ONLY (class_type))\n+      if (CLASSTYPE_INTERFACE_KNOWN (class_type)\n+\t  && CLASSTYPE_INTERFACE_ONLY (class_type))\n \timport_p = true;\n       else if ((!flag_weak || TARGET_WEAK_NOT_IN_ARCHIVE_TOC)\n \t       && !CLASSTYPE_USE_TEMPLATE (class_type)\n@@ -4080,42 +4003,6 @@ generate_ctor_and_dtor_functions_for_priority (splay_tree_node n, void * data)\n   return 0;\n }\n \n-/* Java requires that we be able to reference a local address for a\n-   method, and not be confused by PLT entries.  If supported, create a\n-   hidden alias for all such methods.  */\n-\n-static void\n-build_java_method_aliases (void)\n-{\n-#ifndef HAVE_GAS_HIDDEN\n-  return;\n-#endif\n-\n-  struct cgraph_node *node;\n-  FOR_EACH_FUNCTION (node)\n-    {\n-      tree fndecl = node->decl;\n-\n-      if (DECL_CLASS_SCOPE_P (fndecl)\n-\t  && TYPE_FOR_JAVA (DECL_CONTEXT (fndecl))\n-\t  && TARGET_USE_LOCAL_THUNK_ALIAS_P (fndecl))\n-\t{\n-\t  /* Mangle the name in a predictable way; we need to reference\n-\t     this from a java compiled object file.  */\n-\t  tree oid = DECL_ASSEMBLER_NAME (fndecl);\n-\t  const char *oname = IDENTIFIER_POINTER (oid);\n-\t  gcc_assert (oname[0] == '_' && oname[1] == 'Z');\n-\t  char *nname = ACONCAT ((\"_ZGA\", oname + 2, NULL));\n-\n-\t  tree alias = make_alias_for (fndecl, get_identifier (nname));\n-\t  TREE_PUBLIC (alias) = 1;\n-\t  DECL_VISIBILITY (alias) = VISIBILITY_HIDDEN;\n-\n-\t  cgraph_node::create_same_body_alias (alias, fndecl);\n-\t}\n-    }\n-}\n-\n /* Return C++ property of T, based on given operation OP.  */\n \n static int\n@@ -4908,9 +4795,6 @@ c_parse_final_cleanups (void)\n      linkage now.  */\n   pop_lang_context ();\n \n-  /* Generate Java hidden aliases.  */\n-  build_java_method_aliases ();\n-\n   if (flag_vtable_verify)\n     {\n       vtv_recover_class_info ();\n@@ -5066,7 +4950,7 @@ possibly_inlined_p (tree decl)\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   if (DECL_UNINLINABLE (decl))\n     return false;\n-  if (!optimize || pragma_java_exceptions)\n+  if (!optimize)\n     return DECL_DECLARED_INLINE_P (decl);\n   /* When optimizing, we might inline everything when flatten\n      attribute or heuristics inlining for size or autoinlining"}, {"sha": "745d7ba86722b8b1f10f9a78fd0d4075a41e4216", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -3019,9 +3019,6 @@ language_to_string (enum languages c)\n     case lang_cplusplus:\n       return \"C++\";\n \n-    case lang_java:\n-      return \"Java\";\n-\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "1c60b08bb1089a1167e6cae836057ee24a1f0e4f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 150, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -35,7 +35,6 @@ static tree prepare_eh_type (tree);\n static tree do_begin_catch (void);\n static int dtor_nothrow (tree);\n static tree do_end_catch (tree);\n-static bool decl_is_java_type (tree decl, int err);\n static void initialize_handler_parm (tree, tree);\n static tree do_allocate_exception (tree);\n static tree wrap_cleanups_r (tree *, int *, void *);\n@@ -103,17 +102,10 @@ prepare_eh_type (tree type)\n tree\n eh_type_info (tree type)\n {\n-  tree exp;\n-\n   if (type == NULL_TREE || type == error_mark_node)\n     return type;\n \n-  if (decl_is_java_type (type, 0))\n-    exp = build_java_class_ref (TREE_TYPE (type));\n-  else\n-    exp = get_tinfo_decl (type);\n-\n-  return exp;\n+  return get_tinfo_decl (type);\n }\n \n /* Build the address of a typeinfo decl for use in the runtime\n@@ -262,107 +254,6 @@ push_eh_cleanup (tree type)\n   finish_decl_cleanup (NULL_TREE, do_end_catch (type));\n }\n \n-/* Return nonzero value if DECL is a Java type suitable for catch or\n-   throw.  */\n-\n-static bool\n-decl_is_java_type (tree decl, int err)\n-{\n-  bool r = (TYPE_PTR_P (decl)\n-\t    && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n-\t    && TYPE_FOR_JAVA (TREE_TYPE (decl)));\n-\n-  if (err)\n-    {\n-      if (TREE_CODE (decl) == REFERENCE_TYPE\n-\t  && TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n-\t  && TYPE_FOR_JAVA (TREE_TYPE (decl)))\n-\t{\n-\t  /* Can't throw a reference.  */\n-\t  error (\"type %qT is disallowed in Java %<throw%> or %<catch%>\",\n-\t\t decl);\n-\t}\n-\n-      if (r)\n-\t{\n-\t  tree jthrow_node\n-\t    = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jthrowable\"));\n-\n-\t  if (jthrow_node == NULL_TREE)\n-\t    fatal_error\n-\t      (input_location,\n-\t       \"call to Java %<catch%> or %<throw%> with %<jthrowable%> undefined\");\n-\n-\t  jthrow_node = TREE_TYPE (TREE_TYPE (jthrow_node));\n-\n-\t  if (! DERIVED_FROM_P (jthrow_node, TREE_TYPE (decl)))\n-\t    {\n-\t      /* Thrown object must be a Throwable.  */\n-\t      error (\"type %qT is not derived from %<java::lang::Throwable%>\",\n-\t\t     TREE_TYPE (decl));\n-\t    }\n-\t}\n-    }\n-\n-  return r;\n-}\n-\n-/* Select the personality routine to be used for exception handling,\n-   or issue an error if we need two different ones in the same\n-   translation unit.\n-   ??? At present DECL_FUNCTION_PERSONALITY is set via\n-   LANG_HOOKS_EH_PERSONALITY.  Should it be done here instead?  */\n-void\n-choose_personality_routine (enum languages lang)\n-{\n-  static enum {\n-    chose_none,\n-    chose_cpp,\n-    chose_java,\n-    gave_error\n-  } state;\n-\n-  switch (state)\n-    {\n-    case gave_error:\n-      return;\n-\n-    case chose_cpp:\n-      if (lang != lang_cplusplus)\n-\tgoto give_error;\n-      return;\n-\n-    case chose_java:\n-      if (lang != lang_java)\n-\tgoto give_error;\n-      return;\n-\n-    case chose_none:\n-      ; /* Proceed to language selection.  */\n-    }\n-\n-  switch (lang)\n-    {\n-    case lang_cplusplus:\n-      state = chose_cpp;\n-      break;\n-\n-    case lang_java:\n-      state = chose_java;\n-      terminate_node = builtin_decl_explicit (BUILT_IN_ABORT);\n-      pragma_java_exceptions = true;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-  return;\n-\n- give_error:\n-  error (\"mixing C++ and Java catches in a single translation unit\");\n-  state = gave_error;\n-}\n-\n /* Wrap EXPR in a MUST_NOT_THROW_EXPR expressing that EXPR must\n    not throw any exceptions if COND is true.  A condition of\n    NULL_TREE is treated as 'true'.  */\n@@ -408,9 +299,6 @@ initialize_handler_parm (tree decl, tree exp)\n   if (!POINTER_TYPE_P (init_type))\n     init_type = build_reference_type (init_type);\n \n-  choose_personality_routine (decl_is_java_type (init_type, 0)\n-\t\t\t      ? lang_java : lang_cplusplus);\n-\n   /* Since pointers are passed by value, initialize a reference to\n      pointer catch parm with the address of the temporary.  */\n   if (TREE_CODE (init_type) == REFERENCE_TYPE\n@@ -490,22 +378,6 @@ expand_start_catch_block (tree decl)\n   else\n     type = NULL_TREE;\n \n-  if (decl && decl_is_java_type (type, 1))\n-    {\n-      /* Java only passes object via pointer and doesn't require\n-\t adjusting.  The java object is immediately before the\n-\t generic exception header.  */\n-      exp = build_exc_ptr ();\n-      exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n-      exp = fold_build_pointer_plus (exp,\n-\t\t    fold_build1_loc (input_location,\n-\t\t\t\t     NEGATE_EXPR, sizetype,\n-\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (exp))));\n-      exp = cp_build_indirect_ref (exp, RO_NULL, tf_warning_or_error);\n-      initialize_handler_parm (decl, exp);\n-      return type;\n-    }\n-\n   /* Call __cxa_end_catch at the end of processing the exception.  */\n   push_eh_cleanup (type);\n \n@@ -738,27 +610,7 @@ build_throw (tree exp)\n   if (! doing_eh ())\n     return error_mark_node;\n \n-  if (exp && decl_is_java_type (TREE_TYPE (exp), 1))\n-    {\n-      tree fn = get_identifier (\"_Jv_Throw\");\n-      if (!get_global_value_if_present (fn, &fn))\n-\t{\n-\t  /* Declare void _Jv_Throw (void *).  */\n-\t  tree tmp;\n-\t  tmp = build_function_type_list (ptr_type_node,\n-\t\t\t\t\t  ptr_type_node, NULL_TREE);\n-\t  fn = push_throw_library_fn (fn, tmp);\n-\t}\n-      else if (really_overloaded_fn (fn))\n-\t{\n-\t  error (\"%qD should never be overloaded\", fn);\n-\t  return error_mark_node;\n-\t}\n-      fn = OVL_CURRENT (fn);\n-      exp = cp_build_function_call_nary (fn, tf_warning_or_error,\n-\t\t\t\t\t exp, NULL_TREE);\n-    }\n-  else if (exp)\n+  if (exp)\n     {\n       tree throw_type;\n       tree temp_type;"}, {"sha": "0d17370e46871f3b4a8d83ac148a2c0e6cc0cf7c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 75, "deletions": 181, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -2622,7 +2622,6 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   tree alloc_fn;\n   tree cookie_expr, init_expr;\n   int nothrow, check_new;\n-  int use_java_new = 0;\n   /* If non-NULL, the number of extra bytes to allocate at the\n      beginning of the storage allocated for an array-new expression in\n      order to store the number of elements.  */\n@@ -2866,149 +2865,97 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   bool member_new_p = false;\n \n   /* Allocate the object.  */\n-  if (vec_safe_is_empty (*placement) && TYPE_FOR_JAVA (elt_type))\n-    {\n-      tree class_addr;\n-      tree class_decl;\n-      static const char alloc_name[] = \"_Jv_AllocObject\";\n+  tree fnname;\n+  tree fns;\n \n-      if (!MAYBE_CLASS_TYPE_P (elt_type))\n-\t{\n-\t  error (\"%qT isn%'t a valid Java class type\", elt_type);\n-\t  return error_mark_node;\n-\t}\n+  fnname = ansi_opname (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n \n-      class_decl = build_java_class_ref (elt_type);\n-      if (class_decl == error_mark_node)\n-\treturn error_mark_node;\n+  member_new_p = !globally_qualified_p\n+\t\t && CLASS_TYPE_P (elt_type)\n+\t\t && (array_p\n+\t\t     ? TYPE_HAS_ARRAY_NEW_OPERATOR (elt_type)\n+\t\t     : TYPE_HAS_NEW_OPERATOR (elt_type));\n \n-      use_java_new = 1;\n-      if (!get_global_value_if_present (get_identifier (alloc_name),\n-\t\t\t\t\t&alloc_fn))\n+  if (member_new_p)\n+    {\n+      /* Use a class-specific operator new.  */\n+      /* If a cookie is required, add some extra space.  */\n+      if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n+\tsize = size_binop (PLUS_EXPR, size, cookie_size);\n+      else\n \t{\n-          if (complain & tf_error)\n-            error (\"call to Java constructor with %qs undefined\", alloc_name);\n-\t  return error_mark_node;\n+\t  cookie_size = NULL_TREE;\n+\t  /* No size arithmetic necessary, so the size check is\n+\t     not needed. */\n+\t  if (outer_nelts_check != NULL && inner_size == 1)\n+\t    outer_nelts_check = NULL_TREE;\n \t}\n-      else if (really_overloaded_fn (alloc_fn))\n+      /* Perform the overflow check.  */\n+      tree errval = TYPE_MAX_VALUE (sizetype);\n+      if (cxx_dialect >= cxx11 && flag_exceptions)\n+\terrval = throw_bad_array_new_length ();\n+      if (outer_nelts_check != NULL_TREE)\n+\tsize = fold_build3 (COND_EXPR, sizetype, outer_nelts_check,\n+\t\t\t    size, errval);\n+      /* Create the argument list.  */\n+      vec_safe_insert (*placement, 0, size);\n+      /* Do name-lookup to find the appropriate operator.  */\n+      fns = lookup_fnfields (elt_type, fnname, /*protect=*/2);\n+      if (fns == NULL_TREE)\n \t{\n-          if (complain & tf_error)\n-            error (\"%qD should never be overloaded\", alloc_fn);\n+\t  if (complain & tf_error)\n+\t    error (\"no suitable %qD found in class %qT\", fnname, elt_type);\n \t  return error_mark_node;\n \t}\n-      alloc_fn = OVL_CURRENT (alloc_fn);\n-      if (TREE_CODE (alloc_fn) != FUNCTION_DECL\n-\t  || TREE_CODE (TREE_TYPE (alloc_fn)) != FUNCTION_TYPE\n-\t  || !POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (alloc_fn))))\n+      if (TREE_CODE (fns) == TREE_LIST)\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"%qD is not a function returning a pointer\", alloc_fn);\n+\t    {\n+\t      error (\"request for member %qD is ambiguous\", fnname);\n+\t      print_candidates (fns);\n+\t    }\n \t  return error_mark_node;\n \t}\n-      class_addr = build1 (ADDR_EXPR, jclass_node, class_decl);\n-      alloc_call = cp_build_function_call_nary (alloc_fn, complain,\n-\t\t\t\t\t\tclass_addr, NULL_TREE);\n-    }\n-  else if (TYPE_FOR_JAVA (elt_type) && MAYBE_CLASS_TYPE_P (elt_type))\n-    {\n-      error (\"Java class %q#T object allocated using placement new\", elt_type);\n-      return error_mark_node;\n+      tree dummy = build_dummy_object (elt_type);\n+      alloc_call = NULL_TREE;\n+      if (align_arg)\n+\t{\n+\t  vec<tree, va_gc> *align_args\n+\t    = vec_copy_and_insert (*placement, align_arg, 1);\n+\t  alloc_call\n+\t    = build_new_method_call (dummy, fns, &align_args,\n+\t\t\t\t     /*conversion_path=*/NULL_TREE,\n+\t\t\t\t     LOOKUP_NORMAL, &alloc_fn, tf_none);\n+\t  /* If no matching function is found and the allocated object type\n+\t     has new-extended alignment, the alignment argument is removed\n+\t     from the argument list, and overload resolution is performed\n+\t     again.  */\n+\t  if (alloc_call == error_mark_node)\n+\t    alloc_call = NULL_TREE;\n+\t}\n+      if (!alloc_call)\n+\talloc_call = build_new_method_call (dummy, fns, placement,\n+\t\t\t\t\t    /*conversion_path=*/NULL_TREE,\n+\t\t\t\t\t    LOOKUP_NORMAL,\n+\t\t\t\t\t    &alloc_fn, complain);\n     }\n   else\n     {\n-      tree fnname;\n-      tree fns;\n-\n-      fnname = ansi_opname (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n-\n-      member_new_p = !globally_qualified_p\n-\t  && CLASS_TYPE_P (elt_type)\n-\t  && (array_p\n-\t      ? TYPE_HAS_ARRAY_NEW_OPERATOR (elt_type)\n-\t    : TYPE_HAS_NEW_OPERATOR (elt_type));\n-\n-      if (member_new_p)\n+      /* Use a global operator new.  */\n+      /* See if a cookie might be required.  */\n+      if (!(array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type)))\n \t{\n-\t  /* Use a class-specific operator new.  */\n-\t  /* If a cookie is required, add some extra space.  */\n-\t  if (array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type))\n-\t    size = size_binop (PLUS_EXPR, size, cookie_size);\n-\t  else\n-\t    {\n-\t      cookie_size = NULL_TREE;\n-\t      /* No size arithmetic necessary, so the size check is\n-\t\t not needed. */\n-\t      if (outer_nelts_check != NULL && inner_size == 1)\n-\t\touter_nelts_check = NULL_TREE;\n-\t    }\n-\t  /* Perform the overflow check.  */\n-\t  tree errval = TYPE_MAX_VALUE (sizetype);\n-\t  if (cxx_dialect >= cxx11 && flag_exceptions)\n-\t    errval = throw_bad_array_new_length ();\n-\t  if (outer_nelts_check != NULL_TREE)\n-            size = fold_build3 (COND_EXPR, sizetype, outer_nelts_check,\n-                                size, errval);\n-\t  /* Create the argument list.  */\n-\t  vec_safe_insert (*placement, 0, size);\n-\t  /* Do name-lookup to find the appropriate operator.  */\n-\t  fns = lookup_fnfields (elt_type, fnname, /*protect=*/2);\n-\t  if (fns == NULL_TREE)\n-\t    {\n-              if (complain & tf_error)\n-                error (\"no suitable %qD found in class %qT\", fnname, elt_type);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (TREE_CODE (fns) == TREE_LIST)\n-\t    {\n-              if (complain & tf_error)\n-                {\n-                  error (\"request for member %qD is ambiguous\", fnname);\n-                  print_candidates (fns);\n-                }\n-\t      return error_mark_node;\n-\t    }\n-\t  tree dummy = build_dummy_object (elt_type);\n-\t  alloc_call = NULL_TREE;\n-\t  if (align_arg)\n-\t    {\n-\t      vec<tree, va_gc> *align_args\n-\t\t= vec_copy_and_insert (*placement, align_arg, 1);\n-\t      alloc_call\n-\t\t= build_new_method_call (dummy, fns, &align_args,\n-\t\t\t\t\t /*conversion_path=*/NULL_TREE,\n-\t\t\t\t\t LOOKUP_NORMAL, &alloc_fn, tf_none);\n-\t      /* If no matching function is found and the allocated object type\n-\t\t has new-extended alignment, the alignment argument is removed\n-\t\t from the argument list, and overload resolution is performed\n-\t\t again.  */\n-\t      if (alloc_call == error_mark_node)\n-\t\talloc_call = NULL_TREE;\n-\t    }\n-\t  if (!alloc_call)\n-\t    alloc_call = build_new_method_call (dummy, fns, placement,\n-\t\t\t\t\t\t/*conversion_path=*/NULL_TREE,\n-\t\t\t\t\t\tLOOKUP_NORMAL,\n-\t\t\t\t\t\t&alloc_fn, complain);\n+\t  cookie_size = NULL_TREE;\n+\t  /* No size arithmetic necessary, so the size check is\n+\t     not needed. */\n+\t  if (outer_nelts_check != NULL && inner_size == 1)\n+\t    outer_nelts_check = NULL_TREE;\n \t}\n-      else\n-\t{\n-\t  /* Use a global operator new.  */\n-\t  /* See if a cookie might be required.  */\n-\t  if (!(array_p && TYPE_VEC_NEW_USES_COOKIE (elt_type)))\n-\t    {\n-\t      cookie_size = NULL_TREE;\n-\t      /* No size arithmetic necessary, so the size check is\n-\t\t not needed. */\n-\t      if (outer_nelts_check != NULL && inner_size == 1)\n-\t\touter_nelts_check = NULL_TREE;\n-\t    }\n \n-\t  alloc_call = build_operator_new_call (fnname, placement,\n-\t\t\t\t\t\t&size, &cookie_size,\n-\t\t\t\t\t\talign_arg,\n-\t\t\t\t\t\touter_nelts_check,\n-\t\t\t\t\t\t&alloc_fn, complain);\n-\t}\n+      alloc_call = build_operator_new_call (fnname, placement,\n+\t\t\t\t\t    &size, &cookie_size,\n+\t\t\t\t\t    align_arg, outer_nelts_check,\n+\t\t\t\t\t    &alloc_fn, complain);\n     }\n \n   if (alloc_call == error_mark_node)\n@@ -3111,7 +3058,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n      So check for a null exception spec on the op new we just called.  */\n \n   nothrow = TYPE_NOTHROW_P (TREE_TYPE (alloc_fn));\n-  check_new = (flag_check_new || nothrow) && ! use_java_new;\n+  check_new = (flag_check_new || nothrow);\n \n   if (cookie_size)\n     {\n@@ -3290,7 +3237,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t unambiguous matching deallocation function can be found,\n \t propagating the exception does not cause the object's memory to be\n \t freed.  */\n-      if (flag_exceptions && ! use_java_new)\n+      if (flag_exceptions)\n \t{\n \t  enum tree_code dcode = array_p ? VEC_DELETE_EXPR : DELETE_EXPR;\n \t  tree cleanup;\n@@ -3531,59 +3478,6 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   return rval;\n }\n-\n-/* Given a Java class, return a decl for the corresponding java.lang.Class.  */\n-\n-tree\n-build_java_class_ref (tree type)\n-{\n-  tree name = NULL_TREE, class_decl;\n-  static tree CL_suffix = NULL_TREE;\n-  if (CL_suffix == NULL_TREE)\n-    CL_suffix = get_identifier(\"class$\");\n-  if (jclass_node == NULL_TREE)\n-    {\n-      jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jclass\"));\n-      if (jclass_node == NULL_TREE)\n-\t{\n-\t  error (\"call to Java constructor, while %<jclass%> undefined\");\n-\t  return error_mark_node;\n-\t}\n-      jclass_node = TREE_TYPE (jclass_node);\n-    }\n-\n-  /* Mangle the class$ field.  */\n-  {\n-    tree field;\n-    for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n-      if (DECL_NAME (field) == CL_suffix)\n-\t{\n-\t  mangle_decl (field);\n-\t  name = DECL_ASSEMBLER_NAME (field);\n-\t  break;\n-\t}\n-    if (!field)\n-      {\n-\terror (\"can%'t find %<class$%> in %qT\", type);\n-\treturn error_mark_node;\n-      }\n-  }\n-\n-  class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n-  if (class_decl == NULL_TREE)\n-    {\n-      class_decl = build_decl (input_location,\n-\t\t\t       VAR_DECL, name, TREE_TYPE (jclass_node));\n-      TREE_STATIC (class_decl) = 1;\n-      DECL_EXTERNAL (class_decl) = 1;\n-      TREE_PUBLIC (class_decl) = 1;\n-      DECL_ARTIFICIAL (class_decl) = 1;\n-      DECL_IGNORED_P (class_decl) = 1;\n-      pushdecl_top_level (class_decl);\n-      make_decl_rtl (class_decl);\n-    }\n-  return class_decl;\n-}\n \f\n static tree\n build_vec_delete_1 (tree base, tree maxindex, tree type,"}, {"sha": "eec8b5dca23bb6442e75513fd9066bd44aa78c51", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -37,7 +37,6 @@ static void handle_pragma_vtable (cpp_reader *);\n static void handle_pragma_unit (cpp_reader *);\n static void handle_pragma_interface (cpp_reader *);\n static void handle_pragma_implementation (cpp_reader *);\n-static void handle_pragma_java_exceptions (cpp_reader *);\n \n static void init_operators (void);\n static void copy_lang_type (tree);\n@@ -71,9 +70,6 @@ struct impl_files\n };\n \n static struct impl_files *impl_file_chain;\n-\n-/* True if we saw \"#pragma GCC java_exceptions\".  */\n-bool pragma_java_exceptions;\n \f\n void\n cxx_finish (void)\n@@ -210,7 +206,6 @@ init_cp_pragma (void)\n   c_register_pragma (0, \"implementation\", handle_pragma_implementation);\n   c_register_pragma (\"GCC\", \"interface\", handle_pragma_interface);\n   c_register_pragma (\"GCC\", \"implementation\", handle_pragma_implementation);\n-  c_register_pragma (\"GCC\", \"java_exceptions\", handle_pragma_java_exceptions);\n }\n \f\n /* TRUE if a code represents a statement.  */\n@@ -427,18 +422,6 @@ handle_pragma_implementation (cpp_reader* /*dfile*/)\n     }\n }\n \n-/* Indicate that this file uses Java-personality exception handling.  */\n-static void\n-handle_pragma_java_exceptions (cpp_reader* /*dfile*/)\n-{\n-  tree x;\n-  if (pragma_lex (&x) != CPP_EOF)\n-    warning (0, \"junk at end of #pragma GCC java_exceptions\");\n-\n-  choose_personality_routine (lang_java);\n-  pragma_java_exceptions = true;\n-}\n-\n /* Issue an error message indicating that the lookup of NAME (an\n    IDENTIFIER_NODE) failed.  Returns the ERROR_MARK_NODE.  */\n \n@@ -580,8 +563,6 @@ retrofit_lang_decl (tree t)\n     SET_DECL_LANGUAGE (t, lang_cplusplus);\n   else if (current_lang_name == lang_name_c)\n     SET_DECL_LANGUAGE (t, lang_c);\n-  else if (current_lang_name == lang_name_java)\n-    SET_DECL_LANGUAGE (t, lang_java);\n   else\n     gcc_unreachable ();\n "}, {"sha": "9f86e914afedce346a6c55e7cd53c1ff505584a1", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -239,10 +239,6 @@ static bool equal_abi_tags (tree, tree);\n static inline void start_mangling (const tree);\n static tree mangle_special_for_type (const tree, const char *);\n \n-/* Foreign language functions.  */\n-\n-static void write_java_integer_type_codes (const tree);\n-\n /* Append a single character to the end of the mangled\n    representation.  */\n #define write_char(CHAR)\t\t\t\t\t\t\\\n@@ -2436,8 +2432,6 @@ write_builtin_type (tree type)\n \twrite_string (\"Ds\");\n       else if (type == char32_type_node)\n \twrite_string (\"Di\");\n-      else if (TYPE_FOR_JAVA (type))\n-\twrite_java_integer_type_codes (type);\n       else\n \t{\n \t  size_t itk;\n@@ -2492,11 +2486,9 @@ write_builtin_type (tree type)\n       break;\n \n     case REAL_TYPE:\n-      if (type == float_type_node\n-\t  || type == java_float_type_node)\n+      if (type == float_type_node)\n \twrite_char ('f');\n-      else if (type == double_type_node\n-\t       || type == java_double_type_node)\n+      else if (type == double_type_node)\n \twrite_char ('d');\n       else if (type == long_double_type_node)\n \twrite_char ('e');\n@@ -2621,40 +2613,16 @@ write_function_type (const tree type)\n /* Non-terminal <bare-function-type>.  TYPE is a FUNCTION_TYPE or\n    METHOD_TYPE.  If INCLUDE_RETURN_TYPE is nonzero, the return value\n    is mangled before the parameter types.  If non-NULL, DECL is\n-   FUNCTION_DECL for the function whose type is being emitted.\n-\n-   If DECL is a member of a Java type, then a literal 'J'\n-   is output and the return type is mangled as if INCLUDE_RETURN_TYPE\n-   were nonzero.\n-\n-     <bare-function-type> ::= [J]</signature/ type>+  */\n+   FUNCTION_DECL for the function whose type is being emitted.  */\n \n static void\n write_bare_function_type (const tree type, const int include_return_type_p,\n \t\t\t  const tree decl)\n {\n-  int java_method_p;\n-\n   MANGLE_TRACE_TREE (\"bare-function-type\", type);\n \n-  /* Detect Java methods and emit special encoding.  */\n-  if (decl != NULL\n-      && DECL_FUNCTION_MEMBER_P (decl)\n-      && TYPE_FOR_JAVA (DECL_CONTEXT (decl))\n-      && !DECL_CONSTRUCTOR_P (decl)\n-      && !DECL_DESTRUCTOR_P (decl)\n-      && !DECL_CONV_FN_P (decl))\n-    {\n-      java_method_p = 1;\n-      write_char ('J');\n-    }\n-  else\n-    {\n-      java_method_p = 0;\n-    }\n-\n   /* Mangle the return type, if requested.  */\n-  if (include_return_type_p || java_method_p)\n+  if (include_return_type_p)\n     write_type (TREE_TYPE (type));\n \n   /* Now mangle the types of the arguments.  */\n@@ -4264,30 +4232,6 @@ mangle_ref_init_variable (const tree variable)\n   return finish_mangling_get_identifier ();\n }\n \f\n-\n-/* Foreign language type mangling section.  */\n-\n-/* How to write the type codes for the integer Java type.  */\n-\n-static void\n-write_java_integer_type_codes (const tree type)\n-{\n-  if (type == java_int_type_node)\n-    write_char ('i');\n-  else if (type == java_short_type_node)\n-    write_char ('s');\n-  else if (type == java_byte_type_node)\n-    write_char ('c');\n-  else if (type == java_char_type_node)\n-    write_char ('w');\n-  else if (type == java_long_type_node)\n-    write_char ('x');\n-  else if (type == java_boolean_type_node)\n-    write_char ('b');\n-  else\n-    gcc_unreachable ();\n-}\n-\n /* Given a CLASS_TYPE, such as a record for std::bad_exception this\n    function generates a mangled name for the vtable map variable of\n    the class type.  For example, if the class type is"}, {"sha": "bbbf59be6be765545dec799fc24711f6e483c2a3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -1765,7 +1765,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \n   type = TYPE_MAIN_VARIANT (type);\n \n-  if (targetm.cxx.cdtor_returns_this () && !TYPE_FOR_JAVA (type))\n+  if (targetm.cxx.cdtor_returns_this ())\n     {\n       if (kind == sfk_destructor)\n \t/* See comment in check_special_function_return_type.  */"}, {"sha": "1bce63bb2dd75f8d92bb36767be361fd8e7edda3", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -6054,9 +6054,6 @@ pushtag_1 (tree name, tree type, tag_scope scope)\n \t      && b->level_chain->kind == sk_class))\n \tin_class = 1;\n \n-      if (current_lang_name == lang_name_java)\n-\tTYPE_FOR_JAVA (type) = 1;\n-\n       tdef = create_implicit_typedef (name, type);\n       DECL_CONTEXT (tdef) = FROB_CONTEXT (context);\n       if (scope == ts_within_enclosing_non_class)"}, {"sha": "2fd1aac5d5d0a32bb7c2b287114c2208bd6001cc", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -893,7 +893,6 @@ maybe_new_partial_specialization (tree type)\n       // for the newly declared specialization.\n       tree t = make_class_type (TREE_CODE (type));\n       CLASSTYPE_DECLARED_CLASS (t) = CLASSTYPE_DECLARED_CLASS (type);\n-      TYPE_FOR_JAVA (t) = TYPE_FOR_JAVA (type);\n       SET_TYPE_TEMPLATE_INFO (t, build_template_info (tmpl, args));\n \n       /* We only need a separate type node for storing the definition of this\n@@ -8453,7 +8452,6 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \t  CLASSTYPE_DECLARED_CLASS (t)\n \t    = CLASSTYPE_DECLARED_CLASS (template_type);\n \t  SET_CLASSTYPE_IMPLICIT_INSTANTIATION (t);\n-\t  TYPE_FOR_JAVA (t) = TYPE_FOR_JAVA (template_type);\n \n \t  /* A local class.  Make sure the decl gets registered properly.  */\n \t  if (context == current_function_decl)\n@@ -9918,7 +9916,6 @@ instantiate_class_template_1 (tree type)\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);\n   SET_TYPE_ALIGN (type, TYPE_ALIGN (pattern));\n   TYPE_USER_ALIGN (type) = TYPE_USER_ALIGN (pattern);\n-  TYPE_FOR_JAVA (type) = TYPE_FOR_JAVA (pattern); /* For libjava's JArray<T> */\n   if (ANON_AGGR_TYPE_P (pattern))\n     SET_ANON_AGGR_TYPE_P (type);\n   if (CLASSTYPE_VISIBILITY_SPECIFIED (pattern))"}, {"sha": "c3853e370d199262e6b4dd7ba4d4ef6d7e2e1ac1", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -42,7 +42,6 @@ static tree count_trees_r (tree *, int *, void *);\n static tree verify_stmt_tree_r (tree *, int *, void *);\n static tree build_local_temp (tree);\n \n-static tree handle_java_interface_attribute (tree *, tree, tree, int, bool *);\n static tree handle_init_priority_attribute (tree *, tree, tree, int, bool *);\n static tree handle_abi_tag_attribute (tree *, tree, tree, int, bool *);\n \n@@ -3638,8 +3637,6 @@ const struct attribute_spec cxx_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n        affects_type_identity } */\n-  { \"java_interface\", 0, 0, false, false, false,\n-    handle_java_interface_attribute, false },\n   { \"init_priority\",  1, 1, true,  false, false,\n     handle_init_priority_attribute, false },\n   { \"abi_tag\", 1, -1, false, false, false,\n@@ -3659,31 +3656,6 @@ const struct attribute_spec std_attribute_table[] =\n   { NULL,\t      0, 0, false, false, false, NULL, false }\n };\n \n-/* Handle a \"java_interface\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-static tree\n-handle_java_interface_attribute (tree* node,\n-\t\t\t\t tree name,\n-\t\t\t\t tree /*args*/,\n-\t\t\t\t int flags,\n-\t\t\t\t bool* no_add_attrs)\n-{\n-  if (DECL_P (*node)\n-      || !CLASS_TYPE_P (*node)\n-      || !TYPE_FOR_JAVA (*node))\n-    {\n-      error (\"%qE attribute can only be applied to Java class definitions\",\n-\t     name);\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-  if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-    *node = build_variant_type_copy (*node);\n-  TYPE_JAVA_INTERFACE (*node) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n /* Handle an \"init_priority\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree"}, {"sha": "c70cfc80ff796b36fee541fabfcd4a2db6f163a3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -1226,8 +1226,6 @@ structural_comptypes (tree t1, tree t2, int strict)\n        || TREE_CODE (t1) == METHOD_TYPE)\n       && type_memfn_rqual (t1) != type_memfn_rqual (t2))\n     return false;\n-  if (TYPE_FOR_JAVA (t1) != TYPE_FOR_JAVA (t2))\n-    return false;\n \n   /* Allow for two different type nodes which have essentially the same\n      definition.  Note that we already checked for equality of the type"}, {"sha": "49367f540f083ddfaf5934eda0395c34c60afb29", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -21392,7 +21392,6 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n * Namespace Association:: Strong using-directives for namespace association.\n * Type Traits::         Compiler support for type traits.\n * C++ Concepts::        Improved support for generic programming.\n-* Java Exceptions::     Tweaking exception handling to work with Java.\n * Deprecated Features:: Things will disappear from G++.\n * Backwards Compatibility:: Compatibilities with earlier definitions of C++.\n @end menu\n@@ -21937,14 +21936,6 @@ Some_Class  B  __attribute__ ((init_priority (543)));\n Note that the particular values of @var{priority} do not matter; only their\n relative ordering.\n \n-@item java_interface\n-@cindex @code{java_interface} type attribute\n-\n-This type attribute informs C++ that the class is a Java interface.  It may\n-only be applied to classes declared within an @code{extern \"Java\"} block.\n-Calls to methods declared in this interface are dispatched using GCJ's\n-interface table mechanism, instead of regular virtual table dispatch.\n-\n @item warn_unused\n @cindex @code{warn_unused} type attribute\n \n@@ -22252,41 +22243,6 @@ A binary type trait: true whenever the type arguments are the same.\n @end table\n \n \n-@node Java Exceptions\n-@section Java Exceptions\n-\n-The Java language uses a slightly different exception handling model\n-from C++.  Normally, GNU C++ automatically detects when you are\n-writing C++ code that uses Java exceptions, and handle them\n-appropriately.  However, if C++ code only needs to execute destructors\n-when Java exceptions are thrown through it, GCC guesses incorrectly.\n-Sample problematic code is:\n-\n-@smallexample\n-  struct S @{ ~S(); @};\n-  extern void bar();    // @r{is written in Java, and may throw exceptions}\n-  void foo()\n-  @{\n-    S s;\n-    bar();\n-  @}\n-@end smallexample\n-\n-@noindent\n-The usual effect of an incorrect guess is a link failure, complaining of\n-a missing routine called @samp{__gxx_personality_v0}.\n-\n-You can inform the compiler that Java exceptions are to be used in a\n-translation unit, irrespective of what it might think, by writing\n-@samp{@w{#pragma GCC java_exceptions}} at the head of the file.  This\n-@samp{#pragma} must appear before any functions that throw or catch\n-exceptions, or run destructors when exceptions are thrown through them.\n-\n-You cannot mix Java and C++ exceptions in the same translation unit.  It\n-is believed to be safe to throw a C++ exception from one file through\n-another file compiled for the Java exception model, or vice versa, but\n-there may be bugs in this area.\n-\n @node Deprecated Features\n @section Deprecated Features\n "}, {"sha": "ef45ca1ca3b7ced9eddf54c9679d931ee5b113b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfecd57cd46ac368213f55fc4a3ff67c8c59c5ea", "patch": "@@ -1,3 +1,18 @@\n+2016-10-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* g++.dg/other/java3.C: Remove.\n+\t* g++.dg/other/java1.C: Remove.\n+\t* g++.dg/other/error12.C: Remove.\n+\t* g++.dg/other/java2.C: Remove.\n+\t* g++.dg/warn/Wnvdtor.C: Remove.\n+\t* g++.dg/lookup/java1.C: Remove.\n+\t* g++.dg/lookup/java2.C: Remove.\n+\t* g++.dg/ext/pr34829.C: Remove.\n+\t* g++.dg/ext/java-3.C: Remove.\n+\t* g++.dg/ext/java-1.C: Remove.\n+\t* g++.dg/ext/java-2.C: Remove.\n+\t* g++.old-deja/g++.oliva/dwarf2.C: Remove.\n+\n 2016-10-04  Doug Gilmore  <doug.gilmore@imgtec.com>\n \n \tPR tree-optimization/77808"}, {"sha": "f88e1fcab5da99be173d42d1fbabf0ec8ed648df", "filename": "gcc/testsuite/g++.dg/ext/java-1.C", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-1.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,26 +0,0 @@\n-// { dg-do compile { target { ! { powerpc-ibm-aix* } } } }\n-// { dg-options \"\" }\n-// Test extern \"java\" and some throwing of the objects.\n-\n-extern \"Java\"\n-  namespace java\n-  {\n-    namespace lang\n-    {\n-      class Throwable;\n-      class Class;\n-  }\n-}\n-typedef class java::lang::Throwable* jthrowable;\n-typedef class java::lang::Class* jclass;\n-class java::lang::Throwable {\n-public:\n-  static jclass class$;\n-};\n-int\n-_Jv_FindClassFromSignature ( )\n-  try \n-    {\n-    }\n-  catch (java::lang::Throwable *ncdfe) {} \n-"}, {"sha": "8114517b942c685af0b57e3bfe7af02828c0ff8b", "filename": "gcc/testsuite/g++.dg/ext/java-2.C", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-2.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,79 +0,0 @@\n-// PR c++/30293\n-// PR c++/30294\n-// { dg-do compile { target { ! { powerpc-ibm-aix* } } } }\n-// { dg-options \"\" }\n-\n-extern \"Java\" {\n-typedef __java_byte jbyte;\n-namespace java {\n-namespace lang {\n-  class Object {};\n-  class Class {};\n-}\n-}\n-typedef struct java::lang::Object* jobject;\n-typedef java::lang::Class *jclass;\n-}\n-extern \"C\" jobject _Jv_AllocObject (jclass);\n-\n-extern \"Java\" {\n-  struct A { static java::lang::Class class$; };\n-}\n-\n-struct B {\n-  A a;\t\t// { dg-error \"has Java class type\" }\n-};\n-\n-void* operator new (__SIZE_TYPE__, void*) throw();\n-char buf[1024];\n-\n-A a;\t\t// { dg-error \"not allocated with\" }\n-A b = A ();\t// { dg-error \"not allocated with\" }\n-A *c = new ((void *) buf) A ();\t// { dg-error \"using placement new\" }\n-A *d = new A ();\n-jbyte e = 6;\n-\n-const A fn1 ()\t// { dg-error \"return type has Java class type\" }\n-{\n-  A a;\t\t// { dg-error \"not allocated with\" }\n-  return a;\n-}\n-\n-A fn2 ()\t// { dg-error \"return type has Java class type\" }\n-{\n-  A a;\t\t// { dg-error \"not allocated with\" }\n-  return a;\n-}\n-\n-A *fn3 ()\n-{\n-  return new A ();\n-}\n-\n-A &fn4 ()\n-{\n-  return *c;\n-}\n-\n-jbyte fn5 ()\n-{\n-  return 7;\n-}\n-\n-void fn6 (A x)\t// { dg-error \"has Java class type\" }\n-{\n-}\n-\n-void fn7 (const A x)\t// { dg-error \"has Java class type\" }\n-{\n-}\n-\n-void fn8 (A *x)\n-{\n-  (void) x;\n-}\n-\n-void fn9 (jbyte x)\n-{\n-  (void) x;\n-}"}, {"sha": "128db653116dae0768fdf7d773ca0e19309d3d5e", "filename": "gcc/testsuite/g++.dg/ext/java-3.C", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fjava-3.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,39 +0,0 @@\n-// PR c++/70267\n-// { dg-do compile { target { ! { powerpc-ibm-aix* } } } }\n-// { dg-options \"-O2\" }\n-\n-extern \"Java\"\n-{\n-  typedef __java_int jint;\n-  namespace java\n-  {\n-    namespace lang\n-    {\n-      class Class;\n-      class Object;\n-      class Throwable {};\n-      class Foo;\n-    }\n-  }\n-} \n-\n-typedef struct java::lang::Object * jobject;\n-typedef struct java::lang::Throwable * jthrowable;\n-typedef class  java::lang::Class * jclass;\n-\n-using java::lang::Foo;\n-\n-class Foo: public java::lang::Throwable\n-{\n-  public:static::java::lang::Class class$;\n-};\n-\n-extern \"C\" Foo _Jv_AllocObject (jclass);\n-extern \"C\" void _Jv_Throw (jthrowable) __attribute__ ((__noreturn__));\n-\n-void \n-Bar4 (void)\n-{\n-  Foo * f = new java::lang::Foo;\t// { dg-error \"is not a function returning a pointer\" }\n-  throw (f);\n-}"}, {"sha": "d588b5b2bbd75a06d00ee95386537b56e4a5961d", "filename": "gcc/testsuite/g++.dg/ext/pr34829.C", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpr34829.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpr34829.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpr34829.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,22 +0,0 @@\n-// Test for PR c++/34829\n-// Placement new should be ok for non-aggregate Java types.\n-\n-// { dg-do compile }\n-// { dg-options \"\" }\n-\n-extern \"Java\"\n-{\n-  typedef __java_byte jbyte;\n-}\n-\n-typedef __SIZE_TYPE__ size_t;\n-\n-void *operator new (size_t, void *m)\n-{\n-  return m;\n-}\n-\n-jbyte *f(void *memory)\n-{\n-  return new (memory) jbyte;\n-}"}, {"sha": "0d9b22ee1d55811361a56bd67fb93e6b35b353cd", "filename": "gcc/testsuite/g++.dg/lookup/java1.C", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fjava1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fjava1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fjava1.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,68 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fdollars-in-identifiers\" }\n-// Origin: Giovanni Bajo <giovannibajo at libero dot it>\n-// Make sure that Java special functions can be called correctly.\n-\n-extern \"Java\"\n-{\n-  typedef __java_int jint;\n-  namespace java\n-  {\n-    namespace lang\n-    {\n-      class Class;\n-      class Object;\n-      class Throwable {};\n-      class Foo;\n-    }\n-  }\n-}\n-\n-typedef struct java::lang::Object* jobject;\n-typedef struct java::lang::Throwable* jthrowable;\n-typedef class java::lang::Class* jclass;\n-using java::lang::Foo;\n-\n-class Foo : public java::lang::Throwable\n-{\n-public:\n-  static ::java::lang::Class class$;\n-};\n-\n-\n-/*\n- * Step 1: no declarations. A declaration for _Jv_Throw is created.\n- */\n-\n-void Bar1(void)\n-{\n-  Foo* f = new java::lang::Foo;   // { dg-error \"call to Java constructor\" }\n-  throw (f);\n-}\n-\n-\n-/*\n- * Step 2: constructor declaration\n- */\n-\n-extern \"C\" jobject _Jv_AllocObject (jclass) __attribute__((__malloc__));\n-\n-void Bar2(void)\n-{\n-  Foo* f = new java::lang::Foo; \n-  throw (f);  \n-}\n-\n-\n-/*\n- * Step 3: overloads\n- */\n-\n-jobject _Jv_AllocObject (jclass, jint, float) __attribute__((__malloc__));\n-void _Jv_Throw (int, float) __attribute__ ((__noreturn__));\n-\n-void Bar3(void)\n-{\n-  Foo* f = new java::lang::Foo;\t  // { dg-error \"should never be overloaded\" }\n-  throw (f);\t\t\t  // { dg-error \"should never be overloaded\" }\n-}"}, {"sha": "26fd36922b626b64335bb92751d52712a3f5709a", "filename": "gcc/testsuite/g++.dg/lookup/java2.C", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fjava2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fjava2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fjava2.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,47 +0,0 @@\n-// { dg-do compile }\n-// { dg-options \"-fdollars-in-identifiers\" }\n-// Origin: Giovanni Bajo <giovannibajo at libero dot it>\n-// Make sure that Java special functions can be called correctly.\n-// (continue from java1.C)\n-\n-extern \"Java\"\n-{\n-  typedef __java_int jint;\n-  namespace java\n-  {\n-    namespace lang\n-    {\n-      class Class;\n-      class Object;\n-      class Throwable {};\n-      class Foo;\n-    }\n-  }\n-}\n-\n-typedef struct java::lang::Object* jobject;\n-typedef struct java::lang::Throwable* jthrowable;\n-typedef class java::lang::Class* jclass;\n-using java::lang::Foo;\n-\n-class Foo : public java::lang::Throwable\n-{\n-public:\n-  static ::java::lang::Class class$;\n-};\n-\n-/*\n- * Step 4: Manual declaration of _Jv_Throw\n- *  This is the last case we need to test. In the other file we're testing\n- *  the compiler is able to generate an artifical declaration for this \n- *  function, so we need to test here if it works with a normal declaration.\n- */\n-\n-extern \"C\" jobject _Jv_AllocObject (jclass) __attribute__((__malloc__));\n-extern \"C\" void _Jv_Throw (jthrowable) __attribute__ ((__noreturn__));\n-\n-void Bar4(void)\n-{\n-  Foo* f = new java::lang::Foo;\n-  throw (f);\n-}"}, {"sha": "253561e8febaff4d9d77a043bd5eee8060a40b4f", "filename": "gcc/testsuite/g++.dg/other/error12.C", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror12.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,9 +0,0 @@\n-//PR c++/28292\n-\n-extern \"Java\"\n-{\n-  struct A\n-  {\n-    void foo(void; // { dg-error \"before|incomplete type|invalid use\" }\n-  };\n-}"}, {"sha": "38b5e0c3070111a08438605c2960cd62f9801584", "filename": "gcc/testsuite/g++.dg/other/java1.C", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava1.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,22 +0,0 @@\n-// { dg-options \"-w -ansi -pedantic\" }\n-\n-// Copyright (C) 2003 Free Software Foundation, Inc.\n-// Contributed by Nathan Sidwell 23 Oct 2003 <nathan@codesourcery.com>\n-\n-extern \"Java\" {\n-  class One \n-  {\n-    ~One (); // { dg-error \"cannot have a destructor\" \"\" }\n-    One ();\n-  };\n-\n-  class Two {};\n-\n-  class Three : One {}; // { dg-error \"cannot have an implicit\" \"\" }\n-\n-  class Four : Two {};\n-\n-  class Five : Two, Four {}; //  { dg-error \"cannot have multiple bases\" \"\" }\n-\n-  class Six : virtual Two {}; // { dg-error \"cannot have virtual base\" \"\" }\n-}"}, {"sha": "8ba4d5a72c84a39f612207cf4d2bad5344f1f83f", "filename": "gcc/testsuite/g++.dg/other/java2.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava2.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,11 +0,0 @@\n-// PR c++/???\n-// { dg-do compile }\n-\n-extern \"Java\"\n-{\n-  struct A {};\n-}\n-\n-typedef void* jclass;\n-\n-A* p = new A;  // { dg-error \"class\\\\$\" }"}, {"sha": "1bc0a8874fe129fed6e20d0bf05c35cc19092da3", "filename": "gcc/testsuite/g++.dg/other/java3.C", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fjava3.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,7 +0,0 @@\n-// PR c++/11006\n-\n-typedef int* jclass;\n-\n-void foo () {\n-  new __java_boolean;  // { dg-error \"valid\" }\n-}"}, {"sha": "f03cff5b31ced686c5d1a03aa43907c613d584b9", "filename": "gcc/testsuite/g++.dg/warn/Wnvdtor.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWnvdtor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWnvdtor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWnvdtor.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,11 +0,0 @@\n-// { dg-options \"-Wnon-virtual-dtor\" }\n-\n-extern \"Java\"\n-{\n-  class Foo\n-  {\n-  public:\n-    virtual void bar( void);\n-  };\n-}\n-"}, {"sha": "c50b1b7d6be80edf81051a2d2cfc75d83597bc20", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/dwarf2.C", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fdwarf2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8b1e839ca91a61440288049a868944346eef4b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fdwarf2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Fdwarf2.C?ref=fe8b1e839ca91a61440288049a868944346eef4b", "patch": "@@ -1,10 +0,0 @@\n-// { dg-do assemble }\n-\n-// Copyright (C) 1999 Free Software Foundation\n-\n-// by Alexandre Oliva <oliva@dcc.unicamp.br>\n-\n-// Fails with dwarf debugging.\n-\n-typedef __java_boolean jboolean;\n-void foo() {}"}]}