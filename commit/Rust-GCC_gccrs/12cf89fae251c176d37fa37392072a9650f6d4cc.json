{"sha": "12cf89fae251c176d37fa37392072a9650f6d4cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJjZjg5ZmFlMjUxYzE3NmQzN2ZhMzczOTIwNzJhOTY1MGY2ZDRjYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-12T01:33:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-12T01:33:47Z"}, "message": "call.c (build_operator_new_call): Avoid using push_to_top_level.\n\n\t* call.c (build_operator_new_call): Avoid using push_to_top_level.\n\t(build_new_op): Adjust call to lookup_function_nonclass.\n\t* name-lookup.c (identifier_type_value): Adjust call to\n\tlookup_name_real.\n\t(lookup_name_real): Add block_p parameter.\n\t(lookup_name_nonclass): Adjust call to lookup_name_real.\n\t(lookup_function_nonclass): Likewise.\n\t(lookup_name): Likewise.\n\t* name-lookup.h (lookup_name_real): Change prototype.\n\t(lookup_name_nonclass): Likewise.\n\t* parser.c (cp_parser_lookup_name): Likewise.\n\nFrom-SVN: r84543", "tree": {"sha": "7a29bc1859143741c7e914f78e715d6ffa1d2baf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a29bc1859143741c7e914f78e715d6ffa1d2baf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12cf89fae251c176d37fa37392072a9650f6d4cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12cf89fae251c176d37fa37392072a9650f6d4cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12cf89fae251c176d37fa37392072a9650f6d4cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12cf89fae251c176d37fa37392072a9650f6d4cc/comments", "author": null, "committer": null, "parents": [{"sha": "597073ace8549d2a934a1fe7d9402e1f63e91220", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/597073ace8549d2a934a1fe7d9402e1f63e91220", "html_url": "https://github.com/Rust-GCC/gccrs/commit/597073ace8549d2a934a1fe7d9402e1f63e91220"}], "stats": {"total": 105, "additions": 66, "deletions": 39}, "files": [{"sha": "e8cef5fa1cbdae85c2ecce191daf2a148095cba7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=12cf89fae251c176d37fa37392072a9650f6d4cc", "patch": "@@ -1,5 +1,17 @@\n 2004-07-11  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* call.c (build_operator_new_call): Avoid using push_to_top_level.\n+\t(build_new_op): Adjust call to lookup_function_nonclass.\n+\t* name-lookup.c (identifier_type_value): Adjust call to\n+\tlookup_name_real.\n+\t(lookup_name_real): Add block_p parameter.\n+\t(lookup_name_nonclass): Adjust call to lookup_name_real.\n+\t(lookup_function_nonclass): Likewise.\n+\t(lookup_name): Likewise.\n+\t* name-lookup.h (lookup_name_real): Change prototype.\n+\t(lookup_name_nonclass): Likewise.\n+\t* parser.c (cp_parser_lookup_name): Likewise.\n+\n \t* cp-tree.h (saved_scope): Make old_bindings a vector.\n \t(unuse_fields): Remove.\n \t* name-lookup.h (cxx_saved_binding): Define it."}, {"sha": "b4f4dbbcab03643cb5765a5baec20eb23ddd3fb8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=12cf89fae251c176d37fa37392072a9650f6d4cc", "patch": "@@ -2812,10 +2812,16 @@ build_operator_new_call (tree fnname, tree args, tree *size, tree *cookie_size)\n   if (args == error_mark_node)\n     return args;\n \n-  /* A global operator new must be looked up only at global scope.  */\n-  push_to_top_level();\n-  fns = lookup_function_nonclass (fnname, args);\n-  pop_from_top_level();\n+  /* Based on:\n+\n+       [expr.new]\n+\n+       If this lookup fails to find the name, or if the allocated type\n+       is not a class type, the allocation function's name is looked\n+       up in the global scope.\n+\n+     we disregard block-scope declarations of \"operator new\".  */\n+  fns = lookup_function_nonclass (fnname, args, /*block_p=*/false);\n \n   /* Figure out what function is being called.  */\n   cand = perform_overload_resolution (fns, args, &candidates, &any_viable_p);\n@@ -3636,7 +3642,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \n   /* Add namespace-scope operators to the list of functions to\n      consider.  */\n-  add_candidates (lookup_function_nonclass (fnname, arglist),\n+  add_candidates (lookup_function_nonclass (fnname, arglist, /*block_p=*/true),\n \t\t  arglist, NULL_TREE, false, NULL_TREE, NULL_TREE,\n \t\t  flags, &candidates);\n   /* Add class-member operators to the candidate set.  */"}, {"sha": "fb043af52c7f4839ddfc86ee6540ae3289ae728b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=12cf89fae251c176d37fa37392072a9650f6d4cc", "patch": "@@ -1745,7 +1745,7 @@ identifier_type_value (tree id)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, REAL_IDENTIFIER_TYPE_VALUE (id));\n   /* Have to search for it. It must be on the global level, now.\n      Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, 2, 1, 0, LOOKUP_COMPLAIN);\n+  id = lookup_name_real (id, 2, 1, /*block_p=*/true, 0, LOOKUP_COMPLAIN);\n   if (id)\n     POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_TYPE (id));\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n@@ -3998,10 +3998,13 @@ qualified_lookup_using_namespace (tree name, tree scope,\n    Otherwise we prefer non-TYPE_DECLs.\n \n    If NONCLASS is nonzero, we don't look for the NAME in class scope,\n-   using IDENTIFIER_CLASS_VALUE.  */\n+   using IDENTIFIER_CLASS_VALUE.  \n+\n+   If BLOCK_P is true, block scopes are examined; otherwise, they are\n+   skipped.  */\n \n tree\n-lookup_name_real (tree name, int prefer_type, int nonclass, \n+lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n \t\t  int namespaces_only, int flags)\n {\n   cxx_binding *iter;\n@@ -4044,29 +4047,30 @@ lookup_name_real (tree name, int prefer_type, int nonclass,\n   if (current_class_type == NULL_TREE)\n     nonclass = 1;\n \n-  for (iter = IDENTIFIER_BINDING (name); iter; iter = iter->previous)\n-    {\n-      tree binding;\n-\n-      if (!LOCAL_BINDING_P (iter) && nonclass)\n-\t/* We're not looking for class-scoped bindings, so keep going.  */\n-\tcontinue;\n-\n-      /* If this is the kind of thing we're looking for, we're done.  */\n-      if (qualify_lookup (iter->value, flags))\n-\tbinding = iter->value;\n-      else if ((flags & LOOKUP_PREFER_TYPES)\n-\t       && qualify_lookup (iter->type, flags))\n-\tbinding = iter->type;\n-      else\n-\tbinding = NULL_TREE;\n-\n-      if (binding)\n-\t{\n-\t  val = binding;\n-\t  break;\n-\t}\n-    }\n+  if (block_p || !nonclass)\n+    for (iter = IDENTIFIER_BINDING (name); iter; iter = iter->previous)\n+      {\n+\ttree binding;\n+\t\n+\t/* Skip entities we don't want.  */\n+\tif (LOCAL_BINDING_P (iter) ? !block_p : nonclass)\n+\t  continue;\n+\t\n+\t/* If this is the kind of thing we're looking for, we're done.  */\n+\tif (qualify_lookup (iter->value, flags))\n+\t  binding = iter->value;\n+\telse if ((flags & LOOKUP_PREFER_TYPES)\n+\t\t && qualify_lookup (iter->type, flags))\n+\t  binding = iter->type;\n+\telse\n+\t  binding = NULL_TREE;\n+\t\n+\tif (binding)\n+\t  {\n+\t    val = binding;\n+\t    break;\n+\t  }\n+      }\n \n   /* Now lookup in namespace scopes.  */\n   if (!val)\n@@ -4089,19 +4093,24 @@ lookup_name_real (tree name, int prefer_type, int nonclass,\n tree\n lookup_name_nonclass (tree name)\n {\n-  return lookup_name_real (name, 0, 1, 0, LOOKUP_COMPLAIN);\n+  return lookup_name_real (name, 0, 1, /*block_p=*/true, 0, LOOKUP_COMPLAIN);\n }\n \n tree\n-lookup_function_nonclass (tree name, tree args)\n+lookup_function_nonclass (tree name, tree args, bool block_p)\n {\n-  return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n+  return \n+    lookup_arg_dependent (name, \n+\t\t\t  lookup_name_real (name, 0, 1, block_p, 0, \n+\t\t\t\t\t    LOOKUP_COMPLAIN),\n+\t\t\t  args);\n }\n \n tree\n lookup_name (tree name, int prefer_type)\n {\n-  return lookup_name_real (name, prefer_type, 0, 0, LOOKUP_COMPLAIN);\n+  return lookup_name_real (name, prefer_type, 0, /*block_p=*/true, \n+\t\t\t   0, LOOKUP_COMPLAIN);\n }\n \n /* Similar to `lookup_name' but look only in the innermost non-class"}, {"sha": "1b35b466a53e5b652f23575fa417416027eb1461", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=12cf89fae251c176d37fa37392072a9650f6d4cc", "patch": "@@ -304,13 +304,13 @@ extern tree pushdecl_with_scope (tree, cxx_scope *);\n extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n extern tree lookup_tag_reverse (tree, tree);\n extern tree lookup_name\t(tree, int);\n-extern tree lookup_name_real (tree, int, int, int, int);\n+extern tree lookup_name_real (tree, int, int, bool, int, int);\n extern tree namespace_binding (tree, tree);\n extern void set_namespace_binding (tree, tree, tree);\n extern tree lookup_namespace_name (tree, tree);\n extern tree lookup_qualified_name (tree, tree, bool, bool);\n extern tree lookup_name_nonclass (tree);\n-extern tree lookup_function_nonclass (tree, tree);\n+extern tree lookup_function_nonclass (tree, tree, bool);\n extern void push_local_binding (tree, tree, int);\n extern int push_class_binding (tree, tree);\n extern bool pushdecl_class_level (tree);"}, {"sha": "a7fe73db722c520c7c1433d3a1d859a8f558f4b9", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12cf89fae251c176d37fa37392072a9650f6d4cc/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=12cf89fae251c176d37fa37392072a9650f6d4cc", "patch": "@@ -14245,7 +14245,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t\t     /*protect=*/0, is_type);\n       /* Look it up in the enclosing context, too.  */\n       decl = lookup_name_real (name, is_type, /*nonclass=*/0,\n-\t\t\t       is_namespace,\n+\t\t\t       /*block_p=*/true, is_namespace,\n \t\t\t       /*flags=*/0);\n       parser->object_scope = object_type;\n       parser->qualifying_scope = NULL_TREE;\n@@ -14255,7 +14255,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n   else\n     {\n       decl = lookup_name_real (name, is_type, /*nonclass=*/0,\n-\t\t\t       is_namespace,\n+\t\t\t       /*block_p=*/true, is_namespace,\n \t\t\t       /*flags=*/0);\n       parser->qualifying_scope = NULL_TREE;\n       parser->object_scope = NULL_TREE;"}]}