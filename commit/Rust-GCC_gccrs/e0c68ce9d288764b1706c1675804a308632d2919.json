{"sha": "e0c68ce9d288764b1706c1675804a308632d2919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBjNjhjZTlkMjg4NzY0YjE3MDZjMTY3NTgwNGEzMDg2MzJkMjkxOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2008-09-04T17:32:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2008-09-04T17:32:38Z"}, "message": "rtl.h (LABEL_REF_NONLOCAL_P): Don't check for REG_LABEL_OPERAND or REG_LABEL_TARGET.\n\n./:\t* rtl.h (LABEL_REF_NONLOCAL_P): Don't check for REG_LABEL_OPERAND\n\tor REG_LABEL_TARGET.\n\t* calls.c (emit_library_call_value_1): Use MEM_P rather than\n\tcomparing MODE with MEM.\n\t* gimple.c (gimple_build_predict): Cast END_PREDICTORS before\n\tcomparing with GF_PREDICT_TAKEN.\n\t(gimple_get_lhs): Change code to enum gimple_code.\n\t(gimple_set_lhs): Likewise.\n\t* ifcvt.c (noce_process_if_block): Correct GET_MODE to GET_CODE.\n\t* omp-low.c (find_omp_clause): Change kind parameter to enum\n\tomp_clause_code.\n\t* tree-flow.h (find_omp_clause): Update declaration.\n\t* regrename.c (clear_dead_regs): Change kind parameter to enum\n\treg_note.\n\t* reload1.c (eliminate_regs_1): Use REG_NOTE_KIND rather than\n\tGET_MODE.\n\t* see.c (see_get_extension_data): Change return type to enum\n\tentry_type.  Change UNKNOWN to NOT_RELEVANT, SIGN_EXTEND to\n\tSIGNED_EXTENDED_DEF, ZERO_EXTEND to ZERO_EXTENDED_DEF.\n\t(see_gen_normalized_extension): Change extension_code parameter to\n\tenum entry_type.\n\t(see_seek_pre_extension_expr): Change extension_code to enum\n\tentry_type.\n\t(see_merge_one_def_extension): Likewise.\n\t(see_handle_relevant_defs): Likewise.\n\t(see_handle_relevant_uses): Likewise.\n\t(see_analyze_one_def): Likewise.\n\t* tree-cfg.c (need_fake_edge_p): Compare gimple code with\n\tGIMPLE_ASM rather than ASM_EXPR.\n\t* tree-ssa-alias.c (is_escape_site): Compare gimple code with\n\tGIMPLE_RETURN rather than RETURN_EXPR.\n\t* tree-ssa-ccp.c (likely_value): Change code to enum gimple_code.\n\t(evaluate_stmt): Likewise.\n\t* tree-vect-analyze.c (vect_analyze_operations): Change relevance\n\tto enum vect_relevant.\n\t(vect_mark_stmts_to_be_vectorized): Change assertion to not\n\tcompare gimple codes with tree codes.\ncp/:\n\t* parser.c (check_no_duplicate_clause): Change code parameter to\n\tenum omp_clause_code.\nfortran/:\n\t* symbol.c (generate_isocbinding_symbol): Compare\n\tgfc_notification_std with ERROR rather than FAILURE.\n\t* resolve.c (check_assumed_size_reference): Compare array type\n\twith AR_FULL rather than DIMEN_ELEMENT.\n\t(resolve_actual_arglist): Compare with EXPR_VARIABLE rather than\n\tFL_VARIABLE.\n\nFrom-SVN: r139991", "tree": {"sha": "e7591f410b663abb31581a206c6aad6794cf2e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7591f410b663abb31581a206c6aad6794cf2e66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0c68ce9d288764b1706c1675804a308632d2919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c68ce9d288764b1706c1675804a308632d2919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c68ce9d288764b1706c1675804a308632d2919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c68ce9d288764b1706c1675804a308632d2919/comments", "author": null, "committer": null, "parents": [{"sha": "71062f1eb1d80f078873c97468d485024f7e8171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71062f1eb1d80f078873c97468d485024f7e8171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71062f1eb1d80f078873c97468d485024f7e8171"}], "stats": {"total": 165, "additions": 109, "deletions": 56}, "files": [{"sha": "375a50a2af3654133c8aca8fd1bc3a5614682497", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -1,3 +1,43 @@\n+2008-09-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* rtl.h (LABEL_REF_NONLOCAL_P): Don't check for REG_LABEL_OPERAND\n+\tor REG_LABEL_TARGET.\n+\t* calls.c (emit_library_call_value_1): Use MEM_P rather than\n+\tcomparing MODE with MEM.\n+\t* gimple.c (gimple_build_predict): Cast END_PREDICTORS before\n+\tcomparing with GF_PREDICT_TAKEN.\n+\t(gimple_get_lhs): Change code to enum gimple_code.\n+\t(gimple_set_lhs): Likewise.\n+\t* ifcvt.c (noce_process_if_block): Correct GET_MODE to GET_CODE.\n+\t* omp-low.c (find_omp_clause): Change kind parameter to enum\n+\tomp_clause_code.\n+\t* tree-flow.h (find_omp_clause): Update declaration.\n+\t* regrename.c (clear_dead_regs): Change kind parameter to enum\n+\treg_note.\n+\t* reload1.c (eliminate_regs_1): Use REG_NOTE_KIND rather than\n+\tGET_MODE.\n+\t* see.c (see_get_extension_data): Change return type to enum\n+\tentry_type.  Change UNKNOWN to NOT_RELEVANT, SIGN_EXTEND to\n+\tSIGNED_EXTENDED_DEF, ZERO_EXTEND to ZERO_EXTENDED_DEF.\n+\t(see_gen_normalized_extension): Change extension_code parameter to\n+\tenum entry_type.\n+\t(see_seek_pre_extension_expr): Change extension_code to enum\n+\tentry_type.\n+\t(see_merge_one_def_extension): Likewise.\n+\t(see_handle_relevant_defs): Likewise.\n+\t(see_handle_relevant_uses): Likewise.\n+\t(see_analyze_one_def): Likewise.\n+\t* tree-cfg.c (need_fake_edge_p): Compare gimple code with\n+\tGIMPLE_ASM rather than ASM_EXPR.\n+\t* tree-ssa-alias.c (is_escape_site): Compare gimple code with\n+\tGIMPLE_RETURN rather than RETURN_EXPR.\n+\t* tree-ssa-ccp.c (likely_value): Change code to enum gimple_code.\n+\t(evaluate_stmt): Likewise.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Change relevance\n+\tto enum vect_relevant.\n+\t(vect_mark_stmts_to_be_vectorized): Change assertion to not\n+\tcompare gimple codes with tree codes.\n+\n 2008-09-04  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (arm_size_rtx_costs): Call cost function."}, {"sha": "a3d35b3bf5c334e3abb4891e0ecb17228d72693d", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -3423,7 +3423,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t      flags |= ECF_PURE;\n \t    }\n \n-\t  if (GET_MODE (val) == MEM && !must_copy)\n+\t  if (MEM_P (val) && !must_copy)\n \t    slot = val;\n \t  else\n \t    {"}, {"sha": "f7ee7ddb7b57373efdcc65d03dbba82be86864e3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -1,3 +1,8 @@\n+2008-09-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* parser.c (check_no_duplicate_clause): Change code parameter to\n+\tenum omp_clause_code.\n+\n 2008-09-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/37348"}, {"sha": "3f6e370112776a1472737503eabdd1b337dee799", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -20039,7 +20039,7 @@ cp_parser_omp_clause_name (cp_parser *parser)\n /* Validate that a clause of the given type does not already exist.  */\n \n static void\n-check_no_duplicate_clause (tree clauses, enum tree_code code,\n+check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n \t\t\t   const char *name, location_t location)\n {\n   tree c;"}, {"sha": "57ed95f71de32fa280ca8585fc49226891bda14c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -1,3 +1,12 @@\n+2008-09-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* symbol.c (generate_isocbinding_symbol): Compare\n+\tgfc_notification_std with ERROR rather than FAILURE.\n+\t* resolve.c (check_assumed_size_reference): Compare array type\n+\twith AR_FULL rather than DIMEN_ELEMENT.\n+\t(resolve_actual_arglist): Compare with EXPR_VARIABLE rather than\n+\tFL_VARIABLE.\n+\n 2008-09-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/37228"}, {"sha": "8c41ce43af08d1ba8defe1b2ee07ec7f19f021bd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -994,9 +994,11 @@ check_assumed_size_reference (gfc_symbol *sym, gfc_expr *e)\n   if (need_full_assumed_size || !(sym->as && sym->as->type == AS_ASSUMED_SIZE))\n       return false;\n \n+  /* FIXME: The comparison \"e->ref->u.ar.type == AR_FULL\" is wrong.\n+     What should it be?  */\n   if ((e->ref->u.ar.end[e->ref->u.ar.as->rank - 1] == NULL)\n \t  && (e->ref->u.ar.as->type == AS_ASSUMED_SIZE)\n-\t       && (e->ref->u.ar.type == DIMEN_ELEMENT))\n+\t       && (e->ref->u.ar.type == AR_FULL))\n     {\n       gfc_error (\"The upper bound in the last dimension must \"\n \t\t \"appear in the reference to the assumed size \"\n@@ -1070,7 +1072,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t  continue;\n \t}\n \n-      if (e->expr_type == FL_VARIABLE && e->symtree->ambiguous)\n+      if (e->expr_type == EXPR_VARIABLE && e->symtree->ambiguous)\n \t{\n \t  gfc_error (\"'%s' at %L is ambiguous\", e->symtree->n.sym->name,\n \t\t     &e->where);\n@@ -1080,7 +1082,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n       if (e->ts.type != BT_PROCEDURE)\n \t{\n \t  save_need_full_assumed_size = need_full_assumed_size;\n-\t  if (e->expr_type != FL_VARIABLE)\n+\t  if (e->expr_type != EXPR_VARIABLE)\n \t    need_full_assumed_size = 0;\n \t  if (gfc_resolve_expr (e) != SUCCESS)\n \t    return FAILURE;\n@@ -1224,7 +1226,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t is a  variable instead, it needs to be resolved as it was not\n \t done at the beginning of this function.  */\n       save_need_full_assumed_size = need_full_assumed_size;\n-      if (e->expr_type != FL_VARIABLE)\n+      if (e->expr_type != EXPR_VARIABLE)\n \tneed_full_assumed_size = 0;\n       if (gfc_resolve_expr (e) != SUCCESS)\n \treturn FAILURE;"}, {"sha": "ee45f2a7ba0b7a9fbde92d05711c363fc16c390e", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -3922,7 +3922,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n   char comp_name[(GFC_MAX_SYMBOL_LEN * 2) + 1];\n   int index;\n \n-  if (gfc_notification_std (std_for_isocbinding_symbol (s)) == FAILURE)\n+  if (gfc_notification_std (std_for_isocbinding_symbol (s)) == ERROR)\n     return;\n   tmp_symtree = gfc_find_symtree (gfc_current_ns->sym_root, name);\n "}, {"sha": "9075b2e58e2bdb1918568a5282ce27ed6d2168fa", "filename": "gcc/gimple.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -1085,7 +1085,7 @@ gimple_build_predict (enum br_predictor predictor, enum prediction outcome)\n {\n   gimple p = gimple_alloc (GIMPLE_PREDICT, 0);\n   /* Ensure all the predictors fit into the lower bits of the subcode.  */\n-  gcc_assert (END_PREDICTORS <= GF_PREDICT_TAKEN);\n+  gcc_assert ((int) END_PREDICTORS <= GF_PREDICT_TAKEN);\n   gimple_predict_set_predictor (p, predictor);\n   gimple_predict_set_outcome (p, outcome);\n   return p;\n@@ -2066,7 +2066,7 @@ gimple_assign_set_rhs_with_ops (gimple_stmt_iterator *gsi, enum tree_code code,\n tree\n gimple_get_lhs (const_gimple stmt)\n {\n-  enum tree_code code = gimple_code (stmt);\n+  enum gimple_code code = gimple_code (stmt);\n \n   if (code == GIMPLE_ASSIGN)\n     return gimple_assign_lhs (stmt);\n@@ -2083,7 +2083,7 @@ gimple_get_lhs (const_gimple stmt)\n void\n gimple_set_lhs (gimple stmt, tree lhs)\n {\n-  enum tree_code code = gimple_code (stmt);\n+  enum gimple_code code = gimple_code (stmt);\n \n   if (code == GIMPLE_ASSIGN)\n     gimple_assign_set_lhs (stmt, lhs);"}, {"sha": "aef71a7511e992f5463190e5a8b4ca0dbb4efee2", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -2289,7 +2289,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n       if (GET_MODE (x) == BLKmode)\n \treturn FALSE;\n \n-      if (GET_MODE (x) == ZERO_EXTRACT\n+      if (GET_CODE (x) == ZERO_EXTRACT\n \t  && (GET_CODE (XEXP (x, 1)) != CONST_INT\n \t      || GET_CODE (XEXP (x, 2)) != CONST_INT))\n \treturn FALSE;"}, {"sha": "7d32f21781f2fb08cf27cace3f6b281ca7204d1e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -164,7 +164,7 @@ static tree maybe_lookup_decl_in_outer_ctx (tree, omp_context *);\n /* Find an OpenMP clause of type KIND within CLAUSES.  */\n \n tree\n-find_omp_clause (tree clauses, enum tree_code kind)\n+find_omp_clause (tree clauses, enum omp_clause_code kind)\n {\n   for (; clauses ; clauses = OMP_CLAUSE_CHAIN (clauses))\n     if (OMP_CLAUSE_CODE (clauses) == kind)"}, {"sha": "bd2373cbb5a6576c9b36e4901ff4dc1784fe48bf", "filename": "gcc/regrename.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -89,7 +89,7 @@ static void scan_rtx (rtx, rtx *, enum reg_class, enum scan_actions,\n static struct du_chain *build_def_use (basic_block);\n static void dump_def_use_chain (struct du_chain *);\n static void note_sets (rtx, const_rtx, void *);\n-static void clear_dead_regs (HARD_REG_SET *, enum machine_mode, rtx);\n+static void clear_dead_regs (HARD_REG_SET *, enum reg_note, rtx);\n static void merge_overlapping_regs (basic_block, HARD_REG_SET *,\n \t\t\t\t    struct du_chain *);\n \n@@ -114,7 +114,7 @@ note_sets (rtx x, const_rtx set ATTRIBUTE_UNUSED, void *data)\n    in the list NOTES.  */\n \n static void\n-clear_dead_regs (HARD_REG_SET *pset, enum machine_mode kind, rtx notes)\n+clear_dead_regs (HARD_REG_SET *pset, enum reg_note kind, rtx notes)\n {\n   rtx note;\n   for (note = notes; note; note = XEXP (note, 1))\n@@ -1990,4 +1990,3 @@ struct rtl_opt_pass pass_cprop_hardreg =\n   TODO_dump_func | TODO_verify_rtl_sharing /* todo_flags_finish */\n  }\n };\n-"}, {"sha": "1ea41091260c5346cb1626c0ff2d2f578288f762", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -2709,7 +2709,7 @@ eliminate_regs_1 (rtx x, enum machine_mode mem_mode, rtx insn,\n \t      /* If this is a REG_DEAD note, it is not valid anymore.\n \t\t Using the eliminated version could result in creating a\n \t\t REG_DEAD note for the stack or frame pointer.  */\n-\t      if (GET_MODE (x) == REG_DEAD)\n+\t      if (REG_NOTE_KIND (x) == REG_DEAD)\n \t\treturn (XEXP (x, 1)\n \t\t\t? eliminate_regs_1 (XEXP (x, 1), mem_mode, insn, true)\n \t\t\t: NULL_RTX);"}, {"sha": "5d2e793e2dce2b7f57ff5caf6eeece7b55908ec0", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -1246,8 +1246,7 @@ do {\t\t\t\t\t\t\\\n /* Likewise in an expr_list for a REG_LABEL_OPERAND or\n    REG_LABEL_TARGET note.  */\n #define LABEL_REF_NONLOCAL_P(RTX)\t\t\t\t\t\\\n-  (RTL_FLAG_CHECK3(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF,\t\t\\\n-\t\t   REG_LABEL_OPERAND, REG_LABEL_TARGET)->volatil)\n+  (RTL_FLAG_CHECK1(\"LABEL_REF_NONLOCAL_P\", (RTX), LABEL_REF)->volatil)\n \n /* 1 if RTX is a code_label that should always be considered to be needed.  */\n #define LABEL_PRESERVE_P(RTX)\t\t\t\t\t\t\\"}, {"sha": "55b37bf7c2a0d2c78b697b9e84b0f3c797fdcb8c", "filename": "gcc/see.c", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fsee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Fsee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsee.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -712,13 +712,13 @@ see_get_extension_reg (rtx extension, bool return_dest_reg)\n     Otherwise, set SOURCE_MODE to be the mode of the extended expr and return\n     the rtx code of the extension.  */\n \n-static enum rtx_code\n+static enum entry_type\n see_get_extension_data (rtx extension, enum machine_mode *source_mode)\n {\n   rtx rhs, lhs, set;\n \n   if (!extension || !INSN_P (extension))\n-    return UNKNOWN;\n+    return NOT_RELEVANT;\n \n   /* Parallel pattern for extension not supported for the moment.  */\n   if (GET_CODE (PATTERN (extension)) == PARALLEL)\n@@ -733,21 +733,21 @@ see_get_extension_data (rtx extension, enum machine_mode *source_mode)\n   /* Don't handle extensions to something other then register or\n      subregister.  */\n   if (!REG_P (lhs) && GET_CODE (lhs) != SUBREG)\n-    return UNKNOWN;\n+    return NOT_RELEVANT;\n \n   if (GET_CODE (rhs) != SIGN_EXTEND && GET_CODE (rhs) != ZERO_EXTEND)\n-    return UNKNOWN;\n+    return NOT_RELEVANT;\n \n   if (!REG_P (XEXP (rhs, 0))\n       && !(GET_CODE (XEXP (rhs, 0)) == SUBREG\n \t   && REG_P (SUBREG_REG (XEXP (rhs, 0)))))\n-    return UNKNOWN;\n+    return NOT_RELEVANT;\n \n   *source_mode = GET_MODE (XEXP (rhs, 0));\n \n   if (GET_CODE (rhs) == SIGN_EXTEND)\n-    return SIGN_EXTEND;\n-  return ZERO_EXTEND;\n+    return SIGN_EXTENDED_DEF;\n+  return ZERO_EXTENDED_DEF;\n }\n \n \n@@ -760,19 +760,20 @@ see_get_extension_data (rtx extension, enum machine_mode *source_mode)\n    Otherwise, return the generated instruction.  */\n \n static rtx\n-see_gen_normalized_extension (rtx reg, enum rtx_code extension_code,\n+see_gen_normalized_extension (rtx reg, enum entry_type extension_code,\n    \t\t\t      enum machine_mode mode)\n {\n   rtx subreg, insn;\n   rtx extension = NULL;\n \n   if (!reg\n       || !REG_P (reg)\n-      || (extension_code != SIGN_EXTEND && extension_code != ZERO_EXTEND))\n+      || (extension_code != SIGN_EXTENDED_DEF\n+          && extension_code != ZERO_EXTENDED_DEF))\n     return NULL;\n \n   subreg = gen_lowpart_SUBREG (mode, reg);\n-  if (extension_code == SIGN_EXTEND)\n+  if (extension_code == SIGN_EXTENDED_DEF)\n     extension = gen_rtx_SIGN_EXTEND (GET_MODE (reg), subreg);\n   else\n     extension = gen_rtx_ZERO_EXTEND (GET_MODE (reg), subreg);\n@@ -1019,14 +1020,14 @@ see_seek_pre_extension_expr (rtx extension, enum extension_type type)\n {\n   struct see_pre_extension_expr **slot_pre_exp, temp_pre_exp;\n   rtx dest_extension_reg = see_get_extension_reg (extension, 1);\n-  enum rtx_code extension_code;\n+  enum entry_type extension_code;\n   enum machine_mode source_extension_mode;\n \n   if (type == DEF_EXTENSION)\n     {\n       extension_code = see_get_extension_data (extension,\n \t\t\t\t\t       &source_extension_mode);\n-      gcc_assert (extension_code != UNKNOWN);\n+      gcc_assert (extension_code != NOT_RELEVANT);\n       extension =\n \tsee_gen_normalized_extension (dest_extension_reg, extension_code,\n \t\t\t\t      source_extension_mode);\n@@ -2807,7 +2808,7 @@ see_merge_one_def_extension (void **slot, void *b)\n   rtx simplified_temp_extension = NULL;\n   rtx *pat;\n   enum rtx_code code;\n-  enum rtx_code extension_code;\n+  enum entry_type extension_code;\n   enum machine_mode source_extension_mode;\n   enum machine_mode source_mode = VOIDmode;\n   enum machine_mode dest_extension_mode;\n@@ -2866,7 +2867,7 @@ see_merge_one_def_extension (void **slot, void *b)\n \t    {\n \t      rtx orig_src = SET_SRC (*sub);\n \n-\t      if (extension_code == SIGN_EXTEND)\n+\t      if (extension_code == SIGN_EXTENDED_DEF)\n \t\ttemp_extension = gen_rtx_SIGN_EXTEND (dest_extension_mode,\n \t\t\t\t\t\t      orig_src);\n \t      else\n@@ -2898,7 +2899,7 @@ see_merge_one_def_extension (void **slot, void *b)\n     {\n       rtx orig_src = SET_SRC (*pat);\n \n-      if (extension_code == SIGN_EXTEND)\n+      if (extension_code == SIGN_EXTENDED_DEF)\n \ttemp_extension = gen_rtx_SIGN_EXTEND (dest_extension_mode, orig_src);\n       else\n \ttemp_extension = gen_rtx_ZERO_EXTEND (dest_extension_mode, orig_src);\n@@ -3245,7 +3246,7 @@ see_handle_relevant_defs (struct df_ref *ref, rtx insn)\n {\n   struct web_entry *root_entry = NULL;\n   rtx se_insn = NULL;\n-  enum rtx_code extension_code;\n+  enum entry_type extension_code;\n   rtx reg = DF_REF_REAL_REG (ref);\n   rtx ref_insn = NULL;\n   unsigned int i = DF_REF_ID (ref);\n@@ -3274,9 +3275,9 @@ see_handle_relevant_defs (struct df_ref *ref, rtx insn)\n     {\n       \n       if (ENTRY_EI (root_entry)->relevancy == SIGN_EXTENDED_DEF)\n-\textension_code = SIGN_EXTEND;\n+\textension_code = SIGN_EXTENDED_DEF;\n       else\n-\textension_code = ZERO_EXTEND;\n+\textension_code = ZERO_EXTENDED_DEF;\n       \n       se_insn =\n \tsee_gen_normalized_extension (reg, extension_code,\n@@ -3314,7 +3315,7 @@ see_handle_relevant_uses (struct df_ref *ref, rtx insn)\n {\n   struct web_entry *root_entry = NULL;\n   rtx se_insn = NULL;\n-  enum rtx_code extension_code;\n+  enum entry_type extension_code;\n   rtx reg = DF_REF_REAL_REG (ref);\n \n   root_entry = unionfind_root (&use_entry[DF_REF_ID (ref)]);\n@@ -3333,9 +3334,9 @@ see_handle_relevant_uses (struct df_ref *ref, rtx insn)\n   \n   /* Generate the use extension.  */\n   if (ENTRY_EI (root_entry)->relevancy == SIGN_EXTENDED_DEF)\n-    extension_code = SIGN_EXTEND;\n+    extension_code = SIGN_EXTENDED_DEF;\n   else\n-    extension_code = ZERO_EXTEND;\n+    extension_code = ZERO_EXTENDED_DEF;\n   \n   se_insn =\n     see_gen_normalized_extension (reg, extension_code,\n@@ -3468,7 +3469,7 @@ static enum entry_type\n see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n \t\t     enum machine_mode *source_mode_unsigned)\n {\n-  enum rtx_code extension_code;\n+  enum entry_type extension_code;\n   rtx rhs = NULL;\n   rtx lhs = NULL;\n   rtx set = NULL;\n@@ -3487,8 +3488,8 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n   extension_code = see_get_extension_data (insn, source_mode);\n   switch (extension_code)\n     {\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n+    case SIGN_EXTENDED_DEF:\n+    case ZERO_EXTENDED_DEF:\n       source_register = see_get_extension_reg (insn, 0);\n       /* FIXME: This restriction can be relaxed.  The only thing that is\n \t important is that the reference would be inside the same basic block\n@@ -3521,12 +3522,9 @@ see_analyze_one_def (rtx insn, enum machine_mode *source_mode,\n \t    return NOT_RELEVANT;\n \t}\n \n-      if (extension_code == SIGN_EXTEND)\n-\treturn SIGN_EXTENDED_DEF;\n-      else\n-\treturn ZERO_EXTENDED_DEF;\n+      return extension_code;\n \n-    case UNKNOWN:\n+    case NOT_RELEVANT:\n       /* This may still be an EXTENDED_DEF.  */\n \n       /* FIXME: This restriction can be relaxed.  It is possible to handle\n@@ -3894,4 +3892,3 @@ struct rtl_opt_pass pass_see =\n   TODO_dump_func\t\t\t/* todo_flags_finish */\n  }\n };\n-"}, {"sha": "ce06d0e583d96b0c9f947268299ab0d08648257a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -6231,7 +6231,7 @@ need_fake_edge_p (gimple t)\n       && !(call_flags & ECF_NORETURN))\n     return true;\n \n-  if (gimple_code (t) == ASM_EXPR\n+  if (gimple_code (t) == GIMPLE_ASM\n        && (gimple_asm_volatile_p (t) || gimple_asm_input_p (t)))\n     return true;\n "}, {"sha": "99b993dc415fa07e4b0a1aa9a1c0333422e8ea81", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -676,7 +676,7 @@ extern struct omp_region *new_omp_region (basic_block, enum gimple_code,\n \t\t\t\t\t  struct omp_region *);\n extern void free_omp_regions (void);\n void omp_expand_local (basic_block);\n-extern tree find_omp_clause (tree, enum tree_code);\n+extern tree find_omp_clause (tree, enum omp_clause_code);\n tree copy_var_decl (tree, tree, tree);\n \n /*---------------------------------------------------------------------------"}, {"sha": "42a54312bdf7c128661795cd9c70e92e25d00149", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -3216,7 +3216,7 @@ is_escape_site (gimple stmt)\n \t Applications (OOPSLA), pp. 1-19, 1999.  */\n       return ESCAPE_STORED_IN_GLOBAL;\n     }\n-  else if (gimple_code (stmt) == RETURN_EXPR)\n+  else if (gimple_code (stmt) == GIMPLE_RETURN)\n     return ESCAPE_TO_RETURN;\n \n   return NO_ESCAPE;"}, {"sha": "8f700c47be2c854feb98a63c605e1da37013451a", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -501,7 +501,7 @@ likely_value (gimple stmt)\n   tree use;\n   ssa_op_iter iter;\n \n-  enum tree_code code = gimple_code (stmt);\n+  enum gimple_code code = gimple_code (stmt);\n \n   /* This function appears to be called only for assignments, calls,\n      conditionals, and switches, due to the logic in visit_stmt.  */\n@@ -1308,7 +1308,7 @@ evaluate_stmt (gimple stmt)\n      bother folding the statement.  */\n   else if (likelyvalue == VARYING)\n     {\n-      enum tree_code code = gimple_code (stmt);\n+      enum gimple_code code = gimple_code (stmt);\n       if (code == GIMPLE_ASSIGN)\n         {\n           enum tree_code subcode = gimple_assign_rhs_code (stmt);"}, {"sha": "06e004c34bbd2e76f4c48df8f517bf902ae83da7", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c68ce9d288764b1706c1675804a308632d2919/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=e0c68ce9d288764b1706c1675804a308632d2919", "patch": "@@ -427,7 +427,7 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t{\n \t  gimple stmt = gsi_stmt (si);\n \t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t  enum vect_def_type relevance = STMT_VINFO_RELEVANT (stmt_info);\n+\t  enum vect_relevant relevance = STMT_VINFO_RELEVANT (stmt_info);\n \n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    {\n@@ -4081,8 +4081,10 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n \t    case vect_used_in_outer_by_reduction:\n \t    case vect_used_in_outer:\n-\t      gcc_assert (gimple_code (stmt) != WIDEN_SUM_EXPR\n-\t\t\t  && gimple_code (stmt) != DOT_PROD_EXPR);\n+\t      gcc_assert (gimple_code (stmt) != GIMPLE_ASSIGN\n+                          || (gimple_assign_rhs_code (stmt) != WIDEN_SUM_EXPR\n+                              && (gimple_assign_rhs_code (stmt)\n+                                  != DOT_PROD_EXPR)));\n \t      break;\n \n \t    case vect_used_by_reduction:"}]}