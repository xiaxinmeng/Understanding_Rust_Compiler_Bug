{"sha": "e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTljZmVmNjQxMzUxYWY2ODJmMmY2ZTFiYzBmYWJiZDJlMDg5ODJiNQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-08-09T23:32:59Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-09T23:32:59Z"}, "message": "re PR fortran/16919 (ICE with derived type and array constructor)\n\n\tPR fortran/16919\n\t* trans-array.c (gfc_add_loop_ss_code): Handle GFC_SS_COMPONENT.\n\t(gfc_conv_array_index_offset): Allow \"temporary\" with nonzero delta.\n\t(gfc_trans_preloop_setup, gfc_trans_scalarized_loop_boundary):\n\tHandle GFC_SS_COMPONENT.\n\t(gfc_conv_ss_startstride): Ditto.  Set ss->shape.\n\t(gfc_conv_loop_setup): Tweak commends. Remove dead code.\n\tUse ss->shape.\n\t(gfc_conv_array_initializer): Call specific initializer routines.\n\t* trans-expr.c (gfc_trans_structure_assign): New function.\n\t(gfc_trans_subarray_assign): New function.\n\t(gfc_trans_subcomponent_assign): New fucntion\n\t(gfc_conv_structure): Use them.\n\t* trans.h (gfc_ss_type): Add GFC_SS_COMPONENT.\n\t(gfc_ss): Add shape.\ntestsuite/\n\t* gfortran.dg/der_array_1.f90: New test.\n\nFrom-SVN: r85730", "tree": {"sha": "1f5890ab4bdea842dda65be22a1cc5fb3958a381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f5890ab4bdea842dda65be22a1cc5fb3958a381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/comments", "author": null, "committer": null, "parents": [{"sha": "b9bfca8100c3db821b58a88bea733d83d4bf2c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9bfca8100c3db821b58a88bea733d83d4bf2c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9bfca8100c3db821b58a88bea733d83d4bf2c28"}], "stats": {"total": 343, "additions": 313, "deletions": 30}, "files": [{"sha": "12aca9d2e227741fabefd2345caa57ad7c09090f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "patch": "@@ -1,3 +1,21 @@\n+2004-08-10  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/16919\n+\t* trans-array.c (gfc_add_loop_ss_code): Handle GFC_SS_COMPONENT.\n+\t(gfc_conv_array_index_offset): Allow \"temporary\" with nonzero delta.\n+\t(gfc_trans_preloop_setup, gfc_trans_scalarized_loop_boundary):\n+\tHandle GFC_SS_COMPONENT.\n+\t(gfc_conv_ss_startstride): Ditto.  Set ss->shape.\n+\t(gfc_conv_loop_setup): Tweak commends. Remove dead code.\n+\tUse ss->shape.\n+\t(gfc_conv_array_initializer): Call specific initializer routines.\n+\t* trans-expr.c (gfc_trans_structure_assign): New function.\n+\t(gfc_trans_subarray_assign): New function.\n+\t(gfc_trans_subcomponent_assign): New fucntion\n+\t(gfc_conv_structure): Use them.\n+\t* trans.h (gfc_ss_type): Add GFC_SS_COMPONENT.\n+\t(gfc_ss): Add shape.\n+\n 2004-08-08  Victor Leikehman  <lei@il.ibm.com>\n \n \t* simplify.c (gfc_simplify_shape): Bugfix."}, {"sha": "bc825bb00cf1a863199a530972d1fd247afca901", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "patch": "@@ -1027,6 +1027,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n   gfc_se se;\n   int n;\n \n+  /* TODO: This can generate bad code if there are ordering dependencies.\n+     eg. a callee allocated function and an unknown size constructor.  */\n   assert (ss != NULL);\n \n   for (; ss != gfc_ss_terminator; ss = ss->loop_chain)\n@@ -1100,7 +1102,8 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \t  break;\n \n         case GFC_SS_TEMP:\n-          /* Do nothing.  This will be handled later.  */\n+\tcase GFC_SS_COMPONENT:\n+          /* Do nothing.  These are handled elsewhere.  */\n           break;\n \n \tdefault:\n@@ -1446,9 +1449,12 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n     }\n   else\n     {\n-      /* Temporary array.  */\n+      /* Temporary array or derived type component.  */\n       assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n+      if (!integer_zerop (info->delta[i]))\n+\tindex = fold (build (PLUS_EXPR, gfc_array_index_type, index,\n+\t\t\t     info->delta[i]));\n     }\n \n   /* Multiply by the stride.  */\n@@ -1597,7 +1603,8 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \tcontinue;\n \n       if (ss->type != GFC_SS_SECTION\n-\t  && ss->type != GFC_SS_FUNCTION && ss->type != GFC_SS_CONSTRUCTOR)\n+\t  && ss->type != GFC_SS_FUNCTION && ss->type != GFC_SS_CONSTRUCTOR\n+\t  && ss->type != GFC_SS_COMPONENT)\n \tcontinue;\n \n       info = &ss->data.info;\n@@ -1819,7 +1826,8 @@ gfc_trans_scalarized_loop_boundary (gfc_loopinfo * loop, stmtblock_t * body)\n \tcontinue;\n \n       if (ss->type != GFC_SS_SECTION\n-\t  && ss->type != GFC_SS_FUNCTION && ss->type != GFC_SS_CONSTRUCTOR)\n+\t  && ss->type != GFC_SS_FUNCTION && ss->type != GFC_SS_CONSTRUCTOR\n+\t  && ss->type != GFC_SS_COMPONENT)\n \tcontinue;\n \n       ss->data.info.offset = ss->data.info.saved_offset;\n@@ -1975,6 +1983,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \tcase GFC_SS_SECTION:\n \tcase GFC_SS_CONSTRUCTOR:\n \tcase GFC_SS_FUNCTION:\n+\tcase GFC_SS_COMPONENT:\n \t  loop->dimen = ss->data.info.dimen;\n \t  break;\n \n@@ -1990,6 +1999,9 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n   /* Loop over all the SS in the chain.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n+      if (ss->expr && ss->expr->shape && !ss->shape)\n+\tss->shape = ss->expr->shape;\n+\n       switch (ss->type)\n \t{\n \tcase GFC_SS_SECTION:\n@@ -2271,7 +2283,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n          loop for this dimension.  We try to pick the simplest term.  */\n       for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n \t{\n-\t  if (ss->expr && ss->expr->shape)\n+\t  if (ss->shape)\n \t    {\n \t      /* The frontend has worked out the size for us.  */\n \t      loopspec[n] = ss;\n@@ -2280,6 +2292,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \n \t  if (ss->type == GFC_SS_CONSTRUCTOR)\n \t    {\n+\t      /* An unknown size constructor will always be rank one.\n+\t\t Higher rank constructors will wither have known shape,\n+\t\t or still be wrapped in a call to reshape.  */\n+\t      assert (loop->dimen == 1);\n \t      /* Try to figure out the size of the constructor.  */\n \t      /* TODO: avoid this by making the frontend set the shape.  */\n \t      gfc_get_array_cons_size (&i, ss->expr->value.constructor);\n@@ -2295,7 +2311,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t    }\n \n \t  /* TODO: Pick the best bound if we have a choice between a\n-\t     functions and something else.  */\n+\t     function and something else.  */\n           if (ss->type == GFC_SS_FUNCTION)\n             {\n               loopspec[n] = ss;\n@@ -2305,8 +2321,6 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t  if (ss->type != GFC_SS_SECTION)\n \t    continue;\n \n-\t  info = &ss->data.info;\n-\n \t  if (loopspec[n])\n \t    specinfo = &loopspec[n]->data.info;\n \t  else\n@@ -2321,6 +2335,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t   */\n \t  if (!specinfo)\n \t    loopspec[n] = ss;\n+\t  /* TODO: Is != contructor correct?  */\n \t  else if (loopspec[n]->type != GFC_SS_CONSTRUCTOR)\n \t    {\n \t      if (integer_onep (info->stride[n])\n@@ -2345,7 +2360,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n       info = &loopspec[n]->data.info;\n \n       /* Set the extents of this range.  */\n-      cshape = loopspec[n]->expr->shape;\n+      cshape = loopspec[n]->shape;\n       if (cshape && INTEGER_CST_P (info->start[n])\n \t  && INTEGER_CST_P (info->stride[n]))\n \t{\n@@ -2440,7 +2455,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n   /* Calculate the translation from loop variables to array indices.  */\n   for (ss = loop->ss; ss != gfc_ss_terminator; ss = ss->loop_chain)\n     {\n-      if (ss->type != GFC_SS_SECTION)\n+      if (ss->type != GFC_SS_SECTION && ss->type != GFC_SS_COMPONENT)\n \tcontinue;\n \n       info = &ss->data.info;\n@@ -2449,7 +2464,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t{\n \t  dim = info->dim[n];\n \n-\t  /* If we are specifying the range the delta may already be set.  */\n+\t  /* If we are specifying the range the delta is already set.  */\n \t  if (loopspec[n] != ss)\n \t    {\n \t      /* Calculate the offset relative to the loop variable.\n@@ -2705,7 +2720,11 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n       /* A single scalar or derived type value.  Create an array with all\n          elements equal to that value.  */\n       gfc_init_se (&se, NULL);\n-      gfc_conv_expr (&se, expr);\n+      \n+      if (expr->expr_type == EXPR_CONSTANT)\n+\tgfc_conv_constant (&se, expr);\n+      else\n+\tgfc_conv_structure (&se, expr, 1);\n \n       tmp = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n       assert (tmp && INTEGER_CST_P (tmp));"}, {"sha": "554cf1daf3c190c51780410df4cba3c8e4e430de", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 221, "deletions": 17, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "patch": "@@ -43,6 +43,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */\n #include \"trans-stmt.h\"\n \n+static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n \n /* Copy the scalarization loop variables.  */\n \n@@ -1413,6 +1414,209 @@ gfc_conv_initializer (gfc_expr * expr, gfc_typespec * ts, tree type,\n     }\n }\n   \n+static tree\n+gfc_trans_subarray_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n+{\n+  gfc_se rse;\n+  gfc_se lse;\n+  gfc_ss *rss;\n+  gfc_ss *lss;\n+  stmtblock_t body;\n+  stmtblock_t block;\n+  gfc_loopinfo loop;\n+  int n;\n+  tree tmp;\n+\n+  gfc_start_block (&block);\n+\n+  /* Initialize the scalarizer.  */\n+  gfc_init_loopinfo (&loop);\n+\n+  gfc_init_se (&lse, NULL);\n+  gfc_init_se (&rse, NULL);\n+\n+  /* Walk the rhs.  */\n+  rss = gfc_walk_expr (expr);\n+  if (rss == gfc_ss_terminator)\n+    {\n+      /* The rhs is scalar.  Add a ss for the expression.  */\n+      rss = gfc_get_ss ();\n+      rss->next = gfc_ss_terminator;\n+      rss->type = GFC_SS_SCALAR;\n+      rss->expr = expr;\n+    }\n+\n+  /* Create a SS for the destination.  */\n+  lss = gfc_get_ss ();\n+  lss->type = GFC_SS_COMPONENT;\n+  lss->expr = NULL;\n+  lss->shape = gfc_get_shape (cm->as->rank);\n+  lss->next = gfc_ss_terminator;\n+  lss->data.info.dimen = cm->as->rank;\n+  lss->data.info.descriptor = dest;\n+  lss->data.info.data = gfc_conv_array_data (dest);\n+  lss->data.info.offset = gfc_conv_array_offset (dest);\n+  for (n = 0; n < cm->as->rank; n++)\n+    {\n+      lss->data.info.dim[n] = n;\n+      lss->data.info.start[n] = gfc_conv_array_lbound (dest, n);\n+      lss->data.info.stride[n] = gfc_index_one_node;\n+\n+      mpz_init (lss->shape[n]);\n+      mpz_sub (lss->shape[n], cm->as->upper[n]->value.integer,\n+\t       cm->as->lower[n]->value.integer);\n+      mpz_add_ui (lss->shape[n], lss->shape[n], 1);\n+    }\n+  \n+  /* Associate the SS with the loop.  */\n+  gfc_add_ss_to_loop (&loop, lss);\n+  gfc_add_ss_to_loop (&loop, rss);\n+\n+  /* Calculate the bounds of the scalarization.  */\n+  gfc_conv_ss_startstride (&loop);\n+\n+  /* Setup the scalarizing loops.  */\n+  gfc_conv_loop_setup (&loop);\n+\n+  /* Setup the gfc_se structures.  */\n+  gfc_copy_loopinfo_to_se (&lse, &loop);\n+  gfc_copy_loopinfo_to_se (&rse, &loop);\n+\n+  rse.ss = rss;\n+  gfc_mark_ss_chain_used (rss, 1);\n+  lse.ss = lss;\n+  gfc_mark_ss_chain_used (lss, 1);\n+\n+  /* Start the scalarized loop body.  */\n+  gfc_start_scalarized_body (&loop, &body);\n+\n+  gfc_conv_tmp_array_ref (&lse);\n+  gfc_conv_expr (&rse, expr);\n+\n+  tmp = gfc_trans_scalar_assign (&lse, &rse, cm->ts.type);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  if (rse.ss != gfc_ss_terminator)\n+    abort ();\n+\n+  /* Generate the copying loops.  */\n+  gfc_trans_scalarizing_loops (&loop, &body);\n+\n+  /* Wrap the whole thing up.  */\n+  gfc_add_block_to_block (&block, &loop.pre);\n+  gfc_add_block_to_block (&block, &loop.post);\n+\n+  gfc_cleanup_loop (&loop);\n+\n+  for (n = 0; n < cm->as->rank; n++)\n+    mpz_clear (lss->shape[n]);\n+  gfc_free (lss->shape);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+/* Assign a single component of a derived type constructor.  */\n+\n+static tree\n+gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr)\n+{\n+  gfc_se se;\n+  gfc_ss *rss;\n+  stmtblock_t block;\n+  tree tmp;\n+\n+  gfc_start_block (&block);\n+  if (cm->pointer)\n+    {\n+      gfc_init_se (&se, NULL);\n+      /* Pointer component.  */\n+      if (cm->dimension)\n+\t{\n+\t  /* Array pointer.  */\n+\t  if (expr->expr_type == EXPR_NULL)\n+\t    {\n+\t      dest = gfc_conv_descriptor_data (dest);\n+\t      tmp = fold_convert (TREE_TYPE (se.expr),\n+\t\t\t\t  null_pointer_node);\n+\t      gfc_add_modify_expr (&block, dest, tmp);\n+\t    }\n+\t  else\n+\t    {\n+\t      rss = gfc_walk_expr (expr);\n+\t      se.direct_byref = 1;\n+\t      se.expr = dest;\n+\t      gfc_conv_expr_descriptor (&se, expr, rss);\n+\t      gfc_add_block_to_block (&block, &se.pre);\n+\t      gfc_add_block_to_block (&block, &se.post);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Scalar pointers.  */\n+\t  se.want_pointer = 1;\n+\t  gfc_conv_expr (&se, expr);\n+\t  gfc_add_block_to_block (&block, &se.pre);\n+\t  gfc_add_modify_expr (&block, dest,\n+\t\t\t       fold_convert (TREE_TYPE (dest), se.expr));\n+\t  gfc_add_block_to_block (&block, &se.post);\n+\t}\n+    }\n+  else if (cm->dimension)\n+    {\n+      tmp = gfc_trans_subarray_assign (dest, cm, expr);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  else if (expr->ts.type == BT_DERIVED)\n+    {\n+      /* Nested dervived type.  */\n+      tmp = gfc_trans_structure_assign (dest, expr);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  else\n+    {\n+      /* Scalar component.  */\n+      gfc_se lse;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_init_se (&lse, NULL);\n+\n+      gfc_conv_expr (&se, expr);\n+      if (cm->ts.type == BT_CHARACTER)\n+\tlse.string_length = cm->ts.cl->backend_decl;\n+      lse.expr = dest;\n+      tmp = gfc_trans_scalar_assign (&lse, &se, cm->ts.type);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  return gfc_finish_block (&block);\n+}\n+\n+/* Assign a derived type contructor to a variable.  */\n+\n+static tree\n+gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n+{\n+  gfc_constructor *c;\n+  gfc_component *cm;\n+  stmtblock_t block;\n+  tree field;\n+  tree tmp;\n+\n+  gfc_start_block (&block);\n+  cm = expr->ts.derived->components;\n+  for (c = expr->value.constructor; c; c = c->next, cm = cm->next)\n+    {\n+      /* Skip absent members in default initializers.  */\n+      if (!c->expr)\n+        continue;\n+\n+      field = cm->backend_decl;\n+      tmp = build (COMPONENT_REF, TREE_TYPE (field), dest, field, NULL_TREE);\n+      tmp = gfc_trans_subcomponent_assign (tmp, cm, c->expr);\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  return gfc_finish_block (&block);\n+}\n+\n /* Build an expression for a constructor. If init is nonzero then\n    this is part of a static variable initializer.  */\n \n@@ -1424,11 +1628,22 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n   tree head;\n   tree tail;\n   tree val;\n-  gfc_se cse;\n   tree type;\n+  tree tmp;\n \n-  assert (expr->expr_type == EXPR_STRUCTURE || expr->expr_type == EXPR_NULL);\n+  assert (se->ss == NULL);\n+  assert (expr->expr_type == EXPR_STRUCTURE);\n   type = gfc_typenode_for_spec (&expr->ts);\n+\n+  if (!init)\n+    {\n+      /* Create a temporary variable and fill it in.  */\n+      se->expr = gfc_create_var (type, expr->ts.derived->name);\n+      tmp = gfc_trans_structure_assign (se->expr, expr);\n+      gfc_add_expr_to_block (&se->pre, tmp);\n+      return;\n+    }\n+\n   head = build1 (CONSTRUCTOR, type, NULL_TREE);\n   tail = NULL_TREE;\n \n@@ -1439,22 +1654,11 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       if (!c->expr)\n         continue;\n \n-      gfc_init_se (&cse, se);\n-      /* Evaluate the expression for this component.  */\n-      if (init)\n-\t{\n-\t  cse.expr = gfc_conv_initializer (c->expr, &cm->ts,\n-\t      TREE_TYPE (cm->backend_decl), cm->dimension, cm->pointer);\n-\t}\n-      else\n-\t{\n-\t  gfc_conv_expr (&cse, c->expr);\n-\t  gfc_add_block_to_block (&se->pre, &cse.pre);\n-\t  gfc_add_block_to_block (&se->post, &cse.post);\n-\t}\n+      val = gfc_conv_initializer (c->expr, &cm->ts,\n+\t  TREE_TYPE (cm->backend_decl), cm->dimension, cm->pointer);\n \n       /* Build a TREE_CHAIN to hold it.  */\n-      val = tree_cons (cm->backend_decl, cse.expr, NULL_TREE);\n+      val = tree_cons (cm->backend_decl, val, NULL_TREE);\n \n       /* Add it to the list.  */\n       if (tail == NULL_TREE)\n@@ -1497,7 +1701,7 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n   if (se->ss && se->ss->expr == expr\n       && (se->ss->type == GFC_SS_SCALAR || se->ss->type == GFC_SS_REFERENCE))\n     {\n-      /* Substiture a scalar expression evaluated outside the scalarization\n+      /* Substitute a scalar expression evaluated outside the scalarization\n          loop.  */\n       se->expr = se->ss->data.scalar.expr;\n       se->string_length = se->ss->data.scalar.string_length;"}, {"sha": "51c63ce56864088221a7959bf4dd0858d5b998b2", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "patch": "@@ -148,7 +148,10 @@ typedef enum\n \n   /* An intrinsic function call.  Many intrinsic functions which map directly\n      to library calls are created as GFC_SS_FUNCTION nodes.  */\n-  GFC_SS_INTRINSIC\n+  GFC_SS_INTRINSIC,\n+  \n+  /* A component of a derived type.  */\n+  GFC_SS_COMPONENT\n }\n gfc_ss_type;\n \n@@ -158,6 +161,7 @@ typedef struct gfc_ss\n {\n   gfc_ss_type type;\n   gfc_expr *expr;\n+  mpz_t *shape;\n   union\n   {\n     /* If type is GFC_SS_SCALAR or GFC_SS_REFERENCE.  */"}, {"sha": "c42f6dd1454cbea334dc48cc1d2da60e0aa6d827", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "patch": "@@ -1,3 +1,8 @@\n+2004-08-10  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/16919\n+\t* gfortran.dg/der_array_1.f90: New test.\n+\n 2004-08-09  David Edelsohn  <edelsohn@gnu.org>\n \n \t* gcc.dg/cpp/assert4.c: _AIX asserts #system(unix)."}, {"sha": "00dc7a5c2b3354a158f42f4b85e086d483ccae7d", "filename": "gcc/testsuite/gfortran.dg/der_array_1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9cfef641351af682f2f6e1bc0fabbd2e08982b5/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fder_array_1.f90?ref=e9cfef641351af682f2f6e1bc0fabbd2e08982b5", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! Test derived type constructors for derived types containing arrays.\n+! PR16919\n+program der_array_1\n+  implicit none\n+  integer n\n+  integer m\n+  ! The 4 components here test known shape array, unknown shape array,\n+  ! multi-dimensional arrays and array pointers\n+  type t\n+    integer :: a(2)\n+    integer :: b(2)\n+    integer, dimension(2, 3) :: c\n+    integer, pointer, dimension(:) :: p\n+  end type\n+  type(t) :: v\n+  integer, dimension(2, 3) :: d\n+  integer, dimension(:), pointer :: e\n+  integer, dimension(2) :: f\n+\n+  m = 2\n+  f = (/3, 4/)\n+  d = reshape ((/5, 6, 7, 8, 9, 10/), (/2, 3/));\n+  allocate (e(2))\n+\n+  v = t((/1, 2/), reshape (f, (/m/)), d, e);\n+  if (any (v%a .ne. (/1, 2/)) .or. any (v%b .ne. (/3, 4/)) &\n+      .or. any (v%c .ne. d) .or. .not. associated (v%p, e)) &\n+    call abort ()\n+\n+  deallocate(e)\n+end program\n+"}]}