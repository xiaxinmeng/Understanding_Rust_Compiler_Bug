{"sha": "df4bacab135cf6c92e3b5c46900d58c1592e8ada", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY0YmFjYWIxMzVjZjZjOTJlM2I1YzQ2OTAwZDU4YzE1OTJlOGFkYQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-08T14:08:09Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-05-08T14:08:09Z"}, "message": "sh-protos.h (sh_media_register_for_return): Remove.\n\ngcc/\n\t* config/sh/sh-protos.h (sh_media_register_for_return): Remove.\n\t* config/sh/sh.c: Define and declare variables on first use throughout\n\tthe file.\n\t(current_function_interrupt): Change to bool type.\n\t(frame_insn): Rename to emit_frame_insn and update users.\n\t(push_regs): Use bool for 'interrupt_handler' argument.\n\t(save_schedule_s): Remove.\n\t(TARGET_ASM_UNALIGNED_DI_OP, TARGET_ASM_ALIGNED_DI_OP): Remove.\n\t(sh_option_override): Don't nullify targetm.asm_out.aligned_op.di and\n\ttargetm.asm_out.unaligned_op.di.\n\t(gen_far_branch): Remove redundant forward declaration.\n\t(sh_media_register_for_return, MAX_SAVED_REGS, save_entry_s, save_entry,\n\tMAX_TEMPS, save_schedule_ssave_schedule): Remove.\n\t(sh_set_return_address, sh_function_ok_for_sibcall,\n\tscavenge_reg): Update comments.\n\t(sh_builtin_saveregs): Use TRAGET_FPU_ANY condition.\n\t(sh2a_get_function_vector_number, sh2a_function_vector_p): Use for loop.\n\t(sh_attr_renesas_p): Remove unnecessary parentheses.\n\t(branch_dest): Simplify.\n\t* config/sh/sh.h (sh_args): Remove byref, byref_regs, stack_regs fields.\n\tChange force_mem, prototype_p, outgoing, renesas_abi fields to bool.\n\t(CUMULATIVE_ARGS): Change macro to typedef.\n\t(current_function_interrupt): Change to bool type.\n\t(sh_arg_class, sh_args, CUMULATIVE_ARGS, current_function_interrupt):\n\tSurround with __cplusplus ifdef.\n\t(sh_compare_op0, sh_compare_op1): Remove.\n\t(EPILOGUE_USES): Use TARGET_FPU_ANY condition.\n\nFrom-SVN: r236008", "tree": {"sha": "0dfd4c050b9e6c33731231d038bcc8fe1df7542d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dfd4c050b9e6c33731231d038bcc8fe1df7542d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df4bacab135cf6c92e3b5c46900d58c1592e8ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4bacab135cf6c92e3b5c46900d58c1592e8ada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df4bacab135cf6c92e3b5c46900d58c1592e8ada", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df4bacab135cf6c92e3b5c46900d58c1592e8ada/comments", "author": null, "committer": null, "parents": [{"sha": "5ebbbd3da1b46077353621b840d0ff96ce3411a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebbbd3da1b46077353621b840d0ff96ce3411a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ebbbd3da1b46077353621b840d0ff96ce3411a6"}], "stats": {"total": 636, "additions": 238, "deletions": 398}, "files": [{"sha": "62fe152b31ca2a1c589a4e13e339eba9c2803c28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df4bacab135cf6c92e3b5c46900d58c1592e8ada", "patch": "@@ -1,3 +1,33 @@\n+2016-05-08  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh-protos.h (sh_media_register_for_return): Remove.\n+\t* config/sh/sh.c: Define and declare variables on first use throughout\n+\tthe file.\n+\t(current_function_interrupt): Change to bool type.\n+\t(frame_insn): Rename to emit_frame_insn and update users.\n+\t(push_regs): Use bool for 'interrupt_handler' argument.\n+\t(save_schedule_s): Remove.\n+\t(TARGET_ASM_UNALIGNED_DI_OP, TARGET_ASM_ALIGNED_DI_OP): Remove.\n+\t(sh_option_override): Don't nullify targetm.asm_out.aligned_op.di and\n+\ttargetm.asm_out.unaligned_op.di.\n+\t(gen_far_branch): Remove redundant forward declaration.\n+\t(sh_media_register_for_return, MAX_SAVED_REGS, save_entry_s, save_entry,\n+\tMAX_TEMPS, save_schedule_ssave_schedule): Remove.\n+\t(sh_set_return_address, sh_function_ok_for_sibcall,\n+\tscavenge_reg): Update comments.\n+\t(sh_builtin_saveregs): Use TRAGET_FPU_ANY condition.\n+\t(sh2a_get_function_vector_number, sh2a_function_vector_p): Use for loop.\n+\t(sh_attr_renesas_p): Remove unnecessary parentheses.\n+\t(branch_dest): Simplify.\n+\t* config/sh/sh.h (sh_args): Remove byref, byref_regs, stack_regs fields.\n+\tChange force_mem, prototype_p, outgoing, renesas_abi fields to bool.\n+\t(CUMULATIVE_ARGS): Change macro to typedef.\n+\t(current_function_interrupt): Change to bool type.\n+\t(sh_arg_class, sh_args, CUMULATIVE_ARGS, current_function_interrupt):\n+\tSurround with __cplusplus ifdef.\n+\t(sh_compare_op0, sh_compare_op1): Remove.\n+\t(EPILOGUE_USES): Use TARGET_FPU_ANY condition.\n+\n 2016-05-07  Jim Wilson  <jim.wilson@linaro.org>\n \n \t* config/arm/arm.md: (arch): Add neon."}, {"sha": "fecbb886d0f5ab15b3868b7c915d130e5f5790d1", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=df4bacab135cf6c92e3b5c46900d58c1592e8ada", "patch": "@@ -366,7 +366,6 @@ extern void sh_cpu_cpp_builtins (cpp_reader* pfile);\n \n extern const char *output_jump_label_table (void);\n extern rtx get_t_reg_rtx (void);\n-extern int sh_media_register_for_return (void);\n extern void sh_expand_prologue (void);\n extern void sh_expand_epilogue (bool);\n extern void sh_set_return_address (rtx, rtx);"}, {"sha": "51f983c05075ec386ad6f558c372f888e3ff42b7", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 184, "deletions": 364, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=df4bacab135cf6c92e3b5c46900d58c1592e8ada", "patch": "@@ -80,8 +80,9 @@ int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n \t\t  ? (DECL_ATTRIBUTES (decl)) \\\n \t\t  : TYPE_ATTRIBUTES (TREE_TYPE (decl))\n \n-/* Set to 1 by expand_prologue() when the function is an interrupt handler.  */\n-int current_function_interrupt;\n+/* Set to true by expand_prologue() when the function is an\n+   interrupt handler.  */\n+bool current_function_interrupt;\n \n tree sh_deferred_function_attributes;\n tree *sh_deferred_function_attributes_tail = &sh_deferred_function_attributes;\n@@ -180,10 +181,10 @@ static void sh_reorg (void);\n static void sh_option_override (void);\n static void sh_override_options_after_change (void);\n static void output_stack_adjust (int, rtx, int, HARD_REG_SET *, bool);\n-static rtx_insn *frame_insn (rtx);\n+static rtx_insn* emit_frame_insn (rtx);\n static rtx push (int);\n static void pop (int);\n-static void push_regs (HARD_REG_SET *, int);\n+static void push_regs (HARD_REG_SET* mask, bool interrupt_handler);\n static int calc_live_regs (HARD_REG_SET *);\n static HOST_WIDE_INT rounded_frame_size (int);\n static bool sh_frame_pointer_required (void);\n@@ -267,7 +268,6 @@ static rtx sh_delegitimize_address (rtx);\n static bool sh_cannot_substitute_mem_equiv_p (rtx);\n static bool sh_legitimize_address_displacement (rtx *, rtx *, machine_mode);\n static int scavenge_reg (HARD_REG_SET *s);\n-struct save_schedule_s;\n \n static rtx sh_struct_value_rtx (tree, int);\n static rtx sh_function_value (const_tree, const_tree, bool);\n@@ -355,12 +355,6 @@ static const struct attribute_spec sh_attribute_table[] =\n #undef TARGET_ASM_UNALIGNED_SI_OP\n #define TARGET_ASM_UNALIGNED_SI_OP \"\\t.ualong\\t\"\n \n-/* These are NULLed out on non-SH5 in TARGET_OPTION_OVERRIDE.  */\n-#undef TARGET_ASM_UNALIGNED_DI_OP\n-#define TARGET_ASM_UNALIGNED_DI_OP \"\\t.uaquad\\t\"\n-#undef TARGET_ASM_ALIGNED_DI_OP\n-#define TARGET_ASM_ALIGNED_DI_OP \"\\t.quad\\t\"\n-\n #undef TARGET_OPTION_OVERRIDE\n #define TARGET_OPTION_OVERRIDE sh_option_override\n \n@@ -832,10 +826,6 @@ sh_option_override (void)\n       sh_cpu = PROCESSOR_SH4A;\n     }\n \n-  /* Only the sh64-elf assembler fully supports .quad properly.  */\n-  targetm.asm_out.aligned_op.di = NULL;\n-  targetm.asm_out.unaligned_op.di = NULL;\n-\n   /* User/priviledged mode is supported only on SH3* and SH4*.\n      Disable it for everything else.  */\n   if (!TARGET_SH3 && TARGET_USERMODE)\n@@ -1662,11 +1652,9 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \n   if (mode == Pmode || mode == ptr_mode)\n     {\n-      rtx op0, op1, opc;\n-      enum tls_model tls_kind;\n-\n-      op0 = operands[0];\n-      op1 = operands[1];\n+      rtx op0 = operands[0];\n+      rtx op1 = operands[1];\n+      rtx opc;\n       if (GET_CODE (op1) == CONST\n \t  && GET_CODE (XEXP (op1, 0)) == PLUS\n \t  && (tls_symbolic_operand (XEXP (XEXP (op1, 0), 0), Pmode)\n@@ -1678,6 +1666,8 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n       else\n \topc = NULL_RTX;\n \n+      enum tls_model tls_kind;\n+\n       if (! reload_in_progress && ! reload_completed\n \t  && (tls_kind = tls_symbolic_operand (op1, Pmode)) != TLS_MODEL_NONE)\n \t{\n@@ -1698,7 +1688,7 @@ prepare_move_operands (rtx operands[], machine_mode mode)\n \t      emit_use (gen_rtx_REG (SImode, PIC_REG));\n \t      if (flag_schedule_insns)\n \t\temit_insn (gen_blockage ());\n-\t}\n+\t    }\n \n \t  switch (tls_kind)\n \t    {\n@@ -2256,7 +2246,6 @@ sh_emit_scc_to_t (enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx t_reg = get_t_reg_rtx ();\n   enum rtx_code oldcode = code;\n-  machine_mode mode;\n \n   /* First need a compare insn.  */\n   switch (code)\n@@ -2282,7 +2271,7 @@ sh_emit_scc_to_t (enum rtx_code code, rtx op0, rtx op1)\n   if (code != oldcode)\n     std::swap (op0, op1);\n \n-  mode = GET_MODE (op0);\n+  machine_mode mode = GET_MODE (op0);\n   if (mode == VOIDmode)\n     mode = GET_MODE (op1);\n \n@@ -2825,14 +2814,13 @@ static bool\n unspec_caller_rtx_p (rtx pat)\n {\n   rtx base, offset;\n-  int i;\n-\n   split_const (pat, &base, &offset);\n+\n   if (GET_CODE (base) == UNSPEC)\n     {\n       if (XINT (base, 1) == UNSPEC_CALLER)\n \treturn true;\n-      for (i = 0; i < XVECLEN (base, 0); i++)\n+      for (int i = 0; i < XVECLEN (base, 0); i++)\n \tif (unspec_caller_rtx_p (XVECEXP (base, 0, i)))\n \t  return true;\n     }\n@@ -2844,8 +2832,6 @@ unspec_caller_rtx_p (rtx pat)\n static bool\n sh_cannot_copy_insn_p (rtx_insn *insn)\n {\n-  rtx pat;\n-\n   if (!reload_completed || !flag_pic)\n     return false;\n \n@@ -2854,7 +2840,7 @@ sh_cannot_copy_insn_p (rtx_insn *insn)\n   if (asm_noperands (insn) >= 0)\n     return false;\n \n-  pat = PATTERN (insn);\n+  rtx pat = PATTERN (insn);\n \n   if (GET_CODE (pat) == CLOBBER || GET_CODE (pat) == USE)\n     return false;\n@@ -4479,12 +4465,11 @@ static int max_labelno_before_reorg;\n static rtx_code_label *\n add_constant (rtx x, machine_mode mode, rtx last_value)\n {\n-  int i;\n   rtx_code_label *lab, *new_rtx;\n   label_ref_list_t ref, newref;\n \n   /* First see if we've already got it.  */\n-  for (i = 0; i < pool_size; i++)\n+  for (int i = 0; i < pool_size; i++)\n     {\n       if (x->code == pool_vector[i].value->code\n \t  && mode == pool_vector[i].mode)\n@@ -4558,15 +4543,14 @@ static void\n dump_table (rtx_insn *start, rtx_insn *barrier)\n {\n   rtx_insn *scan = barrier;\n-  int i;\n   bool need_align = true;\n   rtx lab;\n   label_ref_list_t ref;\n   bool have_df = false;\n \n   /* Do two passes, first time dump out the HI sized constants.  */\n \n-  for (i = 0; i < pool_size; i++)\n+  for (int i = 0; i < pool_size; i++)\n     {\n       pool_node *p = &pool_vector[i];\n \n@@ -4615,7 +4599,7 @@ dump_table (rtx_insn *start, rtx_insn *barrier)\n       scan = emit_insn_after (gen_align_log (GEN_INT (3)), scan);\n       need_align = false;\n \n-      for (i = 0; i < pool_size; i++)\n+      for (int i = 0; i < pool_size; i++)\n \t{\n \t  pool_node *p = &pool_vector[i];\n \n@@ -4681,7 +4665,7 @@ dump_table (rtx_insn *start, rtx_insn *barrier)\n       pool_size = 0;\n     }\n \n-  for (i = 0; i < pool_size; i++)\n+  for (int i = 0; i < pool_size; i++)\n     {\n       pool_node *p = &pool_vector[i];\n \n@@ -5250,7 +5234,7 @@ sfunc_uses_reg (rtx_insn *insn)\n   if (! reg_part)\n     return NULL_RTX;\n   reg = XEXP (reg_part, 0);\n-  for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n+  for (int i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n     {\n       part = XVECEXP (pattern, 0, i);\n       if (part == reg_part || GET_CODE (part) == CLOBBER)\n@@ -5269,14 +5253,12 @@ sfunc_uses_reg (rtx_insn *insn)\n static bool\n noncall_uses_reg (rtx reg, rtx_insn *insn, rtx *set)\n {\n-  rtx pattern, reg2;\n-\n   *set = NULL_RTX;\n \n-  reg2 = sfunc_uses_reg (insn);\n+  rtx reg2 = sfunc_uses_reg (insn);\n   if (reg2 && REGNO (reg2) == REGNO (reg))\n     {\n-      pattern = single_set (insn);\n+      rtx pattern = single_set (insn);\n       if (pattern\n \t  && REG_P (SET_DEST (pattern))\n \t  && REGNO (reg) == REGNO (SET_DEST (pattern)))\n@@ -5287,7 +5269,7 @@ noncall_uses_reg (rtx reg, rtx_insn *insn, rtx *set)\n     {\n       /* We don't use rtx_equal_p because we don't care if the mode is\n \t different.  */\n-      pattern = single_set (insn);\n+      rtx pattern = single_set (insn);\n       if (pattern\n \t  && REG_P (SET_DEST (pattern))\n \t  && REGNO (reg) == REGNO (SET_DEST (pattern)))\n@@ -5310,13 +5292,11 @@ noncall_uses_reg (rtx reg, rtx_insn *insn, rtx *set)\n       return true;\n     }\n \n-  pattern = PATTERN (insn);\n+  rtx pattern = PATTERN (insn);\n \n   if (GET_CODE (pattern) == PARALLEL)\n     {\n-      int i;\n-\n-      for (i = XVECLEN (pattern, 0) - 1; i >= 1; i--)\n+      for (int i = XVECLEN (pattern, 0) - 1; i >= 1; i--)\n \tif (reg_mentioned_p (reg, XVECEXP (pattern, 0, i)))\n \t  return true;\n       pattern = XVECEXP (pattern, 0, 0);\n@@ -5356,7 +5336,7 @@ regs_used (rtx x, int is_dest)\n {\n   enum rtx_code code;\n   const char *fmt;\n-  int i, used = 0;\n+  int used = 0;\n \n   if (! x)\n     return used;\n@@ -5403,12 +5383,11 @@ regs_used (rtx x, int is_dest)\n \n   fmt = GET_RTX_FORMAT (code);\n \n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+  for (int i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  for (int j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    used |= regs_used (XVECEXP (x, i, j), is_dest);\n \t}\n       else if (fmt[i] == 'e')\n@@ -5431,7 +5410,6 @@ gen_block_redirect (rtx_insn *jump, int addr, int need_block)\n {\n   int dead = 0;\n   rtx_insn *prev = prev_nonnote_insn (jump);\n-  rtx dest;\n \n   /* First, check if we already have an instruction that satisfies our need.  */\n   if (prev && NONJUMP_INSN_P (prev) && ! prev->deleted ())\n@@ -5457,7 +5435,7 @@ gen_block_redirect (rtx_insn *jump, int addr, int need_block)\n     }\n   /* We can't use JUMP_LABEL here because it might be undefined\n      when not optimizing.  */\n-  dest = XEXP (SET_SRC (PATTERN (jump)), 0);\n+  rtx dest = XEXP (SET_SRC (PATTERN (jump)), 0);\n   /* If the branch is out of range, try to find a scratch register for it.  */\n   if (optimize\n       && (INSN_ADDRESSES (INSN_UID (dest)) - addr + (unsigned) 4092\n@@ -5475,11 +5453,9 @@ gen_block_redirect (rtx_insn *jump, int addr, int need_block)\n \n       for (scan = jump; (scan = PREV_INSN (scan)); )\n \t{\n-\t  enum rtx_code code;\n-\n \t  if (scan->deleted ())\n \t    continue;\n-\t  code = GET_CODE (scan);\n+\t  rtx_code code = GET_CODE (scan);\n \t  if (code == CODE_LABEL || code == JUMP_INSN)\n \t    break;\n \t  if (code == INSN\n@@ -5494,11 +5470,9 @@ gen_block_redirect (rtx_insn *jump, int addr, int need_block)\n       for (used = dead = 0, scan = JUMP_LABEL_AS_INSN (jump);\n \t   (scan = NEXT_INSN (scan)); )\n \t{\n-\t  enum rtx_code code;\n-\n \t  if (scan->deleted ())\n \t    continue;\n-\t  code = GET_CODE (scan);\n+\t  rtx_code code = GET_CODE (scan);\n \t  if (INSN_P (scan))\n \t    {\n \t      used |= regs_used (PATTERN (scan), 0);\n@@ -5594,15 +5568,14 @@ struct far_branch\n   int address;\n };\n \n-static void gen_far_branch (struct far_branch *);\n enum mdep_reorg_phase_e mdep_reorg_phase;\n+\n static void\n gen_far_branch (struct far_branch *bp)\n {\n   rtx_insn *insn = bp->insert_place;\n   rtx_jump_insn *jump;\n   rtx_code_label *label = gen_label_rtx ();\n-  int ok;\n \n   emit_label_after (label, insn);\n   if (bp->far_label)\n@@ -5631,7 +5604,7 @@ gen_far_branch (struct far_branch *bp)\n       JUMP_LABEL (jump) = pat;\n     }\n \n-  ok = invert_jump (as_a <rtx_jump_insn *> (insn), label, 1);\n+  bool ok = invert_jump (as_a <rtx_jump_insn *> (insn), label, 1);\n   gcc_assert (ok);\n \n   /* If we are branching around a jump (rather than a return), prevent\n@@ -5701,8 +5674,6 @@ fixup_addr_diff_vecs (rtx_insn *first)\n int\n barrier_align (rtx_insn *barrier_or_label)\n {\n-  rtx next, pat;\n-\n   if (! barrier_or_label)\n     return 0;\n \n@@ -5715,7 +5686,7 @@ barrier_align (rtx_insn *barrier_or_label)\n       && PREV_INSN (barrier_or_label)\n       && JUMP_TABLE_DATA_P (PREV_INSN (barrier_or_label)))\n     {\n-      pat = PATTERN (PREV_INSN (barrier_or_label));\n+      rtx pat = PATTERN (PREV_INSN (barrier_or_label));\n       /* If this is a very small table, we want to keep the alignment after\n \t the table to the minimum for proper code alignment.  */\n       return ((optimize_size\n@@ -5724,12 +5695,12 @@ barrier_align (rtx_insn *barrier_or_label)\n \t      ? 1 : align_jumps_log);\n     }\n \n-  next = next_active_insn (barrier_or_label);\n+  rtx next = next_active_insn (barrier_or_label);\n \n   if (! next)\n     return 0;\n \n-  pat = PATTERN (next);\n+  rtx pat = PATTERN (next);\n \n   if (GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == UNSPECV_ALIGN)\n     /* This is a barrier in front of a constant table.  */\n@@ -6297,11 +6268,11 @@ int\n get_dest_uid (rtx label, int max_uid)\n {\n   rtx_insn *dest = next_real_insn (label);\n-  int dest_uid;\n+\n   if (! dest)\n     /* This can happen for an undefined label.  */\n     return 0;\n-  dest_uid = INSN_UID (dest);\n+  int dest_uid = INSN_UID (dest);\n   /* If this is a newly created branch redirection blocking instruction,\n      we cannot index the branch_uid or insn_addresses arrays with its\n      uid.  But then, we won't need to, because the actual destination is\n@@ -6560,14 +6531,9 @@ final_prescan_insn (rtx_insn *insn, rtx *opvec ATTRIBUTE_UNUSED,\n \n   if (TARGET_RELAX)\n     {\n-      rtx note;\n-\n-      note = find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX);\n-      if (note)\n+      if (rtx note = find_reg_note (insn, REG_LABEL_OPERAND, NULL_RTX))\n \t{\n-\t  rtx pattern;\n-\n-\t  pattern = PATTERN (insn);\n+\t  rtx pattern = PATTERN (insn);\n \t  if (GET_CODE (pattern) == PARALLEL)\n \t    pattern = XVECEXP (pattern, 0, 0);\n \t  switch (GET_CODE (pattern))\n@@ -6598,12 +6564,10 @@ final_prescan_insn (rtx_insn *insn, rtx *opvec ATTRIBUTE_UNUSED,\n const char *\n output_jump_label_table (void)\n {\n-  int i;\n-\n   if (pool_size)\n     {\n       fprintf (asm_out_file, \"\\t.align 2\\n\");\n-      for (i = 0; i < pool_size; i++)\n+      for (int i = 0; i < pool_size; i++)\n \t{\n \t  pool_node *p = &pool_vector[i];\n \n@@ -6648,7 +6612,7 @@ static void\n output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t\t     HARD_REG_SET *live_regs_mask, bool frame_p)\n {\n-  rtx_insn *(*emit_fn) (rtx) = frame_p ? &frame_insn : &emit_insn;\n+  rtx_insn *(*emit_fn) (rtx) = frame_p ? &emit_frame_insn : &emit_insn;\n   if (size)\n     {\n       HOST_WIDE_INT align = STACK_BOUNDARY / BITS_PER_UNIT;\n@@ -6798,10 +6762,9 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n     }\n }\n \n-/* Emit the specified insn and mark it as frame related.\n-   FIXME: Rename this to emit_frame_insn.  */\n+/* Emit the specified insn and mark it as frame related.  */\n static rtx_insn *\n-frame_insn (rtx x)\n+emit_frame_insn (rtx x)\n {\n   rtx_insn *insn = emit_insn (x);\n   RTX_FRAME_RELATED_P (insn) = 1;\n@@ -6829,7 +6792,7 @@ push (int rn)\n   else\n     x = gen_push (gen_rtx_REG (SImode, rn));\n \n-  x = frame_insn (x);\n+  x = emit_frame_insn (x);\n   add_reg_note (x, REG_INC, gen_rtx_REG (SImode, STACK_POINTER_REGNUM));\n   return x;\n }\n@@ -6872,15 +6835,15 @@ pop (int rn)\n \n /* Generate code to push the regs specified in the mask.  */\n static void\n-push_regs (HARD_REG_SET *mask, int interrupt_handler)\n+push_regs (HARD_REG_SET *mask, bool interrupt_handler)\n {\n-  int i = interrupt_handler ? LAST_BANKED_REG + 1 : 0;\n-  int skip_fpscr = 0;\n+  bool skip_fpscr = false;\n \n   /* Push PR last; this gives better latencies after the prologue, and\n      candidates for the return delay slot when there are no general\n      registers pushed.  */\n-  for (; i < FIRST_PSEUDO_REGISTER; i++)\n+  for (int i = interrupt_handler ? LAST_BANKED_REG + 1 : 0;\n+       i < FIRST_PSEUDO_REGISTER; i++)\n     {\n       /* If this is an interrupt handler, and the SZ bit varies,\n \t and we have to push any floating point register, we need\n@@ -6893,7 +6856,7 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t  push (FPSCR_REG);\n \t  COMPL_HARD_REG_SET (unsaved, *mask);\n \t  fpscr_set_from_mem (NORMAL_MODE (FP_MODE), unsaved);\n-\t  skip_fpscr = 1;\n+\t  skip_fpscr = true;\n \t}\n       if (i != PR_REG\n \t  && (i != FPSCR_REG || ! skip_fpscr)\n@@ -6919,7 +6882,7 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t{\n \t  unsigned int count = 0;\n \n-\t  for (i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n+\t  for (int i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n \t    if (TEST_HARD_REG_BIT (*mask, i))\n \t      count++;\n \t    else\n@@ -6941,8 +6904,8 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t     insns.  */\n \t  emit_insn (gen_blockage ());\n \t  x = gen_movml_push_banked (sp_reg);\n-\t  x = frame_insn (x);\n-\t  for (i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n+\t  x = emit_frame_insn (x);\n+\t  for (int i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n \t    {\n \t      mem = gen_rtx_MEM (SImode, plus_constant (Pmode, sp_reg, i * 4));\n \t      reg = gen_rtx_REG (SImode, i);\n@@ -6954,7 +6917,7 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n \t  emit_insn (gen_blockage ());\n \t}\n       else\n-\tfor (i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n+\tfor (int i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n \t  if (TEST_HARD_REG_BIT (*mask, i))\n \t    push (i);\n     }\n@@ -6974,11 +6937,9 @@ static int\n calc_live_regs (HARD_REG_SET *live_regs_mask)\n {\n   unsigned int reg;\n-  int count;\n   tree attrs;\n   bool interrupt_or_trapa_handler, trapa_handler, interrupt_handler;\n   bool nosave_low_regs;\n-  int pr_live, has_call;\n \n   attrs = DECL_ATTRIBUTES (current_function_decl);\n   interrupt_or_trapa_handler = sh_cfun_interrupt_handler_p ();\n@@ -6992,7 +6953,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n     target_flags &= ~MASK_FPU_SINGLE;\n   /* If we can save a lot of saves by switching to double mode, do that.  */\n   else if (TARGET_FPU_DOUBLE && TARGET_FMOVD && TARGET_FPU_SINGLE)\n-    for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n+    for (int count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n       if (df_regs_ever_live_p (reg) && df_regs_ever_live_p (reg+1)\n \t  && (! call_really_used_regs[reg]\n \t      || interrupt_handler)\n@@ -7002,20 +6963,22 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t  break;\n \t}\n \n-    {\n-      rtx pr_initial = has_hard_reg_initial_val (Pmode, PR_REG);\n-      pr_live = (pr_initial\n+\n+  rtx pr_initial = has_hard_reg_initial_val (Pmode, PR_REG);\n+  bool pr_live = (pr_initial\n \t\t ? (!REG_P (pr_initial)\n \t\t    || REGNO (pr_initial) != (PR_REG))\n \t\t : df_regs_ever_live_p (PR_REG));\n-      /* For Shcompact, if not optimizing, we end up with a memory reference\n-\t using the return address pointer for __builtin_return_address even\n-\t though there is no actual need to put the PR register on the stack.  */\n-      pr_live |= df_regs_ever_live_p (RETURN_ADDRESS_POINTER_REGNUM);\n-    }\n+  /* For Shcompact, if not optimizing, we end up with a memory reference\n+     using the return address pointer for __builtin_return_address even\n+     though there is no actual need to put the PR register on the stack.  */\n+  pr_live |= df_regs_ever_live_p (RETURN_ADDRESS_POINTER_REGNUM);\n+\n   /* Force PR to be live if the prologue has to call the SHmedia\n      argument decoder or register saver.  */\n-  has_call = pr_live;\n+  bool has_call = pr_live;\n+\n+  int count;\n   for (count = 0, reg = FIRST_PSEUDO_REGISTER; reg-- != 0; )\n     {\n       if (reg == PR_REG\n@@ -7119,93 +7082,34 @@ rounded_frame_size (int pushed)\n   return ((size + pushed + align - 1) & -align) - pushed;\n }\n \n-/* Choose a call-clobbered target-branch register that remains\n-   unchanged along the whole function.  We set it up as the return\n-   value in the prologue.  */\n-int\n-sh_media_register_for_return (void)\n-{\n-  int regno;\n-  int tr0_used;\n-\n-  if (! crtl->is_leaf)\n-    return -1;\n-  if (lookup_attribute (\"interrupt_handler\",\n-\t\t\tDECL_ATTRIBUTES (current_function_decl)))\n-    return -1;\n-  if (sh_cfun_interrupt_handler_p ())\n-    return -1;\n-\n-  tr0_used = flag_pic && df_regs_ever_live_p (PIC_OFFSET_TABLE_REGNUM);\n-\n-  for (regno = FIRST_TARGET_REG + tr0_used; regno <= LAST_TARGET_REG; regno++)\n-    if (call_really_used_regs[regno] && ! df_regs_ever_live_p (regno))\n-      return regno;\n-\n-  return -1;\n-}\n-\n-/* The maximum registers we need to save are:\n-   - 62 general purpose registers (r15 is stack pointer, r63 is zero)\n-   - 32 floating point registers (for each pair, we save none,\n-         one single precision value, or a double precision value).\n-   -  8 target registers\n-   -  add 1 entry for a delimiter.  */\n-#define MAX_SAVED_REGS (62+32+8)\n-\n-typedef struct save_entry_s\n-{\n-  unsigned char reg;\n-  unsigned char mode;\n-  short offset;\n-} save_entry;\n-\n-#define MAX_TEMPS 4\n-\n-/* There will be a delimiter entry with VOIDmode both at the start and the\n-   end of a filled in schedule.  The end delimiter has the offset of the\n-   save with the smallest (i.e. most negative) offset.  */\n-typedef struct save_schedule_s\n-{\n-  save_entry entries[MAX_SAVED_REGS + 2];\n-  int temps[MAX_TEMPS+1];\n-} save_schedule;\n-\n /* Expand code for the function prologue.  */\n void\n sh_expand_prologue (void)\n {\n-  HARD_REG_SET live_regs_mask;\n-  int d, i;\n-  int d_rounding = 0;\n   int save_flags = target_flags;\n-  int pretend_args;\n-  int stack_usage;\n   tree sp_switch_attr\n     = lookup_attribute (\"sp_switch\", DECL_ATTRIBUTES (current_function_decl));\n \n   current_function_interrupt = sh_cfun_interrupt_handler_p ();\n \n   /* We have pretend args if we had an object sent partially in registers\n      and partially on the stack, e.g. a large structure.  */\n-  pretend_args = crtl->args.pretend_args_size;\n+  int pretend_args = crtl->args.pretend_args_size;\n   if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl)\n       && (NPARM_REGS(SImode)\n \t  > crtl->args.info.arg_count[(int) SH_ARG_INT]))\n     pretend_args = 0;\n \n-  output_stack_adjust (-pretend_args\n-\t\t       - crtl->args.info.stack_regs * 8,\n-\t\t       stack_pointer_rtx, 0, NULL, true);\n-  stack_usage = pretend_args + crtl->args.info.stack_regs * 8;\n+  output_stack_adjust (-pretend_args, stack_pointer_rtx, 0, NULL, true);\n+  int stack_usage = pretend_args;\n \n   /* Emit the code for SETUP_VARARGS.  */\n   if (cfun->stdarg)\n     {\n       if (TARGET_VARARGS_PRETEND_ARGS (current_function_decl))\n \t{\n \t  /* Push arg regs as if they'd been provided by caller in stack.  */\n-\t  for (i = 0; i < NPARM_REGS(SImode); i++)\n+\t  for (int i = 0; i < NPARM_REGS(SImode); i++)\n \t    {\n \t      int rn = NPARM_REGS(SImode) + FIRST_PARM_REG - i - 1;\n \n@@ -7226,8 +7130,7 @@ sh_expand_prologue (void)\n       /* The argument specifies a variable holding the address of the\n \t stack the interrupt function should switch to/from at entry/exit.  */\n       tree arg = TREE_VALUE ( TREE_VALUE (sp_switch_attr));\n-      const char *s\n-\t= ggc_strdup (TREE_STRING_POINTER (arg));\n+      const char* s = ggc_strdup (TREE_STRING_POINTER (arg));\n       rtx sp_switch = gen_rtx_SYMBOL_REF (Pmode, s);\n \n       lab = add_constant (sp_switch, SImode, 0);\n@@ -7236,7 +7139,8 @@ sh_expand_prologue (void)\n       emit_insn (gen_sp_switch_1 (newsrc));\n     }\n \n-  d = calc_live_regs (&live_regs_mask);\n+  HARD_REG_SET live_regs_mask;\n+  int d = calc_live_regs (&live_regs_mask);\n   /* ??? Maybe we could save some switching if we can move a mode switch\n      that already happens to be at the function start into the prologue.  */\n   if (target_flags != save_flags && ! current_function_interrupt)\n@@ -7254,12 +7158,12 @@ sh_expand_prologue (void)\n \n   target_flags = save_flags;\n \n-  output_stack_adjust (-rounded_frame_size (d) + d_rounding,\n+  output_stack_adjust (-rounded_frame_size (d),\n \t\t       stack_pointer_rtx, 0, NULL, true);\n-  stack_usage += rounded_frame_size (d) - d_rounding;\n+  stack_usage += rounded_frame_size (d);\n \n   if (frame_pointer_needed)\n-    frame_insn (GEN_MOV (hard_frame_pointer_rtx, stack_pointer_rtx));\n+    emit_frame_insn (GEN_MOV (hard_frame_pointer_rtx, stack_pointer_rtx));\n \n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  Similarly if some call instructions are swapped\n@@ -7276,19 +7180,15 @@ sh_expand_prologue (void)\n void\n sh_expand_epilogue (bool sibcall_p)\n {\n-  HARD_REG_SET live_regs_mask;\n-  int d, i;\n-  int d_rounding = 0;\n-\n   int save_flags = target_flags;\n-  int frame_size, save_size;\n-  int fpscr_deferred = 0;\n+  bool fpscr_deferred = false;\n   int e = sibcall_p ? -1 : 1;\n \n-  d = calc_live_regs (&live_regs_mask);\n+  HARD_REG_SET live_regs_mask;\n+  int d = calc_live_regs (&live_regs_mask);\n \n-  save_size = d;\n-  frame_size = rounded_frame_size (d);\n+  int save_size = d;\n+  int frame_size = rounded_frame_size (d);\n \n   if (frame_pointer_needed)\n     {\n@@ -7303,7 +7203,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t occur after the SP adjustment and clobber data in the local\n \t frame.  */\n       emit_insn (gen_blockage ());\n-      frame_insn (GEN_MOV (stack_pointer_rtx, hard_frame_pointer_rtx));\n+      emit_frame_insn (GEN_MOV (stack_pointer_rtx, hard_frame_pointer_rtx));\n     }\n   else if (frame_size)\n     {\n@@ -7345,7 +7245,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t    {\n \t      unsigned int count = 0;\n \n-\t      for (i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n+\t      for (int i = FIRST_BANKED_REG; i <= LAST_BANKED_REG; i++)\n \t\tif (TEST_HARD_REG_BIT (live_regs_mask, i))\n \t\t  count++;\n \t\telse\n@@ -7369,7 +7269,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t      emit_insn (gen_blockage ());\n \t    }\n \t  else\n-\t    for (i = LAST_BANKED_REG; i >= FIRST_BANKED_REG; i--)\n+\t    for (int i = LAST_BANKED_REG; i >= FIRST_BANKED_REG; i--)\n \t      if (TEST_HARD_REG_BIT (live_regs_mask, i))\n \t\tpop (i);\n \n@@ -7378,14 +7278,14 @@ sh_expand_epilogue (bool sibcall_p)\n       else\n \tlast_reg = FIRST_PSEUDO_REGISTER;\n \n-      for (i = 0; i < last_reg; i++)\n+      for (int i = 0; i < last_reg; i++)\n \t{\n \t  int j = (FIRST_PSEUDO_REGISTER - 1) - i;\n \n \t  if (j == FPSCR_REG && current_function_interrupt && TARGET_FMOVD\n \t      && hard_reg_set_intersect_p (live_regs_mask,\n \t\t\t\t\t  reg_class_contents[DF_REGS]))\n-\t    fpscr_deferred = 1;\n+\t    fpscr_deferred = true;\n \t  /* For an ISR with RESBANK attribute assigned, don't pop\n \t     following registers, R0-R14, MACH, MACL and GBR.  */\n \t  else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j) \n@@ -7405,9 +7305,7 @@ sh_expand_epilogue (bool sibcall_p)\n     emit_insn (gen_toggle_sz ());\n   target_flags = save_flags;\n \n-  output_stack_adjust (crtl->args.pretend_args_size\n-\t\t       + save_size + d_rounding\n-\t\t       + crtl->args.info.stack_regs * 8,\n+  output_stack_adjust (crtl->args.pretend_args_size + save_size,\n \t\t       stack_pointer_rtx, e, NULL, true);\n \n   if (crtl->calls_eh_return)\n@@ -7434,8 +7332,7 @@ sh_set_return_address (rtx ra, rtx tmp)\n   HARD_REG_SET live_regs_mask;\n   int d = calc_live_regs (&live_regs_mask);\n \n-  /* If pr_reg isn't life, we can set it (or the register given in\n-     sh_media_register_for_return) directly.  */\n+  /* If pr_reg isn't life, we can set it directly.  */\n   if (! TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n     {\n       rtx rr = gen_rtx_REG (SImode, PR_REG);\n@@ -7482,7 +7379,7 @@ sh_builtin_saveregs (void)\n   int bufsize, regno;\n   alias_set_type alias_set;\n \n-  if (! TARGET_SH2E && ! TARGET_SH4)\n+  if (!TARGET_FPU_ANY)\n     {\n       error (\"__builtin_saveregs not supported by this subtarget\");\n       return const0_rtx;\n@@ -7723,30 +7620,26 @@ static tree\n sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t\t\t gimple_seq *post_p ATTRIBUTE_UNUSED)\n {\n-  HOST_WIDE_INT size, rsize;\n-  tree tmp, pptr_type_node;\n+  tree tmp;\n   tree addr, lab_over = NULL, result = NULL;\n-  bool pass_by_ref;\n   tree eff_type;\n \n-  if (!VOID_TYPE_P (type))\n-    pass_by_ref = targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n-  else\n-    pass_by_ref = false;\n+  const bool pass_by_ref =\n+    !VOID_TYPE_P (type)\n+    && targetm.calls.must_pass_in_stack (TYPE_MODE (type), type);\n \n   if (pass_by_ref)\n     type = build_pointer_type (type);\n \n-  size = int_size_in_bytes (type);\n-  rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n-  pptr_type_node = build_pointer_type (ptr_type_node);\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+  HOST_WIDE_INT rsize = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+  tree pptr_type_node = build_pointer_type (ptr_type_node);\n \n   if ((TARGET_SH2E || TARGET_SH4)\n       && ! (TARGET_HITACHI || sh_cfun_attr_renesas_p ()))\n     {\n       tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n       tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n-      int pass_as_float;\n       tree lab_false;\n       tree member;\n \n@@ -7791,6 +7684,7 @@ sh_gimplify_va_arg_expr (tree valist, tree type, gimple_seq *pre_p,\n \t    }\n \t}\n \n+      bool pass_as_float;\n       if (TARGET_FPU_DOUBLE)\n \t{\n \t  pass_as_float = ((TREE_CODE (eff_type) == REAL_TYPE && size <= 8)\n@@ -8149,7 +8043,7 @@ sh_function_arg_advance (cumulative_args_t ca_v, machine_mode mode,\n   CUMULATIVE_ARGS *ca = get_cumulative_args (ca_v);\n \n   if (ca->force_mem)\n-    ca->force_mem = 0;\n+    ca->force_mem = false;\n \n   if ((TARGET_HITACHI || ca->renesas_abi) && TARGET_FPU_DOUBLE)\n     {\n@@ -8290,27 +8184,22 @@ sh_pretend_outgoing_varargs_named (cumulative_args_t ca_v)\n int\n initial_elimination_offset (int from, int to)\n {\n-  int regs_saved;\n-  int regs_saved_rounding = 0;\n-  int total_saved_regs_space;\n-  int total_auto_space;\n+  const int regs_saved_rounding = 0;\n   int save_flags = target_flags;\n   HARD_REG_SET live_regs_mask;\n \n-  regs_saved = calc_live_regs (&live_regs_mask);\n+  int regs_saved = calc_live_regs (&live_regs_mask);\n \n-  total_auto_space = rounded_frame_size (regs_saved) - regs_saved_rounding;\n+  int total_auto_space = rounded_frame_size (regs_saved) - regs_saved_rounding;\n   target_flags = save_flags;\n \n-  total_saved_regs_space = regs_saved + regs_saved_rounding;\n+  int total_saved_regs_space = regs_saved + regs_saved_rounding;\n \n   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n-    return total_saved_regs_space + total_auto_space\n-\t   + crtl->args.info.byref_regs * 8;\n+    return total_saved_regs_space + total_auto_space;\n \n   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n-    return total_saved_regs_space + total_auto_space\n-\t   + crtl->args.info.byref_regs * 8;\n+    return total_saved_regs_space + total_auto_space;\n \n   /* Initial gap between fp and sp is 0.  */\n   if (from == HARD_FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n@@ -8332,39 +8221,34 @@ initial_elimination_offset (int from, int to)\n void\n sh_fix_range (const char *const_str)\n {\n-  int i, first, last;\n-  char *str, *dash, *comma;\n-\n   /* str must be of the form REG1'-'REG2{,REG1'-'REG} where REG1 and\n      REG2 are either register names or register numbers.  The effect\n      of this option is to mark the registers in the range from REG1 to\n      REG2 as ``fixed'' so they won't be used by the compiler.  */\n \n-  i = strlen (const_str);\n-  str = (char *) alloca (i + 1);\n-  memcpy (str, const_str, i + 1);\n+  char* str = strcpy ((char*)alloca (strlen (const_str) + 1), const_str);\n \n   while (1)\n     {\n-      dash = strchr (str, '-');\n+      char* dash = strchr (str, '-');\n       if (!dash)\n \t{\n \t  warning (0, \"value of -mfixed-range must have form REG1-REG2\");\n \t  return;\n \t}\n       *dash = '\\0';\n-      comma = strchr (dash + 1, ',');\n+      char* comma = strchr (dash + 1, ',');\n       if (comma)\n \t*comma = '\\0';\n \n-      first = decode_reg_name (str);\n+      int first = decode_reg_name (str);\n       if (first < 0)\n \t{\n \t  warning (0, \"unknown register name: %s\", str);\n \t  return;\n \t}\n \n-      last = decode_reg_name (dash + 1);\n+      int last = decode_reg_name (dash + 1);\n       if (last < 0)\n \t{\n \t  warning (0, \"unknown register name: %s\", dash + 1);\n@@ -8379,7 +8263,7 @@ sh_fix_range (const char *const_str)\n \t  return;\n \t}\n \n-      for (i = first; i <= last; ++i)\n+      for (int i = first; i <= last; ++i)\n \tfixed_regs[i] = call_used_regs[i] = 1;\n \n       if (!comma)\n@@ -8394,8 +8278,6 @@ sh_fix_range (const char *const_str)\n static void\n sh_insert_attributes (tree node, tree *attributes)\n {\n-  tree attrs;\n-\n   if (TREE_CODE (node) != FUNCTION_DECL)\n     return;\n \n@@ -8405,7 +8287,7 @@ sh_insert_attributes (tree node, tree *attributes)\n \n   /* Append the attributes to the deferred attributes.  */\n   *sh_deferred_function_attributes_tail = *attributes;\n-  attrs = sh_deferred_function_attributes;\n+  tree attrs = sh_deferred_function_attributes;\n   if (!attrs)\n     return;\n \n@@ -8600,28 +8482,17 @@ sh2a_is_function_vector_call (rtx x)\n int\n sh2a_get_function_vector_number (rtx x)\n {\n-  int num;\n-  tree list, t;\n-\n   if ((GET_CODE (x) == SYMBOL_REF)\n       && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n     {\n-      t = SYMBOL_REF_DECL (x);\n+      tree t = SYMBOL_REF_DECL (x);\n \n       if (TREE_CODE (t) != FUNCTION_DECL)\n \treturn 0;\n \n-      list = SH_ATTRIBUTES (t);\n-      while (list)\n-\t{\n-\t  if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n-\t    {\n-\t      num = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n-\t      return num;\n-\t    }\n-\n-\t  list = TREE_CHAIN (list);\n-\t}\n+      for (tree list = SH_ATTRIBUTES (t); list; list = TREE_CHAIN (list))\n+\tif (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+\t  return TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n \n       return 0;\n     }\n@@ -8699,8 +8570,7 @@ sh_attr_renesas_p (const_tree td)\n     td = TREE_TYPE (td);\n   if (td == error_mark_node)\n     return false;\n-  return (lookup_attribute (\"renesas\", TYPE_ATTRIBUTES (td))\n-\t  != NULL_TREE);\n+  return lookup_attribute (\"renesas\", TYPE_ATTRIBUTES (td)) != NULL_TREE;\n }\n \n /* True if __attribute__((renesas)) or -mrenesas, for the current\n@@ -8726,18 +8596,13 @@ sh_cfun_interrupt_handler_p (void)\n bool\n sh2a_function_vector_p (tree func)\n {\n-  tree list;\n   if (TREE_CODE (func) != FUNCTION_DECL)\n     return false;\n \n-  list = SH_ATTRIBUTES (func);\n-  while (list)\n-    {\n-      if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n-\treturn true;\n+  for (tree list = SH_ATTRIBUTES (func); list; list = TREE_CHAIN (list))\n+    if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+      return true;\n \n-      list = TREE_CHAIN (list);\n-    }\n   return false;\n }\n \n@@ -8797,12 +8662,10 @@ system_reg_operand (rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n bool\n fp_zero_operand (rtx op)\n {\n-  const REAL_VALUE_TYPE *r;\n-\n   if (GET_MODE (op) != SFmode)\n     return false;\n \n-  r = CONST_DOUBLE_REAL_VALUE (op);\n+  const REAL_VALUE_TYPE* r = CONST_DOUBLE_REAL_VALUE (op);\n   return real_equal (r, &dconst0) && ! REAL_VALUE_MINUS_ZERO (*r);\n }\n \n@@ -8830,13 +8693,11 @@ static int\n branch_dest (rtx branch)\n {\n   rtx dest = SET_SRC (PATTERN (branch));\n-  int dest_uid;\n \n   if (GET_CODE (dest) == IF_THEN_ELSE)\n     dest = XEXP (dest, 1);\n-  dest = XEXP (dest, 0);\n-  dest_uid = INSN_UID (dest);\n-  return INSN_ADDRESSES (dest_uid);\n+\n+  return INSN_ADDRESSES (INSN_UID (XEXP (dest, 0)));\n }\n \f\n /* Return nonzero if REG is not used after INSN.\n@@ -8845,24 +8706,20 @@ branch_dest (rtx branch)\n bool\n reg_unused_after (rtx reg, rtx_insn *insn)\n {\n-  enum rtx_code code;\n-  rtx set;\n-\n   /* If the reg is set by this instruction, then it is safe for our\n      case.  Disregard the case where this is a store to memory, since\n      we are checking a register used in the store address.  */\n-  set = single_set (insn);\n+  rtx set = single_set (insn);\n   if (set && !MEM_P (SET_DEST (set))\n       && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n     return true;\n \n   while ((insn = NEXT_INSN (insn)))\n     {\n-      rtx set;\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      code = GET_CODE (insn);\n+      rtx_code code = GET_CODE (insn);\n \n #if 0\n       /* If this is a label that existed before reload, then the register\n@@ -8884,10 +8741,9 @@ reg_unused_after (rtx reg, rtx_insn *insn)\n       else if (code == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t{\n \t  rtx_sequence *seq = as_a <rtx_sequence *> (PATTERN (insn));\n-\t  int i;\n-\t  int retval = 0;\n+\t  bool retval = false;\n \n-\t  for (i = 0; i < seq->len (); i++)\n+\t  for (int i = 0; i < seq->len (); i++)\n \t    {\n \t      rtx_insn *this_insn = seq->insn (i);\n \t      rtx set = single_set (this_insn);\n@@ -8914,18 +8770,18 @@ reg_unused_after (rtx reg, rtx_insn *insn)\n \t\t  && reg_overlap_mentioned_p (reg, PATTERN (this_insn)))\n \t\treturn false;\n \t    }\n-\t  if (retval == 1)\n+\t  if (retval)\n \t    return true;\n \t  else if (code == JUMP_INSN)\n \t    return false;\n \t}\n \n-      set = single_set (insn);\n+      rtx set = single_set (insn);\n       if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n \treturn false;\n       if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n \treturn !MEM_P (SET_DEST (set));\n-      if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+      if (set == NULL && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n \treturn false;\n \n       if (code == CALL_INSN && call_really_used_regs[REGNO (reg)])\n@@ -8949,13 +8805,9 @@ static GTY(()) tree fpscr_values;\n static void\n emit_fpu_switch (rtx scratch, int index)\n {\n-  rtx src;\n-\n   if (fpscr_values == NULL)\n     {\n-      tree t;\n-\n-      t = build_index_type (integer_one_node);\n+      tree t = build_index_type (integer_one_node);\n       t = build_array_type (integer_type_node, t);\n       t = build_decl (BUILTINS_LOCATION,\n \t\t      VAR_DECL, get_identifier (\"__fpscr_values\"), t);\n@@ -8969,7 +8821,7 @@ emit_fpu_switch (rtx scratch, int index)\n       fpscr_values = t;\n     }\n \n-  src = DECL_RTL (fpscr_values);\n+  rtx src = DECL_RTL (fpscr_values);\n   if (!can_create_pseudo_p ())\n     {\n       emit_move_insn (scratch, XEXP (src, 0));\n@@ -9017,9 +8869,8 @@ fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n {\n   enum attr_fp_mode fp_mode = (enum attr_fp_mode) mode;\n   enum attr_fp_mode norm_mode = ACTUAL_NORMAL_MODE (FP_MODE);\n-  rtx addr_reg;\n \n-  addr_reg = !can_create_pseudo_p () ? get_free_reg (regs_live) : NULL_RTX;\n+  rtx addr_reg = !can_create_pseudo_p () ? get_free_reg (regs_live) : NULL_RTX;\n   emit_fpu_switch (addr_reg, fp_mode == norm_mode);\n }\n \n@@ -9031,13 +8882,11 @@ fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n static bool\n sequence_insn_p (rtx_insn *insn)\n {\n-  rtx_insn *prev, *next;\n-\n-  prev = PREV_INSN (insn);\n+  rtx_insn* prev = PREV_INSN (insn);\n   if (prev == NULL)\n     return false;\n \n-  next = NEXT_INSN (prev);\n+  rtx_insn* next = NEXT_INSN (prev);\n   if (next == NULL)\n     return false;\n \n@@ -9201,9 +9050,6 @@ sh_legitimate_address_p (machine_mode mode, rtx x, bool strict)\n bool\n nonpic_symbol_mentioned_p (rtx x)\n {\n-  const char *fmt;\n-  int i;\n-\n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF\n       || GET_CODE (x) == PC)\n     return true;\n@@ -9229,13 +9075,12 @@ nonpic_symbol_mentioned_p (rtx x)\n \t  || XINT (x, 1) == UNSPEC_GOTOFFFUNCDESC))\n     return false;\n \n-  fmt = GET_RTX_FORMAT (GET_CODE (x));\n-  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+  const char* fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (int i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  for (int j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (nonpic_symbol_mentioned_p (XVECEXP (x, i, j)))\n \t      return true;\n \t}\n@@ -9249,8 +9094,7 @@ nonpic_symbol_mentioned_p (rtx x)\n /* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n    @GOTOFF in `reg'.  */\n rtx\n-legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\trtx reg)\n+legitimize_pic_address (rtx orig, machine_mode mode ATTRIBUTE_UNUSED, rtx reg)\n {\n   if (tls_symbolic_operand (orig, Pmode) != TLS_MODEL_NONE)\n     return orig;\n@@ -9466,16 +9310,14 @@ sh_legitimize_reload_address (rtx *p, machine_mode mode, int opnum,\n static rtx\n sh_delegitimize_address (rtx orig_x)\n {\n-  rtx x, y;\n-\n   orig_x = delegitimize_mem_from_attrs (orig_x);\n \n-  x = orig_x;\n+  rtx x = orig_x;\n   if (MEM_P (x))\n     x = XEXP (x, 0);\n   if (GET_CODE (x) == CONST)\n     {\n-      y = XEXP (x, 0);\n+      rtx y = XEXP (x, 0);\n       if (GET_CODE (y) == UNSPEC)\n \t{\n \t  if (XINT (y, 1) == UNSPEC_GOT\n@@ -9505,9 +9347,6 @@ sh_delegitimize_address (rtx orig_x)\n static rtx\n mark_constant_pool_use (rtx x)\n {\n-  rtx_insn *insn, *lab;\n-  rtx pattern;\n-\n   if (x == NULL_RTX)\n     return x;\n \n@@ -9523,8 +9362,8 @@ mark_constant_pool_use (rtx x)\n \n   /* Get the first label in the list of labels for the same constant\n      and delete another labels in the list.  */\n-  lab = as_a <rtx_insn *> (x);\n-  for (insn = PREV_INSN (lab); insn; insn = PREV_INSN (insn))\n+  rtx_insn* lab = as_a <rtx_insn*> (x);\n+  for (rtx_insn* insn = PREV_INSN (lab); insn; insn = PREV_INSN (insn))\n     {\n       if (!LABEL_P (insn)\n \t  || LABEL_REFS (insn) != NEXT_INSN (insn))\n@@ -9536,12 +9375,13 @@ mark_constant_pool_use (rtx x)\n     as_a<rtx_insn *> (insn)->set_deleted ();\n \n   /* Mark constants in a window.  */\n-  for (insn = NEXT_INSN (as_a <rtx_insn *> (x)); insn; insn = NEXT_INSN (insn))\n+  for (rtx_insn* insn = NEXT_INSN (as_a <rtx_insn *> (x)); insn;\n+       insn = NEXT_INSN (insn))\n     {\n       if (!NONJUMP_INSN_P (insn))\n \tcontinue;\n \n-      pattern = PATTERN (insn);\n+      rtx pattern = PATTERN (insn);\n       if (GET_CODE (pattern) != UNSPEC_VOLATILE)\n \tcontinue;\n \n@@ -9636,14 +9476,11 @@ sh_adjust_cost (rtx_insn *insn, rtx link ATTRIBUTE_UNUSED,\n \n   if (REG_NOTE_KIND (link) == 0)\n     {\n-      enum attr_type type;\n-      rtx dep_set;\n-\n       if (recog_memoized (insn) < 0\n \t  || recog_memoized (dep_insn) < 0)\n \treturn cost;\n \n-      dep_set = single_set (dep_insn);\n+      rtx dep_set = single_set (dep_insn);\n \n       /* The latency that we specify in the scheduling description refers\n \t to the actual output, not to an auto-increment register; for that,\n@@ -9689,8 +9526,8 @@ sh_adjust_cost (rtx_insn *insn, rtx link ATTRIBUTE_UNUSED,\n \t}\n       if (TARGET_HARD_SH4 && !TARGET_SH4_300)\n \t{\n-\t  enum attr_type dep_type = get_attr_type (dep_insn);\n-\n+\t  attr_type dep_type = get_attr_type (dep_insn);\n+\t  attr_type type;\n \t  if (dep_type == TYPE_FLOAD || dep_type == TYPE_PCFLOAD)\n \t    cost--;\n \t  else if ((dep_type == TYPE_LOAD_SI || dep_type == TYPE_PCLOAD_SI)\n@@ -9730,6 +9567,7 @@ sh_adjust_cost (rtx_insn *insn, rtx link ATTRIBUTE_UNUSED,\n       else if (TARGET_SH4_300)\n \t{\n \t  /* Stores need their input register two cycles later.  */\n+\t  attr_type type;\n \t  if (dep_set && cost >= 1\n \t      && ((type = get_attr_type (insn)) == TYPE_STORE\n \t\t  || type == TYPE_PSTORE\n@@ -9849,12 +9687,9 @@ find_set_regmode_weight (rtx x, machine_mode mode)\n static short\n find_insn_regmode_weight (rtx insn, machine_mode mode)\n {\n-  short reg_weight = 0;\n-  rtx x;\n-\n   /* Increment weight for each register born here.  */\n-  x = PATTERN (insn);\n-  reg_weight += find_set_regmode_weight (x, mode);\n+  rtx x = PATTERN (insn);\n+  short reg_weight = find_set_regmode_weight (x, mode);\n   if (GET_CODE (x) == PARALLEL)\n     {\n       int j;\n@@ -9949,43 +9784,42 @@ ready_reorder (rtx_insn **ready, int nready)\n static int\n find_r0_life_regions (basic_block b)\n {\n-  rtx_insn *end, *insn;\n-  rtx pset;\n-  rtx r0_reg;\n-  int live;\n+  bool live;\n   int set;\n   int death = 0;\n \n   if (REGNO_REG_SET_P (df_get_live_in (b), R0_REG))\n     {\n       set = 1;\n-      live = 1;\n+      live = true;\n     }\n   else\n     {\n       set = 0;\n-      live = 0;\n+      live = false;\n     }\n \n-  insn = BB_HEAD (b);\n-  end = BB_END (b);\n-  r0_reg = gen_rtx_REG (SImode, R0_REG);\n+  rtx_insn* insn = BB_HEAD (b);\n+  rtx_insn* end = BB_END (b);\n+  rtx r0_reg = gen_rtx_REG (SImode, R0_REG);\n   while (1)\n     {\n       if (INSN_P (insn))\n \t{\n \t  if (find_regno_note (insn, REG_DEAD, R0_REG))\n \t    {\n \t      death++;\n-\t      live = 0;\n+\t      live = false;\n \t    }\n+\n+\t  rtx pset;\n \t  if (!live\n \t      && (pset = single_set (insn))\n \t      && reg_overlap_mentioned_p (r0_reg, SET_DEST (pset))\n \t      && !find_regno_note (insn, REG_UNUSED, R0_REG))\n \t    {\n \t      set++;\n-\t      live = 1;\n+\t      live = true;\n \t    }\n \t}\n       if (insn == end)\n@@ -10278,10 +10112,6 @@ sh_trampoline_adjust_address (rtx tramp)\n   return tramp;\n }\n \n-/* FIXME: This is overly conservative.  A SHcompact function that\n-   receives arguments ``by reference'' will have them stored in its\n-   own stack frame, so it must not pass pointers or references to\n-   these arguments to other functions by means of sibling calls.  */\n /* If PIC, we cannot make sibling calls to global functions\n    because the PLT requires r12 to be live.  */\n static bool\n@@ -10621,15 +10451,14 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \n   for (int i = 1; i <= 3; i++, nop++)\n     {\n-      tree arg;\n-      machine_mode opmode, argmode;\n-      tree optype;\n-\n       if (! signature_args[signature][i])\n \tbreak;\n-      arg = CALL_EXPR_ARG (exp, i - 1);\n+      tree arg = CALL_EXPR_ARG (exp, i - 1);\n       if (arg == error_mark_node)\n \treturn const0_rtx;\n+\n+      machine_mode opmode;\n+      tree optype;\n       if (signature_args[signature][i] & 8)\n \t{\n \t  opmode = ptr_mode;\n@@ -10640,7 +10469,8 @@ sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \t  opmode = insn_data[icode].operand[nop].mode;\n \t  optype = (*lang_hooks.types.type_for_mode) (opmode, 0);\n \t}\n-      argmode = TYPE_MODE (TREE_TYPE (arg));\n+\n+      machine_mode argmode = TYPE_MODE (TREE_TYPE (arg));\n       if (argmode != opmode)\n \targ = build1 (NOP_EXPR, optype, arg);\n       op[nop] = expand_expr (arg, NULL_RTX, opmode, EXPAND_NORMAL);\n@@ -11150,12 +10980,12 @@ function_symbol (rtx target, const char *name, sh_function_kind kind)\n   return function_symbol_result (sym, lab);\n }\n \n-/* Find the number of a general purpose register in S.  */\n+/* Find the number of the first general purpose register in S that\n+   is not set.  */\n static int\n scavenge_reg (HARD_REG_SET *s)\n {\n-  int r;\n-  for (r = FIRST_GENERAL_REG; r <= LAST_GENERAL_REG; r++)\n+  for (int r = FIRST_GENERAL_REG; r <= LAST_GENERAL_REG; r++)\n     if (TEST_HARD_REG_BIT (*s, r))\n       return r;\n   return -1;\n@@ -11188,14 +11018,13 @@ sh_expand_t_scc (rtx operands[])\n   rtx op0 = operands[2];\n   rtx op1 = operands[3];\n   rtx result = target;\n-  HOST_WIDE_INT val;\n \n   if (!REG_P (op0) || REGNO (op0) != T_REG\n       || !CONST_INT_P (op1))\n     return false;\n   if (!REG_P (result))\n     result = gen_reg_rtx (SImode);\n-  val = INTVAL (op1);\n+  HOST_WIDE_INT val = INTVAL (op1);\n   if ((code == EQ && val == 1) || (code == NE && val == 0))\n     emit_insn (gen_movt (result, get_t_reg_rtx ()));\n   else if ((code == EQ && val == 0) || (code == NE && val == 1))\n@@ -11213,14 +11042,11 @@ sh_expand_t_scc (rtx operands[])\n static rtx\n extract_sfunc_addr (rtx insn)\n {\n-  rtx pattern, part = NULL_RTX;\n-  int len, i;\n-\n-  pattern = PATTERN (insn);\n-  len = XVECLEN (pattern, 0);\n-  for (i = 0; i < len; i++)\n+  rtx pattern = PATTERN (insn);\n+  const int len = XVECLEN (pattern, 0);\n+  for (int i = 0; i < len; i++)\n     {\n-      part = XVECEXP (pattern, 0, i);\n+      rtx part = XVECEXP (pattern, 0, i);\n       if (GET_CODE (part) == USE && GET_MODE (XEXP (part, 0)) == Pmode\n \t  && GENERAL_REGISTER_P (true_regnum (XEXP (part, 0))))\n \treturn XEXP (part, 0);\n@@ -11305,13 +11131,10 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n {\n   pcum->arg_count [(int) SH_ARG_FLOAT] = 0;\n   pcum->free_single_fp_reg = 0;\n-  pcum->stack_regs = 0;\n-  pcum->byref_regs = 0;\n-  pcum->byref = 0;\n-  pcum->outgoing = (n_named_args == -1) ? 0 : 1;\n+  pcum->outgoing = n_named_args != -1;\n \n-  /* XXX - Should we check TARGET_HITACHI here ???  */\n-  pcum->renesas_abi = sh_attr_renesas_p (fntype) ? 1 : 0;\n+  /* FIXME: Should we check TARGET_HITACHI here ???  */\n+  pcum->renesas_abi = sh_attr_renesas_p (fntype);\n \n   if (fntype)\n     {\n@@ -11323,7 +11146,7 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n   else\n     {\n       pcum->arg_count [(int) SH_ARG_INT] = 0;\n-      pcum->prototype_p = FALSE;\n+      pcum->prototype_p = false;\n       if (mode != VOIDmode)\n \t{\n \t  /* If the default ABI is the Renesas ABI then all library\n@@ -11342,7 +11165,7 @@ sh_init_cumulative_args (CUMULATIVE_ARGS *  pcum,\n \t\t\t && TARGET_FPU_DOUBLE)));\n \t}\n       else\n-\tpcum->force_mem = FALSE;\n+\tpcum->force_mem = false;\n     }\n }\n \n@@ -11598,8 +11421,7 @@ sh_movsf_ie_ra_split_p (rtx op0, rtx op1, rtx op2)\n static void\n sh_conditional_register_usage (void)\n {\n-  int regno;\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)\n+  for (int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno ++)\n     if (! VALID_REGISTER_P (regno))\n       fixed_regs[regno] = call_used_regs[regno] = 1;\n   /* R8 and R9 are call-clobbered on SH5, but not on earlier SH ABIs.  */\n@@ -11621,7 +11443,7 @@ sh_conditional_register_usage (void)\n       call_really_used_regs[MACL_REG] = 0;\n     }\n \n-  for (regno = FIRST_GENERAL_REG; regno <= LAST_GENERAL_REG; regno++)\n+  for (int regno = FIRST_GENERAL_REG; regno <= LAST_GENERAL_REG; regno++)\n     if (! fixed_regs[regno] && call_really_used_regs[regno])\n       SET_HARD_REG_BIT (reg_class_contents[SIBCALL_REGS], regno);\n \n@@ -11669,9 +11491,6 @@ sh_init_sync_libfuncs (void)\n bool\n sh_can_use_simple_return_p (void)\n {\n-  HARD_REG_SET live_regs_mask;\n-  int d;\n-\n   if (! reload_completed || frame_pointer_needed)\n     return false;\n \n@@ -11680,7 +11499,8 @@ sh_can_use_simple_return_p (void)\n     return false;\n \n   /* Finally, allow for pr save.  */\n-  d = calc_live_regs (&live_regs_mask);\n+  HARD_REG_SET live_regs_mask;\n+  int d = calc_live_regs (&live_regs_mask);\n \n   if (rounded_frame_size (d) > 4)\n    return false;"}, {"sha": "34dd1359102a00b305aac70bb3697f128347b92d", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df4bacab135cf6c92e3b5c46900d58c1592e8ada/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=df4bacab135cf6c92e3b5c46900d58c1592e8ada", "patch": "@@ -1154,6 +1154,8 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n        && (unsigned) (REGNO) < (unsigned) (FIRST_FP_PARM_REG\t\t\\\n \t\t\t\t\t   + NPARM_REGS (SFmode))))\n \f\n+#ifdef __cplusplus\n+\n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n@@ -1164,41 +1166,37 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n    of arguments scanned so far (including the invisible argument,\n    if any, which holds the structure-value-address).\n    Thus NARGREGS or more means all following args should go on the stack.  */\n+\n enum sh_arg_class { SH_ARG_INT = 0, SH_ARG_FLOAT = 1 };\n-struct sh_args {\n-    int arg_count[2];\n-    int force_mem;\n+\n+struct sh_args\n+{\n+  /* How many SH_ARG_INT and how many SH_ARG_FLOAT args there are.  */\n+  int arg_count[2];\n+\n+  bool force_mem;\n+\n   /* Nonzero if a prototype is available for the function.  */\n-    int prototype_p;\n+  bool prototype_p;\n+\n   /* The number of an odd floating-point register, that should be used\n      for the next argument of type float.  */\n-    int free_single_fp_reg;\n+  int free_single_fp_reg;\n+\n   /* Whether we're processing an outgoing function call.  */\n-    int outgoing;\n-  /* The number of general-purpose registers that should have been\n-     used to pass partial arguments, that are passed totally on the\n-     stack.  On SHcompact, a call trampoline will pop them off the\n-     stack before calling the actual function, and, if the called\n-     function is implemented in SHcompact mode, the incoming arguments\n-     decoder will push such arguments back onto the stack.  For\n-     incoming arguments, STACK_REGS also takes into account other\n-     arguments passed by reference, that the decoder will also push\n-     onto the stack.  */\n-    int stack_regs;\n-  /* The number of general-purpose registers that should have been\n-     used to pass arguments, if the arguments didn't have to be passed\n-     by reference.  */\n-    int byref_regs;\n-  /* Set as by shcompact_byref if the current argument is to be passed\n-     by reference.  */\n-    int byref;\n+  bool outgoing;\n \n   /* This is set to nonzero when the call in question must use the Renesas ABI,\n      even without the -mrenesas option.  */\n-    int renesas_abi;\n+  bool renesas_abi;\n };\n \n-#define CUMULATIVE_ARGS  struct sh_args\n+typedef sh_args CUMULATIVE_ARGS;\n+\n+/* Set when processing a function with interrupt attribute.  */\n+extern bool current_function_interrupt;\n+\n+#endif // __cplusplus\n \n #define GET_SH_ARG_CLASS(MODE) \\\n   ((TARGET_FPU_ANY && (MODE) == SFmode) \\\n@@ -1805,10 +1803,6 @@ struct sh_args {\n #define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n   final_prescan_insn ((INSN), (OPVEC), (NOPERANDS))\n \n-\f\n-extern rtx sh_compare_op0;\n-extern rtx sh_compare_op1;\n-\n /* Which processor to schedule for.  The elements of the enumeration must\n    match exactly the cpu attribute in the sh.md file.  */\n enum processor_type {\n@@ -1847,8 +1841,6 @@ extern enum mdep_reorg_phase_e mdep_reorg_phase;\n extern tree sh_deferred_function_attributes;\n extern tree *sh_deferred_function_attributes_tail;\n \n-/* Set when processing a function with interrupt attribute.  */\n-extern int current_function_interrupt;\n \n \f\n /* Instructions with unfilled delay slots take up an\n@@ -1889,8 +1881,7 @@ extern int current_function_interrupt;\n    ? (TARGET_FMOVD ? FP_MODE_DOUBLE : FP_MODE_NONE) \\\n    : ACTUAL_NORMAL_MODE (ENTITY))\n \n-#define EPILOGUE_USES(REGNO) ((TARGET_SH2E || TARGET_SH4) \\\n-\t\t\t      && (REGNO) == FPSCR_REG)\n+#define EPILOGUE_USES(REGNO) (TARGET_FPU_ANY && REGNO == FPSCR_REG)\n \n #define DWARF_FRAME_RETURN_COLUMN (DWARF_FRAME_REGNUM (PR_REG))\n "}]}