{"sha": "17b456229ec66d747ffb569508fa168f5d92cfc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiNDU2MjI5ZWM2NmQ3NDdmZmI1Njk1MDhmYTE2OGY1ZDkyY2ZjOA==", "commit": {"author": {"name": "Ranjit Mathew", "email": "rmathew@hotmail.com", "date": "2005-08-16T18:46:18Z"}, "committer": {"name": "Ranjit Mathew", "email": "rmathew@gcc.gnu.org", "date": "2005-08-16T18:46:18Z"}, "message": "re PR java/22113 (Buffer overflow in the lexical analyser while reading FP literals)\n\n\n\tPR java/22113\n\t* lex.c (do_java_lex): Define MAX_TOKEN_LEN. Avoid overflowing\n\t`literal_token' for large numeric input tokens.\n\nFrom-SVN: r103167", "tree": {"sha": "171349b84a5e6f0d001eac3f48739c1e2237c51c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/171349b84a5e6f0d001eac3f48739c1e2237c51c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17b456229ec66d747ffb569508fa168f5d92cfc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b456229ec66d747ffb569508fa168f5d92cfc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b456229ec66d747ffb569508fa168f5d92cfc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b456229ec66d747ffb569508fa168f5d92cfc8/comments", "author": null, "committer": null, "parents": [{"sha": "17ccdd2c51e9498d5eddd581e5328253ae42fb2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ccdd2c51e9498d5eddd581e5328253ae42fb2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ccdd2c51e9498d5eddd581e5328253ae42fb2a"}], "stats": {"total": 35, "additions": 25, "deletions": 10}, "files": [{"sha": "07dfc5b54dc516149d382b17d613fcd575ca2ff7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b456229ec66d747ffb569508fa168f5d92cfc8/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b456229ec66d747ffb569508fa168f5d92cfc8/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=17b456229ec66d747ffb569508fa168f5d92cfc8", "patch": "@@ -1,3 +1,9 @@\n+2005-08-16  Ranjit Mathew  <rmathew@hotmail.com>\n+\n+\tPR java/22113\n+\t* lex.c (do_java_lex): Define MAX_TOKEN_LEN. Avoid overflowing\n+\t`literal_token' for large numeric input tokens.\n+\n 2005-08-16  Ranjit Mathew  <rmathew@hotmail.com>\n \n \tPR java/19870"}, {"sha": "6941c4e19d43526dc7cb27f7b23fa8adb749b79b", "filename": "gcc/java/lex.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17b456229ec66d747ffb569508fa168f5d92cfc8/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17b456229ec66d747ffb569508fa168f5d92cfc8/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=17b456229ec66d747ffb569508fa168f5d92cfc8", "patch": "@@ -965,7 +965,9 @@ do_java_lex (YYSTYPE *java_lval)\n       int parts[TOTAL_PARTS];\n       HOST_WIDE_INT high, low;\n       /* End borrowed section.  */\n-      char literal_token [256];\n+\n+#define MAX_TOKEN_LEN 256\n+      char literal_token [MAX_TOKEN_LEN + 1];\n       int  literal_index = 0, radix = 10, long_suffix = 0, overflow = 0, bytes;\n       int  found_hex_digits = 0, found_non_octal_digits = -1;\n       int  i;\n@@ -1020,9 +1022,14 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t}\n \t    }\n \t}\n+\n+      /* Terminate LITERAL_TOKEN in case we bail out on large tokens.  */\n+      literal_token [MAX_TOKEN_LEN] = '\\0';\n+\n       /* Parse the first part of the literal, until we find something\n \t which is not a number.  */\n-      while (radix == 16 ? JAVA_ASCII_HEXDIGIT (c) : JAVA_ASCII_DIGIT (c))\n+      while ((radix == 16 ? JAVA_ASCII_HEXDIGIT (c) : JAVA_ASCII_DIGIT (c))\n+             && literal_index < MAX_TOKEN_LEN)\n \t{\n \t  /* We store in a string (in case it turns out to be a FP) and in\n \t     PARTS if we have to process a integer literal.  */\n@@ -1078,7 +1085,7 @@ do_java_lex (YYSTYPE *java_lval)\n \t    java_lex_error (\"Can't express non-decimal FP literal\", 0);\n \t  radix = 10;\n \n-\t  for (;;)\n+\t  for (; literal_index < MAX_TOKEN_LEN;)\n \t    {\n \t      if (c == '.')\n \t\t{\n@@ -1095,7 +1102,7 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t    java_lex_error (\"Invalid character in FP literal\", 0);\n \t\t}\n \n-\t      if (c == 'e' || c == 'E')\n+\t      if ((c == 'e' || c == 'E') && literal_index < MAX_TOKEN_LEN)\n \t\t{\n \t\t  if (stage < 2)\n \t\t    {\n@@ -1119,18 +1126,20 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t  stage = 4;\t/* So we fall through.  */\n \t\t}\n \n-\t      if ((c=='-' || c =='+') && stage == 2)\n+\t      if ((c=='-' || c =='+') && stage == 2\n+                  && literal_index < MAX_TOKEN_LEN)\n \t\t{\n \t\t  stage = 3;\n \t\t  literal_token [literal_index++] = c;\n \t\t  java_next_unicode ();\n \t\t  c = java_peek_unicode ();\n \t\t}\n \n-\t      if ((stage == 0 && JAVA_ASCII_FPCHAR (c)) ||\n-\t\t  (stage == 1 && JAVA_ASCII_FPCHAR (c) && !(c == '.')) ||\n-\t\t  (stage == 2 && (JAVA_ASCII_DIGIT (c) || JAVA_FP_PM (c))) ||\n-\t\t  (stage == 3 && JAVA_ASCII_DIGIT (c)))\n+              if (((stage == 0 && JAVA_ASCII_FPCHAR (c))\n+                   || (stage == 1 && JAVA_ASCII_FPCHAR (c) && !(c == '.'))\n+                   || (stage == 2 && (JAVA_ASCII_DIGIT (c) || JAVA_FP_PM (c)))\n+                   || (stage == 3 && JAVA_ASCII_DIGIT (c)))\n+                  && literal_index < MAX_TOKEN_LEN)\n \t\t{\n \t\t  if (JAVA_ASCII_DIGIT (c))\n \t\t    seen_digit = 1;\n@@ -1140,7 +1149,7 @@ do_java_lex (YYSTYPE *java_lval)\n \t\t  java_next_unicode ();\n \t\t  c = java_peek_unicode ();\n \t\t}\n-\t      else\n+\t      else if (literal_index < MAX_TOKEN_LEN)\n \t\t{\n \t\t  if (stage == 4) /* Don't push back fF/dD.  */\n \t\t    java_next_unicode ();"}]}