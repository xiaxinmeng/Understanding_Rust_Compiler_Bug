{"sha": "da5477a930cfa15554c08a951faa12d740623dd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE1NDc3YTkzMGNmYTE1NTU0YzA4YTk1MWZhYTEyZDc0MDYyM2RkNQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-21T21:02:34Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-21T21:02:34Z"}, "message": "cfgcleanup.c: Use rtx_insn (also touches basic-block.h and ifcvt.c)\n\ngcc/\n2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n\n\t* basic-block.h (flow_find_cross_jump): Strengthen params 3 and 4\n\t\"f1\" and \"f2\" from rtx * to rtx_insn **.\n\t(flow_find_head_matching_sequence): Likewise.\n\n\t* cfgcleanup.c (try_simplify_condjump): Strengthen local\n\t\"cbranch_insn\" from rtx to rtx_insn *.\n\t(thread_jump): Likewise for local \"insn\".\n\t(try_forward_edges): Likewise for local \"last\".\n\t(merge_blocks_move_predecessor_nojumps): Likewise for local \"barrier\".\n\t(merge_blocks_move_successor_nojumps): Likewise for locals \"barrier\",\n\t\"real_b_end\".\n\t(can_replace_by): Likewise for params \"i1\", \"i2\".\n\t(old_insns_match_p): Likewise.\n\t(merge_notes): Likewise.\n\t(walk_to_nondebug_insn): Likewise for param \"i1\".\n\t(flow_find_cross_jump): Strengthen params \"f1\" and \"f2\" from rtx *\n\tto rtx_insn **.  Strengthen locals \"i1\", \"i2\", \"last1\", \"last2\",\n\t\"afterlast1\", \"afterlast2\" from rtx to rtx_insn *.\n\t(flow_find_head_matching_sequence): Strengthen params \"f1\" and\n\t\"f2\" from rtx * to rtx_insn **.  Strengthen locals \"i1\", \"i2\",\n\t\"last1\", \"last2\", \"beforelast1\", \"beforelast2\" from rtx to\n\trtx_insn *.\n\t(outgoing_edges_match): Likewise for locals \"last1\", \"last2\".\n\t(try_crossjump_to_edge): Likewise for local \"insn\".\n\tReplace call to for_each_rtx with for_each_rtx_in_insn.\n\n\t(try_crossjump_to_edge): Likewise for locals \"newpos1\", \"newpos2\".\n\t(try_head_merge_bb): Likewise for locals \"e0_last_head_, \"jump\",\n\t\"e0_last\", \"e_last\", \"head\", \"curr\", \"insn\".  Strengthen locals\n\t\"headptr\", \"currptr\", \"nextptr\" from rtx * to rtx_insn **.\n\t(try_optimize_cfg): Strengthen local \"last\" from rtx to\n\trtx_insn *.\n\t(delete_dead_jumptables): Likewise for locals \"insn\", \"next\",\n\t\"label\".\n\n\t* ifcvt.c (cond_exec_process_if_block): Likewise for locals\n\t\"rtx then_last_head\", \"rtx else_last_head\", \"rtx then_first_tail\",\n\t\"rtx else_first_tail\", to reflect the basic-block.h changes above.\n\nFrom-SVN: r214292", "tree": {"sha": "db7f3c0f53d71518c200853007e36b9008ea6916", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db7f3c0f53d71518c200853007e36b9008ea6916"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da5477a930cfa15554c08a951faa12d740623dd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da5477a930cfa15554c08a951faa12d740623dd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da5477a930cfa15554c08a951faa12d740623dd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da5477a930cfa15554c08a951faa12d740623dd5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bbd58151e8b45501da6b011f9607be86a963bed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbd58151e8b45501da6b011f9607be86a963bed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbd58151e8b45501da6b011f9607be86a963bed"}], "stats": {"total": 137, "additions": 90, "deletions": 47}, "files": [{"sha": "5fd1b9cf15f812e8468ff81b5559fca175f15dc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da5477a930cfa15554c08a951faa12d740623dd5", "patch": "@@ -1,3 +1,44 @@\n+2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* basic-block.h (flow_find_cross_jump): Strengthen params 3 and 4\n+\t\"f1\" and \"f2\" from rtx * to rtx_insn **.\n+\t(flow_find_head_matching_sequence): Likewise.\n+\n+\t* cfgcleanup.c (try_simplify_condjump): Strengthen local\n+\t\"cbranch_insn\" from rtx to rtx_insn *.\n+\t(thread_jump): Likewise for local \"insn\".\n+\t(try_forward_edges): Likewise for local \"last\".\n+\t(merge_blocks_move_predecessor_nojumps): Likewise for local \"barrier\".\n+\t(merge_blocks_move_successor_nojumps): Likewise for locals \"barrier\",\n+\t\"real_b_end\".\n+\t(can_replace_by): Likewise for params \"i1\", \"i2\".\n+\t(old_insns_match_p): Likewise.\n+\t(merge_notes): Likewise.\n+\t(walk_to_nondebug_insn): Likewise for param \"i1\".\n+\t(flow_find_cross_jump): Strengthen params \"f1\" and \"f2\" from rtx *\n+\tto rtx_insn **.  Strengthen locals \"i1\", \"i2\", \"last1\", \"last2\",\n+\t\"afterlast1\", \"afterlast2\" from rtx to rtx_insn *.\n+\t(flow_find_head_matching_sequence): Strengthen params \"f1\" and\n+\t\"f2\" from rtx * to rtx_insn **.  Strengthen locals \"i1\", \"i2\",\n+\t\"last1\", \"last2\", \"beforelast1\", \"beforelast2\" from rtx to\n+\trtx_insn *.\n+\t(outgoing_edges_match): Likewise for locals \"last1\", \"last2\".\n+\t(try_crossjump_to_edge): Likewise for local \"insn\".\n+\tReplace call to for_each_rtx with for_each_rtx_in_insn.\n+\n+\t(try_crossjump_to_edge): Likewise for locals \"newpos1\", \"newpos2\".\n+\t(try_head_merge_bb): Likewise for locals \"e0_last_head_, \"jump\",\n+\t\"e0_last\", \"e_last\", \"head\", \"curr\", \"insn\".  Strengthen locals\n+\t\"headptr\", \"currptr\", \"nextptr\" from rtx * to rtx_insn **.\n+\t(try_optimize_cfg): Strengthen local \"last\" from rtx to\n+\trtx_insn *.\n+\t(delete_dead_jumptables): Likewise for locals \"insn\", \"next\",\n+\t\"label\".\n+\n+\t* ifcvt.c (cond_exec_process_if_block): Likewise for locals\n+\t\"rtx then_last_head\", \"rtx else_last_head\", \"rtx then_first_tail\",\n+\t\"rtx else_first_tail\", to reflect the basic-block.h changes above.\n+\n 2014-08-21  David Malcolm  <dmalcolm@redhat.com>\n \n \t* cfgbuild.c (make_edges): Strengthen local \"insn\" from rtx to"}, {"sha": "fc931f128bbb947958e46fbe28472f16bc71b0aa", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=da5477a930cfa15554c08a951faa12d740623dd5", "patch": "@@ -821,10 +821,10 @@ enum replace_direction { dir_none, dir_forward, dir_backward, dir_both };\n \n /* In cfgcleanup.c.  */\n extern bool cleanup_cfg (int);\n-extern int flow_find_cross_jump (basic_block, basic_block, rtx *, rtx *,\n-                                 enum replace_direction*);\n+extern int flow_find_cross_jump (basic_block, basic_block, rtx_insn **,\n+\t\t\t\t rtx_insn **, enum replace_direction*);\n extern int flow_find_head_matching_sequence (basic_block, basic_block,\n-\t\t\t\t\t     rtx *, rtx *, int);\n+\t\t\t\t\t     rtx_insn **, rtx_insn **, int);\n \n extern bool delete_unreachable_blocks (void);\n "}, {"sha": "17426cc5591c0a70c0456f4a6f17c80728814f1e", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=da5477a930cfa15554c08a951faa12d740623dd5", "patch": "@@ -70,7 +70,7 @@ static bool block_was_dirty;\n static bool try_crossjump_to_edge (int, edge, edge, enum replace_direction);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n-static enum replace_direction old_insns_match_p (int, rtx, rtx);\n+static enum replace_direction old_insns_match_p (int, rtx_insn *, rtx_insn *);\n \n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n@@ -115,7 +115,7 @@ try_simplify_condjump (basic_block cbranch_block)\n {\n   basic_block jump_block, jump_dest_block, cbranch_dest_block;\n   edge cbranch_jump_edge, cbranch_fallthru_edge;\n-  rtx cbranch_insn;\n+  rtx_insn *cbranch_insn;\n \n   /* Verify that there are exactly two successors.  */\n   if (EDGE_COUNT (cbranch_block->succs) != 2)\n@@ -265,7 +265,8 @@ mentions_nonequal_regs (rtx *x, void *data)\n static edge\n thread_jump (edge e, basic_block b)\n {\n-  rtx set1, set2, cond1, cond2, insn;\n+  rtx set1, set2, cond1, cond2;\n+  rtx_insn *insn;\n   enum rtx_code code1, code2, reversed_code2;\n   bool reverse1 = false;\n   unsigned i;\n@@ -492,7 +493,7 @@ try_forward_edges (int mode, basic_block b)\n \t\t      if (LOCATION_LOCUS (new_locus) != UNKNOWN_LOCATION)\n \t\t\tlocus = new_locus;\n \n-\t\t      rtx last = BB_END (target);\n+\t\t      rtx_insn *last = BB_END (target);\n \t\t      if (DEBUG_INSN_P (last))\n \t\t\tlast = prev_nondebug_insn (last);\n \t\t      if (last && INSN_P (last))\n@@ -659,7 +660,7 @@ try_forward_edges (int mode, basic_block b)\n static void\n merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n {\n-  rtx barrier;\n+  rtx_insn *barrier;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -703,7 +704,7 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n static void\n merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n {\n-  rtx barrier, real_b_end;\n+  rtx_insn *barrier, *real_b_end;\n   rtx label;\n   rtx_jump_table_data *table;\n \n@@ -1014,7 +1015,7 @@ equal_different_set_p (rtx p1, rtx s1, rtx p2, rtx s2)\n    - dir_both if both are the case.  */\n \n static enum replace_direction\n-can_replace_by (rtx i1, rtx i2)\n+can_replace_by (rtx_insn *i1, rtx_insn *i2)\n {\n   rtx s1, s2, d1, d2, src1, src2, note1, note2;\n   bool c1, c2;\n@@ -1093,7 +1094,7 @@ merge_dir (enum replace_direction a, enum replace_direction b)\n    - dir_both if both are the case.  */\n \n static enum replace_direction\n-old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n+old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)\n {\n   rtx p1, p2;\n \n@@ -1224,7 +1225,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n    flow_find_head_matching_sequence, ensure the notes match.  */\n \n static void\n-merge_notes (rtx i1, rtx i2)\n+merge_notes (rtx_insn *i1, rtx_insn *i2)\n {\n   /* If the merged insns have different REG_EQUAL notes, then\n      remove them.  */\n@@ -1250,7 +1251,7 @@ merge_notes (rtx i1, rtx i2)\n     DID_FALLTHRU.  Otherwise, stops at the head of the bb.  */\n \n static void\n-walk_to_nondebug_insn (rtx *i1, basic_block *bb1, bool follow_fallthru,\n+walk_to_nondebug_insn (rtx_insn **i1, basic_block *bb1, bool follow_fallthru,\n                        bool *did_fallthru)\n {\n   edge fallthru;\n@@ -1293,10 +1294,10 @@ walk_to_nondebug_insn (rtx *i1, basic_block *bb1, bool follow_fallthru,\n    store the head of the blocks in *F1 and *F2.  */\n \n int\n-flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n-                      enum replace_direction *dir_p)\n+flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx_insn **f1,\n+\t\t      rtx_insn **f2, enum replace_direction *dir_p)\n {\n-  rtx i1, i2, last1, last2, afterlast1, afterlast2;\n+  rtx_insn *i1, *i2, *last1, *last2, *afterlast1, *afterlast2;\n   int ninsns = 0;\n   enum replace_direction dir, last_dir, afterlast_dir;\n   bool follow_fallthru, did_fallthru;\n@@ -1312,7 +1313,7 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n      need to be compared for equivalence, which we'll do below.  */\n \n   i1 = BB_END (bb1);\n-  last1 = afterlast1 = last2 = afterlast2 = NULL_RTX;\n+  last1 = afterlast1 = last2 = afterlast2 = NULL;\n   if (onlyjump_p (i1)\n       || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n     {\n@@ -1428,10 +1429,10 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx *f1, rtx *f2,\n    non-zero, only count active insns.  */\n \n int\n-flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx *f1,\n-\t\t\t\t  rtx *f2, int stop_after)\n+flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx_insn **f1,\n+\t\t\t\t  rtx_insn **f2, int stop_after)\n {\n-  rtx i1, i2, last1, last2, beforelast1, beforelast2;\n+  rtx_insn *i1, *i2, *last1, *last2, *beforelast1, *beforelast2;\n   int ninsns = 0;\n   edge e;\n   edge_iterator ei;\n@@ -1446,7 +1447,7 @@ flow_find_head_matching_sequence (basic_block bb1, basic_block bb2, rtx *f1,\n \n   i1 = BB_HEAD (bb1);\n   i2 = BB_HEAD (bb2);\n-  last1 = beforelast1 = last2 = beforelast2 = NULL_RTX;\n+  last1 = beforelast1 = last2 = beforelast2 = NULL;\n \n   while (true)\n     {\n@@ -1751,8 +1752,8 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n      stop when we see the NOTE_INSN_BASIC_BLOCK, as old_insns_match_p\n      handles that case specially. old_insns_match_p does not handle\n      other types of instruction notes.  */\n-  rtx last1 = BB_END (bb1);\n-  rtx last2 = BB_END (bb2);\n+  rtx_insn *last1 = BB_END (bb1);\n+  rtx_insn *last2 = BB_END (bb2);\n   while (!NOTE_INSN_BASIC_BLOCK_P (last1) &&\n          (DEBUG_INSN_P (last1) || NOTE_P (last1)))\n     last1 = PREV_INSN (last1);\n@@ -1884,11 +1885,11 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n   basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to, redirect_from, to_remove;\n   basic_block osrc1, osrc2, redirect_edges_to, tmp;\n-  rtx newpos1, newpos2;\n+  rtx_insn *newpos1, *newpos2;\n   edge s;\n   edge_iterator ei;\n \n-  newpos1 = newpos2 = NULL_RTX;\n+  newpos1 = newpos2 = NULL;\n \n   /* If we have partitioned hot/cold basic blocks, it is a bad idea\n      to try this optimization.\n@@ -1955,7 +1956,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n       SWAP (basic_block, osrc1, osrc2);\n       SWAP (basic_block, src1, src2);\n       SWAP (edge, e1, e2);\n-      SWAP (rtx, newpos1, newpos2);\n+      SWAP (rtx_insn *, newpos1, newpos2);\n #undef SWAP\n     }\n \n@@ -1986,7 +1987,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \t  && label1 != label2)\n \t{\n \t  replace_label_data rr;\n-\t  rtx insn;\n+\t  rtx_insn *insn;\n \n \t  /* Replace references to LABEL1 with LABEL2.  */\n \t  rr.r1 = label1;\n@@ -1998,7 +1999,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \t\t a block whose end is a tablejump, the tablejump referenced\n \t\t from the instruction is deleted too.  */\n \t      if (insn != BB_END (osrc1))\n-\t\tfor_each_rtx (&insn, replace_label, &rr);\n+\t\tfor_each_rtx_in_insn (&insn, replace_label, &rr);\n \t    }\n \t}\n     }\n@@ -2286,12 +2287,13 @@ try_head_merge_bb (basic_block bb)\n   basic_block final_dest_bb = NULL;\n   int max_match = INT_MAX;\n   edge e0;\n-  rtx *headptr, *currptr, *nextptr;\n+  rtx_insn **headptr, **currptr, **nextptr;\n   bool changed, moveall;\n   unsigned ix;\n-  rtx e0_last_head, cond, move_before;\n+  rtx_insn *e0_last_head;\n+  rtx cond, move_before;\n   unsigned nedges = EDGE_COUNT (bb->succs);\n-  rtx jump = BB_END (bb);\n+  rtx_insn *jump = BB_END (bb);\n   regset live, live_union;\n \n   /* Nothing to do if there is not at least two outgoing edges.  */\n@@ -2381,13 +2383,13 @@ try_head_merge_bb (basic_block bb)\n     }\n \n   e0 = EDGE_SUCC (bb, 0);\n-  e0_last_head = NULL_RTX;\n+  e0_last_head = NULL;\n   changed = false;\n \n   for (ix = 1; ix < nedges; ix++)\n     {\n       edge e = EDGE_SUCC (bb, ix);\n-      rtx e0_last, e_last;\n+      rtx_insn *e0_last, *e_last;\n       int nmatch;\n \n       nmatch = flow_find_head_matching_sequence (e0->dest, e->dest,\n@@ -2424,15 +2426,15 @@ try_head_merge_bb (basic_block bb)\n   live = BITMAP_ALLOC (NULL);\n   live_union = BITMAP_ALLOC (NULL);\n \n-  currptr = XNEWVEC (rtx, nedges);\n-  headptr = XNEWVEC (rtx, nedges);\n-  nextptr = XNEWVEC (rtx, nedges);\n+  currptr = XNEWVEC (rtx_insn *, nedges);\n+  headptr = XNEWVEC (rtx_insn *, nedges);\n+  nextptr = XNEWVEC (rtx_insn *, nedges);\n \n   for (ix = 0; ix < nedges; ix++)\n     {\n       int j;\n       basic_block merge_bb = EDGE_SUCC (bb, ix)->dest;\n-      rtx head = BB_HEAD (merge_bb);\n+      rtx_insn *head = BB_HEAD (merge_bb);\n \n       while (!NONDEBUG_INSN_P (head))\n \thead = NEXT_INSN (head);\n@@ -2522,7 +2524,7 @@ try_head_merge_bb (basic_block bb)\n \t    break;\n \t  for (ix = 0; ix < nedges; ix++)\n \t    {\n-\t      rtx curr = currptr[ix];\n+\t      rtx_insn *curr = currptr[ix];\n \t      do\n \t\tcurr = NEXT_INSN (curr);\n \t      while (!NONDEBUG_INSN_P (curr));\n@@ -2535,7 +2537,7 @@ try_head_merge_bb (basic_block bb)\n       if (!moveall)\n \tfor (ix = 0; ix < nedges; ix++)\n \t  {\n-\t    rtx curr = currptr[ix];\n+\t    rtx_insn *curr = currptr[ix];\n \t    do\n \t      curr = NEXT_INSN (curr);\n \t    while (!NONDEBUG_INSN_P (curr));\n@@ -2589,7 +2591,7 @@ try_head_merge_bb (basic_block bb)\n static bool\n trivially_empty_bb_p (basic_block bb)\n {\n-  rtx insn = BB_END (bb);\n+  rtx_insn *insn = BB_END (bb);\n \n   while (1)\n     {\n@@ -2687,7 +2689,7 @@ try_optimize_cfg (int mode)\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  rtx last = get_last_bb_insn (b);\n+\t\t\t  rtx_insn *last = get_last_bb_insn (b);\n \t\t\t  if (last && BARRIER_P (last))\n \t\t\t    FOR_EACH_EDGE (e, ei, b->preds)\n \t\t\t      if ((e->flags & EDGE_FALLTHRU))\n@@ -2961,7 +2963,7 @@ delete_dead_jumptables (void)\n      between two adjacent basic blocks.  */\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      rtx insn, next;\n+      rtx_insn *insn, *next;\n \n       for (insn = NEXT_INSN (BB_END (bb));\n \t   insn && !NOTE_INSN_BASIC_BLOCK_P (insn);\n@@ -2972,7 +2974,7 @@ delete_dead_jumptables (void)\n \t      && LABEL_NUSES (insn) == LABEL_PRESERVE_P (insn)\n \t      && JUMP_TABLE_DATA_P (next))\n \t    {\n-\t      rtx label = insn, jump = next;\n+\t      rtx_insn *label = insn, *jump = next;\n \n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Dead jumptable %i removed\\n\","}, {"sha": "c1894bb5c6fc7166b507e8a15a31deedeeea687c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da5477a930cfa15554c08a951faa12d740623dd5/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=da5477a930cfa15554c08a951faa12d740623dd5", "patch": "@@ -476,10 +476,10 @@ cond_exec_process_if_block (ce_if_block * ce_info,\n   rtx false_expr;\t\t/* test for then block insns */\n   int true_prob_val;\t\t/* probability of else block */\n   int false_prob_val;\t\t/* probability of then block */\n-  rtx then_last_head = NULL_RTX;\t/* Last match at the head of THEN */\n-  rtx else_last_head = NULL_RTX;\t/* Last match at the head of ELSE */\n-  rtx then_first_tail = NULL_RTX;\t/* First match at the tail of THEN */\n-  rtx else_first_tail = NULL_RTX;\t/* First match at the tail of ELSE */\n+  rtx_insn *then_last_head = NULL;\t/* Last match at the head of THEN */\n+  rtx_insn *else_last_head = NULL;\t/* Last match at the head of ELSE */\n+  rtx_insn *then_first_tail = NULL;\t/* First match at the tail of THEN */\n+  rtx_insn *else_first_tail = NULL;\t/* First match at the tail of ELSE */\n   int then_n_insns, else_n_insns, n_insns;\n   enum rtx_code false_code;\n   rtx note;"}]}