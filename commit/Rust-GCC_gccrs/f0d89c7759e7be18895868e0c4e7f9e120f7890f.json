{"sha": "f0d89c7759e7be18895868e0c4e7f9e120f7890f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkODljNzc1OWU3YmUxODg5NTg2OGUwYzRlN2Y5ZTEyMGY3ODkwZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T17:30:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T17:30:00Z"}, "message": "runtime: avoid write barriers with traceback info\n    \n    Unlike the gc runtime, libgo stores traceback information in location\n    structs, which contain strings.  Therefore, copying location structs\n    around appears to require write barriers, although in fact write\n    barriers are never important because the strings are never allocated\n    in Go memory.  They come from libbacktrace.\n    \n    Some of the generated write barriers come at times when write barriers\n    are not permitted.  For example, exitsyscall, marked\n    nowritebarrierrec, calls exitsyscallfast which calls traceGoSysExit\n    which calls traceEvent which calls traceStackID which calls\n    trace.stackTab.put which copies location values into memory allocated\n    by tab.newStack.  This write barrier can be invoked when there is no\n    p, causing a crash.\n    \n    This change fixes the problem by ensuring that location values are\n    copied around in the tracing code with no write barriers.\n    \n    This was found by fixing the compiler to fully implement\n    //go:nowritebarrierrec; CL to follow.\n    \n    Reviewed-on: https://go-review.googlesource.com/134226\n\nFrom-SVN: r264282", "tree": {"sha": "ffb6a90f3e684836545e8c93e21e30588428ca11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffb6a90f3e684836545e8c93e21e30588428ca11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0d89c7759e7be18895868e0c4e7f9e120f7890f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d89c7759e7be18895868e0c4e7f9e120f7890f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d89c7759e7be18895868e0c4e7f9e120f7890f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d89c7759e7be18895868e0c4e7f9e120f7890f/comments", "author": null, "committer": null, "parents": [{"sha": "5f54d5fee46b8f1a0a78a8fbeb03e3ddfc8c9346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f54d5fee46b8f1a0a78a8fbeb03e3ddfc8c9346", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f54d5fee46b8f1a0a78a8fbeb03e3ddfc8c9346"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "205ead9d55385262d67610e46a32851413cf1bc6", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d89c7759e7be18895868e0c4e7f9e120f7890f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d89c7759e7be18895868e0c4e7f9e120f7890f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f0d89c7759e7be18895868e0c4e7f9e120f7890f", "patch": "@@ -1,4 +1,4 @@\n-70bd9801911f8ed27df410d36a928166c37a68fd\n+baf07c40960dc4f8df9da97281870d80d4245b18\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "12d7071c3c0fe8901b89bedac7e8c290fcfe63fc", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=f0d89c7759e7be18895868e0c4e7f9e120f7890f", "patch": "@@ -1140,7 +1140,7 @@ func startTheWorldWithSema(emitTraceEvent bool) int64 {\n func kickoff() {\n \tgp := getg()\n \n-\tif gp.traceback != nil {\n+\tif gp.traceback != 0 {\n \t\tgtraceback(gp)\n \t}\n \n@@ -3097,7 +3097,7 @@ func newproc(fn uintptr, arg unsafe.Pointer) *g {\n \t} else {\n \t\tresetNewG(newg, &sp, &spsize)\n \t}\n-\tnewg.traceback = nil\n+\tnewg.traceback = 0\n \n \tif readgstatus(newg) != _Gdead {\n \t\tthrow(\"newproc1: new g is not Gdead\")"}, {"sha": "2de1cc8d725dcdc5377c9e7d1a6439325e51a5e0", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=f0d89c7759e7be18895868e0c4e7f9e120f7890f", "patch": "@@ -431,7 +431,7 @@ type g struct {\n \n \tisSystemGoroutine bool // whether goroutine is a \"system\" goroutine\n \n-\ttraceback *tracebackg // stack traceback buffer\n+\ttraceback uintptr // stack traceback buffer\n \n \tcontext      g_ucontext_t // saved context for setcontext\n \tstackcontext [10]uintptr  // split-stack context"}, {"sha": "e2bbb5d52ab52b6d08b1b23489c124299007e515", "filename": "libgo/go/runtime/trace.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Ftrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Ftrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace.go?ref=f0d89c7759e7be18895868e0c4e7f9e120f7890f", "patch": "@@ -135,6 +135,7 @@ var trace struct {\n }\n \n // traceBufHeader is per-P tracing buffer.\n+//go:notinheap\n type traceBufHeader struct {\n \tlink      traceBufPtr              // in trace.empty/full\n \tlastTicks uint64                   // when we wrote the last event\n@@ -747,7 +748,8 @@ func (tab *traceStackTable) put(pcs []location) uint32 {\n \tstk.n = len(pcs)\n \tstkpc := stk.stack()\n \tfor i, pc := range pcs {\n-\t\tstkpc[i] = pc\n+\t\t// Use memmove to avoid write barrier.\n+\t\tmemmove(unsafe.Pointer(&stkpc[i]), unsafe.Pointer(&pc), unsafe.Sizeof(pc))\n \t}\n \tpart := int(hash % uintptr(len(tab.tab)))\n \tstk.link = tab.tab[part]"}, {"sha": "9456b1f4b3d0b5d212f5cdad93a1db8ab9a8ee04", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=f0d89c7759e7be18895868e0c4e7f9e120f7890f", "patch": "@@ -186,7 +186,7 @@ func tracebackothers(me *g) {\n \tif gp != nil && gp != me {\n \t\tprint(\"\\n\")\n \t\tgoroutineheader(gp)\n-\t\tgp.traceback = (*tracebackg)(noescape(unsafe.Pointer(&tb)))\n+\t\tgp.traceback = (uintptr)(noescape(unsafe.Pointer(&tb)))\n \t\tgetTraceback(me, gp)\n \t\tprinttrace(tb.locbuf[:tb.c], nil)\n \t\tprintcreatedby(gp)\n@@ -220,7 +220,7 @@ func tracebackothers(me *g) {\n \t\t\tprint(\"\\tgoroutine in C code; stack unavailable\\n\")\n \t\t\tprintcreatedby(gp)\n \t\t} else {\n-\t\t\tgp.traceback = (*tracebackg)(noescape(unsafe.Pointer(&tb)))\n+\t\t\tgp.traceback = (uintptr)(noescape(unsafe.Pointer(&tb)))\n \t\t\tgetTraceback(me, gp)\n \t\t\tprinttrace(tb.locbuf[:tb.c], nil)\n \t\t\tprintcreatedby(gp)"}, {"sha": "7bd95a061c77b36dd821f2c5e13b8e2640d18a97", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d89c7759e7be18895868e0c4e7f9e120f7890f/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=f0d89c7759e7be18895868e0c4e7f9e120f7890f", "patch": "@@ -338,7 +338,7 @@ runtime_mcall(FuncVal *fv)\n \t\tgp = runtime_g();\n \t\tmp = gp->m;\n \n-\t\tif(gp->traceback != nil)\n+\t\tif(gp->traceback != 0)\n \t\t\tgtraceback(gp);\n \t}\n \tif (gp == nil || !gp->fromgogo) {\n@@ -443,7 +443,7 @@ void getTraceback(G* me, G* gp)\n #endif\n \tgetcontext(ucontext_arg(&me->context[0]));\n \n-\tif (gp->traceback != nil) {\n+\tif (gp->traceback != 0) {\n \t\truntime_gogo(gp);\n \t}\n }\n@@ -457,8 +457,8 @@ gtraceback(G* gp)\n \tTraceback* traceback;\n \tM* holdm;\n \n-\ttraceback = gp->traceback;\n-\tgp->traceback = nil;\n+\ttraceback = (Traceback*)gp->traceback;\n+\tgp->traceback = 0;\n \tholdm = gp->m;\n \tif(holdm != nil && holdm != g->m)\n \t\truntime_throw(\"gtraceback: m is not nil\");\n@@ -510,7 +510,7 @@ runtime_mstart(void *arg)\n \t// multiple times via the setcontext call in mcall.\n \tgetcontext(ucontext_arg(&gp->context[0]));\n \n-\tif(gp->traceback != nil) {\n+\tif(gp->traceback != 0) {\n \t\t// Got here from getTraceback.\n \t\t// I'm not sure this ever actually happens--getTraceback\n \t\t// may always go to the getcontext call in mcall."}]}