{"sha": "d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk3MzcxZTAyNDlmNWMyOWYzMDZmZmU5YmViZDU1NWZhOGZlYTNjOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-18T06:27:40Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-18T06:27:40Z"}, "message": "cpplib.c (dtable): Update.\n\n\t* cpplib.c (dtable): Update.\n\t(end_directive): Decrement expansion prevention count.\n\tClear state.in_expression.\n\t(prepare_directive_trad): Set state.in_expression.\n\tIncrement expansion prevention count.\n\t* cpptrad.c (enum ls): New.\n\t(_cpp_overlay_buffer): Set overlaid_buffer.\n\t(_cpp_remove_overlay): Use overlaid_buffer.\n\t(_cpp_read_logcial_line_trad): Update buffer when it might\n\thave changed.\n\t(scan_out_logical_line): Handle state transitions for assertions\n\tand defined() in #if, and for funlike invocations including the\n\tdirective case.  Handle '<' and '>' as a quote mechanism in\n\t#include.  Warn about unterminated macro invocations.\n\t* cpphash.h (struct lexer_state): New member in_expression.\n\t(struct cpp_reader): New member overlaid buffer.\n\nFrom-SVN: r54732", "tree": {"sha": "91cf53e07a5ce822aa18fc347d7f155a4deeee70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91cf53e07a5ce822aa18fc347d7f155a4deeee70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/comments", "author": null, "committer": null, "parents": [{"sha": "807b20b01ec236384e83cbed3b82241616a97880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/807b20b01ec236384e83cbed3b82241616a97880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/807b20b01ec236384e83cbed3b82241616a97880"}], "stats": {"total": 191, "additions": 148, "deletions": 43}, "files": [{"sha": "4f1c3de545cf04f3c38e8392a0b73dd436736364", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "patch": "@@ -1,3 +1,22 @@\n+2002-06-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpplib.c (dtable): Update.\n+\t(end_directive): Decrement expansion prevention count.\n+\tClear state.in_expression.\n+\t(prepare_directive_trad): Set state.in_expression.\n+\tIncrement expansion prevention count.\n+\t* cpptrad.c (enum ls): New.\n+\t(_cpp_overlay_buffer): Set overlaid_buffer.\n+\t(_cpp_remove_overlay): Use overlaid_buffer.\n+\t(_cpp_read_logcial_line_trad): Update buffer when it might\n+\thave changed.\n+\t(scan_out_logical_line): Handle state transitions for assertions\n+\tand defined() in #if, and for funlike invocations including the\n+\tdirective case.  Handle '<' and '>' as a quote mechanism in\n+\t#include.  Warn about unterminated macro invocations.\n+\t* cpphash.h (struct lexer_state): New member in_expression.\n+\t(struct cpp_reader): New member overlaid buffer.\n+\n 2002-06-18  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/arit.c (do_31div, __Udiv, __Umod): Mark prototype"}, {"sha": "98dfb49ca7c377c89e71008d9b5abcec95622862", "filename": "gcc/cpphash.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "patch": "@@ -211,6 +211,9 @@ struct lexer_state\n   /* Nonzero if in a directive that takes angle-bracketed headers.  */\n   unsigned char angled_headers;\n \n+  /* Nonzero if in a #if or #elif directive.  */\n+  unsigned char in_expression;\n+\n   /* Nonzero to save comments.  Turned off if discard_comments, and in\n      all directives apart from #define.  */\n   unsigned char save_comments;\n@@ -309,6 +312,9 @@ struct cpp_reader\n   /* Top of buffer stack.  */\n   cpp_buffer *buffer;\n \n+  /* Overlaid buffer (can be different after processing #include).  */\n+  cpp_buffer *overlaid_buffer;\n+\n   /* Lexer state.  */\n   struct lexer_state state;\n "}, {"sha": "4ee97e81a05ea502759d968882f116f5a5ea85d1", "filename": "gcc/cpplib.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "patch": "@@ -72,9 +72,7 @@ struct pragma_entry\n    means this directive should be handled even if -fpreprocessed is in\n    effect (these are the directives with callback hooks).\n \n-   EXPAND is set on directives that are always macro-expanded.  If\n-   INCL is set, macro expansion is special-cased and EXPAND should not\n-   be set.  */\n+   EXPAND is set on directives that are always macro-expanded.  */\n #define COND\t\t(1 << 0)\n #define IF_COND\t\t(1 << 1)\n #define INCL\t\t(1 << 2)\n@@ -147,7 +145,7 @@ static void handle_assertion\tPARAMS ((cpp_reader *, const char *, int));\n \n #define DIRECTIVE_TABLE\t\t\t\t\t\t\t\\\n D(define,\tT_DEFINE = 0,\tKANDR,     IN_I)\t   /* 270554 */ \\\n-D(include,\tT_INCLUDE,\tKANDR,     INCL)\t   /*  52262 */ \\\n+D(include,\tT_INCLUDE,\tKANDR,     INCL | EXPAND)  /*  52262 */ \\\n D(endif,\tT_ENDIF,\tKANDR,     COND)\t   /*  45855 */ \\\n D(ifdef,\tT_IFDEF,\tKANDR,     COND | IF_COND) /*  22000 */ \\\n D(if,\t\tT_IF,\t\tKANDR, COND | IF_COND | EXPAND) /*  18162 */ \\\n@@ -159,9 +157,9 @@ D(elif,\t\tT_ELIF,\t\tSTDC89,    COND | EXPAND)  /*    610 */ \\\n D(error,\tT_ERROR,\tSTDC89,    0)\t\t   /*    475 */ \\\n D(pragma,\tT_PRAGMA,\tSTDC89,    IN_I)\t   /*    195 */ \\\n D(warning,\tT_WARNING,\tEXTENSION, 0)\t\t   /*     22 */ \\\n-D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION, INCL)\t   /*     19 */ \\\n+D(include_next,\tT_INCLUDE_NEXT,\tEXTENSION, INCL | EXPAND)  /*     19 */ \\\n D(ident,\tT_IDENT,\tEXTENSION, IN_I)\t   /*     11 */ \\\n-D(import,\tT_IMPORT,\tEXTENSION, INCL)\t   /* 0 ObjC */\t\\\n+D(import,\tT_IMPORT,\tEXTENSION, INCL | EXPAND)  /* 0 ObjC */\t\\\n D(assert,\tT_ASSERT,\tEXTENSION, 0)\t\t   /* 0 SVR4 */\t\\\n D(unassert,\tT_UNASSERT,\tEXTENSION, 0)\t\t   /* 0 SVR4 */\t\\\n SCCS_ENTRY\t\t\t\t\t\t   /* 0 SVR4? */\n@@ -256,6 +254,9 @@ end_directive (pfile, skip_line)\n {\n   if (CPP_OPTION (pfile, traditional))\n     {\n+      /* Revert change of prepare_directive_trad.  */\n+      pfile->state.prevent_expansion--;\n+\n       if (pfile->directive != &dtable[T_DEFINE])\n \t_cpp_remove_overlay (pfile);\n     }\n@@ -273,6 +274,7 @@ end_directive (pfile, skip_line)\n   /* Restore state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n   pfile->state.in_directive = 0;\n+  pfile->state.in_expression = 0;\n   pfile->state.angled_headers = 0;\n   pfile->directive = 0;\n }\n@@ -291,6 +293,8 @@ prepare_directive_trad (pfile)\n       bool was_skipping = pfile->state.skipping;\n \n       pfile->state.skipping = false;\n+      pfile->state.in_expression = (pfile->directive == &dtable[T_IF]\n+\t\t\t\t    || pfile->directive == &dtable[T_ELIF]);\n       if (no_expand)\n \tpfile->state.prevent_expansion++;\n       _cpp_read_logical_line_trad (pfile);\n@@ -300,6 +304,9 @@ prepare_directive_trad (pfile)\n       _cpp_overlay_buffer (pfile, pfile->out.base,\n \t\t\t   pfile->out.cur - pfile->out.base);\n     }\n+\n+  /* Stop ISO C from expanding anything.  */\n+  pfile->state.prevent_expansion++;\n }\n \n /* Output diagnostics for a directive DIR.  INDENTED is non-zero if"}, {"sha": "b29750dd6c5c8701e8faef2f85cefd6ef07da75b", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 110, "deletions": 37, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d97371e0249f5c29f306ffe9bebd555fa8fea3c9/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=d97371e0249f5c29f306ffe9bebd555fa8fea3c9", "patch": "@@ -63,6 +63,15 @@ struct fun_macro\n   unsigned int argc;\n };\n \n+/* Lexing state.  It is mostly used to prevent macro expansion.  */\n+enum ls {ls_none = 0,\t\t/* Normal state.  */\n+\t ls_fun_macro,\t\t/* When looking for '('.  */\n+\t ls_defined,\t\t/* After defined.  */\n+\t ls_defined_close,\t/* Looking for ')' of defined().  */\n+\t ls_hash,\t\t/* After # in preprocessor conditional.  */\n+\t ls_predicate,\t\t/* After the predicate, maybe paren?  */\n+\t ls_answer};\t\t/* In answer to predicate.  */\n+\n /* Lexing TODO: Maybe handle space in escaped newlines.  Stop cpplex.c\n    from recognizing comments and directives during its lexing pass.  */\n \n@@ -322,6 +331,7 @@ _cpp_overlay_buffer (pfile, start, len)\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n+  pfile->overlaid_buffer = buffer;\n   buffer->saved_cur = buffer->cur;\n   buffer->saved_rlimit = buffer->rlimit;\n \n@@ -336,7 +346,7 @@ void\n _cpp_remove_overlay (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n+  cpp_buffer *buffer = pfile->overlaid_buffer;\n \n   buffer->cur = buffer->saved_cur;\n   buffer->rlimit = buffer->saved_rlimit;\n@@ -363,6 +373,7 @@ _cpp_read_logical_line_trad (pfile)\n \t    {\n \t      stop = buffer->return_at_eof;\n \t      _cpp_pop_buffer (pfile);\n+\t      buffer = pfile->buffer;\n \t    }\n \n \t  if (stop)\n@@ -372,6 +383,7 @@ _cpp_read_logical_line_trad (pfile)\n       CUR (pfile->context) = buffer->cur;\n       RLIMIT (pfile->context) = buffer->rlimit;\n       scan_out_logical_line (pfile, NULL);\n+      buffer = pfile->buffer;\n       buffer->cur = CUR (pfile->context);\n     }\n   while (pfile->state.skipping);\n@@ -426,9 +438,10 @@ scan_out_logical_line (pfile, macro)\n {\n   cpp_context *context;\n   const uchar *cur;\n-  unsigned int c, paren_depth = 0, quote = 0;\n   uchar *out;\n   struct fun_macro fmacro;\n+  unsigned int c, paren_depth = 0, quote = 0;\n+  enum ls lex_state = ls_none;\n \n   fmacro.buff = NULL;\n \n@@ -446,13 +459,19 @@ scan_out_logical_line (pfile, macro)\n       c = *cur++;\n       *out++ = c;\n \n-      /* There are only a few entities we need to catch: comments,\n-\t identifiers, newlines, escaped newlines, # and '\\0'.  */\n+      /* Whitespace should \"continue\" out of the switch,\n+\t non-whitespace should \"break\" out of it.  */\n       switch (c)\n \t{\n+\tcase ' ':\n+\tcase '\\t':\n+\tcase '\\f':\n+\tcase '\\v':\n+\t  continue;\n+\n \tcase '\\0':\n \t  if (cur - 1 != RLIMIT (context))\n-\t    break;\n+\t    continue;\n \n \t  /* If this is a macro's expansion, pop it.  */\n \t  if (context->prev)\n@@ -475,14 +494,26 @@ scan_out_logical_line (pfile, macro)\n \n \tcase '\\r': case '\\n':\n \t  cur = handle_newline (pfile, cur - 1);\n-\t  if (pfile->state.parsing_args == 2)\n+\t  if (pfile->state.parsing_args == 2 && !pfile->state.in_directive)\n \t    {\n \t      /* Newlines in arguments become a space.  */\n \t      out[-1] = ' ';\n \t      continue;\n \t    }\n \t  goto done;\n \n+\tcase '<':\n+\t  if (pfile->state.angled_headers && !quote)\n+\t    quote = '>';\n+\t  break;\n+\tcase '>':\n+\t  if (pfile->state.angled_headers && c == quote)\n+\t    {\n+\t      pfile->state.angled_headers = false;\n+\t      quote = 0;\n+\t    }\n+\t  break;\n+\n \tcase '\"':\n \tcase '\\'':\n \t  if (c == quote)\n@@ -493,7 +524,11 @@ scan_out_logical_line (pfile, macro)\n \n \tcase '\\\\':\n \t  if (is_vspace (*cur))\n-\t    out--, cur = skip_escaped_newlines (pfile, cur - 1);\n+\t    {\n+\t      out--;\n+\t      cur = skip_escaped_newlines (pfile, cur - 1);\n+\t      continue;\n+\t    }\n \t  else\n \t    {\n \t      /* Skip escaped quotes here, it's easier than above, but\n@@ -515,6 +550,7 @@ scan_out_logical_line (pfile, macro)\n \t\t  pfile->out.cur = out;\n \t\t  cur = copy_comment (pfile, cur, macro != 0);\n \t\t  out = pfile->out.cur;\n+\t\t  continue;\n \t\t}\n \t    }\n \t  break;\n@@ -530,26 +566,33 @@ scan_out_logical_line (pfile, macro)\n \tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n \tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n \tcase 'Y': case 'Z':\n-\t  if (quote == 0 || macro)\n+\t  if (!pfile->state.skipping && (quote == 0 || macro))\n \t    {\n \t      cpp_hashnode *node;\n+\t      uchar *out_start = out - 1;\n \n-\t      pfile->out.cur = --out;\n+\t      pfile->out.cur = out_start;\n \t      node = lex_identifier (pfile, cur - 1);\n+\t      out = pfile->out.cur;\n+\t      cur = CUR (context);\n \n \t      if (node->type == NT_MACRO\n-\t\t  && !pfile->state.skipping\n-\t\t  && pfile->state.parsing_args != 2\n+\t\t  /* Should we expand for ls_answer?  */\n+\t\t  && lex_state == ls_none\n \t\t  && !pfile->state.prevent_expansion\n \t\t  && !recursive_macro (pfile, node))\n \t\t{\n \t\t  if (node->value.macro->fun_like)\n-\t\t    maybe_start_funlike (pfile, node, out, &fmacro);\n+\t\t    {\n+\t\t      maybe_start_funlike (pfile, node, out_start, &fmacro);\n+\t\t      lex_state = ls_fun_macro;\n+\t\t      continue;\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Remove the object-like macro's name from the\n \t\t\t output, and push its replacement text.  */\n-\t\t      pfile->out.cur = out;\n+\t\t      pfile->out.cur = out_start;\n \t\t      push_replacement_text (pfile, node);\n \t\t      goto new_context;\n \t\t    }\n@@ -558,40 +601,39 @@ scan_out_logical_line (pfile, macro)\n \t\t{\n \t\t  /* Found a parameter in the replacement text of a\n \t\t     #define.  Remove its name from the output.  */\n-\t\t  pfile->out.cur = out;\n+\t\t  out = pfile->out.cur = out_start;\n \t\t  save_replacement_text (pfile, macro, node->arg_index);\n \t\t}\n-\n-\t      out = pfile->out.cur;\n-\t      cur = CUR (context);\n+\t      else if (lex_state == ls_hash)\n+\t\t{\n+\t\t  lex_state = ls_predicate;\n+\t\t  continue;\n+\t\t}\n+\t      else if (pfile->state.in_expression\n+\t\t       && node == pfile->spec_nodes.n_defined)\n+\t\t{\n+\t\t  lex_state = ls_defined;\n+\t\t  continue;\n+\t\t}\n \t    }\n \t  break;\n \n \tcase '(':\n \t  if (quote == 0)\n \t    {\n \t      paren_depth++;\n-\t      if (pfile->state.parsing_args == 1)\n+\t      if (lex_state == ls_fun_macro)\n \t\t{\n-\t\t  const uchar *p = pfile->out.base + fmacro.offset;\n-\n-\t\t  /* Invoke a prior function-like macro if there is only\n-\t\t     white space in-between.  */\n-\t\t  while (is_numchar (*p))\n-\t\t    p++;\n-\t\t  while (is_space (*p))\n-\t\t    p++;\n-\n-\t\t  if (p == out - 1)\n-\t\t    {\n-\t\t      pfile->state.parsing_args = 2;\n-\t\t      paren_depth = 1;\n-\t\t      out = pfile->out.base + fmacro.offset;\n-\t\t      fmacro.args[0] = fmacro.offset;\n-\t\t    }\n-\t\t  else\n-\t\t    pfile->state.parsing_args = 0;\n+\t\t  lex_state = ls_none;\n+\t\t  pfile->state.parsing_args = 2;\n+\t\t  paren_depth = 1;\n+\t\t  out = pfile->out.base + fmacro.offset;\n+\t\t  fmacro.args[0] = fmacro.offset;\n \t\t}\n+\t      else if (lex_state == ls_predicate)\n+\t\tlex_state = ls_answer;\n+\t      else if (lex_state == ls_defined)\n+\t\tlex_state = ls_defined_close;\n \t    }\n \t  break;\n \n@@ -614,7 +656,7 @@ scan_out_logical_line (pfile, macro)\n \t\t  /* A single zero-length argument is no argument.  */\n \t\t  if (fmacro.argc == 1\n \t\t      && m->paramc == 0\n-\t\t      && out == pfile->out.base + 1)\n+\t\t      && out == pfile->out.base + fmacro.offset + 1)\n \t\t    fmacro.argc = 0;\n \n \t\t  if (_cpp_arguments_ok (pfile, m, fmacro.node, fmacro.argc))\n@@ -628,6 +670,8 @@ scan_out_logical_line (pfile, macro)\n \t\t      goto new_context;\n \t\t    }\n \t\t}\n+\t      else if (lex_state == ls_answer || lex_state == ls_defined_close)\n+\t\tlex_state = ls_none;\n \t    }\n \t  break;\n \n@@ -641,11 +685,34 @@ scan_out_logical_line (pfile, macro)\n \t      if (_cpp_handle_directive (pfile, false /* indented */))\n \t\tgoto start_logical_line;\n \t    }\n+\t  if (pfile->state.in_expression)\n+\t    {\n+\t      lex_state = ls_hash;\n+\t      continue;\n+\t    }\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n+\n+      if (lex_state == ls_none)\n+\tcontinue;\n+\n+      /* Some of these transitions of state are syntax errors.  The\n+\t ISO preprocessor will issue errors later.  */\n+      if (lex_state == ls_fun_macro)\n+\t{\n+\t  /* Missing '('.  */\n+\t  lex_state = ls_none;\n+\t  pfile->state.parsing_args = 0;\n+\t}\n+      else if (lex_state == ls_hash\n+\t       || lex_state == ls_predicate\n+\t       || lex_state == ls_defined)\n+\tlex_state = ls_none;\n+\n+      /* ls_answer and ls_defined_close keep going until ')'.  */\n     }\n \n  done:\n@@ -654,6 +721,12 @@ scan_out_logical_line (pfile, macro)\n   pfile->out.cur = out - 1;\n   if (fmacro.buff)\n     _cpp_release_buff (pfile, fmacro.buff);\n+\n+  if (pfile->state.parsing_args == 2)\n+    cpp_error (pfile, DL_ERROR,\n+\t       \"unterminated argument list invoking macro \\\"%s\\\"\",\n+\t       NODE_NAME (fmacro.node));\n+  pfile->state.parsing_args = 0;\n }\n \n /* Push a context holding the replacement text of the macro NODE on"}]}