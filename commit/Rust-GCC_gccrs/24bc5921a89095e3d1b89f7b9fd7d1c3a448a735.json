{"sha": "24bc5921a89095e3d1b89f7b9fd7d1c3a448a735", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRiYzU5MjFhODkwOTVlM2QxYjg5ZjdiOWZkN2QxYzNhNDQ4YTczNQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-08-05T13:50:49Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-08-05T13:50:49Z"}, "message": "gcov tool: Implement Hawick's algorithm for cycle detection,\n\n\t    Joshua Cranmer  <Pidgeot18@gmail.com>\n\n\t* gcov.c (line_t::has_block): New function.\n\t(enum loop_type): New enum.\n\t(handle_cycle): New function.\n\t(unblock): Likewise.\n\t(circuit): Likewise.\n\t(get_cycles_count): Likewise.\n\t(accumulate_line_counts): Use new loop detection algorithm.\n\nFrom-SVN: r239169", "tree": {"sha": "ae7ebf2ef6e5bb8aada9e6b026f7634c6b059876", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae7ebf2ef6e5bb8aada9e6b026f7634c6b059876"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4457451f3d3475158e48f7b751eb2ddf7875c894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4457451f3d3475158e48f7b751eb2ddf7875c894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4457451f3d3475158e48f7b751eb2ddf7875c894"}], "stats": {"total": 301, "additions": 200, "deletions": 101}, "files": [{"sha": "b8d3e3040d0f80412e35b93203904addabaad3aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24bc5921a89095e3d1b89f7b9fd7d1c3a448a735", "patch": "@@ -1,3 +1,15 @@\n+2016-08-05  Martin Liska  <mliska@suse.cz>\n+\n+\t    Joshua Cranmer  <Pidgeot18@gmail.com>\n+\n+\t* gcov.c (line_t::has_block): New function.\n+\t(enum loop_type): New enum.\n+\t(handle_cycle): New function.\n+\t(unblock): Likewise.\n+\t(circuit): Likewise.\n+\t(get_cycles_count): Likewise.\n+\t(accumulate_line_counts): Use new loop detection algorithm.\n+\n 2016-08-05  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (output_intermediate_file): Rename"}, {"sha": "496bff65257f0b6e8e48aff8199322d126bb9982", "filename": "gcc/gcov.c", "status": "modified", "additions": 188, "deletions": 101, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24bc5921a89095e3d1b89f7b9fd7d1c3a448a735/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=24bc5921a89095e3d1b89f7b9fd7d1c3a448a735", "patch": "@@ -41,6 +41,11 @@ along with Gcov; see the file COPYING3.  If not see\n \n #include <getopt.h>\n \n+#include <vector>\n+#include <algorithm>\n+\n+using namespace std;\n+\n #define IN_GCOV 1\n #include \"gcov-io.h\"\n #include \"gcov-io.c\"\n@@ -222,6 +227,9 @@ typedef struct coverage_info\n \n typedef struct line_info\n {\n+  /* Return true when NEEDLE is one of basic blocks the line belongs to.  */\n+  bool has_block (block_t *needle);\n+\n   gcov_type count;\t   /* execution count */\n   union\n   {\n@@ -235,6 +243,16 @@ typedef struct line_info\n   unsigned unexceptional : 1;\n } line_t;\n \n+bool\n+line_t::has_block (block_t *needle)\n+{\n+  for (block_t *n = u.blocks; n; n = n->chain)\n+    if (n == needle)\n+      return true;\n+\n+  return false;\n+}\n+\n /* Describes a file mentioned in the block graph.  Contains an array\n    of line info.  */\n \n@@ -407,6 +425,166 @@ static void release_structures (void);\n static void release_function (function_t *);\n extern int main (int, char **);\n \n+/* Cycle detection!\n+   There are a bajillion algorithms that do this.  Boost's function is named\n+   hawick_cycles, so I used the algorithm by K. A. Hawick and H. A. James in\n+   \"Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs\"\n+   (url at <http://complexity.massey.ac.nz/cstn/013/cstn-013.pdf>).\n+\n+   The basic algorithm is simple: effectively, we're finding all simple paths\n+   in a subgraph (that shrinks every iteration).  Duplicates are filtered by\n+   \"blocking\" a path when a node is added to the path (this also prevents non-\n+   simple paths)--the node is unblocked only when it participates in a cycle.\n+   */\n+\n+typedef vector<arc_t *> arc_vector_t;\n+typedef vector<const block_t *> block_vector_t;\n+\n+/* Enum with types of loop in CFG.  */\n+\n+enum loop_type\n+{\n+  NO_LOOP = 0,\n+  LOOP = 1,\n+  NEGATIVE_LOOP = 3\n+};\n+\n+/* Loop_type operator that merges two values: A and B.  */\n+\n+inline loop_type& operator |= (loop_type& a, loop_type b)\n+{\n+    return a = static_cast<loop_type> (a | b);\n+}\n+\n+/* Handle cycle identified by EDGES, where the function finds minimum cs_count\n+   and subtract the value from all counts.  The subtracted value is added\n+   to COUNT.  Returns type of loop.  */\n+\n+static loop_type\n+handle_cycle (const arc_vector_t &edges, int64_t &count)\n+{\n+  /* Find the minimum edge of the cycle, and reduce all nodes in the cycle by\n+     that amount.  */\n+  int64_t cycle_count = INT64_MAX;\n+  for (unsigned i = 0; i < edges.size (); i++)\n+    {\n+      int64_t ecount = edges[i]->cs_count;\n+      if (cycle_count > ecount)\n+\tcycle_count = ecount;\n+    }\n+  count += cycle_count;\n+  for (unsigned i = 0; i < edges.size (); i++)\n+    edges[i]->cs_count -= cycle_count;\n+\n+  return cycle_count < 0 ? NEGATIVE_LOOP : LOOP;\n+}\n+\n+/* Unblock a block U from BLOCKED.  Apart from that, iterate all blocks\n+   blocked by U in BLOCK_LISTS.  */\n+\n+static void\n+unblock (const block_t *u, block_vector_t &blocked,\n+\t vector<block_vector_t > &block_lists)\n+{\n+  block_vector_t::iterator it = find (blocked.begin (), blocked.end (), u);\n+  if (it == blocked.end ())\n+    return;\n+\n+  unsigned index = it - blocked.begin ();\n+  blocked.erase (it);\n+\n+  for (block_vector_t::iterator it2 = block_lists[index].begin ();\n+       it2 != block_lists[index].end (); it2++)\n+    unblock (*it2, blocked, block_lists);\n+  for (unsigned j = 0; j < block_lists[index].size (); j++)\n+    unblock (u, blocked, block_lists);\n+\n+  block_lists.erase (block_lists.begin () + index);\n+}\n+\n+/* Find circuit going to block V, PATH is provisional seen cycle.\n+   BLOCKED is vector of blocked vertices, BLOCK_LISTS contains vertices\n+   blocked by a block.  COUNT is accumulated count of the current LINE.\n+   Returns what type of loop it contains.  */\n+\n+static loop_type\n+circuit (block_t *v, arc_vector_t &path, block_t *start,\n+\t block_vector_t &blocked, vector<block_vector_t> &block_lists,\n+\t line_t &linfo, int64_t &count)\n+{\n+  loop_type result = NO_LOOP;\n+\n+  /* Add v to the block list.  */\n+  gcc_assert (find (blocked.begin (), blocked.end (), v) == blocked.end ());\n+  blocked.push_back (v);\n+  block_lists.push_back (block_vector_t ());\n+\n+  for (arc_t *arc = v->succ; arc; arc = arc->succ_next)\n+    {\n+      block_t *w = arc->dst;\n+      if (w < start || !linfo.has_block (w))\n+\tcontinue;\n+\n+      path.push_back (arc);\n+      if (w == start)\n+\t/* Cycle has been found.  */\n+\tresult |= handle_cycle (path, count);\n+      else if (find (blocked.begin (), blocked.end (), w) == blocked.end ())\n+\tresult |= circuit (w, path, start, blocked, block_lists, linfo, count);\n+\n+      path.pop_back ();\n+    }\n+\n+  if (result != NO_LOOP)\n+    unblock (v, blocked, block_lists);\n+  else\n+    for (arc_t *arc = v->succ; arc; arc = arc->succ_next)\n+      {\n+\tblock_t *w = arc->dst;\n+\tif (w < start || !linfo.has_block (w))\n+\t  continue;\n+\n+\tsize_t index\n+\t  = find (blocked.begin (), blocked.end (), w) - blocked.begin ();\n+\tgcc_assert (index < blocked.size ());\n+\tblock_vector_t &list = block_lists[index];\n+\tif (find (list.begin (), list.end (), v) == list.end ())\n+\t  list.push_back (v);\n+      }\n+\n+  return result;\n+}\n+\n+/* Find cycles for a LINFO.  If HANDLE_NEGATIVE_CYCLES is set and the line\n+   contains a negative loop, then perform the same function once again.  */\n+\n+static gcov_type\n+get_cycles_count (line_t &linfo, bool handle_negative_cycles = true)\n+{\n+  /* Note that this algorithm works even if blocks aren't in sorted order.\n+     Each iteration of the circuit detection is completely independent\n+     (except for reducing counts, but that shouldn't matter anyways).\n+     Therefore, operating on a permuted order (i.e., non-sorted) only\n+     has the effect of permuting the output cycles.  */\n+\n+  loop_type result = NO_LOOP;\n+  gcov_type count = 0;\n+  for (block_t *block = linfo.u.blocks; block; block = block->chain)\n+    {\n+      arc_vector_t path;\n+      block_vector_t blocked;\n+      vector<block_vector_t > block_lists;\n+      result |= circuit (block, path, block, blocked, block_lists, linfo,\n+\t\t\t count);\n+    }\n+\n+  /* If we have a negative cycle, repeat the find_cycles routine.  */\n+  if (result == NEGATIVE_LOOP && handle_negative_cycles)\n+    count += get_cycles_count (linfo, false);\n+\n+  return count;\n+}\n+\n int\n main (int argc, char **argv)\n {\n@@ -2201,113 +2379,22 @@ accumulate_line_counts (source_t *src)\n \t      arc_t *arc;\n \n \t      for (arc = block->pred; arc; arc = arc->pred_next)\n-\t\t{\n-\t\t  if (arc->src->u.cycle.ident != ix)\n-\t\t    count += arc->count;\n-\t\t  if (flag_branches)\n-\t\t    add_branch_counts (&src->coverage, arc);\n-\t\t}\n-\n-\t      /* Initialize the cs_count.  */\n-\t      for (arc = block->succ; arc; arc = arc->succ_next)\n-\t\tarc->cs_count = arc->count;\n+\t\tif (flag_branches)\n+\t\t  add_branch_counts (&src->coverage, arc);\n \t    }\n \n-\t  /* Find the loops. This uses the algorithm described in\n-\t     Tiernan 'An Efficient Search Algorithm to Find the\n-\t     Elementary Circuits of a Graph', CACM Dec 1970. We hold\n-\t     the P array by having each block point to the arc that\n-\t     connects to the previous block. The H array is implicitly\n-\t     held because of the arc ordering, and the block's\n-\t     previous arc pointer.\n-\n-\t     Although the algorithm is O(N^3) for highly connected\n-\t     graphs, at worst we'll have O(N^2), as most blocks have\n-\t     only one or two exits. Most graphs will be small.\n-\n-\t     For each loop we find, locate the arc with the smallest\n-\t     transition count, and add that to the cumulative\n-\t     count.  Decrease flow over the cycle and remove the arc\n-\t     from consideration.  */\n+\t  /* Cycle detection.  */\n \t  for (block = line->u.blocks; block; block = block->chain)\n \t    {\n-\t      block_t *head = block;\n-\t      arc_t *arc;\n-\n-\t    next_vertex:;\n-\t      arc = head->succ;\n-\t    current_vertex:;\n-\t      while (arc)\n-\t\t{\n-\t\t  block_t *dst = arc->dst;\n-\t\t  if (/* Already used that arc.  */\n-\t\t      arc->cycle\n-\t\t      /* Not to same graph, or before first vertex.  */\n-\t\t      || dst->u.cycle.ident != ix\n-\t\t      /* Already in path.  */\n-\t\t      || dst->u.cycle.arc)\n-\t\t    {\n-\t\t      arc = arc->succ_next;\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  if (dst == block)\n-\t\t    {\n-\t\t      /* Found a closing arc.  */\n-\t\t      gcov_type cycle_count = arc->cs_count;\n-\t\t      arc_t *cycle_arc = arc;\n-\t\t      arc_t *probe_arc;\n-\n-\t\t      /* Locate the smallest arc count of the loop.  */\n-\t\t      for (dst = head; (probe_arc = dst->u.cycle.arc);\n-\t\t\t   dst = probe_arc->src)\n-\t\t\tif (cycle_count > probe_arc->cs_count)\n-\t\t\t  {\n-\t\t\t    cycle_count = probe_arc->cs_count;\n-\t\t\t    cycle_arc = probe_arc;\n-\t\t\t  }\n-\n-\t\t      count += cycle_count;\n-\t\t      cycle_arc->cycle = 1;\n-\n-\t\t      /* Remove the flow from the cycle.  */\n-\t\t      arc->cs_count -= cycle_count;\n-\t\t      for (dst = head; (probe_arc = dst->u.cycle.arc);\n-\t\t\t   dst = probe_arc->src)\n-\t\t\tprobe_arc->cs_count -= cycle_count;\n-\n-\t\t      /* Unwind to the cyclic arc.  */\n-\t\t      while (head != cycle_arc->src)\n-\t\t\t{\n-\t\t\t  arc = head->u.cycle.arc;\n-\t\t\t  head->u.cycle.arc = NULL;\n-\t\t\t  head = arc->src;\n-\t\t\t}\n-\t\t      /* Move on.  */\n-\t\t      arc = arc->succ_next;\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  /* Add new block to chain.  */\n-\t\t  dst->u.cycle.arc = arc;\n-\t\t  head = dst;\n-\t\t  goto next_vertex;\n-\t\t}\n-\t      /* We could not add another vertex to the path. Remove\n-\t\t the last vertex from the list.  */\n-\t      arc = head->u.cycle.arc;\n-\t      if (arc)\n-\t\t{\n-\t\t  /* It was not the first vertex. Move onto next arc.  */\n-\t\t  head->u.cycle.arc = NULL;\n-\t\t  head = arc->src;\n-\t\t  arc = arc->succ_next;\n-\t\t  goto current_vertex;\n-\t\t}\n-\t      /* Mark this block as unusable.  */\n-\t      block->u.cycle.ident = ~0U;\n+\t      for (arc_t *arc = block->pred; arc; arc = arc->pred_next)\n+\t\tif (!line->has_block (arc->src))\n+\t\t  count += arc->count;\n+\t      for (arc_t *arc = block->succ; arc; arc = arc->succ_next)\n+\t\tarc->cs_count = arc->count;\n \t    }\n \n+\t  /* Now, add the count of loops entirely on this line.  */\n+\t  count += get_cycles_count (*line);\n \t  line->count = count;\n \t}\n "}]}