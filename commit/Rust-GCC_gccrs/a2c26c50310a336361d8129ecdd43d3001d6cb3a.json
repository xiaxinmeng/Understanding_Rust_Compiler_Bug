{"sha": "a2c26c50310a336361d8129ecdd43d3001d6cb3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJjMjZjNTAzMTBhMzM2MzYxZDgxMjllY2RkNDNkMzAwMWQ2Y2IzYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2019-11-11T09:19:29Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2019-11-11T09:19:29Z"}, "message": "Fortran] Support absent optional args with use_device_{ptr,addr}\n\n2019-11-11  Tobias Burnus  <tobias@codesourcery.com>\n            Kwok Cheung Yeung  <kcy@codesourcery.com>\n\n        gcc/\n        * langhooks-def.h (LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT):\n        Renamed from LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT; update define.\n        (LANG_HOOKS_DECLS): Rename also here.\n        * langhooks.h (lang_hooks_for_decls): Rename\n        omp_is_optional_argument to omp_check_optional_argument; take\n        additional bool argument.\n        * omp-general.h (omp_check_optional_argument): Likewise.\n        * omp-general.h (omp_check_optional_argument): Likewise.\n        * omp-low.c (lower_omp_target): Update calls; handle absent\n        Fortran optional arguments with USE_DEVICE_ADDR/USE_DEVICE_PTR.\n\n        gcc/fortran/\n        * trans-expr.c (gfc_conv_expr_present): Check for DECL_ARTIFICIAL\n        for the VALUE hidden argument avoiding -fallow-underscore issues.\n        * trans-decl.c (create_function_arglist): Also set\n        GFC_DECL_OPTIONAL_ARGUMENT for per-value arguments.\n        * f95-lang.c (LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT):\n        Renamed from LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT; point\n        to gfc_omp_check_optional_argument.\n        * trans.h (gfc_omp_check_optional_argument): Subsitutes\n        gfc_omp_is_optional_argument declaration.\n        * trans-openmp.c (gfc_omp_is_optional_argument): Make static.\n        (gfc_omp_check_optional_argument): New function.\n\n        libgomp/\n        * testsuite/libgomp.fortran/use_device_ptr-optional-1.f90: Extend.\n        * testsuite/libgomp.fortran/use_device_ptr-optional-2.f90: New.\n\n\nCo-Authored-By: Kwok Cheung Yeung <kcy@codesourcery.com>\n\nFrom-SVN: r278046", "tree": {"sha": "652752017ebc9459258438136af1d92a63535d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/652752017ebc9459258438136af1d92a63535d0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2c26c50310a336361d8129ecdd43d3001d6cb3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c26c50310a336361d8129ecdd43d3001d6cb3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c26c50310a336361d8129ecdd43d3001d6cb3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c26c50310a336361d8129ecdd43d3001d6cb3a/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bfa1837b010feaa81a56cbc46ce7c17dc909c3bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa1837b010feaa81a56cbc46ce7c17dc909c3bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa1837b010feaa81a56cbc46ce7c17dc909c3bb"}], "stats": {"total": 318, "additions": 270, "deletions": 48}, "files": [{"sha": "2c2c456e21706068be008344be62b91ee2d13c35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -1,3 +1,17 @@\n+2019-11-11  Tobias Burnus  <tobias@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT):\n+\tRenamed from LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT; update define.\n+\t(LANG_HOOKS_DECLS): Rename also here.\n+\t* langhooks.h (lang_hooks_for_decls): Rename\n+\tomp_is_optional_argument to omp_check_optional_argument; take\n+\tadditional bool argument.\n+\t* omp-general.h (omp_check_optional_argument): Likewise.\n+\t* omp-general.h (omp_check_optional_argument): Likewise.\n+\t* omp-low.c (lower_omp_target): Update calls; handle absent\n+\tFortran optional arguments with USE_DEVICE_ADDR/USE_DEVICE_PTR.\n+\n 2019-11-11  H.J. Lu  <hjl.tools@gmail.com>\n \n \tPR target/87833"}, {"sha": "0a8efedb6e63ba513c89272dd561c4549792f3a4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -1,3 +1,18 @@\n+2019-11-11  Tobias Burnus  <tobias@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* trans-expr.c (gfc_conv_expr_present): Check for DECL_ARTIFICIAL\n+\tfor the VALUE hidden argument avoiding -fallow-underscore issues.\n+\t* trans-decl.c (create_function_arglist): Also set\n+\tGFC_DECL_OPTIONAL_ARGUMENT for per-value arguments.\n+\t* f95-lang.c (LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT):\n+\tRenamed from LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT; point\n+\tto gfc_omp_check_optional_argument.\n+\t* trans.h (gfc_omp_check_optional_argument): Subsitutes\n+\tgfc_omp_is_optional_argument declaration.\n+\t* trans-openmp.c (gfc_omp_is_optional_argument): Make static.\n+\t(gfc_omp_check_optional_argument): New function.\n+\n 2019-11-10  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/91413"}, {"sha": "c7b592dbfe2e0c54e6cc3a4f64212cd50f222743", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -115,7 +115,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_INIT_TS\n #undef LANG_HOOKS_OMP_ARRAY_DATA\n #undef LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\n-#undef LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT\n+#undef LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT\n #undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n #undef LANG_HOOKS_OMP_REPORT_DECL\n@@ -150,7 +150,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_INIT_TS\t\tgfc_init_ts\n #define LANG_HOOKS_OMP_ARRAY_DATA\t\tgfc_omp_array_data\n #define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR\tgfc_omp_is_allocatable_or_ptr\n-#define LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT\tgfc_omp_is_optional_argument\n+#define LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT\tgfc_omp_check_optional_argument\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING\tgfc_omp_predetermined_sharing\n #define LANG_HOOKS_OMP_REPORT_DECL\t\tgfc_omp_report_decl"}, {"sha": "e74244774272ed10bc1015fadfaba07b0397e436", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -2692,9 +2692,8 @@ create_function_arglist (gfc_symbol * sym)\n \t  && (!f->sym->attr.proc_pointer\n \t      && f->sym->attr.flavor != FL_PROCEDURE))\n \tDECL_BY_REFERENCE (parm) = 1;\n-      if (f->sym->attr.optional && !f->sym->attr.value)\n+      if (f->sym->attr.optional)\n \t{\n-\t  /* With value, the argument is passed as is.  */\n \t  gfc_allocate_lang_decl (parm);\n \t  GFC_DECL_OPTIONAL_ARGUMENT (parm) = 1;\n \t}"}, {"sha": "63559384c1e2793524570429259382995d19a737", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -1725,7 +1725,8 @@ gfc_conv_expr_present (gfc_symbol * sym)\n       /* Walk function argument list to find hidden arg.  */\n       cond = DECL_ARGUMENTS (DECL_CONTEXT (decl));\n       for ( ; cond != NULL_TREE; cond = TREE_CHAIN (cond))\n-\tif (DECL_NAME (cond) == tree_name)\n+\tif (DECL_NAME (cond) == tree_name\n+\t    && DECL_ARTIFICIAL (cond))\n \t  break;\n \n       gcc_assert (cond);"}, {"sha": "dee7cc26a7dc3e711dcb8bbdbb3a6fbc0065374f", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 58, "deletions": 5, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -58,19 +58,72 @@ gfc_omp_is_allocatable_or_ptr (const_tree decl)\n \t      || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)));\n }\n \n-/* True if OpenMP should treat this DECL as an optional argument;  note: for\n-   arguments with VALUE attribute, the DECL is identical to nonoptional\n-   arguments; hence, we return false here.  To check whether the variable is\n-   present, use the DECL which is passed as hidden argument.  */\n+/* True if the argument is an optional argument; except that false is also\n+   returned for arguments with the value attribute (nonpointers) and for\n+   assumed-shape variables (decl is a local variable containing arg->data).  */\n \n-bool\n+static bool\n gfc_omp_is_optional_argument (const_tree decl)\n {\n   return (TREE_CODE (decl) == PARM_DECL\n \t  && DECL_LANG_SPECIFIC (decl)\n+\t  && TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n \t  && GFC_DECL_OPTIONAL_ARGUMENT (decl));\n }\n \n+/* Check whether this DECL belongs to a Fortran optional argument.\n+   With 'for_present_check' set to false, decls which are optional parameters\n+   themselve are returned as tree - or a NULL_TREE otherwise. Those decls are\n+   always pointers.  With 'for_present_check' set to true, the decl for checking\n+   whether an argument is present is returned; for arguments with value\n+   attribute this is the hidden argument and of BOOLEAN_TYPE.  If the decl is\n+   unrelated to optional arguments, NULL_TREE is returned.  */\n+\n+tree\n+gfc_omp_check_optional_argument (tree decl, bool for_present_check)\n+{\n+  if (!for_present_check)\n+    return gfc_omp_is_optional_argument (decl) ? decl : NULL_TREE;\n+\n+  if (!DECL_LANG_SPECIFIC (decl))\n+    return NULL_TREE;\n+\n+  /* For assumed-shape arrays, a local decl with arg->data is used.  */\n+  if (TREE_CODE (decl) != PARM_DECL\n+      && (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n+\t  || GFC_ARRAY_TYPE_P (TREE_TYPE (decl))))\n+    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+\n+  if (TREE_CODE (decl) != PARM_DECL\n+      || !DECL_LANG_SPECIFIC (decl)\n+      || !GFC_DECL_OPTIONAL_ARGUMENT (decl))\n+    return NULL_TREE;\n+\n+  /* For VALUE, the scalar variable is passed as is but a hidden argument\n+     denotes the value.  Cf. trans-expr.c.  */\n+  if (TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE)\n+    {\n+      char name[GFC_MAX_SYMBOL_LEN + 2];\n+      tree tree_name;\n+\n+      name[0] = '_';\n+      strcpy (&name[1], IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      tree_name = get_identifier (name);\n+\n+      /* Walk function argument list to find the hidden arg.  */\n+      decl = DECL_ARGUMENTS (DECL_CONTEXT (decl));\n+      for ( ; decl != NULL_TREE; decl = TREE_CHAIN (decl))\n+\tif (DECL_NAME (decl) == tree_name\n+\t    && DECL_ARTIFICIAL (decl))\n+\t  break;\n+\n+      gcc_assert (decl);\n+      return decl;\n+    }\n+\n+  return decl;\n+}\n+\n \n /* Returns tree with NULL if it is not an array descriptor and with the tree to\n    access the 'data' component otherwise.  With type_only = true, it returns the"}, {"sha": "359c7a2561a0323ecd79306cbe6804eff7ba9442", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -787,7 +787,7 @@ bool gfc_get_array_descr_info (const_tree, struct array_descr_info *);\n \n /* In trans-openmp.c */\n bool gfc_omp_is_allocatable_or_ptr (const_tree);\n-bool gfc_omp_is_optional_argument (const_tree);\n+tree gfc_omp_check_optional_argument (tree, bool);\n tree gfc_omp_array_data (tree, bool);\n bool gfc_omp_privatize_by_reference (const_tree);\n enum omp_clause_default_kind gfc_omp_predetermined_sharing (tree);"}, {"sha": "4002f281ddd382fcd4a504e0204674e6c16592dc", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -241,7 +241,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n #define LANG_HOOKS_DECL_OK_FOR_SIBCALL\tlhd_decl_ok_for_sibcall\n #define LANG_HOOKS_OMP_ARRAY_DATA\thook_tree_tree_bool_null\n #define LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR hook_bool_const_tree_false\n-#define LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT hook_bool_const_tree_false\n+#define LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT hook_tree_tree_bool_null\n #define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE hook_bool_const_tree_false\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING lhd_omp_predetermined_sharing\n #define LANG_HOOKS_OMP_REPORT_DECL lhd_pass_through_t\n@@ -269,7 +269,7 @@ extern tree lhd_unit_size_without_reusable_padding (tree);\n   LANG_HOOKS_DECL_OK_FOR_SIBCALL, \\\n   LANG_HOOKS_OMP_ARRAY_DATA, \\\n   LANG_HOOKS_OMP_IS_ALLOCATABLE_OR_PTR, \\\n-  LANG_HOOKS_OMP_IS_OPTIONAL_ARGUMENT, \\\n+  LANG_HOOKS_OMP_CHECK_OPTIONAL_ARGUMENT, \\\n   LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE, \\\n   LANG_HOOKS_OMP_PREDETERMINED_SHARING, \\\n   LANG_HOOKS_OMP_REPORT_DECL, \\"}, {"sha": "0e451c15ffcf0b7a21676873e6afb7db10c4eb3a", "filename": "gcc/langhooks.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -235,11 +235,14 @@ struct lang_hooks_for_decls\n      allocatable or pointer attribute.  */\n   bool (*omp_is_allocatable_or_ptr) (const_tree);\n \n-  /* True if OpenMP should treat DECL as a Fortran optional argument;  note: for\n-     arguments with VALUE attribute, the DECL is identical to nonoptional\n-     arguments; hence, we return false here.  To check whether the variable is\n-     present, use the DECL which is passed as hidden argument.  */\n-  bool (*omp_is_optional_argument) (const_tree);\n+  /* Check whether this DECL belongs to a Fortran optional argument.\n+     With 'for_present_check' set to false, decls which are optional parameters\n+     themselve are returned as tree - or a NULL_TREE otherwise. Those decls are\n+     always pointers.  With 'for_present_check' set to true, the decl for\n+     checking whether an argument is present is returned; for arguments with\n+     value attribute this is the hidden argument and of BOOLEAN_TYPE.  If the\n+     decl is unrelated to optional arguments, NULL_TREE is returned.  */\n+  tree (*omp_check_optional_argument) (tree, bool);\n \n   /* True if OpenMP should privatize what this DECL points to rather\n      than the DECL itself.  */"}, {"sha": "fd074a36b2335e1ee16ce190f5cfcbbc64be65a9", "filename": "gcc/omp-general.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -63,12 +63,18 @@ omp_is_allocatable_or_ptr (tree decl)\n   return lang_hooks.decls.omp_is_allocatable_or_ptr (decl);\n }\n \n-/* Return true if DECL is a Fortran optional argument.  */\n+/* Check whether this DECL belongs to a Fortran optional argument.\n+   With 'for_present_check' set to false, decls which are optional parameters\n+   themselve are returned as tree - or a NULL_TREE otherwise. Those decls are\n+   always pointers.  With 'for_present_check' set to true, the decl for checking\n+   whether an argument is present is returned; for arguments with value\n+   attribute this is the hidden argument and of BOOLEAN_TYPE.  If the decl is\n+   unrelated to optional arguments, NULL_TREE is returned.  */\n \n-bool\n-omp_is_optional_argument (tree decl)\n+tree\n+omp_check_optional_argument (tree decl, bool for_present_check)\n {\n-  return lang_hooks.decls.omp_is_optional_argument (decl);\n+  return lang_hooks.decls.omp_check_optional_argument (decl, for_present_check);\n }\n \n /* Return true if DECL is a reference type.  */"}, {"sha": "500c93941a2015f6c44d65cdec7552dea8ab011f", "filename": "gcc/omp-general.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -74,7 +74,7 @@ struct omp_for_data\n \n extern tree omp_find_clause (tree clauses, enum omp_clause_code kind);\n extern bool omp_is_allocatable_or_ptr (tree decl);\n-extern bool omp_is_optional_argument (tree decl);\n+extern tree omp_check_optional_argument (tree decl, bool for_present_check);\n extern bool omp_is_reference (tree decl);\n extern void omp_adjust_for_condition (location_t loc, enum tree_code *cond_code,\n \t\t\t\t      tree *n2, tree v, tree step);"}, {"sha": "e232d7aa62d3eba048877bd5d96fda8654be9b06", "filename": "gcc/omp-low.c", "status": "modified", "additions": 95, "deletions": 25, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -11796,12 +11796,12 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t    if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FROM\n \t\t\t || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TO)\n \t\t\t&& (omp_is_allocatable_or_ptr (var)\n-\t\t\t    && omp_is_optional_argument (var)))\n+\t\t\t    && omp_check_optional_argument (var, false)))\n \t\t      var = build_fold_indirect_ref (var);\n \t\t    else if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FROM\n \t\t\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TO)\n \t\t\t     || (!omp_is_allocatable_or_ptr (var)\n-\t\t\t\t && !omp_is_optional_argument (var)))\n+\t\t\t\t && !omp_check_optional_argument (var, false)))\n \t\t      var = build_fold_addr_expr (var);\n \t\t    gimplify_assign (x, var, &ilist);\n \t\t  }\n@@ -11975,6 +11975,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case OMP_CLAUSE_USE_DEVICE_PTR:\n \t  case OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n+\t    bool do_optional_check;\n+\t    do_optional_check = false;\n \t    ovar = OMP_CLAUSE_DECL (c);\n \t    var = lookup_decl_in_outer_ctx (ovar, ctx);\n \n@@ -11996,7 +11998,10 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      }\n \t    type = TREE_TYPE (ovar);\n \t    if (lang_hooks.decls.omp_array_data (ovar, true))\n-\t      var = lang_hooks.decls.omp_array_data (ovar, false);\n+\t      {\n+\t\tvar = lang_hooks.decls.omp_array_data (ovar, false);\n+\t\tdo_optional_check = true;\n+\t      }\n \t    else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n \t\t      && !omp_is_reference (ovar)\n \t\t      && !omp_is_allocatable_or_ptr (ovar))\n@@ -12005,7 +12010,7 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    else\n \t      {\n \t\tif (omp_is_reference (ovar)\n-\t\t    || omp_is_optional_argument (ovar)\n+\t\t    || omp_check_optional_argument (ovar, false)\n \t\t    || omp_is_allocatable_or_ptr (ovar))\n \t\t  {\n \t\t    type = TREE_TYPE (type);\n@@ -12014,11 +12019,39 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t    && !omp_is_allocatable_or_ptr (ovar))\n \t\t\t   || (omp_is_reference (ovar)\n \t\t\t       && omp_is_allocatable_or_ptr (ovar))))\n-\t\t      var = build_simple_mem_ref (var);\n+\t\t      {\n+\t\t\tvar = build_simple_mem_ref (var);\n+\t\t\tdo_optional_check = true;\n+\t\t      }\n \t\t    var = fold_convert (TREE_TYPE (x), var);\n \t\t  }\n \t      }\n-\t    gimplify_assign (x, var, &ilist);\n+\t    tree present;\n+\t    present = (do_optional_check\n+\t\t       ? omp_check_optional_argument (ovar, true) : NULL_TREE);\n+\t    if (present)\n+\t      {\n+\t\ttree null_label = create_artificial_label (UNKNOWN_LOCATION);\n+\t\ttree notnull_label = create_artificial_label (UNKNOWN_LOCATION);\n+\t\ttree opt_arg_label = create_artificial_label (UNKNOWN_LOCATION);\n+\t\ttree new_x = unshare_expr (x);\n+\t\tgimplify_expr (&present, &ilist, NULL, is_gimple_val,\n+\t\t\t       fb_rvalue);\n+\t\tgcond *cond = gimple_build_cond_from_tree (present,\n+\t\t\t\t\t\t\t   notnull_label,\n+\t\t\t\t\t\t\t   null_label);\n+\t\tgimple_seq_add_stmt (&ilist, cond);\n+\t\tgimple_seq_add_stmt (&ilist, gimple_build_label (null_label));\n+\t\tgimplify_assign (new_x, null_pointer_node, &ilist);\n+\t\tgimple_seq_add_stmt (&ilist, gimple_build_goto (opt_arg_label));\n+\t\tgimple_seq_add_stmt (&ilist,\n+\t\t\t\t     gimple_build_label (notnull_label));\n+\t\tgimplify_assign (x, var, &ilist);\n+\t\tgimple_seq_add_stmt (&ilist,\n+\t\t\t\t     gimple_build_label (opt_arg_label));\n+\t      }\n+\t    else\n+\t      gimplify_assign (x, var, &ilist);\n \t    s = size_int (0);\n \t    purpose = size_int (map_idx++);\n \t    CONSTRUCTOR_APPEND_ELT (vsize, purpose, s);\n@@ -12167,8 +12200,13 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case OMP_CLAUSE_USE_DEVICE_PTR:\n \t  case OMP_CLAUSE_USE_DEVICE_ADDR:\n \t  case OMP_CLAUSE_IS_DEVICE_PTR:\n-\t    var = OMP_CLAUSE_DECL (c);\n+\t    tree new_var;\n+\t    gimple_seq assign_body;\n \t    bool is_array_data;\n+\t    bool do_optional_check;\n+\t    assign_body = NULL;\n+\t    do_optional_check = false;\n+\t    var = OMP_CLAUSE_DECL (c);\n \t    is_array_data = lang_hooks.decls.omp_array_data (var, true) != NULL;\n \n \t    if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IS_DEVICE_PTR)\n@@ -12181,34 +12219,35 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t    if (is_array_data)\n \t      {\n \t\tbool is_ref = omp_is_reference (var);\n+\t\tdo_optional_check = true;\n \t\t/* First, we copy the descriptor data from the host; then\n \t\t   we update its data to point to the target address.  */\n-\t\ttree new_var = lookup_decl (var, ctx);\n+\t\tnew_var = lookup_decl (var, ctx);\n \t\tnew_var = DECL_VALUE_EXPR (new_var);\n \t\ttree v = new_var;\n \n \t\tif (is_ref)\n \t\t  {\n \t\t    var = build_fold_indirect_ref (var);\n-\t\t    gimplify_expr (&var, &new_body, NULL, is_gimple_val,\n+\t\t    gimplify_expr (&var, &assign_body, NULL, is_gimple_val,\n \t\t\t\t   fb_rvalue);\n \t\t    v = create_tmp_var_raw (TREE_TYPE (var), get_name (var));\n \t\t    gimple_add_tmp_var (v);\n \t\t    TREE_ADDRESSABLE (v) = 1;\n-\t\t    gimple_seq_add_stmt (&new_body,\n+\t\t    gimple_seq_add_stmt (&assign_body,\n \t\t\t\t\t gimple_build_assign (v, var));\n \t\t    tree rhs = build_fold_addr_expr (v);\n-\t\t    gimple_seq_add_stmt (&new_body,\n+\t\t    gimple_seq_add_stmt (&assign_body,\n \t\t\t\t\t gimple_build_assign (new_var, rhs));\n \t\t  }\n \t\telse\n-\t\t  gimple_seq_add_stmt (&new_body,\n+\t\t  gimple_seq_add_stmt (&assign_body,\n \t\t\t\t       gimple_build_assign (new_var, var));\n \n \t\ttree v2 = lang_hooks.decls.omp_array_data (unshare_expr (v), false);\n \t\tgcc_assert (v2);\n-\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val, fb_rvalue);\n-\t\tgimple_seq_add_stmt (&new_body,\n+\t\tgimplify_expr (&x, &assign_body, NULL, is_gimple_val, fb_rvalue);\n+\t\tgimple_seq_add_stmt (&assign_body,\n \t\t\t\t     gimple_build_assign (v2, x));\n \t      }\n \t    else if (is_variable_sized (var))\n@@ -12217,29 +12256,29 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\tgcc_assert (TREE_CODE (pvar) == INDIRECT_REF);\n \t\tpvar = TREE_OPERAND (pvar, 0);\n \t\tgcc_assert (DECL_P (pvar));\n-\t\ttree new_var = lookup_decl (pvar, ctx);\n-\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val, fb_rvalue);\n-\t\tgimple_seq_add_stmt (&new_body,\n+\t\tnew_var = lookup_decl (pvar, ctx);\n+\t\tgimplify_expr (&x, &assign_body, NULL, is_gimple_val, fb_rvalue);\n+\t\tgimple_seq_add_stmt (&assign_body,\n \t\t\t\t     gimple_build_assign (new_var, x));\n \t      }\n \t    else if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_USE_DEVICE_ADDR\n \t\t      && !omp_is_reference (var)\n \t\t      && !omp_is_allocatable_or_ptr (var))\n \t\t     || TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n \t      {\n-\t\ttree new_var = lookup_decl (var, ctx);\n+\t\tnew_var = lookup_decl (var, ctx);\n \t\tnew_var = DECL_VALUE_EXPR (new_var);\n \t\tgcc_assert (TREE_CODE (new_var) == MEM_REF);\n \t\tnew_var = TREE_OPERAND (new_var, 0);\n \t\tgcc_assert (DECL_P (new_var));\n-\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val, fb_rvalue);\n-\t\tgimple_seq_add_stmt (&new_body,\n+\t\tgimplify_expr (&x, &assign_body, NULL, is_gimple_val, fb_rvalue);\n+\t\tgimple_seq_add_stmt (&assign_body,\n \t\t\t\t     gimple_build_assign (new_var, x));\n \t      }\n \t    else\n \t      {\n \t\ttree type = TREE_TYPE (var);\n-\t\ttree new_var = lookup_decl (var, ctx);\n+\t\tnew_var = lookup_decl (var, ctx);\n \t\tif (omp_is_reference (var))\n \t\t  {\n \t\t    type = TREE_TYPE (type);\n@@ -12252,19 +12291,50 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\tgimple_add_tmp_var (v);\n \t\t\tTREE_ADDRESSABLE (v) = 1;\n \t\t\tx = fold_convert (type, x);\n-\t\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val,\n+\t\t\tgimplify_expr (&x, &assign_body, NULL, is_gimple_val,\n \t\t\t\t       fb_rvalue);\n-\t\t\tgimple_seq_add_stmt (&new_body,\n+\t\t\tgimple_seq_add_stmt (&assign_body,\n \t\t\t\t\t     gimple_build_assign (v, x));\n \t\t\tx = build_fold_addr_expr (v);\n+\t\t\tdo_optional_check = true;\n \t\t      }\n \t\t  }\n \t\tnew_var = DECL_VALUE_EXPR (new_var);\n \t\tx = fold_convert (TREE_TYPE (new_var), x);\n-\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val, fb_rvalue);\n-\t\tgimple_seq_add_stmt (&new_body,\n+\t\tgimplify_expr (&x, &assign_body, NULL, is_gimple_val, fb_rvalue);\n+\t\tgimple_seq_add_stmt (&assign_body,\n \t\t\t\t     gimple_build_assign (new_var, x));\n \t      }\n+\t    tree present;\n+\t    present = (do_optional_check\n+\t\t       ? omp_check_optional_argument (OMP_CLAUSE_DECL (c), true)\n+\t\t       : NULL_TREE);\n+\t    if (present)\n+\t      {\n+\t\ttree null_label = create_artificial_label (UNKNOWN_LOCATION);\n+\t\ttree notnull_label = create_artificial_label (UNKNOWN_LOCATION);\n+\t\ttree opt_arg_label = create_artificial_label (UNKNOWN_LOCATION);\n+\t\tglabel *null_glabel = gimple_build_label (null_label);\n+\t\tglabel *notnull_glabel = gimple_build_label (notnull_label);\n+\t\tggoto *opt_arg_ggoto = gimple_build_goto (opt_arg_label);\n+\t\tgimplify_expr (&x, &new_body, NULL, is_gimple_val,\n+\t\t\t\t\t   fb_rvalue);\n+\t\tgimplify_expr (&present, &new_body, NULL, is_gimple_val,\n+\t\t\t       fb_rvalue);\n+\t\tgcond *cond = gimple_build_cond_from_tree (present,\n+\t\t\t\t\t\t\t   notnull_label,\n+\t\t\t\t\t\t\t   null_label);\n+\t\tgimple_seq_add_stmt (&new_body, cond);\n+\t\tgimple_seq_add_stmt (&new_body, null_glabel);\n+\t\tgimplify_assign (new_var, null_pointer_node, &new_body);\n+\t\tgimple_seq_add_stmt (&new_body, opt_arg_ggoto);\n+\t\tgimple_seq_add_stmt (&new_body, notnull_glabel);\n+\t\tgimple_seq_add_seq (&new_body, assign_body);\n+\t\tgimple_seq_add_stmt (&new_body,\n+\t\t\t\t     gimple_build_label (opt_arg_label));\n+\t      }\n+\t    else\n+\t      gimple_seq_add_seq (&new_body, assign_body);\n \t    break;\n \t  }\n       /* Handle GOMP_MAP_FIRSTPRIVATE_{POINTER,REFERENCE} in second pass,"}, {"sha": "2f60d606a88c52d8559bb2ba16c14f06e4ee85d7", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -1,3 +1,9 @@\n+2019-11-11  Tobias Burnus  <tobias@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* testsuite/libgomp.fortran/use_device_ptr-optional-1.f90: Extend.\n+\t* testsuite/libgomp.fortran/use_device_ptr-optional-2.f90: New.\n+\n 2019-11-11  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* testsuite/libgomp.fortran/target9.f90: Specify 'dg-do run'."}, {"sha": "e92ee8bf573c64f42940c4cbb7933e5e5f19c6d4", "filename": "libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-1.f90", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-1.f90?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -11,6 +11,9 @@ program test_it\n \n   ptr_null => null()\n   call bar(ptr_null)\n+\n+  call foo_absent()\n+  call bar_absent()\n contains\n   subroutine foo(ii)\n     integer, pointer, optional :: ii\n@@ -34,4 +37,23 @@ subroutine bar(jj)\n    if (associated(jj)) stop 8\n     !$omp end target data\n   end subroutine bar\n+\n+  subroutine foo_absent(ii)\n+    integer, pointer, optional :: ii\n+\n+    if (present(ii)) STOP 31\n+    !$omp target data map(to:ixx) use_device_ptr(ii)\n+    if (present(ii)) STOP 32\n+    !$omp end target data\n+  end subroutine foo_absent\n+\n+  ! For bar, it is assumed that a NULL ptr on the host maps to NULL on the device\n+  subroutine bar_absent(jj)\n+    integer, pointer, optional :: jj\n+\n+    if (present(jj)) STOP 41\n+    !$omp target data map(to:ixx) use_device_ptr(jj)\n+    if (present(jj)) STOP 42\n+    !$omp end target data\n+  end subroutine bar_absent\n end program test_it"}, {"sha": "41abf17eedeeb23b1900fd2ef673870213919dee", "filename": "libgomp/testsuite/libgomp.fortran/use_device_ptr-optional-2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c26c50310a336361d8129ecdd43d3001d6cb3a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c26c50310a336361d8129ecdd43d3001d6cb3a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fuse_device_ptr-optional-2.f90?ref=a2c26c50310a336361d8129ecdd43d3001d6cb3a", "patch": "@@ -0,0 +1,33 @@\n+! Check whether absent optional arguments are properly\n+! handled with use_device_{addr,ptr}.\n+program main\n+ implicit none (type, external)\n+ call foo()\n+contains\n+  subroutine foo(v, w, x, y, z)\n+    integer, target, optional, value :: v\n+    integer, target, optional :: w\n+    integer, target, optional :: x(:)\n+    integer, target, optional, allocatable :: y\n+    integer, target, optional, allocatable :: z(:)\n+    integer :: d\n+\n+    !$omp target data map(d) use_device_addr(v, w, x, y, z)\n+      if(present(v)) stop 1\n+      if(present(w)) stop 2\n+      if(present(x)) stop 3\n+      if(present(y)) stop 4\n+      if(present(z)) stop 5\n+    !$omp end target data\n+\n+! Using 'v' in use_device_ptr gives an ICE\n+! TODO: Find out what the OpenMP spec permits for use_device_ptr\n+\n+    !$omp target data map(d) use_device_ptr(w, x, y, z)\n+      if(present(w)) stop 6\n+      if(present(x)) stop 7\n+      if(present(y)) stop 8\n+      if(present(z)) stop 9\n+    !$omp end target data\n+  end subroutine foo\n+end program main"}]}