{"sha": "97bf048c04d93ba1e0265893fdb06f8991c149f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdiZjA0OGMwNGQ5M2JhMWUwMjY1ODkzZmRiMDZmODk5MWMxNDlmNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-09T09:37:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-09T09:37:55Z"}, "message": "Reject tail calls that read from an escaped RESULT_DECL (PR90313)\n\nIn this PR we have two return paths from a function \"map\".  The common\ncode sets <result> to the value returned by one path, while the other\npath does:\n\n   <retval> = map (&<retval>, ...);\n\nWe treated this call as tail recursion, losing the copy semantics\non the value returned by the recursive call.\n\nWe'd correctly reject the same thing for variables:\n\n   local = map (&local, ...);\n\nThe problem is that RESULT_DECLs didn't get the same treatment.\n\n2019-08-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR middle-end/90313\n\t* tree-tailcall.c (find_tail_calls): Reject calls that might\n\tread from an escaped RESULT_DECL.\n\ngcc/testsuite/\n\tPR middle-end/90313\n\t* g++.dg/torture/pr90313.cc: New test.\n\nFrom-SVN: r274234", "tree": {"sha": "a9411dc3fa2b7e713504601c237f7d2978768f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9411dc3fa2b7e713504601c237f7d2978768f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97bf048c04d93ba1e0265893fdb06f8991c149f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97bf048c04d93ba1e0265893fdb06f8991c149f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97bf048c04d93ba1e0265893fdb06f8991c149f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97bf048c04d93ba1e0265893fdb06f8991c149f7/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c787deb0124b667802d8519bc285894bb6d771d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c787deb0124b667802d8519bc285894bb6d771d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c787deb0124b667802d8519bc285894bb6d771d7"}], "stats": {"total": 73, "additions": 73, "deletions": 0}, "files": [{"sha": "beffd1b91c0f04c9dcbbfb9bbea11620bd10266b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97bf048c04d93ba1e0265893fdb06f8991c149f7", "patch": "@@ -1,3 +1,9 @@\n+2019-08-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR middle-end/90313\n+\t* tree-tailcall.c (find_tail_calls): Reject calls that might\n+\tread from an escaped RESULT_DECL.\n+\n 2019-08-09  Martin Liska  <mliska@suse.cz>\n \n \t* doc/invoke.texi: Document the option value."}, {"sha": "7ab92df5a56e25fb534a973f7e3ae4dec0dd0e57", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=97bf048c04d93ba1e0265893fdb06f8991c149f7", "patch": "@@ -1,3 +1,8 @@\n+2019-08-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR middle-end/90313\n+\t* g++.dg/torture/pr90313.cc: New test.\n+\n 2019-08-09  Martin Liska  <mliska@suse.cz>\n \n \t* g++.dg/lto/devirt-19_0.C: Add -flto=auto."}, {"sha": "d9f183a2939c95f05bc19933255fb3cae1c83c47", "filename": "gcc/testsuite/g++.dg/torture/pr90313.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr90313.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr90313.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr90313.cc?ref=97bf048c04d93ba1e0265893fdb06f8991c149f7", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do run }\n+\n+#include <stddef.h>\n+\n+namespace std {\n+  template<typename T, size_t N> struct array {\n+    T elems[N];\n+    const T &operator[](size_t i) const { return elems[i]; }\n+  };\n+}\n+\n+using Coordinates = std::array<double, 3>;\n+\n+Coordinates map(const Coordinates &c, size_t level)\n+{\n+  Coordinates result{ c[1], c[2], c[0] };\n+\n+  if (level != 0)\n+    result = map (result, level - 1);\n+\n+  return result;\n+}\n+\n+int main()\n+{\n+  Coordinates vecOfCoordinates = { 1.0, 2.0, 3.0 };\n+\n+  auto result = map(vecOfCoordinates, 1);\n+  if (result[0] != 3 || result[1] != 1 || result[2] != 2)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "a4b563efd73ae8e0f039ddb866b6fca53123406d", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97bf048c04d93ba1e0265893fdb06f8991c149f7/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=97bf048c04d93ba1e0265893fdb06f8991c149f7", "patch": "@@ -491,6 +491,35 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n       && !stmt_can_throw_external (cfun, stmt))\n     return;\n \n+  /* If the function returns a value, then at present, the tail call\n+     must return the same type of value.  There is conceptually a copy\n+     between the object returned by the tail call candidate and the\n+     object returned by CFUN itself.\n+\n+     This means that if we have:\n+\n+\t lhs = f (&<retval>);    // f reads from <retval>\n+\t\t\t\t // (lhs is usually also <retval>)\n+\n+     there is a copy between the temporary object returned by f and lhs,\n+     meaning that any use of <retval> in f occurs before the assignment\n+     to lhs begins.  Thus the <retval> that is live on entry to the call\n+     to f is really an independent local variable V that happens to be\n+     stored in the RESULT_DECL rather than a local VAR_DECL.\n+\n+     Turning this into a tail call would remove the copy and make the\n+     lifetimes of the return value and V overlap.  The same applies to\n+     tail recursion, since if f can read from <retval>, we have to assume\n+     that CFUN might already have written to <retval> before the call.\n+\n+     The problem doesn't apply when <retval> is passed by value, but that\n+     isn't a case we handle anyway.  */\n+  tree result_decl = DECL_RESULT (cfun->decl);\n+  if (result_decl\n+      && may_be_aliased (result_decl)\n+      && ref_maybe_used_by_stmt_p (call, result_decl))\n+    return;\n+\n   /* We found the call, check whether it is suitable.  */\n   tail_recursion = false;\n   func = gimple_call_fndecl (call);"}]}