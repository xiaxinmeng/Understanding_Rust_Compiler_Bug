{"sha": "27431d88dd1a06237f8a62a48f8bdd72154134d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc0MzFkODhkZDFhMDYyMzdmOGE2MmE0OGY4YmRkNzIxNTQxMzRkNg==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-10T17:20:47Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2010-04-10T17:20:47Z"}, "message": "i386.md (ashr<mode>3): Macroize expander from ashr{qi,hi,si,di,ti}3_1 using SDWIM mode iterator.\n\n\t* config/i386/i386.md (ashr<mode>3): Macroize expander from\n\tashr{qi,hi,si,di,ti}3_1 using SDWIM mode iterator.\n\t(*ashr<mode>3_doubleword): New insn_and_split_pattern.  Macroize\n\tpattern from *ashr{di,ti}3_1 and corresponding splitters using\n\tDWI mode iterator.\n\t(*ashr<mode>3_doubleword peephole2): Macroize peephole2 pattern\n\tfrom corresponding peephole2 patterns.\n\t(ashrdi3_cvt): Rename from ashrdi3_63_rex64.\n\t(ashrsi3_cvt): Rename from ashrsi3_31.\n\t(*ashrsi3_cvt_zext): Rename from *ashrsi3_31_zext.\n\t(x86_shift<mode>_adj_3): Macroize expander from x86_shift_adj_3\n\tand x86_64_shift_adj_3 using SWI48 mode iterator.\n\t(*ashr<mode>3_1): Merge with *ashr{qi,hi,si}3_1_one_bit and\n\t*ashrdi3_1_one_bit_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp\n\tand *ashrdi3_cmp_rex64 using SWI mode iterator.\n\t(*ashrqi3_1_slp): Merge with *ashrqi3_1_one_bit_slp.\n\t(*ashr<mode>3_cmp): Merge with *ashr{qi,hi,si}3_one_bit_cmp and\n\t*ashrdi3_one_bit_cmp_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp\n\tand *ashrdi3_cmp_rex64 using SWI mode iterator.\n\t(*ashrsi3_cmp_zext): Merge with *ashrsi3_cmp_one_bit_zext.\n\t(*ashr<mode>3_cconly): Merge with *ashr{qi,hi,si}3_one_bit_cconly and\n\t*ashrdi3_one_bit_cconly_rex64. Macroize insn from\n\t*ashr{qi,hi,si}3_cconly and *ashrdi3_cconly_rex64 using\n\tSWI mode iterator.\n\t(sign_extend splitters): Update for renamed ashr{di,si}3_patterns.\n\t* config/i386/i386.c (ix86_split_ashr): Update for renamed\n\tx86_shift<mode>_adj_3 expander.\n\nFrom-SVN: r158195", "tree": {"sha": "172938f1757a12ff2723501c40af178899a9d293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/172938f1757a12ff2723501c40af178899a9d293"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27431d88dd1a06237f8a62a48f8bdd72154134d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27431d88dd1a06237f8a62a48f8bdd72154134d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27431d88dd1a06237f8a62a48f8bdd72154134d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27431d88dd1a06237f8a62a48f8bdd72154134d6/comments", "author": null, "committer": null, "parents": [{"sha": "a6d57223b149b3859ad5d5341a721a05b2e0060d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6d57223b149b3859ad5d5341a721a05b2e0060d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6d57223b149b3859ad5d5341a721a05b2e0060d"}], "stats": {"total": 928, "additions": 293, "deletions": 635}, "files": [{"sha": "c053f3df96a433804da6d1e173016c95669d4f64", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27431d88dd1a06237f8a62a48f8bdd72154134d6", "patch": "@@ -1,3 +1,33 @@\n+2010-04-10  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (ashr<mode>3): Macroize expander from\n+\tashr{qi,hi,si,di,ti}3_1 using SDWIM mode iterator.\n+\t(*ashr<mode>3_doubleword): New insn_and_split_pattern.  Macroize\n+\tpattern from *ashr{di,ti}3_1 and corresponding splitters using\n+\tDWI mode iterator.\n+\t(*ashr<mode>3_doubleword peephole2): Macroize peephole2 pattern\n+\tfrom corresponding peephole2 patterns.\n+\t(ashrdi3_cvt): Rename from ashrdi3_63_rex64.\n+\t(ashrsi3_cvt): Rename from ashrsi3_31.\n+\t(*ashrsi3_cvt_zext): Rename from *ashrsi3_31_zext.\n+\t(x86_shift<mode>_adj_3): Macroize expander from x86_shift_adj_3\n+\tand x86_64_shift_adj_3 using SWI48 mode iterator.\n+\t(*ashr<mode>3_1): Merge with *ashr{qi,hi,si}3_1_one_bit and\n+\t*ashrdi3_1_one_bit_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp\n+\tand *ashrdi3_cmp_rex64 using SWI mode iterator.\n+\t(*ashrqi3_1_slp): Merge with *ashrqi3_1_one_bit_slp.\n+\t(*ashr<mode>3_cmp): Merge with *ashr{qi,hi,si}3_one_bit_cmp and\n+\t*ashrdi3_one_bit_cmp_rex64. Macroize insn from *ashr{qi,hi,si}3_cmp\n+\tand *ashrdi3_cmp_rex64 using SWI mode iterator.\n+\t(*ashrsi3_cmp_zext): Merge with *ashrsi3_cmp_one_bit_zext.\n+\t(*ashr<mode>3_cconly): Merge with *ashr{qi,hi,si}3_one_bit_cconly and\n+\t*ashrdi3_one_bit_cconly_rex64. Macroize insn from\n+\t*ashr{qi,hi,si}3_cconly and *ashrdi3_cconly_rex64 using\n+\tSWI mode iterator.\n+\t(sign_extend splitters): Update for renamed ashr{di,si}3_patterns.\n+\t* config/i386/i386.c (ix86_split_ashr): Update for renamed\n+\tx86_shift<mode>_adj_3 expander.\n+\n 2010-04-10  Wei Guozhi  <carrot@google.com>\n \n \tPR target/42601\n@@ -44,8 +74,8 @@\n \n 2010-04-09  Hariharan Sandanagobalane  <hariharan@picochip.com>\n \n-\t* config/picochip/picochip.c (picochip_rtx_costs): Use correct function\n-\ttemplate.\n+\t* config/picochip/picochip.c (picochip_rtx_costs): Use correct\n+\tfunction template.\n \t(picochip_override_options): Enable section anchors only above -O1.\n \t(picochip_reorg): Fixed a couple of build warnings.\n \n@@ -210,7 +240,7 @@\n \t(ix86_attribute_table): Add description for thiscall attribute.\n \t* config/i386/i386.h (ix86_args): Adjust comment for member fastcall.\n \t* doc/extend.texi: Add documentation for thiscall.\n-\t\n+\n 2010-04-09  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/28584\n@@ -255,7 +285,7 @@\n \t* gcc.h (DEFAULT_SWITCH_TAKES_ARG): Delete -b and -V.\n \n 2010-04-08  Christian Borntraeger  <borntraeger@de.ibm.com>\n-            Wolfgang Gellerich  <gellerich@de.ibm.com>\n+\t    Wolfgang Gellerich  <gellerich@de.ibm.com>\n \n \tImplement target hook for loop unrolling\n \t* target.h (loop_unroll_adjust): Add a new target hook function.\n@@ -422,7 +452,7 @@\n \tinserting GIMPLE_NOPs into the IL.\n \t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n \tExplicitly strip handled components and indirect references.\n-  \n+ \n \t* fold-const.c (fold_unary_loc): Do not strip qualifiers when\n \tfolding address expressions.\n \t* gimple.c (gimple_ior_addresses_taken_1): Use get_base_address."}, {"sha": "2c6a09cad0c027e7a81c09385b746f330c59ac80", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=27431d88dd1a06237f8a62a48f8bdd72154134d6", "patch": "@@ -17224,8 +17224,8 @@ ix86_split_ashr (rtx *operands, rtx scratch, enum machine_mode mode)\n \t}\n       else\n \temit_insn ((mode == DImode\n-\t\t    ? gen_x86_shift_adj_3\n-\t\t    : gen_x86_64_shift_adj_3) (low[0], high[0], operands[2]));\n+\t\t    ? gen_x86_shiftsi_adj_3\n+\t\t    : gen_x86_shiftdi_adj_3) (low[0], high[0], operands[2]));\n     }\n }\n "}, {"sha": "95220d389ac41f766616be02e64f58dcef20afb2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 246, "deletions": 617, "changes": 863, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=27431d88dd1a06237f8a62a48f8bdd72154134d6", "patch": "@@ -4177,12 +4177,12 @@\n       && true_regnum (operands[1]) == AX_REG\n       && true_regnum (operands[2]) == DX_REG)\n     {\n-      emit_insn (gen_ashrsi3_31 (operands[2], operands[1], GEN_INT (31)));\n+      emit_insn (gen_ashrsi3_cvt (operands[2], operands[1], GEN_INT (31)));\n     }\n   else\n     {\n       emit_move_insn (operands[2], operands[1]);\n-      emit_insn (gen_ashrsi3_31 (operands[2], operands[2], GEN_INT (31)));\n+      emit_insn (gen_ashrsi3_cvt (operands[2], operands[2], GEN_INT (31)));\n     }\n   emit_move_insn (operands[4], operands[2]);\n   DONE;\n@@ -4207,14 +4207,14 @@\n   if ((optimize_function_for_size_p (cfun) || TARGET_USE_CLTD)\n       && true_regnum (operands[3]) == AX_REG)\n     {\n-      emit_insn (gen_ashrsi3_31 (operands[4], operands[3], GEN_INT (31)));\n+      emit_insn (gen_ashrsi3_cvt (operands[4], operands[3], GEN_INT (31)));\n       DONE;\n     }\n \n   if (true_regnum (operands[4]) != true_regnum (operands[1]))\n     emit_move_insn (operands[4], operands[1]);\n \n-  emit_insn (gen_ashrsi3_31 (operands[4], operands[4], GEN_INT (31)));\n+  emit_insn (gen_ashrsi3_cvt (operands[4], operands[4], GEN_INT (31)));\n   DONE;\n })\n \n@@ -10209,42 +10209,40 @@\n \n ;; See comment above `ashldi3' about how this works.\n \n-(define_expand \"ashrti3\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"ix86_expand_binary_operator (ASHIFTRT, TImode, operands); DONE;\")\n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:SDWIM 0 \"<shift_operand>\" \"\")\n+\t(ashiftrt:SDWIM (match_operand:SDWIM 1 \"<shift_operand>\" \"\")\n+\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"ix86_expand_binary_operator (ASHIFTRT, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*ashrti3_1\"\n-  [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Oc\")))\n+(define_insn_and_split \"*ashr<mode>3_doubleword\"\n+  [(set (match_operand:DWI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:DWI (match_operand:DWI 1 \"register_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"<S>c\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\"\n+  \"\"\n   \"#\"\n+  \"(optimize && flag_peephole2) ? epilogue_completed : reload_completed\"\n+  [(const_int 0)]\n+  \"ix86_split_ashr (operands, NULL_RTX, <MODE>mode); DONE;\"\n   [(set_attr \"type\" \"multi\")])\n \n+;; By default we don't ask for a scratch register, because when DWImode\n+;; values are manipulated, registers are already at a premium.  But if\n+;; we have one handy, we won't turn it away.\n+\n (define_peephole2\n-  [(match_scratch:DI 3 \"r\")\n-   (parallel [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t\t   (ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n-\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n+  [(match_scratch:DWIH 3 \"r\")\n+   (parallel [(set (match_operand:<DWI> 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:<DWI>\n+\t\t     (match_operand:<DWI> 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n \t      (clobber (reg:CC FLAGS_REG))])\n    (match_dup 3)]\n-  \"TARGET_64BIT\"\n-  [(const_int 0)]\n-  \"ix86_split_ashr (operands, operands[3], TImode); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:TI 0 \"register_operand\" \"\")\n-\t(ashiftrt:TI (match_operand:TI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t    ? epilogue_completed : reload_completed)\"\n+  \"TARGET_CMOVE\"\n   [(const_int 0)]\n-  \"ix86_split_ashr (operands, NULL_RTX, TImode); DONE;\")\n+  \"ix86_split_ashr (operands, operands[3], <DWI>mode); DONE;\")\n \n (define_insn \"x86_64_shrd\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"+r*m\")\n@@ -10261,23 +10259,83 @@\n    (set_attr \"athlon_decode\" \"vector\")\n    (set_attr \"amdfam10_decode\" \"vector\")])\n \n-(define_expand \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"shiftdi_operand\" \"\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"shiftdi_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+(define_insn \"x86_shrd\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+r*m\")\n+        (ior:SI (ashiftrt:SI (match_dup 0)\n+\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"Ic\"))\n+\t\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (minus:QI (const_int 32) (match_dup 2)))))\n+   (clobber (reg:CC FLAGS_REG))]\n   \"\"\n-  \"ix86_expand_binary_operator (ASHIFTRT, DImode, operands); DONE;\")\n+  \"shrd{l}\\t{%s2%1, %0|%0, %1, %2}\"\n+  [(set_attr \"type\" \"ishift\")\n+   (set_attr \"prefix_0f\" \"1\")\n+   (set_attr \"pent_pair\" \"np\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrdi3_cvt\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=*d,rm\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"*a,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && INTVAL (operands[2]) == 63\n+   && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n+   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n+  \"@\n+   {cqto|cqo}\n+   sar{q}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"imovx,ishift\")\n+   (set_attr \"prefix_0f\" \"0,*\")\n+   (set_attr \"length_immediate\" \"0,*\")\n+   (set_attr \"modrm\" \"0,1\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"*ashrsi3_cvt_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=*d,r\")\n+\t(zero_extend:DI\n+\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"*a,0\")\n+\t\t       (match_operand:QI 2 \"const_int_operand\" \"\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && INTVAL (operands[2]) == 31\n+   && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n+   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n+  \"@\n+   {cltd|cdq}\n+   sar{l}\\t{%2, %k0|%k0, %2}\"\n+  [(set_attr \"type\" \"imovx,ishift\")\n+   (set_attr \"prefix_0f\" \"0,*\")\n+   (set_attr \"length_immediate\" \"0,*\")\n+   (set_attr \"modrm\" \"0,1\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"ashrsi3_cvt\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,rm\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"*a,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"INTVAL (operands[2]) == 31\n+   && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n+   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n+  \"@\n+   {cltd|cdq}\n+   sar{l}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"imovx,ishift\")\n+   (set_attr \"prefix_0f\" \"0,*\")\n+   (set_attr \"length_immediate\" \"0,*\")\n+   (set_attr \"modrm\" \"0,1\")\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_expand \"x86_64_shift_adj_3\"\n-  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n-   (use (match_operand:DI 1 \"register_operand\" \"\"))\n+(define_expand \"x86_shift<mode>_adj_3\"\n+  [(use (match_operand:SWI48 0 \"register_operand\" \"\"))\n+   (use (match_operand:SWI48 1 \"register_operand\" \"\"))\n    (use (match_operand:QI 2 \"register_operand\" \"\"))]\n   \"\"\n {\n   rtx label = gen_label_rtx ();\n   rtx tmp;\n \n-  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (64)));\n+  emit_insn (gen_testqi_ccz_1 (operands[2],\n+\t\t\t       GEN_INT (GET_MODE_BITSIZE (<MODE>mode))));\n \n   tmp = gen_rtx_REG (CCZmode, FLAGS_REG);\n   tmp = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n@@ -10288,617 +10346,188 @@\n   JUMP_LABEL (tmp) = label;\n \n   emit_move_insn (operands[0], operands[1]);\n-  emit_insn (gen_ashrdi3_63_rex64 (operands[1], operands[1], GEN_INT (63)));\n-\n+  emit_insn (gen_ashr<mode>3_cvt (operands[1], operands[1],\n+\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (<MODE>mode)-1)));\n   emit_label (label);\n   LABEL_NUSES (label) = 1;\n \n   DONE;\n })\n \n-(define_insn \"ashrdi3_63_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=*d,rm\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"*a,0\")\n-\t\t     (match_operand:DI 2 \"const_int_operand\" \"i,i\")))\n+(define_insn \"*ashr<mode>3_1\"\n+  [(set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(ashiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"c<S>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && INTVAL (operands[2]) == 63\n-   && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"@\n-   {cqto|cqo}\n-   sar{q}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"imovx,ishift\")\n-   (set_attr \"prefix_0f\" \"0,*\")\n-   (set_attr \"length_immediate\" \"0,*\")\n-   (set_attr \"modrm\" \"0,1\")\n-   (set_attr \"mode\" \"DI\")])\n+  \"ix86_binary_operator_ok (ASHIFTRT, <MODE>mode, operands)\"\n+{\n+  if (REG_P (operands[2]))\n+    return \"sar{<imodesuffix>}\\t{%b2, %0|%0, %b2}\";\n+  else if (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"sar{<imodesuffix>}\\t%0\";\n+  else\n+    return \"sar{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n+  [(set_attr \"type\" \"ishift\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*ashrdi3_1_one_bit_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n+(define_insn \"*ashrsi3_1_zext\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:QI 2 \"nonmemory_operand\" \"cI\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"sar{q}\\t%0\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n+{\n+  if (REG_P (operands[2]))\n+    return \"sar{l}\\t{%b2, %k0|%k0, %b2}\";\n+  else if (operands[2] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"sar{l}\\t%k0\";\n+  else\n+    return \"sar{l}\\t{%2, %k0|%k0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*ashrdi3_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"J,c\")))\n+(define_insn \"*ashrqi3_1_slp\"\n+  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n+\t(ashiftrt:QI (match_dup 0)\n+\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"@\n-   sar{q}\\t{%2, %0|%0, %2}\n-   sar{q}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"DI\")])\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_REG_STALL\n+    || (operands[1] == const1_rtx\n+\t&& TARGET_SHIFT1))\"\n+{\n+  if (REG_P (operands[1]))\n+    return \"sar{b}\\t{%b1, %0|%0, %b1}\";\n+  else if (operands[1] == const1_rtx\n+\t   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"sar{b}\\t%0\";\n+  else\n+    return \"sar{b}\\t{%1, %0|%0, %1}\";\n+}\n+  [(set_attr \"type\" \"ishift1\")\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 1 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"QI\")])\n \n ;; This pattern can't accept a variable shift count, since shifts by\n ;; zero don't affect the flags.  We assume that shifts by constant\n ;; zero are optimized away.\n-(define_insn \"*ashrdi3_one_bit_cmp_rex64\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"sar{q}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*ashrdi3_one_bit_cconly_rex64\"\n+(define_insn \"*ashr<mode>3_cmp\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n+\t  (ashiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n+   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>m\")\n+\t(ashiftrt:SWI (match_dup 1) (match_dup 2)))]\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_FLAG_REG_STALL\n+    || (operands[2] == const1_rtx\n+\t&& TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"sar{q}\\t%0\"\n+   && ix86_binary_operator_ok (ASHIFTRT, <MODE>mode, operands)\"\n+{\n+  if (operands[2] == const1_rtx\n+      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"sar{<imodesuffix>}\\t%0\";\n+  else\n+    return \"sar{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"DI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrdi3_cmp_rex64\"\n+(define_insn \"*ashrsi3_cmp_zext\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_63_operand\" \"J\"))\n+\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n \t  (const_int 0)))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:DI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (ashiftrt:SI (match_dup 1) (match_dup 2))))]\n   \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n+   && (optimize_function_for_size_p (cfun)\n+       || !TARGET_PARTIAL_FLAG_REG_STALL\n+       || (operands[2] == const1_rtx\n+\t   && TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"sar{q}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n+{\n+  if (operands[2] == const1_rtx\n+      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"sar{l}\\t%k0\";\n+  else\n+    return \"sar{l}\\t{%2, %k0|%k0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"DI\")])\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*ashrdi3_cconly_rex64\"\n+(define_insn \"*ashr<mode>3_cconly\"\n   [(set (reg FLAGS_REG)\n \t(compare\n-\t  (ashiftrt:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_63_operand\" \"J\"))\n+\t  (ashiftrt:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t(match_operand:QI 2 \"<shift_immediate_operand>\" \"<S>\"))\n \t  (const_int 0)))\n-   (clobber (match_scratch:DI 0 \"=r\"))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n+   (clobber (match_scratch:DI 0 \"=<r>\"))]\n+  \"(optimize_function_for_size_p (cfun)\n+    || !TARGET_PARTIAL_FLAG_REG_STALL\n+    || (operands[2] == const1_rtx\n+\t&& TARGET_SHIFT1))\n    && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, DImode, operands)\"\n-  \"sar{q}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (ASHIFTRT, <MODE>mode, operands)\"\n+{\n+  if (operands[2] == const1_rtx\n+      && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n+    return \"sar{<imodesuffix>}\\t%0\";\n+  else\n+    return \"sar{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n+}\n   [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"DI\")])\n-\n-(define_insn \"*ashrdi3_1\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"Jc\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\"\n-  \"#\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-;; By default we don't ask for a scratch register, because when DImode\n-;; values are manipulated, registers are already at a premium.  But if\n-;; we have one handy, we won't turn it away.\n-(define_peephole2\n-  [(match_scratch:SI 3 \"r\")\n-   (parallel [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t   (ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t\t        (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (match_dup 3)]\n-  \"!TARGET_64BIT && TARGET_CMOVE\"\n-  [(const_int 0)]\n-  \"ix86_split_ashr (operands, operands[3], DImode); DONE;\")\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && ((optimize > 0 && flag_peephole2)\n-\t\t     ? epilogue_completed : reload_completed)\"\n-  [(const_int 0)]\n-  \"ix86_split_ashr (operands, NULL_RTX, DImode); DONE;\")\n-\n-(define_insn \"x86_shrd\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"+r*m\")\n-        (ior:SI (ashiftrt:SI (match_dup 0)\n-\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"Ic\"))\n-\t\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (minus:QI (const_int 32) (match_dup 2)))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"\"\n-  \"shrd{l}\\t{%s2%1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"prefix_0f\" \"1\")\n-   (set_attr \"pent_pair\" \"np\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"x86_shift_adj_3\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n-   (use (match_operand:SI 1 \"register_operand\" \"\"))\n-   (use (match_operand:QI 2 \"register_operand\" \"\"))]\n-  \"\"\n-{\n-  rtx label = gen_label_rtx ();\n-  rtx tmp;\n-\n-  emit_insn (gen_testqi_ccz_1 (operands[2], GEN_INT (32)));\n-\n-  tmp = gen_rtx_REG (CCZmode, FLAGS_REG);\n-  tmp = gen_rtx_EQ (VOIDmode, tmp, const0_rtx);\n-  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-\t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t      pc_rtx);\n-  tmp = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));\n-  JUMP_LABEL (tmp) = label;\n-\n-  emit_move_insn (operands[0], operands[1]);\n-  emit_insn (gen_ashrsi3_31 (operands[1], operands[1], GEN_INT (31)));\n-\n-  emit_label (label);\n-  LABEL_NUSES (label) = 1;\n-\n-  DONE;\n-})\n-\n-(define_expand \"ashrsi3_31\"\n-  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,rm\")\n-\t           (ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"*a,0\")\n-\t\t                (match_operand:SI 2 \"const_int_operand\" \"i,i\")))\n-              (clobber (reg:CC FLAGS_REG))])]\n-  \"\")\n-\n-(define_insn \"*ashrsi3_31\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,rm\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"*a,0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"i,i\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"INTVAL (operands[2]) == 31\n-   && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"@\n-   {cltd|cdq}\n-   sar{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"imovx,ishift\")\n-   (set_attr \"prefix_0f\" \"0,*\")\n-   (set_attr \"length_immediate\" \"0,*\")\n-   (set_attr \"modrm\" \"0,1\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_31_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=*d,r\")\n-\t(zero_extend:DI (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"*a,0\")\n-\t\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"i,i\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && (TARGET_USE_CLTD || optimize_function_for_size_p (cfun))\n-   && INTVAL (operands[2]) == 31\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"@\n-   {cltd|cdq}\n-   sar{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"imovx,ishift\")\n-   (set_attr \"prefix_0f\" \"0,*\")\n-   (set_attr \"length_immediate\" \"0,*\")\n-   (set_attr \"modrm\" \"0,1\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (ASHIFTRT, SImode, operands); DONE;\")\n-\n-(define_insn \"*ashrsi3_1_one_bit\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_1_one_bit_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t\t\t     (match_operand:QI 2 \"const1_operand\" \"\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t%k0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_1\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"@\n-   sar{l}\\t{%2, %0|%0, %2}\n-   sar{l}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:DI (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"@\n-   sar{l}\\t{%2, %k0|%k0, %2}\n-   sar{l}\\t{%b2, %k0|%k0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrsi3_one_bit_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:SI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_one_bit_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_one_bit_cmp_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (ashiftrt:SI (match_dup 1) (match_dup 2))))]\n-  \"TARGET_64BIT\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t%k0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrsi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:SI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:SI 0 \"=r\"))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*ashrsi3_cmp_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (ashiftrt:SI (match_dup 1) (match_dup 2))))]\n-  \"TARGET_64BIT\n-   && (optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, SImode, operands)\"\n-  \"sar{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_HIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ASHIFTRT, HImode, operands); DONE;\")\n-\n-(define_insn \"*ashrhi3_1_one_bit\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)\"\n-  \"sar{w}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*ashrhi3_1\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,rm\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ASHIFTRT, HImode, operands)\"\n-  \"@\n-   sar{w}\\t{%2, %0|%0, %2}\n-   sar{w}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrhi3_one_bit_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:HI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)\"\n-  \"sar{w}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*ashrhi3_one_bit_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)\"\n-  \"sar{w}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrhi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n-\t(ashiftrt:HI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)\"\n-  \"sar{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_insn \"*ashrhi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:HI 0 \"=r\"))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, HImode, operands)\"\n-  \"sar{w}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"HI\")])\n-\n-(define_expand \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_QIMODE_MATH\"\n-  \"ix86_expand_binary_operator (ASHIFTRT, QImode, operands); DONE;\")\n-\n-(define_insn \"*ashrqi3_1_one_bit\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"sar{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*ashrqi3_1_one_bit_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm\"))\n-\t(ashiftrt:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"const1_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"sar{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift1\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*ashrqi3_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,qm\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"@\n-   sar{b}\\t{%2, %0|%0, %2}\n-   sar{b}\\t{%b2, %0|%0, %b2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*ashrqi3_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,qm\"))\n-\t(ashiftrt:QI (match_dup 0)\n-\t\t     (match_operand:QI 1 \"nonmemory_operand\" \"I,c\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"@\n-   sar{b}\\t{%1, %0|%0, %1}\n-   sar{b}\\t{%b1, %0|%0, %b1}\"\n-  [(set_attr \"type\" \"ishift1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrqi3_one_bit_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(ashiftrt:QI (match_dup 1) (match_dup 2)))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"sar{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*ashrqi3_one_bit_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const1_operand\" \"\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n-  \"(TARGET_SHIFT1 || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"sar{b}\\t%0\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-;; This pattern can't accept a variable shift count, since shifts by\n-;; zero don't affect the flags.  We assume that shifts by constant\n-;; zero are optimized away.\n-(define_insn \"*ashrqi3_cmp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n-\t(ashiftrt:QI (match_dup 1) (match_dup 2)))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"sar{b}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*ashrqi3_cconly\"\n-  [(set (reg FLAGS_REG)\n-\t(compare\n-\t  (ashiftrt:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")\n-\t\t       (match_operand:QI 2 \"const_1_to_31_operand\" \"I\"))\n-\t  (const_int 0)))\n-   (clobber (match_scratch:QI 0 \"=q\"))]\n-  \"(optimize_function_for_size_p (cfun) || !TARGET_PARTIAL_FLAG_REG_STALL)\n-   && ix86_match_ccmode (insn, CCGOCmode)\n-   && ix86_binary_operator_ok (ASHIFTRT, QImode, operands)\"\n-  \"sar{b}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"ishift\")\n-   (set_attr \"mode\" \"QI\")])\n-\n+   (set (attr \"length_immediate\")\n+     (if_then_else\n+       (and (match_operand 2 \"const1_operand\" \"\")\n+\t    (ne (symbol_ref \"TARGET_SHIFT1 || optimize_function_for_size_p (cfun)\")\n+\t\t(const_int 0)))\n+       (const_string \"0\")\n+       (const_string \"*\")))\n+   (set_attr \"mode\" \"<MODE>\")])\n \f\n ;; Logical shift instructions\n "}, {"sha": "a7ef6764dc95b2967cdcf49f87b8c73156da8464", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27431d88dd1a06237f8a62a48f8bdd72154134d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27431d88dd1a06237f8a62a48f8bdd72154134d6", "patch": "@@ -54,15 +54,15 @@\n \t* g++.dg/other/pr35504.C: Add check for thiscall.\n \t* g++.dg/torture/stackalign/eh-thiscall-1.C: New.\n \t* gcc.dg/torture/stackalign/thiscall-1.c: New.\n-\t\n+\n 2010-04-09  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/28584\n \t* gcc.dg/Wint-to-pointer-cast-1.c: Move to...\n \t* c-c++-common/Wint-to-pointer-cast-1.c: ...  here.\n-\t* gcc.dg/Wint-to-pointer-cast-2.c: Move to...\t\n+\t* gcc.dg/Wint-to-pointer-cast-2.c: Move to...\n \t* c-c++-common/Wint-to-pointer-cast-2.c: ...  here.\n-\t* gcc.dg/Wint-to-pointer-cast-3.c: Move to...\t\n+\t* gcc.dg/Wint-to-pointer-cast-3.c: Move to...\n \t* c-c++-common/Wint-to-pointer-cast-3.c: ...  here. Update.\n \t* g++.old-deja/g++.mike/warn1.C: Add -Wno-int-to-pointer-cast.\n \t* g++.dg/other/increment1.C: Likewise.\n@@ -218,7 +218,7 @@\n \n 2010-04-06  Dodji Seketeli  <dodji@redhat.com>\n \n-\t* g++.dg/debug/dwarf2/redeclaration-1.C: Moved from \n+\t* g++.dg/debug/dwarf2/redeclaration-1.C: Moved from\n \tc-c++-common/dwarf2/redeclaration-1.C\n \n 2010-04-06  Jason Merrill  <jason@redhat.com>\n@@ -388,7 +388,7 @@\n \n \tPR tree-optimization/43141\n \t* gcc.dg/guality/pr43141.c: New test.\n-\t\n+\n 2010-04-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/cpp/_Pragma1.C: Skip on alpha*-dec-osf*.\n@@ -701,13 +701,13 @@\n \t* objc/execute/class_self-2.m: Include <stdlib.h>.\n \t* objc/execute/forward-1.x: Do not XFAIL for 32bit powerpc-darwin.\n \t* objc.dg/desig-init-1.m: Use shared wrapper headers (Object1.h,\n-\tProtocol1.h) and next-mapping.h as required. XFAIL run if NeXT \n+\tProtocol1.h) and next-mapping.h as required. XFAIL run if NeXT\n \tand 64bit. Use new NeXT interface as required.\n \t* objc.dg/special/unclaimed-category-1.m: Ditto.\n \t* objc.dg/special/unclaimed-category-1.h: Ditto.\n \t* objc.dg/special/unclaimed-category-1a.m: Ditto.\n \t* objc.dg/func-ptr-1.m: Ditto.\n-\t* objc.dg/stret-1.m: Ditto.\t\n+\t* objc.dg/stret-1.m: Ditto.\n \t* objc.dg/encode-2.m: Ditto.\n \t* objc.dg/category-1.m: Ditto.\n \t* objc.dg/encode-3.m: Ditto.\n@@ -727,10 +727,10 @@\n \t* objc.dg/call-super-1.m: Ditto.\n \t* objc.dg/type-size-2.m: Ditto.\n \t* objc.dg/method-10.m: Ditto.\n-\t* objc.dg/defs.m: Ditto.\t\n+\t* objc.dg/defs.m: Ditto.\n \t* objc.dg/const-str-3.m: Ditto.\n \t* objc.dg/try-catch-6.m: Use shared wrapper headers (Object1.h,\n-\tProtocol1.h) and next-mapping.h as required. Use new NeXT \n+\tProtocol1.h) and next-mapping.h as required. Use new NeXT\n \tinterface as required.\n \t* objc.dg/super-class-4.m: Ditto.\n \t* objc.dg/comp-types-8.m: Ditto.\n@@ -791,8 +791,7 @@\n \t* objc.dg/try-catch-5.m: Ditto.\n \t* objc.dg/const-str-10.m: Use shared wrapper headers (Object1.h,\n \tProtocol1.h) and next-mapping.h as required. Use new NeXT\n-\tinterface as required.  Skip for gnu-runtime.  Test for .quad\n-\tat m64.\n+\tinterface as required.  Skip for gnu-runtime.  Test for .quad at m64.\n \t* objc.dg/const-str-11.m: Ditto.\n \t* objc.dg/const-str-9.m: Ditto.\n \t* objc.dg/method-4.m: Skip for 64Bit NeXT."}]}