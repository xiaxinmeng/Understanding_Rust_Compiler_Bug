{"sha": "765d600ac5d94a978c00cd791c95ea75d1673e66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1ZDYwMGFjNWQ5NGE5NzhjMDBjZDc5MWM5NWVhNzVkMTY3M2U2Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-01-25T09:01:27Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-01-25T09:01:27Z"}, "message": "re PR preprocessor/34692 (Internal error with pragma in macro)\n\n\tPR preprocessor/34692\n\t* macro.c (collect_args): Add pragma_buff argument.  Push\n\tCPP_PRAGMA ... CPP_PRAGMA_EOL tokens to *pragma_buff, rather\n\tthan into arguments.  Reset prevent_expansion and parsing_args\n\tstate at CPP_PRAGMA_EOL/CPP_EOF.\n\t(funlike_invocation_p): Add pragma_buff argument, pass it through\n\tto collect_args.\n\t(enter_macro_context): Add result argument.  Adjust\n\tfunlike_invocation_p caller.  Emit all deferred pragma tokens\n\tgathered during collect_args before the expansion, add a padding\n\ttoken.  Return 2 instead of 1 if any pragma tokens were prepended.\n\t(cpp_get_token): If enter_macro_context returns 2, don't return\n\ta padding token, instead cycle to grab CPP_PRAGMA token.\n\t* directives.c (_cpp_handle_directive): If was_parsing_args\n\tin deferred pragma, leave parsing_args and prevent_expansion as is.\n\n\t* gcc.dg/cpp/pr34692.c: New test.\n\t* gcc.dg/gomp/pr34692.c: New test.\n\nFrom-SVN: r131819", "tree": {"sha": "bd03a307239e9c5c965e1cf60415fca9659096aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd03a307239e9c5c965e1cf60415fca9659096aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/765d600ac5d94a978c00cd791c95ea75d1673e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765d600ac5d94a978c00cd791c95ea75d1673e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/765d600ac5d94a978c00cd791c95ea75d1673e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/765d600ac5d94a978c00cd791c95ea75d1673e66/comments", "author": null, "committer": null, "parents": [{"sha": "1525f2c3a5627b3fd3754c36cbcc7d855f7107cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1525f2c3a5627b3fd3754c36cbcc7d855f7107cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1525f2c3a5627b3fd3754c36cbcc7d855f7107cf"}], "stats": {"total": 230, "additions": 199, "deletions": 31}, "files": [{"sha": "a722cb3b30912417864ea4343bb9c822baeb509e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765d600ac5d94a978c00cd791c95ea75d1673e66/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765d600ac5d94a978c00cd791c95ea75d1673e66/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=765d600ac5d94a978c00cd791c95ea75d1673e66", "patch": "@@ -1,3 +1,9 @@\n+2008-01-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR preprocessor/34692\n+\t* gcc.dg/cpp/pr34692.c: New test.\n+\t* gcc.dg/gomp/pr34692.c: New test.\n+\n 2008-01-25  Olga Golovanevsky  <olga@il.ibm.com>\n \n         * gcc.dg/struct/wo_prof_malloc_size_var.c: UnXFAIL."}, {"sha": "bcb0ca33d240f26d083fe2f7c70045ccf4e8485d", "filename": "gcc/testsuite/gcc.dg/cpp/pr34692.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765d600ac5d94a978c00cd791c95ea75d1673e66/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr34692.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765d600ac5d94a978c00cd791c95ea75d1673e66/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr34692.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr34692.c?ref=765d600ac5d94a978c00cd791c95ea75d1673e66", "patch": "@@ -0,0 +1,35 @@\n+/* PR preprocessor/34692 */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-require-visibility \"\" } */\n+/* { dg-final { scan-hidden \"vara\" } } */\n+/* { dg-final { scan-hidden \"varb\" } } */\n+/* { dg-final { scan-hidden \"varc\" } } */\n+/* { dg-final { scan-hidden \"vard\" } } */\n+/* { dg-final { scan-assembler \"a b cde f g h\" } } */\n+\n+#define FOO(y, x) y #x\n+#define BAR(x) x\n+#define BAZ(x) x\n+FOO (const char *vara =,\n+a\n+#pragma GCC visibility push(hidden)\n+b\n+#pragma GCC visibility push(hidden)\n+cde f g h);\n+int varb = 6;\n+#pragma GCC visibility pop\n+#pragma GCC visibility pop\n+FOO (\n+BAR (\n+#pragma GCC visibility push(hidden)\n+const) char *varc =,);\n+#pragma GCC visibility pop\n+FOO (\n+BAR (\n+BAZ (\n+#pragma GCC visibility push(hidden)\n+#pragma GCC visibility push(hidden)\n+const) char) *vard =,);\n+#pragma GCC visibility pop\n+#pragma GCC visibility pop"}, {"sha": "0e1a1eb827fbc4b9f117fa4a2fbeec864cdf242f", "filename": "gcc/testsuite/gcc.dg/gomp/pr34692.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765d600ac5d94a978c00cd791c95ea75d1673e66/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr34692.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765d600ac5d94a978c00cd791c95ea75d1673e66/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr34692.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr34692.c?ref=765d600ac5d94a978c00cd791c95ea75d1673e66", "patch": "@@ -0,0 +1,26 @@\n+/* PR preprocessor/34692 */\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp parallel\" 1 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp for private\" 1 \"gimple\" } } */\n+\n+void\n+foo (void)\n+{\n+  int i;\n+#define FOO(y, x) y #x\n+#define BAR(x) x\n+#define BAZ(x) x\n+FOO (for (i = 0; i < 10; i++) { const char *vara =,\n+a\n+#define P parallel\n+#pragma omp P\n+#undef P\n+#define P for\n+b\n+#pragma omp P\n+#undef P\n+#define parallel atomic\n+cde f g h);\n+  }\n+}"}, {"sha": "a14c38ef9a98418bad9971e15b01292d134aee6a", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765d600ac5d94a978c00cd791c95ea75d1673e66/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765d600ac5d94a978c00cd791c95ea75d1673e66/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=765d600ac5d94a978c00cd791c95ea75d1673e66", "patch": "@@ -1,12 +1,30 @@\n+2008-01-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR preprocessor/34692\n+\t* macro.c (collect_args): Add pragma_buff argument.  Push\n+\tCPP_PRAGMA ... CPP_PRAGMA_EOL tokens to *pragma_buff, rather\n+\tthan into arguments.  Reset prevent_expansion and parsing_args\n+\tstate at CPP_PRAGMA_EOL/CPP_EOF.\n+\t(funlike_invocation_p): Add pragma_buff argument, pass it through\n+\tto collect_args.\n+\t(enter_macro_context): Add result argument.  Adjust\n+\tfunlike_invocation_p caller.  Emit all deferred pragma tokens\n+\tgathered during collect_args before the expansion, add a padding\n+\ttoken.  Return 2 instead of 1 if any pragma tokens were prepended.\n+\t(cpp_get_token): If enter_macro_context returns 2, don't return\n+\ta padding token, instead cycle to grab CPP_PRAGMA token.\n+\t* directives.c (_cpp_handle_directive): If was_parsing_args\n+\tin deferred pragma, leave parsing_args and prevent_expansion as is.\n+\n 2008-01-22  Tom Tromey  <tromey@redhat.com>\n \n-\tPR c++/34859:\n+\tPR c++/34859\n \t* macro.c (_cpp_create_definition): Handle __STDC_LIMIT_MACROS and\n \t__STDC_CONSTANT_MACROS.\n \n 2008-01-07  Fred Fish  <fnf@specifix.com>\n \n-\tPR preprocessor/30363:\n+\tPR preprocessor/30363\n \t* traditional.c (replace_args_and_push): Add local variable\n \tcxtquote, calculate the replacement text size assuming a \n \tworst case of every input character quoted with backslash,\n@@ -15,7 +33,7 @@\n \n 2008-01-03  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/34602.\n+\tPR preprocessor/34602\n \t* directives.c (do_line): Don't try to spell EOF token.\n \t(do_linemarker): Add comment.\n \n@@ -26,7 +44,7 @@\n \n 2007-12-06  Tom Tromey  <tromey@redhat.com>\n \n-\tPR c/29172:\n+\tPR c/29172\n \t* internal.h (struct cpp_reader) <file_hash_entries>: Changed\n \ttype.\n \t<file_hash_entries_allocated, file_hash_entries_used>: Removed.\n@@ -43,13 +61,13 @@\n \n 2007-12-03  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/34288:\n+\tPR preprocessor/34288\n \t* configure.ac, config.in: Rebuilt.\n \t* configure.ac: Check for ssize_t.\n \n 2007-11-30  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/32868:\n+\tPR preprocessor/32868\n \t* macro.c (_cpp_create_definition): Special case\n \t__STDC_FORMAT_MACROS.\n \n@@ -59,7 +77,7 @@\n \n 2007-11-11  Tom Tromey  <tromey@redhat.com>\n \n-\tPR c++/17557:\n+\tPR c++/17557\n \t* include/cpplib.h (cpp_included_before): Declare.\n \t* files.c (struct file_hash_entry) <location>: New field.\n \t(_cpp_find_file): Initialize new field.\n@@ -68,13 +86,13 @@\n \n 2007-11-01  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/30805:\n+\tPR preprocessor/30805\n \t* macro.c (paste_tokens): Handle padding token.\n \t(paste_tokens): Don't abort unless padding has PASTE_LEFT flag.\n \n 2007-10-31  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/30786:\n+\tPR preprocessor/30786\n \t* macro.c (builtin_macro): Return result of _cpp_do__Pragma.\n \t* directives.c (_cpp_do__Pragma): Return error status.\n \t* internal.h (_cpp_do__Pragma): Update.\n@@ -112,7 +130,7 @@\n \n 2007-08-18  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/32974:\n+\tPR preprocessor/32974\n \t* directives.c (parse_include): Don't check for EOL when\n \tprocessing #pragma dependency.\n \n@@ -227,7 +245,7 @@\n \n 2007-05-02  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/28709:\n+\tPR preprocessor/28709\n \t* macro.c (paste_tokens): Remove PASTE_LEFT from the old lhs.\n \n 2007-03-30  Michael Meissner  <michael.meissner@amd.com>\n@@ -247,13 +265,13 @@\n \n 2007-01-30  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/30468:\n+\tPR preprocessor/30468\n \t* mkdeps.c (apply_vpath): Strip successive '/'s if we stripped\n \t'./'.\n \n 2007-01-30  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/29966:\n+\tPR preprocessor/29966\n \t* macro.c (lex_expansion_token): Save and restore cpp_reader's\n \tcur_token.\n \t(_cpp_create_definition): Don't restore cur_token here.\n@@ -265,7 +283,7 @@\n \n 2007-01-12  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/28227:\n+\tPR preprocessor/28227\n \t* directives.c (lex_macro_node): Added 'is_def_or_undef'\n \targument.\n \t(do_define): Update.\n@@ -283,7 +301,7 @@\n \n 2007-01-04  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/28165:\n+\tPR preprocessor/28165\n \t* internal.h (cpp_in_primary_file): New function.\n \t* directives.c (do_include_next): Use cpp_in_primary_file.\n \t(do_pragma_once): Likewise.\n@@ -302,7 +320,7 @@\n \n 2006-12-28  Tom Tromey  <tromey@redhat.com>\n \n-\tPR preprocessor/30001:\n+\tPR preprocessor/30001\n \t* charset.c (_cpp_convert_input): Check that to.len is greater\n \tthan zero.\n "}, {"sha": "c77e84bfec16aa7f60a67725fde0cff330acc8a9", "filename": "libcpp/directives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765d600ac5d94a978c00cd791c95ea75d1673e66/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765d600ac5d94a978c00cd791c95ea75d1673e66/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=765d600ac5d94a978c00cd791c95ea75d1673e66", "patch": "@@ -475,7 +475,7 @@ _cpp_handle_directive (cpp_reader *pfile, int indented)\n     _cpp_backup_tokens (pfile, 1);\n \n   end_directive (pfile, skip);\n-  if (was_parsing_args)\n+  if (was_parsing_args && !pfile->state.in_deferred_pragma)\n     {\n       /* Restore state when within macro args.  */\n       pfile->state.parsing_args = 2;"}, {"sha": "fd624b10110e91c7acbd2fce58c52fe72f41c9a5", "filename": "libcpp/macro.c", "status": "modified", "additions": 97, "deletions": 14, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/765d600ac5d94a978c00cd791c95ea75d1673e66/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/765d600ac5d94a978c00cd791c95ea75d1673e66/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=765d600ac5d94a978c00cd791c95ea75d1673e66", "patch": "@@ -41,11 +41,13 @@ struct macro_arg\n \n /* Macro expansion.  */\n \n-static int enter_macro_context (cpp_reader *, cpp_hashnode *);\n+static int enter_macro_context (cpp_reader *, cpp_hashnode *,\n+\t\t\t\tconst cpp_token *);\n static int builtin_macro (cpp_reader *, cpp_hashnode *);\n static void push_ptoken_context (cpp_reader *, cpp_hashnode *, _cpp_buff *,\n \t\t\t\t const cpp_token **, unsigned int);\n-static _cpp_buff *collect_args (cpp_reader *, const cpp_hashnode *);\n+static _cpp_buff *collect_args (cpp_reader *, const cpp_hashnode *,\n+\t\t\t\t_cpp_buff **);\n static cpp_context *next_context (cpp_reader *);\n static const cpp_token *padding_token (cpp_reader *, const cpp_token *);\n static void expand_arg (cpp_reader *, macro_arg *);\n@@ -55,7 +57,8 @@ static void paste_all_tokens (cpp_reader *, const cpp_token *);\n static bool paste_tokens (cpp_reader *, const cpp_token **, const cpp_token *);\n static void replace_args (cpp_reader *, cpp_hashnode *, cpp_macro *,\n \t\t\t  macro_arg *);\n-static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *);\n+static _cpp_buff *funlike_invocation_p (cpp_reader *, cpp_hashnode *,\n+\t\t\t\t\t_cpp_buff **);\n static bool create_iso_definition (cpp_reader *, cpp_macro *);\n \n /* #define directive parsing and handling.  */\n@@ -575,9 +578,12 @@ _cpp_arguments_ok (cpp_reader *pfile, cpp_macro *macro, const cpp_hashnode *node\n    invocation.  Assumes the opening parenthesis has been processed.\n    If there is an error, emits an appropriate diagnostic and returns\n    NULL.  Each argument is terminated by a CPP_EOF token, for the\n-   future benefit of expand_arg().  */\n+   future benefit of expand_arg().  If there are any deferred\n+   #pragma directives among macro arguments, store pointers to the\n+   CPP_PRAGMA ... CPP_PRAGMA_EOL tokens into *PRAGMA_BUFF buffer.  */\n static _cpp_buff *\n-collect_args (cpp_reader *pfile, const cpp_hashnode *node)\n+collect_args (cpp_reader *pfile, const cpp_hashnode *node,\n+\t      _cpp_buff **pragma_buff)\n {\n   _cpp_buff *buff, *base_buff;\n   cpp_macro *macro;\n@@ -645,6 +651,51 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node)\n \t  else if (token->type == CPP_EOF\n \t\t   || (token->type == CPP_HASH && token->flags & BOL))\n \t    break;\n+\t  else if (token->type == CPP_PRAGMA)\n+\t    {\n+\t      cpp_token *newtok = _cpp_temp_token (pfile);\n+\n+\t      /* CPP_PRAGMA token lives in directive_result, which will\n+\t\t be overwritten on the next directive.  */\n+\t      *newtok = *token;\n+\t      token = newtok;\n+\t      do\n+\t\t{\n+\t\t  if (*pragma_buff == NULL\n+\t\t      || BUFF_ROOM (*pragma_buff) < sizeof (cpp_token *))\n+\t\t    {\n+\t\t      _cpp_buff *next;\n+\t\t      if (*pragma_buff == NULL)\n+\t\t\t*pragma_buff\n+\t\t\t  = _cpp_get_buff (pfile, 32 * sizeof (cpp_token *));\n+\t\t      else\n+\t\t\t{\n+\t\t\t  next = *pragma_buff;\n+\t\t\t  *pragma_buff\n+\t\t\t    = _cpp_get_buff (pfile,\n+\t\t\t\t\t     (BUFF_FRONT (*pragma_buff)\n+\t\t\t\t\t      - (*pragma_buff)->base) * 2);\n+\t\t\t  (*pragma_buff)->next = next;\n+\t\t\t}\n+\t\t    }\n+\t\t  *(const cpp_token **) BUFF_FRONT (*pragma_buff) = token;\n+\t\t  BUFF_FRONT (*pragma_buff) += sizeof (cpp_token *);\n+\t\t  if (token->type == CPP_PRAGMA_EOL)\n+\t\t    break;\n+\t\t  token = cpp_get_token (pfile);\n+\t\t}\n+\t      while (token->type != CPP_EOF);\n+\n+\t      /* In deferred pragmas parsing_args and prevent_expansion\n+\t\t had been changed, reset it.  */\n+\t      pfile->state.parsing_args = 2;\n+\t      pfile->state.prevent_expansion = 1;\n+\n+\t      if (token->type == CPP_EOF)\n+\t\tbreak;\n+\t      else\n+\t\tcontinue;\n+\t    }\n \n \t  arg->first[ntokens++] = token;\n \t}\n@@ -709,9 +760,11 @@ collect_args (cpp_reader *pfile, const cpp_hashnode *node)\n /* Search for an opening parenthesis to the macro of NODE, in such a\n    way that, if none is found, we don't lose the information in any\n    intervening padding tokens.  If we find the parenthesis, collect\n-   the arguments and return the buffer containing them.  */\n+   the arguments and return the buffer containing them.  PRAGMA_BUFF\n+   argument is the same as in collect_args.  */\n static _cpp_buff *\n-funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node)\n+funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t      _cpp_buff **pragma_buff)\n {\n   const cpp_token *token, *padding = NULL;\n \n@@ -728,7 +781,7 @@ funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node)\n   if (token->type == CPP_OPEN_PAREN)\n     {\n       pfile->state.parsing_args = 2;\n-      return collect_args (pfile, node);\n+      return collect_args (pfile, node, pragma_buff);\n     }\n \n   /* CPP_EOF can be the end of macro arguments, or the end of the\n@@ -749,9 +802,13 @@ funlike_invocation_p (cpp_reader *pfile, cpp_hashnode *node)\n /* Push the context of a macro with hash entry NODE onto the context\n    stack.  If we can successfully expand the macro, we push a context\n    containing its yet-to-be-rescanned replacement list and return one.\n-   Otherwise, we don't push a context and return zero.  */\n+   If there were additionally any unexpanded deferred #pragma directives\n+   among macro arguments, push another context containing the\n+   pragma tokens before the yet-to-be-rescanned replacement list\n+   and return two.  Otherwise, we don't push a context and return zero.  */\n static int\n-enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n+enter_macro_context (cpp_reader *pfile, cpp_hashnode *node,\n+\t\t     const cpp_token *result)\n {\n   /* The presence of a macro invalidates a file's controlling macro.  */\n   pfile->mi_valid = false;\n@@ -762,6 +819,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n   if (! (node->flags & NODE_BUILTIN))\n     {\n       cpp_macro *macro = node->value.macro;\n+      _cpp_buff *pragma_buff = NULL;\n \n       if (macro->fun_like)\n \t{\n@@ -770,7 +828,7 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n \t  pfile->state.prevent_expansion++;\n \t  pfile->keep_tokens++;\n \t  pfile->state.parsing_args = 1;\n-\t  buff = funlike_invocation_p (pfile, node);\n+\t  buff = funlike_invocation_p (pfile, node, &pragma_buff);\n \t  pfile->state.parsing_args = 0;\n \t  pfile->keep_tokens--;\n \t  pfile->state.prevent_expansion--;\n@@ -782,6 +840,9 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n  \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n \t\t\t   NODE_NAME (node));\n \n+\t      if (pragma_buff)\n+\t\t_cpp_release_buff (pfile, pragma_buff);\n+\n \t      return 0;\n \t    }\n \n@@ -798,6 +859,25 @@ enter_macro_context (cpp_reader *pfile, cpp_hashnode *node)\n       if (macro->paramc == 0)\n \t_cpp_push_token_context (pfile, node, macro->exp.tokens, macro->count);\n \n+      if (pragma_buff)\n+\t{\n+\t  if (!pfile->state.in_directive)\n+\t    _cpp_push_token_context (pfile, NULL,\n+\t\t\t\t     padding_token (pfile, result), 1);\n+\t  do\n+\t    {\n+\t      _cpp_buff *tail = pragma_buff->next;\n+\t      pragma_buff->next = NULL;\n+\t      push_ptoken_context (pfile, NULL, pragma_buff,\n+\t\t\t\t   (const cpp_token **) pragma_buff->base,\n+\t\t\t\t   ((const cpp_token **) BUFF_FRONT (pragma_buff)\n+\t\t\t\t    - (const cpp_token **) pragma_buff->base));\n+\t      pragma_buff = tail;\n+\t    }\n+\t  while (pragma_buff != NULL);\n+\t  return 2;\n+\t}\n+\n       return 1;\n     }\n \n@@ -1144,14 +1224,17 @@ cpp_get_token (cpp_reader *pfile)\n \n       if (!(node->flags & NODE_DISABLED))\n \t{\n+\t  int ret;\n \t  /* If not in a macro context, and we're going to start an\n \t     expansion, record the location.  */\n \t  if (can_set && !context->macro)\n \t    pfile->invocation_location = result->src_loc;\n-\t  if (!pfile->state.prevent_expansion\n-\t      && enter_macro_context (pfile, node))\n+\t  if (pfile->state.prevent_expansion)\n+\t    break;\n+\t  ret = enter_macro_context (pfile, node, result);\n+\t  if (ret)\n \t    {\n-\t      if (pfile->state.in_directive)\n+\t      if (pfile->state.in_directive || ret == 2)\n \t\tcontinue;\n \t      return padding_token (pfile, result);\n \t    }"}]}