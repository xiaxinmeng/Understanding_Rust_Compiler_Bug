{"sha": "5a9422664e8646313278d50666e2e4c8427cd5df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5NDIyNjY0ZTg2NDYzMTMyNzhkNTA2NjZlMmU0Yzg0MjdjZDVkZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-05T21:05:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-05T21:05:38Z"}, "message": "compiler: inline call expressions and function references\n    \n    Scan inlinable methods for references to global variables and\n    functions (forgot to do that earlier).\n    \n    Track all packages mentioned by exports (that should have been done\n    earlier too).\n    \n    Record assembler name in export data, so that we can inline calls to\n    non-Go functions.  Modify gccgoimporter code to skip assembler name.\n    \n    This increases the number of inlinable functions in the standard\n    library from 215 to 439.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/180677\n\nFrom-SVN: r271976", "tree": {"sha": "d2b034aeb5116f43b6724b61e017131a3bc64a9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2b034aeb5116f43b6724b61e017131a3bc64a9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a9422664e8646313278d50666e2e4c8427cd5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9422664e8646313278d50666e2e4c8427cd5df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a9422664e8646313278d50666e2e4c8427cd5df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9422664e8646313278d50666e2e4c8427cd5df/comments", "author": null, "committer": null, "parents": [{"sha": "388aa75412ffd1d4cd10dd53d012fdcc1ed47f67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388aa75412ffd1d4cd10dd53d012fdcc1ed47f67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/388aa75412ffd1d4cd10dd53d012fdcc1ed47f67"}], "stats": {"total": 396, "additions": 345, "deletions": 51}, "files": [{"sha": "d596f02f3fef66f91ce942618efbd86fbff13afe", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -1,4 +1,4 @@\n-949c3b7aa603bc09e650d62e82c600b3463802f0\n+2609f9b8420e2341fbbe40d7cf6af42b0fba7293\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "824f821be73856e28e736a86dbec9e2c97da7b65", "filename": "gcc/go/gofrontend/export.cc", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fexport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.cc?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -133,6 +133,11 @@ Collect_references_from_inline::expression(Expression** pexpr)\n   if (fe != NULL)\n     {\n       Named_object* no = fe->named_object();\n+\n+      if (no->is_function_declaration()\n+\t  && no->func_declaration_value()->type()->is_builtin())\n+\treturn TRAVERSE_CONTINUE;\n+\n       std::pair<Unordered_set(Named_object*)::iterator, bool> ins =\n \tthis->exports_->insert(no);\n \n@@ -247,6 +252,22 @@ Export::export_globals(const std::string& package_name,\n \t  if ((*p)->is_function()\n \t      && (*p)->func_value()->export_for_inlining())\n \t    check_inline_refs.push_back(*p);\n+\t  else if ((*p)->is_type())\n+\t    {\n+\t      const Bindings* methods = (*p)->type_value()->local_methods();\n+\t      if (methods != NULL)\n+\t\t{\n+\t\t  for (Bindings::const_definitions_iterator pm =\n+\t\t\t methods->begin_definitions();\n+\t\t       pm != methods->end_definitions();\n+\t\t       ++pm)\n+\t\t    {\n+\t\t      Function* fn = (*pm)->func_value();\n+\t\t      if (fn->export_for_inlining())\n+\t\t\tcheck_inline_refs.push_back(*pm);\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -282,6 +303,9 @@ Export::export_globals(const std::string& package_name,\n \t}\n     }\n \n+  // Track all imported packages mentioned in export data.\n+  Unordered_set(const Package*) all_imports;\n+\n   // Export the symbols in sorted order.  That will reduce cases where\n   // irrelevant changes to the source code affect the exported\n   // interface.\n@@ -291,15 +315,20 @@ Export::export_globals(const std::string& package_name,\n   for (Unordered_set(Named_object*)::const_iterator p = exports.begin();\n        p != exports.end();\n        ++p)\n-    sorted_exports.push_back(*p);\n+    {\n+      sorted_exports.push_back(*p);\n+\n+      const Package* pkg = (*p)->package();\n+      if (pkg != NULL)\n+\tall_imports.insert(pkg);\n+    }\n \n   std::sort(sorted_exports.begin(), sorted_exports.end(), Sort_bindings());\n \n   // Assign indexes to all exported types and types referenced by\n   // exported types, and collect all packages mentioned.\n-  Unordered_set(const Package*) type_imports;\n   int unexported_type_index = this->prepare_types(&sorted_exports,\n-\t\t\t\t\t\t  &type_imports);\n+\t\t\t\t\t\t  &all_imports);\n \n   // Although the export data is readable, at least this version is,\n   // it is conceptually a binary format.  Start with a four byte\n@@ -327,7 +356,7 @@ Export::export_globals(const std::string& package_name,\n \n   this->write_packages(packages);\n \n-  this->write_imports(imports, type_imports);\n+  this->write_imports(imports, all_imports);\n \n   this->write_imported_init_fns(package_name, import_init_fn,\n \t\t\t\timported_init_fns);\n@@ -693,7 +722,7 @@ import_compare(const std::pair<std::string, Package*>& a,\n \n void\n Export::write_imports(const std::map<std::string, Package*>& imports,\n-\t\t      const Unordered_set(const Package*)& type_imports)\n+\t\t      const Unordered_set(const Package*)& all_imports)\n {\n   // Sort the imports for more consistent output.\n   Unordered_set(const Package*) seen;\n@@ -729,8 +758,8 @@ Export::write_imports(const std::map<std::string, Package*>& imports,\n   // Write out a separate list of indirectly imported packages.\n   std::vector<const Package*> indirect_imports;\n   for (Unordered_set(const Package*)::const_iterator p =\n-\t type_imports.begin();\n-       p != type_imports.end();\n+\t all_imports.begin();\n+       p != all_imports.end();\n        ++p)\n     {\n       if (seen.find(*p) == seen.end())"}, {"sha": "1493ddc675f7bb903d0f46703cfbf1fbf3f7a1fc", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 199, "deletions": 29, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -1356,6 +1356,29 @@ Func_expression::do_get_backend(Translate_context* context)\n   return gogo->backend()->convert_expression(btype, bexpr, this->location());\n }\n \n+// The cost of inlining a function reference.\n+\n+int\n+Func_expression::do_inlining_cost() const\n+{\n+  // FIXME: We don't inline references to nested functions.\n+  if (this->closure_ != NULL)\n+    return 0x100000;\n+  if (this->function_->is_function()\n+      && this->function_->func_value()->enclosing() != NULL)\n+    return 0x100000;\n+\n+  return 1;\n+}\n+\n+// Export a reference to a function.\n+\n+void\n+Func_expression::do_export(Export_function_body* efb) const\n+{\n+  Expression::export_name(efb, this->function_);\n+}\n+\n // Ast dump for function.\n \n void\n@@ -10088,38 +10111,82 @@ void\n Builtin_call_expression::do_export(Export_function_body* efb) const\n {\n   Numeric_constant nc;\n-  if (!this->numeric_constant_value(&nc))\n+  if (this->numeric_constant_value(&nc))\n     {\n-      go_error_at(this->location(), \"value is not constant\");\n-      return;\n-    }\n+      if (nc.is_int())\n+\t{\n+\t  mpz_t val;\n+\t  nc.get_int(&val);\n+\t  Integer_expression::export_integer(efb, val);\n+\t  mpz_clear(val);\n+\t}\n+      else if (nc.is_float())\n+\t{\n+\t  mpfr_t fval;\n+\t  nc.get_float(&fval);\n+\t  Float_expression::export_float(efb, fval);\n+\t  mpfr_clear(fval);\n+\t}\n+      else if (nc.is_complex())\n+\t{\n+\t  mpc_t cval;\n+\t  nc.get_complex(&cval);\n+\t  Complex_expression::export_complex(efb, cval);\n+\t  mpc_clear(cval);\n+\t}\n+      else\n+\tgo_unreachable();\n \n-  if (nc.is_int())\n-    {\n-      mpz_t val;\n-      nc.get_int(&val);\n-      Integer_expression::export_integer(efb, val);\n-      mpz_clear(val);\n+      // A trailing space lets us reliably identify the end of the number.\n+      efb->write_c_string(\" \");\n     }\n-  else if (nc.is_float())\n-    {\n-      mpfr_t fval;\n-      nc.get_float(&fval);\n-      Float_expression::export_float(efb, fval);\n-      mpfr_clear(fval);\n-    }\n-  else if (nc.is_complex())\n+  else\n     {\n-      mpc_t cval;\n-      nc.get_complex(&cval);\n-      Complex_expression::export_complex(efb, cval);\n-      mpc_clear(cval);\n+      const char *s = NULL;\n+      switch (this->code_)\n+\t{\n+\tdefault:\n+\t  go_unreachable();\n+\tcase BUILTIN_APPEND:\n+\t  s = \"append\";\n+\t  break;\n+\tcase BUILTIN_COPY:\n+\t  s = \"copy\";\n+\t  break;\n+\tcase BUILTIN_LEN:\n+\t  s = \"len\";\n+\t  break;\n+\tcase BUILTIN_CAP:\n+\t  s = \"cap\";\n+\t  break;\n+\tcase BUILTIN_PRINT:\n+\t  s = \"print\";\n+\t  break;\n+\tcase BUILTIN_PRINTLN:\n+\t  s = \"println\";\n+\t  break;\n+\tcase BUILTIN_PANIC:\n+\t  s = \"panic\";\n+\t  break;\n+\tcase BUILTIN_RECOVER:\n+\t  s = \"recover\";\n+\t  break;\n+\tcase BUILTIN_CLOSE:\n+\t  s = \"close\";\n+\t  break;\n+\tcase BUILTIN_REAL:\n+\t  s = \"real\";\n+\t  break;\n+\tcase BUILTIN_IMAG:\n+\t  s = \"imag\";\n+\t  break;\n+\tcase BUILTIN_COMPLEX:\n+\t  s = \"complex\";\n+\t  break;\n+\t}\n+      efb->write_c_string(s);\n+      this->export_arguments(efb);\n     }\n-  else\n-    go_unreachable();\n-\n-  // A trailing space lets us reliably identify the end of the number.\n-  efb->write_c_string(\" \");\n }\n \n // Class Call_expression.\n@@ -11637,7 +11704,55 @@ Call_expression::do_get_backend(Translate_context* context)\n   return this->call_;\n }\n \n-// Dump ast representation for a call expressin.\n+// The cost of inlining a call expression.\n+\n+int\n+Call_expression::do_inlining_cost() const\n+{\n+  Func_expression* fn = this->fn_->func_expression();\n+\n+  // FIXME: We don't yet support all kinds of calls.\n+  if (fn != NULL && fn->closure() != NULL)\n+    return 0x100000;\n+  if (this->fn_->interface_field_reference_expression())\n+    return 0x100000;\n+  if (this->get_function_type()->is_method())\n+    return 0x100000;\n+\n+  return 5;\n+}\n+\n+// Export a call expression.\n+\n+void\n+Call_expression::do_export(Export_function_body* efb) const\n+{\n+  this->fn_->export_expression(efb);\n+  this->export_arguments(efb);\n+}\n+\n+// Export call expression arguments.\n+\n+void\n+Call_expression::export_arguments(Export_function_body* efb) const\n+{\n+  efb->write_c_string(\"(\");\n+  if (this->args_ != NULL && !this->args_->empty())\n+    {\n+      Expression_list::const_iterator pa = this->args_->begin();\n+      (*pa)->export_expression(efb);\n+      for (pa++; pa != this->args_->end(); pa++)\n+\t{\n+\t  efb->write_c_string(\", \");\n+\t  (*pa)->export_expression(efb);\n+\t}\n+      if (this->is_varargs_)\n+\tefb->write_c_string(\"...\");\n+    }\n+  efb->write_c_string(\")\");\n+}\n+\n+// Dump ast representation for a call expression.\n \n void\n Call_expression::do_dump_expression(Ast_dump_context* ast_dump_context) const\n@@ -17522,6 +17637,47 @@ Expression::make_backend(Bexpression* bexpr, Type* type, Location location)\n \n Expression*\n Expression::import_expression(Import_expression* imp, Location loc)\n+{\n+  Expression* expr = Expression::import_expression_without_suffix(imp, loc);\n+  while (true)\n+    {\n+      if (imp->match_c_string(\"(\"))\n+\t{\n+\t  imp->advance(1);\n+\t  Expression_list* args = new Expression_list();\n+\t  bool is_varargs = false;\n+\t  while (!imp->match_c_string(\")\"))\n+\t    {\n+\t      Expression* arg = Expression::import_expression(imp, loc);\n+\t      if (arg->is_error_expression())\n+\t\treturn arg;\n+\t      args->push_back(arg);\n+\t      if (imp->match_c_string(\")\"))\n+\t\tbreak;\n+\t      else if (imp->match_c_string(\"...)\"))\n+\t\t{\n+\t\t  imp->advance(3);\n+\t\t  is_varargs = true;\n+\t\t  break;\n+\t\t}\n+\t      imp->require_c_string(\", \");\n+\t    }\n+\t  imp->require_c_string(\")\");\n+\t  expr = Expression::make_call(expr, args, is_varargs, loc);\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  return expr;\n+}\n+\n+// Import an expression without considering a suffix (function\n+// arguments, index operations, etc.).\n+\n+Expression*\n+Expression::import_expression_without_suffix(Import_expression* imp,\n+\t\t\t\t\t     Location loc)\n {\n   int c = imp->peek_char();\n   if (c == '+' || c == '-' || c == '!' || c == '^' || c == '&' || c == '*')\n@@ -17608,7 +17764,21 @@ Expression::import_identifier(Import_function_body* ifb, Location loc)\n       return Expression::make_error(loc);\n     }\n \n-  return Expression::make_var_reference(no, loc);\n+  if (no->is_variable() || no->is_result_variable())\n+    return Expression::make_var_reference(no, loc);\n+  else if (no->is_function() || no->is_function_declaration())\n+    return Expression::make_func_reference(no, NULL, loc);\n+  else\n+    {\n+      if (!ifb->saw_error())\n+\tgo_error_at(ifb->location(),\n+\t\t    (\"import error for %qs: \"\n+\t\t     \"unexpected type of identifier %qs (%d)\"),\n+\t\t    ifb->name().c_str(),\n+\t\t    id.c_str(), no->classification());\n+      ifb->set_saw_error();\n+      return Expression::make_error(loc);\n+    }\n }\n \n // Class Expression_list."}, {"sha": "fc1c5a80ff80d4b3c683c4c0f7677f047aeabe99", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -1253,6 +1253,9 @@ class Expression\n   static Expression*\n   import_identifier(Import_function_body*, Location);\n \n+  static Expression*\n+  import_expression_without_suffix(Import_expression*, Location);\n+\n   // The expression classification.\n   Expression_classification classification_;\n   // The location in the input file.\n@@ -2409,6 +2412,12 @@ class Call_expression : public Expression\n   virtual Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const;\n+\n+  void\n+  do_export(Export_function_body*) const;\n+\n   virtual bool\n   do_is_recover_call() const;\n \n@@ -2431,6 +2440,9 @@ class Call_expression : public Expression\n   bool\n   determining_types();\n \n+  void\n+  export_arguments(Export_function_body*) const;\n+\n   void\n   do_dump_expression(Ast_dump_context*) const;\n \n@@ -2571,6 +2583,10 @@ class Builtin_call_expression : public Call_expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const\n+  { return 1; }\n+\n   void\n   do_export(Export_function_body*) const;\n \n@@ -2745,6 +2761,12 @@ class Func_expression : public Expression\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n+  int\n+  do_inlining_cost() const;\n+\n+  void\n+  do_export(Export_function_body*) const;\n+\n   void\n   do_dump_expression(Ast_dump_context*) const;\n "}, {"sha": "6e8ccbba226a3e611d22a5aa31d3e18947f6cc6d", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -5059,6 +5059,9 @@ Mark_inline_candidates::type(Type* t)\n void\n Gogo::do_exports()\n {\n+  if (saw_errors())\n+    return;\n+\n   // Mark any functions whose body should be exported for inlining by\n   // other packages.\n   Mark_inline_candidates mic;\n@@ -5690,7 +5693,7 @@ Function::export_func(Export* exp, const Named_object* no) const\n     block = this->block_;\n   Function::export_func_with_type(exp, no, this->type_, this->results_,\n \t\t\t\t  this->is_method() && this->nointerface(),\n-\t\t\t\t  block, this->location_);\n+\t\t\t\t  this->asm_name(), block, this->location_);\n }\n \n // Export a function with a type.\n@@ -5699,7 +5702,8 @@ void\n Function::export_func_with_type(Export* exp, const Named_object* no,\n \t\t\t\tconst Function_type* fntype,\n \t\t\t\tFunction::Results* result_vars,\n-\t\t\t\tbool nointerface, Block* block, Location loc)\n+\t\t\t\tbool nointerface, const std::string& asm_name,\n+\t\t\t\tBlock* block, Location loc)\n {\n   exp->write_c_string(\"func \");\n \n@@ -5709,6 +5713,13 @@ Function::export_func_with_type(Export* exp, const Named_object* no,\n       exp->write_c_string(\"/*nointerface*/ \");\n     }\n \n+  if (!asm_name.empty())\n+    {\n+      exp->write_c_string(\"/*asm \");\n+      exp->write_string(asm_name);\n+      exp->write_c_string(\" */ \");\n+    }\n+\n   if (fntype->is_method())\n     {\n       exp->write_c_string(\"(\");\n@@ -5848,16 +5859,37 @@ Function::import_func(Import* imp, std::string* pname,\n \t\t      Typed_identifier_list** presults,\n \t\t      bool* is_varargs,\n \t\t      bool* nointerface,\n+\t\t      std::string* asm_name,\n \t\t      std::string* body)\n {\n   imp->require_c_string(\"func \");\n \n   *nointerface = false;\n-  if (imp->match_c_string(\"/*\"))\n+  while (imp->match_c_string(\"/*\"))\n     {\n-      imp->require_c_string(\"/*nointerface*/ \");\n-      *nointerface = true;\n+      imp->advance(2);\n+      if (imp->match_c_string(\"nointerface\"))\n+\t{\n+\t  imp->require_c_string(\"nointerface*/ \");\n+\t  *nointerface = true;\n+\t}\n+      else if (imp->match_c_string(\"asm\"))\n+\t{\n+\t  imp->require_c_string(\"asm \");\n+\t  *asm_name = imp->read_identifier();\n+\t  imp->require_c_string(\" */ \");\n+\t}\n+      else\n+\t{\n+\t  go_error_at(imp->location(),\n+\t\t      \"import error at %d: unrecognized function comment\",\n+\t\t      imp->pos());\n+\t  return false;\n+\t}\n+    }\n \n+  if (*nointerface)\n+    {\n       // Only a method can be nointerface.\n       go_assert(imp->peek_char() == '(');\n     }\n@@ -7158,6 +7190,8 @@ Function_declaration::import_function_body(Gogo* gogo, Named_object* no)\n       Named_type* rtype = fntype->receiver()->type()->deref()->named_type();\n       go_assert(rtype != NULL);\n       no = rtype->add_method(no->name(), fn);\n+      const Package* package = rtype->named_object()->package();\n+      package->bindings()->add_method(no);\n     }\n \n   Import_function_body ifb(gogo, this->imp_, no, body, nl + 1, outer, indent);"}, {"sha": "11974764c4ef63dee7c3b0469b6ab5824306dd37", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -1573,15 +1573,15 @@ class Function\n   static void\n   export_func_with_type(Export*, const Named_object*,\n \t\t\tconst Function_type*, Results*, bool nointerface,\n-\t\t\tBlock* block, Location);\n+\t\t\tconst std::string& asm_name, Block* block, Location);\n \n   // Import a function.  Reports whether the import succeeded.\n   static bool\n   import_func(Import*, std::string* pname, Package** pkg,\n \t      bool* is_exported, Typed_identifier** receiver,\n \t      Typed_identifier_list** pparameters,\n \t      Typed_identifier_list** presults, bool* is_varargs,\n-\t      bool* nointerface, std::string* body);\n+\t      bool* nointerface, std::string* asm_name, std::string* body);\n \n  private:\n   // Type for mapping from label names to Label objects.\n@@ -1805,7 +1805,7 @@ class Function_declaration\n   {\n     Function::export_func_with_type(exp, no, this->fntype_, NULL,\n \t\t\t\t    this->is_method() && this->nointerface(),\n-\t\t\t\t    NULL, this->location_);\n+\t\t\t\t    this->asm_name_, NULL, this->location_);\n   }\n \n   // Check that the types used in this declaration's signature are defined."}, {"sha": "1c3f4a498b5f5cdefaba21626e7a6a8aef7cedff", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -757,10 +757,11 @@ Import::import_func(Package* package)\n   Typed_identifier_list* results;\n   bool is_varargs;\n   bool nointerface;\n+  std::string asm_name;\n   std::string body;\n   if (!Function::import_func(this, &name, &fpkg, &is_exported, &receiver,\n \t\t\t     &parameters, &results, &is_varargs, &nointerface,\n-\t\t\t     &body))\n+\t\t\t     &asm_name, &body))\n     return;\n   if (fpkg == NULL)\n     fpkg = package;\n@@ -802,12 +803,14 @@ Import::import_func(Package* package)\n   else\n     {\n       no = fpkg->add_function_declaration(name, fntype, loc);\n-      if (this->add_to_globals_)\n+      if (this->add_to_globals_ && fpkg == package)\n \tthis->gogo_->add_dot_import_object(no);\n     }\n \n   if (nointerface)\n     no->func_declaration_value()->set_nointerface();\n+  if (!asm_name.empty())\n+    no->func_declaration_value()->set_asm_name(asm_name);\n   if (!body.empty() && !no->func_declaration_value()->has_imported_body())\n     no->func_declaration_value()->set_imported_body(this, body);\n }\n@@ -1231,6 +1234,12 @@ Import::register_builtin_type(Gogo* gogo, const char* name, Builtin_code code)\n   this->builtin_types_[index] = named_object->type_value();\n }\n \n+// Characters that stop read_identifier.  We base this on the\n+// characters that stop an identifier, without worrying about\n+// characters that are permitted in an identifier.  That lets us skip\n+// UTF-8 parsing.\n+static const char * const identifier_stop = \" \\n;,()[]\";\n+\n // Read an identifier from the stream.\n \n std::string\n@@ -1242,8 +1251,14 @@ Import::read_identifier()\n   while (true)\n     {\n       c = stream->peek_char();\n-      if (c == -1 || c == ' ' || c == '\\n' || c == ';' || c == ')')\n+      if (c == -1 || strchr(identifier_stop, c) != NULL)\n \tbreak;\n+\n+      // FIXME: Probably we shouldn't accept '.', but that might break\n+      // some existing imports.\n+      if (c == '.' && stream->match_c_string(\"...\"))\n+\tbreak;\n+\n       ret += c;\n       stream->advance(1);\n     }\n@@ -1521,7 +1536,18 @@ Import_function_body::read_identifier()\n   for (size_t i = start; i < this->body_.length(); i++)\n     {\n       int c = static_cast<unsigned char>(this->body_[i]);\n-      if (c == ' ' || c == '\\n' || c == ';' || c == ')')\n+      if (strchr(identifier_stop, c) != NULL)\n+\t{\n+\t  this->off_ = i;\n+\t  return this->body_.substr(start, i - start);\n+\t}\n+\n+      // FIXME: Probably we shouldn't accept '.', but that might break\n+      // some existing imports.\n+      if (c == '.'\n+\t  && i + 2 < this->body_.length()\n+\t  && this->body_[i + 1] == '.'\n+\t  && this->body_[i + 2] == '.')\n \t{\n \t  this->off_ = i;\n \t  return this->body_.substr(start, i - start);"}, {"sha": "956a9a85c10b13c5224a5a94b43938da351b149f", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9422664e8646313278d50666e2e4c8427cd5df/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9422664e8646313278d50666e2e4c8427cd5df/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=5a9422664e8646313278d50666e2e4c8427cd5df", "patch": "@@ -539,10 +539,12 @@ func (p *parser) parseNamedType(nlist []int) types.Type {\n \t\tfor p.tok == scanner.Ident {\n \t\t\tp.expectKeyword(\"func\")\n \t\t\tif p.tok == '/' {\n-\t\t\t\t// Skip a /*nointerface*/ comment.\n+\t\t\t\t// Skip a /*nointerface*/ or /*asm ID */ comment.\n \t\t\t\tp.expect('/')\n \t\t\t\tp.expect('*')\n-\t\t\t\tp.expect(scanner.Ident)\n+\t\t\t\tif p.expect(scanner.Ident) == \"asm\" {\n+\t\t\t\t\tp.parseUnquotedString()\n+\t\t\t\t}\n \t\t\t\tp.expect('*')\n \t\t\t\tp.expect('/')\n \t\t\t}\n@@ -727,6 +729,17 @@ func (p *parser) parseFunctionType(pkg *types.Package, nlist []int) *types.Signa\n \n // Func = Name FunctionType [InlineBody] .\n func (p *parser) parseFunc(pkg *types.Package) *types.Func {\n+\tif p.tok == '/' {\n+\t\t// Skip an /*asm ID */ comment.\n+\t\tp.expect('/')\n+\t\tp.expect('*')\n+\t\tif p.expect(scanner.Ident) == \"asm\" {\n+\t\t\tp.parseUnquotedString()\n+\t\t}\n+\t\tp.expect('*')\n+\t\tp.expect('/')\n+\t}\n+\n \tname := p.parseName()\n \tif strings.ContainsRune(name, '$') {\n \t\t// This is a Type$equal or Type$hash function, which we don't want to parse,"}]}