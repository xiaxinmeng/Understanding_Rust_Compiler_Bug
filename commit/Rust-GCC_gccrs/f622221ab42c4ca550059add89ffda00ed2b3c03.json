{"sha": "f622221ab42c4ca550059add89ffda00ed2b3c03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyMjIyMWFiNDJjNGNhNTUwMDU5YWRkODlmZmRhMDBlZDJiM2MwMw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-01-05T19:01:12Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-01-05T19:01:12Z"}, "message": "PR 78534 Change character length from int to size_t\n\nIn order to handle large character lengths on (L)LP64 targets, switch\nthe GFortran character length from an int to a size_t.\n\nThis is an ABI change, as procedures with character arguments take\nhidden arguments with the character length.\n\nI also changed the _size member in vtables from int to size_t, as\nthere were some cases where character lengths and sizes were\napparently mixed up and caused regressions otherwise. Although I\nhaven't tested, this might enable very large derived types as well.\n\nAlso, as there are some places in the frontend were negative character\nlengths are used as special flag values, in the frontend the character\nlength is handled as a signed variable of the same size as a size_t,\nalthough in the runtime library it really is size_t.\n\nI haven't changed the character length variables for the co-array\nintrinsics, as this is something that may need to be synchronized with\nOpenCoarrays.\n\nThis is v5 of the patch. v4 was applied but caused breakage on big\nendian targets. These have been fixed and tested, thanks to access to\nthe GCC compile farm.\n\nOverview of v4 of the patch: v3 was applied but had to reverted due to\nbreaking bootstrap. The fix is in resolve.c:resolve_charlen, where\nit's necessary to check that an expression is constant before using\nmpz_sgn.\n\nOverview of v3 of the patch: All the issues pointed out by FX's review\nof v2 have been fixed. In particular, there are now new functions\ngfc_mpz_get_hwi and gfc_mpz_set_hwi, similar to the GMP functions\nmpz_get_si and mpz_set_si, except that they get/set a HOST_WIDE_INT\ninstead of a long value. Similarly, gfc_get_int_expr now takes a\nHOST_WIDE_INT instead of a long, gfc_extract_long is replaced by\ngfc_extract_hwi. Also, the preliminary work to handle\ngfc_charlen_type_node being unsigned has been removed.\n\nRegtested on x86_64-pc-linux-gnu, i686-pc-linux-gnu and\npowerpc64-unknown-linux-gnu. Also regtested all three targets by\nmodifying gfortran-dg.exp to also test with \"-g -flto\", no new\nfailures observed.\n\nfrontend:\n\n2018-01-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/78534\n\tPR fortran/66310\n\t* array.c (got_charlen): Use gfc_charlen_int_kind.\n\t* class.c (gfc_find_derived_vtab): Use gfc_size_kind instead of\n\thardcoded kind.\n\t(find_intrinsic_vtab): Likewise.\n\t* decl.c (match_char_length): Use gfc_charlen_int_kind.\n\t(add_init_expr_to_sym): Use gfc_charlen_t and gfc_charlen_int_kind.\n\t(gfc_match_implicit): Use gfc_charlen_int_kind.\n\t* dump-parse-tree.c (show_char_const): Use gfc_charlen_t and size_t.\n\t(show_expr): Use HOST_WIDE_INT_PRINT_DEC.\n\t* expr.c (gfc_get_character_expr): Length parameter of type\n\tgfc_charlen_t.\n\t(gfc_get_int_expr): Value argument of type HOST_WIDE_INT.\n\t(gfc_extract_hwi): New function.\n\t(simplify_const_ref): Make string_len of type gfc_charlen_t.\n\t(gfc_simplify_expr): Use HOST_WIDE_INT for substring refs.\n\t* frontend-passes.c (optimize_trim): Use gfc_charlen_int_kind.\n\t* gfortran.h (gfc_mpz_get_hwi): New prototype.\n\t(gfc_mpz_set_hwi): Likewise.\n\t(gfc_charlen_t): New typedef.\n\t(gfc_expr): Use gfc_charlen_t for character lengths.\n\t(gfc_size_kind): New extern variable.\n\t(gfc_extract_hwi): New prototype.\n\t(gfc_get_character_expr): Use gfc_charlen_t for character length.\n\t(gfc_get_int_expr): Use HOST_WIDE_INT type for value argument.\n\t* gfortran.texi: Update description of hidden string length argument.\n\t* iresolve.c (check_charlen_present): Use gfc_charlen_int_kind.\n\t(gfc_resolve_char_achar): Likewise.\n\t(gfc_resolve_repeat): Pass string length directly without\n\ttemporary, use gfc_charlen_int_kind.\n\t(gfc_resolve_transfer): Use gfc_charlen_int_kind.\n\t* match.c (select_intrinsic_set_tmp): Use HOST_WIDE_INT for charlen.\n\t* misc.c (gfc_mpz_get_hwi): New function.\n\t(gfc_mpz_set_hwi): New function.\n\t* module.c (atom_int): Change type from int to HOST_WIDE_INT.\n\t(parse_integer): Don't complain about large integers.\n\t(write_atom): Use HOST_WIDE_INT for integers.\n\t(mio_integer): Handle integer type mismatch.\n\t(mio_hwi): New function.\n\t(mio_intrinsic_op): Use HOST_WIDE_INT.\n\t(mio_array_ref): Likewise.\n\t(mio_expr): Likewise.\n\t* primary.c (match_substring): Use gfc_charlen_int_kind.\n\t* resolve.c (resolve_substring_charlen): Use gfc_charlen_int_kind.\n\t(resolve_character_operator): Likewise.\n\t(resolve_assoc_var): Likewise.\n\t(resolve_select_type): Use HOST_WIDE_INT for charlen, use snprintf.\n\t(resolve_charlen): Use mpz_sgn to determine sign.\n\t* simplify.c (gfc_simplify_repeat): Use HOST_WIDE_INT/gfc_charlen_t\n\tinstead of long.\n\t* symbol.c (generate_isocbinding_symbol): Use gfc_charlen_int_kind.\n\t* target-memory.c (size_character): Length argument of type\n\tgfc_charlen_t.\n\t(gfc_encode_character): Likewise.\n\t(gfc_interpret_character): Use gfc_charlen_t.\n\t* target-memory.h (gfc_encode_character): Modify prototype.\n\t* trans-array.c (gfc_trans_array_ctor_element): Use existing type.\n\t(get_array_ctor_var_strlen): Use gfc_conv_mpz_to_tree_type.\n\t(trans_array_constructor): Use existing type.\n\t(get_array_charlen): Likewise.\n\t* trans-const.c (gfc_conv_mpz_to_tree_type): New function.\n\t* trans-const.h (gfc_conv_mpz_to_tree_type): New prototype.\n\t* trans-decl.c (gfc_trans_deferred_vars): Use existing type.\n\t(add_argument_checking): Likewise.\n\t* trans-expr.c (gfc_class_len_or_zero_get): Build const of type\n\tgfc_charlen_type_node.\n\t(gfc_conv_intrinsic_to_class): Use gfc_charlen_int_kind instead of\n\t4, fold_convert to correct type.\n\t(gfc_conv_class_to_class): Build const of type size_type_node for\n\tsize.\n\t(gfc_copy_class_to_class): Likewise.\n\t(gfc_conv_string_length): Use same type in expression.\n\t(gfc_conv_substring): Likewise, use HOST_WIDE_INT for charlen.\n\t(gfc_conv_string_tmp): Make sure len is of the right type.\n\t(gfc_conv_concat_op): Use same type in expression.\n\t(gfc_conv_procedure_call): Likewise.\n\t(fill_with_spaces): Comment out memset() block due to spurious\n\t-Wstringop-overflow warnings.\n\t(gfc_trans_string_copy): Use gfc_charlen_type_node.\n\t(alloc_scalar_allocatable_for_subcomponent_assignment):\n\tfold_convert to right type.\n\t(gfc_trans_subcomponent_assign): Likewise.\n\t(trans_class_vptr_len_assignment): Build const of correct type.\n\t(gfc_trans_pointer_assignment): Likewise.\n\t(alloc_scalar_allocatable_for_assignment): fold_convert to right\n\ttype in expr.\n\t(trans_class_assignment): Build const of correct type.\n\t* trans-intrinsic.c (gfc_conv_associated): Likewise.\n\t(gfc_conv_intrinsic_repeat): Do calculation in sizetype.\n\t* trans-io.c (gfc_build_io_library_fndecls): Use\n\tgfc_charlen_type_node for character lengths.\n\t(set_string): Convert to right type in assignment.\n\t* trans-stmt.c (gfc_trans_label_assign): Build const of\n\tgfc_charlen_type_node.\n\t(trans_associate_var): Likewise.\n\t(gfc_trans_character_select): Likewise.\n\t(gfc_trans_allocate): Likewise, don't typecast strlen result.\n\t(gfc_trans_deallocate): Don't typecast strlen result.\n\t* trans-types.c (gfc_size_kind): New variable.\n\t(gfc_init_types): Determine gfc_charlen_int_kind and gfc_size_kind\n\tfrom size_type_node.\n\t* trans-types.h: Fix comment.\n\ntestsuite:\n\n2018-01-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/78534\n\tPR fortran/66310\n\t* gfortran.dg/char_cast_1.f90: Update scan pattern.\n\t* gfortran.dg/dependency_49.f90: Likewise.\n\t* gfortran.dg/repeat_4.f90: Use integers of kind C_SIZE_T.\n\t* gfortran.dg/repeat_7.f90: New test for PR 66310.\n\t* gfortran.dg/scan_2.f90: Handle potential cast in assignment.\n\t* gfortran.dg/string_1.f90: Limit to ilp32 targets.\n\t* gfortran.dg/string_1_lp64.f90: New test.\n\t* gfortran.dg/string_3.f90: Limit to ilp32 targets.\n\t* gfortran.dg/string_3_lp64.f90: New test.\n\nlibgfortran:\n\n2019-01-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/78534\n\t* intrinsics/args.c (getarg_i4): Use gfc_charlen_type.\n\t(get_command_argument_i4): Likewise.\n\t(get_command_i4): Likewise.\n\t* intrinsics/chmod.c (chmod_internal): Likewise.\n\t* intrinsics/env.c (get_environment_variable_i4): Likewise.\n\t* intrinsics/extends_type_of.c (struct vtype): Use size_t for size\n\tmember.\n\t* intrinsics/gerror.c (gerror): Use gfc_charlen_type.\n\t* intrinsics/getlog.c (getlog): Likewise.\n\t* intrinsics/hostnm.c (hostnm_0): Likewise.\n\t* intrinsics/string_intrinsics_inc.c (string_len_trim): Rework to\n\twork if gfc_charlen_type is unsigned.\n\t(string_scan): Likewise.\n\t* io/transfer.c (transfer_character): Modify prototype.\n\t(transfer_character_write): Likewise.\n\t(transfer_character_wide): Likewise.\n\t(transfer_character_wide_write): Likewise.\n\t(transfer_array): Typecast to avoid signed-unsigned comparison.\n\t* io/unit.c (is_trim_ok): Use gfc_charlen_type.\n\t* io/write.c (namelist_write): Likewise.\n\t* libgfortran.h (gfc_charlen_type): Change typedef to size_t.\n\nFrom-SVN: r256284", "tree": {"sha": "4454a0a3d03bcd3cfe58b17e94ff9ef876078864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4454a0a3d03bcd3cfe58b17e94ff9ef876078864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f622221ab42c4ca550059add89ffda00ed2b3c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f622221ab42c4ca550059add89ffda00ed2b3c03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f622221ab42c4ca550059add89ffda00ed2b3c03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f622221ab42c4ca550059add89ffda00ed2b3c03/comments", "author": null, "committer": null, "parents": [{"sha": "388058dd06b26e8f55d315b3c49b707d51c7a089", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/388058dd06b26e8f55d315b3c49b707d51c7a089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/388058dd06b26e8f55d315b3c49b707d51c7a089"}], "stats": {"total": 871, "additions": 609, "deletions": 262}, "files": [{"sha": "b001a8a1845a1b792b28550ae7dc639dd1312a0a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -1,3 +1,109 @@\n+2018-01-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/78534\n+\tPR fortran/66310\n+\t* array.c (got_charlen): Use gfc_charlen_int_kind.\n+\t* class.c (gfc_find_derived_vtab): Use gfc_size_kind instead of\n+\thardcoded kind.\n+\t(find_intrinsic_vtab): Likewise.\n+\t* decl.c (match_char_length): Use gfc_charlen_int_kind.\n+\t(add_init_expr_to_sym): Use gfc_charlen_t and gfc_charlen_int_kind.\n+\t(gfc_match_implicit): Use gfc_charlen_int_kind.\n+\t* dump-parse-tree.c (show_char_const): Use gfc_charlen_t and size_t.\n+\t(show_expr): Use HOST_WIDE_INT_PRINT_DEC.\n+\t* expr.c (gfc_get_character_expr): Length parameter of type\n+\tgfc_charlen_t.\n+\t(gfc_get_int_expr): Value argument of type HOST_WIDE_INT.\n+\t(gfc_extract_hwi): New function.\n+\t(simplify_const_ref): Make string_len of type gfc_charlen_t.\n+\t(gfc_simplify_expr): Use HOST_WIDE_INT for substring refs.\n+\t* frontend-passes.c (optimize_trim): Use gfc_charlen_int_kind.\n+\t* gfortran.h (gfc_mpz_get_hwi): New prototype.\n+\t(gfc_mpz_set_hwi): Likewise.\n+\t(gfc_charlen_t): New typedef.\n+\t(gfc_expr): Use gfc_charlen_t for character lengths.\n+\t(gfc_size_kind): New extern variable.\n+\t(gfc_extract_hwi): New prototype.\n+\t(gfc_get_character_expr): Use gfc_charlen_t for character length.\n+\t(gfc_get_int_expr): Use HOST_WIDE_INT type for value argument.\n+\t* gfortran.texi: Update description of hidden string length argument.\n+\t* iresolve.c (check_charlen_present): Use gfc_charlen_int_kind.\n+\t(gfc_resolve_char_achar): Likewise.\n+\t(gfc_resolve_repeat): Pass string length directly without\n+\ttemporary, use gfc_charlen_int_kind.\n+\t(gfc_resolve_transfer): Use gfc_charlen_int_kind.\n+\t* match.c (select_intrinsic_set_tmp): Use HOST_WIDE_INT for charlen.\n+\t* misc.c (gfc_mpz_get_hwi): New function.\n+\t(gfc_mpz_set_hwi): New function.\n+\t* module.c (atom_int): Change type from int to HOST_WIDE_INT.\n+\t(parse_integer): Don't complain about large integers.\n+\t(write_atom): Use HOST_WIDE_INT for integers.\n+\t(mio_integer): Handle integer type mismatch.\n+\t(mio_hwi): New function.\n+\t(mio_intrinsic_op): Use HOST_WIDE_INT.\n+\t(mio_array_ref): Likewise.\n+\t(mio_expr): Likewise.\n+\t* primary.c (match_substring): Use gfc_charlen_int_kind.\n+\t* resolve.c (resolve_substring_charlen): Use gfc_charlen_int_kind.\n+\t(resolve_character_operator): Likewise.\n+\t(resolve_assoc_var): Likewise.\n+\t(resolve_select_type): Use HOST_WIDE_INT for charlen, use snprintf.\n+\t(resolve_charlen): Use mpz_sgn to determine sign.\n+\t* simplify.c (gfc_simplify_repeat): Use HOST_WIDE_INT/gfc_charlen_t\n+\tinstead of long.\n+\t* symbol.c (generate_isocbinding_symbol): Use gfc_charlen_int_kind.\n+\t* target-memory.c (size_character): Length argument of type\n+\tgfc_charlen_t.\n+\t(gfc_encode_character): Likewise.\n+\t(gfc_interpret_character): Use gfc_charlen_t.\n+\t* target-memory.h (gfc_encode_character): Modify prototype.\n+\t* trans-array.c (gfc_trans_array_ctor_element): Use existing type.\n+        (get_array_ctor_var_strlen): Use gfc_conv_mpz_to_tree_type.\n+\t(trans_array_constructor): Use existing type.\n+\t(get_array_charlen): Likewise.\n+\t* trans-const.c (gfc_conv_mpz_to_tree_type): New function.\n+\t* trans-const.h (gfc_conv_mpz_to_tree_type): New prototype.\n+\t* trans-decl.c (gfc_trans_deferred_vars): Use existing type.\n+\t(add_argument_checking): Likewise.\n+\t* trans-expr.c (gfc_class_len_or_zero_get): Build const of type\n+\tgfc_charlen_type_node.\n+\t(gfc_conv_intrinsic_to_class): Use gfc_charlen_int_kind instead of\n+\t4, fold_convert to correct type.\n+\t(gfc_conv_class_to_class): Build const of type size_type_node for\n+\tsize.\n+\t(gfc_copy_class_to_class): Likewise.\n+\t(gfc_conv_string_length): Use same type in expression.\n+\t(gfc_conv_substring): Likewise, use HOST_WIDE_INT for charlen.\n+\t(gfc_conv_string_tmp): Make sure len is of the right type.\n+\t(gfc_conv_concat_op): Use same type in expression.\n+\t(gfc_conv_procedure_call): Likewise.\n+\t(fill_with_spaces): Comment out memset() block due to spurious\n+\t-Wstringop-overflow warnings.\n+\t(gfc_trans_string_copy): Use gfc_charlen_type_node.\n+\t(alloc_scalar_allocatable_for_subcomponent_assignment):\n+\tfold_convert to right type.\n+\t(gfc_trans_subcomponent_assign): Likewise.\n+\t(trans_class_vptr_len_assignment): Build const of correct type.\n+\t(gfc_trans_pointer_assignment): Likewise.\n+\t(alloc_scalar_allocatable_for_assignment): fold_convert to right\n+\ttype in expr.\n+\t(trans_class_assignment): Build const of correct type.\n+\t* trans-intrinsic.c (gfc_conv_associated): Likewise.\n+\t(gfc_conv_intrinsic_repeat): Do calculation in sizetype.\n+\t* trans-io.c (gfc_build_io_library_fndecls): Use\n+\tgfc_charlen_type_node for character lengths.\n+\t(set_string): Convert to right type in assignment.\n+\t* trans-stmt.c (gfc_trans_label_assign): Build const of\n+\tgfc_charlen_type_node.\n+\t(trans_associate_var): Likewise.\n+\t(gfc_trans_character_select): Likewise.\n+\t(gfc_trans_allocate): Likewise, don't typecast strlen result.\n+\t(gfc_trans_deallocate): Don't typecast strlen result.\n+\t* trans-types.c (gfc_size_kind): New variable.\n+\t(gfc_init_types): Determine gfc_charlen_int_kind and gfc_size_kind\n+\tfrom size_type_node.\n+\t* trans-types.h: Fix comment.\n+\n 2018-01-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/83683"}, {"sha": "882fe577b76611570f4a87b640e5c4f972bf1d14", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -2039,7 +2039,7 @@ gfc_resolve_character_array_constructor (gfc_expr *expr)\n       gcc_assert (found_length != -1);\n \n       /* Update the character length of the array constructor.  */\n-      expr->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+      expr->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\tNULL, found_length);\n     }\n   else"}, {"sha": "50d25b550a11cf5776e320bbc2bf4e9b4e4f8f79", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -35,7 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.\n \n     Only for unlimited polymorphic classes:\n-    * _len:  An integer(4) to store the string length when the unlimited\n+    * _len:  An integer(C_SIZE_T) to store the string length when the unlimited\n              polymorphic pointer is used to point to a char array.  The '_len'\n              component will be zero when no character array is stored in\n              '_data'.\n@@ -2317,13 +2317,13 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = 4;\n+\t      c->ts.kind = gfc_size_kind;\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      /* Remember the derived type in ts.u.derived,\n \t\t so that the correct initializer can be set later on\n \t\t (in gfc_conv_structure).  */\n \t      c->ts.u.derived = derived;\n-\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t      c->initializer = gfc_get_int_expr (gfc_size_kind,\n \t\t\t\t\t\t NULL, 0);\n \n \t      /* Add component _extends.  */\n@@ -2685,7 +2685,7 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      if (!gfc_add_component (vtype, \"_size\", &c))\n \t\tgoto cleanup;\n \t      c->ts.type = BT_INTEGER;\n-\t      c->ts.kind = 4;\n+\t      c->ts.kind = gfc_size_kind;\n \t      c->attr.access = ACCESS_PRIVATE;\n \n \t      /* Build a minimal expression to make use of\n@@ -2696,11 +2696,11 @@ find_intrinsic_vtab (gfc_typespec *ts)\n \t      e = gfc_get_expr ();\n \t      e->ts = *ts;\n \t      e->expr_type = EXPR_VARIABLE;\n-\t      c->initializer = gfc_get_int_expr (gfc_default_integer_kind,\n+\t      c->initializer = gfc_get_int_expr (gfc_size_kind,\n \t\t\t\t\t\t NULL,\n \t\t\t\t\t\t ts->type == BT_CHARACTER\n \t\t\t\t\t\t ? ts->kind\n-\t\t\t\t\t\t : (int)gfc_element_size (e));\n+\t\t\t\t\t\t : gfc_element_size (e));\n \t      gfc_free_expr (e);\n \n \t      /* Add component _extends.  */"}, {"sha": "a944e4f721fa6d6508148e8bbf7249134b66a4cf", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -995,7 +995,7 @@ match_char_length (gfc_expr **expr, bool *deferred, bool obsolescent_check)\n       if (obsolescent_check\n \t  && !gfc_notify_std (GFC_STD_F95_OBS, \"Old-style character length at %C\"))\n \treturn MATCH_ERROR;\n-      *expr = gfc_get_int_expr (gfc_default_integer_kind, NULL, length);\n+      *expr = gfc_get_int_expr (gfc_charlen_int_kind, NULL, length);\n       return m;\n     }\n \n@@ -1702,7 +1702,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \n \t  if (sym->ts.u.cl->length == NULL)\n \t    {\n-\t      int clen;\n+\t      gfc_charlen_t clen;\n \t      /* If there are multiple CHARACTER variables declared on the\n \t\t same line, we don't want them to share the same length.  */\n \t      sym->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n@@ -1713,7 +1713,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t    {\n \t\t      clen = init->value.character.length;\n \t\t      sym->ts.u.cl->length\n-\t\t\t\t= gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t= gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t    NULL, clen);\n \t\t    }\n \t\t  else if (init->expr_type == EXPR_ARRAY)\n@@ -1740,7 +1740,7 @@ add_init_expr_to_sym (const char *name, gfc_expr **initp, locus *var_locus)\n \t\t      else\n \t\t\t  gcc_unreachable ();\n \t\t      sym->ts.u.cl->length\n-\t\t\t\t= gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\t= gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t    NULL, clen);\n \t\t    }\n \t\t  else if (init->ts.u.cl && init->ts.u.cl->length)\n@@ -3073,7 +3073,7 @@ gfc_match_char_spec (gfc_typespec *ts)\n   cl = gfc_new_charlen (gfc_current_ns, NULL);\n \n   if (seen_length == 0)\n-    cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+    cl->length = gfc_get_int_expr (gfc_charlen_int_kind, NULL, 1);\n   else\n     cl->length = len;\n \n@@ -4315,7 +4315,7 @@ gfc_match_implicit (void)\n \t\t{\n \t\t  ts.kind = gfc_default_character_kind;\n \t\t  ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-\t\t  ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t  ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t      NULL, 1);\n \t\t}\n "}, {"sha": "c2c9b63c8806a4c7cb9f416063e8cea477a7763a", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -348,12 +348,10 @@ show_constructor (gfc_constructor_base base)\n \n \n static void\n-show_char_const (const gfc_char_t *c, int length)\n+show_char_const (const gfc_char_t *c, gfc_charlen_t length)\n {\n-  int i;\n-\n   fputc ('\\'', dumpfile);\n-  for (i = 0; i < length; i++)\n+  for (size_t i = 0; i < (size_t) length; i++)\n     {\n       if (c[i] == '\\'')\n \tfputs (\"''\", dumpfile);\n@@ -465,7 +463,8 @@ show_expr (gfc_expr *p)\n \t  break;\n \n \tcase BT_HOLLERITH:\n-\t  fprintf (dumpfile, \"%dH\", p->representation.length);\n+\t  fprintf (dumpfile, HOST_WIDE_INT_PRINT_DEC \"H\",\n+\t\t   p->representation.length);\n \t  c = p->representation.string;\n \t  for (i = 0; i < p->representation.length; i++, c++)\n \t    {"}, {"sha": "a8f0f0f901608210eb64e2850be6e3d267e31d96", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -27,6 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"match.h\"\n #include \"target-memory.h\" /* for gfc_convert_boz */\n #include \"constructor.h\"\n+#include \"tree.h\"\n \n \n /* The following set of functions provide access to gfc_expr* of\n@@ -184,7 +185,7 @@ gfc_get_constant_expr (bt type, int kind, locus *where)\n    blanked and null-terminated.  */\n \n gfc_expr *\n-gfc_get_character_expr (int kind, locus *where, const char *src, int len)\n+gfc_get_character_expr (int kind, locus *where, const char *src, gfc_charlen_t len)\n {\n   gfc_expr *e;\n   gfc_char_t *dest;\n@@ -210,13 +211,14 @@ gfc_get_character_expr (int kind, locus *where, const char *src, int len)\n /* Get a new expression node that is an integer constant.  */\n \n gfc_expr *\n-gfc_get_int_expr (int kind, locus *where, int value)\n+gfc_get_int_expr (int kind, locus *where, HOST_WIDE_INT value)\n {\n   gfc_expr *p;\n   p = gfc_get_constant_expr (BT_INTEGER, kind,\n \t\t\t     where ? where : &gfc_current_locus);\n \n-  mpz_set_si (p->value.integer, value);\n+  const wide_int w = wi::shwi (value, kind * BITS_PER_UNIT);\n+  wi::to_mpz (w, p->value.integer, SIGNED);\n \n   return p;\n }\n@@ -672,6 +674,62 @@ gfc_extract_int (gfc_expr *expr, int *result, int report_error)\n }\n \n \n+/* Same as gfc_extract_int, but use a HWI.  */\n+\n+bool\n+gfc_extract_hwi (gfc_expr *expr, HOST_WIDE_INT *result, int report_error)\n+{\n+  gfc_ref *ref;\n+\n+  /* A KIND component is a parameter too. The expression for it is\n+     stored in the initializer and should be consistent with the tests\n+     below.  */\n+  if (gfc_expr_attr(expr).pdt_kind)\n+    {\n+      for (ref = expr->ref; ref; ref = ref->next)\n+\t{\n+\t  if (ref->u.c.component->attr.pdt_kind)\n+\t    expr = ref->u.c.component->initializer;\n+\t}\n+    }\n+\n+  if (expr->expr_type != EXPR_CONSTANT)\n+    {\n+      if (report_error > 0)\n+\tgfc_error (\"Constant expression required at %C\");\n+      else if (report_error < 0)\n+\tgfc_error_now (\"Constant expression required at %C\");\n+      return true;\n+    }\n+\n+  if (expr->ts.type != BT_INTEGER)\n+    {\n+      if (report_error > 0)\n+\tgfc_error (\"Integer expression required at %C\");\n+      else if (report_error < 0)\n+\tgfc_error_now (\"Integer expression required at %C\");\n+      return true;\n+    }\n+\n+  /* Use long_long_integer_type_node to determine when to saturate.  */\n+  const wide_int val = wi::from_mpz (long_long_integer_type_node,\n+\t\t\t\t     expr->value.integer, false);\n+\n+  if (!wi::fits_shwi_p (val))\n+    {\n+      if (report_error > 0)\n+\tgfc_error (\"Integer value too large in expression at %C\");\n+      else if (report_error < 0)\n+\tgfc_error_now (\"Integer value too large in expression at %C\");\n+      return true;\n+    }\n+\n+  *result = val.to_shwi ();\n+\n+  return false;\n+}\n+\n+\n /* Recursively copy a list of reference structures.  */\n \n gfc_ref *\n@@ -1701,7 +1759,7 @@ simplify_const_ref (gfc_expr *p)\n \t\t\t a substring out of it, update the type-spec's\n \t\t\t character length according to the first element\n \t\t\t (as all should have the same length).  */\n-\t\t      int string_len;\n+\t\t      gfc_charlen_t string_len;\n \t\t      if ((c = gfc_constructor_first (p->value.constructor)))\n \t\t\t{\n \t\t\t  const gfc_expr* first = c->expr;\n@@ -1719,7 +1777,7 @@ simplify_const_ref (gfc_expr *p)\n \t\t\tgfc_free_expr (p->ts.u.cl->length);\n \n \t\t      p->ts.u.cl->length\n-\t\t\t= gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t= gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t    NULL, string_len);\n \t\t    }\n \t\t}\n@@ -1870,18 +1928,18 @@ gfc_simplify_expr (gfc_expr *p, int type)\n       if (gfc_is_constant_expr (p))\n \t{\n \t  gfc_char_t *s;\n-\t  int start, end;\n+\t  HOST_WIDE_INT start, end;\n \n \t  start = 0;\n \t  if (p->ref && p->ref->u.ss.start)\n \t    {\n-\t      gfc_extract_int (p->ref->u.ss.start, &start);\n+\t      gfc_extract_hwi (p->ref->u.ss.start, &start);\n \t      start--;  /* Convert from one-based to zero-based.  */\n \t    }\n \n \t  end = p->value.character.length;\n \t  if (p->ref && p->ref->u.ss.end)\n-\t    gfc_extract_int (p->ref->u.ss.end, &end);\n+\t    gfc_extract_hwi (p->ref->u.ss.end, &end);\n \n \t  if (end < start)\n \t    end = start;\n@@ -1894,7 +1952,7 @@ gfc_simplify_expr (gfc_expr *p, int type)\n \t  p->value.character.string = s;\n \t  p->value.character.length = end - start;\n \t  p->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-\t  p->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t  p->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t NULL,\n \t\t\t\t\t\t p->value.character.length);\n \t  gfc_free_ref_list (p->ref);"}, {"sha": "bfa50bea7668e66bc172fe9be22567d6fda000fa", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -2224,11 +2224,11 @@ optimize_trim (gfc_expr *e)\n \n   /* Set the start of the reference.  */\n \n-  ref->u.ss.start = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+  ref->u.ss.start = gfc_get_int_expr (gfc_charlen_int_kind, NULL, 1);\n \n   /* Build the function call to len_trim(x, gfc_default_integer_kind).  */\n \n-  fcn = get_len_trim_call (gfc_copy_expr (e), gfc_default_integer_kind);\n+  fcn = get_len_trim_call (gfc_copy_expr (e), gfc_charlen_int_kind);\n \n   /* Set the end of the reference to the call to len_trim.  */\n "}, {"sha": "b3f8e423efec9bd9f6546e7e2d9b63b893b28674", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -2092,6 +2092,14 @@ gfc_intrinsic_sym;\n \n typedef splay_tree gfc_constructor_base;\n \n+\n+/* This should be an unsigned variable of type size_t.  But to handle\n+   compiling to a 64-bit target from a 32-bit host, we need to use a\n+   HOST_WIDE_INT.  Also, occasionally the string length field is used\n+   as a flag with values -1 and -2, see e.g. gfc_add_assign_aux_vars.\n+   So it needs to be signed.  */\n+typedef HOST_WIDE_INT gfc_charlen_t;\n+\n typedef struct gfc_expr\n {\n   expr_t expr_type;\n@@ -2137,7 +2145,7 @@ typedef struct gfc_expr\n      the value.  */\n   struct\n   {\n-    int length;\n+    gfc_charlen_t length;\n     char *string;\n   }\n   representation;\n@@ -2193,7 +2201,7 @@ typedef struct gfc_expr\n \n     struct\n     {\n-      int length;\n+      gfc_charlen_t length;\n       gfc_char_t *string;\n     }\n     character;\n@@ -2809,6 +2817,9 @@ vec_push (char **&optr, size_t &osz, const char *elt)\n   optr[++osz] = NULL;\n }\n \n+HOST_WIDE_INT gfc_mpz_get_hwi (mpz_t);\n+void gfc_mpz_set_hwi (mpz_t, const HOST_WIDE_INT);\n+\n /* options.c */\n unsigned int gfc_option_lang_mask (void);\n void gfc_init_options_struct (struct gcc_options *);\n@@ -2900,6 +2911,7 @@ extern int gfc_atomic_int_kind;\n extern int gfc_atomic_logical_kind;\n extern int gfc_intio_kind;\n extern int gfc_charlen_int_kind;\n+extern int gfc_size_kind;\n extern int gfc_numeric_storage_size;\n extern int gfc_character_storage_size;\n \n@@ -3134,7 +3146,10 @@ void gfc_resolve_oacc_blocks (gfc_code *, gfc_namespace *);\n /* expr.c */\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n+\n bool gfc_extract_int (gfc_expr *, int *, int = 0);\n+bool gfc_extract_hwi (gfc_expr *, HOST_WIDE_INT *, int = 0);\n+\n bool is_subref_array (gfc_expr *);\n bool gfc_is_simply_contiguous (gfc_expr *, bool, bool);\n bool gfc_check_init_expr (gfc_expr *);\n@@ -3152,8 +3167,8 @@ gfc_expr *gfc_get_null_expr (locus *);\n gfc_expr *gfc_get_operator_expr (locus *, gfc_intrinsic_op,gfc_expr *, gfc_expr *);\n gfc_expr *gfc_get_structure_constructor_expr (bt, int, locus *);\n gfc_expr *gfc_get_constant_expr (bt, int, locus *);\n-gfc_expr *gfc_get_character_expr (int, locus *, const char *, int len);\n-gfc_expr *gfc_get_int_expr (int, locus *, int);\n+gfc_expr *gfc_get_character_expr (int, locus *, const char *, gfc_charlen_t len);\n+gfc_expr *gfc_get_int_expr (int, locus *, HOST_WIDE_INT);\n gfc_expr *gfc_get_logical_expr (int, locus *, bool);\n gfc_expr *gfc_get_iokind_expr (locus *, io_kind);\n "}, {"sha": "11246696e18ee3084a542f87199d17fba1b339ff", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -3925,12 +3925,42 @@ front ends of GCC, e.g. to GCC's C99 compiler for @code{_Bool}\n or GCC's Ada compiler for @code{Boolean}.)\n \n For arguments of @code{CHARACTER} type, the character length is passed\n-as hidden argument.  For deferred-length strings, the value is passed\n-by reference, otherwise by value.  The character length has the type\n-@code{INTEGER(kind=4)}.  Note with C binding, @code{CHARACTER(len=1)}\n-result variables are returned according to the platform ABI and no\n-hidden length argument is used for dummy arguments; with @code{VALUE},\n-those variables are passed by value.\n+as a hidden argument at the end of the argument list.  For\n+deferred-length strings, the value is passed by reference, otherwise\n+by value.  The character length has the C type @code{size_t} (or\n+@code{INTEGER(kind=C_SIZE_T)} in Fortran).  Note that this is\n+different to older versions of the GNU Fortran compiler, where the\n+type of the hidden character length argument was a C @code{int}.  In\n+order to retain compatibility with older versions, one can e.g. for\n+the following Fortran procedure\n+\n+@smallexample\n+subroutine fstrlen (s, a)\n+   character(len=*) :: s\n+   integer :: a\n+   print*, len(s)\n+end subroutine fstrlen\n+@end smallexample\n+\n+define the corresponding C prototype as follows:\n+\n+@smallexample\n+#if __GNUC__ > 7\n+typedef size_t fortran_charlen_t;\n+#else\n+typedef int fortran_charlen_t;\n+#endif\n+\n+void fstrlen_ (char*, int*, fortran_charlen_t);\n+@end smallexample\n+\n+In order to avoid such compiler-specific details, for new code it is\n+instead recommended to use the ISO_C_BINDING feature.\n+\n+Note with C binding, @code{CHARACTER(len=1)} result variables are\n+returned according to the platform ABI and no hidden length argument\n+is used for dummy arguments; with @code{VALUE}, those variables are\n+passed by value.\n \n For @code{OPTIONAL} dummy arguments, an absent argument is denoted\n by a NULL pointer, except for scalar dummy arguments of type"}, {"sha": "11f256919b9e917f268bcf147d86ec9bddb426b7", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -82,15 +82,15 @@ check_charlen_present (gfc_expr *source)\n   if (source->expr_type == EXPR_CONSTANT)\n     {\n       source->ts.u.cl->length\n-\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t= gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n \t\t\t\t    source->value.character.length);\n       source->rank = 0;\n     }\n   else if (source->expr_type == EXPR_ARRAY)\n     {\n       gfc_constructor *c = gfc_constructor_first (source->value.constructor);\n       source->ts.u.cl->length\n-\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t= gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n \t\t\t\t    c->expr->value.character.length);\n     }\n }\n@@ -247,7 +247,7 @@ gfc_resolve_char_achar (gfc_expr *f, gfc_expr *x, gfc_expr *kind,\n   f->ts.kind = (kind == NULL)\n \t     ? gfc_default_character_kind : mpz_get_si (kind->value.integer);\n   f->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-  f->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+  f->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind, NULL, 1);\n \n   f->value.function.name\n     = gfc_get_string (\"__%schar_%d_%c%d\", is_achar ? \"a\" : \"\", f->ts.kind,\n@@ -2243,7 +2243,6 @@ void\n gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n \t\t    gfc_expr *ncopies)\n {\n-  int len;\n   gfc_expr *tmp;\n   f->ts.type = BT_CHARACTER;\n   f->ts.kind = string->ts.kind;\n@@ -2256,8 +2255,8 @@ gfc_resolve_repeat (gfc_expr *f, gfc_expr *string,\n   tmp = NULL;\n   if (string->expr_type == EXPR_CONSTANT)\n     {\n-      len = string->value.character.length;\n-      tmp = gfc_get_int_expr (gfc_default_integer_kind, NULL , len);\n+      tmp = gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n+\t\t\t      string->value.character.length);\n     }\n   else if (string->ts.u.cl && string->ts.u.cl->length)\n     {\n@@ -3023,14 +3022,14 @@ gfc_resolve_transfer (gfc_expr *f, gfc_expr *source ATTRIBUTE_UNUSED,\n       if (mold->expr_type == EXPR_CONSTANT)\n         {\n \t  len = mold->value.character.length;\n-\t  mold->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t  mold->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t    NULL, len);\n \t}\n       else\n \t{\n \t  gfc_constructor *c = gfc_constructor_first (mold->value.constructor);\n \t  len = c->expr->value.character.length;\n-\t  mold->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\t  mold->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t    NULL, len);\n \t}\n     }"}, {"sha": "5e313c41fcf6251b43dd21ddf89435805336a2fd", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -5878,7 +5878,7 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n {\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_symtree *tmp;\n-  int charlen = 0;\n+  HOST_WIDE_INT charlen = 0;\n \n   if (ts->type == BT_CLASS || ts->type == BT_DERIVED)\n     return NULL;\n@@ -5889,14 +5889,14 @@ select_intrinsic_set_tmp (gfc_typespec *ts)\n \n   if (ts->type == BT_CHARACTER && ts->u.cl && ts->u.cl->length\n       && ts->u.cl->length->expr_type == EXPR_CONSTANT)\n-    charlen = mpz_get_si (ts->u.cl->length->value.integer);\n+    charlen = gfc_mpz_get_hwi (ts->u.cl->length->value.integer);\n \n   if (ts->type != BT_CHARACTER)\n     sprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (ts->type),\n \t     ts->kind);\n   else\n-    sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (ts->type),\n-\t     charlen, ts->kind);\n+    snprintf (name, sizeof (name), \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+\t      gfc_basic_typename (ts->type), charlen, ts->kind);\n \n   gfc_get_sym_tree (name, gfc_current_ns, &tmp, false);\n   gfc_add_type (tmp->n.sym, ts, NULL);"}, {"sha": "80d282efd07d9527965c2f5bb48789aea2517588", "filename": "gcc/fortran/misc.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"gfortran.h\"\n #include \"spellcheck.h\"\n+#include \"tree.h\"\n \n \n /* Initialize a typespec to unknown.  */\n@@ -321,3 +322,23 @@ gfc_closest_fuzzy_match (const char *typo, char **candidates)\n     }\n   return best;\n }\n+\n+/* Convert between GMP integers (mpz_t) and HOST_WIDE_INT.  */\n+\n+HOST_WIDE_INT\n+gfc_mpz_get_hwi (mpz_t op)\n+{\n+  /* Using long_long_integer_type_node as that is the integer type\n+     node that closest matches HOST_WIDE_INT; both are guaranteed to\n+     be at least 64 bits.  */\n+  const wide_int w = wi::from_mpz (long_long_integer_type_node, op, true);\n+  return w.to_shwi ();\n+}\n+\n+\n+void\n+gfc_mpz_set_hwi (mpz_t rop, const HOST_WIDE_INT op)\n+{\n+  const wide_int w = wi::shwi (op, HOST_BITS_PER_WIDE_INT);\n+  wi::to_mpz (w, rop, SIGNED);\n+}"}, {"sha": "b120501beb7be5175a5180299be0cca8aa1e25cf", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -143,7 +143,7 @@ enum gfc_wsym_state\n typedef struct pointer_info\n {\n   BBT_HEADER (pointer_info);\n-  int integer;\n+  HOST_WIDE_INT integer;\n   pointer_t type;\n \n   /* The first component of each member of the union is the pointer\n@@ -368,7 +368,7 @@ get_pointer (void *gp)\n    creating the node if not found.  */\n \n static pointer_info *\n-get_integer (int integer)\n+get_integer (HOST_WIDE_INT integer)\n {\n   pointer_info *p, t;\n   int c;\n@@ -468,7 +468,7 @@ associate_integer_pointer (pointer_info *p, void *gp)\n    sometime later.  Returns the pointer_info structure.  */\n \n static pointer_info *\n-add_fixup (int integer, void *gp)\n+add_fixup (HOST_WIDE_INT integer, void *gp)\n {\n   pointer_info *p;\n   fixup_t *f;\n@@ -1145,7 +1145,7 @@ static atom_type last_atom;\n \n #define MAX_ATOM_SIZE 100\n \n-static int atom_int;\n+static HOST_WIDE_INT atom_int;\n static char *atom_string, atom_name[MAX_ATOM_SIZE];\n \n \n@@ -1275,7 +1275,7 @@ parse_string (void)\n }\n \n \n-/* Parse a small integer.  */\n+/* Parse an integer. Should fit in a HOST_WIDE_INT.  */\n \n static void\n parse_integer (int c)\n@@ -1292,8 +1292,6 @@ parse_integer (int c)\n \t}\n \n       atom_int = 10 * atom_int + c - '0';\n-      if (atom_int > 99999999)\n-\tbad_module (\"Integer overflow\");\n     }\n \n }\n@@ -1635,11 +1633,12 @@ write_char (char out)\n static void\n write_atom (atom_type atom, const void *v)\n {\n-  char buffer[20];\n+  char buffer[32];\n \n   /* Workaround -Wmaybe-uninitialized false positive during\n      profiledbootstrap by initializing them.  */\n-  int i = 0, len;\n+  int len;\n+  HOST_WIDE_INT i = 0;\n   const char *p;\n \n   switch (atom)\n@@ -1658,11 +1657,9 @@ write_atom (atom_type atom, const void *v)\n       break;\n \n     case ATOM_INTEGER:\n-      i = *((const int *) v);\n-      if (i < 0)\n-\tgfc_internal_error (\"write_atom(): Writing negative integer\");\n+      i = *((const HOST_WIDE_INT *) v);\n \n-      sprintf (buffer, \"%d\", i);\n+      snprintf (buffer, sizeof (buffer), HOST_WIDE_INT_PRINT_DEC, i);\n       p = buffer;\n       break;\n \n@@ -1770,14 +1767,29 @@ static void\n mio_integer (int *ip)\n {\n   if (iomode == IO_OUTPUT)\n-    write_atom (ATOM_INTEGER, ip);\n+    {\n+      HOST_WIDE_INT hwi = *ip;\n+      write_atom (ATOM_INTEGER, &hwi);\n+    }\n   else\n     {\n       require_atom (ATOM_INTEGER);\n       *ip = atom_int;\n     }\n }\n \n+static void\n+mio_hwi (HOST_WIDE_INT *hwi)\n+{\n+  if (iomode == IO_OUTPUT)\n+    write_atom (ATOM_INTEGER, hwi);\n+  else\n+    {\n+      require_atom (ATOM_INTEGER);\n+      *hwi = atom_int;\n+    }\n+}\n+\n \n /* Read or write a gfc_intrinsic_op value.  */\n \n@@ -1787,7 +1799,7 @@ mio_intrinsic_op (gfc_intrinsic_op* op)\n   /* FIXME: Would be nicer to do this via the operators symbolic name.  */\n   if (iomode == IO_OUTPUT)\n     {\n-      int converted = (int) *op;\n+      HOST_WIDE_INT converted = (HOST_WIDE_INT) *op;\n       write_atom (ATOM_INTEGER, &converted);\n     }\n   else\n@@ -2719,7 +2731,7 @@ mio_array_ref (gfc_array_ref *ar)\n     {\n       for (i = 0; i < ar->dimen; i++)\n \t{\n-\t  int tmp = (int)ar->dimen_type[i];\n+\t  HOST_WIDE_INT tmp = (HOST_WIDE_INT)ar->dimen_type[i];\n \t  write_atom (ATOM_INTEGER, &tmp);\n \t}\n     }\n@@ -2756,7 +2768,8 @@ mio_pointer_ref (void *gp)\n   if (iomode == IO_OUTPUT)\n     {\n       p = get_pointer (*((char **) gp));\n-      write_atom (ATOM_INTEGER, &p->integer);\n+      HOST_WIDE_INT hwi = p->integer;\n+      write_atom (ATOM_INTEGER, &hwi);\n     }\n   else\n     {\n@@ -2794,18 +2807,18 @@ static void\n mio_component (gfc_component *c, int vtype)\n {\n   pointer_info *p;\n-  int n;\n \n   mio_lparen ();\n \n   if (iomode == IO_OUTPUT)\n     {\n       p = get_pointer (c);\n-      mio_integer (&p->integer);\n+      mio_hwi (&p->integer);\n     }\n   else\n     {\n-      mio_integer (&n);\n+      HOST_WIDE_INT n;\n+      mio_hwi (&n);\n       p = get_integer (n);\n       associate_integer_pointer (p, c);\n     }\n@@ -3430,6 +3443,7 @@ fix_mio_expr (gfc_expr *e)\n static void\n mio_expr (gfc_expr **ep)\n {\n+  HOST_WIDE_INT hwi;\n   gfc_expr *e;\n   atom_type t;\n   int flag;\n@@ -3644,7 +3658,9 @@ mio_expr (gfc_expr **ep)\n \t  break;\n \n \tcase BT_CHARACTER:\n-\t  mio_integer (&e->value.character.length);\n+\t  hwi = e->value.character.length;\n+\t  mio_hwi (&hwi);\n+\t  e->value.character.length = hwi;\n \t  e->value.character.string\n \t    = CONST_CAST (gfc_char_t *,\n \t\t\t  mio_allocated_wide_string (e->value.character.string,\n@@ -5946,7 +5962,7 @@ write_symtree (gfc_symtree *st)\n \n   mio_pool_string (&st->name);\n   mio_integer (&st->ambiguous);\n-  mio_integer (&p->integer);\n+  mio_hwi (&p->integer);\n }\n \n "}, {"sha": "4b6ad47d75a0b34a81e6c25971043f17e23714c2", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -862,7 +862,7 @@ match_substring (gfc_charlen *cl, int init, gfc_ref **result, bool deferred)\n \n       ref->type = REF_SUBSTRING;\n       if (start == NULL)\n-\tstart = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+\tstart = gfc_get_int_expr (gfc_charlen_int_kind, NULL, 1);\n       ref->u.ss.start = start;\n       if (end == NULL && cl)\n \tend = gfc_copy_expr (cl->length);"}, {"sha": "57155cddf68ef489d300c4c4160e0493222dd335", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -4901,7 +4901,7 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n   if (char_ref->u.ss.start)\n     start = gfc_copy_expr (char_ref->u.ss.start);\n   else\n-    start = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);\n+    start = gfc_get_int_expr (gfc_charlen_int_kind, NULL, 1);\n \n   if (char_ref->u.ss.end)\n     end = gfc_copy_expr (char_ref->u.ss.end);\n@@ -4924,7 +4924,7 @@ gfc_resolve_substring_charlen (gfc_expr *e)\n   /* Length = (end - start + 1).  */\n   e->ts.u.cl->length = gfc_subtract (end, start);\n   e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,\n-\t\t\t\tgfc_get_int_expr (gfc_default_integer_kind,\n+\t\t\t\tgfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t  NULL, 1));\n \n   /* F2008, 6.4.1:  Both the starting point and the ending point shall\n@@ -5690,13 +5690,13 @@ gfc_resolve_character_operator (gfc_expr *e)\n   if (op1->ts.u.cl && op1->ts.u.cl->length)\n     e1 = gfc_copy_expr (op1->ts.u.cl->length);\n   else if (op1->expr_type == EXPR_CONSTANT)\n-    e1 = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+    e1 = gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n \t\t\t   op1->value.character.length);\n \n   if (op2->ts.u.cl && op2->ts.u.cl->length)\n     e2 = gfc_copy_expr (op2->ts.u.cl->length);\n   else if (op2->expr_type == EXPR_CONSTANT)\n-    e2 = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+    e2 = gfc_get_int_expr (gfc_charlen_int_kind, NULL,\n \t\t\t   op2->value.character.length);\n \n   e->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n@@ -8630,7 +8630,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       if (!sym->ts.u.cl->length && !sym->ts.deferred\n \t  && target->expr_type == EXPR_CONSTANT)\n \tsym->ts.u.cl->length\n-\t  = gfc_get_int_expr (gfc_default_integer_kind,\n+\t  = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t      NULL, target->value.character.length);\n     }\n \n@@ -8715,7 +8715,6 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n   char name[GFC_MAX_SYMBOL_LEN];\n   gfc_namespace *ns;\n   int error = 0;\n-  int charlen = 0;\n   int rank = 0;\n   gfc_ref* ref = NULL;\n   gfc_expr *selector_expr = NULL;\n@@ -8966,11 +8965,13 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \tsprintf (name, \"__tmp_type_%s\", c->ts.u.derived->name);\n       else if (c->ts.type == BT_CHARACTER)\n \t{\n+\t  HOST_WIDE_INT charlen = 0;\n \t  if (c->ts.u.cl && c->ts.u.cl->length\n \t      && c->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n-\t    charlen = mpz_get_si (c->ts.u.cl->length->value.integer);\n-\t  sprintf (name, \"__tmp_%s_%d_%d\", gfc_basic_typename (c->ts.type),\n-\t           charlen, c->ts.kind);\n+\t    charlen = gfc_mpz_get_hwi (c->ts.u.cl->length->value.integer);\n+\t  snprintf (name, sizeof (name),\n+\t\t    \"__tmp_%s_\" HOST_WIDE_INT_PRINT_DEC \"_%d\",\n+\t\t    gfc_basic_typename (c->ts.type), charlen, c->ts.kind);\n \t}\n       else\n \tsprintf (name, \"__tmp_%s_%d\", gfc_basic_typename (c->ts.type),\n@@ -11640,7 +11641,7 @@ resolve_index_expr (gfc_expr *e)\n static bool\n resolve_charlen (gfc_charlen *cl)\n {\n-  int i, k;\n+  int k;\n   bool saved_specification_expr;\n \n   if (cl->resolved)\n@@ -11676,9 +11677,10 @@ resolve_charlen (gfc_charlen *cl)\n \n   /* F2008, 4.4.3.2:  If the character length parameter value evaluates to\n      a negative value, the length of character entities declared is zero.  */\n-  if (cl->length && !gfc_extract_int (cl->length, &i) && i < 0)\n+  if (cl->length && cl->length->expr_type == EXPR_CONSTANT\n+      && mpz_sgn (cl->length->value.integer) < 0)\n     gfc_replace_expr (cl->length,\n-\t\t      gfc_get_int_expr (gfc_default_integer_kind, NULL, 0));\n+\t\t      gfc_get_int_expr (gfc_charlen_int_kind, NULL, 0));\n \n   /* Check that the character length is not too large.  */\n   k = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n@@ -15962,7 +15964,7 @@ resolve_equivalence (gfc_equiv *eq)\n \t\t{\n \t\t  ref->type = REF_SUBSTRING;\n \t\t  if (start == NULL)\n-\t\t    start = gfc_get_int_expr (gfc_default_integer_kind,\n+\t\t    start = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t      NULL, 1);\n \t\t  ref->u.ss.start = start;\n \t\t  if (end == NULL && e->ts.u.cl)"}, {"sha": "3e5abd44cc6efeffb4942bd9b0795261457227fc", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -5982,7 +5982,7 @@ gfc_expr *\n gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n {\n   gfc_expr *result;\n-  int i, j, len, ncop, nlen;\n+  gfc_charlen_t len;\n   mpz_t ncopies;\n   bool have_length = false;\n \n@@ -6002,7 +6002,7 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->ts.u.cl && e->ts.u.cl->length\n \t&& e->ts.u.cl->length->expr_type == EXPR_CONSTANT)\n     {\n-      len = mpz_get_si (e->ts.u.cl->length->value.integer);\n+      len = gfc_mpz_get_hwi (e->ts.u.cl->length->value.integer);\n       have_length = true;\n     }\n   else if (e->expr_type == EXPR_CONSTANT\n@@ -6038,7 +6038,8 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n \t}\n       else\n \t{\n-\t  mpz_init_set_si (mlen, len);\n+\t  mpz_init (mlen);\n+\t  gfc_mpz_set_hwi (mlen, len);\n \t  mpz_tdiv_q (max, gfc_integer_kinds[i].huge, mlen);\n \t  mpz_clear (mlen);\n \t}\n@@ -6062,11 +6063,12 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   if (e->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n+  HOST_WIDE_INT ncop;\n   if (len ||\n       (e->ts.u.cl->length &&\n        mpz_sgn (e->ts.u.cl->length->value.integer) != 0))\n     {\n-      bool fail = gfc_extract_int (n, &ncop);\n+      bool fail = gfc_extract_hwi (n, &ncop);\n       gcc_assert (!fail);\n     }\n   else\n@@ -6076,11 +6078,18 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n     return gfc_get_character_expr (e->ts.kind, &e->where, NULL, 0);\n \n   len = e->value.character.length;\n-  nlen = ncop * len;\n+  gfc_charlen_t nlen = ncop * len;\n+\n+  /* Here's a semi-arbitrary limit. If the string is longer than 32 MB\n+     (8 * 2**20 elements * 4 bytes (wide chars) per element) defer to\n+     runtime instead of consuming (unbounded) memory and CPU at\n+     compile time.  */\n+  if (nlen > 8388608)\n+    return NULL;\n \n   result = gfc_get_character_expr (e->ts.kind, &e->where, NULL, nlen);\n-  for (i = 0; i < ncop; i++)\n-    for (j = 0; j < len; j++)\n+  for (size_t i = 0; i < (size_t) ncop; i++)\n+    for (size_t j = 0; j < (size_t) len; j++)\n       result->value.character.string[j+i*len]= e->value.character.string[j];\n \n   result->value.character.string[nlen] = '\\0';\t/* For debugger */"}, {"sha": "344c644bac927766a5f7b9e31949bbf02f543bf0", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -4856,7 +4856,7 @@ generate_isocbinding_symbol (const char *mod_name, iso_c_binding_symbol s,\n \ttmp_sym->value->value.character.string[0]\n \t  = (gfc_char_t) c_interop_kinds_table[s].value;\n \ttmp_sym->ts.u.cl = gfc_new_charlen (gfc_current_ns, NULL);\n-\ttmp_sym->ts.u.cl->length = gfc_get_int_expr (gfc_default_integer_kind,\n+\ttmp_sym->ts.u.cl->length = gfc_get_int_expr (gfc_charlen_int_kind,\n \t\t\t\t\t\t     NULL, 1);\n \n \t/* May not need this in both attr and ts, but do need in"}, {"sha": "c708b17da392e2c2e66e24701fe9cfb5ab2a57c4", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -65,7 +65,7 @@ size_logical (int kind)\n \n \n static size_t\n-size_character (int length, int kind)\n+size_character (gfc_charlen_t length, int kind)\n {\n   int i = gfc_validate_kind (BT_CHARACTER, kind, false);\n   return length * gfc_character_kinds[i].bit_size / 8;\n@@ -97,9 +97,9 @@ gfc_element_size (gfc_expr *e)\n \t       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT\n \t       && e->ts.u.cl->length->ts.type == BT_INTEGER)\n \t{\n-\t  int length;\n+\t  HOST_WIDE_INT length;\n \n-\t  gfc_extract_int (e->ts.u.cl->length, &length);\n+\t  gfc_extract_hwi (e->ts.u.cl->length, &length);\n \t  return size_character (length, e->ts.kind);\n \t}\n       else\n@@ -217,16 +217,15 @@ encode_logical (int kind, int logical, unsigned char *buffer, size_t buffer_size\n \n \n int\n-gfc_encode_character (int kind, int length, const gfc_char_t *string,\n+gfc_encode_character (int kind, gfc_charlen_t length, const gfc_char_t *string,\n \t\t      unsigned char *buffer, size_t buffer_size)\n {\n   size_t elsize = size_character (1, kind);\n   tree type = gfc_get_char_type (kind);\n-  int i;\n \n   gcc_assert (buffer_size >= size_character (length, kind));\n \n-  for (i = 0; i < length; i++)\n+  for (size_t i = 0; i < (size_t) length; i++)\n     native_encode_expr (build_int_cst (type, string[i]), &buffer[i*elsize],\n \t\t\telsize);\n \n@@ -438,19 +437,17 @@ int\n gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n \t\t\t gfc_expr *result)\n {\n-  int i;\n-\n   if (result->ts.u.cl && result->ts.u.cl->length)\n     result->value.character.length =\n-      (int) mpz_get_ui (result->ts.u.cl->length->value.integer);\n+      gfc_mpz_get_hwi (result->ts.u.cl->length->value.integer);\n \n   gcc_assert (buffer_size >= size_character (result->value.character.length,\n \t\t\t\t\t     result->ts.kind));\n   result->value.character.string =\n     gfc_get_wide_string (result->value.character.length + 1);\n \n   if (result->ts.kind == gfc_default_character_kind)\n-    for (i = 0; i < result->value.character.length; i++)\n+    for (size_t i = 0; i < (size_t) result->value.character.length; i++)\n       result->value.character.string[i] = (gfc_char_t) buffer[i];\n   else\n     {\n@@ -459,7 +456,7 @@ gfc_interpret_character (unsigned char *buffer, size_t buffer_size,\n       mpz_init (integer);\n       gcc_assert (bytes <= sizeof (unsigned long));\n \n-      for (i = 0; i < result->value.character.length; i++)\n+      for (size_t i = 0; i < (size_t) result->value.character.length; i++)\n \t{\n \t  gfc_conv_tree_to_mpz (integer,\n \t    native_interpret_expr (gfc_get_char_type (result->ts.kind),"}, {"sha": "a9141a66885b0624339826b9a03b4cff23961859", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -28,7 +28,7 @@ size_t gfc_element_size (gfc_expr *);\n size_t gfc_target_expr_size (gfc_expr *);\n \n /* Write a constant expression in binary form to a target buffer.  */\n-int gfc_encode_character (int, int, const gfc_char_t *, unsigned char *,\n+int gfc_encode_character (int, gfc_charlen_t, const gfc_char_t *, unsigned char *,\n \t\t\t  size_t);\n unsigned HOST_WIDE_INT gfc_target_encode_expr (gfc_expr *, unsigned char *,\n \t\t\t\t\t       size_t);"}, {"sha": "b8e31bb6dff5a90080e3cfa86bc97441ca5ee2a7", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -1537,8 +1537,8 @@ gfc_trans_array_ctor_element (stmtblock_t * pblock, tree desc,\n       esize = size_in_bytes (gfc_get_element_type (TREE_TYPE (desc)));\n       esize = fold_convert (gfc_charlen_type_node, esize);\n       esize = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n-\t\t\t   gfc_charlen_type_node, esize,\n-\t\t\t   build_int_cst (gfc_charlen_type_node,\n+\t\t\t       TREE_TYPE (esize), esize,\n+\t\t\t       build_int_cst (TREE_TYPE (esize),\n \t\t\t\t\t  gfc_character_kinds[i].bit_size / 8));\n \n       gfc_conv_string_parameter (se);\n@@ -2059,8 +2059,7 @@ get_array_ctor_var_strlen (stmtblock_t *block, gfc_expr * expr, tree * len)\n \t  mpz_init_set_ui (char_len, 1);\n \t  mpz_add (char_len, char_len, ref->u.ss.end->value.integer);\n \t  mpz_sub (char_len, char_len, ref->u.ss.start->value.integer);\n-\t  *len = gfc_conv_mpz_to_tree (char_len, gfc_default_integer_kind);\n-\t  *len = convert (gfc_charlen_type_node, *len);\n+\t  *len = gfc_conv_mpz_to_tree_type (char_len, gfc_charlen_type_node);\n \t  mpz_clear (char_len);\n \t  return;\n \n@@ -2428,7 +2427,8 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t     set LEN = 0.  */\n \t  neg_len = fold_build2_loc (input_location, LT_EXPR,\n \t\t\t\t     logical_type_node, ss_info->string_length,\n-\t\t\t\t     build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t\t     build_zero_cst (TREE_TYPE\n+\t\t\t\t\t\t     (ss_info->string_length)));\n \t  /* Print a warning if bounds checking is enabled.  */\n \t  if (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS)\n \t    {\n@@ -2441,7 +2441,8 @@ trans_array_constructor (gfc_ss * ss, locus * where)\n \t  ss_info->string_length\n \t    = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t       gfc_charlen_type_node, neg_len,\n-\t\t\t       build_int_cst (gfc_charlen_type_node, 0),\n+\t\t\t       build_zero_cst\n+\t\t\t       (TREE_TYPE (ss_info->string_length)),\n \t\t\t       ss_info->string_length);\n \t  ss_info->string_length = gfc_evaluate_now (ss_info->string_length,\n \t\t\t\t\t\t     &length_se.pre);\n@@ -6878,8 +6879,8 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n       gfc_add_block_to_block (&se->post, &tse.post);\n       tse.expr = fold_convert (gfc_charlen_type_node, tse.expr);\n       tse.expr = fold_build2_loc (input_location, MAX_EXPR,\n-\t\t\t\t  gfc_charlen_type_node, tse.expr,\n-\t\t\t\t  build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t\t  TREE_TYPE (tse.expr), tse.expr,\n+\t\t\t\t  build_zero_cst (TREE_TYPE (tse.expr)));\n       expr->ts.u.cl->backend_decl = tse.expr;\n       gfc_free_interface_mapping (&mapping);\n       break;"}, {"sha": "028e6d2cedb0ad88fa373c0b945f90bce4f1c444", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -206,6 +206,18 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n   return wide_int_to_tree (gfc_get_int_type (kind), val);\n }\n \n+\n+/* Convert a GMP integer into a tree node of type given by the type\n+   argument.  */\n+\n+tree\n+gfc_conv_mpz_to_tree_type (mpz_t i, const tree type)\n+{\n+  const wide_int val = wi::from_mpz (type, i, true);\n+  return wide_int_to_tree (type, val);\n+}\n+\n+\n /* Converts a backend tree into a GMP integer.  */\n \n void"}, {"sha": "39693bb7cf74455e91f7644a78e4da4ddc83de6d", "filename": "gcc/fortran/trans-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Converts between INT_CST and GMP integer representations.  */\n tree gfc_conv_mpz_to_tree (mpz_t, int);\n+tree gfc_conv_mpz_to_tree_type (mpz_t, const tree);\n void gfc_conv_tree_to_mpz (mpz_t, tree);\n \n /* Converts between REAL_CST and MPFR floating-point representations.  */"}, {"sha": "144a3447769f46cd6b62727e526509364a048820", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -4280,10 +4280,11 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t{\n \t\t  tmp = proc_sym->ts.u.cl->passed_length;\n \t\t  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-\t\t  tmp = fold_convert (gfc_charlen_type_node, tmp);\n \t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t gfc_charlen_type_node, tmp,\n-\t\t\t\t\t proc_sym->ts.u.cl->backend_decl);\n+\t\t\t\t\t TREE_TYPE (tmp), tmp,\n+\t\t\t\t\t fold_convert\n+\t\t\t\t\t (TREE_TYPE (tmp),\n+\t\t\t\t\t  proc_sym->ts.u.cl->backend_decl));\n \t\t}\n \t      else\n \t\ttmp = NULL_TREE;\n@@ -5840,7 +5841,8 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \t    not_0length = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t   logical_type_node,\n \t\t\t\t\t   cl->passed_length,\n-\t\t\t\t\t   build_zero_cst (gfc_charlen_type_node));\n+\t\t\t\t\t   build_zero_cst\n+\t\t\t\t\t   (TREE_TYPE (cl->passed_length)));\n \t    /* The symbol needs to be referenced for gfc_get_symbol_decl.  */\n \t    fsym->attr.referenced = 1;\n \t    not_absent = gfc_conv_expr_present (fsym);"}, {"sha": "533435ae0c32f29fe3c61a0678a4385a17333794", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 55, "deletions": 42, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -250,7 +250,7 @@ gfc_class_len_or_zero_get (tree decl)\n   return len != NULL_TREE ? fold_build3_loc (input_location, COMPONENT_REF,\n \t\t\t\t\t     TREE_TYPE (len), decl, len,\n \t\t\t\t\t     NULL_TREE)\n-\t\t\t  : integer_zero_node;\n+    : build_zero_cst (gfc_charlen_type_node);\n }\n \n \n@@ -884,7 +884,8 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \t\t{\n \t\t  /* Amazingly all data is present to compute the length of a\n \t\t   constant string, but the expression is not yet there.  */\n-\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER, 4,\n+\t\t  e->ts.u.cl->length = gfc_get_constant_expr (BT_INTEGER,\n+\t\t\t\t\t\t\t      gfc_charlen_int_kind,\n \t\t\t\t\t\t\t      &e->where);\n \t\t  mpz_set_ui (e->ts.u.cl->length->value.integer,\n \t\t\t      e->value.character.length);\n@@ -902,7 +903,7 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n       else\n \ttmp = integer_zero_node;\n \n-      gfc_add_modify (&parmse->pre, ctree, tmp);\n+      gfc_add_modify (&parmse->pre, ctree, fold_convert (TREE_TYPE (ctree), tmp));\n     }\n   else if (class_ts.type == BT_CLASS\n \t   && class_ts.u.derived->components\n@@ -1045,7 +1046,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n       if (DECL_LANG_SPECIFIC (tmp) && GFC_DECL_SAVED_DESCRIPTOR (tmp))\n \ttmp = GFC_DECL_SAVED_DESCRIPTOR (tmp);\n \n-      slen = integer_zero_node;\n+      slen = build_zero_cst (size_type_node);\n     }\n   else\n     {\n@@ -1096,7 +1097,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n \t  tmp = slen;\n \t}\n       else\n-\ttmp = integer_zero_node;\n+\ttmp = build_zero_cst (size_type_node);\n       gfc_add_modify (&parmse->pre, ctree,\n \t\t      fold_convert (TREE_TYPE (ctree), tmp));\n \n@@ -1235,7 +1236,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n       if (from != NULL_TREE && unlimited)\n \tfrom_len = gfc_class_len_or_zero_get (from);\n       else\n-\tfrom_len = integer_zero_node;\n+\tfrom_len = build_zero_cst (size_type_node);\n     }\n \n   if (GFC_CLASS_TYPE_P (TREE_TYPE (to)))\n@@ -1347,7 +1348,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t logical_type_node, from_len,\n-\t\t\t\t integer_zero_node);\n+\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t  gfc_add_expr_to_block (&body, tmp);\n@@ -1375,7 +1376,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \t  extcopy = build_call_vec (fcn_type, fcn, args);\n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t logical_type_node, from_len,\n-\t\t\t\t integer_zero_node);\n+\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n \t  tmp = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t}\n@@ -2206,7 +2207,7 @@ gfc_conv_string_length (gfc_charlen * cl, gfc_expr * expr, stmtblock_t * pblock)\n \n   gfc_conv_expr_type (&se, cl->length, gfc_charlen_type_node);\n   se.expr = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n-\t\t\t     se.expr, build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t     se.expr, build_zero_cst (TREE_TYPE (se.expr)));\n   gfc_add_block_to_block (pblock, &se.pre);\n \n   if (cl->backend_decl)\n@@ -2278,7 +2279,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n       /* Check lower bound.  */\n       fault = fold_build2_loc (input_location, LT_EXPR, logical_type_node,\n \t\t\t       start.expr,\n-\t\t\t       build_int_cst (gfc_charlen_type_node, 1));\n+\t\t\t       build_one_cst (TREE_TYPE (start.expr)));\n       fault = fold_build2_loc (input_location, TRUTH_ANDIF_EXPR,\n \t\t\t       logical_type_node, nonempty, fault);\n       if (name)\n@@ -2314,9 +2315,9 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   if (ref->u.ss.end\n       && gfc_dep_difference (ref->u.ss.end, ref->u.ss.start, &length))\n     {\n-      int i_len;\n+      HOST_WIDE_INT i_len;\n \n-      i_len = mpz_get_si (length) + 1;\n+      i_len = gfc_mpz_get_hwi (length) + 1;\n       if (i_len < 0)\n \ti_len = 0;\n \n@@ -2326,7 +2327,8 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n   else\n     {\n       tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_charlen_type_node,\n-\t\t\t     end.expr, start.expr);\n+\t\t\t     fold_convert (gfc_charlen_type_node, end.expr),\n+\t\t\t     fold_convert (gfc_charlen_type_node, start.expr));\n       tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_charlen_type_node,\n \t\t\t     build_int_cst (gfc_charlen_type_node, 1), tmp);\n       tmp = fold_build2_loc (input_location, MAX_EXPR, gfc_charlen_type_node,\n@@ -3129,9 +3131,9 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n     {\n       /* Create a temporary variable to hold the result.  */\n       tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t     gfc_charlen_type_node, len,\n-\t\t\t     build_int_cst (gfc_charlen_type_node, 1));\n-      tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n+\t\t\t     TREE_TYPE (len), len,\n+\t\t\t     build_int_cst (TREE_TYPE (len), 1));\n+      tmp = build_range_type (gfc_charlen_type_node, size_zero_node, tmp);\n \n       if (TREE_CODE (TREE_TYPE (type)) == ARRAY_TYPE)\n \ttmp = build_array_type (TREE_TYPE (TREE_TYPE (type)), tmp);\n@@ -3193,8 +3195,11 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   if (len == NULL_TREE)\n     {\n       len = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t     TREE_TYPE (lse.string_length),\n-\t\t\t     lse.string_length, rse.string_length);\n+\t\t\t     gfc_charlen_type_node,\n+\t\t\t     fold_convert (gfc_charlen_type_node,\n+\t\t\t\t\t   lse.string_length),\n+\t\t\t     fold_convert (gfc_charlen_type_node,\n+\t\t\t\t\t   rse.string_length));\n     }\n \n   type = build_pointer_type (type);\n@@ -5920,11 +5925,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    gfc_conv_expr (&parmse, ts.u.cl->length);\n \t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n \t  gfc_add_block_to_block (&se->post, &parmse.post);\n-\n-\t  tmp = fold_convert (gfc_charlen_type_node, parmse.expr);\n+\t  tmp = parmse.expr;\n \t  tmp = fold_build2_loc (input_location, MAX_EXPR,\n-\t\t\t\t gfc_charlen_type_node, tmp,\n-\t\t\t\t build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t\t TREE_TYPE (tmp), tmp,\n+\t\t\t\t build_zero_cst (TREE_TYPE (tmp)));\n \t  cl.backend_decl = tmp;\n \t}\n \n@@ -6403,13 +6407,16 @@ fill_with_spaces (tree start, tree type, tree size)\n   tree i, el, exit_label, cond, tmp;\n \n   /* For a simple char type, we can call memset().  */\n+  /* TODO: This code does work and is potentially more efficient, but\n+     causes spurious -Wstringop-overflow warnings.\n   if (compare_tree_int (TYPE_SIZE_UNIT (type), 1) == 0)\n     return build_call_expr_loc (input_location,\n \t\t\t    builtin_decl_explicit (BUILT_IN_MEMSET),\n \t\t\t    3, start,\n \t\t\t    build_int_cst (gfc_get_int_type (gfc_c_int_kind),\n \t\t\t\t\t   lang_hooks.to_target_charset (' ')),\n-\t\t\t    size);\n+\t\t\t\tfold_convert (size_type_node, size));\n+  */\n \n   /* Otherwise, we use a loop:\n \tfor (el = start, i = size; i > 0; el--, i+= TYPE_SIZE_UNIT (type))\n@@ -6485,23 +6492,23 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \n   if (slength != NULL_TREE)\n     {\n-      slen = fold_convert (size_type_node, gfc_evaluate_now (slength, block));\n+      slen = gfc_evaluate_now (fold_convert (gfc_charlen_type_node, slength), block);\n       ssc = gfc_string_to_single_character (slen, src, skind);\n     }\n   else\n     {\n-      slen = build_int_cst (size_type_node, 1);\n+      slen = build_one_cst (gfc_charlen_type_node);\n       ssc =  src;\n     }\n \n   if (dlength != NULL_TREE)\n     {\n-      dlen = fold_convert (size_type_node, gfc_evaluate_now (dlength, block));\n+      dlen = gfc_evaluate_now (fold_convert (gfc_charlen_type_node, dlength), block);\n       dsc = gfc_string_to_single_character (dlen, dest, dkind);\n     }\n   else\n     {\n-      dlen = build_int_cst (size_type_node, 1);\n+      dlen = build_one_cst (gfc_charlen_type_node);\n       dsc =  dest;\n     }\n \n@@ -6524,18 +6531,18 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \n   /* Do nothing if the destination length is zero.  */\n   cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node, dlen,\n-\t\t\t  build_int_cst (size_type_node, 0));\n+\t\t\t  build_zero_cst (TREE_TYPE (dlen)));\n \n   /* For non-default character kinds, we have to multiply the string\n      length by the base type size.  */\n   chartype = gfc_get_char_type (dkind);\n-  slen = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n-\t\t\t  fold_convert (size_type_node, slen),\n-\t\t\t  fold_convert (size_type_node,\n+  slen = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (slen),\n+\t\t\t  slen,\n+\t\t\t  fold_convert (TREE_TYPE (slen),\n \t\t\t\t\tTYPE_SIZE_UNIT (chartype)));\n-  dlen = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n-\t\t\t  fold_convert (size_type_node, dlen),\n-\t\t\t  fold_convert (size_type_node,\n+  dlen = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (dlen),\n+\t\t\t  dlen,\n+\t\t\t  fold_convert (TREE_TYPE (dlen),\n \t\t\t\t\tTYPE_SIZE_UNIT (chartype)));\n \n   if (dlength && POINTER_TYPE_P (TREE_TYPE (dest)))\n@@ -6553,7 +6560,8 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \t\t\t  slen);\n   tmp2 = build_call_expr_loc (input_location,\n \t\t\t      builtin_decl_explicit (BUILT_IN_MEMMOVE),\n-\t\t\t      3, dest, src, tmp2);\n+\t\t\t      3, dest, src,\n+\t\t\t      fold_convert (size_type_node, tmp2));\n   stmtblock_t tmpblock2;\n   gfc_init_block (&tmpblock2);\n   gfc_add_expr_to_block (&tmpblock2, tmp2);\n@@ -7264,7 +7272,8 @@ alloc_scalar_allocatable_for_subcomponent_assignment (stmtblock_t *block,\n \n   if (cm->ts.type == BT_CHARACTER && cm->ts.deferred)\n     /* Update the lhs character length.  */\n-    gfc_add_modify (block, lhs_cl_size, size);\n+    gfc_add_modify (block, lhs_cl_size,\n+\t\t    fold_convert (TREE_TYPE (lhs_cl_size), size));\n }\n \n \n@@ -7503,7 +7512,8 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t\t\t\t     1, size);\n \t  gfc_add_modify (&block, dest,\n \t\t\t  fold_convert (TREE_TYPE (dest), tmp));\n-\t  gfc_add_modify (&block, strlen, se.string_length);\n+\t  gfc_add_modify (&block, strlen,\n+\t\t\t  fold_convert (TREE_TYPE (strlen), se.string_length));\n \t  tmp = gfc_build_memcpy_call (dest, se.expr, size);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n@@ -8174,7 +8184,7 @@ trans_class_vptr_len_assignment (stmtblock_t *block, gfc_expr * le,\n \t\t  from_len = gfc_evaluate_now (se.expr, block);\n \t\t}\n \t      else\n-\t\tfrom_len = integer_zero_node;\n+\t\tfrom_len = build_zero_cst (gfc_charlen_type_node);\n \t    }\n \t  gfc_add_modify (pre, to_len, fold_convert (TREE_TYPE (to_len),\n \t\t\t\t\t\t     from_len));\n@@ -8385,7 +8395,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n \t    gfc_add_modify (&block, lse.string_length, rse.string_length);\n \t  else if (lse.string_length != NULL)\n \t    gfc_add_modify (&block, lse.string_length,\n-\t\t\t    build_int_cst (gfc_charlen_type_node, 0));\n+\t\t\t    build_zero_cst (TREE_TYPE (lse.string_length)));\n \t}\n \n       gfc_add_modify (&block, lse.expr,\n@@ -9643,7 +9653,9 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n   if (expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)\n     {\n       cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node,\n-\t\t\t      lse.string_length, size);\n+\t\t\t      lse.string_length,\n+\t\t\t      fold_convert (TREE_TYPE (lse.string_length),\n+\t\t\t\t\t    size));\n       /* Jump past the realloc if the lengths are the same.  */\n       tmp = build3_v (COND_EXPR, cond,\n \t\t      build1_v (GOTO_EXPR, jump_label2),\n@@ -9660,7 +9672,8 @@ alloc_scalar_allocatable_for_assignment (stmtblock_t *block,\n \n       /* Update the lhs character length.  */\n       size = string_length;\n-      gfc_add_modify (block, lse.string_length, size);\n+      gfc_add_modify (block, lse.string_length,\n+\t\t      fold_convert (TREE_TYPE (lse.string_length), size));\n     }\n }\n \n@@ -9842,7 +9855,7 @@ trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n \n \t  tmp = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t logical_type_node, from_len,\n-\t\t\t\t integer_zero_node);\n+\t\t\t\t build_zero_cst (TREE_TYPE (from_len)));\n \t  return fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t  void_type_node, tmp,\n \t\t\t\t  extcopy, stdcopy);"}, {"sha": "7fe8286a0a946c0ead06383b5b84e9b3bdc52e31", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -7600,7 +7600,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \tnonzero_charlen = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t   logical_type_node,\n \t\t\t\t\t   arg1->expr->ts.u.cl->backend_decl,\n-\t\t\t\t\t   integer_zero_node);\n+\t\t\t\t\t   build_zero_cst\n+\t\t\t\t\t   (TREE_TYPE (arg1->expr->ts.u.cl->backend_decl)));\n       if (scalar)\n         {\n \t  /* A pointer to a scalar.  */\n@@ -7890,11 +7891,11 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n \n   /* We store in charsize the size of a character.  */\n   i = gfc_validate_kind (BT_CHARACTER, expr->ts.kind, false);\n-  size = build_int_cst (size_type_node, gfc_character_kinds[i].bit_size / 8);\n+  size = build_int_cst (sizetype, gfc_character_kinds[i].bit_size / 8);\n \n   /* Get the arguments.  */\n   gfc_conv_intrinsic_function_args (se, expr, args, 3);\n-  slen = fold_convert (size_type_node, gfc_evaluate_now (args[0], &se->pre));\n+  slen = fold_convert (sizetype, gfc_evaluate_now (args[0], &se->pre));\n   src = args[1];\n   ncopies = gfc_evaluate_now (args[2], &se->pre);\n   ncopies_type = TREE_TYPE (ncopies);\n@@ -7911,7 +7912,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      is valid, and nothing happens.  */\n   n = gfc_create_var (ncopies_type, \"ncopies\");\n   cond = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, slen,\n-\t\t\t  build_int_cst (size_type_node, 0));\n+\t\t\t  size_zero_node);\n   tmp = fold_build3_loc (input_location, COND_EXPR, ncopies_type, cond,\n \t\t\t build_int_cst (ncopies_type, 0), ncopies);\n   gfc_add_modify (&se->pre, n, tmp);\n@@ -7921,17 +7922,17 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n      (or equal to) MAX / slen, where MAX is the maximal integer of\n      the gfc_charlen_type_node type.  If slen == 0, we need a special\n      case to avoid the division by zero.  */\n-  i = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n-  max = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, gfc_charlen_int_kind);\n-  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n-\t\t\t  fold_convert (size_type_node, max), slen);\n-  largest = TYPE_PRECISION (size_type_node) > TYPE_PRECISION (ncopies_type)\n-\t      ? size_type_node : ncopies_type;\n+  max = fold_build2_loc (input_location, TRUNC_DIV_EXPR, sizetype,\n+\t\t\t fold_convert (sizetype,\n+\t\t\t\t       TYPE_MAX_VALUE (gfc_charlen_type_node)),\n+\t\t\t slen);\n+  largest = TYPE_PRECISION (sizetype) > TYPE_PRECISION (ncopies_type)\n+\t      ? sizetype : ncopies_type;\n   cond = fold_build2_loc (input_location, GT_EXPR, logical_type_node,\n \t\t\t  fold_convert (largest, ncopies),\n \t\t\t  fold_convert (largest, max));\n   tmp = fold_build2_loc (input_location, EQ_EXPR, logical_type_node, slen,\n-\t\t\t build_int_cst (size_type_node, 0));\n+\t\t\t size_zero_node);\n   cond = fold_build3_loc (input_location, COND_EXPR, logical_type_node, tmp,\n \t\t\t  logical_false_node, cond);\n   gfc_trans_runtime_check (true, false, cond, &se->pre, &expr->where,\n@@ -7948,42 +7949,39 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n        for (i = 0; i < ncopies; i++)\n          memmove (dest + (i * slen * size), src, slen*size);  */\n   gfc_start_block (&block);\n-  count = gfc_create_var (ncopies_type, \"count\");\n-  gfc_add_modify (&block, count, build_int_cst (ncopies_type, 0));\n+  count = gfc_create_var (sizetype, \"count\");\n+  gfc_add_modify (&block, count, size_zero_node);\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Start the loop body.  */\n   gfc_start_block (&body);\n \n   /* Exit the loop if count >= ncopies.  */\n   cond = fold_build2_loc (input_location, GE_EXPR, logical_type_node, count,\n-\t\t\t  ncopies);\n+\t\t\t  fold_convert (sizetype, ncopies));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n \t\t\t build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Call memmove (dest + (i*slen*size), src, slen*size).  */\n-  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n-\t\t\t fold_convert (gfc_charlen_type_node, slen),\n-\t\t\t fold_convert (gfc_charlen_type_node, count));\n-  tmp = fold_build2_loc (input_location, MULT_EXPR, gfc_charlen_type_node,\n-\t\t\t tmp, fold_convert (gfc_charlen_type_node, size));\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, sizetype, slen,\n+\t\t\t count);\n+  tmp = fold_build2_loc (input_location, MULT_EXPR, sizetype, tmp,\n+\t\t\t size);\n   tmp = fold_build_pointer_plus_loc (input_location,\n \t\t\t\t     fold_convert (pvoid_type_node, dest), tmp);\n   tmp = build_call_expr_loc (input_location,\n \t\t\t     builtin_decl_explicit (BUILT_IN_MEMMOVE),\n \t\t\t     3, tmp, src,\n \t\t\t     fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t\t      size_type_node, slen,\n-\t\t\t\t\t      fold_convert (size_type_node,\n-\t\t\t\t\t\t\t    size)));\n+\t\t\t\t\t      size_type_node, slen, size));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Increment count.  */\n-  tmp = fold_build2_loc (input_location, PLUS_EXPR, ncopies_type,\n-\t\t\t count, build_int_cst (TREE_TYPE (count), 1));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, sizetype,\n+\t\t\t count, size_one_node);\n   gfc_add_modify (&body, count, tmp);\n \n   /* Build the loop.  */"}, {"sha": "9eb77e5986dfd780bd6d3ef2f00b5826b05a94ce", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -345,11 +345,11 @@ gfc_build_io_library_fndecls (void)\n \n   iocall[IOCALL_X_CHARACTER] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character\")), \".wW\",\n-\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_int4_type_node);\n+\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_charlen_type_node);\n \n   iocall[IOCALL_X_CHARACTER_WRITE] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character_write\")), \".wR\",\n-\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_int4_type_node);\n+\tvoid_type_node, 3, dt_parm_type, pvoid_type_node, gfc_charlen_type_node);\n \n   iocall[IOCALL_X_CHARACTER_WIDE] = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"transfer_character_wide\")), \".wW\",\n@@ -852,7 +852,8 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n \n       gfc_conv_string_parameter (&se);\n       gfc_add_modify (&se.pre, io, fold_convert (TREE_TYPE (io), se.expr));\n-      gfc_add_modify (&se.pre, len, se.string_length);\n+      gfc_add_modify (&se.pre, len, fold_convert (TREE_TYPE (len),\n+\t\t\t\t\t\t  se.string_length));\n     }\n \n   gfc_add_block_to_block (block, &se.pre);"}, {"sha": "74974d38096d4d652a6806629f6c42dece31d7f5", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -112,7 +112,7 @@ gfc_trans_label_assign (gfc_code * code)\n       || code->label1->defined == ST_LABEL_DO_TARGET)\n     {\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n-      len_tree = integer_minus_one_node;\n+      len_tree = build_int_cst (gfc_charlen_type_node, -1);\n     }\n   else\n     {\n@@ -125,7 +125,7 @@ gfc_trans_label_assign (gfc_code * code)\n       label_tree = gfc_build_addr_expr (pvoid_type_node, label_tree);\n     }\n \n-  gfc_add_modify (&se.pre, len, len_tree);\n+  gfc_add_modify (&se.pre, len, fold_convert (TREE_TYPE (len), len_tree));\n   gfc_add_modify (&se.pre, addr, label_tree);\n \n   return gfc_finish_block (&se.pre);\n@@ -1600,7 +1600,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  && se.string_length != sym->ts.u.cl->backend_decl)\n \t{\n \t  gfc_add_modify (&se.pre, sym->ts.u.cl->backend_decl,\n-\t\t\t  fold_convert (gfc_charlen_type_node,\n+\t\t\t  fold_convert (TREE_TYPE (sym->ts.u.cl->backend_decl),\n \t\t\t\t\tse.string_length));\n \t}\n \n@@ -1777,7 +1777,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t  && se.string_length != sym->ts.u.cl->backend_decl)\n \t{\n \t  gfc_add_modify (&se.pre, sym->ts.u.cl->backend_decl,\n-\t\t\t  fold_convert (gfc_charlen_type_node,\n+\t\t\t  fold_convert (TREE_TYPE (sym->ts.u.cl->backend_decl),\n \t\t\t\t\tse.string_length));\n \t  if (e->expr_type == EXPR_FUNCTION)\n \t    {\n@@ -2838,7 +2838,7 @@ gfc_trans_character_select (gfc_code *code)\n     {\n       for (d = cp; d; d = d->right)\n \t{\n-\t  int i;\n+\t  gfc_charlen_t i;\n \t  if (d->low)\n \t    {\n \t      gcc_assert (d->low->expr_type == EXPR_CONSTANT\n@@ -3043,7 +3043,7 @@ gfc_trans_character_select (gfc_code *code)\n       if (d->low == NULL)\n         {\n           CONSTRUCTOR_APPEND_ELT (node, ss_string1[k], null_pointer_node);\n-          CONSTRUCTOR_APPEND_ELT (node, ss_string1_len[k], integer_zero_node);\n+          CONSTRUCTOR_APPEND_ELT (node, ss_string1_len[k], build_zero_cst (gfc_charlen_type_node));\n         }\n       else\n         {\n@@ -3056,7 +3056,7 @@ gfc_trans_character_select (gfc_code *code)\n       if (d->high == NULL)\n         {\n           CONSTRUCTOR_APPEND_ELT (node, ss_string2[k], null_pointer_node);\n-          CONSTRUCTOR_APPEND_ELT (node, ss_string2_len[k], integer_zero_node);\n+          CONSTRUCTOR_APPEND_ELT (node, ss_string2_len[k], build_zero_cst (gfc_charlen_type_node));\n         }\n       else\n         {\n@@ -5747,7 +5747,7 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  gfc_init_se (&se, NULL);\n \t  temp_var_needed = false;\n-\t  expr3_len = integer_zero_node;\n+\t  expr3_len = build_zero_cst (gfc_charlen_type_node);\n \t  e3_is = E3_MOLD;\n \t}\n       /* Prevent aliasing, i.e., se.expr may be already a\n@@ -6152,7 +6152,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t     e.g., a string.  */\n \t\t  memsz = fold_build2_loc (input_location, GT_EXPR,\n \t\t\t\t\t   logical_type_node, expr3_len,\n-\t\t\t\t\t   integer_zero_node);\n+\t\t\t\t\t   build_zero_cst\n+\t\t\t\t\t   (TREE_TYPE (expr3_len)));\n \t\t  memsz = fold_build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t TREE_TYPE (expr3_esize),\n \t\t\t\t\t memsz, tmp, expr3_esize);\n@@ -6521,7 +6522,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\tgfc_build_addr_expr (pchar_type_node,\n \t\t\tgfc_build_localized_cstring_const (msg)));\n \n-      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n+      slen = build_int_cst (gfc_charlen_type_node, strlen (msg));\n       dlen = gfc_get_expr_charlen (code->expr2);\n       slen = fold_build2_loc (input_location, MIN_EXPR,\n \t\t\t      TREE_TYPE (slen), dlen, slen);\n@@ -6818,7 +6819,7 @@ gfc_trans_deallocate (gfc_code *code)\n       gfc_add_modify (&errmsg_block, errmsg_str,\n \t\tgfc_build_addr_expr (pchar_type_node,\n                         gfc_build_localized_cstring_const (msg)));\n-      slen = build_int_cst (gfc_charlen_type_node, ((int) strlen (msg)));\n+      slen = build_int_cst (gfc_charlen_type_node, strlen (msg));\n       dlen = gfc_get_expr_charlen (code->expr2);\n \n       gfc_trans_string_copy (&errmsg_block, dlen, errmsg, code->expr2->ts.kind,"}, {"sha": "abcbf957e5dd8d5c93e5c84f72cf0a097a1abebf", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -123,6 +123,9 @@ int gfc_intio_kind;\n /* The integer kind used to store character lengths.  */\n int gfc_charlen_int_kind;\n \n+/* Kind of internal integer for storing object sizes.  */\n+int gfc_size_kind;\n+\n /* The size of the numeric storage unit and character storage unit.  */\n int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n@@ -1006,14 +1009,17 @@ gfc_init_types (void)\n \t\t\twi::mask (n, UNSIGNED,\n \t\t\t\t  TYPE_PRECISION (size_type_node)));\n \n-\n   logical_type_node = gfc_get_logical_type (gfc_default_logical_kind);\n   logical_true_node = build_int_cst (logical_type_node, 1);\n   logical_false_node = build_int_cst (logical_type_node, 0);\n \n-  /* ??? Shouldn't this be based on gfc_index_integer_kind or so?  */\n-  gfc_charlen_int_kind = 4;\n+  /* Character lengths are of type size_t, except signed.  */\n+  gfc_charlen_int_kind = get_int_kind_from_node (size_type_node);\n   gfc_charlen_type_node = gfc_get_int_type (gfc_charlen_int_kind);\n+\n+  /* Fortran kind number of size_type_node (size_t). This is used for\n+     the _size member in vtables.  */\n+  gfc_size_kind = get_int_kind_from_node (size_type_node);\n }\n \n /* Get the type node for the given type and kind.  */"}, {"sha": "99798ab617c48537d8643f233664082fe6f07574", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GFC_BACKEND_H\n #define GFC_BACKEND_H\n \n+\n extern GTY(()) tree gfc_array_index_type;\n extern GTY(()) tree gfc_array_range_type;\n extern GTY(()) tree gfc_character1_type_node;\n@@ -49,10 +50,9 @@ extern GTY(()) tree logical_false_node;\n \n /* This is the type used to hold the lengths of character variables.\n    It must be the same as the corresponding definition in gfortran.h.  */\n-/* TODO: This is still hardcoded as kind=4 in some bits of the compiler\n-   and runtime library.  */\n extern GTY(()) tree gfc_charlen_type_node;\n \n+\n /* The following flags give us information on the correspondence of\n    real (and complex) kinds with C floating-point types long double\n    and __float128.  */"}, {"sha": "1d3603a34f9cc834c988fd7cc8f05509ab902a38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -1,3 +1,17 @@\n+2018-01-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/78534\n+\tPR fortran/66310\n+\t* gfortran.dg/char_cast_1.f90: Update scan pattern.\n+\t* gfortran.dg/dependency_49.f90: Likewise.\n+\t* gfortran.dg/repeat_4.f90: Use integers of kind C_SIZE_T.\n+\t* gfortran.dg/repeat_7.f90: New test for PR 66310.\n+\t* gfortran.dg/scan_2.f90: Handle potential cast in assignment.\n+\t* gfortran.dg/string_1.f90: Limit to ilp32 targets.\n+\t* gfortran.dg/string_1_lp64.f90: New test.\n+\t* gfortran.dg/string_3.f90: Limit to ilp32 targets.\n+\t* gfortran.dg/string_3_lp64.f90: New test.\n+\n 2018-01-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/83604"}, {"sha": "70963bbf0e6cb70f4e0ad188269a9cb47a08145f", "filename": "gcc/testsuite/gfortran.dg/char_cast_1.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cast_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cast_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cast_1.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -25,6 +25,6 @@ Character (len=20) Function Upper (string)\n     return\n   end function Upper\n end\n-! The sign that all is well is that [S.6][1] appears twice.\n-! Platform dependent variations are [S$6][1], [__S_6][1], [S___6][1]\n-! { dg-final { scan-tree-dump-times \"6\\\\\\]\\\\\\[1\\\\\\]\" 2 \"original\" } }\n+! The sign that all is well is that [S.10][1] appears twice.\n+! Platform dependent variations are [S$10][1], [__S_10][1], [S___10][1]\n+! { dg-final { scan-tree-dump-times \"10\\\\\\]\\\\\\[1\\\\\\]\" 2 \"original\" } }"}, {"sha": "73d517e8f765a4372442ec1b4f0ccf4d9f58529f", "filename": "gcc/testsuite/gfortran.dg/dependency_49.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_49.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_49.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_49.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -11,4 +11,4 @@ program main\n   a%x = a%x(2:3)\n   print *,a%x\n end program main\n-! { dg-final { scan-tree-dump-times \"__var_1\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"__var_1\" 4 \"original\" } }"}, {"sha": "99e7aee4670fa36261409153cb58b5c89132c0e5", "filename": "gcc/testsuite/gfortran.dg/repeat_4.f90", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -2,6 +2,7 @@\n !\n ! { dg-do compile }\n program test\n+  use iso_c_binding, only: k => c_size_t\n   implicit none\n   character(len=0), parameter :: s0 = \"\" \n   character(len=1), parameter :: s1 = \"a\"\n@@ -21,18 +22,18 @@ program test\n   print *, repeat(t2, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n \n   ! Check for too large NCOPIES argument and limit cases\n-  print *, repeat(t0, huge(0))\n-  print *, repeat(t1, huge(0))\n-  print *, repeat(t2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n-  print *, repeat(s2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(t0, huge(0_k))\n+  print *, repeat(t1, huge(0_k))\n+  print *, repeat(t2, huge(0_k)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0_k)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n \n-  print *, repeat(t0, huge(0)/2)\n-  print *, repeat(t1, huge(0)/2)\n-  print *, repeat(t2, huge(0)/2)\n+  print *, repeat(t0, huge(0_k)/2)\n+  print *, repeat(t1, huge(0_k)/2)\n+  print *, repeat(t2, huge(0_k)/2)\n \n-  print *, repeat(t0, huge(0)/2+1)\n-  print *, repeat(t1, huge(0)/2+1)\n-  print *, repeat(t2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n-  print *, repeat(s2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(t0, huge(0_k)/2+1)\n+  print *, repeat(t1, huge(0_k)/2+1)\n+  print *, repeat(t2, huge(0_k)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0_k)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n \n end program test"}, {"sha": "82f8dbf4deaab62625f7aa1c7c2dedb6b3c7128d", "filename": "gcc/testsuite/gfortran.dg/repeat_7.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_7.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do compile }\n+! PR 66310\n+! Make sure there is a limit to how large arrays we try to handle at\n+! compile time.\n+program p\n+  character, parameter :: z = 'z'\n+  print *, repeat(z, huge(1_4))\n+end program p"}, {"sha": "5ef02300d9bad6dfcfba286a27976f2fa2a10b32", "filename": "gcc/testsuite/gfortran.dg/scan_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fscan_2.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -30,5 +30,5 @@ program p1\n    call s1(.TRUE.)\n end program p1\n \n-! { dg-final { scan-tree-dump-times \"iscan = _gfortran_string_scan \\\\(2,\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"iverify = _gfortran_string_verify \\\\(2,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_string_scan \\\\(2,\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_string_verify \\\\(2,\" 1 \"original\" } }"}, {"sha": "6a6151e20a4ea919040429352827828c57c1d97b", "filename": "gcc/testsuite/gfortran.dg/string_1.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-require-effective-target ilp32 }\n !\n program main\n   implicit none"}, {"sha": "a0edbefc53e4cb8df3148b41556f568f588fe782", "filename": "gcc/testsuite/gfortran.dg/string_1_lp64.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_1_lp64.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-require-effective-target lp64 }\n+! { dg-require-effective-target fortran_integer_16 }\n+program main\n+  implicit none\n+  integer(kind=16), parameter :: l1 = 2_16**64_16\n+  character (len=2_16**64_16+4_16), parameter :: s = \"\" ! { dg-error \"too large\" }\n+  character (len=2_16**64_8+4_16) :: ch ! { dg-error \"too large\" }\n+  character (len=l1 + 1_16) :: v ! { dg-error \"too large\" }\n+  character (len=int(huge(0_8),kind=16) + 1_16) :: z ! { dg-error \"too large\" }\n+  character (len=int(huge(0_8),kind=16) + 0_16) :: w\n+\n+  print *, len(s)\n+\n+end program main"}, {"sha": "4a88b06da7cbbc907e2310c432818f2310365dc1", "filename": "gcc/testsuite/gfortran.dg/string_3.f90", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do compile }\n+! { dg-require-effective-target ilp32 }\n !\n subroutine foo(i)\n   implicit none"}, {"sha": "162561fad00b1778e05c63a3b6eaad751f6c0998", "filename": "gcc/testsuite/gfortran.dg/string_3_lp64.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fstring_3_lp64.f90?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-require-effective-target lp64 }\n+! { dg-require-effective-target fortran_integer_16 }\n+subroutine foo(i)\n+  implicit none\n+  integer, intent(in) :: i\n+  character(len=i) :: s\n+\n+  s = ''\n+  print *, s(1:2_16**64_16+3_16) ! { dg-error \"too large\" }\n+  print *, s(2_16**64_16+3_16:2_16**64_16+4_16) ! { dg-error \"too large\" }\n+  print *, len(s(1:2_16**64_16+3_16)) ! { dg-error \"too large\" }\n+  print *, len(s(2_16**64_16+3_16:2_16**64_16+4_16)) ! { dg-error \"too large\" }\n+\n+  print *, s(2_16**64_16+3_16:1)\n+  print *, s(2_16**64_16+4_16:2_16**64_16+3_16)\n+  print *, len(s(2_16**64_16+3_16:1))\n+  print *, len(s(2_16**64_16+4_16:2_16**64_16+3_16))\n+\n+end subroutine"}, {"sha": "4c0e5df6341c6fd17e9eed44edb218a949e0828d", "filename": "libgfortran/intrinsics/args.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fargs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fargs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fargs.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -37,7 +37,6 @@ void\n getarg_i4 (GFC_INTEGER_4 *pos, char  *val, gfc_charlen_type val_len)\n {\n   int argc;\n-  int arglen;\n   char **argv;\n \n   get_args (&argc, &argv);\n@@ -49,7 +48,7 @@ getarg_i4 (GFC_INTEGER_4 *pos, char  *val, gfc_charlen_type val_len)\n \n   if ((*pos) + 1 <= argc  && *pos >=0 )\n     {\n-      arglen = strlen (argv[*pos]);\n+      gfc_charlen_type arglen = strlen (argv[*pos]);\n       if (arglen > val_len)\n \targlen = val_len;\n       memcpy (val, argv[*pos], arglen);\n@@ -119,7 +118,8 @@ get_command_argument_i4 (GFC_INTEGER_4 *number, char *value,\n \t\t\t GFC_INTEGER_4 *length, GFC_INTEGER_4 *status, \n \t\t\t gfc_charlen_type value_len)\n {\n-  int argc, arglen = 0, stat_flag = GFC_GC_SUCCESS;\n+  int argc, stat_flag = GFC_GC_SUCCESS;\n+  gfc_charlen_type arglen = 0;\n   char **argv;\n \n   if (number == NULL )\n@@ -195,10 +195,10 @@ void\n get_command_i4 (char *command, GFC_INTEGER_4 *length, GFC_INTEGER_4 *status,\n \t\tgfc_charlen_type command_len)\n {\n-  int i, argc, arglen, thisarg;\n+  int i, argc, thisarg;\n   int stat_flag = GFC_GC_SUCCESS;\n-  int tot_len = 0;\n   char **argv;\n+  gfc_charlen_type arglen, tot_len = 0;\n \n   if (command == NULL && length == NULL && status == NULL)\n     return; /* No need to do anything.  */"}, {"sha": "1299159a7f1b0c88a996c9f4aa5aa54e26e1dfdb", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -64,7 +64,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n static int\n chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n {\n-  int i;\n   bool ugo[3];\n   bool rwxXstugo[9];\n   int set_mode, part;\n@@ -104,7 +103,7 @@ chmod_internal (char *file, char *mode, gfc_charlen_type mode_len)\n   honor_umask = false;\n #endif\n \n-  for (i = 0; i < mode_len; i++)\n+  for (gfc_charlen_type i = 0; i < mode_len; i++)\n     {\n       if (!continue_clause)\n \t{"}, {"sha": "a2f9498e27f98c558cd329aae1da9eed22166f87", "filename": "libgfortran/intrinsics/env.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fenv.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -93,7 +93,8 @@ get_environment_variable_i4 (char *name, char *value, GFC_INTEGER_4 *length,\n \t\t\t     gfc_charlen_type name_len,\n \t\t\t     gfc_charlen_type value_len)\n {\n-  int stat = GFC_SUCCESS, res_len = 0;\n+  int stat = GFC_SUCCESS;\n+  gfc_charlen_type res_len = 0;\n   char *name_nt;\n   char *res;\n "}, {"sha": "72f40d4f42a4a0efacb33d2aa25968cc53633b1a", "filename": "libgfortran/intrinsics/extends_type_of.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fextends_type_of.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fextends_type_of.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fextends_type_of.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -30,7 +30,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef struct vtype\n {\n   GFC_INTEGER_4 hash;\n-  GFC_INTEGER_4 size;\n+  size_t size;\n   struct vtype *extends;\n }\n vtype;"}, {"sha": "fc51aad09a7cf377953af4be1f5cb995e60a735c", "filename": "libgfortran/intrinsics/gerror.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fgerror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fgerror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgerror.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -39,7 +39,7 @@ export_proto_np(PREFIX(gerror));\n void \n PREFIX(gerror) (char * msg, gfc_charlen_type msg_len)\n {\n-  int p_len;\n+  gfc_charlen_type p_len;\n   char *p;\n \n   p = gf_strerror (errno, msg, msg_len);"}, {"sha": "518e20faec2a9d8e590743d1a325f650b7c91ae8", "filename": "libgfortran/intrinsics/getlog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fgetlog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fgetlog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fgetlog.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -70,7 +70,6 @@ export_proto_np(PREFIX(getlog));\n void\n PREFIX(getlog) (char * login, gfc_charlen_type login_len)\n {\n-  int p_len;\n   char *p;\n \n   memset (login, ' ', login_len); /* Blank the string.  */\n@@ -107,7 +106,7 @@ PREFIX(getlog) (char * login, gfc_charlen_type login_len)\n   if (p == NULL)\n     goto cleanup;\n \n-  p_len = strlen (p);\n+  gfc_charlen_type p_len = strlen (p);\n   if (login_len < p_len)\n     p_len = login_len;\n   memcpy (login, p, p_len);"}, {"sha": "53d9aec943c0b04edf46f7c4449de36a6eb301a6", "filename": "libgfortran/intrinsics/hostnm.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fhostnm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fhostnm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fhostnm.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -88,8 +88,8 @@ w32_gethostname (char *name, size_t len)\n static int\n hostnm_0 (char *name, gfc_charlen_type name_len)\n {\n-  int val, i;\n   char p[HOST_NAME_MAX + 1];\n+  int val;\n \n   memset (name, ' ', name_len);\n \n@@ -99,8 +99,7 @@ hostnm_0 (char *name, gfc_charlen_type name_len)\n \n   if (val == 0)\n   {\n-    i = -1;\n-    while (i < name_len && p[++i] != '\\0')\n+    for (gfc_charlen_type i = 0; i < name_len && p[i] != '\\0'; i++)\n       name[i] = p[i];\n   }\n "}, {"sha": "bfec683f52807751ee2377a27845173e9aac2478", "filename": "libgfortran/intrinsics/string_intrinsics_inc.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics_inc.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -177,23 +177,25 @@ string_trim (gfc_charlen_type *len, CHARTYPE **dest, gfc_charlen_type slen,\n gfc_charlen_type\n string_len_trim (gfc_charlen_type len, const CHARTYPE *s)\n {\n-  const gfc_charlen_type long_len = (gfc_charlen_type) sizeof (unsigned long);\n-  gfc_charlen_type i;\n+  if (len <= 0)\n+    return 0;\n \n-  i = len - 1;\n+  const size_t long_len = sizeof (unsigned long);\n+\n+  size_t i = len - 1;\n \n   /* If we've got the standard (KIND=1) character type, we scan the string in\n      long word chunks to speed it up (until a long word is hit that does not\n      consist of ' 's).  */\n   if (sizeof (CHARTYPE) == 1 && i >= long_len)\n     {\n-      int starting;\n+      size_t starting;\n       unsigned long blank_longword;\n \n       /* Handle the first characters until we're aligned on a long word\n \t boundary.  Actually, s + i + 1 must be properly aligned, because\n \t s + i will be the last byte of a long word read.  */\n-      starting = ((unsigned long)\n+      starting = (\n #ifdef __INTPTR_TYPE__\n \t\t  (__INTPTR_TYPE__)\n #endif\n@@ -224,14 +226,15 @@ string_len_trim (gfc_charlen_type len, const CHARTYPE *s)\n \t      break;\n \t    }\n \t}\n-\n-      /* Now continue for the last characters with naive approach below.  */\n-      assert (i >= 0);\n     }\n \n   /* Simply look for the first non-blank character.  */\n-  while (i >= 0 && s[i] == ' ')\n-    --i;\n+  while (s[i] == ' ')\n+    {\n+      if (i == 0)\n+\treturn 0;\n+      --i;\n+    }\n   return i + 1;\n }\n \n@@ -327,12 +330,12 @@ string_scan (gfc_charlen_type slen, const CHARTYPE *str,\n \n   if (back)\n     {\n-      for (i = slen - 1; i >= 0; i--)\n+      for (i = slen; i != 0; i--)\n \t{\n \t  for (j = 0; j < setlen; j++)\n \t    {\n-\t      if (str[i] == set[j])\n-\t\treturn (i + 1);\n+\t      if (str[i - 1] == set[j])\n+\t\treturn i;\n \t    }\n \t}\n     }"}, {"sha": "4aafcd0cb57641565d1691582b47e018dd73ef65", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -93,17 +93,17 @@ export_proto(transfer_logical);\n extern void transfer_logical_write (st_parameter_dt *, void *, int);\n export_proto(transfer_logical_write);\n \n-extern void transfer_character (st_parameter_dt *, void *, int);\n+extern void transfer_character (st_parameter_dt *, void *, gfc_charlen_type);\n export_proto(transfer_character);\n \n-extern void transfer_character_write (st_parameter_dt *, void *, int);\n+extern void transfer_character_write (st_parameter_dt *, void *, gfc_charlen_type);\n export_proto(transfer_character_write);\n \n-extern void transfer_character_wide (st_parameter_dt *, void *, int, int);\n+extern void transfer_character_wide (st_parameter_dt *, void *, gfc_charlen_type, int);\n export_proto(transfer_character_wide);\n \n extern void transfer_character_wide_write (st_parameter_dt *,\n-\t\t\t\t\t   void *, int, int);\n+\t\t\t\t\t   void *, gfc_charlen_type, int);\n export_proto(transfer_character_wide_write);\n \n extern void transfer_complex (st_parameter_dt *, void *, int);\n@@ -2331,7 +2331,7 @@ transfer_logical_write (st_parameter_dt *dtp, void *p, int kind)\n }\n \n void\n-transfer_character (st_parameter_dt *dtp, void *p, int len)\n+transfer_character (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n {\n   static char *empty_string[0];\n \n@@ -2349,13 +2349,13 @@ transfer_character (st_parameter_dt *dtp, void *p, int len)\n }\n \n void\n-transfer_character_write (st_parameter_dt *dtp, void *p, int len)\n+transfer_character_write (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n {\n   transfer_character (dtp, p, len);\n }\n \n void\n-transfer_character_wide (st_parameter_dt *dtp, void *p, int len, int kind)\n+transfer_character_wide (st_parameter_dt *dtp, void *p, gfc_charlen_type len, int kind)\n {\n   static char *empty_string[0];\n \n@@ -2373,7 +2373,7 @@ transfer_character_wide (st_parameter_dt *dtp, void *p, int len, int kind)\n }\n \n void\n-transfer_character_wide_write (st_parameter_dt *dtp, void *p, int len, int kind)\n+transfer_character_wide_write (st_parameter_dt *dtp, void *p, gfc_charlen_type len, int kind)\n {\n   transfer_character_wide (dtp, p, len, kind);\n }\n@@ -2410,7 +2410,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n     return;\n \n   iotype = (bt) GFC_DESCRIPTOR_TYPE (desc);\n-  size = iotype == BT_CHARACTER ? charlen : GFC_DESCRIPTOR_SIZE (desc);\n+  size = iotype == BT_CHARACTER ? (index_type) charlen : GFC_DESCRIPTOR_SIZE (desc);\n \n   rank = GFC_DESCRIPTOR_RANK (desc);\n   for (n = 0; n < rank; n++)"}, {"sha": "559dba92635754c50a20cf4ea9b1a34cbc6dfb22", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -432,10 +432,9 @@ is_trim_ok (st_parameter_dt *dtp)\n   if (dtp->common.flags & IOPARM_DT_HAS_FORMAT)\n     {\n       char *p = dtp->format;\n-      off_t i;\n       if (dtp->common.flags & IOPARM_DT_HAS_BLANK)\n \treturn false;\n-      for (i = 0; i < dtp->format_len; i++)\n+      for (gfc_charlen_type i = 0; i < dtp->format_len; i++)\n \t{\n \t  if (p[i] == '/') return false;\n \t  if (p[i] == 'b' || p[i] == 'B')"}, {"sha": "c04d243dc086f487d20999975136f12ea4415b10", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -2394,7 +2394,7 @@ namelist_write (st_parameter_dt *dtp)\n   write_character (dtp, \"&\", 1, 1, NODELIM);\n \n   /* Write namelist name in upper case - f95 std.  */\n-  for (i = 0 ;i < dtp->namelist_name_len ;i++ )\n+  for (gfc_charlen_type i = 0; i < dtp->namelist_name_len; i++ )\n     {\n       c = toupper ((int) dtp->namelist_name[i]);\n       write_character (dtp, &c, 1 ,1, NODELIM);"}, {"sha": "84df19e3c6f0916222242326500ce47beead229a", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f622221ab42c4ca550059add89ffda00ed2b3c03/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=f622221ab42c4ca550059add89ffda00ed2b3c03", "patch": "@@ -255,7 +255,7 @@ typedef GFC_INTEGER_4 GFC_IO_INT;\n typedef ptrdiff_t index_type;\n \n /* The type used for the lengths of character variables.  */\n-typedef GFC_INTEGER_4 gfc_charlen_type;\n+typedef size_t gfc_charlen_type;\n \n /* Definitions of CHARACTER data types:\n      - CHARACTER(KIND=1) corresponds to the C char type,"}]}