{"sha": "ce27ef3d722fcd2d60f092e4fb4ace14f79fa058", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UyN2VmM2Q3MjJmY2QyZDYwZjA5MmU0ZmI0YWNlMTRmNzlmYTA1OA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-02-27T13:25:41Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-02-27T13:25:41Z"}, "message": "bfin.c: Include \"cfglayout.h\".\n\n\t* config/bfin/bfin.c: Include \"cfglayout.h\".\n\t(MAX_LSETUP_DISTANCE): New macro.\n\t(struct loop_info): New members incoming, incoming_src and\n\tincoming_dest.  Delete member predecessor.\n\t(length_for_loop): New function.\n\t(bfin_optimize_loop): Handle more different loop structures.\n\t(bfin_discover_loop): Rework detection of predecessor blocks by\n\texamining incoming edges.\n\t(bfin_discover_loops, bfin_free_loops): New functions, broken out of\n\tbfin_reorg_loops.\n\t(bfin_reorder_loops): New function.\n\t(bfin_reorg_loops): Use these three new functions.\n\nFrom-SVN: r122372", "tree": {"sha": "485864d70572c6f81f9af468c9e5996ee4f66d7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/485864d70572c6f81f9af468c9e5996ee4f66d7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058/comments", "author": null, "committer": null, "parents": [{"sha": "9b02a95e8022dca224a076d3ab818ee495f70ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b02a95e8022dca224a076d3ab818ee495f70ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b02a95e8022dca224a076d3ab818ee495f70ecb"}], "stats": {"total": 426, "additions": 340, "deletions": 86}, "files": [{"sha": "51c99a639401572d641d8ec11f305697e3f62fb4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce27ef3d722fcd2d60f092e4fb4ace14f79fa058", "patch": "@@ -2,6 +2,19 @@\n \n \t* config/bfin/bfin.md (doloop_end): FAIL if counter reg isn't SImode.\n \n+\t* config/bfin/bfin.c: Include \"cfglayout.h\".\n+\t(MAX_LSETUP_DISTANCE): New macro.\n+\t(struct loop_info): New members incoming, incoming_src and\n+\tincoming_dest.  Delete member predecessor.\n+\t(length_for_loop): New function.\n+\t(bfin_optimize_loop): Handle more different loop structures.\n+\t(bfin_discover_loop): Rework detection of predecessor blocks by\n+\texamining incoming edges.\n+\t(bfin_discover_loops, bfin_free_loops): New functions, broken out of\n+\tbfin_reorg_loops.\n+\t(bfin_reorder_loops): New function.\n+\t(bfin_reorg_loops): Use these three new functions.\n+\n 2007-02-27  Andreas Schwab  <schwab@suse.de>\n \n \t* Makefile.in (TEXI_GCCINSTALL_FILES): Add gcc-common.texi."}, {"sha": "12212b22cc0a17d2fb301c6eb6d1d32e75988bb8", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 327, "deletions": 86, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce27ef3d722fcd2d60f092e4fb4ace14f79fa058/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=ce27ef3d722fcd2d60f092e4fb4ace14f79fa058", "patch": "@@ -52,6 +52,7 @@\n #include \"tm-preds.h\"\n #include \"gt-bfin.h\"\n #include \"basic-block.h\"\n+#include \"cfglayout.h\"\n #include \"timevar.h\"\n \n /* A C structure for machine-specific, per-function data.\n@@ -3025,6 +3026,9 @@ bfin_hardware_loop (void)\n /* Maximum size of a loop.  */\n #define MAX_LOOP_LENGTH 2042\n \n+/* Maximum distance of the LSETUP instruction from the loop start.  */\n+#define MAX_LSETUP_DISTANCE 30\n+\n /* We need to keep a vector of loops */\n typedef struct loop_info *loop_info;\n DEF_VEC_P (loop_info);\n@@ -3037,9 +3041,16 @@ struct loop_info GTY (())\n   /* loop number, for dumps */\n   int loop_no;\n \n-  /* Predecessor block of the loop.   This is the one that falls into\n-     the loop and contains the initialization instruction.  */\n-  basic_block predecessor;\n+  /* All edges that jump into and out of the loop.  */\n+  VEC(edge,gc) *incoming;\n+\n+  /* We can handle two cases: all incoming edges have the same destination\n+     block, or all incoming edges have the same source block.  These two\n+     members are set to the common source or destination we found, or NULL\n+     if different blocks were found.  If both are NULL the loop can't be\n+     optimized.  */\n+  basic_block incoming_src;\n+  basic_block incoming_dest;\n \n   /* First block in the loop.  This is the one branched to by the loop_end\n      insn.  */\n@@ -3175,6 +3186,31 @@ bfin_scan_loop (loop_info loop, rtx reg, rtx loop_end)\n   return false;\n }\n \n+/* Estimate the length of INSN conservatively.  */\n+\n+static int\n+length_for_loop (rtx insn)\n+{\n+  int length = 0;\n+  if (JUMP_P (insn) && any_condjump_p (insn) && !optimize_size)\n+    {\n+      if (TARGET_CSYNC_ANOMALY)\n+\tlength = 8;\n+      else if (TARGET_SPECLD_ANOMALY)\n+\tlength = 6;\n+    }\n+  else if (LABEL_P (insn))\n+    {\n+      if (TARGET_CSYNC_ANOMALY)\n+\tlength = 4;\n+    }\n+\n+  if (INSN_P (insn))\n+    length += get_attr_length (insn);\n+\n+  return length;\n+}\n+\n /* Optimize LOOP.  */\n \n static void\n@@ -3187,7 +3223,7 @@ bfin_optimize_loop (loop_info loop)\n   rtx reg_lc0, reg_lc1, reg_lt0, reg_lt1, reg_lb0, reg_lb1;\n   rtx iter_reg;\n   rtx lc_reg, lt_reg, lb_reg;\n-  rtx seq;\n+  rtx seq, seq_end;\n   int length;\n   unsigned ix;\n   int inner_depth = 0;\n@@ -3239,30 +3275,40 @@ bfin_optimize_loop (loop_info loop)\n       goto bad_loop;\n     }\n \n+  if (loop->incoming_src)\n+    {\n+      /* Make sure the predecessor is before the loop start label, as required by\n+\t the LSETUP instruction.  */\n+      length = 0;\n+      for (insn = BB_END (loop->incoming_src);\n+\t   insn && insn != loop->start_label;\n+\t   insn = NEXT_INSN (insn))\n+\tlength += length_for_loop (insn);\n+      \n+      if (!insn)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d lsetup not before loop_start\\n\",\n+\t\t     loop->loop_no);\n+\t  goto bad_loop;\n+\t}\n+\n+      if (length > MAX_LSETUP_DISTANCE)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d lsetup too far away\\n\", loop->loop_no);\n+\t  goto bad_loop;\n+\t}\n+    }\n+\n   /* Check if start_label appears before loop_end and calculate the\n      offset between them.  We calculate the length of instructions\n      conservatively.  */\n   length = 0;\n   for (insn = loop->start_label;\n        insn && insn != loop->loop_end;\n        insn = NEXT_INSN (insn))\n-    {\n-      if (JUMP_P (insn) && any_condjump_p (insn) && !optimize_size)\n-\t{\n-\t  if (TARGET_CSYNC_ANOMALY)\n-\t    length += 8;\n-\t  else if (TARGET_SPECLD_ANOMALY)\n-\t    length += 6;\n-\t}\n-      else if (LABEL_P (insn))\n-\t{\n-\t  if (TARGET_CSYNC_ANOMALY)\n-\t    length += 4;\n-\t}\n-\n-      if (INSN_P (insn))\n-\tlength += get_attr_length (insn);\n-    }\n+    length += length_for_loop (insn);\n \n   if (!insn)\n     {\n@@ -3472,21 +3518,64 @@ bfin_optimize_loop (loop_info loop)\n \n   if (loop->init != NULL_RTX)\n     emit_insn (loop->init);\n-  emit_insn(loop->loop_init);\n-  emit_label (loop->start_label);\n+  seq_end = emit_insn (loop->loop_init);\n \n   seq = get_insns ();\n   end_sequence ();\n \n-  emit_insn_after (seq, BB_END (loop->predecessor));\n-  delete_insn (loop->loop_end);\n+  if (loop->incoming_src)\n+    {\n+      rtx prev = BB_END (loop->incoming_src);\n+      if (VEC_length (edge, loop->incoming) > 1\n+\t  || !(VEC_last (edge, loop->incoming)->flags & EDGE_FALLTHRU))\n+\t{\n+\t  gcc_assert (JUMP_P (prev));\n+\t  prev = PREV_INSN (prev);\n+\t}\n+      emit_insn_after (seq, prev);\n+    }\n+  else\n+    {\n+      basic_block new_bb;\n+      edge e;\n+      edge_iterator ei;\n+      \n+      if (loop->head != loop->incoming_dest)\n+\t{\n+\t  FOR_EACH_EDGE (e, ei, loop->head->preds)\n+\t    {\n+\t      if (e->flags & EDGE_FALLTHRU)\n+\t\t{\n+\t\t  rtx newjump = gen_jump (loop->start_label);\n+\t\t  emit_insn_before (newjump, BB_HEAD (loop->head));\n+\t\t  new_bb = create_basic_block (newjump, newjump, loop->head->prev_bb);\n+\t\t  gcc_assert (new_bb = loop->head->prev_bb);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      emit_insn_before (seq, BB_HEAD (loop->head));\n+      seq = emit_label_before (gen_label_rtx (), seq);\n \n+      new_bb = create_basic_block (seq, seq_end, loop->head->prev_bb);\n+      FOR_EACH_EDGE (e, ei, loop->incoming)\n+\t{\n+\t  if (!(e->flags & EDGE_FALLTHRU)\n+\t      || e->dest != loop->head)\n+\t    redirect_edge_and_branch_force (e, new_bb);\n+\t  else\n+\t    redirect_edge_succ (e, new_bb);\n+\t}\n+    }\n+  \n+  delete_insn (loop->loop_end);\n   /* Insert the loop end label before the last instruction of the loop.  */\n   emit_label_before (loop->end_label, loop->last_insn);\n \n   return;\n \n-bad_loop:\n+ bad_loop:\n \n   if (dump_file)\n     fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n@@ -3531,7 +3620,6 @@ bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n   loop->tail = tail_bb;\n   loop->head = BRANCH_EDGE (tail_bb)->dest;\n   loop->successor = FALLTHRU_EDGE (tail_bb)->dest;\n-  loop->predecessor = NULL;\n   loop->loop_end = tail_insn;\n   loop->last_insn = NULL_RTX;\n   loop->iter_reg = SET_DEST (XVECEXP (PATTERN (tail_insn), 0, 1));\n@@ -3540,7 +3628,7 @@ bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n   loop->clobber_loop0 = loop->clobber_loop1 = 0;\n   loop->outer = NULL;\n   loop->loops = NULL;\n-\n+  loop->incoming = VEC_alloc (edge, gc, 2);\n   loop->init = loop->loop_init = NULL_RTX;\n   loop->start_label = XEXP (XEXP (SET_SRC (XVECEXP (PATTERN (tail_insn), 0, 0)), 1), 0);\n   loop->end_label = NULL_RTX;\n@@ -3594,69 +3682,113 @@ bfin_discover_loop (loop_info loop, basic_block tail_bb, rtx tail_insn)\n \t}\n     }\n \n+  /* Find the predecessor, and make sure nothing else jumps into this loop.  */\n   if (!loop->bad)\n     {\n-      /* Make sure we only have one entry point.  */\n-      if (EDGE_COUNT (loop->head->preds) == 2)\n+      int pass, retry;\n+      for (dwork = 0; VEC_iterate (basic_block, loop->blocks, dwork, bb); dwork++)\n \t{\n-\t  loop->predecessor = EDGE_PRED (loop->head, 0)->src;\n-\t  if (loop->predecessor == loop->tail)\n-\t    /* We wanted the other predecessor.  */\n-\t    loop->predecessor = EDGE_PRED (loop->head, 1)->src;\n-\n-\t  /* We can only place a loop insn on a fall through edge of a\n-\t     single exit block.  */\n-\t  if (EDGE_COUNT (loop->predecessor->succs) != 1\n-\t      || !(EDGE_SUCC (loop->predecessor, 0)->flags & EDGE_FALLTHRU)\n-\t      /* If loop->predecessor is in loop, loop->head is not really\n-\t\t the head of the loop.  */\n-\t      || bfin_bb_in_loop (loop, loop->predecessor))\n-\t    loop->predecessor = NULL;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    {\n+\t      basic_block pred = e->src;\n+\n+\t      if (!bfin_bb_in_loop (loop, pred))\n+\t\t{\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \";; Loop %d: incoming edge %d -> %d\\n\",\n+\t\t\t     loop->loop_no, pred->index,\n+\t\t\t     e->dest->index);\n+\t\t  VEC_safe_push (edge, gc, loop->incoming, e);\n+\t\t}\n+\t    }\n \t}\n \n-      if (loop->predecessor == NULL)\n+      for (pass = 0, retry = 1; retry && pass < 2; pass++)\n \t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \";; loop has bad predecessor\\n\");\n-\t  loop->bad = 1;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  bool first = true;\n+\t  retry = 0;\n+\n+\t  FOR_EACH_EDGE (e, ei, loop->incoming)\n+\t    {\n+\t      if (first)\n+\t\t{\n+\t\t  loop->incoming_src = e->src;\n+\t\t  loop->incoming_dest = e->dest;\n+\t\t  first = false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (e->dest != loop->incoming_dest)\n+\t\t    loop->incoming_dest = NULL;\n+\t\t  if (e->src != loop->incoming_src)\n+\t\t    loop->incoming_src = NULL;\n+\t\t}\n+\t      if (loop->incoming_src == NULL && loop->incoming_dest == NULL)\n+\t\t{\n+\t\t  if (pass == 0)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \";; retrying loop %d with forwarder blocks\\n\",\n+\t\t\t\t loop->loop_no);\n+\t\t      retry = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t  loop->bad = 1;\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \";; can't find suitable entry for loop %d\\n\",\n+\t\t\t     loop->loop_no);\n+\t\t  goto out;\n+\t\t}\n+\t    }\n+\t  if (retry)\n+\t    {\n+\t      retry = 0;\n+\t      FOR_EACH_EDGE (e, ei, loop->incoming)\n+\t\t{\n+\t\t  if (forwarder_block_p (e->src))\n+\t\t    {\n+\t\t      edge e2;\n+\t\t      edge_iterator ei2;\n+\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \";; Adding forwarder block %d to loop %d and retrying\\n\",\n+\t\t\t\t e->src->index, loop->loop_no);\n+\t\t      VEC_safe_push (basic_block, heap, loop->blocks, e->src);\n+\t\t      bitmap_set_bit (loop->block_bitmap, e->src->index);\n+\t\t      FOR_EACH_EDGE (e2, ei2, e->src->preds)\n+\t\t\tVEC_safe_push (edge, gc, loop->incoming, e2);\n+\t\t      VEC_unordered_remove (edge, loop->incoming, ei.index);\n+\t\t      retry = 1;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n \n-#ifdef ENABLE_CHECKING\n-  /* Make sure nothing jumps into this loop.  This shouldn't happen as we\n-     wouldn't have generated the counted loop patterns in such a case.\n-     However, this test must be done after the test above to detect loops\n-     with invalid headers.  */\n-  if (!loop->bad)\n-    for (dwork = 0; VEC_iterate (basic_block, loop->blocks, dwork, bb); dwork++)\n-      {\n-\tedge e;\n-\tedge_iterator ei;\n-\tif (bb == loop->head)\n-\t  continue;\n-\tFOR_EACH_EDGE (e, ei, bb->preds)\n-\t  {\n-\t    basic_block pred = EDGE_PRED (bb, ei.index)->src;\n-\t    if (!bfin_bb_in_loop (loop, pred))\n-\t      abort ();\n-\t  }\n-      }\n-#endif\n+ out:\n   VEC_free (basic_block, heap, works);\n }\n \n-static void\n-bfin_reorg_loops (FILE *dump_file)\n+/* Analyze the structure of the loops in the current function.  Use STACK\n+   for bitmap allocations.  Returns all the valid candidates for hardware\n+   loops found in this function.  */\n+static loop_info\n+bfin_discover_loops (bitmap_obstack *stack, FILE *dump_file)\n {\n-  bitmap_obstack stack;\n-  bitmap tmp_bitmap;\n-  basic_block bb;\n   loop_info loops = NULL;\n   loop_info loop;\n+  basic_block bb;\n+  bitmap tmp_bitmap;\n   int nloops = 0;\n \n-  bitmap_obstack_initialize (&stack);\n-\n   /* Find all the possible loop tails.  This means searching for every\n      loop_end instruction.  For each one found, create a loop_info\n      structure and add the head block to the work list. */\n@@ -3678,7 +3810,7 @@ bfin_reorg_loops (FILE *dump_file)\n \t  loops = loop;\n \t  loop->loop_no = nloops++;\n \t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n-\t  loop->block_bitmap = BITMAP_ALLOC (&stack);\n+\t  loop->block_bitmap = BITMAP_ALLOC (stack);\n \t  bb->aux = loop;\n \n \t  if (dump_file)\n@@ -3692,7 +3824,7 @@ bfin_reorg_loops (FILE *dump_file)\n \t}\n     }\n \n-  tmp_bitmap = BITMAP_ALLOC (&stack);\n+  tmp_bitmap = BITMAP_ALLOC (stack);\n   /* Compute loop nestings.  */\n   for (loop = loops; loop; loop = loop->next)\n     {\n@@ -3720,12 +3852,130 @@ bfin_reorg_loops (FILE *dump_file)\n \t    }\n \t  else\n \t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \";; can't find suitable nesting for loops %d and %d\\n\",\n+\t\t\t loop->loop_no, other->loop_no);\n \t      loop->bad = other->bad = 1;\n \t    }\n \t}\n     }\n   BITMAP_FREE (tmp_bitmap);\n \n+  return loops;\n+}\n+\n+/* Free up the loop structures in LOOPS.  */\n+static void\n+free_loops (loop_info loops)\n+{\n+  while (loops)\n+    {\n+      loop_info loop = loops;\n+      loops = loop->next;\n+      VEC_free (loop_info, heap, loop->loops);\n+      VEC_free (basic_block, heap, loop->blocks);\n+      BITMAP_FREE (loop->block_bitmap);\n+      XDELETE (loop);\n+    }\n+}\n+\n+#define BB_AUX_INDEX(BB) ((unsigned)(BB)->aux)\n+\n+/* The taken-branch edge from the loop end can actually go forward.  Since the\n+   Blackfin's LSETUP instruction requires that the loop end be after the loop\n+   start, try to reorder a loop's basic blocks when we find such a case.  */\n+static void\n+bfin_reorder_loops (loop_info loops, FILE *dump_file)\n+{\n+  basic_block bb;\n+  loop_info loop;\n+\n+  FOR_EACH_BB (bb)\n+    bb->aux = NULL;\n+  cfg_layout_initialize (CLEANUP_UPDATE_LIFE);\n+\n+  for (loop = loops; loop; loop = loop->next)\n+    {\n+      unsigned index;\n+      basic_block bb;\n+      edge e;\n+      edge_iterator ei;\n+\n+      if (loop->bad)\n+\tcontinue;\n+\n+      /* Recreate an index for basic blocks that represents their order.  */\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n+\t   bb != EXIT_BLOCK_PTR;\n+\t   bb = bb->next_bb, index++)\n+\tbb->aux = (PTR) index;\n+\n+      if (BB_AUX_INDEX (loop->head) < BB_AUX_INDEX (loop->tail))\n+\tcontinue;\n+\n+      FOR_EACH_EDGE (e, ei, loop->head->succs)\n+\t{\n+\t  if (bitmap_bit_p (loop->block_bitmap, e->dest->index)\n+\t      && BB_AUX_INDEX (e->dest) < BB_AUX_INDEX (loop->tail))\n+\t    {\n+\t      basic_block start_bb = e->dest;\n+\t      basic_block start_prev_bb = start_bb->prev_bb;\n+\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \";; Moving block %d before block %d\\n\",\n+\t\t\t loop->head->index, start_bb->index);\n+\t      loop->head->prev_bb->next_bb = loop->head->next_bb;\n+\t      loop->head->next_bb->prev_bb = loop->head->prev_bb;\n+\n+\t      loop->head->prev_bb = start_prev_bb;\n+\t      loop->head->next_bb = start_bb;\n+\t      start_prev_bb->next_bb = start_bb->prev_bb = loop->head;\n+\t      break;\n+\t    }\n+\t}\n+      loops = loops->next;\n+    }\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb->next_bb != EXIT_BLOCK_PTR)\n+\tbb->aux = bb->next_bb;\n+      else\n+\tbb->aux = NULL;\n+    }\n+  cfg_layout_finalize ();\n+}\n+\n+/* Run from machine_dependent_reorg, this pass looks for doloop_end insns\n+   and tries to rewrite the RTL of these loops so that proper Blackfin\n+   hardware loops are generated.  */\n+\n+static void\n+bfin_reorg_loops (FILE *dump_file)\n+{\n+  loop_info loops = NULL;\n+  loop_info loop;\n+  basic_block bb;\n+  bitmap_obstack stack;\n+\n+  bitmap_obstack_initialize (&stack);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \";; Find loops, first pass\\n\\n\");\n+\n+  loops = bfin_discover_loops (&stack, dump_file);\n+\n+  if (dump_file)\n+    bfin_dump_loops (loops);\n+\n+  bfin_reorder_loops (loops, dump_file);\n+  free_loops (loops);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \";; Find loops, second pass\\n\\n\");\n+\n+  loops = bfin_discover_loops (&stack, dump_file);\n   if (dump_file)\n     {\n       fprintf (dump_file, \";; All loops found:\\n\\n\");\n@@ -3742,16 +3992,7 @@ bfin_reorg_loops (FILE *dump_file)\n       bfin_dump_loops (loops);\n     }\n \n-  /* Free up the loop structures */\n-  while (loops)\n-    {\n-      loop = loops;\n-      loops = loop->next;\n-      VEC_free (loop_info, heap, loop->loops);\n-      VEC_free (basic_block, heap, loop->blocks);\n-      BITMAP_FREE (loop->block_bitmap);\n-      XDELETE (loop);\n-    }\n+  free_loops (loops);\n \n   if (dump_file)\n     print_rtl (dump_file, get_insns ());"}]}