{"sha": "96cbfa7ff8a146febd6af9a53d10468a90706419", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZjYmZhN2ZmOGExNDZmZWJkNmFmOWE1M2QxMDQ2OGE5MDcwNjQxOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-27T22:05:41Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-27T22:05:41Z"}, "message": "PR c++/92206 - ICE with typedef to dependent alias.\n\nrsandifo's patch for 92206 demonstrated a problem with the existing checking\nfor alias template specializations: they were returning false for a typedef\nto an alias template specialization.  Which is sometimes what the caller\nwants, and sometimes not: Sometimes we're interested in whether the type was\nwritten as an alias template-id, and sometimes whether it represents one.\n\nThe testcase illustrates a case that remained wrong with the earlier patch:\nif the typedef is itself an alias template specialization, we can't strip an\nunderlying dependent alias.\n\n\t* pt.c (dependent_alias_template_spec_p)\n\t(alias_template_specialization_p): Add transparent_typedefs\n\tparameter.\n\t(iterative_hash_template_arg, any_template_parm_r)\n\t(primary_template_specialization_p, tsubst, dependent_type_p_r):\n\tAdjust.\n\t* decl.c (check_elaborated_type_specifier): Adjust.\n\t* error.c (dump_template_bindings, dump_aggr_type): Adjust.\n\nFrom-SVN: r278784", "tree": {"sha": "f585e46432a0cccd16721f316ffa8727271560fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f585e46432a0cccd16721f316ffa8727271560fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96cbfa7ff8a146febd6af9a53d10468a90706419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cbfa7ff8a146febd6af9a53d10468a90706419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96cbfa7ff8a146febd6af9a53d10468a90706419", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96cbfa7ff8a146febd6af9a53d10468a90706419/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a92cc0da1c4c85b5ac8bb3eb013946ee9ad3a40f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a92cc0da1c4c85b5ac8bb3eb013946ee9ad3a40f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a92cc0da1c4c85b5ac8bb3eb013946ee9ad3a40f"}], "stats": {"total": 128, "additions": 89, "deletions": 39}, "files": [{"sha": "0f26009b2be9fbd66a1a465ed86bf56708a2dfc6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -1,3 +1,15 @@\n+2019-11-12  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/92206 - ICE with typedef to dependent alias.\n+\t* pt.c (dependent_alias_template_spec_p)\n+\t(alias_template_specialization_p): Add transparent_typedefs\n+\tparameter.\n+\t(iterative_hash_template_arg, any_template_parm_r)\n+\t(primary_template_specialization_p, tsubst, dependent_type_p_r):\n+\tAdjust.\n+\t* decl.c (check_elaborated_type_specifier): Adjust.\n+\t* error.c (dump_template_bindings, dump_aggr_type): Adjust.\n+\n 2019-11-27  Andrew Sutton  <asutton@lock3software.com>\n \n \tPR c++/92236"}, {"sha": "d8e12e99ba3c5283915304ebbd0f2dd7417fc6cd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -6938,8 +6938,9 @@ extern tree instantiate_non_dependent_expr_internal (tree, tsubst_flags_t);\n extern tree instantiate_non_dependent_or_null   (tree);\n extern bool variable_template_specialization_p  (tree);\n extern bool alias_type_or_template_p            (tree);\n-extern bool alias_template_specialization_p     (const_tree);\n-extern bool dependent_alias_template_spec_p     (const_tree);\n+enum { nt_opaque = false, nt_transparent = true };\n+extern tree alias_template_specialization_p     (const_tree, bool);\n+extern tree dependent_alias_template_spec_p     (const_tree, bool);\n extern bool template_parm_object_p\t\t(const_tree);\n extern bool explicit_class_specialization_p     (tree);\n extern bool push_tinst_level                    (tree);"}, {"sha": "7d5bc914d2d407e4409714906bf57da12ff35efc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -14548,7 +14548,7 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \t   && !DECL_SELF_REFERENCE_P (decl)\n \t   && tag_code != typename_type)\n     {\n-      if (alias_template_specialization_p (type))\n+      if (alias_template_specialization_p (type, nt_opaque))\n \terror (\"using alias template specialization %qT after %qs\",\n \t       type, tag_name (tag_code));\n       else"}, {"sha": "a15230a1f012af34689b836acc99e5ff9885d033", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -421,7 +421,7 @@ dump_template_bindings (cxx_pretty_printer *pp, tree parms, tree args,\n static void\n dump_alias_template_specialization (cxx_pretty_printer *pp, tree t, int flags)\n {\n-  gcc_assert (alias_template_specialization_p (t));\n+  gcc_assert (alias_template_specialization_p (t, nt_opaque));\n \n   tree decl = TYPE_NAME (t);\n   if (!(flags & TFF_UNQUALIFIED_NAME))\n@@ -454,7 +454,7 @@ dump_type (cxx_pretty_printer *pp, tree t, int flags)\n \t\t\t\t    ? STF_USER_VISIBLE : 0);\n \t  t = strip_typedefs (t, NULL, stf_flags);\n \t}\n-      else if (alias_template_specialization_p (t))\n+      else if (alias_template_specialization_p (t, nt_opaque))\n \t{\n \t  dump_alias_template_specialization (pp, t, flags);\n \t  return;\n@@ -711,7 +711,7 @@ dump_aggr_type (cxx_pretty_printer *pp, tree t, int flags)\n       typdef = (!DECL_ARTIFICIAL (name)\n \t\t/* An alias specialization is not considered to be a\n \t\t   typedef.  */\n-\t\t&& !alias_template_specialization_p (t));\n+\t\t&& !alias_template_specialization_p (t, nt_opaque));\n \n       if ((typdef\n \t   && ((flags & TFF_CHASE_TYPEDEF)"}, {"sha": "244eb7d4ff355dd2dc6bc5d6abe32cf3092e1dae", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -1882,7 +1882,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n   switch (tclass)\n     {\n     case tcc_type:\n-      if (alias_template_specialization_p (arg))\n+      if (tree ats = alias_template_specialization_p (arg, nt_transparent))\n \t{\n \t  // We want an alias specialization that survived strip_typedefs\n \t  // to hash differently from its TYPE_CANONICAL, to avoid hash\n@@ -1891,7 +1891,7 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n \t  // left alone, or untouched specializations because\n \t  // coerce_template_parms returns the unconverted template\n \t  // arguments if it sees incomplete argument packs.\n-\t  tree ti = TYPE_ALIAS_TEMPLATE_INFO (arg);\n+\t  tree ti = TYPE_ALIAS_TEMPLATE_INFO (ats);\n \t  return hash_tmpl_and_args (TI_TEMPLATE (ti), TI_ARGS (ti));\n \t}\n       if (TYPE_CANONICAL (arg))\n@@ -3575,7 +3575,7 @@ primary_template_specialization_p (const_tree t)\n     return (CLASSTYPE_TEMPLATE_INFO (t)\n \t    && CLASSTYPE_USE_TEMPLATE (t)\n \t    && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)));\n-  else if (alias_template_specialization_p (t))\n+  else if (alias_template_specialization_p (t, nt_transparent))\n     return true;\n   return false;\n }\n@@ -6298,18 +6298,30 @@ alias_type_or_template_p (tree t)\n \t  || DECL_ALIAS_TEMPLATE_P (t));\n }\n \n-/* Return TRUE iff T is a specialization of an alias template.  */\n+/* If T is a specialization of an alias template, return it; otherwise return\n+   NULL_TREE.  If TRANSPARENT_TYPEDEFS is true, look through other aliases.  */\n \n-bool\n-alias_template_specialization_p (const_tree t)\n+tree\n+alias_template_specialization_p (const_tree t,\n+\t\t\t\t bool transparent_typedefs)\n {\n+  if (!TYPE_P (t))\n+    return NULL_TREE;\n+\n   /* It's an alias template specialization if it's an alias and its\n      TYPE_NAME is a specialization of a primary template.  */\n-  if (TYPE_ALIAS_P (t))\n-    if (tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t))\n-      return PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo));\n+  if (typedef_variant_p (t))\n+    {\n+      if (tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t))\n+\tif (PRIMARY_TEMPLATE_P (TI_TEMPLATE (tinfo)))\n+\t  return CONST_CAST_TREE (t);\n+      if (transparent_typedefs)\n+\treturn alias_template_specialization_p (DECL_ORIGINAL_TYPE\n+\t\t\t\t\t\t(TYPE_NAME (t)),\n+\t\t\t\t\t\ttransparent_typedefs);\n+    }\n \n-  return false;\n+  return NULL_TREE;\n }\n \n /* An alias template is complex from a SFINAE perspective if a template-id\n@@ -6354,24 +6366,30 @@ complex_alias_template_p (const_tree tmpl)\n   return false;\n }\n \n-/* Return TRUE iff T is a specialization of a complex alias template with\n-   dependent template-arguments.  */\n+/* If T is a specialization of a complex alias template with dependent\n+   template-arguments, return it; otherwise return NULL_TREE.  If T is a\n+   typedef to such a specialization, return the specialization.  */\n \n-bool\n-dependent_alias_template_spec_p (const_tree t)\n+tree\n+dependent_alias_template_spec_p (const_tree t, bool transparent_typedefs)\n {\n-  if (!alias_template_specialization_p (t))\n-    return false;\n+  if (!TYPE_P (t) || !typedef_variant_p (t))\n+    return NULL_TREE;\n \n   tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t);\n-  if (!TEMPLATE_DECL_COMPLEX_ALIAS_P (TI_TEMPLATE (tinfo)))\n-    return false;\n+  if (tinfo\n+      && TEMPLATE_DECL_COMPLEX_ALIAS_P (TI_TEMPLATE (tinfo))\n+      && (any_dependent_template_arguments_p\n+\t  (INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo)))))\n+    return CONST_CAST_TREE (t);\n \n-  tree args = INNERMOST_TEMPLATE_ARGS (TI_ARGS (tinfo));\n-  if (!any_dependent_template_arguments_p (args))\n-    return false;\n+  if (transparent_typedefs)\n+    {\n+      tree utype = DECL_ORIGINAL_TYPE (TYPE_NAME (t));\n+      return dependent_alias_template_spec_p (utype, transparent_typedefs);\n+    }\n \n-  return true;\n+  return NULL_TREE;\n }\n \n /* Return the number of innermost template parameters in TMPL.  */\n@@ -10384,9 +10402,9 @@ any_template_parm_r (tree t, void *data)\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:\n       /* Search for template parameters in type aliases.  */\n-      if (alias_template_specialization_p (t))\n+      if (tree ats = alias_template_specialization_p (t, nt_opaque))\n \t{\n-\t  tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (t);\n+\t  tree tinfo = TYPE_ALIAS_TEMPLATE_INFO (ats);\n \t  WALK_SUBTREE (TI_ARGS (tinfo));\n         }\n       break;\n@@ -14896,7 +14914,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     {\n       tree decl = TYPE_NAME (t);\n \n-      if (alias_template_specialization_p (t))\n+      if (alias_template_specialization_p (t, nt_opaque))\n \t{\n \t  /* DECL represents an alias template and we want to\n \t     instantiate it.  */\n@@ -25815,7 +25833,7 @@ dependent_type_p_r (tree type)\n \n   /* An alias template specialization can be dependent even if the\n      resulting type is not.  */\n-  if (dependent_alias_template_spec_p (type))\n+  if (dependent_alias_template_spec_p (type, nt_transparent))\n     return true;\n \n   /* -- a cv-qualified type where the cv-unqualified type is"}, {"sha": "f500ee614427c6ee52429e8c8636f0638558c6b7", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -1489,7 +1489,7 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n     return t;\n \n   if (!(flags & STF_STRIP_DEPENDENT)\n-      && dependent_alias_template_spec_p (t))\n+      && dependent_alias_template_spec_p (t, nt_opaque))\n     /* DR 1558: However, if the template-id is dependent, subsequent\n        template argument substitution still applies to the template-id.  */\n     return t;\n@@ -1673,14 +1673,19 @@ strip_typedefs (tree t, bool *remove_attributes, unsigned int flags)\n \t  if ((flags & STF_USER_VISIBLE)\n \t      && !user_facing_original_type_p (t))\n \t    return t;\n+\t  /* If T is a non-template alias or typedef, we can assume that\n+\t     instantiating its definition will hit any substitution failure,\n+\t     so we don't need to retain it here as well.  */\n+\t  if (!alias_template_specialization_p (t, nt_opaque))\n+\t    flags |= STF_STRIP_DEPENDENT;\n \t  result = strip_typedefs (DECL_ORIGINAL_TYPE (TYPE_NAME (t)),\n-\t\t\t\t   remove_attributes,\n-\t\t\t\t   flags | STF_STRIP_DEPENDENT);\n+\t\t\t\t   remove_attributes, flags);\n \t}\n       else\n \tresult = TYPE_MAIN_VARIANT (t);\n     }\n   gcc_assert (!typedef_variant_p (result)\n+\t      || dependent_alias_template_spec_p (result, nt_opaque)\n \t      || ((flags & STF_USER_VISIBLE)\n \t\t  && !user_facing_original_type_p (result)));\n "}, {"sha": "a9b87ea8caf6175f863ebc46983cb907a6ef1b4b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -1463,10 +1463,13 @@ structural_comptypes (tree t1, tree t2, int strict)\n      substitute into the specialization arguments at instantiation\n      time.  And aliases can't be equivalent without being ==, so\n      we don't need to look any deeper.  */\n-  if (comparing_specializations\n-      && (dependent_alias_template_spec_p (t1)\n-\t  || dependent_alias_template_spec_p (t2)))\n-    return false;\n+  if (comparing_specializations)\n+    {\n+      tree dep1 = dependent_alias_template_spec_p (t1, nt_transparent);\n+      tree dep2 = dependent_alias_template_spec_p (t2, nt_transparent);\n+      if ((dep1 || dep2) && dep1 != dep2)\n+\treturn false;\n+    }\n \n   /* If we get here, we know that from a target independent POV the\n      types are the same.  Make sure the target attributes are also"}, {"sha": "4c86d4567cef3fd87527f5f15df4af9f9f1d04cf", "filename": "gcc/testsuite/g++.dg/cpp0x/alias-decl-pr92206-4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-pr92206-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96cbfa7ff8a146febd6af9a53d10468a90706419/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-pr92206-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Falias-decl-pr92206-4.C?ref=96cbfa7ff8a146febd6af9a53d10468a90706419", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <typename T> struct A { };\n+template <typename T, int = sizeof(typename T::type)> using AA = A<T>; // { dg-error  \"char\" }\n+template <typename T> using AAA = AA<T>;\n+\n+template <class T> struct C { };\n+template <class T> struct B {\n+  C<AAA<T>> a;\n+};\n+B<char> b;\t\t\t// { dg-message \"\" }"}]}