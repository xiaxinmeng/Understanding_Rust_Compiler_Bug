{"sha": "4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEwZDBlZDI4ZmU5Njk1Yjk1ZTMwYjVhZWE0ZTQ1Yzc4NDIwZDM1OQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2018-01-12T14:06:10Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2018-01-12T14:06:10Z"}, "message": "Deferring FMA transformations in tight loops\n\n2018-01-12  Martin Jambor  <mjambor@suse.cz>\n\n\tPR target/81616\n\t* params.def: New parameter PARAM_AVOID_FMA_MAX_BITS.\n\t* tree-ssa-math-opts.c: Include domwalk.h.\n\t(convert_mult_to_fma_1): New function.\n\t(fma_transformation_info): New type.\n\t(fma_deferring_state): Likewise.\n\t(cancel_fma_deferring): New function.\n\t(result_of_phi): Likewise.\n\t(last_fma_candidate_feeds_initial_phi): Likewise.\n\t(convert_mult_to_fma): Added deferring logic, split actual\n\ttransformation to convert_mult_to_fma_1.\n\t(math_opts_dom_walker): New type.\n\t(math_opts_dom_walker::after_dom_children): New method, body moved\n\there from pass_optimize_widening_mul::execute, added deferring logic\n\tbits.\n\t(pass_optimize_widening_mul::execute): Moved most of code to\n\tmath_opts_dom_walker::after_dom_children.\n\t* config/i386/x86-tune.def (X86_TUNE_AVOID_128FMA_CHAINS): New.\n\t* config/i386/i386.c (ix86_option_override_internal): Added\n\tmaybe_setting of PARAM_AVOID_FMA_MAX_BITS.\n\nFrom-SVN: r256581", "tree": {"sha": "5e18b1f41b0315bea315561fce77a37210e2e2f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e18b1f41b0315bea315561fce77a37210e2e2f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "80c93fa982c59cb94183d225d28e6763f5707025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80c93fa982c59cb94183d225d28e6763f5707025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80c93fa982c59cb94183d225d28e6763f5707025"}], "stats": {"total": 554, "additions": 426, "deletions": 128}, "files": [{"sha": "198a89d521c7d7af62643038de59f943be63050d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "patch": "@@ -1,3 +1,26 @@\n+2018-01-12  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR target/81616\n+\t* params.def: New parameter PARAM_AVOID_FMA_MAX_BITS.\n+\t* tree-ssa-math-opts.c: Include domwalk.h.\n+\t(convert_mult_to_fma_1): New function.\n+\t(fma_transformation_info): New type.\n+\t(fma_deferring_state): Likewise.\n+\t(cancel_fma_deferring): New function.\n+\t(result_of_phi): Likewise.\n+\t(last_fma_candidate_feeds_initial_phi): Likewise.\n+\t(convert_mult_to_fma): Added deferring logic, split actual\n+\ttransformation to convert_mult_to_fma_1.\n+\t(math_opts_dom_walker): New type.\n+\t(math_opts_dom_walker::after_dom_children): New method, body moved\n+\there from pass_optimize_widening_mul::execute, added deferring logic\n+\tbits.\n+\t(pass_optimize_widening_mul::execute): Moved most of code to\n+\tmath_opts_dom_walker::after_dom_children.\n+\t* config/i386/x86-tune.def (X86_TUNE_AVOID_128FMA_CHAINS): New.\n+\t* config/i386/i386.c (ix86_option_override_internal): Added\n+\tmaybe_setting of PARAM_AVOID_FMA_MAX_BITS.\n+\n 2018-01-12  Richard Biener  <rguenther@suse.de>\n \n \tPR debug/83157"}, {"sha": "d56c83fff7fc92954464a8501daa8db08c35c85e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "patch": "@@ -4900,6 +4900,11 @@ ix86_option_override_internal (bool main_args_p,\n \t(cf_protection_level) (opts->x_flag_cf_protection | CF_SET);\n     }\n \n+  if (ix86_tune_features [X86_TUNE_AVOID_128FMA_CHAINS])\n+    maybe_set_param_value (PARAM_AVOID_FMA_MAX_BITS, 128,\n+\t\t\t   opts->x_param_values,\n+\t\t\t   opts_set->x_param_values);\n+\n   return true;\n }\n "}, {"sha": "53d0e1622ac2350419d3273cb152b835be498f74", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "patch": "@@ -403,6 +403,10 @@ DEF_TUNE (X86_TUNE_AVOID_4BYTE_PREFIXES, \"avoid_4byte_prefixes\",\n DEF_TUNE (X86_TUNE_USE_GATHER, \"use_gather\",\n           ~(m_ZNVER1 | m_GENERIC))\n \n+/* X86_TUNE_AVOID_128FMA_CHAINS: Avoid creating loops with tight 128bit or\n+   smaller FMA chain.  */\n+DEF_TUNE (X86_TUNE_AVOID_128FMA_CHAINS, \"avoid_fma_chains\", m_ZNVER1)\n+\n /*****************************************************************************/\n /* AVX instruction selection tuning (some of SSE flags affects AVX, too)     */\n /*****************************************************************************/"}, {"sha": "a0cd06db339423aa02a2cafa02937b15d14c42c5", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "patch": "@@ -1326,6 +1326,11 @@ DEFPARAM(PARAM_UNROLL_JAM_MAX_UNROLL,\n \t \"Maximum unroll factor for the unroll-and-jam transformation.\",\n \t 4, 0, 0)\n \n+DEFPARAM(PARAM_AVOID_FMA_MAX_BITS,\n+\t \"avoid-fma-max-bits\",\n+\t \"Maximum number of bits for which we avoid creating FMAs.\",\n+\t 0, 0, 512)\n+\n /*\n \n Local variables:"}, {"sha": "16d9399af0b0922d1a4823b33c3880d41dc3cc90", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 389, "deletions": 128, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a0d0ed28fe9695b95e30b5aea4e45c78420d359/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=4a0d0ed28fe9695b95e30b5aea4e45c78420d359", "patch": "@@ -115,6 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"optabs-libfuncs.h\"\n #include \"tree-eh.h\"\n #include \"targhooks.h\"\n+#include \"domwalk.h\"\n \n /* This structure represents one basic block that either computes a\n    division, or is a common dominator for basic block that compute a\n@@ -2639,17 +2640,214 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple *stmt,\n   return true;\n }\n \n+/* Given a result MUL_RESULT which is a result of a multiplication of OP1 and\n+   OP2 and which we know is used in statements that can be, together with the\n+   multiplication, converted to FMAs, perform the transformation.  */\n+\n+static void\n+convert_mult_to_fma_1 (tree mul_result, tree op1, tree op2)\n+{\n+  tree type = TREE_TYPE (mul_result);\n+  gimple *use_stmt;\n+  imm_use_iterator imm_iter;\n+  gassign *fma_stmt;\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+      enum tree_code use_code;\n+      tree addop, mulop1 = op1, result = mul_result;\n+      bool negate_p = false;\n+\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n+\n+      use_code = gimple_assign_rhs_code (use_stmt);\n+      if (use_code == NEGATE_EXPR)\n+\t{\n+\t  result = gimple_assign_lhs (use_stmt);\n+\t  use_operand_p use_p;\n+\t  gimple *neguse_stmt;\n+\t  single_imm_use (gimple_assign_lhs (use_stmt), &use_p, &neguse_stmt);\n+\t  gsi_remove (&gsi, true);\n+\t  release_defs (use_stmt);\n+\n+\t  use_stmt = neguse_stmt;\n+\t  gsi = gsi_for_stmt (use_stmt);\n+\t  use_code = gimple_assign_rhs_code (use_stmt);\n+\t  negate_p = true;\n+\t}\n+\n+      if (gimple_assign_rhs1 (use_stmt) == result)\n+\t{\n+\t  addop = gimple_assign_rhs2 (use_stmt);\n+\t  /* a * b - c -> a * b + (-c)  */\n+\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t    addop = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t\t      build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t      type, addop),\n+\t\t\t\t\t      true, NULL_TREE, true,\n+\t\t\t\t\t      GSI_SAME_STMT);\n+\t}\n+      else\n+\t{\n+\t  addop = gimple_assign_rhs1 (use_stmt);\n+\t  /* a - b * c -> (-b) * c + a */\n+\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t    negate_p = !negate_p;\n+\t}\n+\n+      if (negate_p)\n+\tmulop1 = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t\t   build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t   type, mulop1),\n+\t\t\t\t\t   true, NULL_TREE, true,\n+\t\t\t\t\t   GSI_SAME_STMT);\n+\n+      fma_stmt = gimple_build_assign (gimple_assign_lhs (use_stmt),\n+\t\t\t\t      FMA_EXPR, mulop1, op2, addop);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Generated FMA \");\n+\t  print_gimple_stmt (dump_file, fma_stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      gsi_replace (&gsi, fma_stmt, true);\n+      widen_mul_stats.fmas_inserted++;\n+    }\n+}\n+\n+/* Data necessary to perform the actual transformation from a multiplication\n+   and an addition to an FMA after decision is taken it should be done and to\n+   then delete the multiplication statement from the function IL.  */\n+\n+struct fma_transformation_info\n+{\n+  gimple *mul_stmt;\n+  tree mul_result;\n+  tree op1;\n+  tree op2;\n+};\n+\n+/* Structure containing the current state of FMA deferring, i.e. whether we are\n+   deferring, whether to continue deferring, and all data necessary to come\n+   back and perform all deferred transformations.  */\n+\n+class fma_deferring_state\n+{\n+public:\n+  /* Class constructor.  Pass true as PERFORM_DEFERRING in order to actually\n+     do any deferring.  */\n+\n+  fma_deferring_state (bool perform_deferring)\n+    : m_candidates (), m_mul_result_set (), m_initial_phi (NULL),\n+      m_last_result (NULL_TREE), m_deferring_p (perform_deferring) {}\n+\n+  /* List of FMA candidates for which we the transformation has been determined\n+     possible but we at this point in BB analysis we do not consider them\n+     beneficial.  */\n+  auto_vec<fma_transformation_info, 8> m_candidates;\n+\n+  /* Set of results of multiplication that are part of an already deferred FMA\n+     candidates.  */\n+  hash_set<tree> m_mul_result_set;\n+\n+  /* The PHI that supposedly feeds back result of a FMA to another over loop\n+     boundary.  */\n+  gphi *m_initial_phi;\n+\n+  /* Result of the last produced FMA candidate or NULL if there has not been\n+     one.  */\n+  tree m_last_result;\n+\n+  /* If true, deferring might still be profitable.  If false, transform all\n+     candidates and no longer defer.  */\n+  bool m_deferring_p;\n+};\n+\n+/* Transform all deferred FMA candidates and mark STATE as no longer\n+   deferring.  */\n+\n+static void\n+cancel_fma_deferring (fma_deferring_state *state)\n+{\n+  if (!state->m_deferring_p)\n+    return;\n+\n+  for (unsigned i = 0; i < state->m_candidates.length (); i++)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"Generating deferred FMA\\n\");\n+\n+      const fma_transformation_info &fti = state->m_candidates[i];\n+      convert_mult_to_fma_1 (fti.mul_result, fti.op1, fti.op2);\n+\n+      gimple_stmt_iterator gsi = gsi_for_stmt (fti.mul_stmt);\n+      gsi_remove (&gsi, true);\n+      release_defs (fti.mul_stmt);\n+    }\n+  state->m_deferring_p = false;\n+}\n+\n+/* If OP is an SSA name defined by a PHI node, return the PHI statement.\n+   Otherwise return NULL.  */\n+\n+static gphi *\n+result_of_phi (tree op)\n+{\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return NULL;\n+\n+  return dyn_cast <gphi *> (SSA_NAME_DEF_STMT (op));\n+}\n+\n+/* After processing statements of a BB and recording STATE, return true if the\n+   initial phi is fed by the last FMA candidate result ore one such result from\n+   previously processed BBs marked in LAST_RESULT_SET.  */\n+\n+static bool\n+last_fma_candidate_feeds_initial_phi (fma_deferring_state *state,\n+\t\t\t\t      hash_set<tree> *last_result_set)\n+{\n+  ssa_op_iter iter;\n+  use_operand_p use;\n+  FOR_EACH_PHI_ARG (use, state->m_initial_phi, iter, SSA_OP_USE)\n+    {\n+      tree t = USE_FROM_PTR (use);\n+      if (t == state->m_last_result\n+\t  || last_result_set->contains (t))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Combine the multiplication at MUL_STMT with operands MULOP1 and MULOP2\n    with uses in additions and subtractions to form fused multiply-add\n-   operations.  Returns true if successful and MUL_STMT should be removed.  */\n+   operations.  Returns true if successful and MUL_STMT should be removed.\n+\n+   If STATE indicates that we are deferring FMA transformation, that means\n+   that we do not produce FMAs for basic blocks which look like:\n+\n+    <bb 6>\n+    # accumulator_111 = PHI <0.0(5), accumulator_66(6)>\n+    _65 = _14 * _16;\n+    accumulator_66 = _65 + accumulator_111;\n+\n+  or its unrolled version, i.e. with several FMA candidates that feed result\n+  of one into the addend of another.  Instead, we add them to a list in STATE\n+  and if we later discover an FMA candidate that is not part of such a chain,\n+  we go back and perform all deferred past candidates.  */\n \n static bool\n-convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2)\n+convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n+\t\t     fma_deferring_state *state)\n {\n   tree mul_result = gimple_get_lhs (mul_stmt);\n   tree type = TREE_TYPE (mul_result);\n   gimple *use_stmt, *neguse_stmt;\n-  gassign *fma_stmt;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n \n@@ -2673,6 +2871,11 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2)\n   if (has_zero_uses (mul_result))\n     return false;\n \n+  bool check_defer\n+    = (state->m_deferring_p\n+       && (tree_to_shwi (TYPE_SIZE (type))\n+\t   <= PARAM_VALUE (PARAM_AVOID_FMA_MAX_BITS)));\n+  bool defer = check_defer;\n   /* Make sure that the multiplication statement becomes dead after\n      the transformation, thus that all uses are transformed to FMAs.\n      This means we assume that an FMA operation has the same cost\n@@ -2770,77 +2973,92 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2)\n \t    }\n \t}\n \n+      tree use_rhs1 = gimple_assign_rhs1 (use_stmt);\n+      tree use_rhs2 = gimple_assign_rhs2 (use_stmt);\n       /* We can't handle a * b + a * b.  */\n-      if (gimple_assign_rhs1 (use_stmt) == gimple_assign_rhs2 (use_stmt))\n+      if (use_rhs1 == use_rhs2)\n+\treturn false;\n+      /* If deferring, make sure we are not looking at an instruction that\n+\t wouldn't have existed if we were not.  */\n+      if (state->m_deferring_p\n+\t  && (state->m_mul_result_set.contains (use_rhs1)\n+\t      || state->m_mul_result_set.contains (use_rhs2)))\n \treturn false;\n \n-      /* While it is possible to validate whether or not the exact form\n-\t that we've recognized is available in the backend, the assumption\n-\t is that the transformation is never a loss.  For instance, suppose\n-\t the target only has the plain FMA pattern available.  Consider\n-\t a*b-c -> fma(a,b,-c): we've exchanged MUL+SUB for FMA+NEG, which\n-\t is still two operations.  Consider -(a*b)-c -> fma(-a,b,-c): we\n-\t still have 3 operations, but in the FMA form the two NEGs are\n-\t independent and could be run in parallel.  */\n-    }\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)\n-    {\n-      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-      enum tree_code use_code;\n-      tree addop, mulop1 = op1, result = mul_result;\n-      bool negate_p = false;\n-\n-      if (is_gimple_debug (use_stmt))\n-\tcontinue;\n-\n-      use_code = gimple_assign_rhs_code (use_stmt);\n-      if (use_code == NEGATE_EXPR)\n+      if (check_defer)\n \t{\n-\t  result = gimple_assign_lhs (use_stmt);\n-\t  single_imm_use (gimple_assign_lhs (use_stmt), &use_p, &neguse_stmt);\n-\t  gsi_remove (&gsi, true);\n-\t  release_defs (use_stmt);\n+\t  tree use_lhs = gimple_assign_lhs (use_stmt);\n+\t  if (state->m_last_result)\n+\t    {\n+\t      if (use_rhs2 == state->m_last_result\n+\t\t  || use_rhs1 == state->m_last_result)\n+\t\tdefer = true;\n+\t      else\n+\t\tdefer = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_checking_assert (!state->m_initial_phi);\n+\t      gphi *phi;\n+\t      if (use_rhs1 == result)\n+\t\tphi = result_of_phi (use_rhs2);\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (use_rhs2 == result);\n+\t\t  phi = result_of_phi (use_rhs1);\n+\t\t}\n \n-\t  use_stmt = neguse_stmt;\n-\t  gsi = gsi_for_stmt (use_stmt);\n-\t  use_code = gimple_assign_rhs_code (use_stmt);\n-\t  negate_p = true;\n-\t}\n+\t      if (phi)\n+\t\t{\n+\t\t  state->m_initial_phi = phi;\n+\t\t  defer = true;\n+\t\t}\n+\t      else\n+\t\tdefer = false;\n+\t    }\n \n-      if (gimple_assign_rhs1 (use_stmt) == result)\n-\t{\n-\t  addop = gimple_assign_rhs2 (use_stmt);\n-\t  /* a * b - c -> a * b + (-c)  */\n-\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n-\t    addop = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t\t      build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t      type, addop),\n-\t\t\t\t\t      true, NULL_TREE, true,\n-\t\t\t\t\t      GSI_SAME_STMT);\n+\t  state->m_last_result = use_lhs;\n+\t  check_defer = false;\n \t}\n       else\n+\tdefer = false;\n+\n+      /* While it is possible to validate whether or not the exact form that\n+\t we've recognized is available in the backend, the assumption is that\n+\t if the deferring logic above did not trigger, the transformation is\n+\t never a loss.  For instance, suppose the target only has the plain FMA\n+\t pattern available.  Consider a*b-c -> fma(a,b,-c): we've exchanged\n+\t MUL+SUB for FMA+NEG, which is still two operations.  Consider\n+         -(a*b)-c -> fma(-a,b,-c): we still have 3 operations, but in the FMA\n+\t form the two NEGs are independent and could be run in parallel.  */\n+    }\n+\n+  if (defer)\n+    {\n+      fma_transformation_info fti;\n+      fti.mul_stmt = mul_stmt;\n+      fti.mul_result = mul_result;\n+      fti.op1 = op1;\n+      fti.op2 = op2;\n+      state->m_candidates.safe_push (fti);\n+      state->m_mul_result_set.add (mul_result);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  addop = gimple_assign_rhs1 (use_stmt);\n-\t  /* a - b * c -> (-b) * c + a */\n-\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n-\t    negate_p = !negate_p;\n+\t  fprintf (dump_file, \"Deferred generating FMA for multiplication \");\n+\t  print_gimple_stmt (dump_file, mul_stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      if (negate_p)\n-\tmulop1 = force_gimple_operand_gsi (&gsi,\n-\t\t\t\t\t   build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t   type, mulop1),\n-\t\t\t\t\t   true, NULL_TREE, true,\n-\t\t\t\t\t   GSI_SAME_STMT);\n-\n-      fma_stmt = gimple_build_assign (gimple_assign_lhs (use_stmt),\n-\t\t\t\t      FMA_EXPR, mulop1, op2, addop);\n-      gsi_replace (&gsi, fma_stmt, true);\n-      widen_mul_stats.fmas_inserted++;\n+      return false;\n+    }\n+  else\n+    {\n+      if (state->m_deferring_p)\n+\tcancel_fma_deferring (state);\n+      convert_mult_to_fma_1 (mul_result, op1, op2);\n+      return true;\n     }\n-\n-  return true;\n }\n \n \n@@ -3270,92 +3488,135 @@ class pass_optimize_widening_mul : public gimple_opt_pass\n \n }; // class pass_optimize_widening_mul\n \n-unsigned int\n-pass_optimize_widening_mul::execute (function *fun)\n+/* Walker class to perform the transformation in reverse dominance order. */\n+\n+class math_opts_dom_walker : public dom_walker\n {\n-  basic_block bb;\n-  bool cfg_changed = false;\n+public:\n+  /* Constructor, CFG_CHANGED is a pointer to a boolean flag that will be set\n+     if walking modidifes the CFG.  */\n \n-  memset (&widen_mul_stats, 0, sizeof (widen_mul_stats));\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  renumber_gimple_stmt_uids ();\n+  math_opts_dom_walker (bool *cfg_changed_p)\n+    : dom_walker (CDI_DOMINATORS), m_last_result_set (),\n+      m_cfg_changed_p (cfg_changed_p) {}\n \n-  FOR_EACH_BB_FN (bb, fun)\n+  /* The actual actions performed in the walk.  */\n+\n+  virtual void after_dom_children (basic_block);\n+\n+  /* Set of results of chains of multiply and add statement combinations that\n+     were not transformed into FMAs because of active deferring.  */\n+  hash_set<tree> m_last_result_set;\n+\n+  /* Pointer to a flag of the user that needs to be set if CFG has been\n+     modified.  */\n+  bool *m_cfg_changed_p;\n+};\n+\n+void\n+math_opts_dom_walker::after_dom_children (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  fma_deferring_state fma_state (PARAM_VALUE (PARAM_AVOID_FMA_MAX_BITS) > 0);\n+\n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n     {\n-      gimple_stmt_iterator gsi;\n+      gimple *stmt = gsi_stmt (gsi);\n+      enum tree_code code;\n \n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n-        {\n-\t  gimple *stmt = gsi_stmt (gsi);\n-\t  enum tree_code code;\n+      if (is_gimple_assign (stmt))\n+\t{\n+\t  code = gimple_assign_rhs_code (stmt);\n+\t  switch (code)\n+\t    {\n+\t    case MULT_EXPR:\n+\t      if (!convert_mult_to_widen (stmt, &gsi)\n+\t\t  && !convert_expand_mult_copysign (stmt, &gsi)\n+\t\t  && convert_mult_to_fma (stmt,\n+\t\t\t\t\t  gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t  gimple_assign_rhs2 (stmt),\n+\t\t\t\t\t  &fma_state))\n+\t\t{\n+\t\t  gsi_remove (&gsi, true);\n+\t\t  release_defs (stmt);\n+\t\t  continue;\n+\t\t}\n+\t      break;\n+\n+\t    case PLUS_EXPR:\n+\t    case MINUS_EXPR:\n+\t      if (!convert_plusminus_to_widen (&gsi, stmt, code))\n+\t\tmatch_uaddsub_overflow (&gsi, stmt, code);\n+\t      break;\n \n-\t  if (is_gimple_assign (stmt))\n+\t    case TRUNC_MOD_EXPR:\n+\t      convert_to_divmod (as_a<gassign *> (stmt));\n+\t      break;\n+\n+\t    default:;\n+\t    }\n+\t}\n+      else if (is_gimple_call (stmt))\n+\t{\n+\t  tree fndecl = gimple_call_fndecl (stmt);\n+\t  if (fndecl && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n \t    {\n-\t      code = gimple_assign_rhs_code (stmt);\n-\t      switch (code)\n+\t      switch (DECL_FUNCTION_CODE (fndecl))\n \t\t{\n-\t\tcase MULT_EXPR:\n-\t\t  if (!convert_mult_to_widen (stmt, &gsi)\n-\t\t      && !convert_expand_mult_copysign (stmt, &gsi)\n+\t\tcase BUILT_IN_POWF:\n+\t\tcase BUILT_IN_POW:\n+\t\tcase BUILT_IN_POWL:\n+\t\t  if (gimple_call_lhs (stmt)\n+\t\t      && TREE_CODE (gimple_call_arg (stmt, 1)) == REAL_CST\n+\t\t      && real_equal\n+\t\t      (&TREE_REAL_CST (gimple_call_arg (stmt, 1)),\n+\t\t       &dconst2)\n \t\t      && convert_mult_to_fma (stmt,\n-\t\t\t\t\t      gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t      gimple_assign_rhs2 (stmt)))\n+\t\t\t\t\t      gimple_call_arg (stmt, 0),\n+\t\t\t\t\t      gimple_call_arg (stmt, 0),\n+\t\t\t\t\t      &fma_state))\n \t\t    {\n-\t\t      gsi_remove (&gsi, true);\n+\t\t      unlink_stmt_vdef (stmt);\n+\t\t      if (gsi_remove (&gsi, true)\n+\t\t\t  && gimple_purge_dead_eh_edges (bb))\n+\t\t\t*m_cfg_changed_p = true;\n \t\t      release_defs (stmt);\n \t\t      continue;\n \t\t    }\n \t\t  break;\n \n-\t\tcase PLUS_EXPR:\n-\t\tcase MINUS_EXPR:\n-\t\t  if (!convert_plusminus_to_widen (&gsi, stmt, code))\n-\t\t    match_uaddsub_overflow (&gsi, stmt, code);\n-\t\t  break;\n-\n-\t\tcase TRUNC_MOD_EXPR:\n-\t\t  convert_to_divmod (as_a<gassign *> (stmt));\n-\t\t  break;\n-\n \t\tdefault:;\n \t\t}\n \t    }\n-\t  else if (is_gimple_call (stmt)\n-\t\t   && gimple_call_lhs (stmt))\n-\t    {\n-\t      tree fndecl = gimple_call_fndecl (stmt);\n-\t      if (fndecl\n-\t\t  && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n-\t\t{\n-\t\t  switch (DECL_FUNCTION_CODE (fndecl))\n-\t\t    {\n-\t\t      case BUILT_IN_POWF:\n-\t\t      case BUILT_IN_POW:\n-\t\t      case BUILT_IN_POWL:\n-\t\t\tif (TREE_CODE (gimple_call_arg (stmt, 1)) == REAL_CST\n-\t\t\t    && real_equal\n-\t\t\t         (&TREE_REAL_CST (gimple_call_arg (stmt, 1)),\n-\t\t\t\t  &dconst2)\n-\t\t\t    && convert_mult_to_fma (stmt,\n-\t\t\t\t\t\t    gimple_call_arg (stmt, 0),\n-\t\t\t\t\t\t    gimple_call_arg (stmt, 0)))\n-\t\t\t  {\n-\t\t\t    unlink_stmt_vdef (stmt);\n-\t\t\t    if (gsi_remove (&gsi, true)\n-\t\t\t\t&& gimple_purge_dead_eh_edges (bb))\n-\t\t\t      cfg_changed = true;\n-\t\t\t    release_defs (stmt);\n-\t\t\t    continue;\n-\t\t\t  }\n-\t\t\t  break;\n-\n-\t\t      default:;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  gsi_next (&gsi);\n+\t  else\n+\t    cancel_fma_deferring (&fma_state);\n \t}\n+      gsi_next (&gsi);\n     }\n+  if (fma_state.m_deferring_p\n+      && fma_state.m_initial_phi)\n+    {\n+      gcc_checking_assert (fma_state.m_last_result);\n+      if (!last_fma_candidate_feeds_initial_phi (&fma_state,\n+\t\t\t\t\t\t &m_last_result_set))\n+\tcancel_fma_deferring (&fma_state);\n+      else\n+\tm_last_result_set.add (fma_state.m_last_result);\n+    }\n+}\n+\n+\n+unsigned int\n+pass_optimize_widening_mul::execute (function *fun)\n+{\n+  bool cfg_changed = false;\n+\n+  memset (&widen_mul_stats, 0, sizeof (widen_mul_stats));\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  renumber_gimple_stmt_uids ();\n+\n+  math_opts_dom_walker (&cfg_changed).walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   statistics_counter_event (fun, \"widening multiplications inserted\",\n \t\t\t    widen_mul_stats.widen_mults_inserted);"}]}