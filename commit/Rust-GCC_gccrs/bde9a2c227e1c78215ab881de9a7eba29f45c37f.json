{"sha": "bde9a2c227e1c78215ab881de9a7eba29f45c37f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRlOWEyYzIyN2UxYzc4MjE1YWI4ODFkZTlhN2ViYTI5ZjQ1YzM3Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-08-21T08:30:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-08-21T08:30:00Z"}, "message": "[Ada] Fix type mismatch in extended return statement expansion\n\nThis fixes a (sub)type mismatch in the expansion of an extended return\nstatement generated for a built-in-place function that doesn't need a\nBIP_Alloc_Form parameter but returns unconstrained.\n\nNo functional changes.\n\n2019-08-21  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): In the case\n\tof a built-in-place function that doesn't need a BIP_Alloc_Form\n\tparameter but returns unconstrained, build the return\n\tconsistently using the function's result subtype.  Remove bypass\n\tadded in previous change.\n\nFrom-SVN: r274782", "tree": {"sha": "391fa6706b147579cd92e5a21b2127e546666177", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/391fa6706b147579cd92e5a21b2127e546666177"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bde9a2c227e1c78215ab881de9a7eba29f45c37f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde9a2c227e1c78215ab881de9a7eba29f45c37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde9a2c227e1c78215ab881de9a7eba29f45c37f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde9a2c227e1c78215ab881de9a7eba29f45c37f/comments", "author": null, "committer": null, "parents": [{"sha": "92ef57728eeec64cbe2c83cee3409466e3c98448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ef57728eeec64cbe2c83cee3409466e3c98448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92ef57728eeec64cbe2c83cee3409466e3c98448"}], "stats": {"total": 93, "additions": 68, "deletions": 25}, "files": [{"sha": "c27e6e550232efae33d45b35a7b333b97e4d8120", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde9a2c227e1c78215ab881de9a7eba29f45c37f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde9a2c227e1c78215ab881de9a7eba29f45c37f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bde9a2c227e1c78215ab881de9a7eba29f45c37f", "patch": "@@ -1,3 +1,11 @@\n+2019-08-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): In the case\n+\tof a built-in-place function that doesn't need a BIP_Alloc_Form\n+\tparameter but returns unconstrained, build the return\n+\tconsistently using the function's result subtype.  Remove bypass\n+\tadded in previous change.\n+\n 2019-08-21  Piotr Trojanek  <trojanek@adacore.com>\n \n \t* sem_prag.adb (Max_Entry_Queue_Length): Do not substitute"}, {"sha": "e3109c251b7177703bd6a28aed29f8a2377e88a9", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 60, "deletions": 25, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bde9a2c227e1c78215ab881de9a7eba29f45c37f/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bde9a2c227e1c78215ab881de9a7eba29f45c37f/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=bde9a2c227e1c78215ab881de9a7eba29f45c37f", "patch": "@@ -5199,7 +5199,7 @@ package body Exp_Ch6 is\n                end if;\n \n                --  When the function's subtype is unconstrained, a run-time\n-               --  test is needed to determine the form of allocation to use\n+               --  test may be needed to decide the form of allocation to use\n                --  for the return object. The function has an implicit formal\n                --  parameter indicating this. If the BIP_Alloc_Form formal has\n                --  the value one, then the caller has passed access to an\n@@ -5235,13 +5235,6 @@ package body Exp_Ch6 is\n                      SS_Allocator   : Node_Id;\n \n                   begin\n-                     --  Reuse the itype created for the function's implicit\n-                     --  access formal. This avoids the need to create a new\n-                     --  access type here, plus it allows assigning the access\n-                     --  formal directly without applying a conversion.\n-\n-                     --    Ref_Type := Etype (Object_Access);\n-\n                      --  Create an access type designating the function's\n                      --  result subtype.\n \n@@ -5570,6 +5563,64 @@ package body Exp_Ch6 is\n                      --  Remember the local access object for use in the\n                      --  dereference of the renaming created below.\n \n+                     Obj_Acc_Formal := Alloc_Obj_Id;\n+                  end;\n+\n+               --  When the function's subtype is unconstrained and a run-time\n+               --  test is not needed, we nevertheless need to build the return\n+               --  using the function's result subtype.\n+\n+               elsif not Is_Constrained (Underlying_Type (Etype (Func_Id)))\n+               then\n+                  declare\n+                     Alloc_Obj_Id   : Entity_Id;\n+                     Alloc_Obj_Decl : Node_Id;\n+                     Ptr_Type_Decl  : Node_Id;\n+                     Ref_Type       : Entity_Id;\n+\n+                  begin\n+                     --  Create an access type designating the function's\n+                     --  result subtype.\n+\n+                     Ref_Type := Make_Temporary (Loc, 'A');\n+\n+                     Ptr_Type_Decl :=\n+                       Make_Full_Type_Declaration (Loc,\n+                         Defining_Identifier => Ref_Type,\n+                         Type_Definition     =>\n+                           Make_Access_To_Object_Definition (Loc,\n+                             All_Present        => True,\n+                             Subtype_Indication =>\n+                               New_Occurrence_Of (Ret_Obj_Typ, Loc)));\n+\n+                     Insert_Before (Ret_Obj_Decl, Ptr_Type_Decl);\n+\n+                     --  Create an access object initialized to the conversion\n+                     --  of the implicit access value passed in by the caller.\n+\n+                     Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n+                     Set_Etype (Alloc_Obj_Id, Ref_Type);\n+\n+                     --  See the ??? comment a few lines above about the use of\n+                     --  an unchecked conversion here.\n+\n+                     Alloc_Obj_Decl :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Alloc_Obj_Id,\n+                         Object_Definition   =>\n+                           New_Occurrence_Of (Ref_Type, Loc),\n+                         Expression =>\n+                           Make_Unchecked_Type_Conversion (Loc,\n+                             Subtype_Mark =>\n+                               New_Occurrence_Of (Ref_Type, Loc),\n+                             Expression   =>\n+                               New_Occurrence_Of (Obj_Acc_Formal, Loc)));\n+\n+                     Insert_Before (Ret_Obj_Decl, Alloc_Obj_Decl);\n+\n+                     --  Remember the local access object for use in the\n+                     --  dereference of the renaming created below.\n+\n                      Obj_Acc_Formal := Alloc_Obj_Id;\n                   end;\n                end if;\n@@ -5615,23 +5666,7 @@ package body Exp_Ch6 is\n       Set_Comes_From_Extended_Return_Statement (Return_Stmt);\n \n       Rewrite (N, Result);\n-\n-      declare\n-         T : constant Entity_Id := Etype (Ret_Obj_Id);\n-      begin\n-         Analyze (N, Suppress => All_Checks);\n-\n-         --  In some cases, analysis of N can set the Etype of an N_Identifier\n-         --  to a subtype of the Etype of the Entity of the N_Identifier, which\n-         --  gigi doesn't like. Reset the Etypes correctly here.\n-\n-         if Nkind (Expression (Return_Stmt)) = N_Identifier\n-           and then Entity (Expression (Return_Stmt)) = Ret_Obj_Id\n-         then\n-            Set_Etype (Ret_Obj_Id, T);\n-            Set_Etype (Expression (Return_Stmt), T);\n-         end if;\n-      end;\n+      Analyze (N, Suppress => All_Checks);\n    end Expand_N_Extended_Return_Statement;\n \n    ----------------------------"}]}