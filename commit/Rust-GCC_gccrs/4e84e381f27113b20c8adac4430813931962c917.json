{"sha": "4e84e381f27113b20c8adac4430813931962c917", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU4NGUzODFmMjcxMTNiMjBjOGFkYWM0NDMwODEzOTMxOTYyYzkxNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-26T19:15:38Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-08-26T19:15:38Z"}, "message": "Refactor warn_uninit() code.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-uninit.c (warn_uninit): Refactor and simplify.\n\t(warn_uninit_phi_uses): Remove argument from calls to warn_uninit.\n\t(warn_uninitialized_vars): Same.  Reduce visibility of locals.\n\t(warn_uninitialized_phi): Same.", "tree": {"sha": "12ec35e1a700b2d981cb9dd251e5c860818629f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12ec35e1a700b2d981cb9dd251e5c860818629f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e84e381f27113b20c8adac4430813931962c917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e84e381f27113b20c8adac4430813931962c917", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e84e381f27113b20c8adac4430813931962c917", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e84e381f27113b20c8adac4430813931962c917/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2ef23239f245871e9b35b902391f2e94a041627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2ef23239f245871e9b35b902391f2e94a041627", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2ef23239f245871e9b35b902391f2e94a041627"}], "stats": {"total": 186, "additions": 83, "deletions": 103}, "files": [{"sha": "394dbf40c9ca78322a78c073f770c5d0c8c3e183", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 83, "deletions": 103, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e84e381f27113b20c8adac4430813931962c917/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e84e381f27113b20c8adac4430813931962c917/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=4e84e381f27113b20c8adac4430813931962c917", "patch": "@@ -131,86 +131,89 @@ uninit_undefined_value_p (tree t)\n    again for plain uninitialized variables, since optimization may have\n    changed conditionally uninitialized to unconditionally uninitialized.  */\n \n-/* Emit a warning for EXPR based on variable VAR at the point in the\n-   program T, an SSA_NAME, is used being uninitialized.  The exact\n-   warning text is in MSGID and DATA is the gimple stmt with info about\n-   the location in source code.  When DATA is a GIMPLE_PHI, PHIARG_IDX\n-   gives which argument of the phi node to take the location from.  WC\n-   is the warning code.  */\n+/* Emit warning OPT for variable VAR at the point in the program where\n+   the SSA_NAME T is being used uninitialized.  The warning text is in\n+   MSGID and STMT is the statement that does the uninitialized read.\n+   PHI_ARG_LOC is the location of the PHI argument if T and VAR are one,\n+   or UNKNOWN_LOCATION otherwise.  */\n \n static void\n-warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n-\t     const char *gmsgid, void *data, location_t phiarg_loc)\n+warn_uninit (opt_code opt, tree t, tree var, const char *gmsgid,\n+\t     gimple *context, location_t phi_arg_loc = UNKNOWN_LOCATION)\n {\n-  gimple *context = (gimple *) data;\n-  location_t location, cfun_loc;\n-  expanded_location xloc, floc;\n+  /* Bail if the value isn't provably uninitialized.  */\n+  if (!has_undefined_value_p (t))\n+    return;\n \n   /* Ignore COMPLEX_EXPR as initializing only a part of a complex\n      turns in a COMPLEX_EXPR with the not initialized part being\n      set to its previous (undefined) value.  */\n   if (is_gimple_assign (context)\n       && gimple_assign_rhs_code (context) == COMPLEX_EXPR)\n     return;\n-  if (!has_undefined_value_p (t))\n-    return;\n-\n   /* Anonymous SSA_NAMEs shouldn't be uninitialized, but ssa_undefined_value_p\n-     can return true if the def stmt of anonymous SSA_NAME is COMPLEX_EXPR\n+     can return true if the def stmt of an anonymous SSA_NAME is COMPLEX_EXPR\n      created for conversion from scalar to complex.  Use the underlying var of\n      the COMPLEX_EXPRs real part in that case.  See PR71581.  */\n-  if (expr == NULL_TREE\n-      && var == NULL_TREE\n-      && SSA_NAME_VAR (t) == NULL_TREE\n-      && is_gimple_assign (SSA_NAME_DEF_STMT (t))\n-      && gimple_assign_rhs_code (SSA_NAME_DEF_STMT (t)) == COMPLEX_EXPR)\n-    {\n-      tree v = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (t));\n-      if (TREE_CODE (v) == SSA_NAME\n-\t  && has_undefined_value_p (v)\n-\t  && zerop (gimple_assign_rhs2 (SSA_NAME_DEF_STMT (t))))\n+  if (!var && !SSA_NAME_VAR (t))\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n+      if (is_gimple_assign (def_stmt)\n+\t  && gimple_assign_rhs_code (def_stmt) == COMPLEX_EXPR)\n \t{\n-\t  expr = SSA_NAME_VAR (v);\n-\t  var = expr;\n+\t  tree v = gimple_assign_rhs1 (def_stmt);\n+\t  if (TREE_CODE (v) == SSA_NAME\n+\t      && has_undefined_value_p (v)\n+\t      && zerop (gimple_assign_rhs2 (def_stmt)))\n+\t    var = SSA_NAME_VAR (v);\n \t}\n     }\n \n-  if (expr == NULL_TREE)\n+  if (var == NULL_TREE)\n     return;\n \n-  /* TREE_NO_WARNING either means we already warned, or the front end\n-     wishes to suppress the warning.  */\n-  if ((context\n-       && (warning_suppressed_p (context, OPT_Wuninitialized)\n-\t   || (gimple_assign_single_p (context)\n-\t       && get_no_uninit_warning (gimple_assign_rhs1 (context)))))\n-      || get_no_uninit_warning (expr))\n+  /* Avoid warning if we've already done so or if the warning has been\n+     suppressed.  */\n+  if (((warning_suppressed_p (context, OPT_Wuninitialized)\n+\t|| (gimple_assign_single_p (context)\n+\t    && get_no_uninit_warning (gimple_assign_rhs1 (context)))))\n+      || get_no_uninit_warning (var))\n     return;\n \n-  if (context != NULL && gimple_has_location (context))\n+  /* Use either the location of the read statement or that of the PHI\n+     argument, or that of the uninitialized variable, in that order,\n+     whichever is valid.  */\n+  location_t location;\n+  if (gimple_has_location (context))\n     location = gimple_location (context);\n-  else if (phiarg_loc != UNKNOWN_LOCATION)\n-    location = phiarg_loc;\n+  else if (phi_arg_loc != UNKNOWN_LOCATION)\n+    location = phi_arg_loc;\n   else\n     location = DECL_SOURCE_LOCATION (var);\n   location = linemap_resolve_location (line_table, location,\n \t\t\t\t       LRK_SPELLING_LOCATION, NULL);\n-  cfun_loc = DECL_SOURCE_LOCATION (cfun->decl);\n-  xloc = expand_location (location);\n-  floc = expand_location (cfun_loc);\n+\n   auto_diagnostic_group d;\n-  if (warning_at (location, wc, gmsgid, expr))\n-    {\n-      suppress_warning (expr, wc);\n+  if (!warning_at (location, opt, gmsgid, var))\n+    return;\n \n-      if (location == DECL_SOURCE_LOCATION (var))\n-\treturn;\n-      if (xloc.file != floc.file\n-\t  || linemap_location_before_p (line_table, location, cfun_loc)\n-\t  || linemap_location_before_p (line_table, cfun->function_end_locus,\n+  /* Avoid subsequent warnings for reads of the same variable again.  */\n+  suppress_warning (var, opt);\n+\n+  /* Issue a note pointing to the read variable unless the warning\n+     is at the same location.  */\n+  location_t var_loc = DECL_SOURCE_LOCATION (var);\n+  if (location == var_loc)\n+    return;\n+\n+  location_t cfun_loc = DECL_SOURCE_LOCATION (cfun->decl);\n+  expanded_location xloc = expand_location (location);\n+  expanded_location floc = expand_location (cfun_loc);\n+  if (xloc.file != floc.file\n+      || linemap_location_before_p (line_table, location, cfun_loc)\n+      || linemap_location_before_p (line_table, cfun->function_end_locus,\n \t\t\t\t\tlocation))\n-\tinform (DECL_SOURCE_LOCATION (var), \"%qD was declared here\", var);\n-    }\n+    inform (var_loc, \"%qD was declared here\", var);\n }\n \n struct check_defs_data\n@@ -845,13 +848,14 @@ warn_uninit_phi_uses (basic_block bb)\n \t}\n       if (use_stmt)\n \twarn_uninit (OPT_Wuninitialized, def, SSA_NAME_VAR (def),\n-\t\t     SSA_NAME_VAR (def),\n-\t\t     \"%qD is used uninitialized\", use_stmt,\n-\t\t     UNKNOWN_LOCATION);\n+\t\t     \"%qD is used uninitialized\", use_stmt);\n     }\n }\n \n-static unsigned int\n+/* Issue warnings about reads of uninitialized variables.  WMAYBE_UNINIT\n+   is true to issue -Wmaybe-uninitialized, otherwise -Wuninitialized.  */\n+\n+static void\n warn_uninitialized_vars (bool wmaybe_uninit)\n {\n   /* Counters and limits controlling the the depth of the warning.  */\n@@ -871,15 +875,13 @@ warn_uninitialized_vars (bool wmaybe_uninit)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n-\t  use_operand_p use_p;\n-\t  ssa_op_iter op_iter;\n-\t  tree use;\n-\n \t  if (is_gimple_debug (stmt))\n \t    continue;\n \n \t  /* We only do data flow with SSA_NAMEs, so that's all we\n \t     can warn about.  */\n+\t  use_operand_p use_p;\n+\t  ssa_op_iter op_iter;\n \t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, op_iter, SSA_OP_USE)\n \t    {\n \t      /* BIT_INSERT_EXPR first operand should not be considered\n@@ -890,17 +892,13 @@ warn_uninitialized_vars (bool wmaybe_uninit)\n \t\t      && use_p->use == gimple_assign_rhs1_ptr (ass))\n \t\t    continue;\n \t\t}\n-\t      use = USE_FROM_PTR (use_p);\n+\t      tree use = USE_FROM_PTR (use_p);\n \t      if (wlims.always_executed)\n \t\twarn_uninit (OPT_Wuninitialized, use, SSA_NAME_VAR (use),\n-\t\t\t     SSA_NAME_VAR (use),\n-\t\t\t     \"%qD is used uninitialized\", stmt,\n-\t\t\t     UNKNOWN_LOCATION);\n+\t\t\t     \"%qD is used uninitialized\", stmt);\n \t      else if (wmaybe_uninit)\n \t\twarn_uninit (OPT_Wmaybe_uninitialized, use, SSA_NAME_VAR (use),\n-\t\t\t     SSA_NAME_VAR (use),\n-\t\t\t     \"%qD may be used uninitialized\",\n-\t\t\t     stmt, UNKNOWN_LOCATION);\n+\t\t\t     \"%qD may be used uninitialized\", stmt);\n \t    }\n \n \t  /* For limiting the alias walk below we count all\n@@ -930,8 +928,6 @@ warn_uninitialized_vars (bool wmaybe_uninit)\n \t    }\n \t}\n     }\n-\n-  return 0;\n }\n \n /* Checks if the operand OPND of PHI is defined by\n@@ -943,16 +939,13 @@ warn_uninitialized_vars (bool wmaybe_uninit)\n static bool\n can_skip_redundant_opnd (tree opnd, gimple *phi)\n {\n-  gimple *op_def;\n-  tree phi_def;\n-  int i, n;\n-\n-  phi_def = gimple_phi_result (phi);\n-  op_def = SSA_NAME_DEF_STMT (opnd);\n+  tree phi_def = gimple_phi_result (phi);\n+  gimple *op_def = SSA_NAME_DEF_STMT (opnd);\n   if (gimple_code (op_def) != GIMPLE_PHI)\n     return false;\n-  n = gimple_phi_num_args (op_def);\n-  for (i = 0; i < n; ++i)\n+\n+  unsigned n = gimple_phi_num_args (op_def);\n+  for (unsigned i = 0; i < n; ++i)\n     {\n       tree op = gimple_phi_arg_def (op_def, i);\n       if (TREE_CODE (op) != SSA_NAME)\n@@ -970,15 +963,14 @@ can_skip_redundant_opnd (tree opnd, gimple *phi)\n static unsigned\n compute_uninit_opnds_pos (gphi *phi)\n {\n-  size_t i, n;\n   unsigned uninit_opnds = 0;\n \n-  n = gimple_phi_num_args (phi);\n+  unsigned n = gimple_phi_num_args (phi);\n   /* Bail out for phi with too many args.  */\n   if (n > max_phi_args)\n     return 0;\n \n-  for (i = 0; i < n; ++i)\n+  for (unsigned i = 0; i < n; ++i)\n     {\n       tree op = gimple_phi_arg_def (phi, i);\n       if (TREE_CODE (op) == SSA_NAME\n@@ -998,8 +990,7 @@ compute_uninit_opnds_pos (gphi *phi)\n   return uninit_opnds;\n }\n \n-/* Find the immediate postdominator PDOM of the specified\n-   basic block BLOCK.  */\n+/* Find the immediate postdominator of the specified basic block BLOCK.  */\n \n static inline basic_block\n find_pdom (basic_block block)\n@@ -1015,7 +1006,7 @@ find_pdom (basic_block block)\n     }\n }\n \n-/* Find the immediate DOM of the specified basic block BLOCK.  */\n+/* Find the immediate dominator of the specified basic block BLOCK.  */\n \n static inline basic_block\n find_dom (basic_block block)\n@@ -1053,9 +1044,7 @@ is_non_loop_exit_postdominating (basic_block bb1, basic_block bb2)\n static inline basic_block\n find_control_equiv_block (basic_block bb)\n {\n-  basic_block pdom;\n-\n-  pdom = find_pdom (bb);\n+  basic_block pdom = find_pdom (bb);\n \n   /* Skip the postdominating bb that is also loop exit.  */\n   if (!is_non_loop_exit_postdominating (pdom, bb))\n@@ -3193,18 +3182,11 @@ static void\n warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n \t\t\thash_set<gphi *> *added_to_worklist)\n {\n-  unsigned uninit_opnds;\n-  gimple *uninit_use_stmt = 0;\n-  tree uninit_op;\n-  int phiarg_index;\n-  location_t loc;\n-\n   /* Don't look at virtual operands.  */\n   if (virtual_operand_p (gimple_phi_result (phi)))\n     return;\n \n-  uninit_opnds = compute_uninit_opnds_pos (phi);\n-\n+  unsigned uninit_opnds = compute_uninit_opnds_pos (phi);\n   if (MASK_EMPTY (uninit_opnds))\n     return;\n \n@@ -3215,25 +3197,23 @@ warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n     }\n \n   /* Now check if we have any use of the value without proper guard.  */\n-  uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n-\t\t\t\t     worklist, added_to_worklist);\n+  gimple *uninit_use_stmt = find_uninit_use (phi, uninit_opnds,\n+\t\t\t\t\t     worklist, added_to_worklist);\n \n   /* All uses are properly guarded.  */\n   if (!uninit_use_stmt)\n     return;\n \n-  phiarg_index = MASK_FIRST_SET_BIT (uninit_opnds);\n-  uninit_op = gimple_phi_arg_def (phi, phiarg_index);\n+  int phiarg_index = MASK_FIRST_SET_BIT (uninit_opnds);\n+  tree uninit_op = gimple_phi_arg_def (phi, phiarg_index);\n   if (SSA_NAME_VAR (uninit_op) == NULL_TREE)\n     return;\n-  if (gimple_phi_arg_has_location (phi, phiarg_index))\n-    loc = gimple_phi_arg_location (phi, phiarg_index);\n-  else\n-    loc = UNKNOWN_LOCATION;\n-  warn_uninit (OPT_Wmaybe_uninitialized, uninit_op, SSA_NAME_VAR (uninit_op),\n+\n+  location_t phi_arg_loc = gimple_phi_arg_location (phi, phiarg_index);\n+  warn_uninit (OPT_Wmaybe_uninitialized, uninit_op,\n \t       SSA_NAME_VAR (uninit_op),\n \t       \"%qD may be used uninitialized in this function\",\n-\t       uninit_use_stmt, loc);\n+\t       uninit_use_stmt, phi_arg_loc);\n }\n \n static bool"}]}