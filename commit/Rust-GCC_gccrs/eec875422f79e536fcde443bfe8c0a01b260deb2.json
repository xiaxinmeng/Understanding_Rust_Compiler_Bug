{"sha": "eec875422f79e536fcde443bfe8c0a01b260deb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWVjODc1NDIyZjc5ZTUzNmZjZGU0NDNiZmU4YzBhMDFiMjYwZGViMg==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2001-12-14T19:01:02Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2001-12-14T19:01:02Z"}, "message": "class.c (get_dispatch_table): Fix java vtable layout for TARGET_VTABLE_USES_DESCRIPTORS.\n\n\t* class.c (get_dispatch_table): Fix java vtable layout\n\tfor TARGET_VTABLE_USES_DESCRIPTORS.\n\t* decl.c (java_init_decl_processing): Initialize\n\talloc_no_finalizer_node, finalize_identifier_node.\n\t* expr.c (class_has_finalize_method): New function.\n\t(expand_java_NEW): Generate calls for finalizer-free allocation.\n\t(build_invokevirtual): Fix java vtable layout for\n\tTARGET_VTABLE_USES_DESCRIPTORS.\n\t* java-tree.h (enum java_tree_index): New entries:\n\tJTI_ALLOC_NO_FINALIZER_NODE, JTI_FINALIZE_IDENTIFIER_NODE.\n\t(alloc_no_finalizer_node, finalize_deintifier_node): New macros.\n\t(class_has_finalize_method): declare.\n\t(HAS_FINALIZER_P): New macro.\n\t* parse.y (patch_invoke): Generate calls for finalizer-free\n\tallocation.\n\nFrom-SVN: r48004", "tree": {"sha": "def86bbb77acbb0823471cf90f10ce49709dfe9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/def86bbb77acbb0823471cf90f10ce49709dfe9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eec875422f79e536fcde443bfe8c0a01b260deb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec875422f79e536fcde443bfe8c0a01b260deb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eec875422f79e536fcde443bfe8c0a01b260deb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eec875422f79e536fcde443bfe8c0a01b260deb2/comments", "author": null, "committer": null, "parents": [{"sha": "abf80f8ff8818e104126e16df6bfcc97587a9cce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf80f8ff8818e104126e16df6bfcc97587a9cce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abf80f8ff8818e104126e16df6bfcc97587a9cce"}], "stats": {"total": 94, "additions": 82, "deletions": 12}, "files": [{"sha": "3654cff875eba5e8af76b2608ec3f0d59b11f704", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=eec875422f79e536fcde443bfe8c0a01b260deb2", "patch": "@@ -1,3 +1,21 @@\n+2001-12-14  Hans Boehm  <Hans_Boehm@hp.com>\n+\n+\t* class.c (get_dispatch_table): Fix java vtable layout\n+\tfor TARGET_VTABLE_USES_DESCRIPTORS.\n+\t* decl.c (java_init_decl_processing): Initialize\n+\talloc_no_finalizer_node, finalize_identifier_node.\n+\t* expr.c (class_has_finalize_method): New function.\n+\t(expand_java_NEW): Generate calls for finalizer-free allocation.\n+\t(build_invokevirtual): Fix java vtable layout for\n+\tTARGET_VTABLE_USES_DESCRIPTORS.\n+\t* java-tree.h (enum java_tree_index): New entries: \n+\tJTI_ALLOC_NO_FINALIZER_NODE, JTI_FINALIZE_IDENTIFIER_NODE.\n+\t(alloc_no_finalizer_node, finalize_deintifier_node): New macros.\n+\t(class_has_finalize_method): declare.\n+\t(HAS_FINALIZER_P): New macro.\n+\t* parse.y (patch_invoke): Generate calls for finalizer-free\n+\tallocation.\n+\n 2001-12-12  Matthias Klose  <doko@debian.org>\n \n \t* Make-lang.in: JAVA_INSTALL_NAME, JAVA_CROSS_NAME: Remove"}, {"sha": "5695aba3e40008305930d6a3abe7870c8e3a560c", "filename": "gcc/java/class.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=eec875422f79e536fcde443bfe8c0a01b260deb2", "patch": "@@ -694,6 +694,13 @@ add_method_1 (handle_class, access_flags, name, function_type)\n   TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n   TYPE_METHODS (handle_class) = fndecl;\n \n+  /* Notice that this is a finalizer and update the class type\n+     accordingly. This is used to optimize instance allocation. */\n+  if (name == finalize_identifier_node\n+      && TREE_TYPE (function_type) == void_type_node\n+      && TREE_VALUE (TYPE_ARG_TYPES (function_type)) == void_type_node)\n+    HAS_FINALIZER_P (handle_class) = 1;\n+\n   if (access_flags & ACC_PUBLIC) METHOD_PUBLIC (fndecl) = 1;\n   if (access_flags & ACC_PROTECTED) METHOD_PROTECTED (fndecl) = 1;\n   if (access_flags & ACC_PRIVATE)\n@@ -1374,6 +1381,7 @@ get_dispatch_table (type, this_class_addr)\n   tree list = NULL_TREE;\n   int nvirtuals = TREE_VEC_LENGTH (vtable);\n   int arraysize;\n+  tree gc_descr;\n \n   for (i = nvirtuals;  --i >= 0; )\n     {\n@@ -1415,15 +1423,17 @@ get_dispatch_table (type, this_class_addr)\n      using the Boehm GC we sometimes stash a GC type descriptor\n      there. We set the PURPOSE to NULL_TREE not to interfere (reset)\n      the emitted byte count during the output to the assembly file. */\n-  for (j = 1; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n-    list = tree_cons (NULL_TREE, null_pointer_node, list);\n-  list = tree_cons (NULL_TREE, get_boehm_type_descriptor (type), list);\n-\n-  for (j = 1; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n-    list = tree_cons (NULL_TREE, null_pointer_node, list);\n+  /* With TARGET_VTABLE_USES_DESCRIPTORS, we only add one extra\n+     fake \"function descriptor\".  It's first word is the is the class\n+     pointer, and subsequent words (usually one) contain the GC descriptor.\n+     In all other cases, we reserve two extra vtable slots. */\n+  gc_descr =  get_boehm_type_descriptor (type);\n+  list = tree_cons (NULL_TREE, gc_descr, list);\n+  for (j = 1; j < TARGET_VTABLE_USES_DESCRIPTORS-1; ++j)\n+    list = tree_cons (NULL_TREE, gc_descr, list);\n   list = tree_cons (integer_zero_node, this_class_addr, list);\n \n-  arraysize = nvirtuals + 2;\n+  arraysize = (TARGET_VTABLE_USES_DESCRIPTORS? nvirtuals + 1 : nvirtuals + 2);\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     arraysize *= TARGET_VTABLE_USES_DESCRIPTORS;\n   return build (CONSTRUCTOR,"}, {"sha": "17b3607a8717aef692257f19566c362c4ceea03a", "filename": "gcc/java/decl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=eec875422f79e536fcde443bfe8c0a01b260deb2", "patch": "@@ -586,6 +586,7 @@ java_init_decl_processing ()\n   instinit_identifier_node = get_identifier (\"instinit$\");\n   void_signature_node = get_identifier (\"()V\");\n   length_identifier_node = get_identifier (\"length\");\n+  finalize_identifier_node = get_identifier (\"finalize\");\n   this_identifier_node = get_identifier (\"this\");\n   super_identifier_node = get_identifier (\"super\");\n   continue_identifier_node = get_identifier (\"continue\");\n@@ -729,6 +730,11 @@ java_init_decl_processing ()\n \t\t\t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\t\t\t0, NOT_BUILT_IN, NULL);\n   DECL_IS_MALLOC (alloc_object_node) = 1;\n+  alloc_no_finalizer_node = \n+    builtin_function (\"_Jv_AllocObjectNoFinalizer\",\n+\t\t      build_function_type (ptr_type_node, t),\n+\t\t      0, NOT_BUILT_IN, NULL);\n+  DECL_IS_MALLOC (alloc_no_finalizer_node) = 1;\n \n   t = tree_cons (NULL_TREE, ptr_type_node, endlink);\n   soft_initclass_node = builtin_function (\"_Jv_InitClass\","}, {"sha": "ef1a13959e1e156e80a5d715e7f016447dfb8e10", "filename": "gcc/java/expr.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=eec875422f79e536fcde443bfe8c0a01b260deb2", "patch": "@@ -1131,15 +1131,31 @@ build_address_of (value)\n   return build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (value)), value);\n }\n \n+bool class_has_finalize_method (type)\n+     tree type;\n+{\n+  tree super = CLASSTYPE_SUPER (type);\n+\n+  if (super == NULL_TREE)\n+    return false;\t/* Every class with a real finalizer inherits\t*/\n+   \t\t\t/* from java.lang.Object.\t\t\t*/\n+  else\n+    return HAS_FINALIZER_P (type) || class_has_finalize_method (super);\n+}\n+\n static void\n expand_java_NEW (type)\n      tree type;\n {\n+  tree alloc_node;\n+\n+  alloc_node = (class_has_finalize_method (type) ? alloc_object_node\n+\t\t  \t\t\t\t : alloc_no_finalizer_node);\n   if (! CLASS_LOADED_P (type))\n     load_class (type, 1);\n   safe_layout_class (type);\n   push_value (build (CALL_EXPR, promote_type (type),\n-\t\t     build_address_of (alloc_object_node),\n+\t\t     build_address_of (alloc_node),\n \t\t     tree_cons (NULL_TREE, build_class_ref (type),\n \t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t size_in_bytes (type))),\n@@ -1849,9 +1865,12 @@ build_invokevirtual (dtable, method)\n     = build_pointer_type (nativecode_ptr_type_node);\n   tree method_index = convert (sizetype, DECL_VINDEX (method));\n \n-  /* Add one to skip \"class\" field of dtable, and one to skip unused\n-     vtable entry (for C++ compatibility). */\n-  method_index = size_binop (PLUS_EXPR, method_index, size_int (2));\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    /* Add one to skip bogus descriptor for class and GC descriptor. */\n+    method_index = size_binop (PLUS_EXPR, method_index, size_int (1));\n+  else\n+    /* Add 1 to skip \"class\" field of dtable, and 1 to skip GC descriptor.  */\n+    method_index = size_binop (PLUS_EXPR, method_index, size_int (2));\n   method_index = size_binop (MULT_EXPR, method_index,\n \t\t\t     TYPE_SIZE_UNIT (nativecode_ptr_ptr_type_node));\n "}, {"sha": "9d11bf6baf12b63a8f3dd655e08a8626582463d4", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=eec875422f79e536fcde443bfe8c0a01b260deb2", "patch": "@@ -60,6 +60,7 @@ struct JCF;\n       RESOLVE_PACKAGE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       SWITCH_HAS_DEFAULT (in SWITCH_EXPR)\n       ZIP_FILE_P (in TREE_LIST in current_file_list)\n+      HAS_FINALIZER (in RECORD_TYPE)\n    4: IS_A_COMMAND_LINE_FILENAME_P (in IDENTIFIER_NODE)\n       RESOLVE_TYPE_NAME_P (in EXPR_WITH_FILE_LOCATION)\n       CALL_USING_SUPER (in CALL_EXPR)\n@@ -290,6 +291,7 @@ enum java_tree_index\n   JTI_FINIT_LEG_IDENTIFIER_NODE,  \n   JTI_VOID_SIGNATURE_NODE,       \n   JTI_LENGTH_IDENTIFIER_NODE,  \n+  JTI_FINALIZE_IDENTIFIER_NODE,\n   JTI_THIS_IDENTIFIER_NODE,  \n   JTI_SUPER_IDENTIFIER_NODE,  \n   JTI_CONTINUE_IDENTIFIER_NODE,  \n@@ -334,6 +336,7 @@ enum java_tree_index\n \n   JTI_THROW_NODE,\n   JTI_ALLOC_OBJECT_NODE,\n+  JTI_ALLOC_NO_FINALIZER_NODE,\n   JTI_SOFT_INSTANCEOF_NODE,\n   JTI_SOFT_CHECKCAST_NODE,\n   JTI_SOFT_INITCLASS_NODE,\n@@ -485,6 +488,8 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_VOID_SIGNATURE_NODE]       /* \"()V\" */\n #define length_identifier_node \\\n   java_global_trees[JTI_LENGTH_IDENTIFIER_NODE]  /* \"length\" */\n+#define finalize_identifier_node \\\n+  java_global_trees[JTI_FINALIZE_IDENTIFIER_NODE]  /* \"finalize\" */\n #define this_identifier_node \\\n   java_global_trees[JTI_THIS_IDENTIFIER_NODE]  /* \"this\" */\n #define super_identifier_node \\\n@@ -569,6 +574,8 @@ extern tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_THROW_NODE]\n #define alloc_object_node \\\n   java_global_trees[JTI_ALLOC_OBJECT_NODE]\n+#define alloc_no_finalizer_node \\\n+  java_global_trees[JTI_ALLOC_NO_FINALIZER_NODE]\n #define soft_instanceof_node \\\n   java_global_trees[JTI_SOFT_INSTANCEOF_NODE]\n #define soft_checkcast_node \\\n@@ -1163,6 +1170,7 @@ extern void java_debug_context PARAMS ((void));\n extern void safe_layout_class PARAMS ((tree));\n \n extern tree get_boehm_type_descriptor PARAMS ((tree));\n+extern bool class_has_finalize_method PARAMS ((tree));\n extern unsigned long java_hash_hash_tree_node PARAMS ((hash_table_key));\n extern bool java_hash_compare_tree_node PARAMS ((hash_table_key, \n \t\t\t\t\t\t    hash_table_key));\n@@ -1421,6 +1429,10 @@ extern tree *type_map;\n    already checked (for redifitions, etc, see java_check_regular_methods.) */\n #define CLASS_METHOD_CHECKED_P(EXPR) TREE_LANG_FLAG_2 (EXPR)\n \n+/* True if TYPE (a TREE_TYPE denoting a class type) was found to\n+   feature a finalizer method. */\n+#define HAS_FINALIZER_P(EXPR) TREE_LANG_FLAG_3 (EXPR)\n+\n /* True if EXPR (a WFL in that case) resolves into an expression name */\n #define RESOLVE_EXPRESSION_NAME_P(WFL) TREE_LANG_FLAG_0 (WFL)\n "}, {"sha": "4dae766a695a788e1fde5ee78bee1e805d625f6c", "filename": "gcc/java/parse.y", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eec875422f79e536fcde443bfe8c0a01b260deb2/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=eec875422f79e536fcde443bfe8c0a01b260deb2", "patch": "@@ -10662,6 +10662,8 @@ patch_invoke (patch, method, args)\n     {\n       tree class = DECL_CONTEXT (method);\n       tree c1, saved_new, size, new;\n+      tree alloc_node;\n+\n       if (flag_emit_class_files || flag_emit_xref)\n \t{\n \t  TREE_TYPE (patch) = build_pointer_type (class);\n@@ -10670,8 +10672,11 @@ patch_invoke (patch, method, args)\n       if (!TYPE_SIZE (class))\n \tsafe_layout_class (class);\n       size = size_in_bytes (class);\n+      alloc_node =\n+\t(class_has_finalize_method (class) ? alloc_object_node\n+\t\t  \t\t\t   : alloc_no_finalizer_node);\n       new = build (CALL_EXPR, promote_type (class),\n-\t\t   build_address_of (alloc_object_node),\n+\t\t   build_address_of (alloc_node),\n \t\t   tree_cons (NULL_TREE, build_class_ref (class),\n \t\t\t      build_tree_list (NULL_TREE, \n \t\t\t\t\t       size_in_bytes (class))),"}]}