{"sha": "b0a16e6d4c91120dd9a2900da0831e83e65f2046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBhMTZlNmQ0YzkxMTIwZGQ5YTI5MDBkYTA4MzFlODNlNjVmMjA0Ng==", "commit": {"author": {"name": "Ghjuvan Lacambre", "email": "lacambre@adacore.com", "date": "2020-01-30T10:47:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-19T09:53:39Z"}, "message": "[Ada] Implement initialization of CUDA runtime\n\ngcc/ada/\n\n\t* debug.adb: Document -gnatd_c flag as being used for CUDA.\n\t* gnat_cuda.ads: New file.\n\t* gnat_cuda.adb: New file.\n\t* rtsfind.ads: Add Interfaces_C_Strings package and\n\tRE_Fatbin_Wrapper, RE_Register_Fat_Binary,\n\tRE_Register_Fat_Binary_End, RE_Register_Function, RE_Chars_Ptr,\n\tRE_New_Char_Array entities.\n\t* rtsfind.adb: Create new Interfaces_C_Descendant subtype,\n\thandle it.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Call CUDA init\n\tprocedure.\n\t* sem_prag.adb (Analyze_Pragma): Call Add_Cuda_Kernel procedure.\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS): Add gnat_cuda.o.", "tree": {"sha": "fddf91c6ac35ddec55df092cb2927cff6a1cc151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fddf91c6ac35ddec55df092cb2927cff6a1cc151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0a16e6d4c91120dd9a2900da0831e83e65f2046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0a16e6d4c91120dd9a2900da0831e83e65f2046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0a16e6d4c91120dd9a2900da0831e83e65f2046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0a16e6d4c91120dd9a2900da0831e83e65f2046/comments", "author": {"login": "glacambre", "id": 11534587, "node_id": "MDQ6VXNlcjExNTM0NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/11534587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glacambre", "html_url": "https://github.com/glacambre", "followers_url": "https://api.github.com/users/glacambre/followers", "following_url": "https://api.github.com/users/glacambre/following{/other_user}", "gists_url": "https://api.github.com/users/glacambre/gists{/gist_id}", "starred_url": "https://api.github.com/users/glacambre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glacambre/subscriptions", "organizations_url": "https://api.github.com/users/glacambre/orgs", "repos_url": "https://api.github.com/users/glacambre/repos", "events_url": "https://api.github.com/users/glacambre/events{/privacy}", "received_events_url": "https://api.github.com/users/glacambre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4"}], "stats": {"total": 733, "additions": 731, "deletions": 2}, "files": [{"sha": "4eb3d5b5c1676d016d4dd05adf3066907d640bac", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -147,7 +147,7 @@ package body Debug is\n \n    --  d_a  Stop elaboration checks on accept or select statement\n    --  d_b\n-   --  d_c\n+   --  d_c  CUDA compilation : compile for the host\n    --  d_d\n    --  d_e  Ignore entry calls and requeue statements for elaboration\n    --  d_f  Issue info messages related to GNATprove usage"}, {"sha": "78fe6023e5b42f6fb67113e5d742c5506f5c5511", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -327,6 +327,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/libgnat/g-u3spch.o\t\\\n  ada/get_targ.o\t\\\n  ada/ghost.o\t\\\n+ ada/gnat_cuda.o \\\n  ada/libgnat/gnat.o\t\\\n  ada/gnatvsn.o\t\\\n  ada/hostparm.o\t\\"}, {"sha": "fef0d185918a7b06a936379e5fe111027baed7a7", "filename": "gcc/ada/gnat_cuda.adb", "status": "added", "additions": 586, "deletions": 0, "changes": 586, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fgnat_cuda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fgnat_cuda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_cuda.adb?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -0,0 +1,586 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                 C U D A                                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 2010-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package defines CUDA-specific datastructures and functions.\n+\n+with Atree;    use Atree;\n+with Debug;    use Debug;\n+with Elists;   use Elists;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Rtsfind;  use Rtsfind;\n+with Sinfo;    use Sinfo;\n+with Stringt;  use Stringt;\n+with Tbuild;   use Tbuild;\n+with Uintp;    use Uintp;\n+with Sem;      use Sem;\n+with Sem_Util; use Sem_Util;\n+with Snames;   use Snames;\n+\n+with GNAT.HTable;\n+\n+package body GNAT_CUDA is\n+\n+   --------------------------------------\n+   -- Hash Table for CUDA_Global nodes --\n+   --------------------------------------\n+\n+   type Hash_Range is range 0 .. 510;\n+   --  Size of hash table headers\n+\n+   function Hash (F : Entity_Id) return Hash_Range;\n+   --  Hash function for hash table\n+\n+   package CUDA_Kernels_Table is new\n+     GNAT.HTable.Simple_HTable\n+       (Header_Num => Hash_Range,\n+        Element    => Elist_Id,\n+        No_Element => No_Elist,\n+        Key        => Entity_Id,\n+        Hash       => Hash,\n+        Equal      => \"=\");\n+   --  The keys of this table are package entities whose bodies contain at\n+   --  least one procedure marked with aspect CUDA_Global. The values are\n+   --  Elists of the marked procedures.\n+\n+   function Get_CUDA_Kernels (Pack_Id : Entity_Id) return Elist_Id;\n+   --  Returns an Elist of all procedures marked with pragma CUDA_Global that\n+   --  are declared within package body Pack_Body. Returns No_Elist if\n+   --  Pack_Id does not contain such procedures.\n+\n+   procedure Set_CUDA_Kernels\n+     (Pack_Id : Entity_Id;\n+      Kernels : Elist_Id);\n+   --  Stores Kernels as the list of kernels belonging to the package entity\n+   --  Pack_Id. Pack_Id must not have a list of kernels.\n+\n+   ---------------------\n+   -- Add_CUDA_Kernel --\n+   ---------------------\n+\n+   procedure Add_CUDA_Kernel\n+     (Pack_Id : Entity_Id;\n+      Kernel  : Entity_Id)\n+   is\n+      Kernels : Elist_Id := Get_CUDA_Kernels (Pack_Id);\n+   begin\n+      if Kernels = No_Elist then\n+         Kernels := New_Elmt_List;\n+         Set_CUDA_Kernels (Pack_Id, Kernels);\n+      end if;\n+      Append_Elmt (Kernel, Kernels);\n+   end Add_CUDA_Kernel;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (F : Entity_Id) return Hash_Range is\n+   begin\n+      return Hash_Range (F mod 511);\n+   end Hash;\n+\n+   ----------------------\n+   -- Get_CUDA_Kernels --\n+   ----------------------\n+\n+   function Get_CUDA_Kernels (Pack_Id : Entity_Id) return Elist_Id is\n+   begin\n+      return CUDA_Kernels_Table.Get (Pack_Id);\n+   end Get_CUDA_Kernels;\n+\n+   ------------------------------------------\n+   -- Build_And_Insert_CUDA_Initialization --\n+   ------------------------------------------\n+\n+   procedure Build_And_Insert_CUDA_Initialization (N : Node_Id) is\n+\n+      --  For the following kernel declaration:\n+      --\n+      --  package body <Package_Name> is\n+      --     procedure <Proc_Name> (X : Integer) with CUDA_Global;\n+      --  end package;\n+      --\n+      --  Insert the following declarations:\n+      --\n+      --     Fat_Binary : System.Address;\n+      --     pragma Import\n+      --        (Convention    => C,\n+      --         Entity        => Fat_Binary,\n+      --         External_Name => \"_binary_<Package_Name>_fatbin_start\");\n+      --\n+      --     Wrapper : Fatbin_Wrapper :=\n+      --       (16#466243b1#, 1, Fat_Binary'Address, System.Null_Address);\n+      --\n+      --     Proc_Symbol_Name : Interfaces.C.Strings.Chars_Ptr :=\n+      --       Interfaces.C.Strings.New_Char_Array(\"<Proc_Name>\");\n+      --\n+      --     Fat_Binary_Handle : System.Address :=\n+      --       CUDA.Internal.Register_Fat_Binary (Wrapper'Address);\n+      --\n+      --     procedure Initialize_CUDA_Kernel is\n+      --     begin\n+      --        CUDA.Internal.Register_Function\n+      --           (Fat_Binary_Handle,\n+      --            <Proc_Name>'Address,\n+      --            Proc_Symbol_Name,\n+      --            Proc_Symbol_Name,\n+      --            -1,\n+      --            System.Null_Address,\n+      --            System.Null_Address,\n+      --            System.Null_Address,\n+      --            System.Null_Address,\n+      --            System.Null_Address);\n+      --        CUDA.Internal.Register_Fat_Binary_End (Fat_Binary_Handle);\n+      --     end Initialize_CUDA_Kernel;\n+      --\n+      --  Proc_Symbol_Name is the name of the procedure marked with\n+      --  CUDA_Global. The CUDA runtime uses this in order to be able to find\n+      --  kernels in the fat binary, so it has to match the name of the\n+      --  procedure symbol compiled by GNAT_LLVM. When looking at the code\n+      --  generated by NVCC, it seems that the CUDA runtime also needs the name\n+      --  of the procedure symbol of the host. Fortuantely, the procedures are\n+      --  named the same way whether they are compiled for the host or the\n+      --  device, so we use Vector_Add_Name to specify the name of the symbol\n+      --  for both the host and the device. The meaning of the rest of the\n+      --  arguments is unknown.\n+\n+      function Build_CUDA_Init_Proc\n+        (Init_Id      : Entity_Id;\n+         CUDA_Kernels : Elist_Id;\n+         Handle_Id    : Entity_Id;\n+         Pack_Decls   : List_Id) return Node_Id;\n+      --  Create the declaration of Init_Id, the function that binds each\n+      --  kernel present in CUDA_Kernels with the fat binary Handle_Id and then\n+      --  tells the CUDA runtime that no new function will be bound to the fat\n+      --  binary.\n+\n+      function Build_Fat_Binary_Declaration\n+        (Bin_Id : Entity_Id) return Node_Id;\n+      --  Create a declaration for Bin_Id, the entity that represents the fat\n+      --  binary, i.e.:\n+      --\n+      --    Bin_Id : System.Address;\n+\n+      function Build_Fat_Binary_Handle_Declaration\n+        (Handle_Id  : Entity_Id;\n+         Wrapper_Id : Entity_Id) return Node_Id;\n+      --  Create the declaration of Handle_Id, a System.Address that will\n+      --  receive the results of passing the address of Wrapper_Id to\n+      --  CUDA.Register_Fat_Binary, i.e.:\n+      --\n+      --    Handle_Id : System.Address :=\n+      --      CUDA.Register_Fat_Binary (Wrapper_Id'Address)\n+\n+      function Build_Fat_Binary_Wrapper_Declaration\n+        (Wrapper_Id : Entity_Id;\n+         Bin_Id     : Entity_Id) return Node_Id;\n+      --  Create the declaration of the fat binary wrapper Wrapper_Id, which\n+      --  holds magic numbers and Bin_Id'Address, i.e.:\n+      --\n+      --     Wrapper_Id : System.Address :=\n+      --       (16#466243b1#, 1, Bin_Id'Address, System.Null_Address);\n+\n+      function Build_Import_Pragma\n+        (Bin_Id    : Entity_Id;\n+         Pack_Body : Node_Id) return Node_Id;\n+      --  Create a pragma that will bind the fat binary Bin_Id to its external\n+      --  symbol. N is the package body Bin_Id belongs to, i.e.:\n+      --\n+      --     pragma Import\n+      --        (Convention    => C,\n+      --         Entity        => Bin_Id,\n+      --         External_Name => \"_binary_<Pack_Body's name>_fatbin_start\");\n+\n+      function Build_Kernel_Name_Declaration\n+        (Kernel : Entity_Id) return Node_Id;\n+      --  Create the declaration of a C string that contains the name of\n+      --  Kernel's symbol, i.e.:\n+      --\n+      --     Kernel : Interfaces.C.Strings.Chars_Ptr :=\n+      --       Interfaces.C.Strings.New_Char_Array(\"<Kernel's name>\");\n+\n+      function Build_Register_Function_Call\n+        (Loc         : Source_Ptr;\n+         Bin         : Entity_Id;\n+         Kernel      : Entity_Id;\n+         Kernel_Name : Entity_Id) return Node_Id;\n+      --  Return a call to CUDA.Internal.Register_Function that binds Kernel\n+      --  (the entity of a procedure) to the symbol described by the C string\n+      --  Kernel_Name in the fat binary Bin, using Loc as location.\n+\n+      --------------------------\n+      -- Build_CUDA_Init_Proc --\n+      --------------------------\n+\n+      function Build_CUDA_Init_Proc\n+        (Init_Id      : Entity_Id;\n+         CUDA_Kernels : Elist_Id;\n+         Handle_Id    : Entity_Id;\n+         Pack_Decls   : List_Id) return Node_Id\n+      is\n+         Loc : constant Source_Ptr := Sloc (Init_Id);\n+\n+         Stmts : constant List_Id := New_List;\n+         --  List of statements that will be used by the cuda initialization\n+         --  function.\n+\n+         New_Stmt : Node_Id;\n+         --  Temporary variable to hold the various newly-created nodes.\n+\n+         Kernel_Elmt : Elmt_Id;\n+         Kernel_Id   : Entity_Id;\n+\n+      begin\n+         --  For each CUDA_Global function, declare a C string that holds\n+         --  its symbol's name (i.e. packagename __ functionname).\n+\n+         --  Also create a function call to CUDA.Internal.Register_Function\n+         --  that takes the declared C string, a pointer to the function and\n+         --  the fat binary handle.\n+\n+         Kernel_Elmt := First_Elmt (CUDA_Kernels);\n+         while Present (Kernel_Elmt) loop\n+            Kernel_Id := Node (Kernel_Elmt);\n+\n+            New_Stmt :=\n+              Build_Kernel_Name_Declaration (Kernel_Id);\n+            Append (New_Stmt, Pack_Decls);\n+            Analyze (New_Stmt);\n+\n+            Append_To (Stmts,\n+              Build_Register_Function_Call (Loc,\n+                Bin         => Handle_Id,\n+                Kernel      => Kernel_Id,\n+                Kernel_Name => Defining_Entity (New_Stmt)));\n+\n+            Next_Elmt (Kernel_Elmt);\n+         end loop;\n+\n+         --  Finish the CUDA initialization function: add a call to\n+         --  register_fat_binary_end, to let the CUDA runtime know that we\n+         --  won't be registering any other symbol with the current fat binary.\n+\n+         Append_To (Stmts,\n+           Make_Function_Call (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Register_Fat_Binary_End), Loc),\n+             Parameter_Associations =>\n+               New_List (New_Occurrence_Of (Handle_Id, Loc))));\n+\n+         --  Now that we have all the declarations and calls we need, we can\n+         --  build and and return the initialization procedure.\n+\n+         return\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Procedure_Specification (Loc, Init_Id),\n+             Declarations               => New_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+      end Build_CUDA_Init_Proc;\n+\n+      ----------------------------------\n+      -- Build_Fat_Binary_Declaration --\n+      ----------------------------------\n+\n+      function Build_Fat_Binary_Declaration\n+        (Bin_Id : Entity_Id) return Node_Id\n+      is\n+      begin\n+         return\n+           Make_Object_Declaration (Sloc (Bin_Id),\n+             Defining_Identifier => Bin_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (RTE (RE_Address), Sloc (Bin_Id)));\n+      end Build_Fat_Binary_Declaration;\n+\n+      -----------------------------------------\n+      -- Build_Fat_Binary_Handle_Declaration --\n+      -----------------------------------------\n+\n+      function Build_Fat_Binary_Handle_Declaration\n+        (Handle_Id  : Entity_Id;\n+         Wrapper_Id : Entity_Id) return Node_Id\n+      is\n+         Loc : constant Source_Ptr := Sloc (Handle_Id);\n+      begin\n+         --  Generate:\n+         --    Handle_Id : System.Address :=\n+         --      CUDA.Register_Fat_Binary (Wrapper_Id'Address);\n+\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Handle_Id,\n+             Object_Definition   => New_Occurrence_Of (RTE (RE_Address), Loc),\n+             Expression          =>\n+               Make_Function_Call (Loc,\n+                 Name                   =>\n+                   New_Occurrence_Of (RTE (RE_Register_Fat_Binary), Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         =>\n+                       New_Occurrence_Of (Wrapper_Id, Loc),\n+                     Attribute_Name => Name_Address))));\n+      end Build_Fat_Binary_Handle_Declaration;\n+\n+      ------------------------------------------\n+      -- Build_Fat_Binary_Wrapper_Declaration --\n+      ------------------------------------------\n+\n+      function Build_Fat_Binary_Wrapper_Declaration\n+        (Wrapper_Id : Entity_Id;\n+         Bin_Id     : Entity_Id) return Node_Id\n+      is\n+         Loc : constant Source_Ptr := Sloc (Wrapper_Id);\n+      begin\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Wrapper_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (RTE (RE_Fatbin_Wrapper), Loc),\n+             Expression          =>\n+               Make_Aggregate (Loc,\n+                 Expressions => New_List (\n+                   Make_Integer_Literal (Loc, UI_From_Int (16#466243b1#)),\n+                   Make_Integer_Literal (Loc, UI_From_Int (1)),\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix         => New_Occurrence_Of (Bin_Id, Loc),\n+                     Attribute_Name => Name_Address),\n+                   New_Occurrence_Of (RTE (RE_Null_Address), Loc))));\n+      end Build_Fat_Binary_Wrapper_Declaration;\n+\n+      -------------------------\n+      -- Build_Import_Pragma --\n+      -------------------------\n+\n+      function Build_Import_Pragma\n+        (Bin_Id    : Entity_Id;\n+         Pack_Body : Node_Id) return Node_Id\n+      is\n+         Loc             : constant Source_Ptr := Sloc (Bin_Id);\n+         External_Symbol : String_Id;\n+      begin\n+         Start_String;\n+         Store_String_Chars\n+           (\"_binary_\"\n+            & Get_Name_String (Chars (Defining_Unit_Name (Pack_Body)))\n+            & \"_fatbin_start\");\n+         External_Symbol := End_String;\n+\n+         return\n+           Make_Pragma (Loc,\n+             Pragma_Identifier            =>\n+               Make_Identifier (Loc, Name_Import),\n+             Pragma_Argument_Associations => New_List (\n+               Make_Pragma_Argument_Association (Loc,\n+                 Chars      => Name_Convention,\n+                 Expression => Make_Identifier (Loc, Name_C)),\n+               Make_Pragma_Argument_Association (Loc,\n+                 Chars      => Name_Entity,\n+                 Expression => New_Occurrence_Of (Bin_Id, Loc)),\n+               Make_Pragma_Argument_Association (Loc,\n+                 Chars      => Name_External_Name,\n+                 Expression => Make_String_Literal (Loc, External_Symbol))));\n+      end Build_Import_Pragma;\n+\n+      -------------------------------------\n+      -- Build_Kernel_Name_Declaration --\n+      -------------------------------------\n+\n+      function Build_Kernel_Name_Declaration\n+        (Kernel : Entity_Id) return Node_Id\n+      is\n+         Loc : constant Source_Ptr := Sloc (Kernel);\n+\n+         Package_Name : constant String :=\n+           Get_Name_String (Chars (Scope (Kernel)));\n+\n+         Symbol_Name : constant String := Get_Name_String (Chars (Kernel));\n+\n+         Kernel_Name : String_Id;\n+      begin\n+         Start_String;\n+         Store_String_Chars (Package_Name & \"__\" & Symbol_Name);\n+         Kernel_Name := End_String;\n+\n+         return\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Make_Temporary (Loc, 'C'),\n+             Object_Definition   =>\n+               New_Occurrence_Of (RTE (RE_Chars_Ptr), Loc),\n+             Expression          =>\n+               Make_Function_Call (Loc,\n+                 Name                   =>\n+                   New_Occurrence_Of (RTE (RE_New_Char_Array), Loc),\n+                 Parameter_Associations => New_List (\n+                   Make_String_Literal (Loc, Kernel_Name))));\n+      end Build_Kernel_Name_Declaration;\n+\n+      ----------------------------------\n+      -- Build_Register_Function_Call --\n+      ----------------------------------\n+\n+      function Build_Register_Function_Call\n+        (Loc         : Source_Ptr;\n+         Bin         : Entity_Id;\n+         Kernel      : Entity_Id;\n+         Kernel_Name : Entity_Id) return Node_Id\n+      is\n+         Args : constant List_Id := New_List;\n+      begin\n+         --  First argument: the handle of the fat binary.\n+\n+         Append (New_Occurrence_Of (Bin, Loc), Args);\n+\n+         --  Second argument: the host address of the function that is\n+         --  marked with CUDA_Global.\n+\n+         Append_To (Args,\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Kernel, Loc),\n+             Attribute_Name => Name_Address));\n+\n+         --  Third argument, the name of the function on the host.\n+\n+         Append (New_Occurrence_Of (Kernel_Name, Loc), Args);\n+\n+         --  Fourth argument, the name of the function on the device.\n+\n+         Append (New_Occurrence_Of (Kernel_Name, Loc), Args);\n+\n+         --  Fith argument: -1. Meaning unknown - this has been copied from\n+         --  LLVM.\n+\n+         Append (Make_Integer_Literal (Loc, UI_From_Int (-1)), Args);\n+\n+         --  Args 6, 7, 8, 9, 10: Null pointers. Again, meaning unknown.\n+\n+         for Arg_Count in 1 .. 5 loop\n+            Append_To (Args, New_Occurrence_Of (RTE (RE_Null_Address), Loc));\n+         end loop;\n+\n+         --  Build the call to CUDARegisterFunction, passing the argument\n+         --  list we just built.\n+\n+         return\n+           Make_Function_Call (Loc,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RE_Register_Function), Loc),\n+             Parameter_Associations => Args);\n+      end Build_Register_Function_Call;\n+\n+      --  Local declarations\n+\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Spec_Id : constant Node_Id := Corresponding_Spec (N);\n+      --  The specification of the package we're adding a cuda init func to.\n+\n+      Pack_Decls : constant List_Id := Declarations (N);\n+\n+      CUDA_Node_List : constant Elist_Id := Get_CUDA_Kernels (Spec_Id);\n+      --  CUDA nodes that belong to the package.\n+\n+      CUDA_Init_Func : Entity_Id;\n+      --  Entity of the cuda init func.\n+\n+      Fat_Binary : Entity_Id;\n+      --  Entity of the fat binary of N. Bound to said fat binary by a pragma.\n+\n+      Fat_Binary_Handle : Entity_Id;\n+      --  Entity of the result of passing the fat binary wrapper to.\n+      --  CUDA.Register_Fat_Binary.\n+\n+      Fat_Binary_Wrapper : Entity_Id;\n+      --  Entity of a record that holds a bunch of magic numbers and a\n+      --  reference to Fat_Binary.\n+\n+      New_Stmt : Node_Id;\n+      --  Node to store newly-created declarations\n+\n+   --  Start of processing for Build_And_Insert_CUDA_Initialization\n+\n+   begin\n+      if CUDA_Node_List = No_Elist or not Debug_Flag_Underscore_C then\n+         return;\n+      end if;\n+\n+      Fat_Binary := Make_Temporary (Loc, 'C');\n+      New_Stmt := Build_Fat_Binary_Declaration (Fat_Binary);\n+      Append_To (Pack_Decls, New_Stmt);\n+      Analyze (New_Stmt);\n+\n+      New_Stmt := Build_Import_Pragma (Fat_Binary, N);\n+      Append_To (Pack_Decls, New_Stmt);\n+      Analyze (New_Stmt);\n+\n+      Fat_Binary_Wrapper := Make_Temporary (Loc, 'C');\n+      New_Stmt :=\n+        Build_Fat_Binary_Wrapper_Declaration\n+          (Wrapper_Id => Fat_Binary_Wrapper,\n+           Bin_Id     => Fat_Binary);\n+      Append_To (Pack_Decls, New_Stmt);\n+      Analyze (New_Stmt);\n+\n+      Fat_Binary_Handle := Make_Temporary (Loc, 'C');\n+      New_Stmt :=\n+        Build_Fat_Binary_Handle_Declaration\n+          (Fat_Binary_Handle, Fat_Binary_Wrapper);\n+      Append_To (Pack_Decls, New_Stmt);\n+      Analyze (New_Stmt);\n+\n+      CUDA_Init_Func := Make_Temporary (Loc, 'C');\n+      New_Stmt :=\n+        Build_CUDA_Init_Proc\n+          (Init_Id      => CUDA_Init_Func,\n+           CUDA_Kernels => CUDA_Node_List,\n+           Handle_Id    => Fat_Binary_Handle,\n+           Pack_Decls   => Pack_Decls);\n+      Append_To (Pack_Decls, New_Stmt);\n+      Analyze (New_Stmt);\n+\n+      New_Stmt :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name => New_Occurrence_Of (CUDA_Init_Func, Loc));\n+      Append_To (Pack_Decls, New_Stmt);\n+      Analyze (New_Stmt);\n+   end Build_And_Insert_CUDA_Initialization;\n+\n+   --------------------\n+   -- Set_CUDA_Nodes --\n+   --------------------\n+\n+   procedure Set_CUDA_Kernels\n+     (Pack_Id : Entity_Id;\n+      Kernels : Elist_Id)\n+   is\n+   begin\n+      pragma Assert (Get_CUDA_Kernels (Pack_Id) = No_Elist);\n+      CUDA_Kernels_Table.Set (Pack_Id, Kernels);\n+   end Set_CUDA_Kernels;\n+\n+end GNAT_CUDA;"}, {"sha": "e27be34bafd97c0ff349aae9735a5ffa873dbdf4", "filename": "gcc/ada/gnat_cuda.ads", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fgnat_cuda.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fgnat_cuda.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_cuda.ads?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -0,0 +1,107 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                 C U D A                                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2010-2020, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package defines CUDA-specific datastructures and subprograms.\n+--\n+--  Compiling for CUDA requires compiling for two targets. One is the CPU (more\n+--  frequently named \"host\"), the other is the GPU (the \"device\"). Compiling\n+--  for the host requires compiling the whole program. Compiling for the device\n+--  only requires compiling packages that contain CUDA kernels.\n+--\n+--  When compiling for the device, GNAT-LLVM is used. It produces assembly\n+--  tailored to Nvidia's GPU (NVPTX). This NVPTX code is then assembled into\n+--  an object file by ptxas, an assembler provided by Nvidia. This object file\n+--  is then combined with its source code into a fat binary by a tool named\n+--  `fatbin`, also provided by Nvidia. The resulting fat binary is turned into\n+--  a regular object file by the host's linker and linked with the program that\n+--  executes on the host.\n+--\n+--  A CUDA kernel is a procedure marked with the CUDA_Global pragma or aspect.\n+--  CUDA_Global does not have any effect when compiling for the device. When\n+--  compiling for the host, the frontend stores procedures marked with\n+--  CUDA_Global in a hash table the key of which is the Node_Id of the package\n+--  body that contains the CUDA_Global procedure. This is done in sem_prag.adb.\n+--  Once the declarations of a package body have been analyzed, variable, type\n+--  and procedure declarations necessary for the initialization of the CUDA\n+--  runtime are appended to the package that contains the CUDA_Global\n+--  procedure.\n+--\n+--  These declarations are used to register the CUDA kernel with the CUDA\n+--  runtime when the program is launched. Registering a CUDA kernel with the\n+--  CUDA runtime requires multiple function calls:\n+--  - The first one registers the fat binary which corresponds to the package\n+--    with the CUDA runtime.\n+--  - Then, as many function calls as there are kernels in order to bind them\n+--    with the fat binary.\n+--    fat binary.\n+--  - The last call lets the CUDA runtime know that we are done initializing\n+--    CUDA.\n+--  Expansion of the CUDA_Global aspect is triggered in sem_ch7.adb, during\n+--  analysis of the package. All of this expansion is performed in the\n+--  Insert_CUDA_Initialization procedure defined in GNAT_CUDA.\n+--\n+--  Once a CUDA package is initialized, its kernels are ready to be used.\n+--  Launching CUDA kernels is done by using the CUDA_Execute pragma. When\n+--  compiling for the host, the CUDA_Execute pragma is expanded into a declare\n+--  block which performs calls to the CUDA runtime functions.\n+--  - The first one pushes a \"launch configuration\" on the \"configuration\n+--    stack\" of the CUDA runtime.\n+--  - The second call pops this call configuration, making it effective.\n+--  - The third call actually launches the kernel.\n+--  Light validation of the CUDA_Execute pragma is performed in sem_prag.adb\n+--  and expansion is performed in exp_prag.adb.\n+\n+with Types; use Types;\n+\n+package GNAT_CUDA is\n+\n+   procedure Add_CUDA_Kernel (Pack_Id : Entity_Id; Kernel : Entity_Id);\n+   --  Add Kernel to the list of CUDA_Global nodes that belong to Pack_Id.\n+   --  Kernel is a procedure entity marked with CUDA_Global, Pack_Id is the\n+   --  entity of its parent package body.\n+\n+   procedure Build_And_Insert_CUDA_Initialization (N : Node_Id);\n+   --  Builds declarations necessary for CUDA initialization and inserts them\n+   --  in N, the package body that contains CUDA_Global nodes. These\n+   --  declarations are:\n+   --\n+   --    * A symbol to hold the pointer to the CUDA fat binary\n+   --\n+   --    * A type definition for a wrapper that contains the pointer to the\n+   --      CUDA fat binary\n+   --\n+   --    * An object of the aforementioned type to hold the aforementioned\n+   --      pointer.\n+   --\n+   --    * For each CUDA_Global procedure in the package, a declaration of a C\n+   --      string containing the function's name.\n+   --\n+   --    * A function that takes care of calling CUDA functions that register\n+   --      CUDA_Global procedures with the runtime.\n+   --\n+   --    * A boolean that holds the result of the call to the aforementioned\n+   --      function.\n+\n+end GNAT_CUDA;"}, {"sha": "872ce0165b9e62007c7b4b4e2e17ee2a94bfdfd2", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -589,7 +589,10 @@ package body Rtsfind is\n      range CUDA_Driver_Types .. CUDA_Vector_Types;\n \n    subtype Interfaces_Descendant is RTU_Id\n-     range Interfaces_C .. Interfaces_Packed_Decimal;\n+     range Interfaces_C .. Interfaces_C_Strings;\n+\n+   subtype Interfaces_C_Descendant is Interfaces_Descendant\n+     range Interfaces_C_Strings .. Interfaces_C_Strings;\n \n    subtype System_Descendant is RTU_Id\n      range System_Address_Image .. System_Tasking_Stages;\n@@ -674,6 +677,10 @@ package body Rtsfind is\n       elsif U_Id in Interfaces_Descendant then\n          Name_Buffer (11) := '.';\n \n+         if U_Id in Interfaces_C_Descendant then\n+            Name_Buffer (13) := '.';\n+         end if;\n+\n       elsif U_Id in System_Descendant then\n          Name_Buffer (7) := '.';\n "}, {"sha": "1c8a2949180ff8f76c76dcbbed52072514d62655", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -179,6 +179,10 @@ package Rtsfind is\n       Interfaces_C,\n       Interfaces_Packed_Decimal,\n \n+      --  Children of Interfaces.C\n+\n+      Interfaces_C_Strings,\n+\n       --  Package System\n \n       System,\n@@ -628,8 +632,12 @@ package Rtsfind is\n \n      RE_Stream_T,                        -- CUDA.Driver_Types\n \n+     RE_Fatbin_Wrapper,                  -- CUDA.Internal\n      RE_Push_Call_Configuration,         -- CUDA.Internal\n      RE_Pop_Call_Configuration,          -- CUDA.Internal\n+     RE_Register_Fat_Binary,             -- CUDA.Internal\n+     RE_Register_Fat_Binary_End,         -- CUDA.Internal\n+     RE_Register_Function,               -- CUDA.Internal\n \n      RE_Launch_Kernel,                   -- CUDA.Runtime_Api\n \n@@ -647,6 +655,9 @@ package Rtsfind is\n      RO_IC_Unsigned,                     -- Interfaces.C\n      RO_IC_Unsigned_Long_Long,           -- Interfaces.C\n \n+     RE_Chars_Ptr,                       -- Interfaces.C.Strings\n+     RE_New_Char_Array,                  -- Interfaces.C.Strings\n+\n      RE_Address,                         -- System\n      RE_Any_Priority,                    -- System\n      RE_Bit_Order,                       -- System\n@@ -1927,8 +1938,12 @@ package Rtsfind is\n \n      RE_Stream_T                         => CUDA_Driver_Types,\n \n+     RE_Fatbin_Wrapper                   => CUDA_Internal,\n      RE_Push_Call_Configuration          => CUDA_Internal,\n      RE_Pop_Call_Configuration           => CUDA_Internal,\n+     RE_Register_Fat_Binary              => CUDA_Internal,\n+     RE_Register_Fat_Binary_End          => CUDA_Internal,\n+     RE_Register_Function                => CUDA_Internal,\n \n      RE_Launch_Kernel                    => CUDA_Runtime_Api,\n \n@@ -1946,6 +1961,9 @@ package Rtsfind is\n      RO_IC_Unsigned                      => Interfaces_C,\n      RO_IC_Unsigned_Long_Long            => Interfaces_C,\n \n+     RE_Chars_Ptr                        => Interfaces_C_Strings,\n+     RE_New_Char_Array                   => Interfaces_C_Strings,\n+\n      RE_Address                          => System,\n      RE_Any_Priority                     => System,\n      RE_Bit_Order                        => System,"}, {"sha": "762f0c13ee9e9a25999e947c341485d93100d323", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -40,6 +40,7 @@ with Exp_Dist;  use Exp_Dist;\n with Exp_Dbug;  use Exp_Dbug;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n+with GNAT_CUDA; use GNAT_CUDA;\n with Lib;       use Lib;\n with Lib.Xref;  use Lib.Xref;\n with Namet;     use Namet;\n@@ -999,6 +1000,13 @@ package body Sem_Ch7 is\n          Analyze_List (Declarations (N));\n       end if;\n \n+      --  If procedures marked with CUDA_Global have been defined within N, we\n+      --  need to register them with the CUDA runtime at program startup. This\n+      --  requires multiple declarations and function calls which need to be\n+      --  appended to N's declarations.\n+\n+      Build_And_Insert_CUDA_Initialization (N);\n+\n       HSS := Handled_Statement_Sequence (N);\n \n       if Present (HSS) then"}, {"sha": "33a3f7aecba612fbe41663e8f087e2018aeb27c8", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0a16e6d4c91120dd9a2900da0831e83e65f2046/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b0a16e6d4c91120dd9a2900da0831e83e65f2046", "patch": "@@ -44,6 +44,7 @@ with Exp_Util;  use Exp_Util;\n with Expander;  use Expander;\n with Freeze;    use Freeze;\n with Ghost;     use Ghost;\n+with GNAT_CUDA; use GNAT_CUDA;\n with Gnatvsn;   use Gnatvsn;\n with Lib;       use Lib;\n with Lib.Writ;  use Lib.Writ;\n@@ -14892,6 +14893,7 @@ package body Sem_Prag is\n \n             else\n                Set_Is_CUDA_Kernel (Kernel_Proc);\n+               Add_CUDA_Kernel (Pack_Id, Kernel_Proc);\n             end if;\n          end CUDA_Global;\n "}]}