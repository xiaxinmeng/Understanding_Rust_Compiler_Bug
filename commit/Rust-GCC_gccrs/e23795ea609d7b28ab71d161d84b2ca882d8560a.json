{"sha": "e23795ea609d7b28ab71d161d84b2ca882d8560a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIzNzk1ZWE2MDlkN2IyOGFiNzFkMTYxZDg0YjJjYTg4MmQ4NTYwYQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-04-10T16:40:03Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-04-10T16:40:03Z"}, "message": "s390.c (larl_operand): Do not allow symbols marked with '@'.\n\n\t* config/s390/s390.c (larl_operand): Do not allow symbols\n\tmarked with '@'.\n\t(s390_encode_section_info): Mark symbols with forced 1-byte\n\talignment with '@'.\n\t(s390_strip_name_encoding): Strip '@'.\n\t(legitimize_pic_address): Handle symbols that are not valid\n\tLARL operands in 64-bit mode.\n\nFrom-SVN: r65426", "tree": {"sha": "4db0503e034a36d836eadff526515bd2114eed7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db0503e034a36d836eadff526515bd2114eed7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e23795ea609d7b28ab71d161d84b2ca882d8560a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e23795ea609d7b28ab71d161d84b2ca882d8560a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e23795ea609d7b28ab71d161d84b2ca882d8560a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e23795ea609d7b28ab71d161d84b2ca882d8560a/comments", "author": null, "committer": null, "parents": [{"sha": "0bb7378dd61303216b670b320644b98a405d1e8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb7378dd61303216b670b320644b98a405d1e8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb7378dd61303216b670b320644b98a405d1e8a"}], "stats": {"total": 65, "additions": 48, "deletions": 17}, "files": [{"sha": "2883d45f410b5b9cb2dacaddf5653fd64232da27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e23795ea609d7b28ab71d161d84b2ca882d8560a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e23795ea609d7b28ab71d161d84b2ca882d8560a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e23795ea609d7b28ab71d161d84b2ca882d8560a", "patch": "@@ -1,3 +1,13 @@\n+2003-04-10  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (larl_operand): Do not allow symbols\n+\tmarked with '@'.\n+\t(s390_encode_section_info): Mark symbols with forced 1-byte\n+\talignment with '@'.\n+\t(s390_strip_name_encoding): Strip '@'.\n+\t(legitimize_pic_address): Handle symbols that are not valid\n+\tLARL operands in 64-bit mode.\n+\n 2003-04-10  Andrew Haley  <aph@redhat.com>\n \n \t* tree-inline.c (inlinable_function_p): Disable inlining for"}, {"sha": "80e030e1f0597871319ffe454c1d3d86841091e5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e23795ea609d7b28ab71d161d84b2ca882d8560a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e23795ea609d7b28ab71d161d84b2ca882d8560a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=e23795ea609d7b28ab71d161d84b2ca882d8560a", "patch": "@@ -1051,6 +1051,7 @@ larl_operand (op, mode)\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n   if (GET_CODE (op) == SYMBOL_REF\n+      && XSTR (op, 0)[0] != '@'\n       && !tls_symbolic_operand (op)\n       && (!flag_pic || SYMBOL_REF_FLAG (op) \n           || CONSTANT_POOL_ADDRESS_P (op)))\n@@ -1074,6 +1075,7 @@ larl_operand (op, mode)\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n   if (GET_CODE (op) == SYMBOL_REF\n+      && XSTR (op, 0)[0] != '@'\n       && !tls_symbolic_operand (op)\n       && (!flag_pic || SYMBOL_REF_FLAG (op)\n           || CONSTANT_POOL_ADDRESS_P (op)))\n@@ -2179,7 +2181,7 @@ legitimize_pic_address (orig, reg)\n               || CONSTANT_POOL_ADDRESS_P (addr))))\n     {\n       /* This is a local symbol.  */\n-      if (TARGET_64BIT)\n+      if (TARGET_64BIT && larl_operand (addr, VOIDmode))\n         {\n           /* Access local symbols PC-relative via LARL.  \n              This is the same as in the non-PIC case, so it is \n@@ -2191,9 +2193,9 @@ legitimize_pic_address (orig, reg)\n \n           rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n-          addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 100);\n-          addr = gen_rtx_CONST (SImode, addr);\n-          addr = force_const_mem (SImode, addr);\n+          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 100);\n+          addr = gen_rtx_CONST (Pmode, addr);\n+          addr = force_const_mem (Pmode, addr);\n \t  emit_move_insn (temp, addr);\n \n           base = gen_rtx_REG (Pmode, BASE_REGISTER);\n@@ -2254,9 +2256,9 @@ legitimize_pic_address (orig, reg)\n \t  if (reload_in_progress || reload_completed)\n \t    regs_ever_live[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n-          addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 112);\n-          addr = gen_rtx_CONST (SImode, addr);\n-          addr = force_const_mem (SImode, addr);\n+          addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 112);\n+          addr = gen_rtx_CONST (Pmode, addr);\n+          addr = force_const_mem (Pmode, addr);\n           emit_move_insn (temp, addr);\n \n           new = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, temp);\n@@ -2282,7 +2284,7 @@ legitimize_pic_address (orig, reg)\n                   case 100:\n                   case 112:\n                   case 114:\n-                    new = force_const_mem (SImode, orig);\n+                    new = force_const_mem (Pmode, orig);\n                     break;\n \n                   /* @GOTENT is OK as is.  */\n@@ -2297,9 +2299,9 @@ legitimize_pic_address (orig, reg)\n                         rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n                         addr = XVECEXP (addr, 0, 0);\n-                        addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, addr), 114);\n-                        addr = gen_rtx_CONST (SImode, addr);\n-                        addr = force_const_mem (SImode, addr);\n+                        addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), 114);\n+                        addr = gen_rtx_CONST (Pmode, addr);\n+                        addr = force_const_mem (Pmode, addr);\n \t                emit_move_insn (temp, addr);\n \n                         base = gen_rtx_REG (Pmode, BASE_REGISTER);\n@@ -2333,7 +2335,7 @@ legitimize_pic_address (orig, reg)\n                         || CONSTANT_POOL_ADDRESS_P (op0))))\n \t      && GET_CODE (op1) == CONST_INT)\n \t    {\n-              if (TARGET_64BIT)\n+              if (TARGET_64BIT && larl_operand (op0, VOIDmode))\n                 {\n                   if (INTVAL (op1) & 1)\n                     {\n@@ -2370,10 +2372,10 @@ legitimize_pic_address (orig, reg)\n \n                   rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n-                  addr = gen_rtx_UNSPEC (SImode, gen_rtvec (1, op0), 100);\n-                  addr = gen_rtx_PLUS (SImode, addr, op1);\n-                  addr = gen_rtx_CONST (SImode, addr);\n-                  addr = force_const_mem (SImode, addr);\n+                  addr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op0), 100);\n+                  addr = gen_rtx_PLUS (Pmode, addr, op1);\n+                  addr = gen_rtx_CONST (Pmode, addr);\n+                  addr = force_const_mem (Pmode, addr);\n         \t  emit_move_insn (temp, addr);\n \n                   base = gen_rtx_REG (Pmode, BASE_REGISTER);\n@@ -2399,7 +2401,7 @@ legitimize_pic_address (orig, reg)\n               if (XINT (op0, 1) != 100)\n                 abort ();\n \n-              new = force_const_mem (SImode, orig);\n+              new = force_const_mem (Pmode, orig);\n             }\n \n           /* Otherwise, compute the sum.  */\n@@ -6480,6 +6482,23 @@ s390_encode_section_info (decl, first)\n \n       XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 2 - 1);\n     }\n+\n+  /* If a variable has a forced alignment to < 2 bytes, mark it\n+     with '@' to prevent it from being used as LARL operand.  */\n+\n+  else if (TREE_CODE (decl) == VAR_DECL \n+\t   && DECL_USER_ALIGN (decl) && DECL_ALIGN (decl) < 16\n+\t   && XSTR (symbol, 0)[0] != '@')\n+    {\n+      const char *symbol_str = XSTR (symbol, 0);\n+      size_t len = strlen (symbol_str) + 1;\n+      char *newstr = alloca (len + 1);\n+\n+      newstr[0] = '@';\n+      memcpy (newstr + 1, symbol_str, len);\n+\n+      XSTR (symbol, 0) = ggc_alloc_string (newstr, len + 1 - 1);\n+    }\n }\n \n /* Undo the above when printing symbol names.  */\n@@ -6490,6 +6509,8 @@ s390_strip_name_encoding (str)\n {\n   if (str[0] == '%')\n     str += 2;\n+  if (str[0] == '@')\n+    str += 1;\n   if (str[0] == '*')\n     str += 1;\n   return str;"}]}