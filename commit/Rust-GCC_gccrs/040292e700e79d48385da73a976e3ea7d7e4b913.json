{"sha": "040292e700e79d48385da73a976e3ea7d7e4b913", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQwMjkyZTcwMGU3OWQ0ODM4NWRhNzNhOTc2ZTNlYTdkN2U0YjkxMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-08-18T14:30:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-08-18T14:30:30Z"}, "message": "gimple-fold.c (maybe_fold_reference): Move re-gimplification code to ...\n\n2014-08-18  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-fold.c (maybe_fold_reference): Move re-gimplification\n\tcode to ...\n\t(maybe_canonicalize_mem_ref_addr): ... this function.\n\t(fold_stmt_1): Apply it here before all simplification.\n\nFrom-SVN: r214103", "tree": {"sha": "0cc63ddc60f5c1363dc3604fb6bc2a51989dfef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cc63ddc60f5c1363dc3604fb6bc2a51989dfef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/040292e700e79d48385da73a976e3ea7d7e4b913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040292e700e79d48385da73a976e3ea7d7e4b913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/040292e700e79d48385da73a976e3ea7d7e4b913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/040292e700e79d48385da73a976e3ea7d7e4b913/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d34af02260f54bf3b5180855daa57e77ae5383d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34af02260f54bf3b5180855daa57e77ae5383d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34af02260f54bf3b5180855daa57e77ae5383d4"}], "stats": {"total": 222, "additions": 161, "deletions": 61}, "files": [{"sha": "f471e2cc48d58b08721c3f59b9fd4d5aae7e8889", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040292e700e79d48385da73a976e3ea7d7e4b913/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040292e700e79d48385da73a976e3ea7d7e4b913/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=040292e700e79d48385da73a976e3ea7d7e4b913", "patch": "@@ -1,3 +1,10 @@\n+2014-08-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-fold.c (maybe_fold_reference): Move re-gimplification\n+\tcode to ...\n+\t(maybe_canonicalize_mem_ref_addr): ... this function.\n+\t(fold_stmt_1): Apply it here before all simplification.\n+\n 2014-08-18  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \tPR ipa/61800"}, {"sha": "d34be0a2906c705d311893a584cc3d2829e9b030", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 154, "deletions": 61, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/040292e700e79d48385da73a976e3ea7d7e4b913/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/040292e700e79d48385da73a976e3ea7d7e4b913/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=040292e700e79d48385da73a976e3ea7d7e4b913", "patch": "@@ -256,7 +256,6 @@ get_symbol_constant_value (tree sym)\n static tree\n maybe_fold_reference (tree expr, bool is_lhs)\n {\n-  tree *t = &expr;\n   tree result;\n \n   if ((TREE_CODE (expr) == VIEW_CONVERT_EXPR\n@@ -276,71 +275,11 @@ maybe_fold_reference (tree expr, bool is_lhs)\n \t\t\t     TREE_OPERAND (expr, 1),\n \t\t\t     TREE_OPERAND (expr, 2));\n \n-  while (handled_component_p (*t))\n-    t = &TREE_OPERAND (*t, 0);\n-\n-  /* Canonicalize MEM_REFs invariant address operand.  Do this first\n-     to avoid feeding non-canonical MEM_REFs elsewhere.  */\n-  if (TREE_CODE (*t) == MEM_REF\n-      && !is_gimple_mem_ref_addr (TREE_OPERAND (*t, 0)))\n-    {\n-      bool volatile_p = TREE_THIS_VOLATILE (*t);\n-      tree tem = fold_binary (MEM_REF, TREE_TYPE (*t),\n-\t\t\t      TREE_OPERAND (*t, 0),\n-\t\t\t      TREE_OPERAND (*t, 1));\n-      if (tem)\n-\t{\n-\t  TREE_THIS_VOLATILE (tem) = volatile_p;\n-\t  *t = tem;\n-\t  tem = maybe_fold_reference (expr, is_lhs);\n-\t  if (tem)\n-\t    return tem;\n-\t  return expr;\n-\t}\n-    }\n-\n   if (!is_lhs\n       && (result = fold_const_aggregate_ref (expr))\n       && is_gimple_min_invariant (result))\n     return result;\n \n-  /* Fold back MEM_REFs to reference trees.  */\n-  if (TREE_CODE (*t) == MEM_REF\n-      && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR\n-      && integer_zerop (TREE_OPERAND (*t, 1))\n-      && (TREE_THIS_VOLATILE (*t)\n-\t  == TREE_THIS_VOLATILE (TREE_OPERAND (TREE_OPERAND (*t, 0), 0)))\n-      && !TYPE_REF_CAN_ALIAS_ALL (TREE_TYPE (TREE_OPERAND (*t, 1)))\n-      && (TYPE_MAIN_VARIANT (TREE_TYPE (*t))\n-\t  == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (TREE_OPERAND (*t, 1)))))\n-      /* We have to look out here to not drop a required conversion\n-\t from the rhs to the lhs if is_lhs, but we don't have the\n-\t rhs here to verify that.  Thus require strict type\n-\t compatibility.  */\n-      && types_compatible_p (TREE_TYPE (*t),\n-\t\t\t     TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t(TREE_OPERAND (*t, 0), 0))))\n-    {\n-      tree tem;\n-      *t = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n-      tem = maybe_fold_reference (expr, is_lhs);\n-      if (tem)\n-\treturn tem;\n-      return expr;\n-    }\n-  else if (TREE_CODE (*t) == TARGET_MEM_REF)\n-    {\n-      tree tem = maybe_fold_tmr (*t);\n-      if (tem)\n-\t{\n-\t  *t = tem;\n-\t  tem = maybe_fold_reference (expr, is_lhs);\n-\t  if (tem)\n-\t    return tem;\n-\t  return expr;\n-\t}\n-    }\n-\n   return NULL_TREE;\n }\n \n@@ -2678,6 +2617,88 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n   return changed;\n }\n \n+/* Canonicalize MEM_REFs invariant address operand after propagation.  */\n+\n+static bool\n+maybe_canonicalize_mem_ref_addr (tree *t)\n+{\n+  bool res = false;\n+\n+  if (TREE_CODE (*t) == ADDR_EXPR)\n+    t = &TREE_OPERAND (*t, 0);\n+\n+  while (handled_component_p (*t))\n+    t = &TREE_OPERAND (*t, 0);\n+\n+  /* Canonicalize MEM [&foo.bar, 0] which appears after propagating\n+     of invariant addresses into a SSA name MEM_REF address.  */\n+  if (TREE_CODE (*t) == MEM_REF\n+      || TREE_CODE (*t) == TARGET_MEM_REF)\n+    {\n+      tree addr = TREE_OPERAND (*t, 0);\n+      if (TREE_CODE (addr) == ADDR_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (addr, 0)) == MEM_REF\n+\t      || handled_component_p (TREE_OPERAND (addr, 0))))\n+\t{\n+\t  tree base;\n+\t  HOST_WIDE_INT coffset;\n+\t  base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n+\t\t\t\t\t\t&coffset);\n+\t  if (!base)\n+\t    gcc_unreachable ();\n+\n+\t  TREE_OPERAND (*t, 0) = build_fold_addr_expr (base);\n+\t  TREE_OPERAND (*t, 1) = int_const_binop (PLUS_EXPR,\n+\t\t\t\t\t\t  TREE_OPERAND (*t, 1),\n+\t\t\t\t\t\t  size_int (coffset));\n+\t  res = true;\n+\t}\n+      gcc_checking_assert (TREE_CODE (TREE_OPERAND (*t, 0)) == DEBUG_EXPR_DECL\n+\t\t\t   || is_gimple_mem_ref_addr (TREE_OPERAND (*t, 0)));\n+    }\n+\n+  /* Canonicalize back MEM_REFs to plain reference trees if the object\n+     accessed is a decl that has the same access semantics as the MEM_REF.  */\n+  if (TREE_CODE (*t) == MEM_REF\n+      && TREE_CODE (TREE_OPERAND (*t, 0)) == ADDR_EXPR\n+      && integer_zerop (TREE_OPERAND (*t, 1)))\n+    {\n+      tree decl = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n+      tree alias_type = TREE_TYPE (TREE_OPERAND (*t, 1));\n+      if (/* Same volatile qualification.  */\n+\t  TREE_THIS_VOLATILE (*t) == TREE_THIS_VOLATILE (decl)\n+\t  /* Same TBAA behavior with -fstrict-aliasing.  */\n+\t  && !TYPE_REF_CAN_ALIAS_ALL (alias_type)\n+\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (decl))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (alias_type)))\n+\t  /* Same alignment.  */\n+\t  && TYPE_ALIGN (TREE_TYPE (decl)) == TYPE_ALIGN (TREE_TYPE (*t))\n+\t  /* We have to look out here to not drop a required conversion\n+\t     from the rhs to the lhs if *t appears on the lhs or vice-versa\n+\t     if it appears on the rhs.  Thus require strict type\n+\t     compatibility.  */\n+\t  && types_compatible_p (TREE_TYPE (*t), TREE_TYPE (decl)))\n+\t{\n+\t  *t = TREE_OPERAND (TREE_OPERAND (*t, 0), 0);\n+\t  res = true;\n+\t}\n+    }\n+\n+  /* Canonicalize TARGET_MEM_REF in particular with respect to\n+     the indexes becoming constant.  */\n+  else if (TREE_CODE (*t) == TARGET_MEM_REF)\n+    {\n+      tree tem = maybe_fold_tmr (*t);\n+      if (tem)\n+\t{\n+\t  *t = tem;\n+\t  res = true;\n+\t}\n+    }\n+\n+  return res;\n+}\n+\n /* Worker for both fold_stmt and fold_stmt_inplace.  The INPLACE argument\n    distinguishes both cases.  */\n \n@@ -2688,6 +2709,78 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n   gimple stmt = gsi_stmt (*gsi);\n   unsigned i;\n \n+  /* First do required canonicalization of [TARGET_]MEM_REF addresses\n+     after propagation.\n+     ???  This shouldn't be done in generic folding but in the\n+     propagation helpers which also know whether an address was\n+     propagated.  */\n+  switch (gimple_code (stmt))\n+    {\n+    case GIMPLE_ASSIGN:\n+      if (gimple_assign_rhs_class (stmt) == GIMPLE_SINGLE_RHS)\n+\t{\n+\t  tree *rhs = gimple_assign_rhs1_ptr (stmt);\n+\t  if ((REFERENCE_CLASS_P (*rhs)\n+\t       || TREE_CODE (*rhs) == ADDR_EXPR)\n+\t      && maybe_canonicalize_mem_ref_addr (rhs))\n+\t    changed = true;\n+\t  tree *lhs = gimple_assign_lhs_ptr (stmt);\n+\t  if (REFERENCE_CLASS_P (*lhs)\n+\t      && maybe_canonicalize_mem_ref_addr (lhs))\n+\t    changed = true;\n+\t}\n+      break;\n+    case GIMPLE_CALL:\n+      {\n+\tfor (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t  {\n+\t    tree *arg = gimple_call_arg_ptr (stmt, i);\n+\t    if (REFERENCE_CLASS_P (*arg)\n+\t\t&& maybe_canonicalize_mem_ref_addr (arg))\n+\t      changed = true;\n+\t  }\n+\ttree *lhs = gimple_call_lhs_ptr (stmt);\n+\tif (*lhs\n+\t    && REFERENCE_CLASS_P (*lhs)\n+\t    && maybe_canonicalize_mem_ref_addr (lhs))\n+\t  changed = true;\n+\tbreak;\n+      }\n+    case GIMPLE_ASM:\n+      {\n+\tfor (i = 0; i < gimple_asm_noutputs (stmt); ++i)\n+\t  {\n+\t    tree link = gimple_asm_output_op (stmt, i);\n+\t    tree op = TREE_VALUE (link);\n+\t    if (REFERENCE_CLASS_P (op)\n+\t\t&& maybe_canonicalize_mem_ref_addr (&TREE_VALUE (link)))\n+\t      changed = true;\n+\t  }\n+\tfor (i = 0; i < gimple_asm_ninputs (stmt); ++i)\n+\t  {\n+\t    tree link = gimple_asm_input_op (stmt, i);\n+\t    tree op = TREE_VALUE (link);\n+\t    if ((REFERENCE_CLASS_P (op)\n+\t\t || TREE_CODE (op) == ADDR_EXPR)\n+\t\t&& maybe_canonicalize_mem_ref_addr (&TREE_VALUE (link)))\n+\t      changed = true;\n+\t  }\n+      }\n+      break;\n+    case GIMPLE_DEBUG:\n+      if (gimple_debug_bind_p (stmt))\n+\t{\n+\t  tree *val = gimple_debug_bind_get_value_ptr (stmt);\n+\t  if (*val\n+\t      && (REFERENCE_CLASS_P (*val)\n+\t\t  || TREE_CODE (*val) == ADDR_EXPR)\n+\t      && maybe_canonicalize_mem_ref_addr (val))\n+\t    changed = true;\n+\t}\n+      break;\n+    default:;\n+    }\n+\n   /* Fold the main computation performed by the statement.  */\n   switch (gimple_code (stmt))\n     {"}]}