{"sha": "2c169babb627a91c6dd3900707cdc53f170a9b70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMxNjliYWJiNjI3YTkxYzZkZDM5MDA3MDdjZGM1M2YxNzBhOWI3MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-08-14T11:08:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-08-14T11:08:53Z"}, "message": "Speed up Koenig lookup.\n\n\t* decl.c (unqualified_namespace_lookup): Nonstatic.  Add spacep parm\n\tto return namespaces we've looked at.\n\t* decl2.c (lookup_using_namespace): Likewise.\n\t(add_function): Don't call ovl_member.\n\t(lookup_arg_dependent): Initialize k.namespaces to the list of\n\tnamespaces seen in unqualified lookup.\n\t* call.c (equal_functions): Move here from tree.c.\n\t(joust): Use it to handle duplicate candidates.\n\t* tree.c (ovl_member): Use ==.\n\nFrom-SVN: r28710", "tree": {"sha": "0fd913fab4e14909c83a60b48cc2851a7734e2cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fd913fab4e14909c83a60b48cc2851a7734e2cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c169babb627a91c6dd3900707cdc53f170a9b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c169babb627a91c6dd3900707cdc53f170a9b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c169babb627a91c6dd3900707cdc53f170a9b70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c169babb627a91c6dd3900707cdc53f170a9b70/comments", "author": null, "committer": null, "parents": [{"sha": "9188c36364c9a8bdd993a5d911b875ce124bb04d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9188c36364c9a8bdd993a5d911b875ce124bb04d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9188c36364c9a8bdd993a5d911b875ce124bb04d"}], "stats": {"total": 158, "additions": 102, "deletions": 56}, "files": [{"sha": "b5ce289067503cb9c5d94b1558e1ebb135150a26", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -1,3 +1,16 @@\n+1999-08-14  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\tSpeed up Koenig lookup.\n+\t* decl.c (unqualified_namespace_lookup): Nonstatic.  Add spacep parm\n+\tto return namespaces we've looked at.\n+\t* decl2.c (lookup_using_namespace): Likewise.\n+\t(add_function): Don't call ovl_member.\n+\t(lookup_arg_dependent): Initialize k.namespaces to the list of \n+\tnamespaces seen in unqualified lookup.\n+\t* call.c (equal_functions): Move here from tree.c.\n+\t(joust): Use it to handle duplicate candidates.\n+\t* tree.c (ovl_member): Use ==.\n+\n 1999-08-13  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.def (DECL_STMT): Make it smaller."}, {"sha": "f193a4b7b162b748fd7d164619bb7c5a0afaec95", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -44,6 +44,7 @@ static tree build_new_method_call PROTO((tree, tree, tree, tree, int));\n \n static tree build_field_call PROTO((tree, tree, tree, tree));\n static struct z_candidate * tourney PROTO((struct z_candidate *));\n+static int equal_functions PROTO((tree, tree));\n static int joust PROTO((struct z_candidate *, struct z_candidate *, int));\n static int compare_ics PROTO((tree, tree));\n static tree build_over_call PROTO((struct z_candidate *, tree, int));\n@@ -4768,6 +4769,20 @@ add_warning (winner, loser)\n \t\t\t\t     winner->warnings);\n }\n \n+/* Returns true iff functions are equivalent. Equivalent functions are\n+   not identical only if one is a function-local extern function.\n+   This assumes that function-locals don't have TREE_PERMANENT.  */\n+\n+static inline int\n+equal_functions (fn1, fn2)\n+     tree fn1;\n+     tree fn2;\n+{\n+  if (!TREE_PERMANENT (fn1) || !TREE_PERMANENT (fn2))\n+    return decls_match (fn1, fn2);\n+  return fn1 == fn2;\n+}\n+\n /* Compare two candidates for overloading as described in\n    [over.match.best].  Return values:\n \n@@ -4963,6 +4978,12 @@ joust (cand1, cand2, warn)\n \t}\n     }\n \n+  /* If the two functions are the same (this can happen with declarations\n+     in multiple scopes and arg-dependent lookup), arbitrarily choose one.  */\n+  if (DECL_P (cand1->fn) && DECL_P (cand2->fn)\n+      && equal_functions (cand1->fn, cand2->fn))\n+    return 1;\n+\n tweak:\n \n   /* Extension: If the worst conversion for one candidate is worse than the"}, {"sha": "82022fadd3ce7c7f3a446f81326b06a7187c205b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -2886,8 +2886,9 @@ extern tree lookup_name_namespace_only          PROTO((tree));\n extern void begin_only_namespace_names          PROTO((void));\n extern void end_only_namespace_names            PROTO((void));\n extern tree namespace_ancestor\t\t\tPROTO((tree, tree));\n-extern int  lookup_using_namespace              PROTO((tree,tree,tree,tree,int));\n-extern int  qualified_lookup_using_namespace    PROTO((tree,tree,tree,int));\n+extern tree unqualified_namespace_lookup\tPROTO((tree, int, tree *));\n+extern int  lookup_using_namespace              PROTO((tree, tree, tree, tree, int, tree *));\n+extern int  qualified_lookup_using_namespace    PROTO((tree, tree, tree, int));\n extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));\n extern void init_decl_processing\t\tPROTO((void));\n extern int init_type_desc\t\t\tPROTO((void));"}, {"sha": "6fb61f72eb77910233fb1eb4cf72982d7dc98c1c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -179,7 +179,6 @@ static void pop_binding PROTO((tree, tree));\n static tree local_variable_p PROTO((tree));\n static tree find_binding PROTO((tree, tree));\n static tree select_decl PROTO((tree, int));\n-static tree unqualified_namespace_lookup PROTO((tree, int));\n static int lookup_flags PROTO((int, int));\n static tree qualify_lookup PROTO((tree, int));\n static tree record_builtin_java_type PROTO((const char *, int));\n@@ -5557,13 +5556,15 @@ select_decl (binding, flags)\n   return val;\n }\n \n-/* Unscoped lookup of a global, iterate over namespaces, considering\n-   using namespace statements. */\n+/* Unscoped lookup of a global: iterate over current namespaces,\n+   considering using-directives.  If SPACESP is non-NULL, store a list\n+   of the namespaces we've considered in it.  */\n \n-static tree\n-unqualified_namespace_lookup (name, flags)\n+tree\n+unqualified_namespace_lookup (name, flags, spacesp)\n      tree name;\n      int flags;\n+     tree *spacesp;\n {\n   struct tree_binding _binding;\n   tree b = binding_init (&_binding);\n@@ -5573,8 +5574,13 @@ unqualified_namespace_lookup (name, flags)\n   struct binding_level *level;\n   tree val = NULL_TREE;\n \n-  while (!val)\n+  if (spacesp)\n+    *spacesp = NULL_TREE;\n+\n+  for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n+      if (spacesp)\n+\t*spacesp = scratch_tree_cons (scope, NULL_TREE, *spacesp);\n       val = binding_for_name (name, scope);\n \n       /* Initialize binding for this context. */\n@@ -5586,7 +5592,7 @@ unqualified_namespace_lookup (name, flags)\n \t   !level->namespace_p;\n \t   level = level->level_chain)\n \tif (!lookup_using_namespace (name, b, level->using_directives,\n-                                     scope, flags))\n+                                     scope, flags, spacesp))\n \t  /* Give up because of error. */\n \t  return error_mark_node;\n \n@@ -5596,7 +5602,7 @@ unqualified_namespace_lookup (name, flags)\n       while (1)\n \t{\n \t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter), \n-\t\t\t\t       scope, flags))\n+\t\t\t\t       scope, flags, spacesp))\n \t    /* Give up because of error. */\n \t    return error_mark_node;\n \t  if (siter == scope) break;\n@@ -5606,7 +5612,6 @@ unqualified_namespace_lookup (name, flags)\n       val = select_decl (b, flags);\n       if (scope == global_namespace)\n \tbreak;\n-      scope = CP_DECL_CONTEXT (scope);\n     }\n   return val;\n }\n@@ -5811,7 +5816,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n   /* Now lookup in namespace scopes.  */\n   if (!val || val_is_implicit_typename)\n     {\n-      t = unqualified_namespace_lookup (name, flags);\n+      t = unqualified_namespace_lookup (name, flags, 0);\n       if (t)\n \t{\n \t  if (val_is_implicit_typename && !yylex)"}, {"sha": "ab82a8ee667ddf578cad771e726585866b6df9c0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -4349,14 +4349,18 @@ ambiguous_decl (name, old, new, flags)\n   return old;\n }\n \n-/* Add the bindings of name in used namespaces to val.\n-   The using list is defined by usings, and the lookup goes to scope.\n+/* Subroutine of unualified_namespace_lookup:\n+   Add the bindings of NAME in used namespaces to VAL.\n+   We are currently looking for names in namespace SCOPE, so we\n+   look through USINGS for using-directives of namespaces\n+   which have SCOPE as a common ancestor with the current scope.\n    Returns zero on errors. */\n \n int\n-lookup_using_namespace (name, val, usings, scope, flags)\n+lookup_using_namespace (name, val, usings, scope, flags, spacesp)\n      tree name, val, usings, scope;\n      int flags;\n+     tree *spacesp;\n {\n   tree iter;\n   tree val1;\n@@ -4365,6 +4369,9 @@ lookup_using_namespace (name, val, usings, scope, flags)\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n     if (TREE_VALUE (iter) == scope)\n       {\n+\tif (spacesp)\n+\t  *spacesp = scratch_tree_cons (TREE_PURPOSE (iter), NULL_TREE,\n+\t\t\t\t\t*spacesp);\n \tval1 = binding_for_name (name, TREE_PURPOSE (iter));\n \t/* Resolve ambiguities. */\n \tval = ambiguous_decl (name, val, val1, flags);\n@@ -4573,28 +4580,32 @@ add_function (k, fn)\n      struct arg_lookup *k;\n      tree fn;\n {\n-  if (ovl_member (fn, k->functions))\n-    return 0;\n+  /* We used to check here to see if the function was already in the list,\n+     but that's O(n^2), which is just too expensive for function lookup.\n+     Now we deal with the occasional duplicate in joust.  In doing this, we\n+     assume that the number of duplicates will be small compared to the\n+     total number of functions being compared, which should usually be the\n+     case.  */\n+\n   /* We must find only functions, or exactly one non-function. */\n   if (k->functions && is_overloaded_fn (k->functions)\n       && is_overloaded_fn (fn))\n     k->functions = build_overload (fn, k->functions);\n-  else \n-    if(k->functions)\n-      {\n-\ttree f1 = OVL_CURRENT (k->functions);\n-\ttree f2 = fn;\n-\tif (is_overloaded_fn (f1))\n-\t  {\n-\t    fn = f1; f1 = f2; f2 = fn;\n-\t  }\n-\tcp_error_at (\"`%D' is not a function,\", f1);\n-\tcp_error_at (\"  conflict with `%D'\", f2);\n-\tcp_error (\"  in call to `%D'\", k->name);\n-\treturn 1;\n-      }\n-    else\n-      k->functions = fn;\n+  else if (k->functions)\n+    {\n+      tree f1 = OVL_CURRENT (k->functions);\n+      tree f2 = fn;\n+      if (is_overloaded_fn (f1))\n+\t{\n+\t  fn = f1; f1 = f2; f2 = fn;\n+\t}\n+      cp_error_at (\"`%D' is not a function,\", f1);\n+      cp_error_at (\"  conflict with `%D'\", f2);\n+      cp_error (\"  in call to `%D'\", k->name);\n+      return 1;\n+    }\n+  else\n+    k->functions = fn;\n   return 0;\n }\n \n@@ -4615,7 +4626,7 @@ arg_assoc_namespace (k, scope)\n   value = namespace_binding (k->name, scope);\n   if (!value)\n     return 0;\n-  \n+\n   for (; value; value = OVL_NEXT (value))\n     if (add_function (k, OVL_CURRENT (value)))\n       return 1;\n@@ -4845,11 +4856,18 @@ lookup_arg_dependent (name, fns, args)\n      tree args;\n {\n   struct arg_lookup k;\n+\n   k.name = name;\n   k.functions = fns;\n-  k.namespaces = NULL_TREE;\n   k.classes = NULL_TREE;\n-  \n+\n+  /* Note that we've already looked at some namespaces during normal\n+     unqualified lookup, unless we found a decl in function scope.  */\n+  if (fns && ! TREE_PERMANENT (OVL_CURRENT (fns)))\n+    k.namespaces = NULL_TREE;\n+  else\n+    unqualified_namespace_lookup (name, 0, &k.namespaces);\n+\n   push_scratch_obstack ();\n   arg_assoc_args (&k, args);\n   pop_obstacks ();"}, {"sha": "c28bba06f4ef8162cc21f538b4b842570b502193", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -3078,10 +3078,13 @@ do_identifier (token, parsing, args)\n     id = lastiddecl;\n \n   /* Do Koenig lookup if appropriate (inside templates we build lookup\n-     expressions instead).  */\n+     expressions instead).\n+\n+     [basic.lookup.koenig]: If the ordinary unqualified lookup of the name\n+     finds the declaration of a class member function, the associated\n+     namespaces and classes are not considered.  */\n+\n   if (args && !current_template_parms && (!id || is_global (id)))\n-    /* If we have arguments and we only found global names, do Koenig\n-       lookup. */\n     id = lookup_arg_dependent (token, id, args);\n \n   /* Remember that this name has been used in the class definition, as per"}, {"sha": "f2e8257b30b622be224fb32455c2ea03452d17e4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c169babb627a91c6dd3900707cdc53f170a9b70/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2c169babb627a91c6dd3900707cdc53f170a9b70", "patch": "@@ -37,7 +37,6 @@ static tree list_hash_lookup PROTO((int, tree, tree, tree));\n static void propagate_binfo_offsets PROTO((tree, tree));\n static int avoid_overlap PROTO((tree, tree));\n static cp_lvalue_kind lvalue_p_1 PROTO((tree, int));\n-static int equal_functions PROTO((tree, tree));\n static tree no_linkage_helper PROTO((tree));\n static tree build_srcloc PROTO((char *, int));\n \n@@ -1411,20 +1410,6 @@ build_overload (decl, chain)\n   return ovl_cons (decl, chain);\n }\n \n-/* Returns true iff functions are equivalent. Equivalent functions are\n-   not identical only if one is a function-local extern function.\n-   This assumes that function-locals don't have TREE_PERMANENT.  */\n-\n-static int\n-equal_functions (fn1, fn2)\n-     tree fn1;\n-     tree fn2;\n-{\n-  if (!TREE_PERMANENT (fn1) || !TREE_PERMANENT (fn2))\n-    return decls_match (fn1, fn2);\n-  return fn1 == fn2;\n-}\n-\n /* True if fn is in ovl. */\n \n int\n@@ -1435,9 +1420,9 @@ ovl_member (fn, ovl)\n   if (ovl == NULL_TREE)\n     return 0;\n   if (TREE_CODE (ovl) != OVERLOAD)\n-    return equal_functions (ovl, fn);\n+    return ovl == fn;\n   for (; ovl; ovl = OVL_CHAIN (ovl))\n-    if (equal_functions (OVL_FUNCTION (ovl), fn))\n+    if (OVL_FUNCTION (ovl) == fn)\n       return 1;\n   return 0;\n }"}]}