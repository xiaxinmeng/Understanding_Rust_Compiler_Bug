{"sha": "30d2e94365655dae5bccb24797f97f5260da3154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkMmU5NDM2NTY1NWRhZTViY2NiMjQ3OTdmOTdmNTI2MGRhMzE1NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenth@gcc.gnu.org", "date": "2005-05-27T17:23:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-05-27T17:23:30Z"}, "message": "[multiple changes]\n\n2005-05-18  Richard Guenther  <rguenth@gcc.gnu.org>\n\n        * tree-inline.c (copy_body_r): Manually fold *& to deal\n        with ADDR_EXPRs with mismatched types for now.\n\n2005-05-17  Richard Guenther  <rguenth@gcc.gnu.org>\n\n        * gimplify.c (fold_indirect_ref_rhs): New function.\n        (gimplify_modify_expr_rhs): Use it instead of pessimistic\n        fold_indirect_ref.\n\n2005-05-15  Richard Guenther  <rguenth@gcc.gnu.org>\n\n        * fold-const.c (fold_indirect_ref_1): Add type argument;\n        make sure the resulting expression is of this type.\n        (build_fold_indirect_ref, fold_indirect_ref): Adjust callers.\n\nFrom-SVN: r100267", "tree": {"sha": "62ea9650b917f6874d18e3dfbb1662d57f77d04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62ea9650b917f6874d18e3dfbb1662d57f77d04b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30d2e94365655dae5bccb24797f97f5260da3154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d2e94365655dae5bccb24797f97f5260da3154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d2e94365655dae5bccb24797f97f5260da3154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d2e94365655dae5bccb24797f97f5260da3154/comments", "author": null, "committer": null, "parents": [{"sha": "46aad78f22f0d84855daed56e7369e73e31c8c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46aad78f22f0d84855daed56e7369e73e31c8c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46aad78f22f0d84855daed56e7369e73e31c8c26"}], "stats": {"total": 108, "additions": 94, "deletions": 14}, "files": [{"sha": "c1dafb0ddc5790a3256ea4dbf5e4ad6b91c776fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30d2e94365655dae5bccb24797f97f5260da3154", "patch": "@@ -1,3 +1,16 @@\n+2005-05-27  Richard Guenther  <rguenth@gcc.gnu.org>\n+\n+\t* tree-inline.c (copy_body_r): Manually fold *& to deal\n+\twith ADDR_EXPRs with mismatched types for now.\n+\n+\t* gimplify.c (fold_indirect_ref_rhs): New function.\n+\t(gimplify_modify_expr_rhs): Use it instead of pessimistic\n+\tfold_indirect_ref.\n+\n+\t* fold-const.c (fold_indirect_ref_1): Add type argument;\n+\tmake sure the resulting expression is of this type.\n+\t(build_fold_indirect_ref, fold_indirect_ref): Adjust callers.\n+\n 2005-05-27  Kazu Hirata  <kazu@cs.umass.edu>\n \n \tPR tree-optimization/21658"}, {"sha": "98803271f56185d894d456e087949757bd07f12c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=30d2e94365655dae5bccb24797f97f5260da3154", "patch": "@@ -11451,14 +11451,14 @@ build_fold_addr_expr (tree t)\n   return build_fold_addr_expr_with_type (t, build_pointer_type (TREE_TYPE (t)));\n }\n \n-/* Given a pointer value T, return a simplified version of an indirection\n-   through T, or NULL_TREE if no simplification is possible.  */\n+/* Given a pointer value OP0 and a type TYPE, return a simplified version\n+   of an indirection through OP0, or NULL_TREE if no simplification is\n+   possible.  */\n \n static tree\n-fold_indirect_ref_1 (tree t)\n+fold_indirect_ref_1 (tree type, tree op0)\n {\n-  tree type = TREE_TYPE (TREE_TYPE (t));\n-  tree sub = t;\n+  tree sub = op0;\n   tree subtype;\n \n   STRIP_NOPS (sub);\n@@ -11471,11 +11471,11 @@ fold_indirect_ref_1 (tree t)\n       tree op = TREE_OPERAND (sub, 0);\n       tree optype = TREE_TYPE (op);\n       /* *&p => p */\n-      if (lang_hooks.types_compatible_p (type, optype))\n+      if (type == optype)\n \treturn op;\n       /* *(foo *)&fooarray => fooarray[0] */\n       else if (TREE_CODE (optype) == ARRAY_TYPE\n-\t       && lang_hooks.types_compatible_p (type, TREE_TYPE (optype)))\n+\t       && type == TREE_TYPE (optype))\n \t{\n \t  tree type_domain = TYPE_DOMAIN (optype);\n \t  tree min_val = size_zero_node;\n@@ -11487,7 +11487,7 @@ fold_indirect_ref_1 (tree t)\n \n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n   if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n-      && lang_hooks.types_compatible_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n+      && type == TREE_TYPE (TREE_TYPE (subtype)))\n     {\n       tree type_domain;\n       tree min_val = size_zero_node;\n@@ -11507,20 +11507,21 @@ fold_indirect_ref_1 (tree t)\n tree\n build_fold_indirect_ref (tree t)\n {\n-  tree sub = fold_indirect_ref_1 (t);\n+  tree type = TREE_TYPE (TREE_TYPE (t));\n+  tree sub = fold_indirect_ref_1 (type, t);\n \n   if (sub)\n     return sub;\n   else\n-    return build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (t)), t);\n+    return build1 (INDIRECT_REF, type, t);\n }\n \n /* Given an INDIRECT_REF T, return either T or a simplified version.  */\n \n tree\n fold_indirect_ref (tree t)\n {\n-  tree sub = fold_indirect_ref_1 (TREE_OPERAND (t, 0));\n+  tree sub = fold_indirect_ref_1 (TREE_TYPE (t), TREE_OPERAND (t, 0));\n \n   if (sub)\n     return sub;"}, {"sha": "657d5311e5b9efb17d94e7935df8720c0727490f", "filename": "gcc/gimplify.c", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=30d2e94365655dae5bccb24797f97f5260da3154", "patch": "@@ -2846,6 +2846,62 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n     return GS_ALL_DONE;\n }\n \n+/* Given a pointer value OP0, return a simplified version of an\n+   indirection through OP0, or NULL_TREE if no simplification is\n+   possible.  This may only be applied to a rhs of an expression.\n+   Note that the resulting type may be different from the type pointed\n+   to in the sense that it is still compatible from the langhooks\n+   point of view. */\n+\n+static tree\n+fold_indirect_ref_rhs (tree t)\n+{\n+  tree type = TREE_TYPE (TREE_TYPE (t));\n+  tree sub = t;\n+  tree subtype;\n+\n+  STRIP_NOPS (sub);\n+  subtype = TREE_TYPE (sub);\n+  if (!POINTER_TYPE_P (subtype))\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (sub) == ADDR_EXPR)\n+    {\n+      tree op = TREE_OPERAND (sub, 0);\n+      tree optype = TREE_TYPE (op);\n+      /* *&p => p */\n+      if (lang_hooks.types_compatible_p (type, optype))\n+        return op;\n+      /* *(foo *)&fooarray => fooarray[0] */\n+      else if (TREE_CODE (optype) == ARRAY_TYPE\n+\t       && lang_hooks.types_compatible_p (type, TREE_TYPE (optype)))\n+       {\n+         tree type_domain = TYPE_DOMAIN (optype);\n+         tree min_val = size_zero_node;\n+         if (type_domain && TYPE_MIN_VALUE (type_domain))\n+           min_val = TYPE_MIN_VALUE (type_domain);\n+         return build4 (ARRAY_REF, type, op, min_val, NULL_TREE, NULL_TREE);\n+       }\n+    }\n+\n+  /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n+  if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n+      && lang_hooks.types_compatible_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n+    {\n+      tree type_domain;\n+      tree min_val = size_zero_node;\n+      sub = fold_indirect_ref_rhs (sub);\n+      if (! sub)\n+\tsub = build1 (INDIRECT_REF, TREE_TYPE (subtype), sub);\n+      type_domain = TYPE_DOMAIN (TREE_TYPE (sub));\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+        min_val = TYPE_MIN_VALUE (type_domain);\n+      return build4 (ARRAY_REF, type, sub, min_val, NULL_TREE, NULL_TREE);\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Subroutine of gimplify_modify_expr to do simplifications of MODIFY_EXPRs\n    based on the code of the RHS.  We loop for as long as something changes.  */\n \n@@ -2869,8 +2925,8 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t     This kind of code arises in C++ when an object is bound\n \t     to a const reference, and if \"x\" is a TARGET_EXPR we want\n \t     to take advantage of the optimization below.  */\n-\t  tree t = fold_indirect_ref (*from_p);\n-\t  if (t != *from_p)\n+\t  tree t = fold_indirect_ref_rhs (TREE_OPERAND (*from_p, 0));\n+\t  if (t)\n \t    {\n \t      *from_p = t;\n \t      ret = GS_OK;"}, {"sha": "c04fe3343fbfc3de3eaedb5b9401d9ed02e65e57", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d2e94365655dae5bccb24797f97f5260da3154/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=30d2e94365655dae5bccb24797f97f5260da3154", "patch": "@@ -613,7 +613,17 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n \t  if (n)\n \t    {\n-\t      *tp = build_fold_indirect_ref ((tree)n->value);\n+\t      /* If we happen to get an ADDR_EXPR in n->value, strip\n+\t         it manually here as we'll eventually get ADDR_EXPRs\n+\t\t which lie about their types pointed to.  In this case\n+\t\t build_fold_indirect_ref wouldn't strip the INDIRECT_REF,\n+\t\t but we absolutely rely on that.  */\n+\t      if (TREE_CODE ((tree)n->value) == ADDR_EXPR)\n+\t\t*tp = TREE_OPERAND ((tree)n->value, 0);\n+\t      else\n+\t        *tp = build1 (INDIRECT_REF,\n+\t\t\t      TREE_TYPE (TREE_TYPE ((tree)n->value)),\n+\t\t\t      (tree)n->value);\n \t      *walk_subtrees = 0;\n \t      return NULL;\n \t    }"}]}