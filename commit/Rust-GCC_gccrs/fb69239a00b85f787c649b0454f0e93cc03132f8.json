{"sha": "fb69239a00b85f787c649b0454f0e93cc03132f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI2OTIzOWEwMGI4NWY3ODdjNjQ5YjA0NTRmMGU5M2NjMDMxMzJmOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-12T09:52:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-12T09:52:00Z"}, "message": "[multiple changes]\n\n2017-09-12  Bob Duff  <duff@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): Initialize Def_Id to\n\tEmpty.\n\n2017-09-12  Georges-Axel Jaloyan  <jaloyan@adacore.com>\n\n\t* debug.adb: Reserving flag -gnatdF for safe pointer checking.\n\t* gnat1drv.adb (gnat1drv): Adding the call to the analysis on\n\tdF flag.\n\t* sem_spark.adb, sem_spark.ads: Implementation of the analysis,\n\tin preparation for the evolution of the SPARK language that\n\tincludes a pointer analysis for checking non-aliasing of access\n\ttypes. The Check_Safe_Pointers function is the entry point, and\n\twill traverse the AST and raise compile-time errors everytime\n\tit detects non-begign aliasing.  Detailed comments are present\n\tin the sem_spark.ads file.\n\t* sem_util.adb, sem_util.ads (First_Global, Next_Global): New\n\tfunctions to iterate over the list of globals of a subprogram.\n\t* libgnat/system.ads: Add restriction No_Finalization.\n\t* gcc-interface/Make-lang.in: Add new file sem_spark.adb and\n\tdependency on g-dynhta.adb.\n\nFrom-SVN: r252000", "tree": {"sha": "b1763ab58debeb29cae0326e3c99664162305894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1763ab58debeb29cae0326e3c99664162305894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb69239a00b85f787c649b0454f0e93cc03132f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb69239a00b85f787c649b0454f0e93cc03132f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb69239a00b85f787c649b0454f0e93cc03132f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb69239a00b85f787c649b0454f0e93cc03132f8/comments", "author": null, "committer": null, "parents": [{"sha": "7f9fcce8343219550bb754890c178f34ccdddce7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f9fcce8343219550bb754890c178f34ccdddce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f9fcce8343219550bb754890c178f34ccdddce7"}], "stats": {"total": 6547, "additions": 6541, "deletions": 6}, "files": [{"sha": "988f2ef55dcdbb5311b35400d9b15d27f23c5f21", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -1,3 +1,26 @@\n+2017-09-12  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): Initialize Def_Id to\n+\tEmpty.\n+\n+2017-09-12  Georges-Axel Jaloyan  <jaloyan@adacore.com>\n+\n+\t* debug.adb: Reserving flag -gnatdF for safe pointer checking.\n+\t* gnat1drv.adb (gnat1drv): Adding the call to the analysis on\n+\tdF flag.\n+\t* sem_spark.adb, sem_spark.ads: Implementation of the analysis,\n+\tin preparation for the evolution of the SPARK language that\n+\tincludes a pointer analysis for checking non-aliasing of access\n+\ttypes. The Check_Safe_Pointers function is the entry point, and\n+\twill traverse the AST and raise compile-time errors everytime\n+\tit detects non-begign aliasing.  Detailed comments are present\n+\tin the sem_spark.ads file.\n+\t* sem_util.adb, sem_util.ads (First_Global, Next_Global): New\n+\tfunctions to iterate over the list of globals of a subprogram.\n+\t* libgnat/system.ads: Add restriction No_Finalization.\n+\t* gcc-interface/Make-lang.in: Add new file sem_spark.adb and\n+\tdependency on g-dynhta.adb.\n+\n 2017-09-12  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch6.adb (Analyze_Expression_Function): Call"}, {"sha": "77afd4b8c9881338ba63ab6e8e5d02a49a8d6a91", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -69,7 +69,7 @@ package body Debug is\n    --  dC   Output debugging information on check suppression\n    --  dD   Delete elaboration checks in inner level routines\n    --  dE   Apply elaboration checks to predefined units\n-   --  dF\n+   --  dF   Perform the new SPARK checking rules for pointer aliasing\n    --  dG   Generate all warnings including those normally suppressed\n    --  dH   Hold (kill) call to gigi\n    --  dI   Inhibit internal name numbering in gnatG listing\n@@ -383,6 +383,11 @@ package body Debug is\n    --  dE   Apply compile time elaboration checking for with relations between\n    --       predefined units. Normally no checks are made.\n \n+   --  dF   Perform the new SPARK checking rules for pointer aliasing. This is\n+   --       only activated in GNATprove mode and on SPARK code. These rules are\n+   --       not yet part of the official SPARK language, but are expected to be\n+   --       included in a future version of SPARK.\n+\n    --  dG   Generate all warnings. Normally Errout suppresses warnings on\n    --       units that are not part of the main extended source, and also\n    --       suppresses warnings on instantiations in the main extended"}, {"sha": "bbced4943aaa6bef978a0fe65fe889cd336b34f1", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -312,6 +312,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/freeze.o\t\\\n  ada/frontend.o\t\\\n  ada/libgnat/g-byorma.o\t\\\n+ ada/libgnat/g-dynhta.o\t\\\n  ada/libgnat/g-hesora.o\t\\\n  ada/libgnat/g-htable.o\t\\\n  ada/libgnat/g-spchge.o\t\\\n@@ -443,6 +444,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/sem_res.o\t\\\n  ada/sem_scil.o\t\\\n  ada/sem_smem.o\t\\\n+ ada/sem_spark.o\t\\\n  ada/sem_type.o\t\\\n  ada/sem_util.o\t\\\n  ada/sem_warn.o\t\\"}, {"sha": "197c6053d78166999a1f723eddee1d1a1905964a", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -61,6 +61,7 @@ with Sem_Ch12;\n with Sem_Ch13;\n with Sem_Elim;\n with Sem_Eval;\n+with Sem_SPARK; use Sem_SPARK;\n with Sem_Type;\n with Set_Targ;\n with Sinfo;    use Sinfo;\n@@ -1449,12 +1450,19 @@ begin\n \n       Prepcomp.Add_Dependencies;\n \n-      --  In gnatprove mode we're writing the ALI much earlier than usual\n-      --  as flow analysis needs the file present in order to append its\n-      --  own globals to it.\n-\n       if GNATprove_Mode then\n \n+         --  Perform the new SPARK checking rules for pointer aliasing. This is\n+         --  only activated in GNATprove mode and on SPARK code.\n+\n+         if Debug_Flag_FF then\n+            Check_Safe_Pointers (Main_Unit_Node);\n+         end if;\n+\n+         --  In GNATprove mode we're writing the ALI much earlier than usual\n+         --  as flow analysis needs the file present in order to append its\n+         --  own globals to it.\n+\n          --  Note: In GNATprove mode, an \"object\" file is always generated as\n          --  the result of calling gnat1 or gnat2why, although this is not the\n          --  same as the object file produced for compilation."}, {"sha": "c1a4a579ab7152efb94181a87ac5f33a982244ef", "filename": "gcc/ada/libgnat/system.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Flibgnat%2Fsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Flibgnat%2Fsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem.ads?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -44,6 +44,12 @@ pragma Restrictions (No_Implicit_Dynamic_Code);\n --  which prevent execution of code on the stack, e.g. in windows environments\n --  with DEP (Data Execution Protection) enabled.\n \n+pragma Restrictions (No_Finalization);\n+--  Use restriction No_Finalization to avoid pulling finalization (not allowed\n+--  in GNAT) inside sem_spark.adb, when defining type Perm_Tree_Access as an\n+--  access type on incomplete type Perm_Tree_Wrapper (which is required for\n+--  defining a recursive type).\n+\n package System is\n    pragma Pure;\n    --  Note that we take advantage of the implementation permission to make"}, {"sha": "ffcc357bfedc7697d2e18aec22ac2062f4969068", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -466,7 +466,7 @@ package body Sem_Ch6 is\n       Orig_N   : Node_Id;\n       Ret      : Node_Id;\n \n-      Def_Id   : Entity_Id;\n+      Def_Id   : Entity_Id := Empty;\n       Prev     : Entity_Id;\n       --  If the expression is a completion, Prev is the entity whose\n       --  declaration is completed. Def_Id is needed to analyze the spec."}, {"sha": "8c81d2e760fe6e14d7ddd3b95ba9f9279a935ff5", "filename": "gcc/ada/sem_spark.adb", "status": "added", "additions": 6188, "deletions": 0, "changes": 6188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=fb69239a00b85f787c649b0454f0e93cc03132f8"}, {"sha": "d7abd8ad74a31eb2daadb336b852f30f8cb4d7d2", "filename": "gcc/ada/sem_spark.ads", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_spark.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_spark.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.ads?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -0,0 +1,143 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            S E M _ S P A R K                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--              Copyright (C) 2017, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package implements an anti-aliasing analysis for access types. The\n+--  rules that are enforced are defined in the anti-aliasing section of the\n+--  SPARK RM 6.4.2\n+--\n+--  Analyze_SPARK is called by Gnat1drv, when GNATprove mode is activated. It\n+--  does an analysis of the source code, looking for code that is considered\n+--  as SPARK and launches another function called Analyze_Node that will do\n+--  the whole analysis.\n+--\n+--  A path is an abstraction of a name, of which all indices, slices (for\n+--  indexed components) and function calls have been abstracted and all\n+--  dereferences are made explicit. A path is the atomic element viewed by the\n+--  analysis, with the notion of prefixes and extensions of different paths.\n+--\n+--  The analysis explores the AST, and looks for different constructs\n+--  that may involve aliasing. These main constructs are assignments\n+--  (N_Assignment_Statement, N_Object_Declaration, ...), or calls\n+--  (N_Procedure_Call_Statement, N_Entry_Call_Statement, N_Function_Call).\n+--  The analysis checks the permissions of each construct and updates them\n+--  according to the SPARK RM. This can follow three main different types\n+--  of operations: move, borrow, and observe.\n+\n+----------------------------\n+-- Deep and shallow types --\n+----------------------------\n+\n+--  The analysis focuses on objects that can cause problems in terms of pointer\n+--  aliasing. These objects have types that are called deep. Deep types are\n+--  defined as being either types with an access part or class-wide types\n+--  (which may have an access part in a derived type). Non-deep types are\n+--  called shallow. Some objects of shallow type may cause pointer aliasing\n+--  problems when they are explicitely marked as aliased (and then the aliasing\n+--  occurs when we take the Access to this object and store it in a pointer).\n+\n+----------\n+-- Move --\n+----------\n+\n+--  Moves can happen at several points in the program: during assignment (and\n+--  any similar statement such as object declaration with initial value), or\n+--  during return statements.\n+--\n+--  The underlying concept consists of transferring the ownership of any path\n+--  on the right-hand side to the left-hand side. There are some details that\n+--  should be taken into account so as not to transfer paths that appear only\n+--  as intermediate results of a more complex expression.\n+\n+--  More specifically, the SPARK RM defines moved expressions, and any moved\n+--  expression that points directly to a path is then checked and sees its\n+--  permissions updated accordingly.\n+\n+------------\n+-- Borrow --\n+------------\n+\n+--  Borrows can happen in subprogram calls. They consist of a temporary\n+--  transfer of ownership from a caller to a callee. Expressions that can be\n+--  borrowed can be found in either procedure or entry actual parameters, and\n+--  consist of parameters of mode either \"out\" or \"in out\", or parameters of\n+--  mode \"in\" that are of type nonconstant access-to-variable. We consider\n+--  global variables as implicit parameters to subprograms, with their mode\n+--  given by the Global contract associated to the subprogram. Note that the\n+--  analysis looks for such a Global contract mentioning any global variable\n+--  of deep type accessed directly in the subprogram, and it raises an error if\n+--  there is no Global contract, or if the Global contract does not mention the\n+--  variable.\n+--\n+--  A borrow of a parameter X is equivalent in terms of aliasing to moving\n+--  X'Access to the callee, and then assigning back X at the end of the call.\n+--\n+--  Borrowed parameters should have read-write permission (or write-only for\n+--  \"out\" parameters), and should all have read-write permission at the end\n+--  of the call (this guarantee is ensured by the callee).\n+\n+-------------\n+-- Observe --\n+-------------\n+\n+--  Observed parameters are all the other parameters that are not borrowed and\n+--  that may cause problems with aliasing. They are considered as being sent to\n+--  the callee with Read-Only permission, so that they can be aliased safely.\n+--  This is the only construct that allows aliasing that does not prevent\n+--  accessing the old path that is being aliased. However, this comes with\n+--  the restriction that those aliased path cannot be written in the callee.\n+\n+--------------------\n+-- Implementation --\n+--------------------\n+\n+--  The implementation is based on trees that represent the possible paths\n+--  in the source code. Those trees can be unbounded in depth, hence they are\n+--  represented using lazy data structures, whose laziness is handled manually.\n+--  Each time an identifier is declared, its path is added to the permission\n+--  environment as a tree with only one node, the declared identifier. Each\n+--  time a path is checked or updated, we look in the tree at the adequate\n+--  node, unfolding the tree whenever needed.\n+\n+--  For this, each node has several variables that indicate whether it is\n+--  deep (Is_Node_Deep), what permission it has (Permission), and what is\n+--  the lowest permission of all its descendants (Children_Permission). After\n+--  unfolding the tree, we update the permissions of each node, deleting the\n+--  Children_Permission, and specifying new ones for the leaves of the unfolded\n+--  tree.\n+\n+--  After assigning a path, the descendants of the assigned path are dumped\n+--  (and hence the tree is folded back), given that all descendants directly\n+--  get read-write permission, which can be specified using the node's\n+--  Children_Permission field.\n+\n+with Types; use Types;\n+\n+package Sem_SPARK is\n+\n+   procedure Check_Safe_Pointers (N : Node_Id);\n+   --  The entry point of this package. It analyzes a node and reports errors\n+   --  when there are violations of aliasing rules.\n+\n+end Sem_SPARK;"}, {"sha": "6dc3591b9734f47fd4549c87a08e1c74d8631e52", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -8093,6 +8093,124 @@ package body Sem_Util is\n       end if;\n    end First_Actual;\n \n+   ------------------\n+   -- First_Global --\n+   ------------------\n+\n+   function First_Global\n+     (Subp        : Entity_Id;\n+      Global_Mode : Name_Id;\n+      Refined     : Boolean := False) return Node_Id\n+   is\n+      function First_From_Global_List\n+        (List        : Node_Id;\n+         Global_Mode : Name_Id := Name_Input) return Entity_Id;\n+      --  Get the first item with suitable mode from List\n+\n+      ----------------------------\n+      -- First_From_Global_List --\n+      ----------------------------\n+\n+      function First_From_Global_List\n+        (List        : Node_Id;\n+         Global_Mode : Name_Id := Name_Input) return Entity_Id\n+      is\n+         Assoc : Node_Id;\n+\n+      begin\n+         --  Empty list (no global items)\n+\n+         if Nkind (List) = N_Null then\n+            return Empty;\n+\n+         --  Single global item declaration (only input items)\n+\n+         elsif Nkind_In (List, N_Expanded_Name,\n+                               N_Identifier,\n+                               N_Selected_Component)\n+         then\n+            if Global_Mode = Name_Input then\n+               return List;\n+            else\n+               return Empty;\n+            end if;\n+\n+         --  Simple global list (only input items) or moded global list\n+         --  declaration.\n+\n+         elsif Nkind (List) = N_Aggregate then\n+            if Present (Expressions (List)) then\n+               if Global_Mode = Name_Input then\n+                  return First (Expressions (List));\n+               else\n+                  return Empty;\n+               end if;\n+\n+            else\n+               Assoc := First (Component_Associations (List));\n+               while Present (Assoc) loop\n+\n+                  --  When we find the desired mode in an association, call\n+                  --  recursively First_From_Global_List as if the mode was\n+                  --  Name_Input, in order to reuse the existing machinery\n+                  --  for the other cases.\n+\n+                  if Chars (First (Choices (Assoc))) = Global_Mode then\n+                     return First_From_Global_List (Expression (Assoc));\n+                  end if;\n+\n+                  Next (Assoc);\n+               end loop;\n+\n+               return Empty;\n+            end if;\n+\n+            --  To accommodate partial decoration of disabled SPARK features,\n+            --  this routine may be called with illegal input. If this is the\n+            --  case, do not raise Program_Error.\n+\n+         else\n+            return Empty;\n+         end if;\n+      end First_From_Global_List;\n+\n+      --  Local variables\n+\n+      Global  : Node_Id := Empty;\n+      Body_Id : Entity_Id;\n+\n+   begin\n+      pragma Assert (Global_Mode = Name_Input\n+                      or else Global_Mode = Name_Output\n+                      or else Global_Mode = Name_In_Out\n+                      or else Global_Mode = Name_Proof_In);\n+\n+      --  Retrieve the suitable pragma Global or Refined_Global. In the second\n+      --  case, it can only be located on the body entity.\n+\n+      if Refined then\n+         Body_Id := Subprogram_Body_Entity (Subp);\n+         if Present (Body_Id) then\n+            Global := Get_Pragma (Body_Id, Pragma_Refined_Global);\n+         end if;\n+      else\n+         Global := Get_Pragma (Subp, Pragma_Global);\n+      end if;\n+\n+      --  No corresponding global if pragma is not present\n+\n+      if No (Global) then\n+         return Empty;\n+\n+      --  Otherwise retrieve the corresponding list of items depending on the\n+      --  Global_Mode.\n+\n+      else\n+         return First_From_Global_List\n+           (Expression (Get_Argument (Global, Subp)), Global_Mode);\n+      end if;\n+   end First_Global;\n+\n    -------------\n    -- Fix_Msg --\n    -------------\n@@ -18980,6 +19098,27 @@ package body Sem_Util is\n       Actual_Id := Next_Actual (Actual_Id);\n    end Next_Actual;\n \n+   -----------------\n+   -- Next_Global --\n+   -----------------\n+\n+   function Next_Global (Node : Node_Id) return Node_Id is\n+   begin\n+      --  The global item may either be in a list, or by itself, in which case\n+      --  there is no next global item with the same mode.\n+\n+      if Is_List_Member (Node) then\n+         return Next (Node);\n+      else\n+         return Empty;\n+      end if;\n+   end Next_Global;\n+\n+   procedure Next_Global (Node : in out Node_Id) is\n+   begin\n+      Node := Next_Global (Node);\n+   end Next_Global;\n+\n    ----------------------------------\n    -- New_Requires_Transient_Scope --\n    ----------------------------------"}, {"sha": "5049ad6a7f8e6febf13405ce03e33559685d56b1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb69239a00b85f787c649b0454f0e93cc03132f8/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=fb69239a00b85f787c649b0454f0e93cc03132f8", "patch": "@@ -885,6 +885,17 @@ package Sem_Util is\n    --  Note that the value returned is always the expression (not the\n    --  N_Parameter_Association nodes, even if named association is used).\n \n+   function First_Global\n+     (Subp        : Entity_Id;\n+      Global_Mode : Name_Id;\n+      Refined     : Boolean := False) return Node_Id;\n+   --  Returns the first global item of mode Global_Mode (which can be\n+   --  Name_Input, Name_Output, Name_In_Out or Name_Proof_In) associated to\n+   --  subprogram Subp, or Empty otherwise. If Refined is True, the global item\n+   --  is retrieved from the Refined_Global aspect/pragma associated to the\n+   --  body of Subp if present. Next_Global can be used to get the next global\n+   --  item with the same mode.\n+\n    function Fix_Msg (Id : Entity_Id; Msg : String) return String;\n    --  Replace all occurrences of a particular word in string Msg depending on\n    --  the Ekind of Id as follows:\n@@ -2177,6 +2188,16 @@ package Sem_Util is\n    --  Note that the result produced is always an expression, not a parameter\n    --  association node, even if named notation was used.\n \n+   procedure Next_Global (Node : in out Node_Id);\n+   pragma Inline (Next_Actual);\n+   --  Next_Global (N) is equivalent to N := Next_Global (N). Note that we\n+   --  inline this procedural form, but not the functional form that follows.\n+\n+   function Next_Global (Node : Node_Id) return Node_Id;\n+   --  Node is a global item from a list, obtained through calling First_Global\n+   --  and possibly Next_Global a number of times. Returns the next global item\n+   --  with the same mode.\n+\n    function No_Heap_Finalization (Typ : Entity_Id) return Boolean;\n    --  Determine whether type Typ is subject to pragma No_Heap_Finalization\n "}]}