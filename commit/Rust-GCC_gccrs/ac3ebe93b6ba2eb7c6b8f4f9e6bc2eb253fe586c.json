{"sha": "ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMzZWJlOTNiNmJhMmViN2M2YjhmNGY5ZTZiYzJlYjI1M2ZlNTg2Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-12-08T13:46:18Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-12-08T13:46:18Z"}, "message": "ms1.md (UNSPEC_LOOP): New constant.\n\n\t* config/ms1/ms1.md (UNSPEC_LOOP): New constant.\n\t(loop_end, loop_init, doloop_end): New insns.\n\t* config/ms1/ms1.h (LOOP_FIRST, LOOP_LAST): New.\n\t(SPECIAL_REG_FIRST, FIRST_PSEUDO_REGISTER): Adjust.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Adjust.\n\t(REG_CLASS_CONTENTS, REGISTER_NAMES): Adjust.\n\t* config/ms1/ms1.c: #include basic-block.h\n\t(struct machine_function): Add has_loops field.\n\t(ms1_add_loop): New.\n\t(MAX_LOOP_DEPTH, MAX_LOO_LENGTH): New.\n\t(struct loop_info, struct loop_work): New.\n\t(ms1_loop_nesting, ms1_block_length, ms1_scan_loop): New workers.\n\t(ms1_reorg_loops): New loop optimization.\n\t(ms1_machine_reorg): Call it.\n\t* config/ms1/ms1-protos.h (ms1_add_loop): Declare.\n\nFrom-SVN: r108229", "tree": {"sha": "40fcec927a856ddf45a9211bf8091c6c96d814ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40fcec927a856ddf45a9211bf8091c6c96d814ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/comments", "author": null, "committer": null, "parents": [{"sha": "bc9053abce09400d12ced72db73bff5dbbd05007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9053abce09400d12ced72db73bff5dbbd05007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9053abce09400d12ced72db73bff5dbbd05007"}], "stats": {"total": 610, "additions": 597, "deletions": 13}, "files": [{"sha": "90e9b84a61559f9a18f55389d55c4c8150afb478", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "patch": "@@ -1,3 +1,21 @@\n+2005-12-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/ms1/ms1.md (UNSPEC_LOOP): New constant.\n+\t(loop_end, loop_init, doloop_end): New insns.\n+\t* config/ms1/ms1.h (LOOP_FIRST, LOOP_LAST): New.\n+\t(SPECIAL_REG_FIRST, FIRST_PSEUDO_REGISTER): Adjust.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Adjust.\n+\t(REG_CLASS_CONTENTS, REGISTER_NAMES): Adjust.\n+\t* config/ms1/ms1.c: #include basic-block.h\n+\t(struct machine_function): Add has_loops field.\n+\t(ms1_add_loop): New.\n+\t(MAX_LOOP_DEPTH, MAX_LOO_LENGTH): New.\n+\t(struct loop_info, struct loop_work): New.\n+\t(ms1_loop_nesting, ms1_block_length, ms1_scan_loop): New workers.\n+\t(ms1_reorg_loops): New loop optimization.\n+\t(ms1_machine_reorg): Call it.\n+\t* config/ms1/ms1-protos.h (ms1_add_loop): Declare.\n+\n 2005-12-08  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/25248"}, {"sha": "c37048263ca99e0c93fd7ae3d47102964084ad8e", "filename": "gcc/config/ms1/ms1-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1-protos.h?ref=ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "patch": "@@ -26,6 +26,7 @@ extern void\t    ms1_override_options (void);\n extern int\t    ms1_initial_elimination_offset (int, int);\n extern const char * ms1_asm_output_opcode (FILE *, const char *);\n extern int          ms1_epilogue_uses\t (int);\n+extern void\t    ms1_add_loop \t (void);\n \n #ifdef TREE_CODE\n extern const char * ms1_cannot_inline_p\t (tree);"}, {"sha": "3695f0fb8b483b1f27a0b3e9b6cee3e4c51f9512", "filename": "gcc/config/ms1/ms1.c", "status": "modified", "additions": 510, "deletions": 1, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.c?ref=ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "patch": "@@ -47,6 +47,7 @@\n #include \"except.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"basic-block.h\"\n \n /* Frame pointer register mask.  */\n #define FP_MASK\t\t \t (1 << (GPR_FP))\n@@ -68,6 +69,7 @@ struct machine_function GTY(())\n   int ra_needs_full_frame;\n   struct rtx_def * eh_stack_adjust;\n   int interrupt_handler;\n+  int has_loops;\n };\n \n /* Define the information needed to generate branch and scc insns.\n@@ -811,7 +813,7 @@ ms1_override_options (void)\n \terror (\"bad value (%s) for -march= switch\", ms1_cpu_string);\n     }\n   else\n-    ms1_cpu = PROCESSOR_MS1_64_001;\n+    ms1_cpu = PROCESSOR_MS2;\n \n   if (flag_exceptions)\n     {\n@@ -1648,6 +1650,510 @@ ms1_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n \t       || TREE_ADDRESSABLE (type))));\n }\n \f\n+/* Increment the counter for the number of loop instructions in the\n+   current function.  */\n+\n+void ms1_add_loop (void)\n+{\n+  cfun->machine->has_loops++;\n+}\n+\n+\n+/* Maxium loop nesting depth.  */\n+#define MAX_LOOP_DEPTH 4\n+/* Maxium size of a loop (allows some headroom for delayed branch slot\n+   filling.  */\n+#define MAX_LOOP_LENGTH (200 * 4)\n+\n+/* We need to keep a vector of basic blocks */\n+DEF_VEC_P (basic_block);\n+DEF_VEC_ALLOC_P (basic_block,heap);\n+\n+/* And a vector of loops */\n+typedef struct loop_info *loop_info;\n+DEF_VEC_P (loop_info);\n+DEF_VEC_ALLOC_P (loop_info,heap);\n+\n+/* Information about a loop we have found (or are in the process of\n+   finding).  */\n+struct loop_info GTY (())\n+{\n+  /* loop number, for dumps */\n+  int loop_no;\n+  \n+  /* Predecessor block of the loop.   This is the one that falls into\n+     the loop and contains the initialization instruction.  */\n+  basic_block predecessor;\n+\n+  /* First block in the loop.  This is the one branched to by the dbnz\n+     insn.  */\n+  basic_block head;\n+  \n+  /* Last block in the loop (the one with the dbnz insn */\n+  basic_block tail;\n+\n+  /* The successor block of the loop.  This is the one the dbnz insn\n+     falls into.  */\n+  basic_block successor;\n+\n+  /* The dbnz insn.  */\n+  rtx dbnz;\n+\n+  /* The initialization insn.  */\n+  rtx init;\n+\n+  /* The new initialization instruction.  */\n+  rtx loop_init;\n+\n+  /* The new ending instruction. */\n+  rtx loop_end;\n+\n+  /* The new label placed at the end of the loop. */\n+  rtx end_label;\n+\n+  /* The nesting depth of the loop.  Set to -1 for a bad loop.  */\n+  int depth;\n+\n+  /* The length of the loop.  */\n+  int length;\n+\n+  /* Next loop in the graph. */\n+  struct loop_info *next;\n+\n+  /* Vector of blocks only within the loop, (excluding those within\n+     inner loops).  */\n+  VEC (basic_block,heap) *blocks;\n+\n+  /* Vector of inner loops within this loop  */\n+  VEC (loop_info,heap) *loops;\n+};\n+\n+/* Information used during loop detection.  */\n+typedef struct loop_work GTY(())\n+{\n+  /* Basic block to be scanned.  */\n+  basic_block block;\n+\n+  /* Loop it will be within.  */\n+  loop_info loop;\n+} loop_work;\n+\n+/* Work list.  */\n+DEF_VEC_O (loop_work);\n+DEF_VEC_ALLOC_O (loop_work,heap);\n+\n+/* Determine the nesting and length of LOOP.  Return false if the loop\n+   is bad.  */\n+\n+static bool\n+ms1_loop_nesting (loop_info loop)\n+{\n+  loop_info inner;\n+  unsigned ix;\n+  int inner_depth = 0;\n+  \n+  if (!loop->depth)\n+    {\n+      /* Make sure we only have one entry point.  */\n+      if (EDGE_COUNT (loop->head->preds) == 2)\n+\t{\n+\t  loop->predecessor = EDGE_PRED (loop->head, 0)->src;\n+\t  if (loop->predecessor == loop->tail)\n+\t    /* We wanted the other predecessor.  */\n+\t    loop->predecessor = EDGE_PRED (loop->head, 1)->src;\n+\t  \n+\t  /* We can only place a loop insn on a fall through edge of a\n+\t     single exit block.  */\n+\t  if (EDGE_COUNT (loop->predecessor->succs) != 1\n+\t      || !(EDGE_SUCC (loop->predecessor, 0)->flags & EDGE_FALLTHRU))\n+\t    loop->predecessor = NULL;\n+\t}\n+\n+      /* Mark this loop as bad for now.  */\n+      loop->depth = -1;\n+      if (loop->predecessor)\n+\t{\n+\t  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix++, inner);)\n+\t    {\n+\t      if (!inner->depth)\n+\t\tms1_loop_nesting (inner);\n+\t      \n+\t      if (inner->depth < 0)\n+\t\t{\n+\t\t  inner_depth = -1;\n+\t\t  break;\n+\t\t}\n+\t      \n+\t      if (inner_depth < inner->depth)\n+\t\tinner_depth = inner->depth;\n+\t      loop->length += inner->length;\n+\t    }\n+\t  \n+\t  /* Set the proper loop depth, if it was good. */\n+\t  if (inner_depth >= 0)\n+\t    loop->depth = inner_depth + 1;\n+\t}\n+    }\n+  return (loop->depth > 0\n+\t  && loop->predecessor\n+\t  && loop->depth < MAX_LOOP_DEPTH\n+\t  && loop->length < MAX_LOOP_LENGTH);\n+}\n+\n+/* Determine the length of block BB.  */\n+\n+static int\n+ms1_block_length (basic_block bb)\n+{\n+  int length = 0;\n+  rtx insn;\n+\n+  for (insn = BB_HEAD (bb);\n+       insn != NEXT_INSN (BB_END (bb));\n+       insn = NEXT_INSN (insn))\n+    {\n+      if (!INSN_P (insn))\n+\tcontinue;\n+      if (CALL_P (insn))\n+\t{\n+\t  /* Calls are not allowed in loops.  */\n+\t  length = MAX_LOOP_LENGTH + 1;\n+\t  break;\n+\t}\n+      \n+      length += get_attr_length (insn);\n+    }\n+  return length;\n+}\n+\n+/* Scan the blocks of LOOP (and its inferiors) looking for uses of\n+   REG.  Return true, if we find any.  Don't count the loop's dbnz\n+   insn if it matches DBNZ.  */\n+\n+static bool\n+ms1_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n+{\n+  unsigned ix;\n+  loop_info inner;\n+  basic_block bb;\n+  \n+  for (ix = 0; VEC_iterate (basic_block, loop->blocks, ix, bb); ix++)\n+    {\n+      rtx insn;\n+\n+      for (insn = BB_HEAD (bb);\n+\t   insn != NEXT_INSN (BB_END (bb));\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\t  if (insn == dbnz)\n+\t    continue;\n+\t  if (reg_mentioned_p (reg, PATTERN (insn)))\n+\t    return true;\n+\t}\n+    }\n+  for (ix = 0; VEC_iterate (loop_info, loop->loops, ix, inner); ix++)\n+    if (ms1_scan_loop (inner, reg, NULL_RTX))\n+      return true;\n+  \n+  return false;\n+}\n+\n+/* MS2 has a loop instruction which needs to be placed just before the\n+   loop.  It indicates the end of the loop and specifies the number of\n+   loop iterations.  It can be nested with an automatically maintained\n+   stack of counter and end address registers.  It's an ideal\n+   candidate for doloop.  Unfortunately, gcc presumes that loops\n+   always end with an explicit instriction, and the doloop_begin\n+   instruction is not a flow control instruction so it can be\n+   scheduled earlier than just before the start of the loop.  To make\n+   matters worse, the optimization pipeline can duplicate loop exit\n+   and entrance blocks and fails to track abnormally exiting loops.\n+   Thus we cannot simply use doloop.\n+\n+   What we do is emit a dbnz pattern for the doloop optimization, and\n+   let that be optimized as normal.  Then in machine dependent reorg\n+   we have to repeat the loop searching algorithm.  We use the\n+   flow graph to find closed loops ending in a dbnz insn.  We then try\n+   and convert it to use the loop instruction.  The conditions are,\n+\n+   * the loop has no abnormal exits, duplicated end conditions or\n+   duplicated entrance blocks\n+\n+   * the loop counter register is only used in the dbnz instruction\n+   within the loop\n+   \n+   * we can find the instruction setting the initial value of the loop\n+   counter\n+\n+   * the loop is not executed more than 65535 times. (This might be\n+   changed to 2^32-1, and would therefore allow variable initializers.)\n+\n+   * the loop is not nested more than 4 deep 5) there are no\n+   subroutine calls in the loop.  */\n+\n+static void\n+ms1_reorg_loops (FILE *dump_file)\n+{\n+  basic_block bb;\n+  loop_info loops = NULL;\n+  loop_info loop;\n+  int nloops = 0;\n+  unsigned dwork = 0;\n+  VEC (loop_work,heap) *works = VEC_alloc (loop_work,heap,20);\n+  loop_work *work;\n+  edge e;\n+  edge_iterator ei;\n+  bool replaced = false;\n+\n+  /* Find all the possible loop tails.  This means searching for every\n+     dbnz instruction.  For each one found, create a loop_info\n+     structure and add the head block to the work list. */\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx tail = BB_END (bb);\n+\n+      while (GET_CODE (tail) == NOTE)\n+\ttail = PREV_INSN (tail);\n+      \n+      bb->aux = NULL;\n+      if (recog_memoized (tail) == CODE_FOR_decrement_and_branch_until_zero)\n+\t{\n+\t  /* A possible loop end */\n+\n+\t  loop = XNEW (struct loop_info);\n+\t  loop->next = loops;\n+\t  loops = loop;\n+\t  loop->tail = bb;\n+\t  loop->head = BRANCH_EDGE (bb)->dest;\n+\t  loop->successor = FALLTHRU_EDGE (bb)->dest;\n+\t  loop->predecessor = NULL;\n+\t  loop->dbnz = tail;\n+\t  loop->depth = 0;\n+\t  loop->length = ms1_block_length (bb);\n+\t  loop->blocks = VEC_alloc (basic_block, heap, 20);\n+\t  VEC_quick_push (basic_block, loop->blocks, bb);\n+\t  loop->loops = NULL;\n+\t  loop->loop_no = nloops++;\n+\t  \n+\t  loop->init = loop->end_label = NULL_RTX;\n+\t  loop->loop_init = loop->loop_end = NULL_RTX;\n+\t  \n+\t  work = VEC_safe_push (loop_work, heap, works, NULL);\n+\t  work->block = loop->head;\n+\t  work->loop = loop;\n+\n+\t  bb->aux = loop;\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \";; potential loop %d ending at\\n\",\n+\t\t       loop->loop_no);\n+\t      print_rtl_single (dump_file, tail);\n+\t    }\n+\t}\n+    }\n+\n+  /*  Now find all the closed loops.\n+      until work list empty,\n+       if block's auxptr is set\n+         if != loop slot\n+           if block's loop's start != block\n+\t     mark loop as bad\n+\t   else\n+             append block's loop's fallthrough block to worklist\n+\t     increment this loop's depth\n+       else if block is exit block\n+         mark loop as bad\n+       else\n+     \t  set auxptr\n+\t  for each target of block\n+     \t    add to worklist */\n+  while (VEC_iterate (loop_work, works, dwork++, work))\n+    {\n+      loop = work->loop;\n+      bb = work->block;\n+      if (bb == EXIT_BLOCK_PTR)\n+\t/* We've reached the exit block.  The loop must be bad. */\n+\tloop->depth = -1;\n+      else if (!bb->aux)\n+\t{\n+\t  /* We've not seen this block before.  Add it to the loop's\n+\t     list and then add each successor to the work list.  */\n+\t  bb->aux = loop;\n+\t  loop->length += ms1_block_length (bb);\n+\t  VEC_safe_push (basic_block, heap, loop->blocks, bb);\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      if (!VEC_space (loop_work, works, 1))\n+\t\t{\n+\t\t  if (dwork)\n+\t\t    {\n+\t\t      VEC_block_remove (loop_work, works, 0, dwork);\n+\t\t      dwork = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    VEC_reserve (loop_work, heap, works, 1);\n+\t\t}\n+\t      work = VEC_quick_push (loop_work, works, NULL);\n+\t      work->block = EDGE_SUCC (bb, ei.index)->dest;\n+\t      work->loop = loop;\n+\t    }\n+\t}\n+      else if (bb->aux != loop)\n+\t{\n+\t  /* We've seen this block in a different loop.  If it's not\n+\t     the other loop's head, then this loop must be bad.\n+\t     Otherwise, the other loop might be a nested loop, so\n+\t     continue from that loop's successor.  */\n+\t  loop_info other = bb->aux;\n+\t  \n+\t  if (other->head != bb)\n+\t    loop->depth = -1;\n+\t  else\n+\t    {\n+\t      VEC_safe_push (loop_info, heap, loop->loops, other);\n+\t      work = VEC_safe_push (loop_work, heap, works, NULL);\n+\t      work->loop = loop;\n+\t      work->block = other->successor;\n+\t    }\n+\t}\n+    }\n+  VEC_free (loop_work, heap, works);\n+\n+  /* Now optimize the loops.  */\n+  for (loop = loops; loop; loop = loop->next)\n+    {\n+      rtx iter_reg, insn, init_insn;\n+      rtx init_val, loop_end, loop_init, end_label, head_label;\n+\n+      if (!ms1_loop_nesting (loop))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d is bad\\n\", loop->loop_no);\n+\t  continue;\n+\t}\n+\n+      /* Get the loop iteration register.  */\n+      iter_reg = SET_DEST (XVECEXP (PATTERN (loop->dbnz), 0, 1));\n+      \n+      if (!REG_P (iter_reg))\n+\t{\n+\t  /* Spilled */\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d has spilled iteration count\\n\",\n+\t\t     loop->loop_no);\n+\t  continue;\n+\t}\n+\n+      /* Look for the initializing insn */\n+      init_insn = NULL_RTX;\n+      for (insn = BB_END (loop->predecessor);\n+\t   insn != PREV_INSN (BB_HEAD (loop->predecessor));\n+\t   insn = PREV_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\t  if (reg_mentioned_p (iter_reg, PATTERN (insn)))\n+\t    {\n+\t      rtx set = single_set (insn);\n+\n+\t      if (set && rtx_equal_p (iter_reg, SET_DEST (set)))\n+\t\tinit_insn = insn;\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (!init_insn)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d has no initializer\\n\",\n+\t\t     loop->loop_no);\n+\t  continue;\n+\t}\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \";; loop %d initialized by\\n\",\n+\t\t   loop->loop_no);\n+\t  print_rtl_single (dump_file, init_insn);\n+\t}\n+\n+      init_val = PATTERN (init_insn);\n+      if (GET_CODE (init_val) == SET)\n+\tinit_val = SET_SRC (init_val);\n+      if (GET_CODE (init_val) != CONST_INT || INTVAL (init_val) >= 65535)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d has complex initializer\\n\",\n+\t\t     loop->loop_no);\n+\t  continue;\n+\t}\n+      \n+      /* Scan all the blocks to make sure they don't use iter_reg.  */\n+      if (ms1_scan_loop (loop, iter_reg, loop->dbnz))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \";; loop %d uses iterator\\n\",\n+\t\t     loop->loop_no);\n+\t  continue;\n+\t}\n+\n+      /* The loop is good for replacement.  */\n+      \n+      /* loop is 1 based, dbnz is zero based.  */\n+      init_val = GEN_INT (INTVAL (init_val) + 1);\n+      \n+      iter_reg = gen_rtx_REG (SImode, LOOP_FIRST + loop->depth - 1);\n+      end_label = gen_label_rtx ();\n+      head_label = XEXP (SET_SRC (XVECEXP (PATTERN (loop->dbnz), 0, 0)), 1);\n+      loop_end = gen_loop_end (iter_reg, head_label);\n+      loop_init = gen_loop_init (iter_reg, init_val, end_label);\n+      loop->init = init_insn;\n+      loop->end_label = end_label;\n+      loop->loop_init = loop_init;\n+      loop->loop_end = loop_end;\n+      replaced = true;\n+      \n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \";; replacing loop %d initializer with\\n\",\n+\t\t   loop->loop_no);\n+\t  print_rtl_single (dump_file, loop->loop_init);\n+\t  fprintf (dump_file, \";; replacing loop %d terminator with\\n\",\n+\t\t   loop->loop_no);\n+\t  print_rtl_single (dump_file, loop->loop_end);\n+\t}\n+    }\n+\n+  /* Now apply the optimizations.  Do it this way so we don't mess up\n+     the flow graph half way through.  */\n+  for (loop = loops; loop; loop = loop->next)\n+    if (loop->loop_init)\n+      {\n+\temit_jump_insn_after (loop->loop_init, BB_END (loop->predecessor));\n+\tdelete_insn (loop->init);\n+\temit_label_before (loop->end_label, loop->dbnz);\n+\temit_jump_insn_before (loop->loop_end, loop->dbnz);\n+\tdelete_insn (loop->dbnz);\n+      }\n+\n+  /* Free up the loop structures */\n+  while (loops)\n+    {\n+      loop = loops;\n+      loops = loop->next;\n+      VEC_free (loop_info, heap, loop->loops);\n+      VEC_free (basic_block, heap, loop->blocks);\n+      XDELETE (loop);\n+    }\n+\n+  if (replaced && dump_file)\n+    {\n+      fprintf (dump_file, \";; Replaced loops\\n\");\n+      print_rtl (dump_file, get_insns ());\n+    }\n+}\n \n /* Structures to hold branch information during reorg.  */\n typedef struct branch_info\n@@ -1959,6 +2465,9 @@ ms1_reorg_hazard (void)\n static void\n ms1_machine_reorg (void)\n {\n+  if (cfun->machine->has_loops)\n+    ms1_reorg_loops (dump_file);\n+\n   if (ms1_flag_delayed_branch)\n     dbr_schedule (get_insns (), dump_file);\n   "}, {"sha": "eff36c7cbaa797c4a5ba66f1659486fe667d9669", "filename": "gcc/config/ms1/ms1.h", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.h?ref=ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "patch": "@@ -41,7 +41,7 @@ extern enum processor_type ms1_cpu;\n /* A C string constant that tells the GCC driver program options to pass to\n    the assembler.  */\n #undef  ASM_SPEC\n-#define ASM_SPEC \"%{march=*} %{!march=*: -march=ms1-16-002}\"\n+#define ASM_SPEC \"%{march=*} %{!march=*: -march=ms2}\"\n \n /* A string to pass to at the end of the command given to the linker.  */\n #undef  LIB_SPEC\n@@ -55,7 +55,7 @@ march=ms1-16-003:-T 16-003.ld%s; \\\n march=MS1-16-003:-T 16-003.ld%s; \\\n march=ms2:-T ms2.ld%s; \\\n march=MS2:-T ms2.ld%s; \\\n-\t : -T 16-002.ld}\"\n+\t : -T ms2.ld}\"\n \n /* A string to pass at the very beginning of the command given to the\n    linker.  */\n@@ -69,7 +69,7 @@ march=ms1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n march=MS1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n march=ms2:%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s; \\\n march=MS2:%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s; \\\n-\t :%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s} \\\n+\t :%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s} \\\n crti.o%s crtbegin.o%s\"\n \n /* A string to pass at the end of the command given to the linker.  */\n@@ -83,7 +83,7 @@ march=ms1-16-003:exit-16-003.o%s; \\\n march=MS1-16-003:exit-16-003.o%s; \\\n march=ms2:exit-ms2.o%s; \\\n march=MS2:exit-ms2.o%s; \\\n-\t :exit-16-002.o%s} \\\n+\t :exit-ms2.o%s} \\\n  crtend.o%s crtn.o%s\"\n \f\n /* Run-time target specifications.  */\n@@ -243,10 +243,13 @@ march=MS2:exit-ms2.o%s; \\\n \t\t\t\t\t   seen  by the caller */\n #define GPR_INTERRUPT_LINK 15\t\t/* hold return addres for interrupts */\n \n+#define LOOP_FIRST         (GPR_LAST + 1)\n+#define LOOP_LAST\t   (LOOP_FIRST + 3)\n+\n /* Argument register that is eliminated in favor of the frame and/or stack\n    pointer.  Also add register to point to where the return address is\n    stored.  */\n-#define SPECIAL_REG_FIRST\t\t(GPR_LAST + 1)\n+#define SPECIAL_REG_FIRST\t\t(LOOP_LAST + 1)\n #define SPECIAL_REG_LAST\t\t(SPECIAL_REG_FIRST)\n #define ARG_POINTER_REGNUM\t\t(SPECIAL_REG_FIRST + 0)\n #define SPECIAL_REG_P(R)\t\t((R) == SPECIAL_REG_FIRST)\n@@ -258,7 +261,7 @@ march=MS2:exit-ms2.o%s; \\\n /* The register used to hold functions return value */\n #define RETVAL_REGNUM\t\t11\n \n-#define FIRST_PSEUDO_REGISTER (GPR_FIRST + 17)\n+#define FIRST_PSEUDO_REGISTER (SPECIAL_REG_LAST + 1)\n \n #define IS_PSEUDO_P(R)\t(REGNO (R) >= FIRST_PSEUDO_REGISTER)\n \n@@ -270,7 +273,7 @@ march=MS2:exit-ms2.o%s; \\\n    R15\tIRA\tinterrupt return address.  */\n #define FIXED_REGISTERS { 1, 0, 0, 0, 0, 0, 0, 0, \\\n \t\t\t  0, 0, 0, 0, 1, 1, 1, 1, \\\n-\t\t\t  1\t\t\t  \\\n+\t\t\t  1, 1, 1, 1, 1\t\t  \\\n \t\t\t }\n \n /* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n@@ -279,7 +282,7 @@ march=MS2:exit-ms2.o%s; \\\n    allocation of values that must live across function calls.  */\n #define CALL_USED_REGISTERS\t{ 1, 1, 1, 1, 1, 0, 0, 1, \\\n \t\t\t\t  1, 1, 1, 1, 1, 1, 1, 1, \\\n-\t\t\t\t  1\t\t\t  \\\n+\t\t\t\t  1, 1, 1, 1, 1\t\t  \\\n \t\t\t\t}\n \n \f\n@@ -310,9 +313,9 @@ enum reg_class\n #define REG_CLASS_NAMES {\"NO_REGS\", \"ALL_REGS\" }\n \n #define REG_CLASS_CONTENTS \\\n-   {\t\t\t\t\t\t\t\t\t\\\n-     { 0x0, 0x0 },\t\t\t\t\t\t\t\\\n-     { (((1 << (GPR_LAST + 1)) - 1) & ~(1 << GPR_FIRST)), 0x0 },\t\\\n+   {\t\t\t\t\t\t\t\t\\\n+     { 0x0 },\t\t\t\t\t\t\t\\\n+     { 0x000fffff },\t\t\t\t\t\t\\\n    }\n \n /* A C expression whose value is a register class containing hard register\n@@ -736,7 +739,7 @@ extern struct ms1_frame_info current_frame_info;\n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n { \"R0\", \"R1\", \"R2\", \"R3\", \"R4\", \"R5\", \"R6\", \"R7\",\t\t\t\\\n   \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\t\t\t\\\n-  \"ap\" }\n+  \"LOOP1\", \"LOOP2\", \"LOOP3\", \"LOOP4\", \"ap\" }\n \n /* If defined, a C initializer for an array of structures containing a name and\n    a register number.  This macro defines additional names for hard registers,"}, {"sha": "104f2829e29a4b4b47146a4f0908cbf8e0503b69", "filename": "gcc/config/ms1/ms1.md", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c/gcc%2Fconfig%2Fms1%2Fms1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.md?ref=ac3ebe93b6ba2eb7c6b8f4f9e6bc2eb253fe586c", "patch": "@@ -25,6 +25,7 @@\n     (UNSPEC_BLOCKAGE 0)\n     (UNSPEC_EI 1)\n     (UNSPEC_DI 2)\n+    (UNSPEC_LOOP 3)\n   ])\n \n ;; Attributes\n@@ -148,6 +149,58 @@\n   \"\")\n \n \f\n+;; Loop instructions.  ms2 has a low overhead looping instructions.\n+;; these take a constant or register loop count and a loop length\n+;; offset.  Unfortunately the loop can only be up to 256 instructions,\n+;; We deal with longer loops by moving the loop end upwards.  To do\n+;; otherwise would force us to to be very pessimistic right up until\n+;; the end.\n+\n+;; This instruction is a placeholder to make the control flow explicit.\n+(define_insn \"loop_end\"\n+  [(set (pc) (if_then_else\n+\t\t\t  (ne (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t      (const_int 1))\n+\t\t\t  (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t  (pc)))\n+   (set (match_dup 0) (plus:SI (match_dup 0) (const_int -1)))\n+   (unspec [(const_int 0)] UNSPEC_LOOP)]\n+  \"TARGET_MS2\"\n+  \";loop end %0,%l1\"\n+  [(set_attr \"length\" \"0\")])\n+\n+;; This is the real looping instruction.  It is placed just before the\n+;; loop body.  We make it a branch insn, so it stays at the end of the\n+;; block it is in.\n+(define_insn \"loop_init\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(match_operand:SI 1 \"uns_arith_operand\" \"r,K\"))\n+   (unspec [(label_ref (match_operand 2 \"\" \"\"))] UNSPEC_LOOP)]\n+  \"TARGET_MS2\"\n+  \"@\n+   loop  %1,%l2 ;%0%#\n+   loopi %1,%l2 ;%0%#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")])\n+\n+; operand 0 is the loop count pseudo register\n+; operand 1 is the number of loop iterations or 0 if it is unknown\n+; operand 2 is the maximum number of loop iterations\n+; operand 3 is the number of levels of enclosed loops\n+; operand 4 is the label to jump to at the top of the loop\n+(define_expand \"doloop_end\"\n+  [(parallel [(set (pc) (if_then_else\n+\t\t\t  (ne (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t\t      (const_int 0))\n+\t\t\t  (label_ref (match_operand 4 \"\" \"\"))\n+\t\t\t  (pc)))\n+\t      (set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (const_int -1)))\n+\t      (clobber (match_scratch:SI 5 \"\"))])]\n+  \"TARGET_MS1_16_003 || TARGET_MS2\"\n+  {ms1_add_loop ();})\n+\f\n ;; Moves\n \n (define_expand \"loadqi\""}]}