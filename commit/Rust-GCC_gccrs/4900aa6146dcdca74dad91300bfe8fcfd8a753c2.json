{"sha": "4900aa6146dcdca74dad91300bfe8fcfd8a753c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkwMGFhNjE0NmRjZGNhNzRkYWQ5MTMwMGJmZThmY2ZkOGE3NTNjMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-01-03T09:49:01Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-01-03T09:49:01Z"}, "message": "* config/sparc/sparc.c: Fix formatting nits.\n\nFrom-SVN: r155582", "tree": {"sha": "a959478083e0becaf1287c078c095661a9d38118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a959478083e0becaf1287c078c095661a9d38118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4900aa6146dcdca74dad91300bfe8fcfd8a753c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4900aa6146dcdca74dad91300bfe8fcfd8a753c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4900aa6146dcdca74dad91300bfe8fcfd8a753c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4900aa6146dcdca74dad91300bfe8fcfd8a753c2/comments", "author": null, "committer": null, "parents": [{"sha": "f9de68b37d21dd93274e66d4bb0c142f55e23d67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9de68b37d21dd93274e66d4bb0c142f55e23d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9de68b37d21dd93274e66d4bb0c142f55e23d67"}], "stats": {"total": 151, "additions": 76, "deletions": 75}, "files": [{"sha": "739cc7d5098d3c394be883fce9246c5d53868515", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4900aa6146dcdca74dad91300bfe8fcfd8a753c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4900aa6146dcdca74dad91300bfe8fcfd8a753c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4900aa6146dcdca74dad91300bfe8fcfd8a753c2", "patch": "@@ -1,3 +1,7 @@\n+2010-01-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc.c: Fix formatting nits.\n+\n 2010-01-02  Gerald Pfeifer  <gerald@pfeifer.com>\n             Alexander Monakov  <amonakov@ispras.ru>\n "}, {"sha": "82bc7d51e40fa7986bfc1e98dd3d2c83570b820e", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 72, "deletions": 75, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4900aa6146dcdca74dad91300bfe8fcfd8a753c2/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4900aa6146dcdca74dad91300bfe8fcfd8a753c2/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=4900aa6146dcdca74dad91300bfe8fcfd8a753c2", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for SPARC.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n    64-bit SPARC-V9 support by Michael Tiemann, Jim Wilson, and Doug Evans,\n@@ -710,7 +710,7 @@ sparc_override_options (void)\n   const struct cpu_table *cpu;\n   const struct sparc_cpu_select *sel;\n   int fpu;\n-  \n+\n #ifndef SPARC_BI_ARCH\n   /* Check for unsupported architecture size.  */\n   if (! TARGET_64BIT != DEFAULT_ARCH32_P)\n@@ -727,7 +727,7 @@ sparc_override_options (void)\n \n   /* Code model selection.  */\n   sparc_cmodel = SPARC_DEFAULT_CMODEL;\n-  \n+\n #ifdef SPARC_BI_ARCH\n   if (TARGET_ARCH32)\n     sparc_cmodel = CM_32;\n@@ -810,7 +810,7 @@ sparc_override_options (void)\n   /* Don't use stack biasing in 32 bit mode.  */\n   if (TARGET_ARCH32)\n     target_flags &= ~MASK_STACK_BIAS;\n-    \n+\n   /* Supply a default value for align_functions.  */\n   if (align_functions == 0\n       && (sparc_cpu == PROCESSOR_ULTRASPARC\n@@ -887,7 +887,7 @@ sparc_override_options (void)\n \t\t      : (sparc_cpu == PROCESSOR_ULTRASPARC3\n \t\t\t ? 8 : 3)));\n   if (!PARAM_SET_P (PARAM_L1_CACHE_LINE_SIZE))\n-    set_param_value (\"l1-cache-line-size\", \n+    set_param_value (\"l1-cache-line-size\",\n \t\t     ((sparc_cpu == PROCESSOR_ULTRASPARC\n \t\t       || sparc_cpu == PROCESSOR_ULTRASPARC3\n \t\t       || sparc_cpu == PROCESSOR_NIAGARA\n@@ -1014,7 +1014,7 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n \t}\n       operands[1] = sym;\n     }\n- \n+\n   /* Fixup PIC cases.  */\n   if (flag_pic && CONSTANT_P (operands[1]))\n     {\n@@ -1110,7 +1110,7 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n       /* input_operand should have filtered out 32-bit mode.  */\n       sparc_emit_set_const64 (operands[0], operands[1]);\n       return true;\n-    \n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -2265,7 +2265,7 @@ emit_scc_insn (rtx operands[])\n   if (code == LTU || code == GEU)\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t      gen_rtx_fmt_ee (code, SImode, \n+\t\t\t      gen_rtx_fmt_ee (code, SImode,\n \t\t\t\t\t      gen_compare_reg_1 (code, x, y),\n \t\t\t\t\t      const0_rtx)));\n       return true;\n@@ -2957,7 +2957,7 @@ check_pic (int i)\n     }\n }\n \n-/* Return true if X is an address which needs a temporary register when \n+/* Return true if X is an address which needs a temporary register when\n    reloaded while generating PIC code.  */\n \n int\n@@ -3072,7 +3072,7 @@ legitimate_pic_operand_p (rtx x)\n \n /* Return nonzero if ADDR is a valid memory address.\n    STRICT specifies whether strict register checking applies.  */\n-   \n+\n static bool\n sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n {\n@@ -3694,7 +3694,7 @@ mem_min_alignment (rtx mem, int desired)\n \t it is to a constant address, or the address involves a LO_SUM.  */\n       return 1;\n     }\n-  \n+\n   /* An obviously unaligned address.  */\n   return 0;\n }\n@@ -3837,7 +3837,7 @@ sparc_init_modes (void)\n \t    sparc_mode_class[i] = 1 << (int) T_MODE;\n \t  else if (GET_MODE_SIZE (i) == 32)\n \t    sparc_mode_class[i] = 1 << (int) O_MODE;\n-\t  else \n+\t  else\n \t    sparc_mode_class[i] = 0;\n \t  break;\n \tcase MODE_VECTOR_INT:\n@@ -3856,7 +3856,7 @@ sparc_init_modes (void)\n \t    sparc_mode_class[i] = 1 << (int) TF_MODE;\n \t  else if (GET_MODE_SIZE (i) == 32)\n \t    sparc_mode_class[i] = 1 << (int) OF_MODE;\n-\t  else \n+\t  else\n \t    sparc_mode_class[i] = 0;\n \t  break;\n \tcase MODE_CC:\n@@ -4231,7 +4231,7 @@ sparc_expand_prologue (void)\n   if (flag_pic && crtl->uses_pic_offset_table)\n     load_pic_register (false);\n }\n- \n+\n /* This function generates the assembly code for function entry, which boils\n    down to emitting the necessary .register directives.  */\n \n@@ -4282,9 +4282,9 @@ sparc_can_use_return_insn_p (void)\n   return sparc_prologue_data_valid_p\n \t && (actual_fsize == 0 || !sparc_leaf_function_p);\n }\n-  \n+\n /* This function generates the assembly code for function exit.  */\n-  \n+\n static void\n sparc_asm_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n@@ -4309,9 +4309,9 @@ sparc_asm_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n   sparc_output_deferred_case_vectors ();\n }\n-  \n+\n /* Output a 'restore' instruction.  */\n- \n+\n static void\n output_restore (rtx pat)\n {\n@@ -4351,7 +4351,7 @@ output_restore (rtx pat)\n \tbreak;\n     }\n }\n-  \n+\n /* Output a return.  */\n \n const char *\n@@ -4534,7 +4534,7 @@ output_sibcall (rtx insn, rtx call_operand)\n      the appropriate fp reg and in memory.\n \n \n-   Summary of the calling conventions implemented by GCC on SPARC:\n+   Summary of the calling conventions implemented by GCC on the SPARC:\n \n    32-bit ABI:\n                                 size      argument     return value\n@@ -4603,7 +4603,7 @@ implemented by the Sun compiler.\n Note #2: integral vector types follow the scalar floating-point types\n conventions to match what is implemented by the Sun VIS SDK.\n \n-Note #3: floating-point vector types follow the aggregate types \n+Note #3: floating-point vector types follow the aggregate types\n conventions.  */\n \n \n@@ -4657,7 +4657,6 @@ sparc_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n      for arithmetic operations which do zero/sign extension at the same time,\n      so without this we end up with a srl/sra after every assignment to an\n      user variable,  which means very very bad code.  */\n-\n   if (TARGET_ARCH64\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n@@ -4666,8 +4665,6 @@ sparc_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,\n   return mode;\n }\n \n-\n-\n /* Handle the TARGET_STRICT_ARGUMENT_NAMING target hook.  */\n \n static bool\n@@ -4983,7 +4980,7 @@ function_arg_record_value_1 (const_tree type, HOST_WIDE_INT startbitpos,\n /* A subroutine of function_arg_record_value.  Assign the bits of the\n    structure between parms->intoffset and bitpos to integer registers.  */\n \n-static void \n+static void\n function_arg_record_value_3 (HOST_WIDE_INT bitpos,\n \t\t\t     struct function_arg_record_value_parms *parms)\n {\n@@ -5147,7 +5144,7 @@ function_arg_record_value_2 (const_tree type, HOST_WIDE_INT startbitpos,\n    NAMED is nonzero if this argument is a named parameter\n     (otherwise it is an extra parameter matching an ellipsis).\n    REGBASE is the regno of the base register for the parameter array.  */\n-   \n+\n static rtx\n function_arg_record_value (const_tree type, enum machine_mode mode,\n \t\t\t   int slotno, int named, int regbase)\n@@ -5547,7 +5544,7 @@ sparc_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n     /* Original SPARC 64-bit ABI says that structures and unions\n        smaller than 16 bytes are passed in registers, as well as\n        all other base types.\n-       \n+\n        Extended ABI (as implemented by the Sun compiler) says that\n        complex floats are passed in registers up to 16 bytes.  Pass\n        all complex integers in registers up to 16 bytes.  More generally,\n@@ -5653,7 +5650,7 @@ sparc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n     /* Original SPARC 64-bit ABI says that structures and unions\n        smaller than 32 bytes are returned in registers, as well as\n        all other base types.\n-       \n+\n        Extended ABI (as implemented by the Sun compiler) says that all\n        complex floats are returned in registers (8 FP registers at most\n        for '_Complex long double').  Return all complex integers in\n@@ -5686,10 +5683,10 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n \tmem = gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx,\n \t\t\t\t\t\t STRUCT_VALUE_OFFSET));\n \n-      /* Only follow the SPARC ABI for fixed-size structure returns. \n-         Variable size structure returns are handled per the normal \n+      /* Only follow the SPARC ABI for fixed-size structure returns.\n+         Variable size structure returns are handled per the normal\n          procedures in GCC. This is enabled by -mstd-struct-return */\n-      if (incoming == 2 \n+      if (incoming == 2\n \t  && sparc_std_struct_return\n \t  && TYPE_SIZE_UNIT (TREE_TYPE (fndecl))\n \t  && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (fndecl))) == INTEGER_CST)\n@@ -5699,7 +5696,7 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n \t     provided.  */\n \t  rtx ret_rtx = gen_rtx_REG (Pmode, 31);\n \t  rtx scratch = gen_reg_rtx (SImode);\n-\t  rtx endlab = gen_label_rtx (); \n+\t  rtx endlab = gen_label_rtx ();\n \n \t  /* Calculate the return object size */\n \t  tree size = TYPE_SIZE_UNIT (TREE_TYPE (fndecl));\n@@ -5708,8 +5705,8 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n \t  rtx temp_val = assign_stack_local (Pmode, TREE_INT_CST_LOW (size), 0);\n \n \t  /* Implement SPARC 32-bit psABI callee returns struck checking\n-\t     requirements: \n-\t    \n+\t     requirements:\n+\n \t      Fetch the instruction where we will return to and see if\n \t     it's an unimp instruction (the most significant 10 bits\n \t     will be zero).  */\n@@ -5719,7 +5716,7 @@ sparc_struct_value_rtx (tree fndecl, int incoming)\n \t  emit_insn (gen_add3_insn (ret_rtx, ret_rtx, GEN_INT (4)));\n \t  emit_cmp_and_jump_insns (scratch, size_rtx, EQ, const0_rtx, SImode, 0, endlab);\n \t  emit_insn (gen_sub3_insn (ret_rtx, ret_rtx, GEN_INT (4)));\n-\t  /* Assign stack temp: \n+\t  /* Assign stack temp:\n \t     Write the address of the memory pointed to by temp_val into\n \t     the memory pointed to by mem */\n \t  emit_move_insn (mem, XEXP (temp_val, 0));\n@@ -6482,21 +6479,21 @@ output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n \n   /* branch on register are limited to +-128KB.  If it is too far away,\n      change\n-     \n+\n      brnz,pt %g1, .LC30\n-     \n+\n      to\n-     \n+\n      brz,pn %g1, .+12\n       nop\n      ba,pt %xcc, .LC30\n-     \n+\n      and\n-     \n+\n      brgez,a,pn %o1, .LC29\n-     \n+\n      to\n-     \n+\n      brlz,pt %o1, .+16\n       nop\n      ba,pt %xcc, .LC29  */\n@@ -6748,30 +6745,30 @@ sparc_absnegfloat_split_legitimate (rtx x, rtx y)\n }\n \n /* Return 1 if REGNO (reg1) is even and REGNO (reg1) == REGNO (reg2) - 1.\n-   This makes them candidates for using ldd and std insns. \n+   This makes them candidates for using ldd and std insns.\n \n    Note reg1 and reg2 *must* be hard registers.  */\n \n int\n registers_ok_for_ldd_peep (rtx reg1, rtx reg2)\n {\n   /* We might have been passed a SUBREG.  */\n-  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n+  if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG)\n     return 0;\n \n   if (REGNO (reg1) % 2 != 0)\n     return 0;\n \n-  /* Integer ldd is deprecated in SPARC V9 */ \n-  if (TARGET_V9 && REGNO (reg1) < 32)                  \n-    return 0;                             \n+  /* Integer ldd is deprecated in SPARC V9 */\n+  if (TARGET_V9 && REGNO (reg1) < 32)\n+    return 0;\n \n   return (REGNO (reg1) == REGNO (reg2) - 1);\n }\n \n /* Return 1 if the addresses in mem1 and mem2 are suitable for use in\n    an ldd or std insn.\n-   \n+\n    This can only happen when addr1 and addr2, the addresses in mem1\n    and mem2, are consecutive memory locations (addr1 + 4 == addr2).\n    addr1 must also be aligned on a 64-bit boundary.\n@@ -6814,10 +6811,10 @@ mems_ok_for_ldd_peep (rtx mem1, rtx mem2, rtx dependent_reg_rtx)\n   /* MEM1 should be aligned on a 64-bit boundary.  */\n   if (MEM_ALIGN (mem1) < 64)\n     return 0;\n-  \n+\n   addr1 = XEXP (mem1, 0);\n   addr2 = XEXP (mem2, 0);\n-  \n+\n   /* Extract a register number and offset (if used) from the first addr.  */\n   if (GET_CODE (addr1) == PLUS)\n     {\n@@ -6855,8 +6852,8 @@ mems_ok_for_ldd_peep (rtx mem1, rtx mem2, rtx dependent_reg_rtx)\n \n   if (dependent_reg_rtx != NULL_RTX && reg1 == REGNO (dependent_reg_rtx))\n     return 0;\n-  \n-  /* The first offset must be evenly divisible by 8 to ensure the \n+\n+  /* The first offset must be evenly divisible by 8 to ensure the\n      address is 64 bit aligned.  */\n   if (offset1 % 8 != 0)\n     return 0;\n@@ -7298,7 +7295,7 @@ sparc_type_code (register tree type)\n \t{\n \tcase ERROR_MARK:\n \t  return qualifiers;\n-  \n+\n \tcase ARRAY_TYPE:\n \t  qualifiers |= (3 << shift);\n \t  break;\n@@ -7346,16 +7343,16 @@ sparc_type_code (register tree type)\n \n \t  if (TYPE_PRECISION (type) <= CHAR_TYPE_SIZE)\n \t    return (qualifiers | (TYPE_UNSIGNED (type) ? 12 : 2));\n-  \n+\n \t  else if (TYPE_PRECISION (type) <= SHORT_TYPE_SIZE)\n \t    return (qualifiers | (TYPE_UNSIGNED (type) ? 13 : 3));\n-  \n+\n \t  else if (TYPE_PRECISION (type) <= INT_TYPE_SIZE)\n \t    return (qualifiers | (TYPE_UNSIGNED (type) ? 14 : 4));\n-  \n+\n \t  else\n \t    return (qualifiers | (TYPE_UNSIGNED (type) ? 15 : 5));\n-  \n+\n \tcase REAL_TYPE:\n \t  /* If this is a range type, consider it to be the underlying\n \t     type.  */\n@@ -7368,9 +7365,9 @@ sparc_type_code (register tree type)\n \t  if (TYPE_PRECISION (type) == FLOAT_TYPE_SIZE)\n \t    return (qualifiers | 6);\n \n-\t  else \n+\t  else\n \t    return (qualifiers | 7);\n-  \n+\n \tcase COMPLEX_TYPE:\t/* GNU Fortran COMPLEX type.  */\n \t  /* ??? We need to distinguish between double and float complex types,\n \t     but I don't know how yet because I can't reach this code from\n@@ -7381,7 +7378,7 @@ sparc_type_code (register tree type)\n \tcase BOOLEAN_TYPE:\t/* Boolean truth value type.  */\n \tcase LANG_TYPE:\t\t/* ? */\n \t  return qualifiers;\n-  \n+\n \tdefault:\n \t  gcc_unreachable ();\t\t/* Not a type! */\n         }\n@@ -7623,13 +7620,13 @@ hypersparc_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \t  if (dep_type == TYPE_STORE || dep_type == TYPE_FPSTORE)\n \t    {\n \t      if (GET_CODE (pat) != SET || GET_CODE (dep_pat) != SET\n-\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM        \n+\t\t  || GET_CODE (SET_DEST (dep_pat)) != MEM\n \t\t  || GET_CODE (SET_SRC (pat)) != MEM\n \t\t  || ! rtx_equal_p (XEXP (SET_DEST (dep_pat), 0),\n \t\t\t\t    XEXP (SET_SRC (pat), 0)))\n \t\treturn cost + 2;\n \n-\t      return cost + 8;        \n+\t      return cost + 8;\n \t    }\n \t  break;\n \n@@ -7656,7 +7653,7 @@ hypersparc_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n     default:\n       break;\n-    }    \n+    }\n \n   return cost;\n }\n@@ -7683,9 +7680,8 @@ static void\n sparc_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n \t\t  int sched_verbose ATTRIBUTE_UNUSED,\n \t\t  int max_ready ATTRIBUTE_UNUSED)\n-{\n-}\n-  \n+{}\n+\n static int\n sparc_use_sched_lookahead (void)\n {\n@@ -7803,13 +7799,13 @@ sparc_defer_case_vector (rtx lab, rtx vec, int diff)\n     sparc_addr_list = gen_rtx_EXPR_LIST (VOIDmode, vec, sparc_addr_list);\n }\n \n-static void \n+static void\n sparc_output_addr_vec (rtx vec)\n {\n   rtx lab = XEXP (vec, 0), body = XEXP (vec, 1);\n   int idx, vlen = XVECLEN (body, 0);\n \n-#ifdef ASM_OUTPUT_ADDR_VEC_START  \n+#ifdef ASM_OUTPUT_ADDR_VEC_START\n   ASM_OUTPUT_ADDR_VEC_START (asm_out_file);\n #endif\n \n@@ -7825,20 +7821,20 @@ sparc_output_addr_vec (rtx vec)\n       ASM_OUTPUT_ADDR_VEC_ELT\n \t(asm_out_file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));\n     }\n-    \n+\n #ifdef ASM_OUTPUT_ADDR_VEC_END\n   ASM_OUTPUT_ADDR_VEC_END (asm_out_file);\n #endif\n }\n \n-static void \n+static void\n sparc_output_addr_diff_vec (rtx vec)\n {\n   rtx lab = XEXP (vec, 0), body = XEXP (vec, 1);\n   rtx base = XEXP (XEXP (body, 0), 0);\n   int idx, vlen = XVECLEN (body, 1);\n \n-#ifdef ASM_OUTPUT_ADDR_VEC_START  \n+#ifdef ASM_OUTPUT_ADDR_VEC_START\n   ASM_OUTPUT_ADDR_VEC_START (asm_out_file);\n #endif\n \n@@ -7857,7 +7853,7 @@ sparc_output_addr_diff_vec (rtx vec)\n          CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 1, idx), 0)),\n          CODE_LABEL_NUMBER (base));\n     }\n-    \n+\n #ifdef ASM_OUTPUT_ADDR_VEC_END\n   ASM_OUTPUT_ADDR_VEC_END (asm_out_file);\n #endif\n@@ -7879,7 +7875,7 @@ sparc_output_deferred_case_vectors (void)\n   align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n   if (align > 0)\n     ASM_OUTPUT_ALIGN (asm_out_file, align);\n-  \n+\n   for (t = sparc_addr_list; t ; t = XEXP (t, 1))\n     sparc_output_addr_vec (XEXP (t, 0));\n   for (t = sparc_addr_diff_list; t ; t = XEXP (t, 1))\n@@ -8800,7 +8796,8 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Find the \"this\" pointer.  Normally in %o0, but in ARCH64 if the function\n      returns a structure, the structure return pointer is there instead.  */\n-  if (TARGET_ARCH64 && aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+  if (TARGET_ARCH64\n+      && aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n     this_rtx = gen_rtx_REG (Pmode, int_arg_first + 1);\n   else\n     this_rtx = gen_rtx_REG (Pmode, int_arg_first);\n@@ -9197,7 +9194,7 @@ sparc_frame_pointer_required (void)\n bool\n sparc_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n {\n-  return (to == HARD_FRAME_POINTER_REGNUM \n+  return (to == HARD_FRAME_POINTER_REGNUM\n           || !targetm.frame_pointer_required ());\n }\n "}]}