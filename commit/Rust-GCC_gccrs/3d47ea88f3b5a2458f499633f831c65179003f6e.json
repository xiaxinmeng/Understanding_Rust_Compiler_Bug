{"sha": "3d47ea88f3b5a2458f499633f831c65179003f6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q0N2VhODhmM2I1YTI0NThmNDk5NjMzZjgzMWM2NTE3OTAwM2Y2ZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb.gcc@gmail.com", "date": "2006-03-12T22:58:22Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2006-03-12T22:58:22Z"}, "message": "predict.c (estimate_probability): Remove.\n\n        * predict.c (estimate_probability): Remove.\n        * profile.c (rest_of_handle_branch_prob, pass_branch_prob): Remove.\n        * basic-block.h (estimate_probability): Remove prototype.\n        * passes.c (finish_optimization_passes): Dump branch prediction or\n        profiling heuristics to the .profile tree dump.\n        (init_optimization_passes): Unqueue pass_branch_prob.\n\n        * doc/invoke.texi (-fdump-rtl-bp): Remove.\n\nFrom-SVN: r111980", "tree": {"sha": "d2df1cff7b7b6d39cad373f658025e733516f5d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2df1cff7b7b6d39cad373f658025e733516f5d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d47ea88f3b5a2458f499633f831c65179003f6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d47ea88f3b5a2458f499633f831c65179003f6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d47ea88f3b5a2458f499633f831c65179003f6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d47ea88f3b5a2458f499633f831c65179003f6e/comments", "author": null, "committer": null, "parents": [{"sha": "189cd5056db36dc477e1673f75f2eccf3be4056b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/189cd5056db36dc477e1673f75f2eccf3be4056b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/189cd5056db36dc477e1673f75f2eccf3be4056b"}], "stats": {"total": 145, "additions": 13, "deletions": 132}, "files": [{"sha": "ad4af1167213cde7134b46071dbdb204379376a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d47ea88f3b5a2458f499633f831c65179003f6e", "patch": "@@ -1,3 +1,14 @@\n+2006-03-12  Steven Bosscher  <stevenb.gcc@gmail.com>\n+\n+\t* predict.c (estimate_probability): Remove.\n+\t* profile.c (rest_of_handle_branch_prob, pass_branch_prob): Remove.\n+\t* basic-block.h (estimate_probability): Remove prototype.\n+\t* passes.c (finish_optimization_passes): Dump branch prediction or\n+\tprofiling heuristics to the .profile tree dump.\n+\t(init_optimization_passes): Unqueue pass_branch_prob.\n+\n+\t* doc/invoke.texi (-fdump-rtl-bp): Remove.\n+\n 2006-03-11  Steven Bosscher  <stevenb.gcc@gmail.com>\n \n \t* rtl.def (LABEL_REF): Remove the field for LABEL_NEXTREF."}, {"sha": "14c22e35466c8cfcc614996c0b6f095cbc99c0ce", "filename": "gcc/basic-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3d47ea88f3b5a2458f499633f831c65179003f6e", "patch": "@@ -869,7 +869,6 @@ extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,\n extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n \n /* In predict.c */\n-extern void estimate_probability (struct loops *);\n extern void expected_value_to_br_prob (void);\n extern bool maybe_hot_bb_p (basic_block);\n extern bool probably_cold_bb_p (basic_block);"}, {"sha": "99fbf8f070719a08c8779d211d240ac0bb1f4269", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3d47ea88f3b5a2458f499633f831c65179003f6e", "patch": "@@ -3712,12 +3712,6 @@ letters for use in @var{letters} and @var{pass}, and their meanings:\n @opindex dA\n Annotate the assembler output with miscellaneous debugging information.\n \n-@item -db\n-@itemx -fdump-rtl-bp\n-@opindex db\n-@opindex fdump-rtl-bp\n-Dump after computing branch probabilities, to @file{@var{file}.09.bp}.\n-\n @item -dB\n @itemx -fdump-rtl-bbro\n @opindex dB"}, {"sha": "f6a97f65edf438aaff6d4fb8bbb5a0a8bd6045f7", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=3d47ea88f3b5a2458f499633f831c65179003f6e", "patch": "@@ -216,10 +216,10 @@ finish_optimization_passes (void)\n   timevar_push (TV_DUMP);\n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n-      dump_file = dump_begin (pass_branch_prob.static_pass_number, NULL);\n+      dump_file = dump_begin (pass_profile.static_pass_number, NULL);\n       end_branch_prob ();\n       if (dump_file)\n-\tdump_end (pass_branch_prob.static_pass_number, dump_file);\n+\tdump_end (pass_profile.static_pass_number, dump_file);\n     }\n \n   if (optimize > 0)\n@@ -635,7 +635,6 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_gcse);\n   NEXT_PASS (pass_jump_bypass);\n   NEXT_PASS (pass_cfg);\n-  NEXT_PASS (pass_branch_prob);\n   NEXT_PASS (pass_rtl_ifcvt);\n   NEXT_PASS (pass_tracer);\n   /* Perform loop optimizations.  It might be better to do them a bit"}, {"sha": "dd0cdc1547002e10f801c301aa4d6e01cfc909b4", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3d47ea88f3b5a2458f499633f831c65179003f6e", "patch": "@@ -826,85 +826,6 @@ bb_estimate_probability_locally (basic_block bb)\n       }\n }\n \n-/* Statically estimate the probability that a branch will be taken and produce\n-   estimated profile.  When profile feedback is present never executed portions\n-   of function gets estimated.  */\n-\n-void\n-estimate_probability (struct loops *loops_info)\n-{\n-  basic_block bb;\n-\n-  connect_infinite_loops_to_exit ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n-\n-  predict_loops (loops_info, true);\n-\n-  iv_analysis_done ();\n-\n-  /* Attempt to predict conditional jumps using a number of heuristics.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      rtx last_insn = BB_END (bb);\n-      edge e;\n-      edge_iterator ei;\n-\n-      if (! can_predict_insn_p (last_insn))\n-\tcontinue;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  /* Predict early returns to be probable, as we've already taken\n-\t     care for error returns and other are often used for fast paths\n-\t     trought function.  */\n-\t  if ((e->dest == EXIT_BLOCK_PTR\n-\t       || (single_succ_p (e->dest)\n-\t\t   && single_succ (e->dest) == EXIT_BLOCK_PTR))\n-\t       && !predicted_by_p (bb, PRED_NULL_RETURN)\n-\t       && !predicted_by_p (bb, PRED_CONST_RETURN)\n-\t       && !predicted_by_p (bb, PRED_NEGATIVE_RETURN)\n-\t       && !last_basic_block_p (e->dest))\n-\t    predict_edge_def (e, PRED_EARLY_RETURN, TAKEN);\n-\n-\t  /* Look for block we are guarding (i.e. we dominate it,\n-\t     but it doesn't postdominate us).  */\n-\t  if (e->dest != EXIT_BLOCK_PTR && e->dest != bb\n-\t      && dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n-\t      && !dominated_by_p (CDI_POST_DOMINATORS, e->src, e->dest))\n-\t    {\n-\t      rtx insn;\n-\n-\t      /* The call heuristic claims that a guarded function call\n-\t\t is improbable.  This is because such calls are often used\n-\t\t to signal exceptional situations such as printing error\n-\t\t messages.  */\n-\t      for (insn = BB_HEAD (e->dest); insn != NEXT_INSN (BB_END (e->dest));\n-\t\t   insn = NEXT_INSN (insn))\n-\t\tif (CALL_P (insn)\n-\t\t    /* Constant and pure calls are hardly used to signalize\n-\t\t       something exceptional.  */\n-\t\t    && ! CONST_OR_PURE_CALL_P (insn))\n-\t\t  {\n-\t\t    predict_edge_def (e, PRED_CALL, NOT_TAKEN);\n-\t\t    break;\n-\t\t  }\n-\t    }\n-\t}\n-      bb_estimate_probability_locally (bb);\n-    }\n-\n-  /* Attach the combined probability to each conditional jump.  */\n-  FOR_EACH_BB (bb)\n-    combine_predictions_for_insn (BB_END (bb), bb);\n-\n-  remove_fake_edges ();\n-  estimate_bb_frequencies (loops_info);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n-  if (profile_status == PROFILE_ABSENT)\n-    profile_status = PROFILE_GUESSED;\n-}\n-\n /* Set edge->probability for each successor edge of BB.  */\n void\n guess_outgoing_edge_probabilities (basic_block bb)"}, {"sha": "2f6d8aa5708d47dc503d22570fa1ae2aee072837", "filename": "gcc/profile.c", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d47ea88f3b5a2458f499633f831c65179003f6e/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=3d47ea88f3b5a2458f499633f831c65179003f6e", "patch": "@@ -1336,46 +1336,3 @@ tree_register_profile_hooks (void)\n   profile_hooks = &tree_profile_hooks;\n }\n \n-\f\n-/* Do branch profiling and static profile estimation passes.  */\n-static unsigned int\n-rest_of_handle_branch_prob (void)\n-{\n-  struct loops loops;\n-\n-  /* Discover and record the loop depth at the head of each basic\n-     block.  The loop infrastructure does the real job for us.  */\n-  flow_loops_find (&loops);\n-\n-  if (dump_file)\n-    flow_loops_dump (&loops, dump_file, NULL, 0);\n-\n-  /* Estimate using heuristics if no profiling info is available.  */\n-  if (flag_guess_branch_prob\n-      && profile_status == PROFILE_ABSENT)\n-    estimate_probability (&loops);\n-\n-  flow_loops_free (&loops);\n-  free_dominance_info (CDI_DOMINATORS);\n-  return 0;\n-}\n-\n-struct tree_opt_pass pass_branch_prob =\n-{\n-  \"bp\",                                 /* name */\n-  NULL,                                 /* gate */   \n-  rest_of_handle_branch_prob,           /* execute */       \n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_BRANCH_PROB,                       /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func,                       /* todo_flags_finish */\n-  'b'                                   /* letter */\n-};\n-\n-\n-"}]}