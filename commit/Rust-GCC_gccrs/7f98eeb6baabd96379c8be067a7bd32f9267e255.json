{"sha": "7f98eeb6baabd96379c8be067a7bd32f9267e255", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Y5OGVlYjZiYWFiZDk2Mzc5YzhiZTA2N2E3YmQzMmY5MjY3ZTI1NQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-19T17:07:19Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-19T17:07:19Z"}, "message": "(output_move_double): Handle register overlap\ncase that occur in soft-float XFmode.\n\nFrom-SVN: r5365", "tree": {"sha": "42084feca11f4ab78812839db4c8213296b7eb3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42084feca11f4ab78812839db4c8213296b7eb3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f98eeb6baabd96379c8be067a7bd32f9267e255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f98eeb6baabd96379c8be067a7bd32f9267e255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f98eeb6baabd96379c8be067a7bd32f9267e255", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f98eeb6baabd96379c8be067a7bd32f9267e255/comments", "author": null, "committer": null, "parents": [{"sha": "9edd4689bdc3cab0d69f23afbb12cd726475551a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9edd4689bdc3cab0d69f23afbb12cd726475551a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9edd4689bdc3cab0d69f23afbb12cd726475551a"}], "stats": {"total": 58, "additions": 57, "deletions": 1}, "files": [{"sha": "50e5e03dc9549bd5cb258c6bfed7dcd0eb3a8d6d", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f98eeb6baabd96379c8be067a7bd32f9267e255/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f98eeb6baabd96379c8be067a7bd32f9267e255/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=7f98eeb6baabd96379c8be067a7bd32f9267e255", "patch": "@@ -884,7 +884,9 @@ output_move_double (operands)\n     } optype0, optype1;\n   rtx latehalf[2];\n   rtx middlehalf[2];\n+  rtx xops[2];\n   rtx addreg0 = 0, addreg1 = 0;\n+  int dest_overlapped_low = 0;\n   int size = GET_MODE_SIZE (GET_MODE (operands[0]));\n \n   middlehalf[0] = 0;\n@@ -1066,6 +1068,59 @@ output_move_double (operands)\n       && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n     operands[1] = latehalf[1];\n \n+  /* For (set (reg:DI N) (mem:DI ... (reg:SI N) ...)),\n+     if the upper part of reg N does not appear in the MEM, arrange to\n+     emit the move late-half first.  Otherwise, compute the MEM address\n+     into the upper part of N and use that as a pointer to the memory\n+     operand.  */\n+  if (optype0 == REGOP\n+      && (optype1 == OFFSOP || optype1 == MEMOP))\n+    {\n+      if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n+\t  && reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\t{\n+\t  /* If both halves of dest are used in the src memory address,\n+\t     compute the address into latehalf of dest.  */\n+compadr:\n+\t  xops[0] = latehalf[0];\n+\t  xops[1] = XEXP (operands[1], 0);\n+\t  output_asm_insn (\"lea%L0,%a1,%0\", xops);\n+\t  if( GET_MODE (operands[1]) == XFmode )\n+\t    {\n+\t      operands[1] = gen_rtx (MEM, XFmode, latehalf[0]);\n+\t      middlehalf[1] = adj_offsettable_operand (operands[1], size-8);\n+\t      latehalf[1] = adj_offsettable_operand (operands[1], size-4);\n+\t    }\n+\t  else\n+\t    {\n+\t      operands[1] = gen_rtx (MEM, DImode, latehalf[0]);\n+\t      latehalf[1] = adj_offsettable_operand (operands[1], size-4);\n+\t    }\n+\t}\n+      else if (size == 12\n+\t\t && reg_mentioned_p (middlehalf[0], XEXP (operands[1], 0)))\n+\t{\n+\t  /* Check for two regs used by both source and dest. */\n+\t  if (reg_mentioned_p (operands[0], XEXP (operands[1], 0))\n+\t\t|| reg_mentioned_p (latehalf[0], XEXP (operands[1], 0)))\n+\t\tgoto compadr;\n+\n+\t  /* JRV says this can't happen: */\n+\t  if (addreg0 || addreg1)\n+\t      abort();\n+\n+\t  /* Only the middle reg conflicts; simply put it last. */\n+\t  output_asm_insn (singlemove_string (operands), operands);\n+\t  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n+\t  return \"\";\n+\t}\n+      else if (reg_mentioned_p (operands[0], XEXP (operands[1], 0)))\n+\t/* If the low half of dest is mentioned in the source memory\n+\t   address, the arrange to emit the move late half first.  */\n+\tdest_overlapped_low = 1;\n+    }\n+\n   /* If one or both operands autodecrementing,\n      do the two words, high-numbered first.  */\n \n@@ -1077,7 +1132,8 @@ output_move_double (operands)\n   if (optype0 == PUSHOP || optype1 == PUSHOP\n       || (optype0 == REGOP && optype1 == REGOP\n \t  && ((middlehalf[1] && REGNO (operands[0]) == REGNO (middlehalf[1]))\n-\t      || REGNO (operands[0]) == REGNO (latehalf[1]))))\n+\t      || REGNO (operands[0]) == REGNO (latehalf[1])))\n+      || dest_overlapped_low)\n     {\n       /* Make any unoffsettable addresses point at high-numbered word.  */\n       if (addreg0)"}]}