{"sha": "d3e427f684b0cd7cedbe7b93a06f455e562c5901", "node_id": "C_kwDOANBUbNoAKGQzZTQyN2Y2ODRiMGNkN2NlZGJlN2I5M2EwNmY0NTVlNTYyYzU5MDE", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-02-25T10:55:08Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2023-02-25T10:55:42Z"}, "message": "Fortran: Skip bound conv in gfc_conv_gfc_desc_to_cfi_desc with intent(out) ptr [PR108621]\n\nWhen the dummy argument of the bind(C) proc is 'pointer, intent(out)', the conversion\nof the GFC to the CFI bounds can be skipped: it is not needed and avoids issues with\nnoninit memory.\n\nNote that the 'cfi->base_addr = gfc->addr' assignment is kept as the C code of a user\nmight assume that a nullified pointer arrives as NULL (or even a specific value).\nFor instance, gfortran.dg/c-interop/section-{1,2}.f90 assumes the value NULL.\n\nNote 2: The PR is about a may-be-uninitialized warning with intent(out). In the PR's\ntestcase, the pointer was nullified and should not have produced that warning.\nThat is a diagnostic issue, now tracked as PR middle-end/108906 as the issue in principle\nstill exists (e.g. with 'intent(inout)'). [But no longer for intent(out).]\n\nNote 3: With undefined pointers and no 'intent', accessing uninit memory is unavoidable\non the caller side as the compiler cannot know what the C function does (but this usage\ndetermines whether the pointer is permitted be undefined or whether the bounds must be\ngfc-to-cfi converted).\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/108621\n\t* trans-expr.cc (gfc_conv_gfc_desc_to_cfi_desc): Skip setting of\n\tbounds of CFI desc for 'pointer,intent(out)'.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/108621\n\t* gfortran.dg/c-interop/fc-descriptor-pr108621.f90: New test.", "tree": {"sha": "f3c68b810b06cc09a7c1e5ebe27b5cf90844e3ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3c68b810b06cc09a7c1e5ebe27b5cf90844e3ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3e427f684b0cd7cedbe7b93a06f455e562c5901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e427f684b0cd7cedbe7b93a06f455e562c5901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3e427f684b0cd7cedbe7b93a06f455e562c5901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3e427f684b0cd7cedbe7b93a06f455e562c5901/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4341106354c6a463ce3628a4ef9c1a1d37193b59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4341106354c6a463ce3628a4ef9c1a1d37193b59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4341106354c6a463ce3628a4ef9c1a1d37193b59"}], "stats": {"total": 71, "additions": 71, "deletions": 0}, "files": [{"sha": "045c8b00b9021cece7d37abc6e1277537ba5a26f", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e427f684b0cd7cedbe7b93a06f455e562c5901/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e427f684b0cd7cedbe7b93a06f455e562c5901/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=d3e427f684b0cd7cedbe7b93a06f455e562c5901", "patch": "@@ -5673,6 +5673,9 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n   gfc_add_modify (&block, tmp,\n \t\t  build_int_cst (TREE_TYPE (tmp), attr));\n \n+  /* The cfi-base_addr assignment could be skipped for 'pointer, intent(out)'.\n+     That is very sensible for undefined pointers, but the C code might assume\n+     that the pointer retains the value, in particular, if it was NULL.  */\n   if (e->rank == 0)\n     {\n       tmp = gfc_get_cfi_desc_base_addr (cfi);\n@@ -5695,6 +5698,9 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n       gfc_add_modify (&block, tmp2, fold_convert (TREE_TYPE (tmp2), tmp));\n     }\n \n+  if (fsym->attr.pointer && fsym->attr.intent == INTENT_OUT)\n+    goto done;\n+\n   /* When allocatable + intent out, free the cfi descriptor.  */\n   if (fsym->attr.allocatable && fsym->attr.intent == INTENT_OUT)\n     {"}, {"sha": "9c9062bd62dbcbc5b87c0229e642a68d1d247bbf", "filename": "gcc/testsuite/gfortran.dg/c-interop/fc-descriptor-pr108621.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3e427f684b0cd7cedbe7b93a06f455e562c5901/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-pr108621.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3e427f684b0cd7cedbe7b93a06f455e562c5901/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-pr108621.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Ffc-descriptor-pr108621.f90?ref=d3e427f684b0cd7cedbe7b93a06f455e562c5901", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/108621\n+!\n+! If the bind(C) procedure's dummy argument is a POINTER with INTENT(OUT),\n+! avoid converting the array bounds for the CFI descriptor before the call.\n+!\n+! Rational: Fewer code and, esp. for undefined pointers, there might be a\n+! compile-time warning or a runtime error due to the 'extent' arithmentic\n+! and integer overflows (i.e. random values and -fsanitize=undefined).\n+!\n+! (For disassociated pointers, it would/should be only pointless code as\n+! the bound setting is guarded by a != NULL condtion. However, as the PR shows,\n+! a bogus may-use-uninitialized-memory warning might still be shown in that case.)\n+!\n+! Without 'intent' (but still intent(out) internally), the same applies but\n+! there is nothing the compiler can do on the caller side.\n+! Still, as only uninit memory and not invalid memory it accessed, it should still\n+! work (at least when run-time checking is turned off).\n+!\n+subroutine demo(f)\n+use, intrinsic :: iso_c_binding, only : c_int\n+implicit none\n+\n+interface\n+  subroutine fun(f_p) bind(c)\n+    import c_int\n+    integer(c_int), pointer, intent(out) :: f_p(:)\n+  end subroutine\n+end interface\n+\n+integer(c_int), pointer :: f(:)\n+\n+call fun(f)\n+end\n+\n+! The following ones must be present even with intent(out):\n+!\n+! { dg-final { scan-tree-dump \"cfi...version = 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...rank = 1;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...type = 1025;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...attribute = 0;\" \"original\" } }\n+! { dg-final { scan-tree-dump \"cfi...elem_len = 4;\" \"original\" } }\n+\n+\n+! The following is not needed - but user code might expect that an incoming pointer is NULL\n+! in this case. - At least the GCC testsuite expects this in the C code at\n+!   gfortran.dg/c-interop/section-{1,2}.f90 \n+! Thus, it is kept as it does not cause any harm:\n+!\n+! { dg-final { scan-tree-dump \"cfi...base_addr = f->data;\" \"original\" } }\n+\n+\n+! The following ones are not need with intent(out) and, therefore, shouldn't be there:\n+!\n+!     cfi.0.dim[idx.1].lower_bound = f->dim[idx.1].lbound;\n+!     cfi.0.dim[idx.1].extent = (f->dim[idx.1].ubound - f->dim[idx.1].lbound) + 1;\n+!     cfi.0.dim[idx.1].sm = f->dim[idx.1].stride * f->span;\n+!\n+! Now match those - but using a rather generic pattern as it is a ...-not scan:\n+!\n+! { dg-final { scan-tree-dump-not \"lower_bound = \" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"extent = \" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"sm = \" \"original\" } }"}]}