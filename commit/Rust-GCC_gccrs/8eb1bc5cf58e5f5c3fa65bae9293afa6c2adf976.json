{"sha": "8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGViMWJjNWNmNThlNWY1YzNmYTY1YmFlOTI5M2FmYTZjMmFkZjk3Ng==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2005-03-21T18:08:32Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2005-03-21T18:08:32Z"}, "message": "xtensa-protos.h: (xtensa_simm7...\n\n\t* config/xtensa/xtensa-protos.h: (xtensa_simm7, xtensa_uimm8,\n\txtensa_uimm8x2, xtensa_uimm8x4, xtensa_ai4const, xtensa_lsi4x4,\n\txtensa_b4const): Delete prototypes.\n\t(xtensa_simm8, xtensa_simm8x256, xtensa_simm12b, xtensa_b4constu,\n\txtensa_mask_immediate, xtensa_mem_offset): Update prototypes.\n\t(xtensa_b4const_or_zero, xtensa_const_ok_for_letter_p,\n\txtensa_extra_constraint): New prototypes.\n\t(add_operand, arith_operand, nonimmed_operand, mem_operand,\n\tmask_operand, extui_fldsz_operand, sext_operand, sext_fldsz_operand,\n\tlsbitnum_operand, branch_operand, ubranch_operand, call_insn_operand,\n\tmove_operand, const_float_1_operand, fpmem_offset_operand,\n\tbranch_operator, ubranch_operator, boolean_operator): Delete prototypes.\n\t* config/xtensa/xtensa.c (b4const_or_zero): Rename to ...\n\t(xtensa_b4const_or_zero): ...this.  Change return type to bool and\n\targument type to HOST_WIDE_INT.\n\t(xtensa_simm8, xtensa_simm8x256, xtensa_simm12b,\n\txtensa_mask_immediate): Likewise.\n\t(xtensa_uimm8, xtensa_uimm8x2, xtensa_uimm8x4, xtensa_b4const):\n\tLikewise.  Also make these functions static.\n\t(xtensa_simm7, xtensa_ai4const, xtensa_lsi4x4): Delete.\n\t(xtensa_const_ok_for_letter_p): New.\n\t(add_operand, arith_operand, nonimmed_operand, mem_operand,\n\tmask_operand, extui_fldsz_operand, sext_operand, sext_fldsz_operand,\n\tlsbitnum_operand, branch_operand, ubranch_operand, call_insn_operand,\n\tmove_operand, const_float_1_operand, fpmem_offset_operand,\n\tbranch_operator, ubranch_operator, boolean_operator): Move to\n\tpredicates.md.\n\t(smalloffset_mem_p): Inline code from xtensa_lsi4x4.\n\t(xtensa_mem_offset): Change return type to bool.\n\t(xtensa_extra_constraint): New.\n\t(gen_int_relational): Update type of const_range_p function pointer.\n\tUse xtensa_b4const_or_zero.\n\t* config/xtensa/xtensa.h (CONST_OK_FOR_LETTER_P): Define to\n\txtensa_const_ok_for_letter_p.  Update comments.\n\t(EXTRA_CONSTRAINT): Define to xtensa_extra_constraint.\n\t(PREDICATE_CODES): Delete.\n\t* config/xtensa/xtensa.md: Include predicates.md.\n\t* config/xtensa/predicates.md: New file.\n\nFrom-SVN: r96824", "tree": {"sha": "420cf3f94815b5de30375d1ed5dd636e1beb3dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/420cf3f94815b5de30375d1ed5dd636e1beb3dea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/comments", "author": null, "committer": null, "parents": [{"sha": "c69002727561c79e9cf16e165652a4bd99020611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c69002727561c79e9cf16e165652a4bd99020611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c69002727561c79e9cf16e165652a4bd99020611"}], "stats": {"total": 824, "additions": 342, "deletions": 482}, "files": [{"sha": "e86cd11cfb17c98b4b524e28c714658d1936fa65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "patch": "@@ -1,3 +1,44 @@\n+2005-03-21  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa-protos.h: (xtensa_simm7, xtensa_uimm8,\n+\txtensa_uimm8x2, xtensa_uimm8x4, xtensa_ai4const, xtensa_lsi4x4,\n+\txtensa_b4const): Delete prototypes.\n+\t(xtensa_simm8, xtensa_simm8x256, xtensa_simm12b, xtensa_b4constu,\n+\txtensa_mask_immediate, xtensa_mem_offset): Update prototypes.\n+\t(xtensa_b4const_or_zero, xtensa_const_ok_for_letter_p,\n+\txtensa_extra_constraint): New prototypes.\n+\t(add_operand, arith_operand, nonimmed_operand, mem_operand,\n+\tmask_operand, extui_fldsz_operand, sext_operand, sext_fldsz_operand,\n+\tlsbitnum_operand, branch_operand, ubranch_operand, call_insn_operand,\n+\tmove_operand, const_float_1_operand, fpmem_offset_operand,\n+\tbranch_operator, ubranch_operator, boolean_operator): Delete prototypes.\n+\t* config/xtensa/xtensa.c (b4const_or_zero): Rename to ...\n+\t(xtensa_b4const_or_zero): ...this.  Change return type to bool and\n+\targument type to HOST_WIDE_INT.\n+\t(xtensa_simm8, xtensa_simm8x256, xtensa_simm12b,\n+\txtensa_mask_immediate): Likewise.\n+\t(xtensa_uimm8, xtensa_uimm8x2, xtensa_uimm8x4, xtensa_b4const):\n+\tLikewise.  Also make these functions static.\n+\t(xtensa_simm7, xtensa_ai4const, xtensa_lsi4x4): Delete.\n+\t(xtensa_const_ok_for_letter_p): New.\n+\t(add_operand, arith_operand, nonimmed_operand, mem_operand,\n+\tmask_operand, extui_fldsz_operand, sext_operand, sext_fldsz_operand,\n+\tlsbitnum_operand, branch_operand, ubranch_operand, call_insn_operand,\n+\tmove_operand, const_float_1_operand, fpmem_offset_operand,\n+\tbranch_operator, ubranch_operator, boolean_operator): Move to\n+\tpredicates.md.\n+\t(smalloffset_mem_p): Inline code from xtensa_lsi4x4.\n+\t(xtensa_mem_offset): Change return type to bool.\n+\t(xtensa_extra_constraint): New.\n+\t(gen_int_relational): Update type of const_range_p function pointer.\n+\tUse xtensa_b4const_or_zero.\n+\t* config/xtensa/xtensa.h (CONST_OK_FOR_LETTER_P): Define to\n+\txtensa_const_ok_for_letter_p.  Update comments.\n+\t(EXTRA_CONSTRAINT): Define to xtensa_extra_constraint.\n+\t(PREDICATE_CODES): Delete.\n+\t* config/xtensa/xtensa.md: Include predicates.md.\n+\t* config/xtensa/predicates.md: New file.\n+\n 2005-03-21  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/v850/v850-protos.h: Remove the prototypes for"}, {"sha": "335584d00e15a6c0f6144cf50fd90a5427e61665", "filename": "gcc/config/xtensa/predicates.md", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fpredicates.md?ref=8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "patch": "@@ -0,0 +1,157 @@\n+;; Predicate definitions for Xtensa.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_predicate \"add_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"xtensa_simm8 (INTVAL (op))\n+\t\t\t || xtensa_simm8x256 (INTVAL (op))\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"arith_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"xtensa_simm8 (INTVAL (op))\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Non-immediate operand excluding the constant pool.\n+(define_predicate \"nonimmed_operand\"\n+  (ior (and (match_operand 0 \"memory_operand\")\n+\t    (match_test \"!constantpool_address_p (XEXP (op, 0))\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+;; Memory operand excluding the constant pool.\n+(define_predicate \"mem_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (match_test \"!constantpool_address_p (XEXP (op, 0))\")))\n+\n+(define_predicate \"mask_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"xtensa_mask_immediate (INTVAL (op))\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"extui_fldsz_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"xtensa_mask_immediate ((1 << INTVAL (op)) - 1)\")))\n+\n+(define_predicate \"sext_operand\"\n+  (if_then_else (match_test \"TARGET_SEXT\")\n+\t\t(match_operand 0 \"nonimmed_operand\")\n+\t\t(match_operand 0 \"mem_operand\")))\n+\n+(define_predicate \"sext_fldsz_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 8 && INTVAL (op) <= 23\")))\n+\n+(define_predicate \"lsbitnum_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"BITS_BIG_ENDIAN\n+\t\t    ? (INTVAL (op) == BITS_PER_WORD - 1)\n+\t\t    : (INTVAL (op) == 0)\")))\n+\n+(define_predicate \"branch_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"xtensa_b4const_or_zero (INTVAL (op))\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"ubranch_operand\"\n+  (ior (and (match_code \"const_int\")\n+\t    (match_test \"xtensa_b4constu (INTVAL (op))\"))\n+       (match_operand 0 \"register_operand\")))\n+\n+(define_predicate \"call_insn_operand\"\n+  (match_code \"const_int,const,symbol_ref,reg\")\n+{\n+  if ((GET_CODE (op) == REG)\n+      && (op != arg_pointer_rtx)\n+      && ((REGNO (op) < FRAME_POINTER_REGNUM)\n+\t  || (REGNO (op) > LAST_VIRTUAL_REGISTER)))\n+    return true;\n+\n+  if (CONSTANT_ADDRESS_P (op))\n+    {\n+      /* Direct calls only allowed to static functions with PIC.  */\n+      if (flag_pic)\n+\t{\n+\t  tree callee, callee_sec, caller_sec;\n+\n+\t  if (GET_CODE (op) != SYMBOL_REF\n+\t      || !SYMBOL_REF_LOCAL_P (op) || SYMBOL_REF_EXTERNAL_P (op))\n+\t    return false;\n+\n+\t  /* Don't attempt a direct call if the callee is known to be in\n+\t     a different section, since there's a good chance it will be\n+\t     out of range.  */\n+\n+\t  if (flag_function_sections\n+\t      || DECL_ONE_ONLY (current_function_decl))\n+\t    return false;\n+\t  caller_sec = DECL_SECTION_NAME (current_function_decl);\n+\t  callee = SYMBOL_REF_DECL (op);\n+\t  if (callee)\n+\t    {\n+\t      if (DECL_ONE_ONLY (callee))\n+\t\treturn false;\n+\t      callee_sec = DECL_SECTION_NAME (callee);\n+\t      if (((caller_sec == NULL_TREE) ^ (callee_sec == NULL_TREE))\n+\t\t  || (caller_sec != NULL_TREE\n+\t\t      && strcmp (TREE_STRING_POINTER (caller_sec),\n+\t\t\t\t TREE_STRING_POINTER (callee_sec)) != 0))\n+\t\treturn false;\n+\t    }\n+\t  else if (caller_sec != NULL_TREE)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  return false;\n+})\n+\n+(define_predicate \"move_operand\"\n+  (ior\n+     (ior (match_operand 0 \"register_operand\")\n+\t  (match_operand 0 \"memory_operand\"))\n+     (ior (and (match_code \"const_int\")\n+\t       (match_test \"GET_MODE_CLASS (mode) == MODE_INT\n+\t\t\t    && xtensa_simm12b (INTVAL (op))\"))\n+\t  (and (match_code \"const_int,const_double,const,symbol_ref,label_ref\")\n+\t       (match_test \"TARGET_CONST16 && CONSTANT_P (op)\n+\t\t\t    && GET_MODE_SIZE (mode) % UNITS_PER_WORD == 0\")))))\n+\n+;; Accept the floating point constant 1 in the appropriate mode.\n+(define_predicate \"const_float_1_operand\"\n+  (match_code \"const_double\")\n+{\n+  REAL_VALUE_TYPE d;\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+  return REAL_VALUES_EQUAL (d, dconst1);\n+})\n+\n+(define_predicate \"fpmem_offset_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"xtensa_mem_offset (INTVAL (op), SFmode)\")))\n+\n+(define_predicate \"branch_operator\"\n+  (match_code \"eq,ne,lt,ge\"))\n+\n+(define_predicate \"ubranch_operator\"\n+  (match_code \"ltu,geu\"))\n+\n+(define_predicate \"boolean_operator\"\n+  (match_code \"eq,ne\"))"}, {"sha": "5f19ebfe028a3c6fe084c6c6043c3be80ab863ca", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes of target machine for GNU compiler for Xtensa.\n-   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n This file is part of GCC.\n@@ -23,45 +23,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define __XTENSA_PROTOS_H__\n \n /* Functions to test whether an immediate fits in a given field.  */\n-extern int xtensa_simm7 (int);\n-extern int xtensa_simm8 (int);\n-extern int xtensa_simm8x256 (int);\n-extern int xtensa_simm12b (int);\n-extern int xtensa_uimm8 (int);\n-extern int xtensa_uimm8x2 (int);\n-extern int xtensa_uimm8x4 (int);\n-extern int xtensa_ai4const (int);\n-extern int xtensa_lsi4x4 (int);\n-extern int xtensa_b4const (int);\n-extern int xtensa_b4constu (int);\n-extern int xtensa_tp7 (int);\n+extern bool xtensa_simm8 (HOST_WIDE_INT);\n+extern bool xtensa_simm8x256 (HOST_WIDE_INT);\n+extern bool xtensa_simm12b (HOST_WIDE_INT);\n+extern bool xtensa_b4const_or_zero (HOST_WIDE_INT);\n+extern bool xtensa_b4constu (HOST_WIDE_INT);\n+extern bool xtensa_mask_immediate (HOST_WIDE_INT);\n+extern bool xtensa_const_ok_for_letter_p (HOST_WIDE_INT, int);\n+extern bool xtensa_mem_offset (unsigned, enum machine_mode);\n \n /* Functions within xtensa.c that we reference.  */\n #ifdef RTX_CODE\n extern int xt_true_regnum (rtx);\n-extern int add_operand (rtx, enum machine_mode);\n-extern int arith_operand (rtx, enum machine_mode);\n-extern int nonimmed_operand (rtx, enum machine_mode);\n-extern int mem_operand (rtx, enum machine_mode);\n extern int xtensa_valid_move (enum machine_mode, rtx *);\n-extern int mask_operand (rtx, enum machine_mode);\n-extern int extui_fldsz_operand (rtx, enum machine_mode);\n-extern int sext_operand (rtx, enum machine_mode);\n-extern int sext_fldsz_operand (rtx, enum machine_mode);\n-extern int lsbitnum_operand (rtx, enum machine_mode);\n-extern int branch_operand (rtx, enum machine_mode);\n-extern int ubranch_operand (rtx, enum machine_mode);\n-extern int call_insn_operand (rtx, enum machine_mode);\n-extern int move_operand (rtx, enum machine_mode);\n extern int smalloffset_mem_p (rtx);\n extern int constantpool_address_p (rtx);\n extern int constantpool_mem_p (rtx);\n-extern int const_float_1_operand (rtx, enum machine_mode);\n-extern int fpmem_offset_operand (rtx, enum machine_mode);\n extern void xtensa_extend_reg (rtx, rtx);\n-extern int branch_operator (rtx, enum machine_mode);\n-extern int ubranch_operator (rtx, enum machine_mode);\n-extern int boolean_operator (rtx, enum machine_mode);\n+extern bool xtensa_extra_constraint (rtx, int);\n extern void xtensa_expand_conditional_branch (rtx *, enum rtx_code);\n extern int xtensa_expand_conditional_move (rtx *, int);\n extern int xtensa_expand_scc (rtx *);\n@@ -94,8 +73,6 @@ extern struct rtx_def *function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t     tree, int);\n #endif /* TREE_CODE */\n \n-extern int xtensa_mask_immediate (int);\n-extern int xtensa_mem_offset (unsigned, enum machine_mode);\n extern void xtensa_setup_frame_addresses (void);\n extern int xtensa_dbx_register_number (int);\n extern void override_options (void);"}, {"sha": "cdba18c8388eae9a0d08aecf757f48979e09704d", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 120, "deletions": 388, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Tensilica's Xtensa architecture.\n-   Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n This file is part of GCC.\n@@ -192,7 +192,6 @@ enum reg_class xtensa_char_to_class[256] =\n   NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n };\n \n-static int b4const_or_zero (int);\n static enum internal_test map_test_to_internal_test (enum rtx_code);\n static rtx gen_int_relational (enum rtx_code, rtx, rtx, int *);\n static rtx gen_float_relational (enum rtx_code, rtx, rtx);\n@@ -270,13 +269,55 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n  * Functions to test Xtensa immediate operand validity.\n  */\n \n-int\n-xtensa_b4constu (int v)\n+bool\n+xtensa_simm8 (HOST_WIDE_INT v)\n+{\n+  return v >= -128 && v <= 127;\n+}\n+\n+\n+bool\n+xtensa_simm8x256 (HOST_WIDE_INT v)\n+{\n+  return (v & 255) == 0 && (v >= -32768 && v <= 32512);\n+}\n+\n+\n+bool\n+xtensa_simm12b (HOST_WIDE_INT v)\n+{\n+  return v >= -2048 && v <= 2047;\n+}\n+\n+\n+static bool\n+xtensa_uimm8 (HOST_WIDE_INT v)\n+{\n+  return v >= 0 && v <= 255;\n+}\n+\n+\n+static bool\n+xtensa_uimm8x2 (HOST_WIDE_INT v)\n+{\n+  return (v & 1) == 0 && (v >= 0 && v <= 510);\n+}\n+\n+\n+static bool\n+xtensa_uimm8x4 (HOST_WIDE_INT v)\n+{\n+  return (v & 3) == 0 && (v >= 0 && v <= 1020);\n+}\n+\n+\n+static bool\n+xtensa_b4const (HOST_WIDE_INT v)\n {\n   switch (v)\n     {\n-    case 32768:\n-    case 65536:\n+    case -1:\n+    case 1:\n     case 2:\n     case 3:\n     case 4:\n@@ -291,36 +332,28 @@ xtensa_b4constu (int v)\n     case 64:\n     case 128:\n     case 256:\n-      return 1;\n+      return true;\n     }\n-  return 0;\n+  return false;\n }\n \n-int\n-xtensa_simm8x256 (int v)\n-{\n-  return (v & 255) == 0 && (v >= -32768 && v <= 32512);\n-}\n \n-int\n-xtensa_ai4const (int v)\n+bool\n+xtensa_b4const_or_zero (HOST_WIDE_INT v)\n {\n-  return (v == -1 || (v >= 1 && v <= 15));\n+  if (v == 0)\n+    return true;\n+  return xtensa_b4const (v);\n }\n \n-int\n-xtensa_simm7 (int v)\n-{\n-  return v >= -32 && v <= 95;\n-}\n \n-int\n-xtensa_b4const (int v)\n+bool\n+xtensa_b4constu (HOST_WIDE_INT v)\n {\n   switch (v)\n     {\n-    case -1:\n-    case 1:\n+    case 32768:\n+    case 65536:\n     case 2:\n     case 3:\n     case 4:\n@@ -335,51 +368,47 @@ xtensa_b4const (int v)\n     case 64:\n     case 128:\n     case 256:\n-      return 1;\n+      return true;\n     }\n-  return 0;\n+  return false;\n }\n \n-int\n-xtensa_simm8 (int v)\n-{\n-  return v >= -128 && v <= 127;\n-}\n-\n-int\n-xtensa_tp7 (int v)\n-{\n-  return (v >= 7 && v <= 22);\n-}\n \n-int\n-xtensa_lsi4x4 (int v)\n+bool\n+xtensa_mask_immediate (HOST_WIDE_INT v)\n {\n-  return (v & 3) == 0 && (v >= 0 && v <= 60);\n-}\n+#define MAX_MASK_SIZE 16\n+  int mask_size;\n \n-int\n-xtensa_simm12b (int v)\n-{\n-  return v >= -2048 && v <= 2047;\n-}\n+  for (mask_size = 1; mask_size <= MAX_MASK_SIZE; mask_size++)\n+    {\n+      if ((v & 1) == 0)\n+\treturn false;\n+      v = v >> 1;\n+      if (v == 0)\n+\treturn true;\n+    }\n \n-int\n-xtensa_uimm8 (int v)\n-{\n-  return v >= 0 && v <= 255;\n+  return false;\n }\n \n-int\n-xtensa_uimm8x2 (int v)\n-{\n-  return (v & 1) == 0 && (v >= 0 && v <= 510);\n-}\n \n-int\n-xtensa_uimm8x4 (int v)\n+bool\n+xtensa_const_ok_for_letter_p (HOST_WIDE_INT v, int c)\n {\n-  return (v & 3) == 0 && (v >= 0 && v <= 1020);\n+  switch (c)\n+    {\n+    case 'I': return xtensa_simm12b (v);\n+    case 'J': return xtensa_simm8 (v);\n+    case 'K': return (v == 0 || xtensa_b4const (v));\n+    case 'L': return xtensa_b4constu (v);\n+    case 'M': return (v >= -32 && v <= 95);\n+    case 'N': return xtensa_simm8x256 (v);\n+    case 'O': return (v == -1 || (v >= 1 && v <= 15));\n+    case 'P': return xtensa_mask_immediate (v);\n+    default: break;\n+    }\n+  return false;\n }\n \n \n@@ -409,52 +438,6 @@ xt_true_regnum (rtx x)\n }\n \n \n-int\n-add_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return (xtensa_simm8 (INTVAL (op)) || xtensa_simm8x256 (INTVAL (op)));\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-int\n-arith_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return xtensa_simm8 (INTVAL (op));\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-int\n-nonimmed_operand (rtx op, enum machine_mode mode)\n-{\n-  /* We cannot use the standard nonimmediate_operand() predicate because\n-     it includes constant pool memory operands.  */\n-\n-  if (memory_operand (op, mode))\n-    return !constantpool_address_p (XEXP (op, 0));\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-int\n-mem_operand (rtx op, enum machine_mode mode)\n-{\n-  /* We cannot use the standard memory_operand() predicate because\n-     it includes constant pool memory operands.  */\n-\n-  if (memory_operand (op, mode))\n-    return !constantpool_address_p (XEXP (op, 0));\n-\n-  return FALSE;\n-}\n-\n-\n int\n xtensa_valid_move (enum machine_mode mode, rtx *operands)\n {\n@@ -484,165 +467,6 @@ xtensa_valid_move (enum machine_mode mode, rtx *operands)\n }\n \n \n-int\n-mask_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return xtensa_mask_immediate (INTVAL (op));\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-int\n-extui_fldsz_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ((GET_CODE (op) == CONST_INT)\n-\t  && xtensa_mask_immediate ((1 << INTVAL (op)) - 1));\n-}\n-\n-\n-int\n-sext_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_SEXT)\n-    return nonimmed_operand (op, mode);\n-  return mem_operand (op, mode);\n-}\n-\n-\n-int\n-sext_fldsz_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return ((GET_CODE (op) == CONST_INT) && xtensa_tp7 (INTVAL (op) - 1));\n-}\n-\n-\n-int\n-lsbitnum_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      return (BITS_BIG_ENDIAN\n-\t      ? (INTVAL (op) == BITS_PER_WORD-1)\n-\t      : (INTVAL (op) == 0));\n-    }\n-  return FALSE;\n-}\n-\n-\n-static int\n-b4const_or_zero (int v)\n-{\n-  if (v == 0)\n-    return TRUE;\n-  return xtensa_b4const (v);\n-}\n-\n-\n-int\n-branch_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return b4const_or_zero (INTVAL (op));\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-int\n-ubranch_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return xtensa_b4constu (INTVAL (op));\n-\n-  return register_operand (op, mode);\n-}\n-\n-\n-int\n-call_insn_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if ((GET_CODE (op) == REG)\n-      && (op != arg_pointer_rtx)\n-      && ((REGNO (op) < FRAME_POINTER_REGNUM)\n-\t  || (REGNO (op) > LAST_VIRTUAL_REGISTER)))\n-    return TRUE;\n-\n-  if (CONSTANT_ADDRESS_P (op))\n-    {\n-      /* Direct calls only allowed to static functions with PIC.  */\n-      if (flag_pic)\n-\t{\n-\t  tree callee, callee_sec, caller_sec;\n-\n-\t  if (GET_CODE (op) != SYMBOL_REF\n-\t      || !SYMBOL_REF_LOCAL_P (op) || SYMBOL_REF_EXTERNAL_P (op))\n-\t    return FALSE;\n-\n-\t  /* Don't attempt a direct call if the callee is known to be in\n-\t     a different section, since there's a good chance it will be\n-\t     out of range.  */\n-\n-\t  if (flag_function_sections\n-\t      || DECL_ONE_ONLY (current_function_decl))\n-\t    return FALSE;\n-\t  caller_sec = DECL_SECTION_NAME (current_function_decl);\n-\t  callee = SYMBOL_REF_DECL (op);\n-\t  if (callee)\n-\t    {\n-\t      if (DECL_ONE_ONLY (callee))\n-\t\treturn FALSE;\n-\t      callee_sec = DECL_SECTION_NAME (callee);\n-\t      if (((caller_sec == NULL_TREE) ^ (callee_sec == NULL_TREE))\n-\t\t  || (caller_sec != NULL_TREE\n-\t\t      && strcmp (TREE_STRING_POINTER (caller_sec),\n-\t\t\t\t TREE_STRING_POINTER (callee_sec)) != 0))\n-\t\treturn FALSE;\n-\t    }\n-\t  else if (caller_sec != NULL_TREE)\n-\t    return FALSE;\n-\t}\n-      return TRUE;\n-    }\n-\n-  return FALSE;\n-}\n-\n-\n-int\n-move_operand (rtx op, enum machine_mode mode)\n-{\n-  if (register_operand (op, mode)\n-      || memory_operand (op, mode))\n-    return TRUE;\n-\n-  switch (mode)\n-    {\n-    case DFmode:\n-    case SFmode:\n-      return TARGET_CONST16 && CONSTANT_P (op);\n-\n-    case DImode:\n-    case SImode:\n-      if (TARGET_CONST16)\n-\treturn CONSTANT_P (op);\n-      /* Fall through.  */\n-\n-    case HImode:\n-    case QImode:\n-      if (GET_CODE (op) == CONST_INT && xtensa_simm12b (INTVAL (op)))\n-\treturn TRUE;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return FALSE;\n-}\n-\n-\n int\n smalloffset_mem_p (rtx op)\n {\n@@ -654,11 +478,14 @@ smalloffset_mem_p (rtx op)\n       if (GET_CODE (addr) == PLUS)\n \t{\n \t  rtx offset = XEXP (addr, 0);\n+\t  HOST_WIDE_INT val;\n \t  if (GET_CODE (offset) != CONST_INT)\n \t    offset = XEXP (addr, 1);\n \t  if (GET_CODE (offset) != CONST_INT)\n \t    return FALSE;\n-\t  return xtensa_lsi4x4 (INTVAL (offset));\n+\n+\t  val = INTVAL (offset);\n+\t  return (val & 3) == 0 && (val >= 0 && val <= 60);\n \t}\n     }\n   return FALSE;\n@@ -704,46 +531,6 @@ constantpool_mem_p (rtx op)\n }\n \n \n-/* Accept the floating point constant 1 in the appropriate mode.  */\n-\n-int\n-const_float_1_operand (rtx op, enum machine_mode mode)\n-{\n-  REAL_VALUE_TYPE d;\n-  static REAL_VALUE_TYPE onedf;\n-  static REAL_VALUE_TYPE onesf;\n-  static int one_initialized;\n-\n-  if ((GET_CODE (op) != CONST_DOUBLE)\n-      || (mode != GET_MODE (op))\n-      || (mode != DFmode && mode != SFmode))\n-    return FALSE;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n-\n-  if (! one_initialized)\n-    {\n-      onedf = REAL_VALUE_ATOF (\"1.0\", DFmode);\n-      onesf = REAL_VALUE_ATOF (\"1.0\", SFmode);\n-      one_initialized = TRUE;\n-    }\n-\n-  if (mode == DFmode)\n-    return REAL_VALUES_EQUAL (d, onedf);\n-  else\n-    return REAL_VALUES_EQUAL (d, onesf);\n-}\n-\n-\n-int\n-fpmem_offset_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return xtensa_mem_offset (INTVAL (op), SFmode);\n-  return 0;\n-}\n-\n-\n void\n xtensa_extend_reg (rtx dst, rtx src)\n {\n@@ -759,82 +546,7 @@ xtensa_extend_reg (rtx dst, rtx src)\n }\n \n \n-int\n-branch_operator (rtx x, enum machine_mode mode)\n-{\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case EQ:\n-    case NE:\n-    case LT:\n-    case GE:\n-      return TRUE;\n-    default:\n-      break;\n-    }\n-  return FALSE;\n-}\n-\n-\n-int\n-ubranch_operator (rtx x, enum machine_mode mode)\n-{\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case LTU:\n-    case GEU:\n-      return TRUE;\n-    default:\n-      break;\n-    }\n-  return FALSE;\n-}\n-\n-\n-int\n-boolean_operator (rtx x, enum machine_mode mode)\n-{\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  switch (GET_CODE (x))\n-    {\n-    case EQ:\n-    case NE:\n-      return TRUE;\n-    default:\n-      break;\n-    }\n-  return FALSE;\n-}\n-\n-\n-int\n-xtensa_mask_immediate (int v)\n-{\n-#define MAX_MASK_SIZE 16\n-  int mask_size;\n-\n-  for (mask_size = 1; mask_size <= MAX_MASK_SIZE; mask_size++)\n-    {\n-      if ((v & 1) == 0)\n-\treturn FALSE;\n-      v = v >> 1;\n-      if (v == 0)\n-\treturn TRUE;\n-    }\n-\n-  return FALSE;\n-}\n-\n-\n-int\n+bool\n xtensa_mem_offset (unsigned v, enum machine_mode mode)\n {\n   switch (mode)\n@@ -865,6 +577,26 @@ xtensa_mem_offset (unsigned v, enum machine_mode mode)\n }\n \n \n+bool\n+xtensa_extra_constraint (rtx op, int c)\n+{\n+  /* Allow pseudo registers during reload.  */\n+  if (GET_CODE (op) != MEM)\n+    return (c >= 'R' && c <= 'U'\n+\t    && reload_in_progress && GET_CODE (op) == REG\n+\t    && REGNO (op) >= FIRST_PSEUDO_REGISTER);\n+\n+  switch (c)\n+    {\n+    case 'R': return smalloffset_mem_p (op);\n+    case 'T': return !TARGET_CONST16 && constantpool_mem_p (op);\n+    case 'U': return !constantpool_mem_p (op);\n+    default: break;\n+    }\n+  return false;\n+}\n+\n+\n /* Make normal rtx_code into something we can index from an array.  */\n \n static enum internal_test\n@@ -903,7 +635,7 @@ gen_int_relational (enum rtx_code test_code, /* relational test (EQ, etc) */\n   struct cmp_info\n   {\n     enum rtx_code test_code;\t/* test code to use in insn */\n-    int (*const_range_p) (int);\t/* predicate function to check range */\n+    bool (*const_range_p) (HOST_WIDE_INT); /* range check function */\n     int const_add;\t\t/* constant to add (convert LE -> LT) */\n     int reverse_regs;\t\t/* reverse registers in test */\n     int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n@@ -913,13 +645,13 @@ gen_int_relational (enum rtx_code test_code, /* relational test (EQ, etc) */\n \n   static struct cmp_info info[ (int)ITEST_MAX ] = {\n \n-    { EQ,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* EQ  */\n-    { NE,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* NE  */\n+    { EQ,\txtensa_b4const_or_zero,\t0, 0, 0, 0, 0 },\t/* EQ  */\n+    { NE,\txtensa_b4const_or_zero,\t0, 0, 0, 0, 0 },\t/* NE  */\n \n-    { LT,\tb4const_or_zero,\t1, 1, 1, 0, 0 },\t/* GT  */\n-    { GE,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* GE  */\n-    { LT,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* LT  */\n-    { GE,\tb4const_or_zero,\t1, 1, 1, 0, 0 },\t/* LE  */\n+    { LT,\txtensa_b4const_or_zero,\t1, 1, 1, 0, 0 },\t/* GT  */\n+    { GE,\txtensa_b4const_or_zero,\t0, 0, 0, 0, 0 },\t/* GE  */\n+    { LT,\txtensa_b4const_or_zero,\t0, 0, 0, 0, 0 },\t/* LT  */\n+    { GE,\txtensa_b4const_or_zero,\t1, 1, 1, 0, 0 },\t/* LE  */\n \n     { LTU,\txtensa_b4constu,\t1, 1, 1, 0, 1 },\t/* GTU */\n     { GEU,\txtensa_b4constu,\t0, 0, 0, 0, 1 },\t/* GEU */"}, {"sha": "ebaed273d14f63926cbc3b482e65ae9c1342bc8f", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 9, "deletions": 61, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "patch": "@@ -545,29 +545,16 @@ extern enum reg_class xtensa_char_to_class[256];\n \n    For Xtensa:\n \n-   I = 12-bit signed immediate for movi\n-   J = 8-bit signed immediate for addi\n+   I = 12-bit signed immediate for MOVI\n+   J = 8-bit signed immediate for ADDI\n    K = 4-bit value in (b4const U {0})\n    L = 4-bit value in b4constu\n-   M = 7-bit value in simm7\n-   N = 8-bit unsigned immediate shifted left by 8 bits for addmi\n-   O = 4-bit value in ai4const\n-   P = valid immediate mask value for extui */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  ((C) == 'I' ? (xtensa_simm12b (VALUE))\t\t\t\t\\\n-   : (C) == 'J' ? (xtensa_simm8 (VALUE))\t\t\t\t\\\n-   : (C) == 'K' ? (((VALUE) == 0) || xtensa_b4const (VALUE))\t\t\\\n-   : (C) == 'L' ? (xtensa_b4constu (VALUE))\t\t\t\t\\\n-   : (C) == 'M' ? (xtensa_simm7 (VALUE))\t\t\t\t\\\n-   : (C) == 'N' ? (xtensa_simm8x256 (VALUE))\t\t\t\t\\\n-   : (C) == 'O' ? (xtensa_ai4const (VALUE))\t\t\t\t\\\n-   : (C) == 'P' ? (xtensa_mask_immediate (VALUE))\t\t\t\\\n-   : FALSE)\n-\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+   M = 7-bit immediate value for MOVI.N\n+   N = 8-bit unsigned immediate shifted left by 8 bits for ADDMI\n+   O = 4-bit immediate for ADDI.N\n+   P = valid immediate mask value for EXTUI */\n+\n+#define CONST_OK_FOR_LETTER_P  xtensa_const_ok_for_letter_p\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) (0)\n \n \n@@ -591,15 +578,7 @@ extern enum reg_class xtensa_char_to_class[256];\n    address will be checked anyway because of the code in\n    GO_IF_LEGITIMATE_ADDRESS.  */\n \n-#define EXTRA_CONSTRAINT(OP, CODE)\t\t\t\t\t\\\n-  ((GET_CODE (OP) != MEM) ?\t\t\t\t\t\t\\\n-       ((CODE) >= 'R' && (CODE) <= 'U'\t\t\t\t\t\\\n-\t&& reload_in_progress && GET_CODE (OP) == REG\t\t\t\\\n-        && REGNO (OP) >= FIRST_PSEUDO_REGISTER)\t\t\t\t\\\n-   : ((CODE) == 'R') ? smalloffset_mem_p (OP)\t\t\t\t\\\n-   : ((CODE) == 'T') ? !TARGET_CONST16 && constantpool_mem_p (OP)\t\\\n-   : ((CODE) == 'U') ? !constantpool_mem_p (OP)\t\t\t\t\\\n-   : FALSE)\n+#define EXTRA_CONSTRAINT  xtensa_extra_constraint\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n   xtensa_preferred_reload_class (X, CLASS, 0)\n@@ -1149,37 +1128,6 @@ typedef struct xtensa_args\n \n #define BRANCH_COST 3\n \n-/* Optionally define this if you have added predicates to\n-   'MACHINE.c'.  This macro is called within an initializer of an\n-   array of structures.  The first field in the structure is the\n-   name of a predicate and the second field is an array of rtl\n-   codes.  For each predicate, list all rtl codes that can be in\n-   expressions matched by the predicate.  The list should have a\n-   trailing comma.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"add_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"nonimmed_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n-  {\"mem_operand\",\t\t{ MEM }},\t\t\t\t\\\n-  {\"mask_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"extui_fldsz_operand\",\t{ CONST_INT }},\t\t\t\t\\\n-  {\"sext_fldsz_operand\",\t{ CONST_INT }},\t\t\t\t\\\n-  {\"lsbitnum_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"fpmem_offset_operand\",\t{ CONST_INT }},\t\t\t\t\\\n-  {\"sext_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n-  {\"branch_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"ubranch_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n-  {\"call_insn_operand\",\t\t{ CONST_INT, CONST, SYMBOL_REF, REG }},\t\\\n-  {\"move_operand\",\t\t{ REG, SUBREG, MEM, CONST_INT, CONST_DOUBLE, \\\n-\t\t\t\t  CONST, SYMBOL_REF, LABEL_REF }},\t\\\n-  {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n-  {\"branch_operator\",\t\t{ EQ, NE, LT, GE }},\t\t\t\\\n-  {\"ubranch_operator\",\t\t{ LTU, GEU }},\t\t\t\t\\\n-  {\"boolean_operator\",\t\t{ EQ, NE }},\n-\n-/* Control the assembler format that we output.  */\n-\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n #define REGISTER_NAMES\t\t\t\t\t\t\t\\"}, {"sha": "8d93db0e999b8f3d86b838e58b93f332b893c949", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=8eb1bc5cf58e5f5c3fa65bae9293afa6c2adf976", "patch": "@@ -87,6 +87,11 @@\n (define_insn_reservation \"xtensa_fconv\" 2\n \t\t\t (eq_attr \"type\" \"fconv\")\n \t\t\t \"nothing\")\n+\f\n+;; Include predicate definitions\n+\n+(include \"predicates.md\")\n+\n \f\n ;; Addition.\n "}]}