{"sha": "1310497511d2ffb29fc4cf42d04606ea9081e76f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMxMDQ5NzUxMWQyZmZiMjlmYzRjZjQyZDA0NjA2ZWE5MDgxZTc2Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@stanford.edu", "date": "2001-08-04T00:20:37Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-04T00:20:37Z"}, "message": "builtins.c (fold_builtin_constant_p): Return integer_zero_node for complex expressions when cfun == 0.\n\n\t* builtins.c (fold_builtin_constant_p): Return integer_zero_node\nfor complex expressions when cfun == 0.\n\t* doc/extend.texi: Document that __builtin_constant_p can be\nused in data initializers as well as functions.\n\t* gcc.dg/bconstp-1.c: New test.\n\nFrom-SVN: r44619", "tree": {"sha": "06e038fe1d38bc55a98f531dcdfb7cf9d2bf4cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e038fe1d38bc55a98f531dcdfb7cf9d2bf4cb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1310497511d2ffb29fc4cf42d04606ea9081e76f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1310497511d2ffb29fc4cf42d04606ea9081e76f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1310497511d2ffb29fc4cf42d04606ea9081e76f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1310497511d2ffb29fc4cf42d04606ea9081e76f/comments", "author": null, "committer": null, "parents": [{"sha": "7335a34984e564b6fb30877390c11dc98cc53ef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7335a34984e564b6fb30877390c11dc98cc53ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7335a34984e564b6fb30877390c11dc98cc53ef8"}], "stats": {"total": 64, "additions": 62, "deletions": 2}, "files": [{"sha": "40acfdf77e14bbc7811c71028da7de96d727645b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1310497511d2ffb29fc4cf42d04606ea9081e76f", "patch": "@@ -1,3 +1,10 @@\n+2001-08-03  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* builtins.c (fold_builtin_constant_p): Return integer_zero_node\n+\tfor complex expressions when cfun == 0.\n+\t* doc/extend.texi: Document that __builtin_constant_p can be\n+\tused in data initializers as well as functions.\n+\n 2001-08-03  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mn10300/mn10300.h (CONDITIONAL_REGISTER_USAGE): Declare"}, {"sha": "08d2bb75e46b6635acb7539b523fd2956612bc45", "filename": "gcc/builtins.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1310497511d2ffb29fc4cf42d04606ea9081e76f", "patch": "@@ -3793,10 +3793,14 @@ fold_builtin_constant_p (arglist)\n      has side effects, show we don't know it to be a constant.\n      Likewise if it's a pointer or aggregate type since in those\n      case we only want literals, since those are only optimized\n-     when generating RTL, not later.  */\n+     when generating RTL, not later.\n+     And finally, if we are compiling an initializer, not code, we\n+     need to return a definite result now; there's not going to be any\n+     more optimization done.  */\n   if (TREE_SIDE_EFFECTS (arglist) || cse_not_expected\n       || AGGREGATE_TYPE_P (TREE_TYPE (arglist))\n-      || POINTER_TYPE_P (TREE_TYPE (arglist)))\n+      || POINTER_TYPE_P (TREE_TYPE (arglist))\n+      || cfun == 0)\n     return integer_zero_node;\n \n   return 0;"}, {"sha": "b7c24961682c5da3277e4c1f0ec29f10c79100ed", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1310497511d2ffb29fc4cf42d04606ea9081e76f", "patch": "@@ -3889,6 +3889,26 @@ never return 1 when you call the inline function with a string constant\n or compound literal (@pxref{Compound Literals}) and will not return 1\n when you pass a constant numeric value to the inline function unless you\n specify the @option{-O} option.\n+\n+You may also use @code{__builtin_constant_p} in initializers for static\n+data.  For instance, you can write\n+\n+@smallexample\n+static const int table[] = {\n+   __builtin_constant_p (EXPRESSION) ? (EXPRESSION) : -1,\n+   /* ... */\n+};\n+@end smallexample\n+\n+@noindent\n+This is an acceptable initializer even if @var{EXPRESSION} is not a\n+constant expression.  GCC must be more conservative about evaluating the\n+built-in in this case, because it has no opportunity to perform\n+optimization.\n+\n+Previous versions of GCC did not accept this built-in in data\n+initializers.  The earliest version where it is completely safe is\n+3.0.1.\n @end deftypefn\n \n @deftypefn {Built-in Function} long __builtin_expect (long @var{exp}, long @var{c})"}, {"sha": "d0813ca70bea541e24fb6d1a4e4f0f5fa57d82d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1310497511d2ffb29fc4cf42d04606ea9081e76f", "patch": "@@ -1,3 +1,7 @@\n+2001-08-03  Zack Weinberg  <zackw@stanford.edu>\n+\n+\t* gcc.dg/bconstp-1.c: New test.\n+\n 2001-08-03  Richard Henderson  <rth@redhat.com>\n \n \t* g++.dg/eh/filter1.C, g++.dg/eh/filter2.C: New tests."}, {"sha": "36831a5d6d5bd9775b63e97c39801163b937b335", "filename": "gcc/testsuite/gcc.dg/bconstp-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1310497511d2ffb29fc4cf42d04606ea9081e76f/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbconstp-1.c?ref=1310497511d2ffb29fc4cf42d04606ea9081e76f", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+\n+/* This test checks that builtin_constant_p can be used safely in\n+   initializers for static data.  The macro X() defined below should\n+   be an acceptable initializer expression no matter how complex its\n+   argument is.  */\n+\n+extern int a;\n+extern int b;\n+\n+extern int foo(void);\n+extern int bar(void);\n+\n+#define X(exp) (__builtin_constant_p(exp) ? (exp) : -1)\n+\n+const short tests[] = {\n+  X(0),\n+  X(a),\n+  X(0 && a),\n+  X(a && b),\n+  X(foo()),\n+  X(0 && foo()),\n+  X(a && foo()),\n+  X(foo() && bar())\n+};"}]}