{"sha": "e95b59d2abbeea533bfcea315ed2b47412f21470", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk1YjU5ZDJhYmJlZWE1MzNiZmNlYTMxNWVkMmI0NzQxMmYyMTQ3MA==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-07-12T12:17:03Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-07-12T12:17:03Z"}, "message": "target.h (builtin_vectorization_cost): Add new target builtin.\n\n2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * target.h (builtin_vectorization_cost): Add new target builtin.\n        * target-def.h (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): New.\n        * tree-vectorizer.h (TARG_SCALAR_STMT_COST): New.\n        (TARG_SCALAR_LOAD_COST, TARG_SCALAR_STORE_COST): New.\n        * tree-vect-analyze.c (vect_analyze_slp_instance): Initisliaze\n        uninitialized variables.\n        * tree-vect-transform.c (cost_for_stmt): New function.\n        (vect_estimate_min_profitable_iters): Call cost_for_stmt instead of\n        using cost 1 for all scalar stmts. Be less conservative when\n        estimating the number of prologue/epulogue iterations. Call\n        targetm.vectorize.builtin_vectorization_cost. Return\n        min_profitable_iters-1.\n        (vect_model_reduction_cost): Use TARG_SCALAR_TO_VEC_COST for\n        initialization cost instead of TARG_VEC_STMT_COST. Use\n        TARG_VEC_TO_SCALAR_COST instead of TARG_VEC_STMT_COST for reduction\n        epilogue code. Fix epilogue cost computation.\n        * config/spu/spu.c (spu_builtin_vectorization_cost): New.\n        (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Implement.\n        * config/spu/spu.h (TARG_COND_BRANCH_COST, TARG_SCALAR_STMT_COST):\n        (TARG_SCALAR_LOAD_COST, TARG_SCALAR_STORE_COST, TARG_VEC_STMT_COST):\n        (TARG_VEC_TO_SCALAR_COST, TARG_SCALAR_TO_VEC, TARG_VEC_LOAD_COST):\n        (TARG_VEC_UNALIGNED_LOAD_COST, TARG_VEC_STORE_COST): Define.\n\n2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c: Loops now\n        get vectorized.\n        * gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c: Loops\n        now get vectorized.\n        * gcc.dg/vect/costmodel/spu/spu-costmodel-vect.exp: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-fast-math-vect-pr29925.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-31a.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-31b.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-31c.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-31d.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-iv-9.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-33.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-76a.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-76b.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-76c.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-68a.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-68b.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-68c.c: New.\n        * gcc.dg/vect/costmodel/spu/costmodel-vect-68d.c: New.\n        * lib/target-supports.exp (check_effective_target_vect_int_mul):\n        Add spu.\n\nFrom-SVN: r126584", "tree": {"sha": "85414467a7c6b6b6755c5dbe54511f8981c7db54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85414467a7c6b6b6755c5dbe54511f8981c7db54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e95b59d2abbeea533bfcea315ed2b47412f21470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95b59d2abbeea533bfcea315ed2b47412f21470", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95b59d2abbeea533bfcea315ed2b47412f21470", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95b59d2abbeea533bfcea315ed2b47412f21470/comments", "author": null, "committer": null, "parents": [{"sha": "e1c8221962aa8dfba5b2462449bccfe10c2d561e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1c8221962aa8dfba5b2462449bccfe10c2d561e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1c8221962aa8dfba5b2462449bccfe10c2d561e"}], "stats": {"total": 955, "additions": 937, "deletions": 18}, "files": [{"sha": "620775cb09d63a55db4a7a5c6a7427a6240b848c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -1,3 +1,28 @@\n+2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* target.h (builtin_vectorization_cost): Add new target builtin.\n+\t* target-def.h (TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): New.\n+\t* tree-vectorizer.h (TARG_SCALAR_STMT_COST): New.\n+\t(TARG_SCALAR_LOAD_COST, TARG_SCALAR_STORE_COST): New.\n+\t* tree-vect-analyze.c (vect_analyze_slp_instance): Initisliaze\n+\tuninitialized variables.\n+\t* tree-vect-transform.c (cost_for_stmt): New function.\n+\t(vect_estimate_min_profitable_iters): Call cost_for_stmt instead of\n+\tusing cost 1 for all scalar stmts. Be less conservative when\n+\testimating the number of prologue/epulogue iterations. Call\n+\ttargetm.vectorize.builtin_vectorization_cost. Return\n+\tmin_profitable_iters-1.\n+\t(vect_model_reduction_cost): Use TARG_SCALAR_TO_VEC_COST for\n+\tinitialization cost instead of TARG_VEC_STMT_COST. Use\n+\tTARG_VEC_TO_SCALAR_COST instead of TARG_VEC_STMT_COST for reduction\n+\tepilogue code. Fix epilogue cost computation.\n+\t* config/spu/spu.c (spu_builtin_vectorization_cost): New.\n+\t(TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST): Implement.\n+\t* config/spu/spu.h (TARG_COND_BRANCH_COST, TARG_SCALAR_STMT_COST):\n+\t(TARG_SCALAR_LOAD_COST, TARG_SCALAR_STORE_COST, TARG_VEC_STMT_COST):\n+\t(TARG_VEC_TO_SCALAR_COST, TARG_SCALAR_TO_VEC, TARG_VEC_LOAD_COST):\n+\t(TARG_VEC_UNALIGNED_LOAD_COST, TARG_VEC_STORE_COST): Define.\n+\n 2007-07-12  Richard Guenther  <rguenther@suse.de>\n \n \t* gimplify.c (gimplify_conversion): Make sure that the result"}, {"sha": "f96326842b1ff1d2a70936e0f123e0e3ee0f5e21", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -133,6 +133,7 @@ static void spu_encode_section_info (tree, rtx, int);\n static tree spu_builtin_mul_widen_even (tree);\n static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n+static int spu_builtin_vectorization_cost (bool);\n \n extern const char *reg_names[];\n rtx spu_compare_op0, spu_compare_op1;\n@@ -261,6 +262,9 @@ const struct attribute_spec spu_attribute_table[];\n #undef TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD\n #define TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD spu_builtin_mask_for_load\n \n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST spu_builtin_vectorization_cost\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n void\n@@ -5191,6 +5195,21 @@ spu_builtin_mask_for_load (void)\n   return d->fndecl;\n }\n \n+/* Implement targetm.vectorize.builtin_vectorization_cost.  */\n+static int \n+spu_builtin_vectorization_cost (bool runtime_test)\n+{\n+  /* If the branch of the runtime test is taken - i.e. - the vectorized\n+     version is skipped - this incurs a misprediction cost (because the\n+     vectorized version is expected to be the fall-through).  So we subtract\n+     the latency of a mispredicted branch from the costs that are incured\n+     when the vectorized version is executed.  */\n+  if (runtime_test)\n+    return -19;\n+  else\n+    return 0;\n+}\n+\n void\n spu_init_expanders (void)\n {   "}, {"sha": "b8af6b2dc8c0bc6776a9376a0c79b4d3291d0862", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -541,6 +541,52 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n #define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n   do { if (LOG!=0) fprintf (FILE, \"\\t.align\\t%d\\n\", (LOG)); } while (0)\n \n+\f\n+/* Model costs for the vectorizer.  */\n+\n+/* Cost of conditional branch.  */\n+#ifndef TARG_COND_BRANCH_COST\n+#define TARG_COND_BRANCH_COST        6\n+#endif\n+\n+/* Cost of any scalar operation, excluding load and store.  */\n+#ifndef TARG_SCALAR_STMT_COST\n+#define TARG_SCALAR_STMT_COST        1\n+#endif\n+\n+/* Cost of scalar load. */\n+#undef TARG_SCALAR_LOAD_COST\n+#define TARG_SCALAR_LOAD_COST        2 /* load + rotate */\n+\n+/* Cost of scalar store.  */\n+#undef TARG_SCALAR_STORE_COST\n+#define TARG_SCALAR_STORE_COST       10\n+\n+/* Cost of any vector operation, excluding load, store,\n+   or vector to scalar operation.  */\n+#undef TARG_VEC_STMT_COST\n+#define TARG_VEC_STMT_COST           1\n+\n+/* Cost of vector to scalar operation.  */\n+#undef TARG_VEC_TO_SCALAR_COST\n+#define TARG_VEC_TO_SCALAR_COST      1\n+\n+/* Cost of scalar to vector operation.  */\n+#undef TARG_SCALAR_TO_VEC_COST\n+#define TARG_SCALAR_TO_VEC_COST      1\n+\n+/* Cost of aligned vector load.  */\n+#undef TARG_VEC_LOAD_COST\n+#define TARG_VEC_LOAD_COST           1\n+\n+/* Cost of misaligned vector load.  */\n+#undef TARG_VEC_UNALIGNED_LOAD_COST\n+#define TARG_VEC_UNALIGNED_LOAD_COST 2\n+\n+/* Cost of vector store.  */\n+#undef TARG_VEC_STORE_COST\n+#define TARG_VEC_STORE_COST          1\n+\n \f\n /* Misc */\n "}, {"sha": "8942de74f96fbee115c03aa33415404901b949ff", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -356,14 +356,16 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   default_builtin_vectorized_conversion\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN 0\n #define TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD 0\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST 0\n \n #define TARGET_VECTORIZE                                                \\\n   {\t\t\t\t\t\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION,\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_CONVERSION,\t\t\t\t\\\n     TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_EVEN,                            \\\n-    TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD\t\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_MUL_WIDEN_ODD,\t\t\t\t\\\n+    TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\t\t\t\t\\\n   }\n \n #define TARGET_DEFAULT_TARGET_FLAGS 0"}, {"sha": "56c99bf14b2b7f1785a5243e4964bcd823cb0761", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -413,6 +413,10 @@ struct gcc_target\n        element-by-element products for the odd elements.  */\n     tree (* builtin_mul_widen_even) (tree);\n     tree (* builtin_mul_widen_odd) (tree);\n+\n+    /* Returns the cost to be added to the overheads involved with\n+       executing the vectorized version of a loop.  */\n+    int (*builtin_vectorization_cost) (bool);\n   } vectorize;\n \n   /* The initial value of target_flags.  */"}, {"sha": "a74a74f8ad969e783c5bdf0aaea0f9ffd24ef494", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -1,3 +1,27 @@\n+2007-07-12  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c: Loops now\n+\tget vectorized.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c: Loops\n+\tnow get vectorized.\n+\t* gcc.dg/vect/costmodel/spu/spu-costmodel-vect.exp: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-fast-math-vect-pr29925.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-31a.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-31b.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-31c.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-31d.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-iv-9.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-33.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-76a.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-76b.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-76c.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-68a.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-68b.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-68c.c: New.\n+\t* gcc.dg/vect/costmodel/spu/costmodel-vect-68d.c: New.\n+\t* lib/target-supports.exp (check_effective_target_vect_int_mul):\n+\tAdd spu.\n+\n 2007-07-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/30854"}, {"sha": "55334fdd20df312449cc8e885542abcb3cfb840a", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-reduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-reduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-reduc-1char.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -46,6 +46,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "55334fdd20df312449cc8e885542abcb3cfb840a", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-vect-reduc-1char.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-reduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-reduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-vect-reduc-1char.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -46,6 +46,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9347d05ea2d981d9beaf9e5287079fac3c7a5bba", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-fast-math-vect-pr29925.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-fast-math-vect-pr29925.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdlib.h>\n+#include \"../../tree-vect.h\"\n+\n+void interp_pitch(float *exc, float *interp, int pitch, int len)\n+{\n+   int i,k;\n+   int maxj;\n+\n+   maxj=3;\n+   for (i=0;i<len;i++)\n+   {\n+      float tmp = 0;\n+      for (k=0;k<7;k++)\n+      {\n+         tmp += exc[i-pitch+k+maxj-6];\n+      }\n+      interp[i] = tmp;\n+   }\n+}\n+\n+int main()\n+{\n+   float *exc = calloc(126,sizeof(float));\n+   float *interp = calloc(80,sizeof(float));\n+   int pitch = -35;\n+\n+   check_vect ();\n+\n+   interp_pitch(exc, interp, pitch, 80);\n+   free(exc);\n+   free(interp);\n+   return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "272b3f0d73308eaeb64d0c9d4b963bd6cba90d81", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31a.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31a.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.b[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.b[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b3224f943d6238ec34469a0b4fa121f9670b18ab", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31b.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31b.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.c[i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.c[i] != 6)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9dcd09aba42ab3266c68ead749fa3e1e851d73e1", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31c.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31c.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.d.k[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.d.k[i] != 7)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "736804fd02095b1f33e5a23f31ac513cd3da249b", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-31d.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-31d.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.e.k[i] = 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.e.k[i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "df92ceb9e8183242ec94445a271f1b5edd2bb912", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-33.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-33.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+struct test {\n+  char ca[N];\n+};\n+\n+extern struct test s;\n+ \n+int main1 ()\n+{  \n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      s.ca[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.ca[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d0d40ac338a310a2d044d807f3fb56d3188becd9", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68a.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68a.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 1. unaligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4e52af8b851fefe2d6ef2f131f6a48e91043cc57", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68b.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68b.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 2. aligned */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 6)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "58c5e9fdbe5488a3642e6a624d8932d6d221248f", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68c.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68c.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 3. aligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 7)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "9cec936333abccb3f4479fd65f6a80ca6769ac1b", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-68d.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-68d.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 20\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 4. unaligned */\n+  for (i = 3; i < N-3; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 8;\n+    }\n+ \n+  /* check results:  */\n+  for (i = 3; i <N-3; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "41fe3aebf90a37f9d3db09a47d89bdf9b8ca6a90", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76a.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+/* Check handling of accesses for which the \"initial condition\" -\n+   the expression that represents the first location accessed - is\n+   more involved than just an ssa_name.  */\n+\n+int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (int *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      ia[i] = pib[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (ia[i] != pib[i - OFF])\n+        abort ();\n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "71f3977b16a71fc6c74bb39aad0fba75b0f6949c", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76b.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76b.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+/* Check handling of accesses for which the \"initial condition\" -\n+   the expression that represents the first location accessed - is\n+   more involved than just an ssa_name.  */\n+\n+int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (int *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      pib[i - OFF] = ic[i];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (pib[i - OFF] != ic[i])\n+        abort ();\n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "f6127ba873ba9d6c83865f42922fa2659debdee4", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-76c.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-76c.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 8\n+#define OFF 4\n+\n+/* Check handling of accesses for which the \"initial condition\" -\n+   the expression that represents the first location accessed - is\n+   more involved than just an ssa_name.  */\n+\n+int ib[N+OFF] __attribute__ ((__aligned__(16))) = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+int main1 (int *pib)\n+{\n+  int i;\n+  int ia[N+OFF];\n+  int ic[N+OFF] = {0, 1, 3, 5, 7, 11, 13, 17, 0, 2, 6, 10};\n+\n+  for (i = OFF; i < N; i++)\n+    {\n+      ia[i] = ic[i - OFF];\n+    }\n+\n+\n+  /* check results:  */\n+  for (i = OFF; i < N; i++)\n+    {\n+     if (ia[i] != ic[i - OFF])\n+        abort ();  \n+    }\n+\n+  return 0;  \n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (&ib[OFF]);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "e01b67e48e1fe3615665f12076b5f5e790c4265e", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/costmodel-vect-iv-9.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-iv-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-iv-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fcostmodel-vect-iv-9.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 26\n+int a[N];\n+ \n+int main1 (int X)\n+{  \n+  int s = X;\n+  int i;\n+\n+  /* vectorization of reduction with induction.  */\n+  for (i = 0; i < N; i++)\n+    s += (i + a[i]);\n+\n+  return s;\n+}\n+\n+int main (void)\n+{ \n+  int s, i;\n+  check_vect ();\n+  \n+  for (i = 0; i < N; i++)\n+    a[i] = 2*i;\n+\n+  s = main1 (3);\n+  if (s != 978)\n+    abort ();\n+\n+  return 0;\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_int_mult } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target {! vect_int_mult } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "fe7439a5463184216f9d6d03fd8f3e87b1302dcf", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/spu/spu-costmodel-vect.exp", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fspu-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fspu-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fspu%2Fspu-costmodel-vect.exp?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -0,0 +1,69 @@\n+# Copyright (C) 1997, 2004, 2005, 2006 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Exit immediately if this isn't a powerpc target.\n+if { ![istarget spu*-*-*] } then {\n+  return\n+}\n+\n+\n+# Set up flags used for tests that don't specify options.\n+set DEFAULT_VECTCFLAGS \"\"\n+\n+# These flags are used for all targets.\n+lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fvect-cost-model\"\n+\n+# If the target system supports vector instructions, the default action\n+# for a test is 'run', otherwise it's 'compile'.  Save current default.\n+# Executing vector instructions on a system without hardware vector support\n+# is also disabled by a call to check_vect, but disabling execution here is\n+# more efficient.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+\n+set dg-do-what-default run\n+\n+# Initialize `dg'.\n+dg-init\n+\n+lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-pr*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+\n+# -ffast-math tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-fast-math-vect*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "ccb6356ccf973769f30377e83229b94ca7fd2e66", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -2039,6 +2039,7 @@ proc check_effective_target_vect_int_mult { } {\n     } else {\n \tset et_vect_int_mult_saved 0\n \tif { [istarget powerpc*-*-*]\n+\t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*] } {\n \t   set et_vect_int_mult_saved 1"}, {"sha": "193c54961cd7ff037afff21edb4120de3f108eee", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 70, "deletions": 13, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -74,6 +74,34 @@ static void vect_update_inits_of_drs (loop_vec_info, tree);\n static int vect_min_worthwhile_factor (enum tree_code);\n \n \n+static int\n+cost_for_stmt (tree stmt)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n+  switch (STMT_VINFO_TYPE (stmt_info))\n+  {\n+  case load_vec_info_type:\n+    return TARG_SCALAR_LOAD_COST;\n+  case store_vec_info_type:\n+    return TARG_SCALAR_STORE_COST;\n+  case op_vec_info_type:\n+  case condition_vec_info_type:\n+  case assignment_vec_info_type:\n+  case reduc_vec_info_type:\n+  case induc_vec_info_type:\n+  case type_promotion_vec_info_type:\n+  case type_demotion_vec_info_type:\n+  case type_conversion_vec_info_type:\n+  case call_vec_info_type:\n+    return TARG_SCALAR_STMT_COST;\n+  case undef_vec_info_type:\n+  default:\n+    gcc_unreachable ();\n+  }\n+}\n+\n+\n /* Function vect_estimate_min_profitable_iters\n \n    Return the number of iterations required for the vector version of the\n@@ -138,7 +166,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n           if (!STMT_VINFO_RELEVANT_P (stmt_info)\n               && !STMT_VINFO_LIVE_P (stmt_info))\n             continue;\n-          scalar_single_iter_cost++;\n+          scalar_single_iter_cost += cost_for_stmt (stmt);\n           vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info);\n           vec_outside_cost += STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info);\n         }\n@@ -148,7 +176,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      loop.\n \n      FORNOW: If we dont know the value of peel_iters for prologue or epilogue\n-     at compile-time - we assume the worst.  \n+     at compile-time - we assume it's (vf-1)/2 (the worst would be vf-1).\n \n      TODO: Build an expression that represents peel_iters for prologue and\n      epilogue to be used in a run-time test.  */\n@@ -157,17 +185,17 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n   if (byte_misalign < 0)\n     {\n-      peel_iters_prologue = vf - 1;\n+      peel_iters_prologue = (vf - 1)/2;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: \"\n-                 \"prologue peel iters set conservatively.\");\n+                 \"prologue peel iters set to (vf-1)/2.\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n          unknown.  */\n-      peel_iters_epilogue = vf - 1;\n+      peel_iters_epilogue = (vf - 1)/2;\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"cost model: \"\n-                 \"epilogue peel iters set conservatively because \"\n+                 \"epilogue peel iters set to (vf-1)/2 because \"\n                  \"peeling for alignment is unknown .\");\n     }\n   else \n@@ -186,10 +214,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \n       if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n         {\n-          peel_iters_epilogue = vf - 1;\n+          peel_iters_epilogue = (vf - 1)/2;\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"cost model: \"\n-                     \"epilogue peel iters set conservatively because \"\n+                     \"epilogue peel iters set to (vf-1)/2 because \"\n                      \"loop iterations are unknown .\");\n         }\n       else      \n@@ -229,6 +257,26 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n                       + (peel_iters_epilogue * scalar_single_iter_cost);\n \n+  /* Allow targets add additional (outside-of-loop) costs. FORNOW, the only\n+     information we provide for the target is whether testing against the\n+     threshold involves a runtime test.  */\n+  if (targetm.vectorize.builtin_vectorization_cost)\n+    {\n+      bool runtime_test = false;\n+\n+      /* If the number of iterations is unknown, or the\n+\t peeling-for-misalignment amount is unknown, we eill have to generate\n+\t a runtime test to test the loop count agains the threshold.  */\n+      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t  || (byte_misalign < 0))\n+\truntime_test = true;\n+      vec_outside_cost +=\n+\ttargetm.vectorize.builtin_vectorization_cost (runtime_test);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+\tfprintf (vect_dump, \"cost model : Adding target out-of-loop cost = %d\",\n+\t\t  targetm.vectorize.builtin_vectorization_cost (runtime_test));\n+    }\n+\n   /* Calculate number of iterations required to make the vector version \n      profitable, relative to the loop bodies only. The following condition\n      must hold true: ((SIC*VF)-VIC)*niters > VOC*VF, where\n@@ -280,7 +328,14 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n \t       min_profitable_iters < vf ? vf : min_profitable_iters);\n     }\n \n-  return min_profitable_iters < vf ? vf : min_profitable_iters;\n+  min_profitable_iters = \n+\tmin_profitable_iters < vf ? vf : min_profitable_iters;\n+\n+  /* Because the condition we create is:\n+     if (niters <= min_profitable_iters)\n+       then skip the vectorized loop.  */\n+  min_profitable_iters--;\n+  return min_profitable_iters;\n }\n \n \n@@ -321,7 +376,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   code = TREE_CODE (GIMPLE_STMT_OPERAND (orig_stmt, 1));\n \n   /* Add in cost for initial definition.  */\n-  outer_cost += TARG_VEC_STMT_COST;\n+  outer_cost += TARG_SCALAR_TO_VEC_COST;\n \n   /* Determine cost of epilogue code.\n \n@@ -341,11 +396,13 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n       optab = optab_for_tree_code (code, vectype);\n \n       /* We have a whole vector shift available.  */\n-      if (!VECTOR_MODE_P (mode) \n-          || optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+      if (VECTOR_MODE_P (mode)\n+\t  && optab->handlers[mode].insn_code != CODE_FOR_nothing\n+\t  && vec_shr_optab->handlers[mode].insn_code != CODE_FOR_nothing)\n         /* Final reduction via vector shifts and the reduction operator. Also\n            requires scalar extract.  */\n-\touter_cost += ((exact_log2(nelements) * 2 + 1) * TARG_VEC_STMT_COST); \n+\touter_cost += ((exact_log2(nelements) * 2) * TARG_VEC_STMT_COST\n+\t\t\t+ TARG_VEC_TO_SCALAR_COST); \n       else\n \t/* Use extracts and reduction op for final reduction.  For N elements,\n            we have N extracts and N-1 reduction ops.  */"}, {"sha": "440bb3dce536b251611f53d3b90a6ca0546b635d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e95b59d2abbeea533bfcea315ed2b47412f21470/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=e95b59d2abbeea533bfcea315ed2b47412f21470", "patch": "@@ -326,6 +326,21 @@ typedef struct _stmt_vec_info {\n #define TARG_COND_BRANCH_COST        3\n #endif\n \n+/* Cost of any scalar operation, excluding load and store.  */\n+#ifndef TARG_SCALAR_STMT_COST\n+#define TARG_SCALAR_STMT_COST           1\n+#endif\n+\n+/* Cost of scalar load.  */\n+#ifndef TARG_SCALAR_LOAD_COST\n+#define TARG_SCALAR_LOAD_COST           1\n+#endif\n+\n+/* Cost of scalar store.  */\n+#ifndef TARG_SCALAR_STORE_COST\n+#define TARG_SCALAR_STORE_COST           1\n+#endif\n+\n /* Cost of any vector operation, excluding load, store or vector to scalar\n    operation.  */ \n #ifndef TARG_VEC_STMT_COST"}]}