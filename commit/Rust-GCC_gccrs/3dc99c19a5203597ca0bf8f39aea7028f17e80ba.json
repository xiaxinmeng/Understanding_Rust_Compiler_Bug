{"sha": "3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RjOTljMTlhNTIwMzU5N2NhMGJmOGYzOWFlYTcwMjhmMTdlODBiYQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-08-27T19:53:39Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-08-27T19:53:39Z"}, "message": "Use rtx_insn_list in various places\n\ngcc/\n2014-08-27  David Malcolm  <dmalcolm@redhat.com>\n\n\t* rtl.h (free_INSN_LIST_list): Strengthen param from rtx * to\n\trtx_insn_list **.\n\t(alloc_INSN_LIST): Strengthen return type from rtx to\n\trtx_insn_list *.\n\t(copy_INSN_LIST): Likewise for return type and param.\n\t(concat_INSN_LIST): Likewise for both params and return type.\n\t(remove_free_INSN_LIST_elem): Strenghten first param from rtx to\n\trtx_insn *.  Strengthen second param from rtx * to rtx_insn_list **.\n\t(remove_free_INSN_LIST_node): Strenghten return type from rtx to\n\trtx_insn *.  Strengthen param from rtx * to rtx_insn_list **.\n\n\t* sched-int.h (struct deps_reg): Strengthen fields \"uses\", \"sets\",\n\t\"implicit_sets\", \"control_uses\", \"clobbers\" from rtx to\n\trtx_insn_list *.\n\t(struct deps_desc): Likewise for fields \"pending_read_insns\",\n\t\"pending_write_insns\", \"pending_jump_insns\",\n\t\"last_pending_memory_flush\", \"last_function_call\",\n\t\"last_function_call_may_noreturn\", \"sched_before_next_call\",\n\t\"sched_before_next_jump\".\n\t(struct _haifa_deps_insn_data): Likewise for field \"cond_deps\".\n\t(remove_from_deps): Strengthen second param from rtx to rtx_insn *.\n\n\t* gcse.c (struct ls_expr): Strengthen fields \"loads\" and \"stores\"\n\tfrom rtx to rtx_insn_list *.\n\t(ldst_entry): Replace use of NULL_RTX with NULL when dealing with\n\trtx_insn_list *.\n\n\t* haifa-sched.c (insn_queue): Strengthen this variable from rtx *\n\tto rtx_insn_list **.\n\t(dep_cost_1): Strengthen local \"dep_cost_rtx_link\" from rtx to\n\trtx_insn_list *.\n\t(queue_insn): Likewise for local \"link\".\n\t(struct haifa_saved_data): Strengthen field \"insn_queue\" from\n\trtx * to rtx_insn_list **.\n\t(save_backtrack_point): Update allocation of save->insn_queue to\n\treflect the strengthening of elements from rtx to rtx_insn_list *.\n\t(queue_to_ready): Strengthen local \"link\" from rtx to\n\trtx_insn_list *; use methods \"next\" and \"insn\" when traversing the\n\tlist.\n\t(early_queue_to_ready): Likewise for locals \"link\", \"next_link\",\n\t\"prev_link\".\n\t(schedule_block): Update allocation of insn_queue to reflect the\n\tstrengthening of elements from rtx to rtx_insn_list *.  Strengthen\n\tlocal \"link\" from rtx to rtx_insn_list *, and use methods when\n\tworking it.\n\t(add_to_speculative_block): Strengthen locals \"twins\" and\n\t\"next_node\" from rtx to rtx_insn_list *, and use methods when\n\tworking with them.  Strengthen local \"twin\" from rtx to\n\trtx_insn *, eliminating a checked cast.\n\t(fix_recovery_deps): Strengthen locals \"ready_list\" and \"link\"\n\tfrom rtx to rtx_insn_list *, and use methods when working with\n\tthem.\n\n\t* lists.c (alloc_INSN_LIST): Strengthen return type and local \"r\"\n\tfrom rtx to rtx_insn_list *, adding a checked cast.\n\t(free_INSN_LIST_list): Strengthen param \"listp\" from rtx * to\n\trtx_insn_list **.\n\t(copy_INSN_LIST): Strengthen return type and locals \"new_queue\",\n\t\"newlink\" from rtx to rtx_insn_list *.  Strengthen local\n\t\"pqueue\" from rtx * to rtx_insn_list **.  Strengthen local \"x\"\n\tfrom rtx to rtx_insn *.\n\t(concat_INSN_LIST): Strengthen return type and local \"new_rtx\",\n\tfrom rtx to rtx_insn_list *.  Use methods of the latter class.\n\t(remove_free_INSN_LIST_elem): Strengthen param \"elem\" from rtx to\n\trtx_insn *, and param \"listp\" from rtx * to rtx_insn_list **.\n\t(remove_free_INSN_LIST_node): Strengthen return type and local\n\t\"elem\" from rtx to rtx_insn *.  Strenghten param \"listp\" from\n\trtx * to rtx_insn_list **.  Strengthen local \"node\" from rtx to\n\trtx_insn_list *, using \"insn\" method.\n\n\t* sched-deps.c (add_dependence_list):  Strengthen param \"list\"\n\tfrom rtx to rtx_insn_list *, and use methods when working with it.\n\t(add_dependence_list_and_free):  Strengthen param \"listp\" from\n\trtx * to rtx_insn_list **.\n\t(remove_from_dependence_list): Strenghten param \"listp\" from rtx *\n\tto rtx_insn_list **, and use methods when working with *listp.\n\t(remove_from_both_dependence_lists): Strengthen param \"listp\" from\n\trtx * to rtx_insn_list **\n\t(add_insn_mem_dependence): Strengthen local \"insn_list\" from rtx *\n\tto rtx_insn_list **.  Eliminate local \"link\", in favor of two new\n\tlocals \"insn_node\" and \"mem_node\", an rtx_insn_list * and an rtx\n\trespectively.\n\t(deps_analyze_insn): Split out uses 'f local \"t\" as an INSN_LIST\n\tby introducing local \"cond_deps\".\n\t(remove_from_deps): Strengthen param \"insn\" from rtx to\n\trtx_insn *.\n\n\t* sched-rgn.c (concat_insn_mem_list): Strengthen param\n\t\"copy_insns\" and local \"new_insns\" from rtx to rtx_insn_list *.\n\tStrengthen param \"old_insns_p\" from rtx * to rtx_insn_list **.\n\tUse methods of rtx_insn_list.\n\n\t* store-motion.c (struct st_expr): Strengthen fields\n\t\"antic_stores\" and \"avail_stores\" from rtx to rtx_insn_list *.\n\t(st_expr_entry): Replace NULL_RTX with NULL when dealing with\n\trtx_insn_list *.\n\t(find_moveable_store): Split out \"tmp\" into multiple more-tightly\n\tscoped locals.  Use methods of rtx_insn_list *.\n\t(compute_store_table): Strengthen local \"tmp\" from rtx to\n\trtx_insn *.  Use methods of rtx_insn_list *.\n\nFrom-SVN: r214590", "tree": {"sha": "6b70cdb662152458e90a78b8cb9af235f424d8a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b70cdb662152458e90a78b8cb9af235f424d8a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a756c6be3193ea9483aaa35b1be4e95ccc79af83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a756c6be3193ea9483aaa35b1be4e95ccc79af83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a756c6be3193ea9483aaa35b1be4e95ccc79af83"}], "stats": {"total": 359, "additions": 237, "deletions": 122}, "files": [{"sha": "b82355b0525d6d856c722c67a9f950cf2e5bd8ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -1,3 +1,106 @@\n+2014-08-27  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* rtl.h (free_INSN_LIST_list): Strengthen param from rtx * to\n+\trtx_insn_list **.\n+\t(alloc_INSN_LIST): Strengthen return type from rtx to\n+\trtx_insn_list *.\n+\t(copy_INSN_LIST): Likewise for return type and param.\n+\t(concat_INSN_LIST): Likewise for both params and return type.\n+\t(remove_free_INSN_LIST_elem): Strenghten first param from rtx to\n+\trtx_insn *.  Strengthen second param from rtx * to rtx_insn_list **.\n+\t(remove_free_INSN_LIST_node): Strenghten return type from rtx to\n+\trtx_insn *.  Strengthen param from rtx * to rtx_insn_list **.\n+\n+\t* sched-int.h (struct deps_reg): Strengthen fields \"uses\", \"sets\",\n+\t\"implicit_sets\", \"control_uses\", \"clobbers\" from rtx to\n+\trtx_insn_list *.\n+\t(struct deps_desc): Likewise for fields \"pending_read_insns\",\n+\t\"pending_write_insns\", \"pending_jump_insns\",\n+\t\"last_pending_memory_flush\", \"last_function_call\",\n+\t\"last_function_call_may_noreturn\", \"sched_before_next_call\",\n+\t\"sched_before_next_jump\".\n+\t(struct _haifa_deps_insn_data): Likewise for field \"cond_deps\".\n+\t(remove_from_deps): Strengthen second param from rtx to rtx_insn *.\n+\n+\t* gcse.c (struct ls_expr): Strengthen fields \"loads\" and \"stores\"\n+\tfrom rtx to rtx_insn_list *.\n+\t(ldst_entry): Replace use of NULL_RTX with NULL when dealing with\n+\trtx_insn_list *.\n+\n+\t* haifa-sched.c (insn_queue): Strengthen this variable from rtx *\n+\tto rtx_insn_list **.\n+\t(dep_cost_1): Strengthen local \"dep_cost_rtx_link\" from rtx to\n+\trtx_insn_list *.\n+\t(queue_insn): Likewise for local \"link\".\n+\t(struct haifa_saved_data): Strengthen field \"insn_queue\" from\n+\trtx * to rtx_insn_list **.\n+\t(save_backtrack_point): Update allocation of save->insn_queue to\n+\treflect the strengthening of elements from rtx to rtx_insn_list *.\n+\t(queue_to_ready): Strengthen local \"link\" from rtx to\n+\trtx_insn_list *; use methods \"next\" and \"insn\" when traversing the\n+\tlist.\n+\t(early_queue_to_ready): Likewise for locals \"link\", \"next_link\",\n+\t\"prev_link\".\n+\t(schedule_block): Update allocation of insn_queue to reflect the\n+\tstrengthening of elements from rtx to rtx_insn_list *.  Strengthen\n+\tlocal \"link\" from rtx to rtx_insn_list *, and use methods when\n+\tworking it.\n+\t(add_to_speculative_block): Strengthen locals \"twins\" and\n+\t\"next_node\" from rtx to rtx_insn_list *, and use methods when\n+\tworking with them.  Strengthen local \"twin\" from rtx to\n+\trtx_insn *, eliminating a checked cast.\n+\t(fix_recovery_deps): Strengthen locals \"ready_list\" and \"link\"\n+\tfrom rtx to rtx_insn_list *, and use methods when working with\n+\tthem.\n+\n+\t* lists.c (alloc_INSN_LIST): Strengthen return type and local \"r\"\n+\tfrom rtx to rtx_insn_list *, adding a checked cast.\n+\t(free_INSN_LIST_list): Strengthen param \"listp\" from rtx * to\n+\trtx_insn_list **.\n+\t(copy_INSN_LIST): Strengthen return type and locals \"new_queue\",\n+\t\"newlink\" from rtx to rtx_insn_list *.  Strengthen local\n+\t\"pqueue\" from rtx * to rtx_insn_list **.  Strengthen local \"x\"\n+\tfrom rtx to rtx_insn *.\n+\t(concat_INSN_LIST): Strengthen return type and local \"new_rtx\",\n+\tfrom rtx to rtx_insn_list *.  Use methods of the latter class.\n+\t(remove_free_INSN_LIST_elem): Strengthen param \"elem\" from rtx to\n+\trtx_insn *, and param \"listp\" from rtx * to rtx_insn_list **.\n+\t(remove_free_INSN_LIST_node): Strengthen return type and local\n+\t\"elem\" from rtx to rtx_insn *.  Strenghten param \"listp\" from\n+\trtx * to rtx_insn_list **.  Strengthen local \"node\" from rtx to\n+\trtx_insn_list *, using \"insn\" method.\n+\n+\t* sched-deps.c (add_dependence_list):  Strengthen param \"list\"\n+\tfrom rtx to rtx_insn_list *, and use methods when working with it.\n+\t(add_dependence_list_and_free):  Strengthen param \"listp\" from\n+\trtx * to rtx_insn_list **.\n+\t(remove_from_dependence_list): Strenghten param \"listp\" from rtx *\n+\tto rtx_insn_list **, and use methods when working with *listp.\n+\t(remove_from_both_dependence_lists): Strengthen param \"listp\" from\n+\trtx * to rtx_insn_list **\n+\t(add_insn_mem_dependence): Strengthen local \"insn_list\" from rtx *\n+\tto rtx_insn_list **.  Eliminate local \"link\", in favor of two new\n+\tlocals \"insn_node\" and \"mem_node\", an rtx_insn_list * and an rtx\n+\trespectively.\n+\t(deps_analyze_insn): Split out uses 'f local \"t\" as an INSN_LIST\n+\tby introducing local \"cond_deps\".\n+\t(remove_from_deps): Strengthen param \"insn\" from rtx to\n+\trtx_insn *.\n+\n+\t* sched-rgn.c (concat_insn_mem_list): Strengthen param\n+\t\"copy_insns\" and local \"new_insns\" from rtx to rtx_insn_list *.\n+\tStrengthen param \"old_insns_p\" from rtx * to rtx_insn_list **.\n+\tUse methods of rtx_insn_list.\n+\n+\t* store-motion.c (struct st_expr): Strengthen fields\n+\t\"antic_stores\" and \"avail_stores\" from rtx to rtx_insn_list *.\n+\t(st_expr_entry): Replace NULL_RTX with NULL when dealing with\n+\trtx_insn_list *.\n+\t(find_moveable_store): Split out \"tmp\" into multiple more-tightly\n+\tscoped locals.  Use methods of rtx_insn_list *.\n+\t(compute_store_table): Strengthen local \"tmp\" from rtx to\n+\trtx_insn *.  Use methods of rtx_insn_list *.\n+\n 2014-08-27  David Malcolm  <dmalcolm@redhat.com>\n \n \t* coretypes.h (class rtx_insn_list): Add forward declaration."}, {"sha": "cd0829fac509646b2f91045dc8d8e3201cc3771d", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -347,8 +347,8 @@ struct ls_expr\n   struct expr * expr;\t\t/* Gcse expression reference for LM.  */\n   rtx pattern;\t\t\t/* Pattern of this mem.  */\n   rtx pattern_regs;\t\t/* List of registers mentioned by the mem.  */\n-  rtx loads;\t\t\t/* INSN list of loads seen.  */\n-  rtx stores;\t\t\t/* INSN list of stores seen.  */\n+  rtx_insn_list *loads;\t\t/* INSN list of loads seen.  */\n+  rtx_insn_list *stores;\t/* INSN list of stores seen.  */\n   struct ls_expr * next;\t/* Next in the list.  */\n   int invalid;\t\t\t/* Invalid for some reason.  */\n   int index;\t\t\t/* If it maps to a bitmap index.  */\n@@ -3774,8 +3774,8 @@ ldst_entry (rtx x)\n   ptr->expr         = NULL;\n   ptr->pattern      = x;\n   ptr->pattern_regs = NULL_RTX;\n-  ptr->loads        = NULL_RTX;\n-  ptr->stores       = NULL_RTX;\n+  ptr->loads        = NULL;\n+  ptr->stores       = NULL;\n   ptr->reaching_reg = NULL_RTX;\n   ptr->invalid      = 0;\n   ptr->index        = 0;"}, {"sha": "1bb6a9d206e1ec32cf1c21d43c934537df0c2eb0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -318,7 +318,7 @@ bool adding_bb_to_current_region_p = true;\n    the base maximal time of functional unit reservations and getting a\n    result.  This is the longest time an insn may be queued.  */\n \n-static rtx *insn_queue;\n+static rtx_insn_list **insn_queue;\n static int q_ptr = 0;\n static int q_size = 0;\n #define NEXT_Q(X) (((X)+1) & max_insn_queue_index)\n@@ -1475,7 +1475,8 @@ dep_cost_1 (dep_t link, dw_t dw)\n \t{\n \t  /* This variable is used for backward compatibility with the\n \t     targets.  */\n-\t  rtx dep_cost_rtx_link = alloc_INSN_LIST (NULL_RTX, NULL_RTX);\n+\t  rtx_insn_list *dep_cost_rtx_link =\n+\t    alloc_INSN_LIST (NULL_RTX, NULL);\n \n \t  /* Make it self-cycled, so that if some tries to walk over this\n \t     incomplete list he/she will be caught in an endless loop.  */\n@@ -2745,7 +2746,7 @@ HAIFA_INLINE static void\n queue_insn (rtx_insn *insn, int n_cycles, const char *reason)\n {\n   int next_q = NEXT_Q_AFTER (q_ptr, n_cycles);\n-  rtx link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n+  rtx_insn_list *link = alloc_INSN_LIST (insn, insn_queue[next_q]);\n   int new_tick;\n \n   gcc_assert (n_cycles <= max_insn_queue_index);\n@@ -4112,7 +4113,7 @@ struct haifa_saved_data\n   /* We don't need to save q_ptr, as its value is arbitrary and we can set it\n      to 0 when restoring.  */\n   int q_size;\n-  rtx *insn_queue;\n+  rtx_insn_list **insn_queue;\n \n   /* Describe pattern replacements that occurred since this backtrack point\n      was queued.  */\n@@ -4163,7 +4164,7 @@ save_backtrack_point (struct delay_pair *pair,\n   save->ready.vec = XNEWVEC (rtx_insn *, ready.veclen);\n   memcpy (save->ready.vec, ready.vec, ready.veclen * sizeof (rtx));\n \n-  save->insn_queue = XNEWVEC (rtx, max_insn_queue_index + 1);\n+  save->insn_queue = XNEWVEC (rtx_insn_list *, max_insn_queue_index + 1);\n   save->q_size = q_size;\n   for (i = 0; i <= max_insn_queue_index; i++)\n     {\n@@ -4926,7 +4927,7 @@ static void\n queue_to_ready (struct ready_list *ready)\n {\n   rtx_insn *insn;\n-  rtx link;\n+  rtx_insn_list *link;\n   rtx skip_insn;\n \n   q_ptr = NEXT_Q (q_ptr);\n@@ -4940,9 +4941,9 @@ queue_to_ready (struct ready_list *ready)\n \n   /* Add all pending insns that can be scheduled without stalls to the\n      ready list.  */\n-  for (link = insn_queue[q_ptr]; link; link = XEXP (link, 1))\n+  for (link = insn_queue[q_ptr]; link; link = link->next ())\n     {\n-      insn = as_a <rtx_insn *> (XEXP (link, 0));\n+      insn = link->insn ();\n       q_size -= 1;\n \n       if (sched_verbose >= 2)\n@@ -4988,7 +4989,7 @@ queue_to_ready (struct ready_list *ready)\n \t{\n \t  if ((link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)]))\n \t    {\n-\t      for (; link; link = XEXP (link, 1))\n+\t      for (; link; link = link->next ())\n \t\t{\n \t\t  insn = as_a <rtx_insn *> (XEXP (link, 0));\n \t\t  q_size -= 1;\n@@ -5082,9 +5083,9 @@ static int\n early_queue_to_ready (state_t state, struct ready_list *ready)\n {\n   rtx_insn *insn;\n-  rtx link;\n-  rtx next_link;\n-  rtx prev_link;\n+  rtx_insn_list *link;\n+  rtx_insn_list *next_link;\n+  rtx_insn_list *prev_link;\n   bool move_to_ready;\n   int cost;\n   state_t temp_state = alloca (dfa_state_size);\n@@ -5118,8 +5119,8 @@ early_queue_to_ready (state_t state, struct ready_list *ready)\n \t  prev_link = 0;\n \t  while (link)\n \t    {\n-\t      next_link = XEXP (link, 1);\n-\t      insn = as_a <rtx_insn *> (XEXP (link, 0));\n+\t      next_link = link->next ();\n+\t      insn = link->insn ();\n \t      if (insn && sched_verbose > 6)\n \t\tprint_rtl_single (sched_dump, insn);\n \n@@ -6038,7 +6039,7 @@ schedule_block (basic_block *target_bb, state_t init_state)\n   q_ptr = 0;\n   q_size = 0;\n \n-  insn_queue = XALLOCAVEC (rtx, max_insn_queue_index + 1);\n+  insn_queue = XALLOCAVEC (rtx_insn_list *, max_insn_queue_index + 1);\n   memset (insn_queue, 0, (max_insn_queue_index + 1) * sizeof (rtx));\n \n   /* Start just before the beginning of time.  */\n@@ -6503,11 +6504,11 @@ schedule_block (basic_block *target_bb, state_t init_state)\n \t}\n       for (i = 0; i <= max_insn_queue_index; i++)\n \t{\n-\t  rtx link;\n+\t  rtx_insn_list *link;\n \t  while ((link = insn_queue[i]) != NULL)\n \t    {\n-\t      rtx_insn *x = as_a <rtx_insn *> (XEXP (link, 0));\n-\t      insn_queue[i] = XEXP (link, 1);\n+\t      rtx_insn *x = link->insn ();\n+\t      insn_queue[i] = link->next ();\n \t      QUEUE_INDEX (x) = QUEUE_NOWHERE;\n \t      free_INSN_LIST_node (link);\n \t      resolve_dependencies (x);\n@@ -7424,7 +7425,7 @@ add_to_speculative_block (rtx_insn *insn)\n   ds_t ts;\n   sd_iterator_def sd_it;\n   dep_t dep;\n-  rtx twins = NULL;\n+  rtx_insn_list *twins = NULL;\n   rtx_vec_t priorities_roots;\n \n   ts = TODO_SPEC (insn);\n@@ -7535,20 +7536,21 @@ add_to_speculative_block (rtx_insn *insn)\n      because that would make TWINS appear in the INSN_BACK_DEPS (INSN).  */\n   while (twins)\n     {\n-      rtx twin;\n+      rtx_insn *twin;\n+      rtx_insn_list *next_node;\n \n-      twin = XEXP (twins, 0);\n+      twin = twins->insn ();\n \n       {\n \tdep_def _new_dep, *new_dep = &_new_dep;\n \n-\tinit_dep (new_dep, insn, as_a <rtx_insn *> (twin), REG_DEP_OUTPUT);\n+\tinit_dep (new_dep, insn, twin, REG_DEP_OUTPUT);\n \tsd_add_dep (new_dep, false);\n       }\n \n-      twin = XEXP (twins, 1);\n+      next_node = twins->next ();\n       free_INSN_LIST_node (twins);\n-      twins = twin;\n+      twins = next_node;\n     }\n \n   calc_priorities (priorities_roots);\n@@ -8066,9 +8068,9 @@ static void\n fix_recovery_deps (basic_block rec)\n {\n   rtx_insn *note, *insn, *jump;\n-  rtx ready_list = 0;\n+  rtx_insn_list *ready_list = 0;\n   bitmap_head in_ready;\n-  rtx link;\n+  rtx_insn_list *link;\n \n   bitmap_initialize (&in_ready, 0);\n \n@@ -8111,8 +8113,8 @@ fix_recovery_deps (basic_block rec)\n   bitmap_clear (&in_ready);\n \n   /* Try to add instructions to the ready or queue list.  */\n-  for (link = ready_list; link; link = XEXP (link, 1))\n-    try_ready (as_a <rtx_insn *> (XEXP (link, 0)));\n+  for (link = ready_list; link; link = link->next ())\n+    try_ready (link->insn ());\n   free_INSN_LIST_list (&ready_list);\n \n   /* Fixing jump's dependences.  */"}, {"sha": "5e07880a10bc5ee8718616c79399f2e3a08ef1d1", "filename": "gcc/lists.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -101,15 +101,15 @@ remove_list_elem (rtx elem, rtx *listp)\n /* This call is used in place of a gen_rtx_INSN_LIST. If there is a cached\n    node available, we'll use it, otherwise a call to gen_rtx_INSN_LIST\n    is made.  */\n-rtx\n+rtx_insn_list *\n alloc_INSN_LIST (rtx val, rtx next)\n {\n-  rtx r;\n+  rtx_insn_list *r;\n \n   if (unused_insn_list)\n     {\n-      r = unused_insn_list;\n-      unused_insn_list = XEXP (r, 1);\n+      r = as_a <rtx_insn_list *> (unused_insn_list);\n+      unused_insn_list = r->next ();\n       XEXP (r, 0) = val;\n       XEXP (r, 1) = next;\n       PUT_REG_NOTE_KIND (r, VOIDmode);\n@@ -155,39 +155,39 @@ free_EXPR_LIST_list (rtx *listp)\n \n /* This function will free up an entire list of INSN_LIST nodes.  */\n void\n-free_INSN_LIST_list (rtx *listp)\n+free_INSN_LIST_list (rtx_insn_list **listp)\n {\n   if (*listp == 0)\n     return;\n-  free_list (listp, &unused_insn_list);\n+  free_list ((rtx *)listp, &unused_insn_list);\n }\n \n /* Make a copy of the INSN_LIST list LINK and return it.  */\n-rtx\n-copy_INSN_LIST (rtx link)\n+rtx_insn_list *\n+copy_INSN_LIST (rtx_insn_list *link)\n {\n-  rtx new_queue;\n-  rtx *pqueue = &new_queue;\n+  rtx_insn_list *new_queue;\n+  rtx_insn_list **pqueue = &new_queue;\n \n-  for (; link; link = XEXP (link, 1))\n+  for (; link; link = link->next ())\n     {\n-      rtx x = XEXP (link, 0);\n-      rtx newlink = alloc_INSN_LIST (x, NULL);\n+      rtx_insn *x = link->insn ();\n+      rtx_insn_list *newlink = alloc_INSN_LIST (x, NULL);\n       *pqueue = newlink;\n-      pqueue = &XEXP (newlink, 1);\n+      pqueue = (rtx_insn_list **)&XEXP (newlink, 1);\n     }\n-  *pqueue = NULL_RTX;\n+  *pqueue = NULL;\n   return new_queue;\n }\n \n /* Duplicate the INSN_LIST elements of COPY and prepend them to OLD.  */\n-rtx\n-concat_INSN_LIST (rtx copy, rtx old)\n+rtx_insn_list *\n+concat_INSN_LIST (rtx_insn_list *copy, rtx_insn_list *old)\n {\n-  rtx new_rtx = old;\n-  for (; copy ; copy = XEXP (copy, 1))\n+  rtx_insn_list *new_rtx = old;\n+  for (; copy ; copy = copy->next ())\n     {\n-      new_rtx = alloc_INSN_LIST (XEXP (copy, 0), new_rtx);\n+      new_rtx = alloc_INSN_LIST (copy->insn (), new_rtx);\n       PUT_REG_NOTE_KIND (new_rtx, REG_NOTE_KIND (copy));\n     }\n   return new_rtx;\n@@ -213,19 +213,19 @@ free_INSN_LIST_node (rtx ptr)\n /* Remove and free corresponding to ELEM node in the INSN_LIST pointed to\n    by LISTP.  */\n void\n-remove_free_INSN_LIST_elem (rtx elem, rtx *listp)\n+remove_free_INSN_LIST_elem (rtx_insn *elem, rtx_insn_list **listp)\n {\n-  free_INSN_LIST_node (remove_list_elem (elem, listp));\n+  free_INSN_LIST_node (remove_list_elem (elem, (rtx *)listp));\n }\n \n /* Remove and free the first node in the INSN_LIST pointed to by LISTP.  */\n-rtx\n-remove_free_INSN_LIST_node (rtx *listp)\n+rtx_insn *\n+remove_free_INSN_LIST_node (rtx_insn_list **listp)\n {\n-  rtx node = *listp;\n-  rtx elem = XEXP (node, 0);\n+  rtx_insn_list *node = *listp;\n+  rtx_insn *elem = node->insn ();\n \n-  remove_list_node (listp);\n+  remove_list_node ((rtx *)listp);\n   free_INSN_LIST_node (node);\n \n   return elem;"}, {"sha": "0062a0c03f9ec11bf1d07b2631a1ac66ac83f60f", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -2776,16 +2776,16 @@ extern void subreg_get_info (unsigned int, enum machine_mode,\n /* lists.c */\n \n extern void free_EXPR_LIST_list (rtx *);\n-extern void free_INSN_LIST_list (rtx *);\n+extern void free_INSN_LIST_list (rtx_insn_list **);\n extern void free_EXPR_LIST_node (rtx);\n extern void free_INSN_LIST_node (rtx);\n-extern rtx alloc_INSN_LIST (rtx, rtx);\n-extern rtx copy_INSN_LIST (rtx);\n-extern rtx concat_INSN_LIST (rtx, rtx);\n+extern rtx_insn_list *alloc_INSN_LIST (rtx, rtx);\n+extern rtx_insn_list *copy_INSN_LIST (rtx_insn_list *);\n+extern rtx_insn_list *concat_INSN_LIST (rtx_insn_list *, rtx_insn_list *);\n extern rtx alloc_EXPR_LIST (int, rtx, rtx);\n-extern void remove_free_INSN_LIST_elem (rtx, rtx *);\n+extern void remove_free_INSN_LIST_elem (rtx_insn *, rtx_insn_list **);\n extern rtx remove_list_elem (rtx, rtx *);\n-extern rtx remove_free_INSN_LIST_node (rtx *);\n+extern rtx_insn *remove_free_INSN_LIST_node (rtx_insn_list **);\n extern rtx remove_free_EXPR_LIST_node (rtx *);\n \n "}, {"sha": "fb1b658b60ce76e1b307bc4c3298a892875f2491", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -483,9 +483,11 @@ static bool mark_as_hard;\n \n static int deps_may_trap_p (const_rtx);\n static void add_dependence_1 (rtx_insn *, rtx_insn *, enum reg_note);\n-static void add_dependence_list (rtx_insn *, rtx, int, enum reg_note, bool);\n+static void add_dependence_list (rtx_insn *, rtx_insn_list *, int,\n+\t\t\t\t enum reg_note, bool);\n static void add_dependence_list_and_free (struct deps_desc *, rtx_insn *,\n-\t\t\t\t\t  rtx *, int, enum reg_note, bool);\n+\t\t\t\t\t  rtx_insn_list **, int, enum reg_note,\n+\t\t\t\t\t  bool);\n static void delete_all_dependences (rtx);\n static void chain_to_prev_insn (rtx_insn *);\n \n@@ -1561,14 +1563,14 @@ add_dependence (rtx_insn *con, rtx_insn *pro, enum reg_note dep_type)\n    true if DEP_NONREG should be set on newly created dependencies.  */\n \n static void\n-add_dependence_list (rtx_insn *insn, rtx list, int uncond, enum reg_note dep_type,\n-\t\t     bool hard)\n+add_dependence_list (rtx_insn *insn, rtx_insn_list *list, int uncond,\n+\t\t     enum reg_note dep_type, bool hard)\n {\n   mark_as_hard = hard;\n-  for (; list; list = XEXP (list, 1))\n+  for (; list; list = list->next ())\n     {\n-      if (uncond || ! sched_insns_conditions_mutex_p (insn, XEXP (list, 0)))\n-\tadd_dependence (insn, as_a <rtx_insn *> (XEXP (list, 0)), dep_type);\n+      if (uncond || ! sched_insns_conditions_mutex_p (insn, list->insn ()))\n+\tadd_dependence (insn, list->insn (), dep_type);\n     }\n   mark_as_hard = false;\n }\n@@ -1578,7 +1580,8 @@ add_dependence_list (rtx_insn *insn, rtx list, int uncond, enum reg_note dep_typ\n    newly created dependencies.  */\n \n static void\n-add_dependence_list_and_free (struct deps_desc *deps, rtx_insn *insn, rtx *listp,\n+add_dependence_list_and_free (struct deps_desc *deps, rtx_insn *insn,\n+\t\t\t      rtx_insn_list **listp,\n                               int uncond, enum reg_note dep_type, bool hard)\n {\n   add_dependence_list (insn, *listp, uncond, dep_type, hard);\n@@ -1596,28 +1599,30 @@ add_dependence_list_and_free (struct deps_desc *deps, rtx_insn *insn, rtx *listp\n    occurrences removed.  */\n \n static int\n-remove_from_dependence_list (rtx insn, rtx* listp)\n+remove_from_dependence_list (rtx insn, rtx_insn_list **listp)\n {\n   int removed = 0;\n \n   while (*listp)\n     {\n-      if (XEXP (*listp, 0) == insn)\n+      if ((*listp)->insn () == insn)\n         {\n           remove_free_INSN_LIST_node (listp);\n           removed++;\n           continue;\n         }\n \n-      listp = &XEXP (*listp, 1);\n+      listp = (rtx_insn_list **)&XEXP (*listp, 1);\n     }\n \n   return removed;\n }\n \n /* Same as above, but process two lists at once.  */\n static int\n-remove_from_both_dependence_lists (rtx insn, rtx *listp, rtx *exprp)\n+remove_from_both_dependence_lists (rtx insn,\n+\t\t\t\t   rtx_insn_list **listp,\n+\t\t\t\t   rtx *exprp)\n {\n   int removed = 0;\n \n@@ -1631,7 +1636,7 @@ remove_from_both_dependence_lists (rtx insn, rtx *listp, rtx *exprp)\n           continue;\n         }\n \n-      listp = &XEXP (*listp, 1);\n+      listp = (rtx_insn_list **)&XEXP (*listp, 1);\n       exprp = &XEXP (*exprp, 1);\n     }\n \n@@ -1712,9 +1717,10 @@ static void\n add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n \t\t\t rtx_insn *insn, rtx mem)\n {\n-  rtx *insn_list;\n+  rtx_insn_list **insn_list;\n+  rtx_insn_list *insn_node;\n   rtx *mem_list;\n-  rtx link;\n+  rtx mem_node;\n \n   gcc_assert (!deps->readonly);\n   if (read_p)\n@@ -1731,17 +1737,17 @@ add_insn_mem_dependence (struct deps_desc *deps, bool read_p,\n       deps->pending_write_list_length++;\n     }\n \n-  link = alloc_INSN_LIST (insn, *insn_list);\n-  *insn_list = link;\n+  insn_node = alloc_INSN_LIST (insn, *insn_list);\n+  *insn_list = insn_node;\n \n   if (sched_deps_info->use_cselib)\n     {\n       mem = shallow_copy_rtx (mem);\n       XEXP (mem, 0) = cselib_subst_to_values_from_insn (XEXP (mem, 0),\n \t\t\t\t\t\t\tGET_MODE (mem), insn);\n     }\n-  link = alloc_EXPR_LIST (VOIDmode, canon_rtx (mem), *mem_list);\n-  *mem_list = link;\n+  mem_node = alloc_EXPR_LIST (VOIDmode, canon_rtx (mem), *mem_list);\n+  *mem_list = mem_node;\n }\n \n /* Make a dependency between every memory reference on the pending lists\n@@ -3603,7 +3609,7 @@ deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n       rtx t;\n       sched_get_condition_with_rev (insn, NULL);\n       t = INSN_CACHED_COND (insn);\n-      INSN_COND_DEPS (insn) = NULL_RTX;\n+      INSN_COND_DEPS (insn) = NULL;\n       if (reload_completed\n \t  && (current_sched_info->flags & DO_PREDICATION)\n \t  && COMPARISON_P (t)\n@@ -3612,18 +3618,18 @@ deps_analyze_insn (struct deps_desc *deps, rtx_insn *insn)\n \t{\n \t  unsigned int regno;\n \t  int nregs;\n+\t  rtx_insn_list *cond_deps = NULL;\n \t  t = XEXP (t, 0);\n \t  regno = REGNO (t);\n \t  nregs = hard_regno_nregs[regno][GET_MODE (t)];\n-\t  t = NULL_RTX;\n \t  while (nregs-- > 0)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[regno + nregs];\n-\t      t = concat_INSN_LIST (reg_last->sets, t);\n-\t      t = concat_INSN_LIST (reg_last->clobbers, t);\n-\t      t = concat_INSN_LIST (reg_last->implicit_sets, t);\n+\t      cond_deps = concat_INSN_LIST (reg_last->sets, cond_deps);\n+\t      cond_deps = concat_INSN_LIST (reg_last->clobbers, cond_deps);\n+\t      cond_deps = concat_INSN_LIST (reg_last->implicit_sets, cond_deps);\n \t    }\n-\t  INSN_COND_DEPS (insn) = t;\n+\t  INSN_COND_DEPS (insn) = cond_deps;\n \t}\n     }\n \n@@ -3968,7 +3974,7 @@ free_deps (struct deps_desc *deps)\n \n /* Remove INSN from dependence contexts DEPS.  */\n void\n-remove_from_deps (struct deps_desc *deps, rtx insn)\n+remove_from_deps (struct deps_desc *deps, rtx_insn *insn)\n {\n   int removed;\n   unsigned i;"}, {"sha": "f8e5e74a44f30861795c33ebfb6eec84e06a45b8", "filename": "gcc/sched-int.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -449,11 +449,11 @@ enum post_call_group\n /* Insns which affect pseudo-registers.  */\n struct deps_reg\n {\n-  rtx uses;\n-  rtx sets;\n-  rtx implicit_sets;\n-  rtx control_uses;\n-  rtx clobbers;\n+  rtx_insn_list *uses;\n+  rtx_insn_list *sets;\n+  rtx_insn_list *implicit_sets;\n+  rtx_insn_list *control_uses;\n+  rtx_insn_list *clobbers;\n   int uses_length;\n   int clobbers_length;\n };\n@@ -471,19 +471,19 @@ struct deps_desc\n      to a list more than once.  */\n \n   /* An INSN_LIST containing all insns with pending read operations.  */\n-  rtx pending_read_insns;\n+  rtx_insn_list *pending_read_insns;\n \n   /* An EXPR_LIST containing all MEM rtx's which are pending reads.  */\n   rtx pending_read_mems;\n \n   /* An INSN_LIST containing all insns with pending write operations.  */\n-  rtx pending_write_insns;\n+  rtx_insn_list *pending_write_insns;\n \n   /* An EXPR_LIST containing all MEM rtx's which are pending writes.  */\n   rtx pending_write_mems;\n \n   /* An INSN_LIST containing all jump insns.  */\n-  rtx pending_jump_insns;\n+  rtx_insn_list *pending_jump_insns;\n \n   /* We must prevent the above lists from ever growing too large since\n      the number of dependencies produced is at least O(N*N),\n@@ -510,27 +510,27 @@ struct deps_desc\n      alias analysis, this restriction can be relaxed.\n      This may also be an INSN that writes memory if the pending lists grow\n      too large.  */\n-  rtx last_pending_memory_flush;\n+  rtx_insn_list *last_pending_memory_flush;\n \n   /* A list of the last function calls we have seen.  We use a list to\n      represent last function calls from multiple predecessor blocks.\n      Used to prevent register lifetimes from expanding unnecessarily.  */\n-  rtx last_function_call;\n+  rtx_insn_list *last_function_call;\n \n   /* A list of the last function calls that may not return normally\n      we have seen.  We use a list to represent last function calls from\n      multiple predecessor blocks.  Used to prevent moving trapping insns\n      across such calls.  */\n-  rtx last_function_call_may_noreturn;\n+  rtx_insn_list *last_function_call_may_noreturn;\n \n   /* A list of insns which use a pseudo register that does not already\n      cross a call.  We create dependencies between each of those insn\n      and the next call insn, to ensure that they won't cross a call after\n      scheduling is done.  */\n-  rtx sched_before_next_call;\n+  rtx_insn_list *sched_before_next_call;\n \n   /* Similarly, a list of insns which should not cross a branch.  */\n-  rtx sched_before_next_jump;\n+  rtx_insn_list *sched_before_next_jump;\n \n   /* Used to keep post-call pseudo/hard reg movements together with\n      the call.  */\n@@ -737,7 +737,7 @@ struct _haifa_deps_insn_data\n \n   /* For a conditional insn, a list of insns that could set the condition\n      register.  Used when generating control dependencies.  */\n-  rtx cond_deps;\n+  rtx_insn_list *cond_deps;\n \n   /* True if the condition in 'cond' should be reversed to get the actual\n      condition.  */\n@@ -1302,7 +1302,7 @@ extern void free_deps (struct deps_desc *);\n extern void init_deps_global (void);\n extern void finish_deps_global (void);\n extern void deps_analyze_insn (struct deps_desc *, rtx_insn *);\n-extern void remove_from_deps (struct deps_desc *, rtx);\n+extern void remove_from_deps (struct deps_desc *, rtx_insn *);\n extern void init_insn_reg_pressure_info (rtx);\n \n extern dw_t get_dep_weak (ds_t, ds_t);"}, {"sha": "92a8a27ea84bbe296b911689cd6acc109aae1308", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -240,7 +240,8 @@ static void add_branch_dependences (rtx_insn *, rtx_insn *);\n static void compute_block_dependences (int);\n \n static void schedule_region (int);\n-static void concat_insn_mem_list (rtx, rtx, rtx *, rtx *);\n+static void concat_insn_mem_list (rtx_insn_list *, rtx,\n+\t\t\t\t  rtx_insn_list **, rtx *);\n static void propagate_deps (int, struct deps_desc *);\n static void free_pending_lists (void);\n \n@@ -2584,17 +2585,18 @@ add_branch_dependences (rtx_insn *head, rtx_insn *tail)\n static struct deps_desc *bb_deps;\n \n static void\n-concat_insn_mem_list (rtx copy_insns, rtx copy_mems, rtx *old_insns_p,\n+concat_insn_mem_list (rtx_insn_list *copy_insns, rtx copy_mems,\n+\t\t      rtx_insn_list **old_insns_p,\n \t\t      rtx *old_mems_p)\n {\n-  rtx new_insns = *old_insns_p;\n+  rtx_insn_list *new_insns = *old_insns_p;\n   rtx new_mems = *old_mems_p;\n \n   while (copy_insns)\n     {\n-      new_insns = alloc_INSN_LIST (XEXP (copy_insns, 0), new_insns);\n+      new_insns = alloc_INSN_LIST (copy_insns->insn (), new_insns);\n       new_mems = alloc_EXPR_LIST (VOIDmode, XEXP (copy_mems, 0), new_mems);\n-      copy_insns = XEXP (copy_insns, 1);\n+      copy_insns = copy_insns->next ();\n       copy_mems = XEXP (copy_mems, 1);\n     }\n "}, {"sha": "fdbc6b3631c4c2504a530c573d069774cd5cd1e5", "filename": "gcc/store-motion.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fstore-motion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3dc99c19a5203597ca0bf8f39aea7028f17e80ba/gcc%2Fstore-motion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstore-motion.c?ref=3dc99c19a5203597ca0bf8f39aea7028f17e80ba", "patch": "@@ -72,9 +72,9 @@ struct st_expr\n   /* List of registers mentioned by the mem.  */\n   rtx pattern_regs;\n   /* INSN list of stores that are locally anticipatable.  */\n-  rtx antic_stores;\n+  rtx_insn_list *antic_stores;\n   /* INSN list of stores that are locally available.  */\n-  rtx avail_stores;\n+  rtx_insn_list *avail_stores;\n   /* Next in the list.  */\n   struct st_expr * next;\n   /* Store ID in the dataflow bitmaps.  */\n@@ -156,8 +156,8 @@ st_expr_entry (rtx x)\n   ptr->next         = store_motion_mems;\n   ptr->pattern      = x;\n   ptr->pattern_regs = NULL_RTX;\n-  ptr->antic_stores = NULL_RTX;\n-  ptr->avail_stores = NULL_RTX;\n+  ptr->antic_stores = NULL;\n+  ptr->avail_stores = NULL;\n   ptr->reaching_reg = NULL_RTX;\n   ptr->index        = 0;\n   ptr->hash_index   = hash;\n@@ -540,7 +540,7 @@ static void\n find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n {\n   struct st_expr * ptr;\n-  rtx dest, set, tmp;\n+  rtx dest, set;\n   int check_anticipatable, check_available;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n \n@@ -587,15 +587,16 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n     check_anticipatable = 1;\n   else\n     {\n-      tmp = XEXP (ptr->antic_stores, 0);\n+      rtx_insn *tmp = ptr->antic_stores->insn ();\n       if (tmp != NULL_RTX\n \t  && BLOCK_FOR_INSN (tmp) != bb)\n \tcheck_anticipatable = 1;\n     }\n   if (check_anticipatable)\n     {\n+      rtx_insn *tmp;\n       if (store_killed_before (dest, ptr->pattern_regs, insn, bb, regs_set_before))\n-\ttmp = NULL_RTX;\n+\ttmp = NULL;\n       else\n \ttmp = insn;\n       ptr->antic_stores = alloc_INSN_LIST (tmp, ptr->antic_stores);\n@@ -609,7 +610,7 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n     check_available = 1;\n   else\n     {\n-      tmp = XEXP (ptr->avail_stores, 0);\n+      rtx_insn *tmp = ptr->avail_stores->insn ();\n       if (BLOCK_FOR_INSN (tmp) != bb)\n \tcheck_available = 1;\n     }\n@@ -619,6 +620,7 @@ find_moveable_store (rtx_insn *insn, int *regs_set_before, int *regs_set_after)\n \t failed last time.  */\n       if (LAST_AVAIL_CHECK_FAILURE (ptr))\n \t{\n+\t  rtx_insn *tmp;\n \t  for (tmp = BB_END (bb);\n \t       tmp != insn && tmp != LAST_AVAIL_CHECK_FAILURE (ptr);\n \t       tmp = PREV_INSN (tmp))\n@@ -646,7 +648,7 @@ compute_store_table (void)\n   unsigned regno;\n #endif\n   rtx_insn *insn;\n-  rtx tmp;\n+  rtx_insn *tmp;\n   df_ref def;\n   int *last_set_in, *already_set;\n   struct st_expr * ptr, **prev_next_ptr_ptr;\n@@ -701,8 +703,8 @@ compute_store_table (void)\n \t{\n \t  LAST_AVAIL_CHECK_FAILURE (ptr) = NULL_RTX;\n \t  if (ptr->antic_stores\n-\t      && (tmp = XEXP (ptr->antic_stores, 0)) == NULL_RTX)\n-\t    ptr->antic_stores = XEXP (ptr->antic_stores, 1);\n+\t      && (tmp = ptr->antic_stores->insn ()) == NULL_RTX)\n+\t    ptr->antic_stores = ptr->antic_stores->next ();\n \t}\n     }\n "}]}