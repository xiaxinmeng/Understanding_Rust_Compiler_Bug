{"sha": "ae9dd7f3f8219057b459356c8234bf4aa73f7e1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU5ZGQ3ZjNmODIxOTA1N2I0NTkzNTZjODIzNGJmNGFhNzNmN2UxZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2016-02-08T15:31:08Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2016-02-08T15:31:08Z"}, "message": "Fix latent LRA remat issue (PR68730)\n\n\tPR rtl-optimization/68730\n\t* lra-remat.c (insn_to_cand_activation): New static variable.\n\t(lra_remat): Allocate and free it.\n\t(create_cand): New arg activation. Initialize a field in\n\tinsn_to_cand_activation if it is nonnull.\n\t(create_cands): Pass the activation insn to create_cand when making\n\ta candidate involving an output reload.  Reorganize code a little.\n\t(do_remat): Keep track of active status of candidates in a separate\n\tbitmap.\n\nFrom-SVN: r233215", "tree": {"sha": "926bd312ed99ba97b6fefe135eac0adb86a7ae0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/926bd312ed99ba97b6fefe135eac0adb86a7ae0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e/comments", "author": null, "committer": null, "parents": [{"sha": "cc07da33ae9cf86c308f6a7858d7d8faa73d63e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc07da33ae9cf86c308f6a7858d7d8faa73d63e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc07da33ae9cf86c308f6a7858d7d8faa73d63e1"}], "stats": {"total": 128, "additions": 90, "deletions": 38}, "files": [{"sha": "66deab1c410962e187381cabd31e63fd29ddc8c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae9dd7f3f8219057b459356c8234bf4aa73f7e1e", "patch": "@@ -1,3 +1,15 @@\n+2016-02-08  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR rtl-optimization/68730\n+\t* lra-remat.c (insn_to_cand_activation): New static variable.\n+\t(lra_remat): Allocate and free it.\n+\t(create_cand): New arg activation. Initialize a field in\n+\tinsn_to_cand_activation if it is nonnull.\n+\t(create_cands): Pass the activation insn to create_cand when making\n+\ta candidate involving an output reload.  Reorganize code a little.\n+\t(do_remat): Keep track of active status of candidates in a separate\n+\tbitmap.\n+\n 2016-02-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69719\n@@ -30,7 +42,6 @@\n \t* tree-ssa-scopedtables.c\n \t(const_and_copies::record_const_or_copy_raw): New, factored out of\n \t(const_and_copies::record_const_or_copy): Call new member function.\n-\t\n \n 2016-02-05  Jeff Law  <law@redhat.com>\n "}, {"sha": "785d53190f27cb873a77cccf458c6d22ece855b2", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 78, "deletions": 37, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9dd7f3f8219057b459356c8234bf4aa73f7e1e/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=ae9dd7f3f8219057b459356c8234bf4aa73f7e1e", "patch": "@@ -112,6 +112,10 @@ static vec<cand_t> all_cands;\n /* Map: insn -> candidate representing it.  It is null if the insn can\n    not be used for rematerialization.  */\n static cand_t *insn_to_cand;\n+/* A secondary map, for candidates that involve two insns, where the\n+   second one makes the equivalence.  The candidate must not be used\n+   before seeing this activation insn.  */\n+static cand_t *insn_to_cand_activation;\n \n /* Map regno -> candidates can be used for the regno\n    rematerialization.  */\n@@ -461,7 +465,7 @@ operand_to_remat (rtx_insn *insn)\n    REGNO.  Insert the candidate into the table and set up the\n    corresponding INSN_TO_CAND element.  */\n static void\n-create_cand (rtx_insn *insn, int nop, int regno)\n+create_cand (rtx_insn *insn, int nop, int regno, rtx_insn *activation = NULL)\n {\n   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n   rtx reg = *id->operand_loc[nop];\n@@ -486,6 +490,8 @@ create_cand (rtx_insn *insn, int nop, int regno)\n       cand->next_regno_cand = regno_cands[cand->regno];\n       regno_cands[cand->regno] = cand;\n     }\n+  if (activation)\n+    insn_to_cand_activation[INSN_UID (activation)] = cand_in_table;\n }\n \n /* Create rematerialization candidates (inserting them into the\n@@ -504,43 +510,55 @@ create_cands (void)\n   /* Create candidates.  */\n   regno_potential_cand = XCNEWVEC (struct potential_cand, max_reg_num ());\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n+    if (NONDEBUG_INSN_P (insn))\n       {\n-\trtx set;\n-\tint src_regno, dst_regno;\n-\trtx_insn *insn2;\n \tlra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n-\tint nop = operand_to_remat (insn);\n-\tint regno = -1;\n-\n-\tif ((set = single_set (insn)) != NULL\n-\t    && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))\n-\t    && ((src_regno = REGNO (SET_SRC (set)))\n-\t\t>= lra_constraint_new_regno_start)\n-\t    && (dst_regno = REGNO (SET_DEST (set))) >= FIRST_PSEUDO_REGISTER\n-\t    && reg_renumber[dst_regno] < 0\n-\t    && (insn2 = regno_potential_cand[src_regno].insn) != NULL\n-\t    && BLOCK_FOR_INSN (insn2) == BLOCK_FOR_INSN (insn))\n-\t  /* It is an output reload insn after insn can be\n-\t     rematerialized (potential candidate).  */\n-\t  create_cand (insn2, regno_potential_cand[src_regno].nop, dst_regno);\n-\tif (nop < 0)\n-\t  goto fail;\n-\tgcc_assert (REG_P (*id->operand_loc[nop]));\n- \tregno = REGNO (*id->operand_loc[nop]);\n-\tgcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n-\tif (reg_renumber[regno] < 0)\n-\t  create_cand (insn, nop, regno);\n-\telse\n+\tint keep_regno = -1;\n+\trtx set = single_set (insn);\n+\tint nop;\n+\n+\t/* See if this is an output reload for a previous insn.  */\n+\tif (set != NULL\n+\t    && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set)))\n+\t  {\n+\t    rtx dstreg = SET_DEST (set);\n+\t    int src_regno = REGNO (SET_SRC (set));\n+\t    int dst_regno = REGNO (dstreg);\n+\t    rtx_insn *insn2 = regno_potential_cand[src_regno].insn;\n+\n+\t    if (insn2 != NULL \n+\t\t&& dst_regno >= FIRST_PSEUDO_REGISTER\n+\t\t&& reg_renumber[dst_regno] < 0\n+\t\t&& BLOCK_FOR_INSN (insn2) == BLOCK_FOR_INSN (insn))\n+\t      {\n+\t\tcreate_cand (insn2, regno_potential_cand[src_regno].nop,\n+\t\t\t     dst_regno, insn);\n+\t\tgoto done;\n+\t      }\n+\t  }\n+\n+\tnop = operand_to_remat (insn);\n+\tif (nop >= 0)\n \t  {\n-\t    regno_potential_cand[regno].insn = insn;\n-\t    regno_potential_cand[regno].nop = nop;\n-\t    goto fail;\n+\t    gcc_assert (REG_P (*id->operand_loc[nop]));\n+\t    int regno = REGNO (*id->operand_loc[nop]);\n+\t    gcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n+\t    /* If we're setting an unrenumbered pseudo, make a candidate immediately.\n+\t       If it's an output reload register, save it for later; the code above\n+\t       looks for output reload insns later on.  */\n+\t    if (reg_renumber[regno] < 0)\n+\t      create_cand (insn, nop, regno);\n+\t    else if (regno >= lra_constraint_new_regno_start)\n+\t      {\n+\t\tregno_potential_cand[regno].insn = insn;\n+\t\tregno_potential_cand[regno].nop = nop;\n+\t\tkeep_regno = regno;\n+\t      }\n \t  }\n-\tregno = -1;\n-      fail:\n+\n+      done:\n \tfor (struct lra_insn_reg *reg = id->regs; reg != NULL; reg = reg->next)\n-\t  if (reg->type != OP_IN && reg->regno != regno\n+\t  if (reg->type != OP_IN && reg->regno != keep_regno\n \t      && reg->regno >= FIRST_PSEUDO_REGISTER)\n \t    regno_potential_cand[reg->regno].insn = NULL;\n       }\n@@ -1072,16 +1090,21 @@ do_remat (void)\n   rtx_insn *insn;\n   basic_block bb;\n   bitmap_head avail_cands;\n+  bitmap_head active_cands;\n   bool changed_p = false;\n   /* Living hard regs and hard registers of living pseudos.  */\n   HARD_REG_SET live_hard_regs;\n \n   bitmap_initialize (&avail_cands, &reg_obstack);\n+  bitmap_initialize (&active_cands, &reg_obstack);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       REG_SET_TO_HARD_REG_SET (live_hard_regs, df_get_live_out (bb));\n       bitmap_and (&avail_cands, &get_remat_bb_data (bb)->avin_cands,\n \t\t  &get_remat_bb_data (bb)->livein_cands);\n+      /* Activating insns are always in the same block as their corresponding\n+\t remat insn, so at the start of a block the two bitsets are equal.  */\n+      bitmap_copy (&active_cands, &avail_cands);\n       FOR_BB_INSNS (bb, insn)\n \t{\n \t  if (!NONDEBUG_INSN_P (insn))\n@@ -1115,7 +1138,8 @@ do_remat (void)\n \t      for (cand = regno_cands[src_regno];\n \t\t   cand != NULL;\n \t\t   cand = cand->next_regno_cand)\n-\t\tif (bitmap_bit_p (&avail_cands, cand->index))\n+\t\tif (bitmap_bit_p (&avail_cands, cand->index)\n+\t\t    && bitmap_bit_p (&active_cands, cand->index))\n \t\t  break;\n \t    }\n \t  int i, hard_regno, nregs;\n@@ -1209,9 +1233,23 @@ do_remat (void)\n \t      }\n \n \t  bitmap_and_compl_into (&avail_cands, &temp_bitmap);\n-\t  if ((cand = insn_to_cand[INSN_UID (insn)]) != NULL)\n-\t    bitmap_set_bit (&avail_cands, cand->index);\n-\t    \n+\n+\t  /* Now see whether a candidate is made active or available\n+\t     by this insn.  */\n+\t  cand = insn_to_cand_activation[INSN_UID (insn)];\n+\t  if (cand)\n+\t    bitmap_set_bit (&active_cands, cand->index);\n+\n+\t  cand = insn_to_cand[INSN_UID (insn)];\n+\t  if (cand != NULL)\n+\t    {\n+\t      bitmap_set_bit (&avail_cands, cand->index);\n+\t      if (cand->reload_regno == -1)\n+\t\tbitmap_set_bit (&active_cands, cand->index);\n+\t      else\n+\t\tbitmap_clear_bit (&active_cands, cand->index);\n+\t    }\n+\n \t  if (remat_insn != NULL)\n \t    {\n \t      HOST_WIDE_INT sp_offset_change = cand_sp_offset - id->sp_offset;\n@@ -1258,6 +1296,7 @@ do_remat (void)\n \t}\n     }\n   bitmap_clear (&avail_cands);\n+  bitmap_clear (&active_cands);\n   return changed_p;\n }\n \n@@ -1286,6 +1325,7 @@ lra_remat (void)\n \t     lra_rematerialization_iter);\n   timevar_push (TV_LRA_REMAT);\n   insn_to_cand = XCNEWVEC (cand_t, get_max_uid ());\n+  insn_to_cand_activation = XCNEWVEC (cand_t, get_max_uid ());\n   regno_cands = XCNEWVEC (cand_t, max_regno);\n   all_cands.create (8000);\n   call_used_regs_arr_len = 0;\n@@ -1314,6 +1354,7 @@ lra_remat (void)\n   bitmap_clear (&all_blocks);\n   free (regno_cands);\n   free (insn_to_cand);\n+  free (insn_to_cand_activation);\n   timevar_pop (TV_LRA_REMAT);\n   return result;\n }"}]}