{"sha": "90cbaa297823c469ca50c5b51b9e1835d944a886", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjYmFhMjk3ODIzYzQ2OWNhNTBjNWI1MWI5ZTE4MzVkOTQ0YTg4Ng==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-04-30T16:47:02Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-04-30T16:47:02Z"}, "message": "go-gcc.cc: #include \"langhooks.h\".\n\n\t* go-gcc.cc: #include \"langhooks.h\".\n\t(Gcc_backend::Gcc_backend): Add constructor.\n\t(Gcc_backend::lookup_function): New function.\n\t(Gcc_backend::define_builtin): New private function.\n\t(Gcc_backend::gcc_backend): Remove.\n\t(go_get_backend): Use new to create new Gcc_backend.\n\nFrom-SVN: r209941", "tree": {"sha": "ab670ce8ca36df10efa0cc961272d07dfbcf5816", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab670ce8ca36df10efa0cc961272d07dfbcf5816"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90cbaa297823c469ca50c5b51b9e1835d944a886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cbaa297823c469ca50c5b51b9e1835d944a886", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90cbaa297823c469ca50c5b51b9e1835d944a886", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90cbaa297823c469ca50c5b51b9e1835d944a886/comments", "author": null, "committer": null, "parents": [{"sha": "6657487103914d2fef39467a861410500a88f798", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6657487103914d2fef39467a861410500a88f798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6657487103914d2fef39467a861410500a88f798"}], "stats": {"total": 699, "additions": 290, "deletions": 409}, "files": [{"sha": "8d86e746d6e54b76380da1d770d78e514242843d", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -1,3 +1,12 @@\n+2014-04-30  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc: #include \"langhooks.h\".\n+\t(Gcc_backend::Gcc_backend): Add constructor.\n+\t(Gcc_backend::lookup_function): New function.\n+\t(Gcc_backend::define_builtin): New private function.\n+\t(Gcc_backend::gcc_backend): Remove.\n+\t(go_get_backend): Use new to create new Gcc_backend.\n+\n 2014-04-25  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc: Include \"cgraph.h\" and \"gimplify.h\"."}, {"sha": "0f3f44b32b8d1bda783df4c40e4e673ba7266b13", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 216, "deletions": 3, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -34,6 +34,7 @@\n #include \"basic-block.h\"\n #include \"gimple-expr.h\"\n #include \"gimplify.h\"\n+#include \"langhooks.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"real.h\"\n@@ -131,6 +132,8 @@ class Blabel : public Gcc_tree\n class Gcc_backend : public Backend\n {\n  public:\n+  Gcc_backend();\n+\n   // Types.\n \n   Btype*\n@@ -425,6 +428,9 @@ class Gcc_backend : public Backend\n   bool\n   function_set_body(Bfunction* function, Bstatement* code_stmt);\n \n+  Bfunction*\n+  lookup_builtin(const std::string&);\n+\n   void\n   write_global_definitions(const std::vector<Btype*>&,\n                            const std::vector<Bexpression*>&,\n@@ -459,6 +465,14 @@ class Gcc_backend : public Backend\n \n   tree\n   non_zero_size_type(tree);\n+\n+private:\n+  void\n+  define_builtin(built_in_function bcode, const char* name, const char* libname,\n+\t\t tree fntype, bool const_p);\n+\n+  // A mapping of the GCC built-ins exposed to GCCGo.\n+  std::map<std::string, Bfunction*> builtin_functions_;\n };\n \n // A helper function.\n@@ -469,6 +483,172 @@ get_identifier_from_string(const std::string& str)\n   return get_identifier_with_length(str.data(), str.length());\n }\n \n+// Define the built-in functions that are exposed to GCCGo.\n+\n+Gcc_backend::Gcc_backend()\n+{\n+  /* We need to define the fetch_and_add functions, since we use them\n+     for ++ and --.  */\n+  tree t = this->integer_type(BITS_PER_UNIT, 1)->get_tree();\n+  tree p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  this->define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\",\n+\t\t       NULL, build_function_type_list(t, p, t, NULL_TREE),\n+\t\t       false);\n+\n+  t = this->integer_type(BITS_PER_UNIT * 2, 1)->get_tree();\n+  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  this->define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\",\n+\t\t       NULL, build_function_type_list(t, p, t, NULL_TREE),\n+\t\t       false);\n+\n+  t = this->integer_type(BITS_PER_UNIT * 4, 1)->get_tree();\n+  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  this->define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\",\n+\t\t       NULL, build_function_type_list(t, p, t, NULL_TREE),\n+\t\t       false);\n+\n+  t = this->integer_type(BITS_PER_UNIT * 8, 1)->get_tree();\n+  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  this->define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\",\n+\t\t       NULL, build_function_type_list(t, p, t, NULL_TREE),\n+\t\t       false);\n+\n+  // We use __builtin_expect for magic import functions.\n+  this->define_builtin(BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n+\t\t       build_function_type_list(long_integer_type_node,\n+\t\t\t\t\t\tlong_integer_type_node,\n+\t\t\t\t\t\tlong_integer_type_node,\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t       true);\n+\n+  // We use __builtin_memcmp for struct comparisons.\n+  this->define_builtin(BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n+\t\t       build_function_type_list(integer_type_node,\n+\t\t\t\t\t\tconst_ptr_type_node,\n+\t\t\t\t\t\tconst_ptr_type_node,\n+\t\t\t\t\t\tsize_type_node,\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t       false);\n+\n+  // We provide some functions for the math library.\n+  tree math_function_type = build_function_type_list(double_type_node,\n+\t\t\t\t\t\t     double_type_node,\n+\t\t\t\t\t\t     NULL_TREE);\n+  tree math_function_type_long =\n+    build_function_type_list(long_double_type_node, long_double_type_node,\n+\t\t\t     long_double_type_node, NULL_TREE);\n+  tree math_function_type_two = build_function_type_list(double_type_node,\n+\t\t\t\t\t\t\t double_type_node,\n+\t\t\t\t\t\t\t double_type_node,\n+\t\t\t\t\t\t\t NULL_TREE);\n+  tree math_function_type_long_two =\n+    build_function_type_list(long_double_type_node, long_double_type_node,\n+\t\t\t     long_double_type_node, NULL_TREE);\n+  this->define_builtin(BUILT_IN_ACOS, \"__builtin_acos\", \"acos\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_ASIN, \"__builtin_asin\", \"asin\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_ASINL, \"__builtin_asinl\", \"asinl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_ATAN, \"__builtin_atan\", \"atan\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_ATANL, \"__builtin_atanl\", \"atanl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_ATAN2, \"__builtin_atan2\", \"atan2\",\n+\t\t       math_function_type_two, true);\n+  this->define_builtin(BUILT_IN_ATAN2L, \"__builtin_atan2l\", \"atan2l\",\n+\t\t       math_function_type_long_two, true);\n+  this->define_builtin(BUILT_IN_CEIL, \"__builtin_ceil\", \"ceil\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_CEILL, \"__builtin_ceill\", \"ceill\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_COS, \"__builtin_cos\", \"cos\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_COSL, \"__builtin_cosl\", \"cosl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_EXP, \"__builtin_exp\", \"exp\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_EXPL, \"__builtin_expl\", \"expl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_EXPM1, \"__builtin_expm1\", \"expm1\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_EXPM1L, \"__builtin_expm1l\", \"expm1l\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_FABS, \"__builtin_fabs\", \"fabs\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_FABSL, \"__builtin_fabsl\", \"fabsl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_FLOOR, \"__builtin_floor\", \"floor\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_FLOORL, \"__builtin_floorl\", \"floorl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_FMOD, \"__builtin_fmod\", \"fmod\",\n+\t\t       math_function_type_two, true);\n+  this->define_builtin(BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n+\t\t       math_function_type_long_two, true);\n+  this->define_builtin(BUILT_IN_LDEXP, \"__builtin_ldexp\", \"ldexp\",\n+\t\t       build_function_type_list(double_type_node,\n+\t\t\t\t\t\tdouble_type_node,\n+\t\t\t\t\t\tinteger_type_node,\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t       true);\n+  this->define_builtin(BUILT_IN_LDEXPL, \"__builtin_ldexpl\", \"ldexpl\",\n+\t\t       build_function_type_list(long_double_type_node,\n+\t\t\t\t\t\tlong_double_type_node,\n+\t\t\t\t\t\tinteger_type_node,\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t       true);\n+  this->define_builtin(BUILT_IN_LOG, \"__builtin_log\", \"log\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_LOGL, \"__builtin_logl\", \"logl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_LOG1P, \"__builtin_log1p\", \"log1p\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_LOG1PL, \"__builtin_log1pl\", \"log1pl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_LOG10, \"__builtin_log10\", \"log10\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_LOG10L, \"__builtin_log10l\", \"log10l\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_LOG2, \"__builtin_log2\", \"log2\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_LOG2L, \"__builtin_log2l\", \"log2l\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_SIN, \"__builtin_sin\", \"sin\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_SINL, \"__builtin_sinl\", \"sinl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_TAN, \"__builtin_tan\", \"tan\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_TANL, \"__builtin_tanl\", \"tanl\",\n+\t\t       math_function_type_long, true);\n+  this->define_builtin(BUILT_IN_TRUNC, \"__builtin_trunc\", \"trunc\",\n+\t\t       math_function_type, true);\n+  this->define_builtin(BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n+\t\t       math_function_type_long, true);\n+\n+  // We use __builtin_return_address in the thunk we build for\n+  // functions which call recover.\n+  this->define_builtin(BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\",\n+\t\t       NULL,\n+\t\t       build_function_type_list(ptr_type_node,\n+\t\t\t\t\t\tunsigned_type_node,\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t       false);\n+\n+  // The compiler uses __builtin_trap for some exception handling\n+  // cases.\n+  this->define_builtin(BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n+\t\t       build_function_type(void_type_node, void_list_node),\n+\t\t       false);\n+}\n+\n // Get an unnamed integer type.\n \n Btype*\n@@ -2598,6 +2778,17 @@ Gcc_backend::function_set_body(Bfunction* function, Bstatement* code_stmt)\n   return true;\n }\n \n+// Look up a named built-in function in the current backend implementation.\n+// Returns NULL if no built-in function by that name exists.\n+\n+Bfunction*\n+Gcc_backend::lookup_builtin(const std::string& name)\n+{\n+  if (this->builtin_functions_.count(name) != 0)\n+    return this->builtin_functions_[name];\n+  return NULL;\n+}\n+\n // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n \n@@ -2680,16 +2871,38 @@ Gcc_backend::write_global_definitions(\n   delete[] defs;\n }\n \n-// The single backend.\n+// Define a builtin function.  BCODE is the builtin function code\n+// defined by builtins.def.  NAME is the name of the builtin function.\n+// LIBNAME is the name of the corresponding library function, and is\n+// NULL if there isn't one.  FNTYPE is the type of the function.\n+// CONST_P is true if the function has the const attribute.\n \n-static Gcc_backend gcc_backend;\n+void\n+Gcc_backend::define_builtin(built_in_function bcode, const char* name,\n+\t\t\t    const char* libname, tree fntype, bool const_p)\n+{\n+  tree decl = add_builtin_function(name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t   libname, NULL_TREE);\n+  if (const_p)\n+    TREE_READONLY(decl) = 1;\n+  set_builtin_decl(bcode, decl, true);\n+  this->builtin_functions_[name] = this->make_function(decl);\n+  if (libname != NULL)\n+    {\n+      decl = add_builtin_function(libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t  NULL, NULL_TREE);\n+      if (const_p)\n+\tTREE_READONLY(decl) = 1;\n+      this->builtin_functions_[libname] = this->make_function(decl);\n+    }\n+}\n \n // Return the backend generator.\n \n Backend*\n go_get_backend()\n {\n-  return &gcc_backend;\n+  return new Gcc_backend();\n }\n \n // FIXME: Temporary functions while converting to the new backend"}, {"sha": "786223fe736cb2b26033c721d0235711c13690f2", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -660,6 +660,11 @@ class Backend\n   virtual bool\n   function_set_body(Bfunction* function, Bstatement* code_stmt) = 0;\n \n+  // Look up a named built-in function in the current backend implementation.\n+  // Returns NULL if no built-in function by that name exists.\n+  virtual Bfunction*\n+  lookup_builtin(const std::string&) = 0;\n+\n   // Utility.\n \n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,"}, {"sha": "d2331f3e0ae39b198e7a776b5913952b012de2ca", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -34,9 +34,6 @@ go_create_gogo(int int_type_size, int pointer_size, const char *pkgpath,\n \n   if (relative_import_path != NULL)\n     ::gogo->set_relative_import_path(relative_import_path);\n-\n-  // FIXME: This should be in the gcc dependent code.\n-  ::gogo->define_builtin_function_trees();\n }\n \n // Parse the input files."}, {"sha": "5b9a8180287a5da83d600b85a5ae6dd82218b720", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 0, "deletions": 378, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -36,266 +36,6 @@ saw_errors()\n   return errorcount != 0 || sorrycount != 0;\n }\n \n-// A helper function.\n-\n-static inline tree\n-get_identifier_from_string(const std::string& str)\n-{\n-  return get_identifier_with_length(str.data(), str.length());\n-}\n-\n-// Builtin functions.\n-\n-static std::map<std::string, tree> builtin_functions;\n-\n-// Define a builtin function.  BCODE is the builtin function code\n-// defined by builtins.def.  NAME is the name of the builtin function.\n-// LIBNAME is the name of the corresponding library function, and is\n-// NULL if there isn't one.  FNTYPE is the type of the function.\n-// CONST_P is true if the function has the const attribute.\n-\n-static void\n-define_builtin(built_in_function bcode, const char* name, const char* libname,\n-\t       tree fntype, bool const_p)\n-{\n-  tree decl = add_builtin_function(name, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t   libname, NULL_TREE);\n-  if (const_p)\n-    TREE_READONLY(decl) = 1;\n-  set_builtin_decl(bcode, decl, true);\n-  builtin_functions[name] = decl;\n-  if (libname != NULL)\n-    {\n-      decl = add_builtin_function(libname, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t  NULL, NULL_TREE);\n-      if (const_p)\n-\tTREE_READONLY(decl) = 1;\n-      builtin_functions[libname] = decl;\n-    }\n-}\n-\n-// Create trees for implicit builtin functions.\n-\n-void\n-Gogo::define_builtin_function_trees()\n-{\n-  /* We need to define the fetch_and_add functions, since we use them\n-     for ++ and --.  */\n-  tree t = go_type_for_size(BITS_PER_UNIT, 1);\n-  tree p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n-  define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\", NULL,\n-\t\t build_function_type_list(t, p, t, NULL_TREE), false);\n-\n-  t = go_type_for_size(BITS_PER_UNIT * 2, 1);\n-  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n-  define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\", NULL,\n-\t\t  build_function_type_list(t, p, t, NULL_TREE), false);\n-\n-  t = go_type_for_size(BITS_PER_UNIT * 4, 1);\n-  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n-  define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\", NULL,\n-\t\t build_function_type_list(t, p, t, NULL_TREE), false);\n-\n-  t = go_type_for_size(BITS_PER_UNIT * 8, 1);\n-  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n-  define_builtin(BUILT_IN_SYNC_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\", NULL,\n-\t\t build_function_type_list(t, p, t, NULL_TREE), false);\n-\n-  // We use __builtin_expect for magic import functions.\n-  define_builtin(BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n-\t\t build_function_type_list(long_integer_type_node,\n-\t\t\t\t\t  long_integer_type_node,\n-\t\t\t\t\t  long_integer_type_node,\n-\t\t\t\t\t  NULL_TREE),\n-\t\t true);\n-\n-  // We use __builtin_memcmp for struct comparisons.\n-  define_builtin(BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n-\t\t build_function_type_list(integer_type_node,\n-\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t  size_type_node,\n-\t\t\t\t\t  NULL_TREE),\n-\t\t false);\n-\n-  // We provide some functions for the math library.\n-  tree math_function_type = build_function_type_list(double_type_node,\n-\t\t\t\t\t\t     double_type_node,\n-\t\t\t\t\t\t     NULL_TREE);\n-  tree math_function_type_long =\n-    build_function_type_list(long_double_type_node, long_double_type_node,\n-\t\t\t     long_double_type_node, NULL_TREE);\n-  tree math_function_type_two = build_function_type_list(double_type_node,\n-\t\t\t\t\t\t\t double_type_node,\n-\t\t\t\t\t\t\t double_type_node,\n-\t\t\t\t\t\t\t NULL_TREE);\n-  tree math_function_type_long_two =\n-    build_function_type_list(long_double_type_node, long_double_type_node,\n-\t\t\t     long_double_type_node, NULL_TREE);\n-  define_builtin(BUILT_IN_ACOS, \"__builtin_acos\", \"acos\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_ASIN, \"__builtin_asin\", \"asin\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_ASINL, \"__builtin_asinl\", \"asinl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_ATAN, \"__builtin_atan\", \"atan\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_ATANL, \"__builtin_atanl\", \"atanl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_ATAN2, \"__builtin_atan2\", \"atan2\",\n-\t\t math_function_type_two, true);\n-  define_builtin(BUILT_IN_ATAN2L, \"__builtin_atan2l\", \"atan2l\",\n-\t\t math_function_type_long_two, true);\n-  define_builtin(BUILT_IN_CEIL, \"__builtin_ceil\", \"ceil\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_CEILL, \"__builtin_ceill\", \"ceill\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_COS, \"__builtin_cos\", \"cos\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_COSL, \"__builtin_cosl\", \"cosl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_EXP, \"__builtin_exp\", \"exp\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_EXPL, \"__builtin_expl\", \"expl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_EXPM1, \"__builtin_expm1\", \"expm1\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_EXPM1L, \"__builtin_expm1l\", \"expm1l\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_FABS, \"__builtin_fabs\", \"fabs\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_FABSL, \"__builtin_fabsl\", \"fabsl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_FLOOR, \"__builtin_floor\", \"floor\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_FLOORL, \"__builtin_floorl\", \"floorl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_FMOD, \"__builtin_fmod\", \"fmod\",\n-\t\t math_function_type_two, true);\n-  define_builtin(BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n-\t\t math_function_type_long_two, true);\n-  define_builtin(BUILT_IN_LDEXP, \"__builtin_ldexp\", \"ldexp\",\n-\t\t build_function_type_list(double_type_node,\n-\t\t\t\t\t  double_type_node,\n-\t\t\t\t\t  integer_type_node,\n-\t\t\t\t\t  NULL_TREE),\n-\t\t true);\n-  define_builtin(BUILT_IN_LDEXPL, \"__builtin_ldexpl\", \"ldexpl\",\n-\t\t build_function_type_list(long_double_type_node,\n-\t\t\t\t\t  long_double_type_node,\n-\t\t\t\t\t  integer_type_node,\n-\t\t\t\t\t  NULL_TREE),\n-\t\t true);\n-  define_builtin(BUILT_IN_LOG, \"__builtin_log\", \"log\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_LOGL, \"__builtin_logl\", \"logl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_LOG1P, \"__builtin_log1p\", \"log1p\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_LOG1PL, \"__builtin_log1pl\", \"log1pl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_LOG10, \"__builtin_log10\", \"log10\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_LOG10L, \"__builtin_log10l\", \"log10l\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_LOG2, \"__builtin_log2\", \"log2\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_LOG2L, \"__builtin_log2l\", \"log2l\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_SIN, \"__builtin_sin\", \"sin\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_SINL, \"__builtin_sinl\", \"sinl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_TAN, \"__builtin_tan\", \"tan\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_TANL, \"__builtin_tanl\", \"tanl\",\n-\t\t math_function_type_long, true);\n-  define_builtin(BUILT_IN_TRUNC, \"__builtin_trunc\", \"trunc\",\n-\t\t math_function_type, true);\n-  define_builtin(BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n-\t\t math_function_type_long, true);\n-\n-  // We use __builtin_return_address in the thunk we build for\n-  // functions which call recover.\n-  define_builtin(BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\", NULL,\n-\t\t build_function_type_list(ptr_type_node,\n-\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t  NULL_TREE),\n-\t\t false);\n-\n-  // The compiler uses __builtin_trap for some exception handling\n-  // cases.\n-  define_builtin(BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n-\t\t build_function_type(void_type_node, void_list_node),\n-\t\t false);\n-}\n-\n-// Get the backend representation.\n-\n-Bfunction*\n-Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n-{\n-  if (this->fndecl_ == NULL)\n-    {\n-      // Let Go code use an asm declaration to pick up a builtin\n-      // function.\n-      if (!this->asm_name_.empty())\n-\t{\n-\t  std::map<std::string, tree>::const_iterator p =\n-\t    builtin_functions.find(this->asm_name_);\n-\t  if (p != builtin_functions.end())\n-\t    {\n-\t      this->fndecl_ = tree_to_function(p->second);\n-\t      return this->fndecl_;\n-\t    }\n-\t}\n-\n-      std::string asm_name;\n-      if (this->asm_name_.empty())\n-        {\n-          asm_name = (no->package() == NULL\n-                                  ? gogo->pkgpath_symbol()\n-                                  : no->package()->pkgpath_symbol());\n-          asm_name.append(1, '.');\n-          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n-          if (this->fntype_->is_method())\n-            {\n-              asm_name.append(1, '.');\n-              Type* rtype = this->fntype_->receiver()->type();\n-              asm_name.append(rtype->mangled_name(gogo));\n-            }\n-        }\n-\n-      Btype* functype = this->fntype_->get_backend_fntype(gogo);\n-      this->fndecl_ =\n-          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n-                                    true, true, true, false, false,\n-                                    this->location());\n-    }\n-\n-  return this->fndecl_;\n-}\n-\n-// Build the descriptor for a function declaration.  This won't\n-// necessarily happen if the package has just a declaration for the\n-// function and no other reference to it, but we may still need the\n-// descriptor for references from other packages.\n-void\n-Function_declaration::build_backend_descriptor(Gogo* gogo)\n-{\n-  if (this->descriptor_ != NULL)\n-    {\n-      Translate_context context(gogo, NULL, NULL, NULL);\n-      this->descriptor_->get_tree(&context);\n-    }\n-}\n-\n // Return the integer type to use for a size.\n \n GO_EXTERN_C\n@@ -380,121 +120,3 @@ go_type_for_mode(enum machine_mode mode, int unsignedp)\n   else\n     return NULL_TREE;\n }\n-\n-// Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n-// the slice.  VALUES is the value pointer and COUNT is the number of\n-// entries.  If CAPACITY is not NULL, it is the capacity; otherwise\n-// the capacity and the count are the same.\n-\n-tree\n-Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n-\t\t\ttree capacity)\n-{\n-  go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE);\n-\n-  vec<constructor_elt, va_gc> *init;\n-  vec_alloc(init, 3);\n-\n-  tree field = TYPE_FIELDS(slice_type_tree);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n-  constructor_elt empty = {NULL, NULL};\n-  constructor_elt* elt = init->quick_push(empty);\n-  elt->index = field;\n-  go_assert(TYPE_MAIN_VARIANT(TREE_TYPE(field))\n-\t     == TYPE_MAIN_VARIANT(TREE_TYPE(values)));\n-  elt->value = values;\n-\n-  count = fold_convert(sizetype, count);\n-  if (capacity == NULL_TREE)\n-    {\n-      count = save_expr(count);\n-      capacity = count;\n-    }\n-\n-  field = DECL_CHAIN(field);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n-  elt = init->quick_push(empty);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), count);\n-\n-  field = DECL_CHAIN(field);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n-  elt = init->quick_push(empty);\n-  elt->index = field;\n-  elt->value = fold_convert(TREE_TYPE(field), capacity);\n-\n-  return build_constructor(slice_type_tree, init);\n-}\n-\n-// Mark a function as a builtin library function.\n-\n-void\n-Gogo::mark_fndecl_as_builtin_library(tree fndecl)\n-{\n-  DECL_EXTERNAL(fndecl) = 1;\n-  TREE_PUBLIC(fndecl) = 1;\n-  DECL_ARTIFICIAL(fndecl) = 1;\n-  TREE_NOTHROW(fndecl) = 1;\n-  DECL_VISIBILITY(fndecl) = VISIBILITY_DEFAULT;\n-  DECL_VISIBILITY_SPECIFIED(fndecl) = 1;\n-}\n-\n-// Build a call to a builtin function.\n-\n-tree\n-Gogo::call_builtin(tree* pdecl, Location location, const char* name,\n-\t\t   int nargs, tree rettype, ...)\n-{\n-  if (rettype == error_mark_node)\n-    return error_mark_node;\n-\n-  tree* types = new tree[nargs];\n-  tree* args = new tree[nargs];\n-\n-  va_list ap;\n-  va_start(ap, rettype);\n-  for (int i = 0; i < nargs; ++i)\n-    {\n-      types[i] = va_arg(ap, tree);\n-      args[i] = va_arg(ap, tree);\n-      if (types[i] == error_mark_node || args[i] == error_mark_node)\n-\t{\n-\t  delete[] types;\n-\t  delete[] args;\n-\t  return error_mark_node;\n-\t}\n-    }\n-  va_end(ap);\n-\n-  if (*pdecl == NULL_TREE)\n-    {\n-      tree fnid = get_identifier(name);\n-\n-      tree argtypes = NULL_TREE;\n-      tree* pp = &argtypes;\n-      for (int i = 0; i < nargs; ++i)\n-\t{\n-\t  *pp = tree_cons(NULL_TREE, types[i], NULL_TREE);\n-\t  pp = &TREE_CHAIN(*pp);\n-\t}\n-      *pp = void_list_node;\n-\n-      tree fntype = build_function_type(rettype, argtypes);\n-\n-      *pdecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL, fnid, fntype);\n-      Gogo::mark_fndecl_as_builtin_library(*pdecl);\n-      go_preserve_from_gc(*pdecl);\n-    }\n-\n-  tree fnptr = build_fold_addr_expr(*pdecl);\n-  if (CAN_HAVE_LOCATION_P(fnptr))\n-    SET_EXPR_LOCATION(fnptr, location.gcc_location());\n-\n-  tree ret = build_call_array(rettype, fnptr, nargs, args);\n-  SET_EXPR_LOCATION(ret, location.gcc_location());\n-\n-  delete[] types;\n-  delete[] args;\n-\n-  return ret;\n-}"}, {"sha": "995a4f2d2da32b53f39ed90446d8bd4573e70c21", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -4855,6 +4855,66 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n   return this->fndecl_;\n }\n \n+// Get the backend representation.\n+\n+Bfunction*\n+Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n+{\n+  if (this->fndecl_ == NULL)\n+    {\n+      // Let Go code use an asm declaration to pick up a builtin\n+      // function.\n+      if (!this->asm_name_.empty())\n+\t{\n+\t  Bfunction* builtin_decl =\n+\t    gogo->backend()->lookup_builtin(this->asm_name_);\n+\t  if (builtin_decl != NULL)\n+\t    {\n+\t      this->fndecl_ = builtin_decl;\n+\t      return this->fndecl_;\n+\t    }\n+\t}\n+\n+      std::string asm_name;\n+      if (this->asm_name_.empty())\n+        {\n+          asm_name = (no->package() == NULL\n+                                  ? gogo->pkgpath_symbol()\n+                                  : no->package()->pkgpath_symbol());\n+          asm_name.append(1, '.');\n+          asm_name.append(Gogo::unpack_hidden_name(no->name()));\n+          if (this->fntype_->is_method())\n+            {\n+              asm_name.append(1, '.');\n+              Type* rtype = this->fntype_->receiver()->type();\n+              asm_name.append(rtype->mangled_name(gogo));\n+            }\n+        }\n+\n+      Btype* functype = this->fntype_->get_backend_fntype(gogo);\n+      this->fndecl_ =\n+          gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n+                                    true, true, true, false, false,\n+                                    this->location());\n+    }\n+\n+  return this->fndecl_;\n+}\n+\n+// Build the descriptor for a function declaration.  This won't\n+// necessarily happen if the package has just a declaration for the\n+// function and no other reference to it, but we may still need the\n+// descriptor for references from other packages.\n+void\n+Function_declaration::build_backend_descriptor(Gogo* gogo)\n+{\n+  if (this->descriptor_ != NULL)\n+    {\n+      Translate_context context(gogo, NULL, NULL, NULL);\n+      this->descriptor_->get_tree(&context);\n+    }\n+}\n+\n // Return the function's decl after it has been built.\n \n Bfunction*"}, {"sha": "37cbbdf4411473f3bdd54827bc5464f0a9762a0b", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90cbaa297823c469ca50c5b51b9e1835d944a886/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=90cbaa297823c469ca50c5b51b9e1835d944a886", "patch": "@@ -575,35 +575,10 @@ class Gogo\n   void\n   write_globals();\n \n-  // Create trees for implicit builtin functions.\n-  void\n-  define_builtin_function_trees();\n-\n-  // Build a call to a builtin function.  PDECL should point to a NULL\n-  // initialized static pointer which will hold the fndecl.  NAME is\n-  // the name of the function.  NARGS is the number of arguments.\n-  // RETTYPE is the return type.  It is followed by NARGS pairs of\n-  // type and argument (both trees).\n-  static tree\n-  call_builtin(tree* pdecl, Location, const char* name, int nargs,\n-\t       tree rettype, ...);\n-\n   // Build a call to the runtime error function.\n   Expression*\n   runtime_error(int code, Location);\n \n-  // Mark a function declaration as a builtin library function.\n-  static void\n-  mark_fndecl_as_builtin_library(tree fndecl);\n-\n-  // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n-  // the slice.  VALUES points to the values.  COUNT is the size,\n-  // CAPACITY is the capacity.  If CAPACITY is NULL, it is set to\n-  // COUNT.\n-  static tree\n-  slice_constructor(tree slice_type_tree, tree values, tree count,\n-\t\t    tree capacity);\n-\n   // Build required interface method tables.\n   void\n   build_interface_method_tables();"}]}