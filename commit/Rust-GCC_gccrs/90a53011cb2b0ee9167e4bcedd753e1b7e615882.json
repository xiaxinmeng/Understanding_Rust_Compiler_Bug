{"sha": "90a53011cb2b0ee9167e4bcedd753e1b7e615882", "node_id": "C_kwDOANBUbNoAKDkwYTUzMDExY2IyYjBlZTkxNjdlNGJjZWRkNzUzZTFiN2U2MTU4ODI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-03-13T21:43:27Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-03-17T10:34:36Z"}, "message": "gccrs: cleanup resolve method address code generation\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-expr.cc (CompileExpr::resolve_method_address): remove unused code\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "6bb1549bba9c21335ab1e3a7d1fd97cfff028dba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6bb1549bba9c21335ab1e3a7d1fd97cfff028dba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90a53011cb2b0ee9167e4bcedd753e1b7e615882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a53011cb2b0ee9167e4bcedd753e1b7e615882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90a53011cb2b0ee9167e4bcedd753e1b7e615882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90a53011cb2b0ee9167e4bcedd753e1b7e615882/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b6a14c46e9572998f88ee211ae8e8323e0ce72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b6a14c46e9572998f88ee211ae8e8323e0ce72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b6a14c46e9572998f88ee211ae8e8323e0ce72"}], "stats": {"total": 52, "additions": 20, "deletions": 32}, "files": [{"sha": "cf6802e91af64dc56a7aa8a22da47cb145acb518", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90a53011cb2b0ee9167e4bcedd753e1b7e615882/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90a53011cb2b0ee9167e4bcedd753e1b7e615882/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=90a53011cb2b0ee9167e4bcedd753e1b7e615882", "patch": "@@ -1924,13 +1924,6 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n \t\t\t\t     Analysis::NodeMapping expr_mappings,\n \t\t\t\t     Location expr_locus)\n {\n-  // lookup compiled functions since it may have already been compiled\n-  tree fn = NULL_TREE;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-    {\n-      return address_expression (fn, expr_locus);\n-    }\n-\n   // Now we can try and resolve the address since this might be a forward\n   // declared function, generic function which has not be compiled yet or\n   // its an not yet trait bound function\n@@ -1983,35 +1976,30 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n       return CompileTraitItem::Compile (trait_item_ref->get_hir_trait_item (),\n \t\t\t\t\tctx, fntype, true, expr_locus);\n     }\n-  else\n-    {\n-      // FIXME this will be a case to return error_mark_node, there is\n-      // an error scenario where a Trait Foo has a method Bar, but this\n-      // receiver does not implement this trait or has an incompatible\n-      // implementation and we should just return error_mark_node\n \n-      rust_assert (candidates.size () == 1);\n-      auto &candidate = *candidates.begin ();\n-      rust_assert (candidate.is_impl_candidate ());\n-      rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n-      TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);\n+  // FIXME this will be a case to return error_mark_node, there is\n+  // an error scenario where a Trait Foo has a method Bar, but this\n+  // receiver does not implement this trait or has an incompatible\n+  // implementation and we should just return error_mark_node\n \n-      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n-      if (!candidate_call->has_subsititions_defined ())\n-\treturn CompileInherentImplItem::Compile (impl_item, ctx);\n+  rust_assert (candidates.size () == 1);\n+  auto &candidate = *candidates.begin ();\n+  rust_assert (candidate.is_impl_candidate ());\n+  rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);\n+  HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n \n-      TyTy::BaseType *monomorphized = candidate_call;\n-      if (candidate_call->needs_generic_substitutions ())\n-\t{\n-\t  TyTy::BaseType *infer_impl_call\n-\t    = candidate_call->infer_substitions (expr_locus);\n-\t  monomorphized\n-\t    = Resolver::unify_site (ref, TyTy::TyWithLocation (infer_impl_call),\n-\t\t\t\t    TyTy::TyWithLocation (fntype), expr_locus);\n-\t}\n-\n-      return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n+  TyTy::BaseType *monomorphized = candidate_call;\n+  if (candidate_call->needs_generic_substitutions ())\n+    {\n+      TyTy::BaseType *infer_impl_call\n+\t= candidate_call->infer_substitions (expr_locus);\n+      monomorphized\n+\t= Resolver::unify_site (ref, TyTy::TyWithLocation (infer_impl_call),\n+\t\t\t\tTyTy::TyWithLocation (fntype), expr_locus);\n     }\n+\n+  return CompileInherentImplItem::Compile (impl_item, ctx, monomorphized);\n }\n \n tree"}]}