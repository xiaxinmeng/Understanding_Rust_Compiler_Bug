{"sha": "c9ef86a1717dd66f185aff6578cf4744771b39e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzllZjg2YTE3MTdkZDY2ZjE4NWFmZjY1NzhjZjQ3NDQ3NzFiMzllNA==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@arm.com", "date": "2013-10-09T18:57:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-09T18:57:14Z"}, "message": "tree-ssa-phiopts.c (rhs_is_fed_for_value_replacement): New function.\n\n\t* tree-ssa-phiopts.c (rhs_is_fed_for_value_replacement): New function.\n\t(operand_equal_for_value_replacement): New function, extracted from\n\tvalue_replacement and enhanced to catch more cases.\n\t(value_replacement): Use operand_equal_for_value_replacement.\n\n\t* gcc.dg/tree-ssa/phi-opt-11.c: New test.\n\nFrom-SVN: r203327", "tree": {"sha": "adac9707f151a887125c84ed9d6217e2bd2d1f45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/adac9707f151a887125c84ed9d6217e2bd2d1f45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9ef86a1717dd66f185aff6578cf4744771b39e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ef86a1717dd66f185aff6578cf4744771b39e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9ef86a1717dd66f185aff6578cf4744771b39e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9ef86a1717dd66f185aff6578cf4744771b39e4/comments", "author": null, "committer": null, "parents": [{"sha": "fd673f296a9070dd0085108dca9bbd7ad8dd4e1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd673f296a9070dd0085108dca9bbd7ad8dd4e1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd673f296a9070dd0085108dca9bbd7ad8dd4e1c"}], "stats": {"total": 160, "additions": 150, "deletions": 10}, "files": [{"sha": "b1028bf7167a3cc5f6a71d212923754522f822bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9ef86a1717dd66f185aff6578cf4744771b39e4", "patch": "@@ -1,3 +1,10 @@\n+2013-10-09  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n+\n+\t* tree-ssa-phiopts.c (rhs_is_fed_for_value_replacement): New function.\n+\t(operand_equal_for_value_replacement): New function, extracted from\n+\tvalue_replacement and enhanced to catch more cases.\n+\t(value_replacement): Use operand_equal_for_value_replacement.\n+\n 2013-10-09  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* loop-doloop.c (doloop_modify, doloop_optimize): Use "}, {"sha": "76cce59c69fa60c65439f67b22d4df1d24726516", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c9ef86a1717dd66f185aff6578cf4744771b39e4", "patch": "@@ -1,3 +1,7 @@\n+2013-10-09  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n+\n+\t* gcc.dg/tree-ssa/phi-opt-11.c: New test.\n+\n 2013-10-09  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/58635"}, {"sha": "7c83007e7f1fc782d3eb65b94b37b34e8b47ad59", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-11.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-11.c?ref=c9ef86a1717dd66f185aff6578cf4744771b39e4", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-optimized\" } */\n+\n+int f(int a, int b, int c)\n+{\n+  if (a == 0 && b > c)\n+   return 0;\n+ return a;\n+}\n+\n+int g(int a, int b, int c)\n+{\n+  if (a == 42 && b > c)\n+   return 42;\n+ return a;\n+}\n+\n+int h(int a, int b, int c, int d)\n+{\n+  if (a == d && b > c)\n+   return d;\n+ return a;\n+}\n+/* { dg-final { scan-tree-dump-times \"if\" 0 \"optimized\"} } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "adf8a28006321543ed0120b531f53a34d37981a6", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 114, "deletions": 10, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9ef86a1717dd66f185aff6578cf4744771b39e4/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=c9ef86a1717dd66f185aff6578cf4744771b39e4", "patch": "@@ -110,6 +110,26 @@ static bool gate_hoist_loads (void);\n    This opportunity can sometimes occur as a result of other\n    optimizations.\n \n+\n+   Another case caught by value replacement looks like this:\n+\n+     bb0:\n+       t1 = a == CONST;\n+       t2 = b > c;\n+       t3 = t1 & t2;\n+       if (t3 != 0) goto bb1; else goto bb2;\n+     bb1:\n+     bb2:\n+       x = PHI (CONST, a)\n+\n+   Gets replaced with:\n+     bb0:\n+     bb2:\n+       t1 = a == CONST;\n+       t2 = b > c;\n+       t3 = t1 & t2;\n+       x = a;\n+\n    ABS Replacement\n    ---------------\n \n@@ -155,7 +175,7 @@ static bool gate_hoist_loads (void);\n \n    Adjacent Load Hoisting\n    ----------------------\n-   \n+\n    This transformation replaces\n \n      bb0:\n@@ -286,7 +306,7 @@ single_non_singleton_phi_for_edges (gimple_seq seq, edge e0, edge e1)\n    phi optimizations.  Both share much of the infrastructure in how\n    to match applicable basic block patterns.  DO_STORE_ELIM is true\n    when we want to do conditional store replacement, false otherwise.\n-   DO_HOIST_LOADS is true when we want to hoist adjacent loads out \n+   DO_HOIST_LOADS is true when we want to hoist adjacent loads out\n    of diamond control flow patterns, false otherwise.  */\n static unsigned int\n tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n@@ -389,7 +409,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \t  continue;\n \t}\n       else\n-\tcontinue;      \n+\tcontinue;\n \n       e1 = EDGE_SUCC (bb1, 0);\n \n@@ -437,7 +457,7 @@ tree_ssa_phiopt_worker (bool do_store_elim, bool do_hoist_loads)\n \n \t  if (!candorest)\n \t    continue;\n-\t  \n+\n \t  phi = single_non_singleton_phi_for_edges (phis, e1, e2);\n \t  if (!phi)\n \t    continue;\n@@ -672,6 +692,93 @@ jump_function_from_stmt (tree *arg, gimple stmt)\n   return false;\n }\n \n+/* RHS is a source argument in a BIT_AND_EXPR which feeds a conditional\n+   of the form SSA_NAME NE 0.\n+\n+   If RHS is fed by a simple EQ_EXPR comparison of two values, see if\n+   the two input values of the EQ_EXPR match arg0 and arg1.\n+\n+   If so update *code and return TRUE.  Otherwise return FALSE.  */\n+\n+static bool\n+rhs_is_fed_for_value_replacement (const_tree arg0, const_tree arg1,\n+\t\t\t\t  enum tree_code *code, const_tree rhs)\n+{\n+  /* Obviously if RHS is not an SSA_NAME, we can't look at the defining\n+     statement.  */\n+  if (TREE_CODE (rhs) == SSA_NAME)\n+    {\n+      gimple def1 = SSA_NAME_DEF_STMT (rhs);\n+\n+      /* Verify the defining statement has an EQ_EXPR on the RHS.  */\n+      if (is_gimple_assign (def1) && gimple_assign_rhs_code (def1) == EQ_EXPR)\n+\t{\n+\t  /* Finally verify the source operands of the EQ_EXPR are equal\n+\t     to arg0 and arg1.  */\n+\t  tree op0 = gimple_assign_rhs1 (def1);\n+\t  tree op1 = gimple_assign_rhs2 (def1);\n+\t  if ((operand_equal_for_phi_arg_p (arg0, op0)\n+\t       && operand_equal_for_phi_arg_p (arg1, op1))\n+\t      || (operand_equal_for_phi_arg_p (arg0, op1)\n+               && operand_equal_for_phi_arg_p (arg1, op0)))\n+\t    {\n+\t      /* We will perform the optimization.  */\n+\t      *code = gimple_assign_rhs_code (def1);\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return TRUE if arg0/arg1 are equal to the rhs/lhs or lhs/rhs of COND. \n+\n+   Also return TRUE if arg0/arg1 are equal to the source arguments of a\n+   an EQ comparison feeding a BIT_AND_EXPR which feeds COND. \n+\n+   Return FALSE otherwise.  */\n+\n+static bool\n+operand_equal_for_value_replacement (const_tree arg0, const_tree arg1,\n+\t\t\t\t     enum tree_code *code, gimple cond)\n+{\n+  gimple def;\n+  tree lhs = gimple_cond_lhs (cond);\n+  tree rhs = gimple_cond_rhs (cond);\n+\n+  if ((operand_equal_for_phi_arg_p (arg0, lhs)\n+       && operand_equal_for_phi_arg_p (arg1, rhs))\n+      || (operand_equal_for_phi_arg_p (arg1, lhs)\n+\t  && operand_equal_for_phi_arg_p (arg0, rhs)))\n+    return true;\n+\n+  /* Now handle more complex case where we have an EQ comparison\n+     which feeds a BIT_AND_EXPR which feeds COND.\n+\n+     First verify that COND is of the form SSA_NAME NE 0.  */\n+  if (*code != NE_EXPR || !integer_zerop (rhs)\n+      || TREE_CODE (lhs) != SSA_NAME)\n+    return false;\n+\n+  /* Now ensure that SSA_NAME is set by a BIT_AND_EXPR.  */\n+  def = SSA_NAME_DEF_STMT (lhs);\n+  if (!is_gimple_assign (def) || gimple_assign_rhs_code (def) != BIT_AND_EXPR)\n+    return false;\n+\n+  /* Now verify arg0/arg1 correspond to the source arguments of an \n+     EQ comparison feeding the BIT_AND_EXPR.  */\n+     \n+  tree tmp = gimple_assign_rhs1 (def);\n+  if (rhs_is_fed_for_value_replacement (arg0, arg1, code, tmp))\n+    return true;\n+\n+  tmp = gimple_assign_rhs2 (def);\n+  if (rhs_is_fed_for_value_replacement (arg0, arg1, code, tmp))\n+    return true;\n+\n+  return false;\n+}\n+\n /*  The function value_replacement does the main work of doing the value\n     replacement.  Return non-zero if the replacement is done.  Otherwise return\n     0.  If we remove the middle basic block, return 2.\n@@ -741,10 +848,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n      We now need to verify that the two arguments in the PHI node match\n      the two arguments to the equality comparison.  */\n \n-  if ((operand_equal_for_phi_arg_p (arg0, gimple_cond_lhs (cond))\n-       && operand_equal_for_phi_arg_p (arg1, gimple_cond_rhs (cond)))\n-      || (operand_equal_for_phi_arg_p (arg1, gimple_cond_lhs (cond))\n-\t  && operand_equal_for_phi_arg_p (arg0, gimple_cond_rhs (cond))))\n+  if (operand_equal_for_value_replacement (arg0, arg1, &code, cond))\n     {\n       edge e;\n       tree arg;\n@@ -1746,7 +1850,7 @@ local_mem_dependence (gimple stmt, basic_block bb)\n \n /* Given a \"diamond\" control-flow pattern where BB0 tests a condition,\n    BB1 and BB2 are \"then\" and \"else\" blocks dependent on this test,\n-   and BB3 rejoins control flow following BB1 and BB2, look for \n+   and BB3 rejoins control flow following BB1 and BB2, look for\n    opportunities to hoist loads as follows.  If BB3 contains a PHI of\n    two loads, one each occurring in BB1 and BB2, and the loads are\n    provably of adjacent fields in the same structure, then move both\n@@ -1796,7 +1900,7 @@ hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n \n       arg1 = gimple_phi_arg_def (phi_stmt, 0);\n       arg2 = gimple_phi_arg_def (phi_stmt, 1);\n-      \n+\n       if (TREE_CODE (arg1) != SSA_NAME\n \t  || TREE_CODE (arg2) != SSA_NAME\n \t  || SSA_NAME_IS_DEFAULT_DEF (arg1)"}]}