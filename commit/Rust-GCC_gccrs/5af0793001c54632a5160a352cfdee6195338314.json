{"sha": "5af0793001c54632a5160a352cfdee6195338314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFmMDc5MzAwMWM1NDYzMmE1MTYwYTM1MmNmZGVlNjE5NTMzODMxNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-04-18T05:56:05Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-04-18T05:56:05Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-04-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * iresolve.c (gfc_resolve_image_index): Set ts.type.\n        * simplify.c (gfc_simplify_image_index): Don't abort if the\n        * bounds\n        are not known at compile time and handle -fcoarray=lib.\n        * trans-intrinsics.c (gfc_conv_intrinsic_function): Handle\n        IMAGE_INDEX.\n        (conv_intrinsic_cobound): Fix comment typo.\n        (trans_this_image): New function.\n        * trans-array.c (gfc_unlikely): Move to trans.c.\n        * trans.c (gfc_unlikely): Function moved from trans-array.c.\n        (gfc_trans_runtime_check): Use it.\n        * trans-io.c (gfc_trans_io_runtime_check): Ditto.\n        * trans.h (gfc_unlikely): Add prototype.\n\n2011-04-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_16.f90: New.\n\nFrom-SVN: r172637", "tree": {"sha": "4fea0be54c2c3408b2ee50b9961ef7a822c4f87b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fea0be54c2c3408b2ee50b9961ef7a822c4f87b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5af0793001c54632a5160a352cfdee6195338314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af0793001c54632a5160a352cfdee6195338314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5af0793001c54632a5160a352cfdee6195338314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5af0793001c54632a5160a352cfdee6195338314/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "12df8d0150a2f18d7e86a8b0a94cfc4201795c18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12df8d0150a2f18d7e86a8b0a94cfc4201795c18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12df8d0150a2f18d7e86a8b0a94cfc4201795c18"}], "stats": {"total": 323, "additions": 285, "deletions": 38}, "files": [{"sha": "7154e621211934448df10c7f5c3f5a7efc621d52", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -1,3 +1,19 @@\n+2011-04-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* iresolve.c (gfc_resolve_image_index): Set ts.type.\n+\t* simplify.c (gfc_simplify_image_index): Don't abort if the bounds\n+\tare not known at compile time and handle -fcoarray=lib.\n+\t* trans-intrinsics.c (gfc_conv_intrinsic_function): Handle\n+\tIMAGE_INDEX.\n+\t(conv_intrinsic_cobound): Fix comment typo.\n+\t(trans_this_image): New function.\n+\t* trans-array.c (gfc_unlikely): Move to trans.c.\n+\t* trans.c (gfc_unlikely): Function moved from trans-array.c.\n+\t(gfc_trans_runtime_check): Use it.\n+\t* trans-io.c (gfc_trans_io_runtime_check): Ditto.\n+\t* trans.h (gfc_unlikely): Add prototype.\n+\n 2011-04-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/48462"}, {"sha": "24c9f76d7fec2937ad5dbe10c42ce7e274c67f6b", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -2547,9 +2547,10 @@ void\n gfc_resolve_image_index (gfc_expr *f, gfc_expr *array ATTRIBUTE_UNUSED,\n \t\t\t gfc_expr *sub ATTRIBUTE_UNUSED)\n {\n-  static char this_image[] = \"__image_index\";\n+  static char image_index[] = \"__image_index\";\n+  f->ts.type = BT_INTEGER;\n   f->ts.kind = gfc_default_integer_kind;\n-  f->value.function.name = this_image;\n+  f->value.function.name = image_index;\n }\n \n "}, {"sha": "b744a214ed538ceff0ec12981272923f6bbc64db", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -6189,7 +6189,7 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n   int d;\n \n   if (!is_constant_array_expr (sub))\n-    goto not_implemented; /* return NULL;*/\n+    return NULL;\n \n   /* Follow any component references.  */\n   as = coarray->symtree->n.sym->as;\n@@ -6198,7 +6198,7 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n       as = ref->u.ar.as;\n \n   if (as->type == AS_DEFERRED)\n-    goto not_implemented; /* return NULL;*/\n+    return NULL;\n \n   /* \"valid sequence of cosubscripts\" are required; thus, return 0 unless\n      the cosubscript addresses the first image.  */\n@@ -6221,7 +6221,7 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n       ca_bound = simplify_bound_dim (coarray, NULL, d + as->rank, 0, as,\n \t\t\t\t     NULL, true);\n       if (ca_bound == NULL)\n-\tgoto not_implemented; /* return NULL */\n+\treturn NULL;\n \n       if (ca_bound == &gfc_bad_expr)\n \treturn ca_bound;\n@@ -6285,6 +6285,10 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n       return &gfc_bad_expr;\n     }\n \n+\n+  if (gfc_option.coarray != GFC_FCOARRAY_SINGLE && !first_image)\n+    return NULL;\n+\n   result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n \t\t\t\t  &gfc_current_locus);\n   if (first_image)\n@@ -6293,11 +6297,6 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n     mpz_set_si (result->value.integer, 0);\n \n   return result;\n-\n-not_implemented:\n-  gfc_error (\"Not yet implemented: IMAGE_INDEX for coarray with non-constant \"\n-\t     \"cobounds at %L\", &coarray->where);\n-  return &gfc_bad_expr;\n }\n \n "}, {"sha": "5293fec225b9e5c9340725e3bc957d11e2307fdc", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -4111,21 +4111,6 @@ gfc_conv_descriptor_cosize (tree desc, int rank, int corank)\n }\n \n \n-/* Helper function for marking a boolean expression tree as unlikely.  */\n-\n-static tree\n-gfc_unlikely (tree cond)\n-{\n-  tree tmp;\n-\n-  cond = fold_convert (long_integer_type_node, cond);\n-  tmp = build_zero_cst (long_integer_type_node);\n-  cond = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n-  cond = fold_convert (boolean_type_node, cond);\n-  return cond;\n-}\n-\n /* Fills in an array descriptor, and returns the size of the array.\n    The size will be a simple_val, ie a variable or a constant.  Also\n    calculates the offset of the base.  The pointer argument overflow,"}, {"sha": "aec670d3b0452c5e86bcc3cd2f25c92ceeb0ca02", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 133, "deletions": 1, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -921,13 +921,141 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n   se->expr = fold_convert (type, res);\n }\n \n+\n static void\n trans_this_image (gfc_se * se, gfc_expr *expr ATTRIBUTE_UNUSED)\n {\n   gfc_init_coarray_decl ();\n   se->expr = gfort_gvar_caf_this_image;\n }\n \n+\n+static void\n+trans_image_index (gfc_se * se, gfc_expr *expr)\n+{\n+  tree num_images, cond, coindex, type, lbound, ubound, desc, subdesc,\n+       tmp, invalid_bound;\n+  gfc_se argse, subse;\n+  gfc_ss *ss, *subss;\n+  int rank, corank, codim;\n+\n+  type = gfc_get_int_type (gfc_default_integer_kind);\n+  corank = gfc_get_corank (expr->value.function.actual->expr);\n+  rank = expr->value.function.actual->expr->rank;\n+\n+  /* Obtain the descriptor of the COARRAY.  */\n+  gfc_init_se (&argse, NULL);\n+  ss = gfc_walk_expr (expr->value.function.actual->expr);\n+  gcc_assert (ss != gfc_ss_terminator);\n+  ss->data.info.codimen = corank;\n+  gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr, ss);\n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  gfc_add_block_to_block (&se->post, &argse.post);\n+  desc = argse.expr;\n+\n+  /* Obtain a handle to the SUB argument.  */\n+  gfc_init_se (&subse, NULL);\n+  subss = gfc_walk_expr (expr->value.function.actual->next->expr);\n+  gcc_assert (subss != gfc_ss_terminator);\n+  gfc_conv_expr_descriptor (&subse, expr->value.function.actual->next->expr,\n+\t\t\t    subss);\n+  gfc_add_block_to_block (&se->pre, &subse.pre);\n+  gfc_add_block_to_block (&se->post, &subse.post);\n+  subdesc = build_fold_indirect_ref_loc (input_location,\n+\t\t\tgfc_conv_descriptor_data_get (subse.expr));\n+\n+  /* Fortran 2008 does not require that the values remain in the cobounds,\n+     thus we need explicitly check this - and return 0 if they are exceeded.  */\n+\n+  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[rank+corank-1]);\n+  tmp = gfc_build_array_ref (subdesc, gfc_rank_cst[corank-1], NULL);\n+  invalid_bound = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t fold_convert (gfc_array_index_type, tmp),\n+\t\t\t\t lbound);\n+\n+  for (codim = corank + rank - 2; codim >= rank; codim--)\n+    {\n+      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[codim]);\n+      ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[codim]);\n+      tmp = gfc_build_array_ref (subdesc, gfc_rank_cst[codim-rank], NULL);\n+      cond = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t      fold_convert (gfc_array_index_type, tmp),\n+\t\t\t      lbound);\n+      invalid_bound = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t       boolean_type_node, invalid_bound, cond);\n+      cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node,\n+\t\t\t      fold_convert (gfc_array_index_type, tmp),\n+\t\t\t      ubound);\n+      invalid_bound = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n+\t\t\t\t       boolean_type_node, invalid_bound, cond);\n+    }\n+\n+  invalid_bound = gfc_unlikely (invalid_bound);\n+\n+\n+  /* See Fortran 2008, C.10 for the following algorithm.  */\n+\n+  /* coindex = sub(corank) - lcobound(n).  */\n+  coindex = fold_convert (gfc_array_index_type,\n+\t\t\t  gfc_build_array_ref (subdesc, gfc_rank_cst[corank-1],\n+\t\t\t\t\t       NULL));\n+  lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[rank+corank-1]);\n+  coindex = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     fold_convert (gfc_array_index_type, coindex),\n+\t\t\t     lbound);\n+\n+  for (codim = corank + rank - 2; codim >= rank; codim--)\n+    {\n+      tree extent, ubound;\n+\n+      /* coindex = coindex*extent(codim) + sub(codim) - lcobound(codim).  */\n+      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[codim]);\n+      ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[codim]);\n+      extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\n+      /* coindex *= extent.  */\n+      coindex = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t gfc_array_index_type, coindex, extent);\n+\n+      /* coindex += sub(codim).  */\n+      tmp = gfc_build_array_ref (subdesc, gfc_rank_cst[codim-rank], NULL);\n+      coindex = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t gfc_array_index_type, coindex,\n+\t\t\t\t fold_convert (gfc_array_index_type, tmp));\n+\n+      /* coindex -= lbound(codim).  */\n+      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[codim]);\n+      coindex = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t gfc_array_index_type, coindex, lbound);\n+    }\n+\n+  coindex = fold_build2_loc (input_location, PLUS_EXPR, type,\n+\t\t\t     fold_convert(type, coindex),\n+\t\t\t     build_int_cst (type, 1));\n+\n+  /* Return 0 if \"coindex\" exceeds num_images().  */\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_SINGLE)\n+    num_images = build_int_cst (type, 1);\n+  else\n+    {\n+      gfc_init_coarray_decl ();\n+      num_images = gfort_gvar_caf_num_images;\n+    }\n+\n+  tmp = gfc_create_var (type, NULL);\n+  gfc_add_modify (&se->pre, tmp, coindex);\n+\n+  cond = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, tmp,\n+\t\t\t  num_images);\n+  cond = fold_build2_loc (input_location, TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\t  cond,\n+\t\t\t  fold_convert (boolean_type_node, invalid_bound));\n+  se->expr = fold_build3_loc (input_location, COND_EXPR, type, cond,\n+\t\t\t      build_int_cst (type, 0), tmp);\n+}\n+\n+\n static void\n trans_num_images (gfc_se * se)\n {\n@@ -1233,7 +1361,7 @@ conv_intrinsic_cobound (gfc_se * se, gfc_expr * expr)\n \t   ceiling (real (num_images ()) / real (size)) - 1\n \t = (num_images () + size - 1) / size - 1\n \t = (num_images - 1) / size(),\n-         where size is the product of the extend of all but the last\n+         where size is the product of the extent of all but the last\n \t codimension.  */\n \n       if (gfc_option.coarray != GFC_FCOARRAY_SINGLE && corank > 1)\n@@ -6312,6 +6440,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n \ttrans_this_image (se, expr);\n       break;\n \n+    case GFC_ISYM_IMAGE_INDEX:\n+      trans_image_index (se, expr);\n+      break;\n+\n     case GFC_ISYM_NUM_IMAGES:\n       trans_num_images (se);\n       break;"}, {"sha": "883ec5c95c130ae254554023f2e500d29263ad4b", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -267,13 +267,7 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n     }\n   else\n     {\n-      /* Tell the compiler that this isn't likely.  */\n-      cond = fold_convert (long_integer_type_node, cond);\n-      tmp = build_int_cst (long_integer_type_node, 0);\n-      cond = build_call_expr_loc (input_location,\n-\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n-      cond = fold_convert (boolean_type_node, cond);\n-\n+      cond = gfc_unlikely (cond);\n       tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (pblock, tmp);\n     }"}, {"sha": "9786d97a0cde720f5f3208fce52460edb10a3933", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -505,11 +505,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n       else\n \tcond = fold_convert (long_integer_type_node, cond);\n \n-      tmp = build_int_cst (long_integer_type_node, 0);\n-      cond = build_call_expr_loc (where->lb->location,\n-\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n-      cond = fold_convert (boolean_type_node, cond);\n-\n+      cond = gfc_unlikely (cond);\n       tmp = fold_build3_loc (where->lb->location, COND_EXPR, void_type_node,\n \t\t\t     cond, body,\n \t\t\t     build_empty_stmt (where->lb->location));\n@@ -1565,3 +1561,19 @@ gfc_finish_wrapped_block (gfc_wrapped_block* block)\n \n   return result;\n }\n+\n+\n+/* Helper function for marking a boolean expression tree as unlikely.  */\n+\n+tree\n+gfc_unlikely (tree cond)\n+{\n+  tree tmp;\n+\n+  cond = fold_convert (long_integer_type_node, cond);\n+  tmp = build_zero_cst (long_integer_type_node);\n+  cond = build_call_expr_loc (input_location,\n+\t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n+  cond = fold_convert (boolean_type_node, cond);\n+  return cond;\n+}"}, {"sha": "6a2e4f57e6e4c174485a270537ae41ac393094c4", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -512,6 +512,9 @@ void gfc_generate_constructors (void);\n /* Get the string length of an array constructor.  */\n bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor_base, tree *);\n \n+/* Mark a condition as unlikely.  */\n+tree gfc_unlikely (tree);\n+\n /* Generate a runtime error call.  */\n tree gfc_trans_runtime_error (bool, locus*, const char*, ...);\n "}, {"sha": "22a33c332810e42b81bccefe202010b6865f7565", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -1,3 +1,8 @@\n+2011-04-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_16.f90: New.\n+\n 2011-04-18  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/48462"}, {"sha": "282e8706848bdd0c57b29ec0958124dae5482c36", "filename": "gcc/testsuite/gfortran.dg/coarray_16.f90", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5af0793001c54632a5160a352cfdee6195338314/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_16.f90?ref=5af0793001c54632a5160a352cfdee6195338314", "patch": "@@ -0,0 +1,100 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Run-time test for IMAGE_INDEX with cobounds only known at\n+! the compile time, suitable for any number of NUM_IMAGES()\n+! For compile-time cobounds, the -fcoarray=lib version still\n+! needs to run-time evalulation if image_index returns > 1\n+! as image_index is 0 if the index would exceed num_images().\n+!\n+! Please set num_images() to >= 13, if possible.\n+!\n+! PR fortran/18918\n+!\n+\n+program test_image_index\n+implicit none\n+integer :: index1, index2, index3\n+logical :: one\n+\n+integer, allocatable :: a(:)[:,:,:], b(:)[:,:], c(:,:)[:]\n+integer, save :: d(2)[-1:3, *]\n+integer, save :: e(2)[-1:-1, 3:*]\n+\n+one = num_images() == 1\n+\n+allocate(a(1)[3:3, -4:-3, 88:*])\n+allocate(b(2)[-1:0,0:*])\n+allocate(c(3,3)[*])\n+\n+index1 = image_index(a, [3, -4, 88] )\n+index2 = image_index(b, [-1, 0] )\n+index3 = image_index(c, [1] )\n+if (index1 /= 1 .or. index2 /= 1 .or. index3 /= 1) call abort()\n+\n+\n+index1 = image_index(a, [3, -3, 88] )\n+index2 = image_index(b, [0, 0] )\n+index3 = image_index(c, [2] )\n+\n+if (one .and. (index1 /= 0 .or. index2 /= 0 .or. index3 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 2 .or. index2 /= 2 .or. index3 /= 2)) &\n+  call abort()\n+\n+\n+index1 = image_index(d, [-1, 1] )\n+index2 = image_index(d, [0, 1] )\n+\n+if (one .and. (index1 /= 1 .or. index2 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 1 .or. index2 /= 2)) &\n+  call abort()\n+\n+index1 = image_index(e, [-1, 3] )\n+index2 = image_index(e, [-1, 4] )\n+\n+if (one .and. (index1 /= 1 .or. index2 /= 0)) &\n+  call abort()\n+if (.not. one .and. (index1 /= 1 .or. index2 /= 2)) &\n+  call abort()\n+\n+call test(1, a,b,c)\n+\n+! The following test is in honour of the F2008 standard:\n+deallocate(a)\n+allocate(a (10) [10, 0:9, 0:*])\n+\n+index1 = image_index(a, [1, 0, 0] )\n+index2 = image_index(a, [3, 1, 2] )  ! = 213, yeah!\n+index3 = image_index(a, [3, 1, 0] )  ! = 13\n+\n+if (num_images() < 13 .and. (index1 /= 1 .or. index2 /= 0 .or. index3 /= 0)) &\n+  call abort()\n+if (num_images() >= 213 .and. (index1 /= 1 .or. index2 /= 213 .or. index3 /= 13)) &\n+  call abort()\n+if (num_images() >= 13 .and. (index1 /= 1 .or. index2 /= 0 .or. index3 /= 13)) &\n+  call abort()\n+\n+\n+contains\n+subroutine test(n, a, b, c)\n+  integer :: n\n+  integer :: a(1)[3*n:3*n, -4*n:-3*n, 88*n:*], b(2)[-1*n:0*n,0*n:*], c(3*n,3*n)[*]\n+\n+  index1 = image_index(a, [3, -4, 88] )\n+  index2 = image_index(b, [-1, 0] )\n+  index3 = image_index(c, [1] )\n+  if (index1 /= 1 .or. index2 /= 1 .or. index3 /= 1) call abort()\n+\n+\n+  index1 = image_index(a, [3, -3, 88] )\n+  index2 = image_index(b, [0, 0] )\n+  index3 = image_index(c, [2] )\n+\n+  if (one .and. (index1 /= 0 .or. index2 /= 0 .or. index3 /= 0)) &\n+    call abort()\n+  if (.not. one .and. (index1 /= 2 .or. index2 /= 2 .or. index3 /= 2)) &\n+    call abort()\n+end subroutine test\n+end program test_image_index"}]}