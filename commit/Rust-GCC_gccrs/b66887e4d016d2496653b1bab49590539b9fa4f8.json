{"sha": "b66887e4d016d2496653b1bab49590539b9fa4f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2ODg3ZTRkMDE2ZDI0OTY2NTNiMWJhYjQ5NTkwNTM5YjlmYTRmOA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-12-10T21:58:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-12-10T21:58:49Z"}, "message": "re PR c++/42317 (Issues with comdat virtual dtors)\n\n\tPR c++/42317\n\t* cgraph.h (struct cgraph_node): Add same_comdat_group field.\n\t* cgraph.c (cgraph_remove_node): Unchain node from same_comdat_group\n\tcircular list.\n\t(cgraph_node_can_be_local_p): Return false for DECL_COMDAT with\n\tnode->same_comdat_group.\n\t* ipa.c (cgraph_remove_unreachable_nodes): For any reachable node\n\tmark all its same_comdat_group nodes as also reachable.\n\t(cgraph_externally_visible_p): Return true even if any of\n\tsame_comdat_group nodes has address taken.\n\t* lto-cgraph.c (lto_output_node): Stream out same_comdat_group.\n\t(output_cgraph): Ensure other same_comdat_group nodes are also\n\tincluded.\n\t(input_node): Stream in same_comdat_group.\n\t(input_cgraph_1): Fix up same_comdat_group fields from references\n\tto pointers.\n\t* cgraphunit.c (cgraph_analyze_functions): Mark all other\n\tsame_comdat_group nodes as reachable.\n\t(cgraph_mark_functions_to_output): For each node->process process\n\talso other same_comdat_group nodes.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Don't reuse nodes\n\twith same_comdat_group non-NULL.\n\t(cgraph_mark_inline_edge): Likewise.\n\n\t* decl2.c (cp_write_global_declarations): Clear DECL_EXTERNAL\n\talso on all other functions in the same comdat group.\n\t* optimize.c (maybe_clone_body): Also optimize virtual implicit\n\tdtors.  For virtual comdat dtors tell cgraph that base and deleting\n\tdtor are in the same comdat group.\n\n\t* config/abi/pre/gnu.ver: Don't export certain base dtors that\n\tweren't previously exported.\n\n\t* g++.dg/opt/dtor2.C: New test.\n\t* g++.dg/opt/dtor2.h: New file.\n\t* g++.dg/opt/dtor2-aux.cc: New file.\n\nFrom-SVN: r155143", "tree": {"sha": "d4a06720c9f0e8aaf194c011c4b0206f944bc2fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4a06720c9f0e8aaf194c011c4b0206f944bc2fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b66887e4d016d2496653b1bab49590539b9fa4f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66887e4d016d2496653b1bab49590539b9fa4f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b66887e4d016d2496653b1bab49590539b9fa4f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b66887e4d016d2496653b1bab49590539b9fa4f8/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63bcb71f99965d29bc1023b92ae4744d5a897e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63bcb71f99965d29bc1023b92ae4744d5a897e7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63bcb71f99965d29bc1023b92ae4744d5a897e7a"}], "stats": {"total": 354, "additions": 325, "deletions": 29}, "files": [{"sha": "79fb7b1f554789c4ec41e1e6a04a1083ea7c7eca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -1,3 +1,29 @@\n+2009-12-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/42317\n+\t* cgraph.h (struct cgraph_node): Add same_comdat_group field.\n+\t* cgraph.c (cgraph_remove_node): Unchain node from same_comdat_group\n+\tcircular list.\n+\t(cgraph_node_can_be_local_p): Return false for DECL_COMDAT with\n+\tnode->same_comdat_group.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): For any reachable node\n+\tmark all its same_comdat_group nodes as also reachable.\n+\t(cgraph_externally_visible_p): Return true even if any of\n+\tsame_comdat_group nodes has address taken.\n+\t* lto-cgraph.c (lto_output_node): Stream out same_comdat_group.\n+\t(output_cgraph): Ensure other same_comdat_group nodes are also\n+\tincluded.\n+\t(input_node): Stream in same_comdat_group.\n+\t(input_cgraph_1): Fix up same_comdat_group fields from references\n+\tto pointers.\n+\t* cgraphunit.c (cgraph_analyze_functions): Mark all other\n+\tsame_comdat_group nodes as reachable.\n+\t(cgraph_mark_functions_to_output): For each node->process process\n+\talso other same_comdat_group nodes.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Don't reuse nodes\n+\twith same_comdat_group non-NULL.\n+\t(cgraph_mark_inline_edge): Likewise.\n+\n 2009-12-10  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/42228"}, {"sha": "0ed097a8b0bcaf8fa58473aa36baf605a58b3218", "filename": "gcc/cgraph.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -1443,6 +1443,20 @@ cgraph_remove_node (struct cgraph_node *node)\n   while (node->same_body)\n     cgraph_remove_same_body_alias (node->same_body);\n \n+  if (node->same_comdat_group)\n+    {\n+      struct cgraph_node *prev;\n+      for (prev = node->same_comdat_group;\n+\t   prev->same_comdat_group != node;\n+\t   prev = prev->same_comdat_group)\n+\t;\n+      if (node->same_comdat_group == prev)\n+\tprev->same_comdat_group = NULL;\n+      else\n+\tprev->same_comdat_group = node->same_comdat_group;\n+      node->same_comdat_group = NULL;\n+    }\n+\n   /* While all the clones are removed after being proceeded, the function\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case.\n@@ -2172,7 +2186,8 @@ bool\n cgraph_node_can_be_local_p (struct cgraph_node *node)\n {\n   return (!node->needed\n-  \t  && (DECL_COMDAT (node->decl) || !node->local.externally_visible));\n+\t  && ((DECL_COMDAT (node->decl) && !node->same_comdat_group)\n+\t      || !node->local.externally_visible));\n }\n \n /* Bring NODE local.  */"}, {"sha": "268e6d442f3d1c2e6d960565d817b68628139d71", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -200,6 +200,8 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   /* For normal nodes pointer to the list of alias and thunk nodes,\n      in alias/thunk nodes pointer to the normal node.  */\n   struct cgraph_node *same_body;\n+  /* Circular list of nodes in the same comdat group if non-NULL.  */\n+  struct cgraph_node *same_comdat_group;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;"}, {"sha": "cf1a00154727fa35b717992c67f55ad9d7bfb111", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -982,6 +982,14 @@ cgraph_analyze_functions (void)\n \tif (!edge->callee->reachable)\n \t  cgraph_mark_reachable_node (edge->callee);\n \n+      if (node->same_comdat_group)\n+\t{\n+\t  for (next = node->same_comdat_group;\n+\t       next != node;\n+\t       next = next->same_comdat_group)\n+\t    cgraph_mark_reachable_node (next);\n+\t}\n+\n       /* If decl is a clone of an abstract function, mark that abstract\n \t function so that we don't release its body. The DECL_INITIAL() of that\n          abstract function declaration will be later needed to output debug info.  */\n@@ -1094,13 +1102,21 @@ static void\n cgraph_mark_functions_to_output (void)\n {\n   struct cgraph_node *node;\n+#ifdef ENABLE_CHECKING\n+  bool check_same_comdat_groups = false;\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    gcc_assert (!node->process);\n+#endif\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       tree decl = node->decl;\n       struct cgraph_edge *e;\n \n-      gcc_assert (!node->process);\n+      gcc_assert (!node->process || node->same_comdat_group);\n+      if (node->process)\n+\tcontinue;\n \n       for (e = node->callers; e; e = e->next_caller)\n \tif (e->inline_failed)\n@@ -1115,7 +1131,23 @@ cgraph_mark_functions_to_output (void)\n \t      || (e && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n-\tnode->process = 1;\n+\t{\n+\t  node->process = 1;\n+\t  if (node->same_comdat_group)\n+\t    {\n+\t      struct cgraph_node *next;\n+\t      for (next = node->same_comdat_group;\n+\t\t   next != node;\n+\t\t   next = next->same_comdat_group)\n+\t\tnext->process = 1;\n+\t    }\n+\t}\n+      else if (node->same_comdat_group)\n+\t{\n+#ifdef ENABLE_CHECKING\n+\t  check_same_comdat_groups = true;\n+#endif\n+\t}\n       else\n \t{\n \t  /* We should've reclaimed all functions that are not needed.  */\n@@ -1135,6 +1167,21 @@ cgraph_mark_functions_to_output (void)\n \t}\n \n     }\n+#ifdef ENABLE_CHECKING\n+  if (check_same_comdat_groups)\n+    for (node = cgraph_nodes; node; node = node->next)\n+      if (node->same_comdat_group && !node->process)\n+\t{\n+\t  tree decl = node->decl;\n+\t  if (!node->global.inlined_to\n+\t      && gimple_has_body_p (decl)\n+\t      && !DECL_EXTERNAL (decl))\n+\t    {\n+\t      dump_cgraph_node (stderr, node);\n+\t      internal_error (\"failed to reclaim unneeded function\");\n+\t    }\n+\t}\n+#endif\n }\n \n /* DECL is FUNCTION_DECL.  Initialize datastructures so DECL is a function"}, {"sha": "c98e68a7a50bf79dc8b48244ef3053feafcd7f12", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -1,3 +1,12 @@\n+2009-12-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/42317\n+\t* decl2.c (cp_write_global_declarations): Clear DECL_EXTERNAL\n+\talso on all other functions in the same comdat group.\n+\t* optimize.c (maybe_clone_body): Also optimize virtual implicit\n+\tdtors.  For virtual comdat dtors tell cgraph that base and deleting\n+\tdtor are in the same comdat group.\n+\n 2009-12-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/42010"}, {"sha": "d4a866a6613a2d92d3491c00914678924e0b9b35", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -3660,7 +3660,7 @@ cp_write_global_declarations (void)\n \t      && DECL_INITIAL (decl)\n \t      && decl_needed_p (decl))\n \t    {\n-\t      struct cgraph_node *node = cgraph_get_node (decl), *alias;\n+\t      struct cgraph_node *node = cgraph_get_node (decl), *alias, *next;\n \n \t      DECL_EXTERNAL (decl) = 0;\n \t      /* If we mark !DECL_EXTERNAL one of the same body aliases,\n@@ -3671,6 +3671,23 @@ cp_write_global_declarations (void)\n \t\t  for (alias = node->same_body; alias; alias = alias->next)\n \t\t    DECL_EXTERNAL (alias->decl) = 0;\n \t\t}\n+\t      /* If we mark !DECL_EXTERNAL one of the symbols in some comdat\n+\t\t group, we need to mark all symbols in the same comdat group\n+\t\t that way.  */\n+\t      if (node->same_comdat_group)\n+\t\tfor (next = node->same_comdat_group;\n+\t\t     next != node;\n+\t\t     next = next->same_comdat_group)\n+\t\t  {\n+\t\t    DECL_EXTERNAL (next->decl) = 0;\n+\t\t    if (next->same_body)\n+\t\t      {\n+\t\t\tfor (alias = next->same_body;\n+\t\t\t     alias;\n+\t\t\t     alias = alias->next)\n+\t\t\t  DECL_EXTERNAL (alias->decl) = 0;\n+\t\t      }\n+\t\t  }\n \t    }\n \n \t  /* If we're going to need to write this function out, and"}, {"sha": "325df8ffcd7fa75931c41d57ef8b4e39a6da9494", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -292,12 +292,7 @@ maybe_clone_body (tree fn)\n \t  && (SUPPORTS_ONE_ONLY || !DECL_WEAK (fns[0]))\n \t  && (!DECL_ONE_ONLY (fns[0])\n \t      || (HAVE_COMDAT_GROUP\n-\t\t  && DECL_WEAK (fns[0])\n-\t\t  /* Don't optimize synthetized virtual dtors, because then\n-\t\t     the deleting and other dtors are emitted when needed\n-\t\t     and so it is not certain we would emit both\n-\t\t     deleting and complete/base dtors in the comdat group.  */\n-\t\t  && (fns[2] == NULL || !DECL_ARTIFICIAL (fn))))\n+\t\t  && DECL_WEAK (fns[0])))\n \t  && cgraph_same_body_alias (clone, fns[0]))\n \t{\n \t  alias = true;\n@@ -396,9 +391,18 @@ maybe_clone_body (tree fn)\n     {\n       DECL_COMDAT_GROUP (fns[1]) = comdat_group;\n       if (fns[2])\n-\t/* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n-\t   virtual, it goes into the same comdat group as well.  */\n-\tDECL_COMDAT_GROUP (fns[2]) = comdat_group;\n+\t{\n+\t  struct cgraph_node *base_dtor_node, *deleting_dtor_node;\n+\t  /* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n+\t     virtual, it goes into the same comdat group as well.  */\n+\t  DECL_COMDAT_GROUP (fns[2]) = comdat_group;\n+\t  base_dtor_node = cgraph_node (fns[0]);\n+\t  deleting_dtor_node = cgraph_node (fns[2]);\n+\t  gcc_assert (base_dtor_node->same_comdat_group == NULL);\n+\t  gcc_assert (deleting_dtor_node->same_comdat_group == NULL);\n+\t  base_dtor_node->same_comdat_group = deleting_dtor_node;\n+\t  deleting_dtor_node->same_comdat_group = base_dtor_node;\n+\t}\n     }\n \n   /* We don't need to process the original function any further.  */"}, {"sha": "b146d0b13e29088e1a6aeb40a3cd94a306a6af98", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -247,6 +247,10 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t In that case just go ahead and re-use it.  */\n       if (!e->callee->callers->next_caller\n \t  && cgraph_can_remove_if_no_direct_calls_p (e->callee)\n+\t  /* Don't reuse if more than one function shares a comdat group.\n+\t     If the other function(s) are needed, we need to emit even\n+\t     this function out of line.  */\n+\t  && !e->callee->same_comdat_group\n \t  && !cgraph_new_nodes)\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n@@ -311,7 +315,8 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   e->callee->global.inlined = true;\n \n   if (e->callee->callers->next_caller\n-      || !cgraph_can_remove_if_no_direct_calls_p (e->callee))\n+      || !cgraph_can_remove_if_no_direct_calls_p (e->callee)\n+      || e->callee->same_comdat_group)\n     duplicate = true;\n   cgraph_clone_inlined_nodes (e, true, update_original);\n "}, {"sha": "b1844db256e3b4c2a981717e93b0e8acfe55129a", "filename": "gcc/ipa.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -1,5 +1,5 @@\n /* Basic IPA optimizations and utilities.\n-   Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation,\n+   Copyright (C) 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation,\n    Inc.\n \n This file is part of GCC.\n@@ -179,7 +179,25 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t          first = e->callee;\n \t        }\n \t    }\n-\t\n+\n+      /* If any function in a comdat group is reachable, force\n+\t all other functions in the same comdat group to be\n+\t also reachable.  */\n+      if (node->same_comdat_group\n+\t  && node->reachable\n+\t  && !node->global.inlined_to)\n+\t{\n+\t  for (next = node->same_comdat_group;\n+\t       next != node;\n+\t       next = next->same_comdat_group)\n+\t    if (!next->reachable)\n+\t      {\n+\t\tnext->aux = first;\n+\t\tfirst = next;\n+\t\tnext->reachable = true;\n+\t      }\n+\t}\n+\n       /* We can freely remove inline clones even if they are cloned, however if\n \t function is clone of real clone, we must keep it around in order to\n \t make materialize_clones produce function body with the changes\n@@ -302,8 +320,24 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program)\n   /* COMDAT functions must be shared only if they have address taken,\n      otherwise we can produce our own private implementation with\n      -fwhole-program.  */\n-  if (DECL_COMDAT (node->decl) && (node->address_taken || !node->analyzed))\n-    return true;\n+  if (DECL_COMDAT (node->decl))\n+    {\n+      if (node->address_taken || !node->analyzed)\n+\treturn true;\n+      if (node->same_comdat_group)\n+\t{\n+\t  struct cgraph_node *next;\n+\n+\t  /* If more than one function is in the same COMDAT group, it must\n+\t     be shared even if just one function in the comdat group has\n+\t     address taken.  */\n+\t  for (next = node->same_comdat_group;\n+\t       next != node;\n+\t       next = next->same_comdat_group)\n+\t    if (next->address_taken || !next->analyzed)\n+\t      return true;\n+\t}\n+    }\n   if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n   if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))"}, {"sha": "e02999d98a164d5a6fb635ec08df7c40490471ec", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -306,6 +306,15 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   lto_output_sleb128_stream (ob->main_stream,\n \t\t\t     node->global.estimated_growth);\n   lto_output_uleb128_stream (ob->main_stream, node->global.inlined);\n+  if (node->same_comdat_group)\n+    {\n+      ref = lto_cgraph_encoder_lookup (encoder, node->same_comdat_group);\n+      gcc_assert (ref != LCC_NOT_FOUND);\n+    }\n+  else\n+    ref = LCC_NOT_FOUND;\n+  lto_output_sleb128_stream (ob->main_stream, ref);\n+\n   if (node->same_body)\n     {\n       struct cgraph_node *alias;\n@@ -407,8 +416,30 @@ output_cgraph (cgraph_node_set set)\n \t      /* We should have moved all the inlines.  */\n \t      gcc_assert (!callee->global.inlined_to);\n \t      lto_cgraph_encoder_encode (encoder, callee);\n+\t      /* Also with each included function include all other functions\n+\t\t in the same comdat group.  */\n+\t      if (callee->same_comdat_group)\n+\t\t{\n+\t\t  struct cgraph_node *next;\n+\t\t  for (next = callee->same_comdat_group;\n+\t\t       next != callee;\n+\t\t       next = next->same_comdat_group)\n+\t\t    if (!cgraph_node_in_set_p (next, set))\n+\t\t      lto_cgraph_encoder_encode (encoder, next);\n+\t\t}\n \t    }\n \t}\n+      /* Also with each included function include all other functions\n+\t in the same comdat group.  */\n+      if (node->same_comdat_group)\n+\t{\n+\t  struct cgraph_node *next;\n+\t  for (next = node->same_comdat_group;\n+\t       next != node;\n+\t       next = next->same_comdat_group)\n+\t    if (!cgraph_node_in_set_p (next, set))\n+\t      lto_cgraph_encoder_encode (encoder, next);\n+\t}\n     }\n \n   /* Write out the nodes.  */\n@@ -519,7 +550,7 @@ input_node (struct lto_file_decl_data *file_data,\n   bool clone_p;\n   int estimated_stack_size = 0;\n   int stack_frame_offset = 0;\n-  int ref = LCC_NOT_FOUND;\n+  int ref = LCC_NOT_FOUND, ref2 = LCC_NOT_FOUND;\n   int estimated_growth = 0;\n   int time = 0;\n   int size = 0;\n@@ -561,6 +592,7 @@ input_node (struct lto_file_decl_data *file_data,\n   size = lto_input_sleb128 (ib);\n   estimated_growth = lto_input_sleb128 (ib);\n   inlined = lto_input_uleb128 (ib);\n+  ref2 = lto_input_sleb128 (ib);\n   same_body_count = lto_input_uleb128 (ib);\n \n   /* Make sure that we have not read this node before.  Nodes that\n@@ -587,6 +619,9 @@ input_node (struct lto_file_decl_data *file_data,\n   node->global.estimated_growth = estimated_growth;\n   node->global.inlined = inlined;\n \n+  /* Store a reference for now, and fix up later to be a pointer.  */\n+  node->same_comdat_group = (cgraph_node_ptr) (intptr_t) ref2;\n+\n   while (same_body_count-- > 0)\n     {\n       tree alias_decl;\n@@ -707,13 +742,21 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \n   for (i = 0; VEC_iterate (cgraph_node_ptr, nodes, i, node); i++)\n     {\n-      const int ref = (int) (intptr_t) node->global.inlined_to;\n+      int ref = (int) (intptr_t) node->global.inlined_to;\n \n       /* Fixup inlined_to from reference to pointer.  */\n       if (ref != LCC_NOT_FOUND)\n \tnode->global.inlined_to = VEC_index (cgraph_node_ptr, nodes, ref);\n       else\n \tnode->global.inlined_to = NULL;\n+\n+      ref = (int) (intptr_t) node->same_comdat_group;\n+\n+      /* Fixup same_comdat_group from reference to pointer.  */\n+      if (ref != LCC_NOT_FOUND)\n+\tnode->same_comdat_group = VEC_index (cgraph_node_ptr, nodes, ref);\n+      else\n+\tnode->same_comdat_group = NULL;\n     }\n \n   VEC_free (cgraph_node_ptr, heap, nodes);"}, {"sha": "939bab3dc9355126cf4884350b7bda622502fba9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -1,3 +1,10 @@\n+2009-12-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/42317\n+\t* g++.dg/opt/dtor2.C: New test.\n+\t* g++.dg/opt/dtor2.h: New file.\n+\t* g++.dg/opt/dtor2-aux.cc: New file.\n+\n 2009-12-10  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/41369"}, {"sha": "9e87cc817d107235bbdfee91e62bba776e3de092", "filename": "gcc/testsuite/g++.dg/opt/dtor2-aux.cc", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2-aux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2-aux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2-aux.cc?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// { dg-options \"\" }\n+\n+#include \"dtor2.h\"\n+\n+A::A () {}\n+A::~A () {}\n+\n+void B::mb () {}\n+B::B (int) {}\n+B::~B () {}\n+\n+void C::mc () {}\n+C::C (int x) : B (x) {}\n+\n+D::~D () {}"}, {"sha": "39b8e6999053228c75c9ca0d38756752f6a713a5", "filename": "gcc/testsuite/g++.dg/opt/dtor2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2.C?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/42317\n+// { dg-do link }\n+// { dg-options \"-O0\" }\n+// { dg-additional-sources \"dtor2-aux.cc\" }\n+\n+#include \"dtor2.h\"\n+\n+D::D (int x) : C (x) {}\n+\n+int\n+main ()\n+{\n+}"}, {"sha": "a869400012f2c9497b068bb90ad0c415d1ae492b", "filename": "gcc/testsuite/g++.dg/opt/dtor2.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdtor2.h?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -0,0 +1,29 @@\n+struct A\n+{\n+  A ();\n+  ~A ();\n+};\n+\n+struct B\n+{\n+  A b;\n+  virtual void mb ();\n+  B (int);\n+  virtual ~B ();\n+};\n+\n+struct C : public B\n+{\n+  virtual void mc ();\n+  C (int);\n+  ~C ();\n+};\n+\n+inline C::~C () {}\n+\n+struct D : public C\n+{\n+  A d;\n+  D (int);\n+  ~D ();\n+};"}, {"sha": "cab2d6bb875bb0db8e5608e398525d12f294dfc8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -1,3 +1,9 @@\n+2009-12-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/42317\n+\t* config/abi/pre/gnu.ver: Don't export certain base dtors that\n+\tweren't previously exported.\n+\n 2009-12-10  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/42261 (take 2)"}, {"sha": "4ed1cfeb2cde8fa8c48e43eb12d71fdaf52fab51", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b66887e4d016d2496653b1bab49590539b9fa4f8/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b66887e4d016d2496653b1bab49590539b9fa4f8/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=b66887e4d016d2496653b1bab49590539b9fa4f8", "patch": "@@ -72,13 +72,18 @@ GLIBCXX_3.4 {\n       std::c[v-z]*;\n #     std::[d-g]*;\n       std::d[a-d]*;\n-      std::d[f-z]*;\n+      std::d[f-n]*;\n+      std::domain_error::d*;\n+#     std::domain_error::~d*;\n+      std::d[p-z]*;\n       std::e[a-q]*;\n       std::error[^_]*;\n       std::e[s-z]*;\n       std::gslice*;\n       std::h[^a]*;\n-      std::i[a-n]*;\n+      std::i[a-m]*;\n+      std::invalid_argument::i*;\n+#     std::invalid_argument::~i*;\n #     std::ios_base::[A-Ha-z]*;\n       std::ios_base::[A-Ha-f]*;\n       std::ios_base::goodbit;\n@@ -94,7 +99,8 @@ GLIBCXX_3.4 {\n       std::istrstream*;\n       std::i[t-z]*;\n       std::[A-Zj-k]*;\n-      std::length_error*;\n+      std::length_error::l*;\n+#     std::length_error::~l*;\n       std::logic_error*;\n       std::locale::[A-Za-e]*;\n       std::locale::facet::[A-Za-z]*;\n@@ -122,10 +128,14 @@ GLIBCXX_3.4 {\n       std::nu[^m]*;\n       std::num[^e]*;\n       std::ostrstream*;\n-      std::out_of_range*;\n-      std::overflow_error*;\n+      std::out_of_range::o*;\n+#     std::out_of_range::~o*;\n+      std::overflow_error::o*;\n+#     std::overflow_error::~o*;\n #     std::[p-q]*;\n-      std::r[^e]*;\n+      std::r[^ae]*;\n+      std::range_error::r*;\n+#     std::range_error::~r*;\n       std::re[^t]*;\n #     std::rethrow_exception\n       std::set_new_handler*;\n@@ -143,7 +153,8 @@ GLIBCXX_3.4 {\n       std::tr1::h[^a]*;\n       std::t[s-z]*;\n #     std::[A-Zu-z]*;\n-      std::underflow_error*;\n+      std::underflow_error::u*;\n+#     std::underflow_error::~u*;\n       std::uncaught_exception*;\n       std::unexpected*;\n       std::[A-Zv-z]*;\n@@ -284,7 +295,8 @@ GLIBCXX_3.4 {\n     _ZNSt15basic_streambufI[cw]St11char_traitsI[cw]EEaSERKS2_;\n \n     # std::basic_stringbuf\n-    _ZNSt15basic_stringbufI[cw]St11char_traitsI[cw]ESaI[cw]EE[CD]*;\n+    _ZNSt15basic_stringbufI[cw]St11char_traitsI[cw]ESaI[cw]EEC*;\n+    _ZNSt15basic_stringbufI[cw]St11char_traitsI[cw]ESaI[cw]EED[^2]*;\n     _ZNSt15basic_stringbufI[cw]St11char_traitsI[cw]ESaI[cw]EE[0-9][a-r]*;\n     _ZNSt15basic_stringbufI[cw]St11char_traitsI[cw]ESaI[cw]EE[0-9]seek*;\n     _ZNSt15basic_stringbufI[cw]St11char_traitsI[cw]ESaI[cw]EE[0-9]set*;\n@@ -639,6 +651,16 @@ GLIBCXX_3.4 {\n     _ZGVNSt[^1]*;\n     _ZGVNSt1[^7]*;\n \n+    # complete and deleting destructors where base destructors should not\n+    # be exported.\n+    _ZNSt11range_errorD[01]Ev;\n+    _ZNSt12domain_errorD[01]Ev;\n+    _ZNSt12length_errorD[01]Ev;\n+    _ZNSt12out_of_rangeD[01]Ev;\n+    _ZNSt14overflow_errorD[01]Ev;\n+    _ZNSt15underflow_errorD[01]Ev;\n+    _ZNSt16invalid_argumentD[01]Ev;\n+\n     # virtual function thunks\n     _ZThn8_NS*;\n     _ZThn16_NS*;\n@@ -891,7 +913,8 @@ GLIBCXX_3.4.10 {\n     _ZNSt15basic_streambufI[cw]St11char_traitsI[cw]EE6stosscEv;\n \n     _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EE4syncEv;\n-    _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EE[5-9CD]*;\n+    _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EE[5-9C]*;\n+    _ZN9__gnu_cxx18stdio_sync_filebufI[cw]St11char_traitsI[cw]EED[^2]*;\n \n } GLIBCXX_3.4.9;\n "}]}