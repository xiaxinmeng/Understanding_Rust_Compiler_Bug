{"sha": "2754d3c5acdcddf405360d38a9c071c0280c06ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1NGQzYzVhY2RjZGRmNDA1MzYwZDM4YTljMDcxYzAyODBjMDZjZQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-06-10T17:15:13Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-06-10T17:15:13Z"}, "message": "Fix cfi generation for SH[1-4]:\n\n\t* sh.c (frame_insn): New function.\n\t(output_stack_adjust): Add parameter emit_fn.  All callers changed.\n\t(push): Now returns rtx.  Use frame_insn.\n\t(sh_expand_prologue): Clear RTX_FRAME_RELATED_P for second push\n\tof a DF register.\n\t* sh.h (INCOMING_RETURN_ADDR_RTX, DWARF_FRAME_RETURN_COLUMN): Define.\n\nFrom-SVN: r54445", "tree": {"sha": "4ffb4c775cedc0efe717c1b99d38130272fe642e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ffb4c775cedc0efe717c1b99d38130272fe642e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2754d3c5acdcddf405360d38a9c071c0280c06ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2754d3c5acdcddf405360d38a9c071c0280c06ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2754d3c5acdcddf405360d38a9c071c0280c06ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2754d3c5acdcddf405360d38a9c071c0280c06ce/comments", "author": null, "committer": null, "parents": [{"sha": "f3e83dc2246c53ea5ffbc24caa18e5cf369baf27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e83dc2246c53ea5ffbc24caa18e5cf369baf27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3e83dc2246c53ea5ffbc24caa18e5cf369baf27"}], "stats": {"total": 80, "additions": 62, "deletions": 18}, "files": [{"sha": "dac47a6e7b8445f8d8822cf18fb83b6f95e47d37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2754d3c5acdcddf405360d38a9c071c0280c06ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2754d3c5acdcddf405360d38a9c071c0280c06ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2754d3c5acdcddf405360d38a9c071c0280c06ce", "patch": "@@ -1,3 +1,14 @@\n+Mon Jun 10 18:02:24 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\n+\tFix cfi generation for SH[1-4]:\n+\n+\t* sh.c (frame_insn): New function.\n+\t(output_stack_adjust): Add parameter emit_fn.  All callers changed.\n+\t(push): Now returns rtx.  Use frame_insn.\n+\t(sh_expand_prologue): Clear RTX_FRAME_RELATED_P for second push\n+\tof a DF register.\n+\t* sh.h (INCOMING_RETURN_ADDR_RTX, DWARF_FRAME_RETURN_COLUMN): Define.\n+\n 2002-06-10  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Makefile.in (STAGESTUFF): Add s-gtype, gt-*.h, gtype-*.h,"}, {"sha": "58824d83749671b9dbcfc5457e1f7eeb6fa3e5a0", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2754d3c5acdcddf405360d38a9c071c0280c06ce/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2754d3c5acdcddf405360d38a9c071c0280c06ce/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=2754d3c5acdcddf405360d38a9c071c0280c06ce", "patch": "@@ -180,8 +180,9 @@ static int mova_p PARAMS ((rtx));\n static rtx find_barrier PARAMS ((int, rtx, rtx));\n static int noncall_uses_reg PARAMS ((rtx, rtx, rtx *));\n static rtx gen_block_redirect PARAMS ((rtx, int, int));\n-static void output_stack_adjust PARAMS ((int, rtx, int));\n-static void push PARAMS ((int));\n+static void output_stack_adjust PARAMS ((int, rtx, int, rtx (*) (rtx)));\n+static rtx frame_insn PARAMS ((rtx));\n+static rtx push PARAMS ((int));\n static void pop PARAMS ((int));\n static void push_regs PARAMS ((HOST_WIDE_INT *));\n static void calc_live_regs PARAMS ((int *, HOST_WIDE_INT *));\n@@ -4204,10 +4205,11 @@ static int extra_push;\n   of a general register that we may clobber.  */\n \n static void\n-output_stack_adjust (size, reg, temp)\n+output_stack_adjust (size, reg, temp, emit_fn)\n      int size;\n      rtx reg;\n      int temp;\n+     rtx (*emit_fn) PARAMS ((rtx));\n {\n   if (size)\n     {\n@@ -4217,19 +4219,20 @@ output_stack_adjust (size, reg, temp)\n \tabort ();\n \n       if (CONST_OK_FOR_ADD (size))\n-\temit_insn (GEN_ADD3 (reg, reg, GEN_INT (size)));\n+\temit_fn (GEN_ADD3 (reg, reg, GEN_INT (size)));\n       /* Try to do it with two partial adjustments; however, we must make\n \t sure that the stack is properly aligned at all times, in case\n \t an interrupt occurs between the two partial adjustments.  */\n       else if (CONST_OK_FOR_ADD (size / 2 & -align)\n \t       && CONST_OK_FOR_ADD (size - (size / 2 & -align)))\n \t{\n-\t  emit_insn (GEN_ADD3 (reg, reg, GEN_INT (size / 2 & -align)));\n-\t  emit_insn (GEN_ADD3 (reg, reg, GEN_INT (size - (size / 2 & -align))));\n+\t  emit_fn (GEN_ADD3 (reg, reg, GEN_INT (size / 2 & -align)));\n+\t  emit_fn (GEN_ADD3 (reg, reg, GEN_INT (size - (size / 2 & -align))));\n \t}\n       else\n \t{\n \t  rtx const_reg;\n+\t  rtx insn;\n \n \t  /* If TEMP is invalid, we could temporarily save a general\n \t     register to MACL.  However, there is currently no need\n@@ -4244,20 +4247,36 @@ output_stack_adjust (size, reg, temp)\n \t  if (size < 0)\n \t    {\n \t      emit_insn (GEN_MOV (const_reg, GEN_INT (-size)));\n-\t      emit_insn (GEN_SUB3 (reg, reg, const_reg));\n+\t      insn = emit_fn (GEN_SUB3 (reg, reg, const_reg));\n \t    }\n \t  else\n \t    {\n \t      emit_insn (GEN_MOV (const_reg, GEN_INT (size)));\n-\t      emit_insn (GEN_ADD3 (reg, reg, const_reg));\n+\t      insn = emit_fn (GEN_ADD3 (reg, reg, const_reg));\n \t    }\n+\t  if (emit_fn == frame_insn)\n+\t    REG_NOTES (insn)\n+\t      = (gen_rtx_EXPR_LIST\n+\t\t (REG_FRAME_RELATED_EXPR,\n+\t\t  gen_rtx_SET (VOIDmode, reg,\n+\t\t\t       gen_rtx_PLUS (SImode, reg, GEN_INT (size))),\n+\t\t  REG_NOTES (insn)));\n \t}\n     }\n }\n \n+static rtx\n+frame_insn (x)\n+     rtx x;\n+{\n+  x = emit_insn (x);\n+  RTX_FRAME_RELATED_P (x) = 1;\n+  return x;\n+}\n+\n /* Output RTL to push register RN onto the stack.  */\n \n-static void\n+static rtx\n push (rn)\n      int rn;\n {\n@@ -4276,10 +4295,11 @@ push (rn)\n   else\n     x = gen_push (gen_rtx_REG (SImode, rn));\n \n-  x = emit_insn (x);\n+  x = frame_insn (x);\n   REG_NOTES (x)\n     = gen_rtx_EXPR_LIST (REG_INC,\n \t\t\t gen_rtx_REG (SImode, STACK_POINTER_REGNUM), 0);\n+  return x;\n }\n \n /* Output RTL to pop register RN from the stack.  */\n@@ -4473,7 +4493,7 @@ sh_expand_prologue ()\n      and partially on the stack, e.g. a large structure.  */\n   output_stack_adjust (-current_function_pretend_args_size\n \t\t       - current_function_args_info.stack_regs * 8,\n-\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1);\n+\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1, frame_insn);\n \n   extra_push = 0;\n \n@@ -4537,11 +4557,14 @@ sh_expand_prologue ()\n \t  for (i = 0; i < NPARM_REGS(SImode); i++)\n \t    {\n \t      int rn = NPARM_REGS(SImode) + FIRST_PARM_REG - i - 1;\n+\t      rtx insn;\n+\n \t      if (i >= (NPARM_REGS(SImode) \n \t\t\t- current_function_args_info.arg_count[(int) SH_ARG_INT]\n \t\t\t))\n \t\tbreak;\n-\t      push (rn);\n+\t      insn = push (rn);\n+\t      RTX_FRAME_RELATED_P (insn) = 0;\n \t      extra_push += 4;\n \t    }\n \t}\n@@ -4571,7 +4594,7 @@ sh_expand_prologue ()\n \t\t      - d % (STACK_BOUNDARY / BITS_PER_UNIT));\n \n       offset = d + d_rounding;\n-      output_stack_adjust (-offset, stack_pointer_rtx, 1);\n+      output_stack_adjust (-offset, stack_pointer_rtx, 1, frame_insn);\n \n       /* We loop twice: first, we save 8-byte aligned registers in the\n \t higher addresses, that are known to be aligned.  Then, we\n@@ -4757,10 +4780,10 @@ sh_expand_prologue ()\n   target_flags = save_flags;\n \n   output_stack_adjust (-rounded_frame_size (d) + d_rounding,\n-\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1);\n+\t\t       stack_pointer_rtx, TARGET_SH5 ? 0 : 1, frame_insn);\n \n   if (frame_pointer_needed)\n-    emit_insn (GEN_MOV (frame_pointer_rtx, stack_pointer_rtx));\n+    frame_insn (GEN_MOV (frame_pointer_rtx, stack_pointer_rtx));\n \n   if (TARGET_SHCOMPACT\n       && (current_function_args_info.call_cookie & ~ CALL_COOKIE_RET_TRAMP(1)))\n@@ -4794,7 +4817,7 @@ sh_expand_epilogue ()\n \n   if (frame_pointer_needed)\n     {\n-      output_stack_adjust (frame_size, frame_pointer_rtx, 7);\n+      output_stack_adjust (frame_size, frame_pointer_rtx, 7, emit_insn);\n \n       /* We must avoid moving the stack pointer adjustment past code\n \t which reads from the local frame, else an interrupt could\n@@ -4810,7 +4833,7 @@ sh_expand_epilogue ()\n \t occur after the SP adjustment and clobber data in the local\n \t frame.  */\n       emit_insn (gen_blockage ());\n-      output_stack_adjust (frame_size, stack_pointer_rtx, 7);\n+      output_stack_adjust (frame_size, stack_pointer_rtx, 7, emit_insn);\n     }\n \n   if (SHMEDIA_REGS_STACK_ADJUST ())\n@@ -4986,7 +5009,7 @@ sh_expand_epilogue ()\n   output_stack_adjust (extra_push + current_function_pretend_args_size\n \t\t       + d + d_rounding\n \t\t       + current_function_args_info.stack_regs * 8,\n-\t\t       stack_pointer_rtx, 7);\n+\t\t       stack_pointer_rtx, 7, emit_insn);\n \n   /* Switch back to the normal stack if necessary.  */\n   if (sp_switch)"}, {"sha": "9e1b4b275555cf74391798396958584ed48dd217", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2754d3c5acdcddf405360d38a9c071c0280c06ce/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2754d3c5acdcddf405360d38a9c071c0280c06ce/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=2754d3c5acdcddf405360d38a9c071c0280c06ce", "patch": "@@ -2095,6 +2095,14 @@ while (0)\n   (((COUNT) == 0)\t\t\t\t\\\n    ? get_hard_reg_initial_val (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG) \\\n    : (rtx) 0)\n+\n+/* A C expression whose value is RTL representing the location of the\n+   incoming return address at the beginning of any function, before the\n+   prologue.  This RTL is either a REG, indicating that the return\n+   value is saved in REG, or a MEM representing a location in\n+   the stack.  */\n+#define INCOMING_RETURN_ADDR_RTX \\\n+  gen_rtx_REG (Pmode, TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n \f\n /* Generate necessary RTL for __builtin_saveregs().  */\n #define EXPAND_BUILTIN_SAVEREGS() sh_builtin_saveregs ()\n@@ -3230,6 +3238,8 @@ extern struct rtx_def *fpscr_rtx;\n #define MD_CAN_REDIRECT_BRANCH(INSN, SEQ) \\\n   sh_can_redirect_branch ((INSN), (SEQ))\n \n+#define DWARF_FRAME_RETURN_COLUMN (TARGET_SH5 ? PR_MEDIA_REG : PR_REG)\n+\n #if (defined CRT_BEGIN || defined CRT_END) && ! __SHMEDIA__\n /* SH constant pool breaks the devices in crtstuff.c to control section\n    in where code resides.  We have to write it as asm code.  */"}]}