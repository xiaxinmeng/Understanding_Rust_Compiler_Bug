{"sha": "562d1e9556777988ae46c5d1357af2636bc272ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYyZDFlOTU1Njc3Nzk4OGFlNDZjNWQxMzU3YWYyNjM2YmMyNzJlYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-02T16:01:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-10-02T16:01:47Z"}, "message": "cif-code.def (MAX_INLINE_INSNS_SINGLE_O2_LIMIT, [...]): New.\n\n\n\t* cif-code.def (MAX_INLINE_INSNS_SINGLE_O2_LIMIT,\n\tMAX_INLINE_INSNS_AUTO_O2_LIMIT): New.\n\t* ipa-inline.c (inline_insns_single, inline_insns_auto): New functions.\n\t(can_inline_edge_by_limits_p): Use it.\n\t(big_speedup_p): Use PARAM_INLINE_MIN_SPEEDUP_O2.\n\t(want_inline_small_function_p): Use O2 bounds.\n\t(edge_badness): LIkewise.\n\t* opts.c (default_options): Add OPT_finline_functions.\n\t* params.def (PARAM_INLINE_MIN_SPEEDUP_O2,\n\tPARAM_MAX_INLINE_INSNS_SINGLE_O2, PARAM_MAX_INLINE_INSNS_AUTO_O2):\n\tNew parameters.\n\n\t* g++.dg/tree-ssa/pr53844.C: Add -fno-inline-functions --param\n\tmax-inline-insns-single-O2=200.\n\t* gcc.c-torture/execute/builtins/builtins.exp: Add\n\t-fno-inline-functions to additional_flags.\n\t* gcc.dg/ipa/inline-7.c: Add -fno-inline-functions.\n\t* gcc.dg/optimize-bswapsi-5.c: Add -fno-inline-functions.\n\t* gcc.dg/tree-ssa/ssa-thread-12.c: Add --param\n\tearly-inlining-insns-O2=14 -fno-inline-functions; revert previous\n\tchange.\n\t* gcc.dg/winline-3.c: Use --param max-inline-insns-single-O2=1\n\t--param inline-min-speedup-O2=100\n\tinstead of --param max-inline-insns-single=1 --param\n\tinline-min-speedup=100\n\n\t* invoke.texi (-finline-functions): Update documentation.\n\t(max-inline-insns-single-O2, max-inline-insns-auto-O2,\n\tinline-min-speedup-O2): Document.\n\t(early-inlining-insns-O2): Simplify docs.\n\nFrom-SVN: r276469", "tree": {"sha": "b07b5dedff4846b2076284b72777f8790ef92e0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b07b5dedff4846b2076284b72777f8790ef92e0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/562d1e9556777988ae46c5d1357af2636bc272ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/562d1e9556777988ae46c5d1357af2636bc272ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/562d1e9556777988ae46c5d1357af2636bc272ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/562d1e9556777988ae46c5d1357af2636bc272ea/comments", "author": null, "committer": null, "parents": [{"sha": "352d2690f1eb7268cc21de643759e2f666119e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/352d2690f1eb7268cc21de643759e2f666119e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/352d2690f1eb7268cc21de643759e2f666119e9f"}], "stats": {"total": 179, "additions": 124, "deletions": 55}, "files": [{"sha": "8676ee1c0f3027742a3c804a07eca0363e9a634f", "filename": "gcc/cif-code.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -70,8 +70,12 @@ DEFCIFCODE(LARGE_STACK_FRAME_GROWTH_LIMIT, CIF_FINAL_NORMAL,\n \t   N_(\"--param large-stack-frame-growth limit reached\"))\n DEFCIFCODE(MAX_INLINE_INSNS_SINGLE_LIMIT, CIF_FINAL_NORMAL,\n \t   N_(\"--param max-inline-insns-single limit reached\"))\n+DEFCIFCODE(MAX_INLINE_INSNS_SINGLE_O2_LIMIT, CIF_FINAL_NORMAL,\n+\t   N_(\"--param max-inline-insns-single-O2 limit reached\"))\n DEFCIFCODE(MAX_INLINE_INSNS_AUTO_LIMIT, CIF_FINAL_NORMAL,\n \t   N_(\"--param max-inline-insns-auto limit reached\"))\n+DEFCIFCODE(MAX_INLINE_INSNS_AUTO_O2_LIMIT, CIF_FINAL_NORMAL,\n+\t   N_(\"--param max-inline-insns-auto-O2 limit reached\"))\n DEFCIFCODE(INLINE_UNIT_GROWTH_LIMIT, CIF_FINAL_NORMAL,\n \t   N_(\"--param inline-unit-growth limit reached\"))\n "}, {"sha": "486192017362804bdd8939e570b5c8b279eab02f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -8346,6 +8346,7 @@ also turns on the following optimization flags:\n -ffinite-loops @gol\n -fgcse  -fgcse-lm  @gol\n -fhoist-adjacent-loads @gol\n+-finline-functions @gol\n -finline-small-functions @gol\n -findirect-inlining @gol\n -fipa-bit-cp  -fipa-cp  -fipa-icf @gol\n@@ -8379,7 +8380,6 @@ by @option{-O2} and also turns on the following optimization flags:\n \n @c Please keep the following list alphabetized!\n @gccoptlist{-fgcse-after-reload @gol\n--finline-functions @gol\n -fipa-cp-clone\n -floop-interchange @gol\n -floop-unroll-and-jam @gol\n@@ -8559,7 +8559,7 @@ If all calls to a given function are integrated, and the function is\n declared @code{static}, then the function is normally not output as\n assembler code in its own right.\n \n-Enabled at levels @option{-O3}, @option{-Os}.  Also enabled\n+Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.  Also enabled\n by @option{-fprofile-use} and @option{-fauto-profile}.\n \n @item -finline-functions-called-once\n@@ -11175,19 +11175,30 @@ when modulo scheduling a loop.  Larger values can exponentially increase\n compilation time.\n \n @item max-inline-insns-single\n-Several parameters control the tree inliner used in GCC@.\n-This number sets the maximum number of instructions (counted in GCC's\n-internal representation) in a single function that the tree inliner\n-considers for inlining.  This only affects functions declared\n-inline and methods implemented in a class declaration (C++).\n+@item max-inline-insns-single-O2\n+Several parameters control the tree inliner used in GCC@.  This number sets the\n+maximum number of instructions (counted in GCC's internal representation) in a\n+single function that the tree inliner considers for inlining.  This only\n+affects functions declared inline and methods implemented in a class\n+declaration (C++). \n+\n+For functions compiled with optimization levels\n+@option{-O3} and @option{-Ofast} parameter @option{max-inline-insns-single} is\n+applied. In other cases @option{max-inline-insns-single-O2} is applied.\n+\n \n @item max-inline-insns-auto\n+@item max-inline-insns-auto-O2\n When you use @option{-finline-functions} (included in @option{-O3}),\n a lot of functions that would otherwise not be considered for inlining\n by the compiler are investigated.  To those functions, a different\n (more restrictive) limit compared to functions declared inline can\n be applied.\n \n+For functions compiled with optimization levels\n+@option{-O3} and @option{-Ofast} parameter @option{max-inline-insns-auto} is\n+applied. In other cases @option{max-inline-insns-auto-O2} is applied.\n+\n @item max-inline-insns-small\n This is bound applied to calls which are considered relevant with\n @option{-finline-small-functions}.\n@@ -11210,11 +11221,16 @@ Same as @option{--param uninlined-function-insns} and\n @option{--param uninlined-function-time} but applied to function thunks\n \n @item inline-min-speedup\n+@item inline-min-speedup-O2\n When estimated performance improvement of caller + callee runtime exceeds this\n threshold (in percent), the function can be inlined regardless of the limit on\n @option{--param max-inline-insns-single} and @option{--param\n max-inline-insns-auto}.\n \n+For functions compiled with optimization levels\n+@option{-O3} and @option{-Ofast} parameter @option{inline-min-speedup} is\n+applied. In other cases @option{inline-min-speedup-O2} is applied.\n+\n @item large-function-insns\n The limit specifying really large functions.  For functions larger than this\n limit after inlining, inlining is constrained by\n@@ -11291,17 +11307,14 @@ recursion depth can be guessed from the probability that function recurses\n via a given call expression.  This parameter limits inlining only to call\n expressions whose probability exceeds the given threshold (in percents).\n \n+@item early-inlining-insns\n @item early-inlining-insns-O2\n Specify growth that the early inliner can make.  In effect it increases\n the amount of inlining for code having a large abstraction penalty.\n-This is applied to functions compiled with @option{-O1} or @option{-O2}\n-optimization levels.\n \n-@item early-inlining-insns\n-Specify growth that the early inliner can make.  In effect it increases\n-the amount of inlining for code having a large abstraction penalty.\n-This is applied to functions compiled with @option{-O3} or @option{-Ofast}\n-optimization levels.\n+For functions compiled with optimization levels\n+@option{-O3} and @option{-Ofast} parameter @option{early-inlining-insns} is\n+applied. In other cases @option{early-inlining-insns-O2} is applied.\n \n @item max-early-inliner-iterations\n Limit of iterations of the early inliner.  This basically bounds"}, {"sha": "98d7fd3c828bd6364c8a18d86235cbb0c6726e2e", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -390,6 +390,28 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   return inlinable;\n }\n \n+/* Return inlining_insns_single limit for function N */\n+\n+static int\n+inline_insns_single (cgraph_node *n)\n+{\n+  if (opt_for_fn (n->decl, optimize >= 3))\n+    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE);\n+  else\n+    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE_O2);\n+}\n+\n+/* Return inlining_insns_auto limit for function N */\n+\n+static int\n+inline_insns_auto (cgraph_node *n)\n+{\n+  if (opt_for_fn (n->decl, optimize >= 3))\n+    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO);\n+  else\n+    return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO_O2);\n+}\n+\n /* Decide if we can inline the edge and possibly update\n    inline_failed reason.  \n    We check whether inlining is possible at all and whether\n@@ -532,8 +554,8 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t  int growth = estimate_edge_growth (e);\n \t  if (growth > PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SIZE)\n \t      && (!DECL_DECLARED_INLINE_P (callee->decl)\n-\t\t  && growth >= MAX (MAX_INLINE_INSNS_SINGLE,\n-\t\t\t\t    MAX_INLINE_INSNS_AUTO)))\n+\t\t  && growth >= MAX (inline_insns_single (caller),\n+\t\t\t\t    inline_insns_auto (caller))))\n \t    {\n \t      e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t      inlinable = false;\n@@ -745,9 +767,14 @@ big_speedup_p (struct cgraph_edge *e)\n   sreal spec_time = estimate_edge_time (e, &unspec_time);\n   sreal time = compute_uninlined_call_time (e, unspec_time);\n   sreal inlined_time = compute_inlined_call_time (e, spec_time);\n+  cgraph_node *caller = e->caller->global.inlined_to\n+\t\t        ? e->caller->global.inlined_to\n+\t\t        : e->caller;\n+  int limit = opt_for_fn (caller->decl, optimize) >= 3\n+\t      ? PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)\n+\t      : PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP_O2);\n \n-  if ((time - inlined_time) * 100\n-      > (sreal) (time * PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)))\n+  if ((time - inlined_time) * 100 > time * limit)\n     return true;\n   return false;\n }\n@@ -781,20 +808,29 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t   && (!e->count.ipa ().initialized_p () || !e->maybe_hot_p ()))\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n-\t      > MAX (MAX_INLINE_INSNS_SINGLE, MAX_INLINE_INSNS_AUTO))\n+\t      > MAX (inline_insns_single (e->caller),\n+\t\t     inline_insns_auto (e->caller)))\n     {\n-      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+      if (opt_for_fn (e->caller->decl, optimize) >= 3)\n+        e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+      else\n+        e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_O2_LIMIT;\n       want_inline = false;\n     }\n   else if ((DECL_DECLARED_INLINE_P (callee->decl)\n \t    || e->count.ipa ().nonzero_p ())\n \t   && ipa_fn_summaries->get (callee)->min_size\n \t\t- ipa_call_summaries->get (e)->call_stmt_size\n-\t      > 16 * MAX_INLINE_INSNS_SINGLE)\n+\t      > 16 * inline_insns_single (e->caller))\n     {\n-      e->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n-\t\t\t  ? CIF_MAX_INLINE_INSNS_SINGLE_LIMIT\n-\t\t\t  : CIF_MAX_INLINE_INSNS_AUTO_LIMIT);\n+      if (opt_for_fn (e->caller->decl, optimize) >= 3)\n+\te->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n+\t\t\t    ? CIF_MAX_INLINE_INSNS_SINGLE_LIMIT\n+\t\t\t    : CIF_MAX_INLINE_INSNS_AUTO_LIMIT);\n+      else\n+\te->inline_failed = (DECL_DECLARED_INLINE_P (callee->decl)\n+\t\t\t    ? CIF_MAX_INLINE_INSNS_SINGLE_O2_LIMIT\n+\t\t\t    : CIF_MAX_INLINE_INSNS_AUTO_O2_LIMIT);\n       want_inline = false;\n     }\n   else\n@@ -808,28 +844,31 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       /* Apply MAX_INLINE_INSNS_SINGLE limit.  Do not do so when\n \t hints suggests that inlining given function is very profitable.  */\n       else if (DECL_DECLARED_INLINE_P (callee->decl)\n-\t       && growth >= MAX_INLINE_INSNS_SINGLE\n-\t       && (growth >= MAX_INLINE_INSNS_SINGLE * 16\n+\t       && growth >= inline_insns_single (e->caller)\n+\t       && (growth >= inline_insns_single (e->caller) * 16\n \t\t   || (!(hints & (INLINE_HINT_indirect_call\n \t\t\t\t  | INLINE_HINT_known_hot\n \t\t\t\t  | INLINE_HINT_loop_iterations\n \t\t\t\t  | INLINE_HINT_loop_stride))\n \t\t       && !(big_speedup = big_speedup_p (e)))))\n \t{\n-\t  e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n+\t  if (opt_for_fn (e->caller->decl, optimize) >= 3)\n+            e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n+\t  else\n+            e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_O2_LIMIT;\n \t  want_inline = false;\n \t}\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !opt_for_fn (e->caller->decl, flag_inline_functions)\n \t       && growth >= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SMALL))\n \t{\n \t  /* growth_likely_positive is expensive, always test it last.  */\n-\t  if (growth >= MAX_INLINE_INSNS_SINGLE\n+          if (growth >= inline_insns_single (e->caller)\n \t      || growth_likely_positive (callee, growth))\n \t    {\n-\t      e->inline_failed = CIF_NOT_DECLARED_INLINED;\n+              e->inline_failed = CIF_NOT_DECLARED_INLINED;\n \t      want_inline = false;\n-\t    }\n+ \t    }\n \t}\n       /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline\n \t Upgrade it to MAX_INLINE_INSNS_SINGLE when hints suggests that\n@@ -839,28 +878,28 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t       && growth >= ((hints & (INLINE_HINT_indirect_call\n \t\t\t\t       | INLINE_HINT_loop_iterations\n \t\t\t\t       | INLINE_HINT_loop_stride))\n-\t\t\t     ? MAX (MAX_INLINE_INSNS_AUTO,\n-\t\t\t\t    MAX_INLINE_INSNS_SINGLE)\n-\t\t\t     : MAX_INLINE_INSNS_AUTO)\n+\t\t\t     ? MAX (inline_insns_auto (e->caller),\n+\t\t\t\t    inline_insns_single (e->caller))\n+\t\t\t     : inline_insns_auto (e->caller))\n \t       && !(big_speedup == -1 ? big_speedup_p (e) : big_speedup))\n \t{\n \t  /* growth_likely_positive is expensive, always test it last.  */\n-\t  if (growth >= MAX_INLINE_INSNS_SINGLE\n+          if (growth >= inline_insns_single (e->caller)\n \t      || growth_likely_positive (callee, growth))\n \t    {\n-\t      e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+\t      if (opt_for_fn (e->caller->decl, optimize) >= 3)\n+\t\te->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n+\t      else\n+\t\te->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_O2_LIMIT;\n \t      want_inline = false;\n-\t    }\n+ \t    }\n \t}\n       /* If call is cold, do not inline when function body would grow. */\n       else if (!e->maybe_hot_p ()\n-\t       && (growth >= MAX_INLINE_INSNS_SINGLE\n+\t       && (growth >= inline_insns_single (e->caller)\n \t\t   || growth_likely_positive (callee, growth)))\n \t{\n-\t  if (e->count.ipa () == profile_count::zero ())\n-\t    e->inline_failed = CIF_NEVER_CALL;\n-\t  else\n-\t    e->inline_failed = CIF_UNLIKELY_CALL;\n+          e->inline_failed = CIF_UNLIKELY_CALL;\n \t  want_inline = false;\n \t}\n     }\n@@ -1166,7 +1205,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t      && caller_info->inlinable\n \t      && caller_info->size\n \t\t < (DECL_DECLARED_INLINE_P (caller->decl)\n-\t\t    ? MAX_INLINE_INSNS_SINGLE : MAX_INLINE_INSNS_AUTO))\n+\t\t    ? inline_insns_single (caller) : inline_insns_auto (caller)))\n \t    {\n \t      if (dump)\n \t\tfprintf (dump_file,"}, {"sha": "2df03519192da3db0223d422aab7f2dbc3f77411", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -527,6 +527,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_ftree_vrp, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_CHEAP },\n+    { OPT_LEVELS_2_PLUS, OPT_finline_functions, NULL, 1 },\n \n     /* -O2 and -Os optimizations.  */\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_falign_functions, NULL, 1 },\n@@ -542,9 +543,6 @@ static const struct default_options default_options_table[] =\n #endif\n \n     /* -O3 and -Os optimizations.  */\n-    /* Inlining of functions reducing size is a good idea with -Os\n-       regardless of them being declared inline.  */\n-    { OPT_LEVELS_3_PLUS_AND_SIZE, OPT_finline_functions, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_fgcse_after_reload, NULL, 1 },"}, {"sha": "80f73b8df7cd71e4a2f6baa2348d70892758686a", "filename": "gcc/params.def", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -51,8 +51,13 @@ DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,\n \n DEFPARAM (PARAM_INLINE_MIN_SPEEDUP,\n \t  \"inline-min-speedup\",\n+\t  \"The minimal estimated speedup allowing inliner to ignore inline-insns-single and inline-insns-auto with -O3 and -Ofast.\",\n+\t  15, 0, 100)\n+\n+DEFPARAM (PARAM_INLINE_MIN_SPEEDUP_O2,\n+\t  \"inline-min-speedup-O2\",\n \t  \"The minimal estimated speedup allowing inliner to ignore inline-insns-single and inline-insns-auto.\",\n-\t  15, 0, 0)\n+\t  30, 0, 100)\n \n /* The single function inlining limit. This is the maximum size\n    of a function counted in internal gcc instructions (not in\n@@ -67,9 +72,14 @@ DEFPARAM (PARAM_INLINE_MIN_SPEEDUP,\n    gets decreased.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n \t  \"max-inline-insns-single\",\n-\t  \"The maximum number of instructions in a single function eligible for inlining.\",\n+\t  \"The maximum number of instructions in a single function eligible for inlining with -O3 and -Ofast.\",\n \t  200, 0, 0)\n \n+DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE_O2,\n+\t  \"max-inline-insns-single-O2\",\n+\t  \"The maximum number of instructions in a single function eligible for inlining.\",\n+\t  30, 0, 0)\n+\n /* The single function inlining limit for functions that are\n    inlined by virtue of -finline-functions (-O3).\n    This limit should be chosen to be below or equal to the limit\n@@ -79,9 +89,14 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS_SINGLE,\n    The default value is 30.  */\n DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO,\n \t  \"max-inline-insns-auto\",\n-\t  \"The maximum number of instructions when automatically inlining.\",\n+\t  \"The maximum number of instructions when automatically inlining with -O3 and -Ofast.\",\n \t  30, 0, 0)\n \n+DEFPARAM (PARAM_MAX_INLINE_INSNS_AUTO_O2,\n+\t  \"max-inline-insns-auto-O2\",\n+\t  \"The maximum number of instructions when automatically inlining.\",\n+\t  15, 0, 0)\n+\n DEFPARAM (PARAM_MAX_INLINE_INSNS_SMALL,\n \t  \"max-inline-insns-small\",\n \t  \"The maximum number of instructions when automatically inlining small functions.\","}, {"sha": "ab9879f6a18ed1623b217a7ae59fca8a0c980ad0", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr53844.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr53844.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr53844.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr53844.C?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-options \"-O2 -fdump-tree-optimized-vops\" }\n+// { dg-options \"-O2 -fdump-tree-optimized-vops -fno-inline-functions --param max-inline-insns-single-O2=200\" }\n \n struct VBase;\n "}, {"sha": "e9d3c9aab7d928bb6d1a4c146d33c8223f9d5a08", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fbuiltins.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fbuiltins.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fbuiltins.exp?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -37,7 +37,7 @@ load_lib c-torture.exp\n torture-init\n set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS\n \n-set additional_flags \"-fno-tree-dse -fno-tree-loop-distribute-patterns -fno-tracer -fno-ipa-ra\"\n+set additional_flags \"-fno-tree-dse -fno-tree-loop-distribute-patterns -fno-tracer -fno-ipa-ra -fno-inline-functions\"\n if [istarget \"powerpc-*-darwin*\"] {\n    lappend additional_flags \"-Wl,-multiply_defined,suppress\"\n }"}, {"sha": "7c649114151c262ddb8ea0e0e3dc6f70a3a4ddb7", "filename": "gcc/testsuite/gcc.dg/ipa/inline-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-7.c?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -1,6 +1,6 @@\n /* Check that early inliner works out that a is empty of parameter 0.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-einline-optimized -fopt-info-inline -fno-partial-inlining\"  } */\n+/* { dg-options \"-O2 -fdump-tree-einline-optimized -fopt-info-inline -fno-partial-inlining -fno-inline-functions\"  } */\n void t(void);\n int a (int b)\n {"}, {"sha": "b4d8b9a8dd930eb2ce50379bac0df98aa7def7ec", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-5.c?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target bswap } */\n-/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-bswap -fno-inline-functions\" } */\n /* { dg-additional-options \"-march=z900\" { target s390-*-* } } */\n \n struct L { unsigned int l[2]; };"}, {"sha": "fff731e8cfc96ee1bc8373019c063c42c57f0f2a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-thread-12.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-thread-12.c?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread2-details -fdump-tree-thread3-details -fdump-tree-thread4-details -fno-finite-loops\" } */\n+/* { dg-options \"-O2 -fdump-tree-thread2-details -fdump-tree-thread3-details -fdump-tree-thread4-details -fno-finite-loops --param early-inlining-insns-O2=14 -fno-inline-functions\" } */\n /* { dg-final { scan-tree-dump \"FSM\" \"thread2\" } } */\n /* { dg-final { scan-tree-dump \"FSM\" \"thread3\" } } */\n /* { dg-final { scan-tree-dump \"FSM\" \"thread4\" { xfail *-*-* } } } */\n@@ -56,7 +56,7 @@ bmp_iter_and_compl (bitmap_iterator * bi, unsigned *bit_no)\n }\n \n extern int VEC_int_base_length (VEC_int_base *);\n-static __inline__ bitmap\n+bitmap\n compute_idf (bitmap def_blocks, bitmap_head * dfs)\n {\n   bitmap_iterator bi;"}, {"sha": "7043a276025f50e9f40ac40e222614f49084eb9c", "filename": "gcc/testsuite/gcc.dg/winline-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/562d1e9556777988ae46c5d1357af2636bc272ea/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwinline-3.c?ref=562d1e9556777988ae46c5d1357af2636bc272ea", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Winline -O2 --param max-inline-insns-single=1 --param inline-min-speedup=100 -fgnu89-inline\" } */\n+/* { dg-options \"-Winline -O2 --param max-inline-insns-single-O2=1 --param inline-min-speedup-O2=100 -fgnu89-inline\" } */\n \n void big (void);\n inline int q(void) /* { dg-warning \"max-inline-insns-single\" } */"}]}