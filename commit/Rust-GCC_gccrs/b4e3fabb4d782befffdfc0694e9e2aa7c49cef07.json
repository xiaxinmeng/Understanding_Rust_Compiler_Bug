{"sha": "b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlM2ZhYmI0ZDc4MmJlZmZmZGZjMDY5NGU5ZTJhYTdjNDljZWYwNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-06-04T13:21:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-06-04T13:21:38Z"}, "message": "tree.def (ARRAY_RANGE_REF): New code.\n\n\t* tree.def (ARRAY_RANGE_REF): New code.\n\t* alias.c (handled_component_p, can_address_p): Handle it.\n\t* dwarf2out.c (loc_descriptor_from_tree): Likewise.\n\t* explow.c (set_mem_attributes): Likewise.\n\t* expr.c (expand_assignment, get_inner_reference): Likewise.\n\t(expand_expr, expand_expr_unaligned, do_jump): Likewise.\n\t* fold-const.c (operand_equal_p): Likewise.\n\t* tree.c (staticp, stabilize_reference): Likewise.\n\t* varasm.c (decode_addr_const): Likewise.\n\nFrom-SVN: r42848", "tree": {"sha": "e79ce033c0250b6636b696185f9b705119768656", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e79ce033c0250b6636b696185f9b705119768656"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/comments", "author": null, "committer": null, "parents": [{"sha": "c7d468e6983d3562c3641d4a0f35a44c8617ab05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7d468e6983d3562c3641d4a0f35a44c8617ab05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7d468e6983d3562c3641d4a0f35a44c8617ab05"}], "stats": {"total": 97, "additions": 71, "deletions": 26}, "files": [{"sha": "b6889451300001269e3b8896de1597ae8f0f80dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -1,3 +1,15 @@\n+Mon Jun  4 09:21:19 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.def (ARRAY_RANGE_REF): New code.\n+\t* alias.c (handled_component_p, can_address_p): Handle it.\n+\t* dwarf2out.c (loc_descriptor_from_tree): Likewise.\n+\t* explow.c (set_mem_attributes): Likewise.\n+\t* expr.c (expand_assignment, get_inner_reference): Likewise.\n+\t(expand_expr, expand_expr_unaligned, do_jump): Likewise.\n+\t* fold-const.c (operand_equal_p): Likewise.\n+\t* tree.c (staticp, stabilize_reference): Likewise.\n+\t* varasm.c (decode_addr_const): Likewise.\n+\n Sun Jun  3 21:59:51 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* reload.c (reload_inner_reg_of_subreg): Return 1 for PLUS."}, {"sha": "79c0c33c6e30ed72d701b22c98ccf61d9d27ea3e", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -412,6 +412,7 @@ handled_component_p (t)\n     case BIT_FIELD_REF:\n     case COMPONENT_REF:\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n     case NON_LVALUE_EXPR:\n       return 1;\n \n@@ -445,7 +446,7 @@ can_address_p (t)\n \t   && can_address_p (TREE_OPERAND (t, 0)))\n     return 1;\n \n-  else if (TREE_CODE (t) == ARRAY_REF\n+  else if ((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t   && ! TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0)))\n \t   && can_address_p (TREE_OPERAND (t, 0)))\n     return 1;"}, {"sha": "d72ecc2c347c824aa4973ea81efe5d97bdd285c8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -7592,6 +7592,7 @@ loc_descriptor_from_tree (loc, addressp)\n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       {\n \ttree obj, offset;\n \tHOST_WIDE_INT bitsize, bitpos, bytepos;"}, {"sha": "921e5556039e09c87df6be3f560c173d9cbad85b", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for manipulating rtx's in semantically interesting ways.\n    Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -702,6 +702,7 @@ set_mem_attributes (ref, t, objectp)\n   if (DECL_P (t))\n     MEM_SCALAR_P (ref) = 1;\n   else if (TREE_CODE (t) == COMPONENT_REF || TREE_CODE (t) == ARRAY_REF\n+\t   || TREE_CODE (t) == ARRAY_RANGE_REF\n \t   || TREE_CODE (t) == BIT_FIELD_REF)\n     MEM_IN_STRUCT_P (ref) = 1;\n }"}, {"sha": "7fb0654d4959484f94e75a8b76552d1cabbf73ac", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -3675,7 +3675,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n      problem.  */\n \n   if (TREE_CODE (to) == COMPONENT_REF || TREE_CODE (to) == BIT_FIELD_REF\n-      || TREE_CODE (to) == ARRAY_REF)\n+      || TREE_CODE (to) == ARRAY_REF || TREE_CODE (to) == ARRAY_RANGE_REF)\n     {\n       enum machine_mode mode1;\n       HOST_WIDE_INT bitsize, bitpos;\n@@ -5333,8 +5333,8 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n }\n \f\n /* Given an expression EXP that may be a COMPONENT_REF, a BIT_FIELD_REF,\n-   or an ARRAY_REF, look for nested COMPONENT_REFs, BIT_FIELD_REFs, or\n-   ARRAY_REFs and find the ultimate containing object, which we return.\n+   an ARRAY_REF, or an ARRAY_RANGE_REF, look for nested operations of these\n+   codes and find the ultimate containing object, which we return.\n \n    We set *PBITSIZE to the size in bits that we want, *PBITPOS to the\n    bit position, and *PUNSIGNEDP to the signedness of the field.\n@@ -5438,12 +5438,14 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t    alignment = MIN (alignment, DECL_OFFSET_ALIGN (field));\n \t}\n \n-      else if (TREE_CODE (exp) == ARRAY_REF)\n+      else if (TREE_CODE (exp) == ARRAY_REF\n+\t       || TREE_CODE (exp) == ARRAY_RANGE_REF)\n \t{\n \t  tree index = TREE_OPERAND (exp, 1);\n-\t  tree domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (exp, 0)));\n+\t  tree array = TREE_OPERAND (exp, 0);\n+\t  tree domain = TYPE_DOMAIN (TREE_TYPE (array));\n \t  tree low_bound = (domain ? TYPE_MIN_VALUE (domain) : 0);\n-\t  tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (exp));\n+\t  tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (array)));\n \n \t  /* We assume all arrays have sizes that are a multiple of a byte.\n \t     First subtract the lower bound, if any, in the type of the\n@@ -5461,8 +5463,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t    index = build (WITH_RECORD_EXPR, TREE_TYPE (index), index, exp);\n \t  if (! TREE_CONSTANT (unit_size)\n \t      && contains_placeholder_p (unit_size))\n-\t    unit_size = build (WITH_RECORD_EXPR, sizetype, unit_size,\n-\t\t\t       TREE_OPERAND (exp, 0));\n+\t    unit_size = build (WITH_RECORD_EXPR, sizetype, unit_size, array);\n \n \t  offset = size_binop (PLUS_EXPR, offset,\n \t\t\t       size_binop (MULT_EXPR,\n@@ -6117,10 +6118,12 @@ expand_expr (exp, target, tmode, modifier)\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx,\n \t\t\t    VOIDmode, ro_modifier);\n       else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<'\n-\t       || code == ARRAY_REF)\n+\t       || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, ro_modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t       ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode,\n+\t\t       ro_modifier);\n \t  return const0_rtx;\n \t}\n       else if ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n@@ -6131,9 +6134,12 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t    VOIDmode, ro_modifier);\n       else if (code == BIT_FIELD_REF)\n \t{\n-\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, ro_modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode, ro_modifier);\n-\t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode, ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n+\t\t       ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 1), const0_rtx, VOIDmode,\n+\t\t       ro_modifier);\n+\t  expand_expr (TREE_OPERAND (exp, 2), const0_rtx, VOIDmode,\n+\t\t       ro_modifier);\n \t  return const0_rtx;\n \t}\n       ;\n@@ -6150,6 +6156,7 @@ expand_expr (exp, target, tmode, modifier)\n       && TREE_CODE (exp) != INTEGER_CST\n       && TREE_CODE (exp) != PARM_DECL\n       && TREE_CODE (exp) != ARRAY_REF\n+      && TREE_CODE (exp) != ARRAY_RANGE_REF\n       && TREE_CODE (exp) != COMPONENT_REF\n       && TREE_CODE (exp) != BIT_FIELD_REF\n       && TREE_CODE (exp) != INDIRECT_REF\n@@ -6168,6 +6175,7 @@ expand_expr (exp, target, tmode, modifier)\n       && TREE_CODE (exp) != INTEGER_CST\n       && TREE_CODE (exp) != PARM_DECL\n       && TREE_CODE (exp) != ARRAY_REF\n+      && TREE_CODE (exp) != ARRAY_RANGE_REF\n       && TREE_CODE (exp) != COMPONENT_REF\n       && TREE_CODE (exp) != BIT_FIELD_REF\n       && TREE_CODE (exp) != INDIRECT_REF\n@@ -6906,11 +6914,12 @@ expand_expr (exp, target, tmode, modifier)\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n+    case ARRAY_RANGE_REF:\n       /* If the operand is a CONSTRUCTOR, we can just extract the\n \t appropriate field if it is present.  Don't do this if we have\n \t already written the data since we want to refer to that copy\n \t and varasm.c assumes that's what we'll do.  */\n-      if (code != ARRAY_REF\n+      if (code == COMPONENT_REF\n \t  && TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n \t  && TREE_CST_RTL (TREE_OPERAND (exp, 0)) == 0)\n \t{\n@@ -8468,8 +8477,10 @@ expand_expr (exp, target, tmode, modifier)\n \n \ttemp = expand_assignment (lhs, rhs, ! ignore, original_target != 0);\n \tif (TYPE_NONCOPIED_PARTS (lhs_type) != 0 && !fixed_type_p (rhs))\n-\t  noncopied_parts = init_noncopied_parts (stabilize_reference (lhs),\n-\t\t\t\t\t\t  TYPE_NONCOPIED_PARTS (lhs_type));\n+\t  noncopied_parts\n+\t    = init_noncopied_parts (stabilize_reference (lhs),\n+\t\t\t\t    TYPE_NONCOPIED_PARTS (lhs_type));\n+\n \twhile (noncopied_parts != 0)\n \t  {\n \t    expand_assignment (TREE_VALUE (noncopied_parts),\n@@ -8529,8 +8540,9 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (TYPE_NONCOPIED_PARTS (lhs_type) != 0\n \t    && ! (fixed_type_p (lhs) && fixed_type_p (rhs)))\n-\t  noncopied_parts = save_noncopied_parts (stabilize_reference (lhs),\n-\t\t\t\t\t\t  TYPE_NONCOPIED_PARTS (lhs_type));\n+\t  noncopied_parts\n+\t    = save_noncopied_parts (stabilize_reference (lhs),\n+\t\t\t\t    TYPE_NONCOPIED_PARTS (lhs_type));\n \n \ttemp = expand_assignment (lhs, rhs, ! ignore, original_target != 0);\n \twhile (noncopied_parts != 0)\n@@ -8946,11 +8958,12 @@ expand_expr_unaligned (exp, palign)\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n+    case ARRAY_RANGE_REF:\n       /* If the operand is a CONSTRUCTOR, we can just extract the\n \t appropriate field if it is present.  Don't do this if we have\n \t already written the data since we want to refer to that copy\n \t and varasm.c assumes that's what we'll do.  */\n-      if (TREE_CODE (exp) != ARRAY_REF\n+      if (TREE_CODE (exp) == COMPONENT_REF\n \t  && TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n \t  && TREE_CST_RTL (TREE_OPERAND (exp, 0)) == 0)\n \t{\n@@ -9522,7 +9535,8 @@ do_jump (exp, if_false_label, if_true_label)\n     case NOP_EXPR:\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == COMPONENT_REF\n \t  || TREE_CODE (TREE_OPERAND (exp, 0)) == BIT_FIELD_REF\n-\t  || TREE_CODE (TREE_OPERAND (exp, 0)) == ARRAY_REF)\n+\t  || TREE_CODE (TREE_OPERAND (exp, 0)) == ARRAY_REF\n+\t  || TREE_CODE (TREE_OPERAND (exp, 0)) == ARRAY_RANGE_REF)\n \tgoto normal;\n     case CONVERT_EXPR:\n       /* If we are narrowing the operand, we have to do the compare in the\n@@ -9628,6 +9642,7 @@ do_jump (exp, if_false_label, if_true_label)\n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       {\n \tHOST_WIDE_INT bitsize, bitpos;\n \tint unsignedp;"}, {"sha": "eec059e361e95ac6b328697bf6b02e1f302ef191", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -2396,6 +2396,7 @@ operand_equal_p (arg0, arg1, only_const)\n \n \tcase COMPONENT_REF:\n \tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n \t  return (operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t   TREE_OPERAND (arg1, 0), 0)\n \t\t  && operand_equal_p (TREE_OPERAND (arg0, 1),"}, {"sha": "2461c9bd40eae88136921892e66ede6099a4f193", "filename": "gcc/tree.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -1518,6 +1518,7 @@ staticp (arg)\n #endif\n \n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n       if (TREE_CODE (TYPE_SIZE (TREE_TYPE (arg))) == INTEGER_CST\n \t  && TREE_CODE (TREE_OPERAND (arg, 1)) == INTEGER_CST)\n \treturn staticp (TREE_OPERAND (arg, 0));\n@@ -2209,6 +2210,12 @@ stabilize_reference (ref)\n \t\t\t stabilize_reference_1 (TREE_OPERAND (ref, 1)));\n       break;\n \n+    case ARRAY_RANGE_REF:\n+      result = build_nt (ARRAY_RANGE_REF,\n+\t\t\t stabilize_reference (TREE_OPERAND (ref, 0)),\n+\t\t\t stabilize_reference_1 (TREE_OPERAND (ref, 1)));\n+      break;\n+\n     case COMPOUND_EXPR:\n       /* We cannot wrap the first expression in a SAVE_EXPR, as then\n \t it wouldn't be ignored.  This matters when dealing with"}, {"sha": "fe1fddb7e39f4a576d167ce50df77d1bec553021", "filename": "gcc/tree.def", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -1,6 +1,7 @@\n /* This file contains the definitions and documentation for the\n    tree codes used in the GNU C compiler.\n-   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1993, 1995, 1997, 1998, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -369,10 +370,15 @@ DEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n /* Pascal `^` on a file.  One operand, an expression for the file.  */\n DEFTREECODE (BUFFER_REF, \"buffer_ref\", 'r', 1)\n \n-/* Array indexing in languages other than C.\n+/* Array indexing.\n    Operand 0 is the array; operand 1 is a (single) array index. */\n DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 2)\n \n+/* Likewise, except that the result is a range of the array.  The starting\n+   index of the array is taken from operand 0 and the size of the range\n+   is taken from the type of the expression.  */\n+DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 2)\n+\n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n    Also used for SET_TYPE in Chill (and potentially Pascal)."}, {"sha": "8d7000c9dd94f8b5c8c3f1d4be1808d346223092", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e3fabb4d782befffdfc0694e9e2aa7c49cef07/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b4e3fabb4d782befffdfc0694e9e2aa7c49cef07", "patch": "@@ -2180,7 +2180,8 @@ decode_addr_const (exp, value)\n \t  offset += int_byte_position (TREE_OPERAND (target, 1));\n \t  target = TREE_OPERAND (target, 0);\n \t}\n-      else if (TREE_CODE (target) == ARRAY_REF)\n+      else if (TREE_CODE (target) == ARRAY_REF\n+\t       || TREE_CODE (target) == ARRAY_RANGE_REF)\n \t{\n \t  offset += (tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (target)), 1)\n \t\t     * tree_low_cst (TREE_OPERAND (target, 1), 0));"}]}