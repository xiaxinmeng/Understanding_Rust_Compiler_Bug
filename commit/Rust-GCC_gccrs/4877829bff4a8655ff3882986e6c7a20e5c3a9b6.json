{"sha": "4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg3NzgyOWJmZjRhODY1NWZmMzg4Mjk4NmU2YzdhMjBlNWMzYTliNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-04-28T12:02:37Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-04-28T12:02:37Z"}, "message": "Replace AWK script with the python script.\n\n\t* analyze_brprob: Remove.\n\t* analyze_brprob.py: New file.\n\nFrom-SVN: r235560", "tree": {"sha": "4c5bcc058ce6317bdb4ffeaa1952b629b0a17d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c5bcc058ce6317bdb4ffeaa1952b629b0a17d05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4877829bff4a8655ff3882986e6c7a20e5c3a9b6/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e"}], "stats": {"total": 288, "additions": 141, "deletions": 147}, "files": [{"sha": "7e5ac53039f14cdd3affbaaf9cfd5408ed6419f3", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4877829bff4a8655ff3882986e6c7a20e5c3a9b6/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4877829bff4a8655ff3882986e6c7a20e5c3a9b6/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "patch": "@@ -1,3 +1,8 @@\n+2016-04-28  Martin Liska  <mliska@suse.cz>\n+\n+\t* analyze_brprob: Remove.\n+\t* analyze_brprob.py: New file.\n+\n 2016-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gennews (files): Add files for GCC 6."}, {"sha": "57028346200c8bba45a534d94ccd3e1da0ebb331", "filename": "contrib/analyze_brprob", "status": "removed", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/contrib%2Fanalyze_brprob", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28633bbd10d6d729708c7bf4de2c1aeae3b4e75e/contrib%2Fanalyze_brprob", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fanalyze_brprob?ref=28633bbd10d6d729708c7bf4de2c1aeae3b4e75e", "patch": "@@ -1,147 +0,0 @@\n-#!/usr/bin/awk -f\n-# Script to analyze experimental results of our branch prediction heuristics\n-# Contributed by Jan Hubicka, SuSE Inc.\n-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING.  If not, write to\n-# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-# Boston, MA 02110-1301, USA.\n-#\n-#\n-# This script is used to calculate two basic properties of the branch prediction\n-# heuristics - coverage and hitrate.  Coverage is number of executions of a given\n-# branch matched by the heuristics and hitrate is probability that once branch is\n-# predicted as taken it is really taken.\n-#\n-# These values are useful to determine the quality of given heuristics.  Hitrate\n-# may be directly used in predict.c.\n-#\n-# Usage:\n-#  Step 1: Compile and profile your program.  You need to use -fprofile-arcs\n-#    flag to get the profiles\n-#  Step 2: Generate log files.  The information about given heuristics are\n-#    saved into ipa-profile dumps.  You need to pass the -fdimp-ipa-profile switch\n-#    to the compiler as well\n-#    as -fbranch-probabilities to get the results of profiling noted in the dumps.\n-#    Ensure that there are no \"Arc profiling: some edge counts were bad.\" warnings.\n-#  Step 3: Run this script to concatenate all *.profile files:\n-#    analyze_brprob `find . -name *.profile`\n-#    the information is collected and print once all files are parsed.  This\n-#    may take a while.\n-#    Note that the script does use bc to perform long arithmetic.\n-#  Step 4: Read the results.  Basically the following table is printed:\n-#  (this is just an example from a very early stage of branch prediction pass\n-#   development, so please don't take these numbers seriously)\n-#\n-#HEURISTICS                  BRANCHES  (REL)  HITRATE             COVERAGE  (REL)\n-#opcode                          2889  83.7%  94.96%/ 97.62%      7516383  75.3%\n-#pointer                          246   7.1%  99.69%/ 99.86%       118791   1.2%\n-#loop header                      449  13.0%  98.32%/ 99.07%        43553   0.4%\n-#first match                     3450 100.0%  89.92%/ 97.27%      9979782 100.0%\n-#loop exit                        924  26.8%  88.95%/ 95.58%      9026266  90.4%\n-#error return                     150   4.3%  64.48%/ 86.81%       453542   4.5%\n-#call                             803  23.3%  51.66%/ 98.61%      3614037  36.2%\n-#loop branch                       51   1.5%  99.26%/ 99.27%        26854   0.3%\n-#noreturn call                    951  27.6% 100.00%/100.00%      1759809  17.6%\n-#\n-#  The heuristic called \"first match\" is a heuristic used by GCC branch\n-#  prediction pass and it predicts 89.92% branches correctly.\n-#\n-#  The quality of heuristics can be rated using both, coverage and hitrate\n-#  parameters.  For example \"loop branch\" heuristics (predicting loopback edge\n-#  as taken) have both very high hitrate and coverage, so it is very useful.\n-#  On the other hand, \"exit block\" heuristics (predicting exit edges as not\n-#  taken) have good hitrate, but poor coverage, so only 3 branches have been\n-#  predicted.  The \"loop header\" heuristic has problems, since it tends to\n-#  misspredict.\n-#\n-#  The implementation of this script is somewhat brute force.  My awk skills\n-#  are limited.\n-\n-function longeval(e)\n-{\n-  e = \"echo \\\"scale = 2 ;\"e\"\\\" | bc\"\n-  e | getline res\n-  close (e)\n-  return res\n-}\n-\n-BEGIN {nnames = 0}\n-\n-/^  .* heuristics: .*.$/ {\n-    name=$0\n-    sub (/^  /,\"\",name)\n-    sub (/ heuristics: .*.$/,\"\",name)\n-    if (!(name in branches))\n-      {\n-\tnames[nnames] = name\n-\tbranches[name]=0\n-\tcounts[name]=0\n-\thits[name]=0\n-\tphits[name]=0\n-\tnnames++\n-      }\n-    branches[name]+=1\n-  }\n-\n-/^  .* heuristics: .*. exec [0-9]* hit [0-9]* (.*.)$/ {\n-    name=$0\n-    sub (/^  /,\"\",name)\n-    sub (/ heuristics: .*. exec [0-9]* hit [0-9]* (.*.)$/,\"\",name)\n-    pred=$0\n-    sub (/^  .* heuristics: /,\"\",pred)\n-    sub (/. exec [0-9]* hit [0-9]* (.*.)$/,\"\",pred)\n-    count=$0\n-    sub (/^  .* heuristics: .*. exec /,\"\",count)\n-    sub (/ hit [0-9]* (.*.)$/,\"\",count)\n-    hit=$0\n-    sub (/^  .* heuristics: .*. exec [0-9]* hit /,\"\",hit)\n-    sub (/ (.*.)$/,\"\",hit)\n-\n-    if (int(pred) < 50.0)\n-      {\n-        hit = count\"-\"hit;\n-      }\n-    counts[name]=counts[name] \"+\" count\n-    hits[name]=hits[name] \"+\" hit\n-    phits[name]=phits[name] \"+((\"hit\")<\"count\"/2)*(\"count\"-(\"hit\"))+((\"hit\")>=\"count\"/2)*(\"hit\")\"\n-\n-    #BC crashes on long strings.  Irritating.\n-    if (length(counts[name]) > 2000)\n-      counts[name] = longeval(counts[name])\n-    if (length(hits[name]) > 2000)\n-      hits[name] = longeval(hits[name])\n-    if (length(phits[name]) > 2000)\n-      phits[name] = longeval(phits[name])\n-  }\n-END {\n-  # Heuristics called combined predicts just everything.\n-  maxcounts = longeval(counts[\"combined\"])\n-  maxbranches = branches[\"combined\"]\n-  max = names[\"combined\"]\n-  printf(\"HEURISTICS                 BRANCHES  (REL)  HITRATE              COVERAGE  (REL)\\n\")\n-  for (i = 0; i < nnames ; i++)\n-   {\n-     name = names[i]\n-     counts[name] = longeval(counts[name])\n-     printf (\"%-26s %8i %5.1f%% %6s%% / %6s%% %12s %5.1f%%\\n\",\n-\t     name,\n-\t     branches[name], branches[name] * 100 / maxbranches,\n-\t     longeval(\"(\"hits[name]\") * 100 /(\" counts[name]\"-0.00001)\"),\n-\t     longeval(\"(\"phits[name]\") * 100 /(\" counts[name]\"-0.00001)\"),\n-\t     counts[name], longeval(counts[name]\" * 100 / (\"maxcounts\"-0.00001)\"))\n-   }\n-}"}, {"sha": "36371ff26ff34f436a3a9f0734820579abcfb23d", "filename": "contrib/analyze_brprob.py", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4877829bff4a8655ff3882986e6c7a20e5c3a9b6/contrib%2Fanalyze_brprob.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4877829bff4a8655ff3882986e6c7a20e5c3a9b6/contrib%2Fanalyze_brprob.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fanalyze_brprob.py?ref=4877829bff4a8655ff3882986e6c7a20e5c3a9b6", "patch": "@@ -0,0 +1,136 @@\n+#!/usr/bin/env python3\n+#\n+# Script to analyze results of our branch prediction heuristics\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+#\n+#\n+#\n+# This script is used to calculate two basic properties of the branch prediction\n+# heuristics - coverage and hitrate.  Coverage is number of executions\n+# of a given branch matched by the heuristics and hitrate is probability\n+# that once branch is predicted as taken it is really taken.\n+#\n+# These values are useful to determine the quality of given heuristics.\n+# Hitrate may be directly used in predict.def.\n+#\n+# Usage:\n+#  Step 1: Compile and profile your program.  You need to use -fprofile-generate\n+#    flag to get the profiles.\n+#  Step 2: Make a reference run of the intrumented application.\n+#  Step 3: Compile the program with collected profile and dump IPA profiles\n+#          (-fprofile-use -fdump-ipa-profile-details)\n+#  Step 4: Collect all generated dump files:\n+#          find . -name '*.profile' | xargs cat > dump_file\n+#  Step 5: Run the script:\n+#          ./analyze_brprob.py dump_file\n+#          and read results.  Basically the following table is printed:\n+#\n+# HEURISTICS                           BRANCHES  (REL)  HITRATE                COVERAGE  (REL)\n+# early return (on trees)                     3   0.2%  35.83% /  93.64%          66360   0.0%\n+# guess loop iv compare                       8   0.6%  53.35% /  53.73%       11183344   0.0%\n+# call                                       18   1.4%  31.95% /  69.95%       51880179   0.2%\n+# loop guard                                 23   1.8%  84.13% /  84.85%    13749065956  42.2%\n+# opcode values positive (on trees)          42   3.3%  15.71% /  84.81%     6771097902  20.8%\n+# opcode values nonequal (on trees)         226  17.6%  72.48% /  72.84%      844753864   2.6%\n+# loop exit                                 231  18.0%  86.97% /  86.98%     8952666897  27.5%\n+# loop iterations                           239  18.6%  91.10% /  91.10%     3062707264   9.4%\n+# DS theory                                 281  21.9%  82.08% /  83.39%     7787264075  23.9%\n+# no prediction                             293  22.9%  46.92% /  70.70%     2293267840   7.0%\n+# guessed loop iterations                   313  24.4%  76.41% /  76.41%    10782750177  33.1%\n+# first match                               708  55.2%  82.30% /  82.31%    22489588691  69.0%\n+# combined                                 1282 100.0%  79.76% /  81.75%    32570120606 100.0%\n+#\n+#\n+#  The heuristics called \"first match\" is a heuristics used by GCC branch\n+#  prediction pass and it predicts 55.2% branches correctly. As you can,\n+#  the heuristics has very good covertage (69.05%).  On the other hand,\n+#  \"opcode values nonequal (on trees)\" heuristics has good hirate, but poor\n+#  coverage.\n+\n+import sys\n+import os\n+import re\n+\n+def percentage(a, b):\n+    return 100.0 * a / b\n+\n+class Summary:\n+    def __init__(self, name):\n+        self.name = name\n+        self.branches = 0\n+        self.count = 0\n+        self.hits = 0\n+        self.fits = 0\n+\n+    def count_formatted(self):\n+        v = self.count\n+        for unit in ['','K','M','G','T','P','E','Z']:\n+            if v < 1000:\n+                return \"%3.2f%s\" % (v, unit)\n+            v /= 1000.0\n+        return \"%.1f%s\" % (v, 'Y')\n+\n+class Profile:\n+    def __init__(self, filename):\n+        self.filename = filename\n+        self.heuristics = {}\n+\n+    def add(self, name, prediction, count, hits):\n+        if not name in self.heuristics:\n+            self.heuristics[name] = Summary(name)\n+\n+        s = self.heuristics[name]\n+        s.branches += 1\n+        s.count += count\n+        if prediction < 50:\n+            hits = count - hits\n+        s.hits += hits\n+        s.fits += max(hits, count - hits)\n+\n+    def branches_max(self):\n+        return max([v.branches for k, v in self.heuristics.items()])\n+\n+    def count_max(self):\n+        return max([v.count for k, v in self.heuristics.items()])\n+\n+    def dump(self):\n+        print('%-36s %8s %6s  %-16s %14s %8s %6s' % ('HEURISTICS', 'BRANCHES', '(REL)',\n+              'HITRATE', 'COVERAGE', 'COVERAGE', '(REL)'))\n+        for (k, v) in sorted(self.heuristics.items(), key = lambda x: x[1].branches):\n+            print('%-36s %8i %5.1f%% %6.2f%% / %6.2f%% %14i %8s %5.1f%%' %\n+            (k, v.branches, percentage(v.branches, self.branches_max ()),\n+             percentage(v.hits, v.count), percentage(v.fits, v.count),\n+             v.count, v.count_formatted(), percentage(v.count, self.count_max()) ))\n+\n+if len(sys.argv) != 2:\n+    print('Usage: ./analyze_brprob.py dump_file')\n+    exit(1)\n+\n+profile = Profile(sys.argv[1])\n+r = re.compile('  (.*) heuristics: (.*)%.*exec ([0-9]*) hit ([0-9]*)')\n+for l in open(profile.filename).readlines():\n+    m = r.match(l)\n+    if m != None:\n+        name = m.group(1)\n+        prediction = float(m.group(2))\n+        count = int(m.group(3))\n+        hits = int(m.group(4))\n+\n+        profile.add(name, prediction, count, hits)\n+\n+profile.dump()"}]}