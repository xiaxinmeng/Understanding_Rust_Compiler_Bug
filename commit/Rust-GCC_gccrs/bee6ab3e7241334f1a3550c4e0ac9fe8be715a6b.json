{"sha": "bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVlNmFiM2U3MjQxMzM0ZjFhMzU1MGM0ZTBhYzlmZThiZTcxNWE2Yg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2003-12-03T18:36:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2003-12-03T18:36:50Z"}, "message": "floatformat.c: Include \"config.h\" and <string.h> if available.\n\n\t* floatformat.c: Include \"config.h\" and <string.h> if available.\n\t(INFINITY, NAN): Define if not defined by <math.h>.\n\t(floatformat_to_double): Handle NaN, infinity, and denormalized\n\tnumbers.\n\t(floatformat_from_double): Likewise.\n\t(ieee_test): In debugging code, use little endian rather than big\n\tendian.  Correct tests to handle NaN and to check correct sign of\n\tzero.  Omit m68k extended test.\n\t(main): Add more debugging cases.\n\nFrom-SVN: r74237", "tree": {"sha": "8f6c7e7a2c51b2e3cd76478d7092e59558dfd1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f6c7e7a2c51b2e3cd76478d7092e59558dfd1fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b/comments", "author": null, "committer": null, "parents": [{"sha": "34cf946f15680f2f9b7f8ef5102aae19f35a8799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34cf946f15680f2f9b7f8ef5102aae19f35a8799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34cf946f15680f2f9b7f8ef5102aae19f35a8799"}], "stats": {"total": 195, "additions": 157, "deletions": 38}, "files": [{"sha": "e3ac9a1fc83806621891a27c539e2c2963458a9f", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b", "patch": "@@ -1,3 +1,15 @@\n+2003-12-03  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* floatformat.c: Include \"config.h\" and <string.h> if available.\n+\t(INFINITY, NAN): Define if not defined by <math.h>.\n+\t(floatformat_to_double): Handle NaN, infinity, and denormalized\n+\tnumbers.\n+\t(floatformat_from_double): Likewise.\n+\t(ieee_test): In debugging code, use little endian rather than big\n+\tendian.  Correct tests to handle NaN and to check correct sign of\n+\tzero.  Omit m68k extended test.\n+\t(main): Add more debugging cases.\n+\n 2003-11-29  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* cp-demangle.c (d_demangle): Only return success if we consumed"}, {"sha": "a0f65354e4827b09f9a16e4d3f41994d4ea8f0c4", "filename": "libiberty/floatformat.c", "status": "modified", "additions": 145, "deletions": 38, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b/libiberty%2Ffloatformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b/libiberty%2Ffloatformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffloatformat.c?ref=bee6ab3e7241334f1a3550c4e0ac9fe8be715a6b", "patch": "@@ -17,16 +17,33 @@ You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n+/* This is needed to pick up the NAN macro on some systems.  */\n+#define _GNU_SOURCE\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+#include <math.h>\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n #include \"ansidecl.h\"\n+#include \"libiberty.h\"\n #include \"floatformat.h\"\n-#include <math.h>\t\t/* ldexp */\n-#ifdef ANSI_PROTOTYPES\n-#include <stddef.h>\n-extern void *memcpy (void *s1, const void *s2, size_t n);\n-extern void *memset (void *s, int c, size_t n);\n+\n+#ifndef INFINITY\n+#ifdef HUGE_VAL\n+#define INFINITY HUGE_VAL\n #else\n-extern char *memcpy ();\n-extern char *memset ();\n+#define INFINITY (1.0 / 0.0)\n+#endif\n+#endif\n+\n+#ifndef NAN\n+#define NAN (0.0 / 0.0)\n #endif\n \n static unsigned long get_field PARAMS ((const unsigned char *,\n@@ -271,9 +288,45 @@ floatformat_to_double (fmt, from, to)\n \n   exponent = get_field (ufrom, fmt->byteorder, fmt->totalsize,\n \t\t\tfmt->exp_start, fmt->exp_len);\n-  /* Note that if exponent indicates a NaN, we can't really do anything useful\n-     (not knowing if the host has NaN's, or how to build one).  So it will\n-     end up as an infinity or something close; that is OK.  */\n+\n+  /* If the exponent indicates a NaN, we don't have information to\n+     decide what to do.  So we handle it like IEEE, except that we\n+     don't try to preserve the type of NaN.  FIXME.  */\n+  if ((unsigned long) exponent == fmt->exp_nan)\n+    {\n+      int nan;\n+\n+      mant_off = fmt->man_start;\n+      mant_bits_left = fmt->man_len;\n+      nan = 0;\n+      while (mant_bits_left > 0)\n+\t{\n+\t  mant_bits = min (mant_bits_left, 32);\n+\n+\t  if (get_field (ufrom, fmt->byteorder, fmt->totalsize,\n+\t\t\t mant_off, mant_bits) != 0)\n+\t    {\n+\t      /* This is a NaN.  */\n+\t      nan = 1;\n+\t      break;\n+\t    }\n+\n+\t  mant_off += mant_bits;\n+\t  mant_bits_left -= mant_bits;\n+\t}\n+\n+      if (nan)\n+\tdto = NAN;\n+      else\n+\tdto = INFINITY;\n+\n+      if (get_field (ufrom, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1))\n+\tdto = -dto;\n+\n+      *to = dto;\n+\n+      return;\n+    }\n \n   mant_bits_left = fmt->man_len;\n   mant_off = fmt->man_start;\n@@ -306,8 +359,18 @@ floatformat_to_double (fmt, from, to)\n       mant = get_field (ufrom, fmt->byteorder, fmt->totalsize,\n \t\t\t mant_off, mant_bits);\n \n-      dto += ldexp ((double)mant, exponent - mant_bits);\n-      exponent -= mant_bits;\n+      /* Handle denormalized numbers.  FIXME: What should we do for\n+\t non-IEEE formats?  */\n+      if (exponent == 0 && mant != 0)\n+\tdto += ldexp ((double)mant,\n+\t\t      (- fmt->exp_bias\n+\t\t       - mant_bits\n+\t\t       - (mant_off - fmt->man_start)\n+\t\t       + 1));\n+      else\n+\tdto += ldexp ((double)mant, exponent - mant_bits);\n+      if (exponent != 0)\n+\texponent -= mant_bits;\n       mant_off += mant_bits;\n       mant_bits_left -= mant_bits;\n     }\n@@ -392,33 +455,54 @@ floatformat_from_double (fmt, from, to)\n   int mant_bits_left;\n   unsigned char *uto = (unsigned char *)to;\n \n-  memcpy (&dfrom, from, sizeof (dfrom));\n+  dfrom = *from;\n   memset (uto, 0, fmt->totalsize / FLOATFORMAT_CHAR_BIT);\n+\n+  /* If negative, set the sign bit.  */\n+  if (dfrom < 0)\n+    {\n+      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1, 1);\n+      dfrom = -dfrom;\n+    }\n+\n   if (dfrom == 0)\n-    return;\t\t\t/* Result is zero */\n+    {\n+      /* 0.0.  */\n+      return;\n+    }\n+\n   if (dfrom != dfrom)\n     {\n-      /* From is NaN */\n+      /* NaN.  */\n       put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,\n \t\t fmt->exp_len, fmt->exp_nan);\n-      /* Be sure it's not infinity, but NaN value is irrel */\n+      /* Be sure it's not infinity, but NaN value is irrelevant.  */\n       put_field (uto, fmt->byteorder, fmt->totalsize, fmt->man_start,\n \t\t 32, 1);\n       return;\n     }\n \n-  /* If negative, set the sign bit.  */\n-  if (dfrom < 0)\n+  if (dfrom + dfrom == dfrom)\n     {\n-      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->sign_start, 1, 1);\n-      dfrom = -dfrom;\n+      /* This can only happen for an infinite value (or zero, which we\n+\t already handled above).  */\n+      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,\n+\t\t fmt->exp_len, fmt->exp_nan);\n+      return;\n     }\n \n-  /* How to tell an infinity from an ordinary number?  FIXME-someday */\n-\n   mant = frexp (dfrom, &exponent);\n-  put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start, fmt->exp_len,\n-\t     exponent + fmt->exp_bias - 1);\n+  if (exponent + fmt->exp_bias - 1 > 0)\n+    put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,\n+\t       fmt->exp_len, exponent + fmt->exp_bias - 1);\n+  else\n+    {\n+      /* Handle a denormalized number.  FIXME: What should we do for\n+\t non-IEEE formats?  */\n+      put_field (uto, fmt->byteorder, fmt->totalsize, fmt->exp_start,\n+\t\t fmt->exp_len, 0);\n+      mant = ldexp (mant, exponent + fmt->exp_bias - 1);\n+    }\n \n   mant_bits_left = fmt->man_len;\n   mant_off = fmt->man_start;\n@@ -431,12 +515,11 @@ floatformat_from_double (fmt, from, to)\n       mant_long = (unsigned long)mant;\n       mant -= mant_long;\n \n-      /* If the integer bit is implicit, then we need to discard it.\n-\t If we are discarding a zero, we should be (but are not) creating\n-\t a denormalized\tnumber which means adjusting the exponent\n-\t (I think).  */\n+      /* If the integer bit is implicit, and we are not creating a\n+\t denormalized number, then we need to discard it.  */\n       if ((unsigned int) mant_bits_left == fmt->man_len\n-\t  && fmt->intbit == floatformat_intbit_no)\n+\t  && fmt->intbit == floatformat_intbit_no\n+\t  && exponent + fmt->exp_bias - 1 > 0)\n \t{\n \t  mant_long &= 0x7fffffff;\n \t  mant_bits -= 1;\n@@ -468,26 +551,40 @@ floatformat_is_valid (fmt, from)\n \n #ifdef IEEE_DEBUG\n \n+#include <stdio.h>\n+\n /* This is to be run on a host which uses IEEE floating point.  */\n \n void\n ieee_test (n)\n      double n;\n {\n   double result;\n-  char exten[16];\n \n-  floatformat_to_double (&floatformat_ieee_double_big, &n, &result);\n-  if (n != result)\n+  floatformat_to_double (&floatformat_ieee_double_little, (char *) &n,\n+\t\t\t &result);\n+  if ((n != result && (! isnan (n) || ! isnan (result)))\n+      || (n < 0 && result >= 0)\n+      || (n >= 0 && result < 0))\n     printf (\"Differ(to): %.20g -> %.20g\\n\", n, result);\n-  floatformat_from_double (&floatformat_ieee_double_big, &n, &result);\n-  if (n != result)\n+\n+  floatformat_from_double (&floatformat_ieee_double_little, &n,\n+\t\t\t   (char *) &result);\n+  if ((n != result && (! isnan (n) || ! isnan (result)))\n+      || (n < 0 && result >= 0)\n+      || (n >= 0 && result < 0))\n     printf (\"Differ(from): %.20g -> %.20g\\n\", n, result);\n \n-  floatformat_from_double (&floatformat_m68881_ext, &n, exten);\n-  floatformat_to_double (&floatformat_m68881_ext, exten, &result);\n-  if (n != result)\n-    printf (\"Differ(to+from): %.20g -> %.20g\\n\", n, result);\n+#if 0\n+  {\n+    char exten[16];\n+\n+    floatformat_from_double (&floatformat_m68881_ext, &n, exten);\n+    floatformat_to_double (&floatformat_m68881_ext, exten, &result);\n+    if (n != result)\n+      printf (\"Differ(to+from): %.20g -> %.20g\\n\", n, result);\n+  }\n+#endif\n \n #if IEEE_DEBUG > 1\n   /* This is to be run on a host which uses 68881 format.  */\n@@ -502,12 +599,22 @@ ieee_test (n)\n int\n main ()\n {\n+  ieee_test (0.0);\n   ieee_test (0.5);\n   ieee_test (256.0);\n   ieee_test (0.12345);\n   ieee_test (234235.78907234);\n   ieee_test (-512.0);\n   ieee_test (-0.004321);\n+  ieee_test (1.2E-70);\n+  ieee_test (1.2E-316);\n+  ieee_test (4.9406564584124654E-324);\n+  ieee_test (- 4.9406564584124654E-324);\n+  ieee_test (- 0.0);\n+  ieee_test (- INFINITY);\n+  ieee_test (- NAN);\n+  ieee_test (INFINITY);\n+  ieee_test (NAN);\n   return 0;\n }\n #endif"}]}