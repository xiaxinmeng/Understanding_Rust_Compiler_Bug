{"sha": "0443f602bc9f5711c31e45a995ceaf6828d08283", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ0M2Y2MDJiYzlmNTcxMWMzMWU0NWE5OTVjZWFmNjgyOGQwODI4Mw==", "commit": {"author": {"name": "Jeffrey Oldham", "email": "oldham@codesourcery.com", "date": "2001-02-21T16:11:59Z"}, "committer": {"name": "Jeffrey D. Oldham", "email": "oldham@gcc.gnu.org", "date": "2001-02-21T16:11:59Z"}, "message": "Makefile.in (reorg.o): Add params.h dependence.\n\n2001-02-21  Jeffrey Oldham  <oldham@codesourcery.com>\n\n\t* Makefile.in (reorg.o): Add params.h dependence.\n\t* params.def: Fix typographical error in comment.\n\t(MAX_DELAY_SLOT_INSN_SEARCH): New parameter.\n\t* params.h: Modify introductory comment.\n\t(MAX_DELAY_SLOT_INSN_SEARCH): New parameter.\n\t* reorg.c: Add dependence on params.h.\n\t(redundant_insn): Add parameterized throttle for search.\n\t(fill_simple_delay_slots): Add a comment explaining a variable.\n\tMove conditional out of loop, simplifying code.\n\t(fill_eager_delay_slots): Fix typographical error in comment.\n\nFrom-SVN: r39948", "tree": {"sha": "4a642b8fbfaab6d7d53f3f8917b92e5cbc52db22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a642b8fbfaab6d7d53f3f8917b92e5cbc52db22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0443f602bc9f5711c31e45a995ceaf6828d08283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0443f602bc9f5711c31e45a995ceaf6828d08283", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0443f602bc9f5711c31e45a995ceaf6828d08283", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0443f602bc9f5711c31e45a995ceaf6828d08283/comments", "author": null, "committer": null, "parents": [{"sha": "7e6d8ba1842561ee144669cc97fad0fcbda65ae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e6d8ba1842561ee144669cc97fad0fcbda65ae6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e6d8ba1842561ee144669cc97fad0fcbda65ae6"}], "stats": {"total": 182, "additions": 100, "deletions": 82}, "files": [{"sha": "9461dcaa14dbc38c1d8d9042037cfac741a9ed7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0443f602bc9f5711c31e45a995ceaf6828d08283", "patch": "@@ -1,3 +1,16 @@\n+2001-02-21  Jeffrey Oldham  <oldham@codesourcery.com>\n+\n+\t* Makefile.in (reorg.o): Add params.h dependence.\n+\t* params.def: Fix typographical error in comment.\n+\t(MAX_DELAY_SLOT_INSN_SEARCH): New parameter.\n+\t* params.h: Modify introductory comment.\n+\t(MAX_DELAY_SLOT_INSN_SEARCH): New parameter.\n+\t* reorg.c: Add dependence on params.h.\n+\t(redundant_insn): Add parameterized throttle for search.\n+\t(fill_simple_delay_slots): Add a comment explaining a variable.\n+\tMove conditional out of loop, simplifying code.\n+\t(fill_eager_delay_slots): Fix typographical error in comment.\n+\n 2001-02-20  Aldy Hernandez  <aldyh@redhat.com>\n \n         * tm.texi (REVERSE_CONDEXEC_PREDICATES_P): New macro documentation."}, {"sha": "ba4187574e680f3b78393ad709b3cfb333980a47", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0443f602bc9f5711c31e45a995ceaf6828d08283", "patch": "@@ -1481,7 +1481,7 @@ caller-save.o : caller-save.c $(CONFIG_H) system.h $(RTL_H) flags.h \\\n    $(RECOG_H) reload.h $(EXPR_H) toplev.h\n reorg.o : reorg.c $(CONFIG_H) system.h $(RTL_H) conditions.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) insn-config.h $(INSN_ATTR_H) insn-flags.h \\\n-   $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h\n+   $(RECOG_H) function.h flags.h output.h $(EXPR_H) toplev.h params.h\n alias.o : alias.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) toplev.h output.h $(EXPR_H) insn-flags.h \\\n    $(GGC_H) function.h cselib.h $(TREE_H)"}, {"sha": "61c3600d9022784277e0db018420fac55a6470bd", "filename": "gcc/params.def", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=0443f602bc9f5711c31e45a995ceaf6828d08283", "patch": "@@ -24,7 +24,7 @@ Boston, MA 02111-1307, USA.\n /* This file contains definitions for language-independent\n    parameters.  The DEFPARAM macro takes 4 arguments:\n \n-     - The enumeral corresonding to this parameter.\n+     - The enumeral corresponding to this parameter.\n \n      - The name that can be used to set this parameter using the \n        command-line option `--param <name>=<value>'.\n@@ -44,6 +44,17 @@ DEFPARAM (PARAM_MAX_INLINE_INSNS,\n \t  \"The maximum number of instructions in a function that is eligible for inlining\",\n \t  10000)\n \n+/* The maximum number of instructions to consider when looking for an\n+   instruction to fill a delay slot.  If more than this arbitrary\n+   number of instructions is searched, the time savings from filling\n+   the delay slot will be minimal so stop searching.  Increasing\n+   values mean more aggressive optimization, making the compile time\n+   increase with probably small improvement in executable run time.  */\n+DEFPARAM (PARAM_MAX_DELAY_SLOT_INSN_SEARCH,\n+\t  \"max-delay-slot-insn-search\",\n+\t  \"The maximum number of instructions to consider to fill a delay slot\",\n+\t  100)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "b60d29db3499f3948813a0f8dc36d259a54d5020", "filename": "gcc/params.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=0443f602bc9f5711c31e45a995ceaf6828d08283", "patch": "@@ -27,7 +27,10 @@ Boston, MA 02111-1307, USA.\n    place.  The values of the parameters can be set on the\n    command-line, thereby providing a way to control the amount of\n    effort spent on particular optimization passes, or otherwise tune\n-   the behavior of the compiler.  */\n+   the behavior of the compiler.\n+\n+   Since their values can be set on the command-line, these parameters\n+   should not be used for non-dynamic memory allocation.  */\n \n #ifndef PARAMS_H\n #define PARAMS_H\n@@ -81,5 +84,7 @@ typedef enum compiler_param\n /* Macros for the various parameters.  */\n #define MAX_INLINE_INSNS \\\n   PARAM_VALUE (PARAM_MAX_INLINE_INSNS)\n+#define MAX_DELAY_SLOT_INSN_SEARCH \\\n+  PARAM_VALUE (PARAM_MAX_DELAY_SLOT_INSN_SEARCH)\n \n #endif /* PARAMS_H */"}, {"sha": "142ecdf6767fc3dfc38c4fc7e267e128c95d01b8", "filename": "gcc/reorg.c", "status": "modified", "additions": 68, "deletions": 79, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0443f602bc9f5711c31e45a995ceaf6828d08283/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0443f602bc9f5711c31e45a995ceaf6828d08283", "patch": "@@ -139,6 +139,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"insn-attr.h\"\n #include \"resource.h\"\n+#include \"params.h\"\n \n #ifdef DELAY_SLOTS\n \n@@ -1635,14 +1636,18 @@ redundant_insn (insn, target, delay_list)\n   rtx trial, pat;\n   struct resources needed, set;\n   int i;\n+  unsigned insns_to_search;\n \n   /* If INSN has any REG_UNUSED notes, it can't match anything since we\n      are allowed to not actually assign to such a register.  */\n   if (find_reg_note (insn, REG_UNUSED, NULL_RTX) != 0)\n     return 0;\n \n   /* Scan backwards looking for a match.  */\n-  for (trial = PREV_INSN (target); trial; trial = PREV_INSN (trial))\n+  for (trial = PREV_INSN (target),\n+\t insns_to_search = MAX_DELAY_SLOT_INSN_SEARCH;\n+       trial && insns_to_search > 0;\n+       trial = PREV_INSN (trial), --insns_to_search)\n     {\n       if (GET_CODE (trial) == CODE_LABEL)\n \treturn 0;\n@@ -1743,9 +1748,10 @@ redundant_insn (insn, target, delay_list)\n   /* Scan backwards until we reach a label or an insn that uses something\n      INSN sets or sets something insn uses or sets.  */\n \n-  for (trial = PREV_INSN (target);\n-       trial && GET_CODE (trial) != CODE_LABEL;\n-       trial = PREV_INSN (trial))\n+  for (trial = PREV_INSN (target),\n+\t insns_to_search = MAX_DELAY_SLOT_INSN_SEARCH;\n+       trial && GET_CODE (trial) != CODE_LABEL && insns_to_search > 0;\n+       trial = PREV_INSN (trial), --insns_to_search)\n     {\n       if (GET_CODE (trial) != INSN && GET_CODE (trial) != CALL_INSN\n \t  && GET_CODE (trial) != JUMP_INSN)\n@@ -2223,9 +2229,11 @@ fill_simple_delay_slots (non_jumps_p)\n \t\t  && ! simplejump_p (insn)\n \t\t  && JUMP_LABEL (insn) != 0)))\n \t{\n+\t  /* Invariant: If insn is a JUMP_INSN, the insn's jump\n+\t     label.  Otherwise, zero.  */\n \t  rtx target = 0;\n \t  int maybe_never = 0;\n-\t  struct resources needed_at_jump;\n+\t  rtx pat, trial_delay;\n \n \t  CLEAR_RESOURCE (&needed);\n \t  CLEAR_RESOURCE (&set);\n@@ -2244,92 +2252,73 @@ fill_simple_delay_slots (non_jumps_p)\n \t\ttarget = JUMP_LABEL (insn);\n \t    }\n \n-\t  for (trial = next_nonnote_insn (insn); trial; trial = next_trial)\n-\t    {\n-\t      rtx pat, trial_delay;\n-\n-\t      next_trial = next_nonnote_insn (trial);\n-\n-\t      if (GET_CODE (trial) == CODE_LABEL\n-\t\t  || GET_CODE (trial) == BARRIER)\n-\t\tbreak;\n+\t  if (target == 0)\n+\t    for (trial = next_nonnote_insn (insn); trial; trial = next_trial)\n+\t      {\n+\t\tnext_trial = next_nonnote_insn (trial);\n \n-\t      /* We must have an INSN, JUMP_INSN, or CALL_INSN.  */\n-\t      pat = PATTERN (trial);\n+\t\tif (GET_CODE (trial) == CODE_LABEL\n+\t\t    || GET_CODE (trial) == BARRIER)\n+\t\t  break;\n \n-\t      /* Stand-alone USE and CLOBBER are just for flow.  */\n-\t      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n-\t\tcontinue;\n+\t\t/* We must have an INSN, JUMP_INSN, or CALL_INSN.  */\n+\t\tpat = PATTERN (trial);\n \n-\t      /* If this already has filled delay slots, get the insn needing\n-\t\t the delay slots.  */\n-\t      if (GET_CODE (pat) == SEQUENCE)\n-\t\ttrial_delay = XVECEXP (pat, 0, 0);\n-\t      else\n-\t\ttrial_delay = trial;\n-\n-\t      /* If this is a jump insn to our target, indicate that we have\n-\t\t seen another jump to it.  If we aren't handling a conditional\n-\t\t jump, stop our search. Otherwise, compute the needs at its\n-\t\t target and add them to NEEDED.  */\n-\t      if (GET_CODE (trial_delay) == JUMP_INSN)\n-\t\t{\n-\t\t  if (target == 0)\n-\t\t    break;\n-\t\t  else if (JUMP_LABEL (trial_delay) != target)\n-\t\t    {\n-\t\t      rtx ninsn =\n-\t\t\tnext_active_insn (JUMP_LABEL (trial_delay));\n-\n-\t\t      mark_target_live_regs (get_insns (), ninsn,\n-\t\t\t\t\t     &needed_at_jump);\n-\t\t      needed.memory |= needed_at_jump.memory;\n-\t\t      needed.unch_memory |= needed_at_jump.unch_memory;\n-\t\t      IOR_HARD_REG_SET (needed.regs, needed_at_jump.regs);\n-\t\t    }\n-\t\t}\n+\t\t/* Stand-alone USE and CLOBBER are just for flow.  */\n+\t\tif (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\t\t  continue;\n \n-\t      /* See if we have a resource problem before we try to\n-\t\t split.   */\n-\t      if (target == 0\n-\t\t  && GET_CODE (pat) != SEQUENCE\n-\t\t  && ! insn_references_resource_p (trial, &set, 1)\n-\t\t  && ! insn_sets_resource_p (trial, &set, 1)\n-\t\t  && ! insn_sets_resource_p (trial, &needed, 1)\n+\t\t/* If this already has filled delay slots, get the insn needing\n+\t\t   the delay slots.  */\n+\t\tif (GET_CODE (pat) == SEQUENCE)\n+\t\t  trial_delay = XVECEXP (pat, 0, 0);\n+\t\telse\n+\t\t  trial_delay = trial;\n+\n+\t\t/* Stop our search when seeing an unconditional jump.  */\n+\t\tif (GET_CODE (trial_delay) == JUMP_INSN)\n+\t\t  break;\n+\n+\t\t/* See if we have a resource problem before we try to\n+\t\t   split.   */\n+\t\tif (GET_CODE (pat) != SEQUENCE\n+\t\t    && ! insn_references_resource_p (trial, &set, 1)\n+\t\t    && ! insn_sets_resource_p (trial, &set, 1)\n+\t\t    && ! insn_sets_resource_p (trial, &needed, 1)\n #ifdef HAVE_cc0\n-\t\t  && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n+\t\t    && ! (reg_mentioned_p (cc0_rtx, pat) && ! sets_cc0_p (pat))\n #endif\n-\t\t  && ! (maybe_never && may_trap_p (pat))\n-\t\t  && (trial = try_split (pat, trial, 0))\n-\t\t  && eligible_for_delay (insn, slots_filled, trial, flags))\n-\t\t{\n-\t\t  next_trial = next_nonnote_insn (trial);\n-\t\t  delay_list = add_to_delay_list (trial, delay_list);\n+\t\t    && ! (maybe_never && may_trap_p (pat))\n+\t\t    && (trial = try_split (pat, trial, 0))\n+\t\t    && eligible_for_delay (insn, slots_filled, trial, flags))\n+\t\t  {\n+\t\t    next_trial = next_nonnote_insn (trial);\n+\t\t    delay_list = add_to_delay_list (trial, delay_list);\n \n #ifdef HAVE_cc0\n-\t\t  if (reg_mentioned_p (cc0_rtx, pat))\n-\t\t    link_cc0_insns (trial);\n+\t\t    if (reg_mentioned_p (cc0_rtx, pat))\n+\t\t      link_cc0_insns (trial);\n #endif\n \n-\t\t  delete_insn (trial);\n-\t\t  if (slots_to_fill == ++slots_filled)\n-\t\t    break;\n-\t\t  continue;\n-\t\t}\n+\t\t    delete_insn (trial);\n+\t\t    if (slots_to_fill == ++slots_filled)\n+\t\t      break;\n+\t\t    continue;\n+\t\t  }\n \n-\t      mark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n-\t      mark_referenced_resources (trial, &needed, 1);\n+\t\tmark_set_resources (trial, &set, 0, MARK_SRC_DEST_CALL);\n+\t\tmark_referenced_resources (trial, &needed, 1);\n \n-\t      /* Ensure we don't put insns between the setting of cc and the\n-\t\t comparison by moving a setting of cc into an earlier delay\n-\t\t slot since these insns could clobber the condition code.  */\n-\t      set.cc = 1;\n+\t\t/* Ensure we don't put insns between the setting of cc and the\n+\t\t   comparison by moving a setting of cc into an earlier delay\n+\t\t   slot since these insns could clobber the condition code.  */\n+\t\tset.cc = 1;\n \n-\t      /* If this is a call or jump, we might not get here.  */\n-\t      if (GET_CODE (trial_delay) == CALL_INSN\n-\t\t  || GET_CODE (trial_delay) == JUMP_INSN)\n-\t\tmaybe_never = 1;\n-\t    }\n+\t\t/* If this is a call or jump, we might not get here.  */\n+\t\tif (GET_CODE (trial_delay) == CALL_INSN\n+\t\t    || GET_CODE (trial_delay) == JUMP_INSN)\n+\t\t  maybe_never = 1;\n+\t      }\n \n \t  /* If there are slots left to fill and our search was stopped by an\n \t     unconditional branch, try the insn at the branch target.  We can\n@@ -2982,7 +2971,7 @@ fill_eager_delay_slots ()\n \t}\n \n       /* If this insn is expected to branch, first try to get insns from our\n-\t target, then our fallthrough insns.  If it is not, expected to branch,\n+\t target, then our fallthrough insns.  If it is not expected to branch,\n \t try the other order.  */\n \n       if (prediction > 0)"}]}