{"sha": "4d4eaa77a7d27bf7b220c3be79615410c873fcf1", "node_id": "C_kwDOANBUbNoAKDRkNGVhYTc3YTdkMjdiZjdiMjIwYzNiZTc5NjE1NDEwYzg3M2ZjZjE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-03-21T13:08:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-04-20T11:28:08Z"}, "message": "tree-optimization/104912 - ensure cost model is checked first\n\nThe following makes sure that when we build the versioning condition\nfor vectorization including the cost model check, we check for the\ncost model and branch over other versioning checks.  That is what\nthe cost modeling assumes, since the cost model check is the only\none accounted for in the scalar outside cost.  Currently we emit\nall checks as straight-line code combined with bitwise ops which\ncan result in surprising ordering of checks in the final assembly.\n\nSince loop_version accepts only a single versioning condition\nthe splitting is done after the fact.\n\nThe result is a 1.5% speedup of 416.gamess on x86_64 when compiling\nwith -Ofast and tuning for generic or skylake.  That's not enough\nto recover from the slowdown when vectorizing but it now cuts off\nthe expensive alias versioning test.\n\n2022-03-21  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/104912\n\t* tree-vect-loop-manip.cc (vect_loop_versioning): Split\n\tthe cost model check to a separate BB to make sure it is\n\tchecked first and not combined with other version checks.", "tree": {"sha": "66cc413d550bfbf39a90a5847e885fb77ae5eb8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66cc413d550bfbf39a90a5847e885fb77ae5eb8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d4eaa77a7d27bf7b220c3be79615410c873fcf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4eaa77a7d27bf7b220c3be79615410c873fcf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4eaa77a7d27bf7b220c3be79615410c873fcf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4eaa77a7d27bf7b220c3be79615410c873fcf1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36f1de95a61132f63c0c07ef154abd9f435721ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f1de95a61132f63c0c07ef154abd9f435721ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f1de95a61132f63c0c07ef154abd9f435721ac"}], "stats": {"total": 60, "additions": 57, "deletions": 3}, "files": [{"sha": "e4381eb707934d31fb67e325eb2611cd4ec5a4a7", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d4eaa77a7d27bf7b220c3be79615410c873fcf1/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d4eaa77a7d27bf7b220c3be79615410c873fcf1/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=4d4eaa77a7d27bf7b220c3be79615410c873fcf1", "patch": "@@ -3445,13 +3445,34 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n \tcond_expr = expr;\n     }\n \n+  tree cost_name = NULL_TREE;\n+  profile_probability prob2 = profile_probability::uninitialized ();\n+  if (cond_expr\n+      && !integer_truep (cond_expr)\n+      && (version_niter\n+\t  || version_align\n+\t  || version_alias\n+\t  || version_simd_if_cond))\n+    {\n+      cost_name = cond_expr = force_gimple_operand_1 (unshare_expr (cond_expr),\n+\t\t\t\t\t\t      &cond_expr_stmt_list,\n+\t\t\t\t\t\t      is_gimple_val, NULL_TREE);\n+      /* Split prob () into two so that the overall probability of passing\n+\t both the cost-model and versioning checks is the orig prob.  */\n+      prob2 = prob.split (prob);\n+    }\n+\n   if (version_niter)\n     vect_create_cond_for_niters_checks (loop_vinfo, &cond_expr);\n \n   if (cond_expr)\n-    cond_expr = force_gimple_operand_1 (unshare_expr (cond_expr),\n-\t\t\t\t\t&cond_expr_stmt_list,\n-\t\t\t\t\tis_gimple_condexpr, NULL_TREE);\n+    {\n+      gimple_seq tem = NULL;\n+      cond_expr = force_gimple_operand_1 (unshare_expr (cond_expr),\n+\t\t\t\t\t  &tem,\n+\t\t\t\t\t  is_gimple_condexpr, NULL_TREE);\n+      gimple_seq_add_seq (&cond_expr_stmt_list, tem);\n+    }\n \n   if (version_align)\n     vect_create_cond_for_align_checks (loop_vinfo, &cond_expr,\n@@ -3655,6 +3676,39 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n       update_ssa (TODO_update_ssa);\n     }\n \n+  /* Split the cost model check off to a separate BB.  Costing assumes\n+     this is the only thing we perform when we enter the scalar loop\n+     from a failed cost decision.  */\n+  if (cost_name && TREE_CODE (cost_name) == SSA_NAME)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (cost_name);\n+      /* All uses of the cost check are 'true' after the check we\n+\t are going to insert.  */\n+      replace_uses_by (cost_name, boolean_true_node);\n+      /* And we're going to build the new single use of it.  */\n+      gcond *cond = gimple_build_cond (NE_EXPR, cost_name, boolean_false_node,\n+\t\t\t\t       NULL_TREE, NULL_TREE);\n+      edge e = split_block (gimple_bb (def), def);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (def);\n+      gsi_insert_after (&gsi, cond, GSI_NEW_STMT);\n+      edge true_e, false_e;\n+      extract_true_false_edges_from_block (e->dest, &true_e, &false_e);\n+      e->flags &= ~EDGE_FALLTHRU;\n+      e->flags |= EDGE_TRUE_VALUE;\n+      edge e2 = make_edge (e->src, false_e->dest, EDGE_FALSE_VALUE);\n+      e->probability = prob2;\n+      e2->probability = prob2.invert ();\n+      set_immediate_dominator (CDI_DOMINATORS, false_e->dest, e->src);\n+      auto_vec<basic_block, 3> adj;\n+      for (basic_block son = first_dom_son (CDI_DOMINATORS, e->dest);\n+\t   son;\n+\t   son = next_dom_son (CDI_DOMINATORS, son))\n+\tif (EDGE_COUNT (son->preds) > 1)\n+\t  adj.safe_push (son);\n+      for (auto son : adj)\n+\tset_immediate_dominator (CDI_DOMINATORS, son, e->src);\n+    }\n+\n   if (version_niter)\n     {\n       /* The versioned loop could be infinite, we need to clear existing"}]}