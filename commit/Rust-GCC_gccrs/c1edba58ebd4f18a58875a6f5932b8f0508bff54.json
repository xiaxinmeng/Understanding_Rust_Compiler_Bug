{"sha": "c1edba58ebd4f18a58875a6f5932b8f0508bff54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlZGJhNThlYmQ0ZjE4YTU4ODc1YTZmNTkzMmI4ZjA1MDhiZmY1NA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@loony.cygnus.com", "date": "1999-10-15T08:19:37Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-15T08:19:37Z"}, "message": "cse.c: Include hashtab.h instead of splay-tree.h (struct cse_reg_info): No longer use...\n\n\n        * cse.c: Include hashtab.h instead of splay-tree.h\n        (struct cse_reg_info): No longer use variant union.  Add new\n        field \"regno\".  All references changed to avoid union.\n        (cse_reg_info_used_list, cse_reg_info_used_list_end): New variables.\n        (free_cse_reg_info): Remove.\n        (hash_cse_reg_info, cse_reg_info_equal_p): New functions.\n        (get_cse_reg_info): Revamp to use expandable hash tables instead\n        of splay trees.  Initialize new fields in cse_reg_info structure.\n        (new_basic_block): Similarly.\n\nFrom-SVN: r30014", "tree": {"sha": "51bee7d55051acc91c3a4b78a828bf3d3142a8e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51bee7d55051acc91c3a4b78a828bf3d3142a8e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1edba58ebd4f18a58875a6f5932b8f0508bff54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1edba58ebd4f18a58875a6f5932b8f0508bff54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1edba58ebd4f18a58875a6f5932b8f0508bff54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1edba58ebd4f18a58875a6f5932b8f0508bff54/comments", "author": null, "committer": null, "parents": [{"sha": "a6ee63bb34096d1ec1ef342c8e81a303102c8733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ee63bb34096d1ec1ef342c8e81a303102c8733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ee63bb34096d1ec1ef342c8e81a303102c8733"}], "stats": {"total": 104, "additions": 71, "deletions": 33}, "files": [{"sha": "6ee8c4feaf44e005166f7d998e85b7d917a8d7a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1edba58ebd4f18a58875a6f5932b8f0508bff54/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1edba58ebd4f18a58875a6f5932b8f0508bff54/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c1edba58ebd4f18a58875a6f5932b8f0508bff54", "patch": "@@ -1,3 +1,15 @@\n+Fri Oct 15 01:47:51 1999  Vladimir Makarov  <vmakarov@loony.cygnus.com>\n+\n+\t* cse.c: Include hashtab.h instead of splay-tree.h\n+\t(struct cse_reg_info): No longer use variant union.  Add new\n+\tfield \"regno\".  All references changed to avoid union.\n+\t(cse_reg_info_used_list, cse_reg_info_used_list_end): New variables.\n+\t(free_cse_reg_info): Remove.\n+\t(hash_cse_reg_info, cse_reg_info_equal_p): New functions.\n+\t(get_cse_reg_info): Revamp to use expandable hash tables instead\n+\tof splay trees.  Initialize new fields in cse_reg_info structure.\n+\t(new_basic_block): Similarly.\n+\n Thu Oct 14 23:51:56 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* genrecog.c (message_with_line): Prototype."}, {"sha": "3993f5ea0a3502904ddee38270bd6ae1cb0ad75c", "filename": "gcc/cse.c", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1edba58ebd4f18a58875a6f5932b8f0508bff54/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1edba58ebd4f18a58875a6f5932b8f0508bff54/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c1edba58ebd4f18a58875a6f5932b8f0508bff54", "patch": "@@ -36,7 +36,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n-#include \"splay-tree.h\"\n+#include \"hashtab.h\"\n #include \"ggc.h\"\n \n /* The basic idea of common subexpression elimination is to go\n@@ -292,14 +292,12 @@ static int *reg_next_eqv;\n static int *reg_prev_eqv;\n \n struct cse_reg_info {\n-  union {\n-    /* The number of times the register has been altered in the current\n-       basic block.  */\n-    int reg_tick;\n-    \n-    /* The next cse_reg_info structure in the free list.  */\n-    struct cse_reg_info* next;\n-  } variant;\n+  /* The number of times the register has been altered in the current\n+     basic block.  */\n+  int reg_tick;\n+\n+  /* The next cse_reg_info structure in the free or used list.  */\n+  struct cse_reg_info* next;\n \n   /* The REG_TICK value at which rtx's containing this register are\n      valid in the hash table.  If this does not equal the current\n@@ -309,13 +307,20 @@ struct cse_reg_info {\n \n   /* The quantity number of the register's current contents.  */\n   int reg_qty;\n+\n+  /* Search key */\n+  int regno;\n };\n \n /* A free list of cse_reg_info entries.  */\n static struct cse_reg_info *cse_reg_info_free_list;\n \n+/* A used list of cse_reg_info entries.  */\n+static struct cse_reg_info *cse_reg_info_used_list;\n+static struct cse_reg_info *cse_reg_info_used_list_end;\n+\n /* A mapping from registers to cse_reg_info data structures.  */\n-static splay_tree cse_reg_info_tree;\n+static hash_table_t cse_reg_info_tree;\n \n /* The last lookup we did into the cse_reg_info_tree.  This allows us\n    to cache repeated lookups.  */\n@@ -511,7 +516,7 @@ struct table_elt\n /* Get the number of times this register has been updated in this\n    basic block.  */\n \n-#define REG_TICK(N) ((GET_CSE_REG_INFO (N))->variant.reg_tick)\n+#define REG_TICK(N) ((GET_CSE_REG_INFO (N))->reg_tick)\n \n /* Get the point at which REG was recorded in the table.  */\n \n@@ -697,7 +702,10 @@ static void count_reg_usage\tPROTO((rtx, int *, rtx, int));\n extern void dump_class          PROTO((struct table_elt*));\n static void check_fold_consts\tPROTO((PTR));\n static struct cse_reg_info* get_cse_reg_info PROTO((int));\n-static void free_cse_reg_info   PROTO((splay_tree_value));\n+static unsigned int hash_cse_reg_info PROTO((hash_table_entry_t));\n+static int cse_reg_info_equal_p\tPROTO((hash_table_entry_t,\n+\t\t\t\t       hash_table_entry_t));\n+\n static void flush_hash_table\tPROTO((void));\n \f\n /* Dump the expressions in the equivalence class indicated by CLASSP.\n@@ -845,32 +853,38 @@ get_cse_reg_info (regno)\n      int regno;\n {\n   struct cse_reg_info *cri;\n-  splay_tree_node n;\n+  struct cse_reg_info **entry;\n+  struct cse_reg_info temp;\n \n   /* See if we already have this entry.  */\n-  n = splay_tree_lookup (cse_reg_info_tree, \n-\t\t\t(splay_tree_key) regno);\n-  if (n)\n-    cri = (struct cse_reg_info *) (n->value);\n+  temp.regno = regno;\n+  entry = (struct cse_reg_info **) find_hash_table_entry (cse_reg_info_tree,\n+\t\t\t\t\t\t\t  &temp, TRUE);\n+\n+  if (*entry)\n+    cri = *entry;\n   else \n     {\n       /* Get a new cse_reg_info structure.  */\n       if (cse_reg_info_free_list) \n \t{\n \t  cri = cse_reg_info_free_list;\n-\t  cse_reg_info_free_list = cri->variant.next;\n+\t  cse_reg_info_free_list = cri->next;\n \t}\n       else\n \tcri = (struct cse_reg_info *) xmalloc (sizeof (struct cse_reg_info));\n \n       /* Initialize it.  */\n-      cri->variant.reg_tick = 0;\n+      cri->reg_tick = 0;\n       cri->reg_in_table = -1;\n       cri->reg_qty = regno;\n-\n-      splay_tree_insert (cse_reg_info_tree, \n-\t\t\t (splay_tree_key) regno, \n-\t\t\t (splay_tree_value) cri);\n+      cri->regno = regno;\n+      cri->next = cse_reg_info_used_list;\n+      cse_reg_info_used_list = cri;\n+      if (!cse_reg_info_used_list_end)\n+\tcse_reg_info_used_list_end = cri;\n+      \n+      *entry = cri;\n     }\n \n   /* Cache this lookup; we tend to be looking up information about the\n@@ -881,14 +895,20 @@ get_cse_reg_info (regno)\n   return cri;\n }\n \n-static void\n-free_cse_reg_info (v)\n-     splay_tree_value v;\n+static unsigned int\n+hash_cse_reg_info (el_ptr)\n+     hash_table_entry_t el_ptr;\n {\n-  struct cse_reg_info *cri = (struct cse_reg_info *) v;\n-  \n-  cri->variant.next = cse_reg_info_free_list;\n-  cse_reg_info_free_list = cri;\n+  return ((struct cse_reg_info *) el_ptr)->regno;\n+}\n+\n+static int\n+cse_reg_info_equal_p (el_ptr1, el_ptr2)\n+     hash_table_entry_t el_ptr1;\n+     hash_table_entry_t el_ptr2;\n+{\n+  return (((struct cse_reg_info *) el_ptr1)->regno\n+\t  == ((struct cse_reg_info *) el_ptr2)->regno);\n }\n \n /* Clear the hash table and initialize each register with its own quantity,\n@@ -903,12 +923,18 @@ new_basic_block ()\n \n   if (cse_reg_info_tree) \n     {\n-      splay_tree_delete (cse_reg_info_tree);\n+      delete_hash_table (cse_reg_info_tree);\n+      if (cse_reg_info_used_list)\n+\t{\n+\t  cse_reg_info_used_list_end->next = cse_reg_info_free_list;\n+\t  cse_reg_info_free_list = cse_reg_info_used_list;\n+\t  cse_reg_info_used_list = cse_reg_info_used_list_end = 0;\n+\t}\n       cached_cse_reg_info = 0;\n     }\n \n-  cse_reg_info_tree = splay_tree_new (splay_tree_compare_ints, 0, \n-\t\t\t\t      free_cse_reg_info);\n+  cse_reg_info_tree = create_hash_table (0, hash_cse_reg_info,\n+\t\t\t\t\t cse_reg_info_equal_p);\n \n   CLEAR_HARD_REG_SET (hard_regs_in_table);\n "}]}