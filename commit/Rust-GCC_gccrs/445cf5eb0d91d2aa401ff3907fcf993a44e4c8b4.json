{"sha": "445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQ1Y2Y1ZWIwZDkxZDJhYTQwMWZmMzkwN2ZjZjk5M2E0NGU0YzhiNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-12-28T04:36:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-12-28T04:36:54Z"}, "message": "Add memory barriers to the double-checked locking used for static initialization.\n\nlibstdc++:\n        Add memory barriers to the double-checked locking used for static\n        initialization.\n        * libsupc++/guard.cc (__test_and_acquire): Define default.\n        (_GLIBCXX_GUARD_TEST_AND_ACQUIRE, __set_and_release)\n        (_GLIBCXX_GUARD_SET_AND_RELEASE): Likewise.\n        (recursion_push, recursion_pop): New abstraction functions.\n        (__cxa_guard_acquire): Use _GLIBCXX_GUARD_TEST_AND_ACQUIRE.\n        (__cxa_guard_release): Use _GLIBCXX_GUARD_SET_AND_RELEASE.\n        * config/cpu/generic/cxxabi_tweaks.h (_GLIBCXX_GUARD_TEST): Rename\n        from _GLIBCXX_GUARD_ACQUIRE and reverse sense.\n        (_GLIBCXX_GUARD_SET): Rename from _GLIBCXX_GUARD_RELEASE.\n        * config/cpu/arm/cxxabi_tweaks.h: Likewise.\n        * config/cpu/alpha/atomic_word.h (_GLIBCXX_READ_MEM_BARRIER)\n        (_GLIBCXX_WRITE_MEM_BARRIER): Define.\n        * config/cpu/powerpc/atomic_word.h: Likewise.\n        * config/cpu/sparc/atomic_word.h: Likewise.\n        * config/cpu/generic/atomic_word.h: Define them, commented out.\n        * include/bits/atomicity.h: Define defaults.\n        * config/cpu/ia64/atomic_word.h (__test_and_acquire)\n        (__set_and_release): New inlines.\n        (_GLIBCXX_GUARD_TEST_AND_ACQUIRE): Define.\n        (_GLIBCXX_GUARD_SET_AND_RELEASE): Define.\n\n        * libsupc++/guard.cc (acquire_1): Use __builtin_trap instead of\n        abort();\n\ngcc:\n        * doc/tm.texi (TARGET_RELAXED_ORDERING): Document.\n        * target.h (struct gcc_target): Add relaxed_ordering field.\n        * target-def.h (TARGET_RELAXED_ORDERING): Define default.\n        (TARGET_INITIALIZER): Add it.\n        * config/alpha/alpha.c (TARGET_RELAXED_ORDERING): Define.\n        * config/ia64/ia64.c (TARGET_RELAXED_ORDERING): Define.\n        * config/rs6000/rs6000.c (TARGET_RELAXED_ORDERING): Define.\n        * config/sparc/sparc.c (TARGET_RELAXED_ORDERING): Define.\n        * cp/decl.c (expand_static_init): Don't use shortcut if\n        targetm.relaxed_ordering.\n\nFrom-SVN: r92659", "tree": {"sha": "d723d1a31c0c3358f41a176191bde7ef4add806e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d723d1a31c0c3358f41a176191bde7ef4add806e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f7edb8b3d65da166df57999ae6053bfdbf939de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f7edb8b3d65da166df57999ae6053bfdbf939de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f7edb8b3d65da166df57999ae6053bfdbf939de"}], "stats": {"total": 381, "additions": 354, "deletions": 27}, "files": [{"sha": "6c6860be8dbb75728c345b05ab102e93a39138ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -1,3 +1,14 @@\n+2004-12-27  Jason Merrill  <jason@redhat.com>\n+\n+\t* doc/tm.texi (TARGET_RELAXED_ORDERING): Document.\n+\t* target.h (struct gcc_target): Add relaxed_ordering field.\n+\t* target-def.h (TARGET_RELAXED_ORDERING): Define default.\n+\t(TARGET_INITIALIZER): Add it.\n+\t* config/alpha/alpha.c (TARGET_RELAXED_ORDERING): Define.\n+\t* config/ia64/ia64.c (TARGET_RELAXED_ORDERING): Define.\n+\t* config/rs6000/rs6000.c (TARGET_RELAXED_ORDERING): Define.\n+\t* config/sparc/sparc.c (TARGET_RELAXED_ORDERING): Define.\n+\n 2004-12-27  Roger Sayle  <roger@eyesopen.com>\n \n \tPR driver/16118"}, {"sha": "042ffa6abcc697e21c69cf427112d4a19bb909ab", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -9462,6 +9462,12 @@ alpha_init_libfuncs (void)\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST alpha_build_builtin_va_list\n \n+/* The Alpha architecture does not require sequential consistency.  See\n+   http://www.cs.umd.edu/~pugh/java/memoryModel/AlphaReordering.html\n+   for an example of how it can be violated in practice.  */\n+#undef TARGET_RELAXED_ORDERING\n+#define TARGET_RELAXED_ORDERING true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n \f"}, {"sha": "332fa9be3ccaa82aaced39af90a2461d17dc42ae", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -420,6 +420,11 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P ia64_scalar_mode_supported_p\n \n+/* ia64 architecture manual 4.4.7: ... reads, writes, and flushes may occur\n+   in an order different from the specified program order.  */\n+#undef TARGET_RELAXED_ORDERING\n+#define TARGET_RELAXED_ORDERING true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n typedef enum"}, {"sha": "95a7b1619bf7fce9d3c2f4893bbb3d1fa2ae5a17", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -1004,6 +1004,17 @@ static const char alt_reg_names[][8] =\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P rs6000_vector_mode_supported_p\n \n+/* MPC604EUM 3.5.2 Weak Consistency between Multiple Processors\n+   The PowerPC architecture requires only weak consistency among\n+   processors--that is, memory accesses between processors need not be\n+   sequentially consistent and memory accesses among processors can occur\n+   in any order. The ability to order memory accesses weakly provides\n+   opportunities for more efficient use of the system bus. Unless a\n+   dependency exists, the 604e allows read operations to precede store\n+   operations.  */\n+#undef TARGET_RELAXED_ORDERING\n+#define TARGET_RELAXED_ORDERING true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n "}, {"sha": "dd83f544b4f7dd64848ab55763e81fa118357223", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -494,6 +494,11 @@ enum processor_type sparc_cpu;\n #define TARGET_ATTRIBUTE_TABLE sparc_attribute_table\n #endif\n \n+/* The SPARC v9 architecture defines a relaxed memory ordering model (RMO)\n+   which requires this if enabled, though it is never used in userspace,\n+   and the Ultra3 processors don't implement it.  */\n+#define TARGET_RELAXED_ORDERING TARGET_V9\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Validate and override various options, and do some machine dependent"}, {"sha": "622a0012a13ba1fdd9a2688084c8dac0608c2ba5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -1,3 +1,8 @@\n+2004-12-27  Jason Merrill  <jason@redhat.com>\n+\n+\t* decl.c (expand_static_init): Don't use shortcut if\n+\ttargetm.relaxed_ordering.\n+\n 2004-12-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/19149"}, {"sha": "7a839d7f3bfc9acc0bef302a103ec9142264a26c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -5313,8 +5313,8 @@ expand_static_init (tree decl, tree init)\n   if (DECL_FUNCTION_SCOPE_P (decl))\n     {\n       /* Emit code to perform this initialization but once.  */\n-      tree if_stmt, inner_if_stmt = NULL_TREE;\n-      tree then_clause, inner_then_clause = NULL_TREE;\n+      tree if_stmt = NULL_TREE, inner_if_stmt = NULL_TREE;\n+      tree then_clause = NULL_TREE, inner_then_clause = NULL_TREE;\n       tree guard, guard_addr, guard_addr_list;\n       tree acquire_fn, release_fn, abort_fn;\n       tree flag, begin;\n@@ -5353,10 +5353,16 @@ expand_static_init (tree decl, tree init)\n       /* Create the guard variable.  */\n       guard = get_guard (decl);\n \n-      /* Begin the conditional initialization.  */\n-      if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n-      then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n+      /* This optimization isn't safe on targets with relaxed memory\n+\t consistency.  On such targets we force synchronization in\n+\t __cxa_guard_acquire.  */\n+      if (!targetm.relaxed_ordering || !flag_threadsafe_statics)\n+\t{\n+\t  /* Begin the conditional initialization.  */\n+\t  if_stmt = begin_if_stmt ();\n+\t  finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n+\t  then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n+\t}\n \n       if (flag_threadsafe_statics)\n \t{\n@@ -5419,9 +5425,12 @@ expand_static_init (tree decl, tree init)\n \t  finish_if_stmt (inner_if_stmt);\n \t}\n \n-      finish_compound_stmt (then_clause);\n-      finish_then_clause (if_stmt);\n-      finish_if_stmt (if_stmt);\n+      if (!targetm.relaxed_ordering || !flag_threadsafe_statics)\n+\t{\n+\t  finish_compound_stmt (then_clause);\n+\t  finish_then_clause (if_stmt);\n+\t  finish_if_stmt (if_stmt);\n+\t}\n     }\n   else\n     static_aggregates = tree_cons (init, decl, static_aggregates);"}, {"sha": "abcf7071763ecaf14f0ceb6d1fa805c9b06c030e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -9574,6 +9574,16 @@ If defined, this macro is the number of entries in\n @code{TARGET_FORMAT_TYPES}.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_RELAXED_ORDERING\n+If set to @code{true}, means that the target's memory model does not\n+guarantee that loads which do not depend on one another will access\n+main memory in the order of the instruction stream; if ordering is\n+important, an explicit memory barrier must be used.  This is true of\n+many recent processors which implement a policy of ``relaxed,''\n+``weak,'' or ``release'' memory consistency, such as Alpha, PowerPC,\n+and ia64.  The default is @code{false}.\n+@end deftypefn\n+\n @defmac TARGET_USE_JCR_SECTION\n This macro determines whether to use the JCR section to register Java\n classes. By default, TARGET_USE_JCR_SECTION is defined to 1 if both"}, {"sha": "cd333c3b5e6ac9cc849640a0032e40a327ca8f07", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -394,6 +394,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #define TARGET_GIMPLIFY_VA_ARG_EXPR std_gimplify_va_arg_expr\n #define TARGET_PASS_BY_REFERENCE hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n+\n+#define TARGET_RELAXED_ORDERING false\n+\n #define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size_or_pad\n #define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_false\n \n@@ -533,6 +536,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n   TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME,\t\\\n   TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\t\t\\\n+  TARGET_RELAXED_ORDERING,\t\t\t\\\n }\n \n #include \"hooks.h\""}, {"sha": "9ad460c18c9309c15c178822756447f4fef259c6", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -598,6 +598,10 @@ struct gcc_target\n   /* True if #pragma extern_prefix is to be supported.  */\n   bool handle_pragma_extern_prefix;\n \n+  /* True if the target is allowed to reorder memory accesses unless\n+     synchronization is explicitly requested.  */\n+  bool relaxed_ordering;\n+\n   /* Leave the boolean fields at the end.  */\n };\n "}, {"sha": "da33b5de852ed90cc2eb7f598ce09a8e8b424192", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -1,3 +1,31 @@\n+2004-12-27  Jason Merrill  <jason@redhat.com>\n+\n+\tAdd memory barriers to the double-checked locking used for static\n+\tinitialization.\n+\t* libsupc++/guard.cc (__test_and_acquire): Define default.\n+\t(_GLIBCXX_GUARD_TEST_AND_ACQUIRE, __set_and_release) \n+\t(_GLIBCXX_GUARD_SET_AND_RELEASE): Likewise.\n+\t(recursion_push, recursion_pop): New abstraction functions.\n+\t(__cxa_guard_acquire): Use _GLIBCXX_GUARD_TEST_AND_ACQUIRE.\n+\t(__cxa_guard_release): Use _GLIBCXX_GUARD_SET_AND_RELEASE.\n+\t* config/cpu/generic/cxxabi_tweaks.h (_GLIBCXX_GUARD_TEST): Rename\n+\tfrom _GLIBCXX_GUARD_ACQUIRE and reverse sense.\n+\t(_GLIBCXX_GUARD_SET): Rename from _GLIBCXX_GUARD_RELEASE.\n+\t* config/cpu/arm/cxxabi_tweaks.h: Likewise.\n+\t* config/cpu/alpha/atomic_word.h (_GLIBCXX_READ_MEM_BARRIER) \n+\t(_GLIBCXX_WRITE_MEM_BARRIER): Define.\n+\t* config/cpu/powerpc/atomic_word.h: Likewise.\n+\t* config/cpu/sparc/atomic_word.h: Likewise.\n+\t* config/cpu/generic/atomic_word.h: Define them, commented out.\n+\t* include/bits/atomicity.h: Define defaults.\n+\t* config/cpu/ia64/atomic_word.h (__test_and_acquire)\n+\t(__set_and_release): New inlines.\n+\t(_GLIBCXX_GUARD_TEST_AND_ACQUIRE): Define.\n+\t(_GLIBCXX_GUARD_SET_AND_RELEASE): Define.\n+\n+\t* libsupc++/guard.cc (acquire_1): Use __builtin_trap instead of\n+\tabort();\n+\n 2004-12-27  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/type_traits: Rework the _DEFINE_SPEC* macros."}, {"sha": "254e3d9ecb3053d3ef9cbe9899259fd9f6c47208", "filename": "libstdc++-v3/config/cpu/alpha/atomic_word.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Falpha%2Fatomic_word.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Falpha%2Fatomic_word.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Falpha%2Fatomic_word.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -0,0 +1,38 @@\n+// Low-level type for atomic operations -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_ATOMIC_WORD_H\n+#define _GLIBCXX_ATOMIC_WORD_H\t1\n+\n+typedef int _Atomic_word;\n+\n+#define _GLIBCXX_READ_MEM_BARRIER __asm __volatile (\"mb\":::\"memory\")\n+#define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile (\"wmb\":::\"memory\")\n+\n+#endif "}, {"sha": "39a10436c2e2f8676174668bbd4259bde9d7c88e", "filename": "libstdc++-v3/config/cpu/arm/cxxabi_tweaks.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Farm%2Fcxxabi_tweaks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Farm%2Fcxxabi_tweaks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Farm%2Fcxxabi_tweaks.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -38,8 +38,8 @@ namespace __cxxabiv1\n #ifdef __ARM_EABI__\n   // The ARM EABI uses the least significant bit of a 32-bit\n   // guard variable.  */\n-#define _GLIBCXX_GUARD_ACQUIRE(x) (!(*(x) & 1))\n-#define _GLIBCXX_GUARD_RELEASE(x) *(x) = 1\n+#define _GLIBCXX_GUARD_TEST(x) ((*(x) & 1) != 0)\n+#define _GLIBCXX_GUARD_SET(x) *(x) = 1\n   typedef int __guard;\n \n   // We also want the element size in array cookies.\n@@ -54,8 +54,8 @@ namespace __cxxabiv1\n #else // __ARM_EABI__\n \n   // The generic ABI uses the first byte of a 64-bit guard variable.\n-#define _GLIBCXX_GUARD_ACQUIRE(x) (!*(char *) (x))\n-#define _GLIBCXX_GUARD_RELEASE(x) *(char *) (x) = 1\n+#define _GLIBCXX_GUARD_TEST(x) (*(char *) (x) != 0)\n+#define _GLIBCXX_GUARD_SET(x) *(char *) (x) = 1\n   __extension__ typedef int __guard __attribute__((mode (__DI__)));\n \n   // __cxa_vec_ctor has void return type."}, {"sha": "f03f1ecbce13d7df1dc891e3ec3ca244a3a4a174", "filename": "libstdc++-v3/config/cpu/generic/atomic_word.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomic_word.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomic_word.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomic_word.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -32,4 +32,17 @@\n \n typedef int _Atomic_word;\n \n+// Define these two macros using the appropriate memory barrier for the target.\n+// The commented out versions below are the defaults.\n+// See ia64/atomic_word.h for an alternative approach.\n+\n+// This one prevents loads from being hoisted across the barrier;\n+// in other words, this is a Load-Load acquire barrier.\n+// This is necessary iff TARGET_RELAXED_ORDERING is defined in tm.h.  \n+// #define _GLIBCXX_READ_MEM_BARRIER __asm __volatile (\"\":::\"memory\")\n+\n+// This one prevents stores from being sunk across the barrier; in other\n+// words, a Store-Store release barrier.\n+// #define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile (\"\":::\"memory\")\n+\n #endif "}, {"sha": "b5808a265dc14d795f439822a4f6d213674c5d28", "filename": "libstdc++-v3/config/cpu/generic/cxxabi_tweaks.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fcxxabi_tweaks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fcxxabi_tweaks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fcxxabi_tweaks.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -36,8 +36,8 @@ namespace __cxxabiv1\n #endif\n \n   // The generic ABI uses the first byte of a 64-bit guard variable.\n-#define _GLIBCXX_GUARD_ACQUIRE(x) (!*(char *) (x))\n-#define _GLIBCXX_GUARD_RELEASE(x) *(char *) (x) = 1\n+#define _GLIBCXX_GUARD_TEST(x) (*(char *) (x) != 0)\n+#define _GLIBCXX_GUARD_SET(x) *(char *) (x) = 1\n   __extension__ typedef int __guard __attribute__((mode (__DI__)));\n \n   // __cxa_vec_ctor has void return type."}, {"sha": "2e49e2707368b6063469b548e7d4e3acbc472a45", "filename": "libstdc++-v3/config/cpu/ia64/atomic_word.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fia64%2Fatomic_word.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fia64%2Fatomic_word.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fia64%2Fatomic_word.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -0,0 +1,69 @@\n+// Low-level type for atomic operations -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_ATOMIC_WORD_H\n+#define _GLIBCXX_ATOMIC_WORD_H\t1\n+\n+#include <cxxabi.h>\n+\n+typedef int _Atomic_word;\n+\n+namespace __gnu_cxx\n+{\n+  // Test the first byte of __g and ensure that no loads are hoisted across\n+  // the test.\n+  inline bool\n+  __test_and_acquire (__cxxabiv1::__guard *__g)\n+  {\n+    unsigned char __c;\n+    unsigned char *__p = reinterpret_cast<unsigned char *>(__g);\n+    // ldN.acq is a load with an implied hoist barrier.\n+    // would ld8+mask be faster than just doing an ld1?\n+    __asm __volatile (\"ld1.acq %0 = %1\" : \"=r\"(__c) : \"m\"(*__p) : \"memory\");\n+    return __c != 0;\n+  }\n+\n+  // Set the first byte of __g to 1 and ensure that no stores are sunk\n+  // across the store.\n+  inline void\n+  __set_and_release (__cxxabiv1::__guard *__g)\n+  {\n+    unsigned char *__p = reinterpret_cast<unsigned char *>(__g);\n+    // stN.rel is a store with an implied sink barrier.\n+    // could load word, set flag, and CAS it back\n+    __asm __volatile (\"st1.rel %0 = %1\" : \"=m\"(*__p) : \"r\"(1) : \"memory\");\n+  }\n+\n+  // We don't define the _BARRIER macros on ia64 because the barriers are\n+  // included in the test and set, above.\n+#define _GLIBCXX_GUARD_TEST_AND_ACQUIRE(G) __gnu_cxx::__test_and_acquire (G)\n+#define _GLIBCXX_GUARD_SET_AND_RELEASE(G) __gnu_cxx::__set_and_release (G)\n+}\n+\n+#endif "}, {"sha": "ff418cc540db87c4d9e31a6cd977dab4ba778a4f", "filename": "libstdc++-v3/config/cpu/powerpc/atomic_word.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fpowerpc%2Fatomic_word.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fpowerpc%2Fatomic_word.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fpowerpc%2Fatomic_word.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -0,0 +1,38 @@\n+// Low-level type for atomic operations -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_ATOMIC_WORD_H\n+#define _GLIBCXX_ATOMIC_WORD_H\t1\n+\n+typedef int _Atomic_word;\n+\n+#define _GLIBCXX_READ_MEM_BARRIER __asm __volatile (\"isync\":::\"memory\")\n+#define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile (\"lwsync\":::\"memory\")\n+\n+#endif "}, {"sha": "59b1a2c9df673fc24ebdd5652b148ea4d3a23689", "filename": "libstdc++-v3/config/cpu/sparc/atomic_word.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fatomic_word.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fatomic_word.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fatomic_word.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -36,4 +36,18 @@\n   typedef int _Atomic_word;\n #endif\n \n+#if defined(__sparc_v9__)\n+// These are necessary under the V9 RMO model, though it is almost never\n+// used in userspace.\n+#define _GLIBCXX_READ_MEM_BARRIER \\\n+  __asm __volatile (\"membar #LoadLoad\":::\"memory\")\n+#define _GLIBCXX_WRITE_MEM_BARRIER \\\n+  __asm __volatile (\"membar #StoreStore\":::\"memory\")\n+\n+#elif defined(__sparc_v8__)\n+// This is necessary under the PSO model.\n+#define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile (\"stbar\":::\"memory\")\n+\n+#endif\n+\n #endif "}, {"sha": "9ad25e0f34295c595e2f4061ea11184031b403d6", "filename": "libstdc++-v3/include/bits/atomicity.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomicity.h?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -48,4 +48,13 @@ namespace __gnu_cxx\n   __atomic_add(volatile _Atomic_word* __mem, int __val);\n } // namespace __gnu_cxx\n \n+/* Even if the CPU doesn't need a memory barrier, we need to ensure that\n+   the compiler doesn't reorder memory accesses across the barriers.  */\n+#ifndef _GLIBCXX_READ_MEM_BARRIER\n+#define _GLIBCXX_READ_MEM_BARRIER __asm __volatile (\"\":::\"memory\")\n+#endif\n+#ifndef _GLIBCXX_WRITE_MEM_BARRIER\n+#define _GLIBCXX_WRITE_MEM_BARRIER __asm __volatile (\"\":::\"memory\")\n+#endif\n+\n #endif "}, {"sha": "e9e147037704bcadddc7c17bb4b13f970e505f85", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=445cf5eb0d91d2aa401ff3907fcf993a44e4c8b4", "patch": "@@ -27,11 +27,13 @@\n // the GNU General Public License.\n \n // Written by Mark Mitchell, CodeSourcery LLC, <mark@codesourcery.com>\n+// Thread support written by Jason Merrill, Red Hat Inc. <jason@redhat.com>\n \n #include <cxxabi.h>\n #include <exception>\n #include <bits/c++config.h>\n #include <bits/gthr.h>\n+#include <bits/atomicity.h>\n \n // The IA64/generic ABI uses the first byte of the guard variable.\n // The ARM EABI uses the least significant bit.\n@@ -84,8 +86,36 @@ namespace\n     __gthread_recursive_mutex_unlock (&mutex);\n   }\n }\n+\n+#ifndef _GLIBCXX_GUARD_TEST_AND_ACQUIRE\n+inline bool\n+__test_and_acquire (__cxxabiv1::__guard *g)\n+{\n+  bool b = _GLIBCXX_GUARD_TEST (g);\n+  _GLIBCXX_READ_MEM_BARRIER;\n+  return b;\n+}\n+#define _GLIBCXX_GUARD_TEST_AND_ACQUIRE(G) __test_and_acquire (G)\n #endif\n \n+#ifndef _GLIBCXX_GUARD_SET_AND_RELEASE\n+inline void\n+__set_and_release (__cxxabiv1::__guard *g)\n+{\n+  _GLIBCXX_WRITE_MEM_BARRIER;\n+  _GLIBCXX_GUARD_SET (g);\n+}\n+#define _GLIBCXX_GUARD_SET_AND_RELEASE(G) __set_and_release (G)\n+#endif\n+\n+#else /* !__GTHREADS */\n+\n+#undef _GLIBCXX_GUARD_TEST_AND_ACQUIRE\n+#undef _GLIBCXX_GUARD_SET_AND_RELEASE\n+#define _GLIBCXX_GUARD_SET_AND_RELEASE(G) _GLIBCXX_GUARD_SET (G)\n+\n+#endif /* __GTHREADS */\n+\n namespace __gnu_cxx\n {\n   // 6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)\n@@ -107,28 +137,46 @@ namespace __gnu_cxx\n \n namespace __cxxabiv1 \n {\n+  static inline int\n+  recursion_push (__guard* g)\n+  {\n+    return ((char *)g)[1]++;\n+  }\n+\n+  static inline void\n+  recursion_pop (__guard* g)\n+  {\n+    --((char *)g)[1];\n+  }\n+\n   static int\n   acquire_1 (__guard *g)\n   {\n-    if (_GLIBCXX_GUARD_ACQUIRE (g))\n+    if (_GLIBCXX_GUARD_TEST (g))\n+      return 0;\n+\n+    if (recursion_push (g))\n       {\n-\tif (((char *)g)[1]++)\n-\t  {\n #ifdef __EXCEPTIONS\n-\t    throw __gnu_cxx::recursive_init();\n+\tthrow __gnu_cxx::recursive_init();\n #else\n-\t    abort ();\n+\t// Use __builtin_trap so we don't require abort().\n+\t__builtin_trap ();\n #endif\n-\t  }\n-\treturn 1;\n       }\n-    return 0;\n+    return 1;\n   }\n-  \n+\n   extern \"C\"\n   int __cxa_guard_acquire (__guard *g) \n   {\n #ifdef __GTHREADS\n+    // If the target can reorder loads, we need to insert a read memory\n+    // barrier so that accesses to the guarded variable happen after the\n+    // guard test.\n+    if (_GLIBCXX_GUARD_TEST_AND_ACQUIRE (g))\n+      return 0;\n+\n     if (__gthread_active_p ())\n       {\n \t// Simple wrapper for exception safety.\n@@ -162,7 +210,7 @@ namespace __cxxabiv1\n   extern \"C\"\n   void __cxa_guard_abort (__guard *g)\n   {\n-    ((char *)g)[1]--;\n+    recursion_pop (g);\n #ifdef __GTHREADS\n     if (__gthread_active_p ())\n       static_mutex::unlock ();\n@@ -172,8 +220,8 @@ namespace __cxxabiv1\n   extern \"C\"\n   void __cxa_guard_release (__guard *g)\n   {\n-    ((char *)g)[1]--;\n-    _GLIBCXX_GUARD_RELEASE (g);\n+    recursion_pop (g);\n+    _GLIBCXX_GUARD_SET_AND_RELEASE (g);\n #ifdef __GTHREADS\n     if (__gthread_active_p ())\n       static_mutex::unlock ();"}]}