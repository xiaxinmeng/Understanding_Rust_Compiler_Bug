{"sha": "28395a0239de38fd77e6c07d9fd5f7fc939c2f5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgzOTVhMDIzOWRlMzhmZDc3ZTZjMDdkOWZkNWY3ZmM5MzljMmY1Yg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-15T22:28:28Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-15T22:28:28Z"}, "message": "In gcc/testsuite/: 2010-10-15 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/testsuite/:\n2010-10-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/gnu-api-2-method.m: New.\n\nFrom-SVN: r165526", "tree": {"sha": "6525b82925dd5d1c6f13bb4cdbc791189d22b43a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6525b82925dd5d1c6f13bb4cdbc791189d22b43a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51194e8eb5db1667efce48ef06a37436ca7ea7de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51194e8eb5db1667efce48ef06a37436ca7ea7de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51194e8eb5db1667efce48ef06a37436ca7ea7de"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "86675d8281b3de65cee1c6c3c1d9fbc4752a49e2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=28395a0239de38fd77e6c07d9fd5f7fc939c2f5b", "patch": "@@ -1,3 +1,7 @@\n+2010-10-15  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/gnu-api-2-method.m: New.\n+\n 2010-10-15  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/lto/pr45983_0.C: New."}, {"sha": "cfcf28a9905754e81740e9d737930b860fbaff3f", "filename": "gcc/testsuite/objc.dg/gnu-api-2-method.m", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-method.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28395a0239de38fd77e6c07d9fd5f7fc939c2f5b/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-method.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-method.m?ref=28395a0239de38fd77e6c07d9fd5f7fc939c2f5b", "patch": "@@ -0,0 +1,227 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+  This is test 'method', covering all functions starting with 'method'.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+@protocol MyProtocol\n+- (id) variable;\n+@end\n+\n+@protocol MySecondProtocol\n+- (id) setVariable: (id)value;\n+@end\n+\n+@interface MySubClass : MyRootClass <MyProtocol>\n+{ id variable_ivar; }\n+- (void) setVariable: (id)value;\n+- (id) variable;\n+- (id) constant;\n+@end\n+\n+@implementation MySubClass\n+- (void) setVariable: (id)value { variable_ivar = value; }\n+- (id) variable { return variable_ivar; }\n+- (id) constant { return nil; }\n+@end\n+\n+\n+int main(int argc, void **args)\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  printf (\"Testing method_copyArgumentType () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    char *type = method_copyArgumentType (method, 2);\n+\n+    if (type == NULL  ||  type[0] != '@')\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_copyReturnType () ...\\n\");\n+  {\n+    Method method = class_getClassMethod (objc_getClass (\"MyRootClass\"),\n+\t\t\t\t\t  @selector (alloc));\n+    char *type = method_copyReturnType (method);\n+\n+    /* Check that it returns an object.  */\n+    if (type == NULL  ||  type[0] != '@')\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_exchangeImplementations () ...\\n\");\n+  {\n+    Method method_a = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (variable));\n+    Method method_b = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (constant));\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    /* Check that things work as expected before the swap.  */\n+    [object setVariable: object];\n+\n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+\n+    /* Swap the methods.  */\n+    method_exchangeImplementations (method_a, method_b);\n+\n+    /* Check that behaviour has changed.  */\n+    if ([object variable] != nil  ||  [object constant] != object)\n+      abort ();\n+\n+    /* Swap the methods again.  */\n+    method_exchangeImplementations (method_a, method_b);\n+    \n+    /* Check that behaviour is back to normal.  */\n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_getArgumentType () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MyRootClass\"),\n+\t\t\t\t\t     @selector (init));\n+    char type[16];\n+    \n+    method_getArgumentType (method, 1, type, 16);\n+\n+    /* Check the second argument (_cmd), which should be a SEL.  */\n+    if (type[0] != ':')\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_getDescription () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (variable));\n+    struct objc_method_description *description = method_getDescription (method);\n+\n+    if (strcmp (sel_getName (description->name), \"variable\") != 0)\n+      abort ();\n+\n+    if (method_getDescription (NULL) != NULL)\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_getImplementation () ...\\n\");\n+  {\n+    typedef void (*set_variable_function) (id receiver, SEL _cmd, id variable);\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    set_variable_function imp;\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    imp = (set_variable_function)(method_getImplementation (method));\n+    \n+    (*imp)(object, @selector (setVariable:), object);\n+\n+    if ([object variable] != object)\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_getName () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    if (strcmp (sel_getName (method_getName (method)), \"setVariable:\") != 0)\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_getNumberOfArguments () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    if (method_getNumberOfArguments (method) != 3)\n+      abort ();\n+\n+    method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t      @selector (variable));\n+    if (method_getNumberOfArguments (method) != 2)\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_getTypeEncoding () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    const char *types = method_getTypeEncoding (method);\n+\n+    /* Check that method type string starts with 'v' (void)  */\n+    if (types == NULL || types[0] != 'v')\n+      abort ();    \n+  }\n+\n+  printf (\"Testing method_getReturnType () ...\\n\");\n+  {\n+    Method method = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t     @selector (setVariable:));\n+    char type[16];\n+    \n+    method_getReturnType (method, type, 16);\n+\n+    if (type[0] != 'v')\n+      abort ();\n+\n+    method_getReturnType (NULL, type, 16);\n+\n+    if (type[0] != 0)\n+      abort ();\n+  }\n+\n+  printf (\"Testing method_setImplementation () ...\\n\");\n+  {\n+    Method method_a = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (variable));\n+    Method method_b = class_getInstanceMethod (objc_getClass (\"MySubClass\"),\n+\t\t\t\t\t       @selector (constant));\n+    IMP original_imp_a = method_getImplementation (method_a);\n+    IMP original_imp_b = method_getImplementation (method_b);\n+    MySubClass *object = [[MySubClass alloc] init];\n+\n+    /* Check that things work as expected before the swap.  */\n+    [object setVariable: object];\n+    \n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+    \n+    /* Have 'variable' use the same implementation as 'constant'.  */\n+    if (method_setImplementation (method_a, original_imp_b) != original_imp_a)\n+      abort ();\n+\n+    /* Check that behaviour has changed.  */\n+    if ([object variable] != nil  ||  [object constant] != nil)\n+      abort ();\n+\n+    /* Put the original method back.  */\n+    if (method_setImplementation (method_a, original_imp_a) != original_imp_b)\n+      abort ();\n+    \n+    /* Check that behaviour is back to normal.  */\n+    if ([object variable] != object  ||  [object constant] != nil)\n+      abort ();\n+  }\n+\n+  return 0;\n+}"}]}