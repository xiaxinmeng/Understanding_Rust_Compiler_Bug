{"sha": "2face51965e6d4b7980ec9f6da0b6a19cf878f99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZhY2U1MTk2NWU2ZDRiNzk4MGVjOWY2ZGEwYjZhMTljZjg3OGY5OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-12-04T10:03:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-12-04T10:03:02Z"}, "message": "init.c (build_new): Use a TARGET_EXPR instead of SAVE_EXPR for alloc_expr.\n\n\t* init.c (build_new): Use a TARGET_EXPR instead of SAVE_EXPR for\n \talloc_expr.\n  \t* call.c (build_op_delete_call): Adjust.\n\nFrom-SVN: r16939", "tree": {"sha": "598ae7a81d707d3612751f1b9b0a87e219a30894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/598ae7a81d707d3612751f1b9b0a87e219a30894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2face51965e6d4b7980ec9f6da0b6a19cf878f99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2face51965e6d4b7980ec9f6da0b6a19cf878f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2face51965e6d4b7980ec9f6da0b6a19cf878f99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2face51965e6d4b7980ec9f6da0b6a19cf878f99/comments", "author": null, "committer": null, "parents": [{"sha": "11f39cf45fe48480da4e44327767f0ac7e77d30e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f39cf45fe48480da4e44327767f0ac7e77d30e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f39cf45fe48480da4e44327767f0ac7e77d30e"}], "stats": {"total": 82, "additions": 64, "deletions": 18}, "files": [{"sha": "c7c56d3109973568cf93c6be3216fcf90c41002a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2face51965e6d4b7980ec9f6da0b6a19cf878f99/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2face51965e6d4b7980ec9f6da0b6a19cf878f99/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2face51965e6d4b7980ec9f6da0b6a19cf878f99", "patch": "@@ -1,5 +1,9 @@\n Wed Dec  3 20:02:39 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* init.c (build_new): Use a TARGET_EXPR instead of SAVE_EXPR for\n+ \talloc_expr.\n+  \t* call.c (build_op_delete_call): Adjust.\n+\n \t* except.c (expand_end_catch_block): Lose rethrow region.\n \t(expand_start_catch_block): Likewise.\n \t(expand_end_catch_block): Don't expand_leftover_cleanups."}, {"sha": "827e904022742aa59d5286d57894313fcf801178", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2face51965e6d4b7980ec9f6da0b6a19cf878f99/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2face51965e6d4b7980ec9f6da0b6a19cf878f99/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=2face51965e6d4b7980ec9f6da0b6a19cf878f99", "patch": "@@ -5148,8 +5148,9 @@ build_op_delete_call (code, addr, size, flags)\n \t is the allocation expression, so extract the info we need from it.\n \t Obviously, if the build_new process changes this may have to\n \t change as well.  */\n-      /* The SAVE_EXPR.  */\n-      tree t = TREE_OPERAND (addr, 0);\n+\n+      /* The NOP_EXPR.  */\n+      tree t = TREE_OPERAND (addr, 1);\n       /* The CALL_EXPR.  */\n       t = TREE_OPERAND (t, 0);\n       /* The function.  */\n@@ -5158,6 +5159,9 @@ build_op_delete_call (code, addr, size, flags)\n       argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (argtypes)));\n       /* The second argument.  */\n       args = TREE_CHAIN (TREE_OPERAND (t, 1));\n+\n+      /* Pull the dummy var out of the TARGET_EXPR for use in our call.  */\n+      addr = TREE_OPERAND (addr, 0);\n     }\n   else\n     {"}, {"sha": "b275a3a7c12dbcb3b762d6c03dd6285c51af47c9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2face51965e6d4b7980ec9f6da0b6a19cf878f99/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2face51965e6d4b7980ec9f6da0b6a19cf878f99/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=2face51965e6d4b7980ec9f6da0b6a19cf878f99", "patch": "@@ -2248,7 +2248,7 @@ build_new (placement, decl, init, use_global_new)\n {\n   tree type, true_type, size, rval;\n   tree nelts;\n-  tree alloc_expr;\n+  tree alloc_expr, alloc_node;\n   int has_array = 0;\n   enum tree_code code = NEW_EXPR;\n   int use_cookie, nothrow, check_new;\n@@ -2527,17 +2527,11 @@ build_new (placement, decl, init, use_global_new)\n     }\n   check_new = flag_check_new || nothrow;\n \n-  if (flag_exceptions && rval)\n+  if ((check_new || flag_exceptions) && rval)\n     {\n-      /* This must last longer so we can use it in the cleanup.\n-         The subexpressions don't need to last, because we won't look at\n-\t them when expanding the cleanup.  */\n-      int yes = suspend_momentary ();\n-      alloc_expr = rval = save_expr (rval);\n-      resume_momentary (yes);\n+      alloc_expr = get_target_expr (rval);\n+      alloc_node = rval = TREE_OPERAND (alloc_expr, 0);\n     }\n-  else if (check_new && rval)\n-    alloc_expr = rval = save_expr (rval);\n   else\n     alloc_expr = NULL_TREE;\n \n@@ -2726,8 +2720,8 @@ build_new (placement, decl, init, use_global_new)\n \t the memory in which the object was being constructed.  */\n       if (flag_exceptions && alloc_expr)\n \t{\n-\t  enum tree_code dcode = has_array? VEC_DELETE_EXPR : DELETE_EXPR;\n-\t  tree cleanup, args = NULL_TREE;\n+\t  enum tree_code dcode = has_array ? VEC_DELETE_EXPR : DELETE_EXPR;\n+\t  tree cleanup;\n \t  int flags = LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL);\n \n \t  /* All cleanups must last longer than normal.  */\n@@ -2739,18 +2733,53 @@ build_new (placement, decl, init, use_global_new)\n \t  /* Copy size to the saveable obstack.  */\n \t  size = copy_node (size);\n \n-\t  cleanup = build_op_delete_call (dcode, alloc_expr, size, flags);\n+\t  /* If we have a new-placement, we need to pass the alloc TARGET_EXPR\n+\t     to build_op_delete_call so it can extract the args.  */\n+\t  cleanup = build_op_delete_call\n+\t    (dcode, placement ? alloc_expr : alloc_node, size, flags);\n \n \t  resume_momentary (yes);\n \n+\t  /* Ack!  First we allocate the memory.  Then we set our sentry\n+\t     variable to true, and expand a cleanup that deletes the memory\n+\t     if sentry is true.  Then we run the constructor and store the\n+\t     returned pointer in buf.  Then we clear sentry and return buf.  */\n+\n \t  if (cleanup)\n \t    {\n+#if 0\n+\t      /* Disable this until flow is fixed so that it doesn't\n+\t\t think the initialization of sentry is a dead write.  */\n+\t      tree end, sentry, begin, buf, t = TREE_TYPE (rval);\n+\n+\t      begin = get_target_expr (boolean_true_node);\n+\t      sentry = TREE_OPERAND (begin, 0);\n+\n+\t      yes = suspend_momentary ();\n+\t      TREE_OPERAND (begin, 2)\n+\t\t= build (COND_EXPR, void_type_node, sentry,\n+\t\t\t cleanup, void_zero_node);\n+\t      resume_momentary (yes);\n+\n+\t      rval = get_target_expr (rval);\n+\n+\t      end = build (MODIFY_EXPR, TREE_TYPE (sentry),\n+\t\t\t   sentry, boolean_false_node);\n+\t      TREE_SIDE_EFFECTS (end) = 1;\n+\n+\t      buf = TREE_OPERAND (rval, 0);\n+\n+\t      rval = build (COMPOUND_EXPR, t, begin,\n+\t\t\t    build (COMPOUND_EXPR, t, rval,\n+\t\t\t\t   build (COMPOUND_EXPR, t, end, buf)));\n+#else\n \t      /* FIXME: this is a workaround for a crash due to overlapping\n \t\t exception regions.  Cleanups shouldn't really happen here.  */\n \t      rval = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (rval), rval);\n \n \t      rval = build (TRY_CATCH_EXPR, TREE_TYPE (rval), rval, cleanup);\n \t      rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+#endif\n \t    }\n \t}\n     }\n@@ -2759,14 +2788,23 @@ build_new (placement, decl, init, use_global_new)\n \n  done:\n \n-  if (check_new && alloc_expr && rval != alloc_expr)\n+  if (alloc_expr && rval == alloc_node)\n+    {\n+      rval = TREE_OPERAND (alloc_expr, 1);\n+      alloc_expr = NULL_TREE;\n+    }\n+\n+  if (check_new && alloc_expr)\n     {\n       /* Did we modify the storage?  */\n-      tree ifexp = build_binary_op (NE_EXPR, alloc_expr,\n+      tree ifexp = build_binary_op (NE_EXPR, alloc_node,\n \t\t\t\t    integer_zero_node, 1);\n-      rval = build_conditional_expr (ifexp, rval, alloc_expr);\n+      rval = build_conditional_expr (ifexp, rval, alloc_node);\n     }\n \n+  if (alloc_expr)\n+    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+\n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n     {\n       /* The type of new int [3][3] is not int *, but int [3] * */"}]}