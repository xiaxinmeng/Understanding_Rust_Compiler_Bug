{"sha": "d5e401fb1452d6a9504e23d76d072a89fd2ba379", "node_id": "C_kwDOANBUbNoAKGQ1ZTQwMWZiMTQ1MmQ2YTk1MDRlMjNkNzZkMDcyYTg5ZmQyYmEzNzk", "commit": {"author": {"name": "Lulu Cheng", "email": "chenglulu@loongson.cn", "date": "2022-07-21T02:32:51Z"}, "committer": {"name": "Lulu Cheng", "email": "chenglulu@loongson.cn", "date": "2022-07-26T06:30:14Z"}, "message": "LoongArch: Subdivision symbol type, add SYMBOL_PCREL support.\n\n1. Remove cModel type support other than normal.\n2. The method for calling global functions changed from 'la.global + jirl' to 'bl'\n   when complied add '-fplt'.\n\ngcc/ChangeLog:\n\n\t* config/loongarch/constraints.md (a): Delete the constraint.\n\t(b): A constant call not local address.\n\t(h): Delete the constraint.\n\t(t): Delete the constraint.\n\t* config/loongarch/loongarch-opts.cc (loongarch_config_target):\n\tRemove cModel type support other than normal.\n\t* config/loongarch/loongarch-protos.h (enum loongarch_symbol_type):\n\tAdd new symbol type 'SYMBOL_PCREL', 'SYMBOL_TLS_IE' and 'SYMBOL_TLS_LE'.\n\t(loongarch_split_symbol): Delete useless function declarations.\n\t(loongarch_split_symbol_type): Delete useless function declarations.\n\t* config/loongarch/loongarch.cc (enum loongarch_address_type):\n\tDelete unnecessary comment information.\n\t(loongarch_symbol_binds_local_p): Modified the judgment order of label\n\tand symbol.\n\t(loongarch_classify_symbol): Return symbol type. If symbol is a label,\n\tor symbol is a local symbol return SYMBOL_PCREL. If is a tls symbol,\n\treturn SYMBOL_TLS. If is a not local symbol return SYMBOL_GOT_DISP.\n\t(loongarch_symbolic_constant_p): Add handling of 'SYMBOL_TLS_IE'\n\t'SYMBOL_TLS_LE' and 'SYMBOL_PCREL'.\n\t(loongarch_symbol_insns): Add handling of 'SYMBOL_TLS_IE' 'SYMBOL_TLS_LE'\n\tand 'SYMBOL_PCREL'.\n\t(loongarch_address_insns): Sort code.\n\t(loongarch_12bit_offset_address_p): Sort code.\n\t(loongarch_14bit_shifted_offset_address_p): Sort code.\n\t(loongarch_call_tls_get_addr): Sort code.\n\t(loongarch_legitimize_tls_address): Sort code.\n\t(loongarch_output_move): Remove schema support for cmodel other than normal.\n\t(loongarch_memmodel_needs_release_fence): Sort code.\n\t(loongarch_print_operand): Sort code.\n\t* config/loongarch/loongarch.h (LARCH_U12BIT_OFFSET_P):\n\tRename to LARCH_12BIT_OFFSET_P.\n\t(LARCH_12BIT_OFFSET_P): New macro.\n\t* config/loongarch/loongarch.md: Reimplement the function call. Remove schema\n\tsupport for cmodel other than normal.\n\t* config/loongarch/predicates.md (is_const_call_weak_symbol): Delete this predicate.\n\t(is_const_call_plt_symbol): Delete this predicate.\n\t(is_const_call_global_noplt_symbol): Delete this predicate.\n\t(is_const_call_no_local_symbol): New predicate, determines whether it is a local\n\tsymbol or label.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/loongarch/func-call-1.c: New test.\n\t* gcc.target/loongarch/func-call-2.c: New test.\n\t* gcc.target/loongarch/func-call-3.c: New test.\n\t* gcc.target/loongarch/func-call-4.c: New test.", "tree": {"sha": "38a5898f2a934a5e4f814e4b3e2af3b607bbaa4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38a5898f2a934a5e4f814e4b3e2af3b607bbaa4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5e401fb1452d6a9504e23d76d072a89fd2ba379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e401fb1452d6a9504e23d76d072a89fd2ba379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e401fb1452d6a9504e23d76d072a89fd2ba379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e401fb1452d6a9504e23d76d072a89fd2ba379/comments", "author": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenglulu326", "id": 88083425, "node_id": "MDQ6VXNlcjg4MDgzNDI1", "avatar_url": "https://avatars.githubusercontent.com/u/88083425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenglulu326", "html_url": "https://github.com/chenglulu326", "followers_url": "https://api.github.com/users/chenglulu326/followers", "following_url": "https://api.github.com/users/chenglulu326/following{/other_user}", "gists_url": "https://api.github.com/users/chenglulu326/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenglulu326/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenglulu326/subscriptions", "organizations_url": "https://api.github.com/users/chenglulu326/orgs", "repos_url": "https://api.github.com/users/chenglulu326/repos", "events_url": "https://api.github.com/users/chenglulu326/events{/privacy}", "received_events_url": "https://api.github.com/users/chenglulu326/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4286601933406142b46693660f7f4b682cb50a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4286601933406142b46693660f7f4b682cb50a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4286601933406142b46693660f7f4b682cb50a5"}], "stats": {"total": 745, "additions": 312, "deletions": 433}, "files": [{"sha": "43cb7b5f0f58bdf2d614a052dee5471e0d0e8544", "filename": "gcc/config/loongarch/constraints.md", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fconstraints.md?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -20,14 +20,14 @@\n \n ;; Register constraints\n \n-;; \"a\" \"A constant call global and noplt address.\"\n-;; \"b\" <-----unused\n+;; \"a\" <-----unused\n+;; \"b\" \"A constant call not local address.\"\n ;; \"c\" \"A constant call local address.\"\n ;; \"d\" <-----unused\n ;; \"e\" JIRL_REGS\n ;; \"f\" FP_REGS\n ;; \"g\" <-----unused\n-;; \"h\" \"A constant call plt address.\"\n+;; \"h\" <-----unused\n ;; \"i\" \"Matches a general integer constant.\" (Global non-architectural)\n ;; \"j\" SIBCALL_REGS\n ;; \"k\" \"A memory operand whose address is formed by a base register and\n@@ -42,7 +42,7 @@\n ;; \"q\" CSR_REGS\n ;; \"r\" GENERAL_REGS (Global non-architectural)\n ;; \"s\" \"Matches a symbolic integer constant.\" (Global non-architectural)\n-;; \"t\" \"A constant call weak address\"\n+;; \"t\" <-----unused\n ;; \"u\" \"A signed 52bit constant and low 32-bit is zero (for logic instructions)\"\n ;; \"v\" \"A signed 64-bit constant and low 44-bit is zero (for logic instructions).\"\n ;; \"w\" \"Matches any valid memory.\"\n@@ -89,10 +89,10 @@\n ;; \"<\" \"Matches a pre-dec or post-dec operand.\" (Global non-architectural)\n ;; \">\" \"Matches a pre-inc or post-inc operand.\" (Global non-architectural)\n \n-(define_constraint \"a\"\n+(define_constraint \"b\"\n   \"@internal\n-   A constant call global and noplt address.\"\n-  (match_operand 0 \"is_const_call_global_noplt_symbol\"))\n+   A constant call no local address.\"\n+  (match_operand 0 \"is_const_call_no_local_symbol\"))\n \n (define_constraint \"c\"\n   \"@internal\n@@ -105,11 +105,6 @@\n (define_register_constraint \"f\" \"TARGET_HARD_FLOAT ? FP_REGS : NO_REGS\"\n   \"A floating-point register (if available).\")\n \n-(define_constraint \"h\"\n-  \"@internal\n-   A constant call plt address.\"\n-  (match_operand 0 \"is_const_call_plt_symbol\"))\n-\n (define_register_constraint \"j\" \"SIBCALL_REGS\"\n   \"@internal\")\n \n@@ -134,11 +129,6 @@\n (define_register_constraint \"q\" \"CSR_REGS\"\n   \"A general-purpose register except for $r0 and $r1 for lcsr.\")\n \n-(define_constraint \"t\"\n-  \"@internal\n-   A constant call weak address.\"\n-  (match_operand 0 \"is_const_call_weak_symbol\"))\n-\n (define_constraint \"u\"\n   \"A signed 52bit constant and low 32-bit is zero (for logic instructions).\"\n   (and (match_code \"const_int\")"}, {"sha": "fc477bfd4bbc3e61e0909fd67ad7988ef4dec5c7", "filename": "gcc/config/loongarch/loongarch-opts.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch-opts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch-opts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-opts.cc?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -376,6 +376,13 @@ loongarch_config_target (struct loongarch_target *target,\n \n   /* 5.  Target code model */\n   t.cmodel = constrained.cmodel ? opt_cmodel : CMODEL_NORMAL;\n+  if (t.cmodel != CMODEL_NORMAL)\n+    {\n+      warning (0, \"%qs is not supported, now cmodel is set to 'normal'.\",\n+\t       loongarch_cmodel_strings[t.cmodel]);\n+      t.cmodel = CMODEL_NORMAL;\n+    }\n+\n \n   /* Cleanup and return.  */\n   obstack_free (&msg_obstack, NULL);"}, {"sha": "080766250d1b34537a45922da439f361812ca106", "filename": "gcc/config/loongarch/loongarch-protos.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch-protos.h?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -27,17 +27,24 @@ along with GCC; see the file COPYING3.  If not see\n    SYMBOL_GOT_DISP\n        The symbol's value will be loaded directly from the GOT.\n \n+   SYMBOL_PCREL\n+       The symbol's value will be loaded directly from data section.\n+\n    SYMBOL_TLS\n        A thread-local symbol.\n \n+   SYMBOL_TLS_IE\n    SYMBOL_TLSGD\n    SYMBOL_TLSLDM\n        UNSPEC wrappers around SYMBOL_TLS, corresponding to the\n        thread-local storage relocation operators.\n    */\n enum loongarch_symbol_type {\n   SYMBOL_GOT_DISP,\n+  SYMBOL_PCREL,\n   SYMBOL_TLS,\n+  SYMBOL_TLS_IE,\n+  SYMBOL_TLS_LE,\n   SYMBOL_TLSGD,\n   SYMBOL_TLSLDM,\n };\n@@ -61,7 +68,6 @@ extern int loongarch_idiv_insns (machine_mode);\n #ifdef RTX_CODE\n extern void loongarch_emit_binary (enum rtx_code, rtx, rtx, rtx);\n #endif\n-extern bool loongarch_split_symbol (rtx, rtx, machine_mode, rtx *);\n extern rtx loongarch_unspec_address (rtx, enum loongarch_symbol_type);\n extern rtx loongarch_strip_unspec_address (rtx);\n extern void loongarch_move_integer (rtx, rtx, unsigned HOST_WIDE_INT);\n@@ -154,7 +160,6 @@ extern rtx loongarch_expand_thread_pointer (rtx);\n extern bool loongarch_eh_uses (unsigned int);\n extern bool loongarch_epilogue_uses (unsigned int);\n extern bool loongarch_load_store_bonding_p (rtx *, machine_mode, bool);\n-extern bool loongarch_split_symbol_type (enum loongarch_symbol_type);\n \n typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);\n "}, {"sha": "1cb5742f6dd8738b86e8591d42290c8d38750075", "filename": "gcc/config/loongarch/loongarch.cc", "status": "modified", "additions": 109, "deletions": 147, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.cc?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -114,19 +114,7 @@ enum loongarch_address_type\n };\n \n \n-/* Information about an address described by loongarch_address_type.\n-\n-   ADDRESS_CONST_INT\n-       No fields are used.\n-\n-   ADDRESS_REG\n-       REG is the base register and OFFSET is the constant offset.\n-\n-   ADDRESS_REG_REG\n-       A base register indexed by (optionally scaled) register.\n-\n-   ADDRESS_SYMBOLIC\n-       SYMBOL_TYPE is the type of symbol that the address references.  */\n+/* Information about an address described by loongarch_address_type.  */\n struct loongarch_address_info\n {\n   enum loongarch_address_type type;\n@@ -1617,11 +1605,12 @@ loongarch_weak_symbol_p (const_rtx x)\n bool\n loongarch_symbol_binds_local_p (const_rtx x)\n {\n-  if (LABEL_REF_P (x))\n+  if (SYMBOL_REF_P (x))\n+    return (SYMBOL_REF_DECL (x)\n+\t    ? targetm.binds_local_p (SYMBOL_REF_DECL (x))\n+\t    : SYMBOL_REF_LOCAL_P (x));\n+  else\n     return false;\n-\n-  return (SYMBOL_REF_DECL (x) ? targetm.binds_local_p (SYMBOL_REF_DECL (x))\n-\t\t\t      : SYMBOL_REF_LOCAL_P (x));\n }\n \n /* Return true if rtx constants of mode MODE should be put into a small\n@@ -1640,17 +1629,16 @@ static enum loongarch_symbol_type\n loongarch_classify_symbol (const_rtx x)\n {\n   if (LABEL_REF_P (x))\n-    return SYMBOL_GOT_DISP;\n-\n-  gcc_assert (SYMBOL_REF_P (x));\n+    return SYMBOL_PCREL;\n \n   if (SYMBOL_REF_TLS_MODEL (x))\n     return SYMBOL_TLS;\n \n-  if (SYMBOL_REF_P (x))\n+  if (SYMBOL_REF_P (x)\n+      && !loongarch_symbol_binds_local_p (x))\n     return SYMBOL_GOT_DISP;\n \n-  return SYMBOL_GOT_DISP;\n+  return SYMBOL_PCREL;\n }\n \n /* Return true if X is a symbolic constant.  If it is,\n@@ -1683,9 +1671,15 @@ loongarch_symbolic_constant_p (rtx x, enum loongarch_symbol_type *symbol_type)\n      relocations.  */\n   switch (*symbol_type)\n     {\n-    case SYMBOL_GOT_DISP:\n+    case SYMBOL_TLS_IE:\n+    case SYMBOL_TLS_LE:\n     case SYMBOL_TLSGD:\n     case SYMBOL_TLSLDM:\n+    case SYMBOL_PCREL:\n+      /* GAS rejects offsets outside the range [-2^31, 2^31-1].  */\n+      return sext_hwi (INTVAL (offset), 32) == INTVAL (offset);\n+\n+    case SYMBOL_GOT_DISP:\n     case SYMBOL_TLS:\n       return false;\n     }\n@@ -1707,9 +1701,14 @@ loongarch_symbol_insns (enum loongarch_symbol_type type, machine_mode mode)\n \n       return 3;\n \n+    case SYMBOL_PCREL:\n+    case SYMBOL_TLS_IE:\n+    case SYMBOL_TLS_LE:\n+      return 2;\n+\n     case SYMBOL_TLSGD:\n     case SYMBOL_TLSLDM:\n-      return 1;\n+      return 3;\n \n     case SYMBOL_TLS:\n       /* We don't treat a bare TLS symbol as a constant.  */\n@@ -1937,11 +1936,7 @@ loongarch_address_insns (rtx x, machine_mode mode, bool might_split_p)\n     switch (addr.type)\n       {\n       case ADDRESS_REG:\n-\treturn factor;\n-\n       case ADDRESS_REG_REG:\n-\treturn factor;\n-\n       case ADDRESS_CONST_INT:\n \treturn factor;\n \n@@ -1983,7 +1978,7 @@ loongarch_12bit_offset_address_p (rtx x, machine_mode mode)\n   return (loongarch_classify_address (&addr, x, mode, false)\n \t  && addr.type == ADDRESS_REG\n \t  && CONST_INT_P (addr.offset)\n-\t  && LARCH_U12BIT_OFFSET_P (INTVAL (addr.offset)));\n+\t  && LARCH_12BIT_OFFSET_P (INTVAL (addr.offset)));\n }\n \n /* Return true if X is a legitimate address with a 14-bit offset shifted 2.\n@@ -2001,6 +1996,9 @@ loongarch_14bit_shifted_offset_address_p (rtx x, machine_mode mode)\n \t  && LARCH_SHIFT_2_OFFSET_P (INTVAL (addr.offset)));\n }\n \n+/* Return true if X is a legitimate address with base and index.\n+   MODE is the mode of the value being accessed.  */\n+\n bool\n loongarch_base_index_address_p (rtx x, machine_mode mode)\n {\n@@ -2310,7 +2308,7 @@ loongarch_call_tls_get_addr (rtx sym, enum loongarch_symbol_type type, rtx v0)\n \n /* Generate the code to access LOC, a thread-local SYMBOL_REF, and return\n    its address.  The return value will be both a valid address and a valid\n-   SET_SRC (either a REG or a LO_SUM).  */\n+   SET_SRC.  */\n \n static rtx\n loongarch_legitimize_tls_address (rtx loc)\n@@ -2336,7 +2334,7 @@ loongarch_legitimize_tls_address (rtx loc)\n       break;\n \n     case TLS_MODEL_INITIAL_EXEC:\n-      /* la.tls.ie; tp-relative add  */\n+      /* la.tls.ie; tp-relative add.  */\n       tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);\n       tmp = gen_reg_rtx (Pmode);\n       emit_insn (loongarch_got_load_tls_ie (tmp, loc));\n@@ -2345,7 +2343,7 @@ loongarch_legitimize_tls_address (rtx loc)\n       break;\n \n     case TLS_MODEL_LOCAL_EXEC:\n-      /* la.tls.le; tp-relative add  */\n+      /* la.tls.le; tp-relative add.  */\n       tp = gen_rtx_REG (Pmode, THREAD_POINTER_REGNUM);\n       tmp = gen_reg_rtx (Pmode);\n       emit_insn (loongarch_got_load_tls_le (tmp, loc));\n@@ -3371,6 +3369,7 @@ loongarch_output_move (rtx dest, rtx src)\n \t    case 2:\n \t      return \"st.h\\t%z1,%0\";\n \t    case 4:\n+\t      /* Matching address type with a 12bit offset.  */\n \t      if (const_arith_operand (offset, Pmode))\n \t\treturn \"st.w\\t%z1,%0\";\n \t      else\n@@ -3409,6 +3408,7 @@ loongarch_output_move (rtx dest, rtx src)\n \t    case 2:\n \t      return \"ld.hu\\t%0,%1\";\n \t    case 4:\n+\t      /* Matching address type with a 12bit offset.  */\n \t      if (const_arith_operand (offset, Pmode))\n \t\treturn \"ld.w\\t%0,%1\";\n \t      else\n@@ -3436,56 +3436,16 @@ loongarch_output_move (rtx dest, rtx src)\n \t  else\n \t    gcc_unreachable ();\n \t}\n+    }\n \n-      if (symbolic_operand (src, VOIDmode))\n-\t{\n-\t  if ((TARGET_CMODEL_TINY && (!loongarch_global_symbol_p (src)\n-\t\t\t\t      || loongarch_symbol_binds_local_p (src)))\n-\t      || (TARGET_CMODEL_TINY_STATIC && !loongarch_weak_symbol_p (src)))\n-\t    {\n-\t      /* The symbol must be aligned to 4 byte.  */\n-\t      unsigned int align;\n-\n-\t      if (LABEL_REF_P (src))\n-\t\talign = 32 /* Whatever.  */;\n-\t      else if (CONSTANT_POOL_ADDRESS_P (src))\n-\t\talign = GET_MODE_ALIGNMENT (get_pool_mode (src));\n-\t      else if (TREE_CONSTANT_POOL_ADDRESS_P (src))\n-\t\t{\n-\t\t  tree exp = SYMBOL_REF_DECL (src);\n-\t\t  align = TYPE_ALIGN (TREE_TYPE (exp));\n-\t\t  align = loongarch_constant_alignment (exp, align);\n-\t\t}\n-\t      else if (SYMBOL_REF_DECL (src))\n-\t\talign = DECL_ALIGN (SYMBOL_REF_DECL (src));\n-\t      else if (SYMBOL_REF_HAS_BLOCK_INFO_P (src)\n-\t\t       && SYMBOL_REF_BLOCK (src) != NULL)\n-\t\talign = SYMBOL_REF_BLOCK (src)->alignment;\n-\t      else\n-\t\talign = BITS_PER_UNIT;\n-\n-\t      if (align % (4 * 8) == 0)\n-\t\treturn \"pcaddi\\t%0,%%pcrel(%1)>>2\";\n-\t    }\n-\t  if (TARGET_CMODEL_TINY\n-\t      || TARGET_CMODEL_TINY_STATIC\n-\t      || TARGET_CMODEL_NORMAL\n-\t      || TARGET_CMODEL_LARGE)\n-\t    {\n-\t      if (!loongarch_global_symbol_p (src)\n-\t\t  || loongarch_symbol_binds_local_p (src))\n-\t\treturn \"la.local\\t%0,%1\";\n-\t      else\n-\t\treturn \"la.global\\t%0,%1\";\n-\t    }\n-\t  if (TARGET_CMODEL_EXTREME)\n-\t    {\n-\t      sorry (\"Normal symbol loading not implemented in extreme mode.\");\n-\t      gcc_unreachable ();\n-\t    }\n-\n-\t}\n+  if (dest_code == REG && symbolic_operand (src, VOIDmode))\n+    {\n+      if (loongarch_classify_symbol (src) == SYMBOL_PCREL)\n+\treturn \"la.local\\t%0,%1\";\n+      else\n+\treturn \"la.global\\t%0,%1\";\n     }\n+\n   if (src_code == REG && FP_REG_P (REGNO (src)))\n     {\n       if (dest_code == REG && FP_REG_P (REGNO (dest)))\n@@ -3503,6 +3463,7 @@ loongarch_output_move (rtx dest, rtx src)\n \t  return dbl_p ? \"fst.d\\t%1,%0\" : \"fst.s\\t%1,%0\";\n \t}\n     }\n+\n   if (dest_code == REG && FP_REG_P (REGNO (dest)))\n     {\n       if (src_code == MEM)\n@@ -3517,6 +3478,7 @@ loongarch_output_move (rtx dest, rtx src)\n \t  return dbl_p ? \"fld.d\\t%0,%1\" : \"fld.s\\t%0,%1\";\n \t}\n     }\n+\n   gcc_unreachable ();\n }\n \n@@ -4347,27 +4309,27 @@ loongarch_memmodel_needs_release_fence (enum memmodel model)\n \n /* Implement TARGET_PRINT_OPERAND.  The LoongArch-specific operand codes are:\n \n-   'X'\tPrint CONST_INT OP in hexadecimal format.\n-   'x'\tPrint the low 16 bits of CONST_INT OP in hexadecimal format.\n+   'A'\tPrint a _DB suffix if the memory model requires a release.\n+   'b'\tPrint the address of a memory operand, without offset.\n+   'C'\tPrint the integer branch condition for comparison OP.\n    'd'\tPrint CONST_INT OP in decimal.\n+   'F'\tPrint the FPU branch condition for comparison OP.\n+   'G'\tPrint a DBAR insn if the memory model requires a release.\n+   'i'\tPrint i if the operand is not a register.\n    'm'\tPrint one less than CONST_INT OP in decimal.\n-   'y'\tPrint exact log2 of CONST_INT OP in decimal.\n-   'C'\tPrint the integer branch condition for comparison OP.\n    'N'\tPrint the inverse of the integer branch condition for comparison OP.\n-   'F'\tPrint the FPU branch condition for comparison OP.\n-   'W'\tPrint the inverse of the FPU branch condition for comparison OP.\n    'T'\tPrint 'f' for (eq:CC ...), 't' for (ne:CC ...),\n \t      'z' for (eq:?I ...), 'n' for (ne:?I ...).\n    't'\tLike 'T', but with the EQ/NE cases reversed\n-   'Y'\tPrint loongarch_fp_conditions[INTVAL (OP)]\n-   'Z'\tPrint OP and a comma for 8CC, otherwise print nothing.\n-   'z'\tPrint $0 if OP is zero, otherwise print OP normally.\n-   'b'\tPrint the address of a memory operand, without offset.\n    'V'\tPrint exact log2 of CONST_INT OP element 0 of a replicated\n \t  CONST_VECTOR in decimal.\n-   'A'\tPrint a _DB suffix if the memory model requires a release.\n-   'G'\tPrint a DBAR insn if the memory model requires a release.\n-   'i'\tPrint i if the operand is not a register.  */\n+   'W'\tPrint the inverse of the FPU branch condition for comparison OP.\n+   'X'\tPrint CONST_INT OP in hexadecimal format.\n+   'x'\tPrint the low 16 bits of CONST_INT OP in hexadecimal format.\n+   'Y'\tPrint loongarch_fp_conditions[INTVAL (OP)]\n+   'y'\tPrint exact log2 of CONST_INT OP in decimal.\n+   'Z'\tPrint OP and a comma for 8CC, otherwise print nothing.\n+   'z'\tPrint $0 if OP is zero, otherwise print OP normally.  */\n \n static void\n loongarch_print_operand (FILE *file, rtx op, int letter)\n@@ -4385,18 +4347,13 @@ loongarch_print_operand (FILE *file, rtx op, int letter)\n \n   switch (letter)\n     {\n-    case 'X':\n-      if (CONST_INT_P (op))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));\n-      else\n-\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+    case 'A':\n+      if (loongarch_memmodel_needs_rel_acq_fence ((enum memmodel) INTVAL (op)))\n+       fputs (\"_db\", file);\n       break;\n \n-    case 'x':\n-      if (CONST_INT_P (op))\n-\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op) & 0xffff);\n-      else\n-\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+    case 'C':\n+      loongarch_print_int_branch_condition (file, code, letter);\n       break;\n \n     case 'd':\n@@ -4406,24 +4363,38 @@ loongarch_print_operand (FILE *file, rtx op, int letter)\n \toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n+    case 'F':\n+      loongarch_print_float_branch_condition (file, code, letter);\n+      break;\n+\n+    case 'G':\n+      if (loongarch_memmodel_needs_release_fence ((enum memmodel) INTVAL (op)))\n+\tfputs (\"dbar\\t0\", file);\n+      break;\n+\n+    case 'i':\n+      if (code != REG)\n+\tfputs (\"i\", file);\n+      break;\n+\n     case 'm':\n       if (CONST_INT_P (op))\n \tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (op) - 1);\n       else\n \toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n-    case 'y':\n-      if (CONST_INT_P (op))\n-\t{\n-\t  int val = exact_log2 (INTVAL (op));\n-\t  if (val != -1)\n-\t    fprintf (file, \"%d\", val);\n-\t  else\n-\t    output_operand_lossage (\"invalid use of '%%%c'\", letter);\n-\t}\n-      else\n-\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n+    case 'N':\n+      loongarch_print_int_branch_condition (file, reverse_condition (code),\n+\t\t\t\t\t    letter);\n+      break;\n+\n+    case 't':\n+    case 'T':\n+      {\n+\tint truth = (code == NE) == (letter == 'T');\n+\tfputc (\"zfnt\"[truth * 2 + FCC_REG_P (REGNO (XEXP (op, 0)))], file);\n+      }\n       break;\n \n     case 'V':\n@@ -4441,30 +4412,36 @@ loongarch_print_operand (FILE *file, rtx op, int letter)\n \toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n-    case 'C':\n-      loongarch_print_int_branch_condition (file, code, letter);\n-      break;\n-\n-    case 'N':\n-      loongarch_print_int_branch_condition (file, reverse_condition (code),\n-\t\t\t\t\t    letter);\n+    case 'W':\n+      loongarch_print_float_branch_condition (file, reverse_condition (code),\n+\t\t\t\t\t      letter);\n       break;\n \n-    case 'F':\n-      loongarch_print_float_branch_condition (file, code, letter);\n+    case 'x':\n+      if (CONST_INT_P (op))\n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op) & 0xffff);\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n-    case 'W':\n-      loongarch_print_float_branch_condition (file, reverse_condition (code),\n-\t\t\t\t\t      letter);\n+    case 'X':\n+      if (CONST_INT_P (op))\n+\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (op));\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n-    case 'T':\n-    case 't':\n-      {\n-\tint truth = (code == NE) == (letter == 'T');\n-\tfputc (\"zfnt\"[truth * 2 + FCC_REG_P (REGNO (XEXP (op, 0)))], file);\n-      }\n+    case 'y':\n+      if (CONST_INT_P (op))\n+\t{\n+\t  int val = exact_log2 (INTVAL (op));\n+\t  if (val != -1)\n+\t    fprintf (file, \"%d\", val);\n+\t  else\n+\t    output_operand_lossage (\"invalid use of '%%%c'\", letter);\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid use of '%%%c'\", letter);\n       break;\n \n     case 'Y':\n@@ -4481,21 +4458,6 @@ loongarch_print_operand (FILE *file, rtx op, int letter)\n       fputc (',', file);\n       break;\n \n-    case 'A':\n-      if (loongarch_memmodel_needs_rel_acq_fence ((enum memmodel) INTVAL (op)))\n-\tfputs (\"_db\", file);\n-      break;\n-\n-    case 'G':\n-      if (loongarch_memmodel_needs_release_fence ((enum memmodel) INTVAL (op)))\n-\tfputs (\"dbar\\t0\", file);\n-      break;\n-\n-    case 'i':\n-      if (code != REG)\n-\tfputs (\"i\", file);\n-      break;\n-\n     default:\n       switch (code)\n \t{"}, {"sha": "89a5bd728feeab48300072be576d3d2bb98d0678", "filename": "gcc/config/loongarch/loongarch.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.h?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -614,7 +614,7 @@ enum reg_class\n #define LU12I_INT(X) LU12I_OPERAND (INTVAL (X))\n #define LU32I_INT(X) LU32I_OPERAND (INTVAL (X))\n #define LU52I_INT(X) LU52I_OPERAND (INTVAL (X))\n-#define LARCH_U12BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -2048, 2047))\n+#define LARCH_12BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -2048, 2047))\n #define LARCH_9BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -256, 255))\n #define LARCH_16BIT_OFFSET_P(OFFSET) (IN_RANGE (OFFSET, -32768, 32767))\n #define LARCH_SHIFT_2_OFFSET_P(OFFSET) (((OFFSET) & 0x3) == 0)"}, {"sha": "376879fbccbf3c772b8da428dea67d0d746d57fe", "filename": "gcc/config/loongarch/loongarch.md", "status": "modified", "additions": 36, "deletions": 243, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Floongarch.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Floongarch.md?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -2844,48 +2844,14 @@\n })\n \n (define_insn \"sibcall_internal\"\n-  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"j,c,a,t,h\"))\n+  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"j,c,b\"))\n \t (match_operand 1 \"\" \"\"))]\n   \"SIBLING_CALL_P (insn)\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"jr\\t%0\";\n-    case 1:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r12,(%%pcrel(%0+0x20000))>>18\\n\\t\"\n-\t       \"jirl\\t$r0,$r12,%%pcrel(%0+4)-(%%pcrel(%0+4+0x20000)>>18<<18)\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.local\\t$r12,$r13,%0\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"b\\t%0\";\n-    case 2:\n-      if (TARGET_CMODEL_TINY_STATIC)\n-\treturn \"b\\t%0\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r12,$r13,%0\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"la.global\\t$r12,%0\\n\\tjr\\t$r12\";\n-    case 3:\n-      if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r12,$r13,%0\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"la.global\\t$r12,%0\\n\\tjr\\t$r12\";\n-    case 4:\n-      if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)\n-\treturn \"b\\t%%plt(%0)\";\n-      else if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r12,(%%plt(%0)+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r0,$r12,%%plt(%0)+4-((%%plt(%0)+(4+0x20000))>>18<<18)\";\n-      else\n-\t/* Cmodel extreme and tiny static not support plt.  */\n-\tgcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"jirl\" \"indirect,direct,direct,direct,direct\")])\n+  \"@\n+   jr\\t%0\n+   b\\t%0\n+   b\\t%%plt(%0)\"\n+  [(set_attr \"jirl\" \"indirect,direct,direct\")])\n \n (define_expand \"sibcall_value\"\n   [(parallel [(set (match_operand 0 \"\")\n@@ -2920,96 +2886,28 @@\n \n (define_insn \"sibcall_value_internal\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,c,a,t,h\"))\n+\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,c,b\"))\n \t      (match_operand 2 \"\" \"\")))]\n   \"SIBLING_CALL_P (insn)\"\n-{\n-  switch (which_alternative)\n-  {\n-    case 0:\n-      return \"jr\\t%1\";\n-    case 1:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r12,%%pcrel(%1+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r0,$r12,%%pcrel(%1+4)-((%%pcrel(%1+4+0x20000))>>18<<18)\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.local\\t$r12,$r13,%1\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"b\\t%1\";\n-    case 2:\n-      if (TARGET_CMODEL_TINY_STATIC)\n-\treturn \"b\\t%1\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r12,$r13,%1\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"la.global\\t$r12,%1\\n\\tjr\\t$r12\";\n-    case 3:\n-      if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r12,$r13,%1\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"la.global\\t$r12,%1\\n\\tjr\\t$r12\";\n-    case 4:\n-      if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)\n-\treturn \" b\\t%%plt(%1)\";\n-      else if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r12,(%%plt(%1)+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r0,$r12,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)\";\n-      else\n-\t/* Cmodel extreme and tiny static not support plt.  */\n-\tgcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-  }\n-}\n-  [(set_attr \"jirl\" \"indirect,direct,direct,direct,direct\")])\n+  \"@\n+   jr\\t%1\n+   b\\t%1\n+   b\\t%%plt(%1)\"\n+  [(set_attr \"jirl\" \"indirect,direct,direct\")])\n \n (define_insn \"sibcall_value_multiple_internal\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,c,a,t,h\"))\n+\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"j,c,b\"))\n \t      (match_operand 2 \"\" \"\")))\n    (set (match_operand 3 \"register_operand\" \"\")\n \t(call (mem:SI (match_dup 1))\n \t      (match_dup 2)))]\n   \"SIBLING_CALL_P (insn)\"\n-{\n-  switch (which_alternative)\n-  {\n-    case 0:\n-      return \"jr\\t%1\";\n-    case 1:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r12,%%pcrel(%1+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r0,$r12,%%pcrel(%1+4)-(%%pcrel(%1+4+0x20000)>>18<<18)\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.local\\t$r12,$r13,%1\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"b\\t%1\";\n-    case 2:\n-      if (TARGET_CMODEL_TINY_STATIC)\n-\treturn \"b\\t%1\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r12,$r13,%1\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"la.global\\t$r12,%1\\n\\tjr\\t$r12\";\n-    case 3:\n-      if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r12,$r13,%1\\n\\tjr\\t$r12\";\n-      else\n-\treturn \"la.global\\t$r12,%1\\n\\tjr\\t$r12\";\n-    case 4:\n-      if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)\n-\treturn \"b\\t%%plt(%1)\";\n-      else if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r12,(%%plt(%1)+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r0,$r12,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)\";\n-      else\n-\t/* Cmodel extreme and tiny static not support plt.  */\n-\tgcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-  }\n-}\n-  [(set_attr \"jirl\" \"indirect,direct,direct,direct,direct\")])\n+  \"@\n+   jr\\t%1\n+   b\\t%1\n+   b\\t%%plt(%1)\"\n+  [(set_attr \"jirl\" \"indirect,direct,direct\")])\n \n (define_expand \"call\"\n   [(parallel [(call (match_operand 0 \"\")\n@@ -3025,50 +2923,15 @@\n })\n \n (define_insn \"call_internal\"\n-  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"e,c,a,t,h\"))\n+  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"e,c,b\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI RETURN_ADDR_REGNUM))]\n   \"\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"jirl\\t$r1,%0,0\";\n-    case 1:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r1,%%pcrel(%0+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r1,$r1,%%pcrel(%0+4)-(%%pcrel(%0+4+0x20000)>>18<<18)\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.local\\t$r1,$r12,%0\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"bl\\t%0\";\n-    case 2:\n-      if (TARGET_CMODEL_TINY_STATIC)\n-\treturn \"bl\\t%0\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r1,$r12,%0\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"la.global\\t$r1,%0\\n\\tjirl\\t$r1,$r1,0\";\n-    case 3:\n-      if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r1,$r12,%0\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"la.global\\t$r1,%0\\n\\tjirl\\t$r1,$r1,0\";\n-    case 4:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r1,(%%plt(%0)+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r1,$r1,%%plt(%0)+4-((%%plt(%0)+(4+0x20000))>>18<<18)\";\n-      else if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)\n-\treturn \"bl\\t%%plt(%0)\";\n-      else\n-\t/* Cmodel extreme and tiny static not support plt.  */\n-\tgcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"jirl\" \"indirect,direct,direct,direct,direct\")\n-   (set_attr \"insn_count\" \"1,2,3,3,2\")])\n+  \"@\n+   jirl\\t$r1,%0,0\n+   bl\\t%0\n+   bl\\t%%plt(%0)\"\n+  [(set_attr \"jirl\" \"indirect,direct,direct\")])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\")\n@@ -3101,100 +2964,30 @@\n \n (define_insn \"call_value_internal\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"e,c,a,t,h\"))\n+\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"e,c,b\"))\n \t      (match_operand 2 \"\" \"\")))\n    (clobber (reg:SI RETURN_ADDR_REGNUM))]\n   \"\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"jirl\\t$r1,%1,0\";\n-    case 1:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r1,%%pcrel(%1+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r1,$r1,%%pcrel(%1+4)-(%%pcrel(%1+4+0x20000)>>18<<18)\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.local\\t$r1,$r12,%1\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"bl\\t%1\";\n-    case 2:\n-      if (TARGET_CMODEL_TINY_STATIC)\n-\treturn \"bl\\t%1\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r1,$r12,%1\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"la.global\\t$r1,%1\\n\\tjirl\\t$r1,$r1,0\";\n-    case 3:\n-      if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r1,$r12,%1\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"la.global\\t$r1,%1\\n\\tjirl\\t$r1,$r1,0\";\n-    case 4:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r1,(%%plt(%1)+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r1,$r1,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)\";\n-      else if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)\n-\treturn \"bl\\t%%plt(%1)\";\n-      else\n-\t/* Cmodel extreme and tiny static not support plt.  */\n-\tgcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"jirl\" \"indirect,direct,direct,direct,direct\")\n-   (set_attr \"insn_count\" \"1,2,3,3,2\")])\n+  \"@\n+   jirl\\t$r1,%1,0\n+   bl\\t%1\n+   bl\\t%%plt(%1)\"\n+  [(set_attr \"jirl\" \"indirect,direct,direct\")])\n \n (define_insn \"call_value_multiple_internal\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"e,c,a,t,h\"))\n+\t(call (mem:SI (match_operand 1 \"call_insn_operand\" \"e,c,b\"))\n \t      (match_operand 2 \"\" \"\")))\n    (set (match_operand 3 \"register_operand\" \"\")\n \t(call (mem:SI (match_dup 1))\n \t      (match_dup 2)))\n    (clobber (reg:SI RETURN_ADDR_REGNUM))]\n   \"\"\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"jirl\\t$r1,%1,0\";\n-    case 1:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r1,%%pcrel(%1+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r1,$r1,%%pcrel(%1+4)-(%%pcrel(%1+4+0x20000)>>18<<18)\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.local\\t$r1,$r12,%1\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"bl\\t%1\";\n-    case 2:\n-      if (TARGET_CMODEL_TINY_STATIC)\n-\treturn \"bl\\t%1\";\n-      else if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r1,$r12,%1\\n\\tjirl\\t$r1,$r1,0 \";\n-      else\n-\treturn \"la.global\\t$r1,%1\\n\\tjirl\\t$r1,$r1,0\";\n-    case 3:\n-      if (TARGET_CMODEL_EXTREME)\n-\treturn \"la.global\\t$r1,$r12,%1\\n\\tjirl\\t$r1,$r1,0\";\n-      else\n-\treturn \"la.global\\t$r1,%1\\n\\tjirl\\t$r1,$r1,0\";\n-    case 4:\n-      if (TARGET_CMODEL_LARGE)\n-\treturn \"pcaddu18i\\t$r1,(%%plt(%1)+0x20000)>>18\\n\\t\"\n-\t       \"jirl\\t$r1,$r1,%%plt(%1)+4-((%%plt(%1)+(4+0x20000))>>18<<18)\";\n-      else if (TARGET_CMODEL_NORMAL || TARGET_CMODEL_TINY)\n-\treturn \"bl\\t%%plt(%1)\";\n-      else\n-\t/* Cmodel extreme and tiny static not support plt.  */\n-\tgcc_unreachable ();\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"jirl\" \"indirect,direct,direct,direct,direct\")\n-   (set_attr \"insn_count\" \"1,2,3,3,2\")])\n+  \"@\n+   jirl\\t$r1,%1,0\n+   bl\\t%1\n+   bl\\t%%plt(%1)\"\n+  [(set_attr \"jirl\" \"indirect,direct,direct\")])\n \n \n ;; Call subroutine returning any type."}, {"sha": "2243ef71c1ad3431575da6ec4fa93d1f1b5689f9", "filename": "gcc/config/loongarch/predicates.md", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Fconfig%2Floongarch%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Fpredicates.md?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -111,20 +111,25 @@\n   (match_code \"const,symbol_ref,label_ref\")\n {\n   enum loongarch_symbol_type symbol_type;\n+  loongarch_symbolic_constant_p (op, &symbol_type);\n \n-  if (!loongarch_symbolic_constant_p (op, &symbol_type))\n+  rtx offset, x = op;\n+  split_const (x, &x, &offset);\n+\n+  if (offset != const0_rtx)\n     return false;\n \n   switch (symbol_type)\n     {\n-    case SYMBOL_GOT_DISP:\n-      /* Without explicit relocs, there is no special syntax for\n-\t loading the address of a call destination into a register.\n-\t Using \"la.global JIRL_REGS,foo; jirl JIRL_REGS\" would prevent the lazy\n-\t binding of \"foo\", so keep the address of global symbols with the jirl\n-\t macro.  */\n+    case SYMBOL_PCREL:\n       return 1;\n \n+    case SYMBOL_GOT_DISP:\n+      if (!flag_plt)\n+\treturn false;\n+      else\n+\treturn 1;\n+\n     default:\n       return false;\n     }\n@@ -140,22 +145,11 @@\n \t    (match_test \"loongarch_symbol_binds_local_p (op) != 0\"))\n        (match_test \"CONSTANT_P (op)\")))\n \n-(define_predicate \"is_const_call_weak_symbol\"\n-  (and (match_operand 0 \"const_call_insn_operand\")\n-       (not (match_operand 0 \"is_const_call_local_symbol\"))\n-       (match_test \"loongarch_weak_symbol_p (op) != 0\")\n-       (match_test \"CONSTANT_P (op)\")))\n-\n-(define_predicate \"is_const_call_plt_symbol\"\n-  (and (match_operand 0 \"const_call_insn_operand\")\n-       (match_test \"flag_plt != 0\")\n-       (match_test \"loongarch_global_symbol_noweak_p (op) != 0\")\n-       (match_test \"CONSTANT_P (op)\")))\n-\n-(define_predicate \"is_const_call_global_noplt_symbol\"\n+(define_predicate \"is_const_call_no_local_symbol\"\n   (and (match_operand 0 \"const_call_insn_operand\")\n-       (match_test \"flag_plt == 0\")\n-       (match_test \"loongarch_global_symbol_noweak_p (op) != 0\")\n+       (ior (match_test \"loongarch_global_symbol_p (op) != 0\")\n+\t    (match_test \"loongarch_symbol_binds_local_p (op) == 0\")\n+       (match_test \"loongarch_weak_symbol_p (op) != 0\"))\n        (match_test \"CONSTANT_P (op)\")))\n \n ;; A legitimate CONST_INT operand that takes more than one instruction\n@@ -219,7 +213,7 @@\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n-      return (loongarch_symbolic_constant_p (op, &symbol_type));\n+      return loongarch_symbolic_constant_p (op, &symbol_type);\n     default:\n       return true;\n     }"}, {"sha": "b0482761aab71143b3dea83a5eb586962b8fb6f1", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-1.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-1.c?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fpic -fplt\" } */\n+/* { dg-final { scan-assembler \"test:.*bl\\t%plt\\\\(g\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"test1:.*bl\\t%plt\\\\(f\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "f5e061c299cb294ce819d23c134ffd9a3c4c0ec8", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-2.c?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fplt\" } */\n+/* { dg-final { scan-assembler \"test:.*bl\\t%plt\\\\(g\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"test1:.*bl\\tf\\n\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "75082c57466eadcf77f4506f416f7d0ec1d42d0f", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-3.c?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fpic -fno-plt\" } */\n+/* { dg-final { scan-assembler \"test:.*la\\.global\\t.*g\\n\\tjirl\" } } */\n+/* { dg-final { scan-assembler \"test1:.*la\\.global\\t.*f\\n\\tjirl\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}, {"sha": "e8a8395493e33291db274201376ccb791131bd90", "filename": "gcc/testsuite/gcc.target/loongarch/func-call-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e401fb1452d6a9504e23d76d072a89fd2ba379/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Floongarch%2Ffunc-call-4.c?ref=d5e401fb1452d6a9504e23d76d072a89fd2ba379", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mabi=lp64d -O0 -fno-pic -fno-plt\" } */\n+/* { dg-final { scan-assembler \"test:.*la\\.global\\t.*g\\n\\tjirl\" } } */\n+/* { dg-final { scan-assembler \"test1:.*bl\\tf\\n\" } } */\n+/* { dg-final { scan-assembler \"test2:.*bl\\tl\\n\" } } */\n+\n+extern void g (void);\n+void\n+f (void)\n+{}\n+\n+static void\n+l (void)\n+{}\n+\n+void\n+test (void)\n+{\n+  g ();\n+}\n+\n+void\n+test1 (void)\n+{\n+  f ();\n+}\n+\n+void\n+test2 (void)\n+{\n+  l ();\n+}"}]}