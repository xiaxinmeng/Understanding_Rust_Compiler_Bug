{"sha": "ed3cf9539b38d56097601dd56acd1433931ed603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQzY2Y5NTM5YjM4ZDU2MDk3NjAxZGQ1NmFjZDE0MzM5MzFlZDYwMw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-03-30T16:00:39Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-03-30T16:00:39Z"}, "message": "cp-tree.h (binding_for_name): Move to name-lookup.h Adjust prototype.\n\n\t* cp-tree.h (binding_for_name: Move to name-lookup.h  Adjust\n\tprototype.\n\t(cxx_scope_find_binding_for_name): Likewise.\n\t* decl.c (find_binding: Move to name-lookup.c.\n\t(binding_for_name): Likewise.\n\t(cxx_scope_find_binding_for_name): Likewise.\n\t(BINDING_LEVEL):  Remove.\n\t(push_binding): Tidy.\n\t(push_class_binding): Likewise.\n\t(pop_binding): Likewise.\n\t(poplevel): Likewise.\n\t(poplevel_class): Likewise.\n\t(set_identifier_type_value_with_scope): Likewise.\n\t(push_overloaded_decl): Likewise.\n\t(lookup_tag): Likewise.\n\t(unqualified_namespace_lookup): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(maybe_inject_for_scope_var): Likewise.\n\t(namespace_binding): Move to name-lookup.c.\n\t(set_namespace_binding): Likewise.\n\t* decl2.c (lookup_using_namespace): Tidy.\n\t(qualified_lookup_using_namespace): Likewise.\n\t(do_toplevel_using_decl): Likewise.\n\t* name-lookup.c: Include \"timevar.h\"\n\t* name-lookup.h (cxx_scope):  Declare.\n\t(struct cxx_binding): Lose member \"has_level\".  Adjust \"scope\"\n\tmember declaration.\n\t(BINDING_SCOPE): Adjust definition.\n\t(BINDING_HAS_LEVEL_P): Remove.\n\nFrom-SVN: r65044", "tree": {"sha": "c2091d7753669f96b0193d11c08e165c9103f777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2091d7753669f96b0193d11c08e165c9103f777"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed3cf9539b38d56097601dd56acd1433931ed603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3cf9539b38d56097601dd56acd1433931ed603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed3cf9539b38d56097601dd56acd1433931ed603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed3cf9539b38d56097601dd56acd1433931ed603/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9a8075a164b4bd63e39b7ab3bda9d1958187f3c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8075a164b4bd63e39b7ab3bda9d1958187f3c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a8075a164b4bd63e39b7ab3bda9d1958187f3c5"}], "stats": {"total": 312, "additions": 162, "deletions": 150}, "files": [{"sha": "159697f7325180bfd62955c145f51a0a324e2584", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ed3cf9539b38d56097601dd56acd1433931ed603", "patch": "@@ -1,3 +1,35 @@\n+2003-03-30  Gabriel Dos Reis <gdr@integrable-solutions.net>\n+\n+\t* cp-tree.h (binding_for_name: Move to name-lookup.h  Adjust\n+\tprototype. \n+\t(cxx_scope_find_binding_for_name): Likewise.\n+\t* decl.c (find_binding: Move to name-lookup.c.\n+\t(binding_for_name): Likewise.\n+\t(cxx_scope_find_binding_for_name): Likewise.\n+\t(BINDING_LEVEL):  Remove.\n+\t(push_binding): Tidy.\n+\t(push_class_binding): Likewise.\n+\t(pop_binding): Likewise.\n+\t(poplevel): Likewise.\n+\t(poplevel_class): Likewise.\n+\t(set_identifier_type_value_with_scope): Likewise.\n+\t(push_overloaded_decl): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(maybe_inject_for_scope_var): Likewise.\n+\t(namespace_binding): Move to name-lookup.c.\n+\t(set_namespace_binding): Likewise.\n+\t* decl2.c (lookup_using_namespace): Tidy.\n+\t(qualified_lookup_using_namespace): Likewise.\n+\t(do_toplevel_using_decl): Likewise.\n+\t* name-lookup.c: Include \"timevar.h\"\n+\t* name-lookup.h (cxx_scope):  Declare.\n+\t(struct cxx_binding): Lose member \"has_level\".  Adjust \"scope\"\n+\tmember declaration.\n+\t(BINDING_SCOPE): Adjust definition.\n+\t(BINDING_HAS_LEVEL_P): Remove.\n+\n 2003-03-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* name-lookup.c: New file."}, {"sha": "a9692fe2842066f2a9268784e89a1182c5ae8576", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ed3cf9539b38d56097601dd56acd1433931ed603", "patch": "@@ -380,8 +380,8 @@ struct tree_srcloc GTY(())\n     BINDING_VALUE is a DECL for the associated declaration.  Thus,\n     name lookup consists simply of pulling off the node at the front\n     of the list (modulo oddities for looking up the names of types,\n-    and such.)  You can use BINDING_SCOPE or BINDING_LEVEL to\n-    determine the scope that bound the name.  */\n+    and such.)  You can use BINDING_SCOPE to determine the scope\n+    that bound the name.  */\n #define IDENTIFIER_BINDING(NODE) \\\n   (LANG_IDENTIFIER_CAST (NODE)->bindings)\n \n@@ -3663,7 +3663,6 @@ extern tree declare_local_label                 (tree);\n extern tree define_label\t\t\t(const char *, int, tree);\n extern void check_goto\t\t\t\t(tree);\n extern void define_case_label\t\t\t(void);\n-extern cxx_binding *binding_for_name (tree, tree);\n extern tree namespace_binding                   (tree, tree);\n extern void set_namespace_binding               (tree, tree, tree);\n extern tree lookup_namespace_name\t\t(tree, tree);\n@@ -3753,7 +3752,6 @@ extern int nonstatic_local_decl_p               (tree);\n extern tree declare_global_var                  (tree, tree);\n extern void register_dtor_fn                    (tree);\n extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n-extern cxx_binding *cxx_scope_find_binding_for_name (tree, tree);\n extern tree cp_fname_init\t\t\t(const char *);\n extern bool have_extern_spec;\n "}, {"sha": "602a116e8511e6117958a8b424cef5c5fd92b9cb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 18, "deletions": 122, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ed3cf9539b38d56097601dd56acd1433931ed603", "patch": "@@ -98,7 +98,6 @@ static void push_binding (tree, tree, struct cp_binding_level*);\n static int add_binding (tree, tree);\n static void pop_binding (tree, tree);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n-static cxx_binding *find_binding (tree, tree, cxx_binding *);\n static tree select_decl (cxx_binding *, int);\n static int lookup_flags (int, int);\n static tree qualify_lookup (tree, int);\n@@ -885,24 +884,19 @@ finish_scope (void)\n   poplevel (0, 0, 0);\n }\n \n-/* For a binding between a name and an entity at a block scope,\n-   this is the `struct cp_binding_level' for the block.  */\n-#define BINDING_LEVEL(NODE) ((NODE)->scope.level)\n-\n /* Make DECL the innermost binding for ID.  The LEVEL is the binding\n    level at which this declaration is being bound.  */\n \n static void\n-push_binding (tree id, tree decl, struct cp_binding_level* level)\n+push_binding (tree id, tree decl, cxx_scope* level)\n {\n    cxx_binding *binding = cxx_binding_make (decl, NULL);\n \n   /* Now, fill in the binding information.  */\n   binding->previous = IDENTIFIER_BINDING (id);\n-  BINDING_LEVEL (binding) = level;\n+  BINDING_SCOPE (binding) = level;\n   INHERITED_VALUE_BINDING_P (binding) = 0;\n   LOCAL_BINDING_P (binding) = (level != class_binding_level);\n-  BINDING_HAS_LEVEL_P (binding) = 1;\n \n   /* And put it on the front of the list of bindings for ID.  */\n   IDENTIFIER_BINDING (id) = binding;\n@@ -1070,7 +1064,7 @@ push_class_binding (tree id, tree decl)\n      other purpose.  */\n   note_name_declared_in_class (id, decl);\n \n-  if (binding && BINDING_LEVEL (binding) == class_binding_level)\n+  if (binding && BINDING_SCOPE (binding) == class_binding_level)\n     /* Supplement the existing binding.  */\n     result = add_binding (id, decl);\n   else\n@@ -1148,9 +1142,9 @@ pop_binding (tree id, tree decl)\n       /* Add it to the free list.  */\n       cxx_binding_free (binding);\n \n-      /* Clear the BINDING_LEVEL so the garbage collector doesn't walk\n+      /* Clear the BINDING_SCOPE so the garbage collector doesn't walk\n \t it.  */\n-      BINDING_LEVEL (binding) = NULL;\n+      BINDING_SCOPE (binding) = NULL;\n     }\n }\n \n@@ -1367,7 +1361,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t    ns_binding = NULL_TREE;\n \n \t  if (outer_binding\n-\t      && (BINDING_LEVEL (outer_binding)\n+\t      && (BINDING_SCOPE (outer_binding)\n \t\t  == current_binding_level->level_chain))\n \t    /* We have something like:\n \n@@ -1414,9 +1408,8 @@ poplevel (int keep, int reverse, int functionbody)\n \t\t\t     dead_vars_from_for);\n \n \t      /* Although we don't pop the cxx_binding, we do clear\n-\t\t its BINDING_LEVEL since the level is going away now.  */\n-\t      BINDING_LEVEL (IDENTIFIER_BINDING (DECL_NAME (link)))\n-\t\t= 0;\n+\t\t its BINDING_SCOPE since the level is going away now.  */\n+\t      BINDING_SCOPE (IDENTIFIER_BINDING (DECL_NAME (link))) = 0;\n \t    }\n \t}\n       else\n@@ -1641,7 +1634,7 @@ poplevel_class (void)\n \t    cxx_binding *binding;\n             \n \t    binding = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n-\t    while (binding && BINDING_LEVEL (binding) != b)\n+\t    while (binding && BINDING_SCOPE (binding) != b)\n \t      binding = binding->previous;\n \n \t    if (binding)\n@@ -2006,105 +1999,6 @@ print_binding_stack (void)\n    the identifier is polymorphic, with three possible values:\n    NULL_TREE, a list of \"cxx_binding\"s.  */\n \n-/* Check whether the a binding for the name to scope is known.\n-   Assumes that the bindings of the name are already a list\n-   of bindings. Returns the binding found, or NULL_TREE.  */\n-\n-static inline cxx_binding *\n-find_binding (tree name, tree scope, cxx_binding *front)\n-{\n-  cxx_binding *iter;\n-  cxx_binding *prev = NULL;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  scope = ORIGINAL_NAMESPACE (scope);\n-\n-  for (iter = front; iter != NULL; iter = iter->previous)\n-    {\n-      if (BINDING_SCOPE (iter) == scope)\n-\t{\n-\t  /* Move binding found to the front of the list, so\n-             subsequent lookups will find it faster.  */\n-\t  if (prev)\n-\t    {\n-\t      prev->previous = iter->previous;\n-\t      iter->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-\t      IDENTIFIER_NAMESPACE_BINDINGS (name) = iter;\n-\t    }\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, iter);\n-\t}\n-      prev = iter;\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL);\n-}\n-\n-/* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n-cxx_binding *\n-cxx_scope_find_binding_for_name (tree scope, tree name)\n-{\n-  cxx_binding *b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  if (b)\n-    {\n-      scope = ORIGINAL_NAMESPACE (scope);\n-      /* Fold-in case where NAME is used only once.  */\n-      if (scope == BINDING_SCOPE (b) && b->previous == NULL)\n-        return b;\n-      return find_binding (name, scope, b);\n-    }\n-  return b;\n-}\n-\n-/* Always returns a binding for name in scope. If the\n-   namespace_bindings is not a list, convert it to one first.\n-   If no binding is found, make a new one.  */\n-\n-cxx_binding *\n-binding_for_name (tree name, tree scope)\n-{\n-  cxx_binding *result;\n-\n-  scope = ORIGINAL_NAMESPACE (scope);\n-  result = cxx_scope_find_binding_for_name (scope, name);\n-  if (result)\n-    return result;\n-  /* Not found, make a new one.  */\n-  result = cxx_binding_make (NULL, NULL);\n-  result->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n-  BINDING_SCOPE (result) = scope;\n-  result->is_local = false;\n-  result->value_is_inherited = false;\n-  result->has_level = false;\n-  IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n-  return result;\n-}\n-\n-/* Return the binding value for name in scope.  */\n-\n-tree\n-namespace_binding (tree name, tree scope)\n-{\n-  cxx_binding *b =\n-    cxx_scope_find_binding_for_name (scope ? scope : global_namespace, name);\n-\n-  return b ? b->value : NULL_TREE;\n-}\n-\n-/* Set the binding value for name in scope. If modifying the binding\n-   of global_namespace is attempted, try to optimize it.  */\n-\n-void\n-set_namespace_binding (tree name, tree scope, tree val)\n-{\n-  cxx_binding *b;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (scope == NULL_TREE)\n-    scope = global_namespace;\n-  b = binding_for_name (name, scope);\n-  BINDING_VALUE (b) = val;\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n /* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n    select a name that is unique to this compilation unit.  */\n \n@@ -2425,7 +2319,8 @@ set_identifier_type_value_with_scope (tree id,\n     }\n   else\n     {\n-      cxx_binding *binding = binding_for_name (id, current_namespace);\n+      cxx_binding *binding =\n+         binding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n       BINDING_TYPE (binding) = type;\n       /* Store marker instead of real type.  */\n       type = global_type_node;\n@@ -4532,7 +4427,7 @@ push_overloaded_decl (tree decl, int flags)\n \t{\n \t  tree *d;\n \n-\t  for (d = &BINDING_LEVEL (IDENTIFIER_BINDING (name))->names;\n+\t  for (d = &BINDING_SCOPE (IDENTIFIER_BINDING (name))->names;\n \t       *d;\n \t       d = &TREE_CHAIN (*d))\n \t    if (*d == old\n@@ -5203,7 +5098,7 @@ follow_tag_typedef (tree type)\n \n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n-   Searches binding levels from BINDING_LEVEL up to the global level.\n+   Searches binding levels from BINDING_SCOPE up to the global level.\n    If THISLEVEL_ONLY is nonzero, searches only the specified context\n    (but skips any tag-transparent contexts to find one that is\n    meaningful for tags).\n@@ -5238,7 +5133,7 @@ lookup_tag (enum tree_code form, tree name,\n \tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n \t  {\n             cxx_binding *binding =\n-              cxx_scope_find_binding_for_name (tail, name);\n+              cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (tail), name);\n \t    tree old;\n \n \t    /* If we just skipped past a template parameter level,\n@@ -5753,7 +5648,8 @@ unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n \n   for (; !val; scope = CP_DECL_CONTEXT (scope))\n     {\n-      cxx_binding *b = cxx_scope_find_binding_for_name (scope, name);\n+      cxx_binding *b =\n+         cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n       if (spacesp)\n \t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n \n@@ -6060,7 +5956,7 @@ lookup_name_current_level (tree name)\n     {\n       while (1)\n \t{\n-\t  if (BINDING_LEVEL (IDENTIFIER_BINDING (name)) == b)\n+\t  if (BINDING_SCOPE (IDENTIFIER_BINDING (name)) == b)\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n \n \t  if (b->keep == 2)\n@@ -7975,7 +7871,7 @@ maybe_inject_for_scope_var (tree decl)\n       cxx_binding *outer_binding\n \t= IDENTIFIER_BINDING (DECL_NAME (decl))->previous;\n \n-      if (outer_binding && BINDING_LEVEL (outer_binding) == outer\n+      if (outer_binding && BINDING_SCOPE (outer_binding) == outer\n \t  && (TREE_CODE (BINDING_VALUE (outer_binding)) == VAR_DECL)\n \t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n \t{"}, {"sha": "b7b0054b7eeaa1510c738d3122e01ce96ab60dc2", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ed3cf9539b38d56097601dd56acd1433931ed603", "patch": "@@ -3632,10 +3632,11 @@ lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n   for (iter = usings; iter; iter = TREE_CHAIN (iter))\n     if (TREE_VALUE (iter) == scope)\n       {\n+        tree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n         cxx_binding *val1 =\n-          cxx_scope_find_binding_for_name (TREE_PURPOSE (iter), name);\n+          cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n         if (spacesp)\n-          *spacesp = tree_cons (TREE_PURPOSE (iter), NULL_TREE, *spacesp);\n+          *spacesp = tree_cons (used, NULL_TREE, *spacesp);\n         /* Resolve ambiguities.  */\n         if (val1)\n           val = ambiguous_decl (name, val, val1, flags);\n@@ -3663,7 +3664,8 @@ qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n   scope = ORIGINAL_NAMESPACE (scope);\n   while (scope && result->value != error_mark_node)\n     {\n-      cxx_binding *binding = cxx_scope_find_binding_for_name (scope, name);\n+      cxx_binding *binding =\n+        cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n       seen = tree_cons (scope, NULL_TREE, seen);\n       if (binding)\n         result = ambiguous_decl (name, result, binding, flags);\n@@ -4355,7 +4357,7 @@ do_toplevel_using_decl (tree decl)\n   if (decl == NULL_TREE)\n     return;\n   \n-  binding = binding_for_name (name, current_namespace);\n+  binding = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n \n   oldval = BINDING_VALUE (binding);\n   oldtype = BINDING_TYPE (binding);"}, {"sha": "3eb010a8d1fd56c3f35eed3d5a1441cc6128924b", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=ed3cf9539b38d56097601dd56acd1433931ed603", "patch": "@@ -2,20 +2,20 @@\n    Copyright (C) 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n@@ -26,6 +26,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"name-lookup.h\"\n+#include \"timevar.h\"\n \n /* A free list of \"cxx_binding\"s, connected by their PREVIOUS.  */\n static GTY((deletable (\"\"))) cxx_binding *free_bindings;\n@@ -56,3 +57,86 @@ cxx_binding_free (cxx_binding *binding)\n   binding->previous = free_bindings;\n   free_bindings = binding;\n }\n+\f\n+/* Return (from the stack of) the BINDING, if any, establihsed at SCOPE.  */ \n+\n+static inline cxx_binding *\n+find_binding (cxx_scope *scope, cxx_binding *binding)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+\n+  for (; binding != NULL; binding = binding->previous)\n+    if (BINDING_SCOPE (binding) == scope)\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, binding);\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL);\n+}\n+\n+/* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n+cxx_binding *\n+cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n+{\n+  cxx_binding *b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+  if (b)\n+    {\n+      /* Fold-in case where NAME is used only once.  */\n+      if (scope == BINDING_SCOPE (b) && b->previous == NULL)\n+        return b;\n+      return find_binding (scope, b);\n+    }\n+  return NULL;\n+}\n+\n+/* Always returns a binding for name in scope.  If no binding is\n+   found, make a new one.  */\n+\n+cxx_binding *\n+binding_for_name (cxx_scope *scope, tree name)\n+{\n+  cxx_binding *result;\n+\n+  result = cxx_scope_find_binding_for_name (scope, name);\n+  if (result)\n+    return result;\n+  /* Not found, make a new one.  */\n+  result = cxx_binding_make (NULL, NULL);\n+  result->previous = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+  BINDING_SCOPE (result) = scope;\n+  result->is_local = false;\n+  result->value_is_inherited = false;\n+  IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n+  return result;\n+}\n+\f\n+/* Namespace-scope manipulation routines.  */\n+\n+/* Return the binding value for name in scope.  */\n+\n+tree\n+namespace_binding (tree name, tree scope)\n+{\n+  cxx_binding *binding;\n+\n+  if (scope == NULL)\n+    scope = global_namespace;\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  binding = cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\n+  return binding ? binding->value : NULL_TREE;\n+}\n+\n+/* Set the binding value for name in scope.  */\n+\n+void\n+set_namespace_binding (tree name, tree scope, tree val)\n+{\n+  cxx_binding *b;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (scope == NULL_TREE)\n+    scope = global_namespace;\n+  b = binding_for_name (NAMESPACE_LEVEL (scope), name);\n+  BINDING_VALUE (b) = val;\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+"}, {"sha": "f6a4131fe5b657ee3c65053f2640f28823a32ab5", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed3cf9539b38d56097601dd56acd1433931ed603/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=ed3cf9539b38d56097601dd56acd1433931ed603", "patch": "@@ -2,20 +2,20 @@\n    Copyright (C) 2003 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n-This file is part of GNU CC.\n+This file is part of GCC.\n \n-GNU CC is free software; you can redistribute it and/or modify\n+GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n \n-GNU CC is distributed in the hope that it will be useful,\n+GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n+along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n@@ -32,6 +32,9 @@ typedef struct cxx_saved_binding cxx_saved_binding;\n    a name and a C++ entity.  */\n typedef struct cxx_binding cxx_binding;\n \n+/* The datatype used to implement C++ scope.  */\n+typedef struct cp_binding_level cxx_scope;\n+\n /* Nonzero if this binding is for a local scope, as opposed to a class\n    or namespace scope.  */\n #define LOCAL_BINDING_P(NODE) ((NODE)->is_local)\n@@ -42,13 +45,8 @@ typedef struct cxx_binding cxx_binding;\n \n /* For a binding between a name and an entity at a non-local scope,\n    defines the scope where the binding is declared.  (Either a class\n-   _TYPE node, or a NAMESPACE_DECL.)  This macro should be used only\n-   for namespace-level bindings; on the IDENTIFIER_BINDING list\n-   BINDING_LEVEL is used instead.  */\n-#define BINDING_SCOPE(NODE) ((NODE)->scope.scope)\n-\n-/* Nonzero if NODE has BINDING_LEVEL, rather than BINDING_SCOPE.  */\n-#define BINDING_HAS_LEVEL_P(NODE) ((NODE)->has_level)\n+   _TYPE node, or a NAMESPACE_DECL.).  */\n+#define BINDING_SCOPE(NODE) ((NODE)->scope)\n \n /* This is the declaration bound to the name. Possible values:\n    variable, overloaded function, namespace, template, enumerator.  */\n@@ -68,11 +66,8 @@ struct cxx_binding GTY(())\n   tree value;\n   /* The type entity this name is bound to.  */\n   tree type;\n-  union tree_binding_u {\n-    tree GTY ((tag (\"0\"))) scope;\n-    struct cp_binding_level * GTY ((tag (\"1\"))) level;\n-  } GTY ((desc (\"%0.has_level\"))) scope;\n-  unsigned has_level : 1;\n+  /* The scope at which this binding was made.  */\n+  cxx_scope *scope;\n   unsigned value_is_inherited : 1;\n   unsigned is_local : 1;\n };\n@@ -81,5 +76,10 @@ extern cxx_binding *cxx_binding_make (tree, tree);\n extern void cxx_binding_free (cxx_binding *);\n \f\n \n+extern cxx_binding *cxx_scope_find_binding_for_name (cxx_scope *, tree);\n+extern cxx_binding *binding_for_name (cxx_scope *, tree);\n+\f\n+extern tree namespace_binding (tree, tree);\n+extern void set_namespace_binding (tree, tree, tree);\n \n #endif /* GCC_CP_NAME_LOOKUP_H */"}]}