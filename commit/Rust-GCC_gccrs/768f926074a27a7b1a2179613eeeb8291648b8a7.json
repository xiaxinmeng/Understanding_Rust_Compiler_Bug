{"sha": "768f926074a27a7b1a2179613eeeb8291648b8a7", "node_id": "C_kwDOANBUbNoAKDc2OGY5MjYwNzRhMjdhN2IxYTIxNzk2MTNlZWViODI5MTY0OGI4YTc", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-16T10:23:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-16T10:23:26Z"}, "message": "Merge #834\n\n834: Add enum code generation r=philberty a=philberty\n\nThis adds a naieve first pass approach to enum type code generation. The\r\noriginal idea was to use GCC's QUAL_UNION_TYPE but I have ran into issues\r\nwith the DECL_QUALIFIER as my understanding of how this works is incorrect.\r\n\r\nThis takes an enum such as:\r\n\r\n```rust\r\nenum AnEnum {\r\n  A,\r\n  B,\r\n  C (char),\r\n  D (x: i64, y: i64),\r\n}\r\n```\r\n\r\nAnd turns this into one big union consisting of all fields as RECORD_TYPES.\r\n\r\n```c\r\nunion AnEnum {\r\n  record A { RUST$ENUM$DISR };\r\n  record B { RUST$ENUM$DISR };\r\n  record C { RUST$ENUM$DISR, char };\r\n  record D { RUST$ENUM$DISR, i64, i64};\r\n}\r\n```\r\n\r\nsee: https://github.com/bminor/binutils-gdb/blob/527b8861cd472385fa9160a91dd6d65a25c41987/gdb/dwarf2/read.c#L9010-L9241\r\n\r\nWith the RUST$ENUM$DISR being the first field in all of the records this\r\nmeans the alignment allows for indirect memory access of the struct to\r\nuse it as a qualifier field to figure out which variant is currently in\r\nuse. The data-less varients use their generated discriminat value during\r\ntype-checking the data variants use their HIR ID for their discriminant.\r\n\r\nThis will likely get redone to get improved GDB integration/updated to use\r\nthe QUAL_UNION_TYPE when we learn how to do this properly.\r\n\r\nFixes #79\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "a696b3458140310c223e519b0b53d4481dc2c1de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a696b3458140310c223e519b0b53d4481dc2c1de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/768f926074a27a7b1a2179613eeeb8291648b8a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhuxOeCRBK7hj4Ov3rIwAA22gIABO7oZbKX6kaqvVWYC62I2IS\nh7gudWCiUGA9huHR3EI8t4j1aaSGadQsnTOeqs/lLeMaGKz75ubLRlKbG2ZdZ9fO\nv5H1r21um8dU3e9S1R+hw9OSsdmAUxj7ITavINs6ckUrrOrx8DavGYqJvlAcKxIv\noeOqWFZmy09etI6AqkcztISF/2bxSNG21WyPyor4Sei4aHYsBwrrFNywwH/qz14k\nZ/D65m8viEq1NAF3co1/WUKFX/But1ZqK7LWbE6YuP0K66fojrN2VEFm6UVw9AD4\nYk6/ohJhHUw7EH3dXxB3G5DkJW7rY67+aT+HPGRqK+nIbUshA/Iz0dM9WHmG0fo=\n=u7ml\n-----END PGP SIGNATURE-----\n", "payload": "tree a696b3458140310c223e519b0b53d4481dc2c1de\nparent 3629645386ad503606f29f95c2e16d0600df6e20\nparent e0588300adc00872b0e818477dba614348d2cb02\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639650206 +0000\ncommitter GitHub <noreply@github.com> 1639650206 +0000\n\nMerge #834\n\n834: Add enum code generation r=philberty a=philberty\n\nThis adds a naieve first pass approach to enum type code generation. The\r\noriginal idea was to use GCC's QUAL_UNION_TYPE but I have ran into issues\r\nwith the DECL_QUALIFIER as my understanding of how this works is incorrect.\r\n\r\nThis takes an enum such as:\r\n\r\n```rust\r\nenum AnEnum {\r\n  A,\r\n  B,\r\n  C (char),\r\n  D (x: i64, y: i64),\r\n}\r\n```\r\n\r\nAnd turns this into one big union consisting of all fields as RECORD_TYPES.\r\n\r\n```c\r\nunion AnEnum {\r\n  record A { RUST$ENUM$DISR };\r\n  record B { RUST$ENUM$DISR };\r\n  record C { RUST$ENUM$DISR, char };\r\n  record D { RUST$ENUM$DISR, i64, i64};\r\n}\r\n```\r\n\r\nsee: https://github.com/bminor/binutils-gdb/blob/527b8861cd472385fa9160a91dd6d65a25c41987/gdb/dwarf2/read.c#L9010-L9241\r\n\r\nWith the RUST$ENUM$DISR being the first field in all of the records this\r\nmeans the alignment allows for indirect memory access of the struct to\r\nuse it as a qualifier field to figure out which variant is currently in\r\nuse. The data-less varients use their generated discriminat value during\r\ntype-checking the data variants use their HIR ID for their discriminant.\r\n\r\nThis will likely get redone to get improved GDB integration/updated to use\r\nthe QUAL_UNION_TYPE when we learn how to do this properly.\r\n\r\nFixes #79\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768f926074a27a7b1a2179613eeeb8291648b8a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768f926074a27a7b1a2179613eeeb8291648b8a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768f926074a27a7b1a2179613eeeb8291648b8a7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3629645386ad503606f29f95c2e16d0600df6e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3629645386ad503606f29f95c2e16d0600df6e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3629645386ad503606f29f95c2e16d0600df6e20"}, {"sha": "e0588300adc00872b0e818477dba614348d2cb02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0588300adc00872b0e818477dba614348d2cb02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0588300adc00872b0e818477dba614348d2cb02"}], "stats": {"total": 630, "additions": 475, "deletions": 155}, "files": [{"sha": "fa88e48c1772b448670ff3cd0f5c3e2f069d1609", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 110, "deletions": 77, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -168,19 +168,36 @@ CompileExpr::visit (HIR::CallExpr &expr)\n   // must be a tuple constructor\n   bool is_fn = tyty->get_kind () == TyTy::TypeKind::FNDEF\n \t       || tyty->get_kind () == TyTy::TypeKind::FNPTR;\n-  if (!is_fn)\n+  bool is_adt_ctor = !is_fn;\n+  if (is_adt_ctor)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n       tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n-      rust_assert (!adt->is_enum ());\n-      rust_assert (adt->number_of_variants () == 1);\n-      auto variant = adt->get_variants ().at (0);\n+      // what variant is it?\n+      int union_disriminator = -1;\n+      TyTy::VariantDef *variant = nullptr;\n+      if (!adt->is_enum ())\n+\t{\n+\t  rust_assert (adt->number_of_variants () == 1);\n+\t  variant = adt->get_variants ().at (0);\n+\t}\n+      else\n+\t{\n+\t  HirId variant_id;\n+\t  bool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\t    expr.get_fnexpr ()->get_mappings ().get_hirid (), &variant_id);\n+\t  rust_assert (ok);\n+\n+\t  ok = adt->lookup_variant_by_id (variant_id, &variant,\n+\t\t\t\t\t  &union_disriminator);\n+\t  rust_assert (ok);\n+\t}\n \n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n-      std::vector<tree> vals;\n+      std::vector<tree> arguments;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -200,95 +217,111 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n \n \t  // add it to the list\n-\t  vals.push_back (rvalue);\n+\t  arguments.push_back (rvalue);\n \t}\n \n-      translated\n-\t= ctx->get_backend ()->constructor_expression (compiled_adt_type, vals,\n-\t\t\t\t\t\t       -1, expr.get_locus ());\n-    }\n-  else\n-    {\n-      auto get_parameter_tyty_at_index\n-\t= [] (const TyTy::BaseType *base, size_t index,\n-\t      TyTy::BaseType **result) -> bool {\n-\tbool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n-\t\t     || base->get_kind () == TyTy::TypeKind::FNPTR;\n-\trust_assert (is_fn);\n-\n-\tif (base->get_kind () == TyTy::TypeKind::FNPTR)\n-\t  {\n-\t    const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n-\t    *result = fn->param_at (index);\n+      // the constructor depends on whether this is actually an enum or not if\n+      // its an enum we need to setup the discriminator\n+      std::vector<tree> ctor_arguments;\n+      if (adt->is_enum ())\n+\t{\n+\t  HirId variant_id = variant->get_id ();\n+\t  mpz_t val;\n+\t  mpz_init_set_ui (val, variant_id);\n+\n+\t  tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+\t  tree qualifier\n+\t    = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n+\t  ctor_arguments.push_back (qualifier);\n+\t}\n+      for (auto &arg : arguments)\n+\tctor_arguments.push_back (arg);\n \n-\t    return true;\n-\t  }\n+      translated = ctx->get_backend ()->constructor_expression (\n+\tcompiled_adt_type, adt->is_enum (), ctor_arguments, union_disriminator,\n+\texpr.get_locus ());\n \n-\tconst TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n-\tauto param = fn->param_at (index);\n-\t*result = param.second;\n+      return;\n+    }\n \n-\treturn true;\n-      };\n+  auto get_parameter_tyty_at_index\n+    = [] (const TyTy::BaseType *base, size_t index,\n+\t  TyTy::BaseType **result) -> bool {\n+    bool is_fn = base->get_kind () == TyTy::TypeKind::FNDEF\n+\t\t || base->get_kind () == TyTy::TypeKind::FNPTR;\n+    rust_assert (is_fn);\n \n-      bool is_varadic = false;\n-      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t{\n-\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n-\t  is_varadic = fn->is_varadic ();\n-\t}\n+    if (base->get_kind () == TyTy::TypeKind::FNPTR)\n+      {\n+\tconst TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (base);\n+\t*result = fn->param_at (index);\n \n-      size_t required_num_args;\n-      if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-\t{\n-\t  const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n-\t  required_num_args = fn->num_params ();\n-\t}\n-      else\n-\t{\n-\t  const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n-\t  required_num_args = fn->num_params ();\n-\t}\n+\treturn true;\n+      }\n \n-      std::vector<tree> args;\n-      for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n-\t{\n-\t  auto &argument = expr.get_arguments ().at (i);\n-\t  auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n+    const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (base);\n+    auto param = fn->param_at (index);\n+    *result = param.second;\n \n-\t  if (is_varadic && i >= required_num_args)\n-\t    {\n-\t      args.push_back (rvalue);\n-\t      continue;\n-\t    }\n+    return true;\n+  };\n \n-\t  // assignments are coercion sites so lets convert the rvalue if\n-\t  // necessary\n-\t  bool ok;\n-\t  TyTy::BaseType *expected = nullptr;\n-\t  ok = get_parameter_tyty_at_index (tyty, i, &expected);\n-\t  rust_assert (ok);\n+  bool is_varadic = false;\n+  if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+      is_varadic = fn->is_varadic ();\n+    }\n \n-\t  TyTy::BaseType *actual = nullptr;\n-\t  ok = ctx->get_tyctx ()->lookup_type (\n-\t    argument->get_mappings ().get_hirid (), &actual);\n-\t  rust_assert (ok);\n+  size_t required_num_args;\n+  if (tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      const TyTy::FnType *fn = static_cast<const TyTy::FnType *> (tyty);\n+      required_num_args = fn->num_params ();\n+    }\n+  else\n+    {\n+      const TyTy::FnPtr *fn = static_cast<const TyTy::FnPtr *> (tyty);\n+      required_num_args = fn->num_params ();\n+    }\n \n-\t  // coerce it if required\n-\t  rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+  std::vector<tree> args;\n+  for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n+    {\n+      auto &argument = expr.get_arguments ().at (i);\n+      auto rvalue = CompileExpr::Compile (argument.get (), ctx);\n \n-\t  // add it to the list\n+      if (is_varadic && i >= required_num_args)\n+\t{\n \t  args.push_back (rvalue);\n+\t  continue;\n \t}\n \n-      // must be a call to a function\n-      auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n-      auto fncontext = ctx->peek_fn ();\n-      translated\n-\t= ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address,\n-\t\t\t\t\t\targs, nullptr,\n-\t\t\t\t\t\texpr.get_locus ());\n+      // assignments are coercion sites so lets convert the rvalue if\n+      // necessary\n+      bool ok;\n+      TyTy::BaseType *expected = nullptr;\n+      ok = get_parameter_tyty_at_index (tyty, i, &expected);\n+      rust_assert (ok);\n+\n+      TyTy::BaseType *actual = nullptr;\n+      ok = ctx->get_tyctx ()->lookup_type (\n+\targument->get_mappings ().get_hirid (), &actual);\n+      rust_assert (ok);\n+\n+      // coerce it if required\n+      rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n+\n+      // add it to the list\n+      args.push_back (rvalue);\n     }\n+\n+  // must be a call to a function\n+  auto fn_address = CompileExpr::Compile (expr.get_fnexpr (), ctx);\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_address, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n }\n \n void"}, {"sha": "9895540fecfa0f6936421b18a291e4c0de67ef27", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 74, "deletions": 12, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -100,8 +100,8 @@ class CompileExpr : public HIRCompileBase\n       }\n \n     translated\n-      = ctx->get_backend ()->constructor_expression (tuple_type, vals, -1,\n-\t\t\t\t\t\t     expr.get_locus ());\n+      = ctx->get_backend ()->constructor_expression (tuple_type, false, vals,\n+\t\t\t\t\t\t     -1, expr.get_locus ());\n   }\n \n   void visit (HIR::ReturnExpr &expr) override\n@@ -660,22 +660,84 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    tree type = TyTyResolveCompile::compile (ctx, tyty);\n-    rust_assert (type != nullptr);\n+    // it must be an ADT\n+    rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n+    TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n+\n+    // what variant is it?\n+    int union_disriminator = struct_expr.union_index;\n+    TyTy::VariantDef *variant = nullptr;\n+    if (!adt->is_enum ())\n+      {\n+\trust_assert (adt->number_of_variants () == 1);\n+\tvariant = adt->get_variants ().at (0);\n+      }\n+    else\n+      {\n+\tHirId variant_id;\n+\tbool ok = ctx->get_tyctx ()->lookup_variant_definition (\n+\t  struct_expr.get_struct_name ().get_mappings ().get_hirid (),\n+\t  &variant_id);\n+\trust_assert (ok);\n+\n+\tok = adt->lookup_variant_by_id (variant_id, &variant,\n+\t\t\t\t\t&union_disriminator);\n+\trust_assert (ok);\n+      }\n+\n+    // compile it\n+    tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n     // this assumes all fields are in order from type resolution and if a base\n     // struct was specified those fields are filed via accesors\n-    std::vector<tree> vals;\n-    for (auto &field : struct_expr.get_fields ())\n+    std::vector<tree> arguments;\n+    for (size_t i = 0; i < struct_expr.get_fields ().size (); i++)\n       {\n-\ttree expr = CompileStructExprField::Compile (field.get (), ctx);\n-\tvals.push_back (expr);\n+\tauto &argument = struct_expr.get_fields ().at (i);\n+\tauto rvalue = CompileStructExprField::Compile (argument.get (), ctx);\n+\n+\t// assignments are coercion sites so lets convert the rvalue if\n+\t// necessary\n+\tauto respective_field = variant->get_field_at_index (i);\n+\tauto expected = respective_field->get_field_type ();\n+\n+\tTyTy::BaseType *actual = nullptr;\n+\tbool ok = ctx->get_tyctx ()->lookup_type (\n+\t  argument->get_mappings ().get_hirid (), &actual);\n+\n+\t// coerce it if required/possible see\n+\t// compile/torture/struct_base_init_1.rs\n+\tif (ok)\n+\t  {\n+\t    rvalue = coercion_site (rvalue, actual, expected,\n+\t\t\t\t    argument->get_locus ());\n+\t  }\n+\n+\t// add it to the list\n+\targuments.push_back (rvalue);\n       }\n \n-    translated\n-      = ctx->get_backend ()->constructor_expression (type, vals,\n-\t\t\t\t\t\t     struct_expr.union_index,\n-\t\t\t\t\t\t     struct_expr.get_locus ());\n+    // the constructor depends on whether this is actually an enum or not if\n+    // its an enum we need to setup the discriminator\n+    std::vector<tree> ctor_arguments;\n+    if (adt->is_enum ())\n+      {\n+\tHirId variant_id = variant->get_id ();\n+\tmpz_t val;\n+\tmpz_init_set_ui (val, variant_id);\n+\n+\ttree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+\ttree qualifier\n+\t  = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n+\n+\tctor_arguments.push_back (qualifier);\n+      }\n+    for (auto &arg : arguments)\n+      ctor_arguments.push_back (arg);\n+\n+    translated = ctx->get_backend ()->constructor_expression (\n+      compiled_adt_type, adt->is_enum (), ctor_arguments, union_disriminator,\n+      struct_expr.get_locus ());\n   }\n \n   void visit (HIR::GroupedExpr &expr) override"}, {"sha": "07133b9db94fb90c6820ba771b8e48bf70f71701", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -45,6 +45,10 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t const Analysis::NodeMapping &mappings,\n \t\t\t Location expr_locus, bool is_qualified_path)\n {\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n+  rust_assert (ok);\n+\n   // need to look up the reference for this identifier\n   NodeId ref_node_id = UNKNOWN_NODEID;\n   if (ctx->get_resolver ()->lookup_resolved_name (mappings.get_nodeid (),\n@@ -63,8 +67,44 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   // in that case the caller should attempt ResolvePathType::Compile\n   if (ref_node_id == UNKNOWN_NODEID)\n     {\n-      rust_error_at (expr_locus, \"unknown nodeid for path expr\");\n-      return ctx->get_backend ()->error_expression ();\n+      // it might be an enum data-less enum variant\n+      if (lookup->get_kind () != TyTy::TypeKind::ADT)\n+\treturn ctx->get_backend ()->error_expression ();\n+\n+      TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+      if (!adt->is_enum ())\n+\treturn ctx->get_backend ()->error_expression ();\n+\n+      HirId variant_id;\n+      if (!ctx->get_tyctx ()->lookup_variant_definition (mappings.get_hirid (),\n+\t\t\t\t\t\t\t &variant_id))\n+\treturn ctx->get_backend ()->error_expression ();\n+\n+      int union_disriminator = -1;\n+      TyTy::VariantDef *variant = nullptr;\n+      if (!adt->lookup_variant_by_id (variant_id, &variant,\n+\t\t\t\t      &union_disriminator))\n+\treturn ctx->get_backend ()->error_expression ();\n+\n+      // FIXME should really return error_mark_node and or rust_internal_error\n+      // error_mark_node\n+      rust_assert (variant->get_variant_type ()\n+\t\t   == TyTy::VariantDef::VariantType::NUM);\n+\n+      // we need the actual gcc type\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, adt);\n+\n+      // make the ctor for the union\n+      mpz_t val;\n+      mpz_init_set_ui (val, variant->get_discriminant ());\n+      tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+      tree qualifier\n+\t= double_int_to_tree (t, mpz_get_double_int (t, val, true));\n+\n+      return ctx->get_backend ()->constructor_expression (compiled_adt_type,\n+\t\t\t\t\t\t\t  true, {qualifier},\n+\t\t\t\t\t\t\t  union_disriminator,\n+\t\t\t\t\t\t\t  expr_locus);\n     }\n \n   HirId ref;\n@@ -86,9 +126,6 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n     return ctx->get_backend ()->var_expression (var, expr_locus);\n \n   // it might be a function call\n-  TyTy::BaseType *lookup = nullptr;\n-  bool ok = ctx->get_tyctx ()->lookup_type (mappings.get_hirid (), &lookup);\n-  rust_assert (ok);\n   if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n@@ -102,7 +139,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   // let the query system figure it out\n   return query_compile (ref, lookup, final_segment, mappings, expr_locus,\n \t\t\tis_qualified_path);\n-}\n+} // namespace Compile\n \n tree\n ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,"}, {"sha": "c147a51953c3ed93bf8a88334a502cade56ce6ea", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 148, "deletions": 18, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -18,9 +18,48 @@\n \n #include \"rust-compile-type.h\"\n \n+#include \"tree.h\"\n+\n namespace Rust {\n namespace Compile {\n \n+static const std::string RUST_ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\";\n+\n+// see: gcc/c/c-decl.c:8230-8241\n+// https://github.com/Rust-GCC/gccrs/blob/0024bc2f028369b871a65ceb11b2fddfb0f9c3aa/gcc/c/c-decl.c#L8229-L8241\n+tree\n+TyTyResolveCompile::get_implicit_enumeral_node_type (Context *ctx)\n+{\n+  // static tree enum_node = NULL_TREE;\n+  // if (enum_node == NULL_TREE)\n+  //   {\n+  //     enum_node = make_node (ENUMERAL_TYPE);\n+  //     SET_TYPE_MODE (enum_node, TYPE_MODE (unsigned_type_node));\n+  //     SET_TYPE_ALIGN (enum_node, TYPE_ALIGN (unsigned_type_node));\n+  //     TYPE_USER_ALIGN (enum_node) = 0;\n+  //     TYPE_UNSIGNED (enum_node) = 1;\n+  //     TYPE_PRECISION (enum_node) = TYPE_PRECISION (unsigned_type_node);\n+  //     TYPE_MIN_VALUE (enum_node) = TYPE_MIN_VALUE (unsigned_type_node);\n+  //     TYPE_MAX_VALUE (enum_node) = TYPE_MAX_VALUE (unsigned_type_node);\n+\n+  //     // tree identifier = ctx->get_backend ()->get_identifier_node\n+  //     // (\"enumeral\"); tree enum_decl\n+  //     //   = build_decl (BUILTINS_LOCATION, TYPE_DECL, identifier,\n+  //     enum_node);\n+  //     // TYPE_NAME (enum_node) = enum_decl;\n+  //   }\n+  // return enum_node;\n+\n+  static tree enum_node = NULL_TREE;\n+  if (enum_node == NULL_TREE)\n+    {\n+      enum_node = ctx->get_backend ()->named_type (\n+\t\"enumeral\", ctx->get_backend ()->integer_type (false, 64),\n+\tLinemap::predeclared_location ());\n+    }\n+  return enum_node;\n+}\n+\n void\n TyTyResolveCompile::visit (const TyTy::ErrorType &)\n {\n@@ -120,29 +159,120 @@ TyTyResolveCompile::visit (const TyTy::ADTType &type)\n   if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n     return;\n \n-  // we dont support enums yet\n-  rust_assert (!type.is_enum ());\n-  rust_assert (type.number_of_variants () == 1);\n+  tree type_record = error_mark_node;\n+  if (!type.is_enum ())\n+    {\n+      rust_assert (type.number_of_variants () == 1);\n \n-  TyTy::VariantDef &variant = *type.get_variants ().at (0);\n-  std::vector<Backend::typed_identifier> fields;\n-  for (size_t i = 0; i < variant.num_fields (); i++)\n+      TyTy::VariantDef &variant = *type.get_variants ().at (0);\n+      std::vector<Backend::typed_identifier> fields;\n+      for (size_t i = 0; i < variant.num_fields (); i++)\n+\t{\n+\t  const TyTy::StructFieldType *field = variant.get_field_at_index (i);\n+\t  tree compiled_field_ty\n+\t    = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+\n+\t  Backend::typed_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\t  fields.push_back (std::move (f));\n+\t}\n+\n+      type_record = type.is_union ()\n+\t\t      ? ctx->get_backend ()->union_type (fields)\n+\t\t      : ctx->get_backend ()->struct_type (fields);\n+    }\n+  else\n     {\n-      const TyTy::StructFieldType *field = variant.get_field_at_index (i);\n-      tree compiled_field_ty\n-\t= TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+      // see:\n+      // https://github.com/bminor/binutils-gdb/blob/527b8861cd472385fa9160a91dd6d65a25c41987/gdb/dwarf2/read.c#L9010-L9241\n+      //\n+      // enums are actually a big union so for example the rust enum:\n+      //\n+      // enum AnEnum {\n+      //   A,\n+      //   B,\n+      //   C (char),\n+      //   D { x: i64, y: i64 },\n+      // }\n+      //\n+      // we actually turn this into\n+      //\n+      // union {\n+      //   struct A { int RUST$ENUM$DISR; }; <- this is a data-less variant\n+      //   struct B { int RUST$ENUM$DISR; }; <- this is a data-less variant\n+      //   struct C { int RUST$ENUM$DISR; char __0; };\n+      //   struct D { int RUST$ENUM$DISR; i64 x; i64 y; };\n+      // }\n+      //\n+      // Ada, qual_union_types might still work for this but I am not 100% sure.\n+      // I ran into some issues lets reuse our normal union and ask Ada people\n+      // about it.\n+\n+      std::vector<tree> variant_records;\n+      for (auto &variant : type.get_variants ())\n+\t{\n+\t  std::vector<Backend::typed_identifier> fields;\n+\n+\t  // add in the qualifier field for the variant\n+\t  tree enumeral_type\n+\t    = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+\t  Backend::typed_identifier f (RUST_ENUM_DISR_FIELD_NAME, enumeral_type,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t variant->get_id ()));\n+\t  fields.push_back (std::move (f));\n+\n+\t  // compile the rest of the fields\n+\t  for (size_t i = 0; i < variant->num_fields (); i++)\n+\t    {\n+\t      const TyTy::StructFieldType *field\n+\t\t= variant->get_field_at_index (i);\n+\t      tree compiled_field_ty\n+\t\t= TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+\n+\t      std::string field_name = field->get_name ();\n+\t      if (variant->get_variant_type ()\n+\t\t  == TyTy::VariantDef::VariantType::TUPLE)\n+\t\tfield_name = \"__\" + field->get_name ();\n+\n+\t      Backend::typed_identifier f (\n+\t\tfield_name, compiled_field_ty,\n+\t\tctx->get_mappings ()->lookup_location (type.get_ty_ref ()));\n+\t      fields.push_back (std::move (f));\n+\t    }\n+\n+\t  tree variant_record = ctx->get_backend ()->struct_type (fields);\n+\t  tree named_variant_record = ctx->get_backend ()->named_type (\n+\t    variant->get_identifier (), variant_record,\n+\t    ctx->get_mappings ()->lookup_location (variant->get_id ()));\n+\n+\t  // set the qualifier to be a builtin\n+\t  DECL_ARTIFICIAL (TYPE_FIELDS (variant_record)) = 1;\n+\n+\t  // add them to the list\n+\t  variant_records.push_back (named_variant_record);\n+\t}\n+\n+      // now we need to make the actual union, but first we need to make\n+      // named_type TYPE_DECL's out of the variants\n+\n+      size_t i = 0;\n+      std::vector<Backend::typed_identifier> enum_fields;\n+      for (auto &variant_record : variant_records)\n+\t{\n+\t  TyTy::VariantDef *variant = type.get_variants ().at (i++);\n+\t  std::string implicit_variant_name = variant->get_identifier ();\n+\n+\t  Backend::typed_identifier f (implicit_variant_name, variant_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\t  enum_fields.push_back (std::move (f));\n+\t}\n \n-      Backend::typed_identifier f (field->get_name (), compiled_field_ty,\n-\t\t\t\t   ctx->get_mappings ()->lookup_location (\n-\t\t\t\t     type.get_ty_ref ()));\n-      fields.push_back (std::move (f));\n+      // finally make the union or the enum\n+      type_record = ctx->get_backend ()->union_type (enum_fields);\n     }\n \n-  tree type_record;\n-  if (type.is_union ())\n-    type_record = ctx->get_backend ()->union_type (fields);\n-  else\n-    type_record = ctx->get_backend ()->struct_type (fields);\n   tree named_struct\n     = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t       ctx->get_mappings ()->lookup_location ("}, {"sha": "1e05e5db25ac62fff7a8892d86a4df14f9c895b3", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -35,6 +35,8 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n     return compiler.translated;\n   }\n \n+  static tree get_implicit_enumeral_node_type (Context *ctx);\n+\n   void visit (const TyTy::InferType &) override;\n   void visit (const TyTy::ADTType &) override;\n   void visit (const TyTy::TupleType &) override;"}, {"sha": "610e3aae650c552c38d798c30f0b7bd90a2a61bd", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -336,8 +336,8 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n     }\n \n   tree constructed_trait_object\n-    = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n-\t\t\t\t\t\t   locus);\n+    = ctx->get_backend ()->constructor_expression (dynamic_object, false, vals,\n+\t\t\t\t\t\t   -1, locus);\n \n   fncontext fnctx = ctx->peek_fn ();\n   tree enclosing_scope = ctx->peek_enclosing_scope ();"}, {"sha": "43a81f20413e822edf2ba6345e6c6fc43757bc8c", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -122,6 +122,8 @@ class Backend\n     return \"unknown\";\n   }\n \n+  virtual tree get_identifier_node (const std::string &str) = 0;\n+\n   // Types.\n \n   // Produce an error type.  Actually the backend could probably just\n@@ -348,7 +350,7 @@ class Backend\n   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n   // backend representation a of struct.  VALS must be in the same order as the\n   // corresponding fields in BTYPE.\n-  virtual tree constructor_expression (tree btype,\n+  virtual tree constructor_expression (tree btype, bool is_variant,\n \t\t\t\t       const std::vector<tree> &vals, int,\n \t\t\t\t       Location)\n     = 0;"}, {"sha": "43716d90be0a9c7e72cb6b81eac3ac2fe407e3c8", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 73, "deletions": 38, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -110,6 +110,11 @@ class Gcc_backend : public Backend\n   void debug (tree t) { debug_tree (t); };\n   void debug (Bvariable *t) { debug_tree (t->get_decl ()); };\n \n+  tree get_identifier_node (const std::string &str)\n+  {\n+    return get_identifier_with_length (str.data (), str.length ());\n+  }\n+\n   // Types.\n   tree error_type () { return error_mark_node; }\n \n@@ -288,7 +293,8 @@ class Gcc_backend : public Backend\n   tree lazy_boolean_expression (LazyBooleanOperator op, tree left, tree right,\n \t\t\t\tLocation);\n \n-  tree constructor_expression (tree, const std::vector<tree> &, int, Location);\n+  tree constructor_expression (tree, bool, const std::vector<tree> &, int,\n+\t\t\t       Location);\n \n   tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n \t\t\t\t     const std::vector<tree> &, Location);\n@@ -1715,7 +1721,7 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n // Return an expression that constructs BTYPE with VALS.\n \n tree\n-Gcc_backend::constructor_expression (tree type_tree,\n+Gcc_backend::constructor_expression (tree type_tree, bool is_variant,\n \t\t\t\t     const std::vector<tree> &vals,\n \t\t\t\t     int union_index, Location location)\n {\n@@ -1728,46 +1734,40 @@ Gcc_backend::constructor_expression (tree type_tree,\n   tree sink = NULL_TREE;\n   bool is_constant = true;\n   tree field = TYPE_FIELDS (type_tree);\n-  if (union_index != -1)\n+\n+  if (is_variant)\n     {\n+      gcc_assert (union_index != -1);\n       gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n-      tree val = vals.front ();\n+\n       for (int i = 0; i < union_index; i++)\n \t{\n \t  gcc_assert (field != NULL_TREE);\n \t  field = DECL_CHAIN (field);\n \t}\n-      if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n-\t  || TREE_TYPE (val) == error_mark_node)\n-\treturn this->error_expression ();\n \n-      if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n-\t{\n-\t  // GIMPLE cannot represent indices of zero-sized types so\n-\t  // trying to construct a map with zero-sized keys might lead\n-\t  // to errors.  Instead, we evaluate each expression that\n-\t  // would have been added as a map element for its\n-\t  // side-effects and construct an empty map.\n-\t  append_to_statement_list (val, &sink);\n-\t}\n-      else\n-\t{\n-\t  constructor_elt empty = {NULL, NULL};\n-\t  constructor_elt *elt = init->quick_push (empty);\n-\t  elt->index = field;\n-\t  elt->value = this->convert_tree (TREE_TYPE (field), val, location);\n-\t  if (!TREE_CONSTANT (elt->value))\n-\t    is_constant = false;\n-\t}\n+      tree nested_ctor\n+\t= constructor_expression (TREE_TYPE (field), false, vals, -1, location);\n+\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt *elt = init->quick_push (empty);\n+      elt->index = field;\n+      elt->value\n+\t= this->convert_tree (TREE_TYPE (field), nested_ctor, location);\n+      if (!TREE_CONSTANT (elt->value))\n+\tis_constant = false;\n     }\n   else\n     {\n-      gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-      for (std::vector<tree>::const_iterator p = vals.begin ();\n-\t   p != vals.end (); ++p, field = DECL_CHAIN (field))\n+      if (union_index != -1)\n \t{\n-\t  gcc_assert (field != NULL_TREE);\n-\t  tree val = (*p);\n+\t  gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n+\t  tree val = vals.front ();\n+\t  for (int i = 0; i < union_index; i++)\n+\t    {\n+\t      gcc_assert (field != NULL_TREE);\n+\t      field = DECL_CHAIN (field);\n+\t    }\n \t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t      || TREE_TYPE (val) == error_mark_node)\n \t    return this->error_expression ();\n@@ -1780,18 +1780,53 @@ Gcc_backend::constructor_expression (tree type_tree,\n \t      // would have been added as a map element for its\n \t      // side-effects and construct an empty map.\n \t      append_to_statement_list (val, &sink);\n-\t      continue;\n \t    }\n+\t  else\n+\t    {\n+\t      constructor_elt empty = {NULL, NULL};\n+\t      constructor_elt *elt = init->quick_push (empty);\n+\t      elt->index = field;\n+\t      elt->value\n+\t\t= this->convert_tree (TREE_TYPE (field), val, location);\n+\t      if (!TREE_CONSTANT (elt->value))\n+\t\tis_constant = false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n+\t  for (std::vector<tree>::const_iterator p = vals.begin ();\n+\t       p != vals.end (); ++p, field = DECL_CHAIN (field))\n+\t    {\n+\t      gcc_assert (field != NULL_TREE);\n+\t      tree val = (*p);\n+\t      if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n+\t\t  || TREE_TYPE (val) == error_mark_node)\n+\t\treturn this->error_expression ();\n+\n+\t      if (int_size_in_bytes (TREE_TYPE (field)) == 0)\n+\t\t{\n+\t\t  // GIMPLE cannot represent indices of zero-sized types so\n+\t\t  // trying to construct a map with zero-sized keys might lead\n+\t\t  // to errors.  Instead, we evaluate each expression that\n+\t\t  // would have been added as a map element for its\n+\t\t  // side-effects and construct an empty map.\n+\t\t  append_to_statement_list (val, &sink);\n+\t\t  continue;\n+\t\t}\n \n-\t  constructor_elt empty = {NULL, NULL};\n-\t  constructor_elt *elt = init->quick_push (empty);\n-\t  elt->index = field;\n-\t  elt->value = this->convert_tree (TREE_TYPE (field), val, location);\n-\t  if (!TREE_CONSTANT (elt->value))\n-\t    is_constant = false;\n+\t      constructor_elt empty = {NULL, NULL};\n+\t      constructor_elt *elt = init->quick_push (empty);\n+\t      elt->index = field;\n+\t      elt->value\n+\t\t= this->convert_tree (TREE_TYPE (field), val, location);\n+\t      if (!TREE_CONSTANT (elt->value))\n+\t\tis_constant = false;\n+\t    }\n+\t  gcc_assert (field == NULL_TREE);\n \t}\n-      gcc_assert (field == NULL_TREE);\n     }\n+\n   tree ret = build_constructor (type_tree, init);\n   if (is_constant)\n     TREE_CONSTANT (ret) = 1;"}, {"sha": "3cedba82e6868815754ea216d9d63cce28562351", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -1268,15 +1268,21 @@ class ADTType : public BaseType, public SubstitutionRef\n     return false;\n   }\n \n-  bool lookup_variant_by_id (HirId id, VariantDef **found_variant) const\n+  bool lookup_variant_by_id (HirId id, VariantDef **found_variant,\n+\t\t\t     int *index = nullptr) const\n   {\n+    int i = 0;\n     for (auto &variant : variants)\n       {\n \tif (variant->get_id () == id)\n \t  {\n+\t    if (index != nullptr)\n+\t      *index = i;\n+\n \t    *found_variant = variant;\n \t    return true;\n \t  }\n+\ti++;\n       }\n     return false;\n   }"}, {"sha": "7cea48f29e22177c4c2feb78498b032a90062fde", "filename": "gcc/testsuite/rust/compile/torture/enum1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fenum1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768f926074a27a7b1a2179613eeeb8291648b8a7/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fenum1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fenum1.rs?ref=768f926074a27a7b1a2179613eeeb8291648b8a7", "patch": "@@ -0,0 +1,13 @@\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn main() {\n+    let _a = Foo::A;\n+    let _b = Foo::B;\n+    let _c = Foo::C('x');\n+    let _d = Foo::D { x: 20, y: 80 };\n+}"}]}