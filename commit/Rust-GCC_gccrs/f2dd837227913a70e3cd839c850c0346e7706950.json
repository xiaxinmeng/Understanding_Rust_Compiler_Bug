{"sha": "f2dd837227913a70e3cd839c850c0346e7706950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJkZDgzNzIyNzkxM2E3MGUzY2Q4MzljODUwYzAzNDZlNzcwNjk1MA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-04-11T08:08:54Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-04-11T08:08:54Z"}, "message": "(expand_divmod): When adjusting op0 for trunc_div or trunc_mod...\n\n(expand_divmod): When adjusting op0 for trunc_div or\ntrunc_mod, using shifts (not branches), make a new pseudo for the\nresult.  Don't use target for adjusted_op0.\n\nFrom-SVN: r4081", "tree": {"sha": "acfd355da208daabdc4e008c1d65c7737fa3f342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acfd355da208daabdc4e008c1d65c7737fa3f342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2dd837227913a70e3cd839c850c0346e7706950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2dd837227913a70e3cd839c850c0346e7706950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2dd837227913a70e3cd839c850c0346e7706950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2dd837227913a70e3cd839c850c0346e7706950/comments", "author": null, "committer": null, "parents": [{"sha": "52266016a226f4dd87ae4efb1a096a06778a6f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52266016a226f4dd87ae4efb1a096a06778a6f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52266016a226f4dd87ae4efb1a096a06778a6f9b"}], "stats": {"total": 26, "additions": 17, "deletions": 9}, "files": [{"sha": "90ab40faa986fc8a579fe32b5f3884d6a0e456ad", "filename": "gcc/expmed.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2dd837227913a70e3cd839c850c0346e7706950/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2dd837227913a70e3cd839c850c0346e7706950/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f2dd837227913a70e3cd839c850c0346e7706950", "patch": "@@ -2359,14 +2359,6 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n     case TRUNC_DIV_EXPR:\n       if (log >= 0 && ! unsignedp)\n \t{\n-\t  if (! can_clobber_op0)\n-\t    {\n-\t      adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n-\t\t\t\t\t\t    compute_mode);\n-\t      /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n-\t\t which will screw up mem refs for autoincrements.  */\n-\t      op0 = force_reg (compute_mode, op0);\n-\t    }\n \t  /* Here we need to add OP1-1 if OP0 is negative, 0 otherwise.\n \t     This can be computed without jumps by arithmetically shifting\n \t     OP0 right LOG-1 places and then shifting right logically\n@@ -2375,17 +2367,33 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  if (log == 1 || BRANCH_COST >= 3)\n \t    {\n \t      rtx temp = gen_reg_rtx (compute_mode);\n+\t      if (! can_clobber_op0)\n+\t\t/* Copy op0 to a reg, to play safe,\n+\t\t   since this is done in the other path.  */\n+\t\top0 = force_reg (compute_mode, op0);\n \t      temp = copy_to_suggested_reg (adjusted_op0, temp, compute_mode);\n \t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n \t\t\t\t   build_int_2 (log - 1, 0), NULL_RTX, 0);\n \t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n \t\t\t\t   build_int_2 (size - log, 0),\n \t\t\t\t   temp, 1);\n-\t      expand_inc (adjusted_op0, temp);\n+\t      /* We supply 0 as the target to make a new pseudo\n+\t\t for the value; that helps loop.c optimize the result.  */\n+\t      adjusted_op0 = expand_binop (compute_mode, add_optab,\n+\t\t\t\t\t   adjusted_op0, temp,\n+\t\t\t\t\t   0, 0, OPTAB_LIB_WIDEN);\n \t    }\n \t  else\n \t    {\n \t      rtx label = gen_label_rtx ();\n+\t      if (! can_clobber_op0)\n+\t\t{\n+\t\t  adjusted_op0 = copy_to_suggested_reg (adjusted_op0, target,\n+\t\t\t\t\t\t\tcompute_mode);\n+\t\t  /* Copy op0 to a reg, since emit_cmp_insn will call emit_queue\n+\t\t     which will screw up mem refs for autoincrements.  */\n+\t\t  op0 = force_reg (compute_mode, op0);\n+\t\t}\n \t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n \t\t\t     NULL_RTX, compute_mode, 0, 0);\n \t      emit_jump_insn (gen_bge (label));"}]}