{"sha": "8ce94e44465bcc958dc11270d9dee1775c7a4f43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNlOTRlNDQ0NjViY2M5NThkYzExMjcwZDlkZWUxNzc1YzdhNGY0Mw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2009-03-30T01:50:44Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2009-03-30T01:50:44Z"}, "message": "re PR middle-end/323 (optimized code gives strange floating point results)\n\n\tPR rtl-optimization/323\n\t* c-common.c (c_fully_fold, convert_and_check,\n\tc_common_truthvalue_conversion): Handle EXCESS_PRECISION_EXPR.\n\t(c_fully_fold_internal): Disallow EXCESS_PRECISION_EXPR.\n\t* c-common.def (EXCESS_PRECISION_EXPR): New.\n\t* c-cppbuiltin.c (builtin_define_float_constants): Define\n\tconstants with enough digits for long double.\n\t* c-lex.c (interpret_float): Interpret constant with excess\n\tprecision where appropriate.\n\t* c-opts.c (c_common_post_options): Set\n\tflag_excess_precision_cmdline.  Give an error for\n\t-fexcess-precision=standard for C++ for processors where the\n\toption is significant.\n\t* c-parser.c (c_parser_conditional_expression): Handle excess\n\tprecision in condition.\n\t* c-typeck.c (convert_arguments): Handle arguments with excess\n\tprecision.\n\t(build_unary_op): Move excess precision outside operation.\n\t(build_conditional_expr): Likewise.\n\t(build_compound_expr): Likewise.\n\t(build_c_cast): Do cast on operand of EXCESS_PRECISION_EXPR.\n\t(build_modify_expr): Handle excess precision in RHS.\n\t(convert_for_assignment): Handle excess precision in converted\n\tvalue.\n\t(digest_init, output_init_element, process_init_element): Handle\n\texcess precision in initializer.\n\t(c_finish_return): Handle excess precision in return value.\n\t(build_binary_op): Handle excess precision in operands and add\n\texcess precision as needed for operation.\n\t* common.opt (-fexcess-precision=): New option.\n\t* config/i386/i386.h (X87_ENABLE_ARITH, X87_ENABLE_FLOAT): New.\n\t* config/i386/i386.md (float<SSEMODEI24:mode><X87MODEF:mode>2):\n\tFor standard excess precision, output explicit conversion to and\n\ttruncation from XFmode.\n\t(*float<SSEMODEI24:mode><X87MODEF:mode>2_1,\n\t*float<SSEMODEI24:mode><X87MODEF:mode>2_i387_with_temp,\n\t*float<SSEMODEI24:mode><X87MODEF:mode>2_i387, two unnamed\n\tdefine_splits, floatdi<X87MODEF:mode>2_i387_with_xmm, two unnamed\n\tdefine_splits, *floatunssi<mode>2_1, two unnamed define_splits,\n\tfloatunssi<mode>2, add<mode>3, sub<mode>3, mul<mode>3, divdf3,\n\tdivsf3, *fop_<mode>_comm_i387, *fop_<mode>_1_i387,\n\t*fop_<MODEF:mode>_2_i387, *fop_<MODEF:mode>_3_i387,\n\t*fop_df_4_i387, *fop_df_5_i387, *fop_df_6_i387, two unnamed\n\tdefine_splits, sqrt<mode>2): Disable where appropriate for\n\tstandard excess precision.\n\t* convert.c (convert_to_real): Do not shorten arithmetic to type\n\tfor which excess precision would be used.\n\t* defaults.h (TARGET_FLT_EVAL_METHOD_NON_DEFAULT): Define.\n\t* doc/invoke.texi (-fexcess-precision=): Document option.\n\t(-mfpmath=): Correct index entry.\n\t* flags.h (enum excess_precision, flag_excess_precision_cmdline,\n\tflag_excess_precision): New.\n\t* langhooks.c (lhd_post_options): Set\n\tflag_excess_precision_cmdline.\n\t* opts.c (common_handle_option): Handle -fexcess-precision=.\n\t* toplev.c (flag_excess_precision_cmdline, flag_excess_precision,\n\tinit_excess_precision): New.\n\t(lang_dependent_init_target): Call init_excess_precision.\n\t* tree.c (excess_precision_type): New.\n\t* tree.h (excess_precision_type): Declare.\n\nada:\n\t* gcc-interface/misc.c (gnat_post_options): Set\n\tflag_excess_precision_cmdline.  Give an error for\n\t-fexcess-precision=standard for processors where the option is\n\tsignificant.\n\nfortran:\n\t* options.c (gfc_post_options): Set\n\tflag_excess_precision_cmdline.  Give an error for\n\t-fexcess-precision=standard for processors where the option is\n\tsignificant.\n\njava:\n\t* lang.c (java_post_options): Set flag_excess_precision_cmdline.\n\tGive an error for -fexcess-precision=standard for processors where\n\tthe option is significant.\n\ntestsuite:\n\t* gcc.target/i386/excess-precision-1.c,\n\tgcc.target/i386/excess-precision-2.c,\n\tgcc.target/i386/excess-precision-3.c,\n\tgcc.target/i386/excess-precision-4.c,\n\tgcc.target/i386/excess-precision-5.c,\n\tgcc.target/i386/excess-precision-6.c: New tests.\n\nFrom-SVN: r145272", "tree": {"sha": "07c0a2aef08a00219e11f34b2e1a27c0dd432823", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07c0a2aef08a00219e11f34b2e1a27c0dd432823"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ce94e44465bcc958dc11270d9dee1775c7a4f43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ce94e44465bcc958dc11270d9dee1775c7a4f43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ce94e44465bcc958dc11270d9dee1775c7a4f43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ce94e44465bcc958dc11270d9dee1775c7a4f43/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e57bf475bf7651b30a5a3199bc669617c5004a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e57bf475bf7651b30a5a3199bc669617c5004a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e57bf475bf7651b30a5a3199bc669617c5004a6"}], "stats": {"total": 1258, "additions": 1189, "deletions": 69}, "files": [{"sha": "db553e9e007a4548ae16e5caf4d78037fdf6e67b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1,3 +1,66 @@\n+2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR rtl-optimization/323\n+\t* c-common.c (c_fully_fold, convert_and_check,\n+\tc_common_truthvalue_conversion): Handle EXCESS_PRECISION_EXPR.\n+\t(c_fully_fold_internal): Disallow EXCESS_PRECISION_EXPR.\n+\t* c-common.def (EXCESS_PRECISION_EXPR): New.\n+\t* c-cppbuiltin.c (builtin_define_float_constants): Define\n+\tconstants with enough digits for long double.\n+\t* c-lex.c (interpret_float): Interpret constant with excess\n+\tprecision where appropriate.\n+\t* c-opts.c (c_common_post_options): Set\n+\tflag_excess_precision_cmdline.  Give an error for\n+\t-fexcess-precision=standard for C++ for processors where the\n+\toption is significant.\n+\t* c-parser.c (c_parser_conditional_expression): Handle excess\n+\tprecision in condition.\n+\t* c-typeck.c (convert_arguments): Handle arguments with excess\n+\tprecision.\n+\t(build_unary_op): Move excess precision outside operation.\n+\t(build_conditional_expr): Likewise.\n+\t(build_compound_expr): Likewise.\n+\t(build_c_cast): Do cast on operand of EXCESS_PRECISION_EXPR.\n+\t(build_modify_expr): Handle excess precision in RHS.\n+\t(convert_for_assignment): Handle excess precision in converted\n+\tvalue.\n+\t(digest_init, output_init_element, process_init_element): Handle\n+\texcess precision in initializer.\n+\t(c_finish_return): Handle excess precision in return value.\n+\t(build_binary_op): Handle excess precision in operands and add\n+\texcess precision as needed for operation.\n+\t* common.opt (-fexcess-precision=): New option.\n+\t* config/i386/i386.h (X87_ENABLE_ARITH, X87_ENABLE_FLOAT): New.\n+\t* config/i386/i386.md (float<SSEMODEI24:mode><X87MODEF:mode>2):\n+\tFor standard excess precision, output explicit conversion to and\n+\ttruncation from XFmode.\n+\t(*float<SSEMODEI24:mode><X87MODEF:mode>2_1,\n+\t*float<SSEMODEI24:mode><X87MODEF:mode>2_i387_with_temp,\n+\t*float<SSEMODEI24:mode><X87MODEF:mode>2_i387, two unnamed\n+\tdefine_splits, floatdi<X87MODEF:mode>2_i387_with_xmm, two unnamed\n+\tdefine_splits, *floatunssi<mode>2_1, two unnamed define_splits,\n+\tfloatunssi<mode>2, add<mode>3, sub<mode>3, mul<mode>3, divdf3,\n+\tdivsf3, *fop_<mode>_comm_i387, *fop_<mode>_1_i387,\n+\t*fop_<MODEF:mode>_2_i387, *fop_<MODEF:mode>_3_i387,\n+\t*fop_df_4_i387, *fop_df_5_i387, *fop_df_6_i387, two unnamed\n+\tdefine_splits, sqrt<mode>2): Disable where appropriate for\n+\tstandard excess precision.\n+\t* convert.c (convert_to_real): Do not shorten arithmetic to type\n+\tfor which excess precision would be used.\n+\t* defaults.h (TARGET_FLT_EVAL_METHOD_NON_DEFAULT): Define.\n+\t* doc/invoke.texi (-fexcess-precision=): Document option.\n+\t(-mfpmath=): Correct index entry.\n+\t* flags.h (enum excess_precision, flag_excess_precision_cmdline,\n+\tflag_excess_precision): New.\n+\t* langhooks.c (lhd_post_options): Set\n+\tflag_excess_precision_cmdline.\n+\t* opts.c (common_handle_option): Handle -fexcess-precision=.\n+\t* toplev.c (flag_excess_precision_cmdline, flag_excess_precision,\n+\tinit_excess_precision): New.\n+\t(lang_dependent_init_target): Call init_excess_precision.\n+\t* tree.c (excess_precision_type): New.\n+\t* tree.h (excess_precision_type): Declare.\n+\n 2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/35235"}, {"sha": "0b16cae9cce2d6e94744dc96069290fbdcf04024", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1,3 +1,11 @@\n+2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR rtl-optimization/323\n+\t* gcc-interface/misc.c (gnat_post_options): Set\n+\tflag_excess_precision_cmdline.  Give an error for\n+\t-fexcess-precision=standard for processors where the option is\n+\tsignificant.\n+\n 2009-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c/39323"}, {"sha": "329f68eebb3bf7e9c9e9b5ea1a1ac415a438e5e9", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -337,6 +337,13 @@ gnat_init_options (unsigned int argc, const char **argv)\n bool\n gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n {\n+  /* Excess precision other than \"fast\" requires front-end\n+     support.  */\n+  if (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD\n+      && TARGET_FLT_EVAL_METHOD_NON_DEFAULT)\n+    sorry (\"-fexcess-precision=standard for Ada\");\n+  flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n+\n   /* ??? The warning machinery is outsmarted by Ada.  */\n   warn_unused_parameter = 0;\n "}, {"sha": "b1ac9bc98161699212da4e921e7d934346e10538", "filename": "gcc/c-common.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1131,6 +1131,7 @@ tree\n c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n {\n   tree ret;\n+  tree eptype = NULL_TREE;\n   bool dummy = true;\n   bool maybe_const_itself = true;\n \n@@ -1142,8 +1143,15 @@ c_fully_fold (tree expr, bool in_init, bool *maybe_const)\n \n   if (!maybe_const)\n     maybe_const = &dummy;\n+  if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+    {\n+      eptype = TREE_TYPE (expr);\n+      expr = TREE_OPERAND (expr, 0);\n+    }\n   ret = c_fully_fold_internal (expr, in_init, maybe_const,\n \t\t\t       &maybe_const_itself);\n+  if (eptype)\n+    ret = fold_convert (eptype, ret);\n   *maybe_const &= maybe_const_itself;\n   return ret;\n }\n@@ -1444,6 +1452,15 @@ c_fully_fold_internal (tree expr, bool in_init, bool *maybe_const_operands,\n \t*maybe_const_itself &= op2_const_self;\n       goto out;\n \n+    case EXCESS_PRECISION_EXPR:\n+      /* Each case where an operand with excess precision may be\n+\t encountered must remove the EXCESS_PRECISION_EXPR around\n+\t inner operands and possibly put one around the whole\n+\t expression or possibly convert to the semantic type (which\n+\t c_fully_fold does); we cannot tell at this stage which is\n+\t appropriate in any particular case.  */\n+      gcc_unreachable ();\n+\n     default:\n       /* Various codes may appear through folding built-in functions\n \t and their arguments.  */\n@@ -2174,14 +2191,29 @@ tree\n convert_and_check (tree type, tree expr)\n {\n   tree result;\n+  tree expr_for_warning;\n+\n+  /* Convert from a value with possible excess precision rather than\n+     via the semantic type, but do not warn about values not fitting\n+     exactly in the semantic type.  */\n+  if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+    {\n+      tree orig_type = TREE_TYPE (expr);\n+      expr = TREE_OPERAND (expr, 0);\n+      expr_for_warning = convert (orig_type, expr);\n+      if (orig_type == type)\n+\treturn expr_for_warning;\n+    }\n+  else\n+    expr_for_warning = expr;\n \n   if (TREE_TYPE (expr) == type)\n     return expr;\n   \n   result = convert (type, expr);\n \n   if (!skip_evaluation && !TREE_OVERFLOW_P (expr) && result != error_mark_node)\n-    warnings_for_convert_and_check (type, expr, result);\n+    warnings_for_convert_and_check (type, expr_for_warning, result);\n \n   return result;\n }\n@@ -3862,6 +3894,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n     case NEGATE_EXPR:\n     case ABS_EXPR:\n     case FLOAT_EXPR:\n+    case EXCESS_PRECISION_EXPR:\n       /* These don't change whether an object is nonzero or zero.  */\n       return c_common_truthvalue_conversion (location, TREE_OPERAND (expr, 0));\n "}, {"sha": "1c593633e12051636fa69eac1d94e357067d8c33", "filename": "gcc/c-common.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -39,6 +39,13 @@ along with GCC; see the file COPYING3.  If not see\n    not.  */\n DEFTREECODE (C_MAYBE_CONST_EXPR, \"c_maybe_const_expr\", tcc_expression, 2)\n \n+/* An EXCESS_PRECISION_EXPR, currently only used for C and Objective\n+   C, represents an expression evaluated in greater range or precision\n+   than its type.  The type of the EXCESS_PRECISION_EXPR is the\n+   semantic type while the operand represents what is actually being\n+   evaluated.  */\n+DEFTREECODE (EXCESS_PRECISION_EXPR, \"excess_precision_expr\", tcc_expression, 1)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "5d6033dfdadf527b3380529ca5d476d37855fd5c", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -98,13 +98,16 @@ builtin_define_float_constants (const char *name_prefix,\n   const double log10_2 = .30102999566398119521;\n   double log10_b;\n   const struct real_format *fmt;\n+  const struct real_format *ldfmt;\n \n   char name[64], buf[128];\n   int dig, min_10_exp, max_10_exp;\n   int decimal_dig;\n \n   fmt = REAL_MODE_FORMAT (TYPE_MODE (type));\n   gcc_assert (fmt->b != 10);\n+  ldfmt = REAL_MODE_FORMAT (TYPE_MODE (long_double_type_node));\n+  gcc_assert (ldfmt->b != 10);\n \n   /* The radix of the exponent representation.  */\n   if (type == float_type_node)\n@@ -187,7 +190,8 @@ builtin_define_float_constants (const char *name_prefix,\n      The only macro we care about is this number for the widest supported\n      floating type, but we want this value for rendering constants below.  */\n   {\n-    double d_decimal_dig = 1 + fmt->p * log10_b;\n+    double d_decimal_dig\n+      = 1 + (fmt->p < ldfmt->p ? ldfmt->p : fmt->p) * log10_b;\n     decimal_dig = d_decimal_dig;\n     if (decimal_dig < d_decimal_dig)\n       decimal_dig++;"}, {"sha": "72a959052d2ec7783019043093bea376a63fe207", "filename": "gcc/c-lex.c", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -605,8 +605,10 @@ static tree\n interpret_float (const cpp_token *token, unsigned int flags)\n {\n   tree type;\n+  tree const_type;\n   tree value;\n   REAL_VALUE_TYPE real;\n+  REAL_VALUE_TYPE real_trunc;\n   char *copy;\n   size_t copylen;\n \n@@ -655,6 +657,10 @@ interpret_float (const cpp_token *token, unsigned int flags)\n     else\n       type = double_type_node;\n \n+  const_type = excess_precision_type (type);\n+  if (!const_type)\n+    const_type = type;\n+\n   /* Copy the constant to a nul-terminated buffer.  If the constant\n      has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF\n      can't handle them.  */\n@@ -675,21 +681,30 @@ interpret_float (const cpp_token *token, unsigned int flags)\n   memcpy (copy, token->val.str.text, copylen);\n   copy[copylen] = '\\0';\n \n-  real_from_string3 (&real, copy, TYPE_MODE (type));\n+  real_from_string3 (&real, copy, TYPE_MODE (const_type));\n+  if (const_type != type)\n+    /* Diagnosing if the result of converting the value with excess\n+       precision to the semantic type would overflow (with associated\n+       double rounding) is more appropriate than diagnosing if the\n+       result of converting the string directly to the semantic type\n+       would overflow.  */\n+    real_convert (&real_trunc, TYPE_MODE (type), &real);\n \n   /* Both C and C++ require a diagnostic for a floating constant\n      outside the range of representable values of its type.  Since we\n      have __builtin_inf* to produce an infinity, this is now a\n      mandatory pedwarn if the target does not support infinities.  */\n-  if (REAL_VALUE_ISINF (real)) \n+  if (REAL_VALUE_ISINF (real)\n+      || (const_type != type && REAL_VALUE_ISINF (real_trunc)))\n     {\n       if (!MODE_HAS_INFINITIES (TYPE_MODE (type)))\n \tpedwarn (input_location, 0, \"floating constant exceeds range of %qT\", type);\n       else\n \twarning (OPT_Woverflow, \"floating constant exceeds range of %qT\", type);\n     }\n   /* We also give a warning if the value underflows.  */\n-  else if (REAL_VALUES_EQUAL (real, dconst0))\n+  else if (REAL_VALUES_EQUAL (real, dconst0)\n+\t   || (const_type != type && REAL_VALUES_EQUAL (real_trunc, dconst0)))\n     {\n       REAL_VALUE_TYPE realvoidmode;\n       int overflow = real_from_string (&realvoidmode, copy);\n@@ -698,9 +713,13 @@ interpret_float (const cpp_token *token, unsigned int flags)\n     }\n \n   /* Create a node with determined type and value.  */\n-  value = build_real (type, real);\n+  value = build_real (const_type, real);\n   if (flags & CPP_N_IMAGINARY)\n-    value = build_complex (NULL_TREE, convert (type, integer_zero_node), value);\n+    value = build_complex (NULL_TREE, convert (const_type, integer_zero_node),\n+\t\t\t   value);\n+\n+  if (type != const_type)\n+    value = build1 (EXCESS_PRECISION_EXPR, type, value);\n \n   return value;\n }"}, {"sha": "395399194708d3dbc2d3210f4b5eb05f2720d159", "filename": "gcc/c-opts.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1013,6 +1013,20 @@ c_common_post_options (const char **pfilename)\n   C_COMMON_OVERRIDE_OPTIONS;\n #endif\n \n+  /* Excess precision other than \"fast\" requires front-end\n+     support.  */\n+  if (c_dialect_cxx ())\n+    {\n+      if (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD\n+\t  && TARGET_FLT_EVAL_METHOD_NON_DEFAULT)\n+\tsorry (\"-fexcess-precision=standard for C++\");\n+      flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n+    }\n+  else if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n+    flag_excess_precision_cmdline = (flag_iso\n+\t\t\t\t     ? EXCESS_PRECISION_STANDARD\n+\t\t\t\t     : EXCESS_PRECISION_FAST);\n+\n   /* By default we use C99 inline semantics in GNU99 or C99 mode.  C99\n      inline semantics are not supported in GNU89 or C89 mode.  */\n   if (flag_gnu89_inline == -1)"}, {"sha": "03a7194a8647c978866ed28bb775d05277ddd928", "filename": "gcc/c-parser.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -4465,10 +4465,18 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n+      tree eptype = NULL_TREE;\n       pedwarn (c_parser_peek_token (parser)->location, OPT_pedantic, \n \t       \"ISO C forbids omitting the middle term of a ?: expression\");\n+      if (TREE_CODE (cond.value) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  eptype = TREE_TYPE (cond.value);\n+\t  cond.value = TREE_OPERAND (cond.value, 0);\n+\t}\n       /* Make sure first operand is calculated only once.  */\n       exp1.value = c_save_expr (default_conversion (cond.value));\n+      if (eptype)\n+\texp1.value = build1 (EXCESS_PRECISION_EXPR, eptype, exp1.value);\n       cond.value = c_objc_common_truthvalue_conversion (cond_loc, exp1.value);\n       skip_evaluation += cond.value == truthvalue_true_node;\n     }"}, {"sha": "8702373eac1f3512ba17c43234d9017f3c4217bf", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 242, "deletions": 32, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -2553,6 +2553,7 @@ convert_arguments (int nargs, tree *argarray,\n   int parmnum;\n   const bool type_generic = fundecl\n     && lookup_attribute (\"type generic\", TYPE_ATTRIBUTES(TREE_TYPE (fundecl)));\n+  bool type_generic_remove_excess_precision = false;\n   tree selector;\n \n   /* Change pointer to function to the function itself for\n@@ -2564,6 +2565,30 @@ convert_arguments (int nargs, tree *argarray,\n   /* Handle an ObjC selector specially for diagnostics.  */\n   selector = objc_message_selector ();\n \n+  /* For type-generic built-in functions, determine whether excess\n+     precision should be removed (classification) or not\n+     (comparison).  */\n+  if (type_generic\n+      && DECL_BUILT_IN (fundecl)\n+      && DECL_BUILT_IN_CLASS (fundecl) == BUILT_IN_NORMAL)\n+    {\n+      switch (DECL_FUNCTION_CODE (fundecl))\n+\t{\n+\tcase BUILT_IN_ISFINITE:\n+\tcase BUILT_IN_ISINF:\n+\tcase BUILT_IN_ISINF_SIGN:\n+\tcase BUILT_IN_ISNAN:\n+\tcase BUILT_IN_ISNORMAL:\n+\tcase BUILT_IN_FPCLASSIFY:\n+\t  type_generic_remove_excess_precision = true;\n+\t  break;\n+\n+\tdefault:\n+\t  type_generic_remove_excess_precision = false;\n+\t  break;\n+\t}\n+    }\n+\n   /* Scan the given expressions and types, producing individual\n      converted arguments and storing them in ARGARRAY.  */\n \n@@ -2573,9 +2598,11 @@ convert_arguments (int nargs, tree *argarray,\n     {\n       tree type = typetail ? TREE_VALUE (typetail) : 0;\n       tree val = TREE_VALUE (valtail);\n+      tree valtype = TREE_TYPE (val);\n       tree rname = function;\n       int argnum = parmnum + 1;\n       const char *invalid_func_diag;\n+      bool excess_precision = false;\n       bool npc;\n \n       if (type == void_type_node)\n@@ -2591,6 +2618,19 @@ convert_arguments (int nargs, tree *argarray,\n \t}\n \n       npc = null_pointer_constant_p (val);\n+\n+      /* If there is excess precision and a prototype, convert once to\n+\t the required type rather than converting via the semantic\n+\t type.  Likewise without a prototype a float value represented\n+\t as long double should be converted once to double.  But for\n+\t type-generic classification functions excess precision must\n+\t be removed here.  */\n+      if (TREE_CODE (val) == EXCESS_PRECISION_EXPR\n+\t  && (type || !type_generic || !type_generic_remove_excess_precision))\n+\t{\n+\t  val = TREE_OPERAND (val, 0);\n+\t  excess_precision = true;\n+\t}\n       val = c_fully_fold (val, false, NULL);\n       STRIP_TYPE_NOPS (val);\n \n@@ -2615,40 +2655,40 @@ convert_arguments (int nargs, tree *argarray,\n \t\t  unsigned int formal_prec = TYPE_PRECISION (type);\n \n \t\t  if (INTEGRAL_TYPE_P (type)\n-\t\t      && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)\n+\t\t      && TREE_CODE (valtype) == REAL_TYPE)\n \t\t    warning (0, \"passing argument %d of %qE as integer \"\n \t\t\t     \"rather than floating due to prototype\",\n \t\t\t     argnum, rname);\n \t\t  if (INTEGRAL_TYPE_P (type)\n-\t\t      && TREE_CODE (TREE_TYPE (val)) == COMPLEX_TYPE)\n+\t\t      && TREE_CODE (valtype) == COMPLEX_TYPE)\n \t\t    warning (0, \"passing argument %d of %qE as integer \"\n \t\t\t     \"rather than complex due to prototype\",\n \t\t\t     argnum, rname);\n \t\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n-\t\t\t   && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)\n+\t\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n \t\t    warning (0, \"passing argument %d of %qE as complex \"\n \t\t\t     \"rather than floating due to prototype\",\n \t\t\t     argnum, rname);\n \t\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (val)))\n+\t\t\t   && INTEGRAL_TYPE_P (valtype))\n \t\t    warning (0, \"passing argument %d of %qE as floating \"\n \t\t\t     \"rather than integer due to prototype\",\n \t\t\t     argnum, rname);\n \t\t  else if (TREE_CODE (type) == COMPLEX_TYPE\n-\t\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (val)))\n+\t\t\t   && INTEGRAL_TYPE_P (valtype))\n \t\t    warning (0, \"passing argument %d of %qE as complex \"\n \t\t\t     \"rather than integer due to prototype\",\n \t\t\t     argnum, rname);\n \t\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t\t   && TREE_CODE (TREE_TYPE (val)) == COMPLEX_TYPE)\n+\t\t\t   && TREE_CODE (valtype) == COMPLEX_TYPE)\n \t\t    warning (0, \"passing argument %d of %qE as floating \"\n \t\t\t     \"rather than complex due to prototype\",\n \t\t\t     argnum, rname);\n \t\t  /* ??? At some point, messages should be written about\n \t\t     conversions between complex types, but that's too messy\n \t\t     to do now.  */\n \t\t  else if (TREE_CODE (type) == REAL_TYPE\n-\t\t\t   && TREE_CODE (TREE_TYPE (val)) == REAL_TYPE)\n+\t\t\t   && TREE_CODE (valtype) == REAL_TYPE)\n \t\t    {\n \t\t      /* Warn if any argument is passed as `float',\n \t\t\t since without a prototype it would be `double'.  */\n@@ -2662,40 +2702,40 @@ convert_arguments (int nargs, tree *argarray,\n \t\t\t for decimal float types.  Warn of conversions with\n \t\t\t binary float types and of precision narrowing due to\n \t\t\t prototype. */\n- \t\t      else if (type != TREE_TYPE (val)\n+ \t\t      else if (type != valtype\n \t\t\t       && (type == dfloat32_type_node\n \t\t\t\t   || type == dfloat64_type_node\n \t\t\t\t   || type == dfloat128_type_node\n-\t\t\t\t   || TREE_TYPE (val) == dfloat32_type_node\n-\t\t\t\t   || TREE_TYPE (val) == dfloat64_type_node\n-\t\t\t\t   || TREE_TYPE (val) == dfloat128_type_node)\n+\t\t\t\t   || valtype == dfloat32_type_node\n+\t\t\t\t   || valtype == dfloat64_type_node\n+\t\t\t\t   || valtype == dfloat128_type_node)\n \t\t\t       && (formal_prec\n-\t\t\t\t   <= TYPE_PRECISION (TREE_TYPE (val))\n+\t\t\t\t   <= TYPE_PRECISION (valtype)\n \t\t\t\t   || (type == dfloat128_type_node\n-\t\t\t\t       && (TREE_TYPE (val)\n+\t\t\t\t       && (valtype\n \t\t\t\t\t   != dfloat64_type_node\n-\t\t\t\t\t   && (TREE_TYPE (val)\n+\t\t\t\t\t   && (valtype\n \t\t\t\t\t       != dfloat32_type_node)))\n \t\t\t\t   || (type == dfloat64_type_node\n-\t\t\t\t       && (TREE_TYPE (val)\n+\t\t\t\t       && (valtype\n \t\t\t\t\t   != dfloat32_type_node))))\n \t\t\twarning (0, \"passing argument %d of %qE as %qT \"\n \t\t\t\t \"rather than %qT due to prototype\",\n-\t\t\t\t argnum, rname, type, TREE_TYPE (val));\n+\t\t\t\t argnum, rname, type, valtype);\n \n \t\t    }\n \t\t  /* Detect integer changing in width or signedness.\n \t\t     These warnings are only activated with\n \t\t     -Wtraditional-conversion, not with -Wtraditional.  */\n \t\t  else if (warn_traditional_conversion && INTEGRAL_TYPE_P (type)\n-\t\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (val)))\n+\t\t\t   && INTEGRAL_TYPE_P (valtype))\n \t\t    {\n \t\t      tree would_have_been = default_conversion (val);\n \t\t      tree type1 = TREE_TYPE (would_have_been);\n \n \t\t      if (TREE_CODE (type) == ENUMERAL_TYPE\n \t\t\t  && (TYPE_MAIN_VARIANT (type)\n-\t\t\t      == TYPE_MAIN_VARIANT (TREE_TYPE (val))))\n+\t\t\t      == TYPE_MAIN_VARIANT (valtype)))\n \t\t\t/* No warning if function asks for enum\n \t\t\t   and the actual arg is that enum type.  */\n \t\t\t;\n@@ -2719,8 +2759,8 @@ convert_arguments (int nargs, tree *argarray,\n \t\t\t unsigned type, it doesn't matter whether we\n \t\t\t pass it as signed or unsigned; the value\n \t\t\t certainly is the same either way.  */\n-\t\t      else if (TYPE_PRECISION (TREE_TYPE (val)) < TYPE_PRECISION (type)\n-\t\t\t       && TYPE_UNSIGNED (TREE_TYPE (val)))\n+\t\t      else if (TYPE_PRECISION (valtype) < TYPE_PRECISION (type)\n+\t\t\t       && TYPE_UNSIGNED (valtype))\n \t\t\t;\n \t\t      else if (TYPE_UNSIGNED (type))\n \t\t\twarning (OPT_Wtraditional_conversion, \"passing argument %d of %qE \"\n@@ -2732,6 +2772,10 @@ convert_arguments (int nargs, tree *argarray,\n \t\t    }\n \t\t}\n \n+\t      /* Possibly restore an EXCESS_PRECISION_EXPR for the\n+\t\t sake of better warnings from convert_and_check.  */\n+\t      if (excess_precision)\n+\t\tval = build1 (EXCESS_PRECISION_EXPR, valtype, val);\n \t      parmval = convert_for_assignment (type, val, ic_argpass, npc,\n \t\t\t\t\t\tfundecl, function,\n \t\t\t\t\t\tparmnum + 1);\n@@ -2743,17 +2787,21 @@ convert_arguments (int nargs, tree *argarray,\n \t    }\n \t  argarray[parmnum] = parmval;\n \t}\n-      else if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n-\t       && (TYPE_PRECISION (TREE_TYPE (val))\n+      else if (TREE_CODE (valtype) == REAL_TYPE\n+\t       && (TYPE_PRECISION (valtype)\n \t\t   < TYPE_PRECISION (double_type_node))\n-\t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (val))))\n+\t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (valtype)))\n         {\n \t  if (type_generic)\n \t    argarray[parmnum] = val;\n \t  else\n \t    /* Convert `float' to `double'.  */\n \t    argarray[parmnum] = convert (double_type_node, val);\n \t}\n+      else if (excess_precision && !type_generic)\n+\t/* A \"double\" argument with excess precision being passed\n+\t   without a prototype or in variable arguments.  */\n+\targarray[parmnum] = convert (valtype, val);\n       else if ((invalid_func_diag =\n \t\ttargetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))\n \t{\n@@ -2959,6 +3007,7 @@ build_unary_op (location_t location,\n   enum tree_code typecode;\n   tree val;\n   tree ret = error_mark_node;\n+  tree eptype = NULL_TREE;\n   int noconvert = flag;\n   const char *invalid_op_diag;\n   bool int_operands;\n@@ -2981,6 +3030,12 @@ build_unary_op (location_t location,\n       return error_mark_node;\n     }\n \n+  if (TREE_CODE (arg) == EXCESS_PRECISION_EXPR)\n+    {\n+      eptype = TREE_TYPE (arg);\n+      arg = TREE_OPERAND (arg, 0);\n+    }\n+\n   switch (code)\n     {\n     case CONVERT_EXPR:\n@@ -3077,6 +3132,8 @@ build_unary_op (location_t location,\n \tret = fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n \tret = arg;\n+      if (eptype && TREE_CODE (eptype) == COMPLEX_TYPE)\n+\teptype = TREE_TYPE (eptype);\n       goto return_build_unary_op;\n \n     case IMAGPART_EXPR:\n@@ -3086,6 +3143,8 @@ build_unary_op (location_t location,\n \tret = fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n \tret = omit_one_operand (TREE_TYPE (arg), integer_zero_node, arg);\n+      if (eptype && TREE_CODE (eptype) == COMPLEX_TYPE)\n+\teptype = TREE_TYPE (eptype);\n       goto return_build_unary_op;\n \n     case PREINCREMENT_EXPR:\n@@ -3333,6 +3392,8 @@ build_unary_op (location_t location,\n     ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n   else if (TREE_CODE (ret) != INTEGER_CST && int_operands)\n     ret = note_integer_operands (ret);\n+  if (eptype)\n+    ret = build1 (EXCESS_PRECISION_EXPR, eptype, ret);\n   protected_set_expr_location (ret, location);\n   return ret;\n }\n@@ -3512,6 +3573,7 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n   enum tree_code code1;\n   enum tree_code code2;\n   tree result_type = NULL;\n+  tree ep_result_type = NULL;\n   tree orig_op1 = op1, orig_op2 = op2;\n   bool int_const, op1_int_operands, op2_int_operands, int_operands;\n   tree ret;\n@@ -3544,6 +3606,28 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n \n   objc_ok = objc_compare_types (type1, type2, -3, NULL_TREE);\n \n+  if ((TREE_CODE (op1) == EXCESS_PRECISION_EXPR\n+       || TREE_CODE (op2) == EXCESS_PRECISION_EXPR)\n+      && (code1 == INTEGER_TYPE || code1 == REAL_TYPE\n+\t  || code1 == COMPLEX_TYPE)\n+      && (code2 == INTEGER_TYPE || code2 == REAL_TYPE\n+\t  || code2 == COMPLEX_TYPE))\n+    {\n+      ep_result_type = c_common_type (type1, type2);\n+      if (TREE_CODE (op1) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  op1 = TREE_OPERAND (op1, 0);\n+\t  type1 = TREE_TYPE (op1);\n+\t  gcc_assert (TREE_CODE (type1) == code1);\n+\t}\n+      if (TREE_CODE (op2) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  op2 = TREE_OPERAND (op2, 0);\n+\t  type2 = TREE_TYPE (op2);\n+\t  gcc_assert (TREE_CODE (type2) == code2);\n+\t}\n+    }\n+\n   /* Quickly detect the usual case where op1 and op2 have the same type\n      after promotion.  */\n   if (TYPE_MAIN_VARIANT (type1) == TYPE_MAIN_VARIANT (type2))\n@@ -3741,6 +3825,8 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n       if (int_operands)\n \tret = note_integer_operands (ret);\n     }\n+  if (ep_result_type)\n+    ret = build1 (EXCESS_PRECISION_EXPR, ep_result_type, ret);\n \n   return ret;\n }\n@@ -3751,8 +3837,17 @@ build_conditional_expr (tree ifexp, bool ifexp_bcp, tree op1, tree op2)\n tree\n build_compound_expr (tree expr1, tree expr2)\n {\n+  tree eptype = NULL_TREE;\n   tree ret;\n \n+  if (TREE_CODE (expr1) == EXCESS_PRECISION_EXPR)\n+    expr1 = TREE_OPERAND (expr1, 0);\n+  if (TREE_CODE (expr2) == EXCESS_PRECISION_EXPR)\n+    {\n+      eptype = TREE_TYPE (expr2);\n+      expr2 = TREE_OPERAND (expr2, 0);\n+    }\n+\n   if (!TREE_SIDE_EFFECTS (expr1))\n     {\n       /* The left-hand operand of a comma expression is like an expression\n@@ -3790,6 +3885,9 @@ build_compound_expr (tree expr1, tree expr2)\n       && EXPR_INT_CONST_OPERANDS (expr2))\n     ret = note_integer_operands (ret);\n \n+  if (eptype)\n+    ret = build1 (EXCESS_PRECISION_EXPR, eptype, ret);\n+\n   return ret;\n }\n \n@@ -3798,7 +3896,12 @@ build_compound_expr (tree expr1, tree expr2)\n tree\n build_c_cast (tree type, tree expr)\n {\n-  tree value = expr;\n+  tree value;\n+\n+  if (TREE_CODE (expr) == EXCESS_PRECISION_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  value = expr;\n \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -4058,6 +4161,7 @@ build_modify_expr (location_t location,\n {\n   tree result;\n   tree newrhs;\n+  tree rhs_semantic_type = NULL_TREE;\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n   bool npc;\n@@ -4072,6 +4176,12 @@ build_modify_expr (location_t location,\n   if (!lvalue_or_else (lhs, lv_assign))\n     return error_mark_node;\n \n+  if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+    {\n+      rhs_semantic_type = TREE_TYPE (rhs);\n+      rhs = TREE_OPERAND (rhs, 0);\n+    }\n+\n   newrhs = rhs;\n \n   if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n@@ -4131,11 +4241,14 @@ build_modify_expr (location_t location,\n       TREE_TYPE (lhs) = lhstype;\n     }\n \n-  /* Convert new value to destination type.  Fold it first for the\n-     sake of conversion warnings.  */\n+  /* Convert new value to destination type.  Fold it first, then\n+     restore any excess precision information, for the sake of\n+     conversion warnings.  */\n \n   npc = null_pointer_constant_p (newrhs);\n   newrhs = c_fully_fold (newrhs, false, NULL);\n+  if (rhs_semantic_type)\n+    newrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n   newrhs = convert_for_assignment (lhstype, newrhs, ic_assign, npc,\n \t\t\t\t   NULL_TREE, NULL_TREE, 0);\n   if (TREE_CODE (newrhs) == ERROR_MARK)\n@@ -4190,6 +4303,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t\t\ttree fundecl, tree function, int parmnum)\n {\n   enum tree_code codel = TREE_CODE (type);\n+  tree orig_rhs = rhs;\n   tree rhstype;\n   enum tree_code coder;\n   tree rname = NULL_TREE;\n@@ -4242,6 +4356,9 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       }                                                                  \\\n   } while (0)\n \n+  if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+    rhs = TREE_OPERAND (rhs, 0);\n+\n   rhstype = TREE_TYPE (rhs);\n   coder = TREE_CODE (rhstype);\n \n@@ -4334,7 +4451,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n       bool save = in_late_binary_op;\n       if (codel == BOOLEAN_TYPE)\n \tin_late_binary_op = true;\n-      ret = convert_and_check (type, rhs);\n+      ret = convert_and_check (type, orig_rhs);\n       if (codel == BOOLEAN_TYPE)\n \tin_late_binary_op = save;\n       return ret;\n@@ -4979,6 +5096,7 @@ digest_init (tree type, tree init, bool null_pointer_constant,\n {\n   enum tree_code code = TREE_CODE (type);\n   tree inside_init = init;\n+  tree semantic_type = NULL_TREE;\n   bool maybe_const = true;\n \n   if (type == error_mark_node\n@@ -4989,6 +5107,11 @@ digest_init (tree type, tree init, bool null_pointer_constant,\n \n   STRIP_TYPE_NOPS (inside_init);\n \n+  if (TREE_CODE (inside_init) == EXCESS_PRECISION_EXPR)\n+    {\n+      semantic_type = TREE_TYPE (inside_init);\n+      inside_init = TREE_OPERAND (inside_init, 0);\n+    }\n   inside_init = c_fully_fold (inside_init, require_constant, &maybe_const);\n   inside_init = decl_constant_value_for_optimization (inside_init);\n \n@@ -5206,6 +5329,9 @@ digest_init (tree type, tree init, bool null_pointer_constant,\n \t  && (TREE_CODE (init) == STRING_CST\n \t      || TREE_CODE (init) == COMPOUND_LITERAL_EXPR))\n \tinside_init = init = array_to_pointer_conversion (init);\n+      if (semantic_type)\n+\tinside_init = build1 (EXCESS_PRECISION_EXPR, semantic_type,\n+\t\t\t      inside_init);\n       inside_init\n \t= convert_for_assignment (type, inside_init, ic_init,\n \t\t\t\t  null_pointer_constant,\n@@ -6587,6 +6713,7 @@ static void\n output_init_element (tree value, bool strict_string, tree type, tree field,\n \t\t     int pending, bool implicit)\n {\n+  tree semantic_type = NULL_TREE;\n   constructor_elt *celt;\n   bool maybe_const = true;\n   bool npc;\n@@ -6617,6 +6744,11 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n     }\n \n   npc = null_pointer_constant_p (value);\n+  if (TREE_CODE (value) == EXCESS_PRECISION_EXPR)\n+    {\n+      semantic_type = TREE_TYPE (value);\n+      value = TREE_OPERAND (value, 0);\n+    }\n   value = c_fully_fold (value, require_constant_value, &maybe_const);\n \n   if (value == error_mark_node)\n@@ -6658,6 +6790,8 @@ output_init_element (tree value, bool strict_string, tree type, tree field,\n \t\t  || TREE_CHAIN (field)))))\n     return;\n \n+  if (semantic_type)\n+    value = build1 (EXCESS_PRECISION_EXPR, semantic_type, value);\n   value = digest_init (type, value, npc, strict_string,\n \t\t       require_constant_value);\n   if (value == error_mark_node)\n@@ -6972,7 +7106,18 @@ process_init_element (struct c_expr value, bool implicit)\n       if (TREE_CODE (value.value) != COMPOUND_LITERAL_EXPR\n \t  || !require_constant_value\n \t  || flag_isoc99)\n-\tvalue.value = c_save_expr (value.value);\n+\t{\n+\t  tree semantic_type = NULL_TREE;\n+\t  if (TREE_CODE (value.value) == EXCESS_PRECISION_EXPR)\n+\t    {\n+\t      semantic_type = TREE_TYPE (value.value);\n+\t      value.value = TREE_OPERAND (value.value, 0);\n+\t    }\n+\t  value.value = c_save_expr (value.value);\n+\t  if (semantic_type)\n+\t    value.value = build1 (EXCESS_PRECISION_EXPR, semantic_type,\n+\t\t\t\t  value.value);\n+\t}\n     }\n \n   while (1)\n@@ -7465,8 +7610,16 @@ c_finish_return (tree retval)\n \n   if (retval)\n     {\n+      tree semantic_type = NULL_TREE;\n       npc = null_pointer_constant_p (retval);\n+      if (TREE_CODE (retval) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  semantic_type = TREE_TYPE (retval);\n+\t  retval = TREE_OPERAND (retval, 0);\n+\t}\n       retval = c_fully_fold (retval, false, NULL);\n+      if (semantic_type)\n+\tretval = build1 (EXCESS_PRECISION_EXPR, semantic_type, retval);\n     }\n \n   if (!retval)\n@@ -8281,7 +8434,8 @@ tree\n build_binary_op (location_t location, enum tree_code code,\n \t\t tree orig_op0, tree orig_op1, int convert_p)\n {\n-  tree type0, type1;\n+  tree type0, type1, orig_type0, orig_type1;\n+  tree eptype;\n   enum tree_code code0, code1;\n   tree op0, op1;\n   tree ret = error_mark_node;\n@@ -8297,6 +8451,10 @@ build_binary_op (location_t location, enum tree_code code,\n      In the simplest cases this is the common type of the arguments.  */\n   tree result_type = NULL;\n \n+  /* When the computation is in excess precision, the type of the\n+     final EXCESS_PRECISION_EXPR.  */\n+  tree real_result_type = NULL;\n+\n   /* Nonzero means operands have already been type-converted\n      in whatever way is necessary.\n      Zero means they need to be converted to RESULT_TYPE.  */\n@@ -8333,6 +8491,10 @@ build_binary_op (location_t location, enum tree_code code,\n   /* True means types are compatible as far as ObjC is concerned.  */\n   bool objc_ok;\n \n+  /* True means this is an arithmetic operation that may need excess\n+     precision.  */\n+  bool may_need_excess_precision;\n+\n   if (location == UNKNOWN_LOCATION)\n     location = input_location;\n \n@@ -8360,8 +8522,8 @@ build_binary_op (location_t location, enum tree_code code,\n       op1 = orig_op1;\n     }\n \n-  type0 = TREE_TYPE (op0);\n-  type1 = TREE_TYPE (op1);\n+  orig_type0 = type0 = TREE_TYPE (op0);\n+  orig_type1 = type1 = TREE_TYPE (op1);\n \n   /* The expression codes of the data types of the arguments tell us\n      whether the arguments are integers, floating, pointers, etc.  */\n@@ -8385,6 +8547,45 @@ build_binary_op (location_t location, enum tree_code code,\n       return error_mark_node;\n     }\n \n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      may_need_excess_precision = true;\n+      break;\n+    default:\n+      may_need_excess_precision = false;\n+      break;\n+    }\n+  if (TREE_CODE (op0) == EXCESS_PRECISION_EXPR)\n+    {\n+      op0 = TREE_OPERAND (op0, 0);\n+      type0 = TREE_TYPE (op0);\n+    }\n+  else if (may_need_excess_precision\n+\t   && (eptype = excess_precision_type (type0)) != NULL_TREE)\n+    {\n+      type0 = eptype;\n+      op0 = convert (eptype, op0);\n+    }\n+  if (TREE_CODE (op1) == EXCESS_PRECISION_EXPR)\n+    {\n+      op1 = TREE_OPERAND (op1, 0);\n+      type1 = TREE_TYPE (op1);\n+    }\n+  else if (may_need_excess_precision\n+\t   && (eptype = excess_precision_type (type1)) != NULL_TREE)\n+    {\n+      type1 = eptype;\n+      op1 = convert (eptype, op1);\n+    }\n+\n   objc_ok = objc_compare_types (type0, type1, -3, NULL_TREE);\n \n   switch (code)\n@@ -8929,7 +9130,14 @@ build_binary_op (location_t location, enum tree_code code,\n     }\n \n   if (build_type == NULL_TREE)\n-    build_type = result_type;\n+    {\n+      build_type = result_type;\n+      if (type0 != orig_type0 || type1 != orig_type1)\n+\t{\n+\t  gcc_assert (may_need_excess_precision && common);\n+\t  real_result_type = c_common_type (orig_type0, orig_type1);\n+\t}\n+    }\n \n   /* Treat expressions in initializers specially as they can't trap.  */\n   if (int_const_or_overflow)\n@@ -8950,6 +9158,8 @@ build_binary_op (location_t location, enum tree_code code,\n   else if (TREE_CODE (ret) != INTEGER_CST && int_operands\n \t   && !in_late_binary_op)\n     ret = note_integer_operands (ret);\n+  if (real_result_type)\n+    ret = build1 (EXCESS_PRECISION_EXPR, real_result_type, ret);\n   protected_set_expr_location (ret, location);\n   return ret;\n }"}, {"sha": "3626c9ed486fb1286986bc2951a867fd1ea35478", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -491,6 +491,10 @@ fexpensive-optimizations\n Common Report Var(flag_expensive_optimizations) Optimization\n Perform a number of minor, expensive optimizations\n \n+fexcess-precision=\n+Common Joined RejectNegative\n+-fexcess-precision=[fast|standard]\tSpecify handling of excess floating-point precision\n+\n ffast-math\n Common\n "}, {"sha": "89e26f63dde64e522f87e4d94bdf58d22273dd4d", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -611,6 +611,20 @@ enum target_cpu_default\n #define TARGET_FLT_EVAL_METHOD \\\n   (TARGET_MIX_SSE_I387 ? -1 : TARGET_SSE_MATH ? 0 : 2)\n \n+/* Whether to allow x87 floating-point arithmetic on MODE (one of\n+   SFmode, DFmode and XFmode) in the current excess precision\n+   configuration.  */\n+#define X87_ENABLE_ARITH(MODE) \\\n+  (flag_excess_precision == EXCESS_PRECISION_FAST || (MODE) == XFmode)\n+\n+/* Likewise, whether to allow direct conversions from integer mode\n+   IMODE (HImode, SImode or DImode) to MODE.  */\n+#define X87_ENABLE_FLOAT(MODE, IMODE)\t\t\t\\\n+  (flag_excess_precision == EXCESS_PRECISION_FAST\t\\\n+   || (MODE) == XFmode\t\t\t\t\t\\\n+   || ((MODE) == DFmode && (IMODE) == SImode)\t\t\\\n+   || (IMODE) == HImode)\n+\n /* target machine storage layout */\n \n #define SHORT_TYPE_SIZE 16"}, {"sha": "9592f91ff7ee364d26bd28b4daf05bcd04b95574", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -5137,13 +5137,28 @@\n   \"TARGET_80387\n    || ((<SSEMODEI24:MODE>mode != DImode || TARGET_64BIT)\n        && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\"\n-  \"\")\n+  \"\n+{\n+  if (!((<SSEMODEI24:MODE>mode != DImode || TARGET_64BIT)\n+\t&& SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\n+      && !X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SSEMODEI24:MODE>mode))\n+    {\n+      rtx reg = gen_reg_rtx (XFmode);\n+      emit_insn (gen_float<SSEMODEI24:mode>xf2 (reg, operands[1]));\n+/* Avoid references to nonexistent function in dead code in XFmode case.  */\n+#define gen_truncxfxf2 gen_truncxfdf2\n+      emit_insn (gen_truncxf<X87MODEF:mode>2 (operands[0], reg));\n+#undef gen_truncxfxf2\n+      DONE;\n+    }\n+}\")\n \n ;; Pre-reload splitter to add memory clobber to the pattern.\n (define_insn_and_split \"*float<SSEMODEI24:mode><X87MODEF:mode>2_1\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"\")\n \t(float:X87MODEF (match_operand:SSEMODEI24 1 \"register_operand\" \"\")))]\n   \"((TARGET_80387\n+     && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SSEMODEI24:MODE>mode)\n      && (!((<SSEMODEI24:MODE>mode != DImode || TARGET_64BIT)\n \t   && SSE_FLOAT_MODE_P (<X87MODEF:MODE>mode) && TARGET_SSE_MATH)\n \t || TARGET_MIX_SSE_I387))\n@@ -5524,7 +5539,8 @@\n \t(float:X87MODEF\n \t  (match_operand:SSEMODEI24 1 \"nonimmediate_operand\" \"m,?r\")))\n   (clobber (match_operand:SSEMODEI24 2 \"memory_operand\" \"=X,m\"))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387\n+   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SSEMODEI24:MODE>mode)\"\n   \"@\n    fild%z1\\t%1\n    #\"\n@@ -5537,7 +5553,8 @@\n   [(set (match_operand:X87MODEF 0 \"register_operand\" \"=f\")\n \t(float:X87MODEF\n \t  (match_operand:SSEMODEI24 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387\n+   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SSEMODEI24:MODE>mode)\"\n   \"fild%z1\\t%1\"\n   [(set_attr \"type\" \"fmov\")\n    (set_attr \"mode\" \"<X87MODEF:MODE>\")\n@@ -5548,6 +5565,7 @@\n \t(float:X87MODEF (match_operand:SSEMODEI24 1 \"register_operand\" \"\")))\n    (clobber (match_operand:SSEMODEI24 2 \"memory_operand\" \"\"))]\n   \"TARGET_80387\n+   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SSEMODEI24:MODE>mode)\n    && reload_completed\n    && FP_REG_P (operands[0])\"\n   [(set (match_dup 2) (match_dup 1))\n@@ -5559,6 +5577,7 @@\n \t(float:X87MODEF (match_operand:SSEMODEI24 1 \"memory_operand\" \"\")))\n    (clobber (match_operand:SSEMODEI24 2 \"memory_operand\" \"\"))]\n   \"TARGET_80387\n+   && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, <SSEMODEI24:MODE>mode)\n    && reload_completed\n    && FP_REG_P (operands[0])\"\n   [(set (match_dup 0) (float:X87MODEF (match_dup 1)))]\n@@ -5574,7 +5593,8 @@\n    (clobber (match_scratch:V4SI 3 \"=X,x\"))\n    (clobber (match_scratch:V4SI 4 \"=X,x\"))\n    (clobber (match_operand:DI 2 \"memory_operand\" \"=X,m\"))]\n-  \"TARGET_80387 && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\n+  \"TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, DImode)\n+   && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\n    && !TARGET_64BIT && optimize_function_for_speed_p (cfun)\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")\n@@ -5588,7 +5608,8 @@\n    (clobber (match_scratch:V4SI 3 \"\"))\n    (clobber (match_scratch:V4SI 4 \"\"))\n    (clobber (match_operand:DI 2 \"memory_operand\" \"\"))]\n-  \"TARGET_80387 && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\n+  \"TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, DImode)\n+   && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\n    && !TARGET_64BIT && optimize_function_for_speed_p (cfun)\n    && reload_completed\n    && FP_REG_P (operands[0])\"\n@@ -5612,7 +5633,8 @@\n    (clobber (match_scratch:V4SI 3 \"\"))\n    (clobber (match_scratch:V4SI 4 \"\"))\n    (clobber (match_operand:DI 2 \"memory_operand\" \"\"))]\n-  \"TARGET_80387 && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\n+  \"TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, DImode)\n+   && TARGET_SSE2 && TARGET_INTER_UNIT_MOVES\n    && !TARGET_64BIT && optimize_function_for_speed_p (cfun)\n    && reload_completed\n    && FP_REG_P (operands[0])\"\n@@ -5632,7 +5654,8 @@\n    (clobber (match_operand:DI 2 \"memory_operand\" \"=m,m\"))\n    (clobber (match_scratch:SI 3 \"=X,x\"))]\n   \"!TARGET_64BIT\n-   && TARGET_80387 && TARGET_SSE\"\n+   && TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, SImode)\n+   && TARGET_SSE\"\n   \"#\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"mode\" \"<MODE>\")])\n@@ -5644,7 +5667,8 @@\n    (clobber (match_operand:DI 2 \"memory_operand\" \"\"))\n    (clobber (match_scratch:SI 3 \"\"))]\n   \"!TARGET_64BIT\n-   && TARGET_80387 && TARGET_SSE\n+   && TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, SImode)\n+   && TARGET_SSE\n    && reload_completed\"\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0)\n@@ -5658,7 +5682,8 @@\n    (clobber (match_operand:DI 2 \"memory_operand\" \"\"))\n    (clobber (match_scratch:SI 3 \"\"))]\n   \"!TARGET_64BIT\n-   && TARGET_80387 && TARGET_SSE\n+   && TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, SImode)\n+   && TARGET_SSE\n    && reload_completed\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 0)\n@@ -5676,7 +5701,8 @@\n       (clobber (match_dup 2))\n       (clobber (match_scratch:SI 3 \"\"))])]\n   \"!TARGET_64BIT\n-   && ((TARGET_80387 && TARGET_SSE)\n+   && ((TARGET_80387 && X87_ENABLE_FLOAT (<X87MODEF:MODE>mode, SImode)\n+\t&& TARGET_SSE)\n        || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH))\"\n {\n   if (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n@@ -7475,7 +7501,8 @@\n   [(set (match_operand:MODEF 0 \"register_operand\" \"\")\n \t(plus:MODEF (match_operand:MODEF 1 \"register_operand\" \"\")\n \t\t    (match_operand:MODEF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n+  \"(TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode))\n+    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"\")\n \f\n ;; Subtract instructions\n@@ -7835,7 +7862,8 @@\n   [(set (match_operand:MODEF 0 \"register_operand\" \"\")\n \t(minus:MODEF (match_operand:MODEF 1 \"register_operand\" \"\")\n \t\t     (match_operand:MODEF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n+  \"(TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode))\n+    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"\")\n \f\n ;; Multiply instructions\n@@ -8390,7 +8418,8 @@\n   [(set (match_operand:MODEF 0 \"register_operand\" \"\")\n \t(mult:MODEF (match_operand:MODEF 1 \"register_operand\" \"\")\n \t\t    (match_operand:MODEF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n+  \"(TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode))\n+    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n   \"\")\n \n ;; SSE5 scalar multiply/add instructions are defined in sse.md.\n@@ -8431,14 +8460,16 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n  \t(div:DF (match_operand:DF 1 \"register_operand\" \"\")\n  \t\t(match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n-   \"TARGET_80387 || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n+   \"(TARGET_80387 && X87_ENABLE_ARITH (DFmode))\n+    || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n    \"\")\n \n (define_expand \"divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(div:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t(match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_80387 || TARGET_SSE_MATH\"\n+  \"(TARGET_80387 && X87_ENABLE_ARITH (SFmode))\n+    || TARGET_SSE_MATH\"\n {\n   if (TARGET_SSE_MATH && TARGET_RECIP && optimize_insn_for_speed_p ()\n       && flag_finite_math_only && !flag_trapping_math\n@@ -16317,7 +16348,7 @@\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n \t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"%0\")\n \t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm\")]))]\n-  \"TARGET_80387\n+  \"TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode)\n    && COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n@@ -16431,7 +16462,8 @@\n \t(match_operator:MODEF 3 \"binary_fp_operator\"\n \t  [(match_operand:MODEF 1 \"nonimmediate_operand\" \"0,fm\")\n \t   (match_operand:MODEF 2 \"nonimmediate_operand\" \"fm,0\")]))]\n-  \"TARGET_80387 && !(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n+  \"TARGET_80387 && X87_ENABLE_ARITH (<MODE>mode)\n+   && !(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n    && !COMMUTATIVE_ARITH_P (operands[3])\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n@@ -16451,7 +16483,8 @@\n \t  [(float:MODEF\n \t     (match_operand:X87MODEI12 1 \"nonimmediate_operand\" \"m,?r\"))\n \t   (match_operand:MODEF 2 \"register_operand\" \"0,0\")]))]\n-  \"TARGET_80387 && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n+  \"TARGET_80387 && X87_ENABLE_FLOAT (<MODEF:MODE>mode, <X87MODEI12:MODE>mode)\n+   && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n    && (TARGET_USE_<X87MODEI12:MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n@@ -16470,7 +16503,8 @@\n \t  [(match_operand:MODEF 1 \"register_operand\" \"0,0\")\n \t   (float:MODEF\n \t     (match_operand:X87MODEI12 2 \"nonimmediate_operand\" \"m,?r\"))]))]\n-  \"TARGET_80387 && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n+  \"TARGET_80387 && X87_ENABLE_FLOAT (<MODEF:MODE>mode, <X87MODEI12:MODE>mode)\n+   && !(SSE_FLOAT_MODE_P (<MODEF:MODE>mode) && TARGET_SSE_MATH)\n    && (TARGET_USE_<X87MODEI12:MODE>MODE_FIOP || optimize_function_for_size_p (cfun))\"\n   \"* return which_alternative ? \\\"#\\\" : output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n@@ -16489,7 +16523,8 @@\n \t   [(float_extend:DF\n \t     (match_operand:SF 1 \"nonimmediate_operand\" \"fm,0\"))\n \t    (match_operand:DF 2 \"register_operand\" \"0,f\")]))]\n-  \"TARGET_80387 && !(TARGET_SSE2 && TARGET_SSE_MATH)\n+  \"TARGET_80387 && X87_ENABLE_ARITH (DFmode)\n+   && !(TARGET_SSE2 && TARGET_SSE_MATH)\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n@@ -16507,7 +16542,8 @@\n \t  [(match_operand:DF 1 \"register_operand\" \"0,f\")\n \t   (float_extend:DF\n \t    (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\"))]))]\n-  \"TARGET_80387 && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n+  \"TARGET_80387 && X87_ENABLE_ARITH (DFmode)\n+   && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(match_operand:DF 3 \"mult_operator\" \"\")\n@@ -16525,7 +16561,8 @@\n \t    (match_operand:SF 1 \"register_operand\" \"0,f\"))\n \t   (float_extend:DF\n \t    (match_operand:SF 2 \"nonimmediate_operand\" \"fm,0\"))]))]\n-  \"TARGET_80387 && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n+  \"TARGET_80387 && X87_ENABLE_ARITH (DFmode)\n+   && !(TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"* return output_387_binary_op (insn, operands);\"\n   [(set (attr \"type\")\n         (cond [(match_operand:DF 3 \"mult_operator\" \"\")\n@@ -16661,7 +16698,8 @@\n \t   [(float (match_operand:X87MODEI12 1 \"register_operand\" \"\"))\n \t    (match_operand 2 \"register_operand\" \"\")]))]\n   \"reload_completed\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\"\n+   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && X87_ENABLE_FLOAT (GET_MODE (operands[0]), GET_MODE (operands[1]))\"\n   [(const_int 0)]\n {\n   operands[4] = ix86_force_to_memory (GET_MODE (operands[1]), operands[1]);\n@@ -16681,7 +16719,8 @@\n \t   [(match_operand 1 \"register_operand\" \"\")\n \t    (float (match_operand:X87MODEI12 2 \"register_operand\" \"\"))]))]\n   \"reload_completed\n-   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\"\n+   && X87_FLOAT_MODE_P (GET_MODE (operands[0]))\n+   && X87_ENABLE_FLOAT (GET_MODE (operands[0]), GET_MODE (operands[2]))\"\n   [(const_int 0)]\n {\n   operands[4] = ix86_force_to_memory (GET_MODE (operands[2]), operands[2]);\n@@ -16767,7 +16806,7 @@\n   [(set (match_operand:MODEF 0 \"register_operand\" \"\")\n \t(sqrt:MODEF\n \t  (match_operand:MODEF 1 \"nonimmediate_operand\" \"\")))]\n-  \"TARGET_USE_FANCY_MATH_387\n+  \"(TARGET_USE_FANCY_MATH_387 && X87_ENABLE_ARITH (<MODE>mode))\n    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\"\n {\n   if (<MODE>mode == SFmode"}, {"sha": "b6a9d3dc5315595c24d5a4f9d5c4c8ea97eae10b", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -326,7 +326,8 @@ convert_to_real (tree type, tree expr)\n \t\t      && (flag_unsafe_math_optimizations\n \t\t\t  || (TYPE_PRECISION (newtype) == TYPE_PRECISION (type)\n \t\t\t      && real_can_shorten_arithmetic (TYPE_MODE (itype),\n-\t\t\t\t\t\t\t      TYPE_MODE (type)))))\n+\t\t\t\t\t\t\t      TYPE_MODE (type))\n+\t\t\t      && !excess_precision_type (newtype))))\n \t\t    {\n \t\t      expr = build2 (TREE_CODE (expr), newtype,\n \t\t\t\t     fold (convert_to_real (newtype, arg0)),"}, {"sha": "a1863cd1309aadd72d0bf337884d8beb716d4b78", "filename": "gcc/defaults.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -688,8 +688,11 @@ along with GCC; see the file COPYING3.  If not see\n #define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n #endif\n \n-#ifndef TARGET_FLT_EVAL_METHOD\n+#ifdef TARGET_FLT_EVAL_METHOD\n+#define TARGET_FLT_EVAL_METHOD_NON_DEFAULT 1\n+#else\n #define TARGET_FLT_EVAL_METHOD 0\n+#define TARGET_FLT_EVAL_METHOD_NON_DEFAULT 0\n #endif\n \n #ifndef TARGET_DEC_EVAL_METHOD"}, {"sha": "19ac3083a65963c586a9c294f9daf588f77a877f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -329,8 +329,9 @@ Objective-C and Objective-C++ Dialects}.\n -fdata-sections -fdce -fdce @gol\n -fdelayed-branch -fdelete-null-pointer-checks -fdse -fdse @gol\n -fearly-inlining -fexpensive-optimizations -ffast-math @gol\n--ffinite-math-only -ffloat-store -fforward-propagate @gol\n--ffunction-sections -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm @gol\n+-ffinite-math-only -ffloat-store -fexcess-precision=@var{style} @gol\n+-fforward-propagate -ffunction-sections @gol\n+-fgcse -fgcse-after-reload -fgcse-las -fgcse-lm @gol\n -fgcse-sm -fif-conversion -fif-conversion2 -findirect-inlining @gol\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n -finline-small-functions -fipa-cp -fipa-cp-clone -fipa-matrix-reorg -fipa-pta @gol \n@@ -6783,6 +6784,32 @@ good, but a few programs rely on the precise definition of IEEE floating\n point.  Use @option{-ffloat-store} for such programs, after modifying\n them to store all pertinent intermediate computations into variables.\n \n+@item -fexcess-precision=@var{style}\n+@opindex fexcess-precision\n+This option allows further control over excess precision on machines\n+where floating-point registers have more precision than the IEEE\n+@code{float} and @code{double} types and the processor does not\n+support operations rounding to those types.  By default,\n+@option{-fexcess-precision=fast} is in effect; this means that\n+operations are carried out in the precision of the registers and that\n+it is unpredictable when rounding to the types specified in the source\n+code takes place.  When compiling C, if\n+@option{-fexcess-precision=standard} is specified then excess\n+precision will follow the rules specified in ISO C99; in particular,\n+both casts and assignments cause values to be rounded to their\n+semantic types (whereas @option{-ffloat-store} only affects\n+assignments).  This option is enabled by default for C if a strict\n+conformance option such as @option{-std=c99} is used.\n+\n+@opindex mfpmath\n+@option{-fexcess-precision=standard} is not implemented for languages\n+other than C, and has no effect if\n+@option{-funsafe-math-optimizations} or @option{-ffast-math} is\n+specified.  On the x86, it also has no effect if @option{-mfpmath=sse}\n+or @option{-mfpmath=sse+387} is specified; in the former case, IEEE\n+semantics apply without excess precision, and in the latter, rounding\n+is unpredictable.\n+\n @item -ffast-math\n @opindex ffast-math\n Sets @option{-fno-math-errno}, @option{-funsafe-math-optimizations},\n@@ -11000,7 +11027,7 @@ specifying @option{-march=@var{cpu-type}} implies @option{-mtune=@var{cpu-type}}\n A deprecated synonym for @option{-mtune}.\n \n @item -mfpmath=@var{unit}\n-@opindex march\n+@opindex mfpmath\n Generate floating point arithmetics for selected unit @var{unit}.  The choices\n for @var{unit} are:\n "}, {"sha": "e606f601f6e09c2e4850995efe3636f2e5de7bee", "filename": "gcc/flags.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -227,6 +227,21 @@ extern enum ira_region flag_ira_region;\n \n extern unsigned int flag_ira_verbose;\n \n+/* The options for excess precision.  */\n+enum excess_precision\n+{\n+  EXCESS_PRECISION_DEFAULT,\n+  EXCESS_PRECISION_FAST,\n+  EXCESS_PRECISION_STANDARD\n+};\n+\n+/* The excess precision specified on the command line, or defaulted by\n+   the front end.  */\n+extern enum excess_precision flag_excess_precision_cmdline;\n+\n+/* The excess precision currently in effect.  */\n+extern enum excess_precision flag_excess_precision;\n+\n \f\n /* Other basic status info about current function.  */\n "}, {"sha": "d4a24ddc1f95ae375d0edaa8cd925aa96f56a51a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1,3 +1,11 @@\n+2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR rtl-optimization/323\n+\t* options.c (gfc_post_options): Set\n+\tflag_excess_precision_cmdline.  Give an error for\n+\t-fexcess-precision=standard for processors where the option is\n+\tsignificant.\n+\n 2009-03-29  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR preprocessor/34695"}, {"sha": "17c577d38bed549428557fd6729d2a4fd3e6fab5", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gfortran.h\"\n #include \"target.h\"\n #include \"cpp.h\"\n+#include \"toplev.h\"\n+#include \"tm.h\"\n \n gfc_option_t gfc_option;\n \n@@ -228,6 +230,13 @@ gfc_post_options (const char **pfilename)\n   char *source_path;\n   int i;\n \n+  /* Excess precision other than \"fast\" requires front-end\n+     support.  */\n+  if (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD\n+      && TARGET_FLT_EVAL_METHOD_NON_DEFAULT)\n+    sorry (\"-fexcess-precision=standard for Fortran\");\n+  flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n+\n   /* Issue an error if -fwhole-program was used.  */\n   if (flag_whole_program)\n     gfc_fatal_error (\"Option -fwhole-program is not supported for Fortran\");"}, {"sha": "a72a2f9470195d9cc40a7db21315d5e1e1f87ed1", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1,3 +1,10 @@\n+2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR rtl-optimization/323\n+\t* lang.c (java_post_options): Set flag_excess_precision_cmdline.\n+\tGive an error for -fexcess-precision=standard for processors where\n+\tthe option is significant.\n+\n 2009-03-18  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* lang.opt: Unify help text for -Wdeprecated."}, {"sha": "c4311412e3ec313a53baf92533987bae1af3736d", "filename": "gcc/java/lang.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -528,6 +528,13 @@ java_post_options (const char **pfilename)\n {\n   const char *filename = *pfilename;\n \n+  /* Excess precision other than \"fast\" requires front-end\n+     support.  */\n+  if (flag_excess_precision_cmdline == EXCESS_PRECISION_STANDARD\n+      && TARGET_FLT_EVAL_METHOD_NON_DEFAULT)\n+    sorry (\"-fexcess-precision=standard for Java\");\n+  flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n+\n   /* An absolute requirement: if we're not using indirect dispatch, we\n      must always verify everything.  */\n   if (! flag_indirect_dispatch)"}, {"sha": "196413792da2f32a54beb15f901204133b6c76d2", "filename": "gcc/langhooks.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -105,6 +105,9 @@ lhd_return_null_const_tree (const_tree ARG_UNUSED (t))\n bool\n lhd_post_options (const char ** ARG_UNUSED (pfilename))\n {\n+  /* Excess precision other than \"fast\" requires front-end\n+     support.  */\n+  flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n   return false;\n }\n "}, {"sha": "e3187901634b1459ded371558f790406ee36c0e3", "filename": "gcc/opts.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1728,6 +1728,15 @@ common_handle_option (size_t scode, const char *arg, int value,\n \treturn 0;\n       break;\n \n+    case OPT_fexcess_precision_:\n+      if (!strcmp (arg, \"fast\"))\n+\tflag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n+      else if (!strcmp (arg, \"standard\"))\n+\tflag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n+      else\n+\terror (\"unknown excess precision style \\\"%s\\\"\", arg);\n+      break;\n+\n     case OPT_ffast_math:\n       set_fast_math_flags (value);\n       break;"}, {"sha": "37dcc216915beca0b0bd719b4fdd7cd0d814e243", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -1,3 +1,13 @@\n+2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR rtl-optimization/323\n+\t* gcc.target/i386/excess-precision-1.c,\n+\tgcc.target/i386/excess-precision-2.c,\n+\tgcc.target/i386/excess-precision-3.c,\n+\tgcc.target/i386/excess-precision-4.c,\n+\tgcc.target/i386/excess-precision-5.c,\n+\tgcc.target/i386/excess-precision-6.c: New tests.\n+\n 2009-03-30  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/35235"}, {"sha": "3d5e7d288f723be3bbbede49aea1da41754f9e1f", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-1.c", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-1.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -0,0 +1,186 @@\n+/* Excess precision tests.  Test that excess precision is carried\n+   through various operations.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fexcess-precision=standard\" } */\n+\n+#include <float.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+volatile float f1 = 1.0f;\n+volatile float f2 = 0x1.0p-30f;\n+volatile float f3 = 0x1.0p-60f;\n+volatile double d1 = 1.0;\n+volatile double d2 = 0x1.0p-30;\n+volatile double d3 = 0x1.0p-60;\n+volatile float fadd1 = 1.0f + 0x1.0p-30f;\n+volatile double dadd2 = 1.0 + 0x1.0p-30 + 0x1.0p-60;\n+volatile long double ldadd1 = 1.0l + 0x1.0p-30l;\n+volatile long double ldadd2 = 1.0l + 0x1.0p-30l + 0x1.0p-60l;\n+\n+void\n+test_add (void)\n+{\n+  if (f1 + f2 != ldadd1)\n+    abort ();\n+  if (f1 + f2 + f3 != ldadd2)\n+    abort ();\n+  if (d1 + d2 != ldadd1)\n+    abort ();\n+  if (d1 + d2 + d3 != ldadd2)\n+    abort ();\n+  if (f1 + d2 + f3 != ldadd2)\n+    abort ();\n+  if (f1 + f2 == fadd1)\n+    abort ();\n+  if (f1 + f2 <= fadd1)\n+    abort ();\n+  if (f1 + f2 < fadd1)\n+    abort ();\n+  if (d1 + d2 + d3 == dadd2)\n+    abort ();\n+  if (!(d1 + d2 + d3 > dadd2))\n+    abort ();\n+  if (!(d1 + d2 + d3 >= dadd2))\n+    abort ();\n+}\n+\n+volatile long double ldsub1 = 1.0l - 0x1.0p-30l;\n+volatile long double ldsub2 = 1.0l - 0x1.0p-30l - 0x1.0p-60l;\n+\n+void\n+test_sub (void)\n+{\n+  if (f1 - f2 != ldsub1)\n+    abort ();\n+  if (f1 - f2 - f3 != ldsub2)\n+    abort ();\n+  if (d1 - d2 != ldsub1)\n+    abort ();\n+  if (d1 - d2 - d3 != ldsub2)\n+    abort ();\n+  if (f1 - d2 - f3 != ldsub2)\n+    abort ();\n+  if (+(f1 - d2 - f3) != ldsub2)\n+    abort ();\n+  if (-(f1 - d2 - f3) != -ldsub2)\n+    abort ();\n+}\n+\n+volatile float flt_min = FLT_MIN;\n+volatile double dbl_min = DBL_MIN;\n+volatile long double flt_min2 = (long double)FLT_MIN * (long double)FLT_MIN;\n+volatile long double dbl_min3 = (long double)DBL_MIN * (long double)DBL_MIN * (long double)DBL_MIN;\n+\n+void\n+test_mul (void)\n+{\n+  if (flt_min * flt_min != flt_min2)\n+    abort ();\n+  if (flt_min * flt_min == 0)\n+    abort ();\n+  if (flt_min * flt_min == 0)\n+    abort ();\n+  if (!(flt_min * flt_min))\n+    abort ();\n+  if (dbl_min * dbl_min * dbl_min != dbl_min3)\n+    abort ();\n+  if ((long double)(dbl_min * dbl_min * dbl_min) != dbl_min3)\n+    abort ();\n+  if ((0, dbl_min * dbl_min * dbl_min) != dbl_min3)\n+    abort ();\n+  if (dbl_min * dbl_min * dbl_min == 0)\n+    abort ();\n+  if ((flt_min * flt_min ? dbl_min * dbl_min * dbl_min : 0) == 0)\n+    abort ();\n+  if ((flt_min * flt_min ? : 0) == 0)\n+    abort ();\n+}\n+\n+volatile float f4 = 0x1.0p100f;\n+volatile double d4 = 0x1.0p100;\n+volatile long double flt_div = 0x1.0p100l / (long double) FLT_MIN;\n+volatile long double dbl_div = 0x1.0p100l / (long double) DBL_MIN;\n+\n+void\n+test_div (void)\n+{\n+  if (f4 / flt_min != flt_div)\n+    abort ();\n+  if (d4 / dbl_min != dbl_div)\n+    abort ();\n+}\n+\n+volatile float f5 = 0x1.0p30;\n+\n+void\n+test_cast (void)\n+{\n+  if ((int)(f1 + f5) != 0x40000001)\n+    abort ();\n+}\n+\n+volatile float _Complex f1c = 1.0f + 1.0if;\n+volatile float _Complex f2c = 0x1.0p-30f + 0x1.0p-31if;\n+volatile float _Complex f3c = 0x1.0p-60f + 0x1.0p-59if;\n+volatile double _Complex d1c = 1.0 + 1.0i;\n+volatile double _Complex d2c = 0x1.0p-30 + 0x1.0p-31i;\n+volatile double _Complex d3c = 0x1.0p-60 + 0x1.0p-59i;\n+volatile long double _Complex ldadd1c = 1.0l + 0x1.0p-30l + 1.0il + 0x1.0p-31il;\n+volatile long double _Complex ldadd2c = 1.0l + 0x1.0p-30l + 0x1.0p-60l + 1.0il + 0x1.0p-31il + 0x1.0p-59il;\n+volatile long double _Complex ldadd2cc = 1.0l + 0x1.0p-30l + 0x1.0p-60l - 1.0il - 0x1.0p-31il - 0x1.0p-59il;\n+volatile float _Complex flt_minc = FLT_MIN;\n+volatile double _Complex dbl_minc = DBL_MIN;\n+volatile float _Complex f4c = 0x1.0p100f;\n+volatile double _Complex d4c = 0x1.0p100;\n+\n+void\n+test_complex (void)\n+{\n+  if (f1c + f2c != ldadd1c)\n+    abort ();\n+  if (f1c + f2c + f3c != ldadd2c)\n+    abort ();\n+  if (d1c + d2c != ldadd1c)\n+    abort ();\n+  if (d1c + d2c + d3c != ldadd2c)\n+    abort ();\n+  if (__real__ (f1c + f2c + f3c) != ldadd2)\n+    abort ();\n+  if (__imag__ (d1c + d2c + d3c) != __imag__ ldadd2c)\n+    abort ();\n+  if (~(d1c + d2c + d3c) != ldadd2cc)\n+    abort ();\n+  /* The following call libgcc functions and so would fail unless they\n+     call those for long double.  */\n+  if (flt_minc * flt_minc != flt_min2)\n+    abort ();\n+  if (dbl_minc * dbl_minc * dbl_minc != dbl_min3)\n+    abort ();\n+  if (f4c / flt_minc != flt_div)\n+    abort ();\n+  if (d4c / dbl_minc != dbl_div)\n+    abort ();\n+  if (f4 / flt_minc != flt_div)\n+    abort ();\n+  if (d4 / dbl_minc != dbl_div)\n+    abort ();\n+  if (f4c / flt_min != flt_div)\n+    abort ();\n+  if (d4c / dbl_min != dbl_div)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  test_add ();\n+  test_sub ();\n+  test_mul ();\n+  test_div ();\n+  test_cast ();\n+  test_complex ();\n+  exit (0);\n+}"}, {"sha": "1075cd0830e55b40358804f4b5548fa4769e0d9a", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-2.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -0,0 +1,34 @@\n+/* Excess precision tests.  Test excess precision of constants.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fexcess-precision=standard\" } */\n+\n+#include <float.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+volatile long double ldadd1 = 1.0l + 0x1.0p-30l;\n+volatile long double ld11f = 1.1f;\n+volatile long double ld11d = 1.1;\n+volatile long double ld11 = 1.1;\n+\n+void\n+test_const (void)\n+{\n+  if (1.0f + 0x1.0p-30f != ldadd1)\n+    abort ();\n+  if (ld11f != ld11)\n+    abort ();\n+  if (ld11d != ld11)\n+    abort ();\n+  if (1.1f != ld11)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  test_const ();\n+  exit (0);\n+}"}, {"sha": "0cdcb3d37b6714be6565a6fbaa2bbb05dc03cf23", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-3.c", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-3.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -0,0 +1,219 @@\n+/* Excess precision tests.  Test excess precision is removed when\n+   necessary.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fexcess-precision=standard\" } */\n+\n+#include <float.h>\n+#include <stdarg.h>\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+volatile float f1 = 1.0f;\n+volatile float f2 = 0x1.0p-30f;\n+volatile float f3 = 0x1.0p-60f;\n+volatile double d1 = 1.0;\n+volatile double d2 = 0x1.0p-30;\n+volatile double d3 = 0x1.0p-60;\n+volatile float fadd1 = 1.0f + 0x1.0p-30f;\n+volatile double dadd2 = 1.0 + 0x1.0p-30 + 0x1.0p-60;\n+volatile double dh = 0x1.0p-24;\n+volatile float fha = 1.0f + 0x1.0p-23f;\n+\n+void\n+test_assign (void)\n+{\n+  float f;\n+  double d;\n+  f = f1 + f2;\n+  if (f != fadd1)\n+    abort ();\n+  d = f1 + f2;\n+  if (d != dadd2)\n+    abort ();\n+  d = d1 + d2 + d3;\n+  if (d != dadd2)\n+    abort ();\n+  /* Verify rounding direct to float without double rounding.  */\n+  f = d1 + dh + d3;\n+  if (f != fha)\n+    abort ();\n+}\n+\n+void\n+test_init (void)\n+{\n+  float f = f1 + f2;\n+  double d = d1 + d2 + d3;\n+  if (f != fadd1)\n+    abort ();\n+  if (d != dadd2)\n+    abort ();\n+}\n+\n+volatile int i1 = 0x40000001;\n+volatile unsigned int u1 = 0x80000001u;\n+volatile long long ll1 = 0x4000000000000001ll;\n+volatile unsigned long long ull1 = 0x8000000000000001ull;\n+\n+void\n+test_cast (void)\n+{\n+  if ((float)(f1 + f2) != fadd1)\n+    abort ();\n+  if ((double)(d1 + d2 + d3) != dadd2)\n+    abort ();\n+  if ((double)(f1 + f2 + f3) != dadd2)\n+    abort ();\n+  if ((float)i1 != 0x1.0p30f)\n+    abort ();\n+  if ((float)u1 != 0x1.0p31f)\n+    abort ();\n+  if ((float)ll1 != 0x1.0p62f)\n+    abort ();\n+  if ((float)ull1 != 0x1.0p63f)\n+    abort ();\n+  if ((double)ll1 != 0x1.0p62)\n+    abort ();\n+  if ((double)ull1 != 0x1.0p63)\n+    abort ();\n+}\n+\n+static inline void\n+check_float (float f)\n+{\n+  if (f != fadd1)\n+    abort ();\n+}\n+\n+static inline void\n+check_double (double d)\n+{\n+  if (d != dadd2)\n+    abort ();\n+}\n+\n+static inline void\n+check_float_nonproto (f)\n+     float f;\n+{\n+  if (f != fadd1)\n+    abort ();\n+}\n+\n+static inline void\n+check_double_nonproto (d)\n+     double d;\n+{\n+  if (d != dadd2)\n+    abort ();\n+}\n+\n+static void\n+check_double_va (int i, ...)\n+{\n+  va_list ap;\n+  va_start (ap, i);\n+  if (va_arg (ap, double) != dadd2)\n+    abort ();\n+  va_end (ap);\n+}\n+\n+void\n+test_call (void)\n+{\n+  check_float (f1 + f2);\n+  check_double (d1 + d2 + d3);\n+  check_double (f1 + f2 + f3);\n+  check_float_nonproto (f1 + f2);\n+  check_double_nonproto (d1 + d2 + d3);\n+  check_double_nonproto (f1 + f2 + f3);\n+  check_double_va (0, d1 + d2 + d3);\n+  check_double_va (0, f1 + f2 + f3);\n+}\n+\n+static inline float\n+return_float (void)\n+{\n+  return f1 + f2;\n+}\n+\n+static inline double\n+return_double1 (void)\n+{\n+  return d1 + d2 + d3;\n+}\n+\n+static inline double\n+return_double2 (void)\n+{\n+  return f1 + f2 + f3;\n+}\n+\n+void\n+test_return (void)\n+{\n+  if (return_float () != fadd1)\n+    abort ();\n+  if (return_double1 () != dadd2)\n+    abort ();\n+  if (return_double2 () != dadd2)\n+    abort ();\n+}\n+\n+volatile float flt_min = FLT_MIN;\n+volatile double dbl_min = DBL_MIN;\n+volatile float flt_max = FLT_MAX;\n+volatile double dbl_max = DBL_MAX;\n+\n+void\n+test_builtin (void)\n+{\n+  /* Classification macros convert to the semantic type.  signbit and\n+     comparison macros do not.  */\n+  if (!__builtin_isinf (flt_max * flt_max))\n+    abort ();\n+  if (!__builtin_isinf (dbl_max * dbl_max))\n+    abort ();\n+  if (__builtin_isnormal (flt_max * flt_max))\n+    abort ();\n+  if (__builtin_isnormal (dbl_max * dbl_max))\n+    abort ();\n+  if (__builtin_isfinite (flt_max * flt_max))\n+    abort ();\n+  if (__builtin_isfinite (dbl_max * dbl_max))\n+    abort ();\n+  if (!__builtin_isgreater (flt_min * flt_min, 0.0f))\n+    abort ();\n+  if (!__builtin_isgreaterequal (flt_min * flt_min, 0.0f))\n+    abort ();\n+  if (!__builtin_isless (0.0f, flt_min * flt_min))\n+    abort ();\n+  if (__builtin_islessequal (flt_min * flt_min, 0.0f))\n+    abort ();\n+  if (!__builtin_islessgreater (flt_min * flt_min, 0.0f))\n+    abort ();\n+  if (!__builtin_isgreater (dbl_min * dbl_min, 0.0))\n+    abort ();\n+  if (!__builtin_isgreaterequal (dbl_min * dbl_min, 0.0))\n+    abort ();\n+  if (!__builtin_isless (0.0, dbl_min * dbl_min))\n+    abort ();\n+  if (__builtin_islessequal (dbl_min * dbl_min, 0.0))\n+    abort ();\n+  if (!__builtin_islessgreater (dbl_min * dbl_min, 0.0))\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  test_assign ();\n+  test_init ();\n+  test_cast ();\n+  test_call ();\n+  test_return ();\n+  test_builtin ();\n+  exit (0);\n+}"}, {"sha": "db44b0f526e23b4b9294ad0f2c819b60eceb600f", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-4.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-4.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -0,0 +1,8 @@\n+/* Excess precision tests.  Test diagnostics for excess precision of\n+   constants.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-fexcess-precision=standard\" } */\n+\n+float f = 0.0f * 1e50f; /* { dg-warning \"floating constant exceeds range of 'float'\" } */\n+double d = 0.0 * 1e400; /* { dg-warning \"floating constant exceeds range of 'double'\" } */"}, {"sha": "9c765922b8115c2481e5f33c90161c4480d864ab", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-5.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -0,0 +1,23 @@\n+/* Excess precision tests.  Verify excess precision doesn't affect\n+   actual types.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-fexcess-precision=standard\" } */\n+\n+float f;\n+double d;\n+\n+void\n+test_types (void)\n+{\n+  float *fp;\n+  double *dp;\n+#define CHECK_FLOAT(E) fp = &(typeof(E)){0}\n+#define CHECK_DOUBLE(E) dp = &(typeof(E)){0}\n+  CHECK_FLOAT (f + f);\n+  CHECK_DOUBLE (d + d);\n+  CHECK_FLOAT (f * f / f);\n+  CHECK_DOUBLE (d * d / d);\n+  CHECK_FLOAT (f ? f - f : f);\n+  CHECK_DOUBLE (d ? d - d : d);\n+}"}, {"sha": "1d421c911c444cdb01ff2270cb8e21146ca624cb", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-6.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -0,0 +1,20 @@\n+/* Excess precision tests.  Make sure sqrt is not inlined for float or\n+   double.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fno-math-errno -fexcess-precision=standard\" } */\n+\n+float f;\n+double d;\n+\n+float fr;\n+double dr;\n+\n+void\n+test_builtins (void)\n+{\n+  fr = __builtin_sqrtf (f);\n+  dr = __builtin_sqrt (d);\n+}\n+\n+/* { dg-final { scan-assembler-not \"fsqrt\" } } */"}, {"sha": "72f3d3087d3b4b4a81ea3edec1db04c25fbcfe9b", "filename": "gcc/toplev.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -281,6 +281,11 @@ enum ira_region flag_ira_region = IRA_REGION_MIXED;\n \n unsigned int flag_ira_verbose = 5;\n \n+/* Set the default for excess precision.  */\n+\n+enum excess_precision flag_excess_precision_cmdline = EXCESS_PRECISION_DEFAULT;\n+enum excess_precision flag_excess_precision = EXCESS_PRECISION_DEFAULT;\n+\n /* Nonzero means change certain warnings into errors.\n    Usually these are warnings about failure to conform to some standard.  */\n \n@@ -2033,11 +2038,51 @@ backend_init (void)\n   backend_init_target ();\n }\n \n+/* Initialize excess precision settings.  */\n+static void\n+init_excess_precision (void)\n+{\n+  /* Adjust excess precision handling based on the target options.  If\n+     the front end cannot handle it, flag_excess_precision_cmdline\n+     will already have been set accordingly in the post_options\n+     hook.  */\n+  gcc_assert (flag_excess_precision_cmdline != EXCESS_PRECISION_DEFAULT);\n+  flag_excess_precision = flag_excess_precision_cmdline;\n+  if (flag_unsafe_math_optimizations)\n+    flag_excess_precision = EXCESS_PRECISION_FAST;\n+  if (flag_excess_precision == EXCESS_PRECISION_STANDARD)\n+    {\n+      int flt_eval_method = TARGET_FLT_EVAL_METHOD;\n+      switch (flt_eval_method)\n+\t{\n+\tcase -1:\n+\tcase 0:\n+\t  /* Either the target acts unpredictably (-1) or has all the\n+\t     operations required not to have excess precision (0).  */\n+\t  flag_excess_precision = EXCESS_PRECISION_FAST;\n+\t  break;\n+\tcase 1:\n+\tcase 2:\n+\t  /* In these cases, predictable excess precision makes\n+\t     sense.  */\n+\t  break;\n+\tdefault:\n+\t  /* Any other implementation-defined FLT_EVAL_METHOD values\n+\t     require the compiler to handle the associated excess\n+\t     precision rules in excess_precision_type.  */\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n /* Initialize things that are both lang-dependent and target-dependent.\n    This function can be called more than once if target parameters change.  */\n static void\n lang_dependent_init_target (void)\n {\n+  /* This determines excess precision settings.  */\n+  init_excess_precision ();\n+\n   /* This creates various _DECL nodes, so needs to be called after the\n      front end is initialized.  It also depends on the HAVE_xxx macros\n      generated from the target machine description.  */"}, {"sha": "76cba2712268645bdf30d265a8ab6875e94c316d", "filename": "gcc/tree.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -6258,6 +6258,61 @@ build_complex_type (tree component_type)\n \n   return build_qualified_type (t, TYPE_QUALS (component_type));\n }\n+\n+/* If TYPE is a real or complex floating-point type and the target\n+   does not directly support arithmetic on TYPE then return the wider\n+   type to be used for arithmetic on TYPE.  Otherwise, return\n+   NULL_TREE.  */\n+\n+tree\n+excess_precision_type (tree type)\n+{\n+  if (flag_excess_precision != EXCESS_PRECISION_FAST)\n+    {\n+      int flt_eval_method = TARGET_FLT_EVAL_METHOD;\n+      switch (TREE_CODE (type))\n+\t{\n+\tcase REAL_TYPE:\n+\t  switch (flt_eval_method)\n+\t    {\n+\t    case 1:\n+\t      if (TYPE_MODE (type) == TYPE_MODE (float_type_node))\n+\t\treturn double_type_node;\n+\t      break;\n+\t    case 2:\n+\t      if (TYPE_MODE (type) == TYPE_MODE (float_type_node)\n+\t\t  || TYPE_MODE (type) == TYPE_MODE (double_type_node))\n+\t\treturn long_double_type_node;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase COMPLEX_TYPE:\n+\t  if (TREE_CODE (TREE_TYPE (type)) != REAL_TYPE)\n+\t    return NULL_TREE;\n+\t  switch (flt_eval_method)\n+\t    {\n+\t    case 1:\n+\t      if (TYPE_MODE (TREE_TYPE (type)) == TYPE_MODE (float_type_node))\n+\t\treturn complex_double_type_node;\n+\t      break;\n+\t    case 2:\n+\t      if (TYPE_MODE (TREE_TYPE (type)) == TYPE_MODE (float_type_node)\n+\t\t  || (TYPE_MODE (TREE_TYPE (type))\n+\t\t      == TYPE_MODE (double_type_node)))\n+\t\treturn complex_long_double_type_node;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n \f\n /* Return OP, stripped of any conversions to wider types as much as is safe.\n    Converting the value back to OP's type makes a value equivalent to OP."}, {"sha": "dbd0faae2f46a64b62ebfddc262c3958f454c053", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ce94e44465bcc958dc11270d9dee1775c7a4f43/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=8ce94e44465bcc958dc11270d9dee1775c7a4f43", "patch": "@@ -4040,6 +4040,7 @@ extern bool tree_expr_nonnegative_p (tree);\n extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n extern bool may_negate_without_overflow_p (const_tree);\n extern tree strip_array_types (tree);\n+extern tree excess_precision_type (tree);\n \n /* Construct various nodes representing fract or accum data types.  */\n "}]}