{"sha": "d383707213c835c7f50ad778229e2428fa402863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM4MzcwNzIxM2M4MzVjN2Y1MGFkNzc4MjI5ZTI0MjhmYTQwMjg2Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-02T08:03:07Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-10-02T08:03:07Z"}, "message": "re PR fortran/33554 (Seg.fault: Default initialization of derived type uses uninitialized values)\n\n2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33554\n\t* trans-decl.c (init_intent_out_dt): New function.\n\t(gfc_trans_deferred_vars): Remove the code for default\n\tinitialization of INTENT(OUT) derived types and put it\n\tin the new function.  Call it earlier than before, so\n\tthat array offsets and lower bounds are available.\n\n2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/33554\n\t* gfortran.dg/intent_out_2.f90: New test.\n\nFrom-SVN: r128950", "tree": {"sha": "ff948ff9b958177f1fdfa3f78bf1080922b15f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff948ff9b958177f1fdfa3f78bf1080922b15f2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d383707213c835c7f50ad778229e2428fa402863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d383707213c835c7f50ad778229e2428fa402863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d383707213c835c7f50ad778229e2428fa402863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d383707213c835c7f50ad778229e2428fa402863/comments", "author": null, "committer": null, "parents": [{"sha": "a7ca4d8d3d7caa24e708267d8a6560eb6faf809a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7ca4d8d3d7caa24e708267d8a6560eb6faf809a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7ca4d8d3d7caa24e708267d8a6560eb6faf809a"}], "stats": {"total": 158, "additions": 97, "deletions": 61}, "files": [{"sha": "5af0989013d2e51f042944f058ba0a20f6762203", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d383707213c835c7f50ad778229e2428fa402863", "patch": "@@ -1,3 +1,12 @@\n+2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33554\n+\t* trans-decl.c (init_intent_out_dt): New function.\n+\t(gfc_trans_deferred_vars): Remove the code for default\n+\tinitialization of INTENT(OUT) derived types and put it\n+\tin the new function.  Call it earlier than before, so\n+\tthat array offsets and lower bounds are available.\n+\n 2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33550"}, {"sha": "f04a4d1b90402fce18cf4eea03dd09cf4400f89f", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d383707213c835c7f50ad778229e2428fa402863", "patch": "@@ -2558,6 +2558,44 @@ gfc_trans_vla_type_sizes (gfc_symbol *sym, stmtblock_t *body)\n }\n \n \n+/* Initialize INTENT(OUT) derived type dummies.  */\n+static tree\n+init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n+{\n+  stmtblock_t fnblock;\n+  gfc_formal_arglist *f;\n+  gfc_expr *tmpe;\n+  tree tmp;\n+  tree present;\n+\n+  gfc_init_block (&fnblock);\n+\n+  for (f = proc_sym->formal; f; f = f->next)\n+    {\n+      if (f->sym && f->sym->attr.intent == INTENT_OUT\n+\t    && f->sym->ts.type == BT_DERIVED\n+\t    && !f->sym->ts.derived->attr.alloc_comp\n+\t    && f->sym->value)\n+\t{\n+\t  gcc_assert (!f->sym->attr.allocatable);\n+\t  gfc_set_sym_referenced (f->sym);\n+\t  tmpe = gfc_lval_expr_from_sym (f->sym);\n+\t  tmp = gfc_trans_assignment (tmpe, f->sym->value, false);\n+\n+\t  present = gfc_conv_expr_present (f->sym);\n+\t  tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n+\t\t\ttmp, build_empty_stmt ());\n+\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t  gfc_free_expr (tmpe);\n+\t}\n+    }\n+\n+  gfc_add_expr_to_block (&fnblock, body);\n+  return gfc_finish_block (&fnblock);\n+}\n+\n+\n+\n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n     Allocation and initialization of array variables.\n@@ -2612,6 +2650,11 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t\t    && proc_sym->ts.type == BT_COMPLEX);\n     }\n \n+  /* Initialize the INTENT(OUT) derived type dummy arguments.  This\n+     should be done here so that the offsets and lbounds of arrays\n+     are available.  */\n+  fnbody = init_intent_out_dt (proc_sym, fnbody);\n+\n   for (sym = proc_sym->tlink; sym != proc_sym; sym = sym->tlink)\n     {\n       bool sym_has_alloc_comp = (sym->ts.type == BT_DERIVED)\n@@ -2710,27 +2753,6 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, tree fnbody)\n \t  if (TREE_CODE (f->sym->ts.cl->backend_decl) == PARM_DECL)\n \t    gfc_trans_vla_type_sizes (f->sym, &body);\n \t}\n-\n-      /* If an INTENT(OUT) dummy of derived type has a default\n-\t initializer, it must be initialized here.  */\n-      if (f->sym && f->sym->attr.intent == INTENT_OUT\n-\t    && f->sym->ts.type == BT_DERIVED\n-\t    && !f->sym->ts.derived->attr.alloc_comp\n-\t    && f->sym->value)\n-\t{\n-\t  gfc_expr *tmpe;\n-\t  tree tmp, present;\n-\t  gcc_assert (!f->sym->attr.allocatable);\n-\t  gfc_set_sym_referenced (f->sym);\n-\t  tmpe = gfc_lval_expr_from_sym (f->sym);\n-\t  tmp = gfc_trans_assignment (tmpe, f->sym->value, false);\n-\n-\t  present = gfc_conv_expr_present (f->sym);\n-\t  tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n-\t\t\ttmp, build_empty_stmt ());\n-\t  gfc_add_expr_to_block (&body, tmp);\n-\t  gfc_free_expr (tmpe);\n-\t}\n     }\n \n   if (gfc_return_by_reference (proc_sym) && proc_sym->ts.type == BT_CHARACTER"}, {"sha": "62187039a5dbf39c6a3c3681e8d411b47f617705", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d383707213c835c7f50ad778229e2428fa402863", "patch": "@@ -1,3 +1,8 @@\n+2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/33554\n+\t* gfortran.dg/intent_out_2.f90: New test.\n+\n 2007-10-02  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/33550"}, {"sha": "4dc5191e9a21c8244919e30d99853379ca1d075a", "filename": "gcc/testsuite/gfortran.dg/intent_out_2.f90", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d383707213c835c7f50ad778229e2428fa402863/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_2.f90?ref=d383707213c835c7f50ad778229e2428fa402863", "patch": "@@ -1,47 +1,47 @@\n-! { dg-do -run }\r\n+! { dg-do run }\n ! Tests the fix for PR33554, in which the default initialization\n ! of temp, in construct_temp, caused a segfault because it was\n ! being done before the array offset and lower bound were\n ! available.\n !\n ! Contributed by Harald Anlauf <anlauf@gmx.de> \n-!\r\n-module gfcbug72\r\n-  implicit none\r\n-\r\n-  type t_datum\r\n-    character(len=8) :: mn = 'abcdefgh'\r\n-  end type t_datum\r\n-\r\n-  type t_temp\r\n-    type(t_datum) :: p\r\n-  end type t_temp\r\n-\r\n-contains\r\n-\r\n-  subroutine setup ()\r\n-    integer :: i\r\n-    type (t_temp), pointer :: temp(:) => NULL ()\r\n-\r\n-    do i=1,2\r\n-       allocate (temp (2))\r\n-       call construct_temp (temp)\r\n-       if (any (temp % p% mn .ne. 'ijklmnop')) call abort ()\r\n-       deallocate (temp)\r\n-    end do\r\n-  end subroutine setup\r\n-  !--\r\n-  subroutine construct_temp (temp)\r\n-    type (t_temp), intent(out) :: temp (:)\r\n-    if (any (temp % p% mn .ne. 'abcdefgh')) call abort ()\r\n-    temp(:)% p% mn = 'ijklmnop'\r\n-  end subroutine construct_temp\r\n-end module gfcbug72\r\n-\r\n-program test\r\n-  use gfcbug72\r\n-  implicit none\r\n-  call setup ()\r\n-end program test\r\n+!\n+module gfcbug72\n+  implicit none\n+\n+  type t_datum\n+    character(len=8) :: mn = 'abcdefgh'\n+  end type t_datum\n+\n+  type t_temp\n+    type(t_datum) :: p\n+  end type t_temp\n+\n+contains\n+\n+  subroutine setup ()\n+    integer :: i\n+    type (t_temp), pointer :: temp(:) => NULL ()\n+\n+    do i=1,2\n+       allocate (temp (2))\n+       call construct_temp (temp)\n+       if (any (temp % p% mn .ne. 'ijklmnop')) call abort ()\n+       deallocate (temp)\n+    end do\n+  end subroutine setup\n+  !--\n+  subroutine construct_temp (temp)\n+    type (t_temp), intent(out) :: temp (:)\n+    if (any (temp % p% mn .ne. 'abcdefgh')) call abort ()\n+    temp(:)% p% mn = 'ijklmnop'\n+  end subroutine construct_temp\n+end module gfcbug72\n+\n+program test\n+  use gfcbug72\n+  implicit none\n+  call setup ()\n+end program test\n ! { dg-final { cleanup-modules \"gfcbug72\" } }\n-\r\n+"}]}