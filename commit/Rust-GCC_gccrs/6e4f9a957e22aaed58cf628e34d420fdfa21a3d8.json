{"sha": "6e4f9a957e22aaed58cf628e34d420fdfa21a3d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU0ZjlhOTU3ZTIyYWFlZDU4Y2Y2MjhlMzRkNDIwZmRmYTIxYTNkOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-08-05T02:58:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-08-05T02:58:15Z"}, "message": "re PR go/61308 (gccgo: ICE in Expression::check_bounds [GoSmith])\n\n\tPR go/61308\n\tPR go/61866\n\ncompiler: Don't cast index expr to int before bounds check.\n\nThis fixes http://gcc.gnu.org/PR61866 : on a 32-bit system,\ncasting an int64 index to int drops the upper 32 bits of the\nvalue, and thus can cause an out-of-range index to appear to\nbe in range.\n\nThis undoes part of change 1318:fa6e0c716dba\n(https://codereview.appspot.com/104610044) and therefore\nbreaks http://gcc.gnu.org/PR61308 again.  I have a separate\npatch for that (http://codereview.appspot.com/122020043).  In\naddition to undoing part of that change, this patch adds code\nto avoid a compiler crash.  This changes PR61308 from a\ncompiler crash to an incorrect error message.\n\nFrom-SVN: r213616", "tree": {"sha": "fa207e6e1795c5257fbe25dc8ef6be5f219245e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa207e6e1795c5257fbe25dc8ef6be5f219245e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e4f9a957e22aaed58cf628e34d420fdfa21a3d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4f9a957e22aaed58cf628e34d420fdfa21a3d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e4f9a957e22aaed58cf628e34d420fdfa21a3d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e4f9a957e22aaed58cf628e34d420fdfa21a3d8/comments", "author": null, "committer": null, "parents": [{"sha": "cb7b4e77170a356818298d5e7fa2f9db747b497f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7b4e77170a356818298d5e7fa2f9db747b497f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7b4e77170a356818298d5e7fa2f9db747b497f"}], "stats": {"total": 19, "additions": 16, "deletions": 3}, "files": [{"sha": "adc4fb092c4c9cdf90aa35529e4a390217b6b635", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e4f9a957e22aaed58cf628e34d420fdfa21a3d8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e4f9a957e22aaed58cf628e34d420fdfa21a3d8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6e4f9a957e22aaed58cf628e34d420fdfa21a3d8", "patch": "@@ -3620,6 +3620,16 @@ Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       return Expression::make_error(this->location());\n     }\n \n+  // Check for an invalid pointer dereference.  We need to do this\n+  // here because Unary_expression::do_type will return an error type\n+  // in this case.  That can cause code to appear erroneous, and\n+  // therefore disappear at lowering time, without any error message.\n+  if (op == OPERATOR_MULT && expr->type()->points_to() == NULL)\n+    {\n+      this->report_error(_(\"expected pointer\"));\n+      return Expression::make_error(this->location());\n+    }\n+\n   if (op == OPERATOR_PLUS || op == OPERATOR_MINUS || op == OPERATOR_XOR)\n     {\n       Numeric_constant nc;\n@@ -9811,7 +9821,10 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n \n   Type* type = left->type();\n   if (type->is_error())\n-    return Expression::make_error(location);\n+    {\n+      go_assert(saw_errors());\n+      return Expression::make_error(location);\n+    }\n   else if (left->is_type_expression())\n     {\n       error_at(location, \"attempt to index type expression\");\n@@ -10298,9 +10311,9 @@ Array_index_expression::do_get_backend(Translate_context* context)\n       go_assert(saw_errors());\n       return context->backend()->error_expression();\n     }\n-  Expression* start_expr = Expression::make_cast(int_type, this->start_, loc);\n+\n   Bexpression* bad_index =\n-    Expression::check_bounds(start_expr, loc)->get_backend(context);\n+    Expression::check_bounds(this->start_, loc)->get_backend(context);\n \n   Bexpression* start = this->start_->get_backend(context);\n   start = gogo->backend()->convert_expression(int_btype, start, loc);"}]}