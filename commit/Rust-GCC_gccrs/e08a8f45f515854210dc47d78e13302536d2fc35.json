{"sha": "e08a8f45f515854210dc47d78e13302536d2fc35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA4YThmNDVmNTE1ODU0MjEwZGM0N2Q3OGUxMzMwMjUzNmQyZmMzNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-03-23T00:01:48Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-03-23T00:01:48Z"}, "message": "cp-tree.h (TYPE_PTRMEMFUNC_P): Use TYPE_PTRMEMFUNC_FLAG.\n\n\t* cp-tree.h (TYPE_PTRMEMFUNC_P): Use TYPE_PTRMEMFUNC_FLAG.\n\tDocument internals of pointer-to-member-functions.\n\t(DELTA2_FROM_PTRMEMFUNC): Make it call delta2_from_ptrmemfunc.\n\t(PFN_FROM_PTRMEMFUNC): Similarly.\n\t(build_type_conversion): Remove unused parameter.\n\t(build_ptrmemfunc1): Declare.\n\t(expand_ptrmemfunc_cst): New function.\n\t(delta2_from_ptrmemfunc): Likewise.\n\t(pfn_from_ptrmemfunc): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Remove unused parameter to\n\tbuild_type_conversion.  Use TYPE_PTRMEM_P for readability.\n\t(convert_to_reference): Remove unused parameter to\n\tbuild_type_conversion.\n\t(ocp_convert): Likewise.\n\t(build_user_type_conversion): Likewise.\n\t* error.c (dump_expr): Handle NULL pointer-to-member functions.\n\t* expr.c (cplus_expand_expr): Handle PTRMEM_CSTs for functions.\n\t* method.c (build_overload_value): Don't go splitting CONSTRUCTORs\n\topen when handling pointer-to-member functions.\n\t* pt.c (convert_nontype_argument): Clean up error messages.  Be\n\tmore stringent with pointers-to-members.\n\t* typeck.c (build_ptrmemfunc1): Don't declare.  Make it global.\n\t(build_unary_op): Tidy ever-so-slightly.\n\t(build_conditional_expr): Remove extra parameter to\n\tbuild_type_conversion.\n\t(build_ptrmemfunc): Build PTRMEM_CSTs if we know what function\n\twe're using.\n\t(expand_ptrmemfunc_cst): Define.\n\t(delta2_from_ptrmemfunc): Likewise.\n\t(pfn_from_ptrmemfunc): Likewise.\n\nFrom-SVN: r25913", "tree": {"sha": "f11d1b07e9ec203859528a02af06b002e362a896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f11d1b07e9ec203859528a02af06b002e362a896"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e08a8f45f515854210dc47d78e13302536d2fc35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08a8f45f515854210dc47d78e13302536d2fc35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e08a8f45f515854210dc47d78e13302536d2fc35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e08a8f45f515854210dc47d78e13302536d2fc35/comments", "author": null, "committer": null, "parents": [{"sha": "edebba7aaef2d4af34267d0a52ebd6f57c5a28b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edebba7aaef2d4af34267d0a52ebd6f57c5a28b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edebba7aaef2d4af34267d0a52ebd6f57c5a28b3"}], "stats": {"total": 421, "additions": 310, "deletions": 111}, "files": [{"sha": "3dd84a890eb3bc265f71b8f655b70ebecaf9ce7e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -1,3 +1,36 @@\n+1999-03-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (TYPE_PTRMEMFUNC_P): Use TYPE_PTRMEMFUNC_FLAG.\n+\tDocument internals of pointer-to-member-functions.\n+\t(DELTA2_FROM_PTRMEMFUNC): Make it call delta2_from_ptrmemfunc.\n+\t(PFN_FROM_PTRMEMFUNC): Similarly.\n+\t(build_type_conversion): Remove unused parameter.\n+\t(build_ptrmemfunc1): Declare.\n+\t(expand_ptrmemfunc_cst): New function.\n+\t(delta2_from_ptrmemfunc): Likewise.\n+\t(pfn_from_ptrmemfunc): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Remove unused parameter to\n+\tbuild_type_conversion.  Use TYPE_PTRMEM_P for readability.\n+\t(convert_to_reference): Remove unused parameter to\n+\tbuild_type_conversion.\n+\t(ocp_convert): Likewise.\n+\t(build_user_type_conversion): Likewise.\n+\t* error.c (dump_expr): Handle NULL pointer-to-member functions.\n+\t* expr.c (cplus_expand_expr): Handle PTRMEM_CSTs for functions.\n+\t* method.c (build_overload_value): Don't go splitting CONSTRUCTORs\n+\topen when handling pointer-to-member functions.\n+\t* pt.c (convert_nontype_argument): Clean up error messages.  Be\n+\tmore stringent with pointers-to-members.\n+\t* typeck.c (build_ptrmemfunc1): Don't declare.  Make it global.\n+\t(build_unary_op): Tidy ever-so-slightly.\n+\t(build_conditional_expr): Remove extra parameter to\n+\tbuild_type_conversion.\n+\t(build_ptrmemfunc): Build PTRMEM_CSTs if we know what function\n+\twe're using.\n+\t(expand_ptrmemfunc_cst): Define.\n+\t(delta2_from_ptrmemfunc): Likewise.\n+\t(pfn_from_ptrmemfunc): Likewise.\n+\t\n 1999-03-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* init.c (build_member_call): Handle template-id expressions"}, {"sha": "59f3e30a3bbca06904cd62da9bcfb1aca502a3f3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -1682,8 +1682,63 @@ extern int flag_new_for_scope;\n \n /* Nonzero for _TYPE node means that this type is a pointer to member\n    function type.  */\n-#define TYPE_PTRMEMFUNC_P(NODE) (TREE_CODE(NODE) == RECORD_TYPE && TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n-#define TYPE_PTRMEMFUNC_FLAG(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n+#define TYPE_PTRMEMFUNC_P(NODE) \\\n+  (TREE_CODE(NODE) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (NODE))\n+#define TYPE_PTRMEMFUNC_FLAG(NODE) \\\n+  (TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n+\n+/* A pointer-to-function member type looks like:\n+\n+   struct {\n+     short __delta;\n+     short __index;\n+     union {\n+       P __pfn;\n+       short __delta2;\n+     } __pfn_or_delta2;\n+   };\n+\n+   where P is a POINTER_TYPE to a METHOD_TYPE appropriate for the\n+   pointer to member.  The fields are used as follows:\n+\n+     If __INDEX is -1, then the function to call is non-virtual, and\n+     is located at the address given by __PFN.\n+\n+     If __INDEX is zero, then this a NULL pointer-to-member.\n+\n+     Otherwise, the function to call is virtual.  Then, __DELTA2 gives\n+     the offset from an instance of the object to the virtual function\n+     table, and __INDEX - 1 is the index into the vtable to use to\n+     find the function.\n+\n+     The value to use for the THIS parameter is the address of the\n+     object plus __DELTA.\n+\n+   For example, given:\n+\n+     struct B1 {\n+       int i;\n+     };\n+\n+     struct B2 {\n+       double d;\n+       void f();\n+     };\n+\n+     struct S : public B1, B2 {};\n+\n+   the pointer-to-member for `&S::f' looks like:\n+\n+     { 4, -1, { &f__2B2 } };\n+\n+   The `4' means that given an `S*' you have to add 4 bytes to get to\n+   the address of the `B2*'.  Then, the -1 indicates that this is a\n+   non-virtual function.  Of course, `&f__2B2' is the name of that\n+   function.\n+\n+   (Of course, the exactl values may differ depending on the mangling\n+   scheme, sizes of types, and such.).  */\n+     \n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n    before using this macro.  */\n@@ -1698,8 +1753,8 @@ extern int flag_new_for_scope;\n #define TYPE_GET_PTRMEMFUNC_TYPE(NODE) ((tree)TYPE_LANG_SPECIFIC(NODE))\n #define TYPE_SET_PTRMEMFUNC_TYPE(NODE, VALUE) (TYPE_LANG_SPECIFIC(NODE) = ((struct lang_type *)(void*)(VALUE)))\n /* These are to get the delta2 and pfn fields from a TYPE_PTRMEMFUNC_P.  */\n-#define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), delta2_identifier, NULL_TREE, 0))\n-#define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), pfn_identifier, NULL_TREE, 0))\n+#define DELTA2_FROM_PTRMEMFUNC(NODE) delta2_from_ptrmemfunc ((NODE))\n+#define PFN_FROM_PTRMEMFUNC(NODE) pfn_from_ptrmemfunc ((NODE))\n \n /* For a pointer-to-member constant `X::Y' this is the RECORD_TYPE for\n    `X'.  */\n@@ -2711,7 +2766,7 @@ extern tree ocp_convert\t\t\t\tPROTO((tree, tree, int, int));\n extern tree cp_convert\t\t\t\tPROTO((tree, tree));\n extern tree convert\t\t\t\tPROTO((tree, tree));\n extern tree convert_force\t\t\tPROTO((tree, tree, int));\n-extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n+extern tree build_type_conversion\t\tPROTO((tree, tree, int));\n extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n extern tree type_promotes_to\t\t\tPROTO((tree));\n extern tree perform_qualification_conversions   PROTO((tree, tree));\n@@ -3417,6 +3472,10 @@ extern int cp_type_quals                        PROTO((tree));\n extern int cp_has_mutable_p                     PROTO((tree));\n extern int at_least_as_qualified_p              PROTO((tree, tree));\n extern int more_qualified_p                     PROTO((tree, tree));\n+extern tree build_ptrmemfunc1                   PROTO((tree, tree, tree, tree, tree));\n+extern void expand_ptrmemfunc_cst               PROTO((tree, tree *, tree *, tree *, tree *));\n+extern tree delta2_from_ptrmemfunc              PROTO((tree));\n+extern tree pfn_from_ptrmemfunc                 PROTO((tree));\n \n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPROTO((tree, tree));"}, {"sha": "72721ce9bca6a32b9d0a082bc32a72746d3339c6", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -85,7 +85,7 @@ cp_convert_to_pointer (type, expr)\n \t  return error_mark_node;\n \t}\n \n-      rval = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n+      rval = build_type_conversion (type, expr, 1);\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)\n@@ -177,9 +177,7 @@ cp_convert_to_pointer (type, expr)\n \t    }\n \t}\n \n-      if (TREE_CODE (type) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE\n-\t  && TREE_CODE (TREE_TYPE (intype)) == OFFSET_TYPE)\n+      if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n \t{\n \t  tree b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n \t  tree b2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (intype));\n@@ -432,7 +430,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n \n       rval_as_conversion\n-\t= build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n+\t= build_type_conversion (reftype, expr, 1);\n \n       if (rval_as_conversion && rval_as_conversion != error_mark_node\n \t  && real_lvalue_p (rval_as_conversion))\n@@ -735,7 +733,7 @@ ocp_convert (type, expr, convtype, flags)\n       if (IS_AGGR_TYPE (intype))\n \t{\n \t  tree rval;\n-\t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);\n+\t  rval = build_type_conversion (type, e, 1);\n \t  if (rval)\n \t    return rval;\n \t  if (flags & LOOKUP_COMPLAIN)\n@@ -762,7 +760,7 @@ ocp_convert (type, expr, convtype, flags)\n       if (IS_AGGR_TYPE (TREE_TYPE (e)))\n \t{\n \t  tree rval;\n-\t  rval = build_type_conversion (CONVERT_EXPR, type, e, 1);\n+\t  rval = build_type_conversion (type, e, 1);\n \t  if (rval)\n \t    return rval;\n \t  else\n@@ -948,8 +946,7 @@ convert_force (type, expr, convtype)\n    (jason 8/9/95)  */\n \n tree\n-build_type_conversion (code, xtype, expr, for_sure)\n-     enum tree_code code ATTRIBUTE_UNUSED;\n+build_type_conversion (xtype, expr, for_sure)\n      tree xtype, expr;\n      int for_sure;\n {"}, {"sha": "90f0a36975852e1b3becc1226fbb16557c5e01f7", "filename": "gcc/cp/error.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -1621,8 +1621,17 @@ dump_expr (t, nop)\n \t      dump_unary_op (\"&\", pfn, 0);\n \t      break;\n \t    }\n-\t  if (TREE_CODE (idx) == INTEGER_CST\n-\t      && TREE_INT_CST_HIGH (idx) == 0)\n+\t  else if (TREE_CODE (idx) == INTEGER_CST\n+\t\t   && tree_int_cst_equal (idx, integer_zero_node))\n+\t    {\n+\t      /* A NULL pointer-to-member constant.  */\n+\t      OB_PUTS (\"((\");\n+\t      dump_type (TREE_TYPE (t), 0);\n+\t      OB_PUTS (\") 0)\");\n+\t      break;\n+\t    }\n+\t  else if (TREE_CODE (idx) == INTEGER_CST\n+\t\t   && TREE_INT_CST_HIGH (idx) == 0)\n \t    {\n \t      tree virtuals;\n \t      unsigned HOST_WIDE_INT n;"}, {"sha": "22dd07513193772073aa6bc63fa173e9237b06bd", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -188,10 +188,16 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \t  }\n \telse\n \t  {\n-\t    /* We don't yet handle pointer-to-member functions this\n-\t       way.  */\n-\t    my_friendly_abort (0);\n-\t    return 0;\n+\t    tree delta;\n+\t    tree idx;\n+\t    tree pfn;\n+\t    tree delta2;\n+\n+\t    expand_ptrmemfunc_cst (exp, &delta, &idx, &pfn, &delta2);\n+\n+\t    return expand_expr (build_ptrmemfunc1 (type, delta, idx,\n+\t\t\t\t\t\t   pfn, delta2),\n+\t\t\t\ttarget, tmode, modifier);\n \t  }\n       }\n "}, {"sha": "ecfa82c4012353104714908bc509c77e835dfffe", "filename": "gcc/cp/method.c", "status": "modified", "additions": 29, "deletions": 43, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -739,9 +739,6 @@ build_overload_value (type, value, in_template)\n       return;\n     }\n \n-  if (TYPE_PTRMEMFUNC_P (type))\n-    type = TYPE_PTRMEMFUNC_FN_TYPE (type);\n-\n   switch (TREE_CODE (type))\n     {\n     case INTEGER_TYPE:\n@@ -818,46 +815,6 @@ build_overload_value (type, value, in_template)\n \treturn;\n       }\n     case POINTER_TYPE:\n-      if (TREE_CODE (TREE_TYPE (type)) == METHOD_TYPE\n-\t  && TREE_CODE (value) != ADDR_EXPR)\n-\t{\n-\t  if (TREE_CODE (value) == CONSTRUCTOR)\n-\t    {\n-\t      /* This is dangerous code, crack built up pointer to members.  */\n-\t      tree args = CONSTRUCTOR_ELTS (value);\n-\t      tree a1 = TREE_VALUE (args);\n-\t      tree a2 = TREE_VALUE (TREE_CHAIN (args));\n-\t      tree a3 = CONSTRUCTOR_ELTS (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args))));\n-\t      a3 = TREE_VALUE (a3);\n-\t      STRIP_NOPS (a3);\n-\t      if (TREE_CODE (a1) == INTEGER_CST\n-\t\t  && TREE_CODE (a2) == INTEGER_CST)\n-\t\t{\n-\t\t  build_overload_int (a1, in_template);\n-\t\t  OB_PUTC ('_');\n-\t\t  build_overload_int (a2, in_template);\n-\t\t  OB_PUTC ('_');\n-\t\t  if (TREE_CODE (a3) == ADDR_EXPR)\n-\t\t    {\n-\t\t      a3 = TREE_OPERAND (a3, 0);\n-\t\t      if (TREE_CODE (a3) == FUNCTION_DECL)\n-\t\t\t{\n-\t\t\t  numeric_output_need_bar = 0;\n-\t\t\t  build_overload_identifier (DECL_ASSEMBLER_NAME (a3));\n-\t\t\t  return;\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (TREE_CODE (a3) == INTEGER_CST)\n-\t\t    {\n-\t\t      OB_PUTC ('i');\n-\t\t      build_overload_int (a3, in_template);\n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  sorry (\"template instantiation with pointer to method that is too complex\");\n-\t  return;\n-\t}\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n \t  build_overload_int (value, in_template);\n@@ -893,6 +850,35 @@ build_overload_value (type, value, in_template)\n \tmy_friendly_abort (71);\n       break; /* not really needed */\n \n+    case RECORD_TYPE:\n+      {\n+\ttree delta;\n+\ttree idx;\n+\ttree pfn;\n+\ttree delta2;\n+\n+\tmy_friendly_assert (TYPE_PTRMEMFUNC_P (type), 0);\n+\tmy_friendly_assert (TREE_CODE (value) == PTRMEM_CST, 0);\n+\n+\texpand_ptrmemfunc_cst (value, &delta, &idx, &pfn, &delta2);\n+\tbuild_overload_int (delta, in_template);\n+\tOB_PUTC ('_');\n+\tbuild_overload_int (idx, in_template);\n+\tOB_PUTC ('_');\n+\tif (pfn)\n+\t  {\n+\t    numeric_output_need_bar = 0;\n+\t    build_overload_identifier (DECL_ASSEMBLER_NAME\n+\t\t\t\t       (PTRMEM_CST_MEMBER (value)));\n+\t  }\n+\telse\n+\t  {\n+\t    OB_PUTC ('i');\n+\t    build_overload_int (delta2, in_template);\n+\t  }\n+      }\n+      break;\n+      \n     default:\n       sorry (\"conversion of %s as template parameter\",\n \t     tree_code_name [(int) TREE_CODE (type)]);"}, {"sha": "38e317c5468cd76284fcee29cf9c7c0515d4c6c6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -2577,7 +2577,14 @@ convert_nontype_argument (type, expr)\n        Check this first since if expr_type is the unknown_type_node\n        we would otherwise complain below.  */\n     ;\n+  else if (TYPE_PTRMEM_P (expr_type)\n+\t   || TYPE_PTRMEMFUNC_P (expr_type))\n+    {\n+      if (TREE_CODE (expr) != PTRMEM_CST)\n+\tgoto bad_argument;\n+    }\n   else if (TYPE_PTR_P (expr_type)\n+\t   || TYPE_PTRMEM_P (expr_type)\n \t   || TREE_CODE (expr_type) == ARRAY_TYPE\n \t   || TREE_CODE (type) == REFERENCE_TYPE\n \t   /* If expr is the address of an overloaded function, we\n@@ -2597,11 +2604,17 @@ convert_nontype_argument (type, expr)\n \t    {\n \t    bad_argument:\n \t      cp_error (\"`%E' is not a valid template argument\", expr);\n-\t      error (\"it must be %s%s with external linkage\",\n-\t\t     TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE\n-\t\t     ? \"a pointer to \" : \"\",\n-\t\t     TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == FUNCTION_TYPE\n-\t\t     ? \"a function\" : \"an object\");\n+\t      if (TYPE_PTR_P (expr_type))\n+\t\t{\n+\t\t  if (TREE_CODE (TREE_TYPE (expr_type)) == FUNCTION_TYPE)\n+\t\t    cp_error (\"it must be the address of a function with external linkage\");\n+\t\t  else\n+\t\t    cp_error (\"it must be the address of an object with external linkage\");\n+\t\t}\n+\t      else if (TYPE_PTRMEM_P (expr_type)\n+\t\t       || TYPE_PTRMEMFUNC_P (expr_type))\n+\t\tcp_error (\"it must be a pointer-to-member of the form `&X::Y'\");\n+\n \t      return NULL_TREE;\n \t    }\n \n@@ -2829,7 +2842,7 @@ convert_nontype_argument (type, expr)\n \t    expr_type != unknown_type_node)\n \t  return error_mark_node;\n \n-\tif (TREE_CODE (expr) == CONSTRUCTOR)\n+\tif (TREE_CODE (expr) == PTRMEM_CST)\n \t  {\n \t    /* A ptr-to-member constant.  */\n \t    if (!same_type_p (type, expr_type))"}, {"sha": "c1aa2142a9036c149dd852a7704783d55ac465fa", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 104, "deletions": 42, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -51,7 +51,6 @@ static int comp_ptr_ttypes_const PROTO((tree, tree));\n static int comp_ptr_ttypes_reinterpret PROTO((tree, tree));\n static int comp_array_types PROTO((int (*) (tree, tree, int), tree,\n \t\t\t\t   tree, int));\n-static tree build_ptrmemfunc1 PROTO((tree, tree, tree, tree, tree));\n static tree common_base_type PROTO((tree, tree));\n #if 0\n static tree convert_sequence PROTO((tree, tree));\n@@ -4705,7 +4704,7 @@ build_unary_op (code, xarg, noconvert)\n \t    (arg, argtype,\n \t     \"attempt to take address of bit-field structure member `%s'\");\n \telse\n-\t  addr = build1 (code, argtype, arg);\n+\t  addr = build1 (ADDR_EXPR, argtype, arg);\n \n \t/* Address of a static or external variable or\n \t   function counts as a constant */\n@@ -5247,7 +5246,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t\t\t\t\t  | TYPE_QUAL_RESTRICT));\n \t  else\n \t    tmp = type2;\n-\t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op1, 0);\n+\t  tmp = build_type_conversion (tmp, op1, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n \t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n@@ -5273,7 +5272,7 @@ build_conditional_expr (ifexp, op1, op2)\n \t  else\n \t    tmp = type1;\n \n-\t  tmp = build_type_conversion (CONVERT_EXPR, tmp, op2, 0);\n+\t  tmp = build_type_conversion (tmp, op2, 0);\n \t  if (tmp == NULL_TREE)\n \t    {\n \t      cp_error (\"incompatible types `%T' and `%T' in `?:'\",\n@@ -6352,7 +6351,7 @@ get_delta_difference (from, to, force)\n   return BINFO_OFFSET (binfo);\n }\n \n-static tree\n+tree\n build_ptrmemfunc1 (type, delta, idx, pfn, delta2)\n      tree type, delta, idx, pfn, delta2;\n {\n@@ -6444,9 +6443,9 @@ build_ptrmemfunc (type, pfn, force)\n   tree idx = integer_zero_node;\n   tree delta = integer_zero_node;\n   tree delta2 = integer_zero_node;\n-  tree vfield_offset;\n   tree npfn = NULL_TREE;\n-\n+  tree fn;\n+  \n   /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n@@ -6499,50 +6498,113 @@ build_ptrmemfunc (type, pfn, force)\n   if (type_unknown_p (pfn))\n     return instantiate_type (type, pfn, 1);\n \n-  if (!force \n-      && comp_target_types (type, TREE_TYPE (pfn), 0) != 1)\n-    cp_error (\"conversion to `%T' from `%T'\", type, TREE_TYPE (pfn));\n-\n-  /* Allow pointer to member conversions here.  */\n-  delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n-\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n-\t\t\t\tforce);\n-  delta2 = build_binary_op (PLUS_EXPR, delta2, delta, 1);\n+  fn = TREE_OPERAND (pfn, 0);\n+  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n+  npfn = make_node (PTRMEM_CST);\n+  TREE_TYPE (npfn) = build_ptrmemfunc_type (type);\n+  PTRMEM_CST_MEMBER (npfn) = fn;\n+  return npfn;\n+}\n \n-  if (TREE_CODE (TREE_OPERAND (pfn, 0)) != FUNCTION_DECL)\n-    warning (\"assuming pointer to member function is non-virtual\");\n+/* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST\n+   given by CST.  */\n \n-  if (TREE_CODE (TREE_OPERAND (pfn, 0)) == FUNCTION_DECL\n-      && DECL_VINDEX (TREE_OPERAND (pfn, 0)))\n-    {\n-      /* Find the offset to the vfield pointer in the object.  */\n-      vfield_offset = get_binfo (DECL_CONTEXT (TREE_OPERAND (pfn, 0)),\n-\t\t\t\t DECL_CLASS_CONTEXT (TREE_OPERAND (pfn, 0)),\n-\t\t\t\t 0);\n-      vfield_offset = get_vfield_offset (vfield_offset);\n-      delta2 = size_binop (PLUS_EXPR, vfield_offset, delta2);\n+void\n+expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n+     tree cst;\n+     tree *delta;\n+     tree *idx;\n+     tree *pfn;\n+     tree *delta2;\n+{\n+  tree type = TREE_TYPE (cst);\n+  tree fn = PTRMEM_CST_MEMBER (cst);\n \n-      /* Map everything down one to make room for the null pointer to member.  */\n-      idx = size_binop (PLUS_EXPR,\n-\t\t\tDECL_VINDEX (TREE_OPERAND (pfn, 0)),\n-\t\t\tinteger_one_node);\n+  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n+  \n+  *delta \n+    = get_delta_difference (TYPE_METHOD_BASETYPE \n+\t\t\t    (TREE_TYPE (fn)),\n+\t\t\t    TYPE_PTRMEMFUNC_OBJECT_TYPE (type),\n+\t\t\t    /*force=*/0);\n+  if (!DECL_VIRTUAL_P (fn))\n+    {\n+      *idx = size_binop (MINUS_EXPR, integer_zero_node,\n+\t\t\t integer_one_node);\n+      *pfn = build_addr_func (fn);\n+      if (!same_type_p (TYPE_METHOD_BASETYPE (TREE_TYPE (fn)),\n+\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (type)))\n+\t*pfn = build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type), \n+\t\t       *pfn);\n+      *delta2 = NULL_TREE;\n     }\n   else\n     {\n-      idx = size_binop (MINUS_EXPR, integer_zero_node, integer_one_node);\n+      *idx = size_binop (PLUS_EXPR, DECL_VINDEX (fn), \n+\t\t\t integer_one_node);\n+      *pfn = NULL_TREE;\n+      *delta2 = get_binfo (DECL_CONTEXT (fn),\n+\t\t\t  DECL_CLASS_CONTEXT (fn),\n+\t\t\t  0);\n+      *delta2 = get_vfield_offset (*delta2);\n+      *delta2 = size_binop (PLUS_EXPR, *delta2,\n+\t\t\t   build_binary_op (PLUS_EXPR,\n+\t\t\t\t\t    *delta, \n+\t\t\t\t\t    integer_zero_node,\n+\t\t\t\t\t    1));\n+    }\n+}\n \n-      if (type == TREE_TYPE (pfn))\n-\t{\n-\t  npfn = pfn;\n-\t}\n-      else\n-\t{\n-\t  npfn = build1 (NOP_EXPR, type, pfn);\n-\t  TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n-\t}\n+/* Return an expression for DELTA2 from the pointer-to-member function\n+   given by T.  */\n+\n+tree\n+delta2_from_ptrmemfunc (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == PTRMEM_CST)\n+    {\n+      tree delta;\n+      tree idx;\n+      tree pfn;\n+      tree delta2;\n+      \n+      expand_ptrmemfunc_cst (t, &delta, &idx, &pfn, &delta2);\n+      if (delta2)\n+\treturn delta2;\n+    }\n+\n+  return (build_component_ref \n+\t  (build_component_ref (t,\n+\t\t\t\tpfn_or_delta2_identifier, NULL_TREE,\n+\t\t\t\t0), \n+\t   delta2_identifier, NULL_TREE, 0)); \n+}\n+\n+/* Return an expression for PFN from the pointer-to-member function\n+   given by T.  */\n+\n+tree\n+pfn_from_ptrmemfunc (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == PTRMEM_CST)\n+    {\n+      tree delta;\n+      tree idx;\n+      tree pfn;\n+      tree delta2;\n+      \n+      expand_ptrmemfunc_cst (t, &delta, &idx, &pfn, &delta2);\n+      if (pfn)\n+\treturn pfn;\n     }\n \n-  return build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx, npfn, delta2);\n+  return (build_component_ref \n+\t  (build_component_ref (t,\n+\t\t\t\tpfn_or_delta2_identifier, NULL_TREE,\n+\t\t\t\t0), \n+\t   pfn_identifier, NULL_TREE, 0)); \n }\n \n /* Convert value RHS to type TYPE as preparation for an assignment"}, {"sha": "946e6244f4a95956a8c910f91a3472a979b7b548", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem6.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e08a8f45f515854210dc47d78e13302536d2fc35/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C?ref=e08a8f45f515854210dc47d78e13302536d2fc35", "patch": "@@ -0,0 +1,34 @@\n+// Build don't link:\n+\n+class A {\n+public:\n+  virtual void f();\n+  int i;\n+};\n+\n+class B : public A {\n+public:\n+  void f();\n+  int j;\n+};\n+\n+template <void (A::*)() >\n+void g() {}\n+template <int A::*>\n+void h() {}\n+\n+\n+int main() {\n+  g<&A::f>();\n+  h<&A::i>();\n+  g<&B::f>(); // ERROR - \n+  h<&B::j>(); // ERROR - \n+  g<(void (A::*)()) &A::f>(); // ERROR - XFAIL *-*-*\n+  h<(int A::*) &A::i>(); // ERROR - \n+  g<(void (A::*)()) &B::f>(); // ERROR - \n+  h<(int A::*) &B::j>(); // ERROR - \n+  g<(void (A::*)()) 0>(); // ERROR - \n+  h<(int A::*) 0>(); // ERROR - \n+\n+  return 0;\n+}"}]}