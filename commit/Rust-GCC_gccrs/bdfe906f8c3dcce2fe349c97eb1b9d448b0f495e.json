{"sha": "bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmRmZTkwNmY4YzNkY2NlMmZlMzQ5Yzk3ZWIxYjlkNDQ4YjBmNDk1ZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-03-22T16:02:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-03-22T16:02:51Z"}, "message": "avr.c (TARGET_EXCEPT_UNWIND_INFO): New.\n\n\t* config/avr/avr.c (TARGET_EXCEPT_UNWIND_INFO): New.\n\t(avr_incoming_return_addr_rtx): New.\n\t(emit_push_byte): New.\n\t(expand_prologue): Use it.  Remove incorrect dwarf annotation for\n\tSREG, RAMPZ, zero register.  Push frame pointer by bytes.  Add dwarf\n\tannotation for __prologue_saves__.  Fixup dwarf annotation for CFA.\n\t(emit_pop_byte): New.\n\t(expand_epilogue): Use it.  Pop frame pointer by bytes.\n\t* config/avr/avr.h (FRAME_POINTER_CFA_OFFSET): Remove.\n\t(INCOMING_RETURN_ADDR_RTX): New.\n\t(INCOMING_FRAME_SP_OFFSET): New.\n\t(ARG_POINTER_CFA_OFFSET): New.\n\t* config/avr/avr.md (*pushqi): Fix mode of auto-inc.\n\t(*pushhi, *pushsi, *pushsf, popqi): Likewise.\n\t(pophi): Remove.\n\nFrom-SVN: r171295", "tree": {"sha": "9c7f6b4f3704dad73a8d15f619a912f15a14694d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c7f6b4f3704dad73a8d15f619a912f15a14694d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/comments", "author": null, "committer": null, "parents": [{"sha": "5b13621b31fc3f51c50d30b50687ef8aac587be4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b13621b31fc3f51c50d30b50687ef8aac587be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b13621b31fc3f51c50d30b50687ef8aac587be4"}], "stats": {"total": 343, "additions": 207, "deletions": 136}, "files": [{"sha": "396c8be7a84b8db0185f488bff90726c8fbad398", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "patch": "@@ -1,3 +1,21 @@\n+2011-03-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/avr/avr.c (TARGET_EXCEPT_UNWIND_INFO): New.\n+\t(avr_incoming_return_addr_rtx): New.\n+\t(emit_push_byte): New.\n+\t(expand_prologue): Use it.  Remove incorrect dwarf annotation for\n+\tSREG, RAMPZ, zero register.  Push frame pointer by bytes.  Add dwarf\n+\tannotation for __prologue_saves__.  Fixup dwarf annotation for CFA.\n+\t(emit_pop_byte): New.\n+\t(expand_epilogue): Use it.  Pop frame pointer by bytes.\n+\t* config/avr/avr.h (FRAME_POINTER_CFA_OFFSET): Remove.\n+\t(INCOMING_RETURN_ADDR_RTX): New.\n+\t(INCOMING_FRAME_SP_OFFSET): New.\n+\t(ARG_POINTER_CFA_OFFSET): New.\n+\t* config/avr/avr.md (*pushqi): Fix mode of auto-inc.\n+\t(*pushhi, *pushsi, *pushsf, popqi): Likewise.\n+\t(pophi): Remove.\n+\n 2011-03-22  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* tree.c (build_call_1): New function."}, {"sha": "3882429adb102072a31a14d1a8c605e596c19c3a", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "patch": "@@ -108,6 +108,7 @@ extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n extern int compare_eq_p (rtx insn);\n extern void out_shift_with_cnt (const char *templ, rtx insn,\n \t\t\t\trtx operands[], int *len, int t_len);\n+extern rtx avr_incoming_return_addr_rtx (void);\n #endif /* RTX_CODE */\n \n #ifdef HAVE_MACHINE_MODES"}, {"sha": "9a32b973c9a0f27eb3b48a7100adb3aed6e7028c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 176, "deletions": 119, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "patch": "@@ -246,6 +246,9 @@ static const struct default_options avr_option_optimization_table[] =\n #undef TARGET_HELP\n #define TARGET_HELP avr_help\n \n+#undef TARGET_EXCEPT_UNWIND_INFO\n+#define TARGET_EXCEPT_UNWIND_INFO sjlj_except_unwind_info\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n static void\n@@ -597,6 +600,35 @@ get_sequence_length (rtx insns)\n   return length;\n }\n \n+/*  Implement INCOMING_RETURN_ADDR_RTX.  */\n+\n+rtx\n+avr_incoming_return_addr_rtx (void)\n+{\n+  /* The return address is at the top of the stack.  Note that the push\n+     was via post-decrement, which means the actual address is off by one.  */\n+  return gen_frame_mem (HImode, plus_constant (stack_pointer_rtx, 1));\n+}\n+\n+/*  Helper for expand_prologue.  Emit a push of a byte register.  */\n+\n+static void\n+emit_push_byte (unsigned regno, bool frame_related_p)\n+{\n+  rtx mem, reg, insn;\n+\n+  mem = gen_rtx_POST_DEC (HImode, stack_pointer_rtx);\n+  mem = gen_frame_mem (QImode, mem);\n+  reg = gen_rtx_REG (QImode, regno);\n+\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, mem, reg));\n+  if (frame_related_p)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+  cfun->machine->stack_usage++;\n+}\n+\n+\n /*  Output function prologue.  */\n \n void\n@@ -606,11 +638,6 @@ expand_prologue (void)\n   HARD_REG_SET set;\n   int minimize;\n   HOST_WIDE_INT size = get_frame_size();\n-  /* Define templates for push instructions.  */\n-  rtx pushbyte = gen_rtx_MEM (QImode,\n-                  gen_rtx_POST_DEC (HImode, stack_pointer_rtx));\n-  rtx pushword = gen_rtx_MEM (HImode,\n-                  gen_rtx_POST_DEC (HImode, stack_pointer_rtx));\n   rtx insn;\n   \n   /* Init cfun->machine.  */\n@@ -638,46 +665,34 @@ expand_prologue (void)\n \n   if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n     {\n+      /* Enable interrupts.  */\n       if (cfun->machine->is_interrupt)\n-        {\n-          /* Enable interrupts.  */\n-          insn = emit_insn (gen_enable_interrupt ());\n-          RTX_FRAME_RELATED_P (insn) = 1;\n-        }\n+\temit_insn (gen_enable_interrupt ());\n \t\n       /* Push zero reg.  */\n-      insn = emit_move_insn (pushbyte, zero_reg_rtx);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      cfun->machine->stack_usage++;\n+      emit_push_byte (ZERO_REGNO, true);\n \n       /* Push tmp reg.  */\n-      insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      cfun->machine->stack_usage++;\n+      emit_push_byte (TMP_REGNO, true);\n \n       /* Push SREG.  */\n-      insn = emit_move_insn (tmp_reg_rtx, \n-                             gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-      cfun->machine->stack_usage++;\n+      /* ??? There's no dwarf2 column reserved for SREG.  */\n+      emit_move_insn (tmp_reg_rtx, gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)));\n+      emit_push_byte (TMP_REGNO, false);\n \n       /* Push RAMPZ.  */\n-      if(AVR_HAVE_RAMPZ \n-         && (TEST_HARD_REG_BIT (set, REG_Z) && TEST_HARD_REG_BIT (set, REG_Z + 1)))\n+      /* ??? There's no dwarf2 column reserved for RAMPZ.  */\n+      if (AVR_HAVE_RAMPZ \n+          && TEST_HARD_REG_BIT (set, REG_Z)\n+          && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n-          insn = emit_move_insn (tmp_reg_rtx, \n-                                 gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)));\n-          RTX_FRAME_RELATED_P (insn) = 1;\n-          insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n-          RTX_FRAME_RELATED_P (insn) = 1;\n-          cfun->machine->stack_usage++;\n+          emit_move_insn (tmp_reg_rtx,\n+\t\t\t  gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)));\n+\t  emit_push_byte (TMP_REGNO, false);\n         }\n \t\n       /* Clear zero reg.  */\n-      insn = emit_move_insn (zero_reg_rtx, const0_rtx);\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      emit_move_insn (zero_reg_rtx, const0_rtx);\n \n       /* Prevent any attempt to delete the setting of ZERO_REG!  */\n       emit_use (zero_reg_rtx);\n@@ -686,37 +701,63 @@ expand_prologue (void)\n \t\t   || (AVR_2_BYTE_PC && live_seq > 6)\n \t\t   || live_seq > 7)) \n     {\n-      insn = emit_move_insn (gen_rtx_REG (HImode, REG_X), \n-                             gen_int_mode (size, HImode));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      int first_reg, reg, offset;\n+\n+      emit_move_insn (gen_rtx_REG (HImode, REG_X), \n+                      gen_int_mode (size, HImode));\n \n-      insn = \n-        emit_insn (gen_call_prologue_saves (gen_int_mode (live_seq, HImode),\n-\t\t\t\t\t    gen_int_mode (size + live_seq, HImode)));\n+      insn = emit_insn (gen_call_prologue_saves\n+\t\t\t(gen_int_mode (live_seq, HImode),\n+\t\t         gen_int_mode (size + live_seq, HImode)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Describe the effect of the unspec_volatile call to prologue_saves.\n+\t Note that this formulation assumes that add_reg_note pushes the\n+\t notes to the front.  Thus we build them in the reverse order of\n+\t how we want dwarf2out to process them.  */\n+\n+      /* The function does always set frame_pointer_rtx, but whether that\n+\t is going to be permanent in the function is frame_pointer_needed.  */\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t    gen_rtx_SET (VOIDmode,\n+\t\t\t\t (frame_pointer_needed\n+\t\t\t\t  ? frame_pointer_rtx : stack_pointer_rtx),\n+\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t-(size + live_seq))));\n+\n+      /* Note that live_seq always contains r28+r29, but the other\n+\t registers to be saved are all below 18.  */\n+      first_reg = 18 - (live_seq - 2);\n+\n+      for (reg = 29, offset = -live_seq + 1;\n+\t   reg >= first_reg;\n+\t   reg = (reg == 28 ? 17 : reg - 1), ++offset)\n+\t{\n+\t  rtx m, r;\n+\n+\t  m = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, offset));\n+\t  r = gen_rtx_REG (QImode, reg);\n+\t  add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, m, r));\n+\t}\n+\n       cfun->machine->stack_usage += size + live_seq;\n     }\n   else\n     {\n       int reg;\n       for (reg = 0; reg < 32; ++reg)\n-        {\n-          if (TEST_HARD_REG_BIT (set, reg))\n-            {\n-              /* Emit push of register to save.  */\n-              insn=emit_move_insn (pushbyte, gen_rtx_REG (QImode, reg));\n-              RTX_FRAME_RELATED_P (insn) = 1;\n-              cfun->machine->stack_usage++;\n-            }\n-        }\n+        if (TEST_HARD_REG_BIT (set, reg))\n+\t  emit_push_byte (reg, true);\n+\n       if (frame_pointer_needed)\n         {\n \t  if (!(cfun->machine->is_OS_task || cfun->machine->is_OS_main))\n \t    {\n-              /* Push frame pointer.  */\n-\t      insn = emit_move_insn (pushword, frame_pointer_rtx);\n-              RTX_FRAME_RELATED_P (insn) = 1;\n-\t      cfun->machine->stack_usage += 2;\n+              /* Push frame pointer.  Always be consistent about the\n+\t\t ordering of pushes -- epilogue_restores expects the\n+\t\t register pair to be pushed low byte first.  */\n+\t      emit_push_byte (REG_Y, true);\n+\t      emit_push_byte (REG_Y + 1, true);\n \t    }\n \n           if (!size)\n@@ -739,13 +780,12 @@ expand_prologue (void)\n               is selected.  */\n               rtx myfp;\n \t      rtx fp_plus_insns; \n-\t      rtx sp_plus_insns = NULL_RTX;\n \n               if (AVR_HAVE_8BIT_SP)\n                 {\n-                  /* The high byte (r29) doesn't change - prefer 'subi' (1 cycle)\n-                     over 'sbiw' (2 cycles, same size).  */\n-                  myfp = gen_rtx_REG (QImode, REGNO (frame_pointer_rtx));\n+                  /* The high byte (r29) doesn't change.  Prefer 'subi'\n+\t\t     (1 cycle) over 'sbiw' (2 cycles, same size).  */\n+                  myfp = gen_rtx_REG (QImode, FRAME_POINTER_REGNUM);\n                 }\n               else \n                 {\n@@ -756,41 +796,43 @@ expand_prologue (void)\n \t      /* Method 1-Adjust frame pointer.  */\n \t      start_sequence ();\n \n-              insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-              RTX_FRAME_RELATED_P (insn) = 1;\n+\t      /* Normally the dwarf2out frame-related-expr interpreter does\n+\t\t not expect to have the CFA change once the frame pointer is\n+\t\t set up.  Thus we avoid marking the move insn below and\n+\t\t instead indicate that the entire operation is complete after\n+\t\t the frame pointer subtraction is done.  */\n \n-              insn = \n-\t        emit_move_insn (myfp,\n-\t\t\t\tgen_rtx_PLUS (GET_MODE(myfp), myfp, \n-\t\t\t\t\t      gen_int_mode (-size, \n-\t\t\t\t\t\t\t    GET_MODE(myfp))));\n-              RTX_FRAME_RELATED_P (insn) = 1;\n+              emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n \n-\t      /* Copy to stack pointer.  */\n+              insn = emit_move_insn (myfp, plus_constant (myfp, -size));\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\t      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\t    gen_rtx_SET (VOIDmode, frame_pointer_rtx,\n+\t\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t\t-size)));\n+\n+\t      /* Copy to stack pointer.  Note that since we've already\n+\t\t changed the CFA to the frame pointer this operation\n+\t\t need not be annotated at all.  */\n \t      if (AVR_HAVE_8BIT_SP)\n \t\t{\n-\t\t  insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n \t\t}\n \t      else if (TARGET_NO_INTERRUPTS \n \t\t       || cfun->machine->is_signal\n \t\t       || cfun->machine->is_OS_main)\n \t\t{\n-\t\t  insn = \n-\t\t    emit_insn (gen_movhi_sp_r_irq_off (stack_pointer_rtx, \n-\t\t\t\t\t\t       frame_pointer_rtx));\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\t\t\n+\t\t  emit_insn (gen_movhi_sp_r_irq_off (stack_pointer_rtx, \n+\t\t\t\t\t\t     frame_pointer_rtx));\n \t\t}\n \t      else if (cfun->machine->is_interrupt)\n \t\t{\n-\t\t  insn = emit_insn (gen_movhi_sp_r_irq_on (stack_pointer_rtx, \n-\t\t\t\t\t\t\t   frame_pointer_rtx));\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  emit_insn (gen_movhi_sp_r_irq_on (stack_pointer_rtx, \n+\t\t\t\t\t\t    frame_pointer_rtx));\n \t\t}\n \t      else\n \t\t{\n-\t\t  insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n \t\t}\n \n \t      fp_plus_insns = get_insns ();\n@@ -799,30 +841,30 @@ expand_prologue (void)\n \t      /* Method 2-Adjust Stack pointer.  */\n               if (size <= 6)\n                 {\n+\t\t  rtx sp_plus_insns;\n+\n \t\t  start_sequence ();\n \n-\t\t  insn = \n-\t\t    emit_move_insn (stack_pointer_rtx,\n-\t\t\t\t    gen_rtx_PLUS (HImode, \n-\t\t\t\t\t\t  stack_pointer_rtx, \n-\t\t\t\t\t\t  gen_int_mode (-size, \n-\t\t\t\t\t\t\t\tHImode)));\n+\t          insn = plus_constant (stack_pointer_rtx, -size);\n+\t\t  insn = emit_move_insn (stack_pointer_rtx, insn);\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  \n-\t\t  insn = \n-\t\t    emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\t\t  insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n \n \t\t  sp_plus_insns = get_insns ();\n \t\t  end_sequence ();\n-                }\n \n-              /* Use shortest method.  */\n-              if (size <= 6 && (get_sequence_length (sp_plus_insns) \n-\t\t\t\t < get_sequence_length (fp_plus_insns)))\n-\t\temit_insn (sp_plus_insns);\n-              else\n+\t\t  /* Use shortest method.  */\n+\t\t  if (get_sequence_length (sp_plus_insns) \n+\t\t      < get_sequence_length (fp_plus_insns))\n+\t\t    emit_insn (sp_plus_insns);\n+\t\t  else\n+\t\t    emit_insn (fp_plus_insns);\n+                }\n+\t      else\n \t\temit_insn (fp_plus_insns);\n+\n \t      cfun->machine->stack_usage += size;\n             }\n         }\n@@ -876,6 +918,20 @@ avr_epilogue_uses (int regno ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n+/*  Helper for expand_epilogue.  Emit a pop of a byte register.  */\n+\n+static void\n+emit_pop_byte (unsigned regno)\n+{\n+  rtx mem, reg;\n+\n+  mem = gen_rtx_PRE_INC (HImode, stack_pointer_rtx);\n+  mem = gen_frame_mem (QImode, mem);\n+  reg = gen_rtx_REG (QImode, regno);\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, reg, mem));\n+}\n+\n /*  Output RTL epilogue.  */\n \n void\n@@ -928,13 +984,12 @@ expand_epilogue (void)\n               /* Try two methods to adjust stack and select shortest.  */\n \t      rtx myfp;\n \t      rtx fp_plus_insns;\n-\t      rtx sp_plus_insns = NULL_RTX;\n-\t      \n+\n \t      if (AVR_HAVE_8BIT_SP)\n                 {\n                   /* The high byte (r29) doesn't change - prefer 'subi' \n                      (1 cycle) over 'sbiw' (2 cycles, same size).  */\n-                  myfp = gen_rtx_REG (QImode, REGNO (frame_pointer_rtx));\n+                  myfp = gen_rtx_REG (QImode, FRAME_POINTER_REGNUM);\n                 }\n               else \n                 {\n@@ -945,10 +1000,7 @@ expand_epilogue (void)\n               /* Method 1-Adjust frame pointer.  */\n \t      start_sequence ();\n \n-\t      emit_move_insn (myfp,\n-\t\t\t      gen_rtx_PLUS (GET_MODE (myfp), myfp,\n-\t\t\t\t\t    gen_int_mode (size, \n-\t\t\t\t\t\t\t  GET_MODE(myfp))));\n+\t      emit_move_insn (myfp, plus_constant (myfp, size));\n \n \t      /* Copy to stack pointer.  */\n \t      if (AVR_HAVE_8BIT_SP)\n@@ -977,58 +1029,63 @@ expand_epilogue (void)\n               /* Method 2-Adjust Stack pointer.  */\n               if (size <= 5)\n                 {\n+\t\t  rtx sp_plus_insns;\n+\n \t\t  start_sequence ();\n \n \t\t  emit_move_insn (stack_pointer_rtx,\n-\t\t\t\t  gen_rtx_PLUS (HImode, stack_pointer_rtx,\n-\t\t\t\t\t\tgen_int_mode (size, \n-\t\t\t\t\t\t\t      HImode)));\n+\t\t\t\t  plus_constant (stack_pointer_rtx, size));\n \n \t\t  sp_plus_insns = get_insns ();\n \t\t  end_sequence ();\n-                }\n \n-              /* Use shortest method.  */\n-              if (size <= 5 && (get_sequence_length (sp_plus_insns) \n-\t\t\t\t < get_sequence_length (fp_plus_insns)))\n-\t      \temit_insn (sp_plus_insns);\n-              else\n+\t\t  /* Use shortest method.  */\n+\t\t  if (get_sequence_length (sp_plus_insns) \n+\t\t      < get_sequence_length (fp_plus_insns))\n+\t\t    emit_insn (sp_plus_insns);\n+\t\t  else\n+\t\t    emit_insn (fp_plus_insns);\n+                }\n+\t      else\n \t\temit_insn (fp_plus_insns);\n             }\n \t  if (!(cfun->machine->is_OS_task || cfun->machine->is_OS_main))\n \t    {\n-              /* Restore previous frame_pointer.  */\n-\t      emit_insn (gen_pophi (frame_pointer_rtx));\n+              /* Restore previous frame_pointer.  See expand_prologue for\n+\t\t rationale for not using pophi.  */\n+\t      emit_pop_byte (REG_Y + 1);\n+\t      emit_pop_byte (REG_Y);\n \t    }\n \t}\n+\n       /* Restore used registers.  */\n       for (reg = 31; reg >= 0; --reg)\n-        {\n-          if (TEST_HARD_REG_BIT (set, reg))\n-              emit_insn (gen_popqi (gen_rtx_REG (QImode, reg)));\n-        }\n+        if (TEST_HARD_REG_BIT (set, reg))\n+          emit_pop_byte (reg);\n+\n       if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n         {\n           /* Restore RAMPZ using tmp reg as scratch.  */\n-\t  if(AVR_HAVE_RAMPZ \n-             && (TEST_HARD_REG_BIT (set, REG_Z) && TEST_HARD_REG_BIT (set, REG_Z + 1)))\n+\t  if (AVR_HAVE_RAMPZ \n+              && TEST_HARD_REG_BIT (set, REG_Z)\n+\t      && TEST_HARD_REG_BIT (set, REG_Z + 1))\n             {\n-\t      emit_insn (gen_popqi (tmp_reg_rtx));\n-\t      emit_move_insn (gen_rtx_MEM(QImode, GEN_INT(RAMPZ_ADDR)), \n+\t      emit_pop_byte (TMP_REGNO);\n+\t      emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)), \n \t\t\t      tmp_reg_rtx);\n \t    }\n \n           /* Restore SREG using tmp reg as scratch.  */\n-          emit_insn (gen_popqi (tmp_reg_rtx));\n+          emit_pop_byte (TMP_REGNO);\n       \n-          emit_move_insn (gen_rtx_MEM(QImode, GEN_INT(SREG_ADDR)), \n+          emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)), \n \t\t\t  tmp_reg_rtx);\n \n           /* Restore tmp REG.  */\n-          emit_insn (gen_popqi (tmp_reg_rtx));\n+          emit_pop_byte (TMP_REGNO);\n \n           /* Restore zero REG.  */\n-          emit_insn (gen_popqi (zero_reg_rtx));\n+          emit_pop_byte (ZERO_REGNO);\n         }\n \n       emit_jump_insn (gen_return ());"}, {"sha": "bd18aedc0f47159352e1d984bc009d0f7e27f8bd", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "patch": "@@ -351,9 +351,6 @@ enum reg_class {\n \n #define STATIC_CHAIN_REGNUM 2\n \n-/* Offset from the frame pointer register value to the top of the stack.  */\n-#define FRAME_POINTER_CFA_OFFSET(FNDECL) 0\n-\n #define ELIMINABLE_REGS {\t\t\t\t\t\\\n       {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n \t{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\\\n@@ -794,6 +791,13 @@ mmcu=*:-mmcu=%*}\"\n \n #define OBJECT_FORMAT_ELF\n \n+#define INCOMING_RETURN_ADDR_RTX   avr_incoming_return_addr_rtx ()\n+#define INCOMING_FRAME_SP_OFFSET   (AVR_3_BYTE_PC ? 3 : 2)\n+\n+/* The caller's stack pointer value immediately before the call\n+   is one byte below the first argument.  */\n+#define ARG_POINTER_CFA_OFFSET(FNDECL)  -1\n+\n #define HARD_REGNO_RENAME_OK(OLD_REG, NEW_REG) \\\n   avr_hard_regno_rename_ok (OLD_REG, NEW_REG)\n "}, {"sha": "0fdee391022d28777e951971240af40a0324a2eb", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=bdfe906f8c3dcce2fe349c97eb1b9d448b0f495e", "patch": "@@ -181,17 +181,16 @@\n \n \n (define_insn \"*pushqi\"\n-  [(set (mem:QI (post_dec (reg:HI REG_SP)))\n+  [(set (mem:QI (post_dec:HI (reg:HI REG_SP)))\n         (match_operand:QI 0 \"reg_or_0_operand\" \"r,L\"))]\n   \"\"\n   \"@\n \tpush %0\n \tpush __zero_reg__\"\n   [(set_attr \"length\" \"1,1\")])\n \n-\n (define_insn \"*pushhi\"\n-  [(set (mem:HI (post_dec (reg:HI REG_SP)))\n+  [(set (mem:HI (post_dec:HI (reg:HI REG_SP)))\n         (match_operand:HI 0 \"reg_or_0_operand\" \"r,L\"))]\n   \"\"\n   \"@\n@@ -200,7 +199,7 @@\n   [(set_attr \"length\" \"2,2\")])\n \n (define_insn \"*pushsi\"\n-  [(set (mem:SI (post_dec (reg:HI REG_SP)))\n+  [(set (mem:SI (post_dec:HI (reg:HI REG_SP)))\n         (match_operand:SI 0 \"reg_or_0_operand\" \"r,L\"))]\n   \"\"\n   \"@\n@@ -209,7 +208,7 @@\n   [(set_attr \"length\" \"4,4\")])\n \n (define_insn \"*pushsf\"\n-  [(set (mem:SF (post_dec (reg:HI REG_SP)))\n+  [(set (mem:SF (post_dec:HI (reg:HI REG_SP)))\n         (match_operand:SF 0 \"register_operand\" \"r\"))]\n   \"\"\n   \"push %D0\n@@ -3126,20 +3125,12 @@\n \n (define_insn \"popqi\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-        (mem:QI (post_inc (reg:HI REG_SP))))]\n+        (mem:QI (pre_inc:HI (reg:HI REG_SP))))]\n   \"\"\n   \"pop %0\"\n   [(set_attr \"cc\" \"none\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"pophi\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (mem:HI (post_inc (reg:HI REG_SP))))]\n-  \"\"\n-  \"pop %A0\\;pop %B0\"\n-  [(set_attr \"cc\" \"none\")\n-   (set_attr \"length\" \"2\")])\n-\n ;; Enable Interrupts\n (define_insn \"enable_interrupt\"\n   [(unspec [(const_int 0)] UNSPEC_SEI)]"}]}