{"sha": "1c8f7377380290e84a80fb0ca8a68375593af8a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM4ZjczNzczODAyOTBlODRhODBmYjBjYThhNjgzNzU1OTNhZjhhMQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-14T12:38:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-14T12:38:32Z"}, "message": "re PR middle-end/54146 (Very slow compile with attribute((flatten)))\n\n2012-08-14  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/54146\n\t* tree-ssa-pre.c (do_regular_insertion): Use a VEC\n\tindexed by pred edge index for avail.\n\t(do_partial_partial_insertion): Likewise.\n\t(insert_into_preds_of_block): Adjust.\n\nFrom-SVN: r190382", "tree": {"sha": "73ba06d2a0d51458bb809ef839d4258cbde95118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73ba06d2a0d51458bb809ef839d4258cbde95118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c8f7377380290e84a80fb0ca8a68375593af8a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8f7377380290e84a80fb0ca8a68375593af8a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c8f7377380290e84a80fb0ca8a68375593af8a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c8f7377380290e84a80fb0ca8a68375593af8a1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ad728d2723fbc0386be5a9379befc1b68e0ab8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ad728d2723fbc0386be5a9379befc1b68e0ab8d"}], "stats": {"total": 67, "additions": 38, "deletions": 29}, "files": [{"sha": "e6b279b1d900af9405e623cae80409d827b62f51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8f7377380290e84a80fb0ca8a68375593af8a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8f7377380290e84a80fb0ca8a68375593af8a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c8f7377380290e84a80fb0ca8a68375593af8a1", "patch": "@@ -1,3 +1,11 @@\n+2012-08-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/54146\n+\t* tree-ssa-pre.c (do_regular_insertion): Use a VEC\n+\tindexed by pred edge index for avail.\n+\t(do_partial_partial_insertion): Likewise.\n+\t(insert_into_preds_of_block): Adjust.\n+\n 2012-08-14  Richard Guenther  <rguenther@suse.de>\n \n \t* gimplify.c (create_tmp_from_val): Mark temporary with"}, {"sha": "83dded2e7ccc8249fe49f954999d0e57775068b0", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c8f7377380290e84a80fb0ca8a68375593af8a1/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c8f7377380290e84a80fb0ca8a68375593af8a1/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=1c8f7377380290e84a80fb0ca8a68375593af8a1", "patch": "@@ -3188,7 +3188,7 @@ inhibit_phi_insertion (basic_block bb, pre_expr expr)\n \n static bool\n insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n-\t\t\t    pre_expr *avail)\n+\t\t\t    VEC(pre_expr, heap) *avail)\n {\n   pre_expr expr = expression_for_id (exprnum);\n   pre_expr newphi;\n@@ -3229,7 +3229,7 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n       gimple_seq stmts = NULL;\n       tree builtexpr;\n       bprime = pred->src;\n-      eprime = avail[bprime->index];\n+      eprime = VEC_index (pre_expr, avail, pred->dest_idx);\n \n       if (eprime->kind != NAME && eprime->kind != CONSTANT)\n \t{\n@@ -3239,14 +3239,14 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t\t\t\t   type);\n \t  gcc_assert (!(pred->flags & EDGE_ABNORMAL));\n \t  gsi_insert_seq_on_edge (pred, stmts);\n-\t  avail[bprime->index] = get_or_alloc_expr_for_name (builtexpr);\n+\t  VEC_replace (pre_expr, avail, pred->dest_idx,\n+\t\t       get_or_alloc_expr_for_name (builtexpr));\n \t  insertions = true;\n \t}\n       else if (eprime->kind == CONSTANT)\n \t{\n \t  /* Constants may not have the right type, fold_convert\n-\t     should give us back a constant with the right type.\n-\t  */\n+\t     should give us back a constant with the right type.  */\n \t  tree constant = PRE_EXPR_CONSTANT (eprime);\n \t  if (!useless_type_conversion_p (type, TREE_TYPE (constant)))\n \t    {\n@@ -3278,11 +3278,13 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t\t    }\n \t\t\t  gsi_insert_seq_on_edge (pred, stmts);\n \t\t\t}\n-\t\t      avail[bprime->index] = get_or_alloc_expr_for_name (forcedexpr);\n+\t\t      VEC_replace (pre_expr, avail, pred->dest_idx,\n+\t\t\t\t   get_or_alloc_expr_for_name (forcedexpr));\n \t\t    }\n \t\t}\n \t      else\n-\t\tavail[bprime->index] = get_or_alloc_expr_for_constant (builtexpr);\n+\t\tVEC_replace (pre_expr, avail, pred->dest_idx,\n+\t\t\t     get_or_alloc_expr_for_constant (builtexpr));\n \t    }\n \t}\n       else if (eprime->kind == NAME)\n@@ -3321,7 +3323,8 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n \t\t    }\n \t\t  gsi_insert_seq_on_edge (pred, stmts);\n \t\t}\n-\t      avail[bprime->index] = get_or_alloc_expr_for_name (forcedexpr);\n+\t      VEC_replace (pre_expr, avail, pred->dest_idx,\n+\t\t\t   get_or_alloc_expr_for_name (forcedexpr));\n \t    }\n \t}\n     }\n@@ -3344,14 +3347,13 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (gimple_phi_result (phi)));\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     {\n-      pre_expr ae = avail[pred->src->index];\n+      pre_expr ae = VEC_index (pre_expr, avail, pred->dest_idx);\n       gcc_assert (get_expr_type (ae) == type\n \t\t  || useless_type_conversion_p (type, get_expr_type (ae)));\n       if (ae->kind == CONSTANT)\n \tadd_phi_arg (phi, PRE_EXPR_CONSTANT (ae), pred, UNKNOWN_LOCATION);\n       else\n-\tadd_phi_arg (phi, PRE_EXPR_NAME (avail[pred->src->index]), pred,\n-\t\t     UNKNOWN_LOCATION);\n+\tadd_phi_arg (phi, PRE_EXPR_NAME (ae), pred, UNKNOWN_LOCATION);\n     }\n \n   newphi = get_or_alloc_expr_for_name (gimple_phi_result (phi));\n@@ -3411,15 +3413,18 @@ static bool\n do_regular_insertion (basic_block block, basic_block dom)\n {\n   bool new_stuff = false;\n-  VEC (pre_expr, heap) *exprs = sorted_array_from_bitmap_set (ANTIC_IN (block));\n+  VEC (pre_expr, heap) *exprs;\n   pre_expr expr;\n+  VEC (pre_expr, heap) *avail = NULL;\n   int i;\n \n+  exprs = sorted_array_from_bitmap_set (ANTIC_IN (block));\n+  VEC_safe_grow (pre_expr, heap, avail, EDGE_COUNT (block->preds));\n+\n   FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       if (expr->kind != NAME)\n \t{\n-\t  pre_expr *avail;\n \t  unsigned int val;\n \t  bool by_some = false;\n \t  bool cant_insert = false;\n@@ -3442,10 +3447,6 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t      continue;\n \t    }\n \n-\t  /* FIXME: This costs N_EXPR*N_BASIC_BLOCKS.  Should use\n-\t     a less costly data structure for avail (e.g. a VEC\n-\t     indexed by edge index).  */\n-\t  avail = XCNEWVEC (pre_expr, last_basic_block);\n \t  FOR_EACH_EDGE (pred, ei, block->preds)\n \t    {\n \t      unsigned int vprime;\n@@ -3468,6 +3469,7 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t\t rest of the results are.  */\n \t      if (eprime == NULL)\n \t\t{\n+\t\t  VEC_replace (pre_expr, avail, pred->dest_idx, NULL);\n \t\t  cant_insert = true;\n \t\t  break;\n \t\t}\n@@ -3478,12 +3480,12 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t\t\t\t\t\t vprime, NULL);\n \t      if (edoubleprime == NULL)\n \t\t{\n-\t\t  avail[bprime->index] = eprime;\n+\t\t  VEC_replace (pre_expr, avail, pred->dest_idx, eprime);\n \t\t  all_same = false;\n \t\t}\n \t      else\n \t\t{\n-\t\t  avail[bprime->index] = edoubleprime;\n+\t\t  VEC_replace (pre_expr, avail, pred->dest_idx, edoubleprime);\n \t\t  by_some = true;\n \t\t  /* We want to perform insertions to remove a redundancy on\n \t\t     a path in the CFG we want to optimize for speed.  */\n@@ -3562,11 +3564,11 @@ do_regular_insertion (basic_block block, basic_block dom)\n \t\t    }\n \t\t}\n \t    }\n-\t  free (avail);\n \t}\n     }\n \n   VEC_free (pre_expr, heap, exprs);\n+  VEC_free (pre_expr, heap, avail);\n   return new_stuff;\n }\n \n@@ -3582,15 +3584,18 @@ static bool\n do_partial_partial_insertion (basic_block block, basic_block dom)\n {\n   bool new_stuff = false;\n-  VEC (pre_expr, heap) *exprs = sorted_array_from_bitmap_set (PA_IN (block));\n+  VEC (pre_expr, heap) *exprs;\n   pre_expr expr;\n+  VEC (pre_expr, heap) *avail = NULL;\n   int i;\n \n+  exprs = sorted_array_from_bitmap_set (PA_IN (block));\n+  VEC_safe_grow (pre_expr, heap, avail, EDGE_COUNT (block->preds));\n+\n   FOR_EACH_VEC_ELT (pre_expr, exprs, i, expr)\n     {\n       if (expr->kind != NAME)\n \t{\n-\t  pre_expr *avail;\n \t  unsigned int val;\n \t  bool by_all = true;\n \t  bool cant_insert = false;\n@@ -3605,10 +3610,6 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t  if (bitmap_set_contains_value (AVAIL_OUT (dom), val))\n \t    continue;\n \n-\t  /* FIXME: This costs N_EXPR*N_BASIC_BLOCKS.  Should use\n-\t     a less costly data structure for avail (e.g. a VEC\n-\t     indexed by edge index).  */\n-\t  avail = XCNEWVEC (pre_expr, last_basic_block);\n \t  FOR_EACH_EDGE (pred, ei, block->preds)\n \t    {\n \t      unsigned int vprime;\n@@ -3633,6 +3634,7 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t\t rest of the results are.  */\n \t      if (eprime == NULL)\n \t\t{\n+\t\t  VEC_replace (pre_expr, avail, pred->dest_idx, NULL);\n \t\t  cant_insert = true;\n \t\t  break;\n \t\t}\n@@ -3641,13 +3643,12 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t      vprime = get_expr_value_id (eprime);\n \t      edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n \t\t\t\t\t\t vprime, NULL);\n+\t      VEC_replace (pre_expr, avail, pred->dest_idx, edoubleprime);\n \t      if (edoubleprime == NULL)\n \t\t{\n \t\t  by_all = false;\n \t\t  break;\n \t\t}\n-\t      else\n-\t\tavail[bprime->index] = edoubleprime;\n \t    }\n \n \t  /* If we can insert it, it's not the same value\n@@ -3701,11 +3702,11 @@ do_partial_partial_insertion (basic_block block, basic_block dom)\n \t\t    new_stuff = true;\n \t\t}\t   \n \t    } \n-\t  free (avail);\n \t}\n     }\n \n   VEC_free (pre_expr, heap, exprs);\n+  VEC_free (pre_expr, heap, avail);\n   return new_stuff;\n }\n "}]}