{"sha": "ee118c14f71f43a4b82c439cd4381e034bd2786a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUxMThjMTRmNzFmNDNhNGI4MmM0MzljZDQzODFlMDM0YmQyNzg2YQ==", "commit": {"author": {"name": "Andrea Corallo", "email": "andrea.corallo@arm.com", "date": "2019-07-04T15:46:00Z"}, "committer": {"name": "Andrea Corallo", "email": "akrl@gcc.gnu.org", "date": "2019-07-04T15:46:00Z"}, "message": "introduce gcc_jit_context_new_bitfield\n\ngcc/jit/ChangeLog:\n2019-07-04  Andrea Corallo <andrea.corallo@arm.com>\n\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_12): New ABI tag.\n\t* docs/topics/types.rst: Add gcc_jit_context_new_bitfield.\n\t* jit-common.h (namespace recording): Add class bitfield.\n\t* jit-playback.c:\n\t(DECL_C_BIT_FIELD, SET_DECL_C_BIT_FIELD): Add macros.\n\t(playback::context::new_bitfield): New method.\n\t(playback::compound_type::set_fields): Add bitfield support.\n\t(playback::lvalue::mark_addressable): Was jit_mark_addressable make this\n\ta method of lvalue plus return a bool to communicate success.\n\t(playback::lvalue::get_address): Check for jit_mark_addressable return\n\tvalue.\n\t* jit-playback.h (new_bitfield): New method.\n\t(class bitfield): New class.\n\t(class lvalue): Add jit_mark_addressable method.\n\t* jit-recording.c (recording::context::new_bitfield): New method.\n\t(recording::bitfield::replay_into): New method.\n\t(recording::bitfield::write_to_dump): Likewise.\n\t(recording::bitfield::make_debug_string): Likewise.\n\t(recording::bitfield::write_reproducer): Likewise.\n\t* jit-recording.h (class context): Add new_bitfield method.\n\t(class field): Make it derivable by class bitfield.\n\t(class bitfield): Add new class.\n\t* libgccjit++.h (class context): Add new_bitfield method.\n\t* libgccjit.c (struct gcc_jit_bitfield): New structure.\n\t(gcc_jit_context_new_bitfield): New function.\n\t* libgccjit.h\n\t(LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield) New macro.\n\t(gcc_jit_context_new_bitfield): New function.\n\t* libgccjit.map (LIBGCCJIT_ABI_12) New ABI tag.\n\ngcc/testsuite/ChangeLog:\n2019-07-04  Andrea Corallo <andrea.corallo@arm.com>\n\n\t* jit.dg/all-non-failing-tests.h: Add test-accessing-bitfield.c.\n\t* jit.dg/test-accessing-bitfield.c: New testcase.\n\t* jit.dg/test-error-gcc_jit_context_new_bitfield-invalid-type.c:\n\tLikewise.\n\t* jit.dg/test-error-gcc_jit_context_new_bitfield-invalid-width.c:\n\tLikewise.\n\t* jit.dg/test-error-gcc_jit_lvalue_get_address-bitfield.c:\n\tLikewise.\n\nFrom-SVN: r273086", "tree": {"sha": "023d5a6423cfaf816e0dc16b7c00aafb8c673194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/023d5a6423cfaf816e0dc16b7c00aafb8c673194"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee118c14f71f43a4b82c439cd4381e034bd2786a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee118c14f71f43a4b82c439cd4381e034bd2786a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee118c14f71f43a4b82c439cd4381e034bd2786a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee118c14f71f43a4b82c439cd4381e034bd2786a/comments", "author": {"login": "AndreaCorallo", "id": 6765576, "node_id": "MDQ6VXNlcjY3NjU1NzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6765576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AndreaCorallo", "html_url": "https://github.com/AndreaCorallo", "followers_url": "https://api.github.com/users/AndreaCorallo/followers", "following_url": "https://api.github.com/users/AndreaCorallo/following{/other_user}", "gists_url": "https://api.github.com/users/AndreaCorallo/gists{/gist_id}", "starred_url": "https://api.github.com/users/AndreaCorallo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AndreaCorallo/subscriptions", "organizations_url": "https://api.github.com/users/AndreaCorallo/orgs", "repos_url": "https://api.github.com/users/AndreaCorallo/repos", "events_url": "https://api.github.com/users/AndreaCorallo/events{/privacy}", "received_events_url": "https://api.github.com/users/AndreaCorallo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ebebc928d8b0d17676e751848892f927373b1fe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebebc928d8b0d17676e751848892f927373b1fe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebebc928d8b0d17676e751848892f927373b1fe5"}], "stats": {"total": 677, "additions": 656, "deletions": 21}, "files": [{"sha": "8323e2f488e5dfd52d8245a7ff67258c0a2c041c", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -1,3 +1,35 @@\n+2019-07-04  Andrea Corallo <andrea.corallo@arm.com>\n+\n+\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_12): New ABI tag.\n+\t* docs/topics/types.rst: Add gcc_jit_context_new_bitfield.\n+\t* jit-common.h (namespace recording): Add class bitfield.\n+\t* jit-playback.c:\n+\t(DECL_C_BIT_FIELD, SET_DECL_C_BIT_FIELD): Add macros.\n+\t(playback::context::new_bitfield): New method.\n+\t(playback::compound_type::set_fields): Add bitfield support.\n+\t(playback::lvalue::mark_addressable): Was jit_mark_addressable make this\n+\ta method of lvalue plus return a bool to communicate success.\n+\t(playback::lvalue::get_address): Check for jit_mark_addressable return\n+\tvalue.\n+\t* jit-playback.h (new_bitfield): New method.\n+\t(class bitfield): New class.\n+\t(class lvalue): Add jit_mark_addressable method.\n+\t* jit-recording.c (recording::context::new_bitfield): New method.\n+\t(recording::bitfield::replay_into): New method.\n+\t(recording::bitfield::write_to_dump): Likewise.\n+\t(recording::bitfield::make_debug_string): Likewise.\n+\t(recording::bitfield::write_reproducer): Likewise.\n+\t* jit-recording.h (class context): Add new_bitfield method.\n+\t(class field): Make it derivable by class bitfield.\n+\t(class bitfield): Add new class.\n+\t* libgccjit++.h (class context): Add new_bitfield method.\n+\t* libgccjit.c (struct gcc_jit_bitfield): New structure.\n+\t(gcc_jit_context_new_bitfield): New function.\n+\t* libgccjit.h\n+\t(LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield) New macro.\n+\t(gcc_jit_context_new_bitfield): New function.\n+\t* libgccjit.map (LIBGCCJIT_ABI_12) New ABI tag.\n+\n 2019-03-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* jit-recording.c (reproducer::m_set_identifiers): Use false as Lazy"}, {"sha": "da649206cec5a2f7b871b7ff9815f7c8a46c9c19", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -177,3 +177,8 @@ entrypoints:\n --------------------\n ``LIBGCCJIT_ABI_11`` covers the addition of\n :func:`gcc_jit_context_add_driver_option`\n+\n+``LIBGCCJIT_ABI_12``\n+--------------------\n+``LIBGCCJIT_ABI_12`` covers the addition of\n+:func:`gcc_jit_context_new_bitfield`"}, {"sha": "37d9d01a958d8d0ced39b60f1bf4be2d30ed5e46", "filename": "gcc/jit/docs/topics/types.rst", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -247,6 +247,30 @@ You can model C `struct` types by creating :c:type:`gcc_jit_struct *` and\n    underlying string, so it is valid to pass in a pointer to an on-stack\n    buffer.\n \n+.. function:: gcc_jit_field *\\\n+              gcc_jit_context_new_bitfield (gcc_jit_context *ctxt,\\\n+                                            gcc_jit_location *loc,\\\n+                                            gcc_jit_type *type,\\\n+                                            int width,\\\n+                                            const char *name)\n+\n+   Construct a new bit field, with the given type width and name.\n+\n+   The parameter ``name`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n+\n+   The parameter ``type`` must be an integer type.\n+\n+   The parameter ``width`` must be a positive integer that does not exceed the\n+   size of ``type``.\n+\n+   This API entrypoint was added in :ref:`LIBGCCJIT_ABI_12`; you can test\n+   for its presence using\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield\n+\n .. function:: gcc_jit_object *\\\n               gcc_jit_field_as_object (gcc_jit_field *field)\n "}, {"sha": "e747d9611f2e63a786a7128187f199be1c16d5ee", "filename": "gcc/jit/jit-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-common.h?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -119,6 +119,7 @@ namespace recording {\n \tclass union_;\n       class vector_type;\n     class field;\n+      class bitfield;\n     class fields;\n     class function;\n     class block;"}, {"sha": "942c7304ebf78774d77bc2f7425a491ce1ef8194", "filename": "gcc/jit/jit-playback.c", "status": "modified", "additions": 79, "deletions": 12, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-playback.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-playback.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -47,6 +47,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"jit-builtins.h\"\n #include \"jit-tempdir.h\"\n \n+/* Compare with gcc/c-family/c-common.h: DECL_C_BIT_FIELD,\n+   SET_DECL_C_BIT_FIELD.\n+   These are redefined here to avoid depending from the C frontend.  */\n+#define DECL_JIT_BIT_FIELD(NODE) \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) == 1)\n+#define SET_DECL_JIT_BIT_FIELD(NODE) \\\n+  (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 1)\n \n /* gcc::jit::playback::context::build_cast uses the convert.h API,\n    which in turn requires the frontend to provide a \"convert\"\n@@ -263,6 +270,46 @@ new_field (location *loc,\n   return new field (decl);\n }\n \n+/* Construct a playback::bitfield instance (wrapping a tree).  */\n+\n+playback::field *\n+playback::context::\n+new_bitfield (location *loc,\n+\t      type *type,\n+\t      int width,\n+\t      const char *name)\n+{\n+  gcc_assert (type);\n+  gcc_assert (name);\n+  gcc_assert (width);\n+\n+  /* compare with c/c-decl.c:grokfield,  grokdeclarator and\n+     check_bitfield_type_and_width.  */\n+\n+  tree tree_type = type->as_tree ();\n+  gcc_assert (INTEGRAL_TYPE_P (tree_type));\n+  tree tree_width = build_int_cst (integer_type_node, width);\n+  if (compare_tree_int (tree_width, TYPE_PRECISION (tree_type)) > 0)\n+    {\n+      add_error (\n+\tloc,\n+\t\"width of bit-field %s (width: %i) is wider than its type (width: %i)\",\n+\tname, width, TYPE_PRECISION (tree_type));\n+      return NULL;\n+    }\n+\n+  tree decl = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t  get_identifier (name), type->as_tree ());\n+  DECL_NONADDRESSABLE_P (decl) = true;\n+  DECL_INITIAL (decl) = tree_width;\n+  SET_DECL_JIT_BIT_FIELD (decl);\n+\n+  if (loc)\n+    set_tree_location (decl, loc);\n+\n+  return new field (decl);\n+}\n+\n /* Construct a playback::compound_type instance (wrapping a tree).  */\n \n playback::compound_type *\n@@ -295,8 +342,15 @@ playback::compound_type::set_fields (const auto_vec<playback::field *> *fields)\n   for (unsigned i = 0; i < fields->length (); i++)\n     {\n       field *f = (*fields)[i];\n-      DECL_CONTEXT (f->as_tree ()) = t;\n-      fieldlist = chainon (f->as_tree (), fieldlist);\n+      tree x = f->as_tree ();\n+      DECL_CONTEXT (x) = t;\n+      if (DECL_JIT_BIT_FIELD (x))\n+\t{\n+\t  unsigned HOST_WIDE_INT width = tree_to_uhwi (DECL_INITIAL (x));\n+\t  DECL_SIZE (x) = bitsize_int (width);\n+\t  DECL_BIT_FIELD (x) = 1;\n+\t}\n+      fieldlist = chainon (x, fieldlist);\n     }\n   fieldlist = nreverse (fieldlist);\n   TYPE_FIELDS (t) = fieldlist;\n@@ -1197,20 +1251,31 @@ dereference (location *loc)\n   return new lvalue (get_context (), datum);\n }\n \n-/* Mark EXP saying that we need to be able to take the\n+/* Mark the lvalue saying that we need to be able to take the\n    address of it; it should not be allocated in a register.\n-   Compare with e.g. c/c-typeck.c: c_mark_addressable.  */\n+   Compare with e.g. c/c-typeck.c: c_mark_addressable really_atomic_lvalue.\n+   Returns false if a failure occurred (an error will already have been\n+   added to the active context for this case).  */\n \n-static void\n-jit_mark_addressable (tree exp)\n+bool\n+playback::lvalue::\n+mark_addressable (location *loc)\n {\n-  tree x = exp;\n+  tree x = as_tree ();;\n \n   while (1)\n     switch (TREE_CODE (x))\n       {\n       case COMPONENT_REF:\n-\t/* (we don't yet support bitfields)  */\n+\tif (DECL_JIT_BIT_FIELD (TREE_OPERAND (x, 1)))\n+\t  {\n+\t    gcc_assert (gcc::jit::active_playback_ctxt);\n+\t    gcc::jit::\n+\t      active_playback_ctxt->add_error (loc,\n+\t\t\t\t\t       \"cannot take address of \"\n+\t\t\t\t\t       \"bit-field\");\n+\t    return false;\n+\t  }\n \t/* fallthrough */\n       case ADDR_EXPR:\n       case ARRAY_REF:\n@@ -1222,7 +1287,7 @@ jit_mark_addressable (tree exp)\n       case COMPOUND_LITERAL_EXPR:\n       case CONSTRUCTOR:\n \tTREE_ADDRESSABLE (x) = 1;\n-\treturn;\n+\treturn true;\n \n       case VAR_DECL:\n       case CONST_DECL:\n@@ -1234,7 +1299,7 @@ jit_mark_addressable (tree exp)\n \tTREE_ADDRESSABLE (x) = 1;\n \t/* fallthrough */\n       default:\n-\treturn;\n+\treturn true;\n       }\n }\n \n@@ -1251,8 +1316,10 @@ get_address (location *loc)\n   tree ptr = build1 (ADDR_EXPR, t_ptrtype, t_lvalue);\n   if (loc)\n     get_context ()->set_tree_location (ptr, loc);\n-  jit_mark_addressable (t_lvalue);\n-  return new rvalue (get_context (), ptr);\n+  if (mark_addressable (loc))\n+    return new rvalue (get_context (), ptr);\n+  else\n+    return NULL;\n }\n \n /* The wrapper subclasses are GC-managed, but can own non-GC memory."}, {"sha": "d4b148e3e57bf5afdd2fe5267515133f21e0c341", "filename": "gcc/jit/jit-playback.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-playback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-playback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-playback.h?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -75,6 +75,12 @@ class context : public log_user\n \t     type *type,\n \t     const char *name);\n \n+  field *\n+  new_bitfield (location *loc,\n+\t\ttype *type,\n+\t\tint width,\n+\t\tconst char *name);\n+\n   compound_type *\n   new_compound_type (location *loc,\n \t\t     const char *name,\n@@ -426,6 +432,8 @@ class field : public wrapper\n   tree m_inner;\n };\n \n+class bitfield : public field {};\n+\n class function : public wrapper\n {\n public:\n@@ -614,6 +622,8 @@ class lvalue : public rvalue\n   rvalue *\n   get_address (location *loc);\n \n+private:\n+  bool mark_addressable (location *loc);\n };\n \n class param : public lvalue\n@@ -703,4 +713,3 @@ extern playback::context *active_playback_ctxt;\n } // namespace gcc\n \n #endif /* JIT_PLAYBACK_H */\n-"}, {"sha": "495ac7f1ae945c207307635926fbf69c51ffdc31", "filename": "gcc/jit/jit-recording.c", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-recording.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-recording.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -872,6 +872,24 @@ recording::context::new_field (recording::location *loc,\n   return result;\n }\n \n+/* Create a recording::bitfield instance and add it to this context's list\n+   of mementos.\n+\n+   Implements the post-error-checking part of\n+   gcc_jit_context_new_bitfield.  */\n+\n+recording::field *\n+recording::context::new_bitfield (recording::location *loc,\n+\t\t\t\t  recording::type *type,\n+\t\t\t\t  int width,\n+\t\t\t\t  const char *name)\n+{\n+  recording::field *result =\n+    new recording::bitfield (this, loc, type, width, new_string (name));\n+  record (result);\n+  return result;\n+}\n+\n /* Create a recording::struct_ instance and add it to this context's\n    list of mementos and list of compound types.\n \n@@ -2962,7 +2980,7 @@ recording::field::replay_into (replayer *r)\n    recording::memento::write_to_dump.  Dump each field\n    by dumping a line of the form:\n       TYPE NAME;\n-   so that we can build up a struct/union field-byfield.  */\n+   so that we can build up a struct/union field by field.  */\n \n void\n recording::field::write_to_dump (dump &d)\n@@ -2999,6 +3017,66 @@ recording::field::write_reproducer (reproducer &r)\n \t  m_name->get_debug_string ());\n }\n \n+/* The implementation of class gcc::jit::recording::bitfield.  */\n+\n+/* Implementation of pure virtual hook recording::memento::replay_into\n+   for recording::bitfield.  */\n+\n+void\n+recording::bitfield::replay_into (replayer *r)\n+{\n+  set_playback_obj (r->new_bitfield (playback_location (r, m_loc),\n+\t\t\t\t     m_type->playback_type (),\n+\t\t\t\t     m_width,\n+\t\t\t\t     playback_string (m_name)));\n+}\n+\n+/* Override the default implementation of\n+   recording::memento::write_to_dump.  Dump each bit field\n+   by dumping a line of the form:\n+      TYPE NAME:WIDTH;\n+   so that we can build up a struct/union field by field.  */\n+\n+void\n+recording::bitfield::write_to_dump (dump &d)\n+{\n+  d.write (\"  %s %s:%d;\\n\",\n+\t   m_type->get_debug_string (),\n+\t   m_name->c_str (),\n+\t   m_width);\n+}\n+\n+/* Implementation of recording::memento::make_debug_string for\n+   results of new_bitfield.  */\n+\n+recording::string *\n+recording::bitfield::make_debug_string ()\n+{\n+  return string::from_printf (m_ctxt,\n+\t\t\t      \"%s:%d\",\n+\t\t\t      m_name->c_str (), m_width);\n+}\n+\n+/* Implementation of recording::memento::write_reproducer for bitfields.  */\n+\n+void\n+recording::bitfield::write_reproducer (reproducer &r)\n+{\n+  const char *id = r.make_identifier (this, \"bitfield\");\n+  r.write (\"  gcc_jit_field *%s =\\n\"\n+\t   \"    gcc_jit_context_new_bitfield (%s,\\n\"\n+\t   \"                               %s, /* gcc_jit_location *loc */\\n\"\n+\t   \"                               %s, /* gcc_jit_type *type, */\\n\"\n+\t   \"                               %d, /* int width, */\\n\"\n+\t   \"                               %s); /* const char *name */\\n\",\n+\t   id,\n+\t   r.get_identifier (get_context ()),\n+\t   r.get_identifier (m_loc),\n+\t   r.get_identifier_as_type (m_type),\n+\t   m_width,\n+\t   m_name->get_debug_string ());\n+}\n+\n /* The implementation of class gcc::jit::recording::compound_type */\n \n /* The constructor for gcc::jit::recording::compound_type.  */"}, {"sha": "13ec7eabefab5d66b4e6634978d1e9b9989701e2", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -95,6 +95,12 @@ class context : public log_user\n \t     type *type,\n \t     const char *name);\n \n+  field *\n+  new_bitfield (location *loc,\n+                type *type,\n+                int width,\n+                const char *name);\n+\n   struct_ *\n   new_struct_type (location *loc,\n \t\t   const char *name);\n@@ -822,9 +828,9 @@ class field : public memento\n   compound_type * get_container () const { return m_container; }\n   void set_container (compound_type *c) { m_container = c; }\n \n-  void replay_into (replayer *) FINAL OVERRIDE;\n+  void replay_into (replayer *) OVERRIDE;\n \n-  void write_to_dump (dump &d) FINAL OVERRIDE;\n+  void write_to_dump (dump &d) OVERRIDE;\n \n   playback::field *\n   playback_field () const\n@@ -833,16 +839,41 @@ class field : public memento\n   }\n \n private:\n-  string * make_debug_string () FINAL OVERRIDE;\n-  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+  string * make_debug_string () OVERRIDE;\n+  void write_reproducer (reproducer &r) OVERRIDE;\n \n-private:\n+protected:\n   location *m_loc;\n   type *m_type;\n   string *m_name;\n   compound_type *m_container;\n };\n \n+\n+class bitfield : public field\n+{\n+public:\n+  bitfield (context *ctxt,\n+\t    location *loc,\n+\t    type *type,\n+\t    int width,\n+\t    string *name)\n+    : field (ctxt, loc, type, name),\n+      m_width (width)\n+  {}\n+\n+  void replay_into (replayer *) FINAL OVERRIDE;\n+\n+  void write_to_dump (dump &d) FINAL OVERRIDE;\n+\n+private:\n+  string * make_debug_string () FINAL OVERRIDE;\n+  void write_reproducer (reproducer &r) FINAL OVERRIDE;\n+\n+private:\n+  int m_width;\n+};\n+\n /* Base class for struct_ and union_ */\n class compound_type : public type\n {"}, {"sha": "0c5be5a85f39cfa60a9c3cda1f89b5ce687180bd", "filename": "gcc/jit/libgccjit++.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit%2B%2B.h?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -152,6 +152,9 @@ namespace gccjit\n     field new_field (type type_, const std::string &name,\n \t\t     location loc = location ());\n \n+    field new_bitfield (type type_, int width, const std::string &name,\n+\t\t\tlocation loc = location ());\n+\n     struct_ new_struct_type (const std::string &name,\n \t\t\t     std::vector<field> &fields,\n \t\t\t     location loc = location ());\n@@ -757,6 +760,17 @@ context::new_field (type type_, const std::string &name, location loc)\n \t\t\t\t\t   name.c_str ()));\n }\n \n+inline field\n+context::new_bitfield (type type_, int width, const std::string &name,\n+\t\t       location loc)\n+{\n+  return field (gcc_jit_context_new_bitfield (m_inner_ctxt,\n+\t\t\t\t\t      loc.get_inner_location (),\n+\t\t\t\t\t      type_.get_inner_type (),\n+\t\t\t\t\t      width,\n+\t\t\t\t\t      name.c_str ()));\n+}\n+\n inline struct_\n context::new_struct_type (const std::string &name,\n \t\t\t  std::vector<field> &fields,"}, {"sha": "abf701919a293cb8ea3e4b04cac8a619c9770f1b", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -62,6 +62,10 @@ struct gcc_jit_field : public gcc::jit::recording::field\n {\n };\n \n+struct gcc_jit_bitfield : public gcc::jit::recording::bitfield\n+{\n+};\n+\n struct gcc_jit_function : public gcc::jit::recording::function\n {\n };\n@@ -554,6 +558,42 @@ gcc_jit_context_new_field (gcc_jit_context *ctxt,\n   return (gcc_jit_field *)ctxt->new_field (loc, type, name);\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::context::new_bitfield method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_field *\n+gcc_jit_context_new_bitfield (gcc_jit_context *ctxt,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      gcc_jit_type *type,\n+\t\t\t      int width,\n+\t\t\t      const char *name)\n+{\n+  RETURN_NULL_IF_FAIL (ctxt, NULL, NULL, \"NULL context\");\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  /* LOC can be NULL.  */\n+  RETURN_NULL_IF_FAIL (name, ctxt, loc, \"NULL name\");\n+  RETURN_NULL_IF_FAIL (type, ctxt, loc, \"NULL type\");\n+  RETURN_NULL_IF_FAIL_PRINTF2 (type->is_int () || type->is_bool (),\n+\t\t\t       ctxt, loc,\n+\t\t\t       \"bit-field %s has non integral type %s\",\n+\t\t\t       name, type->get_debug_string ());\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    width > 0, ctxt, loc,\n+    \"invalid width %d for bitfield \\\"%s\\\" (must be > 0)\",\n+    width, name);\n+  RETURN_NULL_IF_FAIL_PRINTF2 (\n+    type->has_known_size (),\n+    ctxt, loc,\n+    \"unknown size for field \\\"%s\\\" (type: %s)\",\n+    name,\n+    type->get_debug_string ());\n+\n+  return (gcc_jit_field *)ctxt->new_bitfield (loc, type, width, name);\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, this calls the trivial"}, {"sha": "9c5f23bada5ffafb00aee534ad06ed25be1a92d0", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -602,6 +602,21 @@ gcc_jit_context_new_field (gcc_jit_context *ctxt,\n \t\t\t   gcc_jit_type *type,\n \t\t\t   const char *name);\n \n+#define LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield\n+\n+/* Create a bit field, for use within a struct or union.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_12; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_gcc_jit_context_new_bitfield\n+*/\n+extern gcc_jit_field *\n+gcc_jit_context_new_bitfield (gcc_jit_context *ctxt,\n+\t\t\t      gcc_jit_location *loc,\n+\t\t\t      gcc_jit_type *type,\n+\t\t\t      int width,\n+\t\t\t      const char *name);\n+\n /* Upcasting from field to object.  */\n extern gcc_jit_object *\n gcc_jit_field_as_object (gcc_jit_field *field);"}, {"sha": "40e1c78f2bbbe71cdcab390b530c54514227f132", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -174,4 +174,9 @@ LIBGCCJIT_ABI_10 {\n LIBGCCJIT_ABI_11 {\n   global:\n     gcc_jit_context_add_driver_option;\n-} LIBGCCJIT_ABI_10;\n\\ No newline at end of file\n+} LIBGCCJIT_ABI_10;\n+\n+LIBGCCJIT_ABI_12 {\n+  global:\n+    gcc_jit_context_new_bitfield;\n+} LIBGCCJIT_ABI_11;\n\\ No newline at end of file"}, {"sha": "e7db610ab78714a8cb053927053a3a0e611108fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -1,3 +1,14 @@\n+2019-07-04  Andrea Corallo <andrea.corallo@arm.com>\n+\n+\t* jit.dg/all-non-failing-tests.h: Add test-accessing-bitfield.c.\n+\t* jit.dg/test-accessing-bitfield.c: New testcase.\n+\t* jit.dg/test-error-gcc_jit_context_new_bitfield-invalid-type.c:\n+\tLikewise.\n+\t* jit.dg/test-error-gcc_jit_context_new_bitfield-invalid-width.c:\n+\tLikewise.\n+\t* jit.dg/test-error-gcc_jit_lvalue_get_address-bitfield.c:\n+\tLikewise.\n+\n 2019-07-04  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/tree-ssa/alias-access-path-3.c: New testcase.\n@@ -122,7 +133,7 @@\n \n \tPR tree-optimization/91033\n \t* gcc.target/i386/pr91033.c: New test.\n-\t\n+\n 2019-07-03  Bob Duff  <duff@adacore.com>\n \n \t* gnat.dg/task2.adb, gnat.dg/task2_pkg.adb,"}, {"sha": "0272e6f846fbb4fd0aae0808793d8d2160fa0315", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -8,6 +8,13 @@\n    hooks provided by each test case.  */\n #define COMBINED_TEST\n \n+/* test-accessing-bitfield.c */\n+#define create_code create_code_accessing_bitfield\n+#define verify_code verify_code_accessing_bitfield\n+#include \"test-accessing-bitfield.c\"\n+#undef create_code\n+#undef verify_code\n+\n /* test-accessing-struct.c */\n #define create_code create_code_accessing_struct\n #define verify_code verify_code_accessing_struct\n@@ -266,6 +273,9 @@ struct testcase\n };\n \n const struct testcase testcases[] = {\n+  {\"accessing_bitfield\",\n+   create_code_accessing_bitfield,\n+   verify_code_accessing_bitfield},\n   {\"accessing_struct\",\n    create_code_accessing_struct,\n    verify_code_accessing_struct},"}, {"sha": "5e80351e3710732e4d03d4812d8dfc4629fbe714", "filename": "gcc/testsuite/jit.dg/test-accessing-bitfield.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-bitfield.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-bitfield.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-accessing-bitfield.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -0,0 +1,130 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+struct bit_foo\n+{\n+  int i:3;\n+  int x:5;\n+  int y:5;\n+  int z:10;\n+  int j:3;\n+};\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+     void\n+     test_bitfield_access (struct bit_foo *f)\n+     {\n+        f->z = f->x + f->y;\n+     }\n+  */\n+  gcc_jit_type *void_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_VOID);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_field *i =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  3,\n+\t\t\t\t  \"i\");\n+  gcc_jit_field *x =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  5,\n+\t\t\t\t  \"x\");\n+  gcc_jit_field *y =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  5,\n+\t\t\t\t  \"y\");\n+  gcc_jit_field *z =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  10,\n+\t\t\t\t  \"z\");\n+  gcc_jit_field *j =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  3,\n+\t\t\t\t  \"j\");\n+  gcc_jit_field *fields[] = {i, x, y, z, j};\n+  gcc_jit_struct *struct_type =\n+    gcc_jit_context_new_struct_type (ctxt, NULL, \"bit_foo\", 5, fields);\n+  gcc_jit_type *ptr_type =\n+    gcc_jit_type_get_pointer (gcc_jit_struct_as_type (struct_type));\n+\n+  /* Build the test function.  */\n+  gcc_jit_param *param_f =\n+    gcc_jit_context_new_param (ctxt, NULL, ptr_type, \"f\");\n+  gcc_jit_function *test_fn =\n+    gcc_jit_context_new_function (ctxt, NULL,\n+                                  GCC_JIT_FUNCTION_EXPORTED,\n+                                  void_type,\n+                                  \"test_bitfield_access\",\n+                                  1, &param_f,\n+                                  0);\n+\n+  /* f->x + f->y */\n+  gcc_jit_rvalue *sum =\n+    gcc_jit_context_new_binary_op (\n+      ctxt, NULL,\n+      GCC_JIT_BINARY_OP_PLUS,\n+      int_type,\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_rvalue_dereference_field (\n+\t  gcc_jit_param_as_rvalue (param_f),\n+\t  NULL,\n+\t  x)),\n+      gcc_jit_lvalue_as_rvalue (\n+\tgcc_jit_rvalue_dereference_field (\n+\tgcc_jit_param_as_rvalue (param_f),\n+\tNULL,\n+\ty)));\n+\n+  /* f->z = ... */\n+  gcc_jit_block *block = gcc_jit_function_new_block (test_fn, NULL);\n+  gcc_jit_block_add_assignment (\n+    block,\n+    NULL,\n+    gcc_jit_rvalue_dereference_field (\n+      gcc_jit_param_as_rvalue (param_f),\n+      NULL,\n+      z),\n+    sum);\n+  gcc_jit_block_end_with_void_return (block, NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  typedef void (*fn_type) (struct bit_foo *);\n+  CHECK_NON_NULL (result);\n+\n+  fn_type test_bitfield_access =\n+    (fn_type)gcc_jit_result_get_code (result, \"test_bitfield_access\");\n+  CHECK_NON_NULL (test_bitfield_access);\n+\n+  struct bit_foo tmp;\n+  tmp.i = 3;\n+  tmp.x = 5;\n+  tmp.y = 7;\n+  tmp.z = 0;\n+  tmp.j = 3;\n+\n+  /* Call the JIT-generated function.  */\n+  test_bitfield_access (&tmp);\n+\n+  /* Verify that the code correctly modified the field \"z\".  */\n+  CHECK_VALUE (tmp.z, 12);\n+}"}, {"sha": "d2ef5a88c3dfd6840c9f6e0b139965d8cb4ba61f", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_context_new_bitfield-invalid-type.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_bitfield-invalid-type.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_bitfield-invalid-type.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_bitfield-invalid-type.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -0,0 +1,53 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+/* Try to declare a bit-field with invalid type.  */\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *bool_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_BOOL);\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_type *long_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_LONG);\n+  gcc_jit_type *float_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_FLOAT);\n+\n+  gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\tNULL,\n+\t\t\t\tbool_type,\n+\t\t\t\t3,\n+\t\t\t\t\"b\");\n+  gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  3,\n+\t\t\t\t  \"i\");\n+  gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\tNULL,\n+\t\t\t\tlong_type,\n+\t\t\t\t3,\n+\t\t\t\t\"l\");\n+  gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\tNULL,\n+\t\t\t\tfloat_type,\n+\t\t\t\t5,\n+\t\t\t\t\"f\");\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.\t */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"gcc_jit_context_new_bitfield: bit-field f has non \"\n+\t\t      \"integral type float\");\n+}"}, {"sha": "67db120dee2283ec8574a4cf865e2b834e671c91", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_context_new_bitfield-invalid-width.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_bitfield-invalid-width.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_bitfield-invalid-width.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_context_new_bitfield-invalid-width.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -0,0 +1,44 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+/* Try to declare a bit-field with invalid width.  */\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  gcc_jit_type *short_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_SHORT);\n+  gcc_jit_field *i =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  short_type,\n+\t\t\t\t  3,\n+\t\t\t\t  \"i\");\n+  gcc_jit_field *j =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  short_type,\n+\t\t\t\t  157,\n+\t\t\t\t  \"j\");\n+  gcc_jit_field *fields[] = {i, j};\n+  gcc_jit_context_new_struct_type (ctxt, NULL, \"bit_foo\", 2, fields);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+  char error_str[256];\n+  snprintf (error_str, sizeof (error_str),\n+\t    \"width of bit-field j (width: 157) is wider than its type \"\n+\t    \"(width: %zu)\", 8 * sizeof (short));\n+\n+  /* Verify that the correct error message was emitted.  */\n+\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      error_str);\n+}"}, {"sha": "f102a6a7389e3d04751c8bc7b6d9277724d95f51", "filename": "gcc/testsuite/jit.dg/test-error-gcc_jit_lvalue_get_address-bitfield.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_lvalue_get_address-bitfield.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee118c14f71f43a4b82c439cd4381e034bd2786a/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_lvalue_get_address-bitfield.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-error-gcc_jit_lvalue_get_address-bitfield.c?ref=ee118c14f71f43a4b82c439cd4381e034bd2786a", "patch": "@@ -0,0 +1,66 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+/* Try to dereference a bit-field.  */\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Let's try to inject the equivalent of:\n+\n+     struct bit_foo\n+     {\n+       int i:3;\n+       int j:3;\n+     };\n+\n+     struct bit_foo f;\n+     &(f.j)\n+  */\n+  gcc_jit_type *int_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_INT);\n+  gcc_jit_field *i =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  3,\n+\t\t\t\t  \"i\");\n+  gcc_jit_field *j =\n+    gcc_jit_context_new_bitfield (ctxt,\n+\t\t\t\t  NULL,\n+\t\t\t\t  int_type,\n+\t\t\t\t  3,\n+\t\t\t\t  \"j\");\n+  gcc_jit_field *fields[] = {i, j};\n+  gcc_jit_type *struct_type =\n+    gcc_jit_struct_as_type (\n+      gcc_jit_context_new_struct_type (ctxt, NULL, \"bit_foo\", 2, fields));\n+\n+  gcc_jit_lvalue *f_struct =\n+    gcc_jit_context_new_global (ctxt,\n+\t\t\t\tNULL,\n+\t\t\t\tGCC_JIT_GLOBAL_INTERNAL,\n+\t\t\t\tstruct_type,\n+\t\t\t\t\"f\");\n+\n+  gcc_jit_lvalue_get_address (\n+    gcc_jit_lvalue_access_field (\n+      f_struct,\n+      NULL,\n+      j),\n+    NULL);\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  CHECK_VALUE (result, NULL);\n+\n+  /* Verify that the correct error message was emitted.  */\n+  CHECK_STRING_VALUE (gcc_jit_context_get_first_error (ctxt),\n+\t\t      \"cannot take address of bit-field\");\n+}"}]}