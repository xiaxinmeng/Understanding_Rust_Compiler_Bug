{"sha": "7145d9fe6bb782d384cab328c028507b4f8f435a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE0NWQ5ZmU2YmI3ODJkMzg0Y2FiMzI4YzAyODUwN2I0ZjhmNDM1YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-05-02T20:32:31Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-05-02T20:32:31Z"}, "message": "class.c (add_method_1): Set both DECL_EXTERNAL and METHOD_NATIVE on native function.\n\n\t* class.c (add_method_1): Set both DECL_EXTERNAL and METHOD_NATIVE\n\ton native function.\n\t* jcf-parse.c (parse_class_file): Call build_jni_stub for native\n\tJNI methods.\n\t* expr.c (build_jni_stub): New function.\n\t* lang-specs.h: -fjni and -femit-class-file are incompatible.\n\t* parse.c: Rebuilt.\n\t* parse.y (java_complete_expand_methods): Expand a native method\n\tand call build_jni_stub if -fjni given.\n\t* lang-options.h: Document -fjni.\n\t* lang.c (flag_jni): New global.\n\t(lang_f_options): Added `jni' entry.\n\t* java-tree.h (soft_lookupjnimethod_node,\n\tsoft_getjnienvnewframe_node, soft_jnipopsystemframe_node):\n\tDeclare.\n\t(flag_jni): Declare.\n\t(build_jni_stub): Declare.\n\t(struct lang_decl): Added `native' flag.\n\t(METHOD_NATIVE): Redefined to use `native' field of lang specific\n\tstructure.\n\t* decl.c (soft_lookupjnimethod_node, soft_getjnienvnewframe_node,\n\tsoft_jnipopsystemframe_node): New globals.\n\t(init_decl_processing): Set them.  _Jv_InitClass only takes one\n\targument.\n\n\t* java-tree.def: Put into `C' mode.\n\nFrom-SVN: r33615", "tree": {"sha": "f6a3da973a9c08d0deefae724ed229eadde9cd1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6a3da973a9c08d0deefae724ed229eadde9cd1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7145d9fe6bb782d384cab328c028507b4f8f435a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7145d9fe6bb782d384cab328c028507b4f8f435a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7145d9fe6bb782d384cab328c028507b4f8f435a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7145d9fe6bb782d384cab328c028507b4f8f435a/comments", "author": null, "committer": null, "parents": [{"sha": "09fa07054c77f1b022cbd5f676c57df6037b2dd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09fa07054c77f1b022cbd5f676c57df6037b2dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09fa07054c77f1b022cbd5f676c57df6037b2dd0"}], "stats": {"total": 691, "additions": 447, "deletions": 244}, "files": [{"sha": "e3e3a634e32536d64e1b018e920c6f7db8109de8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -1,3 +1,32 @@\n+2000-04-19  Tom Tromey  &lt;tromey@cygnus.com&gt;\n+\n+\t* class.c (add_method_1): Set both DECL_EXTERNAL and METHOD_NATIVE\n+\ton native function.\n+\t* jcf-parse.c (parse_class_file): Call build_jni_stub for native\n+\tJNI methods.\n+\t* expr.c (build_jni_stub): New function.\n+\t* lang-specs.h: -fjni and -femit-class-file are incompatible.\n+\t* parse.c: Rebuilt.\n+\t* parse.y (java_complete_expand_methods): Expand a native method\n+\tand call build_jni_stub if -fjni given.\n+\t* lang-options.h: Document -fjni.\n+\t* lang.c (flag_jni): New global.\n+\t(lang_f_options): Added `jni' entry.\n+\t* java-tree.h (soft_lookupjnimethod_node,\n+\tsoft_getjnienvnewframe_node, soft_jnipopsystemframe_node):\n+\tDeclare.\n+\t(flag_jni): Declare.\n+\t(build_jni_stub): Declare.\n+\t(struct lang_decl): Added `native' flag.\n+\t(METHOD_NATIVE): Redefined to use `native' field of lang specific\n+\tstructure.\n+\t* decl.c (soft_lookupjnimethod_node, soft_getjnienvnewframe_node,\n+\tsoft_jnipopsystemframe_node): New globals.\n+\t(init_decl_processing): Set them.  _Jv_InitClass only takes one\n+\targument.\n+\n+\t* java-tree.def: Put into `C' mode.\n+\n 2000-04-27  Tom Tromey  <tromey@cygnus.com>\n \n \tFix for PR gcj/2:"}, {"sha": "ca29eb9815f447299cae5a40155a03d44daea552", "filename": "gcc/java/class.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -644,7 +644,11 @@ add_method_1 (handle_class, access_flags, name, function_type)\n   if (access_flags & ACC_PROTECTED) METHOD_PROTECTED (fndecl) = 1;\n   if (access_flags & ACC_PRIVATE)\n     METHOD_PRIVATE (fndecl) = DECL_INLINE (fndecl) = 1;\n-  if (access_flags & ACC_NATIVE) METHOD_NATIVE (fndecl) = 1;\n+  if (access_flags & ACC_NATIVE)\n+    {\n+      METHOD_NATIVE (fndecl) = 1;\n+      DECL_EXTERNAL (fndecl) = 1;\n+    }\n   if (access_flags & ACC_STATIC) \n     METHOD_STATIC (fndecl) = DECL_INLINE (fndecl) = 1;\n   if (access_flags & ACC_FINAL) "}, {"sha": "a5eb527e92b9f4a6e0445efead2c8b0471e37582", "filename": "gcc/java/decl.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -381,6 +381,9 @@ tree soft_checkarraystore_node;\n tree soft_monitorenter_node;\n tree soft_monitorexit_node;\n tree soft_lookupinterfacemethod_node;\n+tree soft_lookupjnimethod_node;\n+tree soft_getjnienvnewframe_node;\n+tree soft_jnipopsystemframe_node;\n tree soft_fmod_node;\n tree soft_exceptioninfo_call_node;\n tree soft_idiv_node;\n@@ -753,12 +756,13 @@ init_decl_processing ()\n \t\t\t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\t\t\t0, NOT_BUILT_IN, NULL_PTR);\n   DECL_IS_MALLOC (alloc_object_node) = 1;\n+\n+  t = tree_cons (NULL_TREE, ptr_type_node, endlink);\n   soft_initclass_node = builtin_function (\"_Jv_InitClass\",\n \t\t\t\t\t  build_function_type (void_type_node,\n \t\t\t\t\t\t\t       t),\n \t\t\t\t\t  0, NOT_BUILT_IN,\n \t\t\t\t\t  NULL_PTR);\n-  t = tree_cons (NULL_TREE, ptr_type_node, endlink);\n   throw_node[0] = builtin_function (\"_Jv_Throw\",\n \t\t\t\t    build_function_type (ptr_type_node, t),\n \t\t\t\t    0, NOT_BUILT_IN, NULL_PTR);\n@@ -848,6 +852,24 @@ init_decl_processing ()\n     = builtin_function (\"_Jv_LookupInterfaceMethodIdx\",\n \t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\t0, NOT_BUILT_IN, NULL_PTR);\n+\n+  t = tree_cons (NULL_TREE, object_ptr_type_node,\n+\t\t tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t    tree_cons (NULL_TREE, ptr_type_node, endlink)));\n+  soft_lookupjnimethod_node\n+    = builtin_function (\"_Jv_LookupJNIMethod\",\n+\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\t0, NOT_BUILT_IN, NULL_PTR);\n+  t = tree_cons (NULL_TREE, ptr_type_node, endlink);\n+  soft_getjnienvnewframe_node\n+    = builtin_function (\"_Jv_GetJNIEnvNewFrame\",\n+\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\t0, NOT_BUILT_IN, NULL_PTR);\n+  soft_jnipopsystemframe_node\n+    = builtin_function (\"_Jv_JNI_PopSystemFrame\",\n+\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\t0, NOT_BUILT_IN, NULL_PTR);\n+\n   t = tree_cons (NULL_TREE, double_type_node,\n \t\t tree_cons (NULL_TREE, double_type_node, endlink));\n   soft_fmod_node\n@@ -1726,7 +1748,7 @@ complete_start_java_method (fndecl)\n \n   if (METHOD_SYNCHRONIZED (fndecl) && ! flag_emit_class_files)\n     {\n-      /* Warp function body with a monitorenter plus monitorexit cleanup. */\n+      /* Wrap function body with a monitorenter plus monitorexit cleanup. */\n       tree enter, exit, lock;\n       if (METHOD_STATIC (fndecl))\n \tlock = build_class_ref (DECL_CONTEXT (fndecl));"}, {"sha": "37358e53a3aaf6e9f962eb449e504032aa7201bd", "filename": "gcc/java/expr.c", "status": "modified", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -1844,6 +1844,165 @@ expand_invoke (opcode, method_ref_index, nargs)\n     }\n }\n \n+/* Create a stub which will be put into the vtable but which will call\n+   a JNI function.  */\n+\n+tree\n+build_jni_stub (method)\n+     tree method;\n+{\n+  tree jnifunc, call, args, body, lookup_arg, method_sig, arg_types;\n+  tree jni_func_type, tem;\n+  tree env_var, res_var = NULL_TREE, block;\n+  tree method_args, res_type;\n+\n+  tree klass = DECL_CONTEXT (method);\n+  int from_class = ! CLASS_FROM_SOURCE_P (klass);\n+  klass = build_class_ref (klass);\n+\n+  if (! METHOD_NATIVE (method) || ! flag_jni)\n+    abort ();\n+\n+  DECL_ARTIFICIAL (method) = 1;\n+  DECL_EXTERNAL (method) = 0;\n+\n+  env_var = build_decl (VAR_DECL, get_identifier (\"env\"), ptr_type_node);\n+  if (TREE_TYPE (TREE_TYPE (method)) != void_type_node)\n+    {\n+      res_var = build_decl (VAR_DECL, get_identifier (\"res\"),\n+\t\t\t    TREE_TYPE (TREE_TYPE (method)));\n+      TREE_CHAIN (env_var) = res_var;\n+    }\n+\n+  /* One strange way that the front ends are different is that they\n+     store arguments differently.  */\n+  if (from_class)\n+    method_args = DECL_ARGUMENTS (method);\n+  else\n+    method_args = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (method));\n+  block = build_block (env_var, NULL_TREE, NULL_TREE,\n+\t\t       method_args, NULL_TREE);\n+  TREE_SIDE_EFFECTS (block) = 1;\n+  /* When compiling from source we don't set the type of the block,\n+     because that will prevent patch_return from ever being run.  */\n+  if (from_class)\n+    TREE_TYPE (block) = TREE_TYPE (TREE_TYPE (method));\n+\n+  /* Compute the local `env' by calling _Jv_GetJNIEnvNewFrame.  */\n+  body = build (MODIFY_EXPR, ptr_type_node, env_var,\n+\t\tbuild (CALL_EXPR, ptr_type_node,\n+\t\t       build_address_of (soft_getjnienvnewframe_node),\n+\t\t       build_tree_list (NULL_TREE, klass),\n+\t\t       NULL_TREE));\n+  CAN_COMPLETE_NORMALLY (body) = 1;\n+\n+  /* All the arguments to this method become arguments to the\n+     underlying JNI function.  If we had to wrap object arguments in a\n+     special way, we would do that here.  */\n+  args = NULL_TREE;\n+  for (tem = method_args; tem != NULL_TREE; tem = TREE_CHAIN (tem))\n+    args = tree_cons (NULL_TREE, tem, args);\n+  args = nreverse (args);\n+  arg_types = TYPE_ARG_TYPES (TREE_TYPE (method));\n+\n+  /* For a static method the second argument is the class.  For a\n+     non-static method the second argument is `this'; that is already\n+     available in the argument list.  */\n+  if (METHOD_STATIC (method))\n+    {\n+      args = tree_cons (NULL_TREE, klass, args);\n+      arg_types = tree_cons (NULL_TREE, object_ptr_type_node, arg_types);\n+    }\n+\n+  /* The JNIEnv structure is the first argument to the JNI function.  */\n+  args = tree_cons (NULL_TREE, env_var, args);\n+  arg_types = tree_cons (NULL_TREE, ptr_type_node, arg_types);\n+\n+  /* We call _Jv_LookupJNIMethod to find the actual underlying\n+     function pointer.  _Jv_LookupJNIMethod will throw the appropriate\n+     exception if this function is not found at runtime.  */\n+  method_sig = build_java_signature (TREE_TYPE (method));\n+  lookup_arg =\n+    build_tree_list (NULL_TREE,\n+\t\t     build_utf8_ref (unmangle_classname\n+\t\t\t\t     (IDENTIFIER_POINTER (method_sig),\n+\t\t\t\t      IDENTIFIER_LENGTH (method_sig))));\n+  tem = DECL_NAME (method);\n+  lookup_arg\n+    = tree_cons (NULL_TREE, klass,\n+\t\t tree_cons (NULL_TREE, build_utf8_ref (tem), lookup_arg));\n+\n+  jni_func_type\n+    = build_pointer_type (build_function_type (TREE_TYPE (TREE_TYPE (method)),\n+\t\t\t\t\t       arg_types));\n+\n+  jnifunc = build (CALL_EXPR, ptr_type_node,\n+\t\t   build_address_of (soft_lookupjnimethod_node),\n+\t\t   lookup_arg, NULL_TREE);\n+\n+  /* Now we make the actual JNI call via the resulting function\n+     pointer.    */\n+  call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (method)),\n+\t\tbuild1 (NOP_EXPR, jni_func_type, jnifunc),\n+\t\targs, NULL_TREE);\n+\n+  /* If the JNI call returned a result, capture it here.  If we had to\n+     unwrap JNI object results, we would do that here.  */\n+  if (res_var != NULL_TREE)\n+    call = build (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (method)),\n+\t\t  res_var, call);\n+\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  CAN_COMPLETE_NORMALLY (call) = 1;\n+\n+  body = build (COMPOUND_EXPR, void_type_node, body, call);\n+  TREE_SIDE_EFFECTS (body) = 1;\n+\n+  /* Now free the environment we allocated.  */\n+  call = build (CALL_EXPR, ptr_type_node,\n+\t\tbuild_address_of (soft_jnipopsystemframe_node),\n+\t\tbuild_tree_list (NULL_TREE, env_var),\n+\t\tNULL_TREE);\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  CAN_COMPLETE_NORMALLY (call) = 1;\n+  body = build (COMPOUND_EXPR, void_type_node, body, call);\n+  TREE_SIDE_EFFECTS (body) = 1;\n+\n+  /* Finally, do the return.  When compiling from source we rely on\n+     patch_return to patch the return value -- because DECL_RESULT is\n+     not set at the time this function is called.  */\n+  if (from_class)\n+    {\n+      res_type = void_type_node;\n+      if (res_var != NULL_TREE)\n+\t{\n+\t  tree drt;\n+\t  if (! DECL_RESULT (method))\n+\t    abort ();\n+\t  /* Make sure we copy the result variable to the actual\n+\t     result.  We use the type of the DECL_RESULT because it\n+\t     might be different from the return type of the function:\n+\t     it might be promoted.  */\n+\t  drt = TREE_TYPE (DECL_RESULT (method));\n+\t  if (drt != TREE_TYPE (res_var))\n+\t    res_var = build1 (CONVERT_EXPR, drt, res_var);\n+\t  res_var = build (MODIFY_EXPR, drt, DECL_RESULT (method), res_var);\n+\t  TREE_SIDE_EFFECTS (res_var) = 1;\n+\t}\n+    }\n+  else\n+    {\n+      /* This is necessary to get patch_return to run.  */\n+      res_type = NULL_TREE;\n+    }\n+  body = build (COMPOUND_EXPR, void_type_node, body,\n+\t\tbuild1 (RETURN_EXPR, res_type, res_var));\n+  TREE_SIDE_EFFECTS (body) = 1;\n+\n+  BLOCK_EXPR_BODY (block) = body;\n+  return block;\n+}\n+\n \n /* Expand an operation to extract from or store into a field.\n    IS_STATIC is 1 iff the field is static."}, {"sha": "1b007695650d2c8b8345ce2e17304a6c99d5016e", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -63,7 +63,7 @@ DEFTREECODE (CATCH_EXPR, \"catch\", '1', 1)\n DEFTREECODE (SYNCHRONIZED_EXPR, \"synchronized\", 'e', 2)\n \n /* Throw statement.\n-   Operand 0 is the throw expresion.  */\n+   Operand 0 is the throw expression.  */\n DEFTREECODE (THROW_EXPR, \"throw\", '1', 1)\n \n /* Conditional operator.\n@@ -93,3 +93,8 @@ DEFTREECODE (CLASS_LITERAL, \"class_literal\", '1', 1)\n    is used for context detection, so that special rules can be\n    enforced. */\n DEFTREECODE (INSTANCE_INITIALIZERS_EXPR, \"instance_initializers_expr\", '1', 1)\n+/*\n+Local variables:\n+mode:c\n+End:\n+*/"}, {"sha": "1bf166a1a4b0908147411e923ddd41429acda2a2", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -135,6 +135,11 @@ extern int flag_assume_compiled;\n \n extern int flag_emit_class_files;\n \n+/* When non zero, assume all native functions are implemented with\n+   JNI, not CNI.  */\n+\n+extern int flag_jni;\n+\n /* When non zero, we emit xref strings. Values of the flag for xref\n    backends are defined in xref.h.  */\n \n@@ -296,6 +301,9 @@ extern tree soft_checkarraystore_node;\n extern tree soft_monitorenter_node;\n extern tree soft_monitorexit_node;\n extern tree soft_lookupinterfacemethod_node;\n+extern tree soft_lookupjnimethod_node;\n+extern tree soft_getjnienvnewframe_node;\n+extern tree soft_jnipopsystemframe_node;\n extern tree soft_fmod_node;\n extern tree soft_exceptioninfo_call_node;\n extern tree soft_idiv_node;\n@@ -514,6 +522,9 @@ struct lang_decl\n   tree inner_access;\t\t/* The identifier of the access method\n \t\t\t\t   used for invocation from inner classes */\n   int nap;\t\t\t/* Number of artificial parameters */\n+\n+  int native : 1;\t\t/* Nonzero if this is a native\n+\t\t\t\t   method.  */\n };\n \n /* init_test_table hash table entry structure.  */\n@@ -649,6 +660,7 @@ extern tree build_known_method_ref PARAMS ((tree, tree, tree, tree, tree));\n extern tree build_class_init PARAMS ((tree, tree));\n extern tree build_invokevirtual PARAMS ((tree, tree));\n extern tree build_invokeinterface PARAMS ((tree, tree));\n+extern tree build_jni_stub PARAMS ((tree));\n extern tree invoke_build_dtable PARAMS ((int, tree));\n extern tree build_field_ref PARAMS ((tree, tree, tree));\n extern void pushdecl_force_head PARAMS ((tree));\n@@ -773,7 +785,7 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define METHOD_STATIC(DECL) DECL_LANG_FLAG_2 (DECL)\n #define METHOD_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n #define METHOD_SYNCHRONIZED(DECL) DECL_LANG_FLAG_4 (DECL)\n-#define METHOD_NATIVE(DECL) DECL_EXTERNAL(DECL)\n+#define METHOD_NATIVE(DECL) (DECL_LANG_SPECIFIC(DECL)->native)\n #define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define METHOD_TRANSIENT(DECL) DECL_LANG_FLAG_6 (DECL)\n "}, {"sha": "6d4f2462c6dab81863e83163c5b9d851d689430c", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -684,9 +684,22 @@ parse_class_file ()\n     {\n       JCF *jcf = current_jcf;\n \n-      if (METHOD_NATIVE (method) || METHOD_ABSTRACT (method))\n+      if (METHOD_ABSTRACT (method))\n \tcontinue;\n \n+      if (METHOD_NATIVE (method))\n+\t{\n+\t  if (! flag_jni)\n+\t    continue;\n+\t  DECL_MAX_LOCALS (method)\n+\t    = list_length (TYPE_ARG_TYPES (TREE_TYPE (method)));\n+\t  start_java_method (method);\n+\t  give_name_to_locals (jcf);\n+\t  expand_expr_stmt (build_jni_stub (method));\n+\t  end_java_method ();\n+\t  continue;\n+\t}\n+\n       if (DECL_CODE_OFFSET (method) == 0)\n \t{\n \t  error (\"missing Code attribute\");"}, {"sha": "b6951c643d06e80c28ca226438222a84d3277f99", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -35,6 +35,7 @@ DEFINE_LANG_NAME (\"Java\")\n   { \"-femit-class-files\", \"Dump class files to <name>.class\" },\n   { \"-fuse-boehm-gc\", \"Generate code for Boehm GC\" },\n   { \"-fhash-synchronization\", \"Don't put synchronization structure in each object\" },\n+  { \"-fjni\", \"Assume native functions are implemented using JNI\" },\n #if ! USE_CPPLIB\n   { \"-MD\", \"Print dependencies to FILE.d\" },\n   { \"-MMD\", \"Print dependencies to FILE.d\" },"}, {"sha": "019fca6373c5525589f5399a297adf13f6892286", "filename": "gcc/java/lang-specs.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-specs.h?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for specs for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996, 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -36,6 +36,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \t\t    %{f*} %{+e*} %{aux-info*} %{Qn:-fno-ident}\\\n                     %{I*}\\\n \t\t    %{MD} %{MMD} %{M} %{MM}\\\n+                    %{fjni:%{femit-class-file:%e-fjni and -femit-class-file are incompatible}}\\\n \t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n             %{!S:as %a %Y\\"}, {"sha": "f8c37f2ad818fb602821e182ee583651cb9f1ded", "filename": "gcc/java/lang.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -117,6 +117,10 @@ int flag_use_boehm_gc = 0;\n    object to its synchronization structure.  */\n int flag_hash_synchronization;\n \n+/* When non zero, assume all native functions are implemented with\n+   JNI, not CNI.  */\n+int flag_jni = 0;\n+\n /* From gcc/flags.h, and indicates if exceptions are turned on or not.  */\n \n extern int flag_new_exceptions;\n@@ -135,7 +139,8 @@ lang_f_options[] =\n   {\"emit-class-files\", &flag_emit_class_files, 1},\n   {\"use-divide-subroutine\", &flag_use_divide_subroutine, 1},\n   {\"use-boehm-gc\", &flag_use_boehm_gc, 1},\n-  {\"hash-synchronization\", &flag_hash_synchronization, 1}\n+  {\"hash-synchronization\", &flag_hash_synchronization, 1},\n+  {\"jni\", &flag_jni, 1}\n };\n \n JCF *current_jcf;"}, {"sha": "a362a5dab30fec6e5428958cf15afb023e3420bb", "filename": "gcc/java/parse.c", "status": "modified", "additions": 176, "deletions": 233, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -1,6 +1,7 @@\n \n /*  A Bison parser, made from ./parse.y\n-    by GNU Bison version 1.28  */\n+ by  GNU Bison version 1.25\n+  */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n@@ -11,113 +12,113 @@\n #define yychar java_char\n #define yydebug java_debug\n #define yynerrs java_nerrs\n-#define\tPLUS_TK\t257\n-#define\tMINUS_TK\t258\n-#define\tMULT_TK\t259\n-#define\tDIV_TK\t260\n-#define\tREM_TK\t261\n-#define\tLS_TK\t262\n-#define\tSRS_TK\t263\n-#define\tZRS_TK\t264\n-#define\tAND_TK\t265\n-#define\tXOR_TK\t266\n-#define\tOR_TK\t267\n-#define\tBOOL_AND_TK\t268\n-#define\tBOOL_OR_TK\t269\n-#define\tEQ_TK\t270\n-#define\tNEQ_TK\t271\n-#define\tGT_TK\t272\n-#define\tGTE_TK\t273\n-#define\tLT_TK\t274\n-#define\tLTE_TK\t275\n-#define\tPLUS_ASSIGN_TK\t276\n-#define\tMINUS_ASSIGN_TK\t277\n-#define\tMULT_ASSIGN_TK\t278\n-#define\tDIV_ASSIGN_TK\t279\n-#define\tREM_ASSIGN_TK\t280\n-#define\tLS_ASSIGN_TK\t281\n-#define\tSRS_ASSIGN_TK\t282\n-#define\tZRS_ASSIGN_TK\t283\n-#define\tAND_ASSIGN_TK\t284\n-#define\tXOR_ASSIGN_TK\t285\n-#define\tOR_ASSIGN_TK\t286\n-#define\tPUBLIC_TK\t287\n-#define\tPRIVATE_TK\t288\n-#define\tPROTECTED_TK\t289\n-#define\tSTATIC_TK\t290\n-#define\tFINAL_TK\t291\n-#define\tSYNCHRONIZED_TK\t292\n-#define\tVOLATILE_TK\t293\n-#define\tTRANSIENT_TK\t294\n-#define\tNATIVE_TK\t295\n-#define\tPAD_TK\t296\n-#define\tABSTRACT_TK\t297\n-#define\tMODIFIER_TK\t298\n-#define\tDECR_TK\t299\n-#define\tINCR_TK\t300\n-#define\tDEFAULT_TK\t301\n-#define\tIF_TK\t302\n-#define\tTHROW_TK\t303\n-#define\tBOOLEAN_TK\t304\n-#define\tDO_TK\t305\n-#define\tIMPLEMENTS_TK\t306\n-#define\tTHROWS_TK\t307\n-#define\tBREAK_TK\t308\n-#define\tIMPORT_TK\t309\n-#define\tELSE_TK\t310\n-#define\tINSTANCEOF_TK\t311\n-#define\tRETURN_TK\t312\n-#define\tVOID_TK\t313\n-#define\tCATCH_TK\t314\n-#define\tINTERFACE_TK\t315\n-#define\tCASE_TK\t316\n-#define\tEXTENDS_TK\t317\n-#define\tFINALLY_TK\t318\n-#define\tSUPER_TK\t319\n-#define\tWHILE_TK\t320\n-#define\tCLASS_TK\t321\n-#define\tSWITCH_TK\t322\n-#define\tCONST_TK\t323\n-#define\tTRY_TK\t324\n-#define\tFOR_TK\t325\n-#define\tNEW_TK\t326\n-#define\tCONTINUE_TK\t327\n-#define\tGOTO_TK\t328\n-#define\tPACKAGE_TK\t329\n-#define\tTHIS_TK\t330\n-#define\tBYTE_TK\t331\n-#define\tSHORT_TK\t332\n-#define\tINT_TK\t333\n-#define\tLONG_TK\t334\n-#define\tCHAR_TK\t335\n-#define\tINTEGRAL_TK\t336\n-#define\tFLOAT_TK\t337\n-#define\tDOUBLE_TK\t338\n-#define\tFP_TK\t339\n-#define\tID_TK\t340\n-#define\tREL_QM_TK\t341\n-#define\tREL_CL_TK\t342\n-#define\tNOT_TK\t343\n-#define\tNEG_TK\t344\n-#define\tASSIGN_ANY_TK\t345\n-#define\tASSIGN_TK\t346\n-#define\tOP_TK\t347\n-#define\tCP_TK\t348\n-#define\tOCB_TK\t349\n-#define\tCCB_TK\t350\n-#define\tOSB_TK\t351\n-#define\tCSB_TK\t352\n-#define\tSC_TK\t353\n-#define\tC_TK\t354\n-#define\tDOT_TK\t355\n-#define\tSTRING_LIT_TK\t356\n-#define\tCHAR_LIT_TK\t357\n-#define\tINT_LIT_TK\t358\n-#define\tFP_LIT_TK\t359\n-#define\tTRUE_TK\t360\n-#define\tFALSE_TK\t361\n-#define\tBOOL_LIT_TK\t362\n-#define\tNULL_TK\t363\n+#define\tPLUS_TK\t258\n+#define\tMINUS_TK\t259\n+#define\tMULT_TK\t260\n+#define\tDIV_TK\t261\n+#define\tREM_TK\t262\n+#define\tLS_TK\t263\n+#define\tSRS_TK\t264\n+#define\tZRS_TK\t265\n+#define\tAND_TK\t266\n+#define\tXOR_TK\t267\n+#define\tOR_TK\t268\n+#define\tBOOL_AND_TK\t269\n+#define\tBOOL_OR_TK\t270\n+#define\tEQ_TK\t271\n+#define\tNEQ_TK\t272\n+#define\tGT_TK\t273\n+#define\tGTE_TK\t274\n+#define\tLT_TK\t275\n+#define\tLTE_TK\t276\n+#define\tPLUS_ASSIGN_TK\t277\n+#define\tMINUS_ASSIGN_TK\t278\n+#define\tMULT_ASSIGN_TK\t279\n+#define\tDIV_ASSIGN_TK\t280\n+#define\tREM_ASSIGN_TK\t281\n+#define\tLS_ASSIGN_TK\t282\n+#define\tSRS_ASSIGN_TK\t283\n+#define\tZRS_ASSIGN_TK\t284\n+#define\tAND_ASSIGN_TK\t285\n+#define\tXOR_ASSIGN_TK\t286\n+#define\tOR_ASSIGN_TK\t287\n+#define\tPUBLIC_TK\t288\n+#define\tPRIVATE_TK\t289\n+#define\tPROTECTED_TK\t290\n+#define\tSTATIC_TK\t291\n+#define\tFINAL_TK\t292\n+#define\tSYNCHRONIZED_TK\t293\n+#define\tVOLATILE_TK\t294\n+#define\tTRANSIENT_TK\t295\n+#define\tNATIVE_TK\t296\n+#define\tPAD_TK\t297\n+#define\tABSTRACT_TK\t298\n+#define\tMODIFIER_TK\t299\n+#define\tDECR_TK\t300\n+#define\tINCR_TK\t301\n+#define\tDEFAULT_TK\t302\n+#define\tIF_TK\t303\n+#define\tTHROW_TK\t304\n+#define\tBOOLEAN_TK\t305\n+#define\tDO_TK\t306\n+#define\tIMPLEMENTS_TK\t307\n+#define\tTHROWS_TK\t308\n+#define\tBREAK_TK\t309\n+#define\tIMPORT_TK\t310\n+#define\tELSE_TK\t311\n+#define\tINSTANCEOF_TK\t312\n+#define\tRETURN_TK\t313\n+#define\tVOID_TK\t314\n+#define\tCATCH_TK\t315\n+#define\tINTERFACE_TK\t316\n+#define\tCASE_TK\t317\n+#define\tEXTENDS_TK\t318\n+#define\tFINALLY_TK\t319\n+#define\tSUPER_TK\t320\n+#define\tWHILE_TK\t321\n+#define\tCLASS_TK\t322\n+#define\tSWITCH_TK\t323\n+#define\tCONST_TK\t324\n+#define\tTRY_TK\t325\n+#define\tFOR_TK\t326\n+#define\tNEW_TK\t327\n+#define\tCONTINUE_TK\t328\n+#define\tGOTO_TK\t329\n+#define\tPACKAGE_TK\t330\n+#define\tTHIS_TK\t331\n+#define\tBYTE_TK\t332\n+#define\tSHORT_TK\t333\n+#define\tINT_TK\t334\n+#define\tLONG_TK\t335\n+#define\tCHAR_TK\t336\n+#define\tINTEGRAL_TK\t337\n+#define\tFLOAT_TK\t338\n+#define\tDOUBLE_TK\t339\n+#define\tFP_TK\t340\n+#define\tID_TK\t341\n+#define\tREL_QM_TK\t342\n+#define\tREL_CL_TK\t343\n+#define\tNOT_TK\t344\n+#define\tNEG_TK\t345\n+#define\tASSIGN_ANY_TK\t346\n+#define\tASSIGN_TK\t347\n+#define\tOP_TK\t348\n+#define\tCP_TK\t349\n+#define\tOCB_TK\t350\n+#define\tCCB_TK\t351\n+#define\tOSB_TK\t352\n+#define\tCSB_TK\t353\n+#define\tSC_TK\t354\n+#define\tC_TK\t355\n+#define\tDOT_TK\t356\n+#define\tSTRING_LIT_TK\t357\n+#define\tCHAR_LIT_TK\t358\n+#define\tINT_LIT_TK\t359\n+#define\tFP_LIT_TK\t360\n+#define\tTRUE_TK\t361\n+#define\tFALSE_TK\t362\n+#define\tBOOL_LIT_TK\t363\n+#define\tNULL_TK\t364\n \n #line 48 \"./parse.y\"\n \n@@ -516,7 +517,7 @@ typedef union {\n #define\tYYFLAG\t\t-32768\n #define\tYYNTBASE\t110\n \n-#define YYTRANSLATE(x) ((unsigned)(x) <= 363 ? yytranslate[x] : 272)\n+#define YYTRANSLATE(x) ((unsigned)(x) <= 364 ? yytranslate[x] : 272)\n \n static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n@@ -544,18 +545,18 @@ static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,\n-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,\n-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,\n-    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n-    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n-    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n-    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n-    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n-    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n-    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n-    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,\n-   107,   108,   109\n+     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,\n+     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,\n+    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,\n+    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,\n+    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,\n+    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,\n+    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,\n+    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,\n+    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,\n+    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,\n+    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,\n+   106,   107,   108,   109\n };\n \n #if YYDEBUG != 0\n@@ -2386,8 +2387,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/lib/bison.simple\"\n-/* This file comes from bison-1.28.  */\n+#line 3 \"/usr/share/misc/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2404,66 +2404,46 @@ static const short yycheck[] = {     3,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n    This special exception was added by the Free Software Foundation\n    in version 1.24 of Bison.  */\n \n-/* This is the parser code that is written into each bison parser\n-  when the %semantic_parser declaration is not specified in the grammar.\n-  It was written by Richard Stallman by simplifying the hairy parser\n-  used when %semantic_parser is specified.  */\n-\n-#ifndef YYSTACK_USE_ALLOCA\n-#ifdef alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* alloca not defined */\n+#ifndef alloca\n #ifdef __GNUC__\n-#define YYSTACK_USE_ALLOCA\n #define alloca __builtin_alloca\n #else /* not GNU C.  */\n-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))\n-#define YYSTACK_USE_ALLOCA\n+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)\n #include <alloca.h>\n #else /* not sparc */\n-/* We think this test detects Watcom and Microsoft C.  */\n-/* This used to test MSDOS, but that is a bad idea\n-   since that symbol is in the user namespace.  */\n-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)\n-#if 0 /* No need for malloc.h, which pollutes the namespace;\n-\t instead, just don't use alloca.  */\n+#if defined (MSDOS) && !defined (__TURBOC__)\n #include <malloc.h>\n-#endif\n #else /* not MSDOS, or __TURBOC__ */\n #if defined(_AIX)\n-/* I don't know what this was needed for, but it pollutes the namespace.\n-   So I turned it off.   rms, 2 May 1997.  */\n-/* #include <malloc.h>  */\n+#include <malloc.h>\n  #pragma alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* not MSDOS, or __TURBOC__, or _AIX */\n-#if 0\n-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,\n-\t\t and on HPUX 10.  Eventually we can turn this on.  */\n-#define YYSTACK_USE_ALLOCA\n-#define alloca __builtin_alloca\n+#else /* not MSDOS, __TURBOC__, or _AIX */\n+#ifdef __hpux\n+#ifdef __cplusplus\n+extern \"C\" {\n+void *alloca (unsigned int);\n+};\n+#else /* not __cplusplus */\n+void *alloca ();\n+#endif /* not __cplusplus */\n #endif /* __hpux */\n-#endif\n #endif /* not _AIX */\n #endif /* not MSDOS, or __TURBOC__ */\n-#endif /* not sparc */\n-#endif /* not GNU C */\n-#endif /* alloca not defined */\n-#endif /* YYSTACK_USE_ALLOCA not defined */\n+#endif /* not sparc.  */\n+#endif /* not GNU C.  */\n+#endif /* alloca not defined.  */\n \n-#ifdef YYSTACK_USE_ALLOCA\n-#define YYSTACK_ALLOC alloca\n-#else\n-#define YYSTACK_ALLOC malloc\n-#endif\n+/* This is the parser code that is written into each bison parser\n+  when the %semantic_parser declaration is not specified in the grammar.\n+  It was written by Richard Stallman by simplifying the hairy parser\n+  used when %semantic_parser is specified.  */\n \n /* Note: there must be only one dollar sign in this file.\n    It is replaced by the list of actions, each action\n@@ -2473,8 +2453,8 @@ static const short yycheck[] = {     3,\n #define yyclearin\t(yychar = YYEMPTY)\n #define YYEMPTY\t\t-2\n #define YYEOF\t\t0\n-#define YYACCEPT\tgoto yyacceptlab\n-#define YYABORT \tgoto yyabortlab\n+#define YYACCEPT\treturn(0)\n+#define YYABORT \treturn(1)\n #define YYERROR\t\tgoto yyerrlab1\n /* Like YYERROR except do call yyerror.\n    This remains here temporarily to ease the\n@@ -2555,12 +2535,14 @@ int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n #ifndef YYMAXDEPTH\n #define YYMAXDEPTH 10000\n #endif\n-\f\n-/* Define __yy_memcpy.  Note that the size argument\n-   should be passed with type unsigned int, because that is what the non-GCC\n-   definitions require.  With GCC, __builtin_memcpy takes an arg\n-   of type size_t, but it can handle unsigned int.  */\n \n+/* Prevent warning if -Wstrict-prototypes.  */\n+#ifdef __GNUC__\n+#ifndef YYPARSE_PARAM\n+int yyparse (void);\n+#endif\n+#endif\n+\f\n #if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n #define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n #else\t\t\t\t/* not GNU C or C++ */\n@@ -2572,7 +2554,7 @@ static void\n __yy_memcpy (to, from, count)\n      char *to;\n      char *from;\n-     unsigned int count;\n+     int count;\n {\n   register char *f = from;\n   register char *t = to;\n@@ -2587,10 +2569,10 @@ __yy_memcpy (to, from, count)\n /* This is the most reliable way to avoid incompatibilities\n    in available built-in functions on various systems.  */\n static void\n-__yy_memcpy (char *to, char *from, unsigned int count)\n+__yy_memcpy (char *to, char *from, int count)\n {\n-  register char *t = to;\n   register char *f = from;\n+  register char *t = to;\n   register int i = count;\n \n   while (i-- > 0)\n@@ -2600,7 +2582,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 217 \"/usr/lib/bison.simple\"\n+#line 196 \"/usr/share/misc/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2621,15 +2603,6 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #define YYPARSE_PARAM_DECL\n #endif /* not YYPARSE_PARAM */\n \n-/* Prevent warning if -Wstrict-prototypes.  */\n-#ifdef __GNUC__\n-#ifdef YYPARSE_PARAM\n-int yyparse (void *);\n-#else\n-int yyparse (void);\n-#endif\n-#endif\n-\n int\n yyparse(YYPARSE_PARAM_ARG)\n      YYPARSE_PARAM_DECL\n@@ -2658,7 +2631,6 @@ yyparse(YYPARSE_PARAM_ARG)\n #endif\n \n   int yystacksize = YYINITDEPTH;\n-  int yyfree_stacks = 0;\n \n #ifdef YYPURE\n   int yychar;\n@@ -2743,32 +2715,18 @@ yyparse(YYPARSE_PARAM_ARG)\n       if (yystacksize >= YYMAXDEPTH)\n \t{\n \t  yyerror(\"parser stack overflow\");\n-\t  if (yyfree_stacks)\n-\t    {\n-\t      free (yyss);\n-\t      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-\t      free (yyls);\n-#endif\n-\t    }\n \t  return 2;\n \t}\n       yystacksize *= 2;\n       if (yystacksize > YYMAXDEPTH)\n \tyystacksize = YYMAXDEPTH;\n-#ifndef YYSTACK_USE_ALLOCA\n-      yyfree_stacks = 1;\n-#endif\n-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));\n-      __yy_memcpy ((char *)yyss, (char *)yyss1,\n-\t\t   size * (unsigned int) sizeof (*yyssp));\n-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));\n-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,\n-\t\t   size * (unsigned int) sizeof (*yyvsp));\n+      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));\n+      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));\n+      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));\n+      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));\n #ifdef YYLSP_NEEDED\n-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));\n-      __yy_memcpy ((char *)yyls, (char *)yyls1,\n-\t\t   size * (unsigned int) sizeof (*yylsp));\n+      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));\n+      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));\n #endif\n #endif /* no yyoverflow */\n \n@@ -5020,7 +4978,7 @@ case 503:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 543 \"/usr/lib/bison.simple\"\n+#line 498 \"/usr/share/misc/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -5215,30 +5173,6 @@ case 503:\n \n   yystate = yyn;\n   goto yynewstate;\n-\n- yyacceptlab:\n-  /* YYACCEPT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 0;\n-\n- yyabortlab:\n-  /* YYABORT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 1;\n }\n #line 2546 \"./parse.y\"\n \n@@ -9995,10 +9929,19 @@ java_complete_expand_methods (class_decl)\n   /* First, do the ordinary methods. */\n   for (decl = first_decl; decl; decl = TREE_CHAIN (decl))\n     {\n-      /* Skip abstract or native methods */\n-      if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl)\n+      /* Skip abstract or native methods -- but do handle native\n+ \t methods when generating JNI stubs.  */\n+      if (METHOD_ABSTRACT (decl)\n+ \t  || (! flag_jni && METHOD_NATIVE (decl))\n \t  || DECL_CONSTRUCTOR_P (decl) || DECL_CLINIT_P (decl))\n \tcontinue;\n+\n+      if (METHOD_NATIVE (decl))\n+ \t{\n+ \t  tree body = build_jni_stub (decl);\n+ \t  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (decl)) = body;\n+ \t}\n+\n       java_complete_expand_method (decl);\n     }\n \n@@ -10128,7 +10071,7 @@ java_complete_expand_method (mdecl)\n \t{\n \t  block_body = java_complete_tree (block_body);\n \n-\t  if (!flag_emit_xref)\n+\t  if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n \t    check_for_initialization (block_body);\n \t  ctxp->explicit_constructor_p = 0;\n \t}"}, {"sha": "3f5d7cebf21161c784b95a06b704cc1635042aba", "filename": "gcc/java/parse.y", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7145d9fe6bb782d384cab328c028507b4f8f435a/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=7145d9fe6bb782d384cab328c028507b4f8f435a", "patch": "@@ -7297,10 +7297,19 @@ java_complete_expand_methods (class_decl)\n   /* First, do the ordinary methods. */\n   for (decl = first_decl; decl; decl = TREE_CHAIN (decl))\n     {\n-      /* Skip abstract or native methods */\n-      if (METHOD_ABSTRACT (decl) || METHOD_NATIVE (decl)\n+      /* Skip abstract or native methods -- but do handle native\n+ \t methods when generating JNI stubs.  */\n+      if (METHOD_ABSTRACT (decl)\n+ \t  || (! flag_jni && METHOD_NATIVE (decl))\n \t  || DECL_CONSTRUCTOR_P (decl) || DECL_CLINIT_P (decl))\n \tcontinue;\n+\n+      if (METHOD_NATIVE (decl))\n+ \t{\n+ \t  tree body = build_jni_stub (decl);\n+ \t  BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (decl)) = body;\n+ \t}\n+\n       java_complete_expand_method (decl);\n     }\n \n@@ -7430,7 +7439,7 @@ java_complete_expand_method (mdecl)\n \t{\n \t  block_body = java_complete_tree (block_body);\n \n-\t  if (!flag_emit_xref)\n+\t  if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n \t    check_for_initialization (block_body);\n \t  ctxp->explicit_constructor_p = 0;\n \t}"}]}