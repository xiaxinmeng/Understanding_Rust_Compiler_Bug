{"sha": "811ef5ba910ae7449d73226143271a89d1da6936", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODExZWY1YmE5MTBhZTc0NDlkNzMyMjYxNDMyNzFhODlkMWRhNjkzNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-10-12T10:20:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T10:20:00Z"}, "message": "par-ch13.adb (P_Aspect_Specifications): Fix handling of 'Class aspects\n\n2010-10-12  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch13.adb (P_Aspect_Specifications): Fix handling of 'Class aspects\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Fix bad Sloc on aspects\n\t* sem_prag.adb (Fix_Error): Only change pragma names for pragmas from\n\taspects.\n\t(Check_Optional_Identifier): Handle case of direct arguments\n\t(Chain_PPC): Test for abstract case, giving appropriate messages\n\t* sinfo.ads, sinfo.adb (Class_Present): Allowed on N_Pragma node\n\nFrom-SVN: r165355", "tree": {"sha": "6f7449e9ba90b9416b794aba7df5b126a7544426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f7449e9ba90b9416b794aba7df5b126a7544426"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/811ef5ba910ae7449d73226143271a89d1da6936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/811ef5ba910ae7449d73226143271a89d1da6936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/811ef5ba910ae7449d73226143271a89d1da6936", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/811ef5ba910ae7449d73226143271a89d1da6936/comments", "author": null, "committer": null, "parents": [{"sha": "92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92cbddaa2ae10e2cb208067b0fc2871ab81a62bc"}], "stats": {"total": 148, "additions": 109, "deletions": 39}, "files": [{"sha": "5daf93f4c8cfadb69a14a46a3e8f81a62e04ae77", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=811ef5ba910ae7449d73226143271a89d1da6936", "patch": "@@ -1,3 +1,13 @@\n+2010-10-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch13.adb (P_Aspect_Specifications): Fix handling of 'Class aspects\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Fix bad Sloc on aspects\n+\t* sem_prag.adb (Fix_Error): Only change pragma names for pragmas from\n+\taspects.\n+\t(Check_Optional_Identifier): Handle case of direct arguments\n+\t(Chain_PPC): Test for abstract case, giving appropriate messages\n+\t* sinfo.ads, sinfo.adb (Class_Present): Allowed on N_Pragma node\n+\n 2010-10-12  Robert Dewar  <dewar@adacore.com>\n \n \t* par-endh.adb (Check_End): Don't swallow semicolon or aspects after"}, {"sha": "890a8b4bbfa5a0b6128d81e77d31c89c99bebdee", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=811ef5ba910ae7449d73226143271a89d1da6936", "patch": "@@ -409,10 +409,9 @@ package body Ch13 is\n \n          --  We have an identifier (which should be an aspect identifier)\n \n-         Aspect := Token_Node;\n          A_Id := Get_Aspect_Id (Token_Name);\n          Aspect :=\n-           Make_Aspect_Specification (Sloc (Aspect),\n+           Make_Aspect_Specification (Token_Ptr,\n              Identifier => Token_Node);\n \n          --  No valid aspect identifier present\n@@ -465,6 +464,10 @@ package body Ch13 is\n                      if Token = Tok_Identifier then\n                         Scan; -- past identifier not CLASS\n                      end if;\n+\n+                  else\n+                     Scan; -- past CLASS\n+                     Set_Class_Present (Aspect);\n                   end if;\n                end if;\n             end if;"}, {"sha": "9d15092317e0e8571fbf9128ceeea0f1916db724", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=811ef5ba910ae7449d73226143271a89d1da6936", "patch": "@@ -663,10 +663,11 @@ package body Sem_Ch13 is\n       Aspect := First (L);\n       while Present (Aspect) loop\n          declare\n-            Id   : constant Node_Id   := Identifier (Aspect);\n-            Expr : constant Node_Id   := Expression (Aspect);\n-            Nam  : constant Name_Id   := Chars (Id);\n-            A_Id : constant Aspect_Id := Get_Aspect_Id (Nam);\n+            Loc  : constant Source_Ptr := Sloc (Aspect);\n+            Id   : constant Node_Id    := Identifier (Aspect);\n+            Expr : constant Node_Id    := Expression (Aspect);\n+            Nam  : constant Name_Id    := Chars (Id);\n+            A_Id : constant Aspect_Id  := Get_Aspect_Id (Nam);\n             Anod : Node_Id;\n             T    : Entity_Id;\n \n@@ -728,7 +729,7 @@ package body Sem_Ch13 is\n                   --  Build corresponding pragma node\n \n                   Aitem :=\n-                    Make_Pragma (Sloc (Aspect),\n+                    Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (Ent),\n                       Pragma_Identifier            =>\n                         Make_Identifier (Sloc (Id), Chars (Id)));\n@@ -797,7 +798,7 @@ package body Sem_Ch13 is\n                   --  Construct the attribute definition clause\n \n                   Aitem :=\n-                    Make_Attribute_Definition_Clause (Sloc (Aspect),\n+                    Make_Attribute_Definition_Clause (Loc,\n                       Name       => Ent,\n                       Chars      => Chars (Id),\n                       Expression => Relocate_Node (Expr));\n@@ -823,7 +824,7 @@ package body Sem_Ch13 is\n                   --  Construct the pragma\n \n                   Aitem :=\n-                    Make_Pragma (Sloc (Aspect),\n+                    Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (\n                         New_Occurrence_Of (E, Sloc (Expr)),\n                         Relocate_Node (Expr)),\n@@ -844,54 +845,61 @@ package body Sem_Ch13 is\n                   --  Construct the pragma\n \n                   Aitem :=\n-                    Make_Pragma (Sloc (Aspect),\n+                    Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (\n                         Relocate_Node (Expr),\n                         New_Occurrence_Of (E, Sloc (Expr))),\n                       Pragma_Identifier            =>\n-                         Make_Identifier (Sloc (Id), Chars (Id)));\n+                        Make_Identifier (Sloc (Id), Chars (Id)),\n+                      Class_Present                => Class_Present (Aspect));\n \n                   --  We don't have to play the delay game here, since the only\n                   --  values are check names which don't get analyzed anyway.\n \n                   Delay_Required := False;\n \n-               --  Aspect Post corresponds to pragma Postcondition with single\n+               --  Aspect Pre corresponds to pragma Precondition with single\n                --  argument that is the expression (we never give a message\n-               --  argument. This is inserted right after the declaration,\n+               --  argument). This is inserted right after the declaration,\n                --  to get the required pragma placement.\n \n-               when Aspect_Post =>\n+               when Aspect_Pre =>\n \n                   --  Construct the pragma\n \n                   Aitem :=\n-                    Make_Pragma (Sloc (Expr),\n-                      Pragma_Argument_Associations => New_List (\n-                        Relocate_Node (Expr)),\n+                    Make_Pragma (Loc,\n                       Pragma_Identifier            =>\n-                      Make_Identifier (Sloc (Id), Name_Postcondition));\n+                        Make_Identifier (Sloc (Id), Name_Precondition),\n+                      Class_Present                => Class_Present (Aspect),\n+                      Pragma_Argument_Associations => New_List (\n+                        Make_Pragma_Argument_Association (Sloc (Expr),\n+                          Chars      => Name_Check,\n+                          Expression => Relocate_Node (Expr))));\n \n                   --  We don't have to play the delay game here. The required\n                   --  delay in this case is already implemented by the pragma.\n \n                   Delay_Required := False;\n \n-               --  Aspect Pre corresponds to pragma Precondition with single\n+               --  Aspect Post corresponds to pragma Postcondition with single\n                --  argument that is the expression (we never give a message\n-               --  argument). This is inserted right after the declaration,\n+               --  argument. This is inserted right after the declaration,\n                --  to get the required pragma placement.\n \n-               when Aspect_Pre =>\n+               when Aspect_Post =>\n \n                   --  Construct the pragma\n \n                   Aitem :=\n-                    Make_Pragma (Sloc (Expr),\n-                      Pragma_Argument_Associations => New_List (\n-                        Relocate_Node (Expr)),\n+                    Make_Pragma (Sloc (Aspect),\n                       Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Precondition));\n+                        Make_Identifier (Sloc (Id), Name_Postcondition),\n+                      Class_Present                => Class_Present (Aspect),\n+                      Pragma_Argument_Associations => New_List (\n+                        Make_Pragma_Argument_Association (Sloc (Expr),\n+                          Chars      => Name_Check,\n+                          Expression => Relocate_Node (Expr))));\n \n                   --  We don't have to play the delay game here. The required\n                   --  delay in this case is already implemented by the pragma."}, {"sha": "da5c60117f01ab877af1899b964fb87c382cd359", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=811ef5ba910ae7449d73226143271a89d1da6936", "patch": "@@ -566,9 +566,8 @@ package body Sem_Prag is\n       --  This is called prior to issuing an error message. Msg is a string\n       --  which typically contains the substring pragma. If the current pragma\n       --  comes from an aspect, each such \"pragma\" substring is replaced with\n-      --  the characters \"aspect\", and in addition, if Error_Msg_Name_1 is\n-      --  Name_Precondition (resp Name_Postcondition) it is replaced with\n-      --  Name_Pre (resp Name_Post).\n+      --  the characters \"aspect\", and if Error_Msg_Name_1 is Name_Precondition\n+      --  (resp Name_Postcondition) it is changed to Name_Pre (resp Name_Post).\n \n       procedure Gather_Associations\n         (Names : Name_List;\n@@ -1463,7 +1462,10 @@ package body Sem_Prag is\n \n       procedure Check_Optional_Identifier (Arg : Node_Id; Id : Name_Id) is\n       begin\n-         if Present (Arg) and then Chars (Arg) /= No_Name then\n+         if Present (Arg)\n+           and then Nkind (Arg) = N_Pragma_Argument_Association\n+           and then Chars (Arg) /= No_Name\n+         then\n             if Chars (Arg) /= Id then\n                Error_Msg_Name_1 := Pname;\n                Error_Msg_Name_2 := Id;\n@@ -1499,11 +1501,26 @@ package body Sem_Prag is\n          ---------------\n \n          procedure Chain_PPC (PO : Node_Id) is\n-            S : Node_Id;\n+            S   : Entity_Id;\n+            P   : Node_Id;\n \n          begin\n-            if not Nkind_In (PO, N_Subprogram_Declaration,\n-                                 N_Generic_Subprogram_Declaration)\n+            if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n+               if not From_Aspect_Specification (N) then\n+                  Error_Pragma\n+                    (\"pragma% cannot be applied to abstract subprogram\");\n+\n+               elsif Class_Present (N) then\n+                  Error_Pragma\n+                    (\"aspect `%''Class` not implemented yet\");\n+\n+               else\n+                  Error_Pragma\n+                    (\"aspect % requires ''Class for abstract subprogram\");\n+               end if;\n+\n+            elsif not Nkind_In (PO, N_Subprogram_Declaration,\n+                                    N_Generic_Subprogram_Declaration)\n             then\n                Pragma_Misplaced;\n             end if;\n@@ -1512,6 +1529,35 @@ package body Sem_Prag is\n \n             S := Defining_Unit_Name (Specification (PO));\n \n+            --  Make sure we do not have the case of a pre/postcondition\n+            --  pragma when the corresponding aspect is present. This is\n+            --  never allowed. We allow either pragmas or aspects, not both.\n+\n+            --  We do this by looking at pragmas already chained to the entity\n+            --  since the aspect derived pragma will be put on this list first.\n+\n+            if not From_Aspect_Specification (N) then\n+               P := Spec_PPC_List (S);\n+               while Present (P) loop\n+                  if Pragma_Name (P) = Pragma_Name (N)\n+                    and then From_Aspect_Specification (P)\n+                  then\n+                     Error_Msg_Sloc := Sloc (P);\n+\n+                     if Prag_Id = Pragma_Precondition then\n+                        Error_Msg_Name_2 := Name_Pre;\n+                     else\n+                        Error_Msg_Name_2 := Name_Post;\n+                     end if;\n+\n+                     Error_Pragma\n+                       (\"pragma% not allowed, % aspect given#\");\n+                  end if;\n+\n+                  P := Next_Pragma (P);\n+               end loop;\n+            end if;\n+\n             --  Analyze the pragma unless it appears within a package spec,\n             --  which is the case where we delay the analysis of the PPC until\n             --  the end of the package declarations (for details, see\n@@ -2059,12 +2105,12 @@ package body Sem_Prag is\n                   Msg (J .. J + 5) := \"aspect\";\n                end if;\n             end loop;\n-         end if;\n \n-         if Error_Msg_Name_1 = Name_Precondition then\n-            Error_Msg_Name_1 := Name_Pre;\n-         elsif Error_Msg_Name_1 = Name_Postcondition then\n-            Error_Msg_Name_1 := Name_Post;\n+            if Error_Msg_Name_1 = Name_Precondition then\n+               Error_Msg_Name_1 := Name_Pre;\n+            elsif Error_Msg_Name_1 = Name_Postcondition then\n+               Error_Msg_Name_1 := Name_Post;\n+            end if;\n          end if;\n       end Fix_Error;\n "}, {"sha": "ead2fcb8708faf7ded68cc8758a0c987ae656041", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=811ef5ba910ae7449d73226143271a89d1da6936", "patch": "@@ -412,7 +412,8 @@ package body Sinfo is\n       (N : Node_Id) return Boolean is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification);\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n       return Flag6 (N);\n    end Class_Present;\n \n@@ -3372,7 +3373,8 @@ package body Sinfo is\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Aspect_Specification);\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n       Set_Flag6 (N, Val);\n    end Set_Class_Present;\n "}, {"sha": "a7f4370bd9210919d66fa02e828abdb219b81644", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/811ef5ba910ae7449d73226143271a89d1da6936/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=811ef5ba910ae7449d73226143271a89d1da6936", "patch": "@@ -2028,6 +2028,7 @@ package Sinfo is\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n       --  Aspect_Cancel (Flag11-Sem)\n+      --  Class_Present (Flag6) (set False if not from Aspect with 'Class)\n \n       --  Note: we should have a section on what pragmas are passed on to\n       --  the back end to be processed. This section should note that pragma"}]}