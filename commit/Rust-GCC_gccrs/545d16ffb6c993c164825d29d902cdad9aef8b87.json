{"sha": "545d16ffb6c993c164825d29d902cdad9aef8b87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ1ZDE2ZmZiNmM5OTNjMTY0ODI1ZDI5ZDkwMmNkYWQ5YWVmOGI4Nw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-10-30T14:11:34Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-10-30T14:11:34Z"}, "message": "s390.c (struct machine_function): Use save_return_addr_p as a general flag that the return address register needs...\n\n\t* config/s390/s390.c (struct machine_function): Use save_return_addr_p\n\tas a general flag that the return address register needs to be saved,\n\tnot necessarily because of __builtin_return_addr (0).\n\t(s390_split_branches): Remove TEMP_REG and TEMP_USED arguments,\n\tremove special handling of zSeries machines.\n\t(s390_optimize_prolog): Remove TEMP_USED argument, treat the return\n\tregister as a regular register on zSeries machines.\n\t(s390_reorg): Adjust calls to s390_split_branches and\n\ts390_optimize_prolog.\n\t(s390_frame_info): On zSeries machines, do not assume the return\n\tregister is always used.  Update regs_ever_live with current data\n\tfor the special registers.\n\t(s390_emit_epilogue): Use save_return_addr_p to determine whether\n\tthe return register was saved.\n\t* config/s390/s390.h (CONDITIONAL_REGISTER_USAGE): Do not mark\n\tRETURN_REGNUM fixed on zSeries machines.\n\t(REG_ALLOC_ORDER): Use RETURN_REGNUM last.\n\t* config/s390/s390.md (\"*doloop_si\"): Handle branch overflow\n\tvia ahi-jgne pair on zSeries machines.\n\t(\"*doloop_di\"): Likewise.\n\t(\"*doloop_di_long\"): Remove.\n\nFrom-SVN: r73084", "tree": {"sha": "3daf2dd9d464500d588dd8993bd0f6f793f88b2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3daf2dd9d464500d588dd8993bd0f6f793f88b2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/545d16ffb6c993c164825d29d902cdad9aef8b87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545d16ffb6c993c164825d29d902cdad9aef8b87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/545d16ffb6c993c164825d29d902cdad9aef8b87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/545d16ffb6c993c164825d29d902cdad9aef8b87/comments", "author": null, "committer": null, "parents": [{"sha": "bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bde58e3208a4297b5e9098cd69a5cbc1cbb3efbc"}], "stats": {"total": 229, "additions": 136, "deletions": 93}, "files": [{"sha": "888b36e66af87f13f574ab27a73d3ac99b07f40a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=545d16ffb6c993c164825d29d902cdad9aef8b87", "patch": "@@ -1,3 +1,27 @@\n+2003-10-30  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (struct machine_function): Use save_return_addr_p\n+\tas a general flag that the return address register needs to be saved,\n+\tnot necessarily because of __builtin_return_addr (0).\n+\t(s390_split_branches): Remove TEMP_REG and TEMP_USED arguments,\n+\tremove special handling of zSeries machines.\n+\t(s390_optimize_prolog): Remove TEMP_USED argument, treat the return \n+\tregister as a regular register on zSeries machines.\n+\t(s390_reorg): Adjust calls to s390_split_branches and \n+\ts390_optimize_prolog.\n+\t(s390_frame_info): On zSeries machines, do not assume the return\n+\tregister is always used.  Update regs_ever_live with current data\n+\tfor the special registers.\n+\t(s390_emit_epilogue): Use save_return_addr_p to determine whether\n+\tthe return register was saved.\n+\t* config/s390/s390.h (CONDITIONAL_REGISTER_USAGE): Do not mark\n+\tRETURN_REGNUM fixed on zSeries machines.\n+\t(REG_ALLOC_ORDER): Use RETURN_REGNUM last.\n+\t* config/s390/s390.md (\"*doloop_si\"): Handle branch overflow\n+\tvia ahi-jgne pair on zSeries machines.\n+\t(\"*doloop_di\"): Likewise.\n+\t(\"*doloop_di_long\"): Remove.\n+\n 2003-10-30  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* arm.c (arm_override_options): Revert change of arm_constant_limit"}, {"sha": "67020f040ac1bc62f4a24eb08006ed4c0dba6936", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 101, "deletions": 65, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=545d16ffb6c993c164825d29d902cdad9aef8b87", "patch": "@@ -190,8 +190,7 @@ struct machine_function GTY(())\n   /* Set, if some of the fprs 8-15 need to be saved (64 bit abi).  */\n   int save_fprs_p;\n \n-  /* Set if return address needs to be saved because the current\n-     function uses __builtin_return_addr (0).  */\n+  /* Set if return address needs to be saved.  */\n   bool save_return_addr_p;\n \n   /* Number of first and last gpr to be saved, restored.  */\n@@ -220,12 +219,12 @@ static const char *get_some_local_dynamic_name (void);\n static int get_some_local_dynamic_name_1 (rtx *, void *);\n static int reg_used_in_mem_p (int, rtx);\n static int addr_generation_dependency_p (rtx, rtx);\n-static int s390_split_branches (rtx, bool *);\n+static int s390_split_branches (void);\n static void find_constant_pool_ref (rtx, rtx *);\n static void replace_constant_pool_ref (rtx *, rtx, rtx);\n static rtx find_ltrel_base (rtx);\n static void replace_ltrel_base (rtx *, rtx);\n-static void s390_optimize_prolog (bool, bool);\n+static void s390_optimize_prolog (bool);\n static int find_unused_clobbered_reg (void);\n static void s390_frame_info (void);\n static rtx save_fpr (rtx, int, int);\n@@ -3882,15 +3881,12 @@ s390_sched_reorder2 (FILE *dump ATTRIBUTE_UNUSED,\n \n \n /* Split all branches that exceed the maximum distance.\n-   Returns true if this created a new literal pool entry.\n-\n-   Code generated by this routine is allowed to use\n-   TEMP_REG as temporary scratch register.  If this is\n-   done, TEMP_USED is set to true.  */\n+   Returns true if this created a new literal pool entry.  */\n \n static int\n-s390_split_branches (rtx temp_reg, bool *temp_used)\n+s390_split_branches (void)\n {\n+  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   int new_literal = 0;\n   rtx insn, pat, tmp, target;\n   rtx *label;\n@@ -3928,19 +3924,14 @@ s390_split_branches (rtx temp_reg, bool *temp_used)\n       else\n \tcontinue;\n \n-      if (get_attr_length (insn) <= (TARGET_CPU_ZARCH ? 6 : 4))\n+      if (get_attr_length (insn) <= 4)\n \tcontinue;\n \n-      *temp_used = 1;\n+      /* We are going to use the return register as scratch register,\n+\t make sure it will be saved/restored by the prologue/epilogue.  */\n+      cfun->machine->save_return_addr_p = 1;\n \n-      if (TARGET_CPU_ZARCH)\n-\t{\n-\t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, *label), insn);\n-\t  INSN_ADDRESSES_NEW (tmp, -1);\n-\n-\t  target = temp_reg;\n-\t}\n-      else if (!flag_pic)\n+      if (!flag_pic)\n \t{\n \t  new_literal = 1;\n \t  tmp = force_const_mem (Pmode, *label);\n@@ -5023,30 +5014,20 @@ s390_output_pool_entry (FILE *file, rtx exp, enum machine_mode mode,\n \n /* Rework the prolog/epilog to avoid saving/restoring\n    registers unnecessarily.  BASE_USED specifies whether\n-   the literal pool base register needs to be saved, \n-   TEMP_USED specifies whether the return register needs\n-   to be saved.  */\n+   the literal pool base register needs to be saved.  */\n \n static void\n-s390_optimize_prolog (bool base_used, bool temp_used)\n+s390_optimize_prolog (bool base_used)\n {\n   int save_first, save_last, restore_first, restore_last;\n   int i, j;\n   rtx insn, new_insn, next_insn;\n \n   /* Recompute regs_ever_live data for special registers.  */\n   regs_ever_live[BASE_REGISTER] = base_used;\n-  regs_ever_live[RETURN_REGNUM] = temp_used;\n+  regs_ever_live[RETURN_REGNUM] = cfun->machine->save_return_addr_p;\n   regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n-  /* In non-leaf functions, the prolog/epilog code relies\n-     on RETURN_REGNUM being saved in any case.  We also need\n-     to save the return register if __builtin_return_address (0)\n-     was used in the current function.  */\n-  if (!current_function_is_leaf \n-      || cfun->machine->save_return_addr_p)\n-    regs_ever_live[RETURN_REGNUM] = 1;\n-\n \n   /* Find first and last gpr to be saved.  */\n \n@@ -5093,7 +5074,7 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n   /* If all special registers are in fact used, there's nothing we\n      can do, so no point in walking the insn list.  */\n   if (i <= BASE_REGISTER && j >= BASE_REGISTER\n-      && i <= RETURN_REGNUM && j >= RETURN_REGNUM)\n+      && (TARGET_CPU_ZARCH || (i <= RETURN_REGNUM && j >= RETURN_REGNUM)))\n     return;\n \n \n@@ -5108,10 +5089,9 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n \n       if (GET_CODE (insn) != INSN)\n \tcontinue;\n-      if (GET_CODE (PATTERN (insn)) != PARALLEL)\n-\tcontinue;\n \n-      if (store_multiple_operation (PATTERN (insn), VOIDmode))\n+      if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t  && store_multiple_operation (PATTERN (insn), VOIDmode))\n \t{\n \t  set = XVECEXP (PATTERN (insn), 0, 0);\n \t  first = REGNO (SET_SRC (set));\n@@ -5122,9 +5102,31 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n-\t  if (first > BASE_REGISTER && first > RETURN_REGNUM)\n+\t  if (first > BASE_REGISTER || last < BASE_REGISTER)\n \t    continue;\n-\t  if (last < BASE_REGISTER && last < RETURN_REGNUM)\n+\n+\t  if (save_first != -1)\n+\t    {\n+\t      new_insn = save_gprs (base, off, save_first, save_last);\n+\t      new_insn = emit_insn_before (new_insn, insn);\n+\t      INSN_ADDRESSES_NEW (new_insn, -1);\n+\t    }\n+\n+\t  remove_insn (insn);\n+\t  continue;\n+\t}\n+\n+      if (GET_CODE (PATTERN (insn)) == SET\n+\t  && GET_CODE (SET_SRC (PATTERN (insn))) == REG\n+\t  && REGNO (SET_SRC (PATTERN (insn))) == BASE_REGISTER\n+\t  && GET_CODE (SET_DEST (PATTERN (insn))) == MEM)\n+\t{\n+\t  set = PATTERN (insn);\n+\t  offset = const0_rtx;\n+\t  base = eliminate_constant_term (XEXP (SET_DEST (set), 0), &offset);\n+\t  off = INTVAL (offset) - BASE_REGISTER * UNITS_PER_WORD;\n+\n+\t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n \n \t  if (save_first != -1)\n@@ -5135,9 +5137,11 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n \t    }\n \n \t  remove_insn (insn);\n+\t  continue;\n \t}\n \n-      if (load_multiple_operation (PATTERN (insn), VOIDmode))\n+      if (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t  && load_multiple_operation (PATTERN (insn), VOIDmode))\n \t{\n \t  set = XVECEXP (PATTERN (insn), 0, 0);\n \t  first = REGNO (SET_DEST (set));\n@@ -5148,9 +5152,31 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n \n \t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n-\t  if (first > BASE_REGISTER && first > RETURN_REGNUM)\n+\t  if (first > BASE_REGISTER || last < BASE_REGISTER)\n \t    continue;\n-\t  if (last < BASE_REGISTER && last < RETURN_REGNUM)\n+\n+\t  if (restore_first != -1)\n+\t    {\n+\t      new_insn = restore_gprs (base, off, restore_first, restore_last);\n+\t      new_insn = emit_insn_before (new_insn, insn);\n+\t      INSN_ADDRESSES_NEW (new_insn, -1);\n+\t    }\n+\n+\t  remove_insn (insn);\n+\t  continue;\n+\t}\n+\n+      if (GET_CODE (PATTERN (insn)) == SET\n+\t  && GET_CODE (SET_DEST (PATTERN (insn))) == REG\n+\t  && REGNO (SET_DEST (PATTERN (insn))) == BASE_REGISTER\n+\t  && GET_CODE (SET_SRC (PATTERN (insn))) == MEM)\n+\t{\n+\t  set = PATTERN (insn);\n+\t  offset = const0_rtx;\n+\t  base = eliminate_constant_term (XEXP (SET_SRC (set), 0), &offset);\n+\t  off = INTVAL (offset) - BASE_REGISTER * UNITS_PER_WORD;\n+\n+\t  if (GET_CODE (base) != REG || off < 0)\n \t    continue;\n \n \t  if (restore_first != -1)\n@@ -5161,6 +5187,7 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n \t    }\n \n \t  remove_insn (insn);\n+\t  continue;\n \t}\n     }\n }\n@@ -5170,9 +5197,7 @@ s390_optimize_prolog (bool base_used, bool temp_used)\n static void\n s390_reorg (void)\n {\n-  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n   rtx base_reg = gen_rtx_REG (Pmode, BASE_REGISTER);\n-  bool temp_used = false;\n   bool base_used = false;\n   bool pool_overflow = false;\n \n@@ -5238,8 +5263,9 @@ s390_reorg (void)\n \n       /* Split out-of-range branches.  If this has created new\n \t literal pool entries, cancel current chunk list and\n-\t recompute it.  */\n-      if (s390_split_branches (temp_reg, &temp_used))\n+\t recompute it.  zSeries machines have large branch\n+\t instructions, so we never need to split a branch.  */\n+      if (!TARGET_CPU_ZARCH && s390_split_branches ())\n         {\n           if (pool_overflow)\n             s390_chunkify_cancel (pool);\n@@ -5263,7 +5289,7 @@ s390_reorg (void)\n       break;\n     }\n \n-  s390_optimize_prolog (base_used, temp_used);\n+  s390_optimize_prolog (base_used);\n }\n \n \n@@ -5309,7 +5335,6 @@ find_unused_clobbered_reg (void)\n static void\n s390_frame_info (void)\n {\n-  char gprs_ever_live[16];\n   int i, j;\n   HOST_WIDE_INT fsize = get_frame_size ();\n \n@@ -5336,31 +5361,42 @@ s390_frame_info (void)\n       || current_function_stdarg)\n     cfun->machine->frame_size += STARTING_FRAME_OFFSET;\n \n+  /* If we use the return register, we'll need to make sure\n+     it is going to be saved/restored.  */\n+\n+  if (!current_function_is_leaf\n+      || regs_ever_live[RETURN_REGNUM])\n+    cfun->machine->save_return_addr_p = 1;\n+\n   /* Find first and last gpr to be saved.  Note that at this point,\n-     we assume the return register and the base register always\n-     need to be saved.  This is done because the usage of these\n+     we assume the base register and -on S/390- the return register\n+     always need to be saved.  This is done because the usage of these\n      register might change even after the prolog was emitted.\n      If it turns out later that we really don't need them, the\n      prolog/epilog code is modified again.  */\n \n-  for (i = 0; i < 16; i++)\n-    gprs_ever_live[i] = regs_ever_live[i] && !global_regs[i];\n-\n-  if (flag_pic)\n-    gprs_ever_live[PIC_OFFSET_TABLE_REGNUM] =\n-    regs_ever_live[PIC_OFFSET_TABLE_REGNUM];\n-  gprs_ever_live[BASE_REGISTER] = 1;\n-  gprs_ever_live[RETURN_REGNUM] = 1;\n-  gprs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n+  regs_ever_live[BASE_REGISTER] = 1;\n+  if (!TARGET_CPU_ZARCH || cfun->machine->save_return_addr_p)\n+    regs_ever_live[RETURN_REGNUM] = 1;\n+  regs_ever_live[STACK_POINTER_REGNUM] = cfun->machine->frame_size > 0;\n \n   for (i = 6; i < 16; i++)\n-    if (gprs_ever_live[i])\n-      break;\n+    if (regs_ever_live[i])\n+      if (!global_regs[i]\n+\t  || i == STACK_POINTER_REGNUM\n+          || i == RETURN_REGNUM\n+          || i == BASE_REGISTER\n+          || (flag_pic && i == (int)PIC_OFFSET_TABLE_REGNUM))\n+\tbreak;\n \n   for (j = 15; j > i; j--)\n-    if (gprs_ever_live[j])\n-      break;\n-\n+    if (regs_ever_live[j])\n+      if (!global_regs[j]\n+\t  || j == STACK_POINTER_REGNUM\n+          || j == RETURN_REGNUM\n+          || j == BASE_REGISTER\n+          || (flag_pic && j == (int)PIC_OFFSET_TABLE_REGNUM))\n+\tbreak;\n \n   /* Save / Restore from gpr i to j.  */\n   cfun->machine->first_save_gpr = i;\n@@ -5911,7 +5947,7 @@ s390_emit_epilogue (void)\n       /* Fetch return address from stack before load multiple,\n \t this will do good for scheduling.  */\n \n-      if (!current_function_is_leaf)\n+      if (cfun->machine->save_return_addr_p)\n \t{\n \t  int return_regnum = find_unused_clobbered_reg();\n \t  if (!return_regnum)"}, {"sha": "63fd3eea030faeab430a0f650dd71a43d2f254ef", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=545d16ffb6c993c164825d29d902cdad9aef8b87", "patch": "@@ -313,7 +313,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n    GPRs 6-15 are always call-saved.\n    GPR 12 is fixed if used as GOT pointer.\n    GPR 13 is always fixed (as literal pool pointer).\n-   GPR 14 is always fixed (as return address).\n+   GPR 14 is always fixed on S/390 machines (as return address).\n    GPR 15 is always fixed (as stack pointer).\n    The 'fake' hard registers are call-clobbered and fixed.\n \n@@ -364,6 +364,11 @@ do\t\t\t\t\t\t\t\t\\\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n+    if (TARGET_CPU_ZARCH)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfixed_regs[RETURN_REGNUM] = 0;\t\t\t\t\\\n+\tcall_used_regs[RETURN_REGNUM] = 0;\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n     if (TARGET_64BIT)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n         for (i = 24; i < 32; i++)\t\t\t\t\\\n@@ -378,7 +383,7 @@ do\t\t\t\t\t\t\t\t\\\n \n /* Preferred register allocation order.  */\n #define REG_ALLOC_ORDER                                         \\\n-{  1, 2, 3, 4, 5, 0, 14, 13, 12, 11, 10, 9, 8, 7, 6,            \\\n+{  1, 2, 3, 4, 5, 0, 13, 12, 11, 10, 9, 8, 7, 6, 14,            \\\n    16, 17, 18, 19, 20, 21, 22, 23,                              \\\n    24, 25, 26, 27, 28, 29, 30, 31,                              \\\n    15, 32, 33, 34 }"}, {"sha": "3237f9c50eee41c28aa1f730c0a7c60b1ae7d74a", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/545d16ffb6c993c164825d29d902cdad9aef8b87/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=545d16ffb6c993c164825d29d902cdad9aef8b87", "patch": "@@ -6596,6 +6596,8 @@\n     return \"#\";\n   else if (get_attr_length (insn) == 4)\n     return \"brct\\t%1,%l0\";\n+  else if (TARGET_CPU_ZARCH)\n+    return \"ahi\\t%1,-1\\;jgne\\t%l0\";\n   else\n     abort ();\n }\n@@ -6675,37 +6677,13 @@\n   else if (get_attr_length (insn) == 4)\n     return \"brctg\\t%1,%l0\";\n   else\n-    abort ();\n+    return \"aghi\\t%1,-1\\;jgne\\t%l0\";\n }\n   [(set_attr \"op_type\"  \"RI\")\n    (set_attr \"type\"  \"branch\")\n    (set (attr \"length\")\n         (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-                      (const_int 4) (const_int 12)))])\n-\n-(define_insn \"*doloop_di_long\"\n-  [(set (pc)\n-        (if_then_else\n-          (ne (match_operand:DI 1 \"register_operand\" \"d,d\")\n-              (const_int 1))\n-          (match_operand 0 \"address_operand\" \"U,U\")\n-          (pc)))\n-   (set (match_operand:DI 2 \"register_operand\" \"=1,?*m*d\")\n-        (plus:DI (match_dup 1) (const_int -1)))\n-   (clobber (match_scratch:DI 3 \"=X,&d\"))\n-   (clobber (reg:CC 33))]\n-  \"\"\n-{\n-  if (get_attr_op_type (insn) == OP_TYPE_RRE)\n-    return \"bctgr\\t%1,%0\";\n-  else\n-    return \"bctg\\t%1,%a0\";\n-}\n-  [(set (attr \"op_type\")\n-        (if_then_else (match_operand 0 \"register_operand\" \"\")\n-                      (const_string \"RRE\") (const_string \"RXE\")))\n-   (set_attr \"type\"  \"branch\")\n-   (set_attr \"atype\" \"agen\")])\n+                      (const_int 4) (const_int 10)))])\n \n (define_split\n   [(set (pc)"}]}