{"sha": "994a57cd287e37aaaf909fc1ae671e54b1b360c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0YTU3Y2QyODdlMzdhYWFmOTA5ZmMxYWU2NzFlNTRiMWIzNjBjNA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-17T16:49:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-17T16:49:00Z"}, "message": "builtins.c (expand_builtin_expect): New.\n\n        * builtins.c (expand_builtin_expect): New.\n        (expand_builtin): Call it.\n        * builtins.def (BUILT_IN_EXPECT): New.\n        * c-common.c (c_common_nodes_and_builtins): Declare __builtin_expect.\n        * extend.texi: Document it.\n\n        * predict.c (expected_value_to_br_prob): New.\n        (find_expected_value): New.\n        * basic-block.h (expected_value_to_br_prob): Declare.\n        * toplev.c (rest_of_compilation): Invoke it.\n\n        * rtl.h (NOTE_EXPECTED_VALUE): New.\n        (NOTE_INSN_EXPECTED_VALUE): New.\n        * rtl.c (note_insn_name): Update.\n        * print-rtl.c (print_rtx): Reorg NOTE_LINE_NUMBER special\n        cases; handle NOTE_INSN_EXPECTED_VALUE.\n\nFrom-SVN: r33211", "tree": {"sha": "463f2ea9fd7c3ba92418e1563975dde99f0150de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/463f2ea9fd7c3ba92418e1563975dde99f0150de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/994a57cd287e37aaaf909fc1ae671e54b1b360c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994a57cd287e37aaaf909fc1ae671e54b1b360c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/994a57cd287e37aaaf909fc1ae671e54b1b360c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994a57cd287e37aaaf909fc1ae671e54b1b360c4/comments", "author": null, "committer": null, "parents": [{"sha": "2be5e524b0ce96881e40a84d0355f40edd82e07e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be5e524b0ce96881e40a84d0355f40edd82e07e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be5e524b0ce96881e40a84d0355f40edd82e07e"}], "stats": {"total": 288, "additions": 256, "deletions": 32}, "files": [{"sha": "6366fbc987924ba149a714c6ff227e0d68b86cd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -1,3 +1,22 @@\n+2000-04-17  Richard Henderson  <rth@cygnus.com>\n+\n+\t* builtins.c (expand_builtin_expect): New.\n+\t(expand_builtin): Call it.\n+\t* builtins.def (BUILT_IN_EXPECT): New.\n+\t* c-common.c (c_common_nodes_and_builtins): Declare __builtin_expect.\n+\t* extend.texi: Document it.\n+\n+\t* predict.c (expected_value_to_br_prob): New.\n+\t(find_expected_value): New.\n+\t* basic-block.h (expected_value_to_br_prob): Declare.\n+\t* toplev.c (rest_of_compilation): Invoke it.\n+\n+\t* rtl.h (NOTE_EXPECTED_VALUE): New.\n+\t(NOTE_INSN_EXPECTED_VALUE): New.\n+\t* rtl.c (note_insn_name): Update.\n+\t* print-rtl.c (print_rtx): Reorg NOTE_LINE_NUMBER special\n+\tcases; handle NOTE_INSN_EXPECTED_VALUE.\n+\n 2000-04-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.c (eligible_for_sibcall_delay): Cannot use"}, {"sha": "bd1d2d4a7c2296cf43d9e1f11875f2a7072a6b13", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -449,6 +449,7 @@ extern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n \n /* In predict.c */\n extern void estimate_probability        PARAMS ((struct loops *));\n+extern void expected_value_to_br_prob\tPARAMS ((void));\n \n /* In flow.c */\n extern void reorder_basic_blocks\tPARAMS ((void));"}, {"sha": "7c833e5d8a29906f7f4fa1fb98f1217cff20544b", "filename": "gcc/builtins.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -103,6 +103,7 @@ static rtx expand_builtin_alloca\tPARAMS ((tree, rtx));\n static rtx expand_builtin_ffs\t\tPARAMS ((tree, rtx, rtx));\n static rtx expand_builtin_frame_address\tPARAMS ((tree));\n static tree stabilize_va_list\t\tPARAMS ((tree, int));\n+static rtx expand_builtin_expect\tPARAMS ((tree, rtx));\n \n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n@@ -2306,6 +2307,48 @@ expand_builtin_ffs (arglist, target, subtarget)\n     abort ();\n   return target;\n }\n+\n+/* Expand a call to __builtin_expect.  We return our argument and\n+   emit a NOTE_INSN_EXPECTED_VALUE note.  */\n+\n+static rtx\n+expand_builtin_expect (arglist, target)\n+     tree arglist;\n+     rtx target;\n+{\n+  tree exp, c;\n+  rtx note, rtx_c;\n+\n+  if (arglist == NULL_TREE\n+      || TREE_CHAIN (arglist) == NULL_TREE)\n+    return const0_rtx;\n+  exp = TREE_VALUE (arglist);\n+  c = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  if (TREE_CODE (c) != INTEGER_CST)\n+    {\n+      error (\"second arg to `__builtin_expect' must be a constant\");\n+      c = integer_zero_node;\n+    }\n+\n+  target = expand_expr (exp, target, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Don't bother with expected value notes for integral constants.  */\n+  if (GET_CODE (target) != CONST_INT)\n+    {\n+      /* We do need to force this into a register so that we can be\n+\t moderately sure to be able to correctly interpret the branch\n+\t condition later.  */\n+      target = force_reg (GET_MODE (target), target);\n+  \n+      rtx_c = expand_expr (c, NULL_RTX, GET_MODE (target), EXPAND_NORMAL);\n+\n+      note = emit_note (NULL, NOTE_INSN_EXPECTED_VALUE);\n+      NOTE_EXPECTED_VALUE (note) = gen_rtx_EQ (VOIDmode, target, rtx_c);\n+    }\n+\n+  return target;\n+}\n \f\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n@@ -2581,6 +2624,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n       return expand_builtin_va_end (arglist);\n     case BUILT_IN_VA_COPY:\n       return expand_builtin_va_copy (arglist);\n+    case BUILT_IN_EXPECT:\n+      return expand_builtin_expect (arglist, target);\n \n     default:\t\t\t/* just do library call, if unknown builtin */\n       error (\"built-in function `%s' not currently supported\","}, {"sha": "308257fa85965f3ad51316a602e266fd8ea1f99b", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -79,6 +79,7 @@ DEF_BUILTIN(BUILT_IN_VARARGS_START)\n DEF_BUILTIN(BUILT_IN_STDARG_START)\n DEF_BUILTIN(BUILT_IN_VA_END)\n DEF_BUILTIN(BUILT_IN_VA_COPY)\n+DEF_BUILTIN(BUILT_IN_EXPECT)\n \n   /* C++ extensions */\n DEF_BUILTIN(BUILT_IN_NEW)"}, {"sha": "386721a66d42e619858b6a08214d9982e85874bc", "filename": "gcc/c-common.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -3767,6 +3767,16 @@ c_common_nodes_and_builtins (cplus_mode, no_builtins, no_nonansi_builtins)\n \t\t\t\t\t\t      endlink))),\n \t\t    BUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL_PTR);\n \n+  /* ??? Ought to be `T __builtin_expect(T, T)' for any type T.  */\n+  builtin_function (\"__builtin_expect\",\n+\t\t    build_function_type (long_integer_type_node,\n+\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t    long_integer_type_node,\n+\t\t\t\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\tlong_integer_type_node,\n+\t\t\t\t\t\t\tendlink))),\n+\t\t    BUILT_IN_EXPECT, BUILT_IN_NORMAL, NULL_PTR);\n+\n   /* Currently under experimentation.  */\n   builtin_function (\"__builtin_memcpy\", memcpy_ftype, BUILT_IN_MEMCPY,\n \t\t    BUILT_IN_NORMAL, \"memcpy\");"}, {"sha": "36c451b84851c6d8ea3731116eeb74e19e6c789a", "filename": "gcc/extend.texi", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -3199,7 +3199,9 @@ correspond to the C library functions @code{abort}, @code{abs},\n @code{sinf}, @code{sinl}, @code{sqrt}, @code{sqrtf}, @code{sqrtl},\n @code{strcmp}, @code{strcpy}, and @code{strlen}.\n \n+@table @code\n @findex __builtin_constant_p\n+@item __builtin_constant_p (@var{exp})\n You can use the builtin function @code{__builtin_constant_p} to\n determine if a value is known to be constant at compile-time and hence\n that GNU CC can perform constant-folding on expressions involving that\n@@ -3228,6 +3230,39 @@ or constructor expression (@pxref{Constructors}) and will not return 1\n when you pass a constant numeric value to the inline function unless you\n specify the @samp{-O} option.\n \n+@findex __builtin_expect\n+@item __builtin_expect(@var{exp}, @var{c})\n+You may use @code{__builtin_expect} to provide the compiler with \n+branch prediction information.  In general, you should prefer to\n+use actual profile feedback for this (@samp{-fprofile-arcs}), as\n+programmers are notoriously bad at predicting how their programs\n+actually preform.  However, there are applications in which this\n+data is hard to collect.\n+\n+The return value is the value of @var{exp}, which should be an\n+integral expression.  The value of @var{c} must be a compile-time\n+constant.  The semantics of the builtin are that it is expected\n+that @var{exp} == @var{c}.  For example:\n+\n+@smallexample\n+if (__builtin_expect (x, 0))\n+  foo ();\n+@end smallexample\n+\n+@noindent\n+would indicate that we do not expect to call @code{foo}, since\n+we expect @code{x} to be zero.  Since you are limited to integral\n+expressions for @var{exp}, you should use constructions such as\n+\n+@smallexample\n+if (__builtin_expect (ptr != NULL, 1))\n+  error ();\n+@end smallexample\n+\n+@noindent\n+when testing pointer or floating-point values.\n+@end table\n+\n @node Deprecated Features\n @section Deprecated Features\n "}, {"sha": "767afdcd93e8967c85ad5447e564147888aacc7f", "filename": "gcc/predict.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -180,4 +180,91 @@ estimate_probability (loops_info)\n \t\t\t       REG_NOTES (last_insn));\n     }\n }\n+\f\n+/* __builtin_expect dropped tokens into the insn stream describing\n+   expected values of registers.  Generate branch probabilities \n+   based off these values.  */\n \n+static rtx find_expected_value\t\tPARAMS ((rtx, rtx));\n+\n+void\n+expected_value_to_br_prob ()\n+{\n+  rtx insn, cond, earliest, ev;\n+\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    {\n+      /* Look for simple conditional branches.  */\n+      if (GET_CODE (insn) != JUMP_INSN)\n+\tcontinue;\n+      if (! condjump_p (insn) || simplejump_p (insn))\n+\tcontinue;\n+\n+      /* Collect the branch condition.  Some machines can branch on\n+\t user values directly, others need a compare instruction.  If\n+\t the branch condition involves a MODE_INT register, try that\n+\t expression first.  Otherwise use get_condition.  */\n+      cond = XEXP (SET_SRC (PATTERN (insn)), 0);\n+      if (GET_RTX_CLASS (GET_CODE (cond)) != '<')\n+\tabort ();\n+      if (GET_CODE (XEXP (cond, 0)) == REG\n+\t  && GET_MODE_CLASS (GET_MODE (XEXP (cond, 0))) == MODE_INT\n+\t  && (ev = find_expected_value (cond, insn)) != NULL_RTX)\n+\t;\n+      else if ((cond = get_condition (insn, &earliest)) == NULL_RTX\n+\t       || (ev = find_expected_value (cond, earliest)) == NULL_RTX)\n+\tcontinue;\n+\n+      /* Substitute and simplify.  Given that the expression we're \n+\t building involves two constants, we should wind up with either\n+\t true or false.  */\n+      cond = gen_rtx_fmt_ee (GET_CODE (cond), VOIDmode,\n+\t\t\t     XEXP (ev, 1), XEXP (cond, 1));\n+      cond = simplify_rtx (cond);\n+\n+      /* Turn the condition into a scaled branch probability.  */\n+      if (cond == const0_rtx)\n+\tcond = const1_rtx;\n+      else if (cond == const1_rtx)\n+\tcond = GEN_INT (REG_BR_PROB_BASE - 1);\n+      else\n+\tabort ();\n+      REG_NOTES (insn) = alloc_EXPR_LIST (REG_BR_PROB, cond, REG_NOTES (insn));\n+    }\n+}\n+\n+/* Search backwards for a NOTE_INSN_EXPECTED_VALUE note with a register\n+   that matches the condition.  */\n+\n+static rtx\n+find_expected_value (cond, earliest)\n+     rtx cond, earliest;\n+{\n+  rtx insn, reg = XEXP (cond, 0);\n+  int timeout;\n+\n+  /* The condition should be (op (reg) (const_int)), otherwise we\n+     won't be able to intuit anything about it.  */\n+  if (GET_CODE (reg) != REG\n+      || GET_CODE (XEXP (cond, 1)) != CONST_INT\n+      || GET_MODE_CLASS (GET_MODE (reg)) != MODE_INT)\n+    return NULL_RTX;\n+\n+  /* Assuming the user wrote something like `if (__builtin_expect(...))',\n+     we shouldn't have to search too far.  Also stop if we reach a code\n+     label or if REG is modified.  */\n+  for (insn = earliest, timeout = 10;\n+       insn && timeout > 0;\n+       insn = PREV_INSN (insn), --timeout)\n+    {\n+      if (GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_EXPECTED_VALUE\n+\t  && XEXP (NOTE_EXPECTED_VALUE (insn), 0) == reg)\n+\treturn NOTE_EXPECTED_VALUE (insn);\n+\n+      if (GET_CODE (insn) == CODE_LABEL || reg_set_p (reg, insn))\n+\tbreak;\n+    }\n+\n+  return NULL_RTX;\n+}"}, {"sha": "8b7bebeb6f666d2c4fa9f6923c045f7df2dea085", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 46, "deletions": 30, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -162,55 +162,71 @@ print_rtx (in_rtx)\n       case '0':\n \tif (i == 3 && GET_CODE (in_rtx) == NOTE)\n \t  {\n-\t    if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_BEG\n-\t\t|| NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_EH_REGION_END)\n+\t    switch (NOTE_LINE_NUMBER (in_rtx))\n \t      {\n+\t      case NOTE_INSN_EH_REGION_BEG:\n+\t      case NOTE_INSN_EH_REGION_END:\n \t\tif (flag_dump_unnumbered)\n \t\t  fprintf (outfile, \" #\");\n \t\telse\n \t\t  fprintf (outfile, \" %d\", NOTE_EH_HANDLER (in_rtx));\n \t\tsawclose = 1;\n-\t      }\n-\t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_BEG\n-\t\t     || NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BLOCK_END)\n-\t      {\n+\t\tbreak;\n+\n+\t      case NOTE_INSN_BLOCK_BEG:\n+\t      case NOTE_INSN_BLOCK_END:\n \t\tfprintf (outfile, \" \");\n \t\tif (flag_dump_unnumbered)\n \t\t  fprintf (outfile, \"#\");\n \t\telse\n \t\t  fprintf (outfile, HOST_PTR_PRINTF, \n \t\t\t   (char *) NOTE_BLOCK (in_rtx));\n \t\tsawclose = 1;\n-\t      }\n-\t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_START\n-\t\t     || NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_RANGE_END\n-\t\t     || NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_LIVE)\n-\t      {\n+\t\tbreak;\n+\n+\t      case NOTE_INSN_RANGE_START:\n+\t      case NOTE_INSN_RANGE_END:\n+\t      case NOTE_INSN_LIVE:\n \t\tindent += 2;\n \t\tif (!sawclose)\n \t\t  fprintf (outfile, \" \");\n \t\tprint_rtx (NOTE_RANGE_INFO (in_rtx));\n \t\tindent -= 2;\n-\t      }\n-\t    else if (NOTE_LINE_NUMBER (in_rtx) == NOTE_INSN_BASIC_BLOCK)\n-\t      {\n-\t\tbasic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t\tbreak;\n \n-\t\tif (bb != 0)\n-\t\t  fprintf (outfile, \" [bb %d]\", bb->index);\n-\t      }\n-\t    else\n-\t      {\n-\t\tconst char * const str = X0STR (in_rtx, i);\n-\t\tif (str == 0)\n-\t\t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n-\t\telse\n-\t\t  {\n-\t\t    if (dump_for_graph)\n-\t\t      fprintf (outfile, \" (\\\\\\\"%s\\\\\\\")\", str);\n-\t\t    else\n-\t\t      fprintf (outfile, \" (\\\"%s\\\")\", str);\n-\t\t  }\n+\t      case NOTE_INSN_BASIC_BLOCK:\n+\t\t{\n+\t\t  basic_block bb = NOTE_BASIC_BLOCK (in_rtx);\n+\t\t  if (bb != 0)\n+\t\t    fprintf (outfile, \" [bb %d]\", bb->index);\n+\t\t  break;\n+\t        }\n+\n+\t      case NOTE_INSN_EXPECTED_VALUE:\n+\t\tindent += 2;\n+\t\tif (!sawclose)\n+\t\t  fprintf (outfile, \" \");\n+\t\tprint_rtx (NOTE_EXPECTED_VALUE (in_rtx));\n+\t\tindent -= 2;\n+\t\tbreak;\n+\n+\t      default:\n+\t\t{\n+\t\t  const char * const str = X0STR (in_rtx, i);\n+\n+\t\t  if (NOTE_LINE_NUMBER (in_rtx) < 0)\n+\t\t    ;\n+\t\t  else if (str == 0)\n+\t\t    fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n+\t\t  else\n+\t\t    {\n+\t\t      if (dump_for_graph)\n+\t\t        fprintf (outfile, \" (\\\\\\\"%s\\\\\\\")\", str);\n+\t\t      else\n+\t\t        fprintf (outfile, \" (\\\"%s\\\")\", str);\n+\t\t    }\n+\t\t  break;\n+\t\t}\n \t      }\n \t  }\n \tbreak;"}, {"sha": "80929e5032e7700cbcda442391f7fcf7fc22a3ba", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -247,7 +247,7 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n   \"NOTE_REPEATED_LINE_NUMBER\", \"NOTE_INSN_RANGE_START\",\n   \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\",\n-  \"NOTE_INSN_BASIC_BLOCK\"\n+  \"NOTE_INSN_BASIC_BLOCK\", \"NOTE_INSN_EXPECTED_VALUE\"\n };\n \n const char * const reg_note_name[] ="}, {"sha": "5d86ab747b00eea7527831f7f39210a95f32f0a3", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -577,6 +577,7 @@ extern const char * const reg_note_name[];\n #define NOTE_RANGE_INFO(INSN)  \tXCEXP(INSN, 3, NOTE)\n #define NOTE_LIVE_INFO(INSN)   \tXCEXP(INSN, 3, NOTE)\n #define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF(INSN, 3, NOTE)\n+#define NOTE_EXPECTED_VALUE(INSN) XCEXP(INSN, 3, NOTE)\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n@@ -664,6 +665,10 @@ enum insn_note\n   /* Record the struct for the following basic block.  Uses NOTE_BASIC_BLOCK. */\n   NOTE_INSN_BASIC_BLOCK,\n \n+  /* Record the expected value of a register at a location.  Uses\n+     NOTE_EXPECTED_VALUE; stored as (eq (reg) (const_int)).  */\n+  NOTE_INSN_EXPECTED_VALUE,\n+\n   NOTE_INSN_MAX\n };\n "}, {"sha": "4f9a3851216b36b06eb028946faf379b32172e48", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994a57cd287e37aaaf909fc1ae671e54b1b360c4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=994a57cd287e37aaaf909fc1ae671e54b1b360c4", "patch": "@@ -2893,9 +2893,10 @@ rest_of_compilation (decl)\n \tgoto exit_rest_of_compilation;\n     }\n \n+  init_EXPR_INSN_LIST_cache ();\n+\n   /* We may have potential sibling or tail recursion sites.  Select one\n      (of possibly multiple) methods of performing the call.  */\n-  init_EXPR_INSN_LIST_cache ();\n   if (flag_optimize_sibling_calls)\n     optimize_sibling_and_tail_recursive_calls ();\n   \n@@ -2962,6 +2963,10 @@ rest_of_compilation (decl)\n      of the function.  */\n   TIMEVAR (jump_time,\n \t   {\n+\t     /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n+\t\tbefore jump optimization switches branch directions.  */\n+\t     expected_value_to_br_prob ();\n+\n \t     reg_scan (insns, max_reg_num (), 0);\n \t     jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n \t\t\t    JUMP_AFTER_REGSCAN);"}]}