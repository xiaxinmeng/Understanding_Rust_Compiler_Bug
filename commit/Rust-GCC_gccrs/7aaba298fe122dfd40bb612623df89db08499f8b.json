{"sha": "7aaba298fe122dfd40bb612623df89db08499f8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FhYmEyOThmZTEyMmRmZDQwYmI2MTI2MjNkZjg5ZGIwODQ5OWY4Yg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-01T13:30:34Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-01T13:30:34Z"}, "message": "Add an is_narrower_int_mode helper function\n\nThis patch adds a function for testing whether an arbitrary mode X\nis an integer mode that is narrower than integer mode Y.  This is\nuseful for code like expand_float and expand_fix that could in\nprinciple handle vectors as well as scalars.\n\n2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (is_narrower_int_mode): New function\n\t* optabs.c (expand_float, expand_fix): Use it.\n\t* dwarf2out.c (rotate_loc_descriptor): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254305", "tree": {"sha": "0ae2545c05dfb383c6e30bf2152244a320722bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae2545c05dfb383c6e30bf2152244a320722bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7aaba298fe122dfd40bb612623df89db08499f8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aaba298fe122dfd40bb612623df89db08499f8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aaba298fe122dfd40bb612623df89db08499f8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aaba298fe122dfd40bb612623df89db08499f8b/comments", "author": null, "committer": null, "parents": [{"sha": "b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ad445f853ab7ca0da6216ff1bebfd6f90425f5"}], "stats": {"total": 26, "additions": 22, "deletions": 4}, "files": [{"sha": "b9b5ddd75b3bba0e71ca932869a39f348c89f46e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7aaba298fe122dfd40bb612623df89db08499f8b", "patch": "@@ -1,3 +1,11 @@\n+2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (is_narrower_int_mode): New function\n+\t* optabs.c (expand_float, expand_fix): Use it.\n+\t* dwarf2out.c (rotate_loc_descriptor): Likewise.\n+\n 2017-11-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "734476750e86b13c342ec921f0089a0f4c3e0d70", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=7aaba298fe122dfd40bb612623df89db08499f8b", "patch": "@@ -14547,8 +14547,7 @@ rotate_loc_descriptor (rtx rtl, scalar_int_mode mode,\n   dw_loc_descr_ref op0, op1, ret, mask[2] = { NULL, NULL };\n   int i;\n \n-  if (GET_MODE (rtlop1) != VOIDmode\n-      && GET_MODE_BITSIZE (GET_MODE (rtlop1)) < GET_MODE_BITSIZE (mode))\n+  if (is_narrower_int_mode (GET_MODE (rtlop1), mode))\n     rtlop1 = gen_rtx_ZERO_EXTEND (mode, rtlop1);\n   op0 = mem_loc_descriptor (XEXP (rtl, 0), mode, mem_mode,\n \t\t\t    VAR_INIT_STATUS_INITIALIZED);"}, {"sha": "f53e7b359f75be08ca0d0e6e411397fbdf4de055", "filename": "gcc/machmode.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=7aaba298fe122dfd40bb612623df89db08499f8b", "patch": "@@ -893,6 +893,17 @@ is_complex_float_mode (machine_mode mode, T *cmode)\n   return false;\n }\n \n+/* Return true if MODE is a scalar integer mode with a precision\n+   smaller than LIMIT's precision.  */\n+\n+inline bool\n+is_narrower_int_mode (machine_mode mode, scalar_int_mode limit)\n+{\n+  scalar_int_mode int_mode;\n+  return (is_a <scalar_int_mode> (mode, &int_mode)\n+\t  && GET_MODE_PRECISION (int_mode) < GET_MODE_PRECISION (limit));\n+}\n+\n namespace mode_iterator\n {\n   /* Start mode iterator *ITER at the first mode in class MCLASS, if any.  */"}, {"sha": "8f7089ef0f1308a66edc7e30697765a5c5aaa3d4", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7aaba298fe122dfd40bb612623df89db08499f8b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=7aaba298fe122dfd40bb612623df89db08499f8b", "patch": "@@ -4811,7 +4811,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n       rtx value;\n       convert_optab tab = unsignedp ? ufloat_optab : sfloat_optab;\n \n-      if (GET_MODE_PRECISION (GET_MODE (from)) < GET_MODE_PRECISION (SImode))\n+      if (is_narrower_int_mode (GET_MODE (from), SImode))\n \tfrom = convert_to_mode (SImode, from, unsignedp);\n \n       libfunc = convert_optab_libfunc (tab, GET_MODE (to), GET_MODE (from));\n@@ -4993,7 +4993,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n      that the mode of TO is at least as wide as SImode, since those are the\n      only library calls we know about.  */\n \n-  if (GET_MODE_PRECISION (GET_MODE (to)) < GET_MODE_PRECISION (SImode))\n+  if (is_narrower_int_mode (GET_MODE (to), SImode))\n     {\n       target = gen_reg_rtx (SImode);\n "}]}