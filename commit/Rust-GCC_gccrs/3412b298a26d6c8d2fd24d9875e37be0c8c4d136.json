{"sha": "3412b298a26d6c8d2fd24d9875e37be0c8c4d136", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQxMmIyOThhMjZkNmM4ZDJmZDI0ZDk4NzVlMzdiZTBjOGM0ZDEzNg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-12-31T22:21:06Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-12-31T22:21:06Z"}, "message": "(assign_parms): Emit conversions into a sequence, and\nthen output the sequence after all parameters have been moved.\n\nFrom-SVN: r3025", "tree": {"sha": "7928f4bcd8576f9705f2d7e7f5225b82db691a70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7928f4bcd8576f9705f2d7e7f5225b82db691a70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3412b298a26d6c8d2fd24d9875e37be0c8c4d136", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3412b298a26d6c8d2fd24d9875e37be0c8c4d136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3412b298a26d6c8d2fd24d9875e37be0c8c4d136", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3412b298a26d6c8d2fd24d9875e37be0c8c4d136/comments", "author": null, "committer": null, "parents": [{"sha": "6ffe0821bb193f71b3ef9ba8fa0272c9e61914bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ffe0821bb193f71b3ef9ba8fa0272c9e61914bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ffe0821bb193f71b3ef9ba8fa0272c9e61914bc"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "70e04dfd8e43ba3d774da49862f9849e8c28a7da", "filename": "gcc/function.c", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3412b298a26d6c8d2fd24d9875e37be0c8c4d136/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3412b298a26d6c8d2fd24d9875e37be0c8c4d136/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3412b298a26d6c8d2fd24d9875e37be0c8c4d136", "patch": "@@ -2607,6 +2607,7 @@ assign_parms (fndecl, second_time)\n   tree function_result_decl = 0;\n   int nparmregs = list_length (fnargs) + LAST_VIRTUAL_REGISTER + 1;\n   int varargs_setup = 0;\n+  rtx conversion_insns = 0;\n \n   /* Nonzero if the last arg is named `__builtin_va_alist',\n      which is used on some machines for old-fashioned non-ANSI varargs.h;\n@@ -3050,14 +3051,22 @@ assign_parms (fndecl, second_time)\n \t\t register for a DFmode).  In that case, moves are the only\n \t\t thing valid, so we can't do a convert from there.  This\n \t\t occurs when the calling sequence allow such misaligned\n-\t\t usages.  */\n-\t      if (GET_CODE (entry_parm) == REG\n-\t\t  && REGNO (entry_parm) < FIRST_PSEUDO_REGISTER\n-\t\t  && ! HARD_REGNO_MODE_OK (REGNO (entry_parm),\n-\t\t\t\t\t   GET_MODE (entry_parm)))\n-\t\tconvert_move (parmreg, copy_to_reg (entry_parm), unsignedp);\n-\t      else\n-\t\tconvert_move (parmreg, validize_mem (entry_parm), unsignedp);\n+\t\t usages.\n+\n+\t\t In addition, the conversion may involve a call, which could\n+\t\t clobber parameters which haven't been copied to pseudo\n+\t\t registers yet.  Therefore, we must first copy the parm to\n+\t\t a pseudo reg here, and save the conversion until after all\n+\t\t parameters have been moved.  */\n+\n+\t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n+\n+\t      emit_move_insn (tempreg, validize_mem (entry_parm));\n+\n+\t      push_to_sequence (conversion_insns);\n+\t      convert_move (parmreg, tempreg);\n+\t      conversion_insns = get_insns ();\n+\t      end_sequence ();\n \t    }\n \t  else\n \t    emit_move_insn (parmreg, validize_mem (entry_parm));\n@@ -3122,13 +3131,15 @@ assign_parms (fndecl, second_time)\n \t  if (passed_mode != nominal_mode)\n \t    {\n \t      /* Conversion is required.   */\n-\t      if (GET_CODE (entry_parm) == REG\n-\t\t  && REGNO (entry_parm) < FIRST_PSEUDO_REGISTER\n-\t\t  && ! HARD_REGNO_MODE_OK (REGNO (entry_parm), passed_mode))\n-\t\tentry_parm = copy_to_reg (entry_parm);\n+\t      rtx tempreg = gen_reg_rtx (GET_MODE (entry_parm));\n+\n+\t      emit_move_insn (tempreg, validize_mem (entry_parm));\n \n-\t      entry_parm = convert_to_mode (nominal_mode, entry_parm,\n+\t      push_to_sequence (conversion_insns);\n+\t      entry_parm = convert_to_mode (nominal_mode, tempreg,\n \t\t\t\t\t    TREE_UNSIGNED (TREE_TYPE (parm)));\n+\t      conversion_insns = get_insns ();\n+\t      end_sequence ();\n \t    }\n \n \t  if (entry_parm != stack_parm)\n@@ -3143,8 +3154,17 @@ assign_parms (fndecl, second_time)\n \t\t  MEM_IN_STRUCT_P (stack_parm) = aggregate;\n \t\t}\n \n-\t      emit_move_insn (validize_mem (stack_parm),\n-\t\t\t      validize_mem (entry_parm));\n+\t      if (passed_mode != nominal_mode)\n+\t\t{\n+\t\t  push_to_sequence (conversion_insns);\n+\t\t  emit_move_insn (validize_mem (stack_parm),\n+\t\t\t\t  validize_mem (entry_parm));\n+\t\t  conversion_insns = get_insns ();\n+\t\t  end_sequence ();\n+\t\t}\n+\t      else\n+\t\temit_move_insn (validize_mem (stack_parm),\n+\t\t\t\tvalidize_mem (entry_parm));\n \t    }\n \n \t  DECL_RTL (parm) = stack_parm;\n@@ -3162,6 +3182,10 @@ assign_parms (fndecl, second_time)\n \tRTX_UNCHANGING_P (DECL_RTL (parm)) = 1;\n     }\n \n+  /* Output all parameter conversion instructions (possibly including calls)\n+     now that all parameters have been copied out of hard registers.  */\n+  emit_insns (conversion_insns);\n+\n   max_parm_reg = max_reg_num ();\n   last_parm_insn = get_last_insn ();\n "}]}