{"sha": "c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc1Yzc3OTNmNTg2MmExYThiNWU0YjE2NGYwODAxZGE4NDUyZTdmZA==", "commit": {"author": {"name": "Jeff Sturm", "email": "jsturm@one-point.com", "date": "2003-01-03T23:08:56Z"}, "committer": {"name": "Jeff Sturm", "email": "jsturm@gcc.gnu.org", "date": "2003-01-03T23:08:56Z"}, "message": "ffi.h.in: Add closure defines for SPARC, SPARC64.\n\n* include/ffi.h.in: Add closure defines for SPARC, SPARC64.\n* src/ffitest.c (main): Use static storage for closure.\n* src/sparc/ffi.c (ffi_prep_closure, ffi_closure_sparc_inner): New.\n* src/sparc/v8.S (ffi_closure_v8): New.\n* src/sparc/v9.S (ffi_closure_v9): New.\n\nFrom-SVN: r60857", "tree": {"sha": "5d6ae28f882205c56e8f57b592354a04b05fc737", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d6ae28f882205c56e8f57b592354a04b05fc737"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/comments", "author": null, "committer": null, "parents": [{"sha": "1778c8ff34cd8be9e8d42c5932b9a5f32e487ce2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1778c8ff34cd8be9e8d42c5932b9a5f32e487ce2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1778c8ff34cd8be9e8d42c5932b9a5f32e487ce2"}], "stats": {"total": 335, "additions": 327, "deletions": 8}, "files": [{"sha": "86907524263991fb7bc95d93cf02b1cd104423c7", "filename": "libffi/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "patch": "@@ -1,3 +1,11 @@\n+2003-01-03  Jeff Sturm  <jsturm@one-point.com>\n+\n+\t* include/ffi.h.in: Add closure defines for SPARC, SPARC64.\n+\t* src/ffitest.c (main): Use static storage for closure.\n+\t* src/sparc/ffi.c (ffi_prep_closure, ffi_closure_sparc_inner): New.\n+\t* src/sparc/v8.S (ffi_closure_v8): New.\n+\t* src/sparc/v9.S (ffi_closure_v9): New.\n+\n 2002-11-10  Ranjit Mathew <rmathew@hotmail.com>\n \n \t* include/ffi.h.in: Added FFI_STDCALL ffi_type"}, {"sha": "bc15daace04a8459f83d2fa232b03a07c0f193c5", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------*-C-*-\n-   libffi @VERSION@ - Copyright (c) 1996-2002  Cygnus Solutions\n+   libffi @VERSION@ - Copyright (c) 1996-2003  Cygnus Solutions\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -443,6 +443,18 @@ struct ffi_ia64_trampoline_struct {\n #define FFI_TRAMPOLINE_SIZE 24 /* see struct below */ \n #define FFI_NATIVE_RAW_API 0\n \n+#elif defined(SPARC64)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 24\n+#define FFI_NATIVE_RAW_API 0\n+\n+#elif defined(SPARC)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 16\n+#define FFI_NATIVE_RAW_API 0\n+\n #elif defined(S390)\n \n #define FFI_CLOSURES 1"}, {"sha": "0dd7688dff55ced347b73a00fb264dbc0a18bc50", "filename": "libffi/src/ffitest.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fffitest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fffitest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fffitest.c?ref=c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffitest.c - Copyright (c) 1996, 1997, 1998, 2002  Red Hat, Inc.\n+   ffitest.c - Copyright (c) 1996, 1997, 1998, 2002, 2003  Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -1044,7 +1044,9 @@ int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])\n # if FFI_CLOSURES\n   /* A simple closure test */\n     {\n-      ffi_closure cl;\n+      /* The closure must not be an automatic variable on\n+\t platforms (Solaris) that forbid stack execution by default. */\n+      static ffi_closure cl;\n       ffi_type * cl_arg_types[3];\n \n       cl_arg_types[0] = &ffi_type_sint;"}, {"sha": "573fc84ee5a6ad89ec67e32f2ac9d51ebcad3ce1", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996 Cygnus Solutions\n+   ffi.c - Copyright (c) 1996, 2003 Cygnus Solutions\n    \n    Sparc Foreign Function Interface \n \n@@ -28,6 +28,12 @@\n \n #include <stdlib.h>\n \n+#ifdef SPARC64\n+extern void ffi_closure_v9(void);\n+#else\n+extern void ffi_closure_v8(void);\n+#endif\n+\n /* ffi_prep_args is called by the assembly routine once stack space\n    has been allocated for the function's arguments */\n \n@@ -409,3 +415,101 @@ void ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n     }\n \n }\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t  void *user_data)\n+{\n+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n+  unsigned long fn;\n+  unsigned long ctx = (unsigned long) closure;\n+\n+#ifdef SPARC64\n+  /* Trampoline address is equal to the closure address.  We take advantage\n+     of that to reduce the trampoline size by 8 bytes. */\n+  FFI_ASSERT (cif->abi == FFI_V9);\n+  fn = (unsigned long) ffi_closure_v9;\n+  tramp[0] = 0x83414000;\t/* rd\t%pc, %g1\t*/\n+  tramp[1] = 0xca586010;\t/* ldx\t[%g1+16], %g5\t*/\n+  tramp[2] = 0x81c14000;\t/* jmp\t%g5\t\t*/\n+  tramp[3] = 0x01000000;\t/* nop\t\t\t*/\n+  *((unsigned long *) &tramp[4]) = fn;\n+#else\n+  FFI_ASSERT (cif->abi == FFI_V8);\n+  fn = (unsigned long) ffi_closure_v8;\n+  tramp[0] = 0x03000000 | fn >> 10;\t/* sethi %hi(fn), %g1\t*/\n+  tramp[1] = 0x05000000 | ctx >> 10;\t/* sethi %hi(ctx), %g2\t*/\n+  tramp[2] = 0x81c06000 | (fn & 0x3ff);\t/* jmp   %g1+%lo(fn)\t*/\n+  tramp[3] = 0x8410a000 | (ctx & 0x3ff);/* or    %g2, %lo(ctx)\t*/\n+#endif\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  /* Flush the Icache.  FIXME: alignment isn't certain, assume 8 bytes */\n+#ifdef SPARC64\n+  asm volatile (\"flush\t%0\" : : \"r\" (closure) : \"memory\");\n+  asm volatile (\"flush\t%0\" : : \"r\" (((char *) closure) + 8) : \"memory\");\n+#else\n+  asm volatile (\"iflush\t%0\" : : \"r\" (closure) : \"memory\");\n+  asm volatile (\"iflush\t%0\" : : \"r\" (((char *) closure) + 8) : \"memory\");\n+#endif\n+\n+  return FFI_OK;\n+}\n+\n+int\n+ffi_closure_sparc_inner(ffi_closure *closure,\n+  void *rvalue, unsigned long *gpr, double *fpr)\n+{\n+  ffi_cif *cif;\n+  void **avalue;\n+  ffi_type **arg_types;\n+  int i, avn, argn;\n+\n+  cif = closure->cif;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  argn = 0;\n+\n+  /* Copy the caller's structure return address to that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = (void *) gpr[0];\n+      argn = 1;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+  \n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n+    {\n+      /* Assume big-endian.  FIXME */\n+      argn += ALIGN(arg_types[i]->size, SIZEOF_ARG) / SIZEOF_ARG;\n+\n+#ifdef SPARC64\n+      if (i < 6 && (arg_types[i]->type == FFI_TYPE_FLOAT\n+\t\t || arg_types[i]->type == FFI_TYPE_DOUBLE\n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\t\t || arg_types[i]->type == FFI_TYPE_LONGDOUBLE\n+#endif\n+\t\t))\n+        avalue[i] = ((char *) &fpr[argn]) - arg_types[i]->size;\n+      else\n+#endif\n+        avalue[i] = ((char *) &gpr[argn]) - arg_types[i]->size;\n+      i++;\n+    }\n+\n+  /* Invoke the closure.  */\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_sparc how to perform return type promotions.  */\n+  return cif->rtype->type;\n+}"}, {"sha": "299200a089c0fd1a734386d5fcfa10f1e574260a", "filename": "libffi/src/sparc/v8.S", "status": "modified", "additions": 90, "deletions": 1, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fsparc%2Fv8.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fsparc%2Fv8.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv8.S?ref=c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   v8.S - Copyright (c) 1996, 1997 Cygnus Solutions\n+   v8.S - Copyright (c) 1996, 1997, 2003 Cygnus Solutions\n    \n    Sparc Foreign Function Interface \n \n@@ -94,6 +94,72 @@ longlong:\n .ffi_call_V8_end:\n \t.size\tffi_call_V8,.ffi_call_V8_end-ffi_call_V8\n \n+\n+#define\tSTACKFRAME\t104\t/* 16*4 register window +\n+\t\t\t\t   1*4 struct return +\t\n+\t\t\t\t   6*4 args backing store +\n+\t\t\t\t   3*4 locals */\n+\n+/* ffi_closure_v8(...)\n+\n+   Receives the closure argument in %g2.   */\n+\n+\t.text\n+\t.align 8\n+\t.globl ffi_closure_v8\n+\n+ffi_closure_v8:\n+\t.register\t%g2, #scratch\n+.LLFB2:\n+\tsave\t%sp, -STACKFRAME, %sp\n+.LLCFI1:\n+\n+\t! Store all of the potential argument registers in va_list format.\n+\tst\t%i0, [%fp+68+0]\n+\tst\t%i1, [%fp+68+4]\n+\tst\t%i2, [%fp+68+8]\n+\tst\t%i3, [%fp+68+12]\n+\tst\t%i4, [%fp+68+16]\n+\tst\t%i5, [%fp+68+20]\n+\n+\t! Call ffi_closure_sparc_inner to do the bulk of the work.\n+\tmov\t%g2, %o0\n+\tadd\t%fp, -8, %o1\n+\tadd\t%fp,  68, %o2\n+\tcall\tffi_closure_sparc_inner\n+\t mov\t0, %o3\n+\n+\t! Load up the return value in the proper type.\n+\tcmp\t%o0, FFI_TYPE_VOID\n+\tbe\tdone1\n+\n+\tcmp\t%o0, FFI_TYPE_FLOAT\n+\tbe,a\tdone1\n+\t ld\t[%fp-8], %f0\n+\n+\tcmp\t%o0, FFI_TYPE_DOUBLE\n+\tbe,a\tdone1\n+\t ldd\t[%fp-8], %f0\n+\n+\tcmp\t%o0, FFI_TYPE_SINT64\n+\tbe,a\tinteger\n+\t ld\t[%fp-4], %i1\n+\n+\tcmp\t%o0, FFI_TYPE_UINT64\n+\tbe,a\tinteger\n+\t ld\t[%fp-4], %i1\n+\n+integer:\n+\tld\t[%fp-8], %i0\n+\n+done1:\n+\tret\n+\t restore\n+.LLFE2:\n+\n+.ffi_closure_v8_end:\n+\t.size\tffi_closure_v8,.ffi_closure_v8_end-ffi_closure_v8\n+\n #ifdef SPARC64\n #define WS 8\n #define nword\txword\n@@ -148,3 +214,26 @@ longlong:\n \t.byte\t0x1f\t! uleb128 0x1f\n \t.align\tWS\n .LLEFDE1:\n+.LLSFDE2:\n+\t.uaword\t.LLEFDE2-.LLASFDE2\t! FDE Length\n+.LLASFDE2:\n+\t.uaword\t.LLASFDE2-.LLframe1\t! FDE CIE offset\n+#ifdef HAVE_AS_SPARC_UA_PCREL\n+\t.uaword\t%r_disp32(.LLFB2)\n+\t.uaword\t.LLFE2-.LLFB2\t! FDE address range\n+#else\n+\t.align\tWS\n+\t.nword\t.LLFB2\n+\t.uanword .LLFE2-.LLFB2\t! FDE address range\n+#endif\n+\t.byte\t0x0\t! uleb128 0x0; Augmentation size\n+\t.byte\t0x4\t! DW_CFA_advance_loc4\n+\t.uaword\t.LLCFI1-.LLFB2\n+\t.byte\t0xd\t! DW_CFA_def_cfa_register\n+\t.byte\t0x1e\t! uleb128 0x1e\n+\t.byte\t0x2d\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9\t! DW_CFA_register\n+\t.byte\t0xf\t! uleb128 0xf\n+\t.byte\t0x1f\t! uleb128 0x1f\n+\t.align\tWS\n+.LLEFDE2:"}, {"sha": "8dc9c90f6619a5724b4088acd498d657fd0710ba", "filename": "libffi/src/sparc/v9.S", "status": "modified", "additions": 107, "deletions": 3, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fsparc%2Fv9.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c75c7793f5862a1a8b5e4b164f0801da8452e7fd/libffi%2Fsrc%2Fsparc%2Fv9.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fv9.S?ref=c75c7793f5862a1a8b5e4b164f0801da8452e7fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   v9.S - Copyright (c) 2000 Cygnus Solutions\n+   v9.S - Copyright (c) 2000, 2003 Cygnus Solutions\n    \n    Sparc 64bit Foreign Function Interface \n \n@@ -99,7 +99,7 @@ _ffi_call_V9:\n \tcmp\t%i3, FFI_TYPE_STRUCT\n \tbe,pn\t%icc, dostruct\n \n-\t cmp\t%i3, FFI_TYPE_LONGDOUBLE\n+\tcmp\t%i3, FFI_TYPE_LONGDOUBLE\n \tbne,pt\t%icc, done\n \t nop\n \tstd\t%f0, [%i4+0]\n@@ -125,6 +125,88 @@ dostruct:\n .ffi_call_V9_end:\n \t.size\tffi_call_V9,.ffi_call_V9_end-ffi_call_V9\n \n+\n+#define\tSTACKFRAME\t 240\t/* 16*8 register window +\n+\t\t\t\t   6*8 args backing store +\n+\t\t\t\t   8*8 locals */\n+#define\tFP\t\t%fp+STACK_BIAS\n+\n+/* ffi_closure_v9(...)\n+\n+   Receives the closure argument in %g1.   */\n+\n+\t.text\n+\t.align 8\n+\t.globl ffi_closure_v9\n+\n+ffi_closure_v9:\n+.LLFB2:\n+\tsave\t%sp, -STACKFRAME, %sp\n+.LLCFI1:\n+\n+\t! Store all of the potential argument registers in va_list format.\n+\tstx\t%i0, [FP+128+0]\n+\tstx\t%i1, [FP+128+8]\n+\tstx\t%i2, [FP+128+16]\n+\tstx\t%i3, [FP+128+24]\n+\tstx\t%i4, [FP+128+32]\n+\tstx\t%i5, [FP+128+40]\n+\n+\t! Store possible floating point argument registers too.\n+\tstd\t%f0, [FP-48]\n+\tstd\t%f2, [FP-40]\n+\tstd\t%f4, [FP-32]\n+\tstd\t%f6, [FP-24]\n+\tstd\t%f8, [FP-16]\n+\tstd\t%f10, [FP-8]\n+\n+\t! Call ffi_closure_sparc_inner to do the bulk of the work.\n+\tmov\t%g1, %o0\n+\tadd\t%fp, STACK_BIAS-64, %o1\n+\tadd\t%fp, STACK_BIAS+128, %o2\n+\tcall\tffi_closure_sparc_inner\n+\t add\t%fp, STACK_BIAS-48, %o3\n+\n+\t! Load up the return value in the proper type.\n+\tcmp\t%o0, FFI_TYPE_VOID\n+\tbe,pn\t%icc, done1\n+\n+\tcmp\t%o0, FFI_TYPE_FLOAT\n+\tbe,a,pn\t%icc, done1\n+\t ld\t[FP-64], %f0\n+\n+\tcmp\t%o0, FFI_TYPE_DOUBLE\n+\tbe,a,pn\t%icc, done1\n+\t ldd\t[FP-64], %f0\n+\n+\tcmp\t%o0, FFI_TYPE_LONGDOUBLE\n+\tbe,a,pn\t%icc, longdouble1\n+\t ldd\t[FP-64], %f0\n+\n+\tcmp\t%o0, FFI_TYPE_STRUCT\n+\tbe,pn\t%icc, struct1\n+\n+\t! FFI_TYPE_UINT64 | FFI_TYPE_SINT64 | FFI_TYPE_POINTER\n+\tldx\t[FP-64], %i0\n+\n+done1:\n+\tret\n+\t restore\n+\n+struct1:\n+\tldx [FP-56], %i2\n+\tret\n+\t restore\n+\n+longdouble1:\n+\tldd\t[FP-56], %f2\n+\tret\n+\t restore\n+.LLFE2:\n+\n+.ffi_closure_v9_end:\n+\t.size\tffi_closure_v9,.ffi_closure_v9_end-ffi_closure_v9\n+\n \t.section\t\".eh_frame\",#alloc,#write\n .LLframe1:\n \t.uaword\t.LLECIE1-.LLSCIE1\t! Length of Common Information Entry\n@@ -169,5 +251,27 @@ dostruct:\n \t.byte\t0x1f\t! uleb128 0x1f\n \t.align 8\n .LLEFDE1:\n-\n+.LLSFDE2:\n+\t.uaword\t.LLEFDE2-.LLASFDE2\t! FDE Length\n+.LLASFDE2:\n+\t.uaword\t.LLASFDE2-.LLframe1\t! FDE CIE offset\n+#ifdef HAVE_AS_SPARC_UA_PCREL\n+\t.uaword\t%r_disp32(.LLFB2)\n+\t.uaword\t.LLFE2-.LLFB2\t\t! FDE address range\n+#else\n+\t.align 8\n+\t.xword\t.LLFB2\n+\t.uaxword\t.LLFE2-.LLFB2\t! FDE address range\n+#endif\n+\t.byte\t0x0\t! uleb128 0x0; Augmentation size\n+\t.byte\t0x4\t! DW_CFA_advance_loc4\n+\t.uaword\t.LLCFI1-.LLFB2\n+\t.byte\t0xd\t! DW_CFA_def_cfa_register\n+\t.byte\t0x1e\t! uleb128 0x1e\n+\t.byte\t0x2d\t! DW_CFA_GNU_window_save\n+\t.byte\t0x9\t! DW_CFA_register\n+\t.byte\t0xf\t! uleb128 0xf\n+\t.byte\t0x1f\t! uleb128 0x1f\n+\t.align 8\n+.LLEFDE2:\n #endif"}]}