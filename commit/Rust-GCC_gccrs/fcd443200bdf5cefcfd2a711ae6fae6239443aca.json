{"sha": "fcd443200bdf5cefcfd2a711ae6fae6239443aca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNkNDQzMjAwYmRmNWNlZmNmZDJhNzExYWU2ZmFlNjIzOTQ0M2FjYQ==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-12-17T18:28:07Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-12-17T18:28:07Z"}, "message": "re PR fortran/30207 (ICE in gfc_dep_resolver with where (a < 0) a(:) = 1)\n\n2006-12-17  Roger Sayle  <roger@eyesopen.com>\n\t    Steven G. Kargl  <kargl@gcc.gnu.org>\n\n\tPR fortran/30207\n\t* dependency.c (gfc_full_array_ref_p): New function to test whether\n\tthe given array ref specifies the entire array.\n\t(gfc_dep_resolver): Use gfc_full_array_ref_p to analyze AR_FULL\n\tarray refs against AR_SECTION array refs, and vice versa.\n\t* dependency.h (gfc_full_array_ref_p): Prototype here.\n\t* trans-array.c (gfc_conv_expr_descriptor): Use gfc_full_array_ref_p.\n\n\t* gfortran.fortran-torture/execute/where21.f90: New test.\n\nFrom-SVN: r119990", "tree": {"sha": "e7831650401f70808448a7867424483017c55832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7831650401f70808448a7867424483017c55832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcd443200bdf5cefcfd2a711ae6fae6239443aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcd443200bdf5cefcfd2a711ae6fae6239443aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcd443200bdf5cefcfd2a711ae6fae6239443aca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcd443200bdf5cefcfd2a711ae6fae6239443aca/comments", "author": null, "committer": null, "parents": [{"sha": "2ef73bb4ef051fdcf5e186465fa9bf4f7933f8f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef73bb4ef051fdcf5e186465fa9bf4f7933f8f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef73bb4ef051fdcf5e186465fa9bf4f7933f8f3"}], "stats": {"total": 99, "additions": 79, "deletions": 20}, "files": [{"sha": "a7e26077f85231db37b61e6df61f5331485f84c2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fcd443200bdf5cefcfd2a711ae6fae6239443aca", "patch": "@@ -1,3 +1,13 @@\n+2006-12-17  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR fortran/30207\n+\t* dependency.c (gfc_full_array_ref_p): New function to test whether\n+\tthe given array ref specifies the entire array.\n+\t(gfc_dep_resolver): Use gfc_full_array_ref_p to analyze AR_FULL\n+\tarray refs against AR_SECTION array refs, and vice versa.\n+\t* dependency.h (gfc_full_array_ref_p): Prototype here.\n+\t* trans-array.c (gfc_conv_expr_descriptor): Use gfc_full_array_ref_p.\n+\n 2006-12-16  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* gfortran.texi: Added TeX support for document parts;"}, {"sha": "f9ba4459ffaf3a7258b41d6fff94241cbffddea1", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=fcd443200bdf5cefcfd2a711ae6fae6239443aca", "patch": "@@ -1108,6 +1108,46 @@ gfc_check_element_vs_element (gfc_ref * lref, gfc_ref * rref, int n)\n }\n \n \n+/* Determine if an array ref, usually an array section specifies the\n+   entire array.  */\n+\n+bool\n+gfc_full_array_ref_p (gfc_ref *ref)\n+{\n+  int i;\n+\n+  if (ref->type != REF_ARRAY)\n+    return false;\n+  if (ref->u.ar.type == AR_FULL)\n+    return true;\n+  if (ref->u.ar.type != AR_SECTION)\n+    return false;\n+\n+  for (i = 0; i < ref->u.ar.dimen; i++)\n+    {\n+      /* Check the lower bound.  */\n+      if (ref->u.ar.start[i]\n+\t  && (!ref->u.ar.as\n+\t      || !ref->u.ar.as->lower[i]\n+\t      || gfc_dep_compare_expr (ref->u.ar.start[i],\n+\t\t\t\t       ref->u.ar.as->lower[i])))\n+\treturn false;\n+      /* Check the upper bound.  */\n+      if (ref->u.ar.end[i]\n+\t  && (!ref->u.ar.as\n+\t      || !ref->u.ar.as->upper[i]\n+\t      || gfc_dep_compare_expr (ref->u.ar.end[i],\n+\t\t\t\t       ref->u.ar.as->upper[i])))\n+\treturn false;\n+      /* Check the stride.  */\n+      if (ref->u.ar.stride[i]\n+\t  && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+\n /* Finds if two array references are overlapping or not.\n    Return value\n    \t1 : array references are overlapping.\n@@ -1145,6 +1185,19 @@ gfc_dep_resolver (gfc_ref * lref, gfc_ref * rref)\n \t  return 0;\n \t\n \tcase REF_ARRAY:\n+          if (lref->u.ar.dimen != rref->u.ar.dimen)\n+\t    {\n+\t      if (lref->u.ar.type == AR_FULL)\n+\t\tfin_dep = gfc_full_array_ref_p (rref) ? GFC_DEP_EQUAL\n+\t\t\t\t\t\t      : GFC_DEP_OVERLAP;\n+\t      else if (rref->u.ar.type == AR_FULL)\n+\t\tfin_dep = gfc_full_array_ref_p (lref) ? GFC_DEP_EQUAL\n+\t\t\t\t\t\t      : GFC_DEP_OVERLAP;\n+\t      else\n+                return 1;\n+\t      break;\n+\t    }\n+\n \t  for (n=0; n < lref->u.ar.dimen; n++)\n \t    {\n \t      /* Assume dependency when either of array reference is vector"}, {"sha": "06744fd3613f26f0a0c4e271154499b8d3d5864e", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=fcd443200bdf5cefcfd2a711ae6fae6239443aca", "patch": "@@ -22,6 +22,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n \n bool gfc_ref_needs_temporary_p (gfc_ref *);\n+bool gfc_full_array_ref_p (gfc_ref *);\n gfc_expr *gfc_get_noncopying_intrinsic_argument (gfc_expr *);\n int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n \t\t\t\t gfc_actual_arglist *);"}, {"sha": "23163d5332d75c451b82ade73838a632dfb80974", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fcd443200bdf5cefcfd2a711ae6fae6239443aca", "patch": "@@ -4147,7 +4147,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree start;\n   tree offset;\n   int full;\n-  gfc_ref *ref;\n \n   gcc_assert (ss != gfc_ss_terminator);\n \n@@ -4184,25 +4183,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       else if (se->direct_byref)\n \tfull = 0;\n       else\n-\t{\n-\t  ref = info->ref;\n-\t  gcc_assert (ref->u.ar.type == AR_SECTION);\n-\n-\t  full = 1;\n-\t  for (n = 0; n < ref->u.ar.dimen; n++)\n-\t    {\n-\t      /* Detect passing the full array as a section.  This could do\n-\t         even more checking, but it doesn't seem worth it.  */\n-\t      if (ref->u.ar.start[n]\n-\t\t  || ref->u.ar.end[n]\n-\t\t  || (ref->u.ar.stride[n]\n-\t\t      && !gfc_expr_is_one (ref->u.ar.stride[n], 0)))\n-\t\t{\n-\t\t  full = 0;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n+\tfull = gfc_full_array_ref_p (info->ref);\n \n       if (full)\n \t{"}, {"sha": "ffb2e3a7d76033397b143797e41f9db7c27116bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fcd443200bdf5cefcfd2a711ae6fae6239443aca", "patch": "@@ -1,3 +1,8 @@\n+2006-12-17  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\n+\tPR fortran/30207\n+\t* gfortran.fortran-torture/execute/where21.f90: New test.\n+\n 2006-12-17  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/associated_2.f90: Add test for associated(NULL,NULL)."}, {"sha": "6826b87b688f28cdb550ce46cf0eaf000991fcd8", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/where21.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere21.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcd443200bdf5cefcfd2a711ae6fae6239443aca/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere21.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fwhere21.f90?ref=fcd443200bdf5cefcfd2a711ae6fae6239443aca", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do run }\n+! Test fix for PR fortran/30207.\n+program a\n+  implicit none\n+  integer, parameter :: i(4) = (/ 1, 1, 1, 1 /)\n+  integer :: z(4) = (/ 1, 1, -1, -1 /)\n+  where(z < 0) z(:) = 1\n+  if (any(z /= i)) call abort\n+end program a"}]}