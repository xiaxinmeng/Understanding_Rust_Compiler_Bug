{"sha": "823fbbce5c867613d9a1417d77970ab0ea5f41b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzZmJiY2U1Yzg2NzYxM2Q5YTE0MTdkNzc5NzBhYjBlYTVmNDFiNA==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-04-04T02:48:18Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-04-04T02:48:18Z"}, "message": "pa-linux.h (INCOMING_RETURN_ADDR_RTX): Move.\n\n\t* pa-linux.h (INCOMING_RETURN_ADDR_RTX): Move.\n\t(DWARF_FRAME_RETURN_COLUMN): Move.\n\t(ASM_PREFERRED_EH_DATA_FORMAT): Define.\n\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Define.\n\t* pa.c (except.h, predict.h): Include.\n\t(FRP): Delete.\n\t(store_reg_modify, set_reg_plus_d): Revise prototypes.\n\t(output_ascii): Add cast.\n\t(store_reg_modify): Revise to add frame notes.\n\t(set_reg_plus_d): Likewise.\n\t(compute_frame_size): Include space for eh data registers in frame if\n\tthe current function calls eh_return.\n\t(hppa_expand_prologue):  Ensure register %r2 is saved if the current\n\tfunction calls eh_return.  Save eh data registers if the current\n\tfunction calls eh_return.  Fix code to add frame notes.  Emit\n\tblockage to prevent insns with frame notes being scheduled in the\n\tdelay slot of calls.\n\t(hppa_expand_epilogue): Restore eh data registers and do final stack\n\tadjustment if the current function calls eh_return.  Don't add frame\n\tnotes.\n\t(output_call): Revise for change in length of call insn.  Don't do\n\treturn pointer adjustment for an unconditional jump in the delay slot\n\tof a call when using frame notes.\n\t* pa.h (EH_RETURN_DATA_REGNO): Revise for TARGET_64BIT compatibility.\n\t(EH_RETURN_HANDLER_RTX): Use saved value on stack.\n\t(ARG_POINTER_CFA_OFFSET): Define.\n\t* pa.md (return_external_pic): New pattern.\n\t(prologue): Correct formatting.  Use return_external_pic if current\n\tfunction calls eh_return.\n\t(call_internal_symref, call_value_internal_symref,\n\tsibcall_internal_symref, sibcall_value_internal_symref): Change default\n\tlengths of short, long non-pic, and long pic calls to 8, 68, and 84,\n\trespectively.\n\t(exception_receiver): Use hppa_pic_save_rtx () to restore pic register.\n\n\t* configure.in (\"assembler dwarf2 debug_line support\"): Add hppa*-*-* to\n\tlist of targets to check using \"nop\" insn.\n\t* configure: Rebuilt.\n\nFrom-SVN: r51836", "tree": {"sha": "581f501853359286f80b37739491cd24a96a7357", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/581f501853359286f80b37739491cd24a96a7357"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/823fbbce5c867613d9a1417d77970ab0ea5f41b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823fbbce5c867613d9a1417d77970ab0ea5f41b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/823fbbce5c867613d9a1417d77970ab0ea5f41b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823fbbce5c867613d9a1417d77970ab0ea5f41b4/comments", "author": null, "committer": null, "parents": [{"sha": "4078e2240c57c6d1ad5737de12b724f90d79a612", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4078e2240c57c6d1ad5737de12b724f90d79a612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4078e2240c57c6d1ad5737de12b724f90d79a612"}], "stats": {"total": 611, "additions": 428, "deletions": 183}, "files": [{"sha": "7446680e97c37032a52cc92a301aa68f725c3bc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -1,3 +1,44 @@\n+2002-04-03  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* pa-linux.h (INCOMING_RETURN_ADDR_RTX): Move.\n+\t(DWARF_FRAME_RETURN_COLUMN): Move.\n+\t(ASM_PREFERRED_EH_DATA_FORMAT): Define.\n+\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Define.\n+\t* pa.c (except.h, predict.h): Include.\n+\t(FRP): Delete.\n+\t(store_reg_modify, set_reg_plus_d): Revise prototypes.\n+\t(output_ascii): Add cast.\n+\t(store_reg_modify): Revise to add frame notes.\n+\t(set_reg_plus_d): Likewise.\n+\t(compute_frame_size): Include space for eh data registers in frame if\n+\tthe current function calls eh_return.\n+\t(hppa_expand_prologue):  Ensure register %r2 is saved if the current\n+\tfunction calls eh_return.  Save eh data registers if the current\n+\tfunction calls eh_return.  Fix code to add frame notes.  Emit\n+\tblockage to prevent insns with frame notes being scheduled in the\n+\tdelay slot of calls.\n+\t(hppa_expand_epilogue): Restore eh data registers and do final stack\n+\tadjustment if the current function calls eh_return.  Don't add frame\n+\tnotes.\n+\t(output_call): Revise for change in length of call insn.  Don't do\n+\treturn pointer adjustment for an unconditional jump in the delay slot\n+\tof a call when using frame notes.\n+\t* pa.h (EH_RETURN_DATA_REGNO): Revise for TARGET_64BIT compatibility.\n+\t(EH_RETURN_HANDLER_RTX): Use saved value on stack.\n+\t(ARG_POINTER_CFA_OFFSET): Define.\n+\t* pa.md (return_external_pic): New pattern.\n+\t(prologue): Correct formatting.  Use return_external_pic if current\n+\tfunction calls eh_return.\n+\t(call_internal_symref, call_value_internal_symref,\n+\tsibcall_internal_symref, sibcall_value_internal_symref): Change default\n+\tlengths of short, long non-pic, and long pic calls to 8, 68, and 84,\n+\trespectively.\n+\t(exception_receiver): Use hppa_pic_save_rtx () to restore pic register.\n+\n+\t* configure.in (\"assembler dwarf2 debug_line support\"): Add hppa*-*-* to\n+\tlist of targets to check using \"nop\" insn.\n+\t* configure: Rebuilt.\n+\n 2002-04-04  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/t-linux64 (EXTRA_MULTILIB_PARTS): Define."}, {"sha": "16599ef171a2e250fced0d5c2bf49ca5eb70d774", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -24,6 +24,39 @@ Boston, MA 02111-1307, USA.  */\n #define DWARF2_ASM_LINE_DEBUG_INFO 1\n #define DWARF2_UNWIND_INFO 1\n \n+/* A C expression whose value is RTL representing the location of the\n+   incoming return address at the beginning of any function, before the\n+   prologue.  You only need to define this macro if you want to support\n+   call frame debugging information like that provided by DWARF 2.  */\n+#define INCOMING_RETURN_ADDR_RTX (gen_rtx_REG (word_mode, 2))\n+#define DWARF_FRAME_RETURN_COLUMN (DWARF_FRAME_REGNUM (2))\n+\n+/* This macro chooses the encoding of pointers embedded in the exception\n+   handling sections.  If at all possible, this should be defined such\n+   that the exception handling section will not require dynamic relocations,\n+   and so may be read-only.\n+\n+   FIXME: We use DW_EH_PE_aligned to output a PLABEL constructor for\n+   global function pointers.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)\t\t\t\\\n+  (CODE == 2 && GLOBAL ? DW_EH_PE_aligned : DW_EH_PE_absptr)\n+\n+/* Handle special EH pointer encodings.  Absolute, pc-relative, and\n+   indirect are handled automatically.  Since pc-relative encoding is\n+   not possible on the PA and we don't have the infrastructure for\n+   data relative encoding, we use aligned plabels for global function\n+   pointers.  */\n+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(FILE, ENCODING, SIZE, ADDR, DONE) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (((ENCODING) & 0x0F) == DW_EH_PE_aligned)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfputs (integer_asm_op (SIZE, FALSE), FILE);\t\t\t\\\n+\tfputs (\"P%\", FILE);\t\t\t\t\t\t\\\n+\tassemble_name (FILE, XSTR (ADDR, 0));\t\t\t\t\\\n+\tgoto DONE;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    } while (0)\n+\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-D__ELF__ -Dunix -D__hppa__ -Dlinux -Asystem=unix -Asystem=posix -Acpu=hppa -Amachine=hppa -Amachine=bigendian\"\n \n@@ -64,12 +97,6 @@ Boston, MA 02111-1307, USA.  */\n   else\t\t\t\t\t\t\t\\\n     readonly_data_section ();\n \n-/* A C expression whose value is RTL representing the location of the\n-   incoming return address at the beginning of any function, before the\n-   prologue.  */\n-#define INCOMING_RETURN_ADDR_RTX  (gen_rtx_REG (word_mode, 2))\n-#define DWARF_FRAME_RETURN_COLUMN (DWARF_FRAME_REGNUM (2))\n-\n /* Define the strings used for the special svr4 .type and .size directives.\n    These strings generally do not vary from one system running svr4 to\n    another, but if a given system (e.g. m88k running svr) needs to use"}, {"sha": "7890958fb91c6d46f3ef45829e143e81eeea1235", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 268, "deletions": 127, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"tree.h\"\n+#include \"except.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"libfuncs.h\"\n@@ -43,6 +44,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"ggc.h\"\n #include \"recog.h\"\n+#include \"predict.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -55,18 +57,6 @@ Boston, MA 02111-1307, USA.  */\n #endif\n #endif\n \n-#if DO_FRAME_NOTES\n-#define FRP(INSN) \\\n-  do\t\t\t\t\t\\\n-    {\t\t\t\t\t\\\n-      rtx insn = INSN;\t\t\t\\\n-      RTX_FRAME_RELATED_P (insn) = 1;\t\\\n-    }\t\t\t\t\t\\\n-  while (0)\n-#else\n-#define FRP(INSN) INSN\n-#endif\n-\n #ifndef FUNC_BEGIN_PROLOG_LABEL\n #define FUNC_BEGIN_PROLOG_LABEL        \"LFBP\"\n #endif\n@@ -83,8 +73,9 @@ static int compute_movstrsi_length PARAMS ((rtx));\n static bool pa_assemble_integer PARAMS ((rtx, unsigned int, int));\n static void remove_useless_addtr_insns PARAMS ((rtx, int));\n static void store_reg PARAMS ((int, int, int));\n+static void store_reg_modify PARAMS ((int, int, int));\n static void load_reg PARAMS ((int, int, int));\n-static void set_reg_plus_d PARAMS ((int, int, int));\n+static void set_reg_plus_d PARAMS ((int, int, int, int));\n static void pa_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static int pa_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n static int pa_adjust_priority PARAMS ((rtx, int));\n@@ -2662,7 +2653,7 @@ output_ascii (file, p, size)\n \t  fputs (\"\\\"\\n\\t.STRING \\\"\", file);\n \t  chars_output = 0;\n \t}\n-      fwrite (partial_output, 1, co, file);\n+      fwrite (partial_output, 1, (size_t) co, file);\n       chars_output += co;\n       co = 0;\n     }\n@@ -2933,15 +2924,60 @@ store_reg (reg, disp, base)\n     RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n-/* Emit RTL to set REG to the value specified by BASE+DISP.\n-   Handle case where DISP > 8k by using the add_high_const patterns.\n+/* Emit RTL to store REG at the memory location specified by BASE and then\n+   add MOD to BASE.  MOD must be <= 8k.  */\n \n-   Note in DISP > 8k case, we will leave the high part of the address\n-   in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n+static void\n+store_reg_modify (base, reg, mod)\n+     int base, reg, mod;\n+{\n+  rtx insn, basereg, srcreg, delta;\n+\n+  if (! VAL_14_BITS_P (mod))\n+    abort ();\n+\n+  basereg = gen_rtx_REG (Pmode, base);\n+  srcreg = gen_rtx_REG (word_mode, reg);\n+  delta = GEN_INT (mod);\n+\n+  insn = emit_insn (gen_post_store (basereg, srcreg, delta));\n+  if (DO_FRAME_NOTES)\n+    {\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* RTX_FRAME_RELATED_P must be set on each frame related set\n+\t in a parallel with more than one element.  Don't set\n+\t RTX_FRAME_RELATED_P in the first set if reg is temporary\n+\t register 1. The effect of this operation is recorded in\n+\t the initial copy.  */\n+      if (reg != 1)\n+\t{\n+\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 0)) = 1;\n+\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t}\n+      else\n+\t{\n+\t  /* The first element of a PARALLEL is always processed if it is\n+\t     a SET.  Thus, we need an expression list for this case.  */\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode, basereg,\n+\t\t\t     gen_rtx_PLUS (word_mode, basereg, delta)),\n+                REG_NOTES (insn));\n+\t}\n+    }\n+}\n+\n+/* Emit RTL to set REG to the value specified by BASE+DISP.  Handle case\n+   where DISP > 8k by using the add_high_const patterns.  NOTE indicates\n+   whether to add a frame note or not.\n+\n+   In the DISP > 8k case, we leave the high part of the address in %r1.\n+   There is code in expand_hppa_{prologue,epilogue} that knows about this.  */\n \n static void\n-set_reg_plus_d (reg, base, disp)\n-     int reg, base, disp;\n+set_reg_plus_d (reg, base, disp, note)\n+     int reg, base, disp, note;\n {\n   rtx insn;\n \n@@ -2963,7 +2999,7 @@ set_reg_plus_d (reg, base, disp)\n \t\t\t\t\t     delta));\n     }\n \n-  if (DO_FRAME_NOTES && reg == STACK_POINTER_REGNUM)\n+  if (DO_FRAME_NOTES && note)\n     RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n@@ -2981,6 +3017,18 @@ compute_frame_size (size, fregs_live)\n      of them at the same time.  */\n   fsize = size + (size || frame_pointer_needed ? STARTING_FRAME_OFFSET : 0);\n \n+  /* If the current function calls __builtin_eh_return, then we need\n+     to allocate stack space for registers that will hold data for\n+     the exception handler.  */\n+  if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+    {\n+      unsigned int i;\n+\n+      for (i = 0; EH_RETURN_DATA_REGNO (i) != INVALID_REGNUM; ++i)\n+\tcontinue;\n+      fsize += i * UNITS_PER_WORD;\n+    }\n+\n   /* Account for space used by the callee general register saves.  */\n   for (i = 18; i >= 3; i--)\n     if (regs_ever_live[i])\n@@ -3108,7 +3156,7 @@ hppa_expand_prologue ()\n   int size = get_frame_size ();\n   int merge_sp_adjust_with_store = 0;\n   int i, offset;\n-  rtx tmpreg, size_rtx;\n+  rtx insn, tmpreg;\n \n   gr_saved = 0;\n   fr_saved = 0;\n@@ -3126,12 +3174,11 @@ hppa_expand_prologue ()\n \n   /* Compute a few things we will use often.  */\n   tmpreg = gen_rtx_REG (word_mode, 1);\n-  size_rtx = GEN_INT (actual_fsize);\n \n   /* Save RP first.  The calling conventions manual states RP will\n      always be stored into the caller's frame at sp - 20 or sp - 16\n      depending on which ABI is in use.  */\n-  if (regs_ever_live[2])\n+  if (regs_ever_live[2] || current_function_calls_eh_return)\n     store_reg (2, TARGET_64BIT ? -16 : -20, STACK_POINTER_REGNUM);\n \n   /* Allocate the local frame and set up the frame pointer if needed.  */\n@@ -3141,36 +3188,30 @@ hppa_expand_prologue ()\n \t{\n \t  /* Copy the old frame pointer temporarily into %r1.  Set up the\n \t     new stack pointer, then store away the saved old frame pointer\n-\t     into the stack at sp+actual_fsize and at the same time update\n-\t     the stack pointer by actual_fsize bytes.  Two versions, first\n+\t     into the stack at sp and at the same time update the stack\n+\t     pointer by actual_fsize bytes.  Two versions, first\n \t     handles small (<8k) frames.  The second handles large (>=8k)\n \t     frames.  */\n-\t  emit_move_insn (tmpreg, frame_pointer_rtx);\n-\t  FRP (emit_move_insn (frame_pointer_rtx, stack_pointer_rtx));\n-\t  if (VAL_14_BITS_P (actual_fsize))\n+\t  insn = emit_move_insn (tmpreg, frame_pointer_rtx);\n+\t  if (DO_FRAME_NOTES)\n \t    {\n-\t      rtx insn = emit_insn (gen_post_store (stack_pointer_rtx, tmpreg,\n-\t\t\t\t\t\t    size_rtx));\n-\t      if (DO_FRAME_NOTES)\n-\t\t{\n-\t\t  rtvec vec;\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  vec = gen_rtvec (2,\n-\t\t\t\t   gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t\tgen_rtx_MEM (word_mode,\n-\t\t\t\t\t\t\t     stack_pointer_rtx),\n-\t\t\t\t\t\tframe_pointer_rtx),\n-\t\t\t\t   gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\tgen_rtx_PLUS (word_mode,\n-\t\t\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t\t\t      size_rtx)));\n-\t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t gen_rtx_SEQUENCE (VOIDmode, vec),\n-\t\t\t\t\t REG_NOTES (insn));\n-\t\t}\n+\t      /* We need to record the frame pointer save here since the\n+\t         new frame pointer is set in the following insn.  */\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      REG_NOTES (insn)\n+\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t    gen_rtx_SET (VOIDmode,\n+\t\t\t\t gen_rtx_MEM (word_mode, stack_pointer_rtx),\n+\t\t\t         frame_pointer_rtx),\n+\t\t    REG_NOTES (insn));\n \t    }\n+\n+\t  insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\t  if (DO_FRAME_NOTES)\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\n+\t  if (VAL_14_BITS_P (actual_fsize))\n+\t    store_reg_modify (STACK_POINTER_REGNUM, 1, actual_fsize);\n \t  else\n \t    {\n \t      /* It is incorrect to store the saved frame pointer at *sp,\n@@ -3181,32 +3222,12 @@ hppa_expand_prologue ()\n \t\t finish allocating the new frame.  */\n \t      int adjust1 = 8192 - 64;\n \t      int adjust2 = actual_fsize - adjust1;\n-\t      rtx delta = GEN_INT (adjust1);\n-\t      rtx insn = emit_insn (gen_post_store (stack_pointer_rtx, tmpreg,\n-\t\t\t\t\t\t    delta));\n-\t      if (DO_FRAME_NOTES)\n-\t\t{\n-\t\t  rtvec vec;\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  vec = gen_rtvec (2,\n-\t\t\t\t   gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t\tgen_rtx_MEM (word_mode,\n-\t\t\t\t\t\t\t     stack_pointer_rtx),\n-\t\t\t\t\t\tframe_pointer_rtx),\n-\t\t\t\t   gen_rtx_SET (VOIDmode,\n-\t\t\t\t\t\tstack_pointer_rtx,\n-\t\t\t\t\t\tgen_rtx_PLUS (word_mode,\n-\t\t\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t\t\t      delta)));\n-\t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\t\t\t gen_rtx_SEQUENCE (VOIDmode, vec),\n-\t\t\t\t\t REG_NOTES (insn));\n-\t\t}\n \n+\t      store_reg_modify (STACK_POINTER_REGNUM, 1, adjust1);\n \t      set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n-\t\t\t      adjust2);\n+\t\t\t      adjust2, 1);\n \t    }\n+\n \t  /* Prevent register spills from being scheduled before the\n \t     stack pointer is raised.  Necessary as we will be storing\n \t     registers using the frame pointer as a base register, and\n@@ -3226,7 +3247,7 @@ hppa_expand_prologue ()\n \t     bytes.  */\n \t  else\n \t    set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n-\t\t\t    actual_fsize);\n+\t\t\t    actual_fsize, 1);\n \t}\n     }\n \n@@ -3236,7 +3257,27 @@ hppa_expand_prologue ()\n      was done earlier.  */\n   if (frame_pointer_needed)\n     {\n-      for (i = 18, offset = local_fsize; i >= 4; i--)\n+      offset = local_fsize;\n+\n+      /* Saving the EH return data registers in the frame is the simplest\n+\t way to get the frame unwind information emitted.  We put them\n+\t just before the general registers.  */\n+      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+\t{\n+\t  unsigned int i, regno;\n+\n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\n+\t      store_reg (regno, offset, FRAME_POINTER_REGNUM);\n+\t      offset += UNITS_PER_WORD;\n+\t    }\n+\t}\n+\n+      for (i = 18; i >= 4; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n@@ -3249,18 +3290,42 @@ hppa_expand_prologue ()\n   /* No frame pointer needed.  */\n   else\n     {\n-      for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n+      offset = local_fsize - actual_fsize;\n+\n+      /* Saving the EH return data registers in the frame is the simplest\n+         way to get the frame unwind information emitted.  */\n+      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+\t{\n+\t  unsigned int i, regno;\n+\n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\n+\t      /* If merge_sp_adjust_with_store is nonzero, then we can\n+\t\t optimize the first save.  */\n+\t      if (merge_sp_adjust_with_store)\n+\t\t{\n+\t\t  store_reg_modify (STACK_POINTER_REGNUM, regno, -offset);\n+\t\t  merge_sp_adjust_with_store = 0;\n+\t\t}\n+\t      else\n+\t\tstore_reg (regno, offset, STACK_POINTER_REGNUM);\n+\t      offset += UNITS_PER_WORD;\n+\t    }\n+\t}\n+\n+      for (i = 18; i >= 3; i--)\n       \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    /* If merge_sp_adjust_with_store is nonzero, then we can\n \t       optimize the first GR save.  */\n \t    if (merge_sp_adjust_with_store)\n \t      {\n-\t\trtx delta = GEN_INT (-offset);\n+\t\tstore_reg_modify (STACK_POINTER_REGNUM, i, -offset);\n \t\tmerge_sp_adjust_with_store = 0;\n-\t        FRP (emit_insn (gen_post_store (stack_pointer_rtx,\n-\t\t\t\t\t\tgen_rtx_REG (word_mode, i),\n-\t\t\t\t\t\tdelta)));\n \t      }\n \t    else\n \t      store_reg (i, offset, STACK_POINTER_REGNUM);\n@@ -3272,7 +3337,7 @@ hppa_expand_prologue ()\n \t did any GR saves, then just emit the adjustment here.  */\n       if (merge_sp_adjust_with_store)\n \tset_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n-\t\t\tactual_fsize);\n+\t\t\tactual_fsize, 1);\n     }\n \n   /* The hppa calling conventions say that %r19, the pic offset\n@@ -3290,12 +3355,20 @@ hppa_expand_prologue ()\n   /* Floating point register store.  */\n   if (save_fregs)\n     {\n+      rtx base;\n+\n       /* First get the frame or stack pointer to the start of the FP register\n \t save area.  */\n       if (frame_pointer_needed)\n-\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n+\t{\n+\t  set_reg_plus_d (1, FRAME_POINTER_REGNUM, offset, 0);\n+\t  base = frame_pointer_rtx;\n+\t}\n       else\n-\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n+\t{\n+\t  set_reg_plus_d (1, STACK_POINTER_REGNUM, offset, 0);\n+\t  base = stack_pointer_rtx;\n+\t}\n \n       /* Now actually save the FP registers.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n@@ -3310,20 +3383,49 @@ hppa_expand_prologue ()\n \t      if (DO_FRAME_NOTES)\n \t\t{\n \t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t  gen_rtx_MEM (DFmode,\n-\t\t\t\t       plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t      offset)),\n-\t\t\t  reg),\n-\t\t\tREG_NOTES (insn));\n+\t\t  if (TARGET_64BIT)\n+\t\t    {\n+\t\t      rtx mem = gen_rtx_MEM (DFmode,\n+\t\t\t\t\t     plus_constant (base, offset));\n+\t\t      REG_NOTES (insn)\n+\t\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t     gen_rtx_SET (VOIDmode, mem, reg),\n+\t\t\t\t\t     REG_NOTES (insn));\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      rtx meml = gen_rtx_MEM (SFmode,\n+\t\t\t\t\t      plus_constant (base, offset));\n+\t\t      rtx memr = gen_rtx_MEM (SFmode,\n+\t\t\t\t\t      plus_constant (base, offset + 4));\n+\t\t      rtx regl = gen_rtx_REG (SFmode, i);\n+\t\t      rtx regr = gen_rtx_REG (SFmode, i + 1);\n+\t\t      rtx setl = gen_rtx_SET (VOIDmode, meml, regl);\n+\t\t      rtx setr = gen_rtx_SET (VOIDmode, memr, regr);\n+\t\t      rtvec vec;\n+\n+\t\t      RTX_FRAME_RELATED_P (setl) = 1;\n+\t\t      RTX_FRAME_RELATED_P (setr) = 1;\n+\t\t      vec = gen_rtvec (2, setl, setr);\n+\t\t      REG_NOTES (insn)\n+\t\t\t= gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\t\t\t\t     gen_rtx_SEQUENCE (VOIDmode, vec),\n+\t\t\t\t\t     REG_NOTES (insn));\n+\t\t    }\n \t\t}\n \t      offset += GET_MODE_SIZE (DFmode);\n \t      fr_saved++;\n \t    }\n \t}\n     }\n+\n+  /* FIXME: expand_call and expand_millicode_call need to be fixed to\n+     prevent insns with frame notes being scheduled in the delay slot\n+     of calls.  This causes problems because the dwarf2 output code\n+     processes the insn list serially.  For now, limit the migration\n+     of prologue insns with a blockage.  */\n+  if (DO_FRAME_NOTES)\n+    emit_insn (gen_blockage ());\n }\n \n /* Emit RTL to load REG from the memory location specified by BASE+DISP.\n@@ -3407,7 +3509,7 @@ hppa_expand_epilogue ()\n   /* Try to restore RP early to avoid load/use interlocks when\n      RP gets used in the return (bv) instruction.  This appears to still\n      be necessary even when we schedule the prologue and epilogue.  */\n-  if (regs_ever_live [2])\n+  if (regs_ever_live [2] || current_function_calls_eh_return)\n     {\n       ret_off = TARGET_64BIT ? -16 : -20;\n       if (frame_pointer_needed)\n@@ -3429,7 +3531,26 @@ hppa_expand_epilogue ()\n   /* General register restores.  */\n   if (frame_pointer_needed)\n     {\n-      for (i = 18, offset = local_fsize; i >= 4; i--)\n+      offset = local_fsize;\n+\n+      /* If the current function calls __builtin_eh_return, then we need\n+         to restore the saved EH data registers.  */\n+      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+\t{\n+\t  unsigned int i, regno;\n+\n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\n+\t      load_reg (regno, offset, FRAME_POINTER_REGNUM);\n+\t      offset += UNITS_PER_WORD;\n+\t    }\n+\t}\n+\n+      for (i = 18; i >= 4; i--)\n \tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n@@ -3438,7 +3559,34 @@ hppa_expand_epilogue ()\n     }\n   else\n     {\n-      for (i = 18, offset = local_fsize - actual_fsize; i >= 3; i--)\n+      offset = local_fsize - actual_fsize;\n+\n+      /* If the current function calls __builtin_eh_return, then we need\n+         to restore the saved EH data registers.  */\n+      if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+\t{\n+\t  unsigned int i, regno;\n+\n+\t  for (i = 0; ; ++i)\n+\t    {\n+\t      regno = EH_RETURN_DATA_REGNO (i);\n+\t      if (regno == INVALID_REGNUM)\n+\t\tbreak;\n+\n+\t      /* Only for the first load.\n+\t         merge_sp_adjust_with_load holds the register load\n+\t         with which we will merge the sp adjustment.  */\n+\t      if (merge_sp_adjust_with_load == 0\n+\t\t  && local_fsize == 0\n+\t\t  && VAL_14_BITS_P (-actual_fsize))\n+\t        merge_sp_adjust_with_load = regno;\n+\t      else\n+\t\tload_reg (regno, offset, STACK_POINTER_REGNUM);\n+\t      offset += UNITS_PER_WORD;\n+\t    }\n+\t}\n+\n+      for (i = 18; i >= 3; i--)\n \t{\n \t  if (regs_ever_live[i] && ! call_used_regs[i])\n \t    {\n@@ -3464,9 +3612,9 @@ hppa_expand_epilogue ()\n     {\n       /* Adjust the register to index off of.  */\n       if (frame_pointer_needed)\n-\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset);\n+\tset_reg_plus_d (1, FRAME_POINTER_REGNUM, offset, 0);\n       else\n-\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n+\tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset, 0);\n \n       /* Actually do the restores now.  */\n       for (i = FP_SAVED_REG_LAST; i >= FP_SAVED_REG_FIRST; i -= FP_REG_STEP)\n@@ -3491,45 +3639,36 @@ hppa_expand_epilogue ()\n   if (frame_pointer_needed)\n     {\n       rtx delta = GEN_INT (-64);\n-      rtx insn;\n-      set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64);\n-      insn = emit_insn (gen_pre_load (frame_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t      delta));\n-      if (DO_FRAME_NOTES)\n-\t{\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t     gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n-\t\t\t\t\t   delta)),\n-                REG_NOTES (insn));\n-\t}\n+\n+      set_reg_plus_d (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, 64, 0);\n+      emit_insn (gen_pre_load (frame_pointer_rtx, stack_pointer_rtx, delta));\n     }\n   /* If we were deferring a callee register restore, do it now.  */\n   else if (merge_sp_adjust_with_load)\n     {\n       rtx delta = GEN_INT (-actual_fsize);\n       rtx dest = gen_rtx_REG (word_mode, merge_sp_adjust_with_load);\n-      rtx insn = emit_insn (gen_pre_load (dest, stack_pointer_rtx, delta));\n-      if (DO_FRAME_NOTES)\n-\t{\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t  REG_NOTES (insn)\n-\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t     gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n-\t\t\t\t\t   delta)),\n-                REG_NOTES (insn));\n-\t}\n+\n+      emit_insn (gen_pre_load (dest, stack_pointer_rtx, delta));\n     }\n   else if (actual_fsize != 0)\n-    set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM, - actual_fsize);\n+    set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n+\t\t    - actual_fsize, 0);\n \n   /* If we haven't restored %r2 yet (no frame pointer, and a stack\n      frame greater than 8k), do so now.  */\n   if (ret_off != 0)\n     load_reg (2, ret_off, STACK_POINTER_REGNUM);\n+\n+  if (DO_FRAME_NOTES && current_function_calls_eh_return)\n+    {\n+      rtx sa = EH_RETURN_STACKADJ_RTX;\n+\n+      emit_insn (gen_blockage ());\n+      emit_insn (TARGET_64BIT\n+\t\t ? gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx, sa)\n+\t\t : gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, sa));\n+    }\n }\n \n rtx\n@@ -6029,10 +6168,10 @@ output_call (insn, call_dest, sibcall)\n      and we're sure that the branch will reach the beginning of the $CODE$\n      subspace.  */\n   if ((dbr_sequence_length () == 0\n-       && get_attr_length (insn) == 8)\n+       && get_attr_length (insn) == 12)\n       || (dbr_sequence_length () != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n-\t  && get_attr_length (insn) == 4))\n+\t  && get_attr_length (insn) == 8))\n     {\n       xoperands[0] = call_dest;\n       xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n@@ -6041,7 +6180,7 @@ output_call (insn, call_dest, sibcall)\n     }\n \n   /* This call may not reach the beginning of the $CODE$ subspace.  */\n-  if (get_attr_length (insn) > 8)\n+  if (get_attr_length (insn) > 12)\n     {\n       int delay_insn_deleted = 0;\n       rtx xoperands[2];\n@@ -6241,14 +6380,16 @@ output_call (insn, call_dest, sibcall)\n \t       - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8;\n \n   /* If the branch was too far away, emit a normal call followed\n-     by a nop, followed by the unconditional branch.\n+     by a nop, followed by the unconditional branch.  We also don't\n+     adjust %r2 when generating dwarf2 frame or unwind info since\n+     the adjustment confuses the dwarf2 output.\n \n      If the branch is close, then adjust %r2 from within the\n      call's delay slot.  */\n \n   xoperands[0] = call_dest;\n   xoperands[1] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-  if (! VAL_14_BITS_P (distance))\n+  if (DO_FRAME_NOTES || ! VAL_14_BITS_P (distance))\n     output_asm_insn (\"{bl|b,l} %0,%%r2\\n\\tnop\\n\\tb,n %1\", xoperands);\n   else\n     {"}, {"sha": "1390cae027f832a403749b0a084f71505ac3cc3a", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -506,10 +506,22 @@ extern struct rtx_def *hppa_pic_save_rtx PARAMS ((void));\n #define STRUCT_VALUE_REGNUM 28\n \n /* Describe how we implement __builtin_eh_return.  */\n+/* FIXME: What's a good choice for the EH data registers on TARGET_64BIT?  */\n #define EH_RETURN_DATA_REGNO(N)\t\\\n-  ((N) < 3 ? (N) + 20 : (N) == 4 ? 31 : INVALID_REGNUM)\n+  (TARGET_64BIT\t\t\t\t\t\t\t\t\\\n+   ? ((N) < 4 ? (N) + 4 : INVALID_REGNUM)\t\t\t\t\\\n+   : ((N) < 3 ? (N) + 20 : (N) == 4 ? 31 : INVALID_REGNUM))\n #define EH_RETURN_STACKADJ_RTX\tgen_rtx_REG (Pmode, 29)\n-#define EH_RETURN_HANDLER_RTX\tgen_rtx_REG (Pmode, 2)\n+#define EH_RETURN_HANDLER_RTX \\\n+  gen_rtx_MEM (word_mode,\t\t\t\t\t\t\\\n+\t       gen_rtx_PLUS (word_mode, frame_pointer_rtx,\t\t\\\n+\t\t\t     TARGET_64BIT ? GEN_INT (-16) : GEN_INT (-20)))\n+\t\t\t  \t\n+\n+/* Offset from the argument pointer register value to the top of\n+   stack.  This is different from FIRST_PARM_OFFSET because of the\n+   frame marker.  */\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) 0\n \f\n /* The letters I, J, K, L and M in a register constraint string\n    can be used to stand for particular ranges of immediate operands."}, {"sha": "ec83b1f0806743de4eba6740229489c645e809fd", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 59, "deletions": 35, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -5568,6 +5568,21 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n+;; Use the PIC register to ensure it's restored after a\n+;; call in PIC mode.  This is used for eh returns which\n+;; bypass the return stub.\n+(define_insn \"return_external_pic\"\n+  [(return)\n+   (use (match_operand 0 \"register_operand\" \"r\"))\n+   (use (reg:SI 2))\n+   (clobber (reg:SI 1))]\n+  \"flag_pic\n+   && current_function_calls_eh_return\n+   && true_regnum (operands[0]) == PIC_OFFSET_TABLE_REGNUM\"\n+  \"ldsid (%%sr0,%%r2),%%r1\\;mtsp %%r1,%%sr0\\;be%* 0(%%sr0,%%r2)\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"12\")])\n+\n (define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n@@ -5590,15 +5605,24 @@\n   /* Try to use the trivial return first.  Else use the full\n      epilogue.  */\n   if (hppa_can_use_return_insn_p ())\n-   emit_jump_insn (gen_return ());\n+    emit_jump_insn (gen_return ());\n   else\n     {\n       rtx x;\n \n       hppa_expand_epilogue ();\n       if (flag_pic)\n-\tx = gen_return_internal_pic (gen_rtx_REG (word_mode,\n-\t\t\t\t\t\t  PIC_OFFSET_TABLE_REGNUM));\n+\t{\n+\t  rtx pic = gen_rtx_REG (word_mode, PIC_OFFSET_TABLE_REGNUM);\n+\n+\t  /* EH returns bypass the normal return stub.  Thus, we must do an\n+\t     interspace branch to return from functions that call eh_return.\n+\t     This is only a problem for returns from shared code.  */\n+\t  if (current_function_calls_eh_return)\n+\t    x = gen_return_external_pic (pic);\n+\t  else\n+\t    x = gen_return_internal_pic (pic);\n+\t}\n       else\n \tx = gen_return_internal ();\n       emit_jump_insn (x);\n@@ -5856,18 +5880,19 @@\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n ;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\t linker can use a long-branch stub, then the length is at most\n+;;\t 8 bytes.\n ;;\n-;;\t For long-calls the length will be either 52 bytes (non-pic)\n-;;\t or 68 bytes (pic).  */\n+;;\t For long-calls the length will be at most 68 bytes (non-pic)\n+;;\t or 84 bytes (pic).  */\n ;;\t Else we have to use a long-call;\n       (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n \t\t\t(const_int 240000))\n-\t\t    (const_int 4)\n+\t\t    (const_int 8)\n \t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n \t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 52)\n-\t\t\t\t  (const_int 68))))])\n+\t\t\t\t  (const_int 68)\n+\t\t\t\t  (const_int 84))))])\n \n (define_insn \"call_internal_reg_64bit\"\n   [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n@@ -6029,18 +6054,19 @@\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n ;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\t linker can use a long-branch stub, then the length is at most\n+;;\t 8 bytes.\n ;;\n-;;\t For long-calls the length will be either 52 bytes (non-pic)\n-;;\t or 68 bytes (pic).  */\n+;;\t For long-calls the length will be at most 68 bytes (non-pic)\n+;;\t or 84 bytes (pic).  */\n ;;\t Else we have to use a long-call;\n       (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n \t\t\t(const_int 240000))\n-\t\t    (const_int 4)\n+\t\t    (const_int 8)\n \t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n \t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 52)\n-\t\t\t\t  (const_int 68))))])\n+\t\t\t\t  (const_int 68)\n+\t\t\t\t  (const_int 84))))])\n \n (define_insn \"call_value_internal_reg_64bit\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -6200,18 +6226,19 @@\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n ;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\t linker can use a long-branch stub, then the length is at most\n+;;\t 8 bytes.\n ;;\n-;;\t For long-calls the length will be either 52 bytes (non-pic)\n-;;\t or 68 bytes (pic).  */\n+;;\t For long-calls the length will be at most 68 bytes (non-pic)\n+;;\t or 84 bytes (pic).  */\n ;;\t Else we have to use a long-call;\n       (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n \t\t\t(const_int 240000))\n-\t\t    (const_int 4)\n+\t\t    (const_int 8)\n \t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n \t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 52)\n-\t\t\t\t  (const_int 68))))])\n+\t\t\t\t  (const_int 68)\n+\t\t\t\t  (const_int 84))))])\n \n (define_expand \"sibcall_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -6258,18 +6285,19 @@\n   [(set_attr \"type\" \"call\")\n    (set (attr \"length\")\n ;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is 4 bytes.\n+;;\t linker can use a long-branch stub, then the length is at most\n+;;\t 8 bytes.\n ;;\n-;;\t For long-calls the length will be either 52 bytes (non-pic)\n-;;\t or 68 bytes (pic).  */\n+;;\t For long-calls the length will be at most 68 bytes (non-pic)\n+;;\t or 84 bytes (pic).  */\n ;;\t Else we have to use a long-call;\n       (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n \t\t\t(const_int 240000))\n-\t\t    (const_int 4)\n+\t\t    (const_int 8)\n \t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n \t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 52)\n-\t\t\t\t  (const_int 68))))])\n+\t\t\t\t  (const_int 68)\n+\t\t\t\t  (const_int 84))))])\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -7216,16 +7244,12 @@\n ;; restore the PIC register.\n (define_expand \"exception_receiver\"\n   [(const_int 4)]\n-  \"!TARGET_PORTABLE_RUNTIME && flag_pic\"\n+  \"flag_pic\"\n   \"\n {\n-  /* Load the PIC register from the stack slot (in our caller's\n-     frame).  */\n-  emit_move_insn (pic_offset_table_rtx,\n-\t\t  gen_rtx_MEM (SImode,\n-\t\t\t       plus_constant (stack_pointer_rtx, -32)));\n-  emit_insn (gen_rtx (USE, VOIDmode, pic_offset_table_rtx));\n-  emit_insn (gen_blockage ());\n+  /* Restore the PIC register using hppa_pic_save_rtx ().  The\n+     PIC register is not saved in the frame in 64-bit ABI.  */\n+  emit_move_insn (pic_offset_table_rtx, hppa_pic_save_rtx ());\n   DONE;\n }\")\n "}, {"sha": "0c546ab19a1806c7ec34e24a38842a2e1120e01f", "filename": "gcc/configure", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -2229,7 +2229,7 @@ EOF\n fi\n \n # Find some useful tools\n-for ac_prog in gawk mawk nawk awk\n+for ac_prog in mawk gawk nawk awk\n do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n@@ -7480,7 +7480,7 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs against hidden symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:7430: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n+echo \"configure:7484: checking assembler and linker support unaligned pc related relocs against hidden symbols\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_sparc_ua_pcrel_hidden'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7522,7 +7522,7 @@ EOF\n     case \"$tm_file\" in\n     *64*)\n \techo $ac_n \"checking for 64 bit support in assembler ($gcc_cv_as)\"\"... $ac_c\" 1>&6\n-echo \"configure:7487: checking for 64 bit support in assembler ($gcc_cv_as)\" >&5\n+echo \"configure:7526: checking for 64 bit support in assembler ($gcc_cv_as)\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_flags64'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7567,7 +7567,7 @@ EOF\n \n     if test \"x$gcc_cv_as_flags64\" != xno; then\n \techo $ac_n \"checking for assembler offsetable %lo() support\"\"... $ac_c\" 1>&6\n-echo \"configure:7532: checking for assembler offsetable %lo() support\" >&5\n+echo \"configure:7571: checking for assembler offsetable %lo() support\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_as_offsetable_lo10'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -7607,7 +7607,7 @@ EOF\n \n   i[34567]86-*-* | x86_64-*-*)\n     echo $ac_n \"checking assembler instructions\"\"... $ac_c\" 1>&6\n-echo \"configure:7572: checking assembler instructions\" >&5\n+echo \"configure:7611: checking assembler instructions\" >&5\n     gcc_cv_as_instructions=\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x; then\n       if test \"$gcc_cv_gas_major_version\" -eq 2 -a \"$gcc_cv_gas_minor_version\" -ge 9 -o \"$gcc_cv_gas_major_version\" -gt 2; then\n@@ -7634,7 +7634,7 @@ EOF\n     echo \"$ac_t\"\"$gcc_cv_as_instructions\" 1>&6\n \n     echo $ac_n \"checking assembler GOTOFF in data directives\"\"... $ac_c\" 1>&6\n-echo \"configure:7599: checking assembler GOTOFF in data directives\" >&5\n+echo \"configure:7638: checking assembler GOTOFF in data directives\" >&5\n     gcc_cv_as_gotoff_in_data=no\n     if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x\n     then\n@@ -7664,7 +7664,7 @@ EOF\n esac\n \n echo $ac_n \"checking assembler dwarf2 debug_line support\"\"... $ac_c\" 1>&6\n-echo \"configure:7629: checking assembler dwarf2 debug_line support\" >&5\n+echo \"configure:7668: checking assembler dwarf2 debug_line support\" >&5\n gcc_cv_as_dwarf2_debug_line=no\n # ??? Not all targets support dwarf2 debug_line, even within a version\n # of gas.  Moreover, we need to emit a valid instruction to trigger any\n@@ -7673,7 +7673,7 @@ gcc_cv_as_dwarf2_debug_line=no\n # ??? Once 2.11 is released, probably need to add first known working\n # version to the per-target configury.\n case \"$target\" in\n-  i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* | x86_64*-*-*)\n+  i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* | x86_64*-*-* | hppa*-*-*)\n     insn=\"nop\"\n     ;;\n   ia64*-*-*)\n@@ -7720,7 +7720,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_dwarf2_debug_line\" 1>&6\n \n echo $ac_n \"checking assembler --gdwarf2 support\"\"... $ac_c\" 1>&6\n-echo \"configure:7685: checking assembler --gdwarf2 support\" >&5\n+echo \"configure:7724: checking assembler --gdwarf2 support\" >&5\n gcc_cv_as_gdwarf2_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7749,7 +7749,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gdwarf2_flag\" 1>&6\n \n echo $ac_n \"checking assembler --gstabs support\"\"... $ac_c\" 1>&6\n-echo \"configure:7714: checking assembler --gstabs support\" >&5\n+echo \"configure:7753: checking assembler --gstabs support\" >&5\n gcc_cv_as_gstabs_flag=no\n if test x$gcc_cv_gas_major_version != x -a x$gcc_cv_gas_minor_version != x;\n then\n@@ -7777,7 +7777,7 @@ fi\n echo \"$ac_t\"\"$gcc_cv_as_gstabs_flag\" 1>&6\n \n echo $ac_n \"checking linker PT_GNU_EH_FRAME support\"\"... $ac_c\" 1>&6\n-echo \"configure:7742: checking linker PT_GNU_EH_FRAME support\" >&5\n+echo \"configure:7781: checking linker PT_GNU_EH_FRAME support\" >&5\n gcc_cv_ld_eh_frame_hdr=no\n if test x$gcc_cv_gld_major_version != x -a x$gcc_cv_gld_minor_version != x; then\n   if test \"$gcc_cv_gld_major_version\" -eq 2 -a \"$gcc_cv_gld_minor_version\" -ge 12 -o \"$gcc_cv_gld_major_version\" -gt 2 && grep 'EMUL = elf' ../ld/Makefile > /dev/null; then\n@@ -7940,7 +7940,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:7905: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:7944: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\""}, {"sha": "0e48cb4b0803b47326dde04210295524316c7a90", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823fbbce5c867613d9a1417d77970ab0ea5f41b4/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=823fbbce5c867613d9a1417d77970ab0ea5f41b4", "patch": "@@ -1929,7 +1929,7 @@ gcc_cv_as_dwarf2_debug_line=no\n # ??? Once 2.11 is released, probably need to add first known working\n # version to the per-target configury.\n case \"$target\" in\n-  i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* | x86_64*-*-*)\n+  i?86*-*-* | mips*-*-* | alpha*-*-* | powerpc*-*-* | sparc*-*-* | m68*-*-* | x86_64*-*-* | hppa*-*-*)\n     insn=\"nop\"\n     ;;\n   ia64*-*-*)"}]}