{"sha": "d570d364e65622ce12e1153a5a71e5086ae52bff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU3MGQzNjRlNjU2MjJjZTEyZTExNTNhNWE3MWU1MDg2YWU1MmJmZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-02T07:48:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-02T07:48:00Z"}, "message": "ipa-utils.h (method_class_type, [...]): Constify.\n\n\n\t* ipa-utils.h (method_class_type, vtable_pointer_value_to_binfo,\n\tvtable_pointer_value_to_vtable): Constify.\n\t(contains_polymorphic_type_p): Declare.\n\t* ipa-devirt.c (method_class_type, vtable_pointer_value_to_binfo,\n\tvtable_pointer_value_to_vtable): Constify.\n\t(contains_polymorphic_type_p): New predicate.\n\t* ipa-prop.c (ipa_set_jf_known_type): Allow types containing\n\tpolymorphic types.\n\t(ipa_set_ancestor_jf): Likewise.\n\t(detect_type_change): Return false in easy cases.\n\t(compute_complex_assign_jump_func): Require type to contain\n\tpolymorphic type.\n\t(compute_known_type_jump_func): Likewise.\n\nFrom-SVN: r212222", "tree": {"sha": "225514c436ac69e07051d75ed16ed73298df840f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/225514c436ac69e07051d75ed16ed73298df840f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d570d364e65622ce12e1153a5a71e5086ae52bff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d570d364e65622ce12e1153a5a71e5086ae52bff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d570d364e65622ce12e1153a5a71e5086ae52bff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d570d364e65622ce12e1153a5a71e5086ae52bff/comments", "author": null, "committer": null, "parents": [{"sha": "a90532fda138310a184d7766f660f7fb80d94b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a90532fda138310a184d7766f660f7fb80d94b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a90532fda138310a184d7766f660f7fb80d94b25"}], "stats": {"total": 112, "additions": 80, "deletions": 32}, "files": [{"sha": "cf557122119834f33cbf7bc6aca6f3df72bba1b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d570d364e65622ce12e1153a5a71e5086ae52bff", "patch": "@@ -1,3 +1,19 @@\n+2014-07-01  Jan Hubicka   <hubicka@ucw.cz>\n+\n+\t* ipa-utils.h (method_class_type, vtable_pointer_value_to_binfo,\n+\tvtable_pointer_value_to_vtable): Constify.\n+\t(contains_polymorphic_type_p): Declare.\n+\t* ipa-devirt.c (method_class_type, vtable_pointer_value_to_binfo,\n+\tvtable_pointer_value_to_vtable): Constify.\n+\t(contains_polymorphic_type_p): New predicate.\n+\t* ipa-prop.c (ipa_set_jf_known_type): Allow types containing\n+\tpolymorphic types.\n+\t(ipa_set_ancestor_jf): Likewise.\n+\t(detect_type_change): Return false in easy cases.\n+\t(compute_complex_assign_jump_func): Require type to contain\n+\tpolymorphic type.\n+\t(compute_known_type_jump_func): Likewise.\n+\n 2014-07-01  Jan Hubicka   <hubicka@ucw.cz>\n \n \t* tree.c (decls_same_for_odr, decls_same_for_odr,"}, {"sha": "f7418f175f641da7c6010d0844ab114b714ec6ca", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=d570d364e65622ce12e1153a5a71e5086ae52bff", "patch": "@@ -742,7 +742,7 @@ dump_type_inheritance_graph (FILE *f)\n    Lookup this pointer and get its type.    */\n \n tree\n-method_class_type (tree t)\n+method_class_type (const_tree t)\n {\n   tree first_parm_type = TREE_VALUE (TYPE_ARG_TYPES (t));\n   gcc_assert (TREE_CODE (t) == METHOD_TYPE);\n@@ -1187,6 +1187,31 @@ devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n     free_polymorphic_call_targets_hash ();\n }\n \n+/* Return true when TYPE contains an polymorphic type and thus is interesting\n+   for devirtualization machinery.  */\n+\n+bool\n+contains_polymorphic_type_p (const_tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      if (TYPE_BINFO (type)\n+          && polymorphic_type_binfo_p (TYPE_BINFO (type)))\n+\treturn true;\n+      for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+\tif (TREE_CODE (fld) == FIELD_DECL\n+\t    && !DECL_ARTIFICIAL (fld)\n+\t    && contains_polymorphic_type_p (TREE_TYPE (fld)))\n+\t  return true;\n+      return false;\n+    }\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return contains_polymorphic_type_p (TREE_TYPE (type));\n+  return false;\n+}\n+\n /* CONTEXT->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n    is contained at CONTEXT->OFFSET.  Walk the memory representation of\n    CONTEXT->OUTER_TYPE and find the outermost class type that match\n@@ -1349,7 +1374,8 @@ subbinfo_with_vtable_at_offset (tree binfo, unsigned HOST_WIDE_INT offset,\n    Return false if T does not look like virtual table reference.  */\n \n bool\n-vtable_pointer_value_to_vtable (tree t, tree *v, unsigned HOST_WIDE_INT *offset)\n+vtable_pointer_value_to_vtable (const_tree t, tree *v,\n+\t\t\t\tunsigned HOST_WIDE_INT *offset)\n {\n   /* We expect &MEM[(void *)&virtual_table + 16B].\n      We obtain object's BINFO from the context of the virtual table. \n@@ -1395,7 +1421,7 @@ vtable_pointer_value_to_vtable (tree t, tree *v, unsigned HOST_WIDE_INT *offset)\n    instance type.  */\n \n tree\n-vtable_pointer_value_to_binfo (tree t)\n+vtable_pointer_value_to_binfo (const_tree t)\n {\n   tree vtable;\n   unsigned HOST_WIDE_INT offset;"}, {"sha": "b56921021b820927767ebadf16cd1deb98949c34", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=d570d364e65622ce12e1153a5a71e5086ae52bff", "patch": "@@ -443,11 +443,10 @@ ipa_set_jf_known_type (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n   base_type = TYPE_MAIN_VARIANT (base_type);\n   component_type = TYPE_MAIN_VARIANT (component_type);\n \n-  gcc_assert (TREE_CODE (component_type) == RECORD_TYPE\n-\t      && TYPE_BINFO (component_type));\n+  gcc_assert (contains_polymorphic_type_p (base_type)\n+\t      && contains_polymorphic_type_p (component_type));\n   if (!flag_devirtualize)\n     return;\n-  gcc_assert (BINFO_VTABLE (TYPE_BINFO (component_type)));\n   jfunc->type = IPA_JF_KNOWN_TYPE;\n   jfunc->value.known_type.offset = offset,\n   jfunc->value.known_type.base_type = base_type;\n@@ -534,12 +533,11 @@ ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n {\n   if (!flag_devirtualize)\n     type_preserved = false;\n+  if (!type_preserved)\n+    type = NULL_TREE;\n   if (type)\n     type = TYPE_MAIN_VARIANT (type);\n-  gcc_assert (!type_preserved\n-\t      || (TREE_CODE (type) == RECORD_TYPE\n-\t\t  && TYPE_BINFO (type)\n-\t\t  && BINFO_VTABLE (TYPE_BINFO (type))));\n+  gcc_assert (!type_preserved || contains_polymorphic_type_p (type));\n   jfunc->type = IPA_JF_ANCESTOR;\n   jfunc->value.ancestor.formal_id = formal_id;\n   jfunc->value.ancestor.offset = offset;\n@@ -752,18 +750,12 @@ detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n   gcc_checking_assert (DECL_P (arg)\n \t\t       || TREE_CODE (arg) == MEM_REF\n \t\t       || handled_component_p (arg));\n-  /* Const calls cannot call virtual methods through VMT and so type changes do\n-     not matter.  */\n-  if (!flag_devirtualize || !gimple_vuse (call)\n-      /* Be sure expected_type is polymorphic.  */\n-      || !comp_type\n-      || TREE_CODE (comp_type) != RECORD_TYPE\n-      || !TYPE_BINFO (TYPE_MAIN_VARIANT (comp_type))\n-      || !BINFO_VTABLE (TYPE_BINFO (TYPE_MAIN_VARIANT (comp_type))))\n-    return true;\n \n   comp_type = TYPE_MAIN_VARIANT (comp_type);\n \n+  if (!flag_devirtualize)\n+    return false;\n+\n   /* C++ methods are not allowed to change THIS pointer unless they\n      are constructors or destructors.  */\n   if (TREE_CODE\t(base) == MEM_REF\n@@ -775,7 +767,20 @@ detect_type_change (tree arg, tree base, tree comp_type, gimple call,\n       && !DECL_CXX_DESTRUCTOR_P (current_function_decl)\n       && (SSA_NAME_VAR (TREE_OPERAND (base, 0))\n \t  == DECL_ARGUMENTS (current_function_decl)))\n-    return false;\n+    {\n+      gcc_assert (comp_type);\n+      return false;\n+    }\n+\n+  /* Const calls cannot call virtual methods through VMT and so type changes do\n+     not matter.  */\n+  if (!flag_devirtualize || !gimple_vuse (call)\n+      /* Be sure expected_type is polymorphic.  */\n+      || !comp_type\n+      || TREE_CODE (comp_type) != RECORD_TYPE\n+      || !TYPE_BINFO (TYPE_MAIN_VARIANT (comp_type))\n+      || !BINFO_VTABLE (TYPE_BINFO (TYPE_MAIN_VARIANT (comp_type))))\n+    return true;\n \n   ao_ref_init (&ao, arg);\n   ao.base = base;\n@@ -1258,8 +1263,9 @@ compute_complex_assign_jump_func (struct func_body_info *fbi,\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n   if (index >= 0 && param_type && POINTER_TYPE_P (param_type))\n     {\n-      bool type_p = !detect_type_change (op1, base, TREE_TYPE (param_type),\n-\t\t\t\t\t call, jfunc, offset);\n+      bool type_p = (contains_polymorphic_type_p (TREE_TYPE (param_type))\n+\t\t     && !detect_type_change (op1, base, TREE_TYPE (param_type),\n+\t\t\t\t\t     call, jfunc, offset));\n       if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n \tipa_set_ancestor_jf (jfunc, offset,\n \t\t\t     type_p ? TREE_TYPE (param_type) : NULL, index,\n@@ -1391,7 +1397,8 @@ compute_complex_ancestor_jump_func (struct func_body_info *fbi,\n     }\n \n   bool type_p = false;\n-  if (param_type && POINTER_TYPE_P (param_type))\n+  if (param_type && POINTER_TYPE_P (param_type)\n+      && contains_polymorphic_type_p (TREE_TYPE (param_type)))\n     type_p = !detect_type_change (obj, expr, TREE_TYPE (param_type),\n \t\t\t\t  call, jfunc, offset);\n   if (type_p || jfunc->type == IPA_JF_UNKNOWN)\n@@ -1415,20 +1422,18 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n \n   if (!flag_devirtualize\n       || TREE_CODE (op) != ADDR_EXPR\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (op))) != RECORD_TYPE\n+      || !contains_polymorphic_type_p (TREE_TYPE (TREE_TYPE (op)))\n       /* Be sure expected_type is polymorphic.  */\n       || !expected_type\n-      || TREE_CODE (expected_type) != RECORD_TYPE\n-      || !TYPE_BINFO (TYPE_MAIN_VARIANT (expected_type))\n-      || !BINFO_VTABLE (TYPE_BINFO (TYPE_MAIN_VARIANT (expected_type))))\n+      || !contains_polymorphic_type_p (expected_type))\n     return;\n \n   op = TREE_OPERAND (op, 0);\n   base = get_ref_base_and_extent (op, &offset, &size, &max_size);\n   if (!DECL_P (base)\n       || max_size == -1\n       || max_size != size\n-      || TREE_CODE (TREE_TYPE (base)) != RECORD_TYPE\n+      || !contains_polymorphic_type_p (TREE_TYPE (base))\n       || is_global_var (base))\n     return;\n "}, {"sha": "82aa23fe4032fa5a42247c7566784a56b080c539", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d570d364e65622ce12e1153a5a71e5086ae52bff/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=d570d364e65622ce12e1153a5a71e5086ae52bff", "patch": "@@ -83,15 +83,16 @@ void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t     const ipa_polymorphic_call_context &);\n bool possible_polymorphic_call_target_p (tree, HOST_WIDE_INT,\n \t\t\t\t         const ipa_polymorphic_call_context &,\n-\t\t\t\t\t struct cgraph_node *n);\n-tree method_class_type (tree);\n+\t\t\t\t\t struct cgraph_node *);\n+tree method_class_type (const_tree);\n tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n \t\t\t\tipa_polymorphic_call_context *);\n bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n \t\t\t\t\t       tree, tree, HOST_WIDE_INT);\n-tree vtable_pointer_value_to_binfo (tree t);\n-bool vtable_pointer_value_to_vtable (tree, tree *, unsigned HOST_WIDE_INT *);\n+tree vtable_pointer_value_to_binfo (const_tree);\n+bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n+bool contains_polymorphic_type_p (const_tree);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If FINALP is non-NULL, store true if the list is complette. "}]}