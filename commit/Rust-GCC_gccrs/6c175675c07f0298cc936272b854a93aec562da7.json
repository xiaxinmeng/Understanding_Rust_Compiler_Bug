{"sha": "6c175675c07f0298cc936272b854a93aec562da7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMxNzU2NzVjMDdmMDI5OGNjOTM2MjcyYjg1NGE5M2FlYzU2MmRhNw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2010-09-15T07:19:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-09-15T07:19:37Z"}, "message": "osf5.h (MD_UNWIND_SUPPORT): Define.\n\n\t* config/alpha/osf5.h (MD_UNWIND_SUPPORT): Define.\n\t* config/alpha/osf5-unwind.h: New file.\n\nCo-Authored-By: Jose Ruiz <ruiz@adacore.com>\n\nFrom-SVN: r164297", "tree": {"sha": "0ab4e974bff62acea9173d2a3838c38bb7c66ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ab4e974bff62acea9173d2a3838c38bb7c66ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c175675c07f0298cc936272b854a93aec562da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c175675c07f0298cc936272b854a93aec562da7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c175675c07f0298cc936272b854a93aec562da7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c175675c07f0298cc936272b854a93aec562da7/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b7237bbeb9fbdb1a5621757e25b0860f0a0a032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b7237bbeb9fbdb1a5621757e25b0860f0a0a032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b7237bbeb9fbdb1a5621757e25b0860f0a0a032"}], "stats": {"total": 337, "additions": 337, "deletions": 0}, "files": [{"sha": "3e4e32cf1f2b3a64b0591702b9bc163198e200be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c175675c07f0298cc936272b854a93aec562da7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c175675c07f0298cc936272b854a93aec562da7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c175675c07f0298cc936272b854a93aec562da7", "patch": "@@ -1,3 +1,9 @@\n+2010-09-15  Olivier Hainque  <hainque@adacore.com>\n+            Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* config/alpha/osf5.h (MD_UNWIND_SUPPORT): Define.\n+\t* config/alpha/osf5-unwind.h: New file.\n+\n 2010-09-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/45672"}, {"sha": "c649099349e3b4e1432acacac2da3b7937150c92", "filename": "gcc/config/alpha/osf5-unwind.h", "status": "added", "additions": 329, "deletions": 0, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c175675c07f0298cc936272b854a93aec562da7/gcc%2Fconfig%2Falpha%2Fosf5-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c175675c07f0298cc936272b854a93aec562da7/gcc%2Fconfig%2Falpha%2Fosf5-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf5-unwind.h?ref=6c175675c07f0298cc936272b854a93aec562da7", "patch": "@@ -0,0 +1,329 @@\n+/* DWARF2 EH unwinding support for Alpha Tru64.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file implements the MD_FALLBACK_FRAME_STATE_FOR macro, triggered when\n+   the GCC table based unwinding process hits a frame for which no unwind info\n+   has been registered. This typically occurs when raising an exception from a\n+   signal handler, because the handler is actually called from the OS kernel.\n+\n+   The basic idea is to detect that we are indeed trying to unwind past a\n+   signal handler and to fill out the GCC internal unwinding structures for\n+   the OS kernel frame as if it had been directly called from the interrupted\n+   context.\n+\n+   This is all assuming that the code to set the handler asked the kernel to\n+   pass a pointer to such context information.  */\n+\n+/* --------------------------------------------------------------------------\n+   -- Basic principles of operation:\n+   --------------------------------------------------------------------------\n+\n+   1/ We first need a way to detect if we are trying to unwind past a signal\n+      handler.\n+\n+   The typical method that is used on most platforms is to look at the code\n+   around the return address we have and check if it matches the OS code\n+   calling a handler.  To determine what this code is expected to be, get a\n+   breakpoint into a real signal handler and look at the code around the\n+   return address.  Depending on the library versions the pattern of the\n+   signal handler is different; this is the reason why we check against more\n+   than one pattern.\n+\n+   On this target, the return address is right after the call and every\n+   instruction is 4 bytes long.  For the simple case of a null dereference in\n+   a single-threaded app, it went like:\n+\n+   # Check that we indeed have something we expect: the instruction right\n+   # before the return address is within a __sigtramp function and is a call.\n+\n+   [... run gdb and break at the signal handler entry ...]\n+\n+   (gdb) x /i $ra-4\n+   <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>\n+\n+   # Look at the code around that return address, and eventually observe a\n+   # significantly large chunk of *constant* code right before the call:\n+\n+   (gdb) x /10i  $ra-44\n+   <__sigtramp+120>: lda     gp,-27988(gp)\n+   <__sigtramp+124>: ldq     at,-18968(gp)\n+   <__sigtramp+128>: lda     t0,-1\n+   <__sigtramp+132>: stq     t0,0(at)\n+   <__sigtramp+136>: ldq     at,-18960(gp)\n+   <__sigtramp+140>: ldl     t1,8(at)\n+   <__sigtramp+144>: ldq     at,-18960(gp)\n+   <__sigtramp+148>: stl     t1,12(at)\n+   <__sigtramp+152>: ldq     at,-18960(gp)\n+   <__sigtramp+156>: stl     t0,8(at)\n+\n+   # The hexadecimal equivalent that we will have to match is:\n+\n+   (gdb) x /10x  $ra-44\n+   <__sigtramp+120>: 0x23bd92ac    0xa79db5e8    0x203fffff   0xb43c0000\n+   <__sigtramp+136>: 0xa79db5f0    0xa05c0008    0xa79db5f0   0xb05c000c\n+   <__sigtramp+152>: 0xa79db5f0    0xb03c0008\n+\n+   The problem observed on this target with this approach is that although\n+   we found a constant set of instruction patterns there were some\n+   gp-related offsets that made the machine code to differ from one\n+   installation to another.  This problem could have been overcome by masking\n+   these offsets, but we found that it would be simpler and more efficient to\n+   check whether the return address was part of a signal handler, by comparing\n+   it against some expected code offset from __sigtramp.\n+\n+   # Check that we indeed have something we expect: the instruction\n+   # right before the return address is within a __sigtramp\n+   # function and is a call. We also need to obtain the offset\n+   # between the return address and the start address of __sigtramp.\n+\n+   [... run gdb and break at the signal handler entry ...]\n+\n+   (gdb) x /2i $ra-4\n+   <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>\n+   <__sigtramp+164>: ldah    gp,16381(ra)\n+\n+   (gdb) p (long)$ra - (long)&__sigtramp\n+   $2 = 164\n+\n+   --------------------------------------------------------------------------\n+\n+   2/ Once we know we are going through a signal handler, we need a way to\n+      retrieve information about the interrupted run-time context.\n+\n+   On this platform, the third handler's argument is a pointer to a structure\n+   describing this context (struct sigcontext *). We unfortunately have no\n+   direct way to transfer this value here, so a couple of tricks are required\n+   to compute it.\n+\n+   As documented at least in some header files (e.g. sys/machine/context.h),\n+   the structure the handler gets a pointer to is located on the stack.  As of\n+   today, while writing this macro, we have unfortunately not been able to\n+   find a detailed description of the full stack layout at handler entry time,\n+   so we'll have to resort to empirism :)\n+\n+   When unwinding here, we have the handler's CFA at hand, as part of the\n+   current unwinding context which is one of our arguments.  We presume that\n+   for each call to a signal handler by the same kernel routine, the context's\n+   structure location on the stack is always at the same offset from the\n+   handler's CFA, and we compute that offset from bare observation:\n+\n+   For the simple case of a bare null dereference in a single-threaded app,\n+   computing the offset was done using GNAT like this:\n+\n+   # Break on the first handler's instruction, before the prologue to have the\n+   # CFA in $sp, and get there:\n+\n+   (gdb) b *&__gnat_error_handler\n+   Breakpoint 1 at 0x120016090: file init.c, line 378.\n+\n+   (gdb) r\n+   Program received signal SIGSEGV, Segmentation fault.\n+\n+   (gdb) c\n+   Breakpoint 1, __gnat_error_handler (sig=..., sip=..., context=...)\n+\n+   # The displayed argument value are meaningless because we stopped before\n+   # their final \"homing\". We know they are passed through $a0, $a1 and $a2\n+   # from the ABI, though, so ...\n+\n+   # Observe that $sp and the context pointer are in the same (stack) area,\n+   # and compute the offset:\n+\n+   (gdb) p /x $sp\n+   $2 = 0x11fffbc80\n+\n+   (gdb) p /x $a2\n+   $3 = 0x11fffbcf8\n+\n+   (gdb) p /x (long)$a2 - (long)$sp\n+   $4 = 0x78\n+\n+   --------------------------------------------------------------------------\n+\n+   3/ Once we know we are unwinding through a signal handler and have the\n+      address of the structure describing the interrupted context at hand, we\n+      have to fill the internal frame-state/unwind-context structures properly\n+      to allow the unwinding process to proceed.\n+\n+   Roughly, we are provided with an *unwinding* CONTEXT, describing the state\n+   of some point P in the call chain we are unwinding through.  The macro we\n+   implement has to fill a \"frame state\" structure FS that describe the P's\n+   caller state, by way of *rules* to compute its CFA, return address, and\n+   **saved** registers *locations*. \n+\n+   For the case we are going to deal with, the caller is some kernel code\n+   calling a signal handler, and:\n+\n+   o The saved registers are all in the interrupted run-time context,\n+\n+   o The CFA is the stack pointer value when the kernel code is entered, that\n+     is, the stack pointer value at the interruption point, also part of the\n+     interrupted run-time context.\n+\n+   o We want the return address to appear as the address of the active\n+     instruction at the interruption point, so that the unwinder proceeds as\n+     if the interruption had been a regular call.  This address is also part\n+     of the interrupted run-time context.\n+\n+   --\n+\n+   Also, note that there is an important difference between the return address\n+   we need to claim for the kernel frame and the value of the return address\n+   register at the interruption point.\n+\n+   The latter might be required to be able to unwind past the interrupted\n+   routine, for instance if it is interrupted before saving the incoming\n+   register value in its own frame, which may typically happen during stack\n+   probes for stack-checking purposes.\n+\n+   It is then essential that the rules stated to locate the kernel frame\n+   return address don't clobber the rules describing where is saved the return\n+   address register at the interruption point, so some scratch register state\n+   entry should be used for the former. We have DWARF_ALT_FRAME_RETURN_COLUMN\n+   at hand exactly for that purpose.\n+\n+   --------------------------------------------------------------------------\n+\n+   4/ Depending on the context (single-threaded or multi-threaded app, ...),\n+   the code calling the handler and the handler-cfa to interrupted-context\n+   offset might change, so we use a simple generic data structure to track\n+   the possible variants.  */\n+\n+/* This is the structure to wrap information about each possible sighandler\n+   caller we may have to identify.  */\n+\n+typedef struct {\n+  /* Expected return address when being called from a sighandler.  */\n+  void *ra_value;\n+\n+  /* Offset to get to the sigcontext structure from the handler's CFA\n+     when the pattern matches.  */\n+  int cfa_to_context_offset;\n+\n+} sighandler_call_t;\n+\n+/* Helper macro for MD_FALLBACK_FRAME_STATE_FOR below.\n+\n+   Look at RA to see if it matches within a sighandler caller.\n+   Set SIGCTX to the corresponding sigcontext structure (computed from\n+   CFA) if it does, or to 0 otherwise.  */\n+\n+#define COMPUTE_SIGCONTEXT_FOR(RA,CFA,SIGCTX)\t\t\t\t    \\\n+do {\t\t\t\t\t\t\t\t\t    \\\n+  /* Define and register the applicable patterns.  */\t\t\t    \\\n+  extern void __sigtramp (void);\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  sighandler_call_t sighandler_calls [] = {\t\t\t\t    \\\n+    {__sigtramp + 164, 0x78}\t\t\t\t\t\t    \\\n+  };\t\t\t\t\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  int n_patterns_to_match\t\t\t\t\t\t    \\\n+    = sizeof (sighandler_calls) / sizeof (sighandler_call_t);\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  int pn;  /* pattern number  */\t\t\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  int match = 0;  /* Did last pattern match ?  */\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  /* Try to match each pattern in turn.  */\t\t\t\t    \\\n+  for (pn = 0; !match && pn < n_patterns_to_match; pn ++)\t\t    \\\n+    match = ((RA) == sighandler_calls[pn].ra_value);\t\t\t    \\\n+\t\t\t\t\t\t\t\t\t    \\\n+  (SIGCTX) = (struct sigcontext *)\t\t\t\t\t    \\\n+    (match ? ((CFA) + sighandler_calls[pn - 1].cfa_to_context_offset) : 0); \\\n+} while (0);\n+\n+#include <sys/context_t.h>\n+\n+#define REG_SP  30  /* hard reg for stack pointer */\n+#define REG_RA  26  /* hard reg for return address */\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+alpha_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t    _Unwind_FrameState *fs)\n+{\n+  /* Return address and CFA of the frame we're attempting to unwind through,\n+     possibly a signal handler.  */\n+  void *ctx_ra  = (void *)context->ra;\n+  void *ctx_cfa = (void *)context->cfa;\n+\n+  /* CFA of the intermediate abstract kernel frame between the interrupted\n+     code and the signal handler, if we're indeed unwinding through a signal\n+     handler.  */\n+  void *k_cfa;\n+\n+  /* Pointer to the sigcontext structure pushed by the kernel when we're\n+     unwinding through a signal handler.  */\n+  struct sigcontext *sigctx;\n+  int i;\n+\n+  COMPUTE_SIGCONTEXT_FOR (ctx_ra, ctx_cfa, sigctx);\n+\n+  if (sigctx == 0)\n+    return _URC_END_OF_STACK;\n+\n+  /* The kernel frame's CFA is exactly the stack pointer value at the\n+     interruption point.  */\n+  k_cfa = (void *) sigctx->sc_regs [REG_SP];\n+\n+  /* State the rules to compute the CFA we have the value of: use the\n+     previous CFA and offset by the difference between the two.  See\n+     uw_update_context_1 for the supporting details.  */\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = k_cfa - ctx_cfa;\n+\n+  /* Fill the internal frame_state structure with information stating\n+     where each register of interest in the saved context can be found\n+     from the CFA.  */\n+\n+  /* The general registers are in sigctx->sc_regs.  Leave out r31, which\n+     is read-as-zero. It makes no sense restoring it, and we are going to\n+     use the state entry for the kernel return address rule below.\n+\n+     This loop must cover at least all the callee-saved registers, and\n+     we just don't bother specializing the set here.  */\n+  for (i = 0; i <= 30; i ++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset\n+\t= (void *) &sigctx->sc_regs[i] - (void *) k_cfa;\n+    }\n+\n+  /* Ditto for the floating point registers in sigctx->sc_fpregs.  */\n+  for (i = 0; i <= 31; i ++)\n+    {\n+      fs->regs.reg[32+i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[32+i].loc.offset\n+\t= (void *) &sigctx->sc_fpregs[i] - (void *) k_cfa;\n+    }\n+\n+  /* State the rules to find the kernel's code \"return address\", which\n+     is the address of the active instruction when the signal was caught,\n+     in sigctx->sc_pc. Use DWARF_ALT_FRAME_RETURN_COLUMN since the return\n+     address register is a general register and should be left alone.  */\n+  fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;\n+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset\n+    = (void *) &sigctx->sc_pc - (void *) k_cfa;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+}"}, {"sha": "759b4e799eca5d7cd0b8b01f7c518e9e1ff0da9e", "filename": "gcc/config/alpha/osf5.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c175675c07f0298cc936272b854a93aec562da7/gcc%2Fconfig%2Falpha%2Fosf5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c175675c07f0298cc936272b854a93aec562da7/gcc%2Fconfig%2Falpha%2Fosf5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf5.h?ref=6c175675c07f0298cc936272b854a93aec562da7", "patch": "@@ -274,3 +274,5 @@ __enable_execute_stack (void *addr)\t\t\t\t\t\\\n \n /* Handle #pragma extern_prefix.  */\n #define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX 1\n+\n+#define MD_UNWIND_SUPPORT \"config/alpha/osf5-unwind.h\""}]}