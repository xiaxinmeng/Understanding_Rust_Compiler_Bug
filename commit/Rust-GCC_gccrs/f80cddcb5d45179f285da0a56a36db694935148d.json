{"sha": "f80cddcb5d45179f285da0a56a36db694935148d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgwY2RkY2I1ZDQ1MTc5ZjI4NWRhMGE1NmEzNmRiNjk0OTM1MTQ4ZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-05-13T08:46:18Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-05-13T08:46:18Z"}, "message": "re PR ada/24880 (infinite loop on conversion of integer type with size clause)\n\n\tPR ada/24880\n\tPR ada/26635\n\t* utils.c (convert) <INTEGER_TYPE>: When converting an additive\n\texpression to an integral type with lower precision, use NOP_EXPR\n\tdirectly in a couple of special cases.\n\nFrom-SVN: r135257", "tree": {"sha": "d5e33cde32652206851dc8984dcaa621347d97ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5e33cde32652206851dc8984dcaa621347d97ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f80cddcb5d45179f285da0a56a36db694935148d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80cddcb5d45179f285da0a56a36db694935148d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f80cddcb5d45179f285da0a56a36db694935148d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f80cddcb5d45179f285da0a56a36db694935148d/comments", "author": null, "committer": null, "parents": [{"sha": "8beaca66e37f300d7ca91beae79c0f4eb341f760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8beaca66e37f300d7ca91beae79c0f4eb341f760", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8beaca66e37f300d7ca91beae79c0f4eb341f760"}], "stats": {"total": 78, "additions": 77, "deletions": 1}, "files": [{"sha": "cffae3bc3a71c5ceaf2cd4898489a038a6ba387d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f80cddcb5d45179f285da0a56a36db694935148d", "patch": "@@ -1,3 +1,11 @@\n+2008-05-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/24880\n+\tPR ada/26635\n+\t* utils.c (convert) <INTEGER_TYPE>: When converting an additive\n+\texpression to an integral type with lower precision, use NOP_EXPR\n+\tdirectly in a couple of special cases.\n+\n 2008-05-12  Samuel Tardieu  <sam@rfc1149.net>\n             Ed Schonberg <schonberg@adacore.com>\n "}, {"sha": "b4b38941ddbc1b17d63e84e572e7cb435e3aa9b9", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=f80cddcb5d45179f285da0a56a36db694935148d", "patch": "@@ -3627,7 +3627,7 @@ convert (tree type, tree expr)\n   if (TYPE_FAT_POINTER_P (type) && !TYPE_FAT_POINTER_P (etype))\n     return convert_to_fat_pointer (type, expr);\n \n-  /* If we're converting between two aggregate types that are mere\n+  /* If we are converting between two aggregate types that are mere\n      variants, just make a VIEW_CONVERT_EXPR.  */\n   else if (code == ecode\n \t   && AGGREGATE_TYPE_P (type)\n@@ -3662,6 +3662,30 @@ convert (tree type, tree expr)\n       /* ... fall through ... */\n \n     case ENUMERAL_TYPE:\n+      /* If we are converting an additive expression to an integer type\n+\t with lower precision, be wary of the optimization that can be\n+\t applied by convert_to_integer.  There are 2 problematic cases:\n+\t   - if the first operand was originally of a biased type,\n+\t     because we could be recursively called to convert it\n+\t     to an intermediate type and thus rematerialize the\n+\t     additive operator endlessly,\n+\t   - if the expression contains a placeholder, because an\n+\t     intermediate conversion that changes the sign could\n+\t     be inserted and thus introduce an artificial overflow\n+\t     at compile time when the placeholder is substituted.  */\n+      if (code == INTEGER_TYPE\n+\t  && ecode == INTEGER_TYPE\n+\t  && TYPE_PRECISION (type) < TYPE_PRECISION (etype)\n+\t  && (TREE_CODE (expr) == PLUS_EXPR || TREE_CODE (expr) == MINUS_EXPR))\n+\t{\n+\t  tree op0 = get_unwidened (TREE_OPERAND (expr, 0), type);\n+\n+\t  if ((TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n+\t       && TYPE_BIASED_REPRESENTATION_P (TREE_TYPE (op0)))\n+\t      || CONTAINS_PLACEHOLDER_P (expr))\n+\t    return build1 (NOP_EXPR, type, expr);\n+\t}\n+\n       return fold (convert_to_integer (type, expr));\n \n     case POINTER_TYPE:"}, {"sha": "e870fb4bac3b41019fa0bb381904e754a34a5e80", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f80cddcb5d45179f285da0a56a36db694935148d", "patch": "@@ -1,3 +1,8 @@\n+2008-05-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/discr7.adb: New test\n+\t* gnat.dg/conv_integer.adb: Likewise.\n+\n 2008-05-12  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.c-torture/compile/pr11832.c: XFAIL for mips and powerpc-linux,"}, {"sha": "7693da0775a2492509572f4092569b4115ee6166", "filename": "gcc/testsuite/gnat.dg/conv_integer.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Ftestsuite%2Fgnat.dg%2Fconv_integer.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Ftestsuite%2Fgnat.dg%2Fconv_integer.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fconv_integer.adb?ref=f80cddcb5d45179f285da0a56a36db694935148d", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+procedure Conv_Integer is\n+   S : constant := Integer'Size;\n+   type Regoff_T is range -1 .. 2 ** (S-1);\n+   for Regoff_T'Size use S;\n+   B : Integer;\n+   C : Regoff_T;\n+begin\n+   B := Integer (C);\n+end;"}, {"sha": "3bb61cb12b694b5cb5ce7a941b28b1ac522965a1", "filename": "gcc/testsuite/gnat.dg/discr7.adb", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f80cddcb5d45179f285da0a56a36db694935148d/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fdiscr7.adb?ref=f80cddcb5d45179f285da0a56a36db694935148d", "patch": "@@ -0,0 +1,27 @@\n+-- { dg-do compile }\n+\n+procedure Discr7 is\n+\n+  subtype Index is Natural range 0..5;\n+  type BitString is array(Index range <>) of Boolean;\n+  pragma Pack(BitString);\n+\n+  function Id (I : Integer) return Integer is\n+  begin\n+    return I;\n+  end;\n+\n+  type E(D : Index) is record\n+    C : BitString(1..D);\n+  end record;\n+\n+  subtype E0 is E(Id(0));\n+\n+  function F return E0 is\n+  begin\n+    return E'(D=>0, C=>(1..0=>FALSE));\n+  end;\n+\n+begin\n+  null;\n+end;"}]}