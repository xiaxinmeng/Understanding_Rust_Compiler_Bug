{"sha": "a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlNmVlMzhlNzA4ZWYyYmRlZjRkZmJiOTk0NzMzNDRiZDU2ZmEyZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:21:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:21:00Z"}, "message": "Remove global call sets: LRA\n\nlra_reg has an actual_call_used_reg_set field that is only used during\ninheritance.  This in turn required a special lra_create_live_ranges\npass for flag_ipa_ra to set up this field.  This patch instead makes\nthe inheritance code do its own live register tracking, using the\nsame ABI-mask-and-clobber-set pair as for IRA.\n\nTracking ABIs simplifies (and cheapens) the logic in lra-lives.c and\nmeans we no longer need a separate path for -fipa-ra.  It also means\nwe can remove TARGET_RETURN_CALL_WITH_MAX_CLOBBERS.\n\nThe patch also strengthens the sanity check in lra_assigns so that\nwe check that reg_renumber is consistent with the whole conflict set,\nnot just the call-clobbered registers.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (return_call_with_max_clobbers): Delete.\n\t* doc/tm.texi.in (TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): Delete.\n\t* doc/tm.texi: Regenerate.\n\t* config/aarch64/aarch64.c (aarch64_return_call_with_max_clobbers)\n\t(TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): Delete.\n\t* lra-int.h (lra_reg::actual_call_used_reg_set): Delete.\n\t(lra_reg::call_insn): Delete.\n\t* lra.c: Include function-abi.h.\n\t(initialize_lra_reg_info_element): Don't initialize the fields above.\n\t(lra): Use crtl->abi to test whether the current function needs to\n\tsave a register in the prologue.  Remove special pre-inheritance\n\tlra_create_live_ranges pass for flag_ipa_ra.\n\t* lra-assigns.c: Include function-abi.h\n\t(find_hard_regno_for_1): Use crtl->abi to test whether the current\n\tfunction needs to save a register in the prologue.\n\t(lra_assign): Assert that registers aren't allocated to a\n\tconflicting register, rather than checking only for overlaps\n\twith call_used_or_fixed_regs.  Do this even for flag_ipa_ra,\n\tand for registers that are not live across a call.\n\t* lra-constraints.c (last_call_for_abi): New variable.\n\t(full_and_partial_call_clobbers): Likewise.\n\t(setup_next_usage_insn): Remove the register from\n\tfull_and_partial_call_clobbers.\n\t(need_for_call_save_p): Use call_clobbered_in_region_p to test\n\twhether the register needs a caller save.\n\t(need_for_split_p): Use full_and_partial_reg_clobbers instead\n\tof call_used_or_fixed_regs.\n\t(inherit_in_ebb): Initialize and maintain last_call_for_abi and\n\tfull_and_partial_call_clobbers.\n\t* lra-lives.c (check_pseudos_live_through_calls): Replace\n\tlast_call_used_reg_set and call_insn arguments with an abi argument.\n\tRemove handling of lra_reg::call_insn.  Use function_abi::mode_clobbers\n\tas the set of conflicting registers.\n\t(calls_have_same_clobbers_p): Delete.\n\t(process_bb_lives): Track the ABI of the last call instead of an\n\tinsn/HARD_REG_SET pair.  Update calls to\n\tcheck_pseudos_live_through_calls.  Use eh_edge_abi to calculate\n\tthe set of registers that could be clobbered by an EH edge.\n\tInclude partially-clobbered as well as fully-clobbered registers.\n\t(lra_create_live_ranges_1): Don't initialize lra_reg::call_insn.\n\t* lra-remat.c: Include function-abi.h.\n\t(call_used_regs_arr_len, call_used_regs_arr): Delete.\n\t(set_bb_regs): Use insn_callee_abi to get the set of call-clobbered\n\tregisters and bitmap_view to combine them into dead_regs.\n\t(call_used_input_regno_present_p): Take a function_abi argument\n\tand use it to test whether a register is call-clobbered.\n\t(calculate_gen_cands): Use insn_callee_abi to get the ABI of the\n\tcall insn target.  Update tje call to call_used_input_regno_present_p.\n\t(do_remat): Likewise.\n\t(lra_remat): Remove the initialization of call_used_regs_arr_len\n\tand call_used_regs_arr.\n\nFrom-SVN: r276327", "tree": {"sha": "f7505539096aba2d8bb5a8204b91d5d1e299c13c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7505539096aba2d8bb5a8204b91d5d1e299c13c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5c64181d62bb816b8c2c91e251cee7e2b597f244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c64181d62bb816b8c2c91e251cee7e2b597f244", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c64181d62bb816b8c2c91e251cee7e2b597f244"}], "stats": {"total": 365, "additions": 160, "deletions": 205}, "files": [{"sha": "df3a2f657afed72f39bd160f1d468cb9167a3b62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -1,3 +1,57 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (return_call_with_max_clobbers): Delete.\n+\t* doc/tm.texi.in (TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): Delete.\n+\t* doc/tm.texi: Regenerate.\n+\t* config/aarch64/aarch64.c (aarch64_return_call_with_max_clobbers)\n+\t(TARGET_RETURN_CALL_WITH_MAX_CLOBBERS): Delete.\n+\t* lra-int.h (lra_reg::actual_call_used_reg_set): Delete.\n+\t(lra_reg::call_insn): Delete.\n+\t* lra.c: Include function-abi.h.\n+\t(initialize_lra_reg_info_element): Don't initialize the fields above.\n+\t(lra): Use crtl->abi to test whether the current function needs to\n+\tsave a register in the prologue.  Remove special pre-inheritance\n+\tlra_create_live_ranges pass for flag_ipa_ra.\n+\t* lra-assigns.c: Include function-abi.h\n+\t(find_hard_regno_for_1): Use crtl->abi to test whether the current\n+\tfunction needs to save a register in the prologue.\n+\t(lra_assign): Assert that registers aren't allocated to a\n+\tconflicting register, rather than checking only for overlaps\n+\twith call_used_or_fixed_regs.  Do this even for flag_ipa_ra,\n+\tand for registers that are not live across a call.\n+\t* lra-constraints.c (last_call_for_abi): New variable.\n+\t(full_and_partial_call_clobbers): Likewise.\n+\t(setup_next_usage_insn): Remove the register from\n+\tfull_and_partial_call_clobbers.\n+\t(need_for_call_save_p): Use call_clobbered_in_region_p to test\n+\twhether the register needs a caller save.\n+\t(need_for_split_p): Use full_and_partial_reg_clobbers instead\n+\tof call_used_or_fixed_regs.\n+\t(inherit_in_ebb): Initialize and maintain last_call_for_abi and\n+\tfull_and_partial_call_clobbers.\n+\t* lra-lives.c (check_pseudos_live_through_calls): Replace\n+\tlast_call_used_reg_set and call_insn arguments with an abi argument.\n+\tRemove handling of lra_reg::call_insn.  Use function_abi::mode_clobbers\n+\tas the set of conflicting registers.\n+\t(calls_have_same_clobbers_p): Delete.\n+\t(process_bb_lives): Track the ABI of the last call instead of an\n+\tinsn/HARD_REG_SET pair.  Update calls to\n+\tcheck_pseudos_live_through_calls.  Use eh_edge_abi to calculate\n+\tthe set of registers that could be clobbered by an EH edge.\n+\tInclude partially-clobbered as well as fully-clobbered registers.\n+\t(lra_create_live_ranges_1): Don't initialize lra_reg::call_insn.\n+\t* lra-remat.c: Include function-abi.h.\n+\t(call_used_regs_arr_len, call_used_regs_arr): Delete.\n+\t(set_bb_regs): Use insn_callee_abi to get the set of call-clobbered\n+\tregisters and bitmap_view to combine them into dead_regs.\n+\t(call_used_input_regno_present_p): Take a function_abi argument\n+\tand use it to test whether a register is call-clobbered.\n+\t(calculate_gen_cands): Use insn_callee_abi to get the ABI of the\n+\tcall insn target.  Update tje call to call_used_input_regno_present_p.\n+\t(do_remat): Likewise.\n+\t(lra_remat): Remove the initialization of call_used_regs_arr_len\n+\tand call_used_regs_arr.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* loop-iv.c: Include regs.h and function-abi.h."}, {"sha": "2d4cd3794ce5bed75f0a692b42a2c67793d35c5c", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -1926,19 +1926,6 @@ aarch64_hard_regno_call_part_clobbered (unsigned int abi_id,\n   return false;\n }\n \n-/* Implement TARGET_RETURN_CALL_WITH_MAX_CLOBBERS.  */\n-\n-rtx_insn *\n-aarch64_return_call_with_max_clobbers (rtx_insn *call_1, rtx_insn *call_2)\n-{\n-  gcc_assert (CALL_P (call_1) && CALL_P (call_2));\n-\n-  if (!aarch64_simd_call_p (call_1) || aarch64_simd_call_p (call_2))\n-    return call_1;\n-  else\n-    return call_2;\n-}\n-\n /* Implement REGMODE_NATURAL_SIZE.  */\n poly_uint64\n aarch64_regmode_natural_size (machine_mode mode)\n@@ -21002,10 +20989,6 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_INSN_CALLEE_ABI\n #define TARGET_INSN_CALLEE_ABI aarch64_insn_callee_abi\n \n-#undef TARGET_RETURN_CALL_WITH_MAX_CLOBBERS\n-#define TARGET_RETURN_CALL_WITH_MAX_CLOBBERS \\\n-  aarch64_return_call_with_max_clobbers\n-\n #undef TARGET_CONSTANT_ALIGNMENT\n #define TARGET_CONSTANT_ALIGNMENT aarch64_constant_alignment\n "}, {"sha": "915e961220826fb8d3a564328ce7c5d1fa9b3b06", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -1941,18 +1941,6 @@ The default implementation returns false, which is correct\n for targets that don't have partly call-clobbered registers.\n @end deftypefn\n \n-@deftypefn {Target Hook} {rtx_insn *} TARGET_RETURN_CALL_WITH_MAX_CLOBBERS (rtx_insn *@var{call_1}, rtx_insn *@var{call_2})\n-This hook returns a pointer to the call that partially clobbers the\n-most registers.  If a platform supports multiple ABIs where the registers\n-that are partially clobbered may vary, this function compares two\n-calls and returns a pointer to the one that clobbers the most registers.\n-If both calls clobber the same registers, @var{call_1} must be returned.\n-\n-The registers clobbered in different ABIs must be a proper subset or\n-superset of all other ABIs.  @var{call_1} must always be a call insn,\n-call_2 may be NULL or a call insn.\n-@end deftypefn\n-\n @deftypefn {Target Hook} {const char *} TARGET_GET_MULTILIB_ABI_NAME (void)\n This hook returns name of multilib ABI name.\n @end deftypefn"}, {"sha": "ac0f0494992b6c94649080451fec4b3af6c52820", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -1718,8 +1718,6 @@ must be defined.  Modern ports should define @code{CALL_REALLY_USED_REGISTERS}.\n @cindex call-saved register\n @hook TARGET_HARD_REGNO_CALL_PART_CLOBBERED\n \n-@hook TARGET_RETURN_CALL_WITH_MAX_CLOBBERS\n-\n @hook TARGET_GET_MULTILIB_ABI_NAME\n \n @findex fixed_regs"}, {"sha": "e14a246c0d232000a75195e680c3ce13f9b6d628", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -94,6 +94,7 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"params.h\"\n #include \"lra.h\"\n #include \"lra-int.h\"\n+#include \"function-abi.h\"\n \n /* Current iteration number of the pass and current iteration number\n    of the pass after the latest spill pass when any former reload\n@@ -654,7 +655,7 @@ find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,\n \t  for (j = 0;\n \t       j < hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno));\n \t       j++)\n-\t    if (! TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno + j)\n+\t    if (! crtl->abi->clobbers_full_reg_p (hard_regno + j)\n \t\t&& ! df_regs_ever_live_p (hard_regno + j))\n \t      /* It needs save restore.\t */\n \t      hard_regno_costs[hard_regno]\n@@ -1634,14 +1635,14 @@ lra_assign (bool &fails_p)\n   bitmap_initialize (&all_spilled_pseudos, &reg_obstack);\n   create_live_range_start_chains ();\n   setup_live_pseudos_and_spill_after_risky_transforms (&all_spilled_pseudos);\n-  if (! lra_asm_error_p && flag_checking && !flag_ipa_ra)\n+  if (! lra_asm_error_p && flag_checking)\n     /* Check correctness of allocation for call-crossed pseudos but\n        only when there are no asm errors as in the case of errors the\n        asm is removed and it can result in incorrect allocation.  */\n     for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-      if (lra_reg_info[i].nrefs != 0 && reg_renumber[i] >= 0\n-\t  && lra_reg_info[i].call_insn\n-\t  && overlaps_hard_reg_set_p (call_used_or_fixed_regs,\n+      if (lra_reg_info[i].nrefs != 0\n+\t  && reg_renumber[i] >= 0\n+\t  && overlaps_hard_reg_set_p (lra_reg_info[i].conflict_hard_regs,\n \t\t\t\t      PSEUDO_REGNO_MODE (i), reg_renumber[i]))\n \tgcc_unreachable ();\n   /* Setup insns to process on the next constraint pass.  */"}, {"sha": "0db6d3151cdcf213e8a101a5909604a8a314db14", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -5147,6 +5147,14 @@ static int reloads_num;\n /* Number of calls passed so far in current EBB.  */\n static int calls_num;\n \n+/* Index ID is the CALLS_NUM associated the last call we saw with\n+   ABI identifier ID.  */\n+static int last_call_for_abi[NUM_ABI_IDS];\n+\n+/* Which registers have been fully or partially clobbered by a call\n+   since they were last used.  */\n+static HARD_REG_SET full_and_partial_call_clobbers;\n+\n /* Current reload pseudo check for validity of elements in\n    USAGE_INSNS.\t */\n static int curr_usage_insns_check;\n@@ -5190,6 +5198,10 @@ setup_next_usage_insn (int regno, rtx insn, int reloads_num, bool after_p)\n   usage_insns[regno].reloads_num = reloads_num;\n   usage_insns[regno].calls_num = calls_num;\n   usage_insns[regno].after_p = after_p;\n+  if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)\n+    remove_from_hard_reg_set (&full_and_partial_call_clobbers,\n+\t\t\t      PSEUDO_REGNO_MODE (regno),\n+\t\t\t      reg_renumber[regno]);\n }\n \n /* The function is used to form list REGNO usages which consists of\n@@ -5435,17 +5447,19 @@ static inline bool\n need_for_call_save_p (int regno)\n {\n   lra_assert (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0);\n-  return (usage_insns[regno].calls_num < calls_num\n-\t  && (overlaps_hard_reg_set_p\n-\t      ((flag_ipa_ra &&\n-\t\t! hard_reg_set_empty_p (lra_reg_info[regno].actual_call_used_reg_set))\n-\t       ? lra_reg_info[regno].actual_call_used_reg_set\n-\t       : call_used_or_fixed_regs,\n-\t       PSEUDO_REGNO_MODE (regno), reg_renumber[regno])\n-\t      || (targetm.hard_regno_call_part_clobbered\n-\t\t  (lra_reg_info[regno].call_insn\n-\t\t   ? insn_callee_abi (lra_reg_info[regno].call_insn).id () : 0,\n-\t\t   reg_renumber[regno], PSEUDO_REGNO_MODE (regno)))));\n+  if (usage_insns[regno].calls_num < calls_num)\n+    {\n+      unsigned int abis = 0;\n+      for (unsigned int i = 0; i < NUM_ABI_IDS; ++i)\n+\tif (last_call_for_abi[i] > usage_insns[regno].calls_num)\n+\t  abis |= 1 << i;\n+      gcc_assert (abis);\n+      if (call_clobbered_in_region_p (abis, full_and_partial_call_clobbers,\n+\t\t\t\t      PSEUDO_REGNO_MODE (regno),\n+\t\t\t\t      reg_renumber[regno]))\n+\treturn true;\n+    }\n+  return false;\n }\n \n /* Global registers occurring in the current EBB.  */\n@@ -5485,8 +5499,7 @@ need_for_split_p (HARD_REG_SET potential_reload_hard_regs, int regno)\n \t      true) the assign pass assumes that all pseudos living\n \t      through calls are assigned to call saved hard regs.  */\n \t   && (regno >= FIRST_PSEUDO_REGISTER\n-\t       || ! TEST_HARD_REG_BIT (call_used_or_fixed_regs, regno)\n-\t       || usage_insns[regno].calls_num == calls_num)\n+\t       || !TEST_HARD_REG_BIT (full_and_partial_call_clobbers, regno))\n \t   /* We need at least 2 reloads to make pseudo splitting\n \t      profitable.  We should provide hard regno splitting in\n \t      any case to solve 1st insn scheduling problem when\n@@ -6238,6 +6251,9 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n   curr_usage_insns_check++;\n   clear_invariants ();\n   reloads_num = calls_num = 0;\n+  for (unsigned int i = 0; i < NUM_ABI_IDS; ++i)\n+    last_call_for_abi[i] = 0;\n+  CLEAR_HARD_REG_SET (full_and_partial_call_clobbers);\n   bitmap_clear (&check_only_regs);\n   bitmap_clear (&invalid_invariant_regs);\n   last_processed_bb = NULL;\n@@ -6451,6 +6467,10 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t      int regno, hard_regno;\n \n \t      calls_num++;\n+\t      function_abi callee_abi = insn_callee_abi (curr_insn);\n+\t      last_call_for_abi[callee_abi.id ()] = calls_num;\n+\t      full_and_partial_call_clobbers\n+\t\t|= callee_abi.full_and_partial_reg_clobbers ();\n \t      if ((cheap = find_reg_note (curr_insn,\n \t\t\t\t\t  REG_RETURNED, NULL_RTX)) != NULL_RTX\n \t\t  && ((cheap = XEXP (cheap, 0)), true)\n@@ -6460,7 +6480,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t  /* If there are pending saves/restores, the\n \t\t     optimization is not worth.\t */\n \t\t  && usage_insns[regno].calls_num == calls_num - 1\n-\t\t  && TEST_HARD_REG_BIT (call_used_or_fixed_regs, hard_regno))\n+\t\t  && callee_abi.clobbers_reg_p (GET_MODE (cheap), hard_regno))\n \t\t{\n \t\t  /* Restore the pseudo from the call result as\n \t\t     REG_RETURNED note says that the pseudo value is\n@@ -6483,6 +6503,9 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n \t\t      /* We don't need to save/restore of the pseudo from\n \t\t\t this call.\t */\n \t\t      usage_insns[regno].calls_num = calls_num;\n+\t\t      remove_from_hard_reg_set\n+\t\t\t(&full_and_partial_call_clobbers,\n+\t\t\t GET_MODE (cheap), hard_regno);\n \t\t      bitmap_set_bit (&check_only_regs, regno);\n \t\t    }\n \t\t}"}, {"sha": "7f2bbbe4d33b2d81116d300ff8df47acc16166fa", "filename": "gcc/lra-int.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -73,10 +73,6 @@ class lra_reg\n   /* The following fields are defined only for pseudos.\t */\n   /* Hard registers with which the pseudo conflicts.  */\n   HARD_REG_SET conflict_hard_regs;\n-  /* Call used registers with which the pseudo conflicts, taking into account\n-     the registers used by functions called from calls which cross the\n-     pseudo.  */\n-  HARD_REG_SET actual_call_used_reg_set;\n   /* We assign hard registers to reload pseudos which can occur in few\n      places.  So two hard register preferences are enough for them.\n      The following fields define the preferred hard registers.\tIf\n@@ -104,8 +100,6 @@ class lra_reg\n   int val;\n   /* Offset from relative eliminate register to pesudo reg.  */\n   poly_int64 offset;\n-  /* Call instruction, if any, that may affect this psuedo reg.  */\n-  rtx_insn *call_insn;\n   /* These members are set up in lra-lives.c and updated in\n      lra-coalesce.c.  */\n   /* The biggest size mode in which each pseudo reg is referred in"}, {"sha": "a6cd7bba36b18fb5a10ed93be6265e362a2fbd50", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 24, "deletions": 86, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -576,40 +576,21 @@ lra_setup_reload_pseudo_preferenced_hard_reg (int regno,\n     }\n }\n \n-/* Check that REGNO living through calls and setjumps, set up conflict\n-   regs using LAST_CALL_USED_REG_SET, and clear corresponding bits in\n-   PSEUDOS_LIVE_THROUGH_CALLS and PSEUDOS_LIVE_THROUGH_SETJUMPS.\n-   CALL_INSN is a call that is representative of all calls in the region\n-   described by the PSEUDOS_LIVE_THROUGH_* sets, in terms of the registers\n-   that it preserves and clobbers.  */\n+/* Check whether REGNO lives through calls and setjmps and clear\n+   the corresponding bits in PSEUDOS_LIVE_THROUGH_CALLS and\n+   PSEUDOS_LIVE_THROUGH_SETJUMPS.  All calls in the region described\n+   by PSEUDOS_LIVE_THROUGH_CALLS have the given ABI.  */\n \n static inline void\n-check_pseudos_live_through_calls (int regno,\n-\t\t\t\t  HARD_REG_SET last_call_used_reg_set,\n-\t\t\t\t  rtx_insn *call_insn)\n+check_pseudos_live_through_calls (int regno, const function_abi &abi)\n {\n-  int hr;\n-  rtx_insn *old_call_insn;\n-\n   if (! sparseset_bit_p (pseudos_live_through_calls, regno))\n     return;\n \n-  function_abi callee_abi = insn_callee_abi (call_insn);\n-  old_call_insn = lra_reg_info[regno].call_insn;\n-  if (!old_call_insn\n-      || (targetm.return_call_with_max_clobbers\n-\t  && targetm.return_call_with_max_clobbers (old_call_insn, call_insn)\n-\t     == call_insn))\n-    lra_reg_info[regno].call_insn = call_insn;\n+  machine_mode mode = PSEUDO_REGNO_MODE (regno);\n \n   sparseset_clear_bit (pseudos_live_through_calls, regno);\n-  lra_reg_info[regno].conflict_hard_regs |= last_call_used_reg_set;\n-\n-  for (hr = 0; HARD_REGISTER_NUM_P (hr); hr++)\n-    if (targetm.hard_regno_call_part_clobbered (callee_abi.id (), hr,\n-\t\t\t\t\t\tPSEUDO_REGNO_MODE (regno)))\n-      add_to_hard_reg_set (&lra_reg_info[regno].conflict_hard_regs,\n-\t\t\t   PSEUDO_REGNO_MODE (regno), hr);\n+  lra_reg_info[regno].conflict_hard_regs |= abi.mode_clobbers (mode);\n   if (! sparseset_bit_p (pseudos_live_through_setjumps, regno))\n     return;\n   sparseset_clear_bit (pseudos_live_through_setjumps, regno);\n@@ -630,19 +611,6 @@ reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)\n \t     && TEST_BIT (reg->early_clobber_alts, n_alt)));\n }\n \n-/* Return true if call instructions CALL1 and CALL2 use ABIs that\n-   preserve the same set of registers.  */\n-\n-static bool\n-calls_have_same_clobbers_p (rtx_insn *call1, rtx_insn *call2)\n-{\n-  if (!targetm.return_call_with_max_clobbers)\n-    return false;\n-\n-  return (targetm.return_call_with_max_clobbers (call1, call2) == call1\n-          && targetm.return_call_with_max_clobbers (call2, call1) == call2);\n-}\n-\n /* Process insns of the basic block BB to update pseudo live ranges,\n    pseudo hard register conflicts, and insn notes.  We do it on\n    backward scan of BB insns.  CURR_POINT is the program point where\n@@ -662,15 +630,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n   rtx_insn *next;\n   rtx link, *link_loc;\n   bool need_curr_point_incr;\n-  HARD_REG_SET last_call_used_reg_set;\n-  rtx_insn *call_insn = NULL;\n-  rtx_insn *last_call_insn = NULL;\n+  /* Only has a meaningful value once we've seen a call.  */\n+  function_abi last_call_abi = default_function_abi;\n \n   reg_live_out = df_get_live_out (bb);\n   sparseset_clear (pseudos_live);\n   sparseset_clear (pseudos_live_through_calls);\n   sparseset_clear (pseudos_live_through_setjumps);\n-  CLEAR_HARD_REG_SET (last_call_used_reg_set);\n   REG_SET_TO_HARD_REG_SET (hard_regs_live, reg_live_out);\n   hard_regs_live &= ~eliminable_regset;\n   EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n@@ -876,9 +842,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    {\n \t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n \t      mark_regno_live (reg->regno, reg->biggest_mode);\n-\t      check_pseudos_live_through_calls (reg->regno,\n-\t\t\t\t\t\tlast_call_used_reg_set,\n-\t\t\t\t\t\tcall_insn);\n+\t      /* ??? Should be a no-op for unused registers.  */\n+\t      check_pseudos_live_through_calls (reg->regno, last_call_abi);\n \t    }\n \n \t  if (!HARD_REGISTER_NUM_P (reg->regno))\n@@ -927,37 +892,13 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \n       if (call_p)\n \t{\n-\t  call_insn = curr_insn;\n-\t  if (! flag_ipa_ra && ! targetm.return_call_with_max_clobbers)\n-\t    last_call_used_reg_set = call_used_or_fixed_regs;\n-\t  else\n-\t    {\n-\t      HARD_REG_SET this_call_used_reg_set\n-\t\t= insn_callee_abi (curr_insn).full_reg_clobbers ();\n-\t      /* ??? This preserves traditional behavior; it might not\n-\t\t be needed.  */\n-\t      this_call_used_reg_set |= fixed_reg_set;\n-\n-\t      bool flush = (! hard_reg_set_empty_p (last_call_used_reg_set)\n-\t\t\t    && (last_call_used_reg_set\n-\t\t\t\t!= this_call_used_reg_set))\n-\t\t\t   || (last_call_insn && ! calls_have_same_clobbers_p\n-\t\t\t\t\t\t     (call_insn,\n-\t\t\t\t\t\t      last_call_insn));\n-\n-\t      EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n-\t\t{\n-\t\t  lra_reg_info[j].actual_call_used_reg_set\n-\t\t    |= this_call_used_reg_set;\n+\t  function_abi call_abi = insn_callee_abi (curr_insn);\n \n-\t\t  if (flush)\n-\t\t    check_pseudos_live_through_calls (j,\n-\t\t\t\t\t\t      last_call_used_reg_set,\n-\t\t\t\t\t\t      last_call_insn);\n-\t\t}\n-\t      last_call_used_reg_set = this_call_used_reg_set;\n-\t      last_call_insn = call_insn;\n-\t    }\n+\t  if (last_call_abi != call_abi)\n+\t    EXECUTE_IF_SET_IN_SPARSESET (pseudos_live, j)\n+\t      check_pseudos_live_through_calls (j, last_call_abi);\n+\n+\t  last_call_abi = call_abi;\n \n \t  sparseset_ior (pseudos_live_through_calls,\n \t\t\t pseudos_live_through_calls, pseudos_live);\n@@ -995,9 +936,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t    if (reg->type == OP_IN)\n \t      update_pseudo_point (reg->regno, curr_point, USE_POINT);\n \t    mark_regno_live (reg->regno, reg->biggest_mode);\n-\t    check_pseudos_live_through_calls (reg->regno,\n-\t\t\t\t\t      last_call_used_reg_set,\n-\t\t\t\t\t      call_insn);\n+\t    check_pseudos_live_through_calls (reg->regno, last_call_abi);\n \t  }\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n@@ -1091,10 +1030,10 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       }\n \n   /* Pseudos can't go in stack regs at the start of a basic block that\n-     is reached by an abnormal edge. Likewise for call clobbered regs,\n-     because caller-save, fixup_abnormal_edges and possibly the table\n-     driven EH machinery are not quite ready to handle such pseudos\n-     live across such edges.  */\n+     is reached by an abnormal edge.  Likewise for registers that are at\n+     least partly call clobbered, because caller-save, fixup_abnormal_edges\n+     and possibly the table driven EH machinery are not quite ready to\n+     handle such pseudos live across such edges.  */\n   if (bb_has_abnormal_pred (bb))\n     {\n #ifdef STACK_REGS\n@@ -1109,7 +1048,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       if (!cfun->has_nonlocal_label\n \t  && has_abnormal_call_or_eh_pred_edge_p (bb))\n \tfor (px = 0; HARD_REGISTER_NUM_P (px); px++)\n-\t  if (call_used_or_fixed_reg_p (px)\n+\t  if (eh_edge_abi.clobbers_at_least_part_of_reg_p (px)\n #ifdef REAL_PIC_OFFSET_TABLE_REGNUM\n \t      /* We should create a conflict of PIC pseudo with PIC\n \t\t hard reg as PIC hard reg can have a wrong value after\n@@ -1166,7 +1105,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       if (sparseset_cardinality (pseudos_live_through_calls) == 0)\n \tbreak;\n       if (sparseset_bit_p (pseudos_live_through_calls, j))\n-\tcheck_pseudos_live_through_calls (j, last_call_used_reg_set, call_insn);\n+\tcheck_pseudos_live_through_calls (j, last_call_abi);\n     }\n \n   for (i = 0; HARD_REGISTER_NUM_P (i); ++i)\n@@ -1400,7 +1339,6 @@ lra_create_live_ranges_1 (bool all_p, bool dead_insn_p)\n \tlra_reg_info[i].biggest_mode = GET_MODE (regno_reg_rtx[i]);\n       else\n \tlra_reg_info[i].biggest_mode = VOIDmode;\n-      lra_reg_info[i].call_insn = NULL;\n       if (!HARD_REGISTER_NUM_P (i)\n \t  && lra_reg_info[i].nrefs != 0)\n \t{"}, {"sha": "ee7ebf6e94990be6dd8248823cac95e52fd53ff4", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -65,16 +65,11 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"recog.h\"\n #include \"lra.h\"\n #include \"lra-int.h\"\n+#include \"function-abi.h\"\n \n /* Number of candidates for rematerialization.  */\n static unsigned int cands_num;\n \n-/* The following is used for representation of call_used_or_fixed_regs in\n-   form array whose elements are hard register numbers with nonzero bit\n-   in CALL_USED_OR_FIXED_REGS. */\n-static int call_used_regs_arr_len;\n-static int call_used_regs_arr[FIRST_PSEUDO_REGISTER];\n-\n /* Bitmap used for different calculations.  */\n static bitmap_head temp_bitmap;\n \n@@ -633,9 +628,12 @@ set_bb_regs (basic_block bb, rtx_insn *insn)\n \tbitmap_set_bit (&subreg_regs, regno);\n     }\n   if (CALL_P (insn))\n-    for (int i = 0; i < call_used_regs_arr_len; i++)\n-      bitmap_set_bit (&get_remat_bb_data (bb)->dead_regs,\n-\t\t      call_used_regs_arr[i]);\n+    {\n+      /* Partially-clobbered registers might still be live.  */\n+      HARD_REG_SET clobbers = insn_callee_abi (insn).full_reg_clobbers ();\n+      bitmap_ior_into (&get_remat_bb_data (bb)->dead_regs,\n+\t\t       bitmap_view<HARD_REG_SET> (clobbers));\n+    }\n }\n \n /* Calculate changed_regs and dead_regs for each BB.  */\n@@ -698,7 +696,7 @@ reg_overlap_for_remat_p (lra_insn_reg *reg, rtx_insn *insn)\n \n /* Return true if a call used register is an input operand of INSN.  */\n static bool\n-call_used_input_regno_present_p (rtx_insn *insn)\n+call_used_input_regno_present_p (const function_abi &abi, rtx_insn *insn)\n {\n   int iter;\n   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n@@ -709,8 +707,9 @@ call_used_input_regno_present_p (rtx_insn *insn)\n     for (reg = (iter == 0 ? id->regs : static_id->hard_regs);\n \t reg != NULL;\n \t reg = reg->next)\n-      if (reg->type == OP_IN && reg->regno < FIRST_PSEUDO_REGISTER\n-\t  && TEST_HARD_REG_BIT (call_used_or_fixed_regs, reg->regno))\n+      if (reg->type == OP_IN\n+\t  && reg->regno < FIRST_PSEUDO_REGISTER\n+\t  && abi.clobbers_reg_p (reg->biggest_mode, reg->regno))\n \treturn true;\n   return false;\n }\n@@ -799,18 +798,21 @@ calculate_gen_cands (void)\n \t\t    }\n \t    \n \t    if (CALL_P (insn))\n-\t      EXECUTE_IF_SET_IN_BITMAP (gen_insns, 0, uid, bi)\n-\t\t{\n-\t\t  rtx_insn *insn2 = lra_insn_recog_data[uid]->insn;\n+\t      {\n+\t\tfunction_abi callee_abi = insn_callee_abi (insn);\n+\t\tEXECUTE_IF_SET_IN_BITMAP (gen_insns, 0, uid, bi)\n+\t\t  {\n+\t\t    rtx_insn *insn2 = lra_insn_recog_data[uid]->insn;\n \t\t  \n-\t\t  cand = insn_to_cand[INSN_UID (insn2)];\n-\t\t  gcc_assert (cand != NULL);\n-\t\t  if (call_used_input_regno_present_p (insn2))\n-\t\t    {\n-\t\t      bitmap_clear_bit (gen_cands, cand->index);\n-\t\t      bitmap_set_bit (&temp_bitmap, uid);\n-\t\t    }\n-\t\t}\n+\t\t    cand = insn_to_cand[INSN_UID (insn2)];\n+\t\t    gcc_assert (cand != NULL);\n+\t\t    if (call_used_input_regno_present_p (callee_abi, insn2))\n+\t\t      {\n+\t\t\tbitmap_clear_bit (gen_cands, cand->index);\n+\t\t\tbitmap_set_bit (&temp_bitmap, uid);\n+\t\t      }\n+\t\t  }\n+\t      }\n \t    bitmap_and_compl_into (gen_insns, &temp_bitmap);\n \n \t    cand = insn_to_cand[INSN_UID (insn)];\n@@ -1205,13 +1207,16 @@ do_remat (void)\n \t\t  }\n \n \t  if (CALL_P (insn))\n-\t    EXECUTE_IF_SET_IN_BITMAP (avail_cands, 0, cid, bi)\n-\t      {\n-\t\tcand = all_cands[cid];\n+\t    {\n+\t      function_abi callee_abi = insn_callee_abi (insn);\n+\t      EXECUTE_IF_SET_IN_BITMAP (avail_cands, 0, cid, bi)\n+\t\t{\n+\t\t  cand = all_cands[cid];\n \t\t\n-\t\tif (call_used_input_regno_present_p (cand->insn))\n-\t\t  bitmap_set_bit (&temp_bitmap, cand->index);\n-\t      }\n+\t\t  if (call_used_input_regno_present_p (callee_abi, cand->insn))\n+\t\t    bitmap_set_bit (&temp_bitmap, cand->index);\n+\t\t}\n+\t    }\n \n \t  bitmap_and_compl_into (avail_cands, &temp_bitmap);\n \n@@ -1307,10 +1312,6 @@ lra_remat (void)\n   insn_to_cand_activation = XCNEWVEC (cand_t, get_max_uid ());\n   regno_cands = XCNEWVEC (cand_t, max_regno);\n   all_cands.create (8000);\n-  call_used_regs_arr_len = 0;\n-  for (int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (call_used_or_fixed_reg_p (i))\n-      call_used_regs_arr[call_used_regs_arr_len++] = i;\n   initiate_cand_table ();\n   create_remat_bb_data ();\n   bitmap_initialize (&temp_bitmap, &reg_obstack);"}, {"sha": "a6e6a8ddef68145e792959e761fad8184ba79fe5", "filename": "gcc/lra.c", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -121,6 +121,7 @@ along with GCC; see the file COPYING3.\tIf not see\n #include \"lra.h\"\n #include \"lra-int.h\"\n #include \"print-rtl.h\"\n+#include \"function-abi.h\"\n \n /* Dump bitmap SET with TITLE and BB INDEX.  */\n void\n@@ -1323,7 +1324,6 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].no_stack_p = false;\n #endif\n   CLEAR_HARD_REG_SET (lra_reg_info[i].conflict_hard_regs);\n-  CLEAR_HARD_REG_SET (lra_reg_info[i].actual_call_used_reg_set);\n   lra_reg_info[i].preferred_hard_regno1 = -1;\n   lra_reg_info[i].preferred_hard_regno2 = -1;\n   lra_reg_info[i].preferred_hard_regno_profit1 = 0;\n@@ -1336,7 +1336,6 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].val = get_new_reg_value ();\n   lra_reg_info[i].offset = 0;\n   lra_reg_info[i].copies = NULL;\n-  lra_reg_info[i].call_insn = NULL;\n }\n \n /* Initialize common reg info and copies.  */\n@@ -2420,7 +2419,9 @@ lra (FILE *f)\n \n   if (crtl->saves_all_registers)\n     for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (!call_used_or_fixed_reg_p (i) && !fixed_regs[i] && !LOCAL_REGNO (i))\n+      if (!crtl->abi->clobbers_full_reg_p (i)\n+\t  && !fixed_regs[i]\n+\t  && !LOCAL_REGNO (i))\n \tdf_set_regs_ever_live (i, true);\n \n   /* We don't DF from now and avoid its using because it is to\n@@ -2478,19 +2479,7 @@ lra (FILE *f)\n \t    }\n \t  /* Do inheritance only for regular algorithms.  */\n \t  if (! lra_simple_p)\n-\t    {\n-\t      if (flag_ipa_ra)\n-\t\t{\n-\t\t  if (live_p)\n-\t\t    lra_clear_live_ranges ();\n-\t\t  /* As a side-effect of lra_create_live_ranges, we calculate\n-\t\t     actual_call_used_reg_set,  which is needed during\n-\t\t     lra_inheritance.  */\n-\t\t  lra_create_live_ranges (true, true);\n-\t\t  live_p = true;\n-\t\t}\n-\t      lra_inheritance ();\n-\t    }\n+\t    lra_inheritance ();\n \t  if (live_p)\n \t    lra_clear_live_ranges ();\n \t  bool fails_p;"}, {"sha": "1f011edf88bb6700b1f25f1058b19cc30e67c271", "filename": "gcc/target.def", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=a1e6ee38e708ef2bdef4dfbb99473344bd56fa2f", "patch": "@@ -5836,20 +5836,6 @@ for targets that don't have partly call-clobbered registers.\",\n  bool, (unsigned int abi_id, unsigned int regno, machine_mode mode),\n  hook_bool_uint_uint_mode_false)\n \n-DEFHOOK\n-(return_call_with_max_clobbers,\n- \"This hook returns a pointer to the call that partially clobbers the\\n\\\n-most registers.  If a platform supports multiple ABIs where the registers\\n\\\n-that are partially clobbered may vary, this function compares two\\n\\\n-calls and returns a pointer to the one that clobbers the most registers.\\n\\\n-If both calls clobber the same registers, @var{call_1} must be returned.\\n\\\n-\\n\\\n-The registers clobbered in different ABIs must be a proper subset or\\n\\\n-superset of all other ABIs.  @var{call_1} must always be a call insn,\\n\\\n-call_2 may be NULL or a call insn.\",\n- rtx_insn *, (rtx_insn *call_1, rtx_insn *call_2),\n- NULL)\n-\n DEFHOOK\n (get_multilib_abi_name,\n  \"This hook returns name of multilib ABI name.\","}]}