{"sha": "f258e38b1de989f3d1f9a9dddceedaa7e677e02b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI1OGUzOGIxZGU5ODlmM2QxZjlhOWRkZGNlZWRhYTdlNjc3ZTAyYg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-03-21T19:31:29Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-03-21T19:31:29Z"}, "message": "expmed.c (choose_mult_variant): Pass MULT_COST as argument instead of using register multiplication cost.\n\n\t* expmed.c (choose_mult_variant): Pass MULT_COST as argument instead\n\tof using register multiplication cost.\n\t(expand_mult): Adapt choose_mult_variant call.\n\t(expand_mult_highpart): Call choose_mult_variant with WIDER_MODE\n\tof MODE; pass appropriate cost bound.  Adjust result when\n\tperforming signed multiplication by a negative constant.\n\tDon't use intermediate modes larger than word_mode.\n\nFrom-SVN: r79792", "tree": {"sha": "f37c27cd8555fafcd957936a5edb99a7ea5fe53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37c27cd8555fafcd957936a5edb99a7ea5fe53c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f258e38b1de989f3d1f9a9dddceedaa7e677e02b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f258e38b1de989f3d1f9a9dddceedaa7e677e02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f258e38b1de989f3d1f9a9dddceedaa7e677e02b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f258e38b1de989f3d1f9a9dddceedaa7e677e02b/comments", "author": null, "committer": null, "parents": [{"sha": "4d03807362650c1b8d979d8146f602dcaeb532ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d03807362650c1b8d979d8146f602dcaeb532ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d03807362650c1b8d979d8146f602dcaeb532ce"}], "stats": {"total": 81, "additions": 58, "deletions": 23}, "files": [{"sha": "eccd96c67d360393b5362f1a691accb18aa9b02b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f258e38b1de989f3d1f9a9dddceedaa7e677e02b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f258e38b1de989f3d1f9a9dddceedaa7e677e02b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f258e38b1de989f3d1f9a9dddceedaa7e677e02b", "patch": "@@ -1,3 +1,13 @@\n+2004-03-21  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* expmed.c (choose_mult_variant): Pass MULT_COST as argument instead\n+\tof using register multiplication cost.\n+\t(expand_mult): Adapt choose_mult_variant call.\n+\t(expand_mult_highpart): Call choose_mult_variant with WIDER_MODE\n+\tof MODE; pass appropriate cost bound.  Adjust result when\n+\tperforming signed multiplication by a negative constant.\n+\tDon't use intermediate modes larger than word_mode.\n+\n 2004-03-21  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* alias.c (get_alias_set): Remove handling of PLACEHOLDER_EXPR."}, {"sha": "208e947ea6bfa6ebf3d85741d74d28b1371c87e9", "filename": "gcc/expmed.c", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f258e38b1de989f3d1f9a9dddceedaa7e677e02b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f258e38b1de989f3d1f9a9dddceedaa7e677e02b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f258e38b1de989f3d1f9a9dddceedaa7e677e02b", "patch": "@@ -2157,7 +2157,7 @@ enum mult_variant {basic_variant, negate_variant, add_variant};\n \n static void synth_mult (struct algorithm *, unsigned HOST_WIDE_INT, int);\n static bool choose_mult_variant (enum machine_mode, HOST_WIDE_INT,\n-\t\t\t\t struct algorithm *, enum mult_variant *);\n+\t\t\t\t struct algorithm *, enum mult_variant *, int);\n static rtx expand_mult_const (enum machine_mode, rtx, HOST_WIDE_INT, rtx,\n \t\t\t      const struct algorithm *, enum mult_variant);\n static unsigned HOST_WIDE_INT choose_multiplier (unsigned HOST_WIDE_INT, int,\n@@ -2416,21 +2416,15 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n        - a shift/add sequence based on -VAL, followed by a negation\n        - a shift/add sequence based on VAL - 1, followed by an addition.\n \n-   Return true if the cheapest of these is better than register\n-   multiplication, describing the algorithm in *ALG and final\n-   fixup in *VARIANT.  */\n+   Return true if the cheapest of these cost less than MULT_COST,\n+   describing the algorithm in *ALG and final fixup in *VARIANT.  */\n \n static bool\n choose_mult_variant (enum machine_mode mode, HOST_WIDE_INT val,\n-\t\t     struct algorithm *alg, enum mult_variant *variant)\n+\t\t     struct algorithm *alg, enum mult_variant *variant,\n+\t\t     int mult_cost)\n {\n-  int mult_cost;\n   struct algorithm alg2;\n-  rtx reg;\n-\n-  reg = gen_rtx_REG (mode, FIRST_PSEUDO_REGISTER);\n-  mult_cost = rtx_cost (gen_rtx_MULT (mode, reg, GEN_INT (val)), SET);\n-  mult_cost = MIN (12 * add_cost, mult_cost);\n \n   *variant = basic_variant;\n   synth_mult (alg, val, mult_cost);\n@@ -2642,10 +2636,16 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n      that it seems better to use synth_mult always.  */\n \n   if (const_op1 && GET_CODE (const_op1) == CONST_INT\n-      && (unsignedp || !flag_trapv)\n-      && choose_mult_variant (mode, INTVAL (const_op1), &algorithm, &variant))\n-    return expand_mult_const (mode, op0, INTVAL (const_op1), target,\n-\t\t\t      &algorithm, variant);\n+      && (unsignedp || !flag_trapv))\n+    {\n+      int mult_cost = rtx_cost (gen_rtx_MULT (mode, op0, op1), SET);\n+      mult_cost = MIN (12 * add_cost, mult_cost);\n+\n+      if (choose_mult_variant (mode, INTVAL (const_op1), &algorithm, &variant,\n+\t\t\t       mult_cost))\n+\treturn expand_mult_const (mode, op0, INTVAL (const_op1), target,\n+\t\t\t\t  &algorithm, variant);\n+    }\n \n   if (GET_CODE (op0) == CONST_DOUBLE)\n     {\n@@ -2976,7 +2976,9 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n \t\t      unsigned HOST_WIDE_INT cnst1, rtx target,\n \t\t      int unsignedp, int max_cost)\n {\n-  enum machine_mode wider_mode;\n+  enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n+  int extra_cost;\n+  bool sign_adjust = false;\n   enum mult_variant variant;\n   struct algorithm alg;\n   rtx op1, tem;\n@@ -2986,22 +2988,45 @@ expand_mult_highpart (enum machine_mode mode, rtx op0,\n     abort ();\n \n   op1 = gen_int_mode (cnst1, mode);\n+  cnst1 &= GET_MODE_MASK (mode);\n+\n+  /* We can't optimize modes wider than BITS_PER_WORD. \n+     ??? We might be able to perform double-word arithmetic if \n+     mode == word_mode, however all the cost calculations in\n+     synth_mult etc. assume single-word operations.  */\n+  if (GET_MODE_BITSIZE (wider_mode) > BITS_PER_WORD)\n+    return expand_mult_highpart_optab (mode, op0, op1, target,\n+\t\t\t\t       unsignedp, max_cost);\n+\n+  extra_cost = shift_cost[GET_MODE_BITSIZE (mode) - 1];\n+\n+  /* Check whether we try to multiply by a negative constant.  */\n+  if (!unsignedp && ((cnst1 >> (GET_MODE_BITSIZE (mode) - 1)) & 1))\n+    {\n+      sign_adjust = true;\n+      extra_cost += add_cost;\n+    }\n \n   /* See whether shift/add multiplication is cheap enough.  */\n-  if (choose_mult_variant (mode, cnst1, &alg, &variant)\n-      && (alg.cost += shift_cost[GET_MODE_BITSIZE (mode) - 1]) < max_cost)\n+  if (choose_mult_variant (wider_mode, cnst1, &alg, &variant,\n+\t\t\t   max_cost - extra_cost))\n     {\n       /* See whether the specialized multiplication optabs are\n \t cheaper than the shift/add version.  */\n       tem = expand_mult_highpart_optab (mode, op0, op1, target,\n-\t\t\t\t\tunsignedp, alg.cost);\n+\t\t\t\t\tunsignedp, alg.cost + extra_cost);\n       if (tem)\n \treturn tem;\n \n-      wider_mode = GET_MODE_WIDER_MODE (mode);\n-      op0 = convert_to_mode (wider_mode, op0, unsignedp);\n-      tem = expand_mult_const (wider_mode, op0, cnst1, 0, &alg, variant);\n-      return extract_high_half (mode, tem);\n+      tem = convert_to_mode (wider_mode, op0, unsignedp);\n+      tem = expand_mult_const (wider_mode, tem, cnst1, 0, &alg, variant);\n+      tem = extract_high_half (mode, tem);\n+\n+      /* Adjust result for signedness. */\n+      if (sign_adjust)\n+\ttem = force_operand (gen_rtx_MINUS (mode, tem, op0), tem);\n+\n+      return tem;\n     }\n   return expand_mult_highpart_optab (mode, op0, op1, target,\n \t\t\t\t     unsignedp, max_cost);"}]}