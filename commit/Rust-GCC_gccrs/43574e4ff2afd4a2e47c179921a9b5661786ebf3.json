{"sha": "43574e4ff2afd4a2e47c179921a9b5661786ebf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM1NzRlNGZmMmFmZDRhMmU0N2MxNzk5MjFhOWI1NjYxNzg2ZWJmMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-02-21T21:21:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-02-21T21:21:25Z"}, "message": "re PR c++/89285 (ICE after casting the this pointer in the constructor in C++17 mode)\n\n\tPR c++/89285\n\t* builtins.c (fold_builtin_arith_overflow): If first two args are\n\tINTEGER_CSTs, set intres and ovfres to constants rather than calls\n\tto ifn.\n\n\t* constexpr.c (struct constexpr_fundef): Add parms and result members.\n\t(retrieve_constexpr_fundef): Adjust for the above change.\n\t(register_constexpr_fundef): Save constexpr body with copy_fn,\n\ttemporarily set DECL_CONTEXT on DECL_RESULT before that.\n\t(get_fundef_copy): Change FUN argument to FUNDEF with\n\tconstexpr_fundef * type, grab body and parms/result out of\n\tconstexpr_fundef struct and temporarily change it for copy_fn calls\n\ttoo.\n\t(cxx_eval_builtin_function_call): For __builtin_FUNCTION temporarily\n\tadjust current_function_decl from ctx->call context.  Test\n\t!potential_constant_expression instead of !is_constant_expression.\n\t(cxx_bind_parameters_in_call): Grab parameters from new_call.  Undo\n\tconvert_for_arg_passing changes for TREE_ADDRESSABLE type passing.\n\t(cxx_eval_call_expression): Adjust get_fundef_copy caller.\n\t(cxx_eval_conditional_expression): For IF_STMT, allow then or else\n\toperands to be NULL.\n\t(label_matches): Handle BREAK_STMT and CONTINUE_STMT.\n\t(cxx_eval_loop_expr): Add support for FOR_STMT, WHILE_STMT and DO_STMT.\n\t(cxx_eval_switch_expr): Add support for SWITCH_STMT.\n\t(cxx_eval_constant_expression): Handle IF_STMT, FOR_STMT, WHILE_STMT,\n\tDO_STMT, CONTINUE_STMT, SWITCH_STMT, BREAK_STMT and CONTINUE_STMT.\n\tFor SIZEOF_EXPR, recurse on the result of fold_sizeof_expr.  Ignore\n\tDECL_EXPR with USING_DECL operand.\n\t* lambda.c (maybe_add_lambda_conv_op): Build thisarg using\n\tbuild_int_cst to make it a valid constant expression.\n\n\t* g++.dg/ubsan/vptr-4.C: Expect reinterpret_cast errors.\n\t* g++.dg/cpp1y/constexpr-84192.C (f2): Adjust expected diagnostics.\n\t* g++.dg/cpp1y/constexpr-70265-2.C (foo): Adjust expected line of\n\tdiagnostics.\n\t* g++.dg/cpp1y/constexpr-89285.C: New test.\n\t* g++.dg/cpp0x/constexpr-arith-overflow.C (add, sub, mul): Ifdef out\n\tfor C++11.\n\t(TEST_ADD, TEST_SUB, TEST_MUL): Define to Assert (true) for C++11.\n\t* g++.dg/cpp0x/constexpr-arith-overflow2.C: New test.\n\nFrom-SVN: r269078", "tree": {"sha": "5130c82c404a6ffc07359ce1e92a747310754653", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5130c82c404a6ffc07359ce1e92a747310754653"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43574e4ff2afd4a2e47c179921a9b5661786ebf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43574e4ff2afd4a2e47c179921a9b5661786ebf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43574e4ff2afd4a2e47c179921a9b5661786ebf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43574e4ff2afd4a2e47c179921a9b5661786ebf3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d331c5f10d5e6c9f41a24ff7cb7a8c6493790885", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d331c5f10d5e6c9f41a24ff7cb7a8c6493790885", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d331c5f10d5e6c9f41a24ff7cb7a8c6493790885"}], "stats": {"total": 384, "additions": 321, "deletions": 63}, "files": [{"sha": "0946f79234acd055ac75e0524c8152179360c2ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -1,3 +1,10 @@\n+2019-02-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/89285\n+\t* builtins.c (fold_builtin_arith_overflow): If first two args are\n+\tINTEGER_CSTs, set intres and ovfres to constants rather than calls\n+\tto ifn.\n+\n 2019-02-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87412"}, {"sha": "c19ca308b1bd289fdb825a4c11a9406fc64fb783", "filename": "gcc/builtins.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -9302,8 +9302,7 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n \t\t\t     tree arg0, tree arg1, tree arg2)\n {\n   enum internal_fn ifn = IFN_LAST;\n-  /* The code of the expression corresponding to the type-generic\n-     built-in, or ERROR_MARK for the type-specific ones.  */\n+  /* The code of the expression corresponding to the built-in.  */\n   enum tree_code opcode = ERROR_MARK;\n   bool ovf_only = false;\n \n@@ -9313,42 +9312,39 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n       ovf_only = true;\n       /* FALLTHRU */\n     case BUILT_IN_ADD_OVERFLOW:\n-      opcode = PLUS_EXPR;\n-      /* FALLTHRU */\n     case BUILT_IN_SADD_OVERFLOW:\n     case BUILT_IN_SADDL_OVERFLOW:\n     case BUILT_IN_SADDLL_OVERFLOW:\n     case BUILT_IN_UADD_OVERFLOW:\n     case BUILT_IN_UADDL_OVERFLOW:\n     case BUILT_IN_UADDLL_OVERFLOW:\n+      opcode = PLUS_EXPR;\n       ifn = IFN_ADD_OVERFLOW;\n       break;\n     case BUILT_IN_SUB_OVERFLOW_P:\n       ovf_only = true;\n       /* FALLTHRU */\n     case BUILT_IN_SUB_OVERFLOW:\n-      opcode = MINUS_EXPR;\n-      /* FALLTHRU */\n     case BUILT_IN_SSUB_OVERFLOW:\n     case BUILT_IN_SSUBL_OVERFLOW:\n     case BUILT_IN_SSUBLL_OVERFLOW:\n     case BUILT_IN_USUB_OVERFLOW:\n     case BUILT_IN_USUBL_OVERFLOW:\n     case BUILT_IN_USUBLL_OVERFLOW:\n+      opcode = MINUS_EXPR;\n       ifn = IFN_SUB_OVERFLOW;\n       break;\n     case BUILT_IN_MUL_OVERFLOW_P:\n       ovf_only = true;\n       /* FALLTHRU */\n     case BUILT_IN_MUL_OVERFLOW:\n-      opcode = MULT_EXPR;\n-      /* FALLTHRU */\n     case BUILT_IN_SMUL_OVERFLOW:\n     case BUILT_IN_SMULL_OVERFLOW:\n     case BUILT_IN_SMULLL_OVERFLOW:\n     case BUILT_IN_UMUL_OVERFLOW:\n     case BUILT_IN_UMULL_OVERFLOW:\n     case BUILT_IN_UMULLL_OVERFLOW:\n+      opcode = MULT_EXPR;\n       ifn = IFN_MUL_OVERFLOW;\n       break;\n     default:\n@@ -9373,13 +9369,27 @@ fold_builtin_arith_overflow (location_t loc, enum built_in_function fcode,\n \t\t\t\t ? boolean_true_node : boolean_false_node,\n \t\t\t\t arg2);\n \n-  tree ctype = build_complex_type (type);\n-  tree call = build_call_expr_internal_loc (loc, ifn, ctype,\n-\t\t\t\t\t    2, arg0, arg1);\n-  tree tgt = save_expr (call);\n-  tree intres = build1_loc (loc, REALPART_EXPR, type, tgt);\n-  tree ovfres = build1_loc (loc, IMAGPART_EXPR, type, tgt);\n-  ovfres = fold_convert_loc (loc, boolean_type_node, ovfres);\n+  tree intres, ovfres;\n+  if (TREE_CODE (arg0) == INTEGER_CST && TREE_CODE (arg1) == INTEGER_CST)\n+    {\n+      intres = fold_binary_loc (loc, opcode, type,\n+\t\t\t\tfold_convert_loc (loc, type, arg0),\n+\t\t\t\tfold_convert_loc (loc, type, arg1));\n+      if (TREE_OVERFLOW (intres))\n+\tintres = drop_tree_overflow (intres);\n+      ovfres = (arith_overflowed_p (opcode, type, arg0, arg1)\n+\t\t? boolean_true_node : boolean_false_node);\n+    }\n+  else\n+    {\n+      tree ctype = build_complex_type (type);\n+      tree call = build_call_expr_internal_loc (loc, ifn, ctype, 2,\n+\t\t\t\t\t\targ0, arg1);\n+      tree tgt = save_expr (call);\n+      intres = build1_loc (loc, REALPART_EXPR, type, tgt);\n+      ovfres = build1_loc (loc, IMAGPART_EXPR, type, tgt);\n+      ovfres = fold_convert_loc (loc, boolean_type_node, ovfres);\n+    }\n \n   if (ovf_only)\n     return omit_one_operand_loc (loc, boolean_type_node, ovfres, arg2);"}, {"sha": "824d007d36cb3cff5fdadc24d870294177da15db", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -1,3 +1,32 @@\n+2019-02-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/89285\n+\t* constexpr.c (struct constexpr_fundef): Add parms and result members.\n+\t(retrieve_constexpr_fundef): Adjust for the above change.\n+\t(register_constexpr_fundef): Save constexpr body with copy_fn,\n+\ttemporarily set DECL_CONTEXT on DECL_RESULT before that.\n+\t(get_fundef_copy): Change FUN argument to FUNDEF with\n+\tconstexpr_fundef * type, grab body and parms/result out of\n+\tconstexpr_fundef struct and temporarily change it for copy_fn calls\n+\ttoo.\n+\t(cxx_eval_builtin_function_call): For __builtin_FUNCTION temporarily\n+\tadjust current_function_decl from ctx->call context.  Test\n+\t!potential_constant_expression instead of !is_constant_expression.\n+\t(cxx_bind_parameters_in_call): Grab parameters from new_call.  Undo\n+\tconvert_for_arg_passing changes for TREE_ADDRESSABLE type passing.\n+\t(cxx_eval_call_expression): Adjust get_fundef_copy caller.\n+\t(cxx_eval_conditional_expression): For IF_STMT, allow then or else\n+\toperands to be NULL.\n+\t(label_matches): Handle BREAK_STMT and CONTINUE_STMT.\n+\t(cxx_eval_loop_expr): Add support for FOR_STMT, WHILE_STMT and DO_STMT.\n+\t(cxx_eval_switch_expr): Add support for SWITCH_STMT.\n+\t(cxx_eval_constant_expression): Handle IF_STMT, FOR_STMT, WHILE_STMT,\n+\tDO_STMT, CONTINUE_STMT, SWITCH_STMT, BREAK_STMT and CONTINUE_STMT.\n+\tFor SIZEOF_EXPR, recurse on the result of fold_sizeof_expr.  Ignore\n+\tDECL_EXPR with USING_DECL operand.\n+\t* lambda.c (maybe_add_lambda_conv_op): Build thisarg using\n+\tbuild_int_cst to make it a valid constant expression.\n+\n 2019-02-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/88690 - C++17 ICE with empty base in aggregate."}, {"sha": "40080271c11e8109f8cc6ea8fc6164576180cb15", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 179, "deletions": 37, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -139,6 +139,8 @@ ensure_literal_type_for_constexpr_object (tree decl)\n struct GTY((for_user)) constexpr_fundef {\n   tree decl;\n   tree body;\n+  tree parms;\n+  tree result;\n };\n \n struct constexpr_fundef_hasher : ggc_ptr_hash<constexpr_fundef>\n@@ -176,11 +178,10 @@ constexpr_fundef_hasher::hash (constexpr_fundef *fundef)\n static constexpr_fundef *\n retrieve_constexpr_fundef (tree fun)\n {\n-  constexpr_fundef fundef = { NULL, NULL };\n   if (constexpr_fundef_table == NULL)\n     return NULL;\n \n-  fundef.decl = fun;\n+  constexpr_fundef fundef = { fun, NULL, NULL, NULL };\n   return constexpr_fundef_table->find (&fundef);\n }\n \n@@ -897,8 +898,19 @@ register_constexpr_fundef (tree fun, tree body)\n       = hash_table<constexpr_fundef_hasher>::create_ggc (101);\n \n   entry.decl = fun;\n-  entry.body = body;\n+  tree saved_fn = current_function_decl;\n+  bool clear_ctx = false;\n+  current_function_decl = fun;\n+  if (DECL_RESULT (fun) && DECL_CONTEXT (DECL_RESULT (fun)) == NULL_TREE)\n+    {\n+      clear_ctx = true;\n+      DECL_CONTEXT (DECL_RESULT (fun)) = fun;\n+    }\n+  entry.body = copy_fn (fun, entry.parms, entry.result);\n+  current_function_decl = saved_fn;\n   slot = constexpr_fundef_table->find_slot (&entry, INSERT);\n+  if (clear_ctx)\n+    DECL_CONTEXT (DECL_RESULT (fun)) = NULL_TREE;\n \n   gcc_assert (*slot == NULL);\n   *slot = ggc_alloc<constexpr_fundef> ();\n@@ -1114,27 +1126,40 @@ maybe_initialize_fundef_copies_table ()\n    is parms, TYPE is result.  */\n \n static tree\n-get_fundef_copy (tree fun)\n+get_fundef_copy (constexpr_fundef *fundef)\n {\n   maybe_initialize_fundef_copies_table ();\n \n   tree copy;\n   bool existed;\n-  tree *slot = &fundef_copies_table->get_or_insert (fun, &existed);\n+  tree *slot = &fundef_copies_table->get_or_insert (fundef->decl, &existed);\n \n   if (!existed)\n     {\n       /* There is no cached function available, or in use.  We can use\n \t the function directly.  That the slot is now created records\n \t that this function is now in use.  */\n-      copy = build_tree_list (DECL_SAVED_TREE (fun), DECL_ARGUMENTS (fun));\n-      TREE_TYPE (copy) = DECL_RESULT (fun);\n+      copy = build_tree_list (fundef->body, fundef->parms);\n+      TREE_TYPE (copy) = fundef->result;\n     }\n   else if (*slot == NULL_TREE)\n     {\n       /* We've already used the function itself, so make a copy.  */\n       copy = build_tree_list (NULL, NULL);\n-      TREE_PURPOSE (copy) = copy_fn (fun, TREE_VALUE (copy), TREE_TYPE (copy));\n+      tree saved_body = DECL_SAVED_TREE (fundef->decl);\n+      tree saved_parms = DECL_ARGUMENTS (fundef->decl);\n+      tree saved_result = DECL_RESULT (fundef->decl);\n+      tree saved_fn = current_function_decl;\n+      DECL_SAVED_TREE (fundef->decl) = fundef->body;\n+      DECL_ARGUMENTS (fundef->decl) = fundef->parms;\n+      DECL_RESULT (fundef->decl) = fundef->result;\n+      current_function_decl = fundef->decl;\n+      TREE_PURPOSE (copy) = copy_fn (fundef->decl, TREE_VALUE (copy),\n+\t\t\t\t     TREE_TYPE (copy));\n+      current_function_decl = saved_fn;\n+      DECL_RESULT (fundef->decl) = saved_result;\n+      DECL_ARGUMENTS (fundef->decl) = saved_parms;\n+      DECL_SAVED_TREE (fundef->decl) = saved_body;\n     }\n   else\n     {\n@@ -1245,8 +1270,15 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n \n   bool save_ffbcp = force_folding_builtin_constant_p;\n   force_folding_builtin_constant_p = true;\n+  tree save_cur_fn = current_function_decl;\n+  /* Return name of ctx->call->fundef->decl for __builtin_FUNCTION ().  */\n+  if (fndecl_built_in_p (fun, BUILT_IN_FUNCTION)\n+      && ctx->call\n+      && ctx->call->fundef)\n+    current_function_decl = ctx->call->fundef->decl;\n   new_call = fold_builtin_call_array (EXPR_LOCATION (t), TREE_TYPE (t),\n \t\t\t\t      CALL_EXPR_FN (t), nargs, args);\n+  current_function_decl = save_cur_fn;\n   force_folding_builtin_constant_p = save_ffbcp;\n   if (new_call == NULL)\n     {\n@@ -1269,7 +1301,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n       return t;\n     }\n \n-  if (!is_constant_expression (new_call))\n+  if (!potential_constant_expression (new_call))\n     {\n       if (!*non_constant_p && !ctx->quiet)\n \terror (\"%q+E is not a constant expression\", new_call);\n@@ -1341,7 +1373,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n {\n   const int nargs = call_expr_nargs (t);\n   tree fun = new_call->fundef->decl;\n-  tree parms = DECL_ARGUMENTS (fun);\n+  tree parms = new_call->fundef->parms;\n   int i;\n   tree *p = &new_call->bindings;\n   for (i = 0; i < nargs; ++i)\n@@ -1358,6 +1390,9 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  x = ctx->object;\n \t  x = build_address (x);\n \t}\n+      if (TREE_ADDRESSABLE (type))\n+\t/* Undo convert_for_arg_passing work here.  */\n+\tx = convert_from_reference (x);\n       arg = cxx_eval_constant_expression (ctx, x, /*lval=*/false,\n \t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n@@ -1761,7 +1796,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  tree body, parms, res;\n \n \t  /* Reuse or create a new unshared copy of this function's body.  */\n-\t  tree copy = get_fundef_copy (fun);\n+\t  tree copy = get_fundef_copy (new_call.fundef);\n \t  body = TREE_PURPOSE (copy);\n \t  parms = TREE_VALUE (copy);\n \t  res = TREE_TYPE (copy);\n@@ -2223,14 +2258,13 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n-    return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n-\t\t\t\t\t lval,\n-\t\t\t\t\t non_constant_p, overflow_p,\n-\t\t\t\t\t jump_target);\n-  return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t       lval,\n-\t\t\t\t       non_constant_p, overflow_p,\n-\t\t\t\t       jump_target);\n+    val = TREE_OPERAND (t, 2);\n+  else\n+    val = TREE_OPERAND (t, 1);\n+  if (TREE_CODE (t) == IF_STMT && !val)\n+    val = void_node;\n+  return cxx_eval_constant_expression (ctx, val, lval, non_constant_p,\n+\t\t\t\t       overflow_p, jump_target);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -4059,6 +4093,12 @@ label_matches (const constexpr_ctx *ctx, tree *jump_target, tree stmt)\n \t}\n       break;\n \n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      /* These two are handled directly in cxx_eval_loop_expr by testing\n+\t breaks (jump_target) or continues (jump_target).  */\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -4119,20 +4159,84 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n {\n   constexpr_ctx new_ctx = *ctx;\n \n-  tree body = TREE_OPERAND (t, 0);\n+  tree body, cond = NULL_TREE, expr = NULL_TREE;\n   int count = 0;\n+  switch (TREE_CODE (t))\n+    {\n+    case LOOP_EXPR:\n+      body = LOOP_EXPR_BODY (t);\n+      break;\n+    case DO_STMT:\n+      body = DO_BODY (t);\n+      cond = DO_COND (t);\n+      break;\n+    case WHILE_STMT:\n+      body = WHILE_BODY (t);\n+      cond = WHILE_COND (t);\n+      count = -1;\n+      break;\n+    case FOR_STMT:\n+      if (FOR_INIT_STMT (t))\n+\tcxx_eval_constant_expression (ctx, FOR_INIT_STMT (t), /*lval*/false,\n+\t\t\t\t      non_constant_p, overflow_p, jump_target);\n+      if (*non_constant_p)\n+\treturn NULL_TREE;\n+      body = FOR_BODY (t);\n+      cond = FOR_COND (t);\n+      expr = FOR_EXPR (t);\n+      count = -1;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  hash_set<tree> save_exprs;\n+  new_ctx.save_exprs = &save_exprs;\n   do\n     {\n-      hash_set<tree> save_exprs;\n-      new_ctx.save_exprs = &save_exprs;\n+      if (count != -1)\n+\t{\n+\t  if (body)\n+\t    cxx_eval_constant_expression (&new_ctx, body, /*lval*/false,\n+\t\t\t\t\t  non_constant_p, overflow_p,\n+\t\t\t\t\t  jump_target);\n+\t  if (breaks (jump_target))\n+\t    {\n+\t      *jump_target = NULL_TREE;\n+\t      break;\n+\t    }\n \n-      cxx_eval_constant_expression (&new_ctx, body, /*lval*/false,\n-\t\t\t\t    non_constant_p, overflow_p, jump_target);\n+\t  if (TREE_CODE (t) != LOOP_EXPR && continues (jump_target))\n+\t    *jump_target = NULL_TREE;\n+\n+\t  if (expr)\n+\t    cxx_eval_constant_expression (&new_ctx, expr, /*lval*/false,\n+\t\t\t\t\t  non_constant_p, overflow_p,\n+\t\t\t\t\t  jump_target);\n+\t}\n+\n+      if (cond)\n+\t{\n+\t  tree res\n+\t    = cxx_eval_constant_expression (&new_ctx, cond, /*lval*/false,\n+\t\t\t\t\t    non_constant_p, overflow_p,\n+\t\t\t\t\t    jump_target);\n+\t  if (res)\n+\t    {\n+\t      if (verify_constant (res, ctx->quiet, non_constant_p,\n+\t\t\t\t   overflow_p))\n+\t\tbreak;\n+\t      if (integer_zerop (res))\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    gcc_assert (*jump_target);\n+\t}\n \n       /* Forget saved values of SAVE_EXPRs.  */\n       for (hash_set<tree>::iterator iter = save_exprs.begin();\n \t   iter != save_exprs.end(); ++iter)\n \tnew_ctx.values->remove (*iter);\n+\n       if (++count >= constexpr_loop_limit)\n \t{\n \t  if (!ctx->quiet)\n@@ -4146,11 +4250,14 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n     }\n   while (!returns (jump_target)\n \t && !breaks (jump_target)\n-\t && !switches (jump_target)\n+\t && !continues (jump_target)\n+\t && (!switches (jump_target) || count == 0)\n \t && !*non_constant_p);\n \n-  if (breaks (jump_target))\n-    *jump_target = NULL_TREE;\n+  /* Forget saved values of SAVE_EXPRs.  */\n+  for (hash_set<tree>::iterator iter = save_exprs.begin();\n+       iter != save_exprs.end(); ++iter)\n+    new_ctx.values->remove (*iter);\n \n   return NULL_TREE;\n }\n@@ -4163,13 +4270,15 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n \t\t      bool *non_constant_p, bool *overflow_p,\n \t\t      tree *jump_target)\n {\n-  tree cond = SWITCH_COND (t);\n+  tree cond\n+    = TREE_CODE (t) == SWITCH_STMT ? SWITCH_STMT_COND (t) : SWITCH_COND (t);\n   cond = cxx_eval_constant_expression (ctx, cond, false,\n \t\t\t\t       non_constant_p, overflow_p);\n   VERIFY_CONSTANT (cond);\n   *jump_target = cond;\n \n-  tree body = SWITCH_BODY (t);\n+  tree body\n+    = TREE_CODE (t) == SWITCH_STMT ? SWITCH_STMT_BODY (t) : SWITCH_BODY (t);\n   constexpr_ctx new_ctx = *ctx;\n   constexpr_switch_state css = css_default_not_seen;\n   new_ctx.css_state = &css;\n@@ -4245,6 +4354,10 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tcase STATEMENT_LIST:\n \tcase LOOP_EXPR:\n \tcase COND_EXPR:\n+\tcase IF_STMT:\n+\tcase DO_STMT:\n+\tcase WHILE_STMT:\n+\tcase FOR_STMT:\n \t  break;\n \tcase LABEL_EXPR:\n \tcase CASE_LABEL_EXPR:\n@@ -4389,6 +4502,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case DECL_EXPR:\n       {\n \tr = DECL_EXPR_DECL (t);\n+\tif (TREE_CODE (r) == USING_DECL)\n+\t  {\n+\t    r = void_node;\n+\t    break;\n+\t  }\n \tif (AGGREGATE_TYPE_P (TREE_TYPE (r))\n \t    || VECTOR_TYPE_P (TREE_TYPE (r)))\n \t  {\n@@ -4476,6 +4594,9 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tr = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t  lval,\n \t\t\t\t\t  non_constant_p, overflow_p);\n+      /* FALLTHRU */\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n       if (jump_target)\n \t*jump_target = t;\n       else\n@@ -4526,6 +4647,17 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t      jump_target);\n       break;\n \n+    case CLEANUP_STMT:\n+      r = cxx_eval_constant_expression (ctx, CLEANUP_BODY (t), lval,\n+\t\t\t\t\tnon_constant_p, overflow_p,\n+\t\t\t\t\tjump_target);\n+      if (!CLEANUP_EH_ONLY (t) && !*non_constant_p)\n+\t/* Also evaluate the cleanup.  */\n+\tcxx_eval_constant_expression (ctx, CLEANUP_EXPR (t), true,\n+\t\t\t\t      non_constant_p, overflow_p,\n+\t\t\t\t      jump_target);\n+      break;\n+\n       /* These differ from cxx_eval_unary_expression in that this doesn't\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n@@ -4581,8 +4713,9 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case SIZEOF_EXPR:\n-      r = fold_sizeof_expr (t);\n-      VERIFY_CONSTANT (r);\n+      r = cxx_eval_constant_expression (ctx, fold_sizeof_expr (t), lval,\n+\t\t\t\t\tnon_constant_p, overflow_p,\n+\t\t\t\t\tjump_target);\n       break;\n \n     case COMPOUND_EXPR:\n@@ -4702,16 +4835,18 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case COND_EXPR:\n+    case IF_STMT:\n       if (jump_target && *jump_target)\n \t{\n \t  tree orig_jump = *jump_target;\n+\t  tree arg = ((TREE_CODE (t) != IF_STMT || TREE_OPERAND (t, 1))\n+\t\t      ? TREE_OPERAND (t, 1) : void_node);\n \t  /* When jumping to a label, the label might be either in the\n \t     then or else blocks, so process then block first in skipping\n \t     mode first, and if we are still in the skipping mode at its end,\n \t     process the else block too.  */\n-\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\t    lval, non_constant_p, overflow_p,\n-\t\t\t\t\t    jump_target);\n+\t  r = cxx_eval_constant_expression (ctx, arg, lval, non_constant_p,\n+\t\t\t\t\t    overflow_p, jump_target);\n \t  /* It's possible that we found the label in the then block.  But\n \t     it could have been followed by another jumping statement, e.g.\n \t     say we're looking for case 1:\n@@ -4725,9 +4860,12 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t     in which case we need not go looking to the else block.\n \t     (goto is not allowed in a constexpr function.)  */\n \t  if (*jump_target == orig_jump)\n-\t    r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n-\t\t\t\t\t      lval, non_constant_p, overflow_p,\n-\t\t\t\t\t      jump_target);\n+\t    {\n+\t      arg = ((TREE_CODE (t) != IF_STMT || TREE_OPERAND (t, 2))\n+\t\t     ? TREE_OPERAND (t, 2) : void_node);\n+\t      r = cxx_eval_constant_expression (ctx, arg, lval, non_constant_p,\n+\t\t\t\t\t\toverflow_p, jump_target);\n+\t    }\n \t  break;\n \t}\n       r = cxx_eval_conditional_expression (ctx, t, lval,\n@@ -4971,11 +5109,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case LOOP_EXPR:\n+    case DO_STMT:\n+    case WHILE_STMT:\n+    case FOR_STMT:\n       cxx_eval_loop_expr (ctx, t,\n \t\t\t  non_constant_p, overflow_p, jump_target);\n       break;\n \n     case SWITCH_EXPR:\n+    case SWITCH_STMT:\n       cxx_eval_switch_expr (ctx, t,\n \t\t\t    non_constant_p, overflow_p, jump_target);\n       break;"}, {"sha": "3b803ad86a6abcbbcf32639effb04eb6859c3f67", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -1087,8 +1087,7 @@ maybe_add_lambda_conv_op (tree type)\n   tree optype = TREE_TYPE (callop);\n   tree fn_result = TREE_TYPE (optype);\n \n-  tree thisarg = build_nop (TREE_TYPE (DECL_ARGUMENTS (callop)),\n-\t\t\t    null_pointer_node);\n+  tree thisarg = build_int_cst (TREE_TYPE (DECL_ARGUMENTS (callop)), 0);\n   if (generic_lambda_p)\n     {\n       ++processing_template_decl;"}, {"sha": "78d9d2c82e47760e11258ec826c266b3882bfa39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -1,3 +1,16 @@\n+2019-02-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/89285\n+\t* g++.dg/ubsan/vptr-4.C: Expect reinterpret_cast errors.\n+\t* g++.dg/cpp1y/constexpr-84192.C (f2): Adjust expected diagnostics.\n+\t* g++.dg/cpp1y/constexpr-70265-2.C (foo): Adjust expected line of\n+\tdiagnostics.\n+\t* g++.dg/cpp1y/constexpr-89285.C: New test.\n+\t* g++.dg/cpp0x/constexpr-arith-overflow.C (add, sub, mul): Ifdef out\n+\tfor C++11.\n+\t(TEST_ADD, TEST_SUB, TEST_MUL): Define to Assert (true) for C++11.\n+\t* g++.dg/cpp0x/constexpr-arith-overflow2.C: New test.\n+\n 2019-02-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/87412"}, {"sha": "f39a407da8519abceae7a82660a999086a882d58", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-arith-overflow.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow.C?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -27,6 +27,7 @@\n \n #define Assert(expr) static_assert ((expr), #expr)\n \n+#if __cplusplus >= 201402L\n template <class T>\n constexpr T add (T x, T y, T z = T ())\n {\n@@ -48,6 +49,11 @@ constexpr T mul (T x, T y, T z = T ())\n #define TEST_ADD(T, x, y, z) Assert (z == add<T>(x, y))\n #define TEST_SUB(T, x, y, z) Assert (z == sub<T>(x, y))\n #define TEST_MUL(T, x, y, z) Assert (z == mul<T>(x, y))\n+#else\n+#define TEST_ADD(T, x, y, z) Assert (true)\n+#define TEST_SUB(T, x, y, z) Assert (true)\n+#define TEST_MUL(T, x, y, z) Assert (true)\n+#endif\n \n \n TEST_ADD (signed char,  0,         0,         0);"}, {"sha": "a67b0251ba73b393f911bc339fc28a94e50006ce", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-arith-overflow2.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-arith-overflow2.C?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/70507 - integer overflow builtins not constant expressions\n+// The constexpr-arith-overflow.C testcase covers this for C++14 and later.\n+// { dg-do compile }\n+// { dg-options \"-std=c++11\" }\n+\n+#define Assert(expr) static_assert ((expr), #expr)\n+\n+template <class T>\n+constexpr T add (T x, T y, T z = T ())\n+{\n+  return __builtin_add_overflow (x, y, &z) ? 0 : z;\t// { dg-error \"is not a constant expression\" }\n+}\n+\n+template <class T>\n+constexpr T sub (T x, T y, T z = T ())\n+{\n+  return __builtin_sub_overflow (x, y, &z) ? 0 : z;\t// { dg-error \"is not a constant expression\" }\n+}\n+\n+template <class T>\n+constexpr T mul (T x, T y, T z = T ())\n+{\n+  return __builtin_mul_overflow (x, y, &z) ? 0 : z;\t// { dg-error \"is not a constant expression\" }\n+}\n+\n+Assert (0 == add<int>(0, 0));\t// { dg-error \"non-constant condition for static assertion\" }\n+Assert (0 == sub<int>(0, 0));\t// { dg-error \"non-constant condition for static assertion\" }\n+Assert (0 == mul<int>(0, 0));\t// { dg-error \"non-constant condition for static assertion\" }\n+// { dg-message \"expansion of\" \"\" { target *-*-* } .-3 }\n+// { dg-message \"expansion of\" \"\" { target *-*-* } .-3 }\n+// { dg-message \"expansion of\" \"\" { target *-*-* } .-3 }"}, {"sha": "6eb3c680eec86e5bc00aac0ed5d6ac0e97db43d6", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-70265-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-70265-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-70265-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-70265-2.C?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -5,8 +5,8 @@ constexpr int\n foo (int p)\n {\n   int t = 0;\n-  while (1)\n-    t = 0;  // { dg-error \"count exceeds\" }\n+  while (1)  // { dg-error \"count exceeds\" }\n+    t = 0;\n   return t;\n }\n "}, {"sha": "f7439d80b3967bc59d3c3db97bdc442446ab2bcc", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-84192.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-84192.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-84192.C?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -12,7 +12,7 @@ void\n f2 ()\n { \n   for (;;)\n-    constexpr bool b = ({ break; false; }) && false;\t// { dg-error \"statement is not a constant expression\" }\n+    constexpr bool b = ({ break; false; }) && false;\t// { dg-error \"is not a constant expression\" }\n }\n \n constexpr bool"}, {"sha": "3809e1f7a9f80e6ec3994940483dedc913b05527", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-89285.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285.C?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/89285\n+// { dg-do compile { target c++14 } }\n+\n+struct A {\n+  int a {};\n+};\n+struct B {\n+  int b {};\n+  constexpr B (A *x) {\n+    int *c = &x->a;\n+    while (*c)\n+      c = reinterpret_cast<int *>((reinterpret_cast<char *>(c) + *c));\n+    *c = reinterpret_cast<char *>(this) - reinterpret_cast<char *>(c);\t// { dg-error \"reinterpret_cast\" }\n+  }\n+};\n+struct C : A {\n+  B bar {this};\n+};\n+\n+constexpr C foo {};\t// { dg-message \"expansion of\" }"}, {"sha": "cf638e9b35f9d9225c2c10408a0f35db6652ec09", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-4.C", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43574e4ff2afd4a2e47c179921a9b5661786ebf3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C?ref=43574e4ff2afd4a2e47c179921a9b5661786ebf3", "patch": "@@ -15,11 +15,11 @@ struct T : S {\n   int b;\n   int g() { return 0; }\n   virtual int v() { return 1; }\n-  constexpr const T *foo() { return (const T *) reinterpret_cast<const S *> (this); }\n+  constexpr const T *foo() { return (const T *) reinterpret_cast<const S *> (this); } // { dg-error \"is not a constant expression\" }\n };\n \n constexpr T t;\n-constexpr const T *p = t.foo ();\n+constexpr const T *p = t.foo ();\t// { dg-message \"expansion of\" }\n \n template <typename U>\n struct V {\n@@ -39,16 +39,17 @@ struct W : V<U> {\n };\n \n constexpr W<int> w;\n-constexpr const W<int> *s = w.foo ();\n+constexpr const W<int> *s = w.foo ();\t// { dg-error \"is not a constant expression\" }\n+// { dg-message \"expansion of\" \"\" { target *-*-* } .-1 }\n \n template <typename U>\n int foo (void)\n {\n   static constexpr T t;\n-  static constexpr const T *p = t.foo ();\n+  static constexpr const T *p = t.foo ();\t// { dg-message \"expansion of\" }\n   static constexpr W<U> w;\n-  static constexpr const W<U> *s = w.foo ();\n-  return t.b + w.b;\n+  static constexpr const W<U> *s = w.foo ();\t// { dg-error \"is not a constant expression\" }\n+  return t.b + w.b;\t\t\t\t// { dg-message \"expansion of\" \"\" { target *-*-* } .-1 }\n }\n \n int x = foo <char> ();"}]}