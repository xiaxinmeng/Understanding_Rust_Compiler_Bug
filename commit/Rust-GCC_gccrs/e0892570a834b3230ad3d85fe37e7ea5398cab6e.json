{"sha": "e0892570a834b3230ad3d85fe37e7ea5398cab6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA4OTI1NzBhODM0YjMyMzBhZDNkODVmZTM3ZTdlYTUzOThjYWI2ZQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2007-08-07T10:43:11Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2007-08-07T10:43:11Z"}, "message": "lower-subreg.c (resolve_subreg_use): Remove assertion.\n\n2007-08-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* lower-subreg.c (resolve_subreg_use): Remove assertion.\n\t(find_decomposable_shift_zext, resolve_shift_zext): New functions.\n\t(decompose_multiword_subregs): Use the functions above to decompose\n\tmultiword shifts and zero-extends.\n\n2007-08-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* gcc.dg/multiword-1.c: New testcase.\n\nFrom-SVN: r127270", "tree": {"sha": "65bb0f6c5ac23824ac9750984b2fb4f75c7c7409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65bb0f6c5ac23824ac9750984b2fb4f75c7c7409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0892570a834b3230ad3d85fe37e7ea5398cab6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0892570a834b3230ad3d85fe37e7ea5398cab6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0892570a834b3230ad3d85fe37e7ea5398cab6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0892570a834b3230ad3d85fe37e7ea5398cab6e/comments", "author": null, "committer": null, "parents": [{"sha": "e492980b7349436c6a473e4950b54d0f0bd8b772", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e492980b7349436c6a473e4950b54d0f0bd8b772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e492980b7349436c6a473e4950b54d0f0bd8b772"}], "stats": {"total": 248, "additions": 246, "deletions": 2}, "files": [{"sha": "9b40d76747738f20598834e0a68fbe4284b7cb15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0892570a834b3230ad3d85fe37e7ea5398cab6e", "patch": "@@ -1,3 +1,10 @@\n+2007-08-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* lower-subreg.c (resolve_subreg_use): Remove assertion.\n+\t(find_decomposable_shift_zext, resolve_shift_zext): New functions.\n+\t(decompose_multiword_subregs): Use the functions above to decompose\n+\tmultiword shifts and zero-extends.\n+\n 2007-08-07  Rask Ingemann Lambertsen  <rask@sygehus.dk>\n \n \t* doc/sourcebuild.texi (Test Directives): Fix \"compile\" and"}, {"sha": "4cb2ca8cabedf4ce1833a883edc0ebd6a2ab2347", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 167, "deletions": 2, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=e0892570a834b3230ad3d85fe37e7ea5398cab6e", "patch": "@@ -525,8 +525,8 @@ resolve_subreg_use (rtx *px, void *data)\n     {\n       /* Return 1 to the caller to indicate that we found a direct\n \t reference to a register which is being decomposed.  This can\n-\t happen inside notes.  */\n-      gcc_assert (!insn);\n+\t happen inside notes, multiword shift or zero-extend\n+\t instructions.  */\n       return 1;\n     }\n \n@@ -944,6 +944,155 @@ resolve_use (rtx pat, rtx insn)\n   return false;\n }\n \n+/* Checks if INSN is a decomposable multiword-shift or zero-extend and\n+   sets the decomposable_context bitmap accordingly.  A non-zero value\n+   is returned if a decomposable insn has been found.  */\n+\n+static int\n+find_decomposable_shift_zext (rtx insn)\n+{\n+  rtx set;\n+  rtx op;\n+  rtx op_operand;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return 0;\n+\n+  op = SET_SRC (set);\n+  if (GET_CODE (op) != ASHIFT\n+      && GET_CODE (op) != LSHIFTRT\n+      && GET_CODE (op) != ZERO_EXTEND)\n+    return 0;\n+\n+  op_operand = XEXP (op, 0);\n+  if (!REG_P (SET_DEST (set)) || !REG_P (op_operand)\n+      || HARD_REGISTER_NUM_P (REGNO (SET_DEST (set)))\n+      || HARD_REGISTER_NUM_P (REGNO (op_operand))\n+      || !SCALAR_INT_MODE_P (GET_MODE (op)))\n+    return 0;\n+\n+  if (GET_CODE (op) == ZERO_EXTEND)\n+    {\n+      if (GET_MODE (op_operand) != word_mode\n+\t  || GET_MODE_BITSIZE (GET_MODE (op)) != 2 * BITS_PER_WORD)\n+\treturn 0;\n+    }\n+  else /* left or right shift */\n+    {\n+      if (GET_CODE (XEXP (op, 1)) != CONST_INT\n+\t  || INTVAL (XEXP (op, 1)) < BITS_PER_WORD\n+\t  || GET_MODE_BITSIZE (GET_MODE (op_operand)) != 2 * BITS_PER_WORD)\n+\treturn 0;\n+    }\n+\n+  bitmap_set_bit (decomposable_context, REGNO (SET_DEST (set)));\n+\n+  if (GET_CODE (op) != ZERO_EXTEND)\n+    bitmap_set_bit (decomposable_context, REGNO (op_operand));\n+\n+  return 1;\n+}\n+\n+/* Decompose a more than word wide shift (in INSN) of a multiword\n+   pseudo or a multiword zero-extend of a wordmode pseudo into a move\n+   and 'set to zero' insn.  Return a pointer to the new insn when a\n+   replacement was done.  */\n+\n+static rtx\n+resolve_shift_zext (rtx insn)\n+{\n+  rtx set;\n+  rtx op;\n+  rtx op_operand;\n+  rtx insns;\n+  rtx src_reg, dest_reg, dest_zero;\n+  int src_reg_num, dest_reg_num, offset1, offset2, src_offset;\n+\n+  set = single_set (insn);\n+  if (!set)\n+    return NULL_RTX;\n+\n+  op = SET_SRC (set);\n+  if (GET_CODE (op) != ASHIFT\n+      && GET_CODE (op) != LSHIFTRT\n+      && GET_CODE (op) != ZERO_EXTEND)\n+    return NULL_RTX;\n+\n+  op_operand = XEXP (op, 0);\n+\n+  if (!resolve_reg_p (SET_DEST (set)) && !resolve_reg_p (op_operand))\n+    return NULL_RTX;\n+\n+  /* src_reg_num is the number of the word mode register which we\n+     are operating on.  For a left shift and a zero_extend on little\n+     endian machines this is register 0.  */\n+  src_reg_num = GET_CODE (op) == LSHIFTRT ? 1 : 0;\n+\n+  if (WORDS_BIG_ENDIAN)\n+    src_reg_num = 1 - src_reg_num;\n+\n+  if (GET_CODE (op) == ZERO_EXTEND)\n+    dest_reg_num = src_reg_num;\n+  else\n+    dest_reg_num = 1 - src_reg_num;\n+\n+  offset1 = UNITS_PER_WORD * dest_reg_num;\n+  offset2 = UNITS_PER_WORD * (1 - dest_reg_num);\n+  src_offset = UNITS_PER_WORD * src_reg_num;\n+\n+  if (WORDS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n+    {\n+      offset1 += UNITS_PER_WORD - 1;\n+      offset2 += UNITS_PER_WORD - 1;\n+      src_offset += UNITS_PER_WORD - 1;\n+    }\n+\n+  start_sequence ();\n+\n+  dest_reg = simplify_gen_subreg_concatn (word_mode, SET_DEST (set),\n+                                          GET_MODE (SET_DEST (set)),\n+                                          offset1);\n+  dest_zero = simplify_gen_subreg_concatn (word_mode, SET_DEST (set),\n+                                           GET_MODE (SET_DEST (set)),\n+                                           offset2);\n+  src_reg = simplify_gen_subreg_concatn (word_mode, op_operand,\n+                                         GET_MODE (op_operand),\n+                                         src_offset);\n+  if (GET_CODE (op) != ZERO_EXTEND)\n+    {\n+      int shift_count = INTVAL (XEXP (op, 1));\n+      if (shift_count > BITS_PER_WORD)\n+\tsrc_reg = expand_shift (GET_CODE (op) == ASHIFT ?\n+\t\t\t\tLSHIFT_EXPR : RSHIFT_EXPR,\n+\t\t\t\tword_mode, src_reg,\n+\t\t\t\tbuild_int_cst (NULL_TREE,\n+\t\t\t\t\t       shift_count - BITS_PER_WORD),\n+\t\t\t\tdest_reg, 1);\n+    }\n+\n+  if (dest_reg != src_reg)\n+    emit_move_insn (dest_reg, src_reg);\n+  emit_move_insn (dest_zero, CONST0_RTX (word_mode));\n+  insns = get_insns ();\n+\n+  end_sequence ();\n+\n+  emit_insn_before (insns, insn);\n+\n+  if (dump_file)\n+    {\n+      rtx in;\n+      fprintf (dump_file, \"; Replacing insn: %d with insns: \", INSN_UID (insn));\n+      for (in = insns; in != insn; in = NEXT_INSN (in))\n+\tfprintf (dump_file, \"%d \", INSN_UID (in));\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  delete_insn (insn);\n+  return insns;\n+}\n+\n /* Look for registers which are always accessed via word-sized SUBREGs\n    or via copies.  Decompose these registers into several word-sized\n    pseudo-registers.  */\n@@ -1003,6 +1152,9 @@ decompose_multiword_subregs (void)\n \t      || GET_CODE (PATTERN (insn)) == USE)\n \t    continue;\n \n+\t  if (find_decomposable_shift_zext (insn))\n+\t    continue;\n+\n \t  recog_memoized (insn);\n \t  extract_insn (insn);\n \n@@ -1152,6 +1304,19 @@ decompose_multiword_subregs (void)\n \t\t\t    SET_BIT (sub_blocks, bb->index);\n \t\t\t}\n \t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      rtx decomposed_shift;\n+\n+\t\t      decomposed_shift = resolve_shift_zext (insn);\n+\t\t      if (decomposed_shift != NULL_RTX)\n+\t\t\t{\n+\t\t\t  changed = true;\n+\t\t\t  insn = decomposed_shift;\n+\t\t\t  recog_memoized (insn);\n+\t\t\t  extract_insn (insn);\n+\t\t\t}\n+\t\t    }\n \n \t\t  for (i = recog_data.n_operands - 1; i >= 0; --i)\n \t\t    for_each_rtx (recog_data.operand_loc[i],"}, {"sha": "a20a0098fd01d361c58275733450b6741a1e0ad0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0892570a834b3230ad3d85fe37e7ea5398cab6e", "patch": "@@ -1,3 +1,7 @@\n+2007-08-07  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* gcc.dg/multiword-1.c: New testcase.\n+\n 2007-08-07  Daniel Franke  <franke.daniel@gmail.com>\n \n \t* gfortran.dg/namelist_33.f90: Improved tests, adjusted error"}, {"sha": "c08161791d6884b86ff7df14550692957416d8fb", "filename": "gcc/testsuite/gcc.dg/multiword-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2Ftestsuite%2Fgcc.dg%2Fmultiword-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0892570a834b3230ad3d85fe37e7ea5398cab6e/gcc%2Ftestsuite%2Fgcc.dg%2Fmultiword-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmultiword-1.c?ref=e0892570a834b3230ad3d85fe37e7ea5398cab6e", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+typedef unsigned int u32;\n+typedef unsigned long long u64;\n+\n+u64 __attribute__((noinline))\n+foo (u32 high, u32 low)\n+{\n+  return ((u64)high << 32) | low;\n+}\n+\n+u32 __attribute__((noinline))\n+right (u64 t)\n+{\n+  return (u32)(t >> 32);\n+}\n+\n+u64 __attribute__((noinline))\n+left (u32 t)\n+{\n+  return (u64)t << 32;\n+}\n+\n+u32 __attribute__((noinline))\n+right2 (u64 t)\n+{\n+  return (u32)(t >> 40);\n+}\n+\n+u64 __attribute__((noinline))\n+left2 (u32 t)\n+{\n+  return (u64)t << 40;\n+}\n+\n+u64 __attribute__((noinline))\n+zeroextend (u32 t)\n+{\n+  return (u64)t;\n+}\n+\n+extern void abort ();\n+\n+int\n+main ()\n+{\n+  if (foo (13000, 12000) != 55834574860000ULL)\n+    abort ();\n+\n+  if (right (55834574860000ULL) != 13000)\n+    abort ();\n+\n+  if (left (13000) != 55834574848000ULL)\n+    abort ();\n+\n+  if (right2 (55834574860000ULL) != 50)\n+    abort ();\n+\n+  if (left2 (13000) != 14293651161088000ULL)\n+    abort ();\n+\n+  if (zeroextend (13000) != 13000ULL)\n+    abort ();\n+\n+  return 0;\n+}"}]}