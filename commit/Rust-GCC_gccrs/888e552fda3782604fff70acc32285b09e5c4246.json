{"sha": "888e552fda3782604fff70acc32285b09e5c4246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg4ZTU1MmZkYTM3ODI2MDRmZmY3MGFjYzMyMjg1YjA5ZTVjNDI0Ng==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-08-22T19:50:12Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-08-22T19:50:12Z"}, "message": "Use macros to replace duplicated bodies of assembler code.\n\nFrom-SVN: r35890", "tree": {"sha": "6c8575bbd09f3c6cac2c5355649b255fbc678fdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c8575bbd09f3c6cac2c5355649b255fbc678fdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/888e552fda3782604fff70acc32285b09e5c4246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888e552fda3782604fff70acc32285b09e5c4246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/888e552fda3782604fff70acc32285b09e5c4246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/888e552fda3782604fff70acc32285b09e5c4246/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89e43e33153195963cf124b257a322f0b7f9c2df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e43e33153195963cf124b257a322f0b7f9c2df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e43e33153195963cf124b257a322f0b7f9c2df"}], "stats": {"total": 899, "additions": 292, "deletions": 607}, "files": [{"sha": "d82e97d16e4e32b020b917ae23dd5bb85418b821", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888e552fda3782604fff70acc32285b09e5c4246/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888e552fda3782604fff70acc32285b09e5c4246/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=888e552fda3782604fff70acc32285b09e5c4246", "patch": "@@ -1,3 +1,15 @@\n+2000-08-22  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/arm/lib1funcs.asm (ARM_DIV_MOD_BODY): New macro.\n+\tCommon code for ARM divide and modulus functions.\n+\t(THUMB_DIV_MOD_BODY): New macro. Thumb equivalent of\n+\tARM_DIV_MOD_BODY.\n+\t(FUNC_END): New macro: Common code at the end of the division and\n+\tmodulo functions.\n+\t(THUMB_FUNCTION_START): New macro:  Common code at the start of\n+\tThumb functions.\n+\t(__divsi3, __udivsi3, __modsi3, __umodsi3): Use new macros.\n+\t\n Tue Aug 22 20:34:52 2000  Kaz Kojima <kkojima@rr.iij4u.or.jp>\n \n \t* config/sh/sh.md (cmpeqdi_t splitter): Fix a reverse testing."}, {"sha": "08fa589cca124bbe8de02a85e766f0ecfb9511df", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 280, "deletions": 607, "changes": 887, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/888e552fda3782604fff70acc32285b09e5c4246/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/888e552fda3782604fff70acc32285b09e5c4246/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=888e552fda3782604fff70acc32285b09e5c4246", "patch": "@@ -27,6 +27,9 @@ along with this program; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n /* ------------------------------------------------------------------------ */\n+\n+/* We need to know what prefix to add to function names.  */\n+\n #ifndef __USER_LABEL_PREFIX__\n #error  __USER_LABEL_PREFIX__ not defined\n #endif\n@@ -55,6 +58,7 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n /* Function end macros.  Variants for 26 bit APCS and interworking.  */\n+\n #ifdef __APCS_26__\n # define RET\t\tmovs\tpc, lr\n # define RETc(x)\tmov##x##s\tpc, lr\n@@ -71,13 +75,15 @@ Ldiv0:\n #  define RET\t\tbx\tlr\n #  define RETc(x)\tbx##x\tlr\n .macro THUMB_LDIV0\n+Ldiv0:\n \tpush\t{ lr }\n \tbl\tSYM (__div0)\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n \tpop\t{ r1 }\n \tbx\tr1\n .endm\n .macro ARM_LDIV0\n+Ldiv0:\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n@@ -88,12 +94,14 @@ Ldiv0:\n #  define RET\t\tmov\tpc, lr\n #  define RETc(x)\tmov##x\tpc, lr\n .macro THUMB_LDIV0\n+Ldiv0:\n \tpush\t{ lr }\n \tbl\tSYM (__div0)\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n \tpop\t{ pc }\n .endm\n .macro ARM_LDIV0\n+Ldiv0:\n \tstr\tlr, [sp, #-4]!\n \tbl\tSYM (__div0) __PLT__\n \tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n@@ -103,6 +111,25 @@ Ldiv0:\n # define RETCOND\n #endif\n \n+.macro FUNC_END name\n+Ldiv0:\n+#ifdef __thumb__\n+\tTHUMB_LDIV0\n+#else\n+\tARM_LDIV0\n+#endif\n+\tSIZE (__\\name)\t\n+.endm\n+\n+.macro THUMB_FUNC_START name\n+\t.globl\tSYM (\\name)\n+\tTYPE\t(\\name)\n+\t.thumb_func\n+SYM (\\name):\n+.endm\n+\n+/* Function start macros.  Variants for ARM and Thumb.  */\n+\n #ifdef __thumb__\n #define THUMB_FUNC .thumb_func\n #define THUMB_CODE .force_thumb\n@@ -111,7 +138,6 @@ Ldiv0:\n #define THUMB_CODE\n #endif\n \t\n-\t\n .macro FUNC_START name\n \t.text\n \t.globl SYM (__\\name)\n@@ -121,208 +147,114 @@ Ldiv0:\n \tTHUMB_FUNC\n SYM (__\\name):\n .endm\n-\n-.macro FUNC_END name\n-Ldiv0:\n-#ifdef __thumb__\n-\tTHUMB_LDIV0\n-#else\n-\tARM_LDIV0\n-#endif\n-\tSIZE (__\\name)\t\n-.endm\n-\n-.macro THUMB_FUNC_START name\n-\t.globl\tSYM (\\name)\n-\tTYPE\t(\\name)\n-\t.thumb_func\n-SYM (\\name):\n-.endm\n \t\t\n-/* Used for Thumb code.  */\t\n-work\t\t.req\tr4\t@ XXXX is this safe ?\n-\n-/* ------------------------------------------------------------------------ */\n-#ifdef L_udivsi3\n+/* Register aliases.  */\n \n+work\t\t.req\tr4\t@ XXXX is this safe ?\n dividend\t.req\tr0\n divisor\t\t.req\tr1\n+overdone\t.req\tr2\n result\t\t.req\tr2\n curbit\t\t.req\tr3\n ip\t\t.req\tr12\n sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n-\t\n-\tFUNC_START udivsi3\n-\n-#ifdef __thumb__\n \n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n-\t\n-\tpush\t{ work }\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\n-\t@ Load the constant 0x10000000 into our work register\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tbcs     Lbignum\n-\tcmp\tdivisor, dividend\n-\tbcs     Lbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit,  #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ Set work to 0x80000000\n-\tlsl\twork, #3\n-Loop2:\t\t\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, work\n-\tbcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tbcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit,  #1\n-\tb\tLoop2\n-\n-Loop3:\n-\t@ Test for possible subtractions, and note which bits\n-\t@ are done in the result.  On the final pass, this may subtract\n-\t@ too much from the dividend, but the result will be ok, since the\n-\t@ \"bit\" will have been shifted out at the bottom.\n-\tcmp\tdividend, divisor\n-\tbcc     Over1\n-\tsub\tdividend, dividend, divisor\n-\torr\tresult, result, curbit\n-Over1:\t\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tbcc\tOver2\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #1\n-\torr\tresult, work\n-Over2:\t\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tbcc\tOver3\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #2\n-\torr\tresult, work\n-Over3:\t\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tbcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #3\n-\torr\tresult, work\n-Over4:\t\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tLgot_result\n-\tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n-\tbeq\tLgot_result\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n-Lgot_result:\n-\tmov\tr0, result\n-\tpop\t{ work }\n-\tRET\n-\n-#else /* ARM version.  */\n-\t\n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n+/* ------------------------------------------------------------------------ */\n+/*\t\tBodies of the divsion and modulo routines.\t\t    */\n+/* ------------------------------------------------------------------------ */\t\n+.macro ARM_DIV_MOD_BODY modulo\n Loop1:\n \t@ Unless the divisor is very big, shift it up in multiples of\n \t@ four bits, since this is the amount of unwinding in the main\n \t@ division loop.  Continue shifting until the divisor is \n \t@ larger than the dividend.\n \tcmp\tdivisor, #0x10000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #4\n-\tmovcc\tcurbit, curbit, lsl #4\n-\tbcc\tLoop1\n+\tcmpLO\tdivisor, dividend\n+\tmovLO\tdivisor, divisor, lsl #4\n+\tmovLO\tcurbit,  curbit,  lsl #4\n+\tbLO\tLoop1\n \n Lbignum:\n \t@ For very big divisors, we must shift it a bit at a time, or\n \t@ we will be in danger of overflowing.\n \tcmp\tdivisor, #0x80000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #1\n-\tmovcc\tcurbit, curbit, lsl #1\n-\tbcc\tLbignum\n+\tcmpLO\tdivisor, dividend\n+\tmovLO\tdivisor, divisor, lsl #1\n+\tmovLO\tcurbit,  curbit,  lsl #1\n+\tbLO\tLbignum\n \n Loop3:\n-\t@ Test for possible subtractions, and note which bits\n-\t@ are done in the result.  On the final pass, this may subtract\n-\t@ too much from the dividend, but the result will be ok, since the\n-\t@ \"bit\" will have been shifted out at the bottom.\n+\t@ Test for possible subtractions.  On the final pass, this may \n+\t@ subtract too much from the dividend ...\n+\t\n+  .if \\modulo\n+\t@ ... so keep track of which subtractions are done in OVERDONE.\n+\t@ We can fix them up afterwards.\n+\tmov\toverdone, #0\n \tcmp\tdividend, divisor\n-\tsubcs\tdividend, dividend, divisor\n-\torrcs\tresult, result, curbit\n-\tcmp\tdividend, divisor, lsr #1\n-\tsubcs\tdividend, dividend, divisor, lsr #1\n-\torrcs\tresult, result, curbit, lsr #1\n-\tcmp\tdividend, divisor, lsr #2\n-\tsubcs\tdividend, dividend, divisor, lsr #2\n-\torrcs\tresult, result, curbit, lsr #2\n-\tcmp\tdividend, divisor, lsr #3\n-\tsubcs\tdividend, dividend, divisor, lsr #3\n-\torrcs\tresult, result, curbit, lsr #3\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n-\tmovne\tdivisor, divisor, lsr #4\n-\tbne\tLoop3\n-Lgot_result:\n-\tmov\tr0, result\n-\tRET\t\n+\tsubHS\tdividend, dividend, divisor\n+\tcmp\tdividend, divisor,  lsr #1\n+\tsubHS\tdividend, dividend, divisor, lsr #1\n+\torrHS\toverdone, overdone, curbit,  ror #1\n+\tcmp\tdividend, divisor,  lsr #2\n+\tsubHS\tdividend, dividend, divisor, lsr #2\n+\torrHS\toverdone, overdone, curbit,  ror #2\n+\tcmp\tdividend, divisor,  lsr #3\n+\tsubHS\tdividend, dividend, divisor, lsr #3\n+\torrHS\toverdone, overdone, curbit,  ror #3\n+\tmov\tip,       curbit\n+  .else\n+\t@ ... so keep track of which subtractions are done in RESULT.\n+\t@ The result will be ok, since the \"bit\" will have been \n+\t@ shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tsubHS\tdividend, dividend, divisor\n+\torrHS\tresult,   result,   curbit\n+\tcmp\tdividend, divisor,  lsr #1\n+\tsubHS\tdividend, dividend, divisor, lsr #1\n+\torrHS\tresult,   result,   curbit,  lsr #1\n+\tcmp\tdividend, divisor,  lsr #2\n+\tsubHS\tdividend, dividend, divisor, lsr #2\n+\torrHS\tresult,   result,   curbit,  lsr #2\n+\tcmp\tdividend, divisor,  lsr #3\n+\tsubHS\tdividend, dividend, divisor, lsr #3\n+\torrHS\tresult,   result,   curbit,  lsr #3\n+  .endif\n \n-#endif /* ARM version */\n+\tcmp\tdividend, #0\t\t\t@ Early termination?\n+\tmovNEs\tcurbit,   curbit,  lsr #4\t@ No, any more bits to do?\n+\tmovNE\tdivisor,  divisor, lsr #4\n+\tbNE\tLoop3\n \n-\tFUNC_END udivsi3\n+  .if \\modulo\n+Lfixup_dividend:\t\n+\t@ Any subtractions that we should not have done will be recorded in\n+\t@ the top three bits of OVERDONE.  Exactly which were not needed\n+\t@ are governed by the position of the bit, stored in IP.\n+\tands\toverdone, overdone, #0xe0000000\n+\t@ If we terminated early, because dividend became zero, then the \n+\t@ bit in ip will not be in the bottom nibble, and we should not\n+\t@ perform the additions below.  We must test for this though\n+\t@ (rather relying upon the TSTs to prevent the additions) since\n+\t@ the bit in ip could be in the top two bits which might then match\n+\t@ with one of the smaller RORs.\n+\ttstNE\tip, #0x7\n+\tbEQ\tLgot_result\n+\ttst\toverdone, ip, ror #3\n+\taddNE\tdividend, dividend, divisor, lsr #3\n+\ttst\toverdone, ip, ror #2\n+\taddNE\tdividend, dividend, divisor, lsr #2\n+\ttst\toverdone, ip, ror #1\n+\taddNE\tdividend, dividend, divisor, lsr #1\n+  .endif\n \n-#endif /* L_udivsi3 */\n+Lgot_result:\n+.endm\n /* ------------------------------------------------------------------------ */\n-#ifdef L_umodsi3\n-\n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-overdone\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\t\n-\tFUNC_START umodsi3\n-\n-#ifdef __thumb__\n-\n-\tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tmov\tcurbit, #1\n-\tcmp\tdividend, divisor\n-\tbcs\tOver1\n-\tRET\t\n-\n-Over1:\t\n-\t@ Load the constant 0x10000000 into our work register\n-\tpush\t{ work }\n+.macro THUMB_DIV_MOD_BODY modulo\n+\t@ Load the constant 0x10000000 into our work register.\n \tmov\twork, #1\n \tlsl\twork, #28\n Loop1:\n@@ -331,11 +263,11 @@ Loop1:\n \t@ division loop.  Continue shifting until the divisor is \n \t@ larger than the dividend.\n \tcmp\tdivisor, work\n-\tbcs\tLbignum\n+\tbHS\tLbignum\n \tcmp\tdivisor, dividend\n-\tbcs\tLbignum\n+\tbHS\tLbignum\n \tlsl\tdivisor, #4\n-\tlsl\tcurbit, #4\n+\tlsl\tcurbit,  #4\n \tb\tLoop1\n Lbignum:\n \t@ Set work to 0x80000000\n@@ -344,68 +276,101 @@ Loop2:\n \t@ For very big divisors, we must shift it a bit at a time, or\n \t@ we will be in danger of overflowing.\n \tcmp\tdivisor, work\n-\tbcs\tLoop3\n+\tbHS\tLoop3\n \tcmp\tdivisor, dividend\n-\tbcs\tLoop3\n+\tbHS\tLoop3\n \tlsl\tdivisor, #1\n-\tlsl\tcurbit, #1\n+\tlsl\tcurbit,  #1\n \tb\tLoop2\n Loop3:\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend, so keep track of which\n-\t@ subtractions are done, we can fix them up afterwards...\n+\t@ Test for possible subtractions ...\n+  .if \\modulo\n+\t@ ... On the final pass, this may subtract too much from the dividend, \n+\t@ so keep track of which subtractions are done, we can fix them up \n+\t@ afterwards.\n \tmov\toverdone, #0\n \tcmp\tdividend, divisor\n-\tbcc\tOver2\n+\tbLO\tLover1\n \tsub\tdividend, dividend, divisor\n-Over2:\n+Lover1:\n \tlsr\twork, divisor, #1\n \tcmp\tdividend, work\n-\tbcc\tOver3\n+\tbLO\tLover2\n \tsub\tdividend, dividend, work\n \tmov\tip, curbit\n \tmov\twork, #1\n \tror\tcurbit, work\n \torr\toverdone, curbit\n \tmov\tcurbit, ip\n-Over3:\n+Lover2:\n \tlsr\twork, divisor, #2\n \tcmp\tdividend, work\n-\tbcc\tOver4\n+\tbLO\tLover3\n \tsub\tdividend, dividend, work\n \tmov\tip, curbit\n \tmov\twork, #2\n \tror\tcurbit, work\n \torr\toverdone, curbit\n \tmov\tcurbit, ip\n-Over4:\n+Lover3:\n \tlsr\twork, divisor, #3\n \tcmp\tdividend, work\n-\tbcc\tOver5\n+\tbLO\tLover4\n \tsub\tdividend, dividend, work\n \tmov\tip, curbit\n \tmov\twork, #3\n \tror\tcurbit, work\n \torr\toverdone, curbit\n \tmov\tcurbit, ip\n-Over5:\n+Lover4:\n \tmov\tip, curbit\n+  .else\n+\t@ ... and note which bits are done in the result.  On the final pass,\n+\t@ this may subtract too much from the dividend, but the result will be ok,\n+\t@ since the \"bit\" will have been shifted out at the bottom.\n+\tcmp\tdividend, divisor\n+\tbLO\tLover1\n+\tsub\tdividend, dividend, divisor\n+\torr\tresult, result, curbit\n+Lover1:\n+\tlsr\twork, divisor, #1\n+\tcmp\tdividend, work\n+\tbLO\tLover2\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #1\n+\torr\tresult, work\n+Lover2:\n+\tlsr\twork, divisor, #2\n+\tcmp\tdividend, work\n+\tbLO\tLover3\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #2\n+\torr\tresult, work\n+Lover3:\n+\tlsr\twork, divisor, #3\n+\tcmp\tdividend, work\n+\tbLO\tLover4\n+\tsub\tdividend, dividend, work\n+\tlsr\twork, curbit, #3\n+\torr\tresult, work\n+Lover4:\n+  .endif\n+\t\n \tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tOver6\n-\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n-\tbeq\tOver6\n+\tbEQ\tLover5\n+\tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n+\tbEQ\tLover5\n \tlsr\tdivisor, #4\n \tb\tLoop3\n-Over6:\t\n+Lover5:\n+  .if \\modulo\n \t@ Any subtractions that we should not have done will be recorded in\n \t@ the top three bits of \"overdone\".  Exactly which were not needed\n \t@ are governed by the position of the bit, stored in ip.\n \tmov\twork, #0xe\n-\tlsl\twork, #28\t\n+\tlsl\twork, #28\n \tand\toverdone, work\n-\tbne\tOver7\n-\tpop\t{ work }\n-\tRET\t\t\t\t\t@ No fixups needed\n+\tbEQ\tLgot_result\n \t\n \t@ If we terminated early, because dividend became zero, then the \n \t@ bit in ip will not be in the bottom nibble, and we should not\n@@ -416,103 +381,111 @@ Over6:\n \tmov\tcurbit, ip\n \tmov\twork, #0x7\n \ttst\tcurbit, work\n-\tbeq\tOver10\n+\tbEQ\tLgot_result\n \t\n-Over7:\n \tmov\tcurbit, ip\n \tmov\twork, #3\n \tror\tcurbit, work\n \ttst\toverdone, curbit\n-\tbeq\tOver8\n+\tbEQ\tLover6\n \tlsr\twork, divisor, #3\n-\tadd\tdividend, dividend, work\n-Over8:\n+\tadd\tdividend, work\n+Lover6:\n \tmov\tcurbit, ip\n \tmov\twork, #2\n \tror\tcurbit, work\n \ttst\toverdone, curbit\n-\tbeq\tOver9\n+\tbEQ\tLover7\n \tlsr\twork, divisor, #2\n-\tadd\tdividend, dividend, work\n-Over9:\n+\tadd\tdividend, work\n+Lover7:\n \tmov\tcurbit, ip\n \tmov\twork, #1\n \tror\tcurbit, work\n \ttst\toverdone, curbit\n-\tbeq\tOver10\n+\tbEQ\tLgot_result\n \tlsr\twork, divisor, #1\n-\tadd\tdividend, dividend, work\n-Over10:\n+\tadd\tdividend, work\n+  .endif\n+Lgot_result:\n+.endm\t\n+/* ------------------------------------------------------------------------ */\n+/*\t\tStart of the Real Functions\t\t\t\t    */\n+/* ------------------------------------------------------------------------ */\n+#ifdef L_udivsi3\n+\n+\tFUNC_START udivsi3\n+\n+#ifdef __thumb__\n+\n+\tcmp\tdivisor, #0\n+\tbEQ\tLdiv0\n+\tmov\tcurbit, #1\n+\tmov\tresult, #0\n+\t\n+\tpush\t{ work }\n+\tcmp\tdividend, divisor\n+\tbLO\tLgot_result\n+\n+\tTHUMB_DIV_MOD_BODY 0\n+\t\n+\tmov\tr0, result\n \tpop\t{ work }\n \tRET\n-\t\n-#else  /* ARM version.  */\n+\n+#else /* ARM version.  */\n \t\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbEQ\tLdiv0\n \tmov\tcurbit, #1\n+\tmov\tresult, #0\n \tcmp\tdividend, divisor\n-\tRETc(cc)\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, #0x10000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #4\n-\tmovcc\tcurbit, curbit, lsl #4\n-\tbcc\tLoop1\n+\tbLO\tLgot_result\n+\t\n+\tARM_DIV_MOD_BODY 0\n+\t\n+\tmov\tr0, result\n+\tRET\t\n \n-Lbignum:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, #0x80000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #1\n-\tmovcc\tcurbit, curbit, lsl #1\n-\tbcc\tLbignum\n+#endif /* ARM version */\n \n-Loop3:\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend, so keep track of which\n-\t@ subtractions are done, we can fix them up afterwards...\n-\tmov\toverdone, #0\n+\tFUNC_END udivsi3\n+\n+#endif /* L_udivsi3 */\n+/* ------------------------------------------------------------------------ */\n+#ifdef L_umodsi3\n+\n+\tFUNC_START umodsi3\n+\n+#ifdef __thumb__\n+\n+\tcmp\tdivisor, #0\n+\tbEQ\tLdiv0\n+\tmov\tcurbit, #1\n \tcmp\tdividend, divisor\n-\tsubcs\tdividend, dividend, divisor\n-\tcmp\tdividend, divisor, lsr #1\n-\tsubcs\tdividend, dividend, divisor, lsr #1\n-\torrcs\toverdone, overdone, curbit, ror #1\n-\tcmp\tdividend, divisor, lsr #2\n-\tsubcs\tdividend, dividend, divisor, lsr #2\n-\torrcs\toverdone, overdone, curbit, ror #2\n-\tcmp\tdividend, divisor, lsr #3\n-\tsubcs\tdividend, dividend, divisor, lsr #3\n-\torrcs\toverdone, overdone, curbit, ror #3\n-\tmov\tip, curbit\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n-\tmovne\tdivisor, divisor, lsr #4\n-\tbne\tLoop3\n+\tbHS\tLover10\n+\tRET\t\n \n-\t@ Any subtractions that we should not have done will be recorded in\n-\t@ the top three bits of \"overdone\".  Exactly which were not needed\n-\t@ are governed by the position of the bit, stored in ip.\n-\tands\toverdone, overdone, #0xe0000000\n-\t@ If we terminated early, because dividend became zero, then the \n-\t@ bit in ip will not be in the bottom nibble, and we should not\n-\t@ perform the additions below.  We must test for this though\n-\t@ (rather relying upon the TSTs to prevent the additions) since\n-\t@ the bit in ip could be in the top two bits which might then match\n-\t@ with one of the smaller RORs.\n-\ttstNE\tip, #0x7\n-\tRETc(eq)\t\t\t\t@ No fixups needed\n-\ttst\toverdone, ip, ror #3\n-\taddne\tdividend, dividend, divisor, lsr #3\n-\ttst\toverdone, ip, ror #2\n-\taddne\tdividend, dividend, divisor, lsr #2\n-\ttst\toverdone, ip, ror #1\n-\taddne\tdividend, dividend, divisor, lsr #1\n+Lover10:\n+\tpush\t{ work }\n+\n+\tTHUMB_DIV_MOD_BODY 1\n+\t\n+\tpop\t{ work }\n+\tRET\n+\t\n+#else  /* ARM version.  */\n+\t\n+\tcmp\tdivisor, #0\n+\tbEQ\tLdiv0\n+\tcmp     divisor, #1\n+\tcmpNE\tdividend, divisor\n+\tmovEQ   dividend, #0\n+\tRETc(LO)\n+\tmov\tcurbit, #1\n+\n+\tARM_DIV_MOD_BODY 1\n+\t\n \tRET\t\n \n #endif /* ARM version.  */\n@@ -523,20 +496,11 @@ Loop3:\n /* ------------------------------------------------------------------------ */\n #ifdef L_divsi3\n \n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-result\t\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\n \tFUNC_START divsi3\t\n \n #ifdef __thumb__\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n+\tbEQ\tLdiv0\n \t\n \tpush\t{ work }\n \tmov\twork, dividend\n@@ -545,150 +509,45 @@ pc\t\t.req\tr15\n \tmov\tcurbit, #1\n \tmov\tresult, #0\n \tcmp\tdivisor, #0\n-\tbpl\tOver1\n+\tbPL\tLover10\n \tneg\tdivisor, divisor\t@ Loops below use unsigned.\n-Over1:\t\n+Lover10:\n \tcmp\tdividend, #0\n-\tbpl\tOver2\n+\tbPL\tLover11\n \tneg\tdividend, dividend\n-Over2:\t\n+Lover11:\n \tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tBcs\tLbignum\n-\tcmp\tdivisor, dividend\n-\tBcs\tLbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit, #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tlsl\twork, #3\n-Loop2:\t\t\n-\tcmp\tdivisor, work\n-\tBcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tBcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit, #1\n-\tb\tLoop2\n+\tbLO\tLgot_result\n \n-Loop3:\n-\t@ Test for possible subtractions, and note which bits\n-\t@ are done in the result.  On the final pass, this may subtract\n-\t@ too much from the dividend, but the result will be ok, since the\n-\t@ \"bit\" will have been shifted out at the bottom.\n-\tcmp\tdividend, divisor\n-\tBcc\tOver3\n-\tsub\tdividend, dividend, divisor\n-\torr\tresult, result, curbit\n-Over3:\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tBcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #1\n-\torr\tresult, work\n-Over4:\t\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tBcc\tOver5\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #2\n-\torr\tresult, result, work\n-Over5:\t\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tBcc\tOver6\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #3\n-\torr\tresult, result, work\n-Over6:\t\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tBeq\tLgot_result\n-\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n-\tBeq\tLgot_result\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n+\tTHUMB_DIV_MOD_BODY 0\n \t\n-Lgot_result:\n \tmov\tr0, result\n \tmov\twork, ip\n \tcmp\twork, #0\n-\tBpl\tOver7\n+\tbPL\tLover12\n \tneg\tr0, r0\n-Over7:\n+Lover12:\n \tpop\t{ work }\n-\tRET\t\n+\tRET\n \n #else /* ARM version.  */\n \t\n \teor\tip, dividend, divisor\t\t@ Save the sign of the result.\n \tmov\tcurbit, #1\n \tmov\tresult, #0\n \tcmp\tdivisor, #0\n-\trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n-\tbeq\tLdiv0\n+\trsbMI\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n+\tbEQ\tLdiv0\n \tcmp\tdividend, #0\n-\trsbmi\tdividend, dividend, #0\n+\trsbMI\tdividend, dividend, #0\n \tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, #0x10000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #4\n-\tmovcc\tcurbit, curbit, lsl #4\n-\tbcc\tLoop1\n-\n-Lbignum:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, #0x80000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #1\n-\tmovcc\tcurbit, curbit, lsl #1\n-\tbcc\tLbignum\n+\tbLO\tLgot_result\n \n-Loop3:\n-\t@ Test for possible subtractions, and note which bits\n-\t@ are done in the result.  On the final pass, this may subtract\n-\t@ too much from the dividend, but the result will be ok, since the\n-\t@ \"bit\" will have been shifted out at the bottom.\n-\tcmp\tdividend, divisor\n-\tsubcs\tdividend, dividend, divisor\n-\torrcs\tresult, result, curbit\n-\tcmp\tdividend, divisor, lsr #1\n-\tsubcs\tdividend, dividend, divisor, lsr #1\n-\torrcs\tresult, result, curbit, lsr #1\n-\tcmp\tdividend, divisor, lsr #2\n-\tsubcs\tdividend, dividend, divisor, lsr #2\n-\torrcs\tresult, result, curbit, lsr #2\n-\tcmp\tdividend, divisor, lsr #3\n-\tsubcs\tdividend, dividend, divisor, lsr #3\n-\torrcs\tresult, result, curbit, lsr #3\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n-\tmovne\tdivisor, divisor, lsr #4\n-\tbne\tLoop3\n-Lgot_result:\n+\tARM_DIV_MOD_BODY 0\n+\t\n \tmov\tr0, result\n \tcmp\tip, #0\n-\trsbmi\tr0, r0, #0\n+\trsbMI\tr0, r0, #0\n \tRET\t\n \n #endif /* ARM version */\n@@ -699,242 +558,57 @@ Lgot_result:\n /* ------------------------------------------------------------------------ */\n #ifdef L_modsi3\n \n-dividend\t.req\tr0\n-divisor\t\t.req\tr1\n-overdone\t.req\tr2\n-curbit\t\t.req\tr3\n-ip\t\t.req\tr12\n-sp\t\t.req\tr13\n-lr\t\t.req\tr14\n-pc\t\t.req\tr15\n-\t\n \tFUNC_START modsi3\n \n #ifdef __thumb__\n \n \tmov\tcurbit, #1\n \tcmp\tdivisor, #0\n-\tbeq\tLdiv0\n-\tBpl\tOver1\n+\tbEQ\tLdiv0\n+\tbPL\tLover10\n \tneg\tdivisor, divisor\t\t@ Loops below use unsigned.\n-Over1:\t\n+Lover10:\n \tpush\t{ work }\n \t@ Need to save the sign of the dividend, unfortunately, we need\n-\t@ ip later on.  Must do this after saving the original value of\n+\t@ work later on.  Must do this after saving the original value of\n \t@ the work register, because we will pop this value off first.\n \tpush\t{ dividend }\n \tcmp\tdividend, #0\n-\tBpl\tOver2\n+\tbPL\tLover11\n \tneg\tdividend, dividend\n-Over2:\t\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\tmov\twork, #1\n-\tlsl\twork, #28\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, work\n-\tbcs\tLbignum\n-\tcmp\tdivisor, dividend\n-\tbcs\tLbignum\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit, #4\n-\tb\tLoop1\n-\n-Lbignum:\n-\t@ Set work to 0x80000000\n-\tlsl\twork, #3\n-Loop2:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, work\n-\tbcs\tLoop3\n-\tcmp\tdivisor, dividend\n-\tbcs\tLoop3\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit, #1\n-\tb\tLoop2\n-\n-Loop3:\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend, so keep track of which\n-\t@ subtractions are done, we can fix them up afterwards...\n-\tmov\toverdone, #0\n+Lover11:\n \tcmp\tdividend, divisor\n-\tbcc\tOver3\n-\tsub\tdividend, dividend, divisor\n-Over3:\n-\tlsr\twork, divisor, #1\n-\tcmp\tdividend, work\n-\tbcc\tOver4\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over4:\n-\tlsr\twork, divisor, #2\n-\tcmp\tdividend, work\n-\tbcc\tOver5\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over5:\n-\tlsr\twork, divisor, #3\n-\tcmp\tdividend, work\n-\tbcc\tOver6\n-\tsub\tdividend, dividend, work\n-\tmov\tip, curbit\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n-\tmov\tcurbit, ip\n-Over6:\n-\tmov\tip, curbit\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tbeq\tOver7\n-\tlsr\tcurbit, #4\t\t\t@ No, any more bits to do?\n-\tbeq\tOver7\n-\tlsr\tdivisor, #4\n-\tb\tLoop3\n+\tbLO\tLgot_result\n \n-Over7:\t\n-\t@ Any subtractions that we should not have done will be recorded in\n-\t@ the top three bits of \"overdone\".  Exactly which were not needed\n-\t@ are governed by the position of the bit, stored in ip.\n-\tmov\twork, #0xe\n-\tlsl\twork, #28\n-\tand\toverdone, work\n-\tbeq\tLgot_result\n-\t\n-\t@ If we terminated early, because dividend became zero, then the \n-\t@ bit in ip will not be in the bottom nibble, and we should not\n-\t@ perform the additions below.  We must test for this though\n-\t@ (rather relying upon the TSTs to prevent the additions) since\n-\t@ the bit in ip could be in the top two bits which might then match\n-\t@ with one of the smaller RORs.\n-\tmov\tcurbit, ip\n-\tmov\twork, #0x7\n-\ttst\tcurbit, work\n-\tbeq\tLgot_result\n-\t\n-\tmov\tcurbit, ip\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver8\n-\tlsr\twork, divisor, #3\n-\tadd\tdividend, dividend, work\n-Over8:\n-\tmov\tcurbit, ip\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tOver9\n-\tlsr\twork, divisor, #2\n-\tadd\tdividend, dividend, work\n-Over9:\n-\tmov\tcurbit, ip\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\ttst\toverdone, curbit\n-\tbeq\tLgot_result\n-\tlsr\twork, divisor, #1\n-\tadd\tdividend, dividend, work\n-Lgot_result:\n+\tTHUMB_DIV_MOD_BODY 1\n+\t\t\n \tpop\t{ work }\n \tcmp\twork, #0\n-\tbpl\tOver10\n+\tbPL\tLover12\n \tneg\tdividend, dividend\n-Over10:\n+Lover12:\n \tpop\t{ work }\n \tRET\t\n \n #else /* ARM version.  */\n \t\n-\tmov\tcurbit, #1\n \tcmp\tdivisor, #0\n-\trsbmi\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n-\tbeq\tLdiv0\n+\trsbMI\tdivisor, divisor, #0\t\t@ Loops below use unsigned.\n+\tbEQ\tLdiv0\n \t@ Need to save the sign of the dividend, unfortunately, we need\n \t@ ip later on; this is faster than pushing lr and using that.\n \tstr\tdividend, [sp, #-4]!\n-\tcmp\tdividend, #0\n-\trsbmi\tdividend, dividend, #0\n-\tcmp\tdividend, divisor\n-\tbcc\tLgot_result\n-\n-Loop1:\n-\t@ Unless the divisor is very big, shift it up in multiples of\n-\t@ four bits, since this is the amount of unwinding in the main\n-\t@ division loop.  Continue shifting until the divisor is \n-\t@ larger than the dividend.\n-\tcmp\tdivisor, #0x10000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #4\n-\tmovcc\tcurbit, curbit, lsl #4\n-\tbcc\tLoop1\n+\tcmp\tdividend, #0\t\t\t@ Test dividend against zero\n+\trsbMI\tdividend, dividend, #0\t\t@ If negative make positive\n+\tcmp\tdividend, divisor\t\t@ else if zero return zero\n+\tbLO\tLgot_result\t\t\t@ if smaller return dividend\n+\tmov\tcurbit, #1\n \n-Lbignum:\n-\t@ For very big divisors, we must shift it a bit at a time, or\n-\t@ we will be in danger of overflowing.\n-\tcmp\tdivisor, #0x80000000\n-\tcmpcc\tdivisor, dividend\n-\tmovcc\tdivisor, divisor, lsl #1\n-\tmovcc\tcurbit, curbit, lsl #1\n-\tbcc\tLbignum\n+\tARM_DIV_MOD_BODY 1\n \n-Loop3:\n-\t@ Test for possible subtractions.  On the final pass, this may \n-\t@ subtract too much from the dividend, so keep track of which\n-\t@ subtractions are done, we can fix them up afterwards...\n-\tmov\toverdone, #0\n-\tcmp\tdividend, divisor\n-\tsubcs\tdividend, dividend, divisor\n-\tcmp\tdividend, divisor, lsr #1\n-\tsubcs\tdividend, dividend, divisor, lsr #1\n-\torrcs\toverdone, overdone, curbit, ror #1\n-\tcmp\tdividend, divisor, lsr #2\n-\tsubcs\tdividend, dividend, divisor, lsr #2\n-\torrcs\toverdone, overdone, curbit, ror #2\n-\tcmp\tdividend, divisor, lsr #3\n-\tsubcs\tdividend, dividend, divisor, lsr #3\n-\torrcs\toverdone, overdone, curbit, ror #3\n-\tmov\tip, curbit\n-\tcmp\tdividend, #0\t\t\t@ Early termination?\n-\tmovnes\tcurbit, curbit, lsr #4\t\t@ No, any more bits to do?\n-\tmovne\tdivisor, divisor, lsr #4\n-\tbne\tLoop3\n-\n-\t@ Any subtractions that we should not have done will be recorded in\n-\t@ the top three bits of \"overdone\".  Exactly which were not needed\n-\t@ are governed by the position of the bit, stored in ip.\n-\tands\toverdone, overdone, #0xe0000000\n-\t@ If we terminated early, because dividend became zero, then the \n-\t@ bit in ip will not be in the bottom nibble, and we should not\n-\t@ perform the additions below.  We must test for this though\n-\t@ (rather relying upon the TSTs to prevent the additions) since\n-\t@ the bit in ip could be in the top two bits which might then match\n-\t@ with one of the smaller RORs.\n-\ttstNE\tip, #0x7\n-\tbeq\tLgot_result\n-\ttst\toverdone, ip, ror #3\n-\taddne\tdividend, dividend, divisor, lsr #3\n-\ttst\toverdone, ip, ror #2\n-\taddne\tdividend, dividend, divisor, lsr #2\n-\ttst\toverdone, ip, ror #1\n-\taddne\tdividend, dividend, divisor, lsr #1\n-Lgot_result:\n \tldr\tip, [sp], #4\n \tcmp\tip, #0\n-\trsbmi\tdividend, dividend, #0\n+\trsbMI\tdividend, dividend, #0\n \tRET\t\n \n #endif /* ARM version */\n@@ -1105,4 +779,3 @@ _arm_return:\n \tSIZE\t(_interwork_call_via_lr)\n \t\n #endif /* L_interwork_call_via_rX */\n-"}]}