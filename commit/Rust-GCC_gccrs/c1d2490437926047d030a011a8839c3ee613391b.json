{"sha": "c1d2490437926047d030a011a8839c3ee613391b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFkMjQ5MDQzNzkyNjA0N2QwMzBhMDExYTg4MzljM2VlNjEzMzkxYg==", "commit": {"author": {"name": "Tony Reix", "email": "tony.reix@atos.net", "date": "2017-06-07T23:23:55Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2017-06-07T23:23:55Z"}, "message": "simple-object-xcoff.c (simple_object_xcoff_find_sections): Search symbol table for .go_export symbol and apply pfn if found.\n\n2017-06-07  Tony Reix  <tony.reix@atos.net>\n            Matthieu Sarter  <matthieu.sarter.external@atos.net>\n            David Edelsohn  <dje.gcc@gmail.com>\n\n        * simple-object-xcoff.c (simple_object_xcoff_find_sections):\n        Search symbol table for .go_export symbol and apply pfn if found.\n\nCo-Authored-By: David Edelsohn <dje.gcc@gmail.com>\nCo-Authored-By: Matthieu Sarter <matthieu.sarter.external@atos.net>\n\nFrom-SVN: r248999", "tree": {"sha": "bbc528826e3402c9e25a0f45e8bcc12a825e8f5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bbc528826e3402c9e25a0f45e8bcc12a825e8f5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1d2490437926047d030a011a8839c3ee613391b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d2490437926047d030a011a8839c3ee613391b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1d2490437926047d030a011a8839c3ee613391b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1d2490437926047d030a011a8839c3ee613391b/comments", "author": {"login": "trex58", "id": 5690106, "node_id": "MDQ6VXNlcjU2OTAxMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/5690106?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trex58", "html_url": "https://github.com/trex58", "followers_url": "https://api.github.com/users/trex58/followers", "following_url": "https://api.github.com/users/trex58/following{/other_user}", "gists_url": "https://api.github.com/users/trex58/gists{/gist_id}", "starred_url": "https://api.github.com/users/trex58/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trex58/subscriptions", "organizations_url": "https://api.github.com/users/trex58/orgs", "repos_url": "https://api.github.com/users/trex58/repos", "events_url": "https://api.github.com/users/trex58/events{/privacy}", "received_events_url": "https://api.github.com/users/trex58/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "989cc652ee02ab598a01ccbeec55ca8e2b7df72d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989cc652ee02ab598a01ccbeec55ca8e2b7df72d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989cc652ee02ab598a01ccbeec55ca8e2b7df72d"}], "stats": {"total": 137, "additions": 128, "deletions": 9}, "files": [{"sha": "6e9ff713de1f4a1bc93c278dd5b8452422004b81", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d2490437926047d030a011a8839c3ee613391b/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d2490437926047d030a011a8839c3ee613391b/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=c1d2490437926047d030a011a8839c3ee613391b", "patch": "@@ -1,3 +1,10 @@\n+2017-06-07  Tony Reix  <tony.reix@atos.net>\n+\t    Matthieu Sarter  <matthieu.sarter.external@atos.net>\n+\t    David Edelsohn  <dje.gcc@gmail.com>\n+\n+\t* simple-object-xcoff.c (simple_object_xcoff_find_sections):\n+\tSearch symbol table for .go_export symbol and apply pfn if found.\n+\n 2017-05-31  DJ Delorie  <dj@redhat.com>\n \n \t* configure.ac (strnlen): Add to AC_CHECK_DECLS."}, {"sha": "7be1bf33fe3d1d277366172f7f656c7845b4c88e", "filename": "libiberty/simple-object-xcoff.c", "status": "modified", "additions": 121, "deletions": 9, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1d2490437926047d030a011a8839c3ee613391b/libiberty%2Fsimple-object-xcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1d2490437926047d030a011a8839c3ee613391b/libiberty%2Fsimple-object-xcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-xcoff.c?ref=c1d2490437926047d030a011a8839c3ee613391b", "patch": "@@ -138,15 +138,15 @@ struct external_syment\n   union {\n     struct {\n       union {\n-        /* The name of the symbol.  There is an implicit null character\n-           after the end of the array.  */\n-        char n_name[N_SYMNMLEN];\n-        struct {\n-          /* If n_zeroes is zero, n_offset is the offset the name from\n-             the start of the string table.  */\n-          unsigned char n_zeroes[4];\n-          unsigned char n_offset[4];\n-        } n;\n+/* The name of the symbol.  There is an implicit null character\n+   after the end of the array.  */\n+\tchar n_name[N_SYMNMLEN];\n+\tstruct {\n+\t  /* If n_zeroes is zero, n_offset is the offset the name from\n+\t     the start of the string table.  */\n+\t  unsigned char n_zeroes[4];\n+\t  unsigned char n_offset[4];\n+\t} n;\n       } n;\n \n       /* The symbol's value.  */\n@@ -258,6 +258,8 @@ union external_auxent\n #define C_STAT\t\t(3)\n #define C_FILE\t\t(103)\n \n+#define DBXMASK\t\t0x80\n+\n /* Private data for an simple_object_read.  */\n \n struct simple_object_xcoff_read\n@@ -403,7 +405,9 @@ simple_object_xcoff_find_sections (simple_object_read *sobj,\n   unsigned int nscns;\n   char *strtab;\n   size_t strtab_size;\n+  struct external_syment *symtab = NULL;\n   unsigned int i;\n+  off_t textptr = 0;\n \n   scnhdr_size = u64 ? SCNHSZ64 : SCNHSZ32;\n   scnbuf = XNEWVEC (unsigned char, scnhdr_size * ocr->nscns);\n@@ -485,10 +489,118 @@ simple_object_xcoff_find_sections (simple_object_read *sobj,\n \t\t\t\t\t      u.xcoff32.s_size));\n \t}\n \n+      if (strcmp (name, \".text\") == 0)\n+\ttextptr = scnptr;\n       if (!(*pfn) (data, name, scnptr, size))\n \tbreak;\n     }\n \n+  /* Special handling for .go_export CSECT. */\n+  if (textptr != 0 && ocr->nsyms > 0)\n+    {\n+      unsigned char *sym, *aux;\n+      const char *n_name;\n+      unsigned long n_value, n_offset, n_zeroes, x_scnlen;\n+\n+      /* Read symbol table. */\n+      symtab = XNEWVEC (struct external_syment, ocr->nsyms * SYMESZ);\n+      if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\tsobj->offset + ocr->symptr,\n+\t\t\t\t\t(unsigned char *)symtab,\n+\t\t\t\t\tocr->nsyms * SYMESZ,\n+\t\t\t\t\t&errmsg, err))\n+\t{\n+\t  XDELETEVEC (symtab);\n+\t  XDELETEVEC (scnbuf);\n+\t  return NULL;\n+\t}\n+\n+      /* Search in symbol table if we have a \".go_export\" symbol. */\n+      for (i = 0; i < ocr->nsyms; ++i)\n+\t{\n+\t  sym = (unsigned char *)&symtab[i];\n+\n+\t  if (symtab[i].n_sclass[0] & DBXMASK)\n+\t    {\n+\t      /* Skip debug symbols whose names are in stabs. */\n+\t      i += symtab[i].n_numaux[0];\n+\t      continue;\n+\t    }\n+\t  if (u64)\n+\t    {\n+\t      n_value = fetch_64 (sym + offsetof (struct external_syment,\n+\t\t\t\t\t\t  u.xcoff64.n_value));\n+\t      n_offset = fetch_32 (sym + offsetof (struct external_syment,\n+\t\t\t\t\t\t   u.xcoff64.n_offset));\n+\t    }\n+\t  else\n+\t    {\n+\t      /* \".go_export\" is longer than N_SYMNMLEN */\n+\t      n_zeroes = fetch_32 (sym + offsetof (struct external_syment,\n+\t\t\t\t\t\t   u.xcoff32.n.n.n_zeroes));\n+\t      if (n_zeroes != 0)\n+\t\t{\n+\t\t  /* Skip auxiliary entries. */\n+\t\t  i += symtab[i].n_numaux[0];\n+\t\t  continue;\n+\t\t}\n+\t      n_value = fetch_32 (sym + offsetof (struct external_syment,\n+\t\t\t\t\t\t  u.xcoff32.n_value));\n+\t      n_offset = fetch_32 (sym + offsetof (struct external_syment,\n+\t\t\t\t\t\t   u.xcoff32.n.n.n_offset));\n+\t    }\n+\n+\t  /* The real section name is found in the string table.  */\n+\t  if (strtab == NULL)\n+\t    {\n+\t      strtab = simple_object_xcoff_read_strtab (sobj,\n+\t  \t\t\t\t\t        &strtab_size,\n+\t\t\t\t\t\t\t&errmsg, err);\n+\t      if (strtab == NULL)\n+\t        {\n+                  XDELETEVEC (symtab);\n+\t          XDELETEVEC (scnbuf);\n+\t\t  return errmsg;\n+\t        }\n+\t    }\n+\n+\t  if (n_offset >= strtab_size)\n+            {\n+\t      XDELETEVEC (strtab);\n+\t      XDELETEVEC (symtab);\n+\t      XDELETEVEC (scnbuf);\n+\t      *err = 0;\n+   \t      return \"section string index out of range\";\n+            }\n+          n_name = strtab + n_offset;\n+\n+\t  if (!strcmp(n_name, \".go_export\"))\n+\t    {\n+\t      /* Found .go_export symbol, read auxiliary entry. */\n+\t      if (i + 1 >= ocr->nsyms)\n+\t\tbreak;\n+\n+\t      aux = (unsigned char *)&symtab[i + 1];\n+\t      if (u64)\n+\t\t{\n+\t\t  x_scnlen = fetch_32 (aux + offsetof (union external_auxent,\n+\t\t\t\t\t\t       u.xcoff64.x_csect.x_scnlen_lo));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  x_scnlen = fetch_32 (aux + offsetof (union external_auxent,\n+\t\t\t\t\t\t       u.xcoff32.x_csect.x_scnlen));\n+\t\t}\n+\t      (*pfn) (data, \".go_export\", textptr + n_value, x_scnlen);\n+\t      break;\n+\t    }\n+\t  /* Skip auxiliary entries. */\n+\t  i += symtab[i].n_numaux[0];\n+\t}\n+    }\n+\n+  if (symtab != NULL)\n+    XDELETEVEC (symtab);\n   if (strtab != NULL)\n     XDELETEVEC (strtab);\n   XDELETEVEC (scnbuf);"}]}