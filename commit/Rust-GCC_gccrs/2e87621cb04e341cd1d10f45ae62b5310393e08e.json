{"sha": "2e87621cb04e341cd1d10f45ae62b5310393e08e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU4NzYyMWNiMDRlMzQxY2QxZDEwZjQ1YWU2MmI1MzEwMzkzZTA4ZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-31T09:37:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-31T09:37:46Z"}, "message": "tree-ssa-forwprop.c (forward_propagate_into_comparison): Rename to ...\n\n2011-05-31  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-forwprop.c (forward_propagate_into_comparison): Rename\n\tto ...\n\t(forward_propagate_into_comparison_1): ... this.\n\t(forward_propagate_comparison): Rename to ...\n\t(forward_propagate_into_comparison): ... this.  Split out\n\treal forward propagation code to ...\n\t(forward_propagate_comparison): ... this.\n\t(forward_propagate_into_gimple_cond): Remove looping.\n\t(forward_propagate_into_cond): Likewise.\n\t(simplify_not_neg_expr): Return whether we have done something.\n\t(simplify_gimple_switch): Likewise.\n\t(tree_ssa_forward_propagate_single_use_vars): Rename to ...\n\t(ssa_forward_propagate_and_combine): ... this.  Re-structure\n\tto do a forward forward-propagation walk on BBs and a backward\n\tstmt combining walk on BBs.  Consistently re-scan changed\n\tstatements.\n\t(pass_forwprop): Adjust.\n\nFrom-SVN: r174470", "tree": {"sha": "71092f075f47e927d4c48dd0afb5918e087b8d10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71092f075f47e927d4c48dd0afb5918e087b8d10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e87621cb04e341cd1d10f45ae62b5310393e08e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e87621cb04e341cd1d10f45ae62b5310393e08e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e87621cb04e341cd1d10f45ae62b5310393e08e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e87621cb04e341cd1d10f45ae62b5310393e08e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7bc91385c6421076bda263938f31949b527e5fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bc91385c6421076bda263938f31949b527e5fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bc91385c6421076bda263938f31949b527e5fae"}], "stats": {"total": 741, "additions": 388, "deletions": 353}, "files": [{"sha": "192845576e84d2001c76c9a9816663654fac2355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87621cb04e341cd1d10f45ae62b5310393e08e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87621cb04e341cd1d10f45ae62b5310393e08e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e87621cb04e341cd1d10f45ae62b5310393e08e", "patch": "@@ -1,3 +1,23 @@\n+2011-05-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-forwprop.c (forward_propagate_into_comparison): Rename\n+\tto ...\n+\t(forward_propagate_into_comparison_1): ... this.\n+\t(forward_propagate_comparison): Rename to ...\n+\t(forward_propagate_into_comparison): ... this.  Split out\n+\treal forward propagation code to ...\n+\t(forward_propagate_comparison): ... this.\n+\t(forward_propagate_into_gimple_cond): Remove looping.\n+\t(forward_propagate_into_cond): Likewise.\n+\t(simplify_not_neg_expr): Return whether we have done something.\n+\t(simplify_gimple_switch): Likewise.\n+\t(tree_ssa_forward_propagate_single_use_vars): Rename to ...\n+\t(ssa_forward_propagate_and_combine): ... this.  Re-structure\n+\tto do a forward forward-propagation walk on BBs and a backward\n+\tstmt combining walk on BBs.  Consistently re-scan changed\n+\tstatements.\n+\t(pass_forwprop): Adjust.\n+\n 2011-05-30  Ian Lance Taylor  <iant@google.com>\n \n \t* godump.c (go_format_type): Correct length of name added to"}, {"sha": "56ba5226af400275f7ed25a5b392487145ffe88d", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 368, "deletions": 353, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87621cb04e341cd1d10f45ae62b5310393e08e/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87621cb04e341cd1d10f45ae62b5310393e08e/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2e87621cb04e341cd1d10f45ae62b5310393e08e", "patch": "@@ -392,9 +392,9 @@ combine_cond_expr_cond (location_t loc, enum tree_code code, tree type,\n    were no simplifying combines.  */\n \n static tree\n-forward_propagate_into_comparison (location_t loc,\n-\t\t\t\t   enum tree_code code, tree type,\n-\t\t\t\t   tree op0, tree op1)\n+forward_propagate_into_comparison_1 (location_t loc,\n+\t\t\t\t     enum tree_code code, tree type,\n+\t\t\t\t     tree op0, tree op1)\n {\n   tree tmp = NULL_TREE;\n   tree rhs0 = NULL_TREE, rhs1 = NULL_TREE;\n@@ -439,141 +439,31 @@ forward_propagate_into_comparison (location_t loc,\n   return tmp;\n }\n \n-/* Forward propagate the comparison defined in STMT like\n-   cond_1 = x CMP y to uses of the form\n-     a_1 = (T')cond_1\n-     a_1 = !cond_1\n-     a_1 = cond_1 != 0\n-   Returns 1 if a transformation was done and 2 if the CFG should\n-   be cleaned up.  Else returns 0.  */\n+/* Propagate from the ssa name definition statements of the assignment\n+   from a comparison at *GSI into the conditional if that simplifies it.\n+   Returns true if the stmt was modified, false if not.  */\n \n-static int \n-forward_propagate_comparison (gimple stmt)\n+static bool\n+forward_propagate_into_comparison (gimple_stmt_iterator *gsi)\n {\n-  tree name = gimple_assign_lhs (stmt);\n-  gimple use_stmt;\n-  tree tmp = NULL_TREE;\n-  int did_something = 0;\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree tmp;\n \n   /* Combine the comparison with defining statements.  */\n-  do\n+  tmp = forward_propagate_into_comparison_1 (gimple_location (stmt),\n+\t\t\t\t\t     gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t     TREE_TYPE\n+\t\t\t\t\t       (gimple_assign_lhs (stmt)),\n+\t\t\t\t\t     gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t     gimple_assign_rhs2 (stmt));\n+  if (tmp)\n     {\n-      tmp = forward_propagate_into_comparison (gimple_location (stmt),\n-\t\t\t\t\t       gimple_assign_rhs_code (stmt),\n-\t\t\t\t\t       TREE_TYPE (name),\n-\t\t\t\t\t       gimple_assign_rhs1 (stmt),\n-\t\t\t\t\t       gimple_assign_rhs2 (stmt));\n-      if (tmp)\n-\t{\n-\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\t  bool inv = is_gimple_min_invariant (tmp);\n-\t  gimple_assign_set_rhs_from_tree (&gsi, tmp);\n-\t  gcc_assert (gsi_stmt (gsi) == stmt);\n-\t  update_stmt (stmt);\n-\t  did_something = MAX (did_something, inv ? 2 : 1);\n-\t  if (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) != tcc_comparison)\n-\t    return did_something;\n-\t}\n-    }\n-  while (tmp);\n-\n-  /* Don't propagate ssa names that occur in abnormal phis.  */\n-  if ((TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n-      || (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n-        && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs2 (stmt))))\n-    return did_something;\n-\n-  /* Do not un-cse comparisons.  But propagate through copies.  */\n-  use_stmt = get_prop_dest_stmt (name, &name);\n-  if (!use_stmt)\n-    return did_something;\n-\n-  /* Conversion of the condition result to another integral type.  */\n-  if (is_gimple_assign (use_stmt)\n-      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n-\t  || TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n-\t     == tcc_comparison\n-          || gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (use_stmt))))\n-    {\n-      tree lhs = gimple_assign_lhs (use_stmt);\n-\n-      /* We can propagate the condition into a conversion.  */\n-      if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n-\t{\n-\t  /* Avoid using fold here as that may create a COND_EXPR with\n-\t     non-boolean condition as canonical form.  */\n-\t  tmp = build2 (gimple_assign_rhs_code (stmt), TREE_TYPE (lhs),\n-                        gimple_assign_rhs1 (stmt), gimple_assign_rhs2 (stmt));\n-\t}\n-      /* We can propagate the condition into X op CST where op\n-\t is EQ_EXPR or NE_EXPR and CST is either one or zero.  */\n-      else if (TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n-              == tcc_comparison\n-             && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n-             && TREE_CODE (gimple_assign_rhs2 (use_stmt)) == INTEGER_CST)\n-      {\n-        enum tree_code code = gimple_assign_rhs_code (use_stmt);\n-        tree cst = gimple_assign_rhs2 (use_stmt);\n-\ttree cond;\n-\n-\tcond = build2 (gimple_assign_rhs_code (stmt),\n-\t\t       TREE_TYPE (cst),\n-\t\t       gimple_assign_rhs1 (stmt),\n-\t\t       gimple_assign_rhs2 (stmt));\n-\n-        tmp = combine_cond_expr_cond (gimple_location (use_stmt),\n-\t\t\t\t      code, TREE_TYPE (lhs),\n-\t\t\t\t      cond, cst, false);\n-        if (tmp == NULL_TREE)\n-          return did_something;\n-      }\n-      /* We can propagate the condition into a statement that\n-\t computes the logical negation of the comparison result.  */\n-      else if (gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n-\t{\n-\t  tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t  bool nans = HONOR_NANS (TYPE_MODE (type));\n-\t  enum tree_code code;\n-\t  code = invert_tree_comparison (gimple_assign_rhs_code (stmt), nans);\n-\t  if (code == ERROR_MARK)\n-\t    return did_something;\n-\n-\t  tmp = build2 (code, TREE_TYPE (lhs), gimple_assign_rhs1 (stmt),\n-                        gimple_assign_rhs2 (stmt));\n-\t}\n-      else\n-\treturn did_something;\n-\n-      {\n-\tgimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-\tbool inv = is_gimple_min_invariant (tmp);\n-\tgimple_assign_set_rhs_from_tree (&gsi, unshare_expr (tmp));\n-\tdid_something = MAX (did_something, inv ? 2 : 1);\n-\tuse_stmt = gsi_stmt (gsi);\n-\tupdate_stmt (use_stmt);\n-      }\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  tree old_rhs = rhs_to_tree (TREE_TYPE (gimple_assign_lhs (stmt)),\n-                                      stmt);\n-\t  fprintf (dump_file, \"  Replaced '\");\n-\t  print_generic_expr (dump_file, old_rhs, dump_flags);\n-\t  fprintf (dump_file, \"' with '\");\n-\t  print_generic_expr (dump_file, tmp, dump_flags);\n-\t  fprintf (dump_file, \"'\\n\");\n-\t}\n-\n-      /* Remove defining statements.  */\n-      if (remove_prop_source_from_use (name))\n-\tdid_something = 2;\n-      else\n-\tdid_something = MAX (did_something, 1);\n+      gimple_assign_set_rhs_from_tree (gsi, tmp);\n+      update_stmt (stmt);\n+      return true;\n     }\n \n-  return did_something;\n+  return false;\n }\n \n /* Propagate from the ssa name definition statements of COND_EXPR\n@@ -588,48 +478,41 @@ forward_propagate_into_gimple_cond (gimple stmt)\n {\n   int did_something = 0;\n   location_t loc = gimple_location (stmt);\n+  tree tmp;\n+  enum tree_code code = gimple_cond_code (stmt);\n+\n+  /* We can do tree combining on SSA_NAME and comparison expressions.  */\n+  if (TREE_CODE_CLASS (gimple_cond_code (stmt)) != tcc_comparison)\n+    return 0;\n+\n+  tmp = forward_propagate_into_comparison_1 (loc, code,\n+\t\t\t\t\t     boolean_type_node,\n+\t\t\t\t\t     gimple_cond_lhs (stmt),\n+\t\t\t\t\t     gimple_cond_rhs (stmt));\n+  if (tmp)\n+    {\n+      if (dump_file && tmp)\n+\t{\n+\t  tree cond = build2 (gimple_cond_code (stmt),\n+\t\t\t      boolean_type_node,\n+\t\t\t      gimple_cond_lhs (stmt),\n+\t\t\t      gimple_cond_rhs (stmt));\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, cond, 0);\n+\t  fprintf (dump_file, \"' with '\");\n+\t  print_generic_expr (dump_file, tmp, 0);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n \n-  do {\n-    tree tmp = NULL_TREE;\n-    enum tree_code code = gimple_cond_code (stmt);\n-\n-    /* We can do tree combining on SSA_NAME and comparison expressions.  */\n-    if (TREE_CODE_CLASS (gimple_cond_code (stmt)) == tcc_comparison)\n-      tmp = forward_propagate_into_comparison (loc, code,\n-\t\t\t\t\t       boolean_type_node,\n-\t\t\t\t\t       gimple_cond_lhs (stmt),\n-\t\t\t\t\t       gimple_cond_rhs (stmt));\n-\n-    if (tmp)\n-      {\n-\tif (dump_file && tmp)\n-\t  {\n-            tree cond = build2 (gimple_cond_code (stmt),\n-\t\t\t\tboolean_type_node,\n-\t\t\t\tgimple_cond_lhs (stmt),\n-\t\t\t\tgimple_cond_rhs (stmt));\n-\t    fprintf (dump_file, \"  Replaced '\");\n-\t    print_generic_expr (dump_file, cond, 0);\n-\t    fprintf (dump_file, \"' with '\");\n-\t    print_generic_expr (dump_file, tmp, 0);\n-\t    fprintf (dump_file, \"'\\n\");\n-\t  }\n-\n-        gimple_cond_set_condition_from_tree (stmt, unshare_expr (tmp));\n-\tupdate_stmt (stmt);\n-\n-\t/* Remove defining statements.  */\n-\tif (is_gimple_min_invariant (tmp))\n-\t  did_something = 2;\n-\telse if (did_something == 0)\n-\t  did_something = 1;\n-\n-\t/* Continue combining.  */\n-\tcontinue;\n-      }\n+      gimple_cond_set_condition_from_tree (stmt, unshare_expr (tmp));\n+      update_stmt (stmt);\n \n-    break;\n-  } while (1);\n+      /* Remove defining statements.  */\n+      if (is_gimple_min_invariant (tmp))\n+\tdid_something = 2;\n+      else if (did_something == 0)\n+\tdid_something = 1;\n+    }\n \n   return did_something;\n }\n@@ -648,57 +531,49 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n   gimple stmt = gsi_stmt (*gsi_p);\n   location_t loc = gimple_location (stmt);\n   int did_something = 0;\n+  tree tmp = NULL_TREE;\n+  tree cond = gimple_assign_rhs1 (stmt);\n \n-  do {\n-    tree tmp = NULL_TREE;\n-    tree cond = gimple_assign_rhs1 (stmt);\n-\n-    /* We can do tree combining on SSA_NAME and comparison expressions.  */\n-    if (COMPARISON_CLASS_P (cond))\n-      tmp = forward_propagate_into_comparison (loc, TREE_CODE (cond),\n+  /* We can do tree combining on SSA_NAME and comparison expressions.  */\n+  if (COMPARISON_CLASS_P (cond))\n+    tmp = forward_propagate_into_comparison_1 (loc, TREE_CODE (cond),\n \t\t\t\t\t       boolean_type_node,\n \t\t\t\t\t       TREE_OPERAND (cond, 0),\n \t\t\t\t\t       TREE_OPERAND (cond, 1));\n-    else if (TREE_CODE (cond) == SSA_NAME)\n-      {\n-\ttree name = cond, rhs0;\n-\tgimple def_stmt = get_prop_source_stmt (name, true, NULL);\n-\tif (!def_stmt || !can_propagate_from (def_stmt))\n-\t  return did_something;\n-\n-\trhs0 = gimple_assign_rhs1 (def_stmt);\n-\ttmp = combine_cond_expr_cond (loc, NE_EXPR, boolean_type_node, rhs0,\n-\t\t\t\t      build_int_cst (TREE_TYPE (rhs0), 0),\n-\t\t\t\t      false);\n-      }\n-\n-    if (tmp)\n-      {\n-\tif (dump_file && tmp)\n-\t  {\n-\t    fprintf (dump_file, \"  Replaced '\");\n-\t    print_generic_expr (dump_file, cond, 0);\n-\t    fprintf (dump_file, \"' with '\");\n-\t    print_generic_expr (dump_file, tmp, 0);\n-\t    fprintf (dump_file, \"'\\n\");\n-\t  }\n+  else if (TREE_CODE (cond) == SSA_NAME)\n+    {\n+      tree name = cond, rhs0;\n+      gimple def_stmt = get_prop_source_stmt (name, true, NULL);\n+      if (!def_stmt || !can_propagate_from (def_stmt))\n+\treturn did_something;\n \n-\tgimple_assign_set_rhs_from_tree (gsi_p, unshare_expr (tmp));\n-\tstmt = gsi_stmt (*gsi_p);\n-\tupdate_stmt (stmt);\n+      rhs0 = gimple_assign_rhs1 (def_stmt);\n+      tmp = combine_cond_expr_cond (loc, NE_EXPR, boolean_type_node, rhs0,\n+\t\t\t\t    build_int_cst (TREE_TYPE (rhs0), 0),\n+\t\t\t\t    false);\n+    }\n \n-\t/* Remove defining statements.  */\n-\tif (is_gimple_min_invariant (tmp))\n-\t  did_something = 2;\n-\telse if (did_something == 0)\n-\t  did_something = 1;\n+  if (tmp)\n+    {\n+      if (dump_file && tmp)\n+\t{\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, cond, 0);\n+\t  fprintf (dump_file, \"' with '\");\n+\t  print_generic_expr (dump_file, tmp, 0);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n \n-\t/* Continue combining.  */\n-\tcontinue;\n-      }\n+      gimple_assign_set_rhs_from_tree (gsi_p, unshare_expr (tmp));\n+      stmt = gsi_stmt (*gsi_p);\n+      update_stmt (stmt);\n \n-    break;\n-  } while (1);\n+      /* Remove defining statements.  */\n+      if (is_gimple_min_invariant (tmp))\n+\tdid_something = 2;\n+      else if (did_something == 0)\n+\tdid_something = 1;\n+    }\n \n   return did_something;\n }\n@@ -1224,6 +1099,116 @@ forward_propagate_addr_expr (tree name, tree rhs)\n   return all && has_zero_uses (name);\n }\n \n+\n+/* Forward propagate the comparison defined in STMT like\n+   cond_1 = x CMP y to uses of the form\n+     a_1 = (T')cond_1\n+     a_1 = !cond_1\n+     a_1 = cond_1 != 0\n+   Returns true if stmt is now unused.  */\n+\n+static bool\n+forward_propagate_comparison (gimple stmt)\n+{\n+  tree name = gimple_assign_lhs (stmt);\n+  gimple use_stmt;\n+  tree tmp = NULL_TREE;\n+\n+  /* Don't propagate ssa names that occur in abnormal phis.  */\n+  if ((TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n+      || (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n+        && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs2 (stmt))))\n+    return false;\n+\n+  /* Do not un-cse comparisons.  But propagate through copies.  */\n+  use_stmt = get_prop_dest_stmt (name, &name);\n+  if (!use_stmt)\n+    return false;\n+\n+  /* Conversion of the condition result to another integral type.  */\n+  if (is_gimple_assign (use_stmt)\n+      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n+\t  || TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n+\t     == tcc_comparison\n+          || gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (use_stmt))))\n+    {\n+      tree lhs = gimple_assign_lhs (use_stmt);\n+\n+      /* We can propagate the condition into a conversion.  */\n+      if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n+\t{\n+\t  /* Avoid using fold here as that may create a COND_EXPR with\n+\t     non-boolean condition as canonical form.  */\n+\t  tmp = build2 (gimple_assign_rhs_code (stmt), TREE_TYPE (lhs),\n+                        gimple_assign_rhs1 (stmt), gimple_assign_rhs2 (stmt));\n+\t}\n+      /* We can propagate the condition into X op CST where op\n+\t is EQ_EXPR or NE_EXPR and CST is either one or zero.  */\n+      else if (TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n+              == tcc_comparison\n+             && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n+             && TREE_CODE (gimple_assign_rhs2 (use_stmt)) == INTEGER_CST)\n+      {\n+        enum tree_code code = gimple_assign_rhs_code (use_stmt);\n+        tree cst = gimple_assign_rhs2 (use_stmt);\n+\ttree cond;\n+\n+\tcond = build2 (gimple_assign_rhs_code (stmt),\n+\t\t       TREE_TYPE (cst),\n+\t\t       gimple_assign_rhs1 (stmt),\n+\t\t       gimple_assign_rhs2 (stmt));\n+\n+        tmp = combine_cond_expr_cond (gimple_location (use_stmt),\n+\t\t\t\t      code, TREE_TYPE (lhs),\n+\t\t\t\t      cond, cst, false);\n+        if (tmp == NULL_TREE)\n+          return false;\n+      }\n+      /* We can propagate the condition into a statement that\n+\t computes the logical negation of the comparison result.  */\n+      else if (gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n+\t{\n+\t  tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\t  bool nans = HONOR_NANS (TYPE_MODE (type));\n+\t  enum tree_code code;\n+\t  code = invert_tree_comparison (gimple_assign_rhs_code (stmt), nans);\n+\t  if (code == ERROR_MARK)\n+\t    return false;\n+\n+\t  tmp = build2 (code, TREE_TYPE (lhs), gimple_assign_rhs1 (stmt),\n+                        gimple_assign_rhs2 (stmt));\n+\t}\n+      else\n+\treturn false;\n+\n+      {\n+\tgimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\tgimple_assign_set_rhs_from_tree (&gsi, unshare_expr (tmp));\n+\tuse_stmt = gsi_stmt (gsi);\n+\tupdate_stmt (use_stmt);\n+      }\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  tree old_rhs = rhs_to_tree (TREE_TYPE (gimple_assign_lhs (stmt)),\n+                                      stmt);\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, old_rhs, dump_flags);\n+\t  fprintf (dump_file, \"' with '\");\n+\t  print_generic_expr (dump_file, tmp, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n+\n+      /* Remove defining statements.  */\n+      return remove_prop_source_from_use (name);\n+    }\n+\n+  return false;\n+}\n+\n+\n /* If we have lhs = ~x (STMT), look and see if earlier we had x = ~y.\n    If so, we can change STMT into lhs = y which can later be copy\n    propagated.  Similarly for negation.\n@@ -1236,9 +1221,11 @@ forward_propagate_addr_expr (tree name, tree rhs)\n    there's less work to do for each NOT/NEG expression we find.\n    Backwards propagation needs to look at the statement in a single\n    backlink.  Forward propagation needs to look at potentially more\n-   than one forward link.  */\n+   than one forward link.\n \n-static void\n+   Returns true when the statement was changed.  */\n+\n+static bool \n simplify_not_neg_expr (gimple_stmt_iterator *gsi_p)\n {\n   gimple stmt = gsi_stmt (*gsi_p);\n@@ -1258,14 +1245,17 @@ simplify_not_neg_expr (gimple_stmt_iterator *gsi_p)\n \t  gimple_assign_set_rhs_from_tree (gsi_p, rhs_def_operand);\n \t  stmt = gsi_stmt (*gsi_p);\n \t  update_stmt (stmt);\n+\t  return true;\n \t}\n     }\n+\n+  return false;\n }\n \n /* STMT is a SWITCH_EXPR for which we attempt to find equivalent forms of\n    the condition which we may be able to optimize better.  */\n \n-static void\n+static bool\n simplify_gimple_switch (gimple stmt)\n {\n   tree cond = gimple_switch_index (stmt);\n@@ -1311,10 +1301,13 @@ simplify_gimple_switch (gimple stmt)\n \t\t{\n \t\t  gimple_switch_set_index (stmt, def);\n \t\t  update_stmt (stmt);\n+\t\t  return true;\n \t\t}\n \t    }\n \t}\n     }\n+\n+  return false;\n }\n \n /* For pointers p2 and p1 return p2 - p1 if the\n@@ -2206,10 +2199,11 @@ combine_conversions (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n-/* Main entry point for the forward propagation optimizer.  */\n+/* Main entry point for the forward propagation and statement combine\n+   optimizer.  */\n \n static unsigned int\n-tree_ssa_forward_propagate_single_use_vars (void)\n+ssa_forward_propagate_and_combine (void)\n {\n   basic_block bb;\n   unsigned int todoflags = 0;\n@@ -2220,166 +2214,187 @@ tree_ssa_forward_propagate_single_use_vars (void)\n     {\n       gimple_stmt_iterator gsi;\n \n-      /* Note we update GSI within the loop as necessary.  */\n+      /* Apply forward propagation to all stmts in the basic-block.\n+\t Note we update GSI within the loop as necessary.  */\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n+\t  tree lhs, rhs;\n+\t  enum tree_code code;\n \n-\t  /* If this statement sets an SSA_NAME to an address,\n-\t     try to propagate the address into the uses of the SSA_NAME.  */\n-\t  if (is_gimple_assign (stmt))\n+\t  if (!is_gimple_assign (stmt))\n \t    {\n-\t      tree lhs = gimple_assign_lhs (stmt);\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\t      enum tree_code code = gimple_assign_rhs_code (stmt);\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n \n-\t      if (TREE_CODE (lhs) != SSA_NAME\n-\t\t  || has_zero_uses (lhs))\n-\t\t{\n-\t\t  gsi_next (&gsi);\n-\t\t  continue;\n-\t\t}\n+\t  lhs = gimple_assign_lhs (stmt);\n+\t  rhs = gimple_assign_rhs1 (stmt);\n+\t  code = gimple_assign_rhs_code (stmt);\n+\t  if (TREE_CODE (lhs) != SSA_NAME\n+\t      || has_zero_uses (lhs))\n+\t    {\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n \n-\t      if (code == ADDR_EXPR\n-\t\t  /* Handle pointer conversions on invariant addresses\n-\t\t     as well, as this is valid gimple.  */\n-\t\t  || (CONVERT_EXPR_CODE_P (code)\n-\t\t      && TREE_CODE (rhs) == ADDR_EXPR\n-\t\t      && POINTER_TYPE_P (TREE_TYPE (lhs))))\n-\t\t{\n-\t\t  tree base = get_base_address (TREE_OPERAND (rhs, 0));\n-\t\t  if ((!base\n-\t\t       || !DECL_P (base)\n-\t\t       || decl_address_invariant_p (base))\n-\t\t      && !stmt_references_abnormal_ssa_name (stmt)\n-\t\t      && forward_propagate_addr_expr (lhs, rhs))\n-\t\t    {\n-\t\t      release_defs (stmt);\n-\t\t      todoflags |= TODO_remove_unused_locals;\n-\t\t      gsi_remove (&gsi, true);\n-\t\t    }\n-\t\t  else\n-\t\t    gsi_next (&gsi);\n-\t\t}\n-\t      else if (code == POINTER_PLUS_EXPR\n-\t\t       && can_propagate_from (stmt))\n-\t\t{\n-\t\t  if (TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST\n-\t\t      /* ???  Better adjust the interface to that function\n-\t\t\t instead of building new trees here.  */\n-\t\t      && forward_propagate_addr_expr\n-\t\t           (lhs,\n-\t\t\t    build1 (ADDR_EXPR,\n-\t\t\t\t    TREE_TYPE (rhs),\n-\t\t\t\t    fold_build2 (MEM_REF,\n-\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (rhs)),\n-\t\t\t\t\t\t rhs,\n-\t\t\t\t\t\t fold_convert\n-\t\t\t\t\t\t   (ptr_type_node,\n-\t\t\t\t\t\t    gimple_assign_rhs2 (stmt))))))\n-\t\t    {\n-\t\t      release_defs (stmt);\n-\t\t      todoflags |= TODO_remove_unused_locals;\n-\t\t      gsi_remove (&gsi, true);\n-\t\t    }\n-\t\t  else if (is_gimple_min_invariant (rhs))\n-\t\t    {\n-\t\t      /* Make sure to fold &a[0] + off_1 here.  */\n-\t\t      fold_stmt_inplace (stmt);\n-\t\t      update_stmt (stmt);\n-\t\t      if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n-\t\t\tgsi_next (&gsi);\n-\t\t    }\n-\t\t  else\n-\t\t    gsi_next (&gsi);\n-\t\t}\n-\t      else if ((code == BIT_NOT_EXPR\n-\t\t        || code == NEGATE_EXPR)\n-\t\t       && TREE_CODE (rhs) == SSA_NAME)\n-\t\t{\n-\t\t  simplify_not_neg_expr (&gsi);\n-\t\t  gsi_next (&gsi);\n-\t\t}\n-\t      else if (code == COND_EXPR)\n-                {\n-                  /* In this case the entire COND_EXPR is in rhs1. */\n-\t\t  int did_something;\n-\t\t  fold_defer_overflow_warnings ();\n-                  did_something = forward_propagate_into_cond (&gsi);\n-\t\t  stmt = gsi_stmt (gsi);\n-\t\t  if (did_something == 2)\n-\t\t    cfg_changed = true;\n-\t\t  fold_undefer_overflow_warnings (!TREE_NO_WARNING (rhs)\n-\t\t    && did_something, stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n-\t\t  gsi_next (&gsi);\n-                }\n-\t      else if (TREE_CODE_CLASS (code) == tcc_comparison)\n-\t\t{\n-\t\t  bool no_warning = gimple_no_warning_p (stmt);\n-\t\t  int did_something;\n-\t\t  fold_defer_overflow_warnings ();\n-\t\t  did_something = forward_propagate_comparison (stmt);\n-\t\t  if (did_something == 2)\n-\t\t    cfg_changed = true;\n-\t\t  fold_undefer_overflow_warnings\n-\t\t    (!no_warning && did_something,\n-\t\t     stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n-\t\t  gsi_next (&gsi);\n-\t\t}\n-\t      else if (code == BIT_AND_EXPR\n-\t\t       || code == BIT_IOR_EXPR\n-\t\t       || code == BIT_XOR_EXPR)\n+\t  /* If this statement sets an SSA_NAME to an address,\n+\t     try to propagate the address into the uses of the SSA_NAME.  */\n+\t  if (code == ADDR_EXPR\n+\t      /* Handle pointer conversions on invariant addresses\n+\t\t as well, as this is valid gimple.  */\n+\t      || (CONVERT_EXPR_CODE_P (code)\n+\t\t  && TREE_CODE (rhs) == ADDR_EXPR\n+\t\t  && POINTER_TYPE_P (TREE_TYPE (lhs))))\n+\t    {\n+\t      tree base = get_base_address (TREE_OPERAND (rhs, 0));\n+\t      if ((!base\n+\t\t   || !DECL_P (base)\n+\t\t   || decl_address_invariant_p (base))\n+\t\t  && !stmt_references_abnormal_ssa_name (stmt)\n+\t\t  && forward_propagate_addr_expr (lhs, rhs))\n \t\t{\n-\t\t  if (!simplify_bitwise_binary (&gsi))\n-\t\t    gsi_next (&gsi);\n+\t\t  release_defs (stmt);\n+\t\t  todoflags |= TODO_remove_unused_locals;\n+\t\t  gsi_remove (&gsi, true);\n \t\t}\n-\t      else if (code == PLUS_EXPR\n-\t\t       || code == MINUS_EXPR)\n+\t      else\n+\t\tgsi_next (&gsi);\n+\t    }\n+\t  else if (code == POINTER_PLUS_EXPR\n+\t\t   && can_propagate_from (stmt))\n+\t    {\n+\t      if (TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST\n+\t\t  /* ???  Better adjust the interface to that function\n+\t\t     instead of building new trees here.  */\n+\t\t  && forward_propagate_addr_expr\n+\t\t  (lhs,\n+\t\t   build1 (ADDR_EXPR,\n+\t\t\t   TREE_TYPE (rhs),\n+\t\t\t   fold_build2 (MEM_REF,\n+\t\t\t\t\tTREE_TYPE (TREE_TYPE (rhs)),\n+\t\t\t\t\trhs,\n+\t\t\t\t\tfold_convert\n+\t\t\t\t\t(ptr_type_node,\n+\t\t\t\t\t gimple_assign_rhs2 (stmt))))))\n \t\t{\n-\t\t  cfg_changed |= associate_plusminus (stmt);\n-\t\t  gsi_next (&gsi);\n+\t\t  release_defs (stmt);\n+\t\t  todoflags |= TODO_remove_unused_locals;\n+\t\t  gsi_remove (&gsi, true);\n \t\t}\n-\t      else if (CONVERT_EXPR_CODE_P (code)\n-\t\t       || code == FLOAT_EXPR\n-\t\t       || code == FIX_TRUNC_EXPR)\n+\t      else if (is_gimple_min_invariant (rhs))\n \t\t{\n-\t\t  if (!combine_conversions (&gsi))\n+\t\t  /* Make sure to fold &a[0] + off_1 here.  */\n+\t\t  fold_stmt_inplace (stmt);\n+\t\t  update_stmt (stmt);\n+\t\t  if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR)\n \t\t    gsi_next (&gsi);\n \t\t}\n \t      else\n \t\tgsi_next (&gsi);\n \t    }\n-\t  else if (gimple_code (stmt) == GIMPLE_SWITCH)\n+\t  else if (TREE_CODE_CLASS (code) == tcc_comparison)\n \t    {\n-\t      simplify_gimple_switch (stmt);\n+\t      forward_propagate_comparison (stmt);\n \t      gsi_next (&gsi);\n \t    }\n-\t  else if (gimple_code (stmt) == GIMPLE_COND)\n-\t    {\n-\t      int did_something;\n-\t      fold_defer_overflow_warnings ();\n-\t      did_something = forward_propagate_into_gimple_cond (stmt);\n-\t      if (did_something == 2)\n-\t\tcfg_changed = true;\n-\t      fold_undefer_overflow_warnings (did_something, stmt,\n-\t\t\t\t\t      WARN_STRICT_OVERFLOW_CONDITIONAL);\n-\t      gsi_next (&gsi);\n-\t    }\n-\t  else if (is_gimple_call (stmt))\n-\t    {\n-\t      tree callee = gimple_call_fndecl (stmt);\n-\t      if (callee == NULL_TREE\n-\t\t  || DECL_BUILT_IN_CLASS (callee) != BUILT_IN_NORMAL\n-\t\t  || !simplify_builtin_call (&gsi, callee))\n-\t\tgsi_next (&gsi);\n-\t    }\n \t  else\n \t    gsi_next (&gsi);\n \t}\n+\n+      /* Combine stmts with the stmts defining their operands.\n+\t Note we update GSI within the loop as necessary.  */\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  bool changed = false;\n+\n+\t  switch (gimple_code (stmt))\n+\t    {\n+\t    case GIMPLE_ASSIGN:\n+\t      {\n+\t\ttree rhs1 = gimple_assign_rhs1 (stmt);\n+\t\tenum tree_code code = gimple_assign_rhs_code (stmt);\n+\n+\t\tif ((code == BIT_NOT_EXPR\n+\t\t     || code == NEGATE_EXPR)\n+\t\t    && TREE_CODE (rhs1) == SSA_NAME)\n+\t\t  changed = simplify_not_neg_expr (&gsi);\n+\t\telse if (code == COND_EXPR)\n+\t\t  {\n+\t\t    /* In this case the entire COND_EXPR is in rhs1. */\n+\t\t    int did_something;\n+\t\t    fold_defer_overflow_warnings ();\n+\t\t    did_something = forward_propagate_into_cond (&gsi);\n+\t\t    stmt = gsi_stmt (gsi);\n+\t\t    if (did_something == 2)\n+\t\t      cfg_changed = true;\n+\t\t    fold_undefer_overflow_warnings\n+\t\t      (!TREE_NO_WARNING (rhs1) && did_something, stmt,\n+\t\t       WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t\t    changed = did_something != 0;\n+\t\t  }\n+\t\telse if (TREE_CODE_CLASS (code) == tcc_comparison)\n+\t\t  {\n+\t\t    bool no_warning = gimple_no_warning_p (stmt);\n+\t\t    fold_defer_overflow_warnings ();\n+\t\t    changed = forward_propagate_into_comparison (&gsi);\n+\t\t    fold_undefer_overflow_warnings\n+\t\t\t(!no_warning && changed,\n+\t\t\t stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t\t  }\n+\t\telse if (code == BIT_AND_EXPR\n+\t\t\t || code == BIT_IOR_EXPR\n+\t\t\t || code == BIT_XOR_EXPR)\n+\t\t  changed = simplify_bitwise_binary (&gsi);\n+\t\telse if (code == PLUS_EXPR\n+\t\t\t || code == MINUS_EXPR)\n+\t\t  changed = associate_plusminus (stmt);\n+\t\telse if (CONVERT_EXPR_CODE_P (code)\n+\t\t\t || code == FLOAT_EXPR\n+\t\t\t || code == FIX_TRUNC_EXPR)\n+\t\t  changed = combine_conversions (&gsi);\n+\t\tbreak;\n+\t      }\n+\n+\t    case GIMPLE_SWITCH:\n+\t      changed = simplify_gimple_switch (stmt);\n+\t      break;\n+\n+\t    case GIMPLE_COND:\n+\t      {\n+\t\tint did_something;\n+\t\tfold_defer_overflow_warnings ();\n+\t\tdid_something = forward_propagate_into_gimple_cond (stmt);\n+\t\tif (did_something == 2)\n+\t\t  cfg_changed = true;\n+\t\tfold_undefer_overflow_warnings\n+\t\t  (did_something, stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t\tchanged = did_something != 0;\n+\t\tbreak;\n+\t      }\n+\n+\t    case GIMPLE_CALL:\n+\t      {\n+\t\ttree callee = gimple_call_fndecl (stmt);\n+\t\tif (callee != NULL_TREE\n+\t\t    && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL)\n+\t\t  changed = simplify_builtin_call (&gsi, callee);\n+\t\tbreak;\n+\t      }\n+\n+\t    default:;\n+\t    }\n+\n+\t  /* If the stmt changed try combining it again.  */\n+\t  if (!changed)\n+\t    gsi_prev (&gsi);\n+\t}\n     }\n \n   if (cfg_changed)\n     todoflags |= TODO_cleanup_cfg;\n+\n   return todoflags;\n }\n \n@@ -2396,7 +2411,7 @@ struct gimple_opt_pass pass_forwprop =\n   GIMPLE_PASS,\n   \"forwprop\",\t\t\t/* name */\n   gate_forwprop,\t\t/* gate */\n-  tree_ssa_forward_propagate_single_use_vars,\t/* execute */\n+  ssa_forward_propagate_and_combine,\t/* execute */\n   NULL,\t\t\t\t/* sub */\n   NULL,\t\t\t\t/* next */\n   0,\t\t\t\t/* static_pass_number */"}]}