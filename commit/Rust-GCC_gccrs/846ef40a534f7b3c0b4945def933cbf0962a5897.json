{"sha": "846ef40a534f7b3c0b4945def933cbf0962a5897", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ2ZWY0MGE1MzRmN2IzYzBiNDk0NWRlZjkzM2NiZjA5NjJhNTg5Nw==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2015-01-03T19:16:37Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2015-01-03T19:16:37Z"}, "message": "pa.md (decrement_and_branch_until_zero): Use `Q' constraint instead of `m' constraint.\n\n\t* config/pa/pa.md (decrement_and_branch_until_zero): Use `Q' constraint\n\tinstead of `m' constraint.  Likewise for unnamed movb comparison\n\tpatterns using reg_before_reload_operand predicate.\n\t* config/pa/predicates.md (reg_before_reload_operand): Tighten\n\tpredicate to reject register index and LO_SUM DLT memory forms\n\tafter reload.\n\nFrom-SVN: r219162", "tree": {"sha": "6d27ff113c30fb038e702aa82e7bac32f376cbd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d27ff113c30fb038e702aa82e7bac32f376cbd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/846ef40a534f7b3c0b4945def933cbf0962a5897", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/846ef40a534f7b3c0b4945def933cbf0962a5897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/846ef40a534f7b3c0b4945def933cbf0962a5897", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/846ef40a534f7b3c0b4945def933cbf0962a5897/comments", "author": null, "committer": null, "parents": [{"sha": "d50a179343470eda71460e1a8d6f076c3c060632", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d50a179343470eda71460e1a8d6f076c3c060632", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d50a179343470eda71460e1a8d6f076c3c060632"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "84fd92bef7450de6f54398fc31eced9c1402e0c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846ef40a534f7b3c0b4945def933cbf0962a5897/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846ef40a534f7b3c0b4945def933cbf0962a5897/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=846ef40a534f7b3c0b4945def933cbf0962a5897", "patch": "@@ -1,3 +1,12 @@\n+2015-01-03  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.md (decrement_and_branch_until_zero): Use `Q' constraint\n+\tinstead of `m' constraint.  Likewise for unnamed movb comparison\n+\tpatterns using reg_before_reload_operand predicate.\n+\t* config/pa/predicates.md (reg_before_reload_operand): Tighten\n+\tpredicate to reject register index and LO_SUM DLT memory forms\n+\tafter reload.\n+\t\n 2015-01-02  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/invoke.texi (Option Summary): Fix spelling of"}, {"sha": "6ee396a1cbf1e01bd3a6f1ccdcd8290b1c6d4bfb", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846ef40a534f7b3c0b4945def933cbf0962a5897/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846ef40a534f7b3c0b4945def933cbf0962a5897/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=846ef40a534f7b3c0b4945def933cbf0962a5897", "patch": "@@ -8922,14 +8922,14 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; strength reduction is used.  It is actually created when the instruction\n ;; combination phase combines the special loop test.  Since this insn\n ;; is both a jump insn and has an output, it must deal with its own\n-;; reloads, hence the `m' constraints.  The `!' constraints direct reload\n+;; reloads, hence the `Q' constraints.  The `!' constraints direct reload\n ;; to not choose the register alternatives in the event a reload is needed.\n (define_insn \"decrement_and_branch_until_zero\"\n   [(set (pc)\n \t(if_then_else\n \t  (match_operator 2 \"comparison_operator\"\n \t   [(plus:SI\n-\t      (match_operand:SI 0 \"reg_before_reload_operand\" \"+!r,!*f,*m\")\n+\t      (match_operand:SI 0 \"reg_before_reload_operand\" \"+!r,!*f,*Q\")\n \t      (match_operand:SI 1 \"int5_operand\" \"L,L,L\"))\n \t    (const_int 0)])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n@@ -9018,7 +9018,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t   [(match_operand:SI 1 \"register_operand\" \"r,r,r,r\") (const_int 0)])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n \t  (pc)))\n-   (set (match_operand:SI 0 \"reg_before_reload_operand\" \"=!r,!*f,*m,!*q\")\n+   (set (match_operand:SI 0 \"reg_before_reload_operand\" \"=!r,!*f,*Q,!*q\")\n \t(match_dup 1))]\n   \"\"\n \"* return pa_output_movb (operands, insn, which_alternative, 0); \"\n@@ -9090,7 +9090,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t   [(match_operand:SI 1 \"register_operand\" \"r,r,r,r\") (const_int 0)])\n \t  (pc)\n \t  (label_ref (match_operand 3 \"\" \"\"))))\n-   (set (match_operand:SI 0 \"reg_before_reload_operand\" \"=!r,!*f,*m,!*q\")\n+   (set (match_operand:SI 0 \"reg_before_reload_operand\" \"=!r,!*f,*Q,!*q\")\n \t(match_dup 1))]\n   \"\"\n \"* return pa_output_movb (operands, insn, which_alternative, 1); \""}, {"sha": "405cf7f63c32b1f82f3dbcc2b122c935e07b9bca", "filename": "gcc/config/pa/predicates.md", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/846ef40a534f7b3c0b4945def933cbf0962a5897/gcc%2Fconfig%2Fpa%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/846ef40a534f7b3c0b4945def933cbf0962a5897/gcc%2Fconfig%2Fpa%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpredicates.md?ref=846ef40a534f7b3c0b4945def933cbf0962a5897", "patch": "@@ -528,20 +528,29 @@\n ;; This predicate is used for branch patterns that internally handle\n ;; register reloading.  We need to accept non-symbolic memory operands\n ;; after reload to ensure that the pattern is still valid if reload\n-;; didn't find a hard register for the operand.\n+;; didn't find a hard register for the operand.  We also reject index\n+;; and lo_sum DLT address as these are invalid for move destinations.\n \n (define_predicate \"reg_before_reload_operand\"\n   (match_code \"reg,mem\")\n {\n+  rtx op0;\n+\n   if (register_operand (op, mode))\n     return true;\n \n-  if (reload_completed\n-      && memory_operand (op, mode)\n-      && !symbolic_memory_operand (op, mode))\n-    return true;\n+  if (!reload_in_progress && !reload_completed)\n+    return false;\n \n-  return false;\n+  if (! MEM_P (op))\n+    return false;\n+\n+  op0 = XEXP (op, 0);\n+\n+  return (memory_address_p (mode, op0)\n+\t  && !IS_INDEX_ADDR_P (op0)\n+\t  && !IS_LO_SUM_DLT_ADDR_P (op0)\n+\t  && !symbolic_memory_operand (op, mode));\n })\n \n ;; True iff OP is a register or const_0 operand for MODE."}]}