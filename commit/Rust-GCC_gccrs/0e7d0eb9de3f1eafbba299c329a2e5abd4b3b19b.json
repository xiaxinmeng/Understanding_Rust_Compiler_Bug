{"sha": "0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGU3ZDBlYjlkZTNmMWVhZmJiYTI5OWMzMjlhMmU1YWJkNGIzYjE5Yg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-08-28T01:24:42Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-08-28T01:24:42Z"}, "message": "(record_note_if_dead): Delete function.\n\n(record_reg_life_pat): Rewrite to handle any sort of pattern.\n(record_reg_life): Change interface to record_reg_life_pat.\n(stack_reg_life_analysis): Don't assume that MODE_FLOAT values are\nalways returned in a float reg.\n(subst_stack_regs_pat): Add support for sin and cos insns.\n\nFrom-SVN: r1980", "tree": {"sha": "404939d9f61bc672649fd1c83bb5b155051a7547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/404939d9f61bc672649fd1c83bb5b155051a7547"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b/comments", "author": null, "committer": null, "parents": [{"sha": "a1ee10a4f4848d25f604b90254bc945fbaae2b47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ee10a4f4848d25f604b90254bc945fbaae2b47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ee10a4f4848d25f604b90254bc945fbaae2b47"}], "stats": {"total": 222, "additions": 98, "deletions": 124}, "files": [{"sha": "1b7fb1be37e7b19b341d5ce491233913062ef4f3", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 98, "deletions": 124, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0e7d0eb9de3f1eafbba299c329a2e5abd4b3b19b", "patch": "@@ -245,7 +245,7 @@ static void dump_stack_info ();\n \n int\n stack_regs_mentioned_p (pat)\n-     register rtx pat;\n+     rtx pat;\n {\n   register char *fmt;\n   register int i;\n@@ -446,36 +446,6 @@ get_true_reg (pat)\n \n   return pat;\n }\n-\n-/* If REG is a stack register that is marked dead in REGSTACK, then\n-   record that it is now live. If REG is not DEST, add a death note to\n-   INSN if there isn't one already.  If DEST is not a reg, it is safe to\n-   assume that it does not mention a reg anywhere within. */\n-\n-static void\n-record_note_if_dead (insn, regstack, reg, dest)\n-     rtx insn;\n-     stack regstack;\n-     rtx reg, dest;\n-{\n-  reg = * get_true_reg (& reg);\n-\n-  if (STACK_REG_P (reg))\n-    {\n-      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (reg)))\n-\t{\n-\t  if ((! REG_P (dest) || REGNO (dest) != REGNO (reg))\n-\t      && ! find_regno_note (insn, REG_DEAD, REGNO (reg)))\n-\t    REG_NOTES (insn) = gen_rtx (EXPR_LIST,\n-\t\t\t\t\tREG_DEAD, reg, REG_NOTES (insn));\n-\n-\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (reg));\n-\t}\n-    }\n-  else\n-    if (stack_regs_mentioned_p (reg))\n-      abort ();\n-}\n \f\n /* Scan the OPERANDS and OPERAND_CONSTRAINTS of an asm_operands.\n    N_OPERANDS is the total number of operands.  Return which alternative\n@@ -796,7 +766,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n \n   rtx *clobber_reg;\n \n-  /* Find out what the constraints required.  If no constraint\n+  /* Find out what the constraints require.  If no constraint\n      alternative matches, that is a compiler bug: we should have caught\n      such an insn during reload.  */\n   i = constrain_asm_operands (n_operands, operands, constraints,\n@@ -981,103 +951,54 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n     }\n }\n \n-/* Scan PAT, which is part of INSN, and record the life & death of\n-   stack registers in REGSTACK.  If a register was dead, but is an input\n-   operand in this insn, then mark the register live and record a death\n-   note.\n-\n-   If a register is dead after this insn, but is an output operand in\n-   this insn, record a REG_UNUSED note.\n+/* Scan PAT, which is part of INSN, and record registers appearing in\n+   a SET_DEST in DEST, and other registers in SRC.\n \n    This function does not know about SET_DESTs that are both input and\n    output (such as ZERO_EXTRACT) - this cannot happen on a 387. */\n \n-static void\n-record_reg_life_pat (insn, regstack, pat)\n-     rtx insn;\n-     stack regstack;\n+void\n+record_reg_life_pat (pat, src, dest)\n      rtx pat;\n+     HARD_REG_SET *src, *dest;\n {\n-  rtx src, dest;\n-\n-  /* We should have already handled any asm.  */\n-  if (GET_CODE (pat) == ASM_INPUT || GET_CODE (pat) == ASM_OPERANDS)\n-    abort ();\n-\n-  if (GET_CODE (pat) != SET)\n-    return;\n-\n-  dest = * get_true_reg (& SET_DEST (pat));\n-\n-  /* The destination is dead before this insn.  If the destination is\n-     not used after this insn, record this with REG_UNUSED. */\n+  register char *fmt;\n+  register int i;\n \n-  if (STACK_REG_P (dest))\n+  if (STACK_REG_P (pat))\n     {\n-      /* ??? This check is unnecessary. */\n+      if (src)\n+\tSET_HARD_REG_BIT (*src, REGNO (pat));\n \n-      if (find_regno_note (insn, REG_UNUSED, REGNO (dest)))\n-\tabort ();\n+      if (dest)\n+\tSET_HARD_REG_BIT (*dest, REGNO (pat));\n \n-      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (dest)))\n-\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED, dest,\n-\t\t\t\t    REG_NOTES (insn));\n-\n-      CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (dest));\n+      return;\n     }\n-  else\n-    if (dest != cc0_rtx && stack_regs_mentioned_p (dest))\n-      abort ();\n-\n-  src = * get_true_reg (& SET_SRC (pat));\n \n-  switch (GET_CODE (src))\n+  if (GET_CODE (pat) == SET)\n     {\n-      /* ??? get_true_reg will make some of these cases redundant. */\n-\n-    case PLUS:\n-    case MINUS:\n-    case MULT:\n-    case DIV:\n-    case COMPARE:\n-      record_note_if_dead (insn, regstack, XEXP (src, 0), dest);\n-      record_note_if_dead (insn, regstack, XEXP (src, 1), dest);\n-      break;\n-\n-    case ABS:\n-    case NEG:\n-    case SQRT:\n-    case FLOAT_EXTEND:\n-    case FLOAT_TRUNCATE:\n-    case FLOAT:\n-    case UNSIGNED_FLOAT:\n-      record_note_if_dead (insn, regstack, XEXP (src, 0), dest);\n-      break;\n-\n-    case UNSIGNED_FIX:\n-    case FIX:\n-      src = XEXP (src, 0);\n-      if (GET_CODE (src) == FIX)\n-\trecord_note_if_dead (insn, regstack, XEXP (src, 0), dest);\n-      else\n-\trecord_note_if_dead (insn, regstack, src, dest);\n-      break;\n-\n-    case ASM_OPERANDS:\n-    case ASM_INPUT:\n-      abort ();  /* we should have caught this already. */\n-      break;\n+      record_reg_life_pat (XEXP (pat, 0), NULL_PTR, dest);\n+      record_reg_life_pat (XEXP (pat, 1), src, NULL_PTR);\n+      return;\n+    }\n \n-    case REG:\n-      record_note_if_dead (insn, regstack, src, dest);\n-      break;\n+  /* We don't need to consider either of these cases. */\n+  if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+    return;\n \n-    default:\n-      /* If a stack register appears in the src RTL, it is a bug, and\n-\t code should be added above to handle it. */\n+  fmt = GET_RTX_FORMAT (GET_CODE (pat));\n+  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'E')\n+\t{\n+\t  register int j;\n \n-      if (stack_regs_mentioned_p (src))\n-\tabort ();\n+\t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n+\t    record_reg_life_pat (XVECEXP (pat, i, j), src, dest);\n+\t}\n+      else if (fmt[i] == 'e')\n+\trecord_reg_life_pat (XEXP (pat, i), src, dest);\n     }\n }\n \f\n@@ -1167,15 +1088,34 @@ record_reg_life (insn, block, regstack)\n       return;\n     }\n \n-  if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+  /* An insn referencing a stack reg has a mode of QImode. */\n+  if (GET_MODE (insn) == QImode)\n     {\n-      register int i;\n+      HARD_REG_SET src, dest;\n+      int regno;\n+\n+      CLEAR_HARD_REG_SET (src);\n+      CLEAR_HARD_REG_SET (dest);\n+      record_reg_life_pat (PATTERN (insn), &src, &dest);\n \n-      for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n-\trecord_reg_life_pat (insn, regstack, XVECEXP (PATTERN (insn), 0, i));\n+      for (regno = FIRST_STACK_REG; regno <= LAST_STACK_REG; regno++)\n+\tif (! TEST_HARD_REG_BIT (regstack->reg_set, regno))\n+\t  {\n+\t    if (TEST_HARD_REG_BIT (src, regno)\n+\t\t&& ! TEST_HARD_REG_BIT (dest, regno))\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n+\t\t\t\t\t  FP_mode_reg[regno][(int) DFmode],\n+\t\t\t\t\t  REG_NOTES (insn));\n+\t    else if (TEST_HARD_REG_BIT (dest, regno)\n+\t\t     && ! TEST_HARD_REG_BIT (src, regno))\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED,\n+\t\t\t\t\t  FP_mode_reg[regno][(int) DFmode],\n+\t\t\t\t\t  REG_NOTES (insn));\n+\t  }\n+\n+      AND_COMPL_HARD_REG_SET (regstack->reg_set, dest);\n+      IOR_HARD_REG_SET (regstack->reg_set, src);\n     }\n-  else if (GET_MODE (insn) == QImode)\n-    record_reg_life_pat (insn, regstack, PATTERN (insn));\n \n   /* There might be a reg that is live after a function call.\n      Initialize it to zero so that the program does not crash.  See comment\n@@ -1186,8 +1126,7 @@ record_reg_life (insn, block, regstack)\n       int reg = FIRST_FLOAT_REG;\n \n       /* If a stack reg is mentioned in a CALL_INSN, it must be as the\n-\t return value; conversely, if a float is returned, a stack reg\n-\t must be mentioned. */\n+\t return value.  */\n \n       if (stack_regs_mentioned_p (PATTERN (insn)))\n \treg++;\n@@ -1317,21 +1256,24 @@ stack_reg_life_analysis (first)\n   int reg, block;\n   struct stack_def regstack;\n \n-  if (current_function_returns_real)\n+  if (current_function_returns_real\n+      && STACK_REG_P (DECL_RTL (DECL_RESULT (current_function_decl))))\n     {\n       /* Find all RETURN insns and mark them. */\n \n+      int value_regno = REGNO (DECL_RTL (DECL_RESULT (current_function_decl)));\n+\n       for (block = blocks - 1; block >= 0; block--)\n \tif (GET_CODE (block_end[block]) == JUMP_INSN\n \t    && GET_CODE (PATTERN (block_end[block])) == RETURN)\n-\t  SET_HARD_REG_BIT (block_out_reg_set[block], FIRST_STACK_REG);\n+\t  SET_HARD_REG_BIT (block_out_reg_set[block], value_regno);\n \n       /* Mark of the end of last block if we \"fall off\" the end of the\n \t function into the epilogue. */\n \n       if (GET_CODE (block_end[blocks-1]) != JUMP_INSN\n \t  || GET_CODE (PATTERN (block_end[blocks-1])) == RETURN)\n-\tSET_HARD_REG_BIT (block_out_reg_set[blocks-1], FIRST_STACK_REG);\n+\tSET_HARD_REG_BIT (block_out_reg_set[blocks-1], value_regno);\n     }\n \n   /* now scan all blocks backward for stack register use */\n@@ -2035,6 +1977,38 @@ subst_stack_regs_pat (insn, regstack, pat)\n \n \tbreak;\n \n+      case UNSPEC:\n+\tswitch (XINT (SET_SRC (pat), 1))\n+\t  {\n+\t  case 1: /* sin */\n+\t  case 2: /* cos */\n+\t    /* These insns only operate on the top of the stack.  */\n+\n+\t    src1 = get_true_reg (&XVECEXP (SET_SRC (pat), 0, 0));\n+\n+\t    emit_swap_insn (insn, regstack, *src1, emit_insn_before);\n+\n+\t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\n+\t    if (STACK_REG_P (*dest))\n+\t      replace_reg (dest, FIRST_STACK_REG);\n+\n+\t    if (src1_note)\n+\t      {\n+\t\treplace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t\tregstack->top--;\n+\t\tCLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n+\t      }\n+\n+\t    replace_reg (src1, FIRST_STACK_REG);\n+\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+\n       default:\n \tabort ();\n       }"}]}