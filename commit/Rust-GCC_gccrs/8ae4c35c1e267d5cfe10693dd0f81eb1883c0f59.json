{"sha": "8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlNGMzNWMxZTI2N2Q1Y2ZlMTA2OTNkZDBmODFlYjE4ODNjMGY1OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-08T23:54:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-08T23:54:15Z"}, "message": "compiler: Error for qualified ID as field name in struct literal.\n\nFrom-SVN: r203292", "tree": {"sha": "8a2089703104bb2edffd3b879536df152157fa6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a2089703104bb2edffd3b879536df152157fa6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/comments", "author": null, "committer": null, "parents": [{"sha": "a81169d8fa4382d7d4e702323096358dd31e174a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81169d8fa4382d7d4e702323096358dd31e174a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81169d8fa4382d7d4e702323096358dd31e174a"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "d5e3a67625a78b0d1f1024b539e50d5a6def6a91", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "patch": "@@ -11293,7 +11293,7 @@ Field_reference_expression::do_lower(Gogo* gogo, Named_object* function,\n     }\n \n   Expression* e = Expression::make_composite_literal(array_type, 0, false,\n-\t\t\t\t\t\t     bytes, loc);\n+\t\t\t\t\t\t     bytes, false, loc);\n \n   Variable* var = new Variable(array_type, e, true, false, false, loc);\n \n@@ -13236,9 +13236,11 @@ class Composite_literal_expression : public Parser_expression\n {\n  public:\n   Composite_literal_expression(Type* type, int depth, bool has_keys,\n-\t\t\t       Expression_list* vals, Location location)\n+\t\t\t       Expression_list* vals, bool all_are_names,\n+\t\t\t       Location location)\n     : Parser_expression(EXPRESSION_COMPOSITE_LITERAL, location),\n-      type_(type), depth_(depth), vals_(vals), has_keys_(has_keys)\n+      type_(type), depth_(depth), vals_(vals), has_keys_(has_keys),\n+      all_are_names_(all_are_names)\n   { }\n \n  protected:\n@@ -13256,6 +13258,7 @@ class Composite_literal_expression : public Parser_expression\n \t\t\t\t\t    (this->vals_ == NULL\n \t\t\t\t\t     ? NULL\n \t\t\t\t\t     : this->vals_->copy()),\n+\t\t\t\t\t    this->all_are_names_,\n \t\t\t\t\t    this->location());\n   }\n \n@@ -13285,6 +13288,9 @@ class Composite_literal_expression : public Parser_expression\n   // If this is true, then VALS_ is a list of pairs: a key and a\n   // value.  In an array initializer, a missing key will be NULL.\n   bool has_keys_;\n+  // If this is true, then HAS_KEYS_ is true, and every key is a\n+  // simple identifier.\n+  bool all_are_names_;\n };\n \n // Traversal.\n@@ -13387,6 +13393,8 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n   std::vector<Expression*> vals(field_count);\n   std::vector<int>* traverse_order = new(std::vector<int>);\n   Expression_list::const_iterator p = this->vals_->begin();\n+  Expression* external_expr = NULL;\n+  const Named_object* external_no = NULL;\n   while (p != this->vals_->end())\n     {\n       Expression* name_expr = *p;\n@@ -13492,6 +13500,12 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n \n       if (no != NULL)\n \t{\n+\t  if (no->package() != NULL && external_expr == NULL)\n+\t    {\n+\t      external_expr = name_expr;\n+\t      external_no = no;\n+\t    }\n+\n \t  name = no->name();\n \n \t  // A predefined name won't be packed.  If it starts with a\n@@ -13541,6 +13555,23 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n       traverse_order->push_back(index);\n     }\n \n+  if (!this->all_are_names_)\n+    {\n+      // This is a weird case like bug462 in the testsuite.\n+      if (external_expr == NULL)\n+\terror_at(this->location(), \"unknown field in %qs literal\",\n+\t\t (type->named_type() != NULL\n+\t\t  ? type->named_type()->message_name().c_str()\n+\t\t  : \"unnamed struct\"));\n+      else\n+\terror_at(external_expr->location(), \"unknown field %qs in %qs\",\n+\t\t external_no->message_name().c_str(),\n+\t\t (type->named_type() != NULL\n+\t\t  ? type->named_type()->message_name().c_str()\n+\t\t  : \"unnamed struct\"));\n+      return Expression::make_error(location);\n+    }\n+\n   Expression_list* list = new Expression_list;\n   list->reserve(field_count);\n   for (size_t i = 0; i < field_count; ++i)\n@@ -13830,11 +13861,11 @@ Composite_literal_expression::do_dump_expression(\n \n Expression*\n Expression::make_composite_literal(Type* type, int depth, bool has_keys,\n-\t\t\t\t   Expression_list* vals,\n+\t\t\t\t   Expression_list* vals, bool all_are_names,\n \t\t\t\t   Location location)\n {\n   return new Composite_literal_expression(type, depth, has_keys, vals,\n-\t\t\t\t\t  location);\n+\t\t\t\t\t  all_are_names, location);\n }\n \n // Return whether this expression is a composite literal."}, {"sha": "bc7a25f766a7bd1d015b6e2f06e8199d952d011b", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "patch": "@@ -291,10 +291,13 @@ class Expression\n   make_unsafe_cast(Type*, Expression*, Location);\n \n   // Make a composite literal.  The DEPTH parameter is how far down we\n-  // are in a list of composite literals with omitted types.\n+  // are in a list of composite literals with omitted types.  HAS_KEYS\n+  // is true if the expression list has keys alternating with values.\n+  // ALL_ARE_NAMES is true if all the keys could be struct field\n+  // names.\n   static Expression*\n   make_composite_literal(Type*, int depth, bool has_keys, Expression_list*,\n-\t\t\t Location);\n+\t\t\t bool all_are_names, Location);\n \n   // Make a struct composite literal.\n   static Expression*"}, {"sha": "498125bb2410272bd056a62bb1df51a7a1b949fb", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=8ae4c35c1e267d5cfe10693dd0f81eb1883c0f59", "patch": "@@ -2690,15 +2690,17 @@ Parse::composite_lit(Type* type, int depth, Location location)\n     {\n       this->advance_token();\n       return Expression::make_composite_literal(type, depth, false, NULL,\n-\t\t\t\t\t\tlocation);\n+\t\t\t\t\t\tfalse, location);\n     }\n \n   bool has_keys = false;\n+  bool all_are_names = true;\n   Expression_list* vals = new Expression_list;\n   while (true)\n     {\n       Expression* val;\n       bool is_type_omitted = false;\n+      bool is_name = false;\n \n       const Token* token = this->peek_token();\n \n@@ -2719,6 +2721,7 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t      val = this->id_to_expression(gogo->pack_hidden_name(identifier,\n \t\t\t\t\t\t\t\t  is_exported),\n \t\t\t\t\t   location);\n+\t      is_name = true;\n \t    }\n \t  else\n \t    {\n@@ -2744,6 +2747,7 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \t{\n \t  if (has_keys)\n \t    vals->push_back(NULL);\n+\t  is_name = false;\n \t}\n       else\n \t{\n@@ -2790,6 +2794,9 @@ Parse::composite_lit(Type* type, int depth, Location location)\n \n       vals->push_back(val);\n \n+      if (!is_name)\n+\tall_are_names = false;\n+\n       if (token->is_op(OPERATOR_COMMA))\n \t{\n \t  if (this->advance_token()->is_op(OPERATOR_RCURLY))\n@@ -2830,7 +2837,7 @@ Parse::composite_lit(Type* type, int depth, Location location)\n     }\n \n   return Expression::make_composite_literal(type, depth, has_keys, vals,\n-\t\t\t\t\t    location);\n+\t\t\t\t\t    all_are_names, location);\n }\n \n // FunctionLit = \"func\" Signature Block ."}]}