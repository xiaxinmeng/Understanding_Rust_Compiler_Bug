{"sha": "88fa5555a309e5d6c6171b957daaf2f800920869", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhmYTU1NTVhMzA5ZTVkNmM2MTcxYjk1N2RhYWYyZjgwMDkyMDg2OQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-08-05T18:08:33Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-08-05T18:08:33Z"}, "message": "On-demand locations within string-literals\n\ngcc/c-family/ChangeLog:\n\t* c-common.c: Include \"substring-locations.h\".\n\t(get_cpp_ttype_from_string_type): New function.\n\t(g_string_concat_db): New global.\n\t(substring_loc::get_range): New method.\n\t* c-common.h (g_string_concat_db): New declaration.\n\t(class substring_loc): New class.\n\t* c-lex.c (lex_string): When concatenating strings, capture the\n\tlocations of all tokens using a new obstack, and record the\n\tconcatenation locations within g_string_concat_db.\n\t* c-opts.c (c_common_init_options): Construct g_string_concat_db\n\ton the ggc-heap.\n\ngcc/ChangeLog:\n\t* input.c (string_concat::string_concat): New constructor.\n\t(string_concat_db::string_concat_db): New constructor.\n\t(string_concat_db::record_string_concatenation): New method.\n\t(string_concat_db::get_string_concatenation): New method.\n\t(string_concat_db::get_key_loc): New method.\n\t(class auto_cpp_string_vec): New class.\n\t(get_substring_ranges_for_loc): New function.\n\t(get_source_range_for_substring): New function.\n\t(get_num_source_ranges_for_substring): New function.\n\t(class selftest::lexer_test_options): New class.\n\t(struct selftest::lexer_test): New struct.\n\t(class selftest::ebcdic_execution_charset): New class.\n\t(selftest::ebcdic_execution_charset::s_singleton): New variable.\n\t(selftest::lexer_test::lexer_test): New constructor.\n\t(selftest::lexer_test::~lexer_test): New destructor.\n\t(selftest::lexer_test::get_token): New method.\n\t(selftest::assert_char_at_range): New function.\n\t(ASSERT_CHAR_AT_RANGE): New macro.\n\t(selftest::assert_num_substring_ranges): New function.\n\t(ASSERT_NUM_SUBSTRING_RANGES): New macro.\n\t(selftest::assert_has_no_substring_ranges): New function.\n\t(ASSERT_HAS_NO_SUBSTRING_RANGES): New macro.\n\t(selftest::test_lexer_string_locations_simple): New function.\n\t(selftest::test_lexer_string_locations_ebcdic): New function.\n\t(selftest::test_lexer_string_locations_hex): New function.\n\t(selftest::test_lexer_string_locations_oct): New function.\n\t(selftest::test_lexer_string_locations_letter_escape_1): New function.\n\t(selftest::test_lexer_string_locations_letter_escape_2): New function.\n\t(selftest::test_lexer_string_locations_ucn4): New function.\n\t(selftest::test_lexer_string_locations_ucn8): New function.\n\t(selftest::uint32_from_big_endian): New function.\n\t(selftest::test_lexer_string_locations_wide_string): New function.\n\t(selftest::uint16_from_big_endian): New function.\n\t(selftest::test_lexer_string_locations_string16): New function.\n\t(selftest::test_lexer_string_locations_string32): New function.\n\t(selftest::test_lexer_string_locations_u8): New function.\n\t(selftest::test_lexer_string_locations_utf8_source): New function.\n\t(selftest::test_lexer_string_locations_concatenation_1): New\n\tfunction.\n\t(selftest::test_lexer_string_locations_concatenation_2): New\n\tfunction.\n\t(selftest::test_lexer_string_locations_concatenation_3): New\n\tfunction.\n\t(selftest::test_lexer_string_locations_macro): New function.\n\t(selftest::test_lexer_string_locations_stringified_macro_argument):\n\tNew function.\n\t(selftest::test_lexer_string_locations_non_string): New function.\n\t(selftest::test_lexer_string_locations_long_line): New function.\n\t(selftest::test_lexer_char_constants): New function.\n\t(selftest::input_c_tests): Call the new test functions once per\n\tcase within the line_table test matrix.\n\t* input.h (struct string_concat): New struct.\n\t(struct location_hash): New struct.\n\t(class string_concat_db): New class.\n\t* substring-locations.h: New header.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/diagnostic-test-string-literals-1.c: New file.\n\t* gcc.dg/plugin/diagnostic-test-string-literals-2.c: New file.\n\t* gcc.dg/plugin/diagnostic_plugin_test_string_literals.c: New file.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above new files.\n\nlibcpp/ChangeLog:\n\t* charset.c (cpp_substring_ranges::cpp_substring_ranges): New\n\tconstructor.\n\t(cpp_substring_ranges::~cpp_substring_ranges): New destructor.\n\t(cpp_substring_ranges::add_range): New method.\n\t(cpp_substring_ranges::add_n_ranges): New method.\n\t(_cpp_valid_ucn): Add \"char_range\" and \"loc_reader\" params; if\n\tthey are non-NULL, read position information from *loc_reader\n\tand update char_range->m_finish accordingly.\n\t(convert_ucn): Add \"char_range\", \"loc_reader\", and \"ranges\"\n\tparams.  If loc_reader is non-NULL, read location information from\n\tit, and update *ranges accordingly, using char_range.\n\tConditionalize the conversion into tbuf on tbuf being non-NULL.\n\t(convert_hex): Likewise, conditionalizing the call to\n\temit_numeric_escape on tbuf.\n\t(convert_oct): Likewise.\n\t(convert_escape): Add params \"loc_reader\" and \"ranges\".  If\n\tloc_reader is non-NULL, read location information from it, and\n\tupdate *ranges accordingly.  Conditionalize the conversion into\n\ttbuf on tbuf being non-NULL.\n\t(cpp_interpret_string): Rename to...\n\t(cpp_interpret_string_1): ...this, adding params \"loc_readers\" and\n\t\"out\".  Use \"to\" to conditionalize the initialization and usage of\n\t\"tbuf\", such as running the converter.  If \"loc_readers\" is\n\tnon-NULL, use the instances within it, reading location\n\tinformation from them, and passing them to convert_escape; likewise\n\twrite to \"out\" if loc_readers is non-NULL.  Check for leading\n\tquote and issue an error if it is not present.  Update boundary\n\tcheck from \"== limit\" to \">= limit\" to protect against erroneous\n\tlocation values to calls that are not parsing string literals.\n\t(cpp_interpret_string): Reimplement in terms to\n\tcpp_interpret_string_1.\n\t(noop_error_cb): New function.\n\t(cpp_interpret_string_ranges): New function.\n\t(cpp_string_location_reader::cpp_string_location_reader): New\n\tconstructor.\n\t(cpp_string_location_reader::get_next): New method.\n\t* include/cpplib.h (class cpp_string_location_reader): New class.\n\t(class cpp_substring_ranges): New class.\n\t(cpp_interpret_string_ranges): New prototype.\n\t* internal.h (_cpp_valid_ucn): Add params \"char_range\" and\n\t\"loc_reader\".\n\t* lex.c (forms_identifier_p): Pass NULL for new params to\n\t_cpp_valid_ucn.\n\nFrom-SVN: r239175", "tree": {"sha": "da539f06e1f9c9f39cb46858aa0305df57b746c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da539f06e1f9c9f39cb46858aa0305df57b746c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88fa5555a309e5d6c6171b957daaf2f800920869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fa5555a309e5d6c6171b957daaf2f800920869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88fa5555a309e5d6c6171b957daaf2f800920869", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88fa5555a309e5d6c6171b957daaf2f800920869/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1addb9e62b8970734343074e4a2b38f924954850", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1addb9e62b8970734343074e4a2b38f924954850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1addb9e62b8970734343074e4a2b38f924954850"}], "stats": {"total": 2823, "additions": 2767, "deletions": 56}, "files": [{"sha": "40ca18ca3efb635614abe26cfc4f0739150a6ef4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1,3 +1,61 @@\n+2016-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* input.c (string_concat::string_concat): New constructor.\n+\t(string_concat_db::string_concat_db): New constructor.\n+\t(string_concat_db::record_string_concatenation): New method.\n+\t(string_concat_db::get_string_concatenation): New method.\n+\t(string_concat_db::get_key_loc): New method.\n+\t(class auto_cpp_string_vec): New class.\n+\t(get_substring_ranges_for_loc): New function.\n+\t(get_source_range_for_substring): New function.\n+\t(get_num_source_ranges_for_substring): New function.\n+\t(class selftest::lexer_test_options): New class.\n+\t(struct selftest::lexer_test): New struct.\n+\t(class selftest::ebcdic_execution_charset): New class.\n+\t(selftest::ebcdic_execution_charset::s_singleton): New variable.\n+\t(selftest::lexer_test::lexer_test): New constructor.\n+\t(selftest::lexer_test::~lexer_test): New destructor.\n+\t(selftest::lexer_test::get_token): New method.\n+\t(selftest::assert_char_at_range): New function.\n+\t(ASSERT_CHAR_AT_RANGE): New macro.\n+\t(selftest::assert_num_substring_ranges): New function.\n+\t(ASSERT_NUM_SUBSTRING_RANGES): New macro.\n+\t(selftest::assert_has_no_substring_ranges): New function.\n+\t(ASSERT_HAS_NO_SUBSTRING_RANGES): New macro.\n+\t(selftest::test_lexer_string_locations_simple): New function.\n+\t(selftest::test_lexer_string_locations_ebcdic): New function.\n+\t(selftest::test_lexer_string_locations_hex): New function.\n+\t(selftest::test_lexer_string_locations_oct): New function.\n+\t(selftest::test_lexer_string_locations_letter_escape_1): New function.\n+\t(selftest::test_lexer_string_locations_letter_escape_2): New function.\n+\t(selftest::test_lexer_string_locations_ucn4): New function.\n+\t(selftest::test_lexer_string_locations_ucn8): New function.\n+\t(selftest::uint32_from_big_endian): New function.\n+\t(selftest::test_lexer_string_locations_wide_string): New function.\n+\t(selftest::uint16_from_big_endian): New function.\n+\t(selftest::test_lexer_string_locations_string16): New function.\n+\t(selftest::test_lexer_string_locations_string32): New function.\n+\t(selftest::test_lexer_string_locations_u8): New function.\n+\t(selftest::test_lexer_string_locations_utf8_source): New function.\n+\t(selftest::test_lexer_string_locations_concatenation_1): New\n+\tfunction.\n+\t(selftest::test_lexer_string_locations_concatenation_2): New\n+\tfunction.\n+\t(selftest::test_lexer_string_locations_concatenation_3): New\n+\tfunction.\n+\t(selftest::test_lexer_string_locations_macro): New function.\n+\t(selftest::test_lexer_string_locations_stringified_macro_argument):\n+\tNew function.\n+\t(selftest::test_lexer_string_locations_non_string): New function.\n+\t(selftest::test_lexer_string_locations_long_line): New function.\n+\t(selftest::test_lexer_char_constants): New function.\n+\t(selftest::input_c_tests): Call the new test functions once per\n+\tcase within the line_table test matrix.\n+\t* input.h (struct string_concat): New struct.\n+\t(struct location_hash): New struct.\n+\t(class string_concat_db): New class.\n+\t* substring-locations.h: New header.\n+\n 2016-08-05  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR tree-optimization/72810"}, {"sha": "d5cdfed537a45175323d2c6c1d130d370ca07140", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1,3 +1,17 @@\n+2016-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-common.c: Include \"substring-locations.h\".\n+\t(get_cpp_ttype_from_string_type): New function.\n+\t(g_string_concat_db): New global.\n+\t(substring_loc::get_range): New method.\n+\t* c-common.h (g_string_concat_db): New declaration.\n+\t(class substring_loc): New class.\n+\t* c-lex.c (lex_string): When concatenating strings, capture the\n+\tlocations of all tokens using a new obstack, and record the\n+\tconcatenation locations within g_string_concat_db.\n+\t* c-opts.c (c_common_init_options): Construct g_string_concat_db\n+\ton the ggc-heap.\n+\n 2016-07-29  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/71926"}, {"sha": "569f000150f277b2356318ac199ad7a2769578a2", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -45,6 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"opts.h\"\n #include \"gimplify.h\"\n+#include \"substring-locations.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n@@ -1098,6 +1099,67 @@ fix_string_type (tree value)\n   TREE_STATIC (value) = 1;\n   return value;\n }\n+\n+/* Given a string of type STRING_TYPE, determine what kind of string\n+   token would give an equivalent execution encoding: CPP_STRING,\n+   CPP_STRING16, or CPP_STRING32.  Return CPP_OTHER in case of error.\n+   This may not be exactly the string token type that initially created\n+   the string, since CPP_WSTRING is indistinguishable from the 16/32 bit\n+   string type at this point.\n+\n+   This effectively reverses part of the logic in lex_string and\n+   fix_string_type.  */\n+\n+static enum cpp_ttype\n+get_cpp_ttype_from_string_type (tree string_type)\n+{\n+  gcc_assert (string_type);\n+  if (TREE_CODE (string_type) != ARRAY_TYPE)\n+    return CPP_OTHER;\n+\n+  tree element_type = TREE_TYPE (string_type);\n+  if (TREE_CODE (element_type) != INTEGER_TYPE)\n+    return CPP_OTHER;\n+\n+  int bits_per_character = TYPE_PRECISION (element_type);\n+  switch (bits_per_character)\n+    {\n+    case 8:\n+      return CPP_STRING;  /* It could have also been CPP_UTF8STRING.  */\n+    case 16:\n+      return CPP_STRING16;\n+    case 32:\n+      return CPP_STRING32;\n+    }\n+\n+  return CPP_OTHER;\n+}\n+\n+/* The global record of string concatentations, for use in\n+   extracting locations within string literals.  */\n+\n+GTY(()) string_concat_db *g_string_concat_db;\n+\n+/* Attempt to determine the source range of the substring.\n+   If successful, return NULL and write the source range to *OUT_RANGE.\n+   Otherwise return an error message.  Error messages are intended\n+   for GCC developers (to help debugging) rather than for end-users.  */\n+\n+const char *\n+substring_loc::get_range (source_range *out_range) const\n+{\n+  gcc_assert (out_range);\n+\n+  enum cpp_ttype tok_type = get_cpp_ttype_from_string_type (m_string_type);\n+  if (tok_type == CPP_OTHER)\n+    return \"unrecognized string type\";\n+\n+  return get_source_range_for_substring (parse_in, g_string_concat_db,\n+\t\t\t\t\t m_fmt_string_loc, tok_type,\n+\t\t\t\t\t m_start_idx, m_end_idx,\n+\t\t\t\t\t out_range);\n+}\n+\n \f\n /* Fold X for consideration by one of the warning functions when checking\n    whether an expression has a constant value.  */"}, {"sha": "7b5da5736e9e78d14e0811c1b92fe25da67a7ae9", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1110,6 +1110,35 @@ extern time_t cb_get_source_date_epoch (cpp_reader *pfile);\n    __TIME__ can store.  */\n #define MAX_SOURCE_DATE_EPOCH HOST_WIDE_INT_C (253402300799)\n \n+extern GTY(()) string_concat_db *g_string_concat_db;\n+\n+/* libcpp can calculate location information about a range of characters\n+   within a string literal, but doing so is non-trivial.\n+\n+   This class encapsulates such a source location, so that it can be\n+   passed around (e.g. within c-format.c).  It is effectively a deferred\n+   call into libcpp.  If needed by a diagnostic, the actual source_range\n+   can be calculated by calling the get_range method.  */\n+\n+class substring_loc\n+{\n+ public:\n+  substring_loc (location_t fmt_string_loc, tree string_type,\n+\t\t int start_idx, int end_idx)\n+  : m_fmt_string_loc (fmt_string_loc), m_string_type (string_type),\n+    m_start_idx (start_idx), m_end_idx (end_idx) {}\n+\n+  const char *get_range (source_range *out_range) const;\n+\n+  location_t get_fmt_string_loc () const { return m_fmt_string_loc; }\n+\n+ private:\n+  location_t m_fmt_string_loc;\n+  tree m_string_type;\n+  int m_start_idx;\n+  int m_end_idx;\n+};\n+\n /* In c-gimplify.c  */\n extern void c_genericize (tree);\n extern int c_gimplify_expr (tree *, gimple_seq *, gimple_seq *);"}, {"sha": "4c7e3852142ffe96cd385050add856840a2b17a9", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1097,13 +1097,16 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n   tree value;\n   size_t concats = 0;\n   struct obstack str_ob;\n+  struct obstack loc_ob;\n   cpp_string istr;\n   enum cpp_ttype type = tok->type;\n \n   /* Try to avoid the overhead of creating and destroying an obstack\n      for the common case of just one string.  */\n   cpp_string str = tok->val.str;\n+  location_t init_loc = tok->src_loc;\n   cpp_string *strs = &str;\n+  location_t *locs = NULL;\n \n   /* objc_at_sign_was_seen is only used when doing Objective-C string\n      concatenation.  It is 'true' if we have seen an '@' before the\n@@ -1142,16 +1145,21 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n \t  else\n \t    error (\"unsupported non-standard concatenation of string literals\");\n \t}\n+      /* FALLTHROUGH */\n \n     case CPP_STRING:\n       if (!concats)\n \t{\n \t  gcc_obstack_init (&str_ob);\n+\t  gcc_obstack_init (&loc_ob);\n \t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n+\t  obstack_grow (&loc_ob, &init_loc, sizeof (location_t));\n \t}\n \n       concats++;\n       obstack_grow (&str_ob, &tok->val.str, sizeof (cpp_string));\n+      obstack_grow (&loc_ob, &tok->src_loc, sizeof (location_t));\n+\n       if (objc_string)\n \tobjc_at_sign_was_seen = false;\n       goto retry;\n@@ -1164,7 +1172,10 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n   /* We have read one more token than we want.  */\n   _cpp_backup_tokens (parse_in, 1);\n   if (concats)\n-    strs = XOBFINISH (&str_ob, cpp_string *);\n+    {\n+      strs = XOBFINISH (&str_ob, cpp_string *);\n+      locs = XOBFINISH (&loc_ob, location_t *);\n+    }\n \n   if (concats && !objc_string && !in_system_header_at (input_location))\n     warning (OPT_Wtraditional,\n@@ -1176,6 +1187,12 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n     {\n       value = build_string (istr.len, (const char *) istr.text);\n       free (CONST_CAST (unsigned char *, istr.text));\n+      if (concats)\n+\t{\n+\t  gcc_assert (locs);\n+\t  gcc_assert (g_string_concat_db);\n+\t  g_string_concat_db->record_string_concatenation (concats + 1, locs);\n+\t}\n     }\n   else\n     {\n@@ -1227,7 +1244,10 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n   *valp = fix_string_type (value);\n \n   if (concats)\n-    obstack_free (&str_ob, 0);\n+    {\n+      obstack_free (&str_ob, 0);\n+      obstack_free (&loc_ob, 0);\n+    }\n \n   return objc_string ? CPP_OBJC_STRING : type;\n }"}, {"sha": "0715b2ef20062bb944850a19bb13630b4f422fba", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -216,6 +216,9 @@ c_common_init_options (unsigned int decoded_options_count,\n   unsigned int i;\n   struct cpp_callbacks *cb;\n \n+  g_string_concat_db\n+    = new (ggc_alloc <string_concat_db> ()) string_concat_db ();\n+\n   parse_in = cpp_create_reader (c_dialect_cxx () ? CLK_GNUCXX: CLK_GNUC89,\n \t\t\t\tident_hash, line_table);\n   cb = cpp_get_callbacks (parse_in);"}, {"sha": "d058b8aa81f1639156210f86e9722ed1cdcd940b", "filename": "gcc/input.c", "status": "modified", "additions": 1547, "deletions": 0, "changes": 1547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1189,6 +1189,279 @@ dump_location_info (FILE *stream)\n \t\t\t\tMAX_SOURCE_LOCATION + 1, UINT_MAX);\n }\n \n+/* string_concat's constructor.  */\n+\n+string_concat::string_concat (int num, location_t *locs)\n+  : m_num (num)\n+{\n+  m_locs = ggc_vec_alloc <location_t> (num);\n+  for (int i = 0; i < num; i++)\n+    m_locs[i] = locs[i];\n+}\n+\n+/* string_concat_db's constructor.  */\n+\n+string_concat_db::string_concat_db ()\n+{\n+  m_table = hash_map <location_hash, string_concat *>::create_ggc (64);\n+}\n+\n+/* Record that a string concatenation occurred, covering NUM\n+   string literal tokens.  LOCS is an array of size NUM, containing the\n+   locations of the tokens.  A copy of LOCS is taken.  */\n+\n+void\n+string_concat_db::record_string_concatenation (int num, location_t *locs)\n+{\n+  gcc_assert (num > 1);\n+  gcc_assert (locs);\n+\n+  location_t key_loc = get_key_loc (locs[0]);\n+\n+  string_concat *concat\n+    = new (ggc_alloc <string_concat> ()) string_concat (num, locs);\n+  m_table->put (key_loc, concat);\n+}\n+\n+/* Determine if LOC was the location of the the initial token of a\n+   concatenation of string literal tokens.\n+   If so, *OUT_NUM is written to with the number of tokens, and\n+   *OUT_LOCS with the location of an array of locations of the\n+   tokens, and return true.  *OUT_LOCS is a borrowed pointer to\n+   storage owned by the string_concat_db.\n+   Otherwise, return false.  */\n+\n+bool\n+string_concat_db::get_string_concatenation (location_t loc,\n+\t\t\t\t\t    int *out_num,\n+\t\t\t\t\t    location_t **out_locs)\n+{\n+  gcc_assert (out_num);\n+  gcc_assert (out_locs);\n+\n+  location_t key_loc = get_key_loc (loc);\n+\n+  string_concat **concat = m_table->get (key_loc);\n+  if (!concat)\n+    return false;\n+\n+  *out_num = (*concat)->m_num;\n+  *out_locs =(*concat)->m_locs;\n+  return true;\n+}\n+\n+/* Internal function.  Canonicalize LOC into a form suitable for\n+   use as a key within the database, stripping away macro expansion,\n+   ad-hoc information, and range information, using the location of\n+   the start of LOC within an ordinary linemap.  */\n+\n+location_t\n+string_concat_db::get_key_loc (location_t loc)\n+{\n+  loc = linemap_resolve_location (line_table, loc, LRK_SPELLING_LOCATION,\n+\t\t\t\t  NULL);\n+\n+  loc = get_range_from_loc (line_table, loc).m_start;\n+\n+  return loc;\n+}\n+\n+/* Helper class for use within get_substring_ranges_for_loc.\n+   An vec of cpp_string with responsibility for releasing all of the\n+   str->text for each str in the vector.  */\n+\n+class auto_cpp_string_vec :  public auto_vec <cpp_string>\n+{\n+ public:\n+  auto_cpp_string_vec (int alloc)\n+    : auto_vec <cpp_string> (alloc) {}\n+\n+  ~auto_cpp_string_vec ()\n+  {\n+    /* Clean up the copies within this vec.  */\n+    int i;\n+    cpp_string *str;\n+    FOR_EACH_VEC_ELT (*this, i, str)\n+      free (const_cast <unsigned char *> (str->text));\n+  }\n+};\n+\n+/* Attempt to populate RANGES with source location information on the\n+   individual characters within the string literal found at STRLOC.\n+   If CONCATS is non-NULL, then any string literals that the token at\n+   STRLOC  was concatenated with are also added to RANGES.\n+\n+   Return NULL if successful, or an error message if any errors occurred (in\n+   which case RANGES may be only partially populated and should not\n+   be used).\n+\n+   This is implemented by re-parsing the relevant source line(s).  */\n+\n+static const char *\n+get_substring_ranges_for_loc (cpp_reader *pfile,\n+\t\t\t      string_concat_db *concats,\n+\t\t\t      location_t strloc,\n+\t\t\t      enum cpp_ttype type,\n+\t\t\t      cpp_substring_ranges &ranges)\n+{\n+  gcc_assert (pfile);\n+\n+  if (strloc == UNKNOWN_LOCATION)\n+    return \"unknown location\";\n+\n+  /* If string concatenation has occurred at STRLOC, get the locations\n+     of all of the literal tokens making up the compound string.\n+     Otherwise, just use STRLOC.  */\n+  int num_locs = 1;\n+  location_t *strlocs = &strloc;\n+  if (concats)\n+    concats->get_string_concatenation (strloc, &num_locs, &strlocs);\n+\n+  auto_cpp_string_vec strs (num_locs);\n+  auto_vec <cpp_string_location_reader> loc_readers (num_locs);\n+  for (int i = 0; i < num_locs; i++)\n+    {\n+      /* Get range of strloc.  We will use it to locate the start and finish\n+\t of the literal token within the line.  */\n+      source_range src_range = get_range_from_loc (line_table, strlocs[i]);\n+\n+      if (src_range.m_start >= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))\n+\t/* If the string is within a macro expansion, we can't get at the\n+\t   end location.  */\n+\treturn \"macro expansion\";\n+\n+      if (src_range.m_start >= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+\t/* If so, we can't reliably determine where the token started within\n+\t   its line.  */\n+\treturn \"range starts after LINE_MAP_MAX_LOCATION_WITH_COLS\";\n+\n+      if (src_range.m_finish >= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+\t/* If so, we can't reliably determine where the token finished within\n+\t   its line.  */\n+\treturn \"range ends after LINE_MAP_MAX_LOCATION_WITH_COLS\";\n+\n+      expanded_location start\n+\t= expand_location_to_spelling_point (src_range.m_start);\n+      expanded_location finish\n+\t= expand_location_to_spelling_point (src_range.m_finish);\n+      if (start.file != finish.file)\n+\treturn \"range endpoints are in different files\";\n+      if (start.line != finish.line)\n+\treturn \"range endpoints are on different lines\";\n+      if (start.column > finish.column)\n+\treturn \"range endpoints are reversed\";\n+\n+      int line_width;\n+      const char *line = location_get_source_line (start.file, start.line,\n+\t\t\t\t\t\t   &line_width);\n+      if (line == NULL)\n+\treturn \"unable to read source line\";\n+\n+      /* Determine the location of the literal (including quotes\n+\t and leading prefix chars, such as the 'u' in a u\"\"\n+\t token).  */\n+      const char *literal = line + start.column - 1;\n+      int literal_length = finish.column - start.column + 1;\n+\n+      gcc_assert (line_width >= (start.column - 1 + literal_length));\n+      cpp_string from;\n+      from.len = literal_length;\n+      /* Make a copy of the literal, to avoid having to rely on\n+\t the lifetime of the copy of the line within the cache.\n+\t This will be released by the auto_cpp_string_vec dtor.  */\n+      from.text = XDUPVEC (unsigned char, literal, literal_length);\n+      strs.safe_push (from);\n+\n+      /* For very long lines, a new linemap could have started\n+\t halfway through the token.\n+\t Ensure that the loc_reader uses the linemap of the\n+\t *end* of the token for its start location.  */\n+      const line_map_ordinary *final_ord_map;\n+      linemap_resolve_location (line_table, src_range.m_finish,\n+\t\t\t\tLRK_MACRO_EXPANSION_POINT, &final_ord_map);\n+      location_t start_loc\n+\t= linemap_position_for_line_and_column (line_table, final_ord_map,\n+\t\t\t\t\t\tstart.line, start.column);\n+\n+      cpp_string_location_reader loc_reader (start_loc, line_table);\n+      loc_readers.safe_push (loc_reader);\n+    }\n+\n+  /* Rerun cpp_interpret_string, or rather, a modified version of it.  */\n+  const char *err = cpp_interpret_string_ranges (pfile, strs.address (),\n+\t\t\t\t\t\t loc_readers.address (),\n+\t\t\t\t\t\t num_locs, &ranges, type);\n+  if (err)\n+    return err;\n+\n+  /* Success: \"ranges\" should now contain information on the string.  */\n+  return NULL;\n+}\n+\n+/* Attempt to populate *OUT_RANGE with source location information on the\n+   range of given characters within the string literal found at STRLOC.\n+   START_IDX and END_IDX refer to offsets within the execution character\n+   set.\n+   If CONCATS is non-NULL, then any string literals that the token at\n+   STRLOC was concatenated with are also considered.\n+\n+   This is implemented by re-parsing the relevant source line(s).\n+\n+   Return NULL if successful, or an error message if any errors occurred.\n+   Error messages are intended for GCC developers (to help debugging) rather\n+   than for end-users.  */\n+\n+const char *\n+get_source_range_for_substring (cpp_reader *pfile,\n+\t\t\t\tstring_concat_db *concats,\n+\t\t\t\tlocation_t strloc,\n+\t\t\t\tenum cpp_ttype type,\n+\t\t\t\tint start_idx, int end_idx,\n+\t\t\t\tsource_range *out_range)\n+{\n+  gcc_checking_assert (start_idx >= 0);\n+  gcc_checking_assert (end_idx >= 0);\n+  gcc_assert (out_range);\n+\n+  cpp_substring_ranges ranges;\n+  const char *err\n+    = get_substring_ranges_for_loc (pfile, concats, strloc, type, ranges);\n+  if (err)\n+    return err;\n+\n+  if (start_idx >= ranges.get_num_ranges ())\n+    return \"start_idx out of range\";\n+  if (end_idx >= ranges.get_num_ranges ())\n+    return \"end_idx out of range\";\n+\n+  out_range->m_start = ranges.get_range (start_idx).m_start;\n+  out_range->m_finish = ranges.get_range (end_idx).m_finish;\n+  return NULL;\n+}\n+\n+/* As get_source_range_for_substring, but write to *OUT the number\n+   of ranges that are available.  */\n+\n+const char *\n+get_num_source_ranges_for_substring (cpp_reader *pfile,\n+\t\t\t\t     string_concat_db *concats,\n+\t\t\t\t     location_t strloc,\n+\t\t\t\t     enum cpp_ttype type,\n+\t\t\t\t     int *out)\n+{\n+  gcc_assert (out);\n+\n+  cpp_substring_ranges ranges;\n+  const char *err\n+    = get_substring_ranges_for_loc (pfile, concats, strloc, type, ranges);\n+\n+  if (err)\n+    return err;\n+\n+  *out = ranges.get_num_ranges ();\n+  return NULL;\n+}\n+\n #if CHECKING_P\n \n namespace selftest {\n@@ -1541,6 +1814,1259 @@ test_lexer (const line_table_case &case_)\n   cpp_destroy (parser);\n }\n \n+/* Forward decls.  */\n+\n+struct lexer_test;\n+class lexer_test_options;\n+\n+/* A class for specifying options of a lexer_test.\n+   The \"apply\" vfunc is called during the lexer_test constructor.  */\n+\n+class lexer_test_options\n+{\n+ public:\n+  virtual void apply (lexer_test &) = 0;\n+};\n+\n+/* A struct for writing lexer tests.  */\n+\n+struct lexer_test\n+{\n+  lexer_test (const line_table_case &case_, const char *content,\n+\t      lexer_test_options *options);\n+  ~lexer_test ();\n+\n+  const cpp_token *get_token ();\n+\n+  temp_source_file m_tempfile;\n+  temp_line_table m_tmp_lt;\n+  cpp_reader *m_parser;\n+  string_concat_db m_concats;\n+};\n+\n+/* Use an EBCDIC encoding for the execution charset, specifically\n+   IBM1047-encoded (aka \"EBCDIC 1047\", or \"Code page 1047\").\n+\n+   This exercises iconv integration within libcpp.\n+   Not every build of iconv supports the given charset,\n+   so we need to flag this error and handle it gracefully.  */\n+\n+class ebcdic_execution_charset : public lexer_test_options\n+{\n+ public:\n+  ebcdic_execution_charset () : m_num_iconv_errors (0)\n+    {\n+      gcc_assert (s_singleton == NULL);\n+      s_singleton = this;\n+    }\n+  ~ebcdic_execution_charset ()\n+    {\n+      gcc_assert (s_singleton == this);\n+      s_singleton = NULL;\n+    }\n+\n+  void apply (lexer_test &test) FINAL OVERRIDE\n+  {\n+    cpp_options *cpp_opts = cpp_get_options (test.m_parser);\n+    cpp_opts->narrow_charset = \"IBM1047\";\n+\n+    cpp_callbacks *callbacks = cpp_get_callbacks (test.m_parser);\n+    callbacks->error = on_error;\n+  }\n+\n+  static bool on_error (cpp_reader *pfile ATTRIBUTE_UNUSED,\n+\t\t\tint level ATTRIBUTE_UNUSED,\n+\t\t\tint reason ATTRIBUTE_UNUSED,\n+\t\t\trich_location *richloc ATTRIBUTE_UNUSED,\n+\t\t\tconst char *msgid, va_list *ap ATTRIBUTE_UNUSED)\n+    ATTRIBUTE_FPTR_PRINTF(5,0)\n+  {\n+    gcc_assert (s_singleton);\n+    /* Detect and record errors emitted by libcpp/charset.c:init_iconv_desc\n+       when the local iconv build doesn't support the conversion.  */\n+    if (strstr (msgid, \"not supported by iconv\"))\n+      {\n+\ts_singleton->m_num_iconv_errors++;\n+\treturn true;\n+      }\n+\n+    /* Otherwise, we have an unexpected error.  */\n+    abort ();\n+  }\n+\n+  bool iconv_errors_occurred_p () const { return m_num_iconv_errors > 0; }\n+\n+ private:\n+  static ebcdic_execution_charset *s_singleton;\n+  int m_num_iconv_errors;\n+};\n+\n+ebcdic_execution_charset *ebcdic_execution_charset::s_singleton;\n+\n+/* Constructor.  Override line_table with a new instance based on CASE_,\n+   and write CONTENT to a tempfile.  Create a cpp_reader, and use it to\n+   start parsing the tempfile.  */\n+\n+lexer_test::lexer_test (const line_table_case &case_, const char *content,\n+\t\t\tlexer_test_options *options) :\n+  /* Create a tempfile and write the text to it.  */\n+  m_tempfile (SELFTEST_LOCATION, \".c\", content),\n+  m_tmp_lt (case_),\n+  m_parser (cpp_create_reader (CLK_GNUC99, NULL, line_table)),\n+  m_concats ()\n+{\n+  if (options)\n+    options->apply (*this);\n+\n+  cpp_init_iconv (m_parser);\n+\n+  /* Parse the file.  */\n+  const char *fname = cpp_read_main_file (m_parser,\n+\t\t\t\t\t  m_tempfile.get_filename ());\n+  ASSERT_NE (fname, NULL);\n+}\n+\n+/* Destructor.  Verify that the next token in m_parser is EOF.  */\n+\n+lexer_test::~lexer_test ()\n+{\n+  location_t loc;\n+  const cpp_token *tok;\n+\n+  tok = cpp_get_token_with_location (m_parser, &loc);\n+  ASSERT_NE (tok, NULL);\n+  ASSERT_EQ (tok->type, CPP_EOF);\n+\n+  cpp_finish (m_parser, NULL);\n+  cpp_destroy (m_parser);\n+}\n+\n+/* Get the next token from m_parser.  */\n+\n+const cpp_token *\n+lexer_test::get_token ()\n+{\n+  location_t loc;\n+  const cpp_token *tok;\n+\n+  tok = cpp_get_token_with_location (m_parser, &loc);\n+  ASSERT_NE (tok, NULL);\n+  return tok;\n+}\n+\n+/* Verify that locations within string literals are correctly handled.  */\n+\n+/* Verify get_source_range_for_substring for token(s) at STRLOC,\n+   using the string concatenation database for TEST.\n+\n+   Assert that the character at index IDX is on EXPECTED_LINE,\n+   and that it begins at column EXPECTED_START_COL and ends at\n+   EXPECTED_FINISH_COL (unless the locations are beyond\n+   LINE_MAP_MAX_LOCATION_WITH_COLS, in which case don't check their\n+   columns).  */\n+\n+static void\n+assert_char_at_range (const location &loc,\n+\t\t      lexer_test& test,\n+\t\t      location_t strloc, enum cpp_ttype type, int idx,\n+\t\t      int expected_line, int expected_start_col,\n+\t\t      int expected_finish_col)\n+{\n+  cpp_reader *pfile = test.m_parser;\n+  string_concat_db *concats = &test.m_concats;\n+\n+  source_range actual_range;\n+  const char *err\n+    = get_source_range_for_substring (pfile, concats, strloc, type,\n+\t\t\t\t      idx, idx, &actual_range);\n+  if (should_have_column_data_p (strloc))\n+    ASSERT_EQ_AT (loc, NULL, err);\n+  else\n+    {\n+      ASSERT_STREQ_AT (loc,\n+\t\t       \"range starts after LINE_MAP_MAX_LOCATION_WITH_COLS\",\n+\t\t       err);\n+      return;\n+    }\n+\n+  int actual_start_line = LOCATION_LINE (actual_range.m_start);\n+  ASSERT_EQ_AT (loc, expected_line, actual_start_line);\n+  int actual_finish_line = LOCATION_LINE (actual_range.m_finish);\n+  ASSERT_EQ_AT (loc, expected_line, actual_finish_line);\n+\n+  if (should_have_column_data_p (actual_range.m_start))\n+    {\n+      int actual_start_col = LOCATION_COLUMN (actual_range.m_start);\n+      ASSERT_EQ_AT (loc, expected_start_col, actual_start_col);\n+    }\n+  if (should_have_column_data_p (actual_range.m_finish))\n+    {\n+      int actual_finish_col = LOCATION_COLUMN (actual_range.m_finish);\n+      ASSERT_EQ_AT (loc, expected_finish_col, actual_finish_col);\n+    }\n+}\n+\n+/* Macro for calling assert_char_at_range, supplying SELFTEST_LOCATION for\n+   the effective location of any errors.  */\n+\n+#define ASSERT_CHAR_AT_RANGE(LEXER_TEST, STRLOC, TYPE, IDX, EXPECTED_LINE, \\\n+\t\t\t     EXPECTED_START_COL, EXPECTED_FINISH_COL)\t\\\n+  assert_char_at_range (SELFTEST_LOCATION, (LEXER_TEST), (STRLOC), (TYPE), \\\n+\t\t\t(IDX), (EXPECTED_LINE), (EXPECTED_START_COL), \\\n+\t\t\t(EXPECTED_FINISH_COL))\n+\n+/* Verify get_num_source_ranges_for_substring for token(s) at STRLOC,\n+   using the string concatenation database for TEST.\n+\n+   Assert that the token(s) at STRLOC contain EXPECTED_NUM_RANGES.  */\n+\n+static void\n+assert_num_substring_ranges (const location &loc,\n+\t\t\t     lexer_test& test,\n+\t\t\t     location_t strloc,\n+\t\t\t     enum cpp_ttype type,\n+\t\t\t     int expected_num_ranges)\n+{\n+  cpp_reader *pfile = test.m_parser;\n+  string_concat_db *concats = &test.m_concats;\n+\n+  int actual_num_ranges;\n+  const char *err\n+    = get_num_source_ranges_for_substring (pfile, concats, strloc, type,\n+\t\t\t\t\t   &actual_num_ranges);\n+  if (should_have_column_data_p (strloc))\n+    ASSERT_EQ_AT (loc, NULL, err);\n+  else\n+    {\n+      ASSERT_STREQ_AT (loc,\n+\t\t       \"range starts after LINE_MAP_MAX_LOCATION_WITH_COLS\",\n+\t\t       err);\n+      return;\n+    }\n+  ASSERT_EQ_AT (loc, expected_num_ranges, actual_num_ranges);\n+}\n+\n+/* Macro for calling assert_num_substring_ranges, supplying\n+   SELFTEST_LOCATION for the effective location of any errors.  */\n+\n+#define ASSERT_NUM_SUBSTRING_RANGES(LEXER_TEST, STRLOC, TYPE, \\\n+\t\t\t\t    EXPECTED_NUM_RANGES)\t\t\\\n+  assert_num_substring_ranges (SELFTEST_LOCATION, (LEXER_TEST), (STRLOC), \\\n+\t\t\t       (TYPE), (EXPECTED_NUM_RANGES))\n+\n+\n+/* Verify that get_num_source_ranges_for_substring for token(s) at STRLOC\n+   returns an error (using the string concatenation database for TEST).  */\n+\n+static void\n+assert_has_no_substring_ranges (const location &loc,\n+\t\t\t\tlexer_test& test,\n+\t\t\t\tlocation_t strloc,\n+\t\t\t\tenum cpp_ttype type,\n+\t\t\t\tconst char *expected_err)\n+{\n+  cpp_reader *pfile = test.m_parser;\n+  string_concat_db *concats = &test.m_concats;\n+  cpp_substring_ranges ranges;\n+  const char *actual_err\n+    = get_substring_ranges_for_loc (pfile, concats, strloc,\n+\t\t\t\t    type, ranges);\n+  if (should_have_column_data_p (strloc))\n+    ASSERT_STREQ_AT (loc, expected_err, actual_err);\n+  else\n+    ASSERT_STREQ_AT (loc,\n+\t\t     \"range starts after LINE_MAP_MAX_LOCATION_WITH_COLS\",\n+\t\t     actual_err);\n+}\n+\n+#define ASSERT_HAS_NO_SUBSTRING_RANGES(LEXER_TEST, STRLOC, TYPE, ERR)    \\\n+    assert_has_no_substring_ranges (SELFTEST_LOCATION, (LEXER_TEST), \\\n+\t\t\t\t    (STRLOC), (TYPE), (ERR))\n+\n+/* Lex a simple string literal.  Verify the substring location data, before\n+   and after running cpp_interpret_string on it.  */\n+\n+static void\n+test_lexer_string_locations_simple (const line_table_case &case_)\n+{\n+  /* Digits 0-9 (with 0 at column 10), the simple way.\n+     ....................000000000.11111111112.2222222223333333333\n+     ....................123456789.01234567890.1234567890123456789\n+     We add a trailing comment to ensure that we correctly locate\n+     the end of the string literal token.  */\n+  const char *content = \"        \\\"0123456789\\\" /* not a string */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"0123456789\\\"\");\n+  ASSERT_TOKEN_LOC_EQ (tok, test.m_tempfile.get_filename (), 1, 9, 20);\n+\n+  /* At this point in lexing, the quote characters are treated as part of\n+     the string (they are stripped off by cpp_interpret_string).  */\n+\n+  ASSERT_EQ (tok->val.str.len, 12);\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"0123456789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.  */\n+  for (int i = 0; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1,\n+\t\t\t  10 + i, 10 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, type, 10);\n+}\n+\n+/* As test_lexer_string_locations_simple, but use an EBCDIC execution\n+   encoding.  */\n+\n+static void\n+test_lexer_string_locations_ebcdic (const line_table_case &case_)\n+{\n+  /* EBCDIC support requires iconv.  */\n+  if (!HAVE_ICONV)\n+    return;\n+\n+  /* Digits 0-9 (with 0 at column 10), the simple way.\n+     ....................000000000.11111111112.2222222223333333333\n+     ....................123456789.01234567890.1234567890123456789\n+     We add a trailing comment to ensure that we correctly locate\n+     the end of the string literal token.  */\n+  const char *content = \"        \\\"0123456789\\\" /* not a string */\\n\";\n+  ebcdic_execution_charset use_ebcdic;\n+  lexer_test test (case_, content, &use_ebcdic);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"0123456789\\\"\");\n+  ASSERT_TOKEN_LOC_EQ (tok, test.m_tempfile.get_filename (), 1, 9, 20);\n+\n+  /* At this point in lexing, the quote characters are treated as part of\n+     the string (they are stripped off by cpp_interpret_string).  */\n+\n+  ASSERT_EQ (tok->val.str.len, 12);\n+\n+  /* The remainder of the test requires an iconv implementation that\n+     can convert from UTF-8 to the EBCDIC encoding requested above.  */\n+  if (use_ebcdic.iconv_errors_occurred_p ())\n+    return;\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  /* We should now have EBCDIC-encoded text, specifically\n+     IBM1047-encoded (aka \"EBCDIC 1047\", or \"Code page 1047\").\n+     The digits 0-9 are encoded as 240-249 i.e. 0xf0-0xf9.  */\n+  ASSERT_STREQ (\"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\",\n+\t\t(const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify that we don't attempt to record substring location information\n+     for such cases.  */\n+  ASSERT_HAS_NO_SUBSTRING_RANGES\n+    (test, tok->src_loc, type,\n+     \"execution character set != source character set\");\n+}\n+\n+/* Lex a string literal containing a hex-escaped character.\n+   Verify the substring location data, before and after running\n+   cpp_interpret_string on it.  */\n+\n+static void\n+test_lexer_string_locations_hex (const line_table_case &case_)\n+{\n+  /* Digits 0-9, expressing digit 5 in ASCII as \"\\x35\"\n+     and with a space in place of digit 6, to terminate the escaped\n+     hex code.\n+     ....................000000000.111111.11112222.\n+     ....................123456789.012345.67890123.  */\n+  const char *content = \"        \\\"01234\\\\x35 789\\\"\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"01234\\\\x35 789\\\"\");\n+  ASSERT_TOKEN_LOC_EQ (tok, test.m_tempfile.get_filename (), 1, 9, 23);\n+\n+  /* At this point in lexing, the quote characters are treated as part of\n+     the string (they are stripped off by cpp_interpret_string).  */\n+  ASSERT_EQ (tok->val.str.len, 15);\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"012345 789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.  */\n+  for (int i = 0; i <= 4; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 10 + i, 10 + i);\n+  ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, 5, 1, 15, 18);\n+  for (int i = 6; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 13 + i, 13 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, type, 10);\n+}\n+\n+/* Lex a string literal containing an octal-escaped character.\n+   Verify the substring location data after running cpp_interpret_string\n+   on it.  */\n+\n+static void\n+test_lexer_string_locations_oct (const line_table_case &case_)\n+{\n+  /* Digits 0-9, expressing digit 5 in ASCII as \"\\065\"\n+     and with a space in place of digit 6, to terminate the escaped\n+     octal code.\n+     ....................000000000.111111.11112222.2222223333333333444\n+     ....................123456789.012345.67890123.4567890123456789012  */\n+  const char *content = \"        \\\"01234\\\\065 789\\\" /* not a string */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"01234\\\\065 789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"012345 789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.  */\n+  for (int i = 0; i < 5; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 10 + i, 10 + i);\n+  ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, 5, 1, 15, 18);\n+  for (int i = 6; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 13 + i, 13 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, type, 10);\n+}\n+\n+/* Test of string literal containing letter escapes.  */\n+\n+static void\n+test_lexer_string_locations_letter_escape_1 (const line_table_case &case_)\n+{\n+  /* The string \"\\tfoo\\\\\\nbar\" i.e. tab, \"foo\", backslash, newline, bar.\n+     .....................000000000.1.11111.1.1.11222.22222223333333\n+     .....................123456789.0.12345.6.7.89012.34567890123456.  */\n+  const char *content = (\"        \\\"\\\\tfoo\\\\\\\\\\\\nbar\\\" /* non-str */\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected tokens back.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"\\\\tfoo\\\\\\\\\\\\nbar\\\"\");\n+\n+  /* Verify ranges of individual characters. */\n+  /* \"\\t\".  */\n+  ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t0, 1, 10, 11);\n+  /* \"foo\". */\n+  for (int i = 1; i <= 3; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t  i, 1, 11 + i, 11 + i);\n+  /* \"\\\\\" and \"\\n\".  */\n+  ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t4, 1, 15, 16);\n+  ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t5, 1, 17, 18);\n+\n+  /* \"bar\".  */\n+  for (int i = 6; i <= 8; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t  i, 1, 13 + i, 13 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, CPP_STRING, 9);\n+}\n+\n+/* Another test of a string literal containing a letter escape.\n+   Based on string seen in\n+     printf (\"%-%\\n\");\n+   in gcc.dg/format/c90-printf-1.c.  */\n+\n+static void\n+test_lexer_string_locations_letter_escape_2 (const line_table_case &case_)\n+{\n+  /* .....................000000000.1111.11.1111.22222222223.\n+     .....................123456789.0123.45.6789.01234567890.  */\n+  const char *content = (\"        \\\"%-%\\\\n\\\" /* non-str */\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected tokens back.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"%-%\\\\n\\\"\");\n+\n+  /* Verify ranges of individual characters. */\n+  /* \"%-%\".  */\n+  for (int i = 0; i < 3; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t  i, 1, 10 + i, 10 + i);\n+  /* \"\\n\".  */\n+  ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t3, 1, 13, 14);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, CPP_STRING, 4);\n+}\n+\n+/* Lex a string literal containing UCN 4 characters.\n+   Verify the substring location data after running cpp_interpret_string\n+   on it.  */\n+\n+static void\n+test_lexer_string_locations_ucn4 (const line_table_case &case_)\n+{\n+  /* Digits 0-9, expressing digits 5 and 6 as Roman numerals expressed\n+     as UCN 4.\n+     ....................000000000.111111.111122.222222223.33333333344444\n+     ....................123456789.012345.678901.234567890.12345678901234  */\n+  const char *content = \"        \\\"01234\\\\u2174\\\\u2175789\\\" /* non-str */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"01234\\\\u2174\\\\u2175789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works.\n+     The string should be encoded in the execution character\n+     set.  Assuming that that is UTF-8, we should have the following:\n+     -----------  ----  -----  -------  ----------------\n+     Byte offset  Byte  Octal  Unicode  Source Column(s)\n+     -----------  ----  -----  -------  ----------------\n+     0            0x30         '0'      10\n+     1            0x31         '1'      11\n+     2            0x32         '2'      12\n+     3            0x33         '3'      13\n+     4            0x34         '4'      14\n+     5            0xE2  \\342   U+2174   15-20\n+     6            0x85  \\205    (cont)  15-20\n+     7            0xB4  \\264    (cont)  15-20\n+     8            0xE2  \\342   U+2175   21-26\n+     9            0x85  \\205    (cont)  21-26\n+     10           0xB5  \\265    (cont)  21-26\n+     11           0x37         '7'      27\n+     12           0x38         '8'      28\n+     13           0x39         '9'      29\n+     -----------  ----  -----  -------  ---------------.  */\n+\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"01234\\342\\205\\264\\342\\205\\265789\",\n+\t\t(const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.\n+     '01234'.  */\n+  for (int i = 0; i <= 4; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 10 + i, 10 + i);\n+  /* U+2174.  */\n+  for (int i = 5; i <= 7; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 15, 20);\n+  /* U+2175.  */\n+  for (int i = 8; i <= 10; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 21, 26);\n+  /* '789'.  */\n+  for (int i = 11; i <= 13; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 16 + i, 16 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, type, 14);\n+}\n+\n+/* Lex a string literal containing UCN 8 characters.\n+   Verify the substring location data after running cpp_interpret_string\n+   on it.  */\n+\n+static void\n+test_lexer_string_locations_ucn8 (const line_table_case &case_)\n+{\n+  /* Digits 0-9, expressing digits 5 and 6 as Roman numerals as UCN 8.\n+     ....................000000000.111111.1111222222.2222333333333.344444\n+     ....................123456789.012345.6789012345.6789012345678.901234  */\n+  const char *content = \"        \\\"01234\\\\U00002174\\\\U00002175789\\\" /* */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok,\n+\t\t\t   \"\\\"01234\\\\U00002174\\\\U00002175789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works.\n+     The UTF-8 encoding of the string is identical to that from\n+     the ucn4 testcase above; the only difference is the column\n+     locations.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"01234\\342\\205\\264\\342\\205\\265789\",\n+\t\t(const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.\n+     '01234'.  */\n+  for (int i = 0; i <= 4; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 10 + i, 10 + i);\n+  /* U+2174.  */\n+  for (int i = 5; i <= 7; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 15, 24);\n+  /* U+2175.  */\n+  for (int i = 8; i <= 10; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 25, 34);\n+  /* '789' at columns 35-37  */\n+  for (int i = 11; i <= 13; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 24 + i, 24 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, type, 14);\n+}\n+\n+/* Fetch a big-endian 32-bit value and convert to host endianness.  */\n+\n+static uint32_t\n+uint32_from_big_endian (const uint32_t *ptr_be_value)\n+{\n+  const unsigned char *buf = (const unsigned char *)ptr_be_value;\n+  return (((uint32_t) buf[0] << 24)\n+\t  | ((uint32_t) buf[1] << 16)\n+\t  | ((uint32_t) buf[2] << 8)\n+\t  | (uint32_t) buf[3]);\n+}\n+\n+/* Lex a wide string literal and verify that attempts to read substring\n+   location data from it fail gracefully.  */\n+\n+static void\n+test_lexer_string_locations_wide_string (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     ....................000000000.11111111112.22222222233333\n+     ....................123456789.01234567890.12345678901234  */\n+  const char *content = \"       L\\\"0123456789\\\" /* non-str */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_WSTRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"L\\\"0123456789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works, using CPP_WSTRING.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_WSTRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  /* The cpp_reader defaults to big-endian with\n+     CHAR_BIT * sizeof (int) for the wchar_precision, so dst_string should\n+     now be encoded as UTF-32BE.  */\n+  const uint32_t *be32_chars = (const uint32_t *)dst_string.text;\n+  ASSERT_EQ ('0', uint32_from_big_endian (&be32_chars[0]));\n+  ASSERT_EQ ('5', uint32_from_big_endian (&be32_chars[5]));\n+  ASSERT_EQ ('9', uint32_from_big_endian (&be32_chars[9]));\n+  ASSERT_EQ (0, uint32_from_big_endian (&be32_chars[10]));\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* We don't yet support generating substring location information\n+     for L\"\" strings.  */\n+  ASSERT_HAS_NO_SUBSTRING_RANGES\n+    (test, tok->src_loc, type,\n+     \"execution character set != source character set\");\n+}\n+\n+/* Fetch a big-endian 16-bit value and convert to host endianness.  */\n+\n+static uint16_t\n+uint16_from_big_endian (const uint16_t *ptr_be_value)\n+{\n+  const unsigned char *buf = (const unsigned char *)ptr_be_value;\n+  return ((uint16_t) buf[0] << 8) | (uint16_t) buf[1];\n+}\n+\n+/* Lex a u\"\" string literal and verify that attempts to read substring\n+   location data from it fail gracefully.  */\n+\n+static void\n+test_lexer_string_locations_string16 (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     ....................000000000.11111111112.22222222233333\n+     ....................123456789.01234567890.12345678901234  */\n+  const char *content = \"       u\\\"0123456789\\\" /* non-str */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING16);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"u\\\"0123456789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works, using CPP_STRING16.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING16;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+\n+  /* The cpp_reader defaults to big-endian, so dst_string should\n+     now be encoded as UTF-16BE.  */\n+  const uint16_t *be16_chars = (const uint16_t *)dst_string.text;\n+  ASSERT_EQ ('0', uint16_from_big_endian (&be16_chars[0]));\n+  ASSERT_EQ ('5', uint16_from_big_endian (&be16_chars[5]));\n+  ASSERT_EQ ('9', uint16_from_big_endian (&be16_chars[9]));\n+  ASSERT_EQ (0, uint16_from_big_endian (&be16_chars[10]));\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* We don't yet support generating substring location information\n+     for L\"\" strings.  */\n+  ASSERT_HAS_NO_SUBSTRING_RANGES\n+    (test, tok->src_loc, type,\n+     \"execution character set != source character set\");\n+}\n+\n+/* Lex a U\"\" string literal and verify that attempts to read substring\n+   location data from it fail gracefully.  */\n+\n+static void\n+test_lexer_string_locations_string32 (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     ....................000000000.11111111112.22222222233333\n+     ....................123456789.01234567890.12345678901234  */\n+  const char *content = \"       U\\\"0123456789\\\" /* non-str */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING32);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"U\\\"0123456789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works, using CPP_STRING32.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING32;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+\n+  /* The cpp_reader defaults to big-endian, so dst_string should\n+     now be encoded as UTF-32BE.  */\n+  const uint32_t *be32_chars = (const uint32_t *)dst_string.text;\n+  ASSERT_EQ ('0', uint32_from_big_endian (&be32_chars[0]));\n+  ASSERT_EQ ('5', uint32_from_big_endian (&be32_chars[5]));\n+  ASSERT_EQ ('9', uint32_from_big_endian (&be32_chars[9]));\n+  ASSERT_EQ (0, uint32_from_big_endian (&be32_chars[10]));\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* We don't yet support generating substring location information\n+     for L\"\" strings.  */\n+  ASSERT_HAS_NO_SUBSTRING_RANGES\n+    (test, tok->src_loc, type,\n+     \"execution character set != source character set\");\n+}\n+\n+/* Lex a u8-string literal.\n+   Verify the substring location data after running cpp_interpret_string\n+   on it.  */\n+\n+static void\n+test_lexer_string_locations_u8 (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     ....................000000000.11111111112.22222222233333\n+     ....................123456789.01234567890.12345678901234  */\n+  const char *content = \"      u8\\\"0123456789\\\" /* non-str */\\n\";\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_UTF8STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"u8\\\"0123456789\\\"\");\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"0123456789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.  */\n+  for (int i = 0; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 10 + i, 10 + i);\n+}\n+\n+/* Lex a string literal containing UTF-8 source characters.\n+   Verify the substring location data after running cpp_interpret_string\n+   on it.  */\n+\n+static void\n+test_lexer_string_locations_utf8_source (const line_table_case &case_)\n+{\n+ /* This string literal is written out to the source file as UTF-8,\n+    and is of the form \"before mojibake after\", where \"mojibake\"\n+    is written as the following four unicode code points:\n+       U+6587 CJK UNIFIED IDEOGRAPH-6587\n+       U+5B57 CJK UNIFIED IDEOGRAPH-5B57\n+       U+5316 CJK UNIFIED IDEOGRAPH-5316\n+       U+3051 HIRAGANA LETTER KE.\n+     Each of these is 3 bytes wide when encoded in UTF-8, whereas the\n+     \"before\" and \"after\" are 1 byte per unicode character.\n+\n+     The numbering shown are \"columns\", which are *byte* numbers within\n+     the line, rather than unicode character numbers.\n+\n+     .................... 000000000.1111111.\n+     .................... 123456789.0123456.  */\n+  const char *content = (\"        \\\"before \"\n+\t\t\t /* U+6587 CJK UNIFIED IDEOGRAPH-6587\n+\t\t\t      UTF-8: 0xE6 0x96 0x87\n+\t\t\t      C octal escaped UTF-8: \\346\\226\\207\n+\t\t\t    \"column\" numbers: 17-19.  */\n+\t\t\t \"\\346\\226\\207\"\n+\n+\t\t\t /* U+5B57 CJK UNIFIED IDEOGRAPH-5B57\n+\t\t\t      UTF-8: 0xE5 0xAD 0x97\n+\t\t\t      C octal escaped UTF-8: \\345\\255\\227\n+\t\t\t    \"column\" numbers: 20-22.  */\n+\t\t\t \"\\345\\255\\227\"\n+\n+\t\t\t /* U+5316 CJK UNIFIED IDEOGRAPH-5316\n+\t\t\t      UTF-8: 0xE5 0x8C 0x96\n+\t\t\t      C octal escaped UTF-8: \\345\\214\\226\n+\t\t\t    \"column\" numbers: 23-25.  */\n+\t\t\t \"\\345\\214\\226\"\n+\n+\t\t\t /* U+3051 HIRAGANA LETTER KE\n+\t\t\t      UTF-8: 0xE3 0x81 0x91\n+\t\t\t      C octal escaped UTF-8: \\343\\201\\221\n+\t\t\t    \"column\" numbers: 26-28.  */\n+\t\t\t \"\\343\\201\\221\"\n+\n+\t\t\t /* column numbers 29 onwards\n+\t\t\t  2333333.33334444444444\n+\t\t\t  9012345.67890123456789. */\n+\t\t\t \" after\\\" /* non-str */\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back, with the correct\n+     location information.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ\n+    (test.m_parser, tok,\n+     \"\\\"before \\346\\226\\207\\345\\255\\227\\345\\214\\226\\343\\201\\221 after\\\"\");\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser, &tok->val.str, 1,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ\n+    (\"before \\346\\226\\207\\345\\255\\227\\345\\214\\226\\343\\201\\221 after\",\n+     (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Verify ranges of individual characters.  This no longer includes the\n+     quotes.\n+     Assuming that both source and execution encodings are UTF-8, we have\n+     a run of 25 octets in each.  */\n+  for (int i = 0; i < 25; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, type, i, 1, 10 + i, 10 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, type, 25);\n+}\n+\n+/* Test of string literal concatenation.  */\n+\n+static void\n+test_lexer_string_locations_concatenation_1 (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     .....................000000000.111111.11112222222222\n+     .....................123456789.012345.67890123456789.  */\n+  const char *content = (\"        \\\"01234\\\" /* non-str */\\n\"\n+\t\t\t \"        \\\"56789\\\" /* non-str */\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  location_t input_locs[2];\n+\n+  /* Verify that we get the expected tokens back.  */\n+  auto_vec <cpp_string> input_strings;\n+  const cpp_token *tok_a = test.get_token ();\n+  ASSERT_EQ (tok_a->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok_a, \"\\\"01234\\\"\");\n+  input_strings.safe_push (tok_a->val.str);\n+  input_locs[0] = tok_a->src_loc;\n+\n+  const cpp_token *tok_b = test.get_token ();\n+  ASSERT_EQ (tok_b->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok_b, \"\\\"56789\\\"\");\n+  input_strings.safe_push (tok_b->val.str);\n+  input_locs[1] = tok_b->src_loc;\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser,\n+\t\t\t\t      input_strings.address (), 2,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"0123456789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Simulate c-lex.c's lex_string in order to record concatenation.  */\n+  test.m_concats.record_string_concatenation (2, input_locs);\n+\n+  location_t initial_loc = input_locs[0];\n+\n+  for (int i = 0; i <= 4; i++)\n+    ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 1, 10 + i, 10 + i);\n+  for (int i = 5; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 2, 5 + i, 5 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, initial_loc, type, 10);\n+}\n+\n+/* Another test of string literal concatenation.  */\n+\n+static void\n+test_lexer_string_locations_concatenation_2 (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     .....................000000000.111.11111112222222\n+     .....................123456789.012.34567890123456.  */\n+  const char *content = (\"        \\\"01\\\" /* non-str */\\n\"\n+\t\t\t \"        \\\"23\\\" /* non-str */\\n\"\n+\t\t\t \"        \\\"45\\\" /* non-str */\\n\"\n+\t\t\t \"        \\\"67\\\" /* non-str */\\n\"\n+\t\t\t \"        \\\"89\\\" /* non-str */\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  auto_vec <cpp_string> input_strings;\n+  location_t input_locs[5];\n+\n+  /* Verify that we get the expected tokens back.  */\n+  for (int i = 0; i < 5; i++)\n+    {\n+      const cpp_token *tok = test.get_token ();\n+      ASSERT_EQ (tok->type, CPP_STRING);\n+      input_strings.safe_push (tok->val.str);\n+      input_locs[i] = tok->src_loc;\n+    }\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser,\n+\t\t\t\t      input_strings.address (), 5,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"0123456789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Simulate c-lex.c's lex_string in order to record concatenation.  */\n+  test.m_concats.record_string_concatenation (5, input_locs);\n+\n+  location_t initial_loc = input_locs[0];\n+\n+  /* Within ASSERT_CHAR_AT_RANGE (actually assert_char_at_range), we can\n+     detect if the initial loc is after LINE_MAP_MAX_LOCATION_WITH_COLS\n+     and expect get_source_range_for_substring to fail.\n+     However, for a string concatenation test, we can have a case\n+     where the initial string is fully before LINE_MAP_MAX_LOCATION_WITH_COLS,\n+     but subsequent strings can be after it.\n+     Attempting to detect this within assert_char_at_range\n+     would overcomplicate the logic for the common test cases, so\n+     we detect it here.  */\n+  if (should_have_column_data_p (input_locs[0])\n+      && !should_have_column_data_p (input_locs[4]))\n+    {\n+      /* Verify that get_source_range_for_substring gracefully rejects\n+\t this case.  */\n+      source_range actual_range;\n+      const char *err\n+\t= get_source_range_for_substring (test.m_parser, &test.m_concats,\n+\t\t\t\t\t  initial_loc, type, 0, 0,\n+\t\t\t\t\t  &actual_range);\n+      ASSERT_STREQ (\"range starts after LINE_MAP_MAX_LOCATION_WITH_COLS\", err);\n+      return;\n+    }\n+\n+  for (int i = 0; i < 5; i++)\n+    for (int j = 0; j < 2; j++)\n+      ASSERT_CHAR_AT_RANGE (test, initial_loc, type, (i * 2) + j,\n+\t\t\t    i + 1, 10 + j, 10 + j);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, initial_loc, type, 10);\n+}\n+\n+/* Another test of string literal concatenation, this time combined with\n+   various kinds of escaped characters.  */\n+\n+static void\n+test_lexer_string_locations_concatenation_3 (const line_table_case &case_)\n+{\n+  /* Digits 0-9, expressing digit 5 in ASCII as hex \"\\x35\"\n+     digit 6 in ASCII as octal \"\\066\", concatenating multiple strings.  */\n+  const char *content\n+    /* .000000000.111111.111.1.2222.222.2.2233.333.3333.34444444444555\n+       .123456789.012345.678.9.0123.456.7.8901.234.5678.90123456789012. */\n+    = (\"        \\\"01234\\\"  \\\"\\\\x35\\\"  \\\"\\\\066\\\"  \\\"789\\\" /* non-str */\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  auto_vec <cpp_string> input_strings;\n+  location_t input_locs[4];\n+\n+  /* Verify that we get the expected tokens back.  */\n+  for (int i = 0; i < 4; i++)\n+    {\n+      const cpp_token *tok = test.get_token ();\n+      ASSERT_EQ (tok->type, CPP_STRING);\n+      input_strings.safe_push (tok->val.str);\n+      input_locs[i] = tok->src_loc;\n+    }\n+\n+  /* Verify that cpp_interpret_string works.  */\n+  cpp_string dst_string;\n+  const enum cpp_ttype type = CPP_STRING;\n+  bool result = cpp_interpret_string (test.m_parser,\n+\t\t\t\t      input_strings.address (), 4,\n+\t\t\t\t      &dst_string, type);\n+  ASSERT_TRUE (result);\n+  ASSERT_STREQ (\"0123456789\", (const char *)dst_string.text);\n+  free (const_cast <unsigned char *> (dst_string.text));\n+\n+  /* Simulate c-lex.c's lex_string in order to record concatenation.  */\n+  test.m_concats.record_string_concatenation (4, input_locs);\n+\n+  location_t initial_loc = input_locs[0];\n+\n+  for (int i = 0; i <= 4; i++)\n+    ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 1, 10 + i, 10 + i);\n+  ASSERT_CHAR_AT_RANGE (test, initial_loc, type, 5, 1, 19, 22);\n+  ASSERT_CHAR_AT_RANGE (test, initial_loc, type, 6, 1, 27, 30);\n+  for (int i = 7; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 1, 28 + i, 28 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, initial_loc, type, 10);\n+}\n+\n+/* Test of string literal in a macro.  */\n+\n+static void\n+test_lexer_string_locations_macro (const line_table_case &case_)\n+{\n+  /* Digits 0-9.\n+     .....................0000000001111111111.22222222223.\n+     .....................1234567890123456789.01234567890.  */\n+  const char *content = (\"#define MACRO     \\\"0123456789\\\" /* non-str */\\n\"\n+\t\t\t \"  MACRO\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected tokens back.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_PADDING);\n+\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"0123456789\\\"\");\n+\n+  /* Verify ranges of individual characters.  We ought to\n+     see columns within the macro definition.  */\n+  for (int i = 0; i <= 9; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t  i, 1, 20 + i, 20 + i);\n+\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, CPP_STRING, 10);\n+\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_PADDING);\n+}\n+\n+/* Test of stringification of a macro argument.  */\n+\n+static void\n+test_lexer_string_locations_stringified_macro_argument\n+  (const line_table_case &case_)\n+{\n+  /* .....................000000000111111111122222222223.\n+     .....................123456789012345678901234567890.  */\n+  const char *content = (\"#define MACRO(X) #X /* non-str */\\n\"\n+\t\t\t \"MACRO(foo)\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_PADDING);\n+\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"\\\"foo\\\"\");\n+\n+  /* We don't support getting the location of a stringified macro\n+     argument.  Verify that it fails gracefully.  */\n+  ASSERT_HAS_NO_SUBSTRING_RANGES (test, tok->src_loc, CPP_STRING,\n+\t\t\t\t  \"cpp_interpret_string_1 failed\");\n+\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_PADDING);\n+\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_PADDING);\n+}\n+\n+/* Ensure that we are fail gracefully if something attempts to pass\n+   in a location that isn't a string literal token.  Seen on this code:\n+\n+     const char a[] = \" %d \";\n+     __builtin_printf (a, 0.5);\n+                       ^\n+\n+   when c-format.c erroneously used the indicated one-character\n+   location as the format string location, leading to a read past the\n+   end of a string buffer in cpp_interpret_string_1.  */\n+\n+static void\n+test_lexer_string_locations_non_string (const line_table_case &case_)\n+{\n+  /* .....................000000000111111111122222222223.\n+     .....................123456789012345678901234567890.  */\n+  const char *content = (\"         a\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_NAME);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"a\");\n+\n+  /* At this point, libcpp is attempting to interpret the name as a\n+     string literal, despite it not starting with a quote.  We don't detect\n+     that, but we should at least fail gracefully.  */\n+  ASSERT_HAS_NO_SUBSTRING_RANGES (test, tok->src_loc, CPP_STRING,\n+\t\t\t\t  \"cpp_interpret_string_1 failed\");\n+}\n+\n+/* Ensure that we can read substring information for a token which\n+   starts in one linemap and ends in another .  Adapted from\n+   gcc.dg/cpp/pr69985.c.  */\n+\n+static void\n+test_lexer_string_locations_long_line (const line_table_case &case_)\n+{\n+  /* .....................000000.000111111111\n+     .....................123456.789012346789.  */\n+  const char *content = (\"/* A very long line, so that we start a new line map.  */\\n\"\n+\t\t\t \"     \\\"0123456789012345678901234567890123456789\"\n+\t\t\t \"0123456789012345678901234567890123456789\"\n+\t\t\t \"0123456789012345678901234567890123456789\"\n+\t\t\t \"0123456789\\\"\\n\");\n+\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected token back.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_STRING);\n+\n+  if (!should_have_column_data_p (line_table->highest_location))\n+    return;\n+\n+  /* Verify ranges of individual characters.  */\n+  ASSERT_NUM_SUBSTRING_RANGES (test, tok->src_loc, CPP_STRING, 130);\n+  for (int i = 0; i < 130; i++)\n+    ASSERT_CHAR_AT_RANGE (test, tok->src_loc, CPP_STRING,\n+\t\t\t  i, 2, 7 + i, 7 + i);\n+}\n+\n+/* Test of lexing char constants.  */\n+\n+static void\n+test_lexer_char_constants (const line_table_case &case_)\n+{\n+  /* Various char constants.\n+     .....................0000000001111111111.22222222223.\n+     .....................1234567890123456789.01234567890.  */\n+  const char *content = (\"         'a'\\n\"\n+\t\t\t \"        u'a'\\n\"\n+\t\t\t \"        U'a'\\n\"\n+\t\t\t \"        L'a'\\n\"\n+\t\t\t \"         'abc'\\n\");\n+  lexer_test test (case_, content, NULL);\n+\n+  /* Verify that we get the expected tokens back.  */\n+  /* 'a'.  */\n+  const cpp_token *tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_CHAR);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"'a'\");\n+\n+  unsigned int chars_seen;\n+  int unsignedp;\n+  cppchar_t cc = cpp_interpret_charconst (test.m_parser, tok,\n+\t\t\t\t\t  &chars_seen, &unsignedp);\n+  ASSERT_EQ (cc, 'a');\n+  ASSERT_EQ (chars_seen, 1);\n+\n+  /* u'a'.  */\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_CHAR16);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"u'a'\");\n+\n+  /* U'a'.  */\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_CHAR32);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"U'a'\");\n+\n+  /* L'a'.  */\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_WCHAR);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"L'a'\");\n+\n+  /* 'abc' (c-char-sequence).  */\n+  tok = test.get_token ();\n+  ASSERT_EQ (tok->type, CPP_CHAR);\n+  ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, \"'abc'\");\n+}\n /* A table of interesting location_t values, giving one axis of our test\n    matrix.  */\n \n@@ -1599,6 +3125,27 @@ input_c_tests ()\n \t  /* Run all tests for the given case within the test matrix.  */\n \t  test_accessing_ordinary_linemaps (c);\n \t  test_lexer (c);\n+\t  test_lexer_string_locations_simple (c);\n+\t  test_lexer_string_locations_ebcdic (c);\n+\t  test_lexer_string_locations_hex (c);\n+\t  test_lexer_string_locations_oct (c);\n+\t  test_lexer_string_locations_letter_escape_1 (c);\n+\t  test_lexer_string_locations_letter_escape_2 (c);\n+\t  test_lexer_string_locations_ucn4 (c);\n+\t  test_lexer_string_locations_ucn8 (c);\n+\t  test_lexer_string_locations_wide_string (c);\n+\t  test_lexer_string_locations_string16 (c);\n+\t  test_lexer_string_locations_string32 (c);\n+\t  test_lexer_string_locations_u8 (c);\n+\t  test_lexer_string_locations_utf8_source (c);\n+\t  test_lexer_string_locations_concatenation_1 (c);\n+\t  test_lexer_string_locations_concatenation_2 (c);\n+\t  test_lexer_string_locations_concatenation_3 (c);\n+\t  test_lexer_string_locations_macro (c);\n+\t  test_lexer_string_locations_stringified_macro_argument (c);\n+\t  test_lexer_string_locations_non_string (c);\n+\t  test_lexer_string_locations_long_line (c);\n+\t  test_lexer_char_constants (c);\n \n \t  num_cases_tested++;\n \t}"}, {"sha": "c17e440e576fc6ab90900b492cdf5823ed223763", "filename": "gcc/input.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -95,4 +95,39 @@ void dump_location_info (FILE *stream);\n \n void diagnostics_file_cache_fini (void);\n \n+struct GTY(()) string_concat\n+{\n+  string_concat (int num, location_t *locs);\n+\n+  int m_num;\n+  location_t * GTY ((atomic)) m_locs;\n+};\n+\n+struct location_hash : int_hash <location_t, UNKNOWN_LOCATION> { };\n+\n+class GTY(()) string_concat_db\n+{\n+ public:\n+  string_concat_db ();\n+  void record_string_concatenation (int num, location_t *locs);\n+\n+  bool get_string_concatenation (location_t loc,\n+\t\t\t\t int *out_num,\n+\t\t\t\t location_t **out_locs);\n+\n+ private:\n+  static location_t get_key_loc (location_t loc);\n+\n+  /* For the fields to be private, we must grant access to the\n+     generated code in gtype-desc.c.  */\n+\n+  friend void ::gt_ggc_mx_string_concat_db (void *x_p);\n+  friend void ::gt_pch_nx_string_concat_db (void *x_p);\n+  friend void ::gt_pch_p_16string_concat_db (void *this_obj, void *x_p,\n+\t\t\t\t\t     gt_pointer_operator op,\n+\t\t\t\t\t     void *cookie);\n+\n+  hash_map <location_hash, string_concat *> *m_table;\n+};\n+\n #endif"}, {"sha": "274ebbe4a987c5ca559dd07cdfa9357b34a1a73b", "filename": "gcc/substring-locations.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fsubstring-locations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Fsubstring-locations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsubstring-locations.h?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -0,0 +1,30 @@\n+/* Source locations within string literals.\n+   Copyright (C) 2016 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SUBSTRING_LOCATIONS_H\n+#define GCC_SUBSTRING_LOCATIONS_H\n+\n+extern const char *get_source_range_for_substring (cpp_reader *pfile,\n+\t\t\t\t\t\t   string_concat_db *concats,\n+\t\t\t\t\t\t   location_t strloc,\n+\t\t\t\t\t\t   enum cpp_ttype type,\n+\t\t\t\t\t\t   int start_idx, int end_idx,\n+\t\t\t\t\t\t   source_range *out_range);\n+\n+#endif /* ! GCC_SUBSTRING_LOCATIONS_H */"}, {"sha": "997efac8af0911dd1d7de50b48532473e8655ec0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1,3 +1,10 @@\n+2016-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/diagnostic-test-string-literals-1.c: New file.\n+\t* gcc.dg/plugin/diagnostic-test-string-literals-2.c: New file.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_string_literals.c: New file.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add the above new files.\n+\n 2016-08-05  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR tree-optimization/72810"}, {"sha": "82689b44f48e0e325fca8b1a2a3f6ea8695129c6", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-string-literals-1.c", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-1.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -0,0 +1,211 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret\" } */\n+\n+/* This is a collection of unittests for ranges within string literals,\n+   using diagnostic_plugin_test_string_literals, which handles\n+   \"__emit_string_literal_range\" by generating a warning at the given\n+   subset of a string literal.\n+\n+   The indices are 0-based.  It's easiest to verify things using string\n+   literals that are runs of 0-based digits (to avoid having to count\n+   characters).\n+\n+   LITERAL is a const void * to allow testing the various kinds of wide\n+   string literal, rather than just const char *.  */\n+\n+extern void __emit_string_literal_range (const void *literal,\n+\t\t\t\t\t int start_idx, int end_idx);\n+\n+void\n+test_simple_string_literal (void)\n+{\n+  __emit_string_literal_range (\"0123456789\", /* { dg-warning \"range\" } */\n+\t\t\t       6, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"0123456789\",\n+                                       ^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_concatenated_string_literal (void)\n+{\n+  __emit_string_literal_range (\"01234\" \"56789\", /* { dg-warning \"range\" } */\n+\t\t\t       3, 6);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\" \"56789\",\n+                                    ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_multiline_string_literal (void)\n+{\n+  __emit_string_literal_range (\"01234\" /* { dg-warning \"range\" } */\n+                               \"56789\",\n+                               3, 6);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\"\n+                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                \"56789\",\n+                                ~~~  \n+   { dg-end-multiline-output \"\" } */\n+  /* FIXME: why does the above need two trailing spaces?  */\n+}\n+\n+/* Tests of various unicode encodings.\n+\n+   Digits 0 through 9 are unicode code points:\n+      U+0030 DIGIT ZERO\n+      ...\n+      U+0039 DIGIT NINE\n+   However, these are not always valid as UCN (see the comment in\n+   libcpp/charset.c:_cpp_valid_ucn).\n+\n+   Hence we need to test UCN using an alternative unicode\n+   representation of numbers; let's use Roman numerals,\n+   (though these start at one, not zero):\n+      U+2170 SMALL ROMAN NUMERAL ONE\n+      ...\n+      U+2174 SMALL ROMAN NUMERAL FIVE  (\"v\")\n+      U+2175 SMALL ROMAN NUMERAL SIX   (\"vi\")\n+      ...\n+      U+2178 SMALL ROMAN NUMERAL NINE.  */\n+\n+void\n+test_hex (void)\n+{\n+  /* Digits 0-9, expressing digit 5 in ASCII as \"\\x35\"\n+     and with a space in place of digit 6, to terminate the escaped\n+     hex code.  */\n+  __emit_string_literal_range (\"01234\\x35 789\", /* { dg-warning \"range\" } */\n+\t\t\t       3, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\\x35 789\"\n+                                    ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_oct (void)\n+{\n+  /* Digits 0-9, expressing digit 5 in ASCII as \"\\065\"\n+     and with a space in place of digit 6, to terminate the escaped\n+     octal code.  */\n+  __emit_string_literal_range (\"01234\\065 789\", /* { dg-warning \"range\" } */\n+\t\t\t       3, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\\065 789\"\n+                                    ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_multiple (void)\n+{\n+  /* Digits 0-9, expressing digit 5 in ASCII as hex \"\\x35\"\n+     digit 6 in ASCII as octal \"\\066\", concatenating multiple strings.  */\n+  __emit_string_literal_range (\"01234\"  \"\\x35\"  \"\\066\"  \"789\", /* { dg-warning \"range\" } */\n+\t\t\t       3, 8);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\"  \"\\x35\"  \"\\066\"  \"789\",\n+                                    ^~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_ucn4 (void)\n+{\n+  /* Digits 0-9, expressing digits 5 and 6 as Roman numerals expressed\n+     as UCN 4.\n+     The resulting string is encoded as UTF-8.  Most of the digits are 1 byte\n+     each, but digits 5 and 6 are encoded with 3 bytes each.\n+     Hence to underline digits 4-7 we need to underling using bytes 4-11 in\n+     the UTF-8 encoding.  */\n+  __emit_string_literal_range (\"01234\\u2174\\u2175789\", /* { dg-warning \"range\" } */\n+\t\t\t       4, 11);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\\u2174\\u2175789\",\n+                                     ^~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_ucn8 (void)\n+{\n+  /* Digits 0-9, expressing digits 5 and 6 as Roman numerals as UCN 8.\n+     The resulting string is the same as as in test_ucn4 above, and hence\n+     has the same UTF-8 encoding, and so we again need to underline bytes\n+     4-11 in the UTF-8 encoding in order to underline digits 4-7.  */\n+  __emit_string_literal_range (\"01234\\U00002174\\U00002175789\", /* { dg-warning \"range\" } */\n+\t\t\t       4, 11);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (\"01234\\U00002174\\U00002175789\",\n+                                     ^~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_u8 (void)\n+{\n+  /* Digits 0-9.  */\n+  __emit_string_literal_range (u8\"0123456789\", /* { dg-warning \"range\" } */\n+\t\t\t       4, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (u8\"0123456789\",\n+                                       ^~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_u (void)\n+{\n+  /* Digits 0-9.  */\n+  __emit_string_literal_range (u\"0123456789\", /* { dg-error \"unable to read substring range: execution character set != source character set\" } */\n+\t\t\t       4, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (u\"0123456789\",\n+                                ^~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_U (void)\n+{\n+  /* Digits 0-9.  */\n+  __emit_string_literal_range (U\"0123456789\", /* { dg-error \"unable to read substring range: execution character set != source character set\" } */\n+\t\t\t       4, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (U\"0123456789\",\n+                                ^~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_L (void)\n+{\n+  /* Digits 0-9.  */\n+  __emit_string_literal_range (L\"0123456789\", /* { dg-error \"unable to read substring range: execution character set != source character set\" } */\n+\t\t\t       4, 7);\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_string_literal_range (L\"0123456789\",\n+                                ^~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void\n+test_macro (void)\n+{\n+#define START \"01234\"  /* { dg-warning \"range\" } */\n+  __emit_string_literal_range (START\n+                               \"56789\",\n+                               3, 6);\n+/* { dg-begin-multiline-output \"\" }\n+ #define START \"01234\"\n+                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   __emit_string_literal_range (START\n+   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                                \"56789\",\n+                                ~~~\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "7851c02fb08d9c2c2046561d4674883565cc3f8e", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-string-literals-2.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-string-literals-2.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+\n+/* See the notes in diagnostic-test-string-literals-1.c.\n+   This test case has caret-printing disabled.  */\n+\n+extern void __emit_string_literal_range (const void *literal,\n+\t\t\t\t\t int start_idx, int end_idx);\n+/* Test of a stringified macro argument, by itself.  */\n+\n+void\n+test_stringified_token_1 (int x)\n+{\n+#define STRINGIFY(EXPR) #EXPR\n+\n+  __emit_string_literal_range (STRINGIFY(x > 0), /* { dg-error \"unable to read substring range: macro expansion\" } */\n+                               0, 4);\n+\n+#undef STRINGIFY\n+}\n+\n+/* Test of a stringified token within a concatenation.  */\n+\n+void\n+test_stringized_token_2 (int x)\n+{\n+#define EXAMPLE(EXPR, START_IDX, END_IDX)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    __emit_string_literal_range (\"  before \" #EXPR \" after \\n\",\t\\\n+\t\t\t\t START_IDX, END_IDX);\t\t\\\n+  } while (0)\n+\n+  EXAMPLE(x > 0, 1, 6);\n+  /* { dg-error \"unable to read substring range: cpp_interpret_string_1 failed\" \"\" { target *-*-* } 28 } */\n+\n+#undef EXAMPLE\n+}\n+\n+/* Test of a doubly-stringified macro argument (by itself).  */\n+\n+void\n+test_stringified_token_3 (int x)\n+{\n+#define XSTR(s) STR(s)\n+#define STR(s) #s\n+#define FOO 123456789\n+  __emit_string_literal_range (XSTR (FOO), /* { dg-error \"unable to read substring range: macro expansion\" } */\n+                               2, 3);\n+\n+#undef XSTR\n+#undef STR\n+#undef FOO\n+}\n+"}, {"sha": "d44612a1d098ee3de953144678f8f20a352c0bea", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_string_literals.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_string_literals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_string_literals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_string_literals.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -0,0 +1,212 @@\n+/* This plugin uses the diagnostics code to verify tracking of source code\n+   locations within string literals.  */\n+/* { dg-options \"-O\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"c-family/c-common.h\"\n+#include \"diagnostic.h\"\n+#include \"context.h\"\n+#include \"print-tree.h\"\n+#include \"cpplib.h\"\n+#include \"c-family/c-pragma.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+/* A custom pass for printing string literal location information.  */\n+\n+const pass_data pass_data_test_string_literals =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"test_string_literals\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_test_string_literals : public gimple_opt_pass\n+{\n+public:\n+  pass_test_string_literals(gcc::context *ctxt)\n+    : gimple_opt_pass(pass_data_test_string_literals, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) { return true; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_test_string_literals\n+\n+/* Determine if STMT is a call with NUM_ARGS arguments to a function\n+   named FUNCNAME.\n+   If so, return STMT as a gcall *.  Otherwise return NULL.  */\n+\n+static gcall *\n+check_for_named_call (gimple *stmt,\n+\t\t      const char *funcname, unsigned int num_args)\n+{\n+  gcc_assert (funcname);\n+\n+  gcall *call = dyn_cast <gcall *> (stmt);\n+  if (!call)\n+    return NULL;\n+\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return NULL;\n+\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), funcname))\n+    return NULL;\n+\n+  if (gimple_call_num_args (call) != num_args)\n+    {\n+      error_at (stmt->location, \"expected number of args: %i (got %i)\",\n+\t\tnum_args, gimple_call_num_args (call));\n+      return NULL;\n+    }\n+\n+  return call;\n+}\n+\n+/* Emit a warning covering SRC_RANGE, with the caret at the start of\n+   SRC_RANGE.  */\n+\n+static void\n+emit_warning (source_range src_range)\n+{\n+  location_t loc\n+    = make_location (src_range.m_start, src_range.m_start, src_range.m_finish);\n+  warning_at (loc, 0, \"range %i:%i-%i:%i\",\n+\t      LOCATION_LINE (src_range.m_start),\n+\t      LOCATION_COLUMN (src_range.m_start),\n+\t      LOCATION_LINE (src_range.m_finish),\n+\t      LOCATION_COLUMN (src_range.m_finish));\n+}\n+\n+/* Support code for verifying that we are correctly tracking ranges\n+   within string literals, for use by diagnostic-test-string-literals-*.c.\n+   Emit a warning showing the range of a string literal, for each call to\n+   a function named \"__emit_string_literal_range\".\n+   The initial argument should be a string literal; arguments 2 and 3\n+   should be integer constants, giving the range within the string\n+   to be printed.  */\n+\n+static void\n+test_string_literals (gimple *stmt)\n+{\n+  gcall *call = check_for_named_call (stmt, \"__emit_string_literal_range\", 3);\n+  if (!call)\n+    return;\n+\n+  /* We expect an ADDR_EXPR with a STRING_CST inside it for the\n+     initial arg.  */\n+  tree t_addr_string = gimple_call_arg (call, 0);\n+  if (TREE_CODE (t_addr_string) != ADDR_EXPR)\n+    {\n+      error_at (call->location, \"string literal required for arg 1\");\n+      return;\n+    }\n+\n+  tree t_string = TREE_OPERAND (t_addr_string, 0);\n+  if (TREE_CODE (t_string) != STRING_CST)\n+    {\n+      error_at (call->location, \"string literal required for arg 1\");\n+      return;\n+    }\n+\n+  tree t_start_idx = gimple_call_arg (call, 1);\n+  if (TREE_CODE (t_start_idx) != INTEGER_CST)\n+    {\n+      error_at (call->location, \"integer constant required for arg 2\");\n+      return;\n+    }\n+  int start_idx = TREE_INT_CST_LOW (t_start_idx);\n+\n+  tree t_end_idx = gimple_call_arg (call, 2);\n+  if (TREE_CODE (t_end_idx) != INTEGER_CST)\n+    {\n+      error_at (call->location, \"integer constant required for arg 3\");\n+      return;\n+    }\n+  int end_idx = TREE_INT_CST_LOW (t_end_idx);\n+\n+  /* A STRING_CST doesn't have a location, but the ADDR_EXPR does.  */\n+  location_t strloc = EXPR_LOCATION (t_addr_string);\n+  source_range src_range;\n+  substring_loc substr_loc (strloc, TREE_TYPE (t_string),\n+\t\t\t    start_idx, end_idx);\n+  const char *err = substr_loc.get_range (&src_range);\n+  if (err)\n+    error_at (strloc, \"unable to read substring range: %s\", err);\n+  else\n+    emit_warning (src_range);\n+}\n+\n+/* Call test_string_literals on every statement within FUN.  */\n+\n+unsigned int\n+pass_test_string_literals::execute (function *fun)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB_FN (bb, fun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple *stmt = gsi_stmt (gsi);\n+\ttest_string_literals (stmt);\n+      }\n+\n+  return 0;\n+}\n+\n+/* Entrypoint for the plugin.  Create and register the custom pass.  */\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  pass_info.pass = new pass_test_string_literals (g);\n+  pass_info.reference_pass_name = \"ssa\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_AFTER;\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+\t\t     &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "715038a02794200420925b9046a95add35eca9e1", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -70,6 +70,9 @@ set plugin_test_list [list \\\n \t  diagnostic-test-expressions-1.c } \\\n     { diagnostic_plugin_show_trees.c \\\n \t  diagnostic-test-show-trees-1.c } \\\n+    { diagnostic_plugin_test_string_literals.c \\\n+\t  diagnostic-test-string-literals-1.c \\\n+\t  diagnostic-test-string-literals-2.c } \\\n     { location_overflow_plugin.c \\\n \t  location-overflow-test-1.c \\\n \t  location-overflow-test-2.c } \\"}, {"sha": "3a530b7133af7c1fd5744eb3e6d1502d18fcebed", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1,3 +1,49 @@\n+2016-08-05  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* charset.c (cpp_substring_ranges::cpp_substring_ranges): New\n+\tconstructor.\n+\t(cpp_substring_ranges::~cpp_substring_ranges): New destructor.\n+\t(cpp_substring_ranges::add_range): New method.\n+\t(cpp_substring_ranges::add_n_ranges): New method.\n+\t(_cpp_valid_ucn): Add \"char_range\" and \"loc_reader\" params; if\n+\tthey are non-NULL, read position information from *loc_reader\n+\tand update char_range->m_finish accordingly.\n+\t(convert_ucn): Add \"char_range\", \"loc_reader\", and \"ranges\"\n+\tparams.  If loc_reader is non-NULL, read location information from\n+\tit, and update *ranges accordingly, using char_range.\n+\tConditionalize the conversion into tbuf on tbuf being non-NULL.\n+\t(convert_hex): Likewise, conditionalizing the call to\n+\temit_numeric_escape on tbuf.\n+\t(convert_oct): Likewise.\n+\t(convert_escape): Add params \"loc_reader\" and \"ranges\".  If\n+\tloc_reader is non-NULL, read location information from it, and\n+\tupdate *ranges accordingly.  Conditionalize the conversion into\n+\ttbuf on tbuf being non-NULL.\n+\t(cpp_interpret_string): Rename to...\n+\t(cpp_interpret_string_1): ...this, adding params \"loc_readers\" and\n+\t\"out\".  Use \"to\" to conditionalize the initialization and usage of\n+\t\"tbuf\", such as running the converter.  If \"loc_readers\" is\n+\tnon-NULL, use the instances within it, reading location\n+\tinformation from them, and passing them to convert_escape; likewise\n+\twrite to \"out\" if loc_readers is non-NULL.  Check for leading\n+\tquote and issue an error if it is not present.  Update boundary\n+\tcheck from \"== limit\" to \">= limit\" to protect against erroneous\n+\tlocation values to calls that are not parsing string literals.\n+\t(cpp_interpret_string): Reimplement in terms to\n+\tcpp_interpret_string_1.\n+\t(noop_error_cb): New function.\n+\t(cpp_interpret_string_ranges): New function.\n+\t(cpp_string_location_reader::cpp_string_location_reader): New\n+\tconstructor.\n+\t(cpp_string_location_reader::get_next): New method.\n+\t* include/cpplib.h (class cpp_string_location_reader): New class.\n+\t(class cpp_substring_ranges): New class.\n+\t(cpp_interpret_string_ranges): New prototype.\n+\t* internal.h (_cpp_valid_ucn): Add params \"char_range\" and\n+\t\"loc_reader\".\n+\t* lex.c (forms_identifier_p): Pass NULL for new params to\n+\t_cpp_valid_ucn.\n+\n 2016-08-01  Andreas Schwab  <schwab@suse.de>\n \n \t* include/cpplib.h: Fix comment typo."}, {"sha": "3739d6ca034b2ff51e0d3e4fe1da446578a517b0", "filename": "libcpp/charset.c", "status": "modified", "additions": 380, "deletions": 52, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -812,6 +812,51 @@ cpp_host_to_exec_charset (cpp_reader *pfile, cppchar_t c)\n \n \f\n \n+/* cpp_substring_ranges's constructor. */\n+\n+cpp_substring_ranges::cpp_substring_ranges () :\n+  m_ranges (NULL),\n+  m_num_ranges (0),\n+  m_alloc_ranges (8)\n+{\n+  m_ranges = XNEWVEC (source_range, m_alloc_ranges);\n+}\n+\n+/* cpp_substring_ranges's destructor. */\n+\n+cpp_substring_ranges::~cpp_substring_ranges ()\n+{\n+  free (m_ranges);\n+}\n+\n+/* Add RANGE to the vector of source_range information.  */\n+\n+void\n+cpp_substring_ranges::add_range (source_range range)\n+{\n+  if (m_num_ranges >= m_alloc_ranges)\n+    {\n+      m_alloc_ranges *= 2;\n+      m_ranges\n+\t= (source_range *)xrealloc (m_ranges,\n+\t\t\t\t    sizeof (source_range) * m_alloc_ranges);\n+    }\n+  m_ranges[m_num_ranges++] = range;\n+}\n+\n+/* Read NUM ranges from LOC_READER, adding them to the vector of source_range\n+   information.  */\n+\n+void\n+cpp_substring_ranges::add_n_ranges (int num,\n+\t\t\t\t    cpp_string_location_reader &loc_reader)\n+{\n+  for (int i = 0; i < num; i++)\n+    add_range (loc_reader.get_next ());\n+}\n+\n+\f\n+\n /* Utility routine that computes a mask of the form 0000...111... with\n    WIDTH 1-bits.  */\n static inline size_t\n@@ -980,18 +1025,27 @@ ucn_valid_in_identifier (cpp_reader *pfile, cppchar_t c,\n    one beyond the UCN, or to the syntactically invalid character.\n \n    IDENTIFIER_POS is 0 when not in an identifier, 1 for the start of\n-   an identifier, or 2 otherwise.  */\n+   an identifier, or 2 otherwise.\n+\n+   If CHAR_RANGE and LOC_READER are non-NULL, then position information is\n+   read from *LOC_READER and CHAR_RANGE->m_finish is updated accordingly.  */\n \n bool\n _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n \t\tconst uchar *limit, int identifier_pos,\n-\t\tstruct normalize_state *nst, cppchar_t *cp)\n+\t\tstruct normalize_state *nst, cppchar_t *cp,\n+\t\tsource_range *char_range,\n+\t\tcpp_string_location_reader *loc_reader)\n {\n   cppchar_t result, c;\n   unsigned int length;\n   const uchar *str = *pstr;\n   const uchar *base = str - 2;\n \n+  /* char_range and loc_reader must either be both NULL, or both be\n+     non-NULL.  */\n+  gcc_assert ((char_range != NULL) == (loc_reader != NULL));\n+\n   if (!CPP_OPTION (pfile, cplusplus) && !CPP_OPTION (pfile, c99))\n     cpp_error (pfile, CPP_DL_WARNING,\n \t       \"universal character names are only valid in C++ and C99\");\n@@ -1021,6 +1075,8 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n       if (!ISXDIGIT (c))\n \tbreak;\n       str++;\n+      if (loc_reader)\n+\tchar_range->m_finish = loc_reader->get_next ().m_finish;\n       result = (result << 4) + hex_value (c);\n     }\n   while (--length && str < limit);\n@@ -1086,11 +1142,18 @@ _cpp_valid_ucn (cpp_reader *pfile, const uchar **pstr,\n }\n \n /* Convert an UCN, pointed to by FROM, to UTF-8 encoding, then translate\n-   it to the execution character set and write the result into TBUF.\n-   An advanced pointer is returned.  Issues all relevant diagnostics.  */\n+   it to the execution character set and write the result into TBUF,\n+   if TBUF is non-NULL.\n+   An advanced pointer is returned.  Issues all relevant diagnostics.\n+   If LOC_READER is non-NULL, then RANGES must be non-NULL and CHAR_RANGE\n+   contains the location of the character so far: location information\n+   is read from *LOC_READER, and *RANGES is updated accordingly.  */\n static const uchar *\n convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n+\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt,\n+\t     source_range char_range,\n+\t     cpp_string_location_reader *loc_reader,\n+\t     cpp_substring_ranges *ranges)\n {\n   cppchar_t ucn;\n   uchar buf[6];\n@@ -1099,8 +1162,17 @@ convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n   int rval;\n   struct normalize_state nst = INITIAL_NORMALIZE_STATE;\n \n+  /* loc_reader and ranges must either be both NULL, or both be non-NULL.  */\n+  gcc_assert ((loc_reader != NULL) == (ranges != NULL));\n+\n   from++;  /* Skip u/U.  */\n-  _cpp_valid_ucn (pfile, &from, limit, 0, &nst, &ucn);\n+\n+  if (loc_reader)\n+    /* The u/U is part of the spelling of this character.  */\n+    char_range.m_finish = loc_reader->get_next ().m_finish;\n+\n+  _cpp_valid_ucn (pfile, &from, limit, 0, &nst,\n+\t\t  &ucn, &char_range, loc_reader);\n \n   rval = one_cppchar_to_utf8 (ucn, &bufp, &bytesleft);\n   if (rval)\n@@ -1109,9 +1181,20 @@ convert_ucn (cpp_reader *pfile, const uchar *from, const uchar *limit,\n       cpp_errno (pfile, CPP_DL_ERROR,\n \t\t \"converting UCN to source character set\");\n     }\n-  else if (!APPLY_CONVERSION (cvt, buf, 6 - bytesleft, tbuf))\n-    cpp_errno (pfile, CPP_DL_ERROR,\n-\t       \"converting UCN to execution character set\");\n+  else\n+    {\n+      if (tbuf)\n+\tif (!APPLY_CONVERSION (cvt, buf, 6 - bytesleft, tbuf))\n+\t  cpp_errno (pfile, CPP_DL_ERROR,\n+\t\t     \"converting UCN to execution character set\");\n+\n+      if (loc_reader)\n+\t{\n+\t  int num_encoded_bytes = 6 - bytesleft;\n+\t  for (int i = 0; i < num_encoded_bytes; i++)\n+\t    ranges->add_range (char_range);\n+\t}\n+    }\n \n   return from;\n }\n@@ -1167,31 +1250,48 @@ emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n }\n \n /* Convert a hexadecimal escape, pointed to by FROM, to the execution\n-   character set and write it into the string buffer TBUF.  Returns an\n-   advanced pointer, and issues diagnostics as necessary.\n+   character set and write it into the string buffer TBUF (if non-NULL).\n+   Returns an advanced pointer, and issues diagnostics as necessary.\n    No character set translation occurs; this routine always produces the\n    execution-set character with numeric value equal to the given hex\n-   number.  You can, e.g. generate surrogate pairs this way.  */\n+   number.  You can, e.g. generate surrogate pairs this way.\n+   If LOC_READER is non-NULL, then RANGES must be non-NULL and CHAR_RANGE\n+   contains the location of the character so far: location information\n+   is read from *LOC_READER, and *RANGES is updated accordingly.  */\n static const uchar *\n convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n+\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt,\n+\t     source_range char_range,\n+\t     cpp_string_location_reader *loc_reader,\n+\t     cpp_substring_ranges *ranges)\n {\n   cppchar_t c, n = 0, overflow = 0;\n   int digits_found = 0;\n   size_t width = cvt.width;\n   size_t mask = width_to_mask (width);\n \n+  /* loc_reader and ranges must either be both NULL, or both be non-NULL.  */\n+  gcc_assert ((loc_reader != NULL) == (ranges != NULL));\n+\n   if (CPP_WTRADITIONAL (pfile))\n     cpp_warning (pfile, CPP_W_TRADITIONAL,\n \t         \"the meaning of '\\\\x' is different in traditional C\");\n \n-  from++;  /* Skip 'x'.  */\n+  /* Skip 'x'.  */\n+  from++;\n+\n+  /* The 'x' is part of the spelling of this character.  */\n+  if (loc_reader)\n+    char_range.m_finish = loc_reader->get_next ().m_finish;\n+\n   while (from < limit)\n     {\n       c = *from;\n       if (! hex_p (c))\n \tbreak;\n       from++;\n+      if (loc_reader)\n+\tchar_range.m_finish = loc_reader->get_next ().m_finish;\n       overflow |= n ^ (n << 4 >> 4);\n       n = (n << 4) + hex_value (c);\n       digits_found = 1;\n@@ -1211,7 +1311,10 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n       n &= mask;\n     }\n \n-  emit_numeric_escape (pfile, n, tbuf, cvt);\n+  if (tbuf)\n+    emit_numeric_escape (pfile, n, tbuf, cvt);\n+  if (ranges)\n+    ranges->add_range (char_range);\n \n   return from;\n }\n@@ -1221,23 +1324,34 @@ convert_hex (cpp_reader *pfile, const uchar *from, const uchar *limit,\n    advanced pointer, and issues diagnostics as necessary.\n    No character set translation occurs; this routine always produces the\n    execution-set character with numeric value equal to the given octal\n-   number.  */\n+   number.\n+   If LOC_READER is non-NULL, then RANGES must be non-NULL and CHAR_RANGE\n+   contains the location of the character so far: location information\n+   is read from *LOC_READER, and *RANGES is updated accordingly.  */\n static const uchar *\n convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt)\n+\t     struct _cpp_strbuf *tbuf, struct cset_converter cvt,\n+\t     source_range char_range,\n+\t     cpp_string_location_reader *loc_reader,\n+\t     cpp_substring_ranges *ranges)\n {\n   size_t count = 0;\n   cppchar_t c, n = 0;\n   size_t width = cvt.width;\n   size_t mask = width_to_mask (width);\n   bool overflow = false;\n \n+  /* loc_reader and ranges must either be both NULL, or both be non-NULL.  */\n+  gcc_assert ((loc_reader != NULL) == (ranges != NULL));\n+\n   while (from < limit && count++ < 3)\n     {\n       c = *from;\n       if (c < '0' || c > '7')\n \tbreak;\n       from++;\n+      if (loc_reader)\n+\tchar_range.m_finish = loc_reader->get_next ().m_finish;\n       overflow |= n ^ (n << 3 >> 3);\n       n = (n << 3) + c - '0';\n     }\n@@ -1249,18 +1363,26 @@ convert_oct (cpp_reader *pfile, const uchar *from, const uchar *limit,\n       n &= mask;\n     }\n \n-  emit_numeric_escape (pfile, n, tbuf, cvt);\n+  if (tbuf)\n+    emit_numeric_escape (pfile, n, tbuf, cvt);\n+  if (ranges)\n+    ranges->add_range (char_range);\n \n   return from;\n }\n \n /* Convert an escape sequence (pointed to by FROM) to its value on\n    the target, and to the execution character set.  Do not scan past\n-   LIMIT.  Write the converted value into TBUF.  Returns an advanced\n-   pointer.  Handles all relevant diagnostics.  */\n+   LIMIT.  Write the converted value into TBUF, if TBUF is non-NULL.\n+   Returns an advanced pointer.  Handles all relevant diagnostics.\n+   If LOC_READER is non-NULL, then RANGES must be non-NULL: location\n+   information is read from *LOC_READER, and *RANGES is updated\n+   accordingly.  */\n static const uchar *\n convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n-\t\tstruct _cpp_strbuf *tbuf, struct cset_converter cvt)\n+\t\tstruct _cpp_strbuf *tbuf, struct cset_converter cvt,\n+\t\tcpp_string_location_reader *loc_reader,\n+\t\tcpp_substring_ranges *ranges)\n {\n   /* Values of \\a \\b \\e \\f \\n \\r \\t \\v respectively.  */\n #if HOST_CHARSET == HOST_CHARSET_ASCII\n@@ -1273,20 +1395,28 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \n   uchar c;\n \n+  /* Record the location of the backslash.  */\n+  source_range char_range;\n+  if (loc_reader)\n+    char_range = loc_reader->get_next ();\n+\n   c = *from;\n   switch (c)\n     {\n       /* UCNs, hex escapes, and octal escapes are processed separately.  */\n     case 'u': case 'U':\n-      return convert_ucn (pfile, from, limit, tbuf, cvt);\n+      return convert_ucn (pfile, from, limit, tbuf, cvt,\n+\t\t\t  char_range, loc_reader, ranges);\n \n     case 'x':\n-      return convert_hex (pfile, from, limit, tbuf, cvt);\n+      return convert_hex (pfile, from, limit, tbuf, cvt,\n+\t\t\t  char_range, loc_reader, ranges);\n       break;\n \n     case '0':  case '1':  case '2':  case '3':\n     case '4':  case '5':  case '6':  case '7':\n-      return convert_oct (pfile, from, limit, tbuf, cvt);\n+      return convert_oct (pfile, from, limit, tbuf, cvt,\n+\t\t\t  char_range, loc_reader, ranges);\n \n       /* Various letter escapes.  Get the appropriate host-charset\n \t value into C.  */\n@@ -1338,10 +1468,17 @@ convert_escape (cpp_reader *pfile, const uchar *from, const uchar *limit,\n \t}\n     }\n \n-  /* Now convert what we have to the execution character set.  */\n-  if (!APPLY_CONVERSION (cvt, &c, 1, tbuf))\n-    cpp_errno (pfile, CPP_DL_ERROR,\n-\t       \"converting escape sequence to execution character set\");\n+  if (tbuf)\n+    /* Now convert what we have to the execution character set.  */\n+    if (!APPLY_CONVERSION (cvt, &c, 1, tbuf))\n+      cpp_errno (pfile, CPP_DL_ERROR,\n+\t\t \"converting escape sequence to execution character set\");\n+\n+  if (loc_reader)\n+    {\n+      char_range.m_finish = loc_reader->get_next ().m_finish;\n+      ranges->add_range (char_range);\n+    }\n \n   return from + 1;\n }\n@@ -1374,28 +1511,52 @@ converter_for_type (cpp_reader *pfile, enum cpp_ttype type)\n    are to be converted from the source to the execution character set,\n    escape sequences translated, and finally all are to be\n    concatenated.  WIDE indicates whether or not to produce a wide\n-   string.  The result is written into TO.  Returns true for success,\n-   false for failure.  */\n-bool\n-cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n-\t\t      cpp_string *to,  enum cpp_ttype type)\n+   string.  If TO is non-NULL, the result is written into TO.\n+   If LOC_READERS and OUT are non-NULL, then location information\n+   is read from LOC_READERS (which must be an array of length COUNT),\n+   and location information is written to *RANGES.\n+\n+   Returns true for success, false for failure.  */\n+\n+static bool\n+cpp_interpret_string_1 (cpp_reader *pfile, const cpp_string *from, size_t count,\n+\t\t\tcpp_string *to,  enum cpp_ttype type,\n+\t\t\tcpp_string_location_reader *loc_readers,\n+\t\t\tcpp_substring_ranges *out)\n {\n   struct _cpp_strbuf tbuf;\n   const uchar *p, *base, *limit;\n   size_t i;\n   struct cset_converter cvt = converter_for_type (pfile, type);\n \n-  tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, from->len);\n-  tbuf.text = XNEWVEC (uchar, tbuf.asize);\n-  tbuf.len = 0;\n+  /* loc_readers and out must either be both NULL, or both be non-NULL.  */\n+  gcc_assert ((loc_readers != NULL) == (out != NULL));\n+\n+  if (to)\n+    {\n+      tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, from->len);\n+      tbuf.text = XNEWVEC (uchar, tbuf.asize);\n+      tbuf.len = 0;\n+    }\n \n   for (i = 0; i < count; i++)\n     {\n+      cpp_string_location_reader *loc_reader = NULL;\n+      if (loc_readers)\n+\tloc_reader = &loc_readers[i];\n+\n       p = from[i].text;\n       if (*p == 'u')\n \t{\n-\t  if (*++p == '8')\n-\t    p++;\n+\t  p++;\n+\t  if (loc_reader)\n+\t    loc_reader->get_next ();\n+\t  if (*p == '8')\n+\t    {\n+\t      p++;\n+\t      if (loc_reader)\n+\t\tloc_reader->get_next ();\n+\t    }\n \t}\n       else if (*p == 'L' || *p == 'U') p++;\n       if (*p == 'R')\n@@ -1414,13 +1575,43 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n \n \t  /* Raw strings are all normal characters; these can be fed\n \t     directly to convert_cset.  */\n-\t  if (!APPLY_CONVERSION (cvt, p, limit - p, &tbuf))\n-\t    goto fail;\n+\t  if (to)\n+\t    if (!APPLY_CONVERSION (cvt, p, limit - p, &tbuf))\n+\t      goto fail;\n+\n+\t  if (loc_reader)\n+\t    {\n+\t      /* If generating source ranges, assume we have a 1:1\n+\t\t correspondence between bytes in the source encoding and bytes\n+\t\t in the execution encoding (e.g. if we have a UTF-8 to UTF-8\n+\t\t conversion), so that this run of bytes in the source file\n+\t\t corresponds to a run of bytes in the execution string.\n+\t\t This requirement is guaranteed by an early-reject in\n+\t\t cpp_interpret_string_ranges.  */\n+\t      gcc_assert (cvt.func == convert_no_conversion);\n+\t      out->add_n_ranges (limit - p, *loc_reader);\n+\t    }\n \n \t  continue;\n \t}\n \n-      p++; /* Skip leading quote.  */\n+      /* If we don't now have a leading quote, something has gone wrong.\n+\t This can occur if cpp_interpret_string_ranges is handling a\n+\t stringified macro argument, but should not be possible otherwise.  */\n+      if (*p != '\"' && *p != '\\'')\n+\t{\n+\t  gcc_assert (out != NULL);\n+\t  cpp_error (pfile, CPP_DL_ERROR, \"missing open quote\");\n+\t  if (to)\n+\t    free (tbuf.text);\n+\t  return false;\n+\t}\n+\n+      /* Skip leading quote.  */\n+      p++;\n+      if (loc_reader)\n+\tloc_reader->get_next ();\n+\n       limit = from[i].text + from[i].len - 1; /* Skip trailing quote.  */\n \n       for (;;)\n@@ -1432,29 +1623,130 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n \t    {\n \t      /* We have a run of normal characters; these can be fed\n \t\t directly to convert_cset.  */\n-\t      if (!APPLY_CONVERSION (cvt, base, p - base, &tbuf))\n-\t\tgoto fail;\n+\t      if (to)\n+\t\tif (!APPLY_CONVERSION (cvt, base, p - base, &tbuf))\n+\t\t  goto fail;\n+\t    /* Similar to above: assumes we have a 1:1 correspondence\n+\t       between bytes in the source encoding and bytes in the\n+\t       execution encoding.  */\n+\t      if (loc_reader)\n+\t\t{\n+\t\t  gcc_assert (cvt.func == convert_no_conversion);\n+\t\t  out->add_n_ranges (p - base, *loc_reader);\n+\t\t}\n \t    }\n-\t  if (p == limit)\n+\t  if (p >= limit)\n \t    break;\n \n-\t  p = convert_escape (pfile, p + 1, limit, &tbuf, cvt);\n+\t  struct _cpp_strbuf *tbuf_ptr = to ? &tbuf : NULL;\n+\t  p = convert_escape (pfile, p + 1, limit, tbuf_ptr, cvt,\n+\t\t\t      loc_reader, out);\n \t}\n     }\n-  /* NUL-terminate the 'to' buffer and translate it to a cpp_string\n-     structure.  */\n-  emit_numeric_escape (pfile, 0, &tbuf, cvt);\n-  tbuf.text = XRESIZEVEC (uchar, tbuf.text, tbuf.len);\n-  to->text = tbuf.text;\n-  to->len = tbuf.len;\n+\n+  if (to)\n+    {\n+      /* NUL-terminate the 'to' buffer and translate it to a cpp_string\n+\t structure.  */\n+      emit_numeric_escape (pfile, 0, &tbuf, cvt);\n+      tbuf.text = XRESIZEVEC (uchar, tbuf.text, tbuf.len);\n+      to->text = tbuf.text;\n+      to->len = tbuf.len;\n+    }\n+\n   return true;\n \n  fail:\n   cpp_errno (pfile, CPP_DL_ERROR, \"converting to execution character set\");\n-  free (tbuf.text);\n+  if (to)\n+    free (tbuf.text);\n   return false;\n }\n \n+/* FROM is an array of cpp_string structures of length COUNT.  These\n+   are to be converted from the source to the execution character set,\n+   escape sequences translated, and finally all are to be\n+   concatenated.  WIDE indicates whether or not to produce a wide\n+   string.  The result is written into TO.  Returns true for success,\n+   false for failure.  */\n+bool\n+cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n+\t\t      cpp_string *to,  enum cpp_ttype type)\n+{\n+  return cpp_interpret_string_1 (pfile, from, count, to, type, NULL, NULL);\n+}\n+\n+/* A \"do nothing\" error-handling callback for use by\n+   cpp_interpret_string_ranges, so that it can temporarily suppress\n+   error-handling.  */\n+\n+static bool\n+noop_error_cb (cpp_reader *, int, int, rich_location *,\n+\t       const char *, va_list *)\n+{\n+  /* no-op.  */\n+  return true;\n+}\n+\n+/* This function mimics the behavior of cpp_interpret_string, but\n+   rather than generating a string in the execution character set,\n+   *OUT is written to with the source code ranges of the characters\n+   in such a string.\n+   FROM and LOC_READERS should both be arrays of length COUNT.\n+   Returns NULL for success, or an error message for failure.  */\n+\n+const char *\n+cpp_interpret_string_ranges (cpp_reader *pfile, const cpp_string *from,\n+\t\t\t     cpp_string_location_reader *loc_readers,\n+\t\t\t     size_t count,\n+\t\t\t     cpp_substring_ranges *out,\n+\t\t\t     enum cpp_ttype type)\n+{\n+  /* There are a couple of cases in the range-handling in\n+     cpp_interpret_string_1 that rely on there being a 1:1 correspondence\n+     between bytes in the source encoding and bytes in the execution\n+     encoding, so that each byte in the execution string can correspond\n+     to the location of a byte in the source string.\n+\n+     This holds for the typical case of a UTF-8 to UTF-8 conversion.\n+     Enforce this requirement by only attempting to track substring\n+     locations if we have source encoding == execution encoding.\n+\n+     This is a stronger condition than we need, since we could e.g.\n+     have ASCII to EBCDIC (with 1 byte per character before and after),\n+     but it seems to be a reasonable restriction.  */\n+  struct cset_converter cvt = converter_for_type (pfile, type);\n+  if (cvt.func != convert_no_conversion)\n+    return \"execution character set != source character set\";\n+\n+  /* For on-demand strings we have already lexed the strings, so there\n+     should be no errors.  However, if we have bogus source location\n+     data (or stringified macro arguments), the attempt to lex the\n+     strings could fail with an error.  Temporarily install an\n+     error-handler to catch the error, so that it can lead to this call\n+     failing, rather than being emitted as a user-visible diagnostic.\n+     If an error does occur, we should see it via the return value of\n+     cpp_interpret_string_1.  */\n+  bool (*saved_error_handler) (cpp_reader *, int, int, rich_location *,\n+\t\t\t       const char *, va_list *)\n+    ATTRIBUTE_FPTR_PRINTF(5,0);\n+\n+  saved_error_handler = pfile->cb.error;\n+  pfile->cb.error = noop_error_cb;\n+\n+  bool result = cpp_interpret_string_1 (pfile, from, count, NULL, type,\n+\t\t\t\t\tloc_readers, out);\n+\n+  /* Restore the saved error-handler.  */\n+  pfile->cb.error = saved_error_handler;\n+\n+  if (!result)\n+    return \"cpp_interpret_string_1 failed\";\n+\n+  /* Success.  */\n+  return NULL;\n+}\n+\n /* Subroutine of do_line and do_linemarker.  Convert escape sequences\n    in a string, but do not perform character set conversion.  */\n bool\n@@ -1818,3 +2110,39 @@ _cpp_default_encoding (void)\n \n   return current_encoding;\n }\n+\n+/* Implementation of class cpp_string_location_reader.  */\n+\n+/* Constructor for cpp_string_location_reader.  */\n+\n+cpp_string_location_reader::\n+cpp_string_location_reader (source_location src_loc,\n+\t\t\t    line_maps *line_table)\n+: m_line_table (line_table)\n+{\n+  src_loc = get_range_from_loc (line_table, src_loc).m_start;\n+\n+  /* SRC_LOC might be a macro location.  It only makes sense to do\n+     column-by-column calculations on ordinary maps, so get the\n+     corresponding location in an ordinary map.  */\n+  m_loc\n+    = linemap_resolve_location (line_table, src_loc,\n+\t\t\t\tLRK_SPELLING_LOCATION, NULL);\n+\n+  const line_map_ordinary *map\n+    = linemap_check_ordinary (linemap_lookup (line_table, m_loc));\n+  m_offset_per_column = (1 << map->m_range_bits);\n+}\n+\n+/* Get the range of the next source byte.  */\n+\n+source_range\n+cpp_string_location_reader::get_next ()\n+{\n+  source_range result;\n+  result.m_start = m_loc;\n+  result.m_finish = m_loc;\n+  if (m_loc <= LINE_MAP_MAX_LOCATION_WITH_COLS)\n+    m_loc += m_offset_per_column;\n+  return result;\n+}"}, {"sha": "659686bf2616ee03a1db13842569f1c223c70d88", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -743,6 +743,51 @@ struct GTY(()) cpp_hashnode {\n   union _cpp_hashnode_value GTY ((desc (\"CPP_HASHNODE_VALUE_IDX (%1)\"))) value;\n };\n \n+/* A class for iterating through the source locations within a\n+   string token (before escapes are interpreted, and before\n+   concatenation).  */\n+\n+class cpp_string_location_reader {\n+ public:\n+  cpp_string_location_reader (source_location src_loc,\n+\t\t\t      line_maps *line_table);\n+\n+  source_range get_next ();\n+\n+ private:\n+  source_location m_loc;\n+  int m_offset_per_column;\n+  line_maps *m_line_table;\n+};\n+\n+/* A class for storing the source ranges of all of the characters within\n+   a string literal, after escapes are interpreted, and after\n+   concatenation.\n+\n+   This is not GTY-marked, as instances are intended to be temporary.  */\n+\n+class cpp_substring_ranges\n+{\n+ public:\n+  cpp_substring_ranges ();\n+  ~cpp_substring_ranges ();\n+\n+  int get_num_ranges () const { return m_num_ranges; }\n+  source_range get_range (int idx) const\n+  {\n+    linemap_assert (idx < m_num_ranges);\n+    return m_ranges[idx];\n+  }\n+\n+  void add_range (source_range range);\n+  void add_n_ranges (int num, cpp_string_location_reader &loc_reader);\n+\n+ private:\n+  source_range *m_ranges;\n+  int m_num_ranges;\n+  int m_alloc_ranges;\n+};\n+\n /* Call this first to get a handle to pass to other functions.\n \n    If you want cpplib to manage its own hashtable, pass in a NULL\n@@ -829,6 +874,12 @@ extern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,\n extern bool cpp_interpret_string (cpp_reader *,\n \t\t\t\t  const cpp_string *, size_t,\n \t\t\t\t  cpp_string *, enum cpp_ttype);\n+extern const char *cpp_interpret_string_ranges (cpp_reader *pfile,\n+\t\t\t\t\t\tconst cpp_string *from,\n+\t\t\t\t\t\tcpp_string_location_reader *,\n+\t\t\t\t\t\tsize_t count,\n+\t\t\t\t\t\tcpp_substring_ranges *out,\n+\t\t\t\t\t\tenum cpp_ttype type);\n extern bool cpp_interpret_string_notranslate (cpp_reader *,\n \t\t\t\t\t      const cpp_string *, size_t,\n \t\t\t\t\t      cpp_string *, enum cpp_ttype);"}, {"sha": "4a5cd3c027cdcada2d6d6823067a3f237af2e6b4", "filename": "libcpp/internal.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -754,7 +754,9 @@ struct normalize_state\n extern bool _cpp_valid_ucn (cpp_reader *, const unsigned char **,\n \t\t\t    const unsigned char *, int,\n \t\t\t    struct normalize_state *state,\n-\t\t\t    cppchar_t *);\n+\t\t\t    cppchar_t *,\n+\t\t\t    source_range *char_range,\n+\t\t\t    cpp_string_location_reader *loc_reader);\n extern void _cpp_destroy_iconv (cpp_reader *);\n extern unsigned char *_cpp_convert_input (cpp_reader *, const char *,\n \t\t\t\t\t  unsigned char *, size_t, size_t,"}, {"sha": "4e71965ebe793be4f6920fad0b9926d23f443a76", "filename": "libcpp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88fa5555a309e5d6c6171b957daaf2f800920869/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=88fa5555a309e5d6c6171b957daaf2f800920869", "patch": "@@ -1247,7 +1247,7 @@ forms_identifier_p (cpp_reader *pfile, int first,\n       cppchar_t s;\n       buffer->cur += 2;\n       if (_cpp_valid_ucn (pfile, &buffer->cur, buffer->rlimit, 1 + !first,\n-\t\t\t  state, &s))\n+\t\t\t  state, &s, NULL, NULL))\n \treturn true;\n       buffer->cur -= 2;\n     }"}]}