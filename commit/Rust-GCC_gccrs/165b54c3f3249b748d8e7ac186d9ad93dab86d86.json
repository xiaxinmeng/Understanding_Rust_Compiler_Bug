{"sha": "165b54c3f3249b748d8e7ac186d9ad93dab86d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY1YjU0YzNmMzI0OWI3NDhkOGU3YWMxODZkOWFkOTNkYWI4NmQ4Ng==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-07-17T00:31:15Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-07-17T00:31:15Z"}, "message": "cfgcleanup.c (try_simplify_condjump): Don't remove line notes to avoid unreachable code warnings.\n\n\t* cfgcleanup.c (try_simplify_condjump): Don't remove line\n\tnotes to avoid unreachable code warnings.\n\t* toplev.c (backend_init): Don't emit line notes for\n\tunreachable code warnings.\n\n\t* combine.c (distribute_notes): Don't distribute a\n\tREG_VTABLE_REF note.\n\t* final.c (final_scan_insn): Don't handle it.\n\t* rtl.c (reg_note_name): Remove it.\n\t* rtl.h (enum reg_node): Dito.\n\n\t* emit-rtl.c (force_line_numbers, restore_line_number_status):\n\tRemove.\n\t* rtl.h (force_line_numbers, restore_line_number_status):\n\tRemove prototypes.\n\n\t* stmt.c (using_eh_for_cleanups_p, using_eh_for_cleanups): Move...\n\t* tree-eh.c (using_eh_for_cleanups_p): ...here.  Make static.\n\t(using_eh_for_cleanups): Also moved here.\n\n\t* expr.c (expand_expr_real_1) <CASE_LABEL_EXPR>: Die if we see one.\n\t<SWITCH_EXPR>: Die if we have a non-NULL SWITCH_BODY.  Update calls\n\tto expand_start_case and add_case_node.\n\t* stmt.c (struct nesting): Cleanup unused fields condition_code,\n\tlast_unconditional_cleanup, nominal_type, printname, and\n\tline_number_status.\n\t(struct fixup_goto): Remove.\n\t(struct stmt_status): Remove x_goto_fixup_chain field.\n\t(goto_fixup_chain): Remove.\n\t(strip_default_case_nodes, group_case_nodes, emit_jump_if_reachable,\n\tpushcase, pushcase_range): Remove.\n\t(expand_start_bindings_and_block): Don't set unused fields in\n\tthe nesting stack.\n\t(expand_start_case, add_case_node): Cleanup unused formal arguments.\n\t(expand_end_case_type): Don't simplify the case-list.  Use emit_jump\n\tinstead of emit_jump_if_reachable.\n\t(emit_case_nodes): Likewise.\n\t* tree-cfg.c (group_case_labels, cleanup_dead_labels): No longer\n\tstatic.\n\t(update_eh_label): Work around left-over exception handing regions.\n\t* tree-flow.h (group_case_labels, cleanup_dead_labels): Add protos.\n\t* tree-optimize.c (execute_cleanup_cfg_post_optimizing): New function.\n\t(pass_cleanup_cfg_post_optimizing): New pass.\n\t(init_tree_optimization_passes): Run the new pass after all\n\toptimizations.\n\t* tree.h (pushcase, pushcase_range): Remove prototypes.\n\t(expand_start_case, add_case_node): Update prototypes.\n\ncp/\n\t* cp-tree.h (struct lang_type): Don't have three GTY options on a\n\tsingle bit GTY desc.\n\njava/\n\t* parse.y (java_complete_expand_methods, java_expand_classes): Don't\n\tabuse restore_line_number_status.\n\nFrom-SVN: r84849", "tree": {"sha": "e09da04f98976ea28aef332274d380cd05ad342a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e09da04f98976ea28aef332274d380cd05ad342a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/165b54c3f3249b748d8e7ac186d9ad93dab86d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165b54c3f3249b748d8e7ac186d9ad93dab86d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165b54c3f3249b748d8e7ac186d9ad93dab86d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165b54c3f3249b748d8e7ac186d9ad93dab86d86/comments", "author": null, "committer": null, "parents": [{"sha": "cd0408d8ffac72f1f807c200896d154b798927c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd0408d8ffac72f1f807c200896d154b798927c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd0408d8ffac72f1f807c200896d154b798927c4"}], "stats": {"total": 553, "additions": 142, "deletions": 411}, "files": [{"sha": "48b3e20702fed14880c7ce0ef3c1b05c6264d90d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1,3 +1,53 @@\n+2004-07-17  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cfgcleanup.c (try_simplify_condjump): Don't remove line\n+\tnotes to avoid unreachable code warnings.\n+\t* toplev.c (backend_init): Don't emit line notes for\n+\tunreachable code warnings.\n+\n+\t* combine.c (distribute_notes): Don't distribute a\n+\tREG_VTABLE_REF note.\n+\t* final.c (final_scan_insn): Don't handle it.\n+\t* rtl.c (reg_note_name): Remove it.\n+\t* rtl.h (enum reg_node): Dito.\n+\n+\t* emit-rtl.c (force_line_numbers, restore_line_number_status):\n+\tRemove.\n+\t* rtl.h (force_line_numbers, restore_line_number_status):\n+\tRemove prototypes.\n+\n+\t* stmt.c (using_eh_for_cleanups_p, using_eh_for_cleanups): Move...\n+\t* tree-eh.c (using_eh_for_cleanups_p): ...here.  Make static.\n+\t(using_eh_for_cleanups): Also moved here.\n+\n+\t* expr.c (expand_expr_real_1) <CASE_LABEL_EXPR>: Die if we see one.\n+\t<SWITCH_EXPR>: Die if we have a non-NULL SWITCH_BODY.  Update calls\n+\tto expand_start_case and add_case_node.\n+\t* stmt.c (struct nesting): Cleanup unused fields condition_code,\n+\tlast_unconditional_cleanup, nominal_type, printname, and\n+\tline_number_status.\n+\t(struct fixup_goto): Remove.\n+\t(struct stmt_status): Remove x_goto_fixup_chain field.\n+\t(goto_fixup_chain): Remove.\n+\t(strip_default_case_nodes, group_case_nodes, emit_jump_if_reachable,\n+\tpushcase, pushcase_range): Remove.\n+\t(expand_start_bindings_and_block): Don't set unused fields in\n+\tthe nesting stack.\n+\t(expand_start_case, add_case_node): Cleanup unused formal arguments.\n+\t(expand_end_case_type): Don't simplify the case-list.  Use emit_jump\n+\tinstead of emit_jump_if_reachable.\n+\t(emit_case_nodes): Likewise.\n+\t* tree-cfg.c (group_case_labels, cleanup_dead_labels): No longer\n+\tstatic.\n+\t(update_eh_label): Work around left-over exception handing regions.\n+\t* tree-flow.h (group_case_labels, cleanup_dead_labels): Add protos.\n+\t* tree-optimize.c (execute_cleanup_cfg_post_optimizing): New function.\n+\t(pass_cleanup_cfg_post_optimizing): New pass.\n+\t(init_tree_optimization_passes): Run the new pass after all\n+\toptimizations.\n+\t* tree.h (pushcase, pushcase_range): Remove prototypes.\n+\t(expand_start_case, add_case_node): Update prototypes.\n+\n 2004-07-16  Krister Walfridsson  <cato@df.lth.se>\n \n \t* tree-inline.c (estimate_num_insns_1): Correct increase of count."}, {"sha": "f704d315a19d4ce36d9dd026f6fd7f0d5726330b", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -122,8 +122,6 @@ try_simplify_condjump (basic_block cbranch_block)\n   basic_block jump_block, jump_dest_block, cbranch_dest_block;\n   edge cbranch_jump_edge, cbranch_fallthru_edge;\n   rtx cbranch_insn;\n-  rtx insn, next;\n-  rtx end;\n \n   /* Verify that there are exactly two successors.  */\n   if (!cbranch_block->succ\n@@ -186,26 +184,6 @@ try_simplify_condjump (basic_block cbranch_block)\n   cbranch_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n   update_br_prob_note (cbranch_block);\n \n-  end = BB_END (jump_block);\n-  /* Deleting a block may produce unreachable code warning even when we are\n-     not deleting anything live.  Suppress it by moving all the line number\n-     notes out of the block.  */\n-  for (insn = BB_HEAD (jump_block); insn != NEXT_INSN (BB_END (jump_block));\n-       insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-      if (NOTE_P (insn) && NOTE_LINE_NUMBER (insn) > 0)\n-\t{\n-\t  if (insn == BB_END (jump_block))\n-\t    {\n-\t      BB_END (jump_block) = PREV_INSN (insn);\n-\t      if (insn == end)\n-\t        break;\n-\t    }\n-\t  reorder_insns_nobb (insn, insn, end);\n-\t  end = insn;\n-\t}\n-    }\n   /* Delete the block with the unconditional jump, and clean up the mess.  */\n   delete_basic_block (jump_block);\n   tidy_fallthru_edge (cbranch_jump_edge);"}, {"sha": "e6002d60c251233d01d83375e0ee5b2491c8094e", "filename": "gcc/combine.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -11698,12 +11698,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t  /* Just get rid of this note, as it is unused later anyway.  */\n \t  break;\n \n-\tcase REG_VTABLE_REF:\n-\t  /* ??? Should remain with *a particular* memory load.  Given the\n-\t     nature of vtable data, the last insn seems relatively safe.  */\n-\t  place = i3;\n-\t  break;\n-\n \tcase REG_NON_LOCAL_GOTO:\n \t  if (JUMP_P (i3))\n \t    place = i3;"}, {"sha": "472b101436e6125ee9edd261660d8a9d58690b19", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1,3 +1,8 @@\n+2004-07-16  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cp-tree.h (struct lang_type): Don't have three GTY options on a\n+\tsingle bit GTY desc.\n+\n 2004-07-16  Richard Henderson  <rth@redhat.com>\n \n \t* cp-lang.c (LANG_HOOKS_TREE_INLINING_COPY_RES_DECL_FOR_INLINING): Die."}, {"sha": "e7069ba51e8d761df5c526ccf1f53d0c1972879d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1033,7 +1033,7 @@ struct lang_type GTY(())\n {\n   union lang_type_u \n   {\n-    struct lang_type_header GTY((tag (\"2\"))) h;\n+    struct lang_type_header GTY((skip (\"\"))) h;\n     struct lang_type_class  GTY((tag (\"1\"))) c;\n     struct lang_type_ptrmem GTY((tag (\"0\"))) ptrmem;\n   } GTY((desc (\"%h.h.is_lang_type_class\"))) u;"}, {"sha": "0f32005f49d9a97f4b2f0dff01ef9b9657340507", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -5438,27 +5438,6 @@ init_emit_once (int line_numbers)\n     pic_offset_table_rtx = gen_raw_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n }\n \f\n-/* Query and clear/ restore no_line_numbers.  This is used by the\n-   switch / case handling in stmt.c to give proper line numbers in\n-   warnings about unreachable code.  */\n-\n-int\n-force_line_numbers (void)\n-{\n-  int old = no_line_numbers;\n-\n-  no_line_numbers = 0;\n-  if (old)\n-    force_next_line_note ();\n-  return old;\n-}\n-\n-void\n-restore_line_number_status (int old_value)\n-{\n-  no_line_numbers = old_value;\n-}\n-\n /* Produce exact duplicate of insn INSN after AFTER.\n    Care updating of libcall regions if present.  */\n "}, {"sha": "2ca28db596fd4957ab9fec7a932fe890eedcb39f", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -8541,6 +8541,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case WITH_CLEANUP_EXPR:\n     case CLEANUP_POINT_EXPR:\n     case TARGET_EXPR:\n+    case CASE_LABEL_EXPR:\n     case VA_ARG_EXPR:\n       /* Lowered by gimplify.c.  */\n       abort ();\n@@ -8561,10 +8562,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       abort ();\n \n     case SWITCH_EXPR:\n-      expand_start_case (0, SWITCH_COND (exp), integer_type_node,\n-\t\t\t \"switch\");\n+      expand_start_case (SWITCH_COND (exp));\n+      /* The switch body is lowered in gimplify.c, we should never have\n+\t switches with a non-NULL SWITCH_BODY here.  */\n       if (SWITCH_BODY (exp))\n-        expand_expr_stmt (SWITCH_BODY (exp));\n+        abort ();\n       if (SWITCH_LABELS (exp))\n \t{\n \t  tree duplicate = 0;\n@@ -8623,7 +8625,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    }\n \t\t}\n \t      \n-\t      add_case_node (case_low, case_high, CASE_LABEL (elt), &duplicate, true);\n+\t      add_case_node (case_low, case_high, CASE_LABEL (elt), &duplicate);\n \t      if (duplicate)\n \t\tabort ();\n \t    }\n@@ -8635,16 +8637,6 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       expand_label (TREE_OPERAND (exp, 0));\n       return const0_rtx;\n \n-    case CASE_LABEL_EXPR:\n-      {\n-\ttree duplicate = 0;\n-\tadd_case_node (CASE_LOW (exp), CASE_HIGH (exp), CASE_LABEL (exp),\n-\t\t       &duplicate, false);\n-\tif (duplicate)\n-\t  abort ();\n-\treturn const0_rtx;\n-      }\n-\n     case ASM_EXPR:\n       expand_asm_expr (exp);\n       return const0_rtx;"}, {"sha": "ea75e541348ede2700b4d23477ab6b86ef6d3cd3", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1999,7 +1999,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \trtx body = PATTERN (insn);\n \tint insn_code_number;\n \tconst char *template;\n-\trtx note;\n \n \t/* An INSN, JUMP_INSN or CALL_INSN.\n \t   First check for special kinds that recog doesn't recognize.  */\n@@ -2549,18 +2548,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t  dwarf2out_frame_debug (insn);\n #endif\n \n-#if 0\n-\t/* It's not at all clear why we did this and doing so used to\n-\t   interfere with tests that used REG_WAS_0 notes, which are\n-\t   now gone, so let's try with this out.  */\n-\n-\t/* Mark this insn as having been output.  */\n-\tINSN_DELETED_P (insn) = 1;\n-#endif\n-\n-\t/* Emit information for vtable gc.  */\n-\tnote = find_reg_note (insn, REG_VTABLE_REF, NULL_RTX);\n-\n \tcurrent_output_insn = debug_insn = 0;\n       }\n     }"}, {"sha": "e2e8585ca5a545a253f5618691a642faed19d7f6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1066,7 +1066,7 @@ compare_case_labels (const void *p1, const void *p2)\n   return tree_int_cst_compare (CASE_LOW (case1), CASE_LOW (case2));\n }\n \n-/* Sort the case labels in LABEL_VEC in ascending order.  */\n+/* Sort the case labels in LABEL_VEC in place in ascending order.  */\n \n void\n sort_case_labels (tree label_vec)"}, {"sha": "5cd390e2dfc469709d8c2d4a00ca67fcd9ed066e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1,3 +1,8 @@\n+2004-07-16  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* parse.y (java_complete_expand_methods, java_expand_classes): Don't\n+\tabuse restore_line_number_status.\n+\n 2004-07-15  Frank Ch. Eigler  <fche@redhat.com>\n \n \tg++/15861"}, {"sha": "2ca09a2c33ff1afa1a70315859f2a97d7b1b498d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -7742,21 +7742,9 @@ java_complete_expand_methods (tree class_decl)\n   /* Now do the constructors */\n   for (decl = first_decl ; !java_error_count && decl; decl = TREE_CHAIN (decl))\n     {\n-      int no_body;\n-\n       if (!DECL_CONSTRUCTOR_P (decl))\n \tcontinue;\n-\n-      no_body = !DECL_FUNCTION_BODY (decl);\n-      /* Don't generate debug info on line zero when expanding a\n-\t generated constructor. */\n-      if (no_body)\n-\trestore_line_number_status (1);\n-\n       java_complete_expand_method (decl);\n-\n-      if (no_body)\n-\trestore_line_number_status (0);\n     }\n \n   /* First, do the ordinary methods. */\n@@ -9032,9 +9020,7 @@ java_expand_classes (void)\n \t\t{\n \t\t  if (DECL_CONSTRUCTOR_P (d))\n \t\t    {\n-\t\t      restore_line_number_status (1);\n \t\t      java_complete_expand_method (d);\n-\t\t      restore_line_number_status (0);\n \t\t      break;\t/* There is only one constructor. */\n \t\t    }\n \t\t}\n@@ -9056,11 +9042,7 @@ java_expand_classes (void)\n \t  for (d = TYPE_METHODS (current_class); d; d = TREE_CHAIN (d))\n \t    {\n \t      if (DECL_RESULT (d) == NULL_TREE)\n-\t\t{\n-\t\t  restore_line_number_status (1);\n-\t\t  java_complete_expand_method (d);\n-\t\t  restore_line_number_status (0);\n-\t\t}\n+\t\tjava_complete_expand_method (d);\n \t    }\n \t}\n     }\n@@ -9089,9 +9071,7 @@ java_expand_classes (void)\n \t\t      if (DECL_RESULT (d) == NULL_TREE)\n \t\t\t{\n \t\t\t  something_changed = 1;\n-\t\t\t  restore_line_number_status (1);\n \t\t\t  java_complete_expand_method (d);\n-\t\t\t  restore_line_number_status (0);\n \t\t\t}\n \t\t    }\n \t\t}"}, {"sha": "2c08256478a1cf07b6d537e95b74e249000d8eec", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -136,8 +136,7 @@ const char * const reg_note_name[] =\n   \"REG_VALUE_PROFILE\", \"REG_NOALIAS\", \"REG_SAVE_AREA\", \"REG_BR_PRED\",\n   \"REG_FRAME_RELATED_EXPR\", \"REG_EH_CONTEXT\", \"REG_EH_REGION\",\n   \"REG_SAVE_NOTE\", \"REG_MAYBE_DEAD\", \"REG_NORETURN\",\n-  \"REG_NON_LOCAL_GOTO\", \"REG_CROSSING_JUMP\", \"REG_SETJMP\", \"REG_ALWAYS_RETURN\",\n-  \"REG_VTABLE_REF\"\n+  \"REG_NON_LOCAL_GOTO\", \"REG_CROSSING_JUMP\", \"REG_SETJMP\", \"REG_ALWAYS_RETURN\"\n };\n \n "}, {"sha": "a03684513953b470cf88e3c58a7dfdbc1e8bcffa", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -865,11 +865,7 @@ enum reg_note\n   REG_SETJMP,\n \n   /* Indicate calls that always returns.  */\n-  REG_ALWAYS_RETURN,\n-\n-  /* Indicate that the memory load references a vtable.  The expression\n-     is of the form (plus (symbol_ref vtable_sym) (const_int offset)).  */\n-  REG_VTABLE_REF\n+  REG_ALWAYS_RETURN\n };\n \n /* The base value for branch probability notes.  */\n@@ -2200,11 +2196,6 @@ extern void remove_insn (rtx);\n extern void emit_insn_after_with_line_notes (rtx, rtx, rtx);\n extern enum rtx_code classify_insn (rtx);\n extern rtx emit (rtx);\n-/* Query and clear/ restore no_line_numbers.  This is used by the\n-   switch / case handling in stmt.c to give proper line numbers in\n-   warnings about unreachable code.  */\n-int force_line_numbers (void);\n-void restore_line_number_status (int old_value);\n extern void renumber_insns (FILE *);\n extern void remove_unnecessary_notes (void);\n extern rtx delete_insn (rtx);"}, {"sha": "6f7382d3df8c8a10f674661c16772d396aff2072", "filename": "gcc/stmt.c", "status": "modified", "additions": 13, "deletions": 287, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -174,16 +174,6 @@ struct nesting GTY(())\n \t     reverts to the saved target_temp_slot_level at the very\n \t     end of the block.  */\n \t  int block_target_temp_slot_level;\n-\t  /* True if we are currently emitting insns in an area of\n-\t     output code that is controlled by a conditional\n-\t     expression.  This is used by the cleanup handling code to\n-\t     generate conditional cleanup actions.  */\n-\t  int conditional_code;\n-\t  /* A place to move the start of the exception region for any\n-\t     of the conditional cleanups, must be at the end or after\n-\t     the start of the last unconditional cleanup, and before any\n-\t     conditional branch points.  */\n-\t  rtx last_unconditional_cleanup;\n \t} GTY ((tag (\"BLOCK_NESTING\"))) block;\n       /* For switch (C) or case (Pascal) statements.  */\n       struct nesting_case\n@@ -199,14 +189,6 @@ struct nesting GTY(())\n \t  tree default_label;\n \t  /* The expression to be dispatched on.  */\n \t  tree index_expr;\n-\t  /* Type that INDEX_EXPR should be converted to.  */\n-\t  tree nominal_type;\n-\t  /* Name of this kind of statement, for warnings.  */\n-\t  const char *printname;\n-\t  /* Used to save no_line_numbers till we see the first case label.\n-\t     We set this to -1 when we see the first case label in this\n-\t     case statement.  */\n-\t  int line_number_status;\n \t} GTY ((tag (\"CASE_NESTING\"))) case_stmt;\n     } GTY ((desc (\"%1.desc\"))) data;\n };\n@@ -234,32 +216,6 @@ do { struct nesting *target = STACK;\t\t\t\\\n \t  nesting_stack = this->all; }\t\t\t\\\n      while (this != target); } while (0)\n \f\n-/* In some cases it is impossible to generate code for a forward goto\n-   until the label definition is seen.  This happens when it may be necessary\n-   for the goto to reset the stack pointer: we don't yet know how to do that.\n-   So expand_goto puts an entry on this fixup list.\n-   Each time a binding contour that resets the stack is exited,\n-   we check each fixup.\n-   If the target label has now been defined, we can insert the proper code.  */\n-\n-struct goto_fixup GTY(())\n-{\n-  /* Points to following fixup.  */\n-  struct goto_fixup *next;\n-  /* Points to the insn before the jump insn.\n-     If more code must be inserted, it goes after this insn.  */\n-  rtx before_jump;\n-  /* The LABEL_DECL that this jump is jumping to, or 0\n-     for break, continue or return.  */\n-  tree target;\n-  /* The BLOCK for the place where this goto was found.  */\n-  tree context;\n-  /* The CODE_LABEL rtx that this is jumping to.  */\n-  rtx target_rtl;\n-  /* Number of binding contours started in current function\n-     before the label reference.  */\n-  int block_start_count;\n-};\n \n struct stmt_status GTY(())\n {\n@@ -287,8 +243,6 @@ struct stmt_status GTY(())\n   /* Location of last line-number note, whether we actually\n      emitted it or not.  */\n   location_t x_emit_locus;\n-\n-  struct goto_fixup *x_goto_fixup_chain;\n };\n \n #define block_stack (cfun->stmt->x_block_stack)\n@@ -298,10 +252,6 @@ struct stmt_status GTY(())\n #define nesting_depth (cfun->stmt->x_nesting_depth)\n #define current_block_start_count (cfun->stmt->x_block_start_count)\n #define emit_locus (cfun->stmt->x_emit_locus)\n-#define goto_fixup_chain (cfun->stmt->x_goto_fixup_chain)\n-\n-/* Nonzero if we are using EH to handle cleanups.  */\n-int using_eh_for_cleanups_p = 0;\n \n static int n_occurrences (int, const char *);\n static bool decl_conflicts_with_clobbers_p (tree, const HARD_REG_SET);\n@@ -316,25 +266,16 @@ static void expand_value_return (rtx);\n static void do_jump_if_equal (rtx, rtx, rtx, int);\n static int estimate_case_costs (case_node_ptr);\n static bool same_case_target_p (rtx, rtx);\n-static void strip_default_case_nodes (case_node_ptr *, rtx);\n static bool lshift_cheap_p (void);\n static int case_bit_test_cmp (const void *, const void *);\n static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, rtx);\n-static void group_case_nodes (case_node_ptr);\n static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n-static void emit_jump_if_reachable (rtx);\n static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n static struct case_node *case_tree2list (case_node *, case_node *);\n \f\n-void\n-using_eh_for_cleanups (void)\n-{\n-  using_eh_for_cleanups_p = 1;\n-}\n-\n void\n init_stmt_for_function (void)\n {\n@@ -2207,8 +2148,6 @@ expand_start_bindings_and_block (int flags, tree block)\n   thisblock->depth = ++nesting_depth;\n   thisblock->data.block.block_target_temp_slot_level = target_temp_slot_level;\n \n-  thisblock->data.block.conditional_code = 0;\n-  thisblock->data.block.last_unconditional_cleanup = note;\n   /* When we insert instructions after the last unconditional cleanup,\n      we don't adjust last_insn.  That means that a later add_insn will\n      clobber the instructions we've just added.  The easiest way to\n@@ -2760,8 +2699,7 @@ expand_anon_union_decl (tree decl, tree cleanup ATTRIBUTE_UNUSED,\n    but instead we take short cuts.  */\n \n void\n-expand_start_case (int exit_flag, tree expr, tree type,\n-\t\t   const char *printname)\n+expand_start_case (tree index_expr)\n {\n   struct nesting *thiscase = ALLOC_NESTING ();\n \n@@ -2771,13 +2709,10 @@ expand_start_case (int exit_flag, tree expr, tree type,\n   thiscase->next = case_stack;\n   thiscase->all = nesting_stack;\n   thiscase->depth = ++nesting_depth;\n-  thiscase->exit_label = exit_flag ? gen_label_rtx () : 0;\n+  thiscase->exit_label = 0;\n   thiscase->data.case_stmt.case_list = 0;\n-  thiscase->data.case_stmt.index_expr = expr;\n-  thiscase->data.case_stmt.nominal_type = type;\n+  thiscase->data.case_stmt.index_expr = index_expr;\n   thiscase->data.case_stmt.default_label = 0;\n-  thiscase->data.case_stmt.printname = printname;\n-  thiscase->data.case_stmt.line_number_status = force_line_numbers ();\n   case_stack = thiscase;\n   nesting_stack = thiscase;\n \n@@ -2791,119 +2726,12 @@ expand_start_case (int exit_flag, tree expr, tree type,\n   thiscase->data.case_stmt.start = get_last_insn ();\n }\n \n-/* Accumulate one case or default label inside a case or switch statement.\n-   VALUE is the value of the case (a null pointer, for a default label).\n-   The function CONVERTER, when applied to arguments T and V,\n-   converts the value V to the type T.\n-\n-   If not currently inside a case or switch statement, return 1 and do\n-   nothing.  The caller will print a language-specific error message.\n-   If VALUE is a duplicate or overlaps, return 2 and do nothing\n-   except store the (first) duplicate node in *DUPLICATE.\n-   If VALUE is out of range, return 3 and do nothing.\n-   Return 0 on success.\n-\n-   Extended to handle range statements.  */\n-\n-int\n-pushcase (tree value, tree (*converter) (tree, tree), tree label,\n-\t  tree *duplicate)\n-{\n-  tree index_type;\n-  tree nominal_type;\n-\n-  /* Fail if not inside a real case statement.  */\n-  if (! (case_stack && case_stack->data.case_stmt.start))\n-    return 1;\n-\n-  index_type = TREE_TYPE (case_stack->data.case_stmt.index_expr);\n-  nominal_type = case_stack->data.case_stmt.nominal_type;\n-\n-  /* If the index is erroneous, avoid more problems: pretend to succeed.  */\n-  if (index_type == error_mark_node)\n-    return 0;\n-\n-  /* Convert VALUE to the type in which the comparisons are nominally done.  */\n-  if (value != 0)\n-    value = (*converter) (nominal_type, value);\n-\n-  /* Fail if this value is out of range for the actual type of the index\n-     (which may be narrower than NOMINAL_TYPE).  */\n-  if (value != 0\n-      && (TREE_CONSTANT_OVERFLOW (value)\n-\t  || ! int_fits_type_p (value, index_type)))\n-    return 3;\n-\n-  return add_case_node (value, value, label, duplicate, false);\n-}\n-\n-/* Like pushcase but this case applies to all values between VALUE1 and\n-   VALUE2 (inclusive).  If VALUE1 is NULL, the range starts at the lowest\n-   value of the index type and ends at VALUE2.  If VALUE2 is NULL, the range\n-   starts at VALUE1 and ends at the highest value of the index type.\n-   If both are NULL, this case applies to all values.\n-\n-   The return value is the same as that of pushcase but there is one\n-   additional error code: 4 means the specified range was empty.  */\n-\n-int\n-pushcase_range (tree value1, tree value2, tree (*converter) (tree, tree),\n-\t\ttree label, tree *duplicate)\n-{\n-  tree index_type;\n-  tree nominal_type;\n-\n-  /* Fail if not inside a real case statement.  */\n-  if (! (case_stack && case_stack->data.case_stmt.start))\n-    return 1;\n-\n-  index_type = TREE_TYPE (case_stack->data.case_stmt.index_expr);\n-  nominal_type = case_stack->data.case_stmt.nominal_type;\n-\n-  /* If the index is erroneous, avoid more problems: pretend to succeed.  */\n-  if (index_type == error_mark_node)\n-    return 0;\n-\n-  /* Convert VALUEs to type in which the comparisons are nominally done\n-     and replace any unspecified value with the corresponding bound.  */\n-  if (value1 == 0)\n-    value1 = TYPE_MIN_VALUE (index_type);\n-  if (value2 == 0)\n-    value2 = TYPE_MAX_VALUE (index_type);\n-\n-  /* Fail if the range is empty.  Do this before any conversion since\n-     we want to allow out-of-range empty ranges.  */\n-  if (value2 != 0 && tree_int_cst_lt (value2, value1))\n-    return 4;\n-\n-  /* If the max was unbounded, use the max of the nominal_type we are\n-     converting to.  Do this after the < check above to suppress false\n-     positives.  */\n-  if (value2 == 0)\n-    value2 = TYPE_MAX_VALUE (nominal_type);\n-\n-  value1 = (*converter) (nominal_type, value1);\n-  value2 = (*converter) (nominal_type, value2);\n-\n-  /* Fail if these values are out of range.  */\n-  if (TREE_CONSTANT_OVERFLOW (value1)\n-      || ! int_fits_type_p (value1, index_type))\n-    return 3;\n-\n-  if (TREE_CONSTANT_OVERFLOW (value2)\n-      || ! int_fits_type_p (value2, index_type))\n-    return 3;\n-\n-  return add_case_node (value1, value2, label, duplicate, false);\n-}\n-\n-/* Do the actual insertion of a case label for pushcase and pushcase_range\n-   into case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid\n+/* Do the insertion of a case label into\n+   case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid\n    slowdown for large switch statements.  */\n \n int\n-add_case_node (tree low, tree high, tree label, tree *duplicate,\n-\t       bool dont_expand_label)\n+add_case_node (tree low, tree high, tree label, tree *duplicate)\n {\n   struct case_node *p, **q, *r;\n \n@@ -2922,8 +2750,6 @@ add_case_node (tree low, tree high, tree label, tree *duplicate,\n \t  return 2;\n \t}\n       case_stack->data.case_stmt.default_label = label;\n-      if (!dont_expand_label)\n-        expand_label (label);\n       return 0;\n     }\n \n@@ -2962,8 +2788,6 @@ add_case_node (tree low, tree high, tree label, tree *duplicate,\n     r->high = high;\n \n   r->code_label = label;\n-  if (!dont_expand_label)\n-    expand_label (label);\n \n   *q = r;\n   r->parent = p;\n@@ -3355,11 +3179,6 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \tthiscase->data.case_stmt.case_list\n \t  = case_tree2list (thiscase->data.case_stmt.case_list, 0);\n \n-      /* Simplify the case-list before we count it.  */\n-      group_case_nodes (thiscase->data.case_stmt.case_list);\n-      strip_default_case_nodes (&thiscase->data.case_stmt.case_list,\n-\t\t\t\tdefault_label);\n-\n       /* Get upper and lower bounds of case values.\n \t Also convert all the case values to the index expr's data type.  */\n \n@@ -3534,7 +3353,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t      balance_case_nodes (&thiscase->data.case_stmt.case_list, NULL);\n \t      emit_case_nodes (index, thiscase->data.case_stmt.case_list,\n \t\t\t       default_label, index_type);\n-\t      emit_jump_if_reachable (default_label);\n+\t      emit_jump (default_label);\n \t    }\n \t}\n       else\n@@ -3543,7 +3362,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t  if (! try_casesi (index_type, index_expr, minval, range,\n \t\t\t    table_label, default_label))\n \t    {\n-\t      index_type = thiscase->data.case_stmt.nominal_type;\n+\t      index_type = integer_type_node;\n \n \t      /* Index jumptables from zero for suitable values of\n                  minval to avoid a subtraction.  */\n@@ -3745,100 +3564,16 @@ estimate_case_costs (case_node_ptr node)\n   return 1;\n }\n \n-/* Determine whether two case labels branch to the same target.  */\n+/* Determine whether two case labels branch to the same target.\n+   Since we now do tree optimizations, just comparing labels is\n+   good enough.  */\n \n static bool\n same_case_target_p (rtx l1, rtx l2)\n {\n-#if 0\n-  rtx i1, i2;\n-\n-  if (l1 == l2)\n-    return true;\n-\n-  i1 = next_real_insn (l1);\n-  i2 = next_real_insn (l2);\n-  if (i1 == i2)\n-    return true;\n-\n-  if (i1 && simplejump_p (i1))\n-    {\n-      l1 = XEXP (SET_SRC (PATTERN (i1)), 0);\n-    }\n-\n-  if (i2 && simplejump_p (i2))\n-    {\n-      l2 = XEXP (SET_SRC (PATTERN (i2)), 0);\n-    }\n-#endif\n-  /* When coming from gimple, we usually won't have emitted either\n-     the labels or the body of the switch statement.  The job being\n-     done here should be done via jump threading at the tree level.\n-     Cases that go the same place should have the same label.  */\n   return l1 == l2;\n }\n \n-/* Delete nodes that branch to the default label from a list of\n-   case nodes.  Eg. case 5: default: becomes just default:  */\n-\n-static void\n-strip_default_case_nodes (case_node_ptr *prev, rtx deflab)\n-{\n-  case_node_ptr ptr;\n-\n-  while (*prev)\n-    {\n-      ptr = *prev;\n-      if (same_case_target_p (label_rtx (ptr->code_label), deflab))\n-\t*prev = ptr->right;\n-      else\n-\tprev = &ptr->right;\n-    }\n-}\n-\n-/* Scan an ordered list of case nodes\n-   combining those with consecutive values or ranges.\n-\n-   Eg. three separate entries 1: 2: 3: become one entry 1..3:  */\n-\n-static void\n-group_case_nodes (case_node_ptr head)\n-{\n-  case_node_ptr node = head;\n-\n-  while (node)\n-    {\n-      rtx lab;\n-      case_node_ptr np = node;\n-\n-      lab = label_rtx (node->code_label);\n-\n-      /* Try to group the successors of NODE with NODE.  */\n-      while (((np = np->right) != 0)\n-\t     /* Do they jump to the same place?  */\n-\t     && same_case_target_p (label_rtx (np->code_label), lab)\n-\t     /* Are their ranges consecutive?  */\n-\t     && tree_int_cst_equal (np->low,\n-\t\t\t\t    fold (build (PLUS_EXPR,\n-\t\t\t\t\t\t TREE_TYPE (node->high),\n-\t\t\t\t\t\t node->high,\n-\t\t\t\t\t\t integer_one_node)))\n-\t     /* An overflow is not consecutive.  */\n-\t     && tree_int_cst_lt (node->high,\n-\t\t\t\t fold (build (PLUS_EXPR,\n-\t\t\t\t\t      TREE_TYPE (node->high),\n-\t\t\t\t\t      node->high,\n-\t\t\t\t\t      integer_one_node))))\n-\t{\n-\t  node->high = np->high;\n-\t}\n-      /* NP is the first node after NODE which can't be grouped with it.\n-\t Delete the nodes in between, and move on to that node.  */\n-      node->right = np;\n-      node = np;\n-    }\n-}\n-\n /* Take an ordered list of case nodes\n    and transform them into a near optimal binary tree,\n    on the assumption that any target code selection value is as\n@@ -4061,15 +3796,6 @@ node_is_bounded (case_node_ptr node, tree index_type)\n   return (node_has_low_bound (node, index_type)\n \t  && node_has_high_bound (node, index_type));\n }\n-\n-/*  Emit an unconditional jump to LABEL unless it would be dead code.  */\n-\n-static void\n-emit_jump_if_reachable (rtx label)\n-{\n-  if (!BARRIER_P (get_last_insn ()))\n-    emit_jump (label);\n-}\n \f\n /* Emit step-by-step code to select a case for the value of INDEX.\n    The thus generated decision tree follows the form of the\n@@ -4215,7 +3941,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      emit_case_nodes (index, node->left, default_label, index_type);\n \t      /* If left-hand subtree does nothing,\n \t\t go to default.  */\n-\t      emit_jump_if_reachable (default_label);\n+\t      emit_jump (default_label);\n \n \t      /* Code branches here for the right-hand subtree.  */\n \t      expand_label (test_label);\n@@ -4356,7 +4082,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t    {\n \t      /* If the left-hand subtree fell through,\n \t\t don't let it fall into the right-hand subtree.  */\n-\t      emit_jump_if_reachable (default_label);\n+\t      emit_jump (default_label);\n \n \t      expand_label (test_label);\n \t      emit_case_nodes (index, node->right, default_label, index_type);"}, {"sha": "f0c18cb2e45f3fe33ae5c73fa5eb2acdeed841e7", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -1926,8 +1926,7 @@ backend_init (void)\n \t\t    /* Enable line number info for traceback.  */\n \t\t    || debug_info_level > DINFO_LEVEL_NONE\n #endif\n-\t\t    || flag_test_coverage\n-\t\t    || warn_notreached);\n+\t\t    || flag_test_coverage);\n \n   init_regs ();\n   init_fake_stack_mems ();"}, {"sha": "ac2d5da3c8d85cf7a92295d3662728e0a66bcaae", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -99,8 +99,6 @@ static void tree_cfg2vcg (FILE *);\n static void tree_merge_blocks (basic_block, basic_block);\n static bool tree_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n-static void group_case_labels (void);\n-static void cleanup_dead_labels (void);\n static bool cleanup_control_flow (void);\n static bool cleanup_control_expr_graph (basic_block, block_stmt_iterator);\n static edge find_taken_edge_cond_expr (basic_block, tree);\n@@ -769,7 +767,16 @@ update_eh_label (struct eh_region *region)\n   tree old_label = get_eh_region_tree_label (region);\n   if (old_label)\n     {\n-      tree new_label = label_for_bb[label_to_block (old_label)->index];\n+      tree new_label;\n+      basic_block bb = label_to_block (old_label);\n+\n+      /* ??? After optimizing, there may be EH regions with labels\n+\t that have already been removed from the function body, so\n+\t there is no basic block for them.  */\n+      if (! bb)\n+\treturn;\n+\n+      new_label = label_for_bb[bb->index];\n       set_eh_region_tree_label (region, new_label);\n     }\n }\n@@ -791,7 +798,7 @@ main_block_label (tree label)\n      2) Redirect all references to labels to the leading labels.\n      3) Cleanup all useless labels.  */\n \n-static void\n+void\n cleanup_dead_labels (void)\n {\n   basic_block bb;\n@@ -924,7 +931,7 @@ cleanup_dead_labels (void)\n    same label.\n    Eg. three separate entries 1: 2: 3: become one entry 1..3:  */\n \n-static void\n+void\n group_case_labels (void)\n {\n   basic_block bb;"}, {"sha": "42834e46c17b1566105a11434501a93d1e8b51a2", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -37,8 +37,15 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include \"ggc.h\"\n \n-/* HACK */\n-extern int using_eh_for_cleanups_p;\n+\f\n+/* Nonzero if we are using EH to handle cleanups.  */\n+static int using_eh_for_cleanups_p = 0;\n+\n+void\n+using_eh_for_cleanups (void)\n+{\n+  using_eh_for_cleanups_p = 1;\n+}\n \f\n /* Misc functions used in this file.  */\n "}, {"sha": "2f3273464ce2fa740c15f00c40777fb03226832c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -473,6 +473,8 @@ extern void dump_cfg_stats (FILE *);\n extern void debug_cfg_stats (void);\n extern void debug_loop_ir (void);\n extern void print_loop_ir (FILE *);\n+extern void cleanup_dead_labels (void);\n+extern void group_case_labels (void);\n extern void cleanup_tree_cfg (void);\n extern tree first_stmt (basic_block);\n extern tree last_stmt (basic_block);"}, {"sha": "bd4bb0d1885ed72593386f405b61bf10edafaa09", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -101,6 +101,35 @@ static struct tree_opt_pass pass_all_optimizations =\n   0\t\t\t\t\t/* todo_flags_finish */\n };\n \n+/* Pass: cleanup the CFG just before expanding trees to RTL.\n+   This is just a round of label cleanups and case node grouping\n+   because after the tree optimizers have run such cleanups may\n+   be necessary.  */\n+\n+static void \n+execute_cleanup_cfg_post_optimizing (void)\n+{\n+  cleanup_tree_cfg ();\n+  cleanup_dead_labels ();\n+  group_case_labels ();\n+}\n+\n+static struct tree_opt_pass pass_cleanup_cfg_post_optimizing =\n+{\n+  NULL,\t\t\t\t\t/* name */\n+  NULL,\t\t\t\t\t/* gate */\n+  execute_cleanup_cfg_post_optimizing,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  0\t\t\t\t\t/* todo_flags_finish */\n+};\n+\n /* Pass: do the actions required to finish with tree-ssa optimization\n    passes.  */\n \n@@ -324,6 +353,7 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_del_ssa);\n   NEXT_PASS (pass_nrv);\n   NEXT_PASS (pass_remove_useless_vars);\n+  NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n   *p = NULL;\n \n   p = &pass_loop.sub;"}, {"sha": "0c308686b61dbc217b799b9f5951441917b815b7", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165b54c3f3249b748d8e7ac186d9ad93dab86d86/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=165b54c3f3249b748d8e7ac186d9ad93dab86d86", "patch": "@@ -3352,12 +3352,12 @@ extern void warn_about_unused_variables (tree);\n extern int is_body_block (tree);\n \n extern struct nesting * current_nesting_level (void);\n-extern void expand_start_case (int, tree, tree, const char *);\n+extern void expand_start_case (tree);\n extern void expand_end_case_type (tree, tree);\n #define expand_end_case(cond) expand_end_case_type (cond, NULL)\n-extern int add_case_node (tree, tree, tree, tree *, bool);\n-extern int pushcase (tree, tree (*) (tree, tree), tree, tree *);\n-extern int pushcase_range (tree, tree, tree (*) (tree, tree), tree, tree *);\n+extern int add_case_node (tree, tree, tree, tree *);\n+\n+/* In tree-eh.c */\n extern void using_eh_for_cleanups (void);\n \n /* In fold-const.c */"}]}