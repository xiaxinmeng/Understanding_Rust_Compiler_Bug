{"sha": "1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU3ZmRjMDJjYmE0M2U2NDZmYjIzODllM2M3OWU3YzRlNWZmNzcyZQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-10-02T16:41:34Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-10-02T16:41:34Z"}, "message": "ipa: Bundle estimates of ipa_call_context::estimate_size_and_time\n\nA subsequent patch adds another two estimates that the code in\nipa_call_context::estimate_size_and_time computes, and the fact that\nthe function has a special output parameter for each thing it computes\nwould make it have just too many.  Therefore, this patch collapses all\nthose ouptut parameters into one output structure.\n\ngcc/ChangeLog:\n\n2020-09-02  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Adjusted to use\n\tipa_call_estimates.\n\t(do_estimate_edge_size): Likewise.\n\t(do_estimate_edge_hints): Likewise.\n\t* ipa-fnsummary.h (struct ipa_call_estimates): New type.\n\t(ipa_call_context::estimate_size_and_time): Adjusted declaration.\n\t(estimate_ipcp_clone_size_and_time): Likewise.\n\t* ipa-cp.c (hint_time_bonus): Changed the type of the second argument\n\tto ipa_call_estimates.\n\t(perform_estimation_of_a_value): Adjusted to use ipa_call_estimates.\n\t(estimate_local_effects): Likewise.\n\t* ipa-fnsummary.c (ipa_call_context::estimate_size_and_time): Adjusted\n\tto return estimates in a single ipa_call_estimates parameter.\n\t(estimate_ipcp_clone_size_and_time): Likewise.", "tree": {"sha": "14d201bd3435c921d401b8e08298cec1bf76ab59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14d201bd3435c921d401b8e08298cec1bf76ab59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d2cb2755a14b95b1d71c3e52895d75954b4ec47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2cb2755a14b95b1d71c3e52895d75954b4ec47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2cb2755a14b95b1d71c3e52895d75954b4ec47"}], "stats": {"total": 188, "additions": 105, "deletions": 83}, "files": [{"sha": "77c84a6ed5dfbd07435e2aba30087a7756a65b2d", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "patch": "@@ -3196,12 +3196,13 @@ devirtualization_time_bonus (struct cgraph_node *node,\n   return res;\n }\n \n-/* Return time bonus incurred because of HINTS.  */\n+/* Return time bonus incurred because of hints stored in ESTIMATES.  */\n \n static int\n-hint_time_bonus (cgraph_node *node, ipa_hints hints)\n+hint_time_bonus (cgraph_node *node, const ipa_call_estimates &estimates)\n {\n   int result = 0;\n+  ipa_hints hints = estimates.hints;\n   if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n     result += opt_for_fn (node->decl, param_ipa_cp_loop_hint_bonus);\n   return result;\n@@ -3397,27 +3398,26 @@ perform_estimation_of_a_value (cgraph_node *node,\n \t\t\t       int removable_params_cost, int est_move_cost,\n \t\t\t       ipcp_value_base *val)\n {\n-  int size, time_benefit;\n-  sreal time, base_time;\n-  ipa_hints hints;\n+  int time_benefit;\n+  ipa_call_estimates estimates;\n \n-  estimate_ipcp_clone_size_and_time (node, avals, &size, &time,\n-\t\t\t\t     &base_time, &hints);\n-  base_time -= time;\n-  if (base_time > 65535)\n-    base_time = 65535;\n+  estimate_ipcp_clone_size_and_time (node, avals, &estimates);\n+  sreal time_delta = estimates.nonspecialized_time - estimates.time;\n+  if (time_delta > 65535)\n+    time_delta = 65535;\n \n   /* Extern inline functions have no cloning local time benefits because they\n      will be inlined anyway.  The only reason to clone them is if it enables\n      optimization in any of the functions they call.  */\n   if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))\n     time_benefit = 0;\n   else\n-    time_benefit = base_time.to_int ()\n+    time_benefit = time_delta.to_int ()\n       + devirtualization_time_bonus (node, avals)\n-      + hint_time_bonus (node, hints)\n+      + hint_time_bonus (node, estimates)\n       + removable_params_cost + est_move_cost;\n \n+  int size = estimates.size;\n   gcc_checking_assert (size >=0);\n   /* The inliner-heuristics based estimates may think that in certain\n      contexts some functions do not have any size at all but we want\n@@ -3472,23 +3472,21 @@ estimate_local_effects (struct cgraph_node *node)\n       || (removable_params_cost && node->can_change_signature))\n     {\n       struct caller_statistics stats;\n-      ipa_hints hints;\n-      sreal time, base_time;\n-      int size;\n+      ipa_call_estimates estimates;\n \n       init_caller_stats (&stats);\n       node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n \t\t\t\t\t      false);\n-      estimate_ipcp_clone_size_and_time (node, &avals, &size, &time,\n-\t\t\t\t\t &base_time, &hints);\n-      time -= devirt_bonus;\n-      time -= hint_time_bonus (node, hints);\n-      time -= removable_params_cost;\n-      size -= stats.n_calls * removable_params_cost;\n+      estimate_ipcp_clone_size_and_time (node, &avals, &estimates);\n+      sreal time = estimates.nonspecialized_time - estimates.time;\n+      time += devirt_bonus;\n+      time += hint_time_bonus (node, estimates);\n+      time += removable_params_cost;\n+      int size = estimates.size - stats.n_calls * removable_params_cost;\n \n       if (dump_file)\n \tfprintf (dump_file, \" - context independent values, size: %i, \"\n-\t\t \"time_benefit: %f\\n\", size, (base_time - time).to_double ());\n+\t\t \"time_benefit: %f\\n\", size, (time).to_double ());\n \n       if (size <= 0 || node->local)\n \t{\n@@ -3499,8 +3497,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t     \"known contexts, code not going to grow.\\n\");\n \t}\n       else if (good_cloning_opportunity_p (node,\n-\t\t\t\t\t   MIN ((base_time - time).to_int (),\n-\t\t\t\t\t\t65536),\n+\t\t\t\t\t   MIN ((time).to_int (), 65536),\n \t\t\t\t\t   stats.freq_sum, stats.count_sum,\n \t\t\t\t\t   size))\n \t{"}, {"sha": "f89f1583b6b225ba30527f54d7c89d124d7453b8", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "patch": "@@ -3536,18 +3536,14 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n   return true;\n }\n \n-/* Estimate size and time needed to execute call in the given context.\n-   Additionally determine hints determined by the context.  Finally compute\n-   minimal size needed for the call that is independent on the call context and\n-   can be used for fast estimates.  Return the values in RET_SIZE,\n-   RET_MIN_SIZE, RET_TIME and RET_HINTS.  */\n+/* Fill in the selected fields in ESTIMATES with value estimated for call in\n+   this context.  Always compute size and min_size.  Only compute time and\n+   nonspecialized_time if EST_TIMES is true.  Only compute hints if EST_HINTS\n+   is true.  */\n \n void\n-ipa_call_context::estimate_size_and_time (int *ret_size,\n-\t\t\t\t\t  int *ret_min_size,\n-\t\t\t\t\t  sreal *ret_time,\n-\t\t\t\t\t  sreal *ret_nonspecialized_time,\n-\t\t\t\t\t  ipa_hints *ret_hints)\n+ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n+\t\t\t\t\t  bool est_times, bool est_hints)\n {\n   class ipa_fn_summary *info = ipa_fn_summaries->get (m_node);\n   size_time_entry *e;\n@@ -3577,8 +3573,8 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n \n   if (m_node->callees || m_node->indirect_calls)\n     estimate_calls_size_and_time (m_node, &size, &min_size,\n-\t\t\t\t  ret_time ? &time : NULL,\n-\t\t\t\t  ret_hints ? &hints : NULL, m_possible_truths,\n+\t\t\t\t  est_times ? &time : NULL,\n+\t\t\t\t  est_hints ? &hints : NULL, m_possible_truths,\n \t\t\t\t  &m_avals);\n \n   sreal nonspecialized_time = time;\n@@ -3605,7 +3601,7 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n \t     known to be constant in a specialized setting.  */\n \t  if (nonconst)\n \t    size += e->size;\n-\t  if (!ret_time)\n+\t  if (!est_times)\n \t    continue;\n \t  nonspecialized_time += e->time;\n \t  if (!nonconst)\n@@ -3645,7 +3641,7 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n   if (time > nonspecialized_time)\n     time = nonspecialized_time;\n \n-  if (ret_hints)\n+  if (est_hints)\n     {\n       if (info->loop_iterations\n \t  && !info->loop_iterations->evaluate (m_possible_truths))\n@@ -3663,18 +3659,23 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n   min_size = RDIV (min_size, ipa_fn_summary::size_scale);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\n   size:%i time:%f nonspec time:%f\\n\", (int) size,\n-\t     time.to_double (), nonspecialized_time.to_double ());\n-  if (ret_time)\n-    *ret_time = time;\n-  if (ret_nonspecialized_time)\n-    *ret_nonspecialized_time = nonspecialized_time;\n-  if (ret_size)\n-    *ret_size = size;\n-  if (ret_min_size)\n-    *ret_min_size = min_size;\n-  if (ret_hints)\n-    *ret_hints = hints;\n+    {\n+      if (est_times)\n+\tfprintf (dump_file, \"\\n   size:%i time:%f nonspec time:%f\\n\",\n+\t\t (int) size, time.to_double (),\n+\t\t nonspecialized_time.to_double ());\n+      else\n+\tfprintf (dump_file, \"\\n   size:%i (time not estimated)\\n\", (int) size);\n+    }\n+  if (est_times)\n+    {\n+      estimates->time = time;\n+      estimates->nonspecialized_time = nonspecialized_time;\n+    }\n+  estimates->size = size;\n+  estimates->min_size = min_size;\n+  if (est_hints)\n+    estimates->hints = hints;\n   return;\n }\n \n@@ -3687,17 +3688,14 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n void\n estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n \t\t\t\t   ipa_auto_call_arg_values *avals,\n-\t\t\t\t   int *ret_size, sreal *ret_time,\n-\t\t\t\t   sreal *ret_nonspec_time,\n-\t\t\t\t   ipa_hints *hints)\n+\t\t\t\t   ipa_call_estimates *estimates)\n {\n   clause_t clause, nonspec_clause;\n \n   evaluate_conditions_for_known_args (node, false, avals, &clause,\n \t\t\t\t      &nonspec_clause);\n   ipa_call_context ctx (node, clause, nonspec_clause, vNULL, avals);\n-  ctx.estimate_size_and_time (ret_size, NULL, ret_time,\n-\t\t\t      ret_nonspec_time, hints);\n+  ctx.estimate_size_and_time (estimates);\n }\n \n /* Return stack frame offset where frame of NODE is supposed to start inside"}, {"sha": "ccb6b432f0b9b53cca05a24eb1560057daa0622d", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "patch": "@@ -287,6 +287,29 @@ class ipa_call_summary_t: public fast_call_summary <ipa_call_summary *, va_heap>\n \t\t\t  ipa_call_summary *dst_data);\n };\n \n+/* Estimated execution times, code sizes and other information about the\n+   code executing a call described by ipa_call_context.  */\n+\n+struct ipa_call_estimates\n+{\n+  /* Estimated size needed to execute call in the given context. */\n+  int size;\n+\n+  /* Minimal size needed for the call that is + independent on the call context\n+     and can be used for fast estimates.  */\n+  int min_size;\n+\n+  /* Estimated time needed to execute call in the given context. */\n+  sreal time;\n+\n+  /* Estimated time needed to execute the function when not ignoring\n+     computations known to be constant in this context.  */\n+  sreal nonspecialized_time;\n+\n+  /* Further discovered reasons why to inline or specialize the give calls.  */\n+  ipa_hints hints;\n+};\n+\n class ipa_cached_call_context;\n \n /* This object describe a context of call.  That is a summary of known\n@@ -305,10 +328,8 @@ class ipa_call_context\n   : m_node(NULL)\n   {\n   }\n-  void estimate_size_and_time (int *ret_size, int *ret_min_size,\n-\t\t\t       sreal *ret_time,\n-\t\t\t       sreal *ret_nonspecialized_time,\n-\t\t\t       ipa_hints *ret_hints);\n+  void estimate_size_and_time (ipa_call_estimates *estimates,\n+\t\t\t       bool est_times = true, bool est_hints = true);\n   bool equal_to (const ipa_call_context &);\n   bool exists_p ()\n   {\n@@ -353,10 +374,9 @@ void ipa_dump_hints (FILE *f, ipa_hints);\n void ipa_free_fn_summary (void);\n void ipa_free_size_summary (void);\n void inline_analyze_function (struct cgraph_node *node);\n-void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n-\t\t\t\t\tipa_auto_call_arg_values *,\n-\t\t\t\t\tint *, sreal *, sreal *,\n-\t\t\t\t        ipa_hints *);\n+void estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n+\t\t\t\t\tipa_auto_call_arg_values *avals,\n+\t\t\t\t\tipa_call_estimates *estimates);\n void ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge);\n void ipa_update_overall_fn_summary (struct cgraph_node *node, bool reset = true);\n void compute_fn_summary (struct cgraph_node *, bool);"}, {"sha": "acbf82e84d9576154a66333b68d28475d43c59f1", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "patch": "@@ -208,16 +208,12 @@ do_estimate_edge_time (struct cgraph_edge *edge, sreal *ret_nonspec_time)\n \t      && !opt_for_fn (callee->decl, flag_profile_partial_training)\n \t      && !callee->count.ipa_p ())\n \t    {\n-\t      sreal chk_time, chk_nonspec_time;\n-\t      int chk_size, chk_min_size;\n-\n-\t      ipa_hints chk_hints;\n-\t      ctx.estimate_size_and_time (&chk_size, &chk_min_size,\n-\t\t\t\t\t  &chk_time, &chk_nonspec_time,\n-\t\t\t\t\t  &chk_hints);\n-\t      gcc_assert (chk_size == size && chk_time == time\n-\t\t  \t  && chk_nonspec_time == nonspec_time\n-\t\t\t  && chk_hints == hints);\n+\t      ipa_call_estimates chk_estimates;\n+\t      ctx.estimate_size_and_time (&chk_estimates);\n+\t      gcc_assert (chk_estimates.size == size\n+\t\t\t  && chk_estimates.time == time\n+\t\t  \t  && chk_estimates.nonspecialized_time == nonspec_time\n+\t\t\t  && chk_estimates.hints == hints);\n \t    }\n \t}\n       else\n@@ -227,18 +223,28 @@ do_estimate_edge_time (struct cgraph_edge *edge, sreal *ret_nonspec_time)\n \t  else\n \t    node_context_cache_clear++;\n \t  e->entry.ctx.release ();\n-\t  ctx.estimate_size_and_time (&size, &min_size,\n-\t\t\t\t      &time, &nonspec_time, &hints);\n+\t  ipa_call_estimates estimates;\n+\t  ctx.estimate_size_and_time (&estimates);\n+\t  size = estimates.size;\n \t  e->entry.size = size;\n+\t  time = estimates.time;\n \t  e->entry.time = time;\n+\t  nonspec_time = estimates.nonspecialized_time;\n \t  e->entry.nonspec_time = nonspec_time;\n+\t  hints = estimates.hints;\n \t  e->entry.hints = hints;\n \t  e->entry.ctx.duplicate_from (ctx);\n \t}\n     }\n   else\n-    ctx.estimate_size_and_time (&size, &min_size,\n-\t\t\t\t&time, &nonspec_time, &hints);\n+    {\n+      ipa_call_estimates estimates;\n+      ctx.estimate_size_and_time (&estimates);\n+      size = estimates.size;\n+      time = estimates.time;\n+      nonspec_time = estimates.nonspecialized_time;\n+      hints = estimates.hints;\n+    }\n \n   /* When we have profile feedback, we can quite safely identify hot\n      edges and for those we disable size limits.  Don't do that when\n@@ -321,8 +327,9 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   evaluate_properties_for_edge (edge, true, &clause, &nonspec_clause,\n \t\t\t\t&avals, true);\n   ipa_call_context ctx (callee, clause, nonspec_clause, vNULL, &avals);\n-  ctx.estimate_size_and_time (&size, NULL, NULL, NULL, NULL);\n-  return size;\n+  ipa_call_estimates estimates;\n+  ctx.estimate_size_and_time (&estimates, false, false);\n+  return estimates.size;\n }\n \n \n@@ -332,7 +339,6 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n ipa_hints\n do_estimate_edge_hints (struct cgraph_edge *edge)\n {\n-  ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n \n@@ -341,7 +347,7 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   if (edge_growth_cache != NULL)\n     {\n       do_estimate_edge_time (edge);\n-      hints = edge_growth_cache->get (edge)->hints;\n+      ipa_hints hints = edge_growth_cache->get (edge)->hints;\n       gcc_checking_assert (hints);\n       return hints - 1;\n     }\n@@ -354,8 +360,9 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   evaluate_properties_for_edge (edge, true, &clause, &nonspec_clause,\n \t\t\t\t&avals, true);\n   ipa_call_context ctx (callee, clause, nonspec_clause, vNULL, &avals);\n-  ctx.estimate_size_and_time (NULL, NULL, NULL, NULL, &hints);\n-  hints |= simple_edge_hints (edge);\n+  ipa_call_estimates estimates;\n+  ctx.estimate_size_and_time (&estimates, false, true);\n+  ipa_hints hints = estimates.hints | simple_edge_hints (edge);\n   return hints;\n }\n "}]}