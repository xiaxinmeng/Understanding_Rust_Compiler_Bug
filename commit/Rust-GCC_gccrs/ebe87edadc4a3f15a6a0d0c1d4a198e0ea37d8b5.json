{"sha": "ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "node_id": "C_kwDOANBUbNoAKGViZTg3ZWRhZGM0YTNmMTVhNmEwZDBjMWQ0YTE5OGUwZWEzN2Q4YjU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-19T20:49:38Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-10-19T20:49:38Z"}, "message": "analyzer: fix ICE on __builtin_ms_va_copy [PR105765]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/105765\n\t* varargs.cc (get_BT_VALIST_ARG): Rename to...\n\t(get_va_copy_arg): ...this, and update logic for determining level\n\tof indirection of va_copy's argument to use type of argument,\n\trather than looking at va_list_type_node, to correctly handle\n\t__builtin_ms_va_copy.\n\t(get_stateful_BT_VALIST_ARG): Rename to...\n\t(get_stateful_va_copy_arg): ...this.\n\t(va_list_state_machine::on_va_copy): Update for renaming.\n\t(region_model::impl_call_va_copy): Likewise.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/105765\n\t* gcc.dg/analyzer/stdarg-1-ms_abi.c: New test, based on stdarg-1.c.\n\t* gcc.dg/analyzer/stdarg-1-sysv_abi.c: Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "eb5ad328db141854e3ffd88567478f797175a19c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb5ad328db141854e3ffd88567478f797175a19c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb4db9bc1c567eaf850e997853d084d0832dd4c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4db9bc1c567eaf850e997853d084d0832dd4c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4db9bc1c567eaf850e997853d084d0832dd4c1"}], "stats": {"total": 913, "additions": 897, "deletions": 16}, "files": [{"sha": "20c83dbbadc8bc78d763f9d6ba12046a82ecc3ef", "filename": "gcc/analyzer/varargs.cc", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/gcc%2Fanalyzer%2Fvarargs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/gcc%2Fanalyzer%2Fvarargs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fvarargs.cc?ref=ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "patch": "@@ -132,7 +132,7 @@ namespace ana {\n      __builtin_va_start (&ap, [...]);\n \n    except for the 2nd param of __builtin_va_copy, where the type\n-   is already target-dependent (see the discussion of BT_VALIST_ARG\n+   is already target-dependent (see the discussion of get_va_copy_arg\n    below).  */\n \n /* Get a tree for diagnostics.\n@@ -147,26 +147,33 @@ get_va_list_diag_arg (tree va_list_tree)\n   return va_list_tree;\n }\n \n-/* Get argument ARG_IDX of type BT_VALIST_ARG (for use by va_copy).\n+/* Get argument ARG_IDX of va_copy.\n \n    builtin-types.def has:\n      DEF_PRIMITIVE_TYPE (BT_VALIST_ARG, va_list_arg_type_node)\n \n    and c_common_nodes_and_builtins initializes va_list_arg_type_node\n    based on whether TREE_CODE (va_list_type_node) is of ARRAY_TYPE or\n-   not, giving either one or zero levels of indirection.  */\n+   not, giving either one or zero levels of indirection.\n+\n+   Alternatively we could be dealing with __builtin_ms_va_copy or\n+   __builtin_sysv_va_copy.\n+\n+   Handle this by looking at the types of the argument in question.  */\n \n static const svalue *\n-get_BT_VALIST_ARG (const region_model *model,\n-\t\t   region_model_context *ctxt,\n-\t\t   const gcall *call,\n-\t\t   unsigned arg_idx)\n+get_va_copy_arg (const region_model *model,\n+\t\t region_model_context *ctxt,\n+\t\t const gcall *call,\n+\t\t unsigned arg_idx)\n {\n   tree arg = gimple_call_arg (call, arg_idx);\n   const svalue *arg_sval = model->get_rvalue (arg, ctxt);\n   if (const svalue *cast = arg_sval->maybe_undo_cast ())\n     arg_sval = cast;\n-  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n+  /* Expect a POINTER_TYPE; does it point to an array type?  */\n+  gcc_assert (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE);\n+  if (TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) == ARRAY_TYPE)\n     {\n       /* va_list_arg_type_node is a pointer to a va_list;\n \t return *ARG_SVAL.  */\n@@ -551,19 +558,19 @@ va_list_state_machine::check_for_ended_va_list (sm_context *sm_ctxt,\n \t\t\t\t\t\t usage_fnname));\n }\n \n-/* Get the svalue with associated va_list_state_machine state for a\n-   BT_VALIST_ARG for ARG_IDX of CALL, if SM_CTXT supports this,\n+/* Get the svalue with associated va_list_state_machine state for\n+   ARG_IDX of CALL to va_copy, if SM_CTXT supports this,\n    or NULL otherwise.  */\n \n static const svalue *\n-get_stateful_BT_VALIST_ARG (sm_context *sm_ctxt,\n-\t\t\t    const gcall *call,\n-\t\t\t    unsigned arg_idx)\n+get_stateful_va_copy_arg (sm_context *sm_ctxt,\n+\t\t\t  const gcall *call,\n+\t\t\t  unsigned arg_idx)\n {\n   if (const program_state *new_state = sm_ctxt->get_new_program_state ())\n     {\n       const region_model *new_model = new_state->m_region_model;\n-      const svalue *arg = get_BT_VALIST_ARG (new_model, NULL, call, arg_idx);\n+      const svalue *arg = get_va_copy_arg (new_model, NULL, call, arg_idx);\n       return arg;\n     }\n   return NULL;\n@@ -576,7 +583,7 @@ va_list_state_machine::on_va_copy (sm_context *sm_ctxt,\n \t\t\t\t   const supernode *node,\n \t\t\t\t   const gcall *call) const\n {\n-  const svalue *src_arg = get_stateful_BT_VALIST_ARG (sm_ctxt, call, 1);\n+  const svalue *src_arg = get_stateful_va_copy_arg (sm_ctxt, call, 1);\n   if (src_arg)\n     check_for_ended_va_list (sm_ctxt, node, call, src_arg, \"va_copy\");\n \n@@ -686,7 +693,7 @@ region_model::impl_call_va_copy (const call_details &cd)\n {\n   const svalue *out_dst_ptr = cd.get_arg_svalue (0);\n   const svalue *in_va_list\n-    = get_BT_VALIST_ARG (this, cd.get_ctxt (), cd.get_call_stmt (), 1);\n+    = get_va_copy_arg (this, cd.get_ctxt (), cd.get_call_stmt (), 1);\n   in_va_list = check_for_poison (in_va_list,\n \t\t\t\t get_va_list_diag_arg (cd.get_arg_tree (1)),\n \t\t\t\t cd.get_ctxt ());"}, {"sha": "b0143a7d3e3edcdba528d79e9f6aece456bf4d03", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-1-ms_abi.c", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1-ms_abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1-ms_abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1-ms_abi.c?ref=ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "patch": "@@ -0,0 +1,437 @@\n+/* As per stdarg-1.c, but using the ms_abi versions of the builtins.  */\n+\n+/* { dg-do compile { target { x86_64-*-* && lp64 } } } */\n+\n+#include \"analyzer-decls.h\"\n+\n+/* Unpacking a va_list.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_1 (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)__builtin_va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_1 (void)\n+{\n+  __analyzer_called_by_test_1 (42, \"foo\", 1066, '@');\n+}\n+\n+/* Unpacking a va_list passed from an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_inner (__builtin_ms_va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+  \n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)__builtin_va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_middle (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+  __analyzer_test_2_inner (ap);\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_2 (void)\n+{\n+  __analyzer_test_2_middle (42, \"foo\", 1066, '@');\n+}\n+\n+/* Not enough args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_not_enough_args (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  \n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\) \\\\\\[CWE-685\\\\\\]\" } */\n+\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_not_enough_args (void)\n+{\n+  __analyzer_called_by_test_not_enough_args (42, \"foo\");\n+}\n+\n+/* Not enough args, with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_inner (__builtin_ms_va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  \n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_middle (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+  __analyzer_test_not_enough_args_2_inner (ap);\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_not_enough_args_2 (void)\n+{\n+  __analyzer_test_not_enough_args_2_middle (42, \"foo\");\n+}\n+\n+/* Excess args (not a problem).  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_excess_args (int placeholder, ...)\n+{\n+  const char *s;\n+  \n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_excess_args (void)\n+{\n+  __analyzer_called_by_test_excess_args (42, \"foo\", \"bar\");\n+}\n+\n+/* Missing va_start.  */\n+\n+void test_missing_va_start (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap; /* { dg-message \"region created on stack here\" } */\n+  int i = __builtin_va_arg (ap, int); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+}\n+\n+/* Missing va_end.  */\n+\n+void test_missing_va_end (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = __builtin_va_arg (ap, int);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+/* { dg-message \"\\\\(2\\\\) missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* Missing va_end due to error-handling.  */\n+\n+int test_missing_va_end_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = __builtin_va_arg (ap, int);\n+  if (i == 42)\n+    {\n+      __builtin_ms_va_end (ap);\n+      return -1;\n+    }\n+  j = __builtin_va_arg (ap, int);\n+  if (j == 1066) /* { dg-message \"branch\" } */\n+    return -1; /* { dg-message \"here\" } */\n+  __builtin_ms_va_end (ap);\n+  return 0;\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+\n+/* va_arg after va_end.  */\n+\n+void test_va_arg_after_va_end (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+  __builtin_ms_va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' after 'va_end'\" } */\n+}\n+\n+/* Type mismatch: expect int, but passed a char *.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_1 (int placeholder, ...)\n+{\n+  int i;\n+  \n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' expected 'int' but received '\\[^\\n\\r\\]*' for variadic argument 1 of 'ap' \\\\\\[CWE-686\\\\\\]\" } */\n+\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_type_mismatch_1 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_1 (42, \"foo\");\n+}\n+\n+/* Type mismatch: expect char *, but passed an int.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_2 (int placeholder, ...)\n+{\n+  const char *str;\n+  \n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+\n+  str = __builtin_va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1\" } */\n+\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_type_mismatch_2 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_2 (42, 1066);\n+}\n+\n+/* As above, but with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_inner (__builtin_ms_va_list ap)\n+{\n+  const char *str;\n+  \n+  str = __builtin_va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_middle (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+\n+  __analyzer_test_type_mismatch_3_inner (ap);\n+\n+  __builtin_ms_va_end (ap);\n+}\n+\n+void test_type_mismatch_3 (void)\n+{\n+  __analyzer_test_type_mismatch_3_middle (42, 1066);\n+}\n+\n+/* Multiple traversals of the args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap;\n+\n+  /* First traversal.  */\n+  {\n+    int i, j;\n+\n+    __builtin_ms_va_start (ap, placeholder);\n+\n+    i = __builtin_va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = __builtin_va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    __builtin_ms_va_end (ap);\n+  }\n+\n+  /* Second traversal.  */\n+  {\n+    int i, j;\n+\n+    __builtin_ms_va_start (ap, placeholder);\n+\n+    i = __builtin_va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = __builtin_va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    __builtin_ms_va_end (ap);\n+  }\n+}\n+\n+void test_multiple_traversals (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_ms_va_list args1;\n+  __builtin_ms_va_list args2;\n+\n+  __builtin_ms_va_start (args1, placeholder);\n+  __builtin_ms_va_copy (args2, args1);\n+\n+  /* First traversal.  */\n+  i = __builtin_va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = __builtin_va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_ms_va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  i = __builtin_va_arg (args2, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = __builtin_va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_ms_va_end (args2);\n+}\n+\n+void test_multiple_traversals_2 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_2 (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy after a va_arg.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_3 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_ms_va_list args1;\n+  __builtin_ms_va_list args2;\n+\n+  __builtin_ms_va_start (args1, placeholder);\n+\n+  /* First traversal.  */\n+  i = __builtin_va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  /* va_copy after the first va_arg. */\n+  __builtin_ms_va_copy (args2, args1);\n+\n+  j = __builtin_va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_ms_va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  j = __builtin_va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_ms_va_end (args2);\n+}\n+\n+void test_multiple_traversals_3 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_3 (0, 1066, 42);\n+}\n+\n+/* va_copy after va_end.  */\n+\n+void test_va_copy_after_va_end (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap1, ap2;\n+  __builtin_ms_va_start (ap1, placeholder);\n+  __builtin_ms_va_end (ap1); /* { dg-message \"'va_end' called here\" } */\n+  __builtin_ms_va_copy (ap2, ap1); /* { dg-warning \"'va_copy' after 'va_end'\" } */\n+  __builtin_ms_va_end (ap2);\n+}\n+\n+/* leak of va_copy.  */\n+\n+void test_leak_of_va_copy (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap1, ap2;\n+  __builtin_ms_va_start (ap1, placeholder);\n+  __builtin_ms_va_copy (ap2, ap1); /* { dg-message \"'va_copy' called here\" } */\n+  __builtin_ms_va_end (ap1);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_copy' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* double va_end.  */\n+\n+void test_double_va_end (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder);\n+  __builtin_ms_va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  __builtin_ms_va_end (ap); /* { dg-warning \"'va_end' after 'va_end'\" } */\n+}\n+\n+/* double va_start.  */\n+\n+void test_double_va_start (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_ms_va_list ap;\n+  __builtin_ms_va_start (ap, placeholder); /* { dg-message \"'va_start' called here\" } */\n+  __builtin_ms_va_start (ap, placeholder);  /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+  __builtin_ms_va_end (ap);\n+}\n+\n+/* va_copy before va_start.  */\n+\n+void test_va_copy_before_va_start (int placeholder, ...)\n+{\n+  __builtin_ms_va_list ap1; /* { dg-message \"region created on stack here\" } */\n+  __builtin_ms_va_list ap2;\n+  __builtin_ms_va_copy (ap2, ap1); /* { dg-warning \"use of uninitialized value 'ap1'\" } */\n+  __builtin_ms_va_end (ap2);\n+}\n+\n+/* Verify that we complain about uses of a va_list after the function \n+   in which va_start was called has returned.  */\n+\n+__builtin_ms_va_list global_ap;\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_va_arg_after_return (int placeholder, ...)\n+{\n+  __builtin_ms_va_start (global_ap, placeholder);\n+  __builtin_ms_va_end (global_ap);\n+}\n+\n+void test_va_arg_after_return (void)\n+{\n+  int i;\n+  __analyzer_called_by_test_va_arg_after_return (42, 1066);\n+  i = __builtin_va_arg (global_ap, int); /* { dg-warning \"dereferencing pointer 'global_ap' to within stale stack frame\" } */\n+}"}, {"sha": "1dc97ea3a44e1055fb69e02473c0aa2f69ebd613", "filename": "gcc/testsuite/gcc.dg/analyzer/stdarg-1-sysv_abi.c", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1-sysv_abi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1-sysv_abi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstdarg-1-sysv_abi.c?ref=ebe87edadc4a3f15a6a0d0c1d4a198e0ea37d8b5", "patch": "@@ -0,0 +1,437 @@\n+/* As per stdarg-1.c, but using the sysv_abi versions of the builtins.  */\n+\n+/* { dg-do compile { target { x86_64-*-* && lp64 } } } */\n+\n+#include \"analyzer-decls.h\"\n+\n+/* Unpacking a va_list.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_1 (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)__builtin_va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_1 (void)\n+{\n+  __analyzer_called_by_test_1 (42, \"foo\", 1066, '@');\n+}\n+\n+/* Unpacking a va_list passed from an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_inner (__builtin_sysv_va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  char c;\n+  \n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  c = (char)__builtin_va_arg (ap, int);\n+  __analyzer_eval (c == '@'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_2_middle (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+  __analyzer_test_2_inner (ap);\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_2 (void)\n+{\n+  __analyzer_test_2_middle (42, \"foo\", 1066, '@');\n+}\n+\n+/* Not enough args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_not_enough_args (int placeholder, ...)\n+{\n+  const char *s;\n+  int i;\n+  \n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\) \\\\\\[CWE-685\\\\\\]\" } */\n+\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_not_enough_args (void)\n+{\n+  __analyzer_called_by_test_not_enough_args (42, \"foo\");\n+}\n+\n+/* Not enough args, with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_inner (__builtin_sysv_va_list ap)\n+{\n+  const char *s;\n+  int i;\n+  \n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'ap' has no more arguments \\\\(1 consumed\\\\)\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_not_enough_args_2_middle (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+  __analyzer_test_not_enough_args_2_inner (ap);\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_not_enough_args_2 (void)\n+{\n+  __analyzer_test_not_enough_args_2_middle (42, \"foo\");\n+}\n+\n+/* Excess args (not a problem).  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_excess_args (int placeholder, ...)\n+{\n+  const char *s;\n+  \n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+\n+  s = __builtin_va_arg (ap, char *);\n+  __analyzer_eval (s[0] == 'f'); /* { dg-warning \"TRUE\" } */\n+\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_excess_args (void)\n+{\n+  __analyzer_called_by_test_excess_args (42, \"foo\", \"bar\");\n+}\n+\n+/* Missing va_start.  */\n+\n+void test_missing_va_start (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap; /* { dg-message \"region created on stack here\" } */\n+  int i = __builtin_va_arg (ap, int); /* { dg-warning \"use of uninitialized value 'ap'\" } */\n+}\n+\n+/* Missing va_end.  */\n+\n+void test_missing_va_end (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = __builtin_va_arg (ap, int);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+/* { dg-message \"\\\\(2\\\\) missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* Missing va_end due to error-handling.  */\n+\n+int test_missing_va_end_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder); /* { dg-message \"\\\\(1\\\\) 'va_start' called here\" } */\n+  i = __builtin_va_arg (ap, int);\n+  if (i == 42)\n+    {\n+      __builtin_sysv_va_end (ap);\n+      return -1;\n+    }\n+  j = __builtin_va_arg (ap, int);\n+  if (j == 1066) /* { dg-message \"branch\" } */\n+    return -1; /* { dg-message \"here\" } */\n+  __builtin_sysv_va_end (ap);\n+  return 0;\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+\n+/* va_arg after va_end.  */\n+\n+void test_va_arg_after_va_end (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+  __builtin_sysv_va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' after 'va_end'\" } */\n+}\n+\n+/* Type mismatch: expect int, but passed a char *.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_1 (int placeholder, ...)\n+{\n+  int i;\n+  \n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+\n+  i = __builtin_va_arg (ap, int); /* { dg-warning \"'va_arg' expected 'int' but received '\\[^\\n\\r\\]*' for variadic argument 1 of 'ap' \\\\\\[CWE-686\\\\\\]\" } */\n+\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_type_mismatch_1 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_1 (42, \"foo\");\n+}\n+\n+/* Type mismatch: expect char *, but passed an int.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_type_mismatch_2 (int placeholder, ...)\n+{\n+  const char *str;\n+  \n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+\n+  str = __builtin_va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1\" } */\n+\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_type_mismatch_2 (void)\n+{\n+  __analyzer_called_by_test_type_mismatch_2 (42, 1066);\n+}\n+\n+/* As above, but with an intermediate function.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_inner (__builtin_sysv_va_list ap)\n+{\n+  const char *str;\n+  \n+  str = __builtin_va_arg (ap, const char *); /* { dg-warning \"'va_arg' expected 'const char \\\\*' but received 'int' for variadic argument 1 of 'ap'\" } */\n+}\n+\n+static void __attribute__((noinline))\n+__analyzer_test_type_mismatch_3_middle (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+\n+  __analyzer_test_type_mismatch_3_inner (ap);\n+\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+void test_type_mismatch_3 (void)\n+{\n+  __analyzer_test_type_mismatch_3_middle (42, 1066);\n+}\n+\n+/* Multiple traversals of the args.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap;\n+\n+  /* First traversal.  */\n+  {\n+    int i, j;\n+\n+    __builtin_sysv_va_start (ap, placeholder);\n+\n+    i = __builtin_va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = __builtin_va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    __builtin_sysv_va_end (ap);\n+  }\n+\n+  /* Second traversal.  */\n+  {\n+    int i, j;\n+\n+    __builtin_sysv_va_start (ap, placeholder);\n+\n+    i = __builtin_va_arg (ap, int);\n+    __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+    j = __builtin_va_arg (ap, int);\n+    __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+\n+    __builtin_sysv_va_end (ap);\n+  }\n+}\n+\n+void test_multiple_traversals (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_2 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_sysv_va_list args1;\n+  __builtin_sysv_va_list args2;\n+\n+  __builtin_sysv_va_start (args1, placeholder);\n+  __builtin_sysv_va_copy (args2, args1);\n+\n+  /* First traversal.  */\n+  i = __builtin_va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = __builtin_va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_sysv_va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  i = __builtin_va_arg (args2, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+  j = __builtin_va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_sysv_va_end (args2);\n+}\n+\n+void test_multiple_traversals_2 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_2 (0, 1066, 42);\n+}\n+\n+/* Multiple traversals, using va_copy after a va_arg.  */\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_multiple_traversals_3 (int placeholder, ...)\n+{\n+  int i, j;\n+  __builtin_sysv_va_list args1;\n+  __builtin_sysv_va_list args2;\n+\n+  __builtin_sysv_va_start (args1, placeholder);\n+\n+  /* First traversal.  */\n+  i = __builtin_va_arg (args1, int);\n+  __analyzer_eval (i == 1066); /* { dg-warning \"TRUE\" } */\n+\n+  /* va_copy after the first va_arg. */\n+  __builtin_sysv_va_copy (args2, args1);\n+\n+  j = __builtin_va_arg (args1, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_sysv_va_end (args1);\n+\n+  /* Traversal of copy.  */\n+  j = __builtin_va_arg (args2, int);\n+  __analyzer_eval (j == 42); /* { dg-warning \"TRUE\" } */\n+  __builtin_sysv_va_end (args2);\n+}\n+\n+void test_multiple_traversals_3 (void)\n+{\n+  __analyzer_called_by_test_multiple_traversals_3 (0, 1066, 42);\n+}\n+\n+/* va_copy after va_end.  */\n+\n+void test_va_copy_after_va_end (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap1, ap2;\n+  __builtin_sysv_va_start (ap1, placeholder);\n+  __builtin_sysv_va_end (ap1); /* { dg-message \"'va_end' called here\" } */\n+  __builtin_sysv_va_copy (ap2, ap1); /* { dg-warning \"'va_copy' after 'va_end'\" } */\n+  __builtin_sysv_va_end (ap2);\n+}\n+\n+/* leak of va_copy.  */\n+\n+void test_leak_of_va_copy (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap1, ap2;\n+  __builtin_sysv_va_start (ap1, placeholder);\n+  __builtin_sysv_va_copy (ap2, ap1); /* { dg-message \"'va_copy' called here\" } */\n+  __builtin_sysv_va_end (ap1);\n+} /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_copy' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* double va_end.  */\n+\n+void test_double_va_end (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder);\n+  __builtin_sysv_va_end (ap); /* { dg-message \"'va_end' called here\" } */\n+  __builtin_sysv_va_end (ap); /* { dg-warning \"'va_end' after 'va_end'\" } */\n+}\n+\n+/* double va_start.  */\n+\n+void test_double_va_start (int placeholder, ...)\n+{\n+  int i;\n+  __builtin_sysv_va_list ap;\n+  __builtin_sysv_va_start (ap, placeholder); /* { dg-message \"'va_start' called here\" } */\n+  __builtin_sysv_va_start (ap, placeholder);  /* { dg-warning \"missing call to 'va_end'\" \"warning\" } */\n+  /* { dg-message \"missing call to 'va_end' to match 'va_start' at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+  __builtin_sysv_va_end (ap);\n+}\n+\n+/* va_copy before va_start.  */\n+\n+void test_va_copy_before_va_start (int placeholder, ...)\n+{\n+  __builtin_sysv_va_list ap1; /* { dg-message \"region created on stack here\" } */\n+  __builtin_sysv_va_list ap2;\n+  __builtin_sysv_va_copy (ap2, ap1); /* { dg-warning \"use of uninitialized value 'ap1'\" } */\n+  __builtin_sysv_va_end (ap2);\n+}\n+\n+/* Verify that we complain about uses of a va_list after the function \n+   in which va_start was called has returned.  */\n+\n+__builtin_sysv_va_list global_ap;\n+\n+static void __attribute__((noinline))\n+__analyzer_called_by_test_va_arg_after_return (int placeholder, ...)\n+{\n+  __builtin_sysv_va_start (global_ap, placeholder);\n+  __builtin_sysv_va_end (global_ap);\n+}\n+\n+void test_va_arg_after_return (void)\n+{\n+  int i;\n+  __analyzer_called_by_test_va_arg_after_return (42, 1066);\n+  i = __builtin_va_arg (global_ap, int); /* { dg-warning \"dereferencing pointer 'global_ap' to within stale stack frame\" } */\n+}"}]}