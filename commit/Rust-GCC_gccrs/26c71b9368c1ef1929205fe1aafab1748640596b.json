{"sha": "26c71b9368c1ef1929205fe1aafab1748640596b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZjNzFiOTM2OGMxZWYxOTI5MjA1ZmUxYWFmYWIxNzQ4NjQwNTk2Yg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-03-14T10:55:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-03-14T10:55:09Z"}, "message": "re PR target/52080 (Stores to bitfields introduce a store-data-race on adjacent data)\n\n2012-03-14  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (DECL_BIT_FIELD_REPRESENTATIVE): New define.\n\t* stor-layout.c (start_bitfield_representative): New function.\n\t(finish_bitfield_representative): Likewise.\n\t(finish_bitfield_layout): Likewise.\n\t(finish_record_layout): Call finish_bitfield_layout.\n\t* tree.c (free_lang_data_in_decl): Only free DECL_QUALIFIER\n\tfor QUAL_UNION_TYPE fields.\n\t* tree-streamer-in.c (lto_input_ts_field_decl_tree_pointers):\n\tStream DECL_BIT_FIELD_REPRESENTATIVE.\n\t* tree-streamer-out.c (write_ts_field_decl_tree_pointers): Likewise.\n\n\tPR middle-end/52080\n\tPR middle-end/52097\n\tPR middle-end/48124\n\t* expr.c (get_bit_range): Unconditionally extract bitrange\n\tfrom DECL_BIT_FIELD_REPRESENTATIVE.\n\t(expand_assignment): Adjust call to get_bit_range.\n\n\t* gcc.dg/torture/pr48124-1.c: New testcase.\n\t* gcc.dg/torture/pr48124-2.c: Likewise.\n\t* gcc.dg/torture/pr48124-3.c: Likewise.\n\t* gcc.dg/torture/pr48124-4.c: Likewise.\n\nFrom-SVN: r185379", "tree": {"sha": "26fd822d80791483a72e46062854af7176b44033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26fd822d80791483a72e46062854af7176b44033"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26c71b9368c1ef1929205fe1aafab1748640596b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26c71b9368c1ef1929205fe1aafab1748640596b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26c71b9368c1ef1929205fe1aafab1748640596b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26c71b9368c1ef1929205fe1aafab1748640596b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1caf8dd66c44ca5e25574be4cde0fd1ed7581584", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1caf8dd66c44ca5e25574be4cde0fd1ed7581584", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1caf8dd66c44ca5e25574be4cde0fd1ed7581584"}], "stats": {"total": 468, "additions": 370, "deletions": 98}, "files": [{"sha": "04e1a00e07bafb5b32ca54495a8872c63e0380e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -1,3 +1,23 @@\n+2012-03-14  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (DECL_BIT_FIELD_REPRESENTATIVE): New define.\n+\t* stor-layout.c (start_bitfield_representative): New function.\n+\t(finish_bitfield_representative): Likewise.\n+\t(finish_bitfield_layout): Likewise.\n+\t(finish_record_layout): Call finish_bitfield_layout.\n+\t* tree.c (free_lang_data_in_decl): Only free DECL_QUALIFIER\n+\tfor QUAL_UNION_TYPE fields.\n+\t* tree-streamer-in.c (lto_input_ts_field_decl_tree_pointers):\n+\tStream DECL_BIT_FIELD_REPRESENTATIVE.\n+\t* tree-streamer-out.c (write_ts_field_decl_tree_pointers): Likewise.\n+\n+\tPR middle-end/52080\n+\tPR middle-end/52097\n+\tPR middle-end/48124\n+\t* expr.c (get_bit_range): Unconditionally extract bitrange\n+\tfrom DECL_BIT_FIELD_REPRESENTATIVE.\n+\t(expand_assignment): Adjust call to get_bit_range.\n+\n 2012-03-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/52578"}, {"sha": "e8dce74974df980df9e60a69302b59d3485ad3a4", "filename": "gcc/expr.c", "status": "modified", "additions": 24, "deletions": 95, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -4439,113 +4439,43 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n /* In the C++ memory model, consecutive bit fields in a structure are\n    considered one memory location.\n \n-   Given a COMPONENT_REF, this function returns the bit range of\n-   consecutive bits in which this COMPONENT_REF belongs in.  The\n-   values are returned in *BITSTART and *BITEND.  If either the C++\n-   memory model is not activated, or this memory access is not thread\n-   visible, 0 is returned in *BITSTART and *BITEND.\n-\n-   EXP is the COMPONENT_REF.\n-   INNERDECL is the actual object being referenced.\n-   BITPOS is the position in bits where the bit starts within the structure.\n-   BITSIZE is size in bits of the field being referenced in EXP.\n-\n-   For example, while storing into FOO.A here...\n-\n-      struct {\n-        BIT 0:\n-          unsigned int a : 4;\n-\t  unsigned int b : 1;\n-\tBIT 8:\n-\t  unsigned char c;\n-\t  unsigned int d : 6;\n-      } foo;\n-\n-   ...we are not allowed to store past <b>, so for the layout above, a\n-   range of 0..7 (because no one cares if we store into the\n-   padding).  */\n+   Given a COMPONENT_REF EXP at bit position BITPOS, this function\n+   returns the bit range of consecutive bits in which this COMPONENT_REF\n+   belongs in.  The values are returned in *BITSTART and *BITEND.\n+   If the access does not need to be restricted 0 is returned in\n+   *BITSTART and *BITEND.  */\n \n static void\n get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n \t       unsigned HOST_WIDE_INT *bitend,\n-\t       tree exp, tree innerdecl,\n-\t       HOST_WIDE_INT bitpos, HOST_WIDE_INT bitsize)\n+\t       tree exp,\n+\t       HOST_WIDE_INT bitpos)\n {\n-  tree field, record_type, fld;\n-  bool found_field = false;\n-  bool prev_field_is_bitfield;\n+  unsigned HOST_WIDE_INT bitoffset;\n+  tree field, repr, offset;\n \n   gcc_assert (TREE_CODE (exp) == COMPONENT_REF);\n \n-  /* If other threads can't see this value, no need to restrict stores.  */\n-  if (ALLOW_STORE_DATA_RACES\n-      || ((TREE_CODE (innerdecl) == MEM_REF\n-\t   || TREE_CODE (innerdecl) == TARGET_MEM_REF)\n-\t  && !ptr_deref_may_alias_global_p (TREE_OPERAND (innerdecl, 0)))\n-      || (DECL_P (innerdecl)\n-\t  && ((TREE_CODE (innerdecl) == VAR_DECL\n-\t       && DECL_THREAD_LOCAL_P (innerdecl))\n-\t      || !TREE_STATIC (innerdecl))))\n+  field = TREE_OPERAND (exp, 1);\n+  repr = DECL_BIT_FIELD_REPRESENTATIVE (field);\n+  /* If we do not have a DECL_BIT_FIELD_REPRESENTATIVE there is no\n+     need to limit the range we can access.  */\n+  if (!repr)\n     {\n       *bitstart = *bitend = 0;\n       return;\n     }\n \n-  /* Bit field we're storing into.  */\n-  field = TREE_OPERAND (exp, 1);\n-  record_type = DECL_FIELD_CONTEXT (field);\n-\n-  /* Count the contiguous bitfields for the memory location that\n-     contains FIELD.  */\n-  *bitstart = 0;\n-  prev_field_is_bitfield = true;\n-  for (fld = TYPE_FIELDS (record_type); fld; fld = DECL_CHAIN (fld))\n-    {\n-      tree t, offset;\n-      enum machine_mode mode;\n-      int unsignedp, volatilep;\n-\n-      if (TREE_CODE (fld) != FIELD_DECL)\n-\tcontinue;\n-\n-      t = build3 (COMPONENT_REF, TREE_TYPE (exp),\n-\t\t  unshare_expr (TREE_OPERAND (exp, 0)),\n-\t\t  fld, NULL_TREE);\n-      get_inner_reference (t, &bitsize, &bitpos, &offset,\n-\t\t\t   &mode, &unsignedp, &volatilep, true);\n-\n-      if (field == fld)\n-\tfound_field = true;\n-\n-      if (DECL_BIT_FIELD_TYPE (fld) && bitsize > 0)\n-\t{\n-\t  if (prev_field_is_bitfield == false)\n-\t    {\n-\t      *bitstart = bitpos;\n-\t      prev_field_is_bitfield = true;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  prev_field_is_bitfield = false;\n-\t  if (found_field)\n-\t    break;\n-\t}\n-    }\n-  gcc_assert (found_field);\n+  /* Compute the adjustment to bitpos from the offset of the field\n+     relative to the representative.  */\n+  offset = size_diffop (DECL_FIELD_OFFSET (field),\n+\t\t\tDECL_FIELD_OFFSET (repr));\n+  bitoffset = (tree_low_cst (offset, 1) * BITS_PER_UNIT\n+\t       + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n+\t       - tree_low_cst (DECL_FIELD_BIT_OFFSET (repr), 1));\n \n-  if (fld)\n-    {\n-      /* We found the end of the bit field sequence.  Include the\n-\t padding up to the next field and be done.  */\n-      *bitend = bitpos - 1;\n-    }\n-  else\n-    {\n-      /* If this is the last element in the structure, include the padding\n-\t at the end of structure.  */\n-      *bitend = TREE_INT_CST_LOW (TYPE_SIZE (record_type)) - 1;\n-    }\n+  *bitstart = bitpos - bitoffset;\n+  *bitend = *bitstart + tree_low_cst (DECL_SIZE (repr), 1) - 1;\n }\n \n /* Returns true if the MEM_REF REF refers to an object that does not\n@@ -4682,8 +4612,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \n       if (TREE_CODE (to) == COMPONENT_REF\n \t  && DECL_BIT_FIELD_TYPE (TREE_OPERAND (to, 1)))\n-\tget_bit_range (&bitregion_start, &bitregion_end,\n-\t\t       to, tem, bitpos, bitsize);\n+\tget_bit_range (&bitregion_start, &bitregion_end, to, bitpos);\n \n       /* If we are going to use store_bit_field and extract_bit_field,\n \t make sure to_rtx will be safe for multiple use.  */"}, {"sha": "7c7fabc6bedb51e529e30a0645f5a58057c03357", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -1722,6 +1722,190 @@ finalize_type_size (tree type)\n     }\n }\n \n+/* Return a new underlying object for a bitfield started with FIELD.  */\n+\n+static tree\n+start_bitfield_representative (tree field)\n+{\n+  tree repr = make_node (FIELD_DECL);\n+  DECL_FIELD_OFFSET (repr) = DECL_FIELD_OFFSET (field);\n+  /* Force the representative to begin at a BITS_PER_UNIT aligned\n+     boundary - C++ may use tail-padding of a base object to\n+     continue packing bits so the bitfield region does not start\n+     at bit zero (see g++.dg/abi/bitfield5.C for example).\n+     Unallocated bits may happen for other reasons as well,\n+     for example Ada which allows explicit bit-granular structure layout.  */\n+  DECL_FIELD_BIT_OFFSET (repr)\n+    = size_binop (BIT_AND_EXPR,\n+\t\t  DECL_FIELD_BIT_OFFSET (field),\n+\t\t  bitsize_int (~(BITS_PER_UNIT - 1)));\n+  SET_DECL_OFFSET_ALIGN (repr, DECL_OFFSET_ALIGN (field));\n+  DECL_SIZE (repr) = DECL_SIZE (field);\n+  DECL_SIZE_UNIT (repr) = DECL_SIZE_UNIT (field);\n+  DECL_PACKED (repr) = DECL_PACKED (field);\n+  DECL_CONTEXT (repr) = DECL_CONTEXT (field);\n+  return repr;\n+}\n+\n+/* Finish up a bitfield group that was started by creating the underlying\n+   object REPR with the last field in the bitfield group FIELD.  */\n+\n+static void\n+finish_bitfield_representative (tree repr, tree field)\n+{\n+  unsigned HOST_WIDE_INT bitsize, maxbitsize;\n+  enum machine_mode mode;\n+  tree nextf, size;\n+\n+  size = size_diffop (DECL_FIELD_OFFSET (field),\n+\t\t      DECL_FIELD_OFFSET (repr));\n+  gcc_assert (host_integerp (size, 1));\n+  bitsize = (tree_low_cst (size, 1) * BITS_PER_UNIT\n+\t     + tree_low_cst (DECL_FIELD_BIT_OFFSET (field), 1)\n+\t     - tree_low_cst (DECL_FIELD_BIT_OFFSET (repr), 1)\n+\t     + tree_low_cst (DECL_SIZE (field), 1));\n+\n+  /* Now nothing tells us how to pad out bitsize ...  */\n+  nextf = DECL_CHAIN (field);\n+  while (nextf && TREE_CODE (nextf) != FIELD_DECL)\n+    nextf = DECL_CHAIN (nextf);\n+  if (nextf)\n+    {\n+      tree maxsize;\n+      /* If there was an error, the field may be not layed out\n+         correctly.  Don't bother to do anything.  */\n+      if (TREE_TYPE (nextf) == error_mark_node)\n+\treturn;\n+      maxsize = size_diffop (DECL_FIELD_OFFSET (nextf),\n+\t\t\t     DECL_FIELD_OFFSET (repr));\n+      gcc_assert (host_integerp (maxsize, 1));\n+      maxbitsize = (tree_low_cst (maxsize, 1) * BITS_PER_UNIT\n+\t\t    + tree_low_cst (DECL_FIELD_BIT_OFFSET (nextf), 1)\n+\t\t    - tree_low_cst (DECL_FIELD_BIT_OFFSET (repr), 1));\n+    }\n+  else\n+    {\n+      /* ???  If you consider that tail-padding of this struct might be\n+         re-used when deriving from it we cannot really do the following\n+\t and thus need to set maxsize to bitsize?  */\n+      tree maxsize = size_diffop (TYPE_SIZE_UNIT (DECL_CONTEXT (field)),\n+\t\t\t\t  DECL_FIELD_OFFSET (repr));\n+      gcc_assert (host_integerp (maxsize, 1));\n+      maxbitsize = (tree_low_cst (maxsize, 1) * BITS_PER_UNIT\n+\t\t    - tree_low_cst (DECL_FIELD_BIT_OFFSET (repr), 1));\n+    }\n+\n+  /* Only if we don't artificially break up the representative in\n+     the middle of a large bitfield with different possibly\n+     overlapping representatives.  And all representatives start\n+     at byte offset.  */\n+  gcc_assert (maxbitsize % BITS_PER_UNIT == 0);\n+\n+  /* Round up bitsize to multiples of BITS_PER_UNIT.  */\n+  bitsize = (bitsize + BITS_PER_UNIT - 1) & ~(BITS_PER_UNIT - 1);\n+\n+  /* Find the smallest nice mode to use.  */\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_BITSIZE (mode) >= bitsize)\n+      break;\n+  if (mode != VOIDmode\n+      && (GET_MODE_BITSIZE (mode) > maxbitsize\n+\t  || GET_MODE_BITSIZE (mode) > MAX_FIXED_MODE_SIZE))\n+    mode = VOIDmode;\n+\n+  if (mode == VOIDmode)\n+    {\n+      /* We really want a BLKmode representative only as a last resort,\n+         considering the member b in\n+\t   struct { int a : 7; int b : 17; int c; } __attribute__((packed));\n+\t Otherwise we simply want to split the representative up\n+\t allowing for overlaps within the bitfield region as required for\n+\t   struct { int a : 7; int b : 7;\n+\t\t    int c : 10; int d; } __attribute__((packed));\n+\t [0, 15] HImode for a and b, [8, 23] HImode for c.  */\n+      DECL_SIZE (repr) = bitsize_int (bitsize);\n+      DECL_SIZE_UNIT (repr) = size_int (bitsize / BITS_PER_UNIT);\n+      DECL_MODE (repr) = BLKmode;\n+      TREE_TYPE (repr) = build_array_type_nelts (unsigned_char_type_node,\n+\t\t\t\t\t\t bitsize / BITS_PER_UNIT);\n+    }\n+  else\n+    {\n+      unsigned HOST_WIDE_INT modesize = GET_MODE_BITSIZE (mode);\n+      DECL_SIZE (repr) = bitsize_int (modesize);\n+      DECL_SIZE_UNIT (repr) = size_int (modesize / BITS_PER_UNIT);\n+      DECL_MODE (repr) = mode;\n+      TREE_TYPE (repr) = lang_hooks.types.type_for_mode (mode, 1);\n+    }\n+\n+  /* Remember whether the bitfield group is at the end of the\n+     structure or not.  */\n+  DECL_CHAIN (repr) = nextf;\n+}\n+\n+/* Compute and set FIELD_DECLs for the underlying objects we should\n+   use for bitfield access for the structure layed out with RLI.  */\n+\n+static void\n+finish_bitfield_layout (record_layout_info rli)\n+{\n+  tree field, prev;\n+  tree repr = NULL_TREE;\n+\n+  /* Unions would be special, for the ease of type-punning optimizations\n+     we could use the underlying type as hint for the representative\n+     if the bitfield would fit and the representative would not exceed\n+     the union in size.  */\n+  if (TREE_CODE (rli->t) != RECORD_TYPE)\n+    return;\n+\n+  for (prev = NULL_TREE, field = TYPE_FIELDS (rli->t);\n+       field; field = DECL_CHAIN (field))\n+    {\n+      if (TREE_CODE (field) != FIELD_DECL)\n+\tcontinue;\n+\n+      /* In the C++ memory model, consecutive bit fields in a structure are\n+\t considered one memory location and updating a memory location\n+\t may not store into adjacent memory locations.  */\n+      if (!repr\n+\t  && DECL_BIT_FIELD_TYPE (field))\n+\t{\n+\t  /* Start new representative.  */\n+\t  repr = start_bitfield_representative (field);\n+\t}\n+      else if (repr\n+\t       && ! DECL_BIT_FIELD_TYPE (field))\n+\t{\n+\t  /* Finish off new representative.  */\n+\t  finish_bitfield_representative (repr, prev);\n+\t  repr = NULL_TREE;\n+\t}\n+      else if (DECL_BIT_FIELD_TYPE (field))\n+\t{\n+\t  /* Zero-size bitfields finish off a representative and\n+\t     do not have a representative themselves.  This is\n+\t     required by the C++ memory model.  */\n+\t  if (integer_zerop (DECL_SIZE (field)))\n+\t    {\n+\t      finish_bitfield_representative (repr, prev);\n+\t      repr = NULL_TREE;\n+\t    }\n+\t}\n+      else\n+\tcontinue;\n+\n+      if (repr)\n+\tDECL_BIT_FIELD_REPRESENTATIVE (field) = repr;\n+\n+      prev = field;\n+    }\n+\n+  if (repr)\n+    finish_bitfield_representative (repr, prev);\n+}\n+\n /* Do all of the work required to layout the type indicated by RLI,\n    once the fields have been laid out.  This function will call `free'\n    for RLI, unless FREE_P is false.  Passing a value other than false\n@@ -1742,6 +1926,9 @@ finish_record_layout (record_layout_info rli, int free_p)\n   /* Perform any last tweaks to the TYPE_SIZE, etc.  */\n   finalize_type_size (rli->t);\n \n+  /* Compute bitfield representatives.  */\n+  finish_bitfield_layout (rli);\n+\n   /* Propagate TYPE_PACKED to variants.  With C++ templates,\n      handle_packed_attribute is too early to do this.  */\n   for (variant = TYPE_NEXT_VARIANT (rli->t); variant;"}, {"sha": "406f0959f51587e0b2f3b9e4db99d3d2055a80f7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -1,3 +1,13 @@\n+2012-03-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/52080\n+\tPR middle-end/52097\n+\tPR middle-end/48124\n+\t* gcc.dg/torture/pr48124-1.c: New testcase.\n+\t* gcc.dg/torture/pr48124-2.c: Likewise.\n+\t* gcc.dg/torture/pr48124-3.c: Likewise.\n+\t* gcc.dg/torture/pr48124-4.c: Likewise.\n+\n 2012-03-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/52578"}, {"sha": "ed7618127a07da5cb6fdd15755ea26ccd3a5068b", "filename": "gcc/testsuite/gcc.dg/torture/pr48124-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-1.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-toplevel-reorder\" } */\n+\n+extern void abort (void);\n+\n+struct S\n+{\n+  signed a : 26;\n+  signed b : 16;\n+  signed c : 10;\n+  volatile signed d : 14;\n+};\n+\n+static struct S e = { 0, 0, 0, 1 };\n+static int f = 1;\n+\n+void __attribute__((noinline))\n+foo (void)\n+{\n+  e.d = 0;\n+  f = 2;\n+}\n+\n+int\n+main ()\n+{\n+  if (e.a || e.b || e.c || e.d != 1 || f != 1)\n+    abort ();\n+  foo ();\n+  if (e.a || e.b || e.c || e.d || f != 2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "485d8d4b553e3bd9b876a4bf61dee5b1d6598b2b", "filename": "gcc/testsuite/gcc.dg/torture/pr48124-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-2.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+static volatile struct S0 {\n+    short f3[9];\n+    unsigned f8 : 15;\n+} s = {1};\n+static unsigned short sh = 0x1234;\n+\n+struct S0 a, b;\n+int vi = 0;\n+\n+void func_4()\n+{\n+  s.f8 |= 1;\n+  sh = 15;\n+  if (vi) a = b;\n+}\n+\n+int main()\n+{\n+  func_4();\n+  if (sh != 15)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "386d88bd936ac29ad55611d2d4ed35883e1bf34a", "filename": "gcc/testsuite/gcc.dg/torture/pr48124-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-3.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+struct S1\n+{\n+  int f0;\n+  int:1;\n+  int f3;\n+  int:1;\n+  int:0;\n+  int f6:1;\n+};\n+int g_13 = 1;\n+volatile struct S1 g_118 = {\n+    1\n+};\n+\n+void __attribute__((noinline))\n+func_46 ()\n+{\n+  for (g_13 = 0; g_13 >= 0; g_13 -= 1)\n+    g_118.f6 = 0;\n+}\n+\n+int\n+main ()\n+{\n+  func_46 ();\n+  if (g_13 != -1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "9ccd763f5e0b03d559149b0d06c0aacca1550268", "filename": "gcc/testsuite/gcc.dg/torture/pr48124-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48124-4.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+struct S1 {\n+    unsigned f0, f1;\n+    unsigned short f2, f3;\n+    unsigned f4 : 16;\n+    unsigned f5, f6;\n+    volatile unsigned f7 : 28;\n+};\n+static struct S1 g_76;\n+static struct S1 g_245 = {0,0,0,0,0,0,0,1};\n+static signed char g_323 = 0x80;\n+static void func_1(void)\n+{\n+  g_245.f7 &= 1;\n+  for (g_323 = 0; g_323 <= -1; g_323 -= 2) {\n+      g_76 = g_76;\n+      g_76.f4 ^= 11;\n+  }\n+}\n+int main()\n+{\n+  func_1();\n+  if (g_323 != 0 || g_245.f7 != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "cb940aa7871bb56e3234314aca0af7f9ecd367ee", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -640,7 +640,7 @@ lto_input_ts_field_decl_tree_pointers (struct lto_input_block *ib,\n {\n   DECL_FIELD_OFFSET (expr) = stream_read_tree (ib, data_in);\n   DECL_BIT_FIELD_TYPE (expr) = stream_read_tree (ib, data_in);\n-  /* Do not stream DECL_QUALIFIER, it is useless after gimplification.  */\n+  DECL_BIT_FIELD_REPRESENTATIVE (expr) = stream_read_tree (ib, data_in);\n   DECL_FIELD_BIT_OFFSET (expr) = stream_read_tree (ib, data_in);\n   DECL_FCONTEXT (expr) = stream_read_tree (ib, data_in);\n }"}, {"sha": "c792fc2acf0814441ef773d58114aaf3b6d59cc5", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -552,7 +552,7 @@ write_ts_field_decl_tree_pointers (struct output_block *ob, tree expr,\n {\n   stream_write_tree (ob, DECL_FIELD_OFFSET (expr), ref_p);\n   stream_write_tree (ob, DECL_BIT_FIELD_TYPE (expr), ref_p);\n-  /* Do not stream DECL_QUALIFIER, it is useless after gimplification.  */\n+  stream_write_tree (ob, DECL_BIT_FIELD_REPRESENTATIVE (expr), ref_p);\n   stream_write_tree (ob, DECL_FIELD_BIT_OFFSET (expr), ref_p);\n   stream_write_tree (ob, DECL_FCONTEXT (expr), ref_p);\n }"}, {"sha": "c90331ca560da1ac6dce4a994f95b0a311e1511b", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -4633,7 +4633,8 @@ free_lang_data_in_decl (tree decl)\n   if (TREE_CODE (decl) == FIELD_DECL)\n     {\n       free_lang_data_in_one_sizepos (&DECL_FIELD_OFFSET (decl));\n-      DECL_QUALIFIER (decl) = NULL_TREE;\n+      if (TREE_CODE (DECL_CONTEXT (decl)) == QUAL_UNION_TYPE)\n+\tDECL_QUALIFIER (decl) = NULL_TREE;\n     }\n \n  if (TREE_CODE (decl) == FUNCTION_DECL)"}, {"sha": "d9e826b26ddc30e8059baa4d55db012425080d26", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26c71b9368c1ef1929205fe1aafab1748640596b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=26c71b9368c1ef1929205fe1aafab1748640596b", "patch": "@@ -3024,6 +3024,11 @@ struct GTY(()) tree_decl_with_rtl {\n #define DECL_BIT_FIELD_TYPE(NODE) \\\n   (FIELD_DECL_CHECK (NODE)->field_decl.bit_field_type)\n \n+/* In a FIELD_DECL of a RECORD_TYPE, this is a pointer to the storage\n+   representative FIELD_DECL.  */\n+#define DECL_BIT_FIELD_REPRESENTATIVE(NODE) \\\n+  (FIELD_DECL_CHECK (NODE)->field_decl.qualifier)\n+\n /* For a FIELD_DECL in a QUAL_UNION_TYPE, records the expression, which\n    if nonzero, indicates that the field occupies the type.  */\n #define DECL_QUALIFIER(NODE) (FIELD_DECL_CHECK (NODE)->field_decl.qualifier)"}]}