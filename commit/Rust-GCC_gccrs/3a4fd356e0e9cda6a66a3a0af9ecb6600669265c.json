{"sha": "3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E0ZmQzNTZlMGU5Y2RhNmE2NmEzYTBhZjllY2I2NjAwNjY5MjY1Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-30T14:19:01Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-30T14:19:01Z"}, "message": "optabs.c (expand_abs_nojump): Update BRANCH_COST call.\n\n\t* optabs.c (expand_abs_nojump): Update BRANCH_COST call.\n\t* fold-cost.c (LOGICAL_OP_NON_SHORT_CIRCUIT, fold_truthop): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* ifcvt.c (MAX_CONDITIONAL_EXECUTE): Likewise.\n\t(note-if_info): Add BRANCH_COST.\n\t(noce_try_store_flag_constants, noce_try_addcc, noce_try_store_flag_mask,\n\tnoce_try_cmove_arith, noce_try_cmove_arith, noce_try_cmove_arith,\n\tnoce_find_if_block, find_if_case_1, find_if_case_2): Use compuated\n\tbranch cost.\n\t* expr.h (BRANCH_COST): Update default.\n\t* predict.c (predictable_edge_p): New function.\n\t* expmed.c (expand_smod_pow2, expand_sdiv_pow2, emit_store_flag):\n\tUpdate BRANCH_COST call.\n\t* basic-block.h (predictable_edge_p): Declare.\n\t* config/alpha/alpha.h (BRANCH_COST): Update.\n\t* config/frv/frv.h (BRANCH_COST): Update.\n\t* config/s390/s390.h (BRANCH_COST): Update.\n\t* config/spu/spu.h (BRANCH_COST): Update.\n\t* config/sparc/sparc.h (BRANCH_COST): Update.\n\t* config/m32r/m32r.h (BRANCH_COST): Update.\n\t* config/i386/i386.h (BRANCH_COST): Update.\n\t* config/i386/i386.c (ix86_expand_int_movcc): Update use of BRANCH_COST.\n\t* config/sh/sh.h (BRANCH_COST): Update.\n\t* config/pdp11/pdp11.h (BRANCH_COST): Update.\n\t* config/avr/avr.h (BRANCH_COST): Update.\n\t* config/crx/crx.h (BRANCH_COST): Update.\n\t* config/xtensa/xtensa.h (BRANCH_COST): Update.\n\t* config/stormy16/stormy16.h (BRANCH_COST): Update.\n\t* config/m68hc11/m68hc11.h (BRANCH_COST): Update.\n\t* config/iq2000/iq2000.h (BRANCH_COST): Update.\n\t* config/ia64/ia64.h (BRANCH_COST): Update.\n\t* config/rs6000/rs6000.h (BRANCH_COST): Update.\n\t* config/arc/arc.h (BRANCH_COST): Update.\n\t* config/score/score.h (BRANCH_COST): Update.\n\t* config/arm/arm.h (BRANCH_COST): Update.\n\t* config/pa/pa.h (BRANCH_COST): Update.\n\t* config/mips/mips.h (BRANCH_COST): Update.\n\t* config/vax/vax.h (BRANCH_COST): Update.\n\t* config/h8300/h8300.h (BRANCH_COST): Update.\n\t* params.def (PARAM_PREDICTABLE_BRANCH_OUTCOME): New.\n\t* doc/invoke.texi (predictable-branch-cost-outcome): Document.\n\t* doc/tm.texi (BRANCH_COST): Update.\n\nFrom-SVN: r139804", "tree": {"sha": "4339e3edb706d886f8df2cbbc9a8fe530f969a60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4339e3edb706d886f8df2cbbc9a8fe530f969a60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/comments", "author": null, "committer": null, "parents": [{"sha": "b1bdaf4061096a0e4d4259acbf27cf97542ea9de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1bdaf4061096a0e4d4259acbf27cf97542ea9de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1bdaf4061096a0e4d4259acbf27cf97542ea9de"}], "stats": {"total": 225, "additions": 168, "deletions": 57}, "files": [{"sha": "24493252e2ce502af424673a03757c6f74b8a68c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1,3 +1,48 @@\n+2008-08-30  Jan Hubicka  <jh@suse.cz>\n+\n+\t* optabs.c (expand_abs_nojump): Update BRANCH_COST call.\n+\t* fold-cost.c (LOGICAL_OP_NON_SHORT_CIRCUIT, fold_truthop): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* ifcvt.c (MAX_CONDITIONAL_EXECUTE): Likewise.\n+\t(note-if_info): Add BRANCH_COST.\n+\t(noce_try_store_flag_constants, noce_try_addcc, noce_try_store_flag_mask,\n+\tnoce_try_cmove_arith, noce_try_cmove_arith, noce_try_cmove_arith,\n+\tnoce_find_if_block, find_if_case_1, find_if_case_2): Use compuated\n+\tbranch cost.\n+\t* expr.h (BRANCH_COST): Update default.\n+\t* predict.c (predictable_edge_p): New function.\n+\t* expmed.c (expand_smod_pow2, expand_sdiv_pow2, emit_store_flag):\n+\tUpdate BRANCH_COST call.\n+\t* basic-block.h (predictable_edge_p): Declare.\n+\t* config/alpha/alpha.h (BRANCH_COST): Update.\n+\t* config/frv/frv.h (BRANCH_COST): Update.\n+\t* config/s390/s390.h (BRANCH_COST): Update.\n+\t* config/spu/spu.h (BRANCH_COST): Update.\n+\t* config/sparc/sparc.h (BRANCH_COST): Update.\n+\t* config/m32r/m32r.h (BRANCH_COST): Update.\n+\t* config/i386/i386.h (BRANCH_COST): Update.\n+\t* config/i386/i386.c (ix86_expand_int_movcc): Update use of BRANCH_COST.\n+\t* config/sh/sh.h (BRANCH_COST): Update.\n+\t* config/pdp11/pdp11.h (BRANCH_COST): Update.\n+\t* config/avr/avr.h (BRANCH_COST): Update.\n+\t* config/crx/crx.h (BRANCH_COST): Update.\n+\t* config/xtensa/xtensa.h (BRANCH_COST): Update.\n+\t* config/stormy16/stormy16.h (BRANCH_COST): Update.\n+\t* config/m68hc11/m68hc11.h (BRANCH_COST): Update.\n+\t* config/iq2000/iq2000.h (BRANCH_COST): Update.\n+\t* config/ia64/ia64.h (BRANCH_COST): Update.\n+\t* config/rs6000/rs6000.h (BRANCH_COST): Update.\n+\t* config/arc/arc.h (BRANCH_COST): Update.\n+\t* config/score/score.h (BRANCH_COST): Update.\n+\t* config/arm/arm.h (BRANCH_COST): Update.\n+\t* config/pa/pa.h (BRANCH_COST): Update.\n+\t* config/mips/mips.h (BRANCH_COST): Update.\n+\t* config/vax/vax.h (BRANCH_COST): Update.\n+\t* config/h8300/h8300.h (BRANCH_COST): Update.\n+\t* params.def (PARAM_PREDICTABLE_BRANCH_OUTCOME): New.\n+\t* doc/invoke.texi (predictable-branch-cost-outcome): Document.\n+\t* doc/tm.texi (BRANCH_COST): Update.\n+\n 2008-08-30  Samuel Tardieu  <sam@rfc1149.net>\n \n \tPR target/37283"}, {"sha": "e1d13ea27c6ab05b472e5999ab63df22d4dd076d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -852,6 +852,7 @@ extern void guess_outgoing_edge_probabilities (basic_block);\n extern void remove_predictions_associated_with_edge (edge);\n extern bool edge_probability_reliable_p (const_edge);\n extern bool br_prob_note_reliable_p (const_rtx);\n+extern bool predictable_edge_p (edge);\n \n /* In cfg.c  */\n extern void dump_regset (regset, FILE *);"}, {"sha": "8e022d6a5f8016b965ec468dfc28ad7108d1d7ad", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -640,7 +640,7 @@ extern int alpha_memory_latency;\n #define MEMORY_MOVE_COST(MODE,CLASS,IN)  (2*alpha_memory_latency)\n \n /* Provide the cost of a branch.  Exact meaning under development.  */\n-#define BRANCH_COST 5\n+#define BRANCH_COST(speed_p, predictable_p) 5\n \f\n /* Stack layout; function entry, exit and calling.  */\n "}, {"sha": "ff473c3f73efcc29df7370c22380113b33855ea7", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -824,7 +824,7 @@ arc_select_cc_mode (OP, X, Y)\n /* The cost of a branch insn.  */\n /* ??? What's the right value here?  Branches are certainly more\n    expensive than reg->reg moves.  */\n-#define BRANCH_COST 2\n+#define BRANCH_COST(speed_p, predictable_p) 2\n \n /* Nonzero if access to memory by bytes is slow and undesirable.\n    For RISC chips, it means that access to memory by bytes is no"}, {"sha": "4132b06b0249f107cce27b121d8c9813bb08ea5d", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -2297,7 +2297,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n-#define BRANCH_COST \\\n+#define BRANCH_COST(speed_p, predictable_p) \\\n   (TARGET_32BIT ? 4 : (optimize > 0 ? 2 : 0))\n \f\n /* Position Independent Code.  */"}, {"sha": "744098518056b0a64c0128b135706b8ee79e2333", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -511,7 +511,7 @@ do {\t\t\t\t\t\t\t\t\t    \\\n \t\t\t\t\t (MODE)==SImode ? 8 :\t\\\n \t\t\t\t\t (MODE)==SFmode ? 8 : 16)\n \n-#define BRANCH_COST 0\n+#define BRANCH_COST(speed_p, predictable_p) 0\n \n #define SLOW_BYTE_ACCESS 0\n "}, {"sha": "91c5f31d1e1fdfa6126eac66bc9d29347ce6fbec", "filename": "gcc/config/crx/crx.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -420,7 +420,7 @@ struct cumulative_args\n /* Moving to processor register flushes pipeline - thus asymmetric */\n #define REGISTER_MOVE_COST(MODE, FROM, TO) ((TO != GENERAL_REGS) ? 8 : 2)\n /* Assume best case (branch predicted) */\n-#define BRANCH_COST 2\n+#define BRANCH_COST(speed_p, predictable_p) 2\n \n #define SLOW_BYTE_ACCESS  1\n "}, {"sha": "8a71337fcc10ecc376f5f1ae019ca3bd8d481b03", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -2193,7 +2193,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* A C expression for the cost of a branch instruction.  A value of 1 is the\n    default; other values are interpreted relative to that.  */\n-#define BRANCH_COST frv_branch_cost_int\n+#define BRANCH_COST(speed_p, predictable_p) frv_branch_cost_int\n \n /* Define this macro as a C expression which is nonzero if accessing less than\n    a word of memory (i.e. a `char' or a `short') is no faster than accessing a"}, {"sha": "7305fc32f85804d6eecbd2769902749905fe3be4", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1004,7 +1004,7 @@ struct cum_arg\n #define DELAY_SLOT_LENGTH(JUMP) \\\n   (NEXT_INSN (PREV_INSN (JUMP)) == JUMP ? 0 : 2)\n \n-#define BRANCH_COST 0\n+#define BRANCH_COST(speed_p, predictable_p) 0\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "002a9a7e2a0d0fe3e3aaed7291eb05f5af4e1152", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -14636,7 +14636,8 @@ ix86_expand_int_movcc (rtx operands[])\n        */\n \n       if ((!TARGET_CMOVE || (mode == QImode && TARGET_PARTIAL_REG_STALL))\n-\t  && BRANCH_COST >= 2)\n+\t  && BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t  \t  false) >= 2)\n \t{\n \t  if (cf == 0)\n \t    {\n@@ -14721,7 +14722,7 @@ ix86_expand_int_movcc (rtx operands[])\n       optab op;\n       rtx var, orig_out, out, tmp;\n \n-      if (BRANCH_COST <= 2)\n+      if (BRANCH_COST (optimize_insn_for_speed_p (), false) <= 2)\n \treturn 0; /* FAIL */\n \n       /* If one of the two operands is an interesting constant, load a"}, {"sha": "d933c5e23896e994c4e315df99cbb4196e5bf447", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1975,7 +1975,8 @@ do {\t\t\t\t\t\t\t\\\n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */\n \n-#define BRANCH_COST ix86_branch_cost\n+#define BRANCH_COST(speed_p, predictable_p) \\\n+  (!(speed_p) ? 2 : (predictable_p) ? 0 : ix86_branch_cost)\n \n /* Define this macro as a C expression which is nonzero if accessing\n    less than a word of memory (i.e. a `char' or a `short') is no"}, {"sha": "e97bcf6e934ed00feb6303dc14c4a77f4e2addeb", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1384,7 +1384,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    many additional insn groups we run into, vs how good the dynamic\n    branch predictor is.  */\n \n-#define BRANCH_COST 6\n+#define BRANCH_COST(speed_p, predictable_p) 6\n \n /* Define this macro as a C expression which is nonzero if accessing less than\n    a word of memory (i.e. a `char' or a `short') is no faster than accessing a"}, {"sha": "f6c7ec5edb65f06d3a677f823cf3bbab0371f0bb", "filename": "gcc/config/iq2000/iq2000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fiq2000%2Fiq2000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fiq2000%2Fiq2000.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -624,7 +624,7 @@ typedef struct iq2000_args\n #define MEMORY_MOVE_COST(MODE,CLASS,TO_P)\t\\\n   (TO_P ? 2 : 16)\n \n-#define BRANCH_COST 2\n+#define BRANCH_COST(speed_p, predictable_p) 2\n \n #define SLOW_BYTE_ACCESS 1\n "}, {"sha": "f2f7e891201063a3d55affc652d2a48f73454069", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1224,7 +1224,7 @@ L2:     .word STATIC\n /* A value of 2 here causes GCC to avoid using branches in comparisons like\n    while (a < N && a).  Branches aren't that expensive on the M32R so\n    we define this as 1.  Defining it as 2 had a heavy hit in fp-bit.c.  */\n-#define BRANCH_COST ((TARGET_BRANCH_COST) ? 2 : 1)\n+#define BRANCH_COST(speed_p, predictable_p) ((TARGET_BRANCH_COST) ? 2 : 1)\n \n /* Nonzero if access to memory by bytes is slow and undesirable.\n    For RISC chips, it means that access to memory by bytes is no"}, {"sha": "cae57e3a9feb63c55d3005b9c32174d5689f1fa8", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1266,7 +1266,7 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n \n    Pretend branches are cheap because GCC generates sub-optimal code\n    for the default value.  */\n-#define BRANCH_COST 0\n+#define BRANCH_COST(speed_p, predictable_p) 0\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS\t0"}, {"sha": "e008e8047817c89fe29cc8defe6b62c97c04eedf", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -2557,7 +2557,7 @@ typedef struct mips_args {\n /* A C expression for the cost of a branch instruction.  A value of\n    1 is the default; other values are interpreted relative to that.  */\n \n-#define BRANCH_COST mips_branch_cost\n+#define BRANCH_COST(speed_p, predictable_p) mips_branch_cost\n #define LOGICAL_OP_NON_SHORT_CIRCUIT 0\n \n /* If defined, modifies the length assigned to instruction INSN as a"}, {"sha": "5e272a2f346d5a2177399aecde5909756a512c34", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1570,7 +1570,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n   : 2)\n \n /* Adjust the cost of branches.  */\n-#define BRANCH_COST (pa_cpu == PROCESSOR_8000 ? 2 : 1)\n+#define BRANCH_COST(speed_p, predictable_p) (pa_cpu == PROCESSOR_8000 ? 2 : 1)\n \n /* Handling the special cases is going to get too complicated for a macro,\n    just call `pa_adjust_insn_length' to do the real work.  */"}, {"sha": "e572d6cf9c3eda8aa09e5d9158a415dbbc1d240e", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -1057,7 +1057,7 @@ JMP\tFUNCTION\t0x0058  0x0000 <- FUNCTION\n /* there is no point in avoiding branches on a pdp, \n    since branches are really cheap - I just want to find out\n    how much difference the BRANCH_COST macro makes in code */\n-#define BRANCH_COST (TARGET_BRANCH_CHEAP ? 0 : 1)\n+#define BRANCH_COST(speed_p, predictable_p) (TARGET_BRANCH_CHEAP ? 0 : 1)\n \n \n #define COMPARE_FLAG_MODE HImode"}, {"sha": "2d5bbff39abb6e864d600f9f3423c32b3571879e", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -967,7 +967,7 @@ extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n    Set this to 3 on the RS/6000 since that is roughly the average cost of an\n    unscheduled conditional branch.  */\n \n-#define BRANCH_COST 3\n+#define BRANCH_COST(speed_p, predictable_p) 3\n \n /* Override BRANCH_COST heuristic which empirically produces worse\n    performance for removing short circuiting from the logical ops.  */"}, {"sha": "a31efd24a23edd52afdcf9d8199406f73c75ad43", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -828,7 +828,7 @@ extern struct rtx_def *s390_compare_op0, *s390_compare_op1, *s390_compare_emitte\n \n /* A C expression for the cost of a branch instruction.  A value of 1\n    is the default; other values are interpreted relative to that.  */\n-#define BRANCH_COST 1\n+#define BRANCH_COST(speed_p, predictable_p) 1\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS 1"}, {"sha": "d9900a50214b234658ff8a5c66e21b8b925eb6f1", "filename": "gcc/config/score/score.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fscore%2Fscore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fscore%2Fscore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -793,7 +793,7 @@ typedef struct score_args\n   (4 + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))\n \n /* Try to generate sequences that don't involve branches.  */\n-#define BRANCH_COST                     2\n+#define BRANCH_COST(speed_p, predictable_p) 2\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS                1"}, {"sha": "15bc744fd1d0a62bd68a2d3a184dee5d7a5ffcf6", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -2847,7 +2847,8 @@ struct sh_args {\n    The SH1 does not have delay slots, hence we get a pipeline stall\n    at every branch.  The SH4 is superscalar, so the single delay slot\n    is not sufficient to keep both pipelines filled.  */\n-#define BRANCH_COST (TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1)\n+#define BRANCH_COST(speed_p, predictable_p) \\\n+\t(TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1)\n \f\n /* Assembler output control.  */\n "}, {"sha": "de5f52089a3cb6b42dc74f62f824cf10c5d3e65a", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -2196,7 +2196,7 @@ do {                                                                    \\\n    On Niagara-2, a not-taken branch costs 1 cycle whereas a taken\n    branch costs 6 cycles.  */\n \n-#define BRANCH_COST \\\n+#define BRANCH_COST (speed_p, predictable_p) \\\n \t((sparc_cpu == PROCESSOR_V9 \\\n \t  || sparc_cpu == PROCESSOR_ULTRASPARC) \\\n \t ? 7 \\"}, {"sha": "f78eb73c429ddba086c962a148f86601a39a6433", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -434,7 +434,7 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n \f\n /* Costs */\n \n-#define BRANCH_COST spu_branch_cost\n+#define BRANCH_COST(speed_p, predictable_p) spu_branch_cost\n \n #define SLOW_BYTE_ACCESS 0\n "}, {"sha": "005108de34912f1e04af47899438f5fc95be99fa", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -587,7 +587,7 @@ do {\t\t\t\t\t\t\t\\\n \n #define MEMORY_MOVE_COST(M,C,I) (5 + memory_move_secondary_cost (M, C, I))\n \n-#define BRANCH_COST 5\n+#define BRANCH_COST(speed_p, predictable_p) 5\n \n #define SLOW_BYTE_ACCESS 0\n "}, {"sha": "20d781bf27ed8ef6475ad545492eee2711911bb2", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -648,7 +648,7 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    Branches are extremely cheap on the VAX while the shift insns often\n    used to replace branches can be expensive.  */\n \n-#define BRANCH_COST 0\n+#define BRANCH_COST(speed_p, predictable_p) 0\n \f\n /* Tell final.c how to eliminate redundant test instructions.  */\n "}, {"sha": "fecb56996e3f2bc5ba7fbe2befcd39d507154be6", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -887,7 +887,7 @@ typedef struct xtensa_args\n \n #define MEMORY_MOVE_COST(MODE, CLASS, IN) 4\n \n-#define BRANCH_COST 3\n+#define BRANCH_COST(speed_p, predictable_p) 3\n \n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */"}, {"sha": "29b67c72b61264bb72984e7ee4ff07f10d252996", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -6900,6 +6900,10 @@ to the hottest structure frequency in the program is less than this\n parameter, then structure reorganization is not applied to this structure.\n The default is 10.\n \n+@item predictable-branch-cost-outcome\n+When branch is predicted to be taken with probability lower than this threshold\n+(in percent), then it is considered well predictable. The default is 10.\n+\n @item max-crossjump-edges\n The maximum number of incoming edges to consider for crossjumping.\n The algorithm used by @option{-fcrossjumping} is @math{O(N^2)} in"}, {"sha": "2cd0877601d981938a7e634c93a85b640b4f8d8f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -5874,9 +5874,14 @@ value to the result of that function.  The arguments to that function\n are the same as to this macro.\n @end defmac\n \n-@defmac BRANCH_COST\n-A C expression for the cost of a branch instruction.  A value of 1 is\n-the default; other values are interpreted relative to that.\n+@defmac BRANCH_COST (@var{speed_p}, @var{predictable_p})\n+A C expression for the cost of a branch instruction.  A value of 1 is the\n+default; other values are interpreted relative to that. Parameter @var{speed_p}\n+is true when the branch in question should be optimized for speed.  When\n+it is false, @code{BRANCH_COST} should be returning value optimal for code size\n+rather then performance considerations.  @var{predictable_p} is true for well\n+predictable branches. On many architectures the @code{BRANCH_COST} can be\n+reduced then.\n @end defmac\n \n Here are additional macros which do not specify precise relative costs,"}, {"sha": "bee8da0fd032474e3514ff6b363052f7a22179c5", "filename": "gcc/dojump.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -510,7 +510,9 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       /* High branch cost, expand as the bitwise AND of the conditions.\n \t Do the same if the RHS has side effects, because we're effectively\n \t turning a TRUTH_AND_EXPR into a TRUTH_ANDIF_EXPR.  */\n-      if (BRANCH_COST >= 4 || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n+      if (BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t       false) >= 4\n+\t  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \tgoto normal;\n \n     case TRUTH_ANDIF_EXPR:\n@@ -531,7 +533,8 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       /* High branch cost, expand as the bitwise OR of the conditions.\n \t Do the same if the RHS has side effects, because we're effectively\n \t turning a TRUTH_OR_EXPR into a TRUTH_ORIF_EXPR.  */\n-      if (BRANCH_COST >= 4 || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n+      if (BRANCH_COST (optimize_insn_for_speed_p (), false)>= 4\n+\t  || TREE_SIDE_EFFECTS (TREE_OPERAND (exp, 1)))\n \tgoto normal;\n \n     case TRUTH_ORIF_EXPR:"}, {"sha": "399139b97b570fb3205eebd8f37938c0546d112b", "filename": "gcc/expmed.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -3492,7 +3492,7 @@ expand_smod_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n   result = gen_reg_rtx (mode);\n \n   /* Avoid conditional branches when they're expensive.  */\n-  if (BRANCH_COST >= 2\n+  if (BRANCH_COST (optimize_insn_for_speed_p (), false) >= 2\n       && optimize_insn_for_speed_p ())\n     {\n       rtx signmask = emit_store_flag (result, LT, op0, const0_rtx,\n@@ -3592,7 +3592,9 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n   logd = floor_log2 (d);\n   shift = build_int_cst (NULL_TREE, logd);\n \n-  if (d == 2 && BRANCH_COST >= 1)\n+  if (d == 2\n+      && BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t      false) >= 1)\n     {\n       temp = gen_reg_rtx (mode);\n       temp = emit_store_flag (temp, LT, op0, const0_rtx, mode, 0, 1);\n@@ -3602,7 +3604,8 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n     }\n \n #ifdef HAVE_conditional_move\n-  if (BRANCH_COST >= 2)\n+  if (BRANCH_COST (optimize_insn_for_speed_p (), false)\n+      >= 2)\n     {\n       rtx temp2;\n \n@@ -3631,7 +3634,8 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n     }\n #endif\n \n-  if (BRANCH_COST >= 2)\n+  if (BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t   false) >= 2)\n     {\n       int ushift = GET_MODE_BITSIZE (mode) - logd;\n \n@@ -5345,7 +5349,8 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n      comparison with zero.  Don't do any of these cases if branches are\n      very cheap.  */\n \n-  if (BRANCH_COST > 0\n+  if (BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t   false) > 0\n       && GET_MODE_CLASS (mode) == MODE_INT && (code == EQ || code == NE)\n       && op1 != const0_rtx)\n     {\n@@ -5368,10 +5373,12 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n      do LE and GT if branches are expensive since they are expensive on\n      2-operand machines.  */\n \n-  if (BRANCH_COST == 0\n+  if (BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t   false) == 0\n       || GET_MODE_CLASS (mode) != MODE_INT || op1 != const0_rtx\n       || (code != EQ && code != NE\n-\t  && (BRANCH_COST <= 1 || (code != LE && code != GT))))\n+\t  && (BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t\t   false) <= 1 || (code != LE && code != GT))))\n     return 0;\n \n   /* See what we need to return.  We can only return a 1, -1, or the\n@@ -5467,7 +5474,10 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t that \"or\", which is an extra insn, so we only handle EQ if branches\n \t are expensive.  */\n \n-      if (tem == 0 && (code == NE || BRANCH_COST > 1))\n+      if (tem == 0\n+\t  && (code == NE\n+\t      || BRANCH_COST (optimize_insn_for_speed_p (),\n+\t\t      \t      false) > 1))\n \t{\n \t  if (rtx_equal_p (subtarget, op0))\n \t    subtarget = 0;"}, {"sha": "30dbaef103753f7a6425d15d5d67f98cd5c5a422", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* The default branch cost is 1.  */\n #ifndef BRANCH_COST\n-#define BRANCH_COST 1\n+#define BRANCH_COST(speed_p, predictable_p) 1\n #endif\n \n /* This is the 4th arg to `expand_expr'."}, {"sha": "ae66ad4ee2daa01bf1fe53874f14ee52d6067e2d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -5109,7 +5109,9 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \n \f\n #ifndef LOGICAL_OP_NON_SHORT_CIRCUIT\n-#define LOGICAL_OP_NON_SHORT_CIRCUIT (BRANCH_COST >= 2)\n+#define LOGICAL_OP_NON_SHORT_CIRCUIT \\\n+  (BRANCH_COST (!cfun || optimize_function_for_speed_p (cfun), \\\n+\t\tfalse) >= 2)\n #endif\n \n /* EXP is some logical combination of boolean tests.  See if we can\n@@ -5357,7 +5359,8 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n      that can be merged.  Avoid doing this if the RHS is a floating-point\n      comparison since those can trap.  */\n \n-  if (BRANCH_COST >= 2\n+  if (BRANCH_COST (!cfun || optimize_function_for_speed_p (cfun),\n+\t\t   false) >= 2\n       && ! FLOAT_TYPE_P (TREE_TYPE (rl_arg))\n       && simple_operand_p (rl_arg)\n       && simple_operand_p (rr_arg))"}, {"sha": "51fc48c604345b60dca354f12b8926eba45eda9b", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -67,7 +67,9 @@\n #endif\n \n #ifndef MAX_CONDITIONAL_EXECUTE\n-#define MAX_CONDITIONAL_EXECUTE   (BRANCH_COST + 1)\n+#define MAX_CONDITIONAL_EXECUTE \\\n+  (BRANCH_COST (optimize_function_for_speed_p (cfun), false) \\\n+   + 1)\n #endif\n \n #define IFCVT_MULTIPLE_DUMPS 1\n@@ -626,6 +628,9 @@ struct noce_if_info\n      from TEST_BB.  For the noce transformations, we allow the symmetric\n      form as well.  */\n   bool then_else_reversed;\n+\n+  /* Estimated cost of the particular branch instruction.  */\n+  int branch_cost;\n };\n \n static rtx noce_emit_store_flag (struct noce_if_info *, rtx, int, int);\n@@ -963,20 +968,20 @@ noce_try_store_flag_constants (struct noce_if_info *if_info)\n \tnormalize = 0;\n       else if (ifalse == 0 && exact_log2 (itrue) >= 0\n \t       && (STORE_FLAG_VALUE == 1\n-\t\t   || BRANCH_COST >= 2))\n+\t\t   || if_info->branch_cost >= 2))\n \tnormalize = 1;\n       else if (itrue == 0 && exact_log2 (ifalse) >= 0 && can_reverse\n-\t       && (STORE_FLAG_VALUE == 1 || BRANCH_COST >= 2))\n+\t       && (STORE_FLAG_VALUE == 1 || if_info->branch_cost >= 2))\n \tnormalize = 1, reversep = 1;\n       else if (itrue == -1\n \t       && (STORE_FLAG_VALUE == -1\n-\t\t   || BRANCH_COST >= 2))\n+\t\t   || if_info->branch_cost >= 2))\n \tnormalize = -1;\n       else if (ifalse == -1 && can_reverse\n-\t       && (STORE_FLAG_VALUE == -1 || BRANCH_COST >= 2))\n+\t       && (STORE_FLAG_VALUE == -1 || if_info->branch_cost >= 2))\n \tnormalize = -1, reversep = 1;\n-      else if ((BRANCH_COST >= 2 && STORE_FLAG_VALUE == -1)\n-\t       || BRANCH_COST >= 3)\n+      else if ((if_info->branch_cost >= 2 && STORE_FLAG_VALUE == -1)\n+\t       || if_info->branch_cost >= 3)\n \tnormalize = -1;\n       else\n \treturn FALSE;\n@@ -1107,7 +1112,7 @@ noce_try_addcc (struct noce_if_info *if_info)\n \n       /* If that fails, construct conditional increment or decrement using\n \t setcc.  */\n-      if (BRANCH_COST >= 2\n+      if (if_info->branch_cost >= 2\n \t  && (XEXP (if_info->a, 1) == const1_rtx\n \t      || XEXP (if_info->a, 1) == constm1_rtx))\n         {\n@@ -1158,7 +1163,7 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n   int reversep;\n \n   reversep = 0;\n-  if ((BRANCH_COST >= 2\n+  if ((if_info->branch_cost >= 2\n        || STORE_FLAG_VALUE == -1)\n       && ((if_info->a == const0_rtx\n \t   && rtx_equal_p (if_info->b, if_info->x))\n@@ -1317,7 +1322,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   /* ??? FIXME: Magic number 5.  */\n   if (cse_not_expected\n       && MEM_P (a) && MEM_P (b)\n-      && BRANCH_COST >= 5)\n+      && if_info->branch_cost >= 5)\n     {\n       a = XEXP (a, 0);\n       b = XEXP (b, 0);\n@@ -1347,7 +1352,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   if (insn_a)\n     {\n       insn_cost = insn_rtx_cost (PATTERN (insn_a));\n-      if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (BRANCH_COST))\n+      if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n \treturn FALSE;\n     }\n   else\n@@ -1356,7 +1361,7 @@ noce_try_cmove_arith (struct noce_if_info *if_info)\n   if (insn_b)\n     {\n       insn_cost += insn_rtx_cost (PATTERN (insn_b));\n-      if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (BRANCH_COST))\n+      if (insn_cost == 0 || insn_cost > COSTS_N_INSNS (if_info->branch_cost))\n         return FALSE;\n     }\n \n@@ -2831,6 +2836,8 @@ noce_find_if_block (basic_block test_bb,\n   if_info.cond_earliest = cond_earliest;\n   if_info.jump = jump;\n   if_info.then_else_reversed = then_else_reversed;\n+  if_info.branch_cost = BRANCH_COST (optimize_bb_for_speed_p (test_bb),\n+\t\t\t\t     predictable_edge_p (then_edge));\n \n   /* Do the real work.  */\n \n@@ -3597,7 +3604,9 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, then_bb->index);\n \n   /* THEN is small.  */\n-  if (! cheap_bb_rtx_cost_p (then_bb, COSTS_N_INSNS (BRANCH_COST)))\n+  if (! cheap_bb_rtx_cost_p (then_bb,\n+\tCOSTS_N_INSNS (BRANCH_COST (optimize_bb_for_speed_p (then_edge->src),\n+\t\t\t\t    predictable_edge_p (then_edge)))))\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */\n@@ -3711,7 +3720,9 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n \t     test_bb->index, else_bb->index);\n \n   /* ELSE is small.  */\n-  if (! cheap_bb_rtx_cost_p (else_bb, COSTS_N_INSNS (BRANCH_COST)))\n+  if (! cheap_bb_rtx_cost_p (else_bb, \n+\tCOSTS_N_INSNS (BRANCH_COST (optimize_bb_for_speed_p (else_edge->src),\n+\t\t\t\t    predictable_edge_p (else_edge)))))\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */"}, {"sha": "0c3b9caeed5381a8bf75226f2a102e0759f89edd", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -3443,7 +3443,9 @@ expand_abs_nojump (enum machine_mode mode, rtx op0, rtx target,\n      value of X as (((signed) x >> (W-1)) ^ x) - ((signed) x >> (W-1)),\n      where W is the width of MODE.  */\n \n-  if (GET_MODE_CLASS (mode) == MODE_INT && BRANCH_COST >= 2)\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      && BRANCH_COST (optimize_insn_for_speed_p (),\n+\t      \t      false) >= 2)\n     {\n       rtx extended = expand_shift (RSHIFT_EXPR, mode, op0,\n \t\t\t\t   size_int (GET_MODE_BITSIZE (mode) - 1),"}, {"sha": "5e9a664208fb08bc4c74060f095929c9834c7ced", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -78,6 +78,13 @@ DEFPARAM (PARAM_STRUCT_REORG_COLD_STRUCT_RATIO,\n \t  \"The threshold ratio between current and hottest structure counts\",\n \t  10, 0, 100)\n \n+/* When branch is predicted to be taken with probability lower than this\n+   threshold (in percent), then it is considered well predictable. */\n+DEFPARAM (PARAM_PREDICTABLE_BRANCH_OUTCOME,\n+\t  \"predictable-branch-outcome\",\n+\t  \"Maximal esitmated outcome of branch considered predictable\",\n+\t  2, 0, 50)\n+\n /* The single function inlining limit. This is the maximum size\n    of a function counted in internal gcc instructions (not in\n    real machine instructions) that is eligible for inlining"}, {"sha": "6ca1a0cddc2516a1f81e3c39a6b1568b8cee1f64", "filename": "gcc/predict.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a4fd356e0e9cda6a66a3a0af9ecb6600669265c/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=3a4fd356e0e9cda6a66a3a0af9ecb6600669265c", "patch": "@@ -318,6 +318,23 @@ optimize_loop_nest_for_size_p (struct loop *loop)\n   return !optimize_loop_nest_for_speed_p (loop);\n }\n \n+/* Return true when edge E is likely to be well predictable by branch\n+   predictor.  */\n+\n+bool\n+predictable_edge_p (edge e)\n+{\n+  if (profile_status == PROFILE_ABSENT)\n+    return false;\n+  if ((e->probability\n+       <= PARAM_VALUE (PARAM_PREDICTABLE_BRANCH_OUTCOME) * REG_BR_PROB_BASE / 100)\n+      || (REG_BR_PROB_BASE - e->probability\n+          <= PARAM_VALUE (PARAM_PREDICTABLE_BRANCH_OUTCOME) * REG_BR_PROB_BASE / 100))\n+    return true;\n+  return false;\n+}\n+\n+\n /* Set RTL expansion for BB profile.  */\n \n void"}]}