{"sha": "2822d96ec195c0189edb31e25a64943a3f95b962", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgyMmQ5NmVjMTk1YzAxODllZGIzMWUyNWE2NDk0M2EzZjk1Yjk2Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-04-01T06:09:25Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-04-01T06:09:25Z"}, "message": "pa.h (ASM_OUTPUT_LABEL): TARGET_GAS no longer needs trailing colons.\n\n        * pa.h (ASM_OUTPUT_LABEL): TARGET_GAS no longer needs trailing colons.\n        (ASM_OUTPUT_INTERNAL_LABEL, ASM_OUTPUT_COMMON): Likewise.\n\n        * pa.h (TARGET_PORTABLE_RUNTIME): Define.\n        (TARGET_SWITCHES): Add -mportable-runtime and -mno-portable-runtime.\n        (CUMULATIVE_ARGS): Now a \"struct hppa_args\" rathern than an int.\n        All references changed.\n        (INIT_CUMULATIVE_ARGS): Also initialize nargs_prototype.\n        (INIT_CUMULATIVE_INCOMING_ARGS): Define.\n        (FUNCTION_ARG_ADVANCE): Decrement nargs_prototype for each arg seen.\n        (FUNCTION_ARG): Handle TARGET_PORTABLE_RUNTIME.\n        (ASM_DECLARE_FUNCTION_NAME): Explicitly disallow argument relocations\n        for TARGET_PORTABLE_RUNTIME.\n        (ASM_OUTPUT_INT): Do not use a P% prefix for function references\n        if TARGET_PORTABLE_RUNTIME.\n\n        * pa.md (high and lo_sum for function addresses): Provide alternate\n        definitions for TARGET_PORTABLE_RUNTIME.\n\n        * pa.c (output_arg_descriptor): Explicitly disallow argument\n        relocations for TARGET_PORTABLE_RUNTIME.\n\nFrom-SVN: r6954", "tree": {"sha": "cf47641a8bfd1dc8a5f6723bdc5ba70fa94c6dce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf47641a8bfd1dc8a5f6723bdc5ba70fa94c6dce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2822d96ec195c0189edb31e25a64943a3f95b962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2822d96ec195c0189edb31e25a64943a3f95b962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2822d96ec195c0189edb31e25a64943a3f95b962", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2822d96ec195c0189edb31e25a64943a3f95b962/comments", "author": null, "committer": null, "parents": [{"sha": "7848c2783d4976eb2c1aeb4187b45e44cb7ef978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7848c2783d4976eb2c1aeb4187b45e44cb7ef978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7848c2783d4976eb2c1aeb4187b45e44cb7ef978"}], "stats": {"total": 179, "additions": 139, "deletions": 40}, "files": [{"sha": "afc73368341f76d8384ceda8f978e93cc0ac8e23", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2822d96ec195c0189edb31e25a64943a3f95b962/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2822d96ec195c0189edb31e25a64943a3f95b962/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=2822d96ec195c0189edb31e25a64943a3f95b962", "patch": "@@ -3176,6 +3176,15 @@ output_arg_descriptor (insn)\n   for (i = 0; i < 4; i++)\n     arg_regs[i] = 0;\n \n+  /* Specify explicitly that no argument relocations should take place\n+     if using the portable runtime calling conventions.  */\n+  if (TARGET_PORTABLE_RUNTIME)\n+    {\n+      fprintf (asm_out_file,\n+\t       \"\\t.CALL ARGW0=NO,ARGW1=NO,ARGW2=NO,ARGW3=NO,RETVAL=NO\\n\");\n+      return;\n+    }\n+\n   for (prev_insn = PREV_INSN (insn); GET_CODE (prev_insn) == INSN;\n        prev_insn = PREV_INSN (prev_insn))\n     {"}, {"sha": "512efb118852f780d66fae26a585f59dabda02d7", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 108, "deletions": 38, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2822d96ec195c0189edb31e25a64943a3f95b962/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2822d96ec195c0189edb31e25a64943a3f95b962/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=2822d96ec195c0189edb31e25a64943a3f95b962", "patch": "@@ -62,12 +62,15 @@ extern int target_flags;\n \n #define TARGET_DISABLE_INDEXING (target_flags & 32)\n \n+/* Emit code which follows the new portable runtime calling conventions\n+   HP wants everyone to use for ELF objects.  If at all possible you want\n+   to avoid this since it's a performance loss for non-prototyped code.  */\n+\n+#define TARGET_PORTABLE_RUNTIME (target_flags & 64)\n+\n /* Emit directives only understood by GAS.  This allows parameter\n    relocations to work for static functions.  There is no way\n-   to make them work the HP assembler at this time.\n-\n-   Also forces a colon to be tacked onto the end of local and\n-   global labes.  */\n+   to make them work the HP assembler at this time.  */\n \n #define TARGET_GAS (target_flags & 128)\n \n@@ -90,6 +93,8 @@ extern int target_flags;\n    {\"no-long-calls\", -16},\t\\\n    {\"disable-indexing\", 32},\t\\\n    {\"no-disable-indexing\", -32},\\\n+   {\"portable-runtime\", 64},\t\\\n+   {\"no-portable-runtime\", -64},\\\n    {\"gas\", 128},\t\t\\\n    {\"no-gas\", -128},\t\t\\\n    { \"\", TARGET_DEFAULT}}\n@@ -781,14 +786,30 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    if any, which holds the structure-value-address).\n    Thus 4 or more means all following args should go on the stack.  */\n \n-#define CUMULATIVE_ARGS int\n+struct hppa_args {int words, nargs_prototype; };\n+\n+#define CUMULATIVE_ARGS struct hppa_args\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-*/\n+   For a library call, FNTYPE is 0.  */\n \n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) ((CUM) = 0)\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) \\\n+  (CUM).words = 0, \t\t\t\t\t\t\t\\\n+  (CUM).nargs_prototype = (FNTYPE && TYPE_ARG_TYPES (FNTYPE)\t\t\\\n+\t\t\t   ? (list_length (TYPE_ARG_TYPES (FNTYPE)) - 1\t\\\n+\t\t\t      + (TYPE_MODE (TREE_TYPE (FNTYPE)) == BLKmode \\\n+\t\t\t\t || RETURN_IN_MEMORY (TREE_TYPE (FNTYPE)))) \\\n+\t\t\t   : 0)\n+\n+\n+\n+/* Similar, but when scanning the definition of a procedure.  We always\n+   set NARGS_PROTOTYPE large so we never return an EXPR_LIST.  */\n+\n+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM,FNTYPE,IGNORE) \\\n+  (CUM).words = 0,\t\t\t\t\\\n+  (CUM).nargs_prototype = 1000\n \n /* Figure out the size in words of the function argument. */\n \n@@ -800,8 +821,12 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-    (((((CUM) & 01) && (TYPE) != 0 && FUNCTION_ARG_SIZE(MODE, TYPE) > 1)\\\n-      && (CUM)++), (CUM) += FUNCTION_ARG_SIZE(MODE, TYPE))\n+{ (CUM).nargs_prototype--;\t\t\t\t\t\t\\\n+  ((((CUM).words & 01) && (TYPE) != 0\t\t\t\t\t\\\n+    && FUNCTION_ARG_SIZE(MODE, TYPE) > 1)\t\t\t\t\\\n+   && (CUM).words++),\t\t\t\t\t\t\t\\\n+     (CUM).words += FUNCTION_ARG_SIZE(MODE, TYPE);\t\t\t\\\n+}\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -814,9 +839,9 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    CUM is a variable of type CUMULATIVE_ARGS which gives info about\n     the preceding args and about the function being called.\n    NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n+    (otherwise it is an extra parameter matching an ellipsis).\n \n-/* On the HP-PA the first four words of args are normally in registers\n+   On the HP-PA the first four words of args are normally in registers\n    and the rest are pushed.  But any arg that won't entirely fit in regs\n    is pushed.\n \n@@ -825,24 +850,72 @@ enum reg_class { NO_REGS, R1_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n    The caller must make a distinction between calls to explicitly named\n    functions and calls through pointers to functions -- the conventions\n    are different!  Calls through pointers to functions only use general\n-   registers for the first four argument words.  */\n+   registers for the first four argument words.\n \n+   Of course all this is different for the portable runtime model\n+   HP wants everyone to use for ELF.  Ugh.  Here's a quick description\n+   of how it's supposed to work.\n+\n+   1) callee side remains unchanged.  It expects integer args to be\n+   in the integer registers, float args in the float registers and\n+   unnamed args in integer registers.\n+\n+   2) caller side now depends on if the function being called has\n+   a prototype in scope (rather than if it's being called indirectly).\n+\n+      2a) If there is a prototype in scope, then arguments are passed\n+      according to their type (ints in integer registers, floats in float\n+      registers, unnamed args in integer registers.\n+\n+      2b) If there is no prototype in scope, then floating point arguments\n+      are passed in both integer and float registers.  egad.\n+\n+  FYI: The portable parameter passing conventions are almost exactly like\n+  the standard parameter passing conventions on the RS6000.  That's why\n+  you'll see lots of similar code in rs6000.h.  */\n+  \n #define FUNCTION_ARG_PADDING(MODE, TYPE) function_arg_padding ((MODE), (TYPE))\n \n+/* Do not expect to understand this without reading it several times.  I'm\n+   tempted to try and simply it, but I worry about breaking something.  */\n+\n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t      \t\t\\\n-  (4 >= ((CUM) + FUNCTION_ARG_SIZE ((MODE), (TYPE)))\t\t\t\\\n-   ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t      (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\t\\\n-\t       ? ((! current_call_is_indirect\t\t\t\t\\\n-\t\t   && (MODE) == DFmode)\t\t\t\t\t\\\n-\t\t  ? ((CUM) ? (TARGET_SNAKE ? 50 : 35)\t\t\t\\\n-\t\t     : (TARGET_SNAKE ? 46 : 33))\t\t\t\\\n-\t\t  : ((CUM) ? 23 : 25))\t\t\t\t\t\\\n-\t       : ((! current_call_is_indirect\t\t\t\t\\\n-\t\t   && (MODE) == SFmode)\t\t\t\t\t\\\n-\t\t  ? (TARGET_SNAKE ? 44 + 2 * (CUM) : 32  + (CUM))\t\\\n-\t\t  : (27 - (CUM) - FUNCTION_ARG_SIZE ((MODE), (TYPE))))))\\\n-   : 0)\n+  (4 >= ((CUM).words + FUNCTION_ARG_SIZE ((MODE), (TYPE)))\t\t\\\n+   ? (!TARGET_PORTABLE_RUNTIME || (TYPE) == 0\t\t\t\t\\\n+      || !FLOAT_MODE_P (MODE) || (CUM).nargs_prototype > 0)\t\t\\\n+      ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n+\t\t (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n+\t\t  ? (((!current_call_is_indirect || TARGET_PORTABLE_RUNTIME) \\\n+\t\t      && (MODE) == DFmode)\t\t\t\t\\\n+\t\t     ? ((CUM).words\t\t\t\t\t\\\n+\t\t\t? (TARGET_SNAKE ? 50 : 35) \t\t\t\\\n+\t\t\t: (TARGET_SNAKE ? 46 : 33))\t\t\t\\\n+\t\t     : ((CUM).words ? 23 : 25))\t\t\t\t\\\n+\t\t  : (((!current_call_is_indirect || TARGET_PORTABLE_RUNTIME) \\\n+\t\t      && (MODE) == SFmode)\t\t\t\t\\\n+\t\t     ? (TARGET_SNAKE\t\t\t\t\t\\\n+\t\t\t? 44 + 2 * (CUM).words\t\t\t\t\\\n+\t\t\t: 32  + (CUM).words)\t\t\t\t\\\n+\t\t     : (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\t\\\n+\t\t\t\t\t\t\t      (TYPE))))))\\\n+   /* We are calling a non-prototyped function with floating point\t\\\n+      arguments using the portable conventions.  */\t\t\t\\\n+   : gen_rtx (EXPR_LIST, VOIDmode,\t\t\t\t\t\\\n+\t      gen_rtx (REG, (MODE),\t\t\t\t\t\\\n+\t\t       (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n+\t\t\t? ((CUM).words\t\t\t\t\t\\\n+\t\t\t   ? (TARGET_SNAKE ? 50 : 35)\t\t\t\\\n+\t\t\t   : (TARGET_SNAKE ? 46 : 33))\t\t\t\\\n+\t\t\t: (TARGET_SNAKE\t\t\t\t\t\\\n+\t\t\t   ? 44 + 2 * (CUM).words\t\t\t\\\n+\t\t\t   : 32 + (CUM).words))),\t\t\t\\\n+\t      gen_rtx (REG, (MODE),\t\t\t\t\t\\\n+\t\t       (FUNCTION_ARG_SIZE ((MODE), (TYPE)) > 1\t\t\\\n+\t\t\t? ((CUM).words ? 23 : 25)\t\t\t\\\n+\t\t\t: (27 - (CUM).words - FUNCTION_ARG_SIZE ((MODE),\\\n+\t\t\t\t\t\t\t\t (TYPE)))))) \\\n+  /* Pass this parameter in the stack.  */\t\t\t\t\\\n+  : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n    this is the number of registers used.\n@@ -898,6 +971,12 @@ extern enum cmp_type hppa_branch_type;\n \t\t fputs (\"\\t.PARAM \", FILE);\t\t\t\t\\\n \t\t assemble_name (FILE, NAME);\t\t\t\t\\\n \t       }\t\t\t\t\t\t\t\\\n+\t     if (TARGET_PORTABLE_RUNTIME)\t\t\t\t\\\n+\t       {\t\t\t\t\t\t\t\\\n+\t\t fputs (\"ARGW0=NO,ARGW1=NO,ARGW2=NO,ARGW3=NO,\", FILE);\t\\\n+\t\t fputs (\"RTNVAL=NO\\n\", FILE);\t\t\t\t\\\n+\t\t break;\t\t\t\t\t\t\t\\\n+\t       }\t\t\t\t\t\t\t\\\n \t     for (parm = DECL_ARGUMENTS (DECL), i = 0; parm && i < 4;\t\\\n \t\t  parm = TREE_CHAIN (parm))\t\t\t\t\\\n \t       {\t\t\t\t\t\t\t\\\n@@ -1688,8 +1767,6 @@ readonly_data ()\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n   do { assemble_name (FILE, NAME); \t\\\n-       if (TARGET_GAS)\t\t\t\\\n-\t fputc (':', FILE);\t\t\\\n        fputc ('\\n', FILE); } while (0)\n \n /* This is how to output a command to make the user-level label named NAME\n@@ -1749,11 +1826,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n    PREFIX is the class of label and NUM is the number within the class.  */\n \n #define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  {fprintf (FILE, \"%c$%s%04d\", (PREFIX)[0], (PREFIX) + 1, NUM);\\\n-   if (TARGET_GAS)\t\t\t\t\t\\\n-     fputs (\":\\n\", FILE);\t\t\t\t\\\n-   else\t\t\t\t\t\t\t\\\n-     fputs (\"\\n\", FILE);}\n+  {fprintf (FILE, \"%c$%s%04d\\n\", (PREFIX)[0], (PREFIX) + 1, NUM);}\n \n /* This is how to store into the string LABEL\n    the symbol_ref name of an internal numbered label where\n@@ -1784,7 +1857,8 @@ readonly_data ()\t\t\t\t\t\t\t\\\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n { fprintf (FILE, \"\\t.word \");\t\t\t\\\n-  if (function_label_operand (VALUE, VOIDmode))\t\\\n+  if (function_label_operand (VALUE, VOIDmode)\t\\\n+      && !TARGET_PORTABLE_RUNTIME)\t\t\\\n     fprintf (FILE, \"P%%\");\t\t\t\\\n   output_addr_const (FILE, (VALUE));\t\t\\\n   fprintf (FILE, \"\\n\");}\n@@ -1850,8 +1924,6 @@ readonly_data ()\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n { bss_section ();\t\t\t\t\t\\\n   assemble_name ((FILE), (NAME));\t\t\t\\\n-  if (TARGET_GAS) \t\t\t\t\t\\\n-    fputc (':', (FILE));\t\t\t\t\\\n   fputs (\"\\t.comm \", (FILE));\t\t\t\t\\\n   fprintf ((FILE), \"%d\\n\", (ROUNDED));}\n \n@@ -1862,8 +1934,6 @@ readonly_data ()\t\t\t\t\t\t\t\\\n { bss_section ();\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\t.align %d\\n\", (SIZE) <= 4 ? 4 : 8);\t\\\n   assemble_name ((FILE), (NAME));\t\t\t\t\\\n-  if (TARGET_GAS) \t\t\t\t\t\\\n-    fputc (':', (FILE));\t\t\t\t\\\n   fprintf ((FILE), \"\\n\\t.block %d\\n\", (ROUNDED));}\n \n /* Store in OUTPUT a string (made with alloca) containing"}, {"sha": "8d8c236b5f99bd2356c872b25bd943c27169b868", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2822d96ec195c0189edb31e25a64943a3f95b962/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2822d96ec195c0189edb31e25a64943a3f95b962/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=2822d96ec195c0189edb31e25a64943a3f95b962", "patch": "@@ -1174,11 +1174,21 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand:SI 1 \"function_label_operand\" \"\")))]\n-  \"\"\n+  \"!TARGET_PORTABLE_RUNTIME\"\n   \"ldil LP'%G1,%0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"4\")])\n \n+;; This version is used only for the portable runtime conventions model\n+;; (it does not use/support plabels)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(high:SI (match_operand:SI 1 \"function_label_operand\" \"\")))]\n+  \"TARGET_PORTABLE_RUNTIME\"\n+  \"ldil L'%G1,%0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n@@ -1197,10 +1207,20 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))]\n-  \"\"\n+  \"!TARGET_PORTABLE_RUNTIME\"\n   \"ldo RP'%G2(%1),%0\"\n   [(set_attr \"length\" \"4\")])\n \n+;; This version is used only for the portable runtime conventions model\n+;; (it does not use/support plabels)\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"function_label_operand\" \"\")))]\n+  \"TARGET_PORTABLE_RUNTIME\"\n+  \"ldo R'%G2(%1),%0\"\n+  [(set_attr \"length\" \"4\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")"}]}