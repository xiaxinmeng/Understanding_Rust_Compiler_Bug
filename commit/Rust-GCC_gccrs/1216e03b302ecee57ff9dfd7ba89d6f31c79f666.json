{"sha": "1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIxNmUwM2IzMDJlY2VlNTdmZjlkZmQ3YmE4OWQ2ZjMxYzc5ZjY2Ng==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-18T05:51:50Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-09-18T05:51:50Z"}, "message": "[multiple changes]\n\n2003-09-18  Dalibor Topic  <robilad@kaffe.org>\n\n\t* gnu/java/rmi/rmic/Compile_gcj.java (COMPILER_ARGS): New private\n\tconstant.\n\t(computeArguments): use computeTypicalArguments.\n\n\t* gnu/java/rmi/rmic/Makefile.am (EXTRA_DIST): Add Compile_kjc.java,\n\tCompile_jikes.java and RMICException.java.\n\t* gnu/java/rmi/rmic/Compile_kjc.java: New file.\n\t* gnu/java/rmi/rmic/Compile_jikes.java: Likewise.\n\t* gnu/java/rmi/rmic/RMICException.java: Likewise.\n\n\t* gnu/java/rmi/rmic/Compiler.java (getDestination): New method.\n\n\t* gnu/java/rmi/rmic/CompilerProcess.java: Import java.io.InputStream.\n\t(computeTypicalArguments): New method.\n\t(compile): Print compiler output to System.out. Collect compiler\n\terror output and use it in exception message.\n\n\t* gnu/java/rmi/rmic/RMIC.java: Import java.util.Set.\n\t(destination): Initialize to null.\n\t(run): Replace file separator with '.' when processing class.\n\t(processClass): Replace '.' with file separator when compiling\n\tclasses.\n\t(findClass): Use SystemClassLoader to load class.\n\t(generateStub): Use full class name for generated stub, that puts\n\tit in right path.  Replace '.' with file separator when generating\n\tstub file name. Write just the stub class name without package\n\tinformation as class name, and constructor name. Write only\n\tinterface names for interfaces extending java.rmi.Remote as\n\timplemented.\n\t(generateSkel): Use full class name for generated skel, that puts\n\tit in right path.  Replace '.' with file separator when generating\n\tstub file name. Write just the stub class name without package\n\tinformation as class name.\n\n2003-09-18  Michael Koch  <konqueror@gmx.de>\n\n\t* Makefile.am (rmi_java_source_files):\n\tAdded gnu/java/rmi/rmic/Compile_kjc.java,\n\tgnu/java/rmi/rmic/Compile_jikes.java and\n\tgnu/java/rmi/rmic/RMICException.java\n\t* Makefile.in: Regenerated.\n\nFrom-SVN: r71506", "tree": {"sha": "c58420be4f99acca513d1dd1c884e775323b87f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c58420be4f99acca513d1dd1c884e775323b87f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/comments", "author": null, "committer": null, "parents": [{"sha": "feb297fe3be5cc9a64e281b2f02db9805c14d58a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb297fe3be5cc9a64e281b2f02db9805c14d58a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb297fe3be5cc9a64e281b2f02db9805c14d58a"}], "stats": {"total": 483, "additions": 419, "deletions": 64}, "files": [{"sha": "d1a1a6d664b090a0a27c9d3b04fc757d36248cc6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1,3 +1,47 @@\n+2003-09-18  Dalibor Topic  <robilad@kaffe.org>\n+\n+\t* gnu/java/rmi/rmic/Compile_gcj.java (COMPILER_ARGS): New private\n+\tconstant.\n+\t(computeArguments): use computeTypicalArguments.\n+\n+\t* gnu/java/rmi/rmic/Makefile.am (EXTRA_DIST): Add Compile_kjc.java,\n+\tCompile_jikes.java and RMICException.java.\n+\t* gnu/java/rmi/rmic/Compile_kjc.java: New file.\n+\t* gnu/java/rmi/rmic/Compile_jikes.java: Likewise.\n+\t* gnu/java/rmi/rmic/RMICException.java: Likewise.\n+ \n+\t* gnu/java/rmi/rmic/Compiler.java (getDestination): New method.\n+ \n+\t* gnu/java/rmi/rmic/CompilerProcess.java: Import java.io.InputStream.\n+\t(computeTypicalArguments): New method.\n+\t(compile): Print compiler output to System.out. Collect compiler\n+\terror output and use it in exception message.\n+ \n+\t* gnu/java/rmi/rmic/RMIC.java: Import java.util.Set.\n+\t(destination): Initialize to null.\n+\t(run): Replace file separator with '.' when processing class.\n+\t(processClass): Replace '.' with file separator when compiling\n+\tclasses.\n+\t(findClass): Use SystemClassLoader to load class.\n+\t(generateStub): Use full class name for generated stub, that puts\n+\tit in right path.  Replace '.' with file separator when generating\n+\tstub file name. Write just the stub class name without package\n+\tinformation as class name, and constructor name. Write only\n+\tinterface names for interfaces extending java.rmi.Remote as\n+\timplemented.\n+\t(generateSkel): Use full class name for generated skel, that puts\n+\tit in right path.  Replace '.' with file separator when generating\n+\tstub file name. Write just the stub class name without package\n+\tinformation as class name.\n+\n+2003-09-18  Michael Koch  <konqueror@gmx.de>\n+\n+\t* Makefile.am (rmi_java_source_files):\n+\tAdded gnu/java/rmi/rmic/Compile_kjc.java,\n+\tgnu/java/rmi/rmic/Compile_jikes.java and\n+\tgnu/java/rmi/rmic/RMICException.java\n+\t* Makefile.in: Regenerated.\n+\n 2003-09-17  Graydon Hoare  <graydon@redhat.com>\n \n \t* gnu/java/awt/peer/gtk/GdkGraphics2D.java,"}, {"sha": "60261208df719d3a158b0020417294ea94d829bf", "filename": "libjava/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1580,9 +1580,12 @@ gnu/java/rmi/registry/RegistryImpl.java\t\\\n gnu/java/rmi/registry/RegistryImpl_Skel.java \\\n gnu/java/rmi/registry/RegistryImpl_Stub.java \\\n gnu/java/rmi/rmic/Compile_gcj.java \\\n+gnu/java/rmi/rmic/Compile_jikes.java \\\n+gnu/java/rmi/rmic/Compile_kjc.java \\\n gnu/java/rmi/rmic/Compiler.java\t\\\n gnu/java/rmi/rmic/CompilerProcess.java \\\n gnu/java/rmi/rmic/RMIC.java \\\n+gnu/java/rmi/rmic/RMICException.java \\\n gnu/java/rmi/rmic/TabbedWriter.java \\\n gnu/java/rmi/server/ConnectionRunnerPool.java \\\n gnu/java/rmi/server/ProtocolConstants.java \\"}, {"sha": "613eb087d9019f1ec95e6c8dda494922bcc3d2e7", "filename": "libjava/Makefile.in", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1315,9 +1315,12 @@ gnu/java/rmi/registry/RegistryImpl.java\t\\\n gnu/java/rmi/registry/RegistryImpl_Skel.java \\\n gnu/java/rmi/registry/RegistryImpl_Stub.java \\\n gnu/java/rmi/rmic/Compile_gcj.java \\\n+gnu/java/rmi/rmic/Compile_jikes.java \\\n+gnu/java/rmi/rmic/Compile_kjc.java \\\n gnu/java/rmi/rmic/Compiler.java\t\\\n gnu/java/rmi/rmic/CompilerProcess.java \\\n gnu/java/rmi/rmic/RMIC.java \\\n+gnu/java/rmi/rmic/RMICException.java \\\n gnu/java/rmi/rmic/TabbedWriter.java \\\n gnu/java/rmi/server/ConnectionRunnerPool.java \\\n gnu/java/rmi/server/ProtocolConstants.java \\\n@@ -2705,13 +2708,14 @@ LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n DATA =  $(jar_DATA) $(pkgconfig_DATA) $(toolexecmainlib_DATA)\n \n DIST_COMMON =  README COPYING ChangeLog Makefile.am Makefile.in NEWS \\\n-THANKS acinclude.m4 aclocal.m4 configure configure.in \\\n-libgcj-test.spec.in libgcj.pc.in libgcj.spec.in\n+THANKS acinclude.m4 aclocal.m4 config.guess config.sub configure \\\n+configure.in install-sh libgcj-test.spec.in libgcj.pc.in libgcj.spec.in \\\n+ltmain.sh missing mkinstalldirs\n \n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -3040,9 +3044,12 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/rmi/registry/RegistryImpl_Skel.P \\\n .deps/gnu/java/rmi/registry/RegistryImpl_Stub.P \\\n .deps/gnu/java/rmi/rmic/Compile_gcj.P \\\n+.deps/gnu/java/rmi/rmic/Compile_jikes.P \\\n+.deps/gnu/java/rmi/rmic/Compile_kjc.P \\\n .deps/gnu/java/rmi/rmic/Compiler.P \\\n .deps/gnu/java/rmi/rmic/CompilerProcess.P \\\n-.deps/gnu/java/rmi/rmic/RMIC.P .deps/gnu/java/rmi/rmic/TabbedWriter.P \\\n+.deps/gnu/java/rmi/rmic/RMIC.P .deps/gnu/java/rmi/rmic/RMICException.P \\\n+.deps/gnu/java/rmi/rmic/TabbedWriter.P \\\n .deps/gnu/java/rmi/server/ConnectionRunnerPool.P \\\n .deps/gnu/java/rmi/server/ProtocolConstants.P \\\n .deps/gnu/java/rmi/server/RMIDefaultSocketFactory.P \\"}, {"sha": "ff7924e3d8287197520ffd7e4c7d72b02193ef2f", "filename": "libjava/gnu/java/rmi/rmic/Compile_gcj.java", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_gcj.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_gcj.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_gcj.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 2001 Free Software Foundation, Inc.\n+  Copyright (c) 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -40,21 +40,16 @@\n /** Subclass of Compiler that can be used to invoke gcj.  */\n public class Compile_gcj extends CompilerProcess\n {\n+  private static final String [] COMPILER_ARGS = \n+  {\n+    \"gcj\",\n+    \"-C\"\n+  };\n+\n   public String[] computeArguments (String filename)\n   {\n-    int len = 3 + (dest == null ? 0 : 2);\n-    String[] result = new String[len];\n-    int i = 0;\n-\n-    result[i++] = \"gcj\";\n-    result[i++] = \"-C\";\n-    if (dest != null)\n-      {\n-\tresult[i++] = \"-d\";\n-\tresult[i++] = dest;\n-      }\n-    result[i++] = filename;\n-\n-    return result;\n+    return computeTypicalArguments(COMPILER_ARGS,\n+\t\t\t\t   getDestination(),\n+\t\t\t\t   filename);\n   }\n }"}, {"sha": "fd5534b2b01135bd11fedcabd2ee65f661ab0010", "filename": "libjava/gnu/java/rmi/rmic/Compile_jikes.java", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_jikes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_jikes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_jikes.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -0,0 +1,56 @@\n+/*\r\n+  Copyright (c) 2003 Free Software Foundation, Inc.\r\n+\r\n+This file is part of GNU Classpath.\r\n+\r\n+GNU Classpath is free software; you can redistribute it and/or modify\r\n+it under the terms of the GNU General Public License as published by\r\n+the Free Software Foundation; either version 2, or (at your option)\r\n+any later version.\r\n+ \r\n+GNU Classpath is distributed in the hope that it will be useful, but\r\n+WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+General Public License for more details.\r\n+\r\n+You should have received a copy of the GNU General Public License\r\n+along with GNU Classpath; see the file COPYING.  If not, write to the\r\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\r\n+02111-1307 USA.\r\n+\r\n+Linking this library statically or dynamically with other modules is\r\n+making a combined work based on this library.  Thus, the terms and\r\n+conditions of the GNU General Public License cover the whole\r\n+combination.\r\n+\r\n+As a special exception, the copyright holders of this library give you\r\n+permission to link this library with independent modules to produce an\r\n+executable, regardless of the license terms of these independent\r\n+modules, and to copy and distribute the resulting executable under\r\n+terms of your choice, provided that you also meet, for each linked\r\n+independent module, the terms and conditions of the license of that\r\n+module.  An independent module is a module which is not derived from\r\n+or based on this library.  If you modify this library, you may extend\r\n+this exception to your version of the library, but you are not\r\n+obligated to do so.  If you do not wish to do so, delete this\r\n+exception statement from your version. */\r\n+\r\n+package gnu.java.rmi.rmic;\r\n+\r\n+/** Subclass of Compiler that can be used to invoke jikes.  */\r\n+public class Compile_jikes extends CompilerProcess\r\n+{\r\n+  /** Compiler arguments to invoke jikes */\r\n+  private static final String [] COMPILER_ARGS = \r\n+  {\r\n+    \"jikes\"\r\n+  };\r\n+\r\n+  /** Compute the command line for the process.  */\r\n+  public String[] computeArguments (String filename)\r\n+  {\r\n+    return computeTypicalArguments(COMPILER_ARGS,\r\n+\t\t\t\t   getDestination(),\r\n+\t\t\t\t   filename);\r\n+  }\r\n+}\r"}, {"sha": "cbb27bd7374f7fd29a253d022a486d1dbccee27f", "filename": "libjava/gnu/java/rmi/rmic/Compile_kjc.java", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_kjc.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_kjc.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompile_kjc.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -0,0 +1,56 @@\n+/*\r\n+  Copyright (c) 2003 Free Software Foundation, Inc.\r\n+\r\n+This file is part of GNU Classpath.\r\n+\r\n+GNU Classpath is free software; you can redistribute it and/or modify\r\n+it under the terms of the GNU General Public License as published by\r\n+the Free Software Foundation; either version 2, or (at your option)\r\n+any later version.\r\n+ \r\n+GNU Classpath is distributed in the hope that it will be useful, but\r\n+WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+General Public License for more details.\r\n+\r\n+You should have received a copy of the GNU General Public License\r\n+along with GNU Classpath; see the file COPYING.  If not, write to the\r\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\r\n+02111-1307 USA.\r\n+\r\n+Linking this library statically or dynamically with other modules is\r\n+making a combined work based on this library.  Thus, the terms and\r\n+conditions of the GNU General Public License cover the whole\r\n+combination.\r\n+\r\n+As a special exception, the copyright holders of this library give you\r\n+permission to link this library with independent modules to produce an\r\n+executable, regardless of the license terms of these independent\r\n+modules, and to copy and distribute the resulting executable under\r\n+terms of your choice, provided that you also meet, for each linked\r\n+independent module, the terms and conditions of the license of that\r\n+module.  An independent module is a module which is not derived from\r\n+or based on this library.  If you modify this library, you may extend\r\n+this exception to your version of the library, but you are not\r\n+obligated to do so.  If you do not wish to do so, delete this\r\n+exception statement from your version. */\r\n+\r\n+package gnu.java.rmi.rmic;\r\n+\r\n+/** Subclass of Compiler that can be used to invoke kjc.  */\r\n+public class Compile_kjc extends CompilerProcess\r\n+{\r\n+  /** Compiler arguments to invoke kjc */\r\n+  private static final String [] COMPILER_ARGS = \r\n+  {\r\n+    \"kjc\"\r\n+  };\r\n+\r\n+  /** Compute the command line for the process.  */\r\n+  public String[] computeArguments (String filename)\r\n+  {\r\n+    return computeTypicalArguments(COMPILER_ARGS,\r\n+\t\t\t\t   getDestination(),\r\n+\t\t\t\t   filename);\r\n+  }\r\n+}\r"}, {"sha": "9040c6d93c1208add0fa0f984b38e1a648ce2582", "filename": "libjava/gnu/java/rmi/rmic/Compiler.java", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompiler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompiler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompiler.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 2001 Free Software Foundation, Inc.\n+  Copyright (c) 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,10 +37,12 @@\n \n package gnu.java.rmi.rmic;\n \n-/** A Compiler object can be used to compile a .java file into a\n+/**\n+ * A Compiler object can be used to compile a .java file into a\n  * .class file.  This is an abstract class; the\n  * <code>getInstance()</code> method is used to obtain the actual\n- * compiler object.  */\n+ * compiler object.\n+ */\n public abstract class Compiler\n {\n   // Can't directly instantiate.\n@@ -68,6 +70,12 @@ public static Compiler getInstance (String name)\n     return null;\n   }\n \n+   /** Get the directory where output files will be put.  */\n+   public String getDestination ()\n+   {\n+     return dest;\n+   }\n+\n   /** Set the directory where output files will be put.  */\n   public void setDestination (String dest)\n   {"}, {"sha": "0de36b62b0eca20d469dde829dadf4d1b87d15b5", "filename": "libjava/gnu/java/rmi/rmic/CompilerProcess.java", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompilerProcess.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompilerProcess.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FCompilerProcess.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 2001 Free Software Foundation, Inc.\n+  Copyright (c) 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,19 +37,71 @@\n \n package gnu.java.rmi.rmic;\n \n-/** Subclass of Compiler that can be subclassed to invoke a process to\n- * do its work.  */\n+import java.io.InputStream;\n+\n+/**\n+ * Subclass of Compiler that can be subclassed to invoke a process to\n+ * do its work.\n+ */\n public abstract class CompilerProcess extends Compiler\n {\n   /** This is used to compute the command line for the process.  */\n   public abstract String[] computeArguments (String filename);\n \n+   /**\n+    * This is used to compute the command line for the process.\n+    * Most compilers typically arrange their arguments as in\n+    * <compiler name and arguments> <optional destination> <filename>.\n+    * This method builds an argument array out that. It should be used\n+    * to define computeArguments for those compilers that follow the\n+    * argument convention described above.\n+    */\n+   public static String[] computeTypicalArguments(String[] compilerArgs,\n+\tString destination, String filename)\n+   {\n+     /* length of compiler specific arguments */\n+     final int len = compilerArgs.length;\n+\n+     /* length of returned array of arguments */\n+     final int arglen = len + (destination == null ? 0 : 2) + 1;\n+\n+     /* Allocate String array for computed arguments. */\n+     String [] args = new String[arglen];\n+\n+     /* Fill in compiler arguments. */\n+     System.arraycopy(compilerArgs, 0, args, 0, len);\n+\n+     /* Fill in destination argument if necessary. */\n+     if (destination != null)\n+      {\n+\targs[len] = \"-d\";\n+\targs[len + 1] = destination;\n+      }\n+\n+     /* Fill in filename */\n+     args[arglen - 1] = filename;\n+\n+     return args;\n+   }\n+\n   public void compile (String name) throws Exception\n   {\n     String[] args = computeArguments (name);\n     Process p = Runtime.getRuntime ().exec (args);\n-    // FIXME: probably should collect compiler output here and then\n-    // put it into the exception message.\n+\n+    /* Print compiler output to System.out. */\n+    InputStream procin = p.getInputStream();\n+    for (int ch = procin.read(); ch != -1; ch = procin.read())\n+      System.out.print((char) ch);\n+\n+    /* Collect compiler error output in a buffer.\n+     * If compilation fails, it will be used for an error message.\n+     */\n+    StringBuffer stderr = new StringBuffer();\n+    InputStream procerr = p.getErrorStream();\n+    for (int ch = procerr.read(); ch != -1; ch = procerr.read())\n+      stderr.append((char) ch);\n+\n     int result;\n     while (true)\n       {\n@@ -65,7 +117,8 @@ public void compile (String name) throws Exception\n     if (result != 0)\n       {\n \t// FIXME: wrong exception class.\n-\tthrow new Exception (\"compiler exited with status: \" + result);\n+\tthrow new Exception (\"compiler exited with status: \" + result,\n+\t\t\t     new RMICException(stderr.toString()));\n       }\n   }\n }"}, {"sha": "82bb37ef07cc4651b85290b5749a63b27cdf5088", "filename": "libjava/gnu/java/rmi/rmic/RMIC.java", "status": "modified", "additions": 103, "deletions": 36, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMIC.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -43,10 +43,12 @@\n import java.io.IOException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.rmi.RemoteException;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Arrays;\n-import java.lang.Comparable;\n+import java.util.Set;\n+\n import gnu.java.rmi.server.RMIHashes;\n \n public class RMIC {\n@@ -71,7 +73,9 @@ public class RMIC {\n private MethodRef[] remotemethods;\n private String stubname;\n private String skelname;\n+private int errorCount = 0;\n \n+private Class mRemoteInterface;\n public RMIC(String[] a) {\n \targs = a;\n }\n@@ -99,7 +103,7 @@ public boolean run() {\n \t\t\tif (verbose) {\n \t\t\t\tSystem.out.println(\"[Processing class \" + args[i] + \".class]\");\n \t\t\t}\n-\t\t\tprocessClass(args[i]);\n+\t\t\tprocessClass(args[i].replace(File.separatorChar, '.'));\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\texception = e;\n@@ -110,27 +114,34 @@ public boolean run() {\n }\n \n private boolean processClass(String classname) throws Exception {\n+\terrorCount = 0;\n \tanalyzeClass(classname);\n+\tif(errorCount > 0) {\n+\t\tSystem.exit(1);\n+\t}\n \tgenerateStub();\n \tif (need11Stubs) {\n \t\tgenerateSkel();\n \t}\n \tif (compile) {\n-\t\tcompile(stubname + \".java\");\n+\t\tcompile(stubname.replace('.', File.separatorChar) + \".java\");\n \t\tif (need11Stubs) {\n-\t\t\tcompile(skelname + \".java\");\n+\t\t\tcompile(skelname.replace('.', File.separatorChar) + \".java\");\n \t\t}\n \t}\n \tif (!keep) {\n-\t\t(new File(stubname + \".java\")).delete();\n+\t\t(new File(stubname.replace('.', File.separatorChar) + \".java\")).delete();\n \t\tif (need11Stubs) {\n-\t\t\t(new File(skelname + \".java\")).delete();\n+\t\t\t(new File(skelname.replace('.', File.separatorChar) + \".java\")).delete();\n \t\t}\n \t}\n \treturn (true);\n }\n \n private void analyzeClass(String cname) throws Exception {\n+\tif(verbose){\n+\t\t\tSystem.out.println(\"[analyze class \"+cname+\"]\");\n+\t\t}\n \tint p = cname.lastIndexOf('.');\n \tif (p != -1) {\n \t\tclassname = cname.substring(p+1);\n@@ -140,27 +151,36 @@ private void analyzeClass(String cname) throws Exception {\n \t}\n \tfullclassname = cname;\n \n+\t\n \tHashSet rmeths = new HashSet();\n \tfindClass();\n-\tfor (Class cls = clazz; cls != null; cls = cls.getSuperclass()) {\n-\t\t// Keep going down the inheritence tree until we hit the system\n-\t\tif (cls.getName().startsWith(\"java.\")) {\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\tMethod[] meths = cls.getDeclaredMethods();\n-\t\tfor (int i = 0; i < meths.length; i++) {\n-\t\t\t// Only include public methods\n-\t\t\tint mods = meths[i].getModifiers();\n-\t\t\tif (Modifier.isPublic(mods) && !Modifier.isStatic(mods)) {\n-\t\t\t\t// Should check exceptions here. - XXX\n+\t\n+\t// get the remote interface\n+\tmRemoteInterface = getRemoteInterface(clazz);\n+\tif(mRemoteInterface == null)\n+\t\treturn;\n+\tif(verbose){\n+\t\tSystem.out.println(\"[implements \"+mRemoteInterface.getName()+\"]\");\n+\t}\n \n-\t\t\t\t// Add this one in.\n-\t\t\t\trmeths.add(meths[i]);\n+\t// check if the methods of the remote interface declare RemoteExceptions\n+\tMethod[] meths = mRemoteInterface.getDeclaredMethods();\n+\tfor (int i = 0; i < meths.length; i++) {\n+\t\tClass[] exceptions = meths[i].getExceptionTypes();\n+\t\tint index = 0;\n+\t\tfor(;index < exceptions.length; index++){\n+\t\t\tif(exceptions[index].equals(RemoteException.class)){\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n+\t\tif (index < exceptions.length) {\n+\t\t\trmeths.add(meths[i]);\n+\t\t} else {\n+\t\t\tlogError(\"Method \"+meths[i]+\" does not throw a java.rmi.RemoteException\");\n+\t\t}\n \t}\n \n+\n \t// Convert into a MethodRef array and sort them\n \tremotemethods = new MethodRef[rmeths.size()];\n \tint c = 0;\n@@ -175,12 +195,15 @@ public Exception getException() {\n }\n \n private void findClass() throws ClassNotFoundException {\n-\tclazz = Class.forName(fullclassname);\n+\tclazz = Class.forName(fullclassname, true, ClassLoader.getSystemClassLoader());\n }\n \n private void generateStub() throws IOException {\n-\tstubname = classname + \"_Stub\";\n-\tctrl = new TabbedWriter(new FileWriter(stubname + \".java\"));\n+\tstubname = fullclassname + \"_Stub\";\n+\tString stubclassname = classname + \"_Stub\";\n+\tctrl = new TabbedWriter(new FileWriter((destination == null ? \"\" : destination + File.separator)\n+\t\t\t\t\t       + stubname.replace('.', File.separatorChar)\n+\t\t\t\t\t       + \".java\"));\n \tout = new PrintWriter(ctrl);\n \n \tif (verbose) {\n@@ -195,20 +218,32 @@ private void generateStub() throws IOException {\n \t\tout.println();\n \t}\n \n-\tout.print(\"public final class \" + stubname);\n+\tout.print(\"public final class \" + stubclassname);\n \tctrl.indent();\n \tout.println(\"extends java.rmi.server.RemoteStub\");\n \t\n \t// Output interfaces we implement\n \tout.print(\"implements \");\n-\tClass[] ifaces = clazz.getInterfaces(); \n-\tfor (int i = 0; i < ifaces.length; i++) {\n-\t\tout.print(ifaces[i].getName());\n-\t\tif (i+1 < ifaces.length) {\n+\t/* Scan implemented interfaces, and only print remote interfaces. */ \n+        Class[] ifaces = clazz.getInterfaces(); \n+\tSet remoteIfaces = new HashSet();\n+        for (int i = 0; i < ifaces.length; i++) {\n+\t\tClass iface = ifaces[i];\n+\t\tif (java.rmi.Remote.class.isAssignableFrom(iface)) {\n+\t\t\tremoteIfaces.add(iface);\n+\t\t}\n+\t}\n+\tIterator iter = remoteIfaces.iterator();\n+\twhile (iter.hasNext()) {\n+\t\t/* Print remote interface. */\n+\t\tClass iface = (Class) iter.next();\n+\t\tout.print(iface.getName());\n+\n+\t\t/* Print \", \" if more remote interfaces follow. */\n+\t\tif (iter.hasNext()) {\n \t\t\tout.print(\", \");\n \t\t}\n \t}\n-\n \tctrl.unindent();\n \tout.print(\"{\");\n \tctrl.indent();\n@@ -278,7 +313,7 @@ private void generateStub() throws IOException {\n \t\tfor (int i = 0; i < remotemethods.length; i++) {\n \t\t\tMethod m = remotemethods[i].meth;\n \t\t\tout.print(\"$method_\" + m.getName() + \"_\" + i + \" = \");\n-\t\t\tout.print(fullclassname + \".class.getMethod(\\\"\" + m.getName() + \"\\\"\");\n+\t\t\tout.print(mRemoteInterface.getName() + \".class.getMethod(\\\"\" + m.getName() + \"\\\"\");\n \t\t\tout.print(\", new java.lang.Class[] {\");\n \t\t\t// Output signature\n \t\t\tClass[] sig = m.getParameterTypes();\n@@ -311,15 +346,15 @@ private void generateStub() throws IOException {\n \n \t// Constructors\n \tif (need11Stubs) {\n-\t\tout.print(\"public \" + stubname + \"() {\");\n+\t\tout.print(\"public \" + stubclassname + \"() {\");\n \t\tctrl.indent();\n \t\tout.print(\"super();\");\n \t\tctrl.unindent();\n \t\tout.println(\"}\");\n \t}\n \n \tif (need12Stubs) {\n-\t\tout.print(\"public \" + stubname + \"(java.rmi.server.RemoteRef ref) {\");\n+\t\tout.print(\"public \" + stubclassname + \"(java.rmi.server.RemoteRef ref) {\");\n \t\tctrl.indent();\n \t\tout.print(\"super(ref);\");\n \t\tctrl.unindent();\n@@ -600,8 +635,11 @@ else if (returntype == Double.TYPE) {\n }\n \n private void generateSkel() throws IOException {\n-\tskelname = classname + \"_Skel\";\n-\tctrl = new TabbedWriter(new FileWriter(skelname + \".java\"));\n+\tskelname = fullclassname + \"_Skel\";\n+\tString skelclassname = classname + \"_Skel\";\n+\tctrl = new TabbedWriter(new FileWriter((destination == null ? \"\" : destination + File.separator)\n+\t\t\t\t\t       + skelname.replace('.', File.separatorChar)\n+\t\t\t\t\t       + \".java\"));\n \tout = new PrintWriter(ctrl);\n \n \tif (verbose) {\n@@ -616,7 +654,7 @@ private void generateSkel() throws IOException {\n \t\tout.println();\n \t}\n \n-\tout.print(\"public final class \" + skelname);\n+\tout.print(\"public final class \" + skelclassname);\n \tctrl.indent();\n \t\n \t// Output interfaces we implement\n@@ -961,6 +999,35 @@ else if (arg.charAt(1) == 'J') {\n \t}\n }\n \n+/**\n+ * Looks for the java.rmi.Remote interface that that is implemented by theClazz.\n+ * @param theClazz the class to look in  \n+ * @return the Remote interface of theClazz or null if theClazz does not implement a Remote interface\n+ */\n+private Class getRemoteInterface(Class theClazz)\n+{\n+\tClass[] interfaces = theClazz.getInterfaces();\n+\tfor (int i = 0; i < interfaces.length; i++)\n+\t{\n+\t\tif (java.rmi.Remote.class.isAssignableFrom(interfaces[i]))\n+\t\t{\n+\t\t\treturn interfaces[i];\n+\t\t}\n+\t}\n+\tlogError(\"Class \"+ theClazz.getName()\n+\t\t\t+ \" is not a remote object. It does not implement an interface that is a java.rmi.Remote-interface.\");\n+\treturn null;\n+}\n+\t\n+/**\n+ * Prints an error to System.err and increases the error count.\n+ * @param theError\n+ */\n+private void logError(String theError){\n+\terrorCount++;\n+\tSystem.err.println(\"error:\"+theError);\n+}\n+\n private static void error(String message) {\n \tSystem.err.println(\"rmic: \" + message);\n \tSystem.err.println(\"Try `rmic --help' for more information.\");"}, {"sha": "c048d9e0dbbf9dad6538fb2c3a01c5ed17d51a66", "filename": "libjava/gnu/java/rmi/rmic/RMICException.java", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMICException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1216e03b302ecee57ff9dfd7ba89d6f31c79f666/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMICException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Frmic%2FRMICException.java?ref=1216e03b302ecee57ff9dfd7ba89d6f31c79f666", "patch": "@@ -0,0 +1,66 @@\n+/*\r\n+  Copyright (c) 2003 Free Software Foundation, Inc.\r\n+\r\n+This file is part of GNU Classpath.\r\n+\r\n+GNU Classpath is free software; you can redistribute it and/or modify\r\n+it under the terms of the GNU General Public License as published by\r\n+the Free Software Foundation; either version 2, or (at your option)\r\n+any later version.\r\n+ \r\n+GNU Classpath is distributed in the hope that it will be useful, but\r\n+WITHOUT ANY WARRANTY; without even the implied warranty of\r\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n+General Public License for more details.\r\n+\r\n+You should have received a copy of the GNU General Public License\r\n+along with GNU Classpath; see the file COPYING.  If not, write to the\r\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\r\n+02111-1307 USA.\r\n+\r\n+Linking this library statically or dynamically with other modules is\r\n+making a combined work based on this library.  Thus, the terms and\r\n+conditions of the GNU General Public License cover the whole\r\n+combination.\r\n+\r\n+As a special exception, the copyright holders of this library give you\r\n+permission to link this library with independent modules to produce an\r\n+executable, regardless of the license terms of these independent\r\n+modules, and to copy and distribute the resulting executable under\r\n+terms of your choice, provided that you also meet, for each linked\r\n+independent module, the terms and conditions of the license of that\r\n+module.  An independent module is a module which is not derived from\r\n+or based on this library.  If you modify this library, you may extend\r\n+this exception to your version of the library, but you are not\r\n+obligated to do so.  If you do not wish to do so, delete this\r\n+exception statement from your version. */\r\n+\r\n+package gnu.java.rmi.rmic;\r\n+\r\n+/**\r\n+ * Thrown by the underlying compiler used by RMIC when it fails to compile a file.\r\n+ *\r\n+ * @author Dalibor Topic <robilad@kaffe.org>\r\n+ */\r\n+\r\n+public class RMICException extends Exception {\r\n+\t/**\r\n+\t * Create an exception with a message. The cause remains uninitialized.\r\n+\t *\r\n+\t * @param s the message string\r\n+\t * @see #initCause(Throwable)\r\n+\t */\r\n+\tpublic RMICException(String message) {\r\n+\t\tsuper(message);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Create an exception with a message and a cause.\r\n+\t *\r\n+\t * @param s the message string\r\n+\t * @param cause the cause of this exception\r\n+\t */\r\n+\tpublic RMICException(String message, Throwable cause) {\r\n+\t\tsuper(message, cause);\r\n+\t}\r\n+}\r"}]}