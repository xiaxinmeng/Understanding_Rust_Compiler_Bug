{"sha": "08c8883f44b80fd9802d90277db2a0a54975810c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhjODg4M2Y0NGI4MGZkOTgwMmQ5MDI3N2RiMmEwYTU0OTc1ODEwYw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2020-08-13T14:38:26Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-22T12:11:20Z"}, "message": "[Ada] Ada_2020: ongoing work for aggregates for bounded containers\n\ngcc/ada/\n\n\t* sem_aggr.adb: (Resolve_Container_Aggregate): For an indexed\n\tcontainer, verify that expressions and component associations\n\tare not both present.\n\t* exp_aggr.adb: Code reorganization, additional comments.\n\t(Expand_Container_Aggregate): Use Aggregate_Size for Iterated_\n\tComponent_Associations for indexed aggregates. If present, the\n\tdefault value of the formal in the constructor function is used\n\twhen the size of the aggregate cannot be determined statically.", "tree": {"sha": "9910b9e7d7c429448a7f90f9d818df53c57507da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9910b9e7d7c429448a7f90f9d818df53c57507da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08c8883f44b80fd9802d90277db2a0a54975810c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c8883f44b80fd9802d90277db2a0a54975810c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08c8883f44b80fd9802d90277db2a0a54975810c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08c8883f44b80fd9802d90277db2a0a54975810c/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a11d43f15368d59dcbe424b047dc8029e4e98c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a11d43f15368d59dcbe424b047dc8029e4e98c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a11d43f15368d59dcbe424b047dc8029e4e98c5"}], "stats": {"total": 271, "additions": 176, "deletions": 95}, "files": [{"sha": "698f67187fb97ed630f6b255cf80e384f20c6498", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 167, "deletions": 92, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c8883f44b80fd9802d90277db2a0a54975810c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c8883f44b80fd9802d90277db2a0a54975810c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=08c8883f44b80fd9802d90277db2a0a54975810c", "patch": "@@ -6909,14 +6909,102 @@ package body Exp_Aggr is\n \n       Comp      : Node_Id;\n       Decl      : Node_Id;\n+      Default   : Node_Id;\n       Init_Stat : Node_Id;\n+      Siz       : Int;\n+\n+      function Aggregate_Size return Int;\n+      --  Compute number of entries in aggregate, including choices\n+      --  that cover a range, as well as iterated constructs.\n+      --  Return -1 if the size is not known statically, in which case\n+      --  we allocate a default size for the aggregate.\n \n       procedure Expand_Iterated_Component (Comp : Node_Id);\n       --  Handle iterated_component_association and iterated_Element\n       --  association by generating a loop over the specified range,\n       --  given either by a loop parameter specification or an iterator\n       --  specification.\n \n+      --------------------\n+      -- Aggregate_Size --\n+      --------------------\n+\n+      function Aggregate_Size return Int is\n+         Comp   : Node_Id;\n+         Choice : Node_Id;\n+         Lo, Hi : Node_Id;\n+         Siz     : Int := 0;\n+\n+         procedure Add_Range_Size;\n+         --  Compute size of component association given by\n+         --  range or subtype name.\n+\n+         procedure Add_Range_Size is\n+         begin\n+            if Nkind (Lo) = N_Integer_Literal then\n+               Siz := Siz + UI_To_Int (Intval (Hi))\n+                 - UI_To_Int (Intval (Lo)) + 1;\n+            end if;\n+         end Add_Range_Size;\n+\n+      begin\n+         if Present (Expressions (N)) then\n+            Siz := List_Length (Expressions (N));\n+         end if;\n+\n+         if Present (Component_Associations (N)) then\n+            Comp := First (Component_Associations (N));\n+            while Present (Comp) loop\n+               Choice := First (Choice_List (Comp));\n+\n+               while Present (Choice) loop\n+                  Analyze (Choice);\n+\n+                  if Nkind (Choice) = N_Range then\n+                     Lo := Low_Bound (Choice);\n+                     Hi := High_Bound (Choice);\n+                     if Nkind (Lo) /= N_Integer_Literal\n+                       or else Nkind (Hi) /= N_Integer_Literal\n+                     then\n+                        return -1;\n+                     else\n+                        Add_Range_Size;\n+                     end if;\n+\n+                  elsif Is_Entity_Name (Choice)\n+                    and then Is_Type (Entity (Choice))\n+                  then\n+                     Lo := Type_Low_Bound (Entity (Choice));\n+                     Hi := Type_High_Bound (Entity (Choice));\n+                     if Nkind (Lo) /= N_Integer_Literal\n+                       or else Nkind (Hi) /= N_Integer_Literal\n+                     then\n+                        return -1;\n+                     else\n+                        Add_Range_Size;\n+                     end if;\n+\n+                     Rewrite (Choice,\n+                       Make_Range (Loc,\n+                         New_Copy_Tree (Lo),\n+                         New_Copy_Tree (Hi)));\n+\n+                  else\n+                     --  Single choice (syntax excludes a subtype\n+                     --  indication).\n+\n+                     Siz := Siz + 1;\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+               Next (Comp);\n+            end loop;\n+         end if;\n+\n+         return Siz;\n+      end Aggregate_Size;\n+\n       -------------------------------\n       -- Expand_Iterated_Component --\n       -------------------------------\n@@ -7040,35 +7128,78 @@ package body Exp_Aggr is\n \n       end Expand_Iterated_Component;\n \n+      --  Start of processing for Expand_Container_Aggregate\n+\n    begin\n       Parse_Aspect_Aggregate (Asp,\n         Empty_Subp, Add_Named_Subp, Add_Unnamed_Subp,\n         New_Indexed_Subp, Assign_Indexed_Subp);\n-      Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Temp,\n-          Object_Definition   => New_Occurrence_Of (Typ, Loc));\n-\n-      Insert_Action (N, Decl);\n-      if Ekind (Entity (Empty_Subp)) = E_Function then\n-         Init_Stat := Make_Assignment_Statement (Loc,\n-           Name => New_Occurrence_Of (Temp, Loc),\n-           Expression => Make_Function_Call (Loc,\n-             Name => New_Occurrence_Of (Entity (Empty_Subp), Loc)));\n-      else\n-         Init_Stat := Make_Assignment_Statement (Loc,\n-           Name => New_Occurrence_Of (Temp, Loc),\n-           Expression => New_Occurrence_Of (Entity (Empty_Subp), Loc));\n+\n+      --  The constructor for bounded containers is a function with\n+      --  a parameter that sets the size of the container. If the\n+      --  size cannot be determined statically we use a default value.\n+\n+      Siz := Aggregate_Size;\n+      if Siz < 0 then\n+         Siz := 10;\n       end if;\n \n-      Append (Init_Stat, Aggr_Code);\n+      if Ekind (Entity (Empty_Subp)) = E_Function\n+        and then Present (First_Formal (Entity (Empty_Subp)))\n+      then\n+         Default := Default_Value (First_Formal (Entity (Empty_Subp)));\n+         --  If aggregate size is not static, use default value of\n+         --  formal parameter for allocation. We assume that this\n+         --  (implementation-dependent) value is static, even though\n+         --   the AI does not require it ???.\n+\n+         if Siz < 0 then\n+            Siz := UI_To_Int (Intval (Default));\n+         end if;\n+\n+         Init_Stat :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+             Expression => Make_Function_Call (Loc,\n+               Name => New_Occurrence_Of (Entity (Empty_Subp), Loc),\n+               Parameter_Associations =>\n+                 New_List (Make_Integer_Literal (Loc, Siz))));\n+\n+         Append (Init_Stat, Aggr_Code);\n+\n+         --  Use default value when aggregate size is not static.\n+\n+      else\n+         Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+         Insert_Action (N, Decl);\n+         if Ekind (Entity (Empty_Subp)) = E_Function then\n+            Init_Stat := Make_Assignment_Statement (Loc,\n+              Name => New_Occurrence_Of (Temp, Loc),\n+              Expression => Make_Function_Call (Loc,\n+                Name => New_Occurrence_Of (Entity (Empty_Subp), Loc)));\n+         else\n+            Init_Stat := Make_Assignment_Statement (Loc,\n+              Name => New_Occurrence_Of (Temp, Loc),\n+              Expression => New_Occurrence_Of (Entity (Empty_Subp), Loc));\n+         end if;\n+\n+         Append (Init_Stat, Aggr_Code);\n+      end if;\n \n       ---------------------------\n       --  Positional aggregate --\n       ---------------------------\n \n+      --  If the aggregate is positional the aspect must include\n+      --  an Add_Unnamed subprogram.\n+\n       if Present (Add_Unnamed_Subp)\n-        and then No (Assign_Indexed_Subp)\n+        and then No (Component_Associations (N))\n       then\n          if Present (Expressions (N)) then\n             declare\n@@ -7137,21 +7268,25 @@ package body Exp_Aggr is\n                Next (Comp);\n             end loop;\n          end;\n+      end if;\n \n       -----------------------\n       -- Indexed_Aggregate --\n       -----------------------\n \n-      elsif Present (Assign_Indexed_Subp) then\n+      --  For an indexed aggregate there must be an Assigned_Indexeed\n+      --  subprogram. Note that unlike array aggregates, a container\n+      --  aggregate must be fully positional or fully indexed. In the\n+      --  first case the expansion has already taken place.\n+\n+      if Present (Assign_Indexed_Subp)\n+        and then Present (Component_Associations (N))\n+      then\n          declare\n             Insert : constant Entity_Id := Entity (Assign_Indexed_Subp);\n             Index_Type : constant Entity_Id :=\n                Etype (Next_Formal (First_Formal (Insert)));\n \n-            function Aggregate_Size return Int;\n-            --  Compute number of entries in aggregate, including choices\n-            --  that cover a range, as well as iterated constructs.\n-\n             function  Expand_Range_Component\n               (Rng  : Node_Id;\n                Expr : Node_Id) return Node_Id;\n@@ -7165,7 +7300,6 @@ package body Exp_Aggr is\n             Pos    : Int := 0;\n             Stat   : Node_Id;\n             Key    : Node_Id;\n-            Size   : Int := 0;\n \n             -----------------------------\n             -- Expand_Raange_Component --\n@@ -7205,82 +7339,16 @@ package body Exp_Aggr is\n                           Statements       => Stats);\n             end Expand_Range_Component;\n \n-            --------------------\n-            -- Aggregate_Size --\n-            --------------------\n-\n-            function Aggregate_Size return Int is\n-               Comp   : Node_Id;\n-               Choice : Node_Id;\n-               Lo, Hi : Node_Id;\n-               Siz     : Int := 0;\n-\n-               procedure Add_Range_Size;\n-               --  Compute size of component association given by\n-               --  range or subtype name.\n-\n-               procedure Add_Range_Size is\n-               begin\n-                  if Nkind (Lo) = N_Integer_Literal then\n-                     Siz := Siz + UI_To_Int (Intval (Hi))\n-                       - UI_To_Int (Intval (Lo)) + 1;\n-                  end if;\n-               end Add_Range_Size;\n-\n-            begin\n-               if Present (Expressions (N)) then\n-                  Siz := List_Length (Expressions (N));\n-               end if;\n-\n-               if Present (Component_Associations (N)) then\n-                  Comp := First (Component_Associations (N));\n-                  while Present (Comp) loop\n-                     Choice := First (Choices (Comp));\n-\n-                     while Present (Choice) loop\n-                        Analyze (Choice);\n-\n-                        if Nkind (Choice) = N_Range then\n-                           Lo := Low_Bound (Choice);\n-                           Hi := High_Bound (Choice);\n-                           Add_Range_Size;\n-\n-                        elsif Is_Entity_Name (Choice)\n-                          and then Is_Type (Entity (Choice))\n-                        then\n-                           Lo := Type_Low_Bound (Entity (Choice));\n-                           Hi := Type_High_Bound (Entity (Choice));\n-                           Add_Range_Size;\n-                           Rewrite (Choice,\n-                             Make_Range (Loc,\n-                               New_Copy_Tree (Lo),\n-                               New_Copy_Tree (Hi)));\n-\n-                        else\n-                           Resolve (Choice, Index_Type);\n-                           Siz := Siz + 1;\n-                        end if;\n-\n-                        Next (Choice);\n-                     end loop;\n-                     Next (Comp);\n-                  end loop;\n-               end if;\n-\n-               return Siz;\n-            end Aggregate_Size;\n-\n          begin\n-            Size := Aggregate_Size;\n-            if Size > 0 then\n+            if Siz > 0 then\n \n                --  Modify the call to the constructor to allocate the\n                --  required size for the aggregwte : call the provided\n                --  constructor rather than the Empty aggregate.\n \n                Index :=  Make_Op_Add (Loc,\n                  Left_Opnd => New_Copy_Tree (Type_Low_Bound (Index_Type)),\n-                 Right_Opnd => Make_Integer_Literal (Loc, Size - 1));\n+                 Right_Opnd => Make_Integer_Literal (Loc, Siz - 1));\n \n                Set_Expression (Init_Stat,\n                   Make_Function_Call (Loc,\n@@ -7359,9 +7427,16 @@ package body Exp_Aggr is\n                         <<Next_Key>>\n                         Next (Key);\n                      end loop;\n+\n                   else\n-                     Error_Msg_N (\"iterated associations peding\", N);\n+                     --  Iterated component association. Discard\n+                     --  positional insertion procedure.\n+\n+                     Add_Named_Subp := Assign_Indexed_Subp;\n+                     Add_Unnamed_Subp := Empty;\n+                     Expand_Iterated_Component (Comp);\n                   end if;\n+\n                   Next (Comp);\n                end loop;\n             end if;"}, {"sha": "688937e19e9c2b6ed4c0589315ef69bc82a6c5d6", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08c8883f44b80fd9802d90277db2a0a54975810c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08c8883f44b80fd9802d90277db2a0a54975810c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=08c8883f44b80fd9802d90277db2a0a54975810c", "patch": "@@ -2930,9 +2930,9 @@ package body Sem_Aggr is\n          end;\n \n       else\n-         --  Indexed Aggregate. Both positional and indexed component\n-         --  can be present. Choices must be static values or ranges\n-         --  with static bounds.\n+         --  Indexed Aggregate. Positional or indexed component\n+         --  can be present, but not both. Choices must be static\n+         --  values or ranges with static bounds.\n \n          declare\n             Container : constant Entity_Id :=\n@@ -2953,6 +2953,12 @@ package body Sem_Aggr is\n             end if;\n \n             if Present (Component_Associations (N)) then\n+               if Present (Expressions (N)) then\n+                  Error_Msg_N (\"Container aggregate cannot be \"\n+                    & \"both positional and named\", N);\n+                  return;\n+               end if;\n+\n                Comp := First (Expressions (N));\n \n                while Present (Comp) loop"}]}