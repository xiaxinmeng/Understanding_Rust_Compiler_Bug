{"sha": "6b2231910767d2819899bfba467c2307f92b802e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIyMjMxOTEwNzY3ZDI4MTk4OTliZmJhNDY3YzIzMDdmOTJiODAyZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2009-12-10T06:47:12Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2009-12-10T06:47:12Z"}, "message": "profiler_container_size.h: Fix include guard, formatting fixes.\n\n2009-12-09  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/profile/impl/profiler_container_size.h: Fix include\n\tguard, formatting fixes.\n\t* include/profile/impl/profiler_vector_size.h: Same.\n\t* include/profile/impl/profiler_hash_func.h: Same.\n\t* include/profile/impl/profiler_trace.h: Same.\n\t* include/profile/impl/profiler_vector_to_list.h: Same.\n\t* include/profile/impl/profiler.h: Same.\n\t* include/profile/impl/profiler_state.h: Same.\n\t* include/profile/impl/profiler_map_to_unordered_map.h: Same.\n\t* include/profile/impl/profiler_hashtable_size.h: Same.\n\t* include/profile/impl/profiler_node.h: Same.\n\nFrom-SVN: r155123", "tree": {"sha": "8bc9ea468b616a6d29f970f567c830c49298bf3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bc9ea468b616a6d29f970f567c830c49298bf3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b2231910767d2819899bfba467c2307f92b802e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b2231910767d2819899bfba467c2307f92b802e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b2231910767d2819899bfba467c2307f92b802e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b2231910767d2819899bfba467c2307f92b802e/comments", "author": null, "committer": null, "parents": [{"sha": "14aa63526a63156b1ae10de42af2730cbd7234d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14aa63526a63156b1ae10de42af2730cbd7234d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14aa63526a63156b1ae10de42af2730cbd7234d7"}], "stats": {"total": 2995, "additions": 1522, "deletions": 1473}, "files": [{"sha": "3d9b49a1e8cb84c098c525dfda92ad17466054af", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -1,3 +1,17 @@\n+2009-12-09  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/profile/impl/profiler_container_size.h: Fix include\n+\tguard, formatting fixes.\n+\t* include/profile/impl/profiler_vector_size.h: Same.\n+\t* include/profile/impl/profiler_hash_func.h: Same.\n+\t* include/profile/impl/profiler_trace.h: Same.\n+\t* include/profile/impl/profiler_vector_to_list.h: Same.\n+\t* include/profile/impl/profiler.h: Same.\n+\t* include/profile/impl/profiler_state.h: Same.\n+\t* include/profile/impl/profiler_map_to_unordered_map.h: Same.\n+\t* include/profile/impl/profiler_hashtable_size.h: Same.\n+\t* include/profile/impl/profiler_node.h: Same.\n+\n 2009-12-09  Roman Odaisky  <to.roma.from.bugcc@qwertty.com>\n \n \tPR libstdc++/42273"}, {"sha": "c9db6cde4c39f9d7b9f7bb3c20f38f4d03d51a59", "filename": "libstdc++-v3/include/profile/impl/profiler.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_H__\n-#define PROFCXX_PROFILER_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_H\n+#define _GLIBCXX_PROFILE_PROFILER_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstddef>\n@@ -311,4 +311,4 @@ namespace __gnu_profile\n #include \"profile/impl/profiler_vector_size.h\"\n #include \"profile/impl/profiler_vector_to_list.h\"\n \n-#endif // PROFCXX_PROFILER_H__\n+#endif // _GLIBCXX_PROFILE_PROFILER_H"}, {"sha": "71f5556fa9348478b65335e1fe5a587cb6ea1579", "filename": "libstdc++-v3/include/profile/impl/profiler_container_size.h", "status": "modified", "additions": 193, "deletions": 183, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_container_size.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_CONTAINER_SIZE_H__\n-#define PROFCXX_PROFILER_CONTAINER_SIZE_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_CONTAINER_SIZE_H\n+#define _GLIBCXX_PROFILE_PROFILER_CONTAINER_SIZE_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdlib>\n@@ -53,198 +53,208 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief A container size instrumentation line in the object table.  */\n-class __container_size_info: public __object_info_base \n-{\n- public:\n-  __container_size_info();\n-  __container_size_info(const __container_size_info& __o);\n-  __container_size_info(__stack_t __stack, size_t __num);\n-  virtual ~__container_size_info() {}\n-\n-  void __write(FILE* f) const;\n-  float __magnitude() const { return static_cast<float>(_M_cost); }\n-  const char* __advice() const;\n-\n-  void __merge(const __container_size_info& __o);\n-  // Call if a container is destructed or cleaned.\n-  void __destruct(size_t __num, size_t __inum);\n-  // Estimate the cost of resize/rehash. \n-  float __resize_cost(size_t __from, size_t __to) { return __from; }\n-  // Call if container is resized.\n-  void __resize(size_t __from, size_t __to);\n-\n- private:\n-  size_t _M_init;\n-  size_t _M_max;  // range of # buckets\n-  size_t _M_min;\n-  size_t _M_total;\n-  size_t _M_item_min;  // range of # items\n-  size_t _M_item_max;\n-  size_t _M_item_total;\n-  size_t _M_count;\n-  size_t _M_resize;\n-  size_t _M_cost;\n-};\n-\n-inline const char* __container_size_info::__advice() const\n-{\n-  const size_t __max_chars_size_t_printed = 20;\n-  const char* __message_pattern = \n+  /** @brief A container size instrumentation line in the object table.  */\n+  class __container_size_info: public __object_info_base\n+  {\n+  public:\n+    __container_size_info();\n+    __container_size_info(const __container_size_info& __o);\n+    __container_size_info(__stack_t __stack, size_t __num);\n+    virtual ~__container_size_info() { }\n+\n+    void __write(FILE* f) const;\n+    float __magnitude() const { return static_cast<float>(_M_cost); }\n+    const char* __advice() const;\n+\n+    void __merge(const __container_size_info& __o);\n+\n+    // Call if a container is destructed or cleaned.\n+    void __destruct(size_t __num, size_t __inum);\n+\n+    // Estimate the cost of resize/rehash.\n+    float __resize_cost(size_t __from, size_t __to) { return __from; }\n+\n+    // Call if container is resized.\n+    void __resize(size_t __from, size_t __to);\n+\n+  private:\n+    size_t _M_init;\n+    size_t _M_max;  // Range of # buckets.\n+    size_t _M_min;\n+    size_t _M_total;\n+    size_t _M_item_min;  // Range of # items.\n+    size_t _M_item_max;\n+    size_t _M_item_total;\n+    size_t _M_count;\n+    size_t _M_resize;\n+    size_t _M_cost;\n+  };\n+\n+  inline const char* \n+  __container_size_info::__advice() const\n+  {\n+    const size_t __max_chars_size_t_printed = 20;\n+    const char* __message_pattern =\n       \"change initial container size from %d to %d\";\n-  size_t __message_size = (strlen(__message_pattern) \n-                           + 2 * __max_chars_size_t_printed\n-                           - 2 * 2);\n-  char* __message = new char[__message_size + 1];\n-\n-  if (_M_init < _M_item_max)\n-    snprintf(__message, __message_size, __message_pattern, _M_init,\n-             _M_item_max);\n-  else\n-    snprintf(__message, __message_size, __message_pattern, _M_init,\n-             _M_item_max);\n-\n-  return __message;\n-}\n-\n-inline void __container_size_info::__destruct(size_t __num, size_t __inum) \n-{\n-  _M_max = __max(_M_max, __num);\n-  _M_item_max = __max(_M_item_max, __inum);\n-  if (_M_min == 0) {\n-    _M_min = __num; \n-    _M_item_min = __inum;\n-  } else {\n-    _M_min = __min(_M_min, __num);\n-    _M_item_min = __min(_M_item_min, __inum);\n+    size_t __message_size = (strlen(__message_pattern)\n+\t\t\t     + 2 * __max_chars_size_t_printed\n+\t\t\t     - 2 * 2);\n+    char* __message = new char[__message_size + 1];\n+\n+    if (_M_init < _M_item_max)\n+      snprintf(__message, __message_size, __message_pattern, _M_init,\n+\t       _M_item_max);\n+    else\n+      snprintf(__message, __message_size, __message_pattern, _M_init,\n+\t       _M_item_max);\n+\n+    return __message;\n   }\n-  _M_total += __num;\n-  _M_item_total += __inum;\n-  _M_count += 1;\n-}\n \n-inline void __container_size_info::__resize(size_t __from, size_t __to) \n-{\n-  _M_cost += this->__resize_cost(__from, __to);\n-  _M_resize += 1;\n-  _M_max = __max(_M_max, __to);\n-}\n-\n-inline __container_size_info::__container_size_info(__stack_t __stack, \n-                                                    size_t __num)\n-    : __object_info_base(__stack), _M_init(0), _M_max(0), _M_item_max(0), \n-      _M_min(0), _M_item_min(0), _M_total(0), _M_item_total(0), _M_cost(0), \n-      _M_count(0), _M_resize(0)\n-{\n-  _M_init = _M_max = __num;\n-  _M_item_min = _M_item_max = _M_item_total = _M_total = 0;\n-  _M_min = 0;\n-  _M_count = 0;\n-  _M_resize = 0;\n-}\n-\n-inline void __container_size_info::__merge(const __container_size_info& __o)\n-{\n-  _M_init        = __max(_M_init, __o._M_init);\n-  _M_max         = __max(_M_max, __o._M_max);\n-  _M_item_max    = __max(_M_item_max, __o._M_item_max);\n-  _M_min         = __min(_M_min, __o._M_min);\n-  _M_item_min    = __min(_M_item_min, __o._M_item_min);\n-  _M_total      += __o._M_total;\n-  _M_item_total += __o._M_item_total;\n-  _M_count      += __o._M_count;\n-  _M_cost       += __o._M_cost;\n-  _M_resize     += __o._M_resize;\n-}\n-\n-inline __container_size_info::__container_size_info()\n-    : _M_init(0), _M_max(0), _M_item_max(0), _M_min(0), _M_item_min(0),\n-      _M_total(0), _M_item_total(0), _M_cost(0), _M_count(0), _M_resize(0)\n-{\n-}\n+  inline void \n+  __container_size_info::__destruct(size_t __num, size_t __inum)\n+  {\n+    _M_max = __max(_M_max, __num);\n+    _M_item_max = __max(_M_item_max, __inum);\n+    if (_M_min == 0) \n+      {\n+\t_M_min = __num;\n+\t_M_item_min = __inum;\n+      } \n+    else \n+      {\n+\t_M_min = __min(_M_min, __num);\n+\t_M_item_min = __min(_M_item_min, __inum);\n+      }\n+    _M_total += __num;\n+    _M_item_total += __inum;\n+    _M_count += 1;\n+  }\n \n-inline __container_size_info::__container_size_info(\n-    const __container_size_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_init        = __o._M_init;\n-  _M_max         = __o._M_max;\n-  _M_item_max    = __o._M_item_max;\n-  _M_min         = __o._M_min;\n-  _M_item_min    = __o._M_item_min;\n-  _M_total       = __o._M_total;\n-  _M_item_total  = __o._M_item_total;\n-  _M_cost        = __o._M_cost;\n-  _M_count       = __o._M_count;\n-  _M_resize      = __o._M_resize;\n-}\n-\n-/** @brief A container size instrumentation line in the stack table.  */\n-class __container_size_stack_info: public __container_size_info\n-{\n- public:\n-  __container_size_stack_info(const __container_size_info& __o)\n-      : __container_size_info(__o) {}\n-};\n-\n-/** @brief Container size instrumentation trace producer.  */\n-class __trace_container_size\n-    : public __trace_base<__container_size_info, __container_size_stack_info> \n-{\n- public:\n-  ~__trace_container_size() {}\n-  __trace_container_size()\n-      : __trace_base<__container_size_info, __container_size_stack_info>() {};\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(const __object_t __obj, __stack_t __stack, size_t __num);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj, size_t __num, size_t __inum);\n-  void __construct(const void* __obj, size_t __inum);\n-  // Call at resize to set resize/cost information.\n-  void __resize(const void* __obj, int __from, int __to);\n-};\n-\n-inline void __trace_container_size::__insert(const __object_t __obj,\n-                                             __stack_t __stack, size_t __num)\n-{\n-  __add_object(__obj, __container_size_info(__stack, __num));\n-}\n+  inline void \n+  __container_size_info::__resize(size_t __from, size_t __to)\n+  {\n+    _M_cost += this->__resize_cost(__from, __to);\n+    _M_resize += 1;\n+    _M_max = __max(_M_max, __to);\n+  }\n \n-inline void __container_size_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\", \n-          _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n-          _M_item_min, _M_item_max, _M_item_total);\n-}\n+  inline void \n+  __container_size_info::__merge(const __container_size_info& __o)\n+  {\n+    _M_init        = __max(_M_init, __o._M_init);\n+    _M_max         = __max(_M_max, __o._M_max);\n+    _M_item_max    = __max(_M_item_max, __o._M_item_max);\n+    _M_min         = __min(_M_min, __o._M_min);\n+    _M_item_min    = __min(_M_item_min, __o._M_item_min);\n+    _M_total      += __o._M_total;\n+    _M_item_total += __o._M_item_total;\n+    _M_count      += __o._M_count;\n+    _M_cost       += __o._M_cost;\n+    _M_resize     += __o._M_resize;\n+  }\n \n-inline void __trace_container_size::__destruct(const void* __obj, \n-                                               size_t __num, size_t __inum)\n-{\n-  if (!__is_on()) return;\n+  inline __container_size_info::__container_size_info()\n+  : _M_init(0), _M_max(0), _M_item_max(0), _M_min(0), _M_item_min(0),\n+    _M_total(0), _M_item_total(0), _M_cost(0), _M_count(0), _M_resize(0)\n+  { }\n+\n+  inline __container_size_info::__container_size_info(__stack_t __stack,\n+\t\t\t\t\t\t      size_t __num)\n+  : __object_info_base(__stack), _M_init(0), _M_max(0), _M_item_max(0),\n+    _M_min(0), _M_item_min(0), _M_total(0), _M_item_total(0), _M_cost(0),\n+    _M_count(0), _M_resize(0)\n+  {\n+    _M_init = _M_max = __num;\n+    _M_item_min = _M_item_max = _M_item_total = _M_total = 0;\n+    _M_min = 0;\n+    _M_count = 0;\n+    _M_resize = 0;\n+  }\n \n-  __object_t __obj_handle = static_cast<__object_t>(__obj);\n+  inline __container_size_info::__container_size_info(const __container_size_info& __o)\n+    : __object_info_base(__o)\n+  {\n+    _M_init        = __o._M_init;\n+    _M_max         = __o._M_max;\n+    _M_item_max    = __o._M_item_max;\n+    _M_min         = __o._M_min;\n+    _M_item_min    = __o._M_item_min;\n+    _M_total       = __o._M_total;\n+    _M_item_total  = __o._M_item_total;\n+    _M_cost        = __o._M_cost;\n+    _M_count       = __o._M_count;\n+    _M_resize      = __o._M_resize;\n+  }\n \n-  __container_size_info* __object_info = __get_object_info(__obj_handle);\n-  if (!__object_info)\n-    return;\n+  /** @brief A container size instrumentation line in the stack table.  */\n+  class __container_size_stack_info: public __container_size_info\n+  {\n+  public:\n+    __container_size_stack_info(const __container_size_info& __o)\n+    : __container_size_info(__o) { }\n+  };\n+\n+  /** @brief Container size instrumentation trace producer.  */\n+  class __trace_container_size\n+  : public __trace_base<__container_size_info, __container_size_stack_info>\n+  {\n+  public:\n+    __trace_container_size()\n+    : __trace_base<__container_size_info, __container_size_stack_info>() { };\n+\n+    ~__trace_container_size() { }\n+\n+    // Insert a new node at construct with object, callstack and initial size.\n+    void __insert(const __object_t __obj, __stack_t __stack, size_t __num);\n+\n+    // Call at destruction/clean to set container final size.\n+    void __destruct(const void* __obj, size_t __num, size_t __inum);\n+    void __construct(const void* __obj, size_t __inum);\n+\n+    // Call at resize to set resize/cost information.\n+    void __resize(const void* __obj, int __from, int __to);\n+  };\n+\n+  inline void \n+  __trace_container_size::__insert(const __object_t __obj,\n+\t\t\t\t   __stack_t __stack, size_t __num)\n+  { __add_object(__obj, __container_size_info(__stack, __num)); }\n+\n+  inline void \n+  __container_size_info::__write(FILE* __f) const\n+  {\n+    fprintf(__f, \"%Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu %Zu\\n\",\n+\t    _M_init, _M_count, _M_cost, _M_resize, _M_min, _M_max, _M_total,\n+\t    _M_item_min, _M_item_max, _M_item_total);\n+  }\n \n-  __object_info->__destruct(__num, __inum);\n-  __retire_object(__obj_handle);\n-}\n+  inline void \n+  __trace_container_size::__destruct(const void* __obj, size_t __num, \n+\t\t\t\t     size_t __inum)\n+  {\n+    if (!__is_on()) return;\n \n-inline void __trace_container_size::__resize(const void* __obj, int __from, \n-                                             int __to)\n-{\n-  if (!__is_on()) return;\n+    __object_t __obj_handle = static_cast<__object_t>(__obj);\n+\n+    __container_size_info* __object_info = __get_object_info(__obj_handle);\n+    if (!__object_info)\n+      return;\n \n-  __container_size_info* __object_info = __get_object_info(__obj);\n-  if (!__object_info)\n-    return;\n+    __object_info->__destruct(__num, __inum);\n+    __retire_object(__obj_handle);\n+  }\n+\n+  inline void \n+  __trace_container_size::__resize(const void* __obj, int __from, int __to)\n+  {\n+    if (!__is_on()) return;\n \n-  __object_info->__resize(__from, __to);\n-}\n+    __container_size_info* __object_info = __get_object_info(__obj);\n+    if (!__object_info)\n+      return;\n \n+    __object_info->__resize(__from, __to);\n+  }\n } // namespace __gnu_profile\n-#endif /* PROFCXX_PROFILER_CONTAINER_SIZE_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_CONTAINER_SIZE_H */"}, {"sha": "86859e5601ad4ecb9568c6ca694ae1cd8ca5e86d", "filename": "libstdc++-v3/include/profile/impl/profiler_hash_func.h", "status": "modified", "additions": 128, "deletions": 126, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hash_func.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_HASH_FUNC_H__\n-#define PROFCXX_PROFILER_HASH_FUNC_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_HASH_FUNC_H\n+#define _GLIBCXX_PROFILE_PROFILER_HASH_FUNC_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdlib>\n@@ -52,141 +52,143 @@\n \n namespace __gnu_profile\n {\n+  /** @brief A hash performance instrumentation line in the object table.  */\n+  class __hashfunc_info: public __object_info_base\n+  {\n+  public:\n+    __hashfunc_info() :_M_longest_chain(0), _M_accesses(0), _M_hops(0) { }\n+\n+    __hashfunc_info(const __hashfunc_info& o);\n+\n+    __hashfunc_info(__stack_t __stack) \n+    : __object_info_base(__stack), _M_longest_chain(0), \n+      _M_accesses(0), _M_hops(0) { }\n+\n+    virtual ~__hashfunc_info() { }\n+\n+    void __merge(const __hashfunc_info& __o);\n+    void __destruct(size_t __chain, size_t __accesses, size_t __hops);\n+    void __write(FILE* __f) const;\n+    float __magnitude() const { return static_cast<float>(_M_hops); }\n+    const char* __advice() const { return \"change hash function\"; }\n+\n+  private:\n+    size_t _M_longest_chain;\n+    size_t _M_accesses;\n+    size_t _M_hops;\n+  };\n+\n+  inline __hashfunc_info::__hashfunc_info(const __hashfunc_info& __o)\n+  : __object_info_base(__o)\n+  {\n+    _M_longest_chain = __o._M_longest_chain;\n+    _M_accesses      = __o._M_accesses;\n+    _M_hops          = __o._M_hops;\n+  }\n \n-/** @brief A hash performance instrumentation line in the object table.  */\n-class __hashfunc_info: public __object_info_base\n-{\n- public:\n-  __hashfunc_info()\n-      :_M_longest_chain(0), _M_accesses(0), _M_hops(0) {}\n-  __hashfunc_info(const __hashfunc_info& o);\n-  __hashfunc_info(__stack_t __stack)\n-      : __object_info_base(__stack),\n-        _M_longest_chain(0), _M_accesses(0), _M_hops(0){} \n-  virtual ~__hashfunc_info() {}\n-\n-  void __merge(const __hashfunc_info& __o);\n-  void __destruct(size_t __chain, size_t __accesses, size_t __hops);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return static_cast<float>(_M_hops); }\n-  const char* __advice() const { return \"change hash function\"; }\n-\n-private:\n-  size_t _M_longest_chain;\n-  size_t _M_accesses;\n-  size_t _M_hops;\n-};\n-\n-inline __hashfunc_info::__hashfunc_info(const __hashfunc_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_longest_chain = __o._M_longest_chain;\n-  _M_accesses      = __o._M_accesses;\n-  _M_hops          = __o._M_hops;\n-}\n-\n-inline void __hashfunc_info::__merge(const __hashfunc_info& __o)\n-{\n-  _M_longest_chain  = __max(_M_longest_chain, __o._M_longest_chain);\n-  _M_accesses      += __o._M_accesses;\n-  _M_hops          += __o._M_hops;\n-}\n-\n-inline void __hashfunc_info::__destruct(size_t __chain, size_t __accesses, \n-                                        size_t __hops)\n-{ \n-  _M_longest_chain  = __max(_M_longest_chain, __chain);\n-  _M_accesses      += __accesses;\n-  _M_hops          += __hops;\n-}\n-\n-/** @brief A hash performance instrumentation line in the stack table.  */\n-class __hashfunc_stack_info: public __hashfunc_info {\n- public:\n-  __hashfunc_stack_info(const __hashfunc_info& __o) : __hashfunc_info(__o) {}\n-};\n-\n-/** @brief Hash performance instrumentation producer.  */\n-class __trace_hash_func\n-    : public __trace_base<__hashfunc_info, __hashfunc_stack_info> \n-{\n- public:\n-  __trace_hash_func();\n-  ~__trace_hash_func() {}\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(__object_t __obj, __stack_t __stack);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj, size_t __chain,\n-                  size_t __accesses, size_t __hops);\n-};\n-\n-inline __trace_hash_func::__trace_hash_func()\n-    : __trace_base<__hashfunc_info, __hashfunc_stack_info>()\n-{\n-  __id = \"hash-distr\";\n-}\n-\n-inline void __trace_hash_func::__insert(__object_t __obj, __stack_t __stack)\n-{\n-  __add_object(__obj, __hashfunc_info(__stack));\n-}\n-\n-inline void __hashfunc_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain);\n-}\n-\n-inline void __trace_hash_func::__destruct(const void* __obj, size_t __chain,\n-                                          size_t __accesses, size_t __hops)\n-{\n-  if (!__is_on()) return;\n+  inline void \n+  __hashfunc_info::__merge(const __hashfunc_info& __o)\n+  {\n+    _M_longest_chain  = __max(_M_longest_chain, __o._M_longest_chain);\n+    _M_accesses      += __o._M_accesses;\n+    _M_hops          += __o._M_hops;\n+  }\n \n-  // First find the item from the live objects and update the informations.\n-  __hashfunc_info* __objs = __get_object_info(__obj);\n-  if (!__objs)\n-    return;\n+  inline void \n+  __hashfunc_info::__destruct(size_t __chain, size_t __accesses, size_t __hops)\n+  {\n+    _M_longest_chain  = __max(_M_longest_chain, __chain);\n+    _M_accesses      += __accesses;\n+    _M_hops          += __hops;\n+  }\n \n-  __objs->__destruct(__chain, __accesses, __hops);\n-  __retire_object(__obj);\n-}\n+  /** @brief A hash performance instrumentation line in the stack table.  */\n+  class __hashfunc_stack_info: public __hashfunc_info \n+  {\n+  public:\n+    __hashfunc_stack_info(const __hashfunc_info& __o) : __hashfunc_info(__o) { }\n+  };\n+\n+  /** @brief Hash performance instrumentation producer.  */\n+  class __trace_hash_func\n+  : public __trace_base<__hashfunc_info, __hashfunc_stack_info>\n+  {\n+  public:\n+    __trace_hash_func();\n+    ~__trace_hash_func() { }\n+\n+    // Insert a new node at construct with object, callstack and initial size.\n+    void __insert(__object_t __obj, __stack_t __stack);\n+\n+    // Call at destruction/clean to set container final size.\n+    void __destruct(const void* __obj, size_t __chain, size_t __accesses, \n+\t\t    size_t __hops);\n+  };\n+\n+  inline __trace_hash_func::__trace_hash_func()\n+  : __trace_base<__hashfunc_info, __hashfunc_stack_info>()\n+  { __id = \"hash-distr\"; }\n+\n+  inline void \n+  __trace_hash_func::__insert(__object_t __obj, __stack_t __stack)\n+  { __add_object(__obj, __hashfunc_info(__stack)); }\n+\n+  inline void \n+  __hashfunc_info::__write(FILE* __f) const\n+  { fprintf(__f, \"%Zu %Zu %Zu\\n\", _M_hops, _M_accesses, _M_longest_chain); }\n+\n+  inline void \n+  __trace_hash_func::__destruct(const void* __obj, size_t __chain,\n+\t\t\t\tsize_t __accesses, size_t __hops)\n+  {\n+    if (!__is_on()) \n+      return;\n+\n+    // First find the item from the live objects and update the informations.\n+    __hashfunc_info* __objs = __get_object_info(__obj);\n+    if (!__objs)\n+      return;\n+\n+    __objs->__destruct(__chain, __accesses, __hops);\n+    __retire_object(__obj);\n+  }\n \n-//////////////////////////////////////////////////////////////////////////////\n-// Initialization and report.\n-//////////////////////////////////////////////////////////////////////////////\n \n-inline void __trace_hash_func_init()\n-{\n-  __tables<0>::_S_hash_func = new __trace_hash_func();\n-}\n+  // Initialization and report.\n+  inline void \n+  __trace_hash_func_init()\n+  { __tables<0>::_S_hash_func = new __trace_hash_func(); }\n \n-inline void __trace_hash_func_report(FILE* __f,\n-                                     __warning_vector_t& __warnings)\n-{\n-  if (__tables<0>::_S_hash_func) {\n-    __tables<0>::_S_hash_func->__collect_warnings(__warnings);\n-    __tables<0>::_S_hash_func->__write(__f);\n+  inline void \n+  __trace_hash_func_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (__tables<0>::_S_hash_func) \n+      {\n+\t__tables<0>::_S_hash_func->__collect_warnings(__warnings);\n+\t__tables<0>::_S_hash_func->__write(__f);\n+      }\n   }\n-}\n \n-//////////////////////////////////////////////////////////////////////////////\n-// Implementations of instrumentation hooks.\n-//////////////////////////////////////////////////////////////////////////////\n \n-inline void __trace_hash_func_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  // Implementations of instrumentation hooks.\n+  inline void \n+  __trace_hash_func_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __tables<0>::_S_hash_func->__insert(__obj, __get_stack());\n-}\n+    __tables<0>::_S_hash_func->__insert(__obj, __get_stack());\n+  }\n \n-inline void __trace_hash_func_destruct(const void* __obj, size_t __chain,\n-                                       size_t __accesses, size_t __hops)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_hash_func_destruct(const void* __obj, size_t __chain,\n+\t\t\t     size_t __accesses, size_t __hops)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __tables<0>::_S_hash_func->__destruct(__obj, __chain, __accesses, __hops);\n-}\n+    __tables<0>::_S_hash_func->__destruct(__obj, __chain, __accesses, __hops);\n+  }\n \n } // namespace __gnu_profile\n-#endif /* PROFCXX_PROFILER_HASH_FUNC_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_HASH_FUNC_H */"}, {"sha": "da89c071138e88a574b049e2c776d1a36524c3d1", "filename": "libstdc++-v3/include/profile/impl/profiler_hashtable_size.h", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_hashtable_size.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_HASHTABLE_SIZE_H__\n-#define PROFCXX_PROFILER_HASHTABLE_SIZE_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_HASHTABLE_SIZE_H\n+#define _GLIBCXX_PROFILE_PROFILER_HASHTABLE_SIZE_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdlib>\n@@ -54,62 +54,58 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief Hashtable size instrumentation trace producer.  */\n-class __trace_hashtable_size : public __trace_container_size\n-{\n- public:\n-  __trace_hashtable_size() : __trace_container_size()\n+  /** @brief Hashtable size instrumentation trace producer.  */\n+  class __trace_hashtable_size : public __trace_container_size\n   {\n-    __id = \"hashtable-size\";\n+  public:\n+    __trace_hashtable_size() : __trace_container_size()\n+    { __id = \"hashtable-size\"; }\n+  };\n+\n+  // Initialization and report.\n+  inline void\n+  __trace_hashtable_size_init()\n+  { __tables<0>::_S_hashtable_size = new __trace_hashtable_size(); }\n+\n+  inline void\n+  __trace_hashtable_size_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (__tables<0>::_S_hashtable_size)\n+      {\n+\t__tables<0>::_S_hashtable_size->__collect_warnings(__warnings);\n+\t__tables<0>::_S_hashtable_size->__write(__f);\n+      }\n   }\n-};\n-\n-//////////////////////////////////////////////////////////////////////////////\n-// Initialization and report.\n-//////////////////////////////////////////////////////////////////////////////\n \n-inline void __trace_hashtable_size_init()\n-{\n-  __tables<0>::_S_hashtable_size = new __trace_hashtable_size();\n-}\n+  // Implementations of instrumentation hooks.\n+  inline void\n+  __trace_hashtable_size_construct(const void* __obj, size_t __num)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-inline void __trace_hashtable_size_report(FILE* __f, \n-                                          __warning_vector_t& __warnings)\n-{\n-  if (__tables<0>::_S_hashtable_size) {\n-    __tables<0>::_S_hashtable_size->__collect_warnings(__warnings);\n-    __tables<0>::_S_hashtable_size->__write(__f);\n+    __tables<0>::_S_hashtable_size->__insert(__obj, __get_stack(), __num);\n   }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-// Implementations of instrumentation hooks.\n-//////////////////////////////////////////////////////////////////////////////\n \n-inline void __trace_hashtable_size_construct(const void* __obj, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n-  \n-  __tables<0>::_S_hashtable_size->__insert(__obj, __get_stack(), __num);\n-}\n-\n-inline void __trace_hashtable_size_destruct(const void* __obj, size_t __num, \n-                                            size_t __inum)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hashtable_size_destruct(const void* __obj, size_t __num,\n+\t\t\t\t  size_t __inum)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  __tables<0>::_S_hashtable_size->__destruct(__obj, __num, __inum);\n-}\n+    __tables<0>::_S_hashtable_size->__destruct(__obj, __num, __inum);\n+  }\n \n-inline void __trace_hashtable_size_resize(const void* __obj, size_t __from, \n-                                          size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void\n+  __trace_hashtable_size_resize(const void* __obj, size_t __from, size_t __to)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  __tables<0>::_S_hashtable_size->__resize(__obj, __from, __to);\n-}\n+    __tables<0>::_S_hashtable_size->__resize(__obj, __from, __to);\n+  }\n \n } // namespace __gnu_profile\n \n-#endif /* PROFCXX_PROFILER_HASHTABLE_SIZE_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_HASHTABLE_SIZE_H */"}, {"sha": "6c90e7a0377b217e959d5b7ac191d76842e92680", "filename": "libstdc++-v3/include/profile/impl/profiler_map_to_unordered_map.h", "status": "modified", "additions": 243, "deletions": 222, "changes": 465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_map_to_unordered_map.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_MAP_TO_UNORDERED_MAP_H__\n-#define PROFCXX_PROFILER_MAP_TO_UNORDERED_MAP_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_MAP_TO_UNORDERED_MAP_H\n+#define _GLIBCXX_PROFILE_PROFILER_MAP_TO_UNORDERED_MAP_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdlib>\n@@ -52,254 +52,275 @@\n \n namespace __gnu_profile\n {\n-\n-// Cost model. XXX: this must be taken from the machine model instead.\n-//  Map operations:\n-//   - insert: 1.5 * log(size)\n-//   - erase: 1.5 * log(size)\n-//   - find: log(size)\n-//   - iterate: 2.3\n-//  Unordered map operations:\n-//   - insert: 12\n-//   - erase: 12\n-//   - find: 10\n-//   - iterate: 1.7\n-\n-const float __map_insert_cost_factor = 1.5;\n-const float __map_erase_cost_factor = 1.5;\n-const float __map_find_cost_factor = 1;\n-const float __map_iterate_cost = 2.3;\n-\n-const float __umap_insert_cost = 12.0;\n-const float __umap_erase_cost = 12.0;\n-const float __umap_find_cost = 10.0;\n-const float __umap_iterate_cost = 1.7;\n-\n-inline int __log2(size_t __size)\n-{\n-  for (int __bit_count = sizeof(size_t) - 1; __bit_count >= 0; --__bit_count) {\n-    if ((2 << __bit_count) & __size) {\n-      return __bit_count;\n-    }\n+  // Cost model. \n+  //  Map operations:\n+  //   - insert: 1.5 * log(size)\n+  //   - erase: 1.5 * log(size)\n+  //   - find: log(size)\n+  //   - iterate: 2.3\n+  //  Unordered map operations:\n+  //   - insert: 12\n+  //   - erase: 12\n+  //   - find: 10\n+  //   - iterate: 1.7\n+  // XXX: this must be taken from the machine model instead.\n+  const float __map_insert_cost_factor = 1.5;\n+  const float __map_erase_cost_factor = 1.5;\n+  const float __map_find_cost_factor = 1;\n+  const float __map_iterate_cost = 2.3;\n+\n+  const float __umap_insert_cost = 12.0;\n+  const float __umap_erase_cost = 12.0;\n+  const float __umap_find_cost = 10.0;\n+  const float __umap_iterate_cost = 1.7;\n+\n+  inline int \n+  __log2(size_t __size)\n+  {\n+    int __bit_count = sizeof(size_t) - 1;\n+    for (; __bit_count >= 0; --__bit_count) \n+      {\n+\tif ((2 << __bit_count) & __size)\n+\t  return __bit_count;\n+      }\n+    return 0;\n   }\n-  return 0;\n-}\n-\n-inline float __map_insert_cost(size_t __size)\n-{\n-  return __map_insert_cost_factor * static_cast<float>(__log2(__size));\n-}\n-\n-inline float __map_erase_cost(size_t __size)\n-{\n-  return __map_erase_cost_factor * static_cast<float>(__log2(__size));\n-}\n-\n-inline float __map_find_cost(size_t __size)\n-{\n-  return __map_find_cost_factor * static_cast<float>(__log2(__size));\n-}\n-\n-/** @brief A map-to-unordered_map instrumentation line in the object table.  */\n-class __map2umap_info: public __object_info_base\n-{\n- public:\n-  __map2umap_info()\n-      : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n-        _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {}\n-  __map2umap_info(__stack_t __stack)\n-      : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n-        _M_iterate(0), _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) {} \n-  virtual ~__map2umap_info() {}\n-  __map2umap_info(const __map2umap_info& o);\n-  void __merge(const __map2umap_info& o);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return _M_map_cost - _M_umap_cost; }\n-  const char* __advice() const;\n-\n-  void __record_insert(size_t __size, size_t __count);\n-  void __record_erase(size_t __size, size_t __count);\n-  void __record_find(size_t __size);\n-  void __record_iterate(size_t __count);\n-  void __record_invalidate();\n-\n- private:\n-  size_t _M_insert;\n-  size_t _M_erase;\n-  size_t _M_find;\n-  size_t _M_iterate;\n-  float _M_umap_cost;\n-  float _M_map_cost;\n-  bool  _M_valid;\n-};\n-\n-inline const char* __map2umap_info::__advice() const\n-{\n-  return \"change std::map to std::unordered_map\";\n-}\n-\n-inline __map2umap_info::__map2umap_info(const __map2umap_info& __o)\n-    : __object_info_base(__o), \n-      _M_insert(__o._M_insert),\n-      _M_erase(__o._M_erase),\n-      _M_find(__o._M_find),\n-      _M_iterate(__o._M_iterate),\n-      _M_map_cost(__o._M_map_cost),\n-      _M_umap_cost(__o._M_umap_cost),\n-      _M_valid(__o._M_valid)\n-{}\n-\n-inline void __map2umap_info::__merge(const __map2umap_info& __o)\n-{\n-  _M_insert    += __o._M_insert;\n-  _M_erase     += __o._M_erase;\n-  _M_find      += __o._M_find;\n-  _M_map_cost  += __o._M_map_cost;\n-  _M_umap_cost += __o._M_umap_cost;\n-  _M_valid     &= __o._M_valid;\n-}\n-\n-inline void __map2umap_info:: __record_insert(size_t __size, size_t __count)\n-{\n-  _M_insert += __count;\n-  _M_map_cost += __count * __map_insert_cost(__size);\n-  _M_umap_cost += __count * __umap_insert_cost;\n-}\n-\n-inline void __map2umap_info:: __record_erase(size_t __size, size_t __count)\n-{\n-  _M_erase += __count;\n-  _M_map_cost += __count * __map_erase_cost(__size);\n-  _M_umap_cost += __count * __umap_erase_cost;\n-}\n-\n-inline void __map2umap_info:: __record_find(size_t __size)\n-{\n-  _M_find += 1;\n-  _M_map_cost += __map_find_cost(__size);\n-  _M_umap_cost += __umap_find_cost;\n-}\n-\n-inline void __map2umap_info:: __record_iterate(size_t __count)\n-{\n-  _M_iterate += __count;\n-  _M_map_cost += __count * __map_iterate_cost;\n-  _M_umap_cost += __count * __umap_iterate_cost;\n-}\n \n-inline void __map2umap_info:: __record_invalidate()\n-{\n-  _M_valid = false;\n-}\n+  inline float \n+  __map_insert_cost(size_t __size)\n+  { return __map_insert_cost_factor * static_cast<float>(__log2(__size)); }\n+\n+  inline float \n+  __map_erase_cost(size_t __size)\n+  { return __map_erase_cost_factor * static_cast<float>(__log2(__size)); }\n+\n+  inline float \n+  __map_find_cost(size_t __size)\n+  { return __map_find_cost_factor * static_cast<float>(__log2(__size)); }\n+\n+  /** @brief A map-to-unordered_map instrumentation line in the object table. */\n+  class __map2umap_info: public __object_info_base\n+  {\n+  public:\n+    __map2umap_info()\n+    : _M_insert(0), _M_erase(0), _M_find(0), _M_iterate(0),\n+      _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) { }\n+\n+    __map2umap_info(__stack_t __stack)\n+    : __object_info_base(__stack), _M_insert(0), _M_erase(0), _M_find(0), \n+      _M_iterate(0), _M_map_cost(0.0), _M_umap_cost(0.0), _M_valid(true) { } \n+\n+    virtual ~__map2umap_info() { }\n+\n+    __map2umap_info(const __map2umap_info& o);\n+\n+    void __merge(const __map2umap_info& o);\n+    void __write(FILE* __f) const;\n+    float __magnitude() const { return _M_map_cost - _M_umap_cost; }\n+    const char* __advice() const;\n+\n+    void __record_insert(size_t __size, size_t __count);\n+    void __record_erase(size_t __size, size_t __count);\n+    void __record_find(size_t __size);\n+    void __record_iterate(size_t __count);\n+    void __record_invalidate();\n+\n+  private:\n+    size_t _M_insert;\n+    size_t _M_erase;\n+    size_t _M_find;\n+    size_t _M_iterate;\n+    float _M_umap_cost;\n+    float _M_map_cost;\n+    bool  _M_valid;\n+  };\n+\n+  inline __map2umap_info::__map2umap_info(const __map2umap_info& __o)\n+  : __object_info_base(__o), \n+    _M_insert(__o._M_insert),\n+    _M_erase(__o._M_erase),\n+    _M_find(__o._M_find),\n+    _M_iterate(__o._M_iterate),\n+    _M_map_cost(__o._M_map_cost),\n+    _M_umap_cost(__o._M_umap_cost),\n+    _M_valid(__o._M_valid)\n+  { }\n+\n+  inline const char* \n+  __map2umap_info::__advice() const\n+  { return \"change std::map to std::unordered_map\"; }\n+\n+  inline void \n+  __map2umap_info::__merge(const __map2umap_info& __o)\n+  {\n+    _M_insert    += __o._M_insert;\n+    _M_erase     += __o._M_erase;\n+    _M_find      += __o._M_find;\n+    _M_map_cost  += __o._M_map_cost;\n+    _M_umap_cost += __o._M_umap_cost;\n+    _M_valid     &= __o._M_valid;\n+  }\n \n-inline void __map2umap_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n-          _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost, _M_umap_cost,\n-          _M_valid ? \"valid\" : \"invalid\");\n-}\n+  inline void \n+  __map2umap_info:: __record_insert(size_t __size, size_t __count)\n+  {\n+    _M_insert += __count;\n+    _M_map_cost += __count * __map_insert_cost(__size);\n+    _M_umap_cost += __count * __umap_insert_cost;\n+  }\n \n-/** @brief A map-to-unordered_map instrumentation line in the stack table.  */\n-class __map2umap_stack_info: public __map2umap_info\n-{\n- public:\n-  __map2umap_stack_info(const __map2umap_info& o) : __map2umap_info(o) {}\n-};\n+  inline void \n+  __map2umap_info:: __record_erase(size_t __size, size_t __count)\n+  {\n+    _M_erase += __count;\n+    _M_map_cost += __count * __map_erase_cost(__size);\n+    _M_umap_cost += __count * __umap_erase_cost;\n+  }\n \n-/** @brief Map-to-unordered_map instrumentation producer.  */\n-class __trace_map2umap\n-    : public __trace_base<__map2umap_info, __map2umap_stack_info> \n-{\n- public:\n-  __trace_map2umap();\n-};\n+  inline void \n+  __map2umap_info:: __record_find(size_t __size)\n+  {\n+    _M_find += 1;\n+    _M_map_cost += __map_find_cost(__size);\n+    _M_umap_cost += __umap_find_cost;\n+  }\n \n-inline __trace_map2umap::__trace_map2umap()\n-    : __trace_base<__map2umap_info, __map2umap_stack_info>()\n-{\n-  __id = \"map-to-unordered-map\";\n-}\n+  inline void \n+  __map2umap_info:: __record_iterate(size_t __count)\n+  {\n+    _M_iterate += __count;\n+    _M_map_cost += __count * __map_iterate_cost;\n+    _M_umap_cost += __count * __umap_iterate_cost;\n+  }\n \n-inline void __trace_map_to_unordered_map_init()\n-{\n-  __tables<0>::_S_map2umap = new __trace_map2umap();\n-}\n+  inline void \n+  __map2umap_info:: __record_invalidate()\n+  {\n+    _M_valid = false;\n+  }\n \n-inline void __trace_map_to_unordered_map_report(\n-    FILE* __f, __warning_vector_t& __warnings)\n-{\n-  if (__tables<0>::_S_map2umap) {\n-    __tables<0>::_S_map2umap->__collect_warnings(__warnings);\n-    __tables<0>::_S_map2umap->__write(__f);\n+  inline void \n+  __map2umap_info::__write(FILE* __f) const\n+  {\n+    fprintf(__f, \"%Zu %Zu %Zu %Zu %.0f %.0f %s\\n\",\n+\t    _M_insert, _M_erase, _M_find, _M_iterate, _M_map_cost, _M_umap_cost,\n+\t    _M_valid ? \"valid\" : \"invalid\");\n   }\n-}\n \n-//////////////////////////////////////////////////////////////////////////////\n-// Implementations of instrumentation hooks.\n-//////////////////////////////////////////////////////////////////////////////\n+  /** @brief A map-to-unordered_map instrumentation line in the stack table.  */\n+  class __map2umap_stack_info: public __map2umap_info\n+  {\n+  public:\n+    __map2umap_stack_info(const __map2umap_info& o) : __map2umap_info(o) { }\n+  };\n+\n+  /** @brief Map-to-unordered_map instrumentation producer.  */\n+  class __trace_map2umap\n+  : public __trace_base<__map2umap_info, __map2umap_stack_info> \n+  {\n+  public:\n+    __trace_map2umap();\n+  };\n+\n+  inline __trace_map2umap::__trace_map2umap()\n+  : __trace_base<__map2umap_info, __map2umap_stack_info>()\n+  { __id = \"map-to-unordered-map\"; }\n+\n+  inline void \n+  __trace_map_to_unordered_map_init()\n+  { __tables<0>::_S_map2umap = new __trace_map2umap(); }\n+\n+  inline void \n+  __trace_map_to_unordered_map_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (__tables<0>::_S_map2umap) \n+      {\n+\t__tables<0>::_S_map2umap->__collect_warnings(__warnings);\n+\t__tables<0>::_S_map2umap->__write(__f);\n+      }\n+  }\n \n-inline void __trace_map_to_unordered_map_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  // Implementations of instrumentation hooks.\n+  inline void \n+  __trace_map_to_unordered_map_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __tables<0>::_S_map2umap->__add_object(__obj, \n-                                         __map2umap_info(__get_stack()));\n-}\n+    __tables<0>::_S_map2umap->__add_object(__obj, \n+\t\t\t\t\t   __map2umap_info(__get_stack()));\n+  }\n \n-inline void __trace_map_to_unordered_map_destruct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_map_to_unordered_map_destruct(const void* __obj)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __tables<0>::_S_map2umap->__retire_object(__obj);\n-}\n+    __tables<0>::_S_map2umap->__retire_object(__obj);\n+  }\n \n-inline void __trace_map_to_unordered_map_insert(const void* __obj, \n-                                                size_t __size, size_t __count)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_map_to_unordered_map_insert(const void* __obj, size_t __size, \n+\t\t\t\t      size_t __count)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n \n-  if (__info) __info->__record_insert(__size, __count);\n-}\n+    if (__info) \n+      __info->__record_insert(__size, __count);\n+  }\n \n-inline void __trace_map_to_unordered_map_erase(const void* __obj, \n-                                               size_t __size, size_t __count)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_map_to_unordered_map_erase(const void* __obj, size_t __size, \n+\t\t\t\t     size_t __count)\n+  {\n+    if (!__profcxx_init())\n+      return;\n \n-  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n \n-  if (__info) __info->__record_erase(__size, __count);\n-}\n+    if (__info) \n+      __info->__record_erase(__size, __count);\n+  }\n \n-inline void __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_map_to_unordered_map_find(const void* __obj, size_t __size)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n \n-  if (__info) __info->__record_find(__size);\n-}\n+    if (__info) \n+      __info->__record_find(__size);\n+  }\n \n-inline void __trace_map_to_unordered_map_iterate(const void* __obj, \n-                                                 size_t __count)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_map_to_unordered_map_iterate(const void* __obj, size_t __count)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n \n-  if (__info) __info->__record_iterate(__count);\n-}\n+    if (__info) \n+      __info->__record_iterate(__count);\n+  }\n \n-inline void __trace_map_to_unordered_map_invalidate(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_map_to_unordered_map_invalidate(const void* __obj)\n+  {\n+    if (!__profcxx_init()) \n+      return;\n \n-  __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n+    __map2umap_info* __info = __tables<0>::_S_map2umap->__get_object_info(__obj);\n \n-  if (__info) __info->__record_invalidate();\n-}\n+    if (__info) \n+      __info->__record_invalidate();\n+  }\n \n } // namespace __gnu_profile\n-#endif /* PROFCXX_PROFILER_MAP_TO_UNORDERED_MAP_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_MAP_TO_UNORDERED_MAP_H */"}, {"sha": "66101a7ef71ce93c22553edb26c4604bb0ab191b", "filename": "libstdc++-v3/include/profile/impl/profiler_node.h", "status": "modified", "additions": 94, "deletions": 98, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_node.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_NODE_H__\n-#define PROFCXX_PROFILER_NODE_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_NODE_H\n+#define _GLIBCXX_PROFILE_PROFILER_NODE_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdio>\n@@ -53,120 +53,116 @@\n \n namespace __gnu_profile\n {\n-typedef const void* __object_t;\n-typedef void* __instruction_address_t;\n-typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n-typedef __stack_npt* __stack_t;\n+  typedef const void* __object_t;\n+  typedef void* __instruction_address_t;\n+  typedef std::_GLIBCXX_STD_PR::vector<__instruction_address_t> __stack_npt;\n+  typedef __stack_npt* __stack_t;\n \n-size_t __stack_max_depth();\n+  size_t __stack_max_depth();\n \n-inline __stack_t __get_stack()\n-{\n+  inline __stack_t __get_stack()\n+  {\n #if defined HAVE_EXECINFO_H\n-  size_t __max_depth = __stack_max_depth();\n-  if (__max_depth == 0)\n-    return NULL;\n-  __stack_npt __buffer(__max_depth);\n-  int __depth = backtrace(&__buffer[0], __max_depth);\n-  __stack_t __stack = new __stack_npt(__depth);\n-  memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n-  return __stack;\n+    size_t __max_depth = __stack_max_depth();\n+    if (__max_depth == 0)\n+      return NULL;\n+    __stack_npt __buffer(__max_depth);\n+    int __depth = backtrace(&__buffer[0], __max_depth);\n+    __stack_t __stack = new __stack_npt(__depth);\n+    memcpy(&(*__stack)[0], &__buffer[0], __depth * sizeof(__object_t));\n+    return __stack;\n #else\n-  return NULL;\n+    return NULL;\n #endif\n-}\n-\n-inline __size(const __stack_t& __stack)\n-{\n-  if (!__stack) {\n-    return 0;\n-  } else {\n-    return __stack->size();\n   }\n-}\n \n-inline void __write(FILE* __f, const __stack_t __stack)\n-{\n-  if (!__stack) {\n-    return;\n-  }\n-\n-  __stack_npt::const_iterator __it;\n-  for (__it = __stack->begin(); __it != __stack->end(); ++__it) {\n-    fprintf(__f, \"%p \", *__it);\n+  inline __size(const __stack_t& __stack)\n+  {\n+    if (!__stack)\n+      return 0;\n+    else\n+      return __stack->size();\n   }\n-}\n \n-/** @brief Hash function for summary trace using call stack as index.  */\n-class __stack_hash \n-{\n- public:\n-  size_t operator()(const __stack_t __s) const\n+  inline void __write(FILE* __f, const __stack_t __stack)\n   {\n-    if (!__s) {\n-      return 0;\n-    }\n+    if (!__stack)\n+      return;\n \n-    uintptr_t __index = 0;\n     __stack_npt::const_iterator __it;\n-    for (__it = __s->begin(); __it != __s->end(); ++__it) {\n-      __index += reinterpret_cast<uintptr_t>(*__it);\n-    } \n-    return __index;\n+    for (__it = __stack->begin(); __it != __stack->end(); ++__it)\n+      fprintf(__f, \"%p \", *__it);\n   }\n \n-  bool operator() (const __stack_t __stack1, const __stack_t __stack2) const\n+  /** @brief Hash function for summary trace using call stack as index.  */\n+  class __stack_hash\n   {\n-    if (!__stack1 && !__stack2) return true;\n-    if (!__stack1 || !__stack2) return false;\n-    if (__stack1->size() != __stack2->size()) return false;\n+  public:\n+    size_t operator()(const __stack_t __s) const\n+    {\n+      if (!__s)\n+\treturn 0;\n+      \n+      uintptr_t __index = 0;\n+      __stack_npt::const_iterator __it;\n+      for (__it = __s->begin(); __it != __s->end(); ++__it) \n+\t{\n+\t  __index += reinterpret_cast<uintptr_t>(*__it);\n+\t}\n+      return __index;\n+    }\n \n-    size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n-    return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n-  }\n-};\n+    bool operator() (const __stack_t __stack1, const __stack_t __stack2) const\n+    {\n+      if (!__stack1 && !__stack2) return true;\n+      if (!__stack1 || !__stack2) return false;\n+      if (__stack1->size() != __stack2->size()) return false;\n \n-/** @brief Base class for a line in the object table.  */\n-class __object_info_base\n-{\n- public:\n-  __object_info_base() {}\n-  __object_info_base(__stack_t __stack);\n-  __object_info_base(const __object_info_base& o);\n-  virtual ~__object_info_base() {}\n-  bool __is_valid() const { return _M_valid; }\n-  __stack_t __stack() const { return _M_stack; }\n-  virtual void __write(FILE* f) const = 0;\n-\n- protected:\n-  __stack_t _M_stack;\n-  bool _M_valid;\n-};\n-\n-inline __object_info_base::__object_info_base(__stack_t __stack)\n-{\n-  _M_stack = __stack;\n-  _M_valid = true;\n-}\n+      size_t __byte_size = __stack1->size() * sizeof(__stack_npt::value_type);\n+      return memcmp(&(*__stack1)[0], &(*__stack2)[0], __byte_size) == 0;\n+    }\n+  };\n \n-inline __object_info_base::__object_info_base(const __object_info_base& __o)\n-{\n-  _M_stack = __o._M_stack;\n-  _M_valid = __o._M_valid;\n-}\n+  /** @brief Base class for a line in the object table.  */\n+  class __object_info_base\n+  {\n+  public:\n+    __object_info_base() { }\n+    __object_info_base(__stack_t __stack);\n+    __object_info_base(const __object_info_base& o);\n+    virtual ~__object_info_base() { }\n+    bool __is_valid() const { return _M_valid; }\n+    __stack_t __stack() const { return _M_stack; }\n+    virtual void __write(FILE* f) const = 0;\n+\n+  protected:\n+    __stack_t _M_stack;\n+    bool _M_valid;\n+  };\n+\n+  inline __object_info_base::__object_info_base(__stack_t __stack)\n+  {\n+    _M_stack = __stack;\n+    _M_valid = true;\n+  }\n \n-/** @brief Base class for a line in the stack table.  */\n-template<typename __object_info>\n-class __stack_info_base\n-{\n- public:\n-  __stack_info_base() {}\n-  __stack_info_base(const __object_info& __info) = 0;\n-  virtual ~__stack_info_base() {}\n-  void __merge(const __object_info& __info) = 0;\n-  virtual float __magnitude() const = 0;\n-  virtual const char* __get_id() const = 0;\n-};\n+  inline __object_info_base::__object_info_base(const __object_info_base& __o)\n+  {\n+    _M_stack = __o._M_stack;\n+    _M_valid = __o._M_valid;\n+  }\n \n+  /** @brief Base class for a line in the stack table.  */\n+  template<typename __object_info>\n+    class __stack_info_base\n+    {\n+    public:\n+      __stack_info_base() { }\n+      __stack_info_base(const __object_info& __info) = 0;\n+      virtual ~__stack_info_base() { }\n+      void __merge(const __object_info& __info) = 0;\n+      virtual float __magnitude() const = 0;\n+      virtual const char* __get_id() const = 0;\n+    };\n } // namespace __gnu_profile\n-#endif /* PROFCXX_PROFILER_NODE_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_NODE_H */"}, {"sha": "347b5e248b0bd3a3c04201d14dd69e569f53dd1d", "filename": "libstdc++-v3/include/profile/impl/profiler_state.h", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_state.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_STATE_H__\n-#define PROFCXX_PROFILER_STATE_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_STATE_H\n+#define _GLIBCXX_PROFILE_PROFILER_STATE_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdio>\n@@ -45,63 +45,64 @@\n \n namespace __gnu_profile\n {\n+  /** @brief Profiling mode on/off state.  */\n+  template<int _Unused=0>\n+    class __state\n+    {\n+    private:\n+      enum __state_type { __ON, __OFF, __INVALID };\n+\n+      __state_type \t\t_M_state;\n+\n+    public:\n+      static __state<_Unused>* \t_S_diag_state;\n+\n+      __state() : _M_state(__INVALID) { }\n+      ~__state() { }\n+\n+      bool __is_on() { return _M_state == __ON; }\n+      bool __is_off() { return _M_state == __OFF; }\n+      bool __is_invalid() { return _M_state == __INVALID; }\n+      void __turn_on() { _M_state = __ON; }\n+      void __turn_off() { _M_state = __OFF; }\n+    };\n+\n+  template<int _Unused>\n+    __state<_Unused>* __state<_Unused>::_S_diag_state = NULL;\n+\n+  inline bool \n+  __is_on()\n+  {\n+    return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_on();\n+  }\n \n-/** @brief Profiling mode on/off state.  */\n-template <int _Unused=0>\n-class __state\n-{\n- public:\n-\n-  static __state<_Unused>* _S_diag_state;\n-\n-  __state() : _M_state(__INVALID) {}\n-  ~__state() {}\n-\n-  bool __is_on() { return _M_state == __ON; }\n-  bool __is_off() { return _M_state == __OFF; }\n-  bool __is_invalid() { return _M_state == __INVALID; }\n-  void __turn_on() { _M_state = __ON; }\n-  void __turn_off() { _M_state = __OFF; }\n-\n- private:\n-  enum __state_type { __ON, __OFF, __INVALID };\n-  __state_type _M_state;\n-};\n-\n-template <int _Unused>\n-__state<_Unused>* __state<_Unused>::_S_diag_state = NULL;\n-\n-inline bool __is_on()\n-{\n-  return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_on();\n-}\n-\n-inline bool __is_off()\n-{\n-  return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_off();\n-}\n+  inline bool \n+  __is_off()\n+  {\n+    return __state<0>::_S_diag_state && __state<0>::_S_diag_state->__is_off();\n+  }\n \n-inline bool __is_invalid()\n-{\n-  return (!__state<0>::_S_diag_state \n-          || __state<0>::_S_diag_state->__is_invalid());\n-}\n+  inline bool \n+  __is_invalid()\n+  {\n+    return (!__state<0>::_S_diag_state || __state<0>::_S_diag_state->__is_invalid());\n+  }\n \n-inline void __turn_on()\n-{\n-  if (!__state<0>::_S_diag_state) { \n-    __state<0>::_S_diag_state = new __state<0>();\n+  inline void \n+  __turn_on()\n+  {\n+    if (!__state<0>::_S_diag_state)\n+      __state<0>::_S_diag_state = new __state<0>();\n+    __state<0>::_S_diag_state->__turn_on();\n   }\n-  __state<0>::_S_diag_state->__turn_on();\n-}\n \n-inline void __turn_off()\n-{\n-  if (!__state<0>::_S_diag_state) { \n-    __state<0>::_S_diag_state = new __state<0>();\n+  inline void \n+  __turn_off()\n+  {\n+    if (!__state<0>::_S_diag_state)\n+      __state<0>::_S_diag_state = new __state<0>();\n+    __state<0>::_S_diag_state->__turn_off();\n   }\n-  __state<0>::_S_diag_state->__turn_off();\n-}\n \n } // end namespace __gnu_profile\n-#endif /* PROFCXX_PROFILER_STATE_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_STATE_H */"}, {"sha": "173b647421b78abb1a0ae39715685ae3f3b7d88a", "filename": "libstdc++-v3/include/profile/impl/profiler_trace.h", "status": "modified", "additions": 466, "deletions": 438, "changes": 904, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_trace.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_TRACE_H__\n-#define PROFCXX_PROFILER_TRACE_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_TRACE_H\n+#define _GLIBCXX_PROFILE_PROFILER_TRACE_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cerrno>\n@@ -65,500 +65,528 @@\n \n namespace __gnu_profile\n {\n-\n #if defined _GLIBCXX_PROFILE_THREADS && defined HAVE_TLS\n #define _GLIBCXX_IMPL_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER\n-typedef pthread_mutex_t __mutex_t;\n-/** @brief Pthread mutex wrapper.  */\n-template <int _Unused=0>\n-class __mutex {\n- public:\n-  static __mutex_t __global_lock;\n-  static void __lock(__mutex_t& __m) { pthread_mutex_lock(&__m); }\n-  static void __unlock(__mutex_t& __m) { pthread_mutex_unlock(&__m); }\n-};\n+  typedef pthread_mutex_t __mutex_t;\n+\n+  /** @brief Pthread mutex wrapper.  */\n+  template<int _Unused=0>\n+    class __mutex \n+    {\n+    public:\n+      static __mutex_t __global_lock;\n+      static void __lock(__mutex_t& __m) { pthread_mutex_lock(&__m); }\n+      static void __unlock(__mutex_t& __m) { pthread_mutex_unlock(&__m); }\n+    };\n #else\n #define _GLIBCXX_IMPL_MUTEX_INITIALIZER 0\n-typedef int __mutex_t;\n-/** @brief Mock mutex interface.  */\n-template <int _Unused=0>\n-class __mutex {\n- public:\n-  static __mutex_t __global_lock;\n-  static void __lock(__mutex_t& __m) {}\n-  static void __unlock(__mutex_t& __m) {}\n-};\n+  typedef int __mutex_t;\n+\n+  /** @brief Mock mutex interface.  */\n+  template<int _Unused=0>\n+    class __mutex \n+    {\n+    public:\n+      static __mutex_t __global_lock;\n+      static void __lock(__mutex_t& __m) { }\n+      static void __unlock(__mutex_t& __m) { }\n+    };\n #endif\n \n-template <int _Unused>\n-__mutex_t __mutex<_Unused>::__global_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n-\n-/** @brief Representation of a warning.  */\n-struct __warning_data\n-{\n-  float __magnitude;\n-  __stack_t __context;\n-  const char* __warning_id;\n-  const char* __warning_message;\n-  __warning_data();\n-  __warning_data(float __m, __stack_t __c, const char* __id, \n-                 const char* __msg);\n-  bool operator>(const struct __warning_data& other) const;\n-};\n-\n-inline __warning_data::__warning_data()\n-    : __magnitude(0.0), __context(NULL), __warning_id(NULL),\n-      __warning_message(NULL)\n-{\n-}\n-\n-inline __warning_data::__warning_data(float __m, __stack_t __c, \n-                                      const char* __id, const char* __msg)\n-    : __magnitude(__m), __context(__c), __warning_id(__id),\n-      __warning_message(__msg)\n-{\n-}\n-\n-inline bool __warning_data::operator>(const struct __warning_data& other) const\n-{\n-  return __magnitude > other.__magnitude;\n-}\n-\n-typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n-\n-// Defined in profiler_<diagnostic name>.h.\n-class __trace_hash_func;\n-class __trace_hashtable_size;\n-class __trace_map2umap;\n-class __trace_vector_size;\n-class __trace_vector_to_list;\n-void __trace_vector_size_init();\n-void __trace_hashtable_size_init();\n-void __trace_hash_func_init();\n-void __trace_vector_to_list_init();\n-void __trace_map_to_unordered_map_init();\n-void __trace_vector_size_report(FILE*, __warning_vector_t&);\n-void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n-void __trace_hash_func_report(FILE*, __warning_vector_t&);\n-void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n-void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n-\n-// Utility functions.\n-inline size_t __max(size_t __a, size_t __b)\n-{\n-  return __a >= __b ? __a : __b;\n-}\n-\n-inline size_t __min(size_t __a, size_t __b)\n-{\n-  return __a <= __b ? __a : __b;\n-}\n+  template<int _Unused>\n+    __mutex_t __mutex<_Unused>::__global_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n \n-/** @brief Storage for diagnostic table entries.  Has only static fields.  */\n-template <int _Unused=0>\n-class __tables\n-{\n- public:\n-  static __trace_hash_func* _S_hash_func;\n-  static __trace_hashtable_size* _S_hashtable_size;\n-  static __trace_map2umap* _S_map2umap;\n-  static __trace_vector_size* _S_vector_size;\n-  static __trace_vector_to_list* _S_vector_to_list;\n-};\n-\n-template <int _Unused>\n-__trace_hash_func* __tables<_Unused>::_S_hash_func = NULL;\n-template <int _Unused>\n-__trace_hashtable_size* __tables<_Unused>::_S_hashtable_size = NULL;\n-template <int _Unused>\n-__trace_map2umap* __tables<_Unused>::_S_map2umap = NULL;\n-template <int _Unused>\n-__trace_vector_size* __tables<_Unused>::_S_vector_size = NULL;\n-template <int _Unused>\n-__trace_vector_to_list* __tables<_Unused>::_S_vector_to_list = NULL;\n-\n-/** @brief Storage for user defined parameters.  Has only static fields.  */\n-template <int _Unused=0>\n-class __settings {\n- public:\n-  static const char* _S_trace_file_name;\n-  static size_t _S_max_warn_count;\n-  static size_t _S_max_stack_depth;\n-  static size_t _S_max_mem;\n-};\n-\n-template <int _Unused>\n-const char* __settings<_Unused>::_S_trace_file_name = \n+  /** @brief Representation of a warning.  */\n+  struct __warning_data\n+  {\n+    float __magnitude;\n+    __stack_t __context;\n+    const char* __warning_id;\n+    const char* __warning_message;\n+    __warning_data();\n+    __warning_data(float __m, __stack_t __c, const char* __id,\n+\t\t   const char* __msg);\n+    bool operator>(const struct __warning_data& other) const;\n+  };\n+\n+  inline __warning_data::__warning_data()\n+  : __magnitude(0.0), __context(NULL), __warning_id(NULL),\n+    __warning_message(NULL)\n+  { }\n+\n+  inline __warning_data::__warning_data(float __m, __stack_t __c,\n+\t\t\t\t\tconst char* __id, const char* __msg)\n+  : __magnitude(__m), __context(__c), __warning_id(__id),\n+    __warning_message(__msg)\n+  { }\n+\n+  inline bool \n+  __warning_data::operator>(const struct __warning_data& other) const\n+  { return __magnitude > other.__magnitude; }\n+\n+  typedef std::_GLIBCXX_STD_PR::vector<__warning_data> __warning_vector_t;\n+\n+  // Defined in profiler_<diagnostic name>.h.\n+  class __trace_hash_func;\n+  class __trace_hashtable_size;\n+  class __trace_map2umap;\n+  class __trace_vector_size;\n+  class __trace_vector_to_list;\n+  void __trace_vector_size_init();\n+  void __trace_hashtable_size_init();\n+  void __trace_hash_func_init();\n+  void __trace_vector_to_list_init();\n+  void __trace_map_to_unordered_map_init();\n+  void __trace_vector_size_report(FILE*, __warning_vector_t&);\n+  void __trace_hashtable_size_report(FILE*, __warning_vector_t&);\n+  void __trace_hash_func_report(FILE*, __warning_vector_t&);\n+  void __trace_vector_to_list_report(FILE*, __warning_vector_t&);\n+  void __trace_map_to_unordered_map_report(FILE*, __warning_vector_t&);\n+\n+  // Utility functions.\n+  inline size_t \n+  __max(size_t __a, size_t __b) { return __a >= __b ? __a : __b; }\n+\n+  inline size_t \n+  __min(size_t __a, size_t __b)  { return __a <= __b ? __a : __b; }\n+\n+  /** @brief Storage for diagnostic table entries.  Has only static fields.  */\n+  template<int _Unused=0>\n+    class __tables\n+    {\n+    public:\n+      static __trace_hash_func*        \t_S_hash_func;\n+      static __trace_hashtable_size* \t_S_hashtable_size;\n+      static __trace_map2umap* \t\t_S_map2umap;\n+      static __trace_vector_size* \t_S_vector_size;\n+      static __trace_vector_to_list* \t_S_vector_to_list;\n+    };\n+\n+  template<int _Unused>\n+    __trace_hash_func* __tables<_Unused>::_S_hash_func = NULL;\n+\n+  template<int _Unused>\n+    __trace_hashtable_size* __tables<_Unused>::_S_hashtable_size = NULL;\n+\n+  template<int _Unused>\n+    __trace_map2umap* __tables<_Unused>::_S_map2umap = NULL;\n+\n+  template<int _Unused>\n+    __trace_vector_size* __tables<_Unused>::_S_vector_size = NULL;\n+\n+  template<int _Unused>\n+    __trace_vector_to_list* __tables<_Unused>::_S_vector_to_list = NULL;\n+\n+  /** @brief Storage for user defined parameters.  Has only static fields.  */\n+  template<int _Unused=0>\n+    class __settings \n+    {\n+    public:\n+      static const char* \t_S_trace_file_name;\n+      static size_t \t\t_S_max_warn_count;\n+      static size_t \t\t_S_max_stack_depth;\n+      static size_t \t\t_S_max_mem;\n+  };\n+\n+  template<int _Unused>\n+    const char* __settings<_Unused>::_S_trace_file_name =\n     _GLIBCXX_PROFILE_TRACE_PATH_ROOT;\n-template <int _Unused>\n-size_t __settings<_Unused>::_S_max_warn_count =\n+\n+  template<int _Unused>\n+    size_t __settings<_Unused>::_S_max_warn_count =\n     _GLIBCXX_PROFILE_MAX_WARN_COUNT;\n-template <int _Unused>\n-size_t __settings<_Unused>::_S_max_stack_depth =\n+\n+  template<int _Unused>\n+    size_t __settings<_Unused>::_S_max_stack_depth =\n     _GLIBCXX_PROFILE_MAX_STACK_DEPTH;\n-template <int _Unused>\n-size_t __settings<_Unused>::_S_max_mem =\n+\n+  template<int _Unused>\n+    size_t __settings<_Unused>::_S_max_mem =\n     _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC;\n \n-inline size_t __stack_max_depth()\n-{\n-  return __settings<0>::_S_max_stack_depth;\n-}\n+  inline size_t \n+  __stack_max_depth() { return __settings<0>::_S_max_stack_depth; }\n+\n+  inline size_t \n+  __max_mem() { return __settings<0>::_S_max_mem; }\n+\n+  /** @brief Base class for all trace producers.  */\n+  template<typename __object_info, typename __stack_info>\n+    class __trace_base\n+    {\n+    public:\n+      __trace_base();\n+      virtual ~__trace_base() { }\n+      \n+      void __add_object(__object_t object, __object_info __info);\n+      __object_info* __get_object_info(__object_t __object);\n+      void __retire_object(__object_t __object);\n+      void __write(FILE* f);\n+      void __collect_warnings(__warning_vector_t& warnings);\n+      \n+      void __lock_object_table();\n+      void __lock_stack_table();\n+      void __unlock_object_table();\n+      void __unlock_stack_table();\n+      \n+    private:\n+      __mutex_t __object_table_lock;\n+      __mutex_t __stack_table_lock;\n+      typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t,\n+\t\t\t\t\t  __object_info> __object_table_t;\n+      typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash,\n+\t\t\t\t\t  __stack_hash> __stack_table_t;\n+      __object_table_t __object_table;\n+      __stack_table_t __stack_table;\n+      size_t __stack_table_byte_size;\n+      \n+    protected:\n+      const char* __id;\n+    };\n+  \n+  template<typename __object_info, typename __stack_info>\n+    void \n+    __trace_base<__object_info, __stack_info>::__collect_warnings(__warning_vector_t& warnings)\n+    {\n+      typename __stack_table_t::iterator __i = __stack_table.begin();\n+      for ( ; __i != __stack_table.end(); ++__i)\n+\t{\n+\t  warnings.push_back(__warning_data((*__i).second.__magnitude(),\n+\t\t\t\t\t    (*__i).first,\n+\t\t\t\t\t    __id,\n+\t\t\t\t\t    (*__i).second.__advice()));\n+\t}\n+    }\n \n-inline size_t __max_mem()\n-{\n-  return __settings<0>::_S_max_mem;\n-}\n+  template<typename __object_info, typename __stack_info>\n+    void \n+    __trace_base<__object_info, __stack_info>::__lock_object_table()\n+    { __mutex<0>::__lock(this->__object_table_lock); }\n+\n+  template<typename __object_info, typename __stack_info>\n+    void\n+    __trace_base<__object_info, __stack_info>::__lock_stack_table()\n+    { __mutex<0>::__lock(this->__stack_table_lock); }\n+\n+  template<typename __object_info, typename __stack_info>\n+    void __trace_base<__object_info, __stack_info>::__unlock_object_table()\n+    { __mutex<0>::__unlock(this->__object_table_lock); }\n+\n+  template<typename __object_info, typename __stack_info>\n+    void __trace_base<__object_info, __stack_info>::__unlock_stack_table()\n+    { __mutex<0>::__unlock(this->__stack_table_lock); }\n+\n+  template<typename __object_info, typename __stack_info>\n+    __trace_base<__object_info, __stack_info>::__trace_base()\n+    {\n+      // Do not pick the initial size too large, as we don't know which\n+      // diagnostics are more active.\n+      __object_table.rehash(10000);\n+      __stack_table.rehash(10000);\n+      __stack_table_byte_size = 0;\n+      __id = NULL;\n+      __stack_table_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n+      __object_table_lock = __stack_table_lock;\n+    }\n \n-/** @brief Base class for all trace producers.  */\n-template <typename __object_info, typename __stack_info>\n-class __trace_base\n-{\n- public:\n-  __trace_base();\n-  virtual ~__trace_base() {}\n-\n-  void __add_object(__object_t object, __object_info __info);\n-  __object_info* __get_object_info(__object_t __object);\n-  void __retire_object(__object_t __object);\n-  void __write(FILE* f);\n-  void __collect_warnings(__warning_vector_t& warnings);\n-\n-  void __lock_object_table();\n-  void __lock_stack_table();\n-  void __unlock_object_table();\n-  void __unlock_stack_table();\n-\n- private:\n-  __mutex_t __object_table_lock;\n-  __mutex_t __stack_table_lock;\n-  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__object_t, \n-                                      __object_info> __object_table_t;\n-  typedef _GLIBCXX_IMPL_UNORDERED_MAP<__stack_t, __stack_info, __stack_hash, \n-                                      __stack_hash> __stack_table_t;\n-  __object_table_t __object_table;\n-  __stack_table_t __stack_table;\n-  size_t __stack_table_byte_size;\n-\n- protected:\n-  const char* __id;\n-};\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__collect_warnings(\n-    __warning_vector_t& warnings)\n-{\n-  typename __stack_table_t::iterator __i = __stack_table.begin();\n-  for ( ; __i != __stack_table.end(); ++__i )\n+  template<typename __object_info, typename __stack_info>\n+    void \n+    __trace_base<__object_info, __stack_info>::__add_object(__object_t __object, __object_info __info)\n   {\n-    warnings.push_back(__warning_data((*__i).second.__magnitude(), \n-                                      (*__i).first, \n-                                      __id,\n-                                      (*__i).second.__advice()));\n+    typedef typename __object_table_t::value_type value_type;\n+    if (__max_mem() == 0\n+\t|| __object_table.size() * sizeof(__object_info) <= __max_mem()) \n+      {\n+\t__lock_object_table();\n+\t__object_table.insert(value_type(__object, __info));\n+      __unlock_object_table();\n+    }\n   }\n-}\n \n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__lock_object_table()\n-{\n-  __mutex<0>::__lock(this->__object_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__lock_stack_table()\n-{\n-  __mutex<0>::__lock(this->__stack_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__unlock_object_table()\n-{\n-  __mutex<0>::__unlock(this->__object_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__unlock_stack_table()\n-{\n-  __mutex<0>::__unlock(this->__stack_table_lock);\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-__trace_base<__object_info, __stack_info>::__trace_base()\n-{\n-  // Do not pick the initial size too large, as we don't know which diagnostics\n-  // are more active.\n-  __object_table.rehash(10000);\n-  __stack_table.rehash(10000);\n-  __stack_table_byte_size = 0;\n-  __id = NULL;\n-  __object_table_lock = __stack_table_lock = _GLIBCXX_IMPL_MUTEX_INITIALIZER;\n-}\n-\n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__add_object(\n-    __object_t __object, __object_info __info)\n-{\n-  if (__max_mem() == 0 \n-      || __object_table.size() * sizeof(__object_info) <= __max_mem()) {\n+  template<typename __object_info, typename __stack_info>\n+    __object_info* \n+   __trace_base<__object_info, __stack_info>::__get_object_info(__object_t __object)\n+  {\n+    // XXX: Revisit this to see if we can decrease mutex spans.\n+    // Without this mutex, the object table could be rehashed during an\n+    // insertion on another thread, which could result in a segfault.\n     __lock_object_table();\n-    __object_table.insert(\n-        typename __object_table_t::value_type(__object, __info));\n-    __unlock_object_table();\n+    typename __object_table_t::iterator __object_it =\n+      __object_table.find(__object);\n+\n+    if (__object_it == __object_table.end())\n+      {\n+\t__unlock_object_table();\n+\treturn NULL;\n+      } \n+    else \n+      {\n+\t__unlock_object_table();\n+\treturn &__object_it->second;\n+      }\n   }\n-}\n \n-template <typename __object_info, typename __stack_info>\n-__object_info* __trace_base<__object_info, __stack_info>::__get_object_info(\n-    __object_t __object)\n-{\n-  // XXX: Revisit this to see if we can decrease mutex spans.\n-  // Without this mutex, the object table could be rehashed during an\n-  // insertion on another thread, which could result in a segfault.\n-  __lock_object_table();\n-  typename __object_table_t::iterator __object_it = \n+  template<typename __object_info, typename __stack_info>\n+    void \n+    __trace_base<__object_info, __stack_info>::__retire_object(__object_t __object)\n+  {\n+    __lock_object_table();\n+    __lock_stack_table();\n+    typename __object_table_t::iterator __object_it =\n       __object_table.find(__object);\n-  if (__object_it == __object_table.end()){\n-    __unlock_object_table();\n-    return NULL;\n-  } else {\n+\n+    if (__object_it != __object_table.end())\n+      {\n+\tconst __object_info& __info = __object_it->second;\n+\tconst __stack_t& __stack = __info.__stack();\n+\ttypename __stack_table_t::iterator __stack_it =\n+\t__stack_table.find(__stack);\n+\n+\tif (__stack_it == __stack_table.end()) \n+\t  {\n+\t    // First occurence of this call context.\n+\t    if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) \n+\t      {\n+\t\t__stack_table_byte_size +=\n+\t\t  (sizeof(__instruction_address_t) * __size(__stack)\n+\t\t   + sizeof(__stack) + sizeof(__stack_info));\n+\t\t__stack_table.insert(make_pair(__stack, __stack_info(__info)));\n+\t      }\n+\t  } \n+\telse \n+\t  {\n+\t    // Merge object info into info summary for this call context.\n+\t    __stack_it->second.__merge(__info);\n+\t    delete __stack;\n+\t  }\n+\t__object_table.erase(__object);\n+      }\n+    __unlock_stack_table();\n     __unlock_object_table();\n-    return &__object_it->second;\n   }\n-}\n \n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__retire_object(\n-    __object_t __object)\n-{\n-  __lock_object_table();\n-  __lock_stack_table();\n-  typename __object_table_t::iterator __object_it =\n-      __object_table.find(__object);\n-  if (__object_it != __object_table.end()){\n-    const __object_info& __info = __object_it->second;\n-    const __stack_t& __stack = __info.__stack();\n-    typename __stack_table_t::iterator __stack_it = \n-        __stack_table.find(__stack);\n-    if (__stack_it == __stack_table.end()) {\n-      // First occurence of this call context.\n-      if (__max_mem() == 0 || __stack_table_byte_size < __max_mem()) {\n-        __stack_table_byte_size += \n-            (sizeof(__instruction_address_t) * __size(__stack)\n-             + sizeof(__stack) + sizeof(__stack_info));\n-        __stack_table.insert(make_pair(__stack, __stack_info(__info)));\n+  template<typename __object_info, typename __stack_info>\n+  void \n+  __trace_base<__object_info, __stack_info>::__write(FILE* __f)\n+  {\n+    typename __stack_table_t::iterator __it;\n+\n+    for (__it = __stack_table.begin(); __it != __stack_table.end(); __it++) \n+      {\n+\tif (__it->second.__is_valid()) \n+\t  {\n+\t    fprintf(__f, __id);\n+\t    fprintf(__f, \"|\");\n+\t    __gnu_profile::__write(__f, __it->first);\n+\t    fprintf(__f, \"|\");\n+\t    __it->second.__write(__f);\n+\t  }\n       }\n-    } else {\n-      // Merge object info into info summary for this call context.\n-      __stack_it->second.__merge(__info);\n-      delete __stack;\n-    }\n-    __object_table.erase(__object);\n   }\n-  __unlock_stack_table();\n-  __unlock_object_table();\n-}\n \n-template <typename __object_info, typename __stack_info>\n-void __trace_base<__object_info, __stack_info>::__write(FILE* __f)\n-{\n-  typename __stack_table_t::iterator __it;\n-\n-  for (__it = __stack_table.begin(); __it != __stack_table.end(); __it++) {\n-    if (__it->second.__is_valid()) {\n-      fprintf(__f, __id);\n-      fprintf(__f, \"|\");\n-      __gnu_profile::__write(__f, __it->first);\n-      fprintf(__f, \"|\");\n-      __it->second.__write(__f);\n-    }\n+  inline size_t \n+  __env_to_size_t(const char* __env_var, size_t __default_value)\n+  {\n+    char* __env_value = getenv(__env_var);\n+    if (__env_value) \n+      {\n+\tlong int __converted_value = strtol(__env_value, NULL, 10);\n+\tif (errno || __converted_value < 0) \n+\t  {\n+\t    fprintf(stderr, \"Bad value for environment variable '%s'.\",\n+\t\t    __env_var);\n+\t    abort();\n+\t  } \n+\telse \n+\t  {\n+\t    return static_cast<size_t>(__converted_value);\n+\t  }\n+      } \n+    else \n+      {\n+\treturn __default_value;\n+      }\n   }\n-}\n \n-inline size_t __env_to_size_t(const char* __env_var, size_t __default_value)\n-{\n-  char* __env_value = getenv(__env_var);\n-  if (__env_value) {\n-    long int __converted_value = strtol(__env_value, NULL, 10);\n-    if (errno || __converted_value < 0) {\n-      fprintf(stderr, \"Bad value for environment variable '%s'.\", __env_var);\n-      abort();\n-    } else {\n-      return static_cast<size_t>(__converted_value);\n-    }\n-  } else {\n-    return __default_value;\n+  inline void \n+  __set_max_stack_trace_depth()\n+  {\n+    __settings<0>::_S_max_stack_depth = __env_to_size_t(_GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR, __settings<0>::_S_max_stack_depth);\n   }\n-}\n-\n-inline void __set_max_stack_trace_depth()\n-{\n-  __settings<0>::_S_max_stack_depth = __env_to_size_t(\n-      _GLIBCXX_PROFILE_MAX_STACK_DEPTH_ENV_VAR,\n-      __settings<0>::_S_max_stack_depth);\n-}\n-\n-inline void __set_max_mem()\n-{\n-  __settings<0>::_S_max_mem = __env_to_size_t(\n-      _GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR, __settings<0>::_S_max_mem);\n-}\n \n-inline int __log_magnitude(float f)\n-{\n-  const float log_base = 10.0;\n-  int result = 0;\n-  int sign = 1;\n-  if (f < 0) {\n-    f = -f;\n-    sign = -1;\n-  }\n-  while (f > log_base) {\n-    ++result;\n-    f /= 10.0;\n+  inline void \n+  __set_max_mem()\n+  {\n+    __settings<0>::_S_max_mem = __env_to_size_t(_GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR, __settings<0>::_S_max_mem);\n   }\n-  return sign * result;\n-}\n \n-struct __warn\n-{\n-  FILE* __file;\n-  __warn(FILE* __f) { __file = __f; }\n-  void operator() (const __warning_data& __info)\n+  inline int \n+  __log_magnitude(float f)\n   {\n-    fprintf(__file,  __info.__warning_id);\n-    fprintf(__file, \": improvement = %d\", __log_magnitude(__info.__magnitude));\n-    fprintf(__file, \": call stack = \");\n-    __gnu_profile::__write(__file, __info.__context);\n-    fprintf(__file, \": advice = %s\\n\", __info.__warning_message);\n+    const float log_base = 10.0;\n+    int result = 0;\n+    int sign = 1;\n+    if (f < 0) \n+      {\n+\tf = -f;\n+\tsign = -1;\n+      }\n+    while (f > log_base) \n+      {\n+\t++result;\n+\tf /= 10.0;\n+      }\n+    return sign * result;\n   }\n-};\n \n-inline FILE* __open_output_file(const char* extension)\n-{\n-  // The path is made of _S_trace_file_name + \".\" + extension.\n-  size_t root_len = strlen(__settings<0>::_S_trace_file_name);\n-  size_t ext_len = strlen(extension);\n-  char* file_name = new char[root_len + 1 + ext_len + 1];\n-  char* p = file_name;\n-  memcpy(file_name, __settings<0>::_S_trace_file_name, root_len);\n-  *(file_name + root_len) = '.';\n-  memcpy(file_name + root_len + 1, extension, ext_len + 1);\n-  FILE* out_file = fopen(file_name, \"w\");\n-  if (out_file) {\n-    return out_file;\n-  } else {\n-    fprintf(stderr, \"Could not open trace file '%s'.\", file_name);\n-    abort();\n+  struct __warn\n+  {\n+    FILE* __file;\n+\n+    __warn(FILE* __f) { __file = __f; }\n+\n+    void operator() (const __warning_data& __info)\n+    {\n+      fprintf(__file,  __info.__warning_id);\n+      fprintf(__file, \": improvement = %d\", \n+\t      __log_magnitude(__info.__magnitude));\n+      fprintf(__file, \": call stack = \");\n+      __gnu_profile::__write(__file, __info.__context);\n+      fprintf(__file, \": advice = %s\\n\", __info.__warning_message);\n+    }\n+  };\n+\n+  inline FILE* \n+  __open_output_file(const char* extension)\n+  {\n+    // The path is made of _S_trace_file_name + \".\" + extension.\n+    size_t root_len = strlen(__settings<0>::_S_trace_file_name);\n+    size_t ext_len = strlen(extension);\n+    char* file_name = new char[root_len + 1 + ext_len + 1];\n+    char* p = file_name;\n+    memcpy(file_name, __settings<0>::_S_trace_file_name, root_len);\n+    *(file_name + root_len) = '.';\n+    memcpy(file_name + root_len + 1, extension, ext_len + 1);\n+    FILE* out_file = fopen(file_name, \"w\");\n+    if (out_file) \n+      return out_file;\n+    else \n+      {\n+\tfprintf(stderr, \"Could not open trace file '%s'.\", file_name);\n+\tabort();\n+      }\n   }\n-}\n-\n-/** @brief Final report method, registered with \"atexit\".\n- *\n- * This can also be called directly by user code, including signal handlers.\n- * It is protected against deadlocks by the reentrance guard in profiler.h.\n- * However, when called from a signal handler that triggers while within\n- * __gnu_profile (under the guarded zone), no output will be produced.\n- */\n-inline void __report(void)\n-{\n-  __mutex<0>::__lock(__mutex<0>::__global_lock);\n \n-  __warning_vector_t __warnings;\n+  /** @brief Final report method, registered with \"atexit\".\n+   *\n+   * This can also be called directly by user code, including signal handlers.\n+   * It is protected against deadlocks by the reentrance guard in profiler.h.\n+   * However, when called from a signal handler that triggers while within\n+   * __gnu_profile (under the guarded zone), no output will be produced.\n+   */\n+  inline void \n+  __report(void)\n+  {\n+    __mutex<0>::__lock(__mutex<0>::__global_lock);\n \n-  FILE* __raw_file = __open_output_file(\"raw\");\n-  __trace_vector_size_report(__raw_file, __warnings);\n-  __trace_hashtable_size_report(__raw_file, __warnings);\n-  __trace_hash_func_report(__raw_file, __warnings);\n-  __trace_vector_to_list_report(__raw_file, __warnings);\n-  __trace_map_to_unordered_map_report(__raw_file, __warnings);\n-  fclose(__raw_file);\n+    __warning_vector_t __warnings;\n \n-  // Sort data by magnitude.\n-  // XXX: instead of sorting, should collect only top N for better performance.\n-  size_t __cutoff = __min(__settings<0>::_S_max_warn_count, \n-                          __warnings.size());\n+    FILE* __raw_file = __open_output_file(\"raw\");\n+    __trace_vector_size_report(__raw_file, __warnings);\n+    __trace_hashtable_size_report(__raw_file, __warnings);\n+    __trace_hash_func_report(__raw_file, __warnings);\n+    __trace_vector_to_list_report(__raw_file, __warnings);\n+    __trace_map_to_unordered_map_report(__raw_file, __warnings);\n+    fclose(__raw_file);\n \n-  std::sort(__warnings.begin(), __warnings.end(),\n-            std::greater<__warning_vector_t::value_type>());\n-  __warnings.resize(__cutoff);\n+    // Sort data by magnitude.\n \n-  FILE* __warn_file = __open_output_file(\"txt\");\n-  std::for_each(__warnings.begin(), __warnings.end(), __warn(__warn_file));\n-  fclose(__warn_file);\n+    // XXX: instead of sorting, should collect only top N for better\n+    // performance.\n+    size_t __cutoff = __min(__settings<0>::_S_max_warn_count,\n+\t\t\t    __warnings.size());\n \n-  __mutex<0>::__unlock(__mutex<0>::__global_lock);\n-}\n+    std::sort(__warnings.begin(), __warnings.end(),\n+\t      std::greater<__warning_vector_t::value_type>());\n+    __warnings.resize(__cutoff);\n \n-inline void __set_trace_path()\n-{\n-  char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n+    FILE* __warn_file = __open_output_file(\"txt\");\n+    std::for_each(__warnings.begin(), __warnings.end(), __warn(__warn_file));\n+    fclose(__warn_file);\n \n-  if (__env_trace_file_name) { \n-    __settings<0>::_S_trace_file_name = __env_trace_file_name; \n+    __mutex<0>::__unlock(__mutex<0>::__global_lock);\n   }\n \n-  // Make sure early that we can create the trace file.\n-  fclose(__open_output_file(\"txt\"));\n-}\n+  inline void \n+  __set_trace_path()\n+  {\n+    char* __env_trace_file_name = getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);\n \n-inline void __set_max_warn_count()\n-{\n-  char* __env_max_warn_count_str = getenv(\n-      _GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n+    if (__env_trace_file_name) \n+      __settings<0>::_S_trace_file_name = __env_trace_file_name;\n \n-  if (__env_max_warn_count_str) {\n-    __settings<0>::_S_max_warn_count = static_cast<size_t>(\n-        atoi(__env_max_warn_count_str));\n+    // Make sure early that we can create the trace file.\n+    fclose(__open_output_file(\"txt\"));\n   }\n-}\n-\n-inline void __profcxx_init_unconditional()\n-{\n-  __mutex<0>::__lock(__mutex<0>::__global_lock);\n-\n-  __set_max_warn_count();\n-\n-  if (__is_invalid()) {\n-\n-    if (__settings<0>::_S_max_warn_count == 0) {\n-\n-      __turn_off();\n \n-    } else {\n-\n-      __set_max_stack_trace_depth();\n-      __set_max_mem();\n-      __set_trace_path();\n-\n-      __trace_vector_size_init();\n-      __trace_hashtable_size_init();\n-      __trace_hash_func_init();\n-      __trace_vector_to_list_init();\n-      __trace_map_to_unordered_map_init();\n-\n-      atexit(__report);\n-\n-      __turn_on();\n+  inline void \n+  __set_max_warn_count()\n+  {\n+    char* __env_max_warn_count_str = getenv(_GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);\n \n+    if (__env_max_warn_count_str) \n+      {\n+\tint i = atoi(__env_max_warn_count_str);\n+\t__settings<0>::_S_max_warn_count = static_cast<size_t>(i);\n     }\n   }\n \n-  __mutex<0>::__unlock(__mutex<0>::__global_lock);\n-}\n+  inline void \n+  __profcxx_init_unconditional()\n+  {\n+    __mutex<0>::__lock(__mutex<0>::__global_lock);\n+\n+    __set_max_warn_count();\n+\n+    if (__is_invalid()) \n+      {\n+      if (__settings<0>::_S_max_warn_count == 0) \n+\t{\n+\t  __turn_off();\n+\t} \n+      else \n+\t{\n+\t__set_max_stack_trace_depth();\n+\t__set_max_mem();\n+\t__set_trace_path();\n+\n+\t__trace_vector_size_init();\n+\t__trace_hashtable_size_init();\n+\t__trace_hash_func_init();\n+\t__trace_vector_to_list_init();\n+\t__trace_map_to_unordered_map_init();\n+\n+\tatexit(__report);\n+\n+\t__turn_on();\n+\t}\n+      }\n \n-/** @brief This function must be called by each instrumentation point.\n- *\n- * The common path is inlined fully.\n- */\n-inline bool __profcxx_init(void)\n-{\n-  if (__is_invalid()) {\n-    __profcxx_init_unconditional();\n+    __mutex<0>::__unlock(__mutex<0>::__global_lock);\n   }\n \n-  return __is_on();\n-}\n+  /** @brief This function must be called by each instrumentation point.\n+   *\n+   * The common path is inlined fully.\n+   */\n+  inline bool \n+  __profcxx_init(void)\n+  {\n+    if (__is_invalid())\n+      __profcxx_init_unconditional();\n+    return __is_on();\n+  }\n \n } // namespace __gnu_profile\n \n-#endif /* PROFCXX_PROFILER_TRACE_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_TRACE_H */"}, {"sha": "151e5d4bfb7141b0bd615861ac0ff7071f4b4e5f", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_size.h", "status": "modified", "additions": 42, "deletions": 52, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_size.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_VECTOR_SIZE_H__\n-#define PROFCXX_PROFILER_VECTOR_SIZE_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H\n+#define _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdlib>\n@@ -54,59 +54,49 @@\n \n namespace __gnu_profile\n {\n-\n-/** @brief Hashtable size instrumentation trace producer.  */\n-class __trace_vector_size : public __trace_container_size\n-{\n- public:\n-  __trace_vector_size() : __trace_container_size() { __id = \"vector-size\"; }\n-};\n-\n-//////////////////////////////////////////////////////////////////////////////\n-// Initialization and report.\n-//////////////////////////////////////////////////////////////////////////////\n-\n-inline void __trace_vector_size_init()\n-{\n-  __tables<0>::_S_vector_size = new __trace_vector_size();\n-}\n-\n-inline void __trace_vector_size_report(FILE* __f, \n-                                       __warning_vector_t& __warnings)\n-{\n-  if (__tables<0>::_S_vector_size) {\n-    __tables<0>::_S_vector_size->__collect_warnings(__warnings);\n-    __tables<0>::_S_vector_size->__write(__f);\n+  /** @brief Hashtable size instrumentation trace producer.  */\n+  class __trace_vector_size : public __trace_container_size\n+  {\n+  public:\n+    __trace_vector_size() : __trace_container_size() { __id = \"vector-size\"; }\n+  };\n+\n+  // Initialization and report.\n+  inline void \n+  __trace_vector_size_init()\n+  { __tables<0>::_S_vector_size = new __trace_vector_size(); }\n+\n+  inline void \n+  __trace_vector_size_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (__tables<0>::_S_vector_size) \n+      {\n+\t__tables<0>::_S_vector_size->__collect_warnings(__warnings);\n+\t__tables<0>::_S_vector_size->__write(__f);\n+      }\n   }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-// Implementations of instrumentation hooks.\n-//////////////////////////////////////////////////////////////////////////////\n-\n-inline void __trace_vector_size_construct(const void* __obj, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n-\n-  __tables<0>::_S_vector_size->__insert(__obj, __get_stack(), __num);\n-}\n-\n-inline void __trace_vector_size_destruct(const void* __obj, size_t __num,\n-                                         size_t __inum)\n-{\n-  if (!__profcxx_init()) return;\n-\n-  __tables<0>::_S_vector_size->__destruct(__obj, __num, __inum);\n-}\n \n-inline void __trace_vector_size_resize(const void* __obj, size_t __from,\n-                                       size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  // Implementations of instrumentation hooks.\n+  inline void \n+  __trace_vector_size_construct(const void* __obj, size_t __num)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_size->__insert(__obj, __get_stack(), __num);\n+  }\n \n-  __tables<0>::_S_vector_size->__resize(__obj, __from, __to);\n-}\n+  inline void \n+  __trace_vector_size_destruct(const void* __obj, size_t __num, size_t __inum)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_size->__destruct(__obj, __num, __inum);\n+  }\n \n+  inline void\n+  __trace_vector_size_resize(const void* __obj, size_t __from, size_t __to)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_size->__resize(__obj, __from, __to);\n+  }\n } // namespace __gnu_profile\n \n-#endif /* PROFCXX_PROFILER_VECTOR_SIZE_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H */"}, {"sha": "45076f8eb79568d1d57802996831f6a8f20eab22", "filename": "libstdc++-v3/include/profile/impl/profiler_vector_to_list.h", "status": "modified", "additions": 239, "deletions": 248, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b2231910767d2819899bfba467c2307f92b802e/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Fimpl%2Fprofiler_vector_to_list.h?ref=6b2231910767d2819899bfba467c2307f92b802e", "patch": "@@ -34,8 +34,8 @@\n \n // Written by Lixia Liu and Silvius Rus.\n \n-#ifndef PROFCXX_PROFILER_VECTOR_TO_LIST_H__\n-#define PROFCXX_PROFILER_VECTOR_TO_LIST_H__ 1\n+#ifndef _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H\n+#define _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H 1\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n #include <cstdio>\n@@ -52,267 +52,258 @@\n \n namespace __gnu_profile\n {\n+  /** @brief A vector-to-list instrumentation line in the object table.  */\n+  class __vector2list_info: public __object_info_base\n+  {\n+  public:\n+    __vector2list_info()\n+    :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n+     _M_vector_cost(0), _M_valid(true) { }\n+\n+    __vector2list_info(__stack_t __stack)\n+    : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n+      _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) { } \n+\n+    virtual ~__vector2list_info() { }\n+    __vector2list_info(const __vector2list_info& __o);\n+\n+    void __merge(const __vector2list_info& __o);\n+    void __write(FILE* __f) const;\n+    float __magnitude() const { return _M_vector_cost - _M_list_cost; }\n+    const char* __advice() const { return \"change std::vector to std::list\"; }\n+\n+    size_t __shift_count() { return _M_shift_count; }\n+    size_t __iterate()   { return _M_iterate; }\n+    float __list_cost() { return _M_list_cost; }\n+    size_t __resize() { return _M_resize; }\n+    void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n+    void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n+    bool __is_valid() { return _M_valid; }\n+    void __set_invalid() { _M_valid = false; }\n+\n+    void __opr_insert(size_t __pos, size_t __num);\n+    void __opr_iterate(size_t __num) { _M_iterate += __num; }\n+    void __resize(size_t __from, size_t __to);\n+\n+  private:\n+    size_t _M_shift_count;\n+    size_t _M_iterate;\n+    size_t _M_resize;\n+    float _M_list_cost;\n+    float _M_vector_cost;\n+    bool  _M_valid;\n+  };\n+\n+  inline __vector2list_info::__vector2list_info(const __vector2list_info& __o)\n+  : __object_info_base(__o)\n+  {\n+    _M_shift_count  = __o._M_shift_count;\n+    _M_iterate      = __o._M_iterate;\n+    _M_vector_cost  = __o._M_vector_cost;\n+    _M_list_cost    = __o._M_list_cost;\n+    _M_valid        = __o._M_valid;\n+    _M_resize       = __o._M_resize;\n+  }\n \n-/** @brief A vector-to-list instrumentation line in the object table.  */\n-class __vector2list_info: public __object_info_base\n-{\n- public:\n-  __vector2list_info()\n-      :_M_shift_count(0), _M_iterate(0), _M_resize(0), _M_list_cost(0),\n-       _M_vector_cost(0), _M_valid(true) {}\n-  __vector2list_info(__stack_t __stack)\n-      : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),\n-        _M_resize(0), _M_list_cost(0), _M_vector_cost(0), _M_valid(true) {} \n-  virtual ~__vector2list_info() {}\n-  __vector2list_info(const __vector2list_info& __o);\n-  void __merge(const __vector2list_info& __o);\n-  void __write(FILE* __f) const;\n-  float __magnitude() const { return _M_vector_cost - _M_list_cost; }\n-  const char* __advice() const { return \"change std::vector to std::list\"; }\n-\n-  size_t __shift_count() { return _M_shift_count; }\n-  size_t __iterate()   { return _M_iterate; }\n-  float __list_cost() { return _M_list_cost; }\n-  size_t __resize() { return _M_resize; }\n-  void __set_list_cost(float __lc) { _M_list_cost = __lc; }\n-  void __set_vector_cost(float __vc) { _M_vector_cost = __vc; }\n-  bool __is_valid() { return _M_valid; }\n-  void __set_invalid() { _M_valid = false; }\n-\n-  void __opr_insert(size_t __pos, size_t __num);\n-  void __opr_iterate(size_t __num) { _M_iterate += __num; }\n-  void __resize(size_t __from, size_t __to);\n-\n-private:\n-  size_t _M_shift_count;\n-  size_t _M_iterate;\n-  size_t _M_resize;\n-  float _M_list_cost;\n-  float _M_vector_cost;\n-  bool  _M_valid;\n-};\n-\n-inline __vector2list_info::__vector2list_info(const __vector2list_info& __o)\n-    : __object_info_base(__o)\n-{\n-  _M_shift_count  = __o._M_shift_count;\n-  _M_iterate      = __o._M_iterate;\n-  _M_vector_cost  = __o._M_vector_cost;\n-  _M_list_cost    = __o._M_list_cost;\n-  _M_valid        = __o._M_valid;\n-  _M_resize       = __o._M_resize;\n-}\n-\n-inline void __vector2list_info::__merge(const __vector2list_info& __o)\n-{\n-  _M_shift_count  += __o._M_shift_count;\n-  _M_iterate      += __o._M_iterate;\n-  _M_vector_cost  += __o._M_vector_cost;\n-  _M_list_cost    += __o._M_list_cost;\n-  _M_valid        &= __o._M_valid;\n-  _M_resize       += __o._M_resize;\n-}\n-\n-inline void __vector2list_info::__opr_insert(size_t __pos, size_t __num)\n-{\n-  _M_shift_count += __num - __pos;\n-}\n-\n-inline void __vector2list_info::__resize(size_t __from, size_t __to)\n-{\n-  _M_resize += __from;\n-}\n-\n-/** @brief A vector-to-list instrumentation line in the stack table.  */\n-class __vector2list_stack_info: public __vector2list_info {\n- public:\n-  __vector2list_stack_info(const __vector2list_info& __o) \n-      : __vector2list_info(__o) {}\n-};\n-\n-/** @brief Vector-to-list instrumentation producer.  */\n-class __trace_vector_to_list\n-    : public __trace_base<__vector2list_info, __vector2list_stack_info> \n-{\n- public:\n-  __trace_vector_to_list();\n-  ~__trace_vector_to_list() {}\n-\n-  // Insert a new node at construct with object, callstack and initial size. \n-  void __insert(__object_t __obj, __stack_t __stack);\n-  // Call at destruction/clean to set container final size.\n-  void __destruct(const void* __obj);\n-\n-  // Find the node in the live map.\n-  __vector2list_info* __find(const void* __obj);\n-\n-  // Collect cost of operations.\n-  void __opr_insert(const void* __obj, size_t __pos, size_t __num);\n-  void __opr_iterate(const void* __obj, size_t __num);\n-  void __invalid_operator(const void* __obj);\n-  void __resize(const void* __obj, size_t __from, size_t __to);\n-  float __vector_cost(size_t __shift, size_t __iterate, size_t __resize);\n-  float __list_cost(size_t __shift, size_t __iterate, size_t __resize);\n-};\n-\n-inline __trace_vector_to_list::__trace_vector_to_list()\n-    : __trace_base<__vector2list_info, __vector2list_stack_info>()\n-{\n-  __id = \"vector-to-list\";\n-}\n-\n-inline void __trace_vector_to_list::__insert(__object_t __obj,\n-                                             __stack_t __stack)\n-{\n-  __add_object(__obj, __vector2list_info(__stack));\n-}\n-\n-inline void __vector2list_info::__write(FILE* __f) const\n-{\n-  fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\",\n-          _M_shift_count, _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);\n-}\n-\n-// Cost model.  XXX: get this from the cost model database instead.\n-//  Vector operation cost:\n-//   - Cost per shift: 1\n-//   - Cost per access: 1\n-//   - Cost per resize: 1\n-//  List operation cost:\n-//   - Cost per shift: 0\n-//   - Cost per access: 10\n-//   - Cost per resize: 0\n-\n-inline float __trace_vector_to_list::__vector_cost(size_t __shift, \n-                                                   size_t __iterate,\n-                                                   size_t __resize)\n-{\n-  return __shift * 1 + __iterate * 1 + __resize * 1; \n-}\n-\n-inline float __trace_vector_to_list::__list_cost(size_t __shift, \n-                                                 size_t __iterate,\n-                                                 size_t __resize)\n-{\n-  return __shift * 0 + __iterate * 10 + __resize * 0; \n-}\n-\n-inline void __trace_vector_to_list::__destruct(const void* __obj)\n-{\n-  if (!__is_on())\n-    return;\n-\n- __vector2list_info* __res = __get_object_info(__obj);\n-  if (!__res)\n-    return;\n-\n-  float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n-                             __res->__resize());\n-  float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n-                           __res->__resize());\n-  __res->__set_vector_cost(__vc);\n-  __res->__set_list_cost(__lc);\n-\n-  __retire_object(__obj);\n-}\n-\n-inline void __trace_vector_to_list::__opr_insert(const void* __obj, \n-                                                 size_t __pos, size_t __num)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_insert(__pos, __num);\n-}\n-\n-inline void __trace_vector_to_list::__opr_iterate(const void* __obj,\n-                                                  size_t __num)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__opr_iterate(__num);\n-}\n-\n-inline void __trace_vector_to_list::__invalid_operator(const void* __obj)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__set_invalid();\n-}\n-\n-inline void __trace_vector_to_list::__resize(const void* __obj, size_t __from, \n-                                             size_t __to)\n-{\n-  __vector2list_info* __res = __get_object_info(__obj);\n-  if (__res)\n-    __res->__resize(__from, __to);\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-// Initialization and report.\n-//////////////////////////////////////////////////////////////////////////////\n-\n-inline void __trace_vector_to_list_init()\n-{\n-  __tables<0>::_S_vector_to_list = new __trace_vector_to_list();\n-}\n-\n-inline void __trace_vector_to_list_report(FILE* __f, \n-                                          __warning_vector_t& __warnings)\n-{\n-  if (__tables<0>::_S_vector_to_list) {\n-    __tables<0>::_S_vector_to_list->__collect_warnings(__warnings);\n-    __tables<0>::_S_vector_to_list->__write(__f);\n+  inline void \n+  __vector2list_info::__merge(const __vector2list_info& __o)\n+  {\n+    _M_shift_count  += __o._M_shift_count;\n+    _M_iterate      += __o._M_iterate;\n+    _M_vector_cost  += __o._M_vector_cost;\n+    _M_list_cost    += __o._M_list_cost;\n+    _M_valid        &= __o._M_valid;\n+    _M_resize       += __o._M_resize;\n   }\n-}\n \n-//////////////////////////////////////////////////////////////////////////////\n-// Implementations of instrumentation hooks.\n-//////////////////////////////////////////////////////////////////////////////\n+  inline void \n+  __vector2list_info::__opr_insert(size_t __pos, size_t __num)\n+  { _M_shift_count += __num - __pos; }\n+\n+  inline void \n+  __vector2list_info::__resize(size_t __from, size_t __to)\n+  { _M_resize += __from; }\n+\n+  /** @brief A vector-to-list instrumentation line in the stack table.  */\n+  class __vector2list_stack_info: public __vector2list_info \n+  {\n+  public:\n+    __vector2list_stack_info(const __vector2list_info& __o) \n+    : __vector2list_info(__o) { }\n+  };\n+\n+  /** @brief Vector-to-list instrumentation producer.  */\n+  class __trace_vector_to_list\n+  : public __trace_base<__vector2list_info, __vector2list_stack_info> \n+  {\n+  public:\n+    __trace_vector_to_list();\n+    ~__trace_vector_to_list() { }\n+\n+    // Insert a new node at construct with object, callstack and initial size. \n+    void __insert(__object_t __obj, __stack_t __stack);\n+\n+    // Call at destruction/clean to set container final size.\n+    void __destruct(const void* __obj);\n+\n+    // Find the node in the live map.\n+    __vector2list_info* __find(const void* __obj);\n+\n+    // Collect cost of operations.\n+    void __opr_insert(const void* __obj, size_t __pos, size_t __num);\n+    void __opr_iterate(const void* __obj, size_t __num);\n+    void __invalid_operator(const void* __obj);\n+    void __resize(const void* __obj, size_t __from, size_t __to);\n+    float __vector_cost(size_t __shift, size_t __iterate, size_t __resize);\n+    float __list_cost(size_t __shift, size_t __iterate, size_t __resize);\n+  };\n+\n+  inline __trace_vector_to_list::__trace_vector_to_list()\n+  : __trace_base<__vector2list_info, __vector2list_stack_info>()\n+  { __id = \"vector-to-list\"; }\n+\n+  inline void \n+  __trace_vector_to_list::__insert(__object_t __obj, __stack_t __stack)\n+  { __add_object(__obj, __vector2list_info(__stack)); }\n+\n+  inline void \n+  __vector2list_info::__write(FILE* __f) const\n+  {\n+    fprintf(__f, \"%Zu %Zu %Zu %.0f %.0f\\n\", _M_shift_count, _M_resize, \n+\t    _M_iterate, _M_vector_cost, _M_list_cost);\n+  }\n \n-inline void __trace_vector_to_list_construct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  // Cost model.  \n+  //  Vector operation cost:\n+  //   - Cost per shift: 1\n+  //   - Cost per access: 1\n+  //   - Cost per resize: 1\n+  //  List operation cost:\n+  //   - Cost per shift: 0\n+  //   - Cost per access: 10\n+  //   - Cost per resize: 0\n+  // XXX: get this from the cost model database instead.\n+  inline float \n+  __trace_vector_to_list::__vector_cost(size_t __shift, size_t __iterate,\n+\t\t\t\t\tsize_t __resize)\n+  { return __shift * 1 + __iterate * 1 + __resize * 1; }\n+\n+  inline float \n+  __trace_vector_to_list::__list_cost(size_t __shift, size_t __iterate,\n+\t\t\t\t      size_t __resize)\n+  { return __shift * 0 + __iterate * 10 + __resize * 0; }\n+\n+  inline void \n+  __trace_vector_to_list::__destruct(const void* __obj)\n+  {\n+    if (!__is_on())\n+      return;\n+\n+    __vector2list_info* __res = __get_object_info(__obj);\n+    if (!__res)\n+      return;\n+\n+    float __vc = __vector_cost(__res->__shift_count(), __res->__iterate(),\n+\t\t\t       __res->__resize());\n+    float __lc = __list_cost(__res->__shift_count(), __res->__iterate(),\n+\t\t\t     __res->__resize());\n+    __res->__set_vector_cost(__vc);\n+    __res->__set_list_cost(__lc);\n+\n+    __retire_object(__obj);\n+  }\n \n-  __tables<0>::_S_vector_to_list->__insert(__obj, __get_stack());\n-}\n+  inline void \n+  __trace_vector_to_list::__opr_insert(const void* __obj, size_t __pos, \n+\t\t\t\t       size_t __num)\n+  {\n+    __vector2list_info* __res = __get_object_info(__obj);\n+    if (__res)\n+      __res->__opr_insert(__pos, __num);\n+  }\n \n-inline void __trace_vector_to_list_destruct(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_vector_to_list::__opr_iterate(const void* __obj, size_t __num)\n+  {\n+    __vector2list_info* __res = __get_object_info(__obj);\n+    if (__res)\n+      __res->__opr_iterate(__num);\n+  }\n \n-  __tables<0>::_S_vector_to_list->__destruct(__obj);\n-}\n+  inline void \n+  __trace_vector_to_list::__invalid_operator(const void* __obj)\n+  {\n+    __vector2list_info* __res = __get_object_info(__obj);\n+    if (__res)\n+      __res->__set_invalid();\n+  }\n \n-inline void __trace_vector_to_list_insert(const void* __obj, \n-                                          size_t __pos, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_vector_to_list::__resize(const void* __obj, size_t __from, \n+\t\t\t\t   size_t __to)\n+  {\n+    __vector2list_info* __res = __get_object_info(__obj);\n+    if (__res)\n+      __res->__resize(__from, __to);\n+  }\n \n-  __tables<0>::_S_vector_to_list->__opr_insert(__obj, __pos, __num);\n-}\n \n+  // Initialization and report.\n+  inline void \n+  __trace_vector_to_list_init()\n+  { __tables<0>::_S_vector_to_list = new __trace_vector_to_list(); }\n \n-inline void __trace_vector_to_list_iterate(const void* __obj, size_t __num)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_vector_to_list_report(FILE* __f, __warning_vector_t& __warnings)\n+  {\n+    if (__tables<0>::_S_vector_to_list) \n+      {\n+\t__tables<0>::_S_vector_to_list->__collect_warnings(__warnings);\n+\t__tables<0>::_S_vector_to_list->__write(__f);\n+      }\n+  }\n \n-  __tables<0>::_S_vector_to_list->__opr_iterate(__obj, __num);\n-}\n+  // Implementations of instrumentation hooks.\n+  inline void \n+  __trace_vector_to_list_construct(const void* __obj)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_to_list->__insert(__obj, __get_stack());\n+  }\n \n-inline void __trace_vector_to_list_invalid_operator(const void* __obj)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_vector_to_list_destruct(const void* __obj)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_to_list->__destruct(__obj);\n+  }\n \n-  __tables<0>::_S_vector_to_list->__invalid_operator(__obj);\n-}\n+  inline void \n+  __trace_vector_to_list_insert(const void* __obj, size_t __pos, size_t __num)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_to_list->__opr_insert(__obj, __pos, __num);\n+  }\n \n-inline void __trace_vector_to_list_resize(const void* __obj, \n-                                          size_t __from, size_t __to)\n-{\n-  if (!__profcxx_init()) return;\n+  inline void \n+  __trace_vector_to_list_iterate(const void* __obj, size_t __num)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_to_list->__opr_iterate(__obj, __num);\n+  }\n \n-  __tables<0>::_S_vector_to_list->__resize(__obj, __from, __to);\n-}\n+  inline void \n+  __trace_vector_to_list_invalid_operator(const void* __obj)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_to_list->__invalid_operator(__obj);\n+  }\n \n+  inline void \n+  __trace_vector_to_list_resize(const void* __obj, size_t __from, size_t __to)\n+  {\n+    if (!__profcxx_init()) return;\n+    __tables<0>::_S_vector_to_list->__resize(__obj, __from, __to);\n+  }\n } // namespace __gnu_profile\n-#endif /* PROFCXX_PROFILER_VECTOR_TO_LIST_H__ */\n+#endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H */"}]}