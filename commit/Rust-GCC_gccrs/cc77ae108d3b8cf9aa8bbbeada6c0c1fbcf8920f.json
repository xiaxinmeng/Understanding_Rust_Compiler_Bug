{"sha": "cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M3N2FlMTA4ZDNiOGNmOWFhOGJiYmVhZGE2YzBjMWZiY2Y4OTIwZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-08-07T17:40:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-08-07T17:40:10Z"}, "message": "Make return in memory explicit.\n\n        * function.c (aggregate_value_p): Check DECL_BY_REFERENCE.\n        (assign_parm_find_data_types): Remove code for old front end\n        invisible reference handling.\n        (assign_parms): Handle DECL_BY_REFERENCE on the RESULT_DECL.\n        (expand_function_end): Likewise.\n        * gimplify.c (gimplify_return_expr): Handle a dereferenced\n        RESULT_DECL.\n        * tree-inline.c (copy_body_r): Don't bother looking for &* anymore.\n        (declare_return_variable): Handle DECL_BY_REFERENCE.\n        * cp/cp-gimplify.c (is_invisiref_parm): Also handle RESULT_DECL.\n        (cp_genericize_r): Use convert_from_reference.\n        Don't dereference a RESULT_DECL directly inside a RETURN_EXPR.\n        (cp_genericize): Handle the RESULT_DECL.  Unset TREE_ADDRESSABLE.\n\nFrom-SVN: r85675", "tree": {"sha": "252b73c82d55d0b8da42cb892207cf89b9b2d1bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/252b73c82d55d0b8da42cb892207cf89b9b2d1bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0737fbff594ae45dc2e37dc2eff51601cdb99e1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0737fbff594ae45dc2e37dc2eff51601cdb99e1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0737fbff594ae45dc2e37dc2eff51601cdb99e1b"}], "stats": {"total": 120, "additions": 68, "deletions": 52}, "files": [{"sha": "5cea2153d21177822114be68d5bf636f751ea9e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "patch": "@@ -14,6 +14,21 @@\n \n 2004-08-07  Jason Merrill  <jason@redhat.com>\n \n+\tMake return in memory explicit.\n+\t* function.c (aggregate_value_p): Check DECL_BY_REFERENCE.\n+\t(assign_parm_find_data_types): Remove code for old front end\n+\tinvisible reference handling.\n+\t(assign_parms): Handle DECL_BY_REFERENCE on the RESULT_DECL.\n+\t(expand_function_end): Likewise.\n+\t* gimplify.c (gimplify_return_expr): Handle a dereferenced\n+\tRESULT_DECL.\n+\t* tree-inline.c (copy_body_r): Don't bother looking for &* anymore.\n+\t(declare_return_variable): Handle DECL_BY_REFERENCE.\n+\t* cp/cp-gimplify.c (is_invisiref_parm): Also handle RESULT_DECL.\n+\t(cp_genericize_r): Use convert_from_reference.\n+\tDon't dereference a RESULT_DECL directly inside a RETURN_EXPR.\n+\t(cp_genericize): Handle the RESULT_DECL.  Unset TREE_ADDRESSABLE.\n+\n \t* gimplify.c (gimplify_call_expr): Make return in memory explicit.\n \t(gimplify_modify_expr_rhs): Likewise.\n \t* c-common.c (c_warn_unused_result): Check TREE_USED before"}, {"sha": "5b96e39dbef2be94e9347c0a59dc4c4eeb0bf17e", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "patch": "@@ -267,7 +267,7 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n static inline bool\n is_invisiref_parm (tree t)\n {\n-  return (TREE_CODE (t) == PARM_DECL\n+  return ((TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)\n \t  && DECL_BY_REFERENCE (t));\n }\n \n@@ -283,7 +283,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   if (is_invisiref_parm (stmt))\n     {\n-      *stmt_p = build_fold_indirect_ref (stmt);\n+      *stmt_p = convert_from_reference (stmt);\n       *walk_subtrees = 0;\n       return NULL;\n     }\n@@ -302,6 +302,11 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       *stmt_p = convert (TREE_TYPE (stmt), TREE_OPERAND (stmt, 0));\n       *walk_subtrees = 0;\n     }\n+  else if (TREE_CODE (stmt) == RETURN_EXPR\n+\t   && TREE_OPERAND (stmt, 0)\n+\t   && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n+    /* Don't dereference an invisiref RESULT_DECL inside a RETURN_EXPR.  */\n+    *walk_subtrees = 0;\n   else if (DECL_P (stmt) || TYPE_P (stmt))\n     *walk_subtrees = 0;\n \n@@ -331,12 +336,23 @@ cp_genericize (tree fndecl)\n \t{\n \t  if (DECL_ARG_TYPE (t) == TREE_TYPE (t))\n \t    abort ();\n-\t  DECL_BY_REFERENCE (t) = 1;\n \t  TREE_TYPE (t) = DECL_ARG_TYPE (t);\n+\t  DECL_BY_REFERENCE (t) = 1;\n+\t  TREE_ADDRESSABLE (t) = 0;\n \t  relayout_decl (t);\n \t}\n     }\n \n+  /* Do the same for the return value.  */\n+  if (TREE_ADDRESSABLE (TREE_TYPE (DECL_RESULT (fndecl))))\n+    {\n+      t = DECL_RESULT (fndecl);\n+      TREE_TYPE (t) = build_reference_type (TREE_TYPE (t));\n+      DECL_BY_REFERENCE (t) = 1;\n+      TREE_ADDRESSABLE (t) = 0;\n+      relayout_decl (t);\n+    }\n+\n   /* If we're a clone, the body is already GIMPLE.  */\n   if (DECL_CLONED_FUNCTION_P (fndecl))\n     return;"}, {"sha": "4de748aceb8a8c659f3e01544d77896d9026b391", "filename": "gcc/function.c", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "patch": "@@ -1883,6 +1883,11 @@ aggregate_value_p (tree exp, tree fntype)\n \n   if (TREE_CODE (type) == VOID_TYPE)\n     return 0;\n+  /* If the front end has decided that this needs to be passed by\n+     reference, do so.  */\n+  if ((TREE_CODE (exp) == PARM_DECL || TREE_CODE (exp) == RESULT_DECL)\n+      && DECL_BY_REFERENCE (exp))\n+    return 1;\n   if (targetm.calls.return_in_memory (type, fntype))\n     return 1;\n   /* Types that are TREE_ADDRESSABLE must be constructed in memory,\n@@ -2187,15 +2192,6 @@ assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n       data->passed_pointer = true;\n       passed_mode = nominal_mode = Pmode;\n     }\n-  /* See if the frontend wants to pass this by invisible reference.  */\n-  else if (passed_type != nominal_type\n-\t   && POINTER_TYPE_P (passed_type)\n-\t   && TREE_TYPE (passed_type) == nominal_type)\n-    {\n-      nominal_type = passed_type;\n-      data->passed_pointer = 1;\n-      passed_mode = nominal_mode = Pmode;\n-    }\n \n   /* Find mode as it is passed by the ABI.  */\n   promoted_mode = passed_mode;\n@@ -3095,9 +3091,14 @@ assign_parms (tree fndecl)\n       rtx addr = DECL_RTL (all.function_result_decl);\n       rtx x;\n \n-      addr = convert_memory_address (Pmode, addr);\n-      x = gen_rtx_MEM (DECL_MODE (result), addr);\n-      set_mem_attributes (x, result, 1);\n+      if (DECL_BY_REFERENCE (result))\n+\tx = addr;\n+      else\n+\t{\n+\t  addr = convert_memory_address (Pmode, addr);\n+\t  x = gen_rtx_MEM (DECL_MODE (result), addr);\n+\t  set_mem_attributes (x, result, 1);\n+\t}\n       SET_DECL_RTL (result, x);\n     }\n \n@@ -4385,17 +4386,22 @@ expand_function_end (void)\n   if (current_function_returns_struct\n       || current_function_returns_pcc_struct)\n     {\n-      rtx value_address\n-\t= XEXP (DECL_RTL (DECL_RESULT (current_function_decl)), 0);\n+      rtx value_address = DECL_RTL (DECL_RESULT (current_function_decl));\n       tree type = TREE_TYPE (DECL_RESULT (current_function_decl));\n+      rtx outgoing;\n+\n+      if (DECL_BY_REFERENCE (DECL_RESULT (current_function_decl)))\n+\ttype = TREE_TYPE (type);\n+      else\n+\tvalue_address = XEXP (value_address, 0);\n+\n #ifdef FUNCTION_OUTGOING_VALUE\n-      rtx outgoing\n-\t= FUNCTION_OUTGOING_VALUE (build_pointer_type (type),\n-\t\t\t\t   current_function_decl);\n+      outgoing = FUNCTION_OUTGOING_VALUE (build_pointer_type (type),\n+\t\t\t\t\t  current_function_decl);\n #else\n-      rtx outgoing\n-\t= FUNCTION_VALUE (build_pointer_type (type), current_function_decl);\n-#endif\n+      outgoing = FUNCTION_VALUE (build_pointer_type (type),\n+\t\t\t\t current_function_decl);\n+#endif \n \n       /* Mark this as a function return value so integrate will delete the\n \t assignment and USE below when inlining this function.  */"}, {"sha": "c6478ec40f5bf2e996abcbba33adf8764ab13bcb", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "patch": "@@ -895,6 +895,9 @@ gimplify_return_expr (tree stmt, tree *pre_p)\n   else\n     {\n       result_decl = TREE_OPERAND (ret_expr, 0);\n+      if (TREE_CODE (result_decl) == INDIRECT_REF)\n+\t/* See through a return by reference.  */\n+\tresult_decl = TREE_OPERAND (result_decl, 0);\n #ifdef ENABLE_CHECKING\n       if ((TREE_CODE (ret_expr) != MODIFY_EXPR\n \t   && TREE_CODE (ret_expr) != INIT_EXPR)"}, {"sha": "b34844d82f3945f7cb3537046c1ad9eaa32795c5", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=cc77ae108d3b8cf9aa8bbbeada6c0c1fbcf8920f", "patch": "@@ -573,33 +573,6 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t}\n \t    }\n \t}\n-      else if (TREE_CODE (*tp) == ADDR_EXPR\n-\t       && (lang_hooks.tree_inlining.auto_var_in_fn_p\n-\t\t   (TREE_OPERAND (*tp, 0), fn)))\n-\t{\n-\t  /* Get rid of &* from inline substitutions.  It can occur when\n-\t     someone takes the address of a parm or return slot passed by\n-\t     invisible reference.  */\n-\t  tree decl = TREE_OPERAND (*tp, 0), value;\n-\t  splay_tree_node n;\n-\n-\t  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n-\t  if (n)\n-\t    {\n-\t      value = (tree) n->value;\n-\t      if (TREE_CODE (value) == INDIRECT_REF)\n-\t\t{\n-\t\t  if  (!lang_hooks.types_compatible_p\n-\t\t       (TREE_TYPE (*tp), TREE_TYPE (TREE_OPERAND (value, 0))))\n-\t\t    *tp = fold_convert (TREE_TYPE (*tp),\n-\t\t\t\t\tTREE_OPERAND (value, 0));\n-\t\t  else\n-\t\t    *tp = TREE_OPERAND (value, 0);\n-\n-\t\t  return copy_body_r (tp, walk_subtrees, data);\n-\t\t}\n-\t    }\n-\t}\n       else if (TREE_CODE (*tp) == INDIRECT_REF)\n \t{\n \t  /* Get rid of *& from inline substitutions that can happen when a\n@@ -861,15 +834,18 @@ declare_return_variable (inline_data *id, tree return_slot_addr,\n       return NULL_TREE;\n     }\n \n-  /* If there was a return slot, then the return value the the\n+  /* If there was a return slot, then the return value is the\n      dereferenced address of that object.  */\n   if (return_slot_addr)\n     {\n       /* The front end shouldn't have used both return_slot_addr and\n \t a modify expression.  */\n       if (modify_dest)\n \tabort ();\n-      var = build_fold_indirect_ref (return_slot_addr);\n+      if (DECL_BY_REFERENCE (result))\n+\tvar = return_slot_addr;\n+      else\n+\tvar = build_fold_indirect_ref (return_slot_addr);\n       use = NULL;\n       goto done;\n     }"}]}