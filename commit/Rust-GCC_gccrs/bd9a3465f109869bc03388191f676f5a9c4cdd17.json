{"sha": "bd9a3465f109869bc03388191f676f5a9c4cdd17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ5YTM0NjVmMTA5ODY5YmMwMzM4ODE5MWY2NzZmNWE5YzRjZGQxNw==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2009-06-08T23:40:09Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2009-06-08T23:40:09Z"}, "message": "sh-protos.h (sh_optimization_options): Declare.\n\n\t* config/sh/sh-protos.h (sh_optimization_options): Declare.\n\t(sh_override_options): Likewise.\n\t* config/sh/sh.c: Include params.h.\n\t(sh_optimization_options): New.\n\t(sh_override_options): Likewise.\n\t* config/sh/sh.c (OPTIMIZATION_OPTIONS): Use sh_optimization_options.\n\t(OVERRIDE_OPTIONS): Use sh_override_options.\n\nFrom-SVN: r148299", "tree": {"sha": "8c72dd6a2b731d9f4eea5ab3f4b79c3b6ba5ed97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c72dd6a2b731d9f4eea5ab3f4b79c3b6ba5ed97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd9a3465f109869bc03388191f676f5a9c4cdd17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9a3465f109869bc03388191f676f5a9c4cdd17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd9a3465f109869bc03388191f676f5a9c4cdd17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd9a3465f109869bc03388191f676f5a9c4cdd17/comments", "author": null, "committer": null, "parents": [{"sha": "8845deabba0fa4aec0200e4ed310bf6b489ed1fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8845deabba0fa4aec0200e4ed310bf6b489ed1fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8845deabba0fa4aec0200e4ed310bf6b489ed1fc"}], "stats": {"total": 558, "additions": 291, "deletions": 267}, "files": [{"sha": "fc4bad1f35ce4a0652cbb9b270da48e6091d920b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bd9a3465f109869bc03388191f676f5a9c4cdd17", "patch": "@@ -1,3 +1,13 @@\n+2009-06-08  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh-protos.h (sh_optimization_options): Declare.\n+\t(sh_override_options): Likewise.\n+\t* config/sh/sh.c: Include params.h.\n+\t(sh_optimization_options): New.\n+\t(sh_override_options): Likewise.\n+\t* config/sh/sh.c (OPTIMIZATION_OPTIONS): Use sh_optimization_options.\n+\t(OVERRIDE_OPTIONS): Use sh_override_options.\n+\n 2009-06-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (emit_cfa_remember): New variable."}, {"sha": "35cd73021b9f31000fd5ae7c19464f95735a86b7", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=bd9a3465f109869bc03388191f676f5a9c4cdd17", "patch": "@@ -125,6 +125,8 @@ extern rtx sh_gen_truncate (enum machine_mode, rtx, int);\n extern bool sh_vector_mode_supported_p (enum machine_mode);\n #endif /* RTX_CODE */\n \n+extern void sh_optimization_options (int, int);\n+extern void sh_override_options (void);\n extern const char *output_jump_label_table (void);\n extern int sh_handle_pragma (int (*)(void), void (*)(int), const char *);\n extern struct rtx_def *get_fpscr_rtx (void);"}, {"sha": "7c8b82a7549e1e4deb28f10fd2e092f10d37eefe", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=bd9a3465f109869bc03388191f676f5a9c4cdd17", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfglayout.h\"\n #include \"intl.h\"\n #include \"sched-int.h\"\n+#include \"params.h\"\n #include \"ggc.h\"\n #include \"gimple.h\"\n #include \"cfgloop.h\"\n@@ -610,6 +611,280 @@ sh_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED,\n     }\n }\n \f\n+/* Set default optimization options.  */\n+void\n+sh_optimization_options (int level ATTRIBUTE_UNUSED, int size ATTRIBUTE_UNUSED)\n+{\n+  if (level)\n+    {\n+      flag_omit_frame_pointer = 2;\n+      if (!size)\n+\tsh_div_str = \"inv:minlat\";\n+    }\n+  if (size)\n+    {\n+      target_flags |= MASK_SMALLCODE;\n+      sh_div_str = SH_DIV_STR_FOR_SIZE ;\n+    }\n+  else\n+    TARGET_CBRANCHDI4 = 1;\n+  /* We can't meaningfully test TARGET_SHMEDIA here, because -m options\n+     haven't been parsed yet, hence we'd read only the default.\n+     sh_target_reg_class will return NO_REGS if this is not SHMEDIA, so\n+     it's OK to always set flag_branch_target_load_optimize.  */\n+  if (level > 1)\n+    {\n+      flag_branch_target_load_optimize = 1;\n+      if (!size)\n+\ttarget_flags |= MASK_SAVE_ALL_TARGET_REGS;\n+    }\n+  /* Likewise, we can't meaningfully test TARGET_SH2E / TARGET_IEEE\n+     here, so leave it to OVERRIDE_OPTIONS to set\n+    flag_finite_math_only.  We set it to 2 here so we know if the user\n+    explicitly requested this to be on or off.  */\n+  flag_finite_math_only = 2;\n+  /* If flag_schedule_insns is 1, we set it to 2 here so we know if\n+     the user explicitly requested this to be on or off.  */\n+  if (flag_schedule_insns > 0)\n+    flag_schedule_insns = 2;\n+\n+  set_param_value (\"simultaneous-prefetches\", 2);\n+}\n+\n+/* Implement OVERRIDE_OPTIONS macro.  Validate and override various\n+   options, and do some machine dependent initialization.  */\n+void\n+sh_override_options (void)\n+{\n+  int regno;\n+\n+  SUBTARGET_OVERRIDE_OPTIONS;\n+  if (flag_finite_math_only == 2)\n+    flag_finite_math_only\n+      = !flag_signaling_nans && TARGET_SH2E && ! TARGET_IEEE;\n+  if (TARGET_SH2E && !flag_finite_math_only)\n+    target_flags |= MASK_IEEE;\n+  sh_cpu = PROCESSOR_SH1;\n+  assembler_dialect = 0;\n+  if (TARGET_SH2)\n+    sh_cpu = PROCESSOR_SH2;\n+  if (TARGET_SH2E)\n+    sh_cpu = PROCESSOR_SH2E;\n+  if (TARGET_SH2A)\n+    {\n+      sh_cpu = PROCESSOR_SH2A;\n+      if (TARGET_SH2A_DOUBLE)\n+        target_flags |= MASK_FMOVD;\n+    }\n+  if (TARGET_SH3)\n+    sh_cpu = PROCESSOR_SH3;\n+  if (TARGET_SH3E)\n+    sh_cpu = PROCESSOR_SH3E;\n+  if (TARGET_SH4)\n+    {\n+      assembler_dialect = 1;\n+      sh_cpu = PROCESSOR_SH4;\n+    }\n+  if (TARGET_SH4A_ARCH)\n+    {\n+      assembler_dialect = 1;\n+      sh_cpu = PROCESSOR_SH4A;\n+    }\n+  if (TARGET_SH5)\n+    {\n+      sh_cpu = PROCESSOR_SH5;\n+      target_flags |= MASK_ALIGN_DOUBLE;\n+      if (TARGET_SHMEDIA_FPU)\n+\ttarget_flags |= MASK_FMOVD;\n+      if (TARGET_SHMEDIA)\n+\t{\n+\t  /* There are no delay slots on SHmedia.  */\n+\t  flag_delayed_branch = 0;\n+\t  /* Relaxation isn't yet supported for SHmedia */\n+\t  target_flags &= ~MASK_RELAX;\n+\t  /* After reload, if conversion does little good but can cause\n+\t     ICEs:\n+\t     - find_if_block doesn't do anything for SH because we don't\n+\t       have conditional execution patterns.  (We use conditional\n+\t       move patterns, which are handled differently, and only\n+\t       before reload).\n+\t     - find_cond_trap doesn't do anything for the SH because we\n+\t       don't have conditional traps.\n+\t     - find_if_case_1 uses redirect_edge_and_branch_force in\n+\t       the only path that does an optimization, and this causes\n+\t       an ICE when branch targets are in registers.\n+\t     - find_if_case_2 doesn't do anything for the SHmedia after\n+\t       reload except when it can redirect a tablejump - and\n+\t       that's rather rare.  */\n+\t  flag_if_conversion2 = 0;\n+\t  if (! strcmp (sh_div_str, \"call\"))\n+\t    sh_div_strategy = SH_DIV_CALL;\n+\t  else if (! strcmp (sh_div_str, \"call2\"))\n+\t    sh_div_strategy = SH_DIV_CALL2;\n+\t  if (! strcmp (sh_div_str, \"fp\") && TARGET_FPU_ANY)\n+\t    sh_div_strategy = SH_DIV_FP;\n+\t  else if (! strcmp (sh_div_str, \"inv\"))\n+\t    sh_div_strategy = SH_DIV_INV;\n+\t  else if (! strcmp (sh_div_str, \"inv:minlat\"))\n+\t    sh_div_strategy = SH_DIV_INV_MINLAT;\n+\t  else if (! strcmp (sh_div_str, \"inv20u\"))\n+\t    sh_div_strategy = SH_DIV_INV20U;\n+\t  else if (! strcmp (sh_div_str, \"inv20l\"))\n+\t    sh_div_strategy = SH_DIV_INV20L;\n+\t  else if (! strcmp (sh_div_str, \"inv:call2\"))\n+\t    sh_div_strategy = SH_DIV_INV_CALL2;\n+\t  else if (! strcmp (sh_div_str, \"inv:call\"))\n+\t    sh_div_strategy = SH_DIV_INV_CALL;\n+\t  else if (! strcmp (sh_div_str, \"inv:fp\"))\n+\t    {\n+\t      if (TARGET_FPU_ANY)\n+\t\tsh_div_strategy = SH_DIV_INV_FP;\n+\t      else\n+\t\tsh_div_strategy = SH_DIV_INV;\n+\t    }\n+\t  TARGET_CBRANCHDI4 = 0;\n+\t  /* Assembler CFI isn't yet fully supported for SHmedia.  */\n+\t  flag_dwarf2_cfi_asm = 0;\n+\t}\n+    }\n+  else\n+    {\n+       /* Only the sh64-elf assembler fully supports .quad properly.  */\n+       targetm.asm_out.aligned_op.di = NULL;\n+       targetm.asm_out.unaligned_op.di = NULL;\n+    }\n+  if (TARGET_SH1)\n+    {\n+      if (! strcmp (sh_div_str, \"call-div1\"))\n+\tsh_div_strategy = SH_DIV_CALL_DIV1;\n+      else if (! strcmp (sh_div_str, \"call-fp\")\n+\t       && (TARGET_FPU_DOUBLE\n+\t\t   || (TARGET_HARD_SH4 && TARGET_SH2E)\n+\t\t   || (TARGET_SHCOMPACT && TARGET_FPU_ANY)))\n+\tsh_div_strategy = SH_DIV_CALL_FP;\n+      else if (! strcmp (sh_div_str, \"call-table\") && TARGET_SH2)\n+\tsh_div_strategy = SH_DIV_CALL_TABLE;\n+      else\n+\t/* Pick one that makes most sense for the target in general.\n+\t   It is not much good to use different functions depending\n+\t   on -Os, since then we'll end up with two different functions\n+\t   when some of the code is compiled for size, and some for\n+\t   speed.  */\n+\n+\t/* SH4 tends to emphasize speed.  */\n+\tif (TARGET_HARD_SH4)\n+\t  sh_div_strategy = SH_DIV_CALL_TABLE;\n+\t/* These have their own way of doing things.  */\n+\telse if (TARGET_SH2A)\n+\t  sh_div_strategy = SH_DIV_INTRINSIC;\n+\t/* ??? Should we use the integer SHmedia function instead?  */\n+\telse if (TARGET_SHCOMPACT && TARGET_FPU_ANY)\n+\t  sh_div_strategy = SH_DIV_CALL_FP;\n+        /* SH1 .. SH3 cores often go into small-footprint systems, so\n+\t   default to the smallest implementation available.  */\n+\telse if (TARGET_SH2)\t/* ??? EXPERIMENTAL */\n+\t  sh_div_strategy = SH_DIV_CALL_TABLE;\n+\telse\n+\t  sh_div_strategy = SH_DIV_CALL_DIV1;\n+    }\n+  if (!TARGET_SH1)\n+    TARGET_PRETEND_CMOVE = 0;\n+  if (sh_divsi3_libfunc[0])\n+    ; /* User supplied - leave it alone.  */\n+  else if (TARGET_DIVIDE_CALL_FP)\n+    sh_divsi3_libfunc = \"__sdivsi3_i4\";\n+  else if (TARGET_DIVIDE_CALL_TABLE)\n+    sh_divsi3_libfunc = \"__sdivsi3_i4i\";\n+  else if (TARGET_SH5)\n+    sh_divsi3_libfunc = \"__sdivsi3_1\";\n+  else\n+    sh_divsi3_libfunc = \"__sdivsi3\";\n+  if (sh_branch_cost == -1)\n+    sh_branch_cost\n+      = TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (! VALID_REGISTER_P (regno))\n+      sh_register_names[regno][0] = '\\0';\n+\n+  for (regno = 0; regno < ADDREGNAMES_SIZE; regno++)\n+    if (! VALID_REGISTER_P (ADDREGNAMES_REGNO (regno)))\n+      sh_additional_register_names[regno][0] = '\\0';\n+\n+  if (flag_omit_frame_pointer == 2)\n+   {\n+     /* The debugging information is sufficient,\n+        but gdb doesn't implement this yet */\n+     if (0)\n+      flag_omit_frame_pointer\n+        = (PREFERRED_DEBUGGING_TYPE == DWARF2_DEBUG);\n+     else\n+      flag_omit_frame_pointer = 0;\n+   }\n+\n+  if ((flag_pic && ! TARGET_PREFERGOT)\n+      || (TARGET_SHMEDIA && !TARGET_PT_FIXED))\n+    flag_no_function_cse = 1;\n+\n+  if (SMALL_REGISTER_CLASSES)\n+    {\n+      /* Never run scheduling before reload, since that can\n+\t break global alloc, and generates slower code anyway due\n+\t to the pressure on R0.  */\n+      /* Enable sched1 for SH4 if the user explicitly requests.\n+\t When sched1 is enabled, the ready queue will be reordered by\n+\t the target hooks if pressure is high.  We can not do this for\n+\t PIC, SH3 and lower as they give spill failures for R0.  */\n+      if (!TARGET_HARD_SH4 || flag_pic)\n+        flag_schedule_insns = 0;\n+      /* ??? Current exception handling places basic block boundaries\n+\t after call_insns.  It causes the high pressure on R0 and gives\n+\t spill failures for R0 in reload.  See PR 22553 and the thread\n+\t on gcc-patches\n+         <http://gcc.gnu.org/ml/gcc-patches/2005-10/msg00816.html>.  */\n+      else if (flag_exceptions)\n+\t{\n+\t  if (flag_schedule_insns == 1)\n+\t    warning (0, \"ignoring -fschedule-insns because of exception handling bug\");\n+\t  flag_schedule_insns = 0;\n+\t}\n+      else if (flag_schedule_insns == 2)\n+\tflag_schedule_insns = 0;\n+    }\n+\n+  if (align_loops == 0)\n+    align_loops =  1 << (TARGET_SH5 ? 3 : 2);\n+  if (align_jumps == 0)\n+    align_jumps = 1 << CACHE_LOG;\n+  else if (align_jumps < (TARGET_SHMEDIA ? 4 : 2))\n+    align_jumps = TARGET_SHMEDIA ? 4 : 2;\n+\n+  /* Allocation boundary (in *bytes*) for the code of a function.\n+     SH1: 32 bit alignment is faster, because instructions are always\n+     fetched as a pair from a longword boundary.\n+     SH2 .. SH5 : align to cache line start.  */\n+  if (align_functions == 0)\n+    align_functions\n+      = TARGET_SMALLCODE ? FUNCTION_BOUNDARY/8 : (1 << CACHE_LOG);\n+  /* The linker relaxation code breaks when a function contains\n+     alignments that are larger than that at the start of a\n+     compilation unit.  */\n+  if (TARGET_RELAX)\n+    {\n+      int min_align\n+\t= align_loops > align_jumps ? align_loops : align_jumps;\n+\n+      /* Also take possible .long constants / mova tables int account.\t*/\n+      if (min_align < 4)\n+\tmin_align = 4;\n+      if (align_functions < min_align)\n+\talign_functions = min_align;\n+    }\n+\n+  if (sh_fixed_range_str)\n+    sh_fix_range (sh_fixed_range_str);\n+}\n+\f\n /* Print the operand address in x to the stream.  */\n \n void"}, {"sha": "7f90147bccd3f53b8c6ab330c9ac25c42a45c5a3", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 4, "deletions": 267, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd9a3465f109869bc03388191f676f5a9c4cdd17/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=bd9a3465f109869bc03388191f676f5a9c4cdd17", "patch": "@@ -459,43 +459,8 @@ do { \\\n #endif\n \n #define DRIVER_SELF_SPECS \"%{m2a:%{ml:%eSH2a does not support little-endian}}\"\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (LEVEL)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      flag_omit_frame_pointer = 2;\t\t\t\t\t\\\n-      if (! SIZE)\t\t\t\t\t\t\t\\\n-\tsh_div_str = \"inv:minlat\";\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (SIZE)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      target_flags |= MASK_SMALLCODE;\t\t\t\t\t\\\n-      sh_div_str = SH_DIV_STR_FOR_SIZE ;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    TARGET_CBRANCHDI4 = 1;\t\t\t\t\t\t\\\n-  /* We can't meaningfully test TARGET_SHMEDIA here, because -m options\t\\\n-     haven't been parsed yet, hence we'd read only the default.\t\\\n-     sh_target_reg_class will return NO_REGS if this is not SHMEDIA, so\t\\\n-     it's OK to always set flag_branch_target_load_optimize.  */\t\\\n-  if (LEVEL > 1)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      flag_branch_target_load_optimize = 1;\t\t\t\t\\\n-      if (! (SIZE))\t\t\t\t\t\t\t\\\n-\ttarget_flags |= MASK_SAVE_ALL_TARGET_REGS;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  /* Likewise, we can't meaningfully test TARGET_SH2E / TARGET_IEEE\t\\\n-     here, so leave it to OVERRIDE_OPTIONS to set\t\t\t\\\n-    flag_finite_math_only.  We set it to 2 here so we know if the user\t\\\n-    explicitly requested this to be on or off.  */\t\t\t\\\n-  flag_finite_math_only = 2;\t\t\t\t\t\t\\\n-  /* If flag_schedule_insns is 1, we set it to 2 here so we know if\t\\\n-     the user explicitly requested this to be on or off.  */\t\t\\\n-  if (flag_schedule_insns > 0)\t\t\t\t\t\t\\\n-    flag_schedule_insns = 2;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  set_param_value (\"simultaneous-prefetches\", 2);\t\t\t\\\n-} while (0)\n+\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) sh_optimization_options (LEVEL, SIZE)\n \n #define ASSEMBLER_DIALECT assembler_dialect\n \n@@ -532,236 +497,8 @@ extern enum sh_divide_strategy_e sh_div_strategy;\n \n extern const char *sh_fixed_range_str;\n \n-#define OVERRIDE_OPTIONS \t\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  int regno;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  SUBTARGET_OVERRIDE_OPTIONS;\t\t\t\t\t\t\\\n-  if (flag_finite_math_only == 2)\t\t\t\t\t\\\n-    flag_finite_math_only\t\t\t\t\t\t\\\n-      = !flag_signaling_nans && TARGET_SH2E && ! TARGET_IEEE;\t\t\\\n-  if (TARGET_SH2E && !flag_finite_math_only)\t\t\t\t\\\n-    target_flags |= MASK_IEEE;\t\t\t\t\t\t\\\n-  sh_cpu = PROCESSOR_SH1;\t\t\t\t\t\t\\\n-  assembler_dialect = 0;\t\t\t\t\t\t\\\n-  if (TARGET_SH2)\t\t\t\t\t\t\t\\\n-    sh_cpu = PROCESSOR_SH2;\t\t\t\t\t\t\\\n-  if (TARGET_SH2E)\t\t\t\t\t\t\t\\\n-    sh_cpu = PROCESSOR_SH2E;\t\t\t\t\t\t\\\n-  if (TARGET_SH2A)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      sh_cpu = PROCESSOR_SH2A;\t\t\t\t\t\t\\\n-      if (TARGET_SH2A_DOUBLE)\t\t\t\t\t\t\\\n-        target_flags |= MASK_FMOVD;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SH3)\t\t\t\t\t\t\t\\\n-    sh_cpu = PROCESSOR_SH3;\t\t\t\t\t\t\\\n-  if (TARGET_SH3E)\t\t\t\t\t\t\t\\\n-    sh_cpu = PROCESSOR_SH3E;\t\t\t\t\t\t\\\n-  if (TARGET_SH4)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      assembler_dialect = 1;\t\t\t\t\t\t\\\n-      sh_cpu = PROCESSOR_SH4;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SH4A_ARCH)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      assembler_dialect = 1;\t\t\t\t\t\t\\\n-      sh_cpu = PROCESSOR_SH4A;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SH5)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      sh_cpu = PROCESSOR_SH5;\t\t\t\t\t\t\\\n-      target_flags |= MASK_ALIGN_DOUBLE;\t\t\t\t\\\n-      if (TARGET_SHMEDIA_FPU)\t\t\t\t\t\t\\\n-\ttarget_flags |= MASK_FMOVD;\t\t\t\t\t\\\n-      if (TARGET_SHMEDIA)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  /* There are no delay slots on SHmedia.  */\t\t\t\\\n-\t  flag_delayed_branch = 0;\t\t\t\t\t\\\n-\t  /* Relaxation isn't yet supported for SHmedia */\t\t\\\n-\t  target_flags &= ~MASK_RELAX;\t\t\t\t\t\\\n-\t  /* After reload, if conversion does little good but can cause \\\n-\t     ICEs:\t\t\t\t\t\t\t\\\n-\t     - find_if_block doesn't do anything for SH because we don't\\\n-\t       have conditional execution patterns.  (We use conditional\\\n-\t       move patterns, which are handled differently, and only\t\\\n-\t       before reload).\t\t\t\t\t\t\\\n-\t     - find_cond_trap doesn't do anything for the SH because we \\\t\n-\t       don't have conditional traps.\t\t\t\t\\\n-\t     - find_if_case_1 uses redirect_edge_and_branch_force in\t\\\n-\t       the only path that does an optimization, and this causes\t\\\n-\t       an ICE when branch targets are in registers.\t\t\\\n-\t     - find_if_case_2 doesn't do anything for the SHmedia after\t\\\n-\t       reload except when it can redirect a tablejump - and\t\\\n-\t       that's rather rare.  */\t\t\t\t\t\\\n-\t  flag_if_conversion2 = 0;\t\t\t\t\t\\\n-\t  if (! strcmp (sh_div_str, \"call\"))\t\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_CALL;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"call2\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_CALL2;\t\t\t\t\\\n-\t  if (! strcmp (sh_div_str, \"fp\") && TARGET_FPU_ANY)\t\t\\\n-\t    sh_div_strategy = SH_DIV_FP;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_INV;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv:minlat\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_INV_MINLAT;\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv20u\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_INV20U;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv20l\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_INV20L;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv:call2\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_INV_CALL2;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv:call\"))\t\t\t\\\n-\t    sh_div_strategy = SH_DIV_INV_CALL;\t\t\t\t\\\n-\t  else if (! strcmp (sh_div_str, \"inv:fp\"))\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (TARGET_FPU_ANY)\t\t\t\t\t\\\n-\t\tsh_div_strategy = SH_DIV_INV_FP;\t\t\t\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tsh_div_strategy = SH_DIV_INV;\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  TARGET_CBRANCHDI4 = 0;\t\t\t\t\t\\\n-\t  /* Assembler CFI isn't yet fully supported for SHmedia.  */\t\\\n-\t  flag_dwarf2_cfi_asm = 0;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-       /* Only the sh64-elf assembler fully supports .quad properly.  */\\\n-       targetm.asm_out.aligned_op.di = NULL;\t\t\t\t\\\n-       targetm.asm_out.unaligned_op.di = NULL;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_SH1)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! strcmp (sh_div_str, \"call-div1\"))\t\t\t\t\\\n-\tsh_div_strategy = SH_DIV_CALL_DIV1;\t\t\t\t\\\n-      else if (! strcmp (sh_div_str, \"call-fp\")\t\t\t\t\\\n-\t       && (TARGET_FPU_DOUBLE\t\t\t\t\t\\\n-\t\t   || (TARGET_HARD_SH4 && TARGET_SH2E)\t\t\t\\\n-\t\t   || (TARGET_SHCOMPACT && TARGET_FPU_ANY)))\t\t\\\n-\tsh_div_strategy = SH_DIV_CALL_FP;\t\t\t\t\\\n-      else if (! strcmp (sh_div_str, \"call-table\") && TARGET_SH2)\t\\\n-\tsh_div_strategy = SH_DIV_CALL_TABLE;\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t/* Pick one that makes most sense for the target in general.\t\\\n-\t   It is not much good to use different functions depending\t\\\n-\t   on -Os, since then we'll end up with two different functions\t\\\n-\t   when some of the code is compiled for size, and some for\t\\\n-\t   speed.  */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\t/* SH4 tends to emphasize speed.  */\t\t\t\t\\\n-\tif (TARGET_HARD_SH4)\t\t\t\t\t\t\\\n-\t  sh_div_strategy = SH_DIV_CALL_TABLE;\t\t\t\t\\\n-\t/* These have their own way of doing things.  */\t\t\\\n-\telse if (TARGET_SH2A)\t\t\t\t\t\t\\\n-\t  sh_div_strategy = SH_DIV_INTRINSIC;\t\t\t\t\\\n-\t/* ??? Should we use the integer SHmedia function instead?  */\t\\\n-\telse if (TARGET_SHCOMPACT && TARGET_FPU_ANY)\t\t\t\\\n-\t  sh_div_strategy = SH_DIV_CALL_FP;\t\t\t\t\\\n-        /* SH1 .. SH3 cores often go into small-footprint systems, so\t\\\n-\t   default to the smallest implementation available.  */\t\\\n-\telse if (TARGET_SH2)\t/* ??? EXPERIMENTAL */\t\t\t\\\n-\t  sh_div_strategy = SH_DIV_CALL_TABLE;\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  sh_div_strategy = SH_DIV_CALL_DIV1;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!TARGET_SH1)\t\t\t\t\t\t\t\\\n-    TARGET_PRETEND_CMOVE = 0;\t\t\t\t\t\t\\\n-  if (sh_divsi3_libfunc[0])\t\t\t\t\t\t\\\n-    ; /* User supplied - leave it alone.  */\t\t\t\t\\\n-  else if (TARGET_DIVIDE_CALL_FP)\t\t\t\t\t\\\n-    sh_divsi3_libfunc = \"__sdivsi3_i4\";\t\t\t\t\t\\\n-  else if (TARGET_DIVIDE_CALL_TABLE)\t\t\t\t\t\\\n-    sh_divsi3_libfunc = \"__sdivsi3_i4i\";\t\t\t\t\\\n-  else if (TARGET_SH5)\t\t\t\t\t\t\t\\\n-    sh_divsi3_libfunc = \"__sdivsi3_1\";\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    sh_divsi3_libfunc = \"__sdivsi3\";\t\t\t\t\t\\\n-  if (sh_branch_cost == -1)\t\t\t\t\t\t\\\n-    sh_branch_cost\t\t\t\t\t\t\t\\\n-      = TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n-    if (! VALID_REGISTER_P (regno))\t\t\t\t\t\\\n-      sh_register_names[regno][0] = '\\0';\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  for (regno = 0; regno < ADDREGNAMES_SIZE; regno++)\t\t\t\\\n-    if (! VALID_REGISTER_P (ADDREGNAMES_REGNO (regno)))\t\t\t\\\n-      sh_additional_register_names[regno][0] = '\\0';\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (flag_omit_frame_pointer == 2)\t\t\t\t\t\\\n-   {\t\t\t\t\t\t\t\t\t\\\n-     /* The debugging information is sufficient,\t\t\t\\\n-        but gdb doesn't implement this yet */\t\t\t\t\\\n-     if (0)\t\t\t\t\t\t\t\t\\\n-      flag_omit_frame_pointer\t\t\t\t\t\t\\\n-        = (PREFERRED_DEBUGGING_TYPE == DWARF2_DEBUG);\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-      flag_omit_frame_pointer = 0;\t\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if ((flag_pic && ! TARGET_PREFERGOT)\t\t\t\t\t\\\n-      || (TARGET_SHMEDIA && !TARGET_PT_FIXED))\t\t\t\t\\\n-    flag_no_function_cse = 1;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (SMALL_REGISTER_CLASSES)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Never run scheduling before reload, since that can\t\t\\\n-\t break global alloc, and generates slower code anyway due\t\\\n-\t to the pressure on R0.  */\t\t\t\t\t\\\n-      /* Enable sched1 for SH4 if the user explicitly requests.\t\t\\\n-\t When sched1 is enabled, the ready queue will be reordered by\t\\\n-\t the target hooks if pressure is high.  We can not do this for\t\\\n-\t PIC, SH3 and lower as they give spill failures for R0.  */\t\\\n-      if (!TARGET_HARD_SH4 || flag_pic)\t\t\t\t\t\\\n-        flag_schedule_insns = 0;\t\t \t\t\t\\\n-      /* ??? Current exception handling places basic block boundaries\t\\\n-\t after call_insns.  It causes the high pressure on R0 and gives\t\\\n-\t spill failures for R0 in reload.  See PR 22553 and the thread\t\\\n-\t on gcc-patches\t\t\t\t\t\t\t\\\n-         <http://gcc.gnu.org/ml/gcc-patches/2005-10/msg00816.html>.  */\t\\\n-      else if (flag_exceptions)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (flag_schedule_insns == 1)\t\t \t\t\t\\\n-\t    warning (0, \"ignoring -fschedule-insns because of exception handling bug\");\t\\\n-\t  flag_schedule_insns = 0;\t\t \t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (flag_schedule_insns == 2)\t\t\t\t\\\n-\tflag_schedule_insns = 0;\t\t \t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (align_loops == 0)\t\t\t\t\t\t\t\\\n-    align_loops =  1 << (TARGET_SH5 ? 3 : 2);\t\t\t\t\\\n-  if (align_jumps == 0)\t\t\t\t\t\t\t\\\n-    align_jumps = 1 << CACHE_LOG;\t\t\t\t\t\\\n-  else if (align_jumps < (TARGET_SHMEDIA ? 4 : 2))\t\t\t\\\n-    align_jumps = TARGET_SHMEDIA ? 4 : 2;\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* Allocation boundary (in *bytes*) for the code of a function.\t\\\n-     SH1: 32 bit alignment is faster, because instructions are always\t\\\n-     fetched as a pair from a longword boundary.\t\t\t\\\n-     SH2 .. SH5 : align to cache line start.  */\t\t\t\\\n-  if (align_functions == 0)\t\t\t\t\t\t\\\n-    align_functions\t\t\t\t\t\t\t\\\n-      = TARGET_SMALLCODE ? FUNCTION_BOUNDARY/8 : (1 << CACHE_LOG);\t\\\n-  /* The linker relaxation code breaks when a function contains\t\t\\\n-     alignments that are larger than that at the start of a\t\t\\\n-     compilation unit.  */\t\t\t\t\t\t\\\n-  if (TARGET_RELAX)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int min_align\t\t\t\t\t\t\t\\\n-\t= align_loops > align_jumps ? align_loops : align_jumps;\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      /* Also take possible .long constants / mova tables int account.\t*/\\\n-      if (min_align < 4)\t\t\t\t\t\t\\\n-\tmin_align = 4;\t\t\t\t\t\t\t\\\n-      if (align_functions < min_align)\t\t\t\t\t\\\n-\talign_functions = min_align;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (sh_fixed_range_str)\t\t\t\t\t\t\\\n-    sh_fix_range (sh_fixed_range_str);\t\t\t\t\t\\\n-} while (0)\n+#define OVERRIDE_OPTIONS sh_override_options ()\n+\n \f\n /* Target machine storage layout.  */\n "}]}