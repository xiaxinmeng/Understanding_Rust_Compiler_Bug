{"sha": "ce96d372535446c64e2434f5eafddf78331f2808", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U5NmQzNzI1MzU0NDZjNjRlMjQzNGY1ZWFmZGRmNzgzMzFmMjgwOA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-09-02T22:09:07Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-09-02T22:09:07Z"}, "message": "PR fortran/PR56519\n\n2013-09-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/PR56519\n\t* gfortran.h:  Declare gfc_do_concurrent_flag as extern.\n\t* resolve.c:  Rename do_concurrent_flag to gfc_do_concurrent_flag\n\tand make non-static.\n\t(resolve_function):  Use gfc_do_concurrent_flag instead of\n\tdo_concurrent_flag.\n\t(pure_subroutine):  Likewise.\n\t(resolve_code):  Likewise.\n\t(resolve_types):  Likewise.\n\t* intrinsic.c (gfc_intrinsic_sub_interface):  Raise error for\n\tnon-pure intrinsic subroutines within DO CONCURRENT.\n\n2013-09-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/PR56519\n\t* gfortran.dg/do_concurrent_3.f90:  New test case.\n\nFrom-SVN: r202188", "tree": {"sha": "879ee6e37a254540b134cd1a1f80c3b10c14caf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879ee6e37a254540b134cd1a1f80c3b10c14caf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce96d372535446c64e2434f5eafddf78331f2808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce96d372535446c64e2434f5eafddf78331f2808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce96d372535446c64e2434f5eafddf78331f2808", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce96d372535446c64e2434f5eafddf78331f2808/comments", "author": null, "committer": null, "parents": [{"sha": "07d6cd643c70adfef414d49cc129bb63cf4badf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d6cd643c70adfef414d49cc129bb63cf4badf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07d6cd643c70adfef414d49cc129bb63cf4badf8"}], "stats": {"total": 58, "additions": 49, "deletions": 9}, "files": [{"sha": "2b34517741d462cf515440a13fdeee316f5b3dab", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ce96d372535446c64e2434f5eafddf78331f2808", "patch": "@@ -1,3 +1,17 @@\n+2013-09-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/PR56519\n+\t* gfortran.h:  Declare gfc_do_concurrent_flag as extern.\n+\t* resolve.c:  Rename do_concurrent_flag to gfc_do_concurrent_flag\n+\tand make non-static.\n+\t(resolve_function):  Use gfc_do_concurrent_flag instead of\n+\tdo_concurrent_flag.\n+\t(pure_subroutine):  Likewise.\n+\t(resolve_code):  Likewise.\n+\t(resolve_types):  Likewise.\n+\t* intrinsic.c (gfc_intrinsic_sub_interface):  Raise error for\n+\tnon-pure intrinsic subroutines within DO CONCURRENT.\n+\n 2013-08-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/52243"}, {"sha": "b28edd80002f151f64acc829e9fd22ff28510aaf", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ce96d372535446c64e2434f5eafddf78331f2808", "patch": "@@ -2846,6 +2846,7 @@ gfc_expr *gfc_expr_to_initialize (gfc_expr *);\n bool gfc_type_is_extensible (gfc_symbol *);\n bool gfc_resolve_intrinsic (gfc_symbol *, locus *);\n bool gfc_explicit_interface_required (gfc_symbol *, char *, int);\n+extern int gfc_do_concurrent_flag;\n \n \n /* array.c */"}, {"sha": "3da3c5365a0d93d0d854774d065c51c63187fed9", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=ce96d372535446c64e2434f5eafddf78331f2808", "patch": "@@ -4397,6 +4397,13 @@ gfc_intrinsic_sub_interface (gfc_code *c, int error_flag)\n       c->resolved_sym->attr.elemental = isym->elemental;\n     }\n \n+  if (gfc_do_concurrent_flag && !isym->pure)\n+    {\n+      gfc_error (\"Subroutine call to intrinsic '%s' in DO CONCURRENT \"\n+\t\t \"block at %L is not PURE\", name, &c->loc);\n+      return MATCH_ERROR;\n+    }\n+\n   if (gfc_pure (NULL) && !isym->pure)\n     {\n       gfc_error (\"Subroutine call to intrinsic '%s' at %L is not PURE\", name,"}, {"sha": "2929679aecc6441959bf59cd895676c24633874a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=ce96d372535446c64e2434f5eafddf78331f2808", "patch": "@@ -60,7 +60,7 @@ static code_stack *cs_base = NULL;\n /* Nonzero if we're inside a FORALL or DO CONCURRENT block.  */\n \n static int forall_flag;\n-static int do_concurrent_flag;\n+int gfc_do_concurrent_flag;\n \n /* True when we are resolving an expression that is an actual argument to\n    a procedure.  */\n@@ -2986,11 +2986,11 @@ resolve_function (gfc_expr *expr)\n \t\t     forall_flag == 2 ? \"mask\" : \"block\");\n \t  t = false;\n \t}\n-      else if (do_concurrent_flag)\n+      else if (gfc_do_concurrent_flag)\n \t{\n \t  gfc_error (\"Reference to non-PURE function '%s' at %L inside a \"\n \t\t     \"DO CONCURRENT %s\", name, &expr->where,\n-\t\t     do_concurrent_flag == 2 ? \"mask\" : \"block\");\n+\t\t     gfc_do_concurrent_flag == 2 ? \"mask\" : \"block\");\n \t  t = false;\n \t}\n       else if (gfc_pure (NULL))\n@@ -3059,7 +3059,7 @@ pure_subroutine (gfc_code *c, gfc_symbol *sym)\n   if (forall_flag)\n     gfc_error (\"Subroutine call to '%s' in FORALL block at %L is not PURE\",\n \t       sym->name, &c->loc);\n-  else if (do_concurrent_flag)\n+  else if (gfc_do_concurrent_flag)\n     gfc_error (\"Subroutine call to '%s' in DO CONCURRENT block at %L is not \"\n \t       \"PURE\", sym->name, &c->loc);\n   else if (gfc_pure (NULL))\n@@ -9629,7 +9629,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n     {\n       frame.current = code;\n       forall_save = forall_flag;\n-      do_concurrent_save = do_concurrent_flag;\n+      do_concurrent_save = gfc_do_concurrent_flag;\n \n       if (code->op == EXEC_FORALL)\n \t{\n@@ -9663,9 +9663,9 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t\t to transform the SELECT TYPE into ASSOCIATE first.  */\n \t      break;\n             case EXEC_DO_CONCURRENT:\n-\t      do_concurrent_flag = 1;\n+\t      gfc_do_concurrent_flag = 1;\n \t      gfc_resolve_blocks (code->block, ns);\n-\t      do_concurrent_flag = 2;\n+\t      gfc_do_concurrent_flag = 2;\n \t      break;\n \t    case EXEC_OMP_WORKSHARE:\n \t      omp_workshare_save = omp_workshare_flag;\n@@ -9684,7 +9684,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n       if (code->op != EXEC_COMPCALL && code->op != EXEC_CALL_PPC)\n \tt = gfc_resolve_expr (code->expr1);\n       forall_flag = forall_save;\n-      do_concurrent_flag = do_concurrent_save;\n+      gfc_do_concurrent_flag = do_concurrent_save;\n \n       if (!gfc_resolve_expr (code->expr2))\n \tt = false;\n@@ -14404,7 +14404,7 @@ resolve_types (gfc_namespace *ns)\n     }\n \n   forall_flag = 0;\n-  do_concurrent_flag = 0;\n+  gfc_do_concurrent_flag = 0;\n   gfc_check_interfaces (ns);\n \n   gfc_traverse_ns (ns, resolve_values);"}, {"sha": "db785f70b9abce8cc6051b8014cdb669fe9288fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce96d372535446c64e2434f5eafddf78331f2808", "patch": "@@ -1,3 +1,8 @@\n+2013-09-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/PR56519\n+\t* gfortran.dg/do_concurrent_3.f90:  New test case.\n+\n 2013-09-02  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/tree-ssa/fnsplit-1.c: New testcase."}, {"sha": "09bb0cce722181a353204e3095fc80e7acb8d66f", "filename": "gcc/testsuite/gfortran.dg/do_concurrent_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_concurrent_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce96d372535446c64e2434f5eafddf78331f2808/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_concurrent_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdo_concurrent_3.f90?ref=ce96d372535446c64e2434f5eafddf78331f2808", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! PR 56519 - flag impure intrinsic subroutine calls\n+! within DO CONCURRENT\n+program main\n+  implicit none\n+  integer :: i\n+  real :: array(123), val\n+\n+  do concurrent (i = 1:123)\n+     call random_number (val) ! { dg-error \"is not PURE\" }\n+     array(i) = val\n+  end do\n+end program main"}]}