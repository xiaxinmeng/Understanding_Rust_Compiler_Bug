{"sha": "3339f0bcb06a145e127e5274e223827a6aeb3cb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMzOWYwYmNiMDZhMTQ1ZTEyN2U1Mjc0ZTIyMzgyN2E2YWViM2NiMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-07-29T09:39:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-07-29T09:39:06Z"}, "message": "cgraph.c (cgraph_node::create_indirect_edge): Copy speculative data.\n\n\t* cgraph.c (cgraph_node::create_indirect_edge): Copy speculative data.\n\t* cgraph.h (cgraph_indirect_call_info): Add speculative data.\n\t* gimple-fold.c (fold_gimple_assign): Fix check for virtual\n\tcall.\n\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): Update\n\t(contains_type_p): Forward declare.\n\t(polymorphic_call_target_hasher::hash): Hash speculative info.\n\t(polymorphic_call_target_hasher::equal): Compare speculative info.\n\t(get_class_context): Handle speuclation.\n\t(contains_type_p): Update.\n\t(get_polymorphic_call_info_for_decl): Update.\n\t(walk_ssa_copies): Break out from ...\n\t(get_polymorphic_call_info): ... here; set speculative context\n\tbefore giving up.\n\t* ipa-prop.c (ipa_write_indirect_edge_info, ipa_read_indirect_edge_info):\n\tStream speculative context.\n\t* ipa-utils.h (ipa_polymorphic_call_context): Add speculative info\n\t(SPECULATIVE_OFFSET, SPECULATIVE_OUTER_TYPE,\n\tSPECULATIVE_MAYBE_DERIVED_TYPE).\n\t(possible_polymorphic_call_targets overriders): Update.\n\t(dump_possible_polymorphic_call_targets overriders): Update.\n\t(dump_possible_polymorphic_call_target_p overriders): Update.\n\nFrom-SVN: r213152", "tree": {"sha": "17a1672ffb371dd2e673d37baa24eda5b181647f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17a1672ffb371dd2e673d37baa24eda5b181647f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3339f0bcb06a145e127e5274e223827a6aeb3cb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3339f0bcb06a145e127e5274e223827a6aeb3cb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3339f0bcb06a145e127e5274e223827a6aeb3cb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3339f0bcb06a145e127e5274e223827a6aeb3cb0/comments", "author": null, "committer": null, "parents": [{"sha": "f8a39967a57f8880b7050d53cbf888218626c493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a39967a57f8880b7050d53cbf888218626c493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a39967a57f8880b7050d53cbf888218626c493"}], "stats": {"total": 294, "additions": 251, "deletions": 43}, "files": [{"sha": "484a5e18101a4a079e5ab2c9c73c214dd177a43b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3339f0bcb06a145e127e5274e223827a6aeb3cb0", "patch": "@@ -1,3 +1,28 @@\n+2014-07-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_node::create_indirect_edge): Copy speculative data.\n+\t* cgraph.h (cgraph_indirect_call_info): Add speculative data.\n+\t* gimple-fold.c (fold_gimple_assign): Fix check for virtual\n+\tcall.\n+\t* ipa-devirt.c (ipa_dummy_polymorphic_call_context): Update\n+\t(contains_type_p): Forward declare.\n+\t(polymorphic_call_target_hasher::hash): Hash speculative info.\n+\t(polymorphic_call_target_hasher::equal): Compare speculative info.\n+\t(get_class_context): Handle speuclation.\n+\t(contains_type_p): Update.\n+\t(get_polymorphic_call_info_for_decl): Update.\n+\t(walk_ssa_copies): Break out from ...\n+\t(get_polymorphic_call_info): ... here; set speculative context\n+\tbefore giving up.\n+\t* ipa-prop.c (ipa_write_indirect_edge_info, ipa_read_indirect_edge_info):\n+\tStream speculative context.\n+\t* ipa-utils.h (ipa_polymorphic_call_context): Add speculative info\n+\t(SPECULATIVE_OFFSET, SPECULATIVE_OUTER_TYPE,\n+\tSPECULATIVE_MAYBE_DERIVED_TYPE).\n+\t(possible_polymorphic_call_targets overriders): Update.\n+\t(dump_possible_polymorphic_call_targets overriders): Update.\n+\t(dump_possible_polymorphic_call_target_p overriders): Update.\n+\n 2014-07-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gimple-fold.c (fold_gimple_assign): Fix condition guarding"}, {"sha": "52f9985694a0d50331eeb75d7cca1a790590899d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=3339f0bcb06a145e127e5274e223827a6aeb3cb0", "patch": "@@ -973,10 +973,15 @@ cgraph_node::create_indirect_edge (gimple call_stmt, int ecf_flags,\n       edge->indirect_info->otr_token = otr_token;\n       edge->indirect_info->otr_type = otr_type;\n       edge->indirect_info->outer_type = context.outer_type;\n+      edge->indirect_info->speculative_outer_type\n+\t = context.speculative_outer_type;\n       edge->indirect_info->offset = context.offset;\n+      edge->indirect_info->speculative_offset = context.speculative_offset;\n       edge->indirect_info->maybe_in_construction\n \t = context.maybe_in_construction;\n       edge->indirect_info->maybe_derived_type = context.maybe_derived_type;\n+      edge->indirect_info->speculative_maybe_derived_type\n+\t = context.speculative_maybe_derived_type;\n     }\n \n   edge->next_callee = indirect_calls;\n@@ -3043,12 +3048,9 @@ cgraph_node::get_body (void)\n   data = lto_get_section_data (file_data, LTO_section_function_body,\n \t\t\t       name, &len);\n   if (!data)\n-    {\n-\tdebug ();\n     fatal_error (\"%s: section %s is missing\",\n \t\t file_data->file_name,\n \t\t name);\n-    }\n \n   gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n "}, {"sha": "d8651e2f6f390730bdb7814cd07e8bcc4423fb85", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=3339f0bcb06a145e127e5274e223827a6aeb3cb0", "patch": "@@ -1243,11 +1243,11 @@ struct GTY(()) cgraph_indirect_call_info\n      was actually used in the polymorphic resides within a larger structure.\n      If agg_contents is set, the field contains the offset within the aggregate\n      from which the address to call was loaded.  */\n-  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT offset, speculative_offset;\n   /* OBJ_TYPE_REF_TOKEN of a polymorphic call (if polymorphic is set).  */\n   HOST_WIDE_INT otr_token;\n   /* Type of the object from OBJ_TYPE_REF_OBJECT. */\n-  tree otr_type, outer_type;\n+  tree otr_type, outer_type, speculative_outer_type;\n   /* Index of the parameter that is called.  */\n   int param_index;\n   /* ECF flags determined from the caller.  */\n@@ -1270,6 +1270,7 @@ struct GTY(()) cgraph_indirect_call_info\n   unsigned by_ref : 1;\n   unsigned int maybe_in_construction : 1;\n   unsigned int maybe_derived_type : 1;\n+  unsigned int speculative_maybe_derived_type : 1;\n };\n \n struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgraph_edge {"}, {"sha": "4b5b2a659c0f60b1b46fa3fcd497c4b129265d72", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 190, "deletions": 32, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=3339f0bcb06a145e127e5274e223827a6aeb3cb0", "patch": "@@ -141,7 +141,7 @@ static bool odr_violation_reported = false;\n /* Dummy polymorphic call context.  */\n \n const ipa_polymorphic_call_context ipa_dummy_polymorphic_call_context\n-   = {0, NULL, false, true};\n+   = {0, 0, NULL, NULL, false, true, true};\n \n /* Pointer set of all call targets appearing in the cache.  */\n static pointer_set_t *cached_polymorphic_call_targets;\n@@ -175,6 +175,8 @@ struct GTY(()) odr_type_d\n   bool odr_violated;\n };\n \n+static bool contains_type_p (tree, HOST_WIDE_INT, tree);\n+\n \n /* Return true if BINFO corresponds to a type with virtual methods. \n \n@@ -1641,8 +1643,16 @@ polymorphic_call_target_hasher::hash (const value_type *odr_query)\n   hash = iterative_hash_hashval_t (TYPE_UID (odr_query->context.outer_type),\n \t\t\t\t   hash);\n   hash = iterative_hash_host_wide_int (odr_query->context.offset, hash);\n+  if (odr_query->context.speculative_outer_type)\n+    {\n+      hash = iterative_hash_hashval_t\n+\t       (TYPE_UID (odr_query->context.speculative_outer_type), hash);\n+      hash = iterative_hash_host_wide_int (odr_query->context.speculative_offset,\n+\t\t\t\t\t   hash);\n+    }\n   return iterative_hash_hashval_t\n-\t    (((int)odr_query->context.maybe_in_construction << 1)\n+\t    (((int)odr_query->context.maybe_in_construction << 2)\n+\t     | ((int)odr_query->context.speculative_maybe_derived_type << 1)\n \t     | (int)odr_query->context.maybe_derived_type, hash);\n }\n \n@@ -1654,10 +1664,14 @@ polymorphic_call_target_hasher::equal (const value_type *t1,\n {\n   return (t1->type == t2->type && t1->otr_token == t2->otr_token\n \t  && t1->context.offset == t2->context.offset\n+\t  && t1->context.speculative_offset == t2->context.speculative_offset\n \t  && t1->context.outer_type == t2->context.outer_type\n+\t  && t1->context.speculative_outer_type == t2->context.speculative_outer_type\n \t  && t1->context.maybe_in_construction\n \t      == t2->context.maybe_in_construction\n-\t  && t1->context.maybe_derived_type == t2->context.maybe_derived_type);\n+\t  && t1->context.maybe_derived_type == t2->context.maybe_derived_type\n+\t  && (t1->context.speculative_maybe_derived_type\n+\t      == t2->context.speculative_maybe_derived_type));\n }\n \n /* Remove entry in polymorphic call target cache hash.  */\n@@ -1750,9 +1764,42 @@ get_class_context (ipa_polymorphic_call_context *context,\n {\n   tree type = context->outer_type;\n   HOST_WIDE_INT offset = context->offset;\n-\n+  bool speculative = false;\n+  bool speculation_valid = false;\n+  bool valid = false;\n+\n+ if (!context->outer_type)\n+   {\n+     context->outer_type = expected_type;\n+     context->offset = offset;\n+   }\n+  /* See if speculative type seem to be derrived from outer_type.\n+     Then speculation is valid only if it really is a derivate and derived types\n+     are allowed.  \n+\n+     The test does not really look for derivate, but also accepts the case where\n+     outer_type is a field of speculative_outer_type.  In this case eiter\n+     MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n+     the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n+     and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n+  if (context->speculative_outer_type\n+      && context->speculative_offset >= context->offset\n+      && contains_type_p (context->speculative_outer_type,\n+\t\t\t  context->offset - context->speculative_offset,\n+\t\t\t  context->outer_type))\n+    speculation_valid = context->maybe_derived_type;\n+  else\n+    {\n+      context->speculative_outer_type = NULL;\n+      context->speculative_offset = 0;\n+      context->speculative_maybe_derived_type = false;\n+    }\n+\t\t\t       \n   /* Find the sub-object the constant actually refers to and mark whether it is\n-     an artificial one (as opposed to a user-defined one).  */\n+     an artificial one (as opposed to a user-defined one).\n+\n+     This loop is performed twice; first time for outer_type and second time\n+     for speculative_outer_type.  The second iteration has SPECULATIVE set.  */\n   while (true)\n     {\n       HOST_WIDE_INT pos, size;\n@@ -1762,12 +1809,51 @@ get_class_context (ipa_polymorphic_call_context *context,\n       if (TREE_CODE (type) == TREE_CODE (expected_type)\n \t  && types_same_for_odr (type, expected_type))\n \t{\n-\t  /* Type can not contain itself on an non-zero offset.  In that case\n-\t     just give up.  */\n-\t  if (offset != 0)\n-\t    goto give_up;\n-\t  gcc_assert (offset == 0);\n-\t  return true;\n+\t  if (speculative)\n+\t    {\n+\t      gcc_assert (speculation_valid);\n+\t      gcc_assert (valid);\n+\n+\t      /* If we did not match the offset, just give up on speculation.  */\n+\t      if (offset != 0\n+\t\t  || (types_same_for_odr (context->speculative_outer_type,\n+\t\t\t\t\t  context->outer_type)\n+\t\t      && (context->maybe_derived_type\n+\t\t\t  == context->speculative_maybe_derived_type)))\n+\t\t{\n+\t\t  context->speculative_outer_type = NULL;\n+\t\t  context->speculative_offset = 0;\n+\t\t}\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Type can not contain itself on an non-zero offset.  In that case\n+\t\t just give up.  */\n+\t      if (offset != 0)\n+\t\t{\n+\t\t  valid = false;\n+\t\t  goto give_up;\n+\t\t}\n+\t      valid = true;\n+\t      /* If speculation is not valid or we determined type precisely,\n+\t\t we are done.  */\n+\t      if (!speculation_valid\n+\t\t  || !context->maybe_derived_type)\n+\t\t{\n+\t\t  context->speculative_outer_type = NULL;\n+\t\t  context->speculative_offset = 0;\n+\t          return true;\n+\t\t}\n+\t      /* Otherwise look into speculation now.  */\n+\t      else\n+\t\t{\n+\t\t  speculative = true;\n+\t\t  type = context->speculative_outer_type;\n+\t\t  offset = context->speculative_offset;\n+\t\t  continue;\n+\t\t}\n+\t    }\n \t}\n \n       /* Walk fields and find corresponding on at OFFSET.  */\n@@ -1792,11 +1878,20 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t  /* DECL_ARTIFICIAL represents a basetype.  */\n \t  if (!DECL_ARTIFICIAL (fld))\n \t    {\n-\t      context->outer_type = type;\n-\t      context->offset = offset;\n-\t      /* As soon as we se an field containing the type,\n-\t\t we know we are not looking for derivations.  */\n-\t      context->maybe_derived_type = false;\n+\t      if (!speculative)\n+\t\t{\n+\t\t  context->outer_type = type;\n+\t\t  context->offset = offset;\n+\t\t  /* As soon as we se an field containing the type,\n+\t\t     we know we are not looking for derivations.  */\n+\t\t  context->maybe_derived_type = false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  context->speculative_outer_type = type;\n+\t\t  context->speculative_offset = offset;\n+\t\t  context->speculative_maybe_derived_type = false;\n+\t\t}\n \t    }\n \t}\n       else if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -1809,9 +1904,18 @@ get_class_context (ipa_polymorphic_call_context *context,\n \t    goto give_up;\n \t  offset = offset % tree_to_shwi (TYPE_SIZE (subtype));\n \t  type = subtype;\n-\t  context->outer_type = type;\n-\t  context->offset = offset;\n-\t  context->maybe_derived_type = false;\n+\t  if (!speculative)\n+\t    {\n+\t      context->outer_type = type;\n+\t      context->offset = offset;\n+\t      context->maybe_derived_type = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      context->speculative_outer_type = type;\n+\t      context->speculative_offset = offset;\n+\t      context->speculative_maybe_derived_type = false;\n+\t    }\n \t}\n       /* Give up on anything else.  */\n       else\n@@ -1821,6 +1925,11 @@ get_class_context (ipa_polymorphic_call_context *context,\n   /* If we failed to find subtype we look for, give up and fall back to the\n      most generic query.  */\n give_up:\n+  context->speculative_outer_type = NULL;\n+  context->speculative_offset = 0;\n+  context->speculative_maybe_derived_type = false;\n+  if (valid)\n+    return true;\n   context->outer_type = expected_type;\n   context->offset = 0;\n   context->maybe_derived_type = true;\n@@ -1831,7 +1940,8 @@ get_class_context (ipa_polymorphic_call_context *context,\n   if ((TREE_CODE (type) != RECORD_TYPE\n        || !TYPE_BINFO (type)\n        || !polymorphic_type_binfo_p (TYPE_BINFO (type)))\n-      && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n+      && (!TYPE_SIZE (type)\n+\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n \t  || (offset + tree_to_uhwi (TYPE_SIZE (expected_type)) <=\n \t      tree_to_uhwi (TYPE_SIZE (type)))))\n     return true;\n@@ -1844,9 +1954,9 @@ static bool\n contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n \t\t tree otr_type)\n {\n-  ipa_polymorphic_call_context context = {offset,\n+  ipa_polymorphic_call_context context = {offset, 0,\n \t\t\t\t\t  TYPE_MAIN_VARIANT (outer_type),\n-\t\t\t\t\t  false, true};\n+\t\t\t\t\t  NULL, false, true, false};\n   return get_class_context (&context, otr_type);\n }\n \n@@ -2054,6 +2164,9 @@ get_polymorphic_call_info_for_decl (ipa_polymorphic_call_context *context,\n \n   context->outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n   context->offset = offset;\n+  context->speculative_outer_type = NULL;\n+  context->speculative_offset = 0;\n+  context->speculative_maybe_derived_type = true;\n   /* Make very conservative assumption that all objects\n      may be in construction. \n      TODO: ipa-prop already contains code to tell better. \n@@ -2093,6 +2206,26 @@ get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *context,\n   return true;\n }\n \n+/* See if OP is SSA name initialized as a copy or by single assignment.\n+   If so, walk the SSA graph up.  */\n+\n+static tree\n+walk_ssa_copies (tree op)\n+{\n+  STRIP_NOPS (op);\n+  while (TREE_CODE (op) == SSA_NAME\n+\t && !SSA_NAME_IS_DEFAULT_DEF (op)\n+\t && SSA_NAME_DEF_STMT (op)\n+\t && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n+    {\n+      if (gimple_assign_load_p (SSA_NAME_DEF_STMT (op)))\n+\treturn op;\n+      op = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op));\n+      STRIP_NOPS (op);\n+    }\n+  return op;\n+}\n+\n /* Given REF call in FNDECL, determine class of the polymorphic\n    call (OTR_TYPE), its token (OTR_TOKEN) and CONTEXT.\n    CALL is optional argument giving the actual statement (usually call) where\n@@ -2112,6 +2245,9 @@ get_polymorphic_call_info (tree fndecl,\n   *otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (ref));\n \n   /* Set up basic info in case we find nothing interesting in the analysis.  */\n+  context->speculative_outer_type = NULL;\n+  context->speculative_offset = 0;\n+  context->speculative_maybe_derived_type = true;\n   context->outer_type = TYPE_MAIN_VARIANT (*otr_type);\n   context->offset = 0;\n   base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n@@ -2121,15 +2257,8 @@ get_polymorphic_call_info (tree fndecl,\n   /* Walk SSA for outer object.  */\n   do \n     {\n-      if (TREE_CODE (base_pointer) == SSA_NAME\n-\t  && !SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n-\t  && SSA_NAME_DEF_STMT (base_pointer)\n-\t  && gimple_assign_single_p (SSA_NAME_DEF_STMT (base_pointer)))\n-\t{\n-\t  base_pointer = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (base_pointer));\n-\t  STRIP_NOPS (base_pointer);\n-\t}\n-      else if (TREE_CODE (base_pointer) == ADDR_EXPR)\n+      base_pointer = walk_ssa_copies (base_pointer);\n+      if (TREE_CODE (base_pointer) == ADDR_EXPR)\n \t{\n \t  HOST_WIDE_INT size, max_size;\n \t  HOST_WIDE_INT offset2;\n@@ -2175,7 +2304,7 @@ get_polymorphic_call_info (tree fndecl,\n \t\t\t\t\t\t     context->outer_type,\n \t\t\t\t\t\t     call,\n \t\t\t\t\t\t     current_function_decl);\n-\t\t  return NULL;\n+\t\t  return base_pointer;\n \t\t}\n \t      else\n \t\tbreak;\n@@ -2259,6 +2388,35 @@ get_polymorphic_call_info (tree fndecl,\n           return base_pointer;\n \t}\n     }\n+\n+  tree base_type = TREE_TYPE (base_pointer);\n+\n+  if (TREE_CODE (base_pointer) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n+      && TREE_CODE (SSA_NAME_VAR (base_pointer)) != PARM_DECL)\n+    {\n+      /* Use OTR_TOKEN = INT_MAX as a marker of probably type inconsistent\n+\t code sequences; we arrange the calls to be builtin_unreachable\n+\t later.  */\n+      *otr_token = INT_MAX;\n+      return base_pointer;\n+    }\n+  if (TREE_CODE (base_pointer) == SSA_NAME\n+      && SSA_NAME_DEF_STMT (base_pointer)\n+      && gimple_assign_single_p (SSA_NAME_DEF_STMT (base_pointer)))\n+    base_type = TREE_TYPE (gimple_assign_rhs1\n+\t\t\t    (SSA_NAME_DEF_STMT (base_pointer)));\n+ \n+  if (POINTER_TYPE_P (base_type)\n+      && contains_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n+\t\t\t  context->offset,\n+\t\t\t  *otr_type))\n+    {\n+      context->speculative_outer_type = TYPE_MAIN_VARIANT\n+\t\t\t\t\t  (TREE_TYPE (base_type));\n+      context->speculative_offset = context->offset;\n+      context->speculative_maybe_derived_type = true;\n+    }\n   /* TODO: There are multiple ways to derive a type.  For instance\n      if BASE_POINTER is passed to an constructor call prior our refernece.\n      We do not make this type of flow sensitive analysis yet.  */"}, {"sha": "576e59acc20099556770f707d6de95791d99eb78", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=3339f0bcb06a145e127e5274e223827a6aeb3cb0", "patch": "@@ -4693,13 +4693,17 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n   bp_pack_value (&bp, ii->by_ref, 1);\n   bp_pack_value (&bp, ii->maybe_in_construction, 1);\n   bp_pack_value (&bp, ii->maybe_derived_type, 1);\n+  bp_pack_value (&bp, ii->speculative_maybe_derived_type, 1);\n   streamer_write_bitpack (&bp);\n \n   if (ii->polymorphic)\n     {\n       streamer_write_hwi (ob, ii->otr_token);\n       stream_write_tree (ob, ii->otr_type, true);\n       stream_write_tree (ob, ii->outer_type, true);\n+      stream_write_tree (ob, ii->speculative_outer_type, true);\n+      if (ii->speculative_outer_type)\n+        streamer_write_hwi (ob, ii->speculative_offset);\n     }\n }\n \n@@ -4723,11 +4727,15 @@ ipa_read_indirect_edge_info (struct lto_input_block *ib,\n   ii->by_ref = bp_unpack_value (&bp, 1);\n   ii->maybe_in_construction = bp_unpack_value (&bp, 1);\n   ii->maybe_derived_type = bp_unpack_value (&bp, 1);\n+  ii->speculative_maybe_derived_type = bp_unpack_value (&bp, 1);\n   if (ii->polymorphic)\n     {\n       ii->otr_token = (HOST_WIDE_INT) streamer_read_hwi (ib);\n       ii->otr_type = stream_read_tree (ib, data_in);\n       ii->outer_type = stream_read_tree (ib, data_in);\n+      ii->speculative_outer_type = stream_read_tree (ib, data_in);\n+      if (ii->speculative_outer_type)\n+        ii->speculative_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n     }\n }\n "}, {"sha": "12543048289a295c142a507ba519b38f0f79f59d", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3339f0bcb06a145e127e5274e223827a6aeb3cb0/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=3339f0bcb06a145e127e5274e223827a6aeb3cb0", "patch": "@@ -38,13 +38,19 @@ struct ipa_dfs_info {\n    type inheritance graph.  */\n struct ipa_polymorphic_call_context {\n   /* The called object appears in an object of type OUTER_TYPE\n-     at offset OFFSET.  */\n+     at offset OFFSET.  When information is not 100% reliable, we\n+     use SPECULATIVE_OUTER_TYPE and SPECULATIVE_OFFSET. */\n   HOST_WIDE_INT offset;\n+  HOST_WIDE_INT speculative_offset;\n   tree outer_type;\n+  tree speculative_outer_type;\n   /* True if outer object may be in construction or destruction.  */\n   bool maybe_in_construction;\n   /* True if outer object may be of derived type.  */\n   bool maybe_derived_type;\n+  /* True if speculative outer object may be of derived type.  We always\n+     speculate that construction does not happen.  */\n+  bool speculative_maybe_derived_type;\n };\n \n /* Context representing \"I know nothing\".  */\n@@ -89,6 +95,7 @@ tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n \t\t\t\tipa_polymorphic_call_context *,\n \t\t\t\tgimple call = NULL);\n+bool get_dynamic_type (tree, ipa_polymorphic_call_context *, tree, gimple);\n bool get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *,\n \t\t\t\t\t       tree, tree, HOST_WIDE_INT);\n bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n@@ -114,9 +121,12 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n   ipa_polymorphic_call_context context = {e->indirect_info->offset,\n+\t\t\t\t\t  e->indirect_info->speculative_offset,\n \t\t\t\t\t  e->indirect_info->outer_type,\n+\t\t\t\t\t  e->indirect_info->speculative_outer_type,\n \t\t\t\t\t  e->indirect_info->maybe_in_construction,\n-\t\t\t\t\t  e->indirect_info->maybe_derived_type};\n+\t\t\t\t\t  e->indirect_info->maybe_derived_type,\n+\t\t\t\t\t  e->indirect_info->speculative_maybe_derived_type};\n   return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n \t\t\t\t\t    e->indirect_info->otr_token,\n \t\t\t\t\t    context,\n@@ -153,9 +163,12 @@ dump_possible_polymorphic_call_targets (FILE *f, struct cgraph_edge *e)\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n   ipa_polymorphic_call_context context = {e->indirect_info->offset,\n+\t\t\t\t\t  e->indirect_info->speculative_offset,\n \t\t\t\t\t  e->indirect_info->outer_type,\n+\t\t\t\t\t  e->indirect_info->speculative_outer_type,\n \t\t\t\t\t  e->indirect_info->maybe_in_construction,\n-\t\t\t\t\t  e->indirect_info->maybe_derived_type};\n+\t\t\t\t\t  e->indirect_info->maybe_derived_type,\n+\t\t\t\t\t  e->indirect_info->speculative_maybe_derived_type};\n   dump_possible_polymorphic_call_targets (f, e->indirect_info->otr_type,\n \t\t\t\t\t  e->indirect_info->otr_token,\n \t\t\t\t\t  context);\n@@ -168,10 +181,11 @@ inline bool\n possible_polymorphic_call_target_p (struct cgraph_edge *e,\n \t\t\t\t    struct cgraph_node *n)\n {\n-  ipa_polymorphic_call_context context = {e->indirect_info->offset,\n-\t\t\t\t\t  e->indirect_info->outer_type,\n+  ipa_polymorphic_call_context context = {e->indirect_info->offset, 0,\n+\t\t\t\t\t  e->indirect_info->outer_type, NULL,\n \t\t\t\t\t  e->indirect_info->maybe_in_construction,\n-\t\t\t\t\t  e->indirect_info->maybe_derived_type};\n+\t\t\t\t\t  e->indirect_info->maybe_derived_type,\n+\t\t\t\t\t  false};\n   return possible_polymorphic_call_target_p (e->indirect_info->otr_type,\n \t\t\t\t\t     e->indirect_info->otr_token,\n \t\t\t\t\t     context, n);"}]}