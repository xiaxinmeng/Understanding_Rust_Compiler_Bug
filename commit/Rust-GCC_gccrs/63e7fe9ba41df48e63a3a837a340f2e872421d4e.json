{"sha": "63e7fe9ba41df48e63a3a837a340f2e872421d4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjNlN2ZlOWJhNDFkZjQ4ZTYzYTNhODM3YTM0MGYyZTg3MjQyMWQ0ZQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-08-29T22:14:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-29T22:14:07Z"}, "message": "pa.md (reload_peepholes): Make sure operand is a REG before examining REGNO.\n\n        * pa.md (reload_peepholes): Make sure operand is a REG before\n        examining REGNO.  Allow general registers too.\nFixes sporatic c-torture failure.\n\nRemove last change to fold-const.c and c-decl.c\n\nFrom-SVN: r15000", "tree": {"sha": "7d9d57ce58d730a09cfd1ea2569dc58950c18cba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9d57ce58d730a09cfd1ea2569dc58950c18cba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63e7fe9ba41df48e63a3a837a340f2e872421d4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e7fe9ba41df48e63a3a837a340f2e872421d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63e7fe9ba41df48e63a3a837a340f2e872421d4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63e7fe9ba41df48e63a3a837a340f2e872421d4e/comments", "author": null, "committer": null, "parents": [{"sha": "eb7b11fd0742ac1377e3b6338feec6fc2e64200e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb7b11fd0742ac1377e3b6338feec6fc2e64200e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb7b11fd0742ac1377e3b6338feec6fc2e64200e"}], "stats": {"total": 377, "additions": 169, "deletions": 208}, "files": [{"sha": "dd03361ee3fc559b266f4c86b3026bc5ffc3eb04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=63e7fe9ba41df48e63a3a837a340f2e872421d4e", "patch": "@@ -1,3 +1,8 @@\n+Fri Aug 29 16:13:51 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* pa.md (reload_peepholes): Make sure operand is a REG before\n+\texamining REGNO.  Allow general registers too.\n+\n Fri Aug 29 11:42:04 1997  Jim Wilson  <wilson@cygnus.com>\n \n \t* varasm.c (mark_constants): Don't look inside CONST_DOUBLEs.\n@@ -85,11 +90,6 @@ Wed Aug 27 01:56:18 1997  Doug Evans  <dje@seba.cygnus.com>\n \n \t* loop.c (combine_movables): Earlier insns don't match later ones.\n \n-\t* c-decl.c (grokdeclarator): If array index or size calculations\n-\toverflow, issue an error.\n-\t* fold-const.c (int_const_binop): New static function.\n-\t(const_binop, size_binop): Call it.\n-\n Wed Aug 27 01:24:25 1997  H.J. Lu   (hjl@gnu.ai.mit.edu)\n \n \t* config/linux.h (CC1_SPEC): Define it only if not defined."}, {"sha": "b556d0825f1fd7e4a25b262165e15e03746f249f", "filename": "gcc/c-decl.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=63e7fe9ba41df48e63a3a837a340f2e872421d4e", "patch": "@@ -4672,18 +4672,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t\t\t   convert (index_type, size),\n \t\t\t\t   convert (index_type, size_one_node)));\n \n-\t      /* If that overflowed, the array is too big.\n-\t\t ??? While a size of INT_MAX+1 technically shouldn't cause\n-\t\t an overflow (because we subtract 1), the overflow is recorded\n-\t\t during the conversion to index_type, before the subtraction.\n-\t\t Handling this case seems like an unnecessary complication.  */\n-\t      if (TREE_OVERFLOW (itype))\n-\t\t{\n-\t\t  error (\"size of array `%s' is too large\", name);\n-\t\t  type = error_mark_node;\n-\t\t  continue;\n-\t\t}\n-\n \t      if (size_varies)\n \t\titype = variable_size (itype);\n \t      itype = build_index_type (itype);\n@@ -4859,13 +4847,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n   /* Now TYPE has the actual type.  */\n \n-  /* Did array size calculations overflow?  */\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_SIZE (type)\n-      && TREE_OVERFLOW (TYPE_SIZE (type)))\n-    error (\"size of array `%s' is too large\", name);\n-\n   /* If this is declaring a typedef name, return a TYPE_DECL.  */\n \n   if (specbits & (1 << (int) RID_TYPEDEF))"}, {"sha": "1844a6ea844b3217550e385351a8ad679113f2ce", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=63e7fe9ba41df48e63a3a837a340f2e872421d4e", "patch": "@@ -4835,15 +4835,17 @@\n ;; Clean up turds left by reload.\n (define_peephole\n   [(set (match_operand 0 \"reg_or_nonsymb_mem_operand\" \"\")\n-\t(match_operand 1 \"register_operand\" \"f\"))\n-   (set (match_operand 2 \"register_operand\" \"f\")\n+\t(match_operand 1 \"register_operand\" \"fr\"))\n+   (set (match_operand 2 \"register_operand\" \"fr\")\n \t(match_dup 0))]\n   \"! TARGET_SOFT_FLOAT\n    && GET_CODE (operands[0]) == MEM\n    && ! MEM_VOLATILE_P (operands[0])\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE (operands[0]) == GET_MODE (operands[2])\n    && GET_MODE (operands[0]) == DFmode\n+   && GET_CODE (operands[1]) == REG\n+   && GET_CODE (operands[2]) == REG\n    && REGNO_REG_CLASS (REGNO (operands[1]))\n       == REGNO_REG_CLASS (REGNO (operands[2]))\"\n   \"*\n@@ -4871,17 +4873,19 @@\n }\")\n \n (define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"f\")\n+  [(set (match_operand 0 \"register_operand\" \"fr\")\n \t(match_operand 1 \"reg_or_nonsymb_mem_operand\" \"\"))\n-   (set (match_operand 2 \"register_operand\" \"f\")\n+   (set (match_operand 2 \"register_operand\" \"fr\")\n \t(match_dup 1))]\n   \"! TARGET_SOFT_FLOAT\n    && GET_CODE (operands[1]) == MEM\n    && ! MEM_VOLATILE_P (operands[1])\n    && GET_MODE (operands[0]) == GET_MODE (operands[1])\n    && GET_MODE (operands[0]) == GET_MODE (operands[2])\n    && GET_MODE (operands[0]) == DFmode\n-   && REGNO_REG_CLASS (REGNO (operands[1]))\n+   && GET_CODE (operands[0]) == REG\n+   && GET_CODE (operands[2]) == REG\n+   && REGNO_REG_CLASS (REGNO (operands[0]))\n       == REGNO_REG_CLASS (REGNO (operands[2]))\"\n   \"*\n {"}, {"sha": "10b13f33f7c76239dc79d7778e30e4869a37e9ca", "filename": "gcc/fold-const.c", "status": "modified", "additions": 155, "deletions": 179, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63e7fe9ba41df48e63a3a837a340f2e872421d4e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=63e7fe9ba41df48e63a3a837a340f2e872421d4e", "patch": "@@ -62,7 +62,6 @@ int div_and_round_double\tPROTO((enum tree_code, int, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT *));\n static int split_tree\t\tPROTO((tree, enum tree_code, tree *,\n \t\t\t\t       tree *, int *));\n-static tree int_const_binop\tPROTO((enum tree_code, tree, tree, int, int));\n static tree const_binop\t\tPROTO((enum tree_code, tree, tree, int));\n static tree fold_convert\tPROTO((tree, tree));\n static enum tree_code invert_tree_comparison PROTO((enum tree_code));\n@@ -1052,215 +1051,192 @@ split_tree (in, code, varp, conp, varsignp)\n   return 0;\n }\n \f\n-/* Combine two integer constants ARG1 and ARG2 under operation CODE\n+/* Combine two constants ARG1 and ARG2 under operation CODE\n    to produce a new constant.\n+   We assume ARG1 and ARG2 have the same data type,\n+   or at least are the same kind of constant and the same machine mode.\n \n-   If NOTRUNC is nonzero, do not truncate the result to fit the data type.\n-   If FORSIZE is nonzero, compute overflow for unsigned types.  */\n+   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n static tree\n-int_const_binop (code, arg1, arg2, notrunc, forsize)\n+const_binop (code, arg1, arg2, notrunc)\n      enum tree_code code;\n      register tree arg1, arg2;\n-     int notrunc, forsize;\n+     int notrunc;\n {\n-  HOST_WIDE_INT int1l, int1h, int2l, int2h;\n-  HOST_WIDE_INT low, hi;\n-  HOST_WIDE_INT garbagel, garbageh;\n-  register tree t;\n-  int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n-  int overflow = 0;\n-  int no_overflow = 0;\n-\n-  int1l = TREE_INT_CST_LOW (arg1);\n-  int1h = TREE_INT_CST_HIGH (arg1);\n-  int2l = TREE_INT_CST_LOW (arg2);\n-  int2h = TREE_INT_CST_HIGH (arg2);\n+  STRIP_NOPS (arg1); STRIP_NOPS (arg2);\n \n-  switch (code)\n+  if (TREE_CODE (arg1) == INTEGER_CST)\n     {\n-    case BIT_IOR_EXPR:\n-      low = int1l | int2l, hi = int1h | int2h;\n-      break;\n+      register HOST_WIDE_INT int1l = TREE_INT_CST_LOW (arg1);\n+      register HOST_WIDE_INT int1h = TREE_INT_CST_HIGH (arg1);\n+      HOST_WIDE_INT int2l = TREE_INT_CST_LOW (arg2);\n+      HOST_WIDE_INT int2h = TREE_INT_CST_HIGH (arg2);\n+      HOST_WIDE_INT low, hi;\n+      HOST_WIDE_INT garbagel, garbageh;\n+      register tree t;\n+      int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n+      int overflow = 0;\n+      int no_overflow = 0;\n \n-    case BIT_XOR_EXPR:\n-      low = int1l ^ int2l, hi = int1h ^ int2h;\n-      break;\n+      switch (code)\n+\t{\n+\tcase BIT_IOR_EXPR:\n+\t  low = int1l | int2l, hi = int1h | int2h;\n+\t  break;\n \n-    case BIT_AND_EXPR:\n-      low = int1l & int2l, hi = int1h & int2h;\n-      break;\n+\tcase BIT_XOR_EXPR:\n+\t  low = int1l ^ int2l, hi = int1h ^ int2h;\n+\t  break;\n \n-    case BIT_ANDTC_EXPR:\n-      low = int1l & ~int2l, hi = int1h & ~int2h;\n-      break;\n+\tcase BIT_AND_EXPR:\n+\t  low = int1l & int2l, hi = int1h & int2h;\n+\t  break;\n \n-    case RSHIFT_EXPR:\n-      int2l = - int2l;\n-    case LSHIFT_EXPR:\n-      /* It's unclear from the C standard whether shifts can overflow.\n-\t The following code ignores overflow; perhaps a C standard\n-\t interpretation ruling is needed.  */\n-      lshift_double (int1l, int1h, int2l,\n-\t\t     TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t     &low, &hi,\n-\t\t     !uns);\n-      no_overflow = 1;\n-      break;\n+\tcase BIT_ANDTC_EXPR:\n+\t  low = int1l & ~int2l, hi = int1h & ~int2h;\n+\t  break;\n \n-    case RROTATE_EXPR:\n-      int2l = - int2l;\n-    case LROTATE_EXPR:\n-      lrotate_double (int1l, int1h, int2l,\n-\t\t      TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t      &low, &hi);\n-      break;\n+\tcase RSHIFT_EXPR:\n+\t  int2l = - int2l;\n+\tcase LSHIFT_EXPR:\n+\t  /* It's unclear from the C standard whether shifts can overflow.\n+\t     The following code ignores overflow; perhaps a C standard\n+\t     interpretation ruling is needed.  */\n+\t  lshift_double (int1l, int1h, int2l,\n+\t\t\t TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t\t &low, &hi,\n+\t\t\t !uns);\n+\t  no_overflow = 1;\n+\t  break;\n \n-    case PLUS_EXPR:\n-      overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n-      break;\n+\tcase RROTATE_EXPR:\n+\t  int2l = - int2l;\n+\tcase LROTATE_EXPR:\n+\t  lrotate_double (int1l, int1h, int2l,\n+\t\t\t  TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t\t  &low, &hi);\n+\t  break;\n \n-    case MINUS_EXPR:\n-      neg_double (int2l, int2h, &low, &hi);\n-      add_double (int1l, int1h, low, hi, &low, &hi);\n-      overflow = overflow_sum_sign (hi, int2h, int1h);\n-      break;\n+\tcase PLUS_EXPR:\n+\t  overflow = add_double (int1l, int1h, int2l, int2h, &low, &hi);\n+\t  break;\n \n-    case MULT_EXPR:\n-      overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n-      break;\n+\tcase MINUS_EXPR:\n+\t  neg_double (int2l, int2h, &low, &hi);\n+\t  add_double (int1l, int1h, low, hi, &low, &hi);\n+\t  overflow = overflow_sum_sign (hi, int2h, int1h);\n+\t  break;\n \n-    case TRUNC_DIV_EXPR:\n-    case FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-      /* This is a shortcut for a common special case.  */\n-      if (int2h == 0 && int2l > 0\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n-\t  && int1h == 0 && int1l >= 0)\n-\t{\n-\t  if (code == CEIL_DIV_EXPR)\n-\t    int1l += int2l - 1;\n-\t  low = int1l / int2l, hi = 0;\n+\tcase MULT_EXPR:\n+\t  overflow = mul_double (int1l, int1h, int2l, int2h, &low, &hi);\n \t  break;\n-\t}\n \n-      /* ... fall through ... */\n+\tcase TRUNC_DIV_EXPR:\n+\tcase FLOOR_DIV_EXPR: case CEIL_DIV_EXPR:\n+\tcase EXACT_DIV_EXPR:\n+\t  /* This is a shortcut for a common special case.  */\n+\t  if (int2h == 0 && int2l > 0\n+\t      && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t      && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t      && int1h == 0 && int1l >= 0)\n+\t    {\n+\t      if (code == CEIL_DIV_EXPR)\n+\t\tint1l += int2l - 1;\n+\t      low = int1l / int2l, hi = 0;\n+\t      break;\n+\t    }\n \n-    case ROUND_DIV_EXPR: \n-      if (int2h == 0 && int2l == 1)\n-\t{\n-\t  low = int1l, hi = int1h;\n-\t  break;\n-\t}\n-      if (int1l == int2l && int1h == int2h\n-\t  && ! (int1l == 0 && int1h == 0))\n-\t{\n-\t  low = 1, hi = 0;\n-\t  break;\n-\t}\n-      overflow = div_and_round_double (code, uns,\n-\t\t\t\t       int1l, int1h, int2l, int2h,\n-\t\t\t\t       &low, &hi, &garbagel, &garbageh);\n-      break;\n+\t  /* ... fall through ... */\n \n-    case TRUNC_MOD_EXPR:\n-    case FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n-      /* This is a shortcut for a common special case.  */\n-      if (int2h == 0 && int2l > 0\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t  && ! TREE_CONSTANT_OVERFLOW (arg2)\n-\t  && int1h == 0 && int1l >= 0)\n-\t{\n-\t  if (code == CEIL_MOD_EXPR)\n-\t    int1l += int2l - 1;\n-\t  low = int1l % int2l, hi = 0;\n+\tcase ROUND_DIV_EXPR: \n+\t  if (int2h == 0 && int2l == 1)\n+\t    {\n+\t      low = int1l, hi = int1h;\n+\t      break;\n+\t    }\n+\t  if (int1l == int2l && int1h == int2h\n+\t      && ! (int1l == 0 && int1h == 0))\n+\t    {\n+\t      low = 1, hi = 0;\n+\t      break;\n+\t    }\n+\t  overflow = div_and_round_double (code, uns,\n+\t\t\t\t\t   int1l, int1h, int2l, int2h,\n+\t\t\t\t\t   &low, &hi, &garbagel, &garbageh);\n \t  break;\n-\t}\n \n-      /* ... fall through ... */\n+\tcase TRUNC_MOD_EXPR:\n+\tcase FLOOR_MOD_EXPR: case CEIL_MOD_EXPR:\n+\t  /* This is a shortcut for a common special case.  */\n+\t  if (int2h == 0 && int2l > 0\n+\t      && ! TREE_CONSTANT_OVERFLOW (arg1)\n+\t      && ! TREE_CONSTANT_OVERFLOW (arg2)\n+\t      && int1h == 0 && int1l >= 0)\n+\t    {\n+\t      if (code == CEIL_MOD_EXPR)\n+\t\tint1l += int2l - 1;\n+\t      low = int1l % int2l, hi = 0;\n+\t      break;\n+\t    }\n \n-    case ROUND_MOD_EXPR: \n-      overflow = div_and_round_double (code, uns,\n-\t\t\t\t       int1l, int1h, int2l, int2h,\n-\t\t\t\t       &garbagel, &garbageh, &low, &hi);\n-      break;\n+\t  /* ... fall through ... */\n \n-    case MIN_EXPR:\n-    case MAX_EXPR:\n-      if (uns)\n-\t{\n-\t  low = (((unsigned HOST_WIDE_INT) int1h\n-\t\t  < (unsigned HOST_WIDE_INT) int2h)\n-\t\t || (((unsigned HOST_WIDE_INT) int1h\n-\t\t      == (unsigned HOST_WIDE_INT) int2h)\n-\t\t     && ((unsigned HOST_WIDE_INT) int1l\n-\t\t\t < (unsigned HOST_WIDE_INT) int2l)));\n+\tcase ROUND_MOD_EXPR: \n+\t  overflow = div_and_round_double (code, uns,\n+\t\t\t\t\t   int1l, int1h, int2l, int2h,\n+\t\t\t\t\t   &garbagel, &garbageh, &low, &hi);\n+\t  break;\n+\n+\tcase MIN_EXPR:\n+\tcase MAX_EXPR:\n+\t  if (uns)\n+\t    {\n+\t      low = (((unsigned HOST_WIDE_INT) int1h\n+\t\t      < (unsigned HOST_WIDE_INT) int2h)\n+\t\t     || (((unsigned HOST_WIDE_INT) int1h\n+\t\t\t  == (unsigned HOST_WIDE_INT) int2h)\n+\t\t\t && ((unsigned HOST_WIDE_INT) int1l\n+\t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n+\t    }\n+\t  else\n+\t    {\n+\t      low = ((int1h < int2h)\n+\t\t     || ((int1h == int2h)\n+\t\t\t && ((unsigned HOST_WIDE_INT) int1l\n+\t\t\t     < (unsigned HOST_WIDE_INT) int2l)));\n+\t    }\n+\t  if (low == (code == MIN_EXPR))\n+\t    low = int1l, hi = int1h;\n+\t  else\n+\t    low = int2l, hi = int2h;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n+    got_it:\n+      if (TREE_TYPE (arg1) == sizetype && hi == 0\n+\t  && low >= 0 && low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype))\n+\t  && ! overflow\n+\t  && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n+\tt = size_int (low);\n       else\n \t{\n-\t  low = ((int1h < int2h)\n-\t\t || ((int1h == int2h)\n-\t\t     && ((unsigned HOST_WIDE_INT) int1l\n-\t\t\t < (unsigned HOST_WIDE_INT) int2l)));\n+\t  t = build_int_2 (low, hi);\n+\t  TREE_TYPE (t) = TREE_TYPE (arg1);\n \t}\n-      if (low == (code == MIN_EXPR))\n-\tlow = int1l, hi = int1h;\n-      else\n-\tlow = int2l, hi = int2h;\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n \n-  if (TREE_TYPE (arg1) == sizetype && hi == 0\n-      && low >= 0 && low <= TREE_INT_CST_LOW (TYPE_MAX_VALUE (sizetype))\n-      && ! overflow\n-      && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n-    t = size_int (low);\n-  else\n-    {\n-      t = build_int_2 (low, hi);\n-      TREE_TYPE (t) = TREE_TYPE (arg1);\n+      TREE_OVERFLOW (t)\n+\t= ((notrunc ? !uns && overflow\n+\t    : force_fit_type (t, overflow && !uns) && ! no_overflow)\n+\t   | TREE_OVERFLOW (arg1)\n+\t   | TREE_OVERFLOW (arg2));\n+      TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n+\t\t\t\t    | TREE_CONSTANT_OVERFLOW (arg1)\n+\t\t\t\t    | TREE_CONSTANT_OVERFLOW (arg2));\n+      return t;\n     }\n-\n-  TREE_OVERFLOW (t)\n-    = ((notrunc ? (!uns || forsize) && overflow\n-\t: force_fit_type (t, (!uns || forsize) && overflow) && ! no_overflow)\n-       | TREE_OVERFLOW (arg1)\n-       | TREE_OVERFLOW (arg2));\n-  /* If we're doing a size calculation, unsigned arithmetic does overflow.\n-     So check if force_fit_type truncated the value.  */\n-  if (forsize\n-      && ! TREE_OVERFLOW (t)\n-      && (TREE_INT_CST_HIGH (t) != hi\n-\t  || TREE_INT_CST_LOW (t) != low))\n-    TREE_OVERFLOW (t) = 1;\n-  TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n-\t\t\t\t| TREE_CONSTANT_OVERFLOW (arg1)\n-\t\t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n-  return t;\n-}\n-\n-/* Combine two constants ARG1 and ARG2 under operation CODE\n-   to produce a new constant.\n-   We assume ARG1 and ARG2 have the same data type,\n-   or at least are the same kind of constant and the same machine mode.\n-\n-   If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n-\n-static tree\n-const_binop (code, arg1, arg2, notrunc)\n-     enum tree_code code;\n-     register tree arg1, arg2;\n-     int notrunc;\n-{\n-  STRIP_NOPS (arg1); STRIP_NOPS (arg2);\n-\n-  if (TREE_CODE (arg1) == INTEGER_CST)\n-    return int_const_binop (code, arg1, arg2, notrunc, 0);\n-\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (TREE_CODE (arg1) == REAL_CST)\n     {\n@@ -1474,7 +1450,7 @@ size_binop (code, arg0, arg1)\n \treturn arg1;\n \n       /* Handle general case of two integer constants.  */\n-      return int_const_binop (code, arg0, arg1, 0, 1);\n+      return const_binop (code, arg0, arg1, 0);\n     }\n \n   if (arg0 == error_mark_node || arg1 == error_mark_node)"}]}