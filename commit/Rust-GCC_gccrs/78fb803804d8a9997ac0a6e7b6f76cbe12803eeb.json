{"sha": "78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhmYjgwMzgwNGQ4YTk5OTdhYzBhNmU3YjZmNzZjYmUxMjgwM2VlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-04-04T14:22:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-04-04T14:22:02Z"}, "message": "* config/mcore/mcore.h (target_flags, HARDLIT_BIT, ALIGN8_BIT, DIV_BIT)\n\t(RELAX_IMM_BIT, W_FIELD_BIT, OVERALIGN_FUNC_BIT, CGDATA_BIT)\n\t(SLOW_BYTES_BIT, LITTLE_END_BIT, M340_BIT, TARGET_HARDLIT)\n\t(TARGET_DIV, TARGET_RELAX_IMM, TARGET_W_FIELD, TARGET_OVERALIGN_FUNC)\n\t(TARGET_CG_DATA, TARGET_SLOW_BYTES, TARGET_LITTLE_END, TARGET_M340)\n\t(TARGET_SWITCHES, mcore_stack_increment_string)\n\t(TARGET_OPTIONS): Delete.\n\t(TARGET_DEFAULT, OPTIMIZATION_OPTIONS): Use MASK_* constants rather\n\tthan *_BIT constants.\n\t(TARGET_8ALIGN): #undef old definition before redefining to 1.\n\t* config/mcore/mcore.c (mcore_stack_increment_string): Delete.\n\t(TARGET_DEFAULT_TARGET_FLAGS): Override default to TARGET_DEFAULT.\n\t(mcore_override_options): Delete mcore_stack_increment code.\n\tChange use of M340_BIT to MASK_M340.\n\t* config/mcore/mcore.opt: New file.\n\nFrom-SVN: r97544", "tree": {"sha": "7d9d250e8e8fe08014db1b6a8097ffa783a5e041", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d9d250e8e8fe08014db1b6a8097ffa783a5e041"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/comments", "author": null, "committer": null, "parents": [{"sha": "09c3c5dce7e0d10cdec855bc2722234e6ec60d88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09c3c5dce7e0d10cdec855bc2722234e6ec60d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09c3c5dce7e0d10cdec855bc2722234e6ec60d88"}], "stats": {"total": 218, "additions": 113, "deletions": 105}, "files": [{"sha": "7cb33b7464e2a16b354eb15333b0494223e9a213", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "patch": "@@ -1,3 +1,21 @@\n+2005-04-04  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mcore/mcore.h (target_flags, HARDLIT_BIT, ALIGN8_BIT, DIV_BIT)\n+\t(RELAX_IMM_BIT, W_FIELD_BIT, OVERALIGN_FUNC_BIT, CGDATA_BIT)\n+\t(SLOW_BYTES_BIT, LITTLE_END_BIT, M340_BIT, TARGET_HARDLIT)\n+\t(TARGET_DIV, TARGET_RELAX_IMM, TARGET_W_FIELD, TARGET_OVERALIGN_FUNC)\n+\t(TARGET_CG_DATA, TARGET_SLOW_BYTES, TARGET_LITTLE_END, TARGET_M340)\n+\t(TARGET_SWITCHES, mcore_stack_increment_string)\n+\t(TARGET_OPTIONS): Delete.\n+\t(TARGET_DEFAULT, OPTIMIZATION_OPTIONS): Use MASK_* constants rather\n+\tthan *_BIT constants.\n+\t(TARGET_8ALIGN): #undef old definition before redefining to 1.\n+\t* config/mcore/mcore.c (mcore_stack_increment_string): Delete.\n+\t(TARGET_DEFAULT_TARGET_FLAGS): Override default to TARGET_DEFAULT.\n+\t(mcore_override_options): Delete mcore_stack_increment code.\n+\tChange use of M340_BIT to MASK_M340.\n+\t* config/mcore/mcore.opt: New file.\n+\n 2005-04-04  Ian Lance Taylor  <ian@airs.com>\n \n \t* config/arm/arm.c (replace_symbols_in_block): Remove static"}, {"sha": "65ed1ad4fb9625f4493261c2a1851eb593ffc1a3", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "patch": "@@ -49,8 +49,7 @@\n /* Maximum size we are allowed to grow the stack in a single operation.\n    If we want more, we must do it in increments of at most this size.\n    If this value is 0, we don't check at all.  */\n-const char * mcore_stack_increment_string = 0;\n-int          mcore_stack_increment = STACK_UNITS_MAXSTEP;\n+int mcore_stack_increment = STACK_UNITS_MAXSTEP;\n \n /* For dumping information about frame sizes.  */\n char * mcore_current_function_name = 0;\n@@ -176,6 +175,8 @@ static int        mcore_arg_partial_bytes       (CUMULATIVE_ARGS *,\n #define TARGET_ASM_UNIQUE_SECTION \tmcore_unique_section\n #undef  TARGET_ASM_FUNCTION_RODATA_SECTION\n #define TARGET_ASM_FUNCTION_RODATA_SECTION default_no_function_rodata_section\n+#undef  TARGET_DEFAULT_TARGET_FLAGS\n+#define TARGET_DEFAULT_TARGET_FLAGS\tTARGET_DEFAULT\n #undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO \tmcore_encode_section_info\n #undef  TARGET_STRIP_NAME_ENCODING\n@@ -2981,21 +2982,9 @@ mcore_is_same_reg (rtx x, rtx y)\n void\n mcore_override_options (void)\n {\n-  if (mcore_stack_increment_string)\n-    {\n-      mcore_stack_increment = atoi (mcore_stack_increment_string);\n-      \n-      if (mcore_stack_increment < 0\n-\t  || (mcore_stack_increment == 0\n-\t      && (mcore_stack_increment_string[0] != '0'\n-\t\t  || mcore_stack_increment_string[1] != 0)))\n-\terror (\"invalid option %<-mstack-increment=%s%>\",\n-\t       mcore_stack_increment_string);\t\n-    }\n-  \n   /* Only the m340 supports little endian code.  */\n   if (TARGET_LITTLE_END && ! TARGET_M340)\n-    target_flags |= M340_BIT;\n+    target_flags |= MASK_M340;\n }\n \f\n /* Compute the number of word sized registers needed to "}, {"sha": "9ab7d1348cc19e40a622751cfbad4bb1fff66937", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 11, "deletions": 90, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "patch": "@@ -66,105 +66,26 @@\n #undef  LINK_SPEC\n #define LINK_SPEC \"%{mbig-endian:-EB} %{m210:-EB} -X\"\n \n-/* Can only count on 16 bits of availability; change to long would affect\n-   many architecture specific files (other architectures...).  */\n-extern int target_flags;\n-\n-#define HARDLIT_BIT\t   (1 << 0) /* Build in-line literals using 2 insns.  */\n-#define ALIGN8_BIT\t   (1 << 1) /* Max alignment goes to 8 instead of 4.  */\n-#define DIV_BIT\t\t   (1 << 2) /* Generate divide instructions.  */\n-#define RELAX_IMM_BIT\t   (1 << 3) /* Arbitrary immediates in and, or, tst.  */\n-#define W_FIELD_BIT\t   (1 << 4) /* Generate bit insv/extv using SImode.  */\n-#define\tOVERALIGN_FUNC_BIT (1 << 5) /* Align functions to 4 byte boundary.  */\n-#define CGDATA_BIT\t   (1 << 6) /* Generate callgraph data.  */\n-#define SLOW_BYTES_BIT     (1 << 7) /* Slow byte access.  */\n-#define LITTLE_END_BIT     (1 << 8) /* Generate little endian code.  */\n-#define M340_BIT           (1 << 9) /* Generate code for the m340.  */\n-\n-#define TARGET_DEFAULT     \\\n- (HARDLIT_BIT | ALIGN8_BIT | DIV_BIT | RELAX_IMM_BIT | M340_BIT | LITTLE_END_BIT)\n+#define TARGET_DEFAULT\t\\\n+  (MASK_HARDLIT\t\t\\\n+   | MASK_8ALIGN\t\\\n+   | MASK_DIV\t\t\\\n+   | MASK_RELAX_IMM\t\\\n+   | MASK_M340\t\t\\\n+   | MASK_LITTLE_END)\n \n #ifndef MULTILIB_DEFAULTS\n #define MULTILIB_DEFAULTS { \"mlittle-endian\", \"m340\" }\n #endif\n \n-#define TARGET_HARDLIT\t\t(target_flags & HARDLIT_BIT)\n /* The ability to have 4 byte alignment is being suppressed for now.\n-   If this ability is reenabled, you must enable the definition below\n+   If this ability is reenabled, you must disable the definition below\n    *and* edit t-mcore to enable multilibs for 4 byte alignment code.  */\n-#if 0 \n-#define TARGET_8ALIGN\t\t(target_flags & ALIGN8_BIT)\n-#else\n-#define TARGET_8ALIGN\t\t1\n-#endif\n-#define TARGET_DIV\t\t(target_flags & DIV_BIT)\n-#define TARGET_RELAX_IMM        (target_flags & RELAX_IMM_BIT)\n-#define TARGET_W_FIELD          (target_flags & W_FIELD_BIT)\n-#define TARGET_OVERALIGN_FUNC   (target_flags & OVERALIGN_FUNC_BIT)\n-#define TARGET_CG_DATA \t\t(target_flags & CGDATA_BIT)\n-#define TARGET_CG_DATA \t\t(target_flags & CGDATA_BIT)\n-#define TARGET_SLOW_BYTES \t(target_flags & SLOW_BYTES_BIT)\n-#define TARGET_LITTLE_END\t(target_flags & LITTLE_END_BIT)\n-#define TARGET_M340 \t\t(target_flags & M340_BIT)\n-\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-{ {\"hardlit\", \t            HARDLIT_BIT,\t\t\t\t\\\n-     N_(\"Inline constants if it can be done in 2 insns or less\") },\t\\\n-  {\"no-hardlit\",          - HARDLIT_BIT,\t\t\t\t\\\n-     N_(\"Inline constants if it only takes 1 instruction\") },\t\t\\\n-  {\"4align\",              - ALIGN8_BIT,\t\t\t\t\t\\\n-     N_(\"Set maximum alignment to 4\") },\t\t\t\t\\\n-  {\"8align\",\t            ALIGN8_BIT,\t\t\t\t\t\\\n-     N_(\"Set maximum alignment to 8\") },\t\t\t\t\\\n-  {\"div\",                   DIV_BIT,\t\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  {\"no-div\",\t          - DIV_BIT,\t\t\t\t\t\\\n-     N_(\"Do not use the divide instruction\") },\t\t\t\t\\\n-  {\"relax-immediates\",      RELAX_IMM_BIT,\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  {\"no-relax-immediates\", - RELAX_IMM_BIT,\t\t\t\t\\\n-     N_(\"Do not arbitrary sized immediates in bit operations\") },\t\\\n-  {\"wide-bitfields\",        W_FIELD_BIT,\t\t\t\t\\\n-     N_(\"Always treat bit-field as int-sized\") },\t\t\t\\\n-  {\"no-wide-bitfields\",   - W_FIELD_BIT,\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  {\"4byte-functions\",       OVERALIGN_FUNC_BIT,\t\t\t\t\\\n-     N_(\"Force functions to be aligned to a 4 byte boundary\") },\t\\\n-  {\"no-4byte-functions\",  - OVERALIGN_FUNC_BIT,\t\t\t\t\\\n-     N_(\"Force functions to be aligned to a 2 byte boundary\") },\t\\\n-  {\"callgraph-data\",        CGDATA_BIT,\t\t\t\t\t\\\n-     N_(\"Emit call graph information\") },\t\t\t\t\\\n-  {\"no-callgraph-data\",   - CGDATA_BIT,\t\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  {\"slow-bytes\",            SLOW_BYTES_BIT,\t\t\t\t\\\n-     N_(\"Prefer word accesses over byte accesses\") },\t\t\t\\\n-  {\"no-slow-bytes\",       - SLOW_BYTES_BIT,\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  { \"no-lsim\",              0, \"\" },\t\t\t \t\t\\\n-  {\"little-endian\",         LITTLE_END_BIT,\t\t\t\t\\\n-     N_(\"Generate little endian code\") },\t\t\t\t\\\n-  {\"big-endian\",          - LITTLE_END_BIT,\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  {\"210\",                 - M340_BIT,\t\t\t\t\t\\\n-     \"\" },\t\t\t\t\t\t\t\t\\\n-  {\"340\",                   M340_BIT,\t\t\t\t\t\\\n-     N_(\"Generate code for the M*Core M340\") },\t\t\t\t\\\n-  {\"\",   \t            TARGET_DEFAULT,\t\t\t\t\\\n-     \"\" }\t\t\t\t\t\t\t\t\\\n-}\n+#undef TARGET_8ALIGN\n+#define TARGET_8ALIGN 1\n \n extern char * mcore_current_function_name;\n  \n-/* Target specific options (as opposed to the switches above).  */\n-extern const char * mcore_stack_increment_string;\n-\n-#define\tTARGET_OPTIONS\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  {\"stack-increment=\", & mcore_stack_increment_string,\t\t\t\\\n-     N_(\"Maximum amount for a single stack increment operation\"), 0}\t\\\n-}\n-\n /* The MCore ABI says that bitfields are unsigned by default.  */\n #define CC1_SPEC \"-funsigned-bitfields\"\n \n@@ -189,7 +110,7 @@ extern const char * mcore_stack_increment_string;\n     }\t\t\t\t\t\t\\\n   if (SIZE)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-      target_flags &= ~ HARDLIT_BIT;\t\t\\\n+      target_flags &= ~MASK_HARDLIT;\t\t\\\n     }\t\t\t\t\t\t\\\n }\n "}, {"sha": "75538796e241bb7d8dfcc5cec641e4d3b71af355", "filename": "gcc/config/mcore/mcore.opt", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2Fconfig%2Fmcore%2Fmcore.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78fb803804d8a9997ac0a6e7b6f76cbe12803eeb/gcc%2Fconfig%2Fmcore%2Fmcore.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.opt?ref=78fb803804d8a9997ac0a6e7b6f76cbe12803eeb", "patch": "@@ -0,0 +1,80 @@\n+; Options for the Motorola MCore port of the compiler.\n+\n+; Copyright (C) 2005 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 2, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING.  If not, write to the Free\n+; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+; 02111-1307, USA.\n+\n+m210\n+Target RejectNegative Report InverseMask(M340)\n+Generate code for the M*Core M210\n+\n+m340\n+Target RejectNegative Report Mask(M340)\n+Generate code for the M*Core M340\n+\n+m4align\n+Target RejectNegative Report InverseMask(8ALIGN)\n+Set maximum alignment to 4\n+\n+m4byte-functions\n+Target Report Mask(OVERALIGN_FUNC)\n+Force functions to be aligned to a 4 byte boundary\n+\n+m8align\n+Target RejectNegative Report Mask(8ALIGN)\n+Set maximum alignment to 8\n+\n+mbig-endian\n+Target RejectNegative Report InverseMask(LITTLE_END)\n+Generate big-endian code\n+\n+mcallgraph-data\n+Target Report Mask(CG_DATA)\n+Emit call graph information\n+\n+mdiv\n+Target Report Mask(DIV)\n+Use the divide instruction\n+\n+mhardlit\n+Target Report Mask(HARDLIT)\n+Inline constants if it can be done in 2 insns or less\n+\n+mlittle-endian\n+Target RejectNegative Report Mask(LITTLE_END)\n+Generate little-endian code\n+\n+; Not used by the compiler proper.\n+mno-lsim\n+Target RejectNegative Undocumented\n+\n+mrelax-immediates\n+Target Report Mask(RELAX_IMM)\n+Use arbitrary sized immediates in bit operations\n+\n+mslow-bytes\n+Target Report Mask(SLOW_BYTES)\n+Prefer word accesses over byte accesses\n+\n+mstack-increment=\n+Target RejectNegative Joined UInteger Var(mcore_stack_increment) VarExists\n+Set the maximum amount for a single stack increment operation\n+\n+mwide-bitfields\n+Target Report Mask(W_FIELD)\n+Always treat bitfields as int-sized"}]}