{"sha": "305708cedd962831b648783936cb6991dfdeb87d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA1NzA4Y2VkZDk2MjgzMWI2NDg3ODM5MzZjYjY5OTFkZmRlYjg3ZA==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2016-01-18T14:14:35Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2016-01-18T14:14:35Z"}, "message": "re PR middle-end/68542 (10% 481.wrf performance regression)\n\ngcc/\n\n2016-01-18  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\tPR middle-end/68542\n\t* fold-const.c (fold_binary_op_with_conditional_arg): Bail out for case\n\tof mixind vector and scalar types.\n\t(fold_relational_const): Add handling of vector\n\tcomparison with boolean result.\n\t* tree-cfg.c (verify_gimple_comparison): Add argument CODE, allow\n\tcomparison of vector operands with boolean result for EQ/NE only.\n\t(verify_gimple_assign_binary): Adjust call for verify_gimple_comparison.\n\t(verify_gimple_cond): Likewise.\n\t* tree-vrp.c (extract_code_and_val_from_cond_with_ops): Modify check on\n\tvalid type of VAL.\n\nFrom-SVN: r232518", "tree": {"sha": "fd70591afccdc84c6a6d41f54a41b785c0f898b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd70591afccdc84c6a6d41f54a41b785c0f898b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/305708cedd962831b648783936cb6991dfdeb87d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305708cedd962831b648783936cb6991dfdeb87d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/305708cedd962831b648783936cb6991dfdeb87d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/305708cedd962831b648783936cb6991dfdeb87d/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "969028053faeba62b856707b0ab5d49a15edc688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969028053faeba62b856707b0ab5d49a15edc688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969028053faeba62b856707b0ab5d49a15edc688"}], "stats": {"total": 69, "additions": 55, "deletions": 14}, "files": [{"sha": "f5bd86f066deaf3795eb68a95ade971792690917", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305708cedd962831b648783936cb6991dfdeb87d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305708cedd962831b648783936cb6991dfdeb87d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=305708cedd962831b648783936cb6991dfdeb87d", "patch": "@@ -1,3 +1,17 @@\n+2016-01-18  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR middle-end/68542\n+\t* fold-const.c (fold_binary_op_with_conditional_arg): Bail out for case\n+\tof mixind vector and scalar types.\n+\t(fold_relational_const): Add handling of vector\n+\tcomparison with boolean result.\n+\t* tree-cfg.c (verify_gimple_comparison): Add argument CODE, allow\n+\tcomparison of vector operands with boolean result for EQ/NE only.\n+\t(verify_gimple_assign_binary): Adjust call for verify_gimple_comparison.\n+\t(verify_gimple_cond): Likewise.\n+\t* tree-vrp.c (extract_code_and_val_from_cond_with_ops): Modify check on\n+\tvalid type of VAL.\n+\n 2016-01-18  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/mips/mips.h (ISA_HAS_PAIRED_SINGLE): Require"}, {"sha": "bece8d74b46b64afad8ee9465b4b50f80a87ccad", "filename": "gcc/fold-const.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305708cedd962831b648783936cb6991dfdeb87d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305708cedd962831b648783936cb6991dfdeb87d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=305708cedd962831b648783936cb6991dfdeb87d", "patch": "@@ -6446,13 +6446,17 @@ fold_binary_op_with_conditional_arg (location_t loc,\n       if (VOID_TYPE_P (TREE_TYPE (false_value)))\n \trhs = false_value;\n     }\n-  else\n+  else if (!(TREE_CODE (type) != VECTOR_TYPE\n+\t     && TREE_CODE (TREE_TYPE (cond)) == VECTOR_TYPE))\n     {\n       tree testtype = TREE_TYPE (cond);\n       test = cond;\n       true_value = constant_boolean_node (true, testtype);\n       false_value = constant_boolean_node (false, testtype);\n     }\n+  else\n+    /* Detect the case of mixing vector and scalar types - bail out.  */\n+    return NULL_TREE;\n \n   if (TREE_CODE (TREE_TYPE (test)) == VECTOR_TYPE)\n     cond_code = VEC_COND_EXPR;\n@@ -13984,6 +13988,23 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \n   if (TREE_CODE (op0) == VECTOR_CST && TREE_CODE (op1) == VECTOR_CST)\n     {\n+      if (!VECTOR_TYPE_P (type))\n+\t{\n+\t  /* Have vector comparison with scalar boolean result.  */\n+\t  bool result = true;\n+\t  gcc_assert ((code == EQ_EXPR || code == NE_EXPR)\n+\t\t      && VECTOR_CST_NELTS (op0) == VECTOR_CST_NELTS (op1));\n+\t  for (unsigned i = 0; i < VECTOR_CST_NELTS (op0); i++)\n+\t    {\n+\t      tree elem0 = VECTOR_CST_ELT (op0, i);\n+\t      tree elem1 = VECTOR_CST_ELT (op1, i);\n+\t      tree tmp = fold_relational_const (code, type, elem0, elem1);\n+\t      result &= integer_onep (tmp);\n+\t    }\n+\t  if (code == NE_EXPR)\n+\t    result = !result;\n+\t  return constant_boolean_node (result, type);\n+\t}\n       unsigned count = VECTOR_CST_NELTS (op0);\n       tree *elts =  XALLOCAVEC (tree, count);\n       gcc_assert (VECTOR_CST_NELTS (op1) == count"}, {"sha": "b54545d1bba907ff4a91a3aebf0e804a3497c384", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305708cedd962831b648783936cb6991dfdeb87d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305708cedd962831b648783936cb6991dfdeb87d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=305708cedd962831b648783936cb6991dfdeb87d", "patch": "@@ -3437,10 +3437,10 @@ verify_gimple_call (gcall *stmt)\n }\n \n /* Verifies the gimple comparison with the result type TYPE and\n-   the operands OP0 and OP1.  */\n+   the operands OP0 and OP1, comparison code is CODE.  */\n \n static bool\n-verify_gimple_comparison (tree type, tree op0, tree op1)\n+verify_gimple_comparison (tree type, tree op0, tree op1, enum tree_code code)\n {\n   tree op0_type = TREE_TYPE (op0);\n   tree op1_type = TREE_TYPE (op1);\n@@ -3474,13 +3474,17 @@ verify_gimple_comparison (tree type, tree op0, tree op1)\n       && (TREE_CODE (type) == BOOLEAN_TYPE\n \t  || TYPE_PRECISION (type) == 1))\n     {\n-      if (TREE_CODE (op0_type) == VECTOR_TYPE\n-\t  || TREE_CODE (op1_type) == VECTOR_TYPE)\n-        {\n-          error (\"vector comparison returning a boolean\");\n-          debug_generic_expr (op0_type);\n-          debug_generic_expr (op1_type);\n-          return true;\n+      if ((TREE_CODE (op0_type) == VECTOR_TYPE\n+\t   || TREE_CODE (op1_type) == VECTOR_TYPE)\n+\t  && code != EQ_EXPR && code != NE_EXPR\n+\t  && !VECTOR_BOOLEAN_TYPE_P (op0_type)\n+\t  && !VECTOR_INTEGER_TYPE_P (op0_type))\n+\t{\n+\t  error (\"unsupported operation or type for vector comparison\"\n+\t\t \" returning a boolean\");\n+\t  debug_generic_expr (op0_type);\n+\t  debug_generic_expr (op1_type);\n+\t  return true;\n         }\n     }\n   /* Or a boolean vector type with the same element count\n@@ -3861,7 +3865,7 @@ verify_gimple_assign_binary (gassign *stmt)\n     case LTGT_EXPR:\n       /* Comparisons are also binary, but the result type is not\n \t connected to the operand types.  */\n-      return verify_gimple_comparison (lhs_type, rhs1, rhs2);\n+      return verify_gimple_comparison (lhs_type, rhs1, rhs2, rhs_code);\n \n     case WIDEN_MULT_EXPR:\n       if (TREE_CODE (lhs_type) != INTEGER_TYPE)\n@@ -4570,7 +4574,8 @@ verify_gimple_cond (gcond *stmt)\n \n   return verify_gimple_comparison (boolean_type_node,\n \t\t\t\t   gimple_cond_lhs (stmt),\n-\t\t\t\t   gimple_cond_rhs (stmt));\n+\t\t\t\t   gimple_cond_rhs (stmt),\n+\t\t\t\t   gimple_cond_code (stmt));\n }\n \n /* Verify the GIMPLE statement STMT.  Returns true if there is an"}, {"sha": "159d4870ee8751519ff84de3b17bc27781c08589", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/305708cedd962831b648783936cb6991dfdeb87d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/305708cedd962831b648783936cb6991dfdeb87d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=305708cedd962831b648783936cb6991dfdeb87d", "patch": "@@ -5067,8 +5067,9 @@ extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n   if (invert)\n     comp_code = invert_tree_comparison (comp_code, 0);\n \n-  /* VRP does not handle float types.  */\n-  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)))\n+  /* VRP only handles integral and pointer types.  */\n+  if (! INTEGRAL_TYPE_P (TREE_TYPE (val))\n+      && ! POINTER_TYPE_P (TREE_TYPE (val)))\n     return false;\n \n   /* Do not register always-false predicates."}]}