{"sha": "c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlkY2UzYjE1ZTg5ZTg1MWY1OWViZTllODg3OWM4ZjNhNjIwMzExYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-17T19:53:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-17T19:55:06Z"}, "message": "libstdc++: Handle non-integral sizes in std::uninitialized_fill_n\n\nThe std::uninitialized_fill_n algorithm uses sd::fill_n for trivial\ntypes, but that algorithm has a stronger requirement that the Size\nparameter is convertible to an integral type. As the new test shows,\nthere are types which are valid for std::uninitialized_fill_n but which\nproduce a different result when converted to an integral type, or cannot\nbe converted at all. Only use the std::fill_n optimization when the Size\ntype is already an integral type.\n\nThe std::__uninitialized_default_n extension has the same problem, and\nso does C++17's std::uninitialized_value_construct_n which uses it.\n\n\t* include/bits/stl_uninitialized.h (uninitialized_fill_n): Only\n\tuse std::fill_n when the size is an integral type.\n\t(__uninitialized_default_n): Likewise.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_default_n/sizes.cc:\n\tNew test.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_fill_n/sizes.cc:\n\tNew test.\n\t* testsuite/20_util/specialized_algorithms/uninitialized_value_construct_n/sizes.cc:\n\tNew test.", "tree": {"sha": "38e621db673a7f18290550caec087ca04ba20052", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38e621db673a7f18290550caec087ca04ba20052"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d392babbeb6cb531ab8b1ec68fde9ffd36373a6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d392babbeb6cb531ab8b1ec68fde9ffd36373a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d392babbeb6cb531ab8b1ec68fde9ffd36373a6e"}], "stats": {"total": 233, "additions": 224, "deletions": 9}, "files": [{"sha": "3771ddfd973dd765aad43abf66d181252fc2d538", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "patch": "@@ -273,19 +273,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type\n \t_ValueType;\n+\n+      // Trivial types do not need a constructor to begin their lifetime,\n+      // so try to use std::fill_n to benefit from its memmove optimization.\n+      // For arbitrary class types and floating point types we can't assume\n+      // that __n > 0 and std::__size_to_integer(__n) > 0 are equivalent,\n+      // so only use std::fill_n when _Size is already an integral type.\n #if __cplusplus < 201103L\n-      const bool __assignable = true;\n+      const bool __can_fill = __is_integer<_Size>::__value;\n #else\n-      // Trivial types can have deleted copy constructor, but the std::fill\n+      // Trivial types can have deleted copy constructor, but the std::fill_n\n       // optimization that uses memmove would happily \"copy\" them anyway.\n       static_assert(is_constructible<_ValueType, const _Tp&>::value,\n \t  \"result type must be constructible from input type\");\n \n-      // Trivial types can have deleted assignment, so using std::fill\n-      // would be ill-formed. Require assignability before using std::fill:\n-      const bool __assignable = is_copy_assignable<_ValueType>::value;\n+      // Trivial types can have deleted assignment, so using std::fill_n\n+      // would be ill-formed. Require assignability before using std::fill_n:\n+      constexpr bool __can_fill\n+\t= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;\n #endif\n-      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::\n+      return __uninitialized_fill_n<__is_trivial(_ValueType) && __can_fill>::\n \t__uninit_fill_n(__first, __n, __x);\n     }\n \n@@ -615,11 +622,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       typedef typename iterator_traits<_ForwardIterator>::value_type\n \t_ValueType;\n-      // trivial types can have deleted assignment\n-      const bool __assignable = is_copy_assignable<_ValueType>::value;\n+      // See uninitialized_fill_n for the conditions for using std::fill_n.\n+      constexpr bool __can_fill\n+\t= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;\n \n       return __uninitialized_default_n_1<__is_trivial(_ValueType)\n-\t\t\t\t       && __assignable>::\n+\t\t\t\t\t && __can_fill>::\n \t__uninit_default_n(__first, __n);\n     }\n "}, {"sha": "1bb4c6a9fb16bd5883ffbf86141b4b60f2b53639", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_n/sizes.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_default_n%2Fsizes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_default_n%2Fsizes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_default_n%2Fsizes.cc?ref=c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <memory>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+struct Value\n+{\n+  int value = 0x1234;\n+};\n+\n+void\n+test01()\n+{\n+  alignas(Value) unsigned char buf[3 * sizeof(Value) + 1];\n+  std::fill(std::begin(buf), std::end(buf), 0xff);\n+  const auto p = reinterpret_cast<Value*>(buf);\n+  std::__uninitialized_default_n(p, 2.0001);\n+  VERIFY( p[0].value == 0x1234 );\n+  VERIFY( p[1].value == 0x1234 );\n+  VERIFY( p[2].value == 0x1234 );\n+  VERIFY( *std::prev(std::end(buf)) == 0xff );\n+}\n+\n+void\n+test02()\n+{\n+  // The standard only requires that n>0 and --n are valid expressions.\n+  struct Size\n+  {\n+    int value;\n+\n+    void operator--() { --value; }\n+\n+    int operator>(void*) { return value != 0; }\n+  };\n+\n+  alignas(Value) unsigned char buf[4 * sizeof(Value) + 1];\n+  std::fill(std::begin(buf), std::end(buf), 0xff);\n+  const auto p = reinterpret_cast<Value*>(buf);\n+  Size n = {4};\n+  std::__uninitialized_default_n(p, n);\n+  VERIFY( p[0].value == 0x1234 );\n+  VERIFY( p[1].value == 0x1234 );\n+  VERIFY( p[2].value == 0x1234 );\n+  VERIFY( p[3].value == 0x1234 );\n+  VERIFY( *std::prev(std::end(buf)) == 0xff );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "eb957e148da41040f50e9e0549fdd247052ab3fe", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill_n/sizes.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill_n%2Fsizes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill_n%2Fsizes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill_n%2Fsizes.cc?ref=c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run }\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  int i[4] = { };\n+  std::uninitialized_fill_n(i, 2.0001, 0xabcd);\n+  VERIFY( i[0] == 0xabcd );\n+  VERIFY( i[1] == 0xabcd );\n+  VERIFY( i[2] == 0xabcd );\n+  VERIFY( i[3] == 0 );\n+}\n+\n+void\n+test02()\n+{\n+  // The standard only requires that n>0 and --n are valid expressions.\n+  struct Size\n+  {\n+    int value;\n+\n+    void operator--() { --value; }\n+\n+    int operator>(void*) { return value != 0; }\n+  };\n+\n+  int i[5] = { };\n+  Size n = {4};\n+  std::uninitialized_fill_n(i, n, 0xdcba);\n+  VERIFY( i[0] == 0xdcba );\n+  VERIFY( i[1] == 0xdcba );\n+  VERIFY( i[2] == 0xdcba );\n+  VERIFY( i[3] == 0xdcba );\n+  VERIFY( i[4] == 0 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e822b1989285093452c3509b4f1ca8e4c538a602", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct_n/sizes.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_value_construct_n%2Fsizes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9dce3b15e89e851f59ebe9e8879c8f3a620311a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_value_construct_n%2Fsizes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_value_construct_n%2Fsizes.cc?ref=c9dce3b15e89e851f59ebe9e8879c8f3a620311a", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run { target c++17 } }\n+\n+#include <memory>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+struct Value\n+{\n+  int value = 0x1234;\n+};\n+\n+void\n+test01()\n+{\n+  alignas(Value) unsigned char buf[3 * sizeof(Value) + 1];\n+  std::fill(std::begin(buf), std::end(buf), 0xff);\n+  const auto p = reinterpret_cast<Value*>(buf);\n+  std::uninitialized_value_construct_n(p, 2.0001);\n+  VERIFY( p[0].value == 0x1234 );\n+  VERIFY( p[1].value == 0x1234 );\n+  VERIFY( p[2].value == 0x1234 );\n+  VERIFY( *std::prev(std::end(buf)) == 0xff );\n+}\n+\n+void\n+test02()\n+{\n+  // The standard only requires that n>0 and --n are valid expressions.\n+  struct Size\n+  {\n+    int value;\n+\n+    void operator--() { --value; }\n+\n+    int operator>(void*) { return value != 0; }\n+  };\n+\n+  alignas(Value) unsigned char buf[4 * sizeof(Value) + 1];\n+  std::fill(std::begin(buf), std::end(buf), 0xff);\n+  const auto p = reinterpret_cast<Value*>(buf);\n+  Size n = {4};\n+  std::uninitialized_value_construct_n(p, n);\n+  VERIFY( p[0].value == 0x1234 );\n+  VERIFY( p[1].value == 0x1234 );\n+  VERIFY( p[2].value == 0x1234 );\n+  VERIFY( p[3].value == 0x1234 );\n+  VERIFY( *std::prev(std::end(buf)) == 0xff );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}