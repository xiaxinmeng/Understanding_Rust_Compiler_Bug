{"sha": "fa27426eb1377c2a9e23f58424b4da5497e78c8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmEyNzQyNmViMTM3N2MyYTllMjNmNTg0MjRiNGRhNTQ5N2U3OGM4ZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-11T17:41:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-11T17:41:52Z"}, "message": "re PR tree-optimization/16383 (internal compiler error: in generate_element_copy, at tree-sra.c:1466)\n\n        PR tree-opt/16383\n        * tree-ssa-ccp.c (fold_stmt_r): Split out...\n        * tree.c (fields_compatible_p, find_compatible_field): ... new.\n        * tree.h (fields_compatible_p, find_compatible_field): Declare.\n        * tree-sra.c (sra_hash_tree): Hash fields by offset.\n        (sra_elt_eq): Use fields_compatible_p.\n        (generate_one_element_ref): Use find_compatible_field.\n\nFrom-SVN: r84524", "tree": {"sha": "2934106e3d3e6eaac5aa3e9c20bb96aa1aaada5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2934106e3d3e6eaac5aa3e9c20bb96aa1aaada5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa27426eb1377c2a9e23f58424b4da5497e78c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa27426eb1377c2a9e23f58424b4da5497e78c8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa27426eb1377c2a9e23f58424b4da5497e78c8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa27426eb1377c2a9e23f58424b4da5497e78c8d/comments", "author": null, "committer": null, "parents": [{"sha": "71956db351f1941cf9ebaf35130163832a93478e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71956db351f1941cf9ebaf35130163832a93478e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71956db351f1941cf9ebaf35130163832a93478e"}], "stats": {"total": 170, "additions": 126, "deletions": 44}, "files": [{"sha": "155e3436738674eb770b37a2bc185f8a15863485", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fa27426eb1377c2a9e23f58424b4da5497e78c8d", "patch": "@@ -1,3 +1,13 @@\n+2004-07-11  Richard Henderson  <rth@redhat.com>\n+\n+\tPR tree-opt/16383\n+\t* tree-ssa-ccp.c (fold_stmt_r): Split out...\n+\t* tree.c (fields_compatible_p, find_compatible_field): ... new.\n+\t* tree.h (fields_compatible_p, find_compatible_field): Declare.\n+\t* tree-sra.c (sra_hash_tree): Hash fields by offset.\n+\t(sra_elt_eq): Use fields_compatible_p.\n+\t(generate_one_element_ref): Use find_compatible_field.\n+\n 2004-07-11  Richard Henderson  <rth@redhat.com>\n \n \tPR tree-opt/16422"}, {"sha": "423ee3ca498f5c282bb21ade93def3a215d96cf9", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fa27426eb1377c2a9e23f58424b4da5497e78c8d", "patch": "@@ -357,18 +357,32 @@ can_completely_scalarize_p (struct sra_elt *elt)\n static hashval_t\n sra_hash_tree (tree t)\n {\n+  hashval_t h;\n+\n   switch (TREE_CODE (t))\n     {\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n-    case FIELD_DECL:\n-      return DECL_UID (t);\n+      h = DECL_UID (t);\n+      break;\n+\n     case INTEGER_CST:\n-      return TREE_INT_CST_LOW (t) ^ TREE_INT_CST_HIGH (t);\n+      h = TREE_INT_CST_LOW (t) ^ TREE_INT_CST_HIGH (t);\n+      break;\n+\n+    case FIELD_DECL:\n+      /* We can have types that are compatible, but have different member\n+\t lists, so we can't hash fields by ID.  Use offsets instead.  */\n+      h = iterative_hash_expr (DECL_FIELD_OFFSET (t), 0);\n+      h = iterative_hash_expr (DECL_FIELD_BIT_OFFSET (t), h);\n+      break;\n+\n     default:\n       abort ();\n     }\n+\n+  return h;\n }\n \n /* Hash function for type SRA_PAIR.  */\n@@ -399,20 +413,41 @@ sra_elt_eq (const void *x, const void *y)\n {\n   const struct sra_elt *a = x;\n   const struct sra_elt *b = y;\n+  tree ae, be;\n \n   if (a->parent != b->parent)\n     return false;\n \n-  /* All the field/decl stuff is unique.  */\n-  if (a->element == b->element)\n-    return true;\n+  ae = a->element;\n+  be = b->element;\n \n-  /* The only thing left is integer equality.  */\n-  if (TREE_CODE (a->element) == INTEGER_CST\n-      && TREE_CODE (b->element) == INTEGER_CST)\n-    return tree_int_cst_equal (a->element, b->element);\n-  else\n+  if (ae == be)\n+    return true;\n+  if (TREE_CODE (ae) != TREE_CODE (be))\n     return false;\n+\n+  switch (TREE_CODE (ae))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+      /* These are all pointer unique.  */\n+      return false;\n+\n+    case INTEGER_CST:\n+      /* Integers are not pointer unique, so compare their values.  */\n+      return tree_int_cst_equal (ae, be);\n+\n+    case FIELD_DECL:\n+      /* Fields are unique within a record, but not between\n+\t compatible records.  */\n+      if (DECL_FIELD_CONTEXT (ae) == DECL_FIELD_CONTEXT (be))\n+\treturn false;\n+      return fields_compatible_p (ae, be);\n+\n+    default:\n+      abort ();\n+    }\n }\n \n /* Create or return the SRA_ELT structure for CHILD in PARENT.  PARENT\n@@ -1392,7 +1427,15 @@ generate_one_element_ref (struct sra_elt *elt, tree base)\n   switch (TREE_CODE (TREE_TYPE (base)))\n     {\n     case RECORD_TYPE:\n-      return build (COMPONENT_REF, elt->type, base, elt->element, NULL);\n+      {\n+\ttree field = elt->element;\n+\n+\t/* Watch out for compatible records with differing field lists.  */\n+\tif (DECL_FIELD_CONTEXT (field) != TYPE_MAIN_VARIANT (TREE_TYPE (base)))\n+\t  field = find_compatible_field (TREE_TYPE (base), field);\n+\n+        return build (COMPONENT_REF, elt->type, base, field, NULL);\n+      }\n \n     case ARRAY_TYPE:\n       return build (ARRAY_REF, elt->type, base, elt->element, NULL, NULL);"}, {"sha": "5b6fca62653b523c4016cdfa1680e1016c8e802b", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=fa27426eb1377c2a9e23f58424b4da5497e78c8d", "patch": "@@ -1962,38 +1962,19 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n         return t;\n       *walk_subtrees = 0;\n \n-      /* Make sure the FIELD_DECL is actually a field in the type on\n-         the lhs.  In cases with IMA it is possible that it came\n-         from another, equivalent type at this point.  We have\n-\t already checked the equivalence in this case.\n-\t Match on type plus offset, to allow for unnamed fields.\n-\t We won't necessarily get the corresponding field for\n-\t unions; this is believed to be harmless.  */\n-\n-      if ((current_file_decl && TREE_CHAIN (current_file_decl))\n-        && (DECL_FIELD_CONTEXT (TREE_OPERAND (expr, 1)) !=\n-            TREE_TYPE (TREE_OPERAND (expr, 0))))\n-        {\n-          tree f;\n-          tree orig_field = TREE_OPERAND (expr, 1);\n-          tree orig_type = TREE_TYPE (orig_field);\n-          for (f = TYPE_FIELDS (TREE_TYPE (TREE_OPERAND (expr, 0)));\n-              f; f = TREE_CHAIN (f))\n-            {\n-              if (lang_hooks.types_compatible_p (TREE_TYPE (f), orig_type)\n-                  && tree_int_cst_compare (DECL_FIELD_BIT_OFFSET (f),\n-                                          DECL_FIELD_BIT_OFFSET (orig_field))\n-                      == 0\n-                  && tree_int_cst_compare (DECL_FIELD_OFFSET (f),\n-                                          DECL_FIELD_OFFSET (orig_field))\n-                      == 0)\n-                {\n-                  TREE_OPERAND (expr, 1) = f;\n-                  break;\n-                }\n-            }\n-        /* Fall through is an error; it will be detected in tree-sra.  */\n-        }\n+      /* Make sure the FIELD_DECL is actually a field in the type on the lhs.\n+\t We've already checked that the records are compatible, so we should\n+\t come up with a set of compatible fields.  */\n+      {\n+\ttree expr_record = TREE_TYPE (TREE_OPERAND (expr, 0));\n+\ttree expr_field = TREE_OPERAND (expr, 1);\n+\n+        if (DECL_FIELD_CONTEXT (expr_field) != TYPE_MAIN_VARIANT (expr_record))\n+\t  {\n+\t    expr_field = find_compatible_field (expr_record, expr_field);\n+\t    TREE_OPERAND (expr, 1) = expr_field;\n+\t  }\n+      }\n       break;\n \n     default:"}, {"sha": "30ddcc895a5b5183a589cb02e1d0d0bb5b1ebb79", "filename": "gcc/tree.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=fa27426eb1377c2a9e23f58424b4da5497e78c8d", "patch": "@@ -5693,4 +5693,49 @@ needs_to_live_in_memory (tree t)\n \t  || decl_function_context (t) != current_function_decl);\n }\n \n+/* There are situations in which a language considers record types\n+   compatible which have different field lists.  Decide if two fields\n+   are compatible.  It is assumed that the parent records are compatible.  */\n+\n+bool\n+fields_compatible_p (tree f1, tree f2)\n+{\n+  if (!operand_equal_p (DECL_FIELD_BIT_OFFSET (f1),\n+\t\t\tDECL_FIELD_BIT_OFFSET (f2), OEP_ONLY_CONST))\n+    return false;\n+\n+  if (!operand_equal_p (DECL_FIELD_OFFSET (f1),\n+                        DECL_FIELD_OFFSET (f2), OEP_ONLY_CONST))\n+    return false;\n+\n+  if (!lang_hooks.types_compatible_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n+    return false; \n+\n+  return true;\n+}\n+\n+/* Locate within RECORD a field that is compatible with ORIG_FIELD.  */\n+\n+tree\n+find_compatible_field (tree record, tree orig_field)\n+{\n+  tree f;\n+\n+  for (f = TYPE_FIELDS (record); f ; f = TREE_CHAIN (f))\n+    if (TREE_CODE (f) == FIELD_DECL\n+\t&& fields_compatible_p (f, orig_field))\n+      return f;\n+\n+  /* ??? Why isn't this on the main fields list?  */\n+  f = TYPE_VFIELD (record);\n+  if (f && TREE_CODE (f) == FIELD_DECL\n+      && fields_compatible_p (f, orig_field))\n+    return f;\n+\n+  /* ??? We should abort here, but Java appears to do Bad Things\n+     with inherited fields.  */\n+  return orig_field;\n+}\n+\n+\n #include \"gt-tree.h\""}, {"sha": "baa20781eefc8dbf3fb21e0fdb835e789128825d", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa27426eb1377c2a9e23f58424b4da5497e78c8d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fa27426eb1377c2a9e23f58424b4da5497e78c8d", "patch": "@@ -3481,6 +3481,9 @@ extern void build_common_tree_nodes_2 (int);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n \n+extern bool fields_compatible_p (tree, tree);\n+extern tree find_compatible_field (tree, tree);\n+\n /* In function.c */\n extern void expand_main_function (void);\n extern void init_dummy_function_start (void);"}]}