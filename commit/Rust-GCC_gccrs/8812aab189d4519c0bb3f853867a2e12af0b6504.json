{"sha": "8812aab189d4519c0bb3f853867a2e12af0b6504", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgxMmFhYjE4OWQ0NTE5YzBiYjNmODUzODY3YTJlMTJhZjBiNjUwNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-08-02T14:00:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-08-02T14:00:29Z"}, "message": "tree-into-ssa.c (struct common_info_d): New struct.\n\n2012-08-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-into-ssa.c (struct common_info_d): New struct.\n\t(struct var_info_d, struct ssa_name_info): Use it.\n\t(get_ssa_name_ann): Adjust.\n\t(get_phi_state, set_phi_state): Remove.\n\t(get_common_info): New function.\n\t(get_current_def, set_current_def): Adjust.\n\t(get_def_blocks_for): Take a common info as param.\n\t(set_def_block): Call get_common_info once.\n\t(set_livein_block): Likewise.\n\t(find_def_blocks_for): Adjust.\n\t(insert_phi_nodes): Likewise.\n\t(register_new_def): Call get_common_info once.\n\t(get_reaching_def): Likewise.\n\t(rewrite_debug_stmt_uses): Likewise.\n\t(rewrite_leave_block): Likewise.\n\t(dump_currdefs): Likewise.\n\t(debug_var_infos_r): Adjust.\n\t(register_new_update_single): Call get_common_info once.\n\t(maybe_replace_use_in_debug_stmt): Likewise.\n\t(rewrite_update_leave_block): Likewise.\n\t(mark_use_interesting): Adjust.\n\t(create_new_def_for): Likewise.\n\t(update_ssa): Likewise.\n\nFrom-SVN: r190084", "tree": {"sha": "806bd9b730dcf3c864517658deb1ff3f8e687e51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/806bd9b730dcf3c864517658deb1ff3f8e687e51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8812aab189d4519c0bb3f853867a2e12af0b6504", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8812aab189d4519c0bb3f853867a2e12af0b6504", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8812aab189d4519c0bb3f853867a2e12af0b6504", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8812aab189d4519c0bb3f853867a2e12af0b6504/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "329df070a92bbdea4c20de2cc4e5eecba1684303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329df070a92bbdea4c20de2cc4e5eecba1684303", "html_url": "https://github.com/Rust-GCC/gccrs/commit/329df070a92bbdea4c20de2cc4e5eecba1684303"}], "stats": {"total": 211, "additions": 109, "deletions": 102}, "files": [{"sha": "973ae0d358715d22f55e67e0808e01633fd55e19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8812aab189d4519c0bb3f853867a2e12af0b6504/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8812aab189d4519c0bb3f853867a2e12af0b6504/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8812aab189d4519c0bb3f853867a2e12af0b6504", "patch": "@@ -1,3 +1,29 @@\n+2012-08-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-into-ssa.c (struct common_info_d): New struct.\n+\t(struct var_info_d, struct ssa_name_info): Use it.\n+\t(get_ssa_name_ann): Adjust.\n+\t(get_phi_state, set_phi_state): Remove.\n+\t(get_common_info): New function.\n+\t(get_current_def, set_current_def): Adjust.\n+\t(get_def_blocks_for): Take a common info as param.\n+\t(set_def_block): Call get_common_info once.\n+\t(set_livein_block): Likewise.\n+\t(find_def_blocks_for): Adjust.\n+\t(insert_phi_nodes): Likewise.\n+\t(register_new_def): Call get_common_info once.\n+\t(get_reaching_def): Likewise.\n+\t(rewrite_debug_stmt_uses): Likewise.\n+\t(rewrite_leave_block): Likewise.\n+\t(dump_currdefs): Likewise.\n+\t(debug_var_infos_r): Adjust.\n+\t(register_new_update_single): Call get_common_info once.\n+\t(maybe_replace_use_in_debug_stmt): Likewise.\n+\t(rewrite_update_leave_block): Likewise.\n+\t(mark_use_interesting): Adjust.\n+\t(create_new_def_for): Likewise.\n+\t(update_ssa): Likewise.\n+\n 2012-08-02  Michael Matz  <matz@suse.de>\n \n \t* tree-ssa-live.c (set_is_used): Return a bool."}, {"sha": "b22aa2e90c7500786298d9109c2fa39f6c0374e3", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 83, "deletions": 102, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8812aab189d4519c0bb3f853867a2e12af0b6504/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8812aab189d4519c0bb3f853867a2e12af0b6504/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=8812aab189d4519c0bb3f853867a2e12af0b6504", "patch": "@@ -126,25 +126,34 @@ struct mark_def_sites_global_data\n   bitmap kills;\n };\n \n-\n-/* Information stored for decls.  */\n-struct var_info_d\n+/* Information stored for both SSA names and decls.  */\n+struct common_info_d\n {\n-  /* The variable.  */\n-  tree var;\n-\n   /* This field indicates whether or not the variable may need PHI nodes.\n      See the enum's definition for more detailed information about the\n      states.  */\n   ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n \n-  /* The current reaching definition replacing this SSA name.  */\n+  /* The current reaching definition replacing this var.  */\n   tree current_def;\n \n-  /* Definitions for this VAR.  */\n+  /* Definitions for this var.  */\n   struct def_blocks_d def_blocks;\n };\n \n+/* The information associated with decls and SSA names.  */\n+typedef struct common_info_d *common_info_p;\n+\n+/* Information stored for decls.  */\n+struct var_info_d\n+{\n+  /* The variable.  */\n+  tree var;\n+\n+  /* Information stored for both SSA names and decls.  */\n+  struct common_info_d info;\n+};\n+\n /* The information associated with decls.  */\n typedef struct var_info_d *var_info_p;\n \n@@ -164,19 +173,11 @@ struct ssa_name_info\n      are assumed to be null.  */\n   unsigned age;\n \n-  /* This field indicates whether or not the variable may need PHI nodes.\n-     See the enum's definition for more detailed information about the\n-     states.  */\n-  ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n-\n-  /* The current reaching definition replacing this SSA name.  */\n-  tree current_def;\n-\n   /* Replacement mappings, allocated from update_ssa_obstack.  */\n   bitmap repl_set;\n \n-  /* Definitions for this SSA name.  */\n-  struct def_blocks_d def_blocks;\n+  /* Information stored for both SSA names and decls.  */\n+  struct common_info_d info;\n };\n \n /* The information associated with names.  */\n@@ -323,13 +324,13 @@ get_ssa_name_ann (tree name)\n   info = VEC_index (ssa_name_info_p, info_for_ssa_name, ver);\n   if (info->age < current_info_for_ssa_name_age)\n     {\n-      info->need_phi_state = NEED_PHI_STATE_UNKNOWN;\n-      info->current_def = NULL_TREE;\n-      info->repl_set = NULL;\n-      info->def_blocks.def_blocks = NULL;\n-      info->def_blocks.phi_blocks = NULL;\n-      info->def_blocks.livein_blocks = NULL;\n       info->age = current_info_for_ssa_name_age;\n+      info->repl_set = NULL;\n+      info->info.need_phi_state = NEED_PHI_STATE_UNKNOWN;\n+      info->info.current_def = NULL_TREE;\n+      info->info.def_blocks.def_blocks = NULL;\n+      info->info.def_blocks.phi_blocks = NULL;\n+      info->info.def_blocks.livein_blocks = NULL;\n     }\n \n   return info;\n@@ -368,27 +369,15 @@ clear_ssa_name_info (void)\n }\n \n \n-/* Get phi_state field for VAR.  */\n+/* Get access to the auxiliar information stored per SSA name or decl.  */\n \n-static inline enum need_phi_state\n-get_phi_state (tree var)\n-{\n-  if (TREE_CODE (var) == SSA_NAME)\n-    return get_ssa_name_ann (var)->need_phi_state;\n-  else\n-    return get_var_info (var)->need_phi_state;\n-}\n-\n-\n-/* Sets phi_state field for VAR to STATE.  */\n-\n-static inline void\n-set_phi_state (tree var, enum need_phi_state state)\n+static inline common_info_p\n+get_common_info (tree var)\n {\n   if (TREE_CODE (var) == SSA_NAME)\n-    get_ssa_name_ann (var)->need_phi_state = state;\n+    return &get_ssa_name_ann (var)->info;\n   else\n-    get_var_info (var)->need_phi_state = state;\n+    return &get_var_info (var)->info;\n }\n \n \n@@ -397,10 +386,7 @@ set_phi_state (tree var, enum need_phi_state state)\n tree\n get_current_def (tree var)\n {\n-  if (TREE_CODE (var) == SSA_NAME)\n-    return get_ssa_name_ann (var)->current_def;\n-  else\n-    return get_var_info (var)->current_def;\n+  return get_common_info (var)->current_def;\n }\n \n \n@@ -409,10 +395,7 @@ get_current_def (tree var)\n void\n set_current_def (tree var, tree def)\n {\n-  if (TREE_CODE (var) == SSA_NAME)\n-    get_ssa_name_ann (var)->current_def = def;\n-  else\n-    get_var_info (var)->current_def = def;\n+  get_common_info (var)->current_def = def;\n }\n \n \n@@ -512,15 +495,9 @@ mark_block_for_update (basic_block bb)\n    DEF_BLOCKS, a new one is created and returned.  */\n \n static inline struct def_blocks_d *\n-get_def_blocks_for (tree var)\n+get_def_blocks_for (common_info_p info)\n {\n-  struct def_blocks_d *db_p;\n-\n-  if (TREE_CODE (var) == SSA_NAME)\n-    db_p = &get_ssa_name_ann (var)->def_blocks;\n-  else\n-    db_p = &get_var_info (var)->def_blocks;\n-\n+  struct def_blocks_d *db_p = &info->def_blocks;\n   if (!db_p->def_blocks)\n     {\n       db_p->def_blocks = BITMAP_ALLOC (&update_ssa_obstack);\n@@ -539,10 +516,10 @@ static void\n set_def_block (tree var, basic_block bb, bool phi_p)\n {\n   struct def_blocks_d *db_p;\n-  enum need_phi_state state;\n+  common_info_p info;\n \n-  state = get_phi_state (var);\n-  db_p = get_def_blocks_for (var);\n+  info = get_common_info (var);\n+  db_p = get_def_blocks_for (info);\n \n   /* Set the bit corresponding to the block where VAR is defined.  */\n   bitmap_set_bit (db_p->def_blocks, bb->index);\n@@ -561,10 +538,10 @@ set_def_block (tree var, basic_block bb, bool phi_p)\n      variable which was not dominated by the block containing the\n      definition(s).  In this case we may need a PHI node, so enter\n      state NEED_PHI_STATE_MAYBE.  */\n-  if (state == NEED_PHI_STATE_UNKNOWN)\n-    set_phi_state (var, NEED_PHI_STATE_NO);\n+  if (info->need_phi_state == NEED_PHI_STATE_UNKNOWN)\n+    info->need_phi_state = NEED_PHI_STATE_NO;\n   else\n-    set_phi_state (var, NEED_PHI_STATE_MAYBE);\n+    info->need_phi_state = NEED_PHI_STATE_MAYBE;\n }\n \n \n@@ -573,10 +550,11 @@ set_def_block (tree var, basic_block bb, bool phi_p)\n static void\n set_livein_block (tree var, basic_block bb)\n {\n+  common_info_p info;\n   struct def_blocks_d *db_p;\n-  enum need_phi_state state = get_phi_state (var);\n \n-  db_p = get_def_blocks_for (var);\n+  info = get_common_info (var);\n+  db_p = get_def_blocks_for (info);\n \n   /* Set the bit corresponding to the block where VAR is live in.  */\n   bitmap_set_bit (db_p->livein_blocks, bb->index);\n@@ -587,17 +565,17 @@ set_livein_block (tree var, basic_block bb)\n      by the single block containing the definition(s) of this variable.  If\n      it is, then we remain in NEED_PHI_STATE_NO, otherwise we transition to\n      NEED_PHI_STATE_MAYBE.  */\n-  if (state == NEED_PHI_STATE_NO)\n+  if (info->need_phi_state == NEED_PHI_STATE_NO)\n     {\n       int def_block_index = bitmap_first_set_bit (db_p->def_blocks);\n \n       if (def_block_index == -1\n \t  || ! dominated_by_p (CDI_DOMINATORS, bb,\n \t                       BASIC_BLOCK (def_block_index)))\n-\tset_phi_state (var, NEED_PHI_STATE_MAYBE);\n+\tinfo->need_phi_state = NEED_PHI_STATE_MAYBE;\n     }\n   else\n-    set_phi_state (var, NEED_PHI_STATE_MAYBE);\n+    info->need_phi_state = NEED_PHI_STATE_MAYBE;\n }\n \n \n@@ -976,11 +954,7 @@ prune_unused_phi_nodes (bitmap phis, bitmap kills, bitmap uses)\n static inline struct def_blocks_d *\n find_def_blocks_for (tree var)\n {\n-  def_blocks_p p;\n-  if (TREE_CODE (var) == SSA_NAME)\n-    p = &get_ssa_name_ann (var)->def_blocks;\n-  else\n-    p = &get_var_info (var)->def_blocks;\n+  def_blocks_p p = &get_common_info (var)->def_blocks;\n   if (!p->def_blocks)\n     return NULL;\n   return p;\n@@ -1133,7 +1107,7 @@ insert_phi_nodes (bitmap_head *dfs)\n \n   vars = VEC_alloc (var_info_p, heap, htab_elements (var_infos));\n   FOR_EACH_HTAB_ELEMENT (var_infos, info, var_info_p, hi)\n-    if (info->need_phi_state != NEED_PHI_STATE_NO)\n+    if (info->info.need_phi_state != NEED_PHI_STATE_NO)\n       VEC_quick_push (var_info_p, vars, info);\n \n   /* Do two stages to avoid code generation differences for UID\n@@ -1142,7 +1116,7 @@ insert_phi_nodes (bitmap_head *dfs)\n \n   FOR_EACH_VEC_ELT (var_info_p, vars, i, info)\n     {\n-      bitmap idf = compute_idf (info->def_blocks.def_blocks, dfs);\n+      bitmap idf = compute_idf (info->info.def_blocks.def_blocks, dfs);\n       insert_phi_nodes_for (info->var, idf, false);\n       BITMAP_FREE (idf);\n     }\n@@ -1159,6 +1133,7 @@ insert_phi_nodes (bitmap_head *dfs)\n static void\n register_new_def (tree def, tree sym)\n {\n+  common_info_p info = get_common_info (sym);\n   tree currdef;\n \n   /* If this variable is set in a single basic block and all uses are\n@@ -1169,13 +1144,13 @@ register_new_def (tree def, tree sym)\n      This is the same test to prune the set of variables which may\n      need PHI nodes.  So we just use that information since it's already\n      computed and available for us to use.  */\n-  if (get_phi_state (sym) == NEED_PHI_STATE_NO)\n+  if (info->need_phi_state == NEED_PHI_STATE_NO)\n     {\n-      set_current_def (sym, def);\n+      info->current_def = def;\n       return;\n     }\n \n-  currdef = get_current_def (sym);\n+  currdef = info->current_def;\n \n   /* If SYM is not a GIMPLE register, then CURRDEF may be a name whose\n      SSA_NAME_VAR is not necessarily SYM.  In this case, also push SYM\n@@ -1193,7 +1168,7 @@ register_new_def (tree def, tree sym)\n   VEC_safe_push (tree, heap, block_defs_stack, currdef ? currdef : sym);\n \n   /* Set the current reaching definition for SYM to be DEF.  */\n-  set_current_def (sym, def);\n+  info->current_def = def;\n }\n \n \n@@ -1226,18 +1201,18 @@ register_new_def (tree def, tree sym)\n static tree\n get_reaching_def (tree var)\n {\n+  common_info_p info = get_common_info (var);\n   tree currdef;\n \n   /* Lookup the current reaching definition for VAR.  */\n-  currdef = get_current_def (var);\n+  currdef = info->current_def;\n \n   /* If there is no reaching definition for VAR, create and register a\n      default definition for it (if needed).  */\n   if (currdef == NULL_TREE)\n     {\n       tree sym = DECL_P (var) ? var : SSA_NAME_VAR (var);\n       currdef = get_or_create_ssa_default_def (cfun, sym);\n-      set_current_def (var, currdef);\n     }\n \n   /* Return the current reaching definition for VAR, or the default\n@@ -1258,8 +1233,9 @@ rewrite_debug_stmt_uses (gimple stmt)\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n     {\n       tree var = USE_FROM_PTR (use_p), def;\n+      common_info_p info = get_common_info (var);\n       gcc_assert (DECL_P (var));\n-      def = get_current_def (var);\n+      def = info->current_def;\n       if (!def)\n \t{\n \t  if (TREE_CODE (var) == PARM_DECL && single_succ_p (ENTRY_BLOCK_PTR))\n@@ -1302,7 +1278,7 @@ rewrite_debug_stmt_uses (gimple stmt)\n \t}\n       else\n \t{\n-\t  /* Check if get_current_def can be trusted.  */\n+\t  /* Check if info->current_def can be trusted.  */\n \t  basic_block bb = gimple_bb (stmt);\n \t  basic_block def_bb\n \t      = SSA_NAME_IS_DEFAULT_DEF (def)\n@@ -1317,11 +1293,11 @@ rewrite_debug_stmt_uses (gimple stmt)\n \t    def = NULL;\n \t  /* If there is just one definition and dominates the current\n \t     bb, it is fine.  */\n-\t  else if (get_phi_state (var) == NEED_PHI_STATE_NO)\n+\t  else if (info->need_phi_state == NEED_PHI_STATE_NO)\n \t    ;\n \t  else\n \t    {\n-\t      struct def_blocks_d *db_p = get_def_blocks_for (var);\n+\t      struct def_blocks_d *db_p = get_def_blocks_for (info);\n \n \t      /* If there are some non-debug uses in the current bb,\n \t\t it is fine.  */\n@@ -1515,7 +1491,7 @@ rewrite_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t  var = tmp;\n \t}\n \n-      set_current_def (var, saved_def);\n+      get_common_info (var)->current_def = saved_def;\n     }\n }\n \n@@ -1639,11 +1615,12 @@ dump_currdefs (FILE *file)\n   fprintf (file, \"\\n\\nCurrent reaching definitions\\n\\n\");\n   FOR_EACH_VEC_ELT (tree, symbols_to_rename, i, var)\n     {\n+      common_info_p info = get_common_info (var);\n       fprintf (file, \"CURRDEF (\");\n       print_generic_expr (file, var, 0);\n       fprintf (file, \") = \");\n-      if (get_current_def (var))\n-\tprint_generic_expr (file, get_current_def (var), 0);\n+      if (info->current_def)\n+\tprint_generic_expr (file, info->current_def, 0);\n       else\n \tfprintf (file, \"<NIL>\");\n       fprintf (file, \"\\n\");\n@@ -1744,13 +1721,16 @@ static int\n debug_var_infos_r (void **slot, void *data)\n {\n   FILE *file = (FILE *) data;\n-  struct var_info_d *db_p = (struct var_info_d *) *slot;\n+  struct var_info_d *info = (struct var_info_d *) *slot;\n \n   fprintf (file, \"VAR: \");\n-  print_generic_expr (file, db_p->var, dump_flags);\n-  bitmap_print (file, db_p->def_blocks.def_blocks, \", DEF_BLOCKS: { \", \"}\");\n-  bitmap_print (file, db_p->def_blocks.livein_blocks, \", LIVEIN_BLOCKS: { \", \"}\");\n-  bitmap_print (file, db_p->def_blocks.phi_blocks, \", PHI_BLOCKS: { \", \"}\\n\");\n+  print_generic_expr (file, info->var, dump_flags);\n+  bitmap_print (file, info->info.def_blocks.def_blocks,\n+\t\t\", DEF_BLOCKS: { \", \"}\");\n+  bitmap_print (file, info->info.def_blocks.livein_blocks,\n+\t\t\", LIVEIN_BLOCKS: { \", \"}\");\n+  bitmap_print (file, info->info.def_blocks.phi_blocks,\n+\t\t\", PHI_BLOCKS: { \", \"}\\n\");\n \n   return 1;\n }\n@@ -1781,7 +1761,8 @@ debug_var_infos (void)\n static inline void\n register_new_update_single (tree new_name, tree old_name)\n {\n-  tree currdef = get_current_def (old_name);\n+  common_info_p info = get_common_info (old_name);\n+  tree currdef = info->current_def;\n \n   /* Push the current reaching definition into BLOCK_DEFS_STACK.\n      This stack is later used by the dominator tree callbacks to\n@@ -1794,7 +1775,7 @@ register_new_update_single (tree new_name, tree old_name)\n \n   /* Set the current reaching definition for OLD_NAME to be\n      NEW_NAME.  */\n-  set_current_def (old_name, new_name);\n+  info->current_def = new_name;\n }\n \n \n@@ -1846,10 +1827,10 @@ maybe_replace_use_in_debug_stmt (use_operand_p use_p)\n   tree sym = DECL_P (use) ? use : SSA_NAME_VAR (use);\n \n   if (marked_for_renaming (sym))\n-    rdef = get_current_def (sym);\n+    rdef = get_var_info (sym)->info.current_def;\n   else if (is_old_name (use))\n     {\n-      rdef = get_current_def (use);\n+      rdef = get_ssa_name_ann (use)->info.current_def;\n       /* We can't assume that, if there's no current definition, the\n \t default one should be used.  It could be the case that we've\n \t rearranged blocks so that the earlier definition no longer\n@@ -2202,7 +2183,7 @@ rewrite_update_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \treturn;\n \n       saved_def = VEC_pop (tree, block_defs_stack);\n-      set_current_def (var, saved_def);\n+      get_common_info (var)->current_def = saved_def;\n     }\n }\n \n@@ -2515,7 +2496,7 @@ mark_use_interesting (tree var, gimple stmt, basic_block bb, bool insert_phi_p)\n      replace it).  */\n   if (insert_phi_p)\n     {\n-      struct def_blocks_d *db_p = get_def_blocks_for (var);\n+      struct def_blocks_d *db_p = get_def_blocks_for (get_common_info (var));\n       if (!bitmap_bit_p (db_p->def_blocks, bb->index))\n \tset_livein_block (var, bb);\n     }\n@@ -2898,7 +2879,7 @@ create_new_def_for (tree old_name, gimple stmt, def_operand_p def)\n   /* For the benefit of passes that will be updating the SSA form on\n      their own, set the current reaching definition of OLD_NAME to be\n      NEW_NAME.  */\n-  set_current_def (old_name, new_name);\n+  get_ssa_name_ann (old_name)->info.current_def = new_name;\n \n   return new_name;\n }\n@@ -3281,10 +3262,10 @@ update_ssa (unsigned update_flags)\n   /* Reset the current definition for name and symbol before renaming\n      the sub-graph.  */\n   EXECUTE_IF_SET_IN_SBITMAP (old_ssa_names, 0, i, sbi)\n-    set_current_def (ssa_name (i), NULL_TREE);\n+    get_ssa_name_ann (ssa_name (i))->info.current_def = NULL_TREE;\n \n   FOR_EACH_VEC_ELT (tree, symbols_to_rename, i, sym)\n-    set_current_def (sym, NULL_TREE);\n+    get_var_info (sym)->info.current_def = NULL_TREE;\n \n   /* Now start the renaming process at START_BB.  */\n   interesting_blocks = sbitmap_alloc (last_basic_block);"}]}