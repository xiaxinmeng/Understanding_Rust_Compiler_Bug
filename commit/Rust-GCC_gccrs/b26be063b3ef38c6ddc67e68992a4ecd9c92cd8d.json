{"sha": "b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI2YmUwNjNiM2VmMzhjNmRkYzY3ZTY4OTkyYTRlY2Q5YzkyY2Q4ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-17T07:42:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-17T07:42:04Z"}, "message": "[multiple changes]\n\n2010-06-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb: propagate Pragma_Enabled flag to generic.\n\t* get_scos.adb: Set C2 flag in decision entry of pragma to 'e' (enabled)\n\t* par_sco.ads, par_sco.adb (Set_SCO_Pragma_Enabled): New procedure\n\tRemove use of Node field in SCOs table\n\t(Output_Header): Set 'd' to initially disable pragma entry\n\t* put_scos.adb (Put_SCOs): New flag indicating if pragma is enabled\n\t* scos.ads, scos.adb: Remove Node field from internal SCOs table.\n\tUse C2 field of pragma decision header to indicate enabled.\n\t* sem_prag.adb: Add calls to Set_SCO_Pragma_Enabled.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\n2010-06-17  Vincent Celier  <celier@adacore.com>\n\n\t* back_end.adb (Next_Arg): Moved to procedure Scan_Compiler_Arguments\n\t(Scan_Compiler_Arguments): Call Scan_Front_End_Switches with Next_Arg\n\t(Switch_Subsequently_Cancelled): Function moved to the body of Switch.C\n\t* back_end.ads (Scan_Front_End_Switches): Function moved to the body of\n\tSwitch.C.\n\t* switch-c.adb: Copied a number of global declarations from back_end.adb\n\t(Len_Arg): New function copied from back_end.adb\n\t(Switch_Subsequently_Cancelled): New function moved from back_end.adb\n\t(Scan_Front_End_Switches): New parameter Arg_Rank used to call\n\tSwitch_Subsequently_Cancelled.\n\t* switch-c.ads (Scan_Front_End_Switches): New parameter Arg_Rank.\n\t* gcc-interface/Makefile.in: Add line so that shared libgnat is linked\n\twith -lexc on Tru64.\n\nFrom-SVN: r160878", "tree": {"sha": "24565076b0bd54cc2731f9f111de628d53b3aa07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24565076b0bd54cc2731f9f111de628d53b3aa07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/comments", "author": null, "committer": null, "parents": [{"sha": "038253e614ae4a012cceeffdabd92185164b4f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/038253e614ae4a012cceeffdabd92185164b4f15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/038253e614ae4a012cceeffdabd92185164b4f15"}], "stats": {"total": 411, "additions": 269, "deletions": 142}, "files": [{"sha": "2d4716835e6cd271e2d53db2f0818c0573df3ff3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -1,3 +1,32 @@\n+2010-06-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb: propagate Pragma_Enabled flag to generic.\n+\t* get_scos.adb: Set C2 flag in decision entry of pragma to 'e' (enabled)\n+\t* par_sco.ads, par_sco.adb (Set_SCO_Pragma_Enabled): New procedure\n+\tRemove use of Node field in SCOs table\n+\t(Output_Header): Set 'd' to initially disable pragma entry\n+\t* put_scos.adb (Put_SCOs): New flag indicating if pragma is enabled\n+\t* scos.ads, scos.adb: Remove Node field from internal SCOs table.\n+\tUse C2 field of pragma decision header to indicate enabled.\n+\t* sem_prag.adb: Add calls to Set_SCO_Pragma_Enabled.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2010-06-17  Vincent Celier  <celier@adacore.com>\n+\n+\t* back_end.adb (Next_Arg): Moved to procedure Scan_Compiler_Arguments\n+\t(Scan_Compiler_Arguments): Call Scan_Front_End_Switches with Next_Arg\n+\t(Switch_Subsequently_Cancelled): Function moved to the body of Switch.C\n+\t* back_end.ads (Scan_Front_End_Switches): Function moved to the body of\n+\tSwitch.C.\n+\t* switch-c.adb: Copied a number of global declarations from back_end.adb\n+\t(Len_Arg): New function copied from back_end.adb\n+\t(Switch_Subsequently_Cancelled): New function moved from back_end.adb\n+\t(Scan_Front_End_Switches): New parameter Arg_Rank used to call\n+\tSwitch_Subsequently_Cancelled.\n+\t* switch-c.ads (Scan_Front_End_Switches): New parameter Arg_Rank.\n+\t* gcc-interface/Makefile.in: Add line so that shared libgnat is linked\n+\twith -lexc on Tru64.\n+\n 2010-06-17  Robert Dewar  <dewar@adacore.com>\n \n \t* prj.ads, prj.adb: Minor reformatting"}, {"sha": "974c4b3e913daadeeaa1d5cd709253daf67cbdb1", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -46,10 +46,6 @@ package body Back_End is\n    type Arg_Array_Ptr is access Arg_Array;\n    --  Types to access compiler arguments\n \n-   Next_Arg : Pos := 1;\n-   --  Next argument to be scanned by Scan_Compiler_Arguments. We make this\n-   --  global so that it can be accessed by Switch_Subsequently_Cancelled.\n-\n    flag_stack_check : Int;\n    pragma Import (C, flag_stack_check);\n    --  Indicates if stack checking is enabled, imported from toplev.c\n@@ -166,6 +162,9 @@ package body Back_End is\n \n    procedure Scan_Compiler_Arguments is\n \n+      Next_Arg : Pos;\n+      --  Next argument to be scanned\n+\n       Output_File_Name_Seen : Boolean := False;\n       --  Set to True after having scanned file_name for switch \"-gnatO file\"\n \n@@ -232,6 +231,7 @@ package body Back_End is\n \n       --  Loop through command line arguments, storing them for later access\n \n+      Next_Arg := 1;\n       while Next_Arg < save_argc loop\n          Look_At_Arg : declare\n             Argv_Ptr : constant Big_String_Ptr := save_argv (Next_Arg);\n@@ -284,7 +284,7 @@ package body Back_End is\n                Opt.No_Stdlib := True;\n \n             elsif Is_Front_End_Switch (Argv) then\n-               Scan_Front_End_Switches (Argv);\n+               Scan_Front_End_Switches (Argv, Next_Arg);\n \n             --  All non-front-end switches are back-end switches\n \n@@ -296,32 +296,4 @@ package body Back_End is\n          Next_Arg := Next_Arg + 1;\n       end loop;\n    end Scan_Compiler_Arguments;\n-\n-   -----------------------------------\n-   -- Switch_Subsequently_Cancelled --\n-   -----------------------------------\n-\n-   function Switch_Subsequently_Cancelled (C : String) return Boolean is\n-      Arg : Pos;\n-\n-   begin\n-      Arg := Next_Arg + 1;\n-      while Arg < save_argc loop\n-         declare\n-            Argv_Ptr : constant Big_String_Ptr := save_argv (Arg);\n-            Argv_Len : constant Nat            := Len_Arg (Arg);\n-            Argv     : constant String         :=\n-                         Argv_Ptr (1 .. Natural (Argv_Len));\n-         begin\n-            if Argv = \"-gnat-\" & C then\n-               return True;\n-            end if;\n-         end;\n-\n-         Arg := Arg + 1;\n-      end loop;\n-\n-      return False;\n-   end Switch_Subsequently_Cancelled;\n-\n end Back_End;"}, {"sha": "fb11939a064cd0eb704e42ccb4da91a59bede980", "filename": "gcc/ada/back_end.ads", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fback_end.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fback_end.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.ads?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -61,11 +61,4 @@ package Back_End is\n    --  Any processed switches that influence the result of a compilation must\n    --  be added to the Compilation_Arguments table.\n \n-   function Switch_Subsequently_Cancelled (C : String) return Boolean;\n-   --  This function is called from Scan_Front_End_Switches. It determines if\n-   --  the switch currently being scanned is followed by a switch of the form\n-   --  \"-gnat-\" & C, where C is the argument. If so, then True is returned,\n-   --  and Scan_Front_End_Switches will cancel the effect of the switch. If\n-   --  no such switch is found, False is returned.\n-\n end Back_End;"}, {"sha": "ac68435dcefb973ec5a869885d45c409a3d94718", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -1834,21 +1834,22 @@ ada/exp_ch4.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/get_targ.ads ada/gnat.ads ada/g-htable.ads ada/hostparm.ads \\\n    ada/inline.ads ada/itypes.ads ada/lib.ads ada/namet.ads ada/nlists.ads \\\n    ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n-   ada/restrict.ads ada/restrict.adb ada/rident.ads ada/rtsfind.ads \\\n-   ada/sem.ads ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch13.ads \\\n-   ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_eval.ads \\\n-   ada/sem_eval.adb ada/sem_res.ads ada/sem_scil.ads ada/sem_type.ads \\\n-   ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb \\\n-   ada/sinput.ads ada/snames.ads ada/sprint.ads ada/stand.ads \\\n-   ada/stringt.ads ada/stringt.adb ada/system.ads ada/s-exctab.ads \\\n-   ada/s-exctab.adb ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/urealp.adb ada/validsw.ads \n+   ada/par_sco.ads ada/restrict.ads ada/restrict.adb ada/rident.ads \\\n+   ada/rtsfind.ads ada/sem.ads ada/sem_aux.ads ada/sem_cat.ads \\\n+   ada/sem_ch13.ads ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads \\\n+   ada/sem_eval.ads ada/sem_eval.adb ada/sem_res.ads ada/sem_scil.ads \\\n+   ada/sem_type.ads ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n+   ada/stand.ads ada/stringt.ads ada/stringt.adb ada/system.ads \\\n+   ada/s-exctab.ads ada/s-exctab.adb ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads \\\n+   ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \\\n+   ada/validsw.ads \n \n ada/exp_ch5.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2911,11 +2912,16 @@ ada/prepcomp.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n-ada/put_scos.o : ada/ada.ads ada/a-unccon.ads ada/gnat.ads ada/g-table.ads \\\n-   ada/g-table.adb ada/put_scos.ads ada/put_scos.adb ada/scos.ads \\\n-   ada/system.ads ada/s-exctab.ads ada/s-memory.ads ada/s-stalib.ads \\\n-   ada/s-unstyp.ads ada/types.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/atree.ads ada/sinfo.ads ada/snames.ads\n+ada/put_scos.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n+   ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/debug.ads \\\n+   ada/einfo.ads ada/gnat.ads ada/g-table.ads ada/g-table.adb \\\n+   ada/hostparm.ads ada/namet.ads ada/opt.ads ada/output.ads \\\n+   ada/put_scos.ads ada/put_scos.adb ada/scos.ads ada/sinfo.ads \\\n+   ada/snames.ads ada/system.ads ada/s-exctab.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/repinfo.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -4194,15 +4200,16 @@ ada/switch-b.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/types.ads ada/unchconv.ads ada/unchdeal.ads \n \n ada/switch-c.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n-   ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/gnatvsn.ads \\\n-   ada/hostparm.ads ada/lib.ads ada/namet.ads ada/opt.ads ada/osint.ads \\\n-   ada/output.ads ada/prepcomp.ads ada/sem_warn.ads ada/stylesw.ads \\\n-   ada/switch.ads ada/switch-c.ads ada/switch-c.adb ada/system.ads \\\n-   ada/s-exctab.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n-   ada/types.ads ada/unchconv.ads ada/unchdeal.ads ada/validsw.ads \n+   ada/a-uncdea.ads ada/alloc.ads ada/back_end.ads ada/debug.ads \\\n+   ada/gnatvsn.ads ada/hostparm.ads ada/lib.ads ada/namet.ads ada/opt.ads \\\n+   ada/osint.ads ada/output.ads ada/prepcomp.ads ada/sem_warn.ads \\\n+   ada/stylesw.ads ada/switch.ads ada/switch-c.ads ada/switch-c.adb \\\n+   ada/system.ads ada/s-exctab.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tree_io.ads ada/types.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/validsw.ads \n \n ada/switch.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/gnatvsn.ads \\"}, {"sha": "47bf9fd3e65fb9e552a1a5523164db32decff155", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -1451,6 +1451,7 @@ ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n \n   EH_MECHANISM=-gcc\n   GMEM_LIB=gmemlib\n+  MISCLIB = -lexc\n   THREADSLIB = -lpthread -lmach -lexc -lrt\n   GNATLIB_SHARED = gnatlib-shared-default\n   LIBRARY_VERSION := $(LIB_VERSION)"}, {"sha": "70d77c80b6ad03f1cdc41be2db79563c4f714bbe", "filename": "gcc/ada/get_scos.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fget_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fget_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_scos.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -315,6 +315,7 @@ begin\n \n             declare\n                Loc : Source_Location;\n+               C2v : Character;\n \n             begin\n                --  Acquire location information\n@@ -325,9 +326,18 @@ begin\n                   Get_Source_Location (Loc);\n                end if;\n \n+               --  C2 is a space except for pragmas where it is 'e' since\n+               --  clearly the pragma is enabled if it was written out.\n+\n+               if C = 'P' then\n+                  C2v := 'e';\n+               else\n+                  C2v := ' ';\n+               end if;\n+\n                Add_SCO\n                  (C1   => Dtyp,\n-                  C2   => ' ',\n+                  C2   => C2v,\n                   From => Loc,\n                   To   => No_Source_Location,\n                   Last => False);"}, {"sha": "d0b2a9f3d5cb480547f2442fe157ac147567beb5", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -63,13 +63,14 @@ package body Par_SCO is\n      Table_Increment      => 200,\n      Table_Name           => \"SCO_Unit_Number_Entry\");\n \n-   --------------------------\n-   -- Condition Hash Table --\n-   --------------------------\n+   ---------------------------------\n+   -- Condition/Pragma Hash Table --\n+   ---------------------------------\n \n    --  We need to be able to get to conditions quickly for handling the calls\n-   --  to Set_SCO_Condition efficiently. For this purpose we identify the\n-   --  conditions in the table by their starting sloc, and use the following\n+   --  to Set_SCO_Condition efficiently, and similarly to get to pragmas to\n+   --  handle calls to Set_SCO_Pragma_Enabled. For this purpose we identify the\n+   --  conditions and pragmas in the table by their starting sloc, and use this\n    --  hash table to map from these starting sloc values to SCO_Table indexes.\n \n    type Header_Num is new Integer range 0 .. 996;\n@@ -81,7 +82,7 @@ package body Par_SCO is\n    function Equal (F1, F2 : Source_Ptr) return Boolean;\n    --  Function to test two keys for equality\n \n-   package Condition_Hash_Table is new Simple_HTable\n+   package Condition_Pragma_Hash_Table is new Simple_HTable\n      (Header_Num, Int, 0, Source_Ptr, Hash, Equal);\n    --  The actual hash table\n \n@@ -116,7 +117,6 @@ package body Par_SCO is\n       C2   : Character;\n       From : Source_Ptr;\n       To   : Source_Ptr;\n-      Node : Node_Id;\n       Last : Boolean);\n    --  Append an entry to SCO_Table with fields set as per arguments\n \n@@ -232,11 +232,6 @@ package body Par_SCO is\n                Write_Str (\"  False\");\n             end if;\n \n-            if Present (T.Node) then\n-               Write_Str (\"  Node = \");\n-               Write_Int (Int (T.Node));\n-            end if;\n-\n             Write_Eol;\n          end;\n       end loop;\n@@ -409,7 +404,6 @@ package body Par_SCO is\n                C2   => ' ',\n                From => Sloc (N),\n                To   => No_Location,\n-               Node => Empty,\n                Last => False);\n \n             Output_Decision_Operand (L);\n@@ -436,9 +430,8 @@ package body Par_SCO is\n             C2   => 'c',\n             From => FSloc,\n             To   => LSloc,\n-            Node => Empty,\n             Last => False);\n-         Condition_Hash_Table.Set (FSloc, SCO_Table.Last);\n+         Condition_Pragma_Hash_Table.Set (FSloc, SCO_Table.Last);\n       end Output_Element;\n \n       -------------------\n@@ -458,26 +451,32 @@ package body Par_SCO is\n                   C2   => ' ',\n                   From => Sloc (Parent (N)),\n                   To   => No_Location,\n-                  Node => Empty,\n                   Last => False);\n \n             when 'P' =>\n \n-               --  For PRAGMA, we must record the pragma node. Argument N\n-               --  is the pragma argument, and we have to go up two levels\n-               --  (through the pragma argument association) to get to the\n-               --  pragma node itself.\n+               --  For PRAGMA, we must get the location from the pragma node.\n+               --  Argument N is the pragma argument, and we have to go up two\n+               --  levels (through the pragma argument association) to get to\n+               --  the pragma node itself.\n \n                declare\n-                  Pnode : constant Node_Id := Parent (Parent (N));\n+                  Loc : constant Source_Ptr := Sloc (Parent (Parent (N)));\n+\n                begin\n                   Set_Table_Entry\n                     (C1   => 'P',\n-                     C2   => ' ',\n-                     From => Sloc (Pnode),\n+                     C2   => 'd',\n+                     From => Loc,\n                      To   => No_Location,\n-                     Node => Pnode,\n                      Last => False);\n+\n+                  --  For pragmas we also must make an entry in the hash table\n+                  --  for later access by Set_SCO_Pragma_Enabled. We set the\n+                  --  pragma as disabled above, the call will change C2 to 'e'\n+                  --  to enable the pragma header entry.\n+\n+                  Condition_Pragma_Hash_Table.Set (Loc, SCO_Table.Last);\n                end;\n \n             when 'X' =>\n@@ -489,7 +488,6 @@ package body Par_SCO is\n                   C2   => ' ',\n                   From => No_Location,\n                   To   => No_Location,\n-                  Node => Empty,\n                   Last => False);\n \n             --  No other possibilities\n@@ -821,13 +819,38 @@ package body Par_SCO is\n                                   (False => 'f', True => 't');\n    begin\n       Sloc_Range (Orig, Start, Dummy);\n-      Index := Condition_Hash_Table.Get (Start);\n+      Index := Condition_Pragma_Hash_Table.Get (Start);\n+\n+      --  The test here for zero is to deal with possible previous errors\n \n       if Index /= 0 then\n+         pragma Assert (SCO_Table.Table (Index).C1 = ' ');\n          SCO_Table.Table (Index).C2 := Constant_Condition_Code (Val);\n       end if;\n    end Set_SCO_Condition;\n \n+   ----------------------------\n+   -- Set_SCO_Pragma_Enabled --\n+   ----------------------------\n+\n+   procedure Set_SCO_Pragma_Enabled (Loc : Source_Ptr) is\n+      Index : Nat;\n+\n+   begin\n+      --  Note: the reason we use the Sloc value as the key is that in the\n+      --  generic case, the call to this procedure is made on a copy of the\n+      --  original node, so we can't use the Node_Id value.\n+\n+      Index := Condition_Pragma_Hash_Table.Get (Loc);\n+\n+      --  The test here for zero is to deal with possible previous errors\n+\n+      if Index /= 0 then\n+         pragma Assert (SCO_Table.Table (Index).C1 = 'P');\n+         SCO_Table.Table (Index).C2 := 'e';\n+      end if;\n+   end Set_SCO_Pragma_Enabled;\n+\n    ---------------------\n    -- Set_Table_Entry --\n    ---------------------\n@@ -837,7 +860,6 @@ package body Par_SCO is\n       C2   : Character;\n       From : Source_Ptr;\n       To   : Source_Ptr;\n-      Node : Node_Id;\n       Last : Boolean)\n    is\n       function To_Source_Location (S : Source_Ptr) return Source_Location;\n@@ -866,7 +888,6 @@ package body Par_SCO is\n          C2   => C2,\n          From => To_Source_Location (From),\n          To   => To_Source_Location (To),\n-         Node => Node,\n          Last => Last);\n    end Set_Table_Entry;\n \n@@ -1001,7 +1022,6 @@ package body Par_SCO is\n                   C2   => SCE.Typ,\n                   From => SCE.From,\n                   To   => SCE.To,\n-                  Node => Empty,\n                   Last => (J = SC_Last));\n             end;\n          end loop;\n@@ -1397,7 +1417,6 @@ package body Par_SCO is\n          C2   => ' ',\n          From => First,\n          To   => Last,\n-         Node => Empty,\n          Last => True);\n \n       --  Now output any embedded decisions\n@@ -1423,7 +1442,6 @@ package body Par_SCO is\n       Handler : Node_Id;\n \n    begin\n-\n       --  For package bodies without a statement part, the parser adds an empty\n       --  one, to normalize the representation. The null statement therein,\n       --  which does not come from source, does not get a SCO."}, {"sha": "97e4a6a61af69f70ece40354dc747b9c2648206c", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -49,6 +49,14 @@ package Par_SCO is\n    --  by Val. The condition is identified by the First_Sloc value in the\n    --  original tree associated with Cond.\n \n+   procedure Set_SCO_Pragma_Enabled (Loc : Source_Ptr);\n+   --  This procedure is called from Sem_Prag when a pragma is enabled (i.e.\n+   --  when the Pragma_Enabled flag is set). Loc is the Sloc of the N_Pragma\n+   --  node. This is used to enable the corresponding SCO table entry. Note\n+   --  that we use the Sloc as the key here, since in the generic case, the\n+   --  analysis is on a copy of the node, which is different from the node\n+   --  seen by Par_SCO in the parse tree (but the Sloc values are the same).\n+\n    procedure SCO_Output;\n    --  Outputs SCO lines for all units, with appropriate section headers, for\n    --  unit U in the ALI file, as recorded by previous calls to SCO_Record,"}, {"sha": "9d3bcd7bb2b1a09bc70849f8c75822a74b277055", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -23,9 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree; use Atree;\n-with SCOs;  use SCOs;\n-with Sinfo; use Sinfo;\n+with SCOs; use SCOs;\n \n procedure Put_SCOs is\n    Ctr : Nat;\n@@ -147,17 +145,9 @@ begin\n                   when 'I' | 'E' | 'P' | 'W' | 'X' =>\n                      Start := Start + 1;\n \n-                     --  For disabled pragma, skip decision output. Note that\n-                     --  if the SCO table has been populated by Get_SCOs\n-                     --  (re-reading previously generated SCO information),\n-                     --  then the Node field of pragma entries is Empty. This\n-                     --  is the only way that Node can be Empty, so if we see\n-                     --  an Empty node field, we know the pragma is enabled.\n-\n-                     if T.C1 = 'P'\n-                       and then Present (T.Node)\n-                       and then not Pragma_Enabled (Original_Node (T.Node))\n-                     then\n+                     --  For disabled pragma, skip decision output\n+\n+                     if T.C1 = 'P' and then T.C2 = 'd' then\n                         while not SCO_Table.Table (Start).Last loop\n                            Start := Start + 1;\n                         end loop;"}, {"sha": "c559e6f8dc44b025c95dbb68ffd3f0007e9b8d59", "filename": "gcc/ada/scos.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fscos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fscos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -34,11 +34,10 @@ package body SCOs is\n       To   : Source_Location := No_Source_Location;\n       C1   : Character       := ' ';\n       C2   : Character       := ' ';\n-      Node : Node_Id         := Empty;\n       Last : Boolean         := False)\n    is\n    begin\n-      SCO_Table.Append ((From, To, Node, C1, C2, Last));\n+      SCO_Table.Append ((From, To, C1, C2, Last));\n    end Add_SCO;\n \n    ----------------"}, {"sha": "dc02e28c5e0ea60f605f9e120c61b453fb5360b2", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -286,7 +286,6 @@ package SCOs is\n    type SCO_Table_Entry is record\n       From : Source_Location;\n       To   : Source_Location;\n-      Node : Node_Id;\n       C1   : Character;\n       C2   : Character;\n       Last : Boolean;\n@@ -306,7 +305,6 @@ package SCOs is\n    --      C2   = statement type code to appear on CS line (or ' ' if none)\n    --      From = starting source location\n    --      To   = ending source location\n-   --      Node = Empty\n    --      Last = False for all but the last entry, True for last entry\n \n    --    Note: successive statements (possibly interspersed with entries of\n@@ -321,48 +319,46 @@ package SCOs is\n    --      C2   = ' '\n    --      From = IF/EXIT/WHILE token\n    --      To   = No_Source_Location\n-   --      Node = Empty\n    --      Last = unused\n \n    --    Decision (PRAGMA)\n    --      C1   = 'P'\n-   --      C2   = ' '\n+   --      C2   = 'e'/'d' for enabled/disabled\n    --      From = PRAGMA token\n    --      To   = No_Source_Location\n-   --      Node = N_Pragma node or Empty when reading SCO data (see below)\n    --      Last = unused\n \n    --      Note: when the parse tree is first scanned, we unconditionally build\n    --      a pragma decision entry for any decision in a pragma (here as always\n-   --      in SCO contexts, the only relevant pragmas are Assert, Check,\n-   --      Precondition and Postcondition). Then when we output the SCO info\n-   --      to the ALI file, we use the Node field to check the Pragma_Enabled\n-   --      flag, and if it is False, we suppress output of the pragma decision\n-   --      line. On reading back SCO data from an ALI file, the Node field is\n-   --      always set to Empty.\n+   --      in SCO contexts, the only pragmas with decisions are Assert, Check,\n+   --      Precondition and Postcondition), and we mark the pragma as disabled.\n+   --\n+   --      During analysis, if the pragma is enabled, Set_SCO_Pragma_Enabled to\n+   --      mark the SCO decision table entry as enabled (C2 set to 'e'). Then\n+   --      in Put_SCOs, we only output the decision for a pragma if C2 is 'e'.\n+   --\n+   --      When we read SCOs from an ALI file (in Get_SCOs), we always set C2\n+   --      to 'e', since clearly the pragma is enabled if it was written out.\n \n    --    Decision (Expression)\n    --      C1   = 'X'\n    --      C2   = ' '\n    --      From = No_Source_Location\n    --      To   = No_Source_Location\n-   --      Node = Empty\n    --      Last = unused\n \n    --    Operator\n    --      C1   = '!', '&', '|'\n    --      C2   = ' '\n    --      From = location of NOT/AND/OR token\n    --      To   = No_Source_Location\n-   --      Node = Empty\n    --      Last = False\n \n    --    Element (condition)\n    --      C1   = ' '\n    --      C2   = 'c', 't', or 'f' (condition/true/false)\n    --      From = starting source location\n    --      To   = ending source location\n-   --      Node = Empty\n    --      Last = False for all but the last entry, True for last entry\n \n    --    Note: the sequence starting with a decision, and continuing with\n@@ -415,7 +411,6 @@ package SCOs is\n       To   : Source_Location := No_Source_Location;\n       C1   : Character       := ' ';\n       C2   : Character       := ' ';\n-      Node : Node_Id         := Empty;\n       Last : Boolean         := False);\n    --  Adds one entry to SCO table with given field values\n "}, {"sha": "db3eac64c93f43476fd81799ae9d7fa82942a4bf", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -12223,6 +12223,25 @@ package body Sem_Ch12 is\n                --  All other cases than aggregates\n \n                else\n+\n+                  --  For pragmas, we propagate the Enabled status for the\n+                  --  relevant pragmas to the original generic tree. This was\n+                  --  originally needed for SCO generation. It is no longer\n+                  --  needed there (since we use the Sloc value in calls to\n+                  --  Set_SCO_Pragma_Enabled), but it seems a generally good\n+                  --  idea to have this flag set properly.\n+\n+                  if Nkind (N) = N_Pragma\n+                    and  then\n+                      (Pragma_Name (N) = Name_Precondition\n+                       or else Pragma_Name (N) = Name_Postcondition)\n+                    and then Present (Associated_Node (Pragma_Identifier (N)))\n+                  then\n+                     Set_Pragma_Enabled (N,\n+                       Pragma_Enabled\n+                         (Parent (Associated_Node (Pragma_Identifier (N)))));\n+                  end if;\n+\n                   Save_Global_Descendant (Field1 (N));\n                   Save_Global_Descendant (Field2 (N));\n                   Save_Global_Descendant (Field3 (N));"}, {"sha": "147a920ab6c87e08ee17d086d73916d9565ae4ae", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -46,6 +46,7 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Output;   use Output;\n+with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -1393,9 +1394,12 @@ package body Sem_Prag is\n             Pragma_Misplaced;\n          end if;\n \n-         --  Record whether pragma is enabled\n+         --  Record if pragma is enabled\n \n-         Set_Pragma_Enabled (N, Check_Enabled (Pname));\n+         if Check_Enabled (Pname) then\n+            Set_Pragma_Enabled (N);\n+            Set_SCO_Pragma_Enabled (Loc);\n+         end if;\n \n          --  If we are within an inlined body, the legality of the pragma\n          --  has been checked already.\n@@ -5776,8 +5780,12 @@ package body Sem_Prag is\n             --  is to deal with pragma Assert rewritten as a Check pragma.\n \n             Check_On := Check_Enabled (Chars (Get_Pragma_Arg (Arg1)));\n-            Set_Pragma_Enabled (N, Check_On);\n-            Set_Pragma_Enabled (Original_Node (N), Check_On);\n+\n+            if Check_On then\n+               Set_Pragma_Enabled (N);\n+               Set_Pragma_Enabled (Original_Node (N));\n+               Set_SCO_Pragma_Enabled (Loc);\n+            end if;\n \n             --  If expansion is active and the check is not enabled then we\n             --  rewrite the Check as:"}, {"sha": "1ad7c3c2f495511417d24e481dc08d22124dd965", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 76, "deletions": 3, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -23,7 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Back_End; use Back_End;\n with Debug;    use Debug;\n with Lib;      use Lib;\n with Osint;    use Osint;\n@@ -39,14 +38,57 @@ with System.WCh_Con; use System.WCh_Con;\n \n package body Switch.C is\n \n+   type Arg_Array is array (Nat) of Big_String_Ptr;\n+   type Arg_Array_Ptr is access Arg_Array;\n+   --  Types to access compiler arguments\n+\n+   save_argc : Nat;\n+   pragma Import (C, save_argc);\n+   --  Saved value of argc (number of arguments), imported from toplev.c\n+\n+   save_argv : Arg_Array_Ptr;\n+   pragma Import (C, save_argv);\n+   --  Saved value of argv (argument pointers), imported from toplev.c\n+\n    RTS_Specified : String_Access := null;\n    --  Used to detect multiple use of --RTS= flag\n \n+   function Len_Arg (Arg : Pos) return Nat;\n+   --  Determine length of argument number Arg on original gnat1 command line\n+\n+   function Switch_Subsequently_Cancelled\n+     (C        : String;\n+      Arg_Rank : Pos)\n+      return Boolean;\n+   --  This function is called from Scan_Front_End_Switches. It determines if\n+   --  the switch currently being scanned is followed by a switch of the form\n+   --  \"-gnat-\" & C, where C is the argument. If so, then True is returned,\n+   --  and Scan_Front_End_Switches will cancel the effect of the switch. If\n+   --  no such switch is found, False is returned.\n+\n+   -------------\n+   -- Len_Arg --\n+   -------------\n+\n+   function Len_Arg (Arg : Pos) return Nat is\n+   begin\n+      for J in 1 .. Nat'Last loop\n+         if save_argv (Arg).all (Natural (J)) = ASCII.NUL then\n+            return J - 1;\n+         end if;\n+      end loop;\n+\n+      raise Program_Error;\n+   end Len_Arg;\n+\n    -----------------------------\n    -- Scan_Front_End_Switches --\n    -----------------------------\n \n-   procedure Scan_Front_End_Switches (Switch_Chars : String) is\n+   procedure Scan_Front_End_Switches\n+     (Switch_Chars : String;\n+      Arg_Rank     : Pos)\n+   is\n       First_Switch : Boolean := True;\n       --  False for all but first switch\n \n@@ -665,7 +707,7 @@ package body Switch.C is\n \n                --  Skip processing if cancelled by subsequent -gnat-p\n \n-               if Switch_Subsequently_Cancelled (\"p\") then\n+               if Switch_Subsequently_Cancelled (\"p\", Arg_Rank) then\n                   Store_Switch := False;\n \n                else\n@@ -1078,4 +1120,35 @@ package body Switch.C is\n       end if;\n    end Scan_Front_End_Switches;\n \n+   -----------------------------------\n+   -- Switch_Subsequently_Cancelled --\n+   -----------------------------------\n+\n+   function Switch_Subsequently_Cancelled\n+     (C        : String;\n+      Arg_Rank : Pos)\n+      return Boolean\n+   is\n+      Arg : Pos;\n+\n+   begin\n+      Arg := Arg_Rank + 1;\n+      while Arg < save_argc loop\n+         declare\n+            Argv_Ptr : constant Big_String_Ptr := save_argv (Arg);\n+            Argv_Len : constant Nat            := Len_Arg (Arg);\n+            Argv     : constant String         :=\n+                         Argv_Ptr (1 .. Natural (Argv_Len));\n+         begin\n+            if Argv = \"-gnat-\" & C then\n+               return True;\n+            end if;\n+         end;\n+\n+         Arg := Arg + 1;\n+      end loop;\n+\n+      return False;\n+   end Switch_Subsequently_Cancelled;\n+\n end Switch.C;"}, {"sha": "126183e6ca6a5aadd0bed8990962cbdaf0b220b4", "filename": "gcc/ada/switch-c.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fswitch-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d/gcc%2Fada%2Fswitch-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.ads?ref=b26be063b3ef38c6ddc67e68992a4ecd9c92cd8d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,13 +31,18 @@\n \n package Switch.C is\n \n-   procedure Scan_Front_End_Switches (Switch_Chars : String);\n+   procedure Scan_Front_End_Switches\n+     (Switch_Chars : String;\n+      Arg_Rank     : Pos);\n    --  Procedures to scan out front end switches stored in the given string.\n    --  The first character is known to be a valid switch character, and there\n    --  are no blanks or other switch terminator characters in the string, so\n    --  the entire string should consist of valid switch characters, except that\n    --  an optional terminating NUL character is allowed. A bad switch causes\n    --  a fatal error exit and control does not return. The call also sets\n-   --  Usage_Requested to True if a ? switch is encountered.\n+   --  Usage_Requested to True if a switch -gnath is encountered.\n+   --  Arg_Rank is the position of the switch in the command line arguments.\n+   --  It is used for certain switches -gnatx to check if a subsequent switch\n+   --  -gnat-x cancels the switch -gnatx.\n \n end Switch.C;"}]}