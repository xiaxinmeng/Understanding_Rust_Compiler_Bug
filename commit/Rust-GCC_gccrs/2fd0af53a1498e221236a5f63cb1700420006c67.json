{"sha": "2fd0af53a1498e221236a5f63cb1700420006c67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkMGFmNTNhMTQ5OGUyMjEyMzZhNWY2M2NiMTcwMDQyMDAwNmM2Nw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-02-09T19:39:35Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-02-09T19:39:35Z"}, "message": "reload.c (find_reloads_toplev): Handle arbitrary non-paradoxical SUBREGs of CONST_INTs.\n\n\t* reload.c (find_reloads_toplev): Handle arbitrary non-paradoxical\n\tSUBREGs of CONST_INTs.\n\nFrom-SVN: r17809", "tree": {"sha": "779a35f1417b6e7f4e3c864e530815c72d8d5e57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/779a35f1417b6e7f4e3c864e530815c72d8d5e57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fd0af53a1498e221236a5f63cb1700420006c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd0af53a1498e221236a5f63cb1700420006c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd0af53a1498e221236a5f63cb1700420006c67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd0af53a1498e221236a5f63cb1700420006c67/comments", "author": null, "committer": null, "parents": [{"sha": "a96c354489da8ca6529d8c4c31e5b42b81d591fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96c354489da8ca6529d8c4c31e5b42b81d591fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96c354489da8ca6529d8c4c31e5b42b81d591fa"}], "stats": {"total": 30, "additions": 29, "deletions": 1}, "files": [{"sha": "56cd65e77b5205f9eeb258efdf44a412f59565a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd0af53a1498e221236a5f63cb1700420006c67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd0af53a1498e221236a5f63cb1700420006c67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fd0af53a1498e221236a5f63cb1700420006c67", "patch": "@@ -1,3 +1,8 @@\n+Tue Feb 10 03:35:43 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload.c (find_reloads_toplev): Handle arbitrary non-paradoxical\n+\tSUBREGs of CONST_INTs.\n+\n Mon Feb  9 17:52:36 1998  John Carr  <jfc@mit.edu>\n \n \t* mips.c (print_operand, function_prologue): Make printf format"}, {"sha": "22c8c4e26a17d7aebad7701248e2c0ebbeb7de0b", "filename": "gcc/reload.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd0af53a1498e221236a5f63cb1700420006c67/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd0af53a1498e221236a5f63cb1700420006c67/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=2fd0af53a1498e221236a5f63cb1700420006c67", "patch": "@@ -1,5 +1,5 @@\n /* Search an insn for pseudo regs that must be in hard regs and are not.\n-   Copyright (C) 1987, 88, 89, 92-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-7, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -4163,6 +4163,29 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t\t\t\t     GET_MODE (SUBREG_REG (x)))) != 0)\n \treturn tem;\n \n+      /* If the SUBREG is wider than a word, the above test will fail.\n+\t For example, we might have a SImode SUBREG of a DImode SUBREG_REG\n+\t for a 16 bit target, or a DImode SUBREG of a TImode SUBREG_REG for\n+\t a 32 bit target.  We still can - and have to - handle this\n+\t for non-paradoxical subregs of CONST_INTs.  */\n+      if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n+\t  && reg_equiv_constant[regno] != 0\n+\t  && GET_CODE (reg_equiv_constant[regno]) == CONST_INT\n+\t  && (GET_MODE_SIZE (GET_MODE (x))\n+\t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+\t  {\n+\t    int shift = SUBREG_WORD (x) * BITS_PER_WORD;\n+\t    if (WORDS_BIG_ENDIAN)\n+\t      shift = (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t       - GET_MODE_BITSIZE (GET_MODE (x))\n+\t\t       - shift);\n+\t    /* Here we use the knowledge that CONST_INTs have a\n+\t       HOST_WIDE_INT field.  */\n+\t    if (shift >= HOST_BITS_PER_WIDE_INT)\n+\t      shift = HOST_BITS_PER_WIDE_INT - 1;\n+\t    return GEN_INT (INTVAL (reg_equiv_constant[regno]) >> shift);\n+\t  }\n+\n       if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n \t  && reg_equiv_constant[regno] != 0\n \t  && GET_MODE (reg_equiv_constant[regno]) == VOIDmode)"}]}