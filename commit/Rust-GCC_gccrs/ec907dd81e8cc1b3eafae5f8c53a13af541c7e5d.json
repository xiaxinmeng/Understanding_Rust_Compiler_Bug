{"sha": "ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM5MDdkZDgxZThjYzFiM2VhZmFlNWY4YzUzYTEzYWY1NDFjN2U1ZA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-10-31T15:35:31Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-31T15:35:31Z"}, "message": "alias.c (init_alias_analysis): Add struct_value_incoming_rtx and static_chain_rtx into the potential base...\n\n        * alias.c (init_alias_analysis): Add struct_value_incoming_rtx\n        and static_chain_rtx into the potential base values array if\n        they are registers.\nFixes bugs exposed by improved alias propagation code.\n\n        * alias.c (new_reg_base_value): New array of potential base values.\n        (unique_id): Now file scoped static.\n        (find_base_value, case REG): Return the value in reg_base_value\n        array for the REG if it exists.  Else, return the value from\n        new_reg_base_value if copying args and REG is a hard register.\n        (find_base_value, case PLUS): If either operand of the PLUS is\n        a REG, try to get its base value.  Handle base + index and\n        index + base.\n        (record_set): Use new_reg_base_value instead of reg_base_value.\n        (init_alias_analysis): Allocate space for new_reg_base_value too.\n        Rework code to iterate over the insns propagating base value\n        information until nothing changes.\nImprove alias propagation significantly.\n\nFrom-SVN: r16250", "tree": {"sha": "34a4161112e811f269a44b64d9fa825b82289b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34a4161112e811f269a44b64d9fa825b82289b0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d/comments", "author": null, "committer": null, "parents": [{"sha": "8c316ae21c35468696948951be572bc9a694ad57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c316ae21c35468696948951be572bc9a694ad57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c316ae21c35468696948951be572bc9a694ad57"}], "stats": {"total": 208, "additions": 155, "deletions": 53}, "files": [{"sha": "be80490e469767b6dcd663e9bbd6715e5ff243e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d", "patch": "@@ -1,5 +1,22 @@\n Fri Oct 31 07:10:09 1997  Jeffrey A Law  (law@cygnus.com)\n \n+\t* alias.c (init_alias_analysis): Add struct_value_incoming_rtx\n+\tand static_chain_rtx into the potential base values array if\n+\tthey are registers.\n+\n+\t* alias.c (new_reg_base_value): New array of potential base values.\n+\t(unique_id): Now file scoped static.\n+\t(find_base_value, case REG): Return the value in reg_base_value\n+\tarray for the REG if it exists.  Else, return the value from\n+\tnew_reg_base_value if copying args and REG is a hard register.\n+\t(find_base_value, case PLUS): If either operand of the PLUS is\n+\ta REG, try to get its base value.  Handle base + index and\n+\tindex + base.\n+\t(record_set): Use new_reg_base_value instead of reg_base_value.\n+\t(init_alias_analysis): Allocate space for new_reg_base_value too.\n+\tRework code to iterate over the insns propagating base value\n+\tinformation until nothing changes.\n+\n \t* global.c (global_alloc): Free the conflict matrix after\n \treload has finished.\n "}, {"sha": "73e2668880d94a4c92d344cce1cd130700f684c3", "filename": "gcc/alias.c", "status": "modified", "additions": 138, "deletions": 53, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ec907dd81e8cc1b3eafae5f8c53a13af541c7e5d", "patch": "@@ -52,6 +52,7 @@ static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n    other special value. */\n \n rtx *reg_base_value;\n+rtx *new_reg_base_value;\n unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n #define REG_BASE_VALUE(X) \\\n \t(REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n@@ -94,12 +95,16 @@ find_base_value (src)\n       return src;\n \n     case REG:\n+      /* If this REG is related to a known base value, return it.  */\n+      if (reg_base_value[REGNO (src)])\n+\treturn reg_base_value[REGNO (src)];\n+\n       /* At the start of a function argument registers have known base\n \t values which may be lost later.  Returning an ADDRESS\n \t expression here allows optimization based on argument values\n \t even when the argument registers are used for other purposes.  */\n       if (REGNO (src) < FIRST_PSEUDO_REGISTER && copying_arguments)\n-\treturn reg_base_value[REGNO (src)];\n+\treturn new_reg_base_value[REGNO (src)];\n       return src;\n \n     case MEM:\n@@ -122,21 +127,45 @@ find_base_value (src)\n     case PLUS:\n     case MINUS:\n       {\n-\trtx src_0 = XEXP (src, 0), src_1 = XEXP (src, 1);\n+\trtx temp, src_0 = XEXP (src, 0), src_1 = XEXP (src, 1);\n+\n+\t/* If either operand is a REG, then see if we already have\n+\t   a known value for it.  */\n+\tif (GET_CODE (src_0) == REG)\n+\t  {\n+\t    temp = find_base_value (src_0);\n+\t    if (temp)\n+\t      src_0 = temp;\n+\t  }\n+\n+\tif (GET_CODE (src_1) == REG)\n+\t  {\n+\t    temp = find_base_value (src_1);\n+\t    if (temp)\n+\t      src_1 = temp;\n+\t  }\n \n \t/* Guess which operand is the base address.\n \n-\t   If the first operand is a symbol or the second operand is\n-\t   an integer, the first operand is the base address.  Else if\n-\t   either operand is a register marked as a pointer, it is the\n-\t   base address.  */\n+\t   If either operand is a symbol, then it is the base.  If\n+\t   either operand is a CONST_INT, then the other is the base.  */\n \n \tif (GET_CODE (src_1) == CONST_INT\n \t    || GET_CODE (src_0) == SYMBOL_REF\n \t    || GET_CODE (src_0) == LABEL_REF\n \t    || GET_CODE (src_0) == CONST)\n \t  return find_base_value (src_0);\n \n+\tif (GET_CODE (src_0) == CONST_INT\n+\t    || GET_CODE (src_1) == SYMBOL_REF\n+\t    || GET_CODE (src_1) == LABEL_REF\n+\t    || GET_CODE (src_1) == CONST)\n+\t  return find_base_value (src_1);\n+\n+\t/* This might not be necessary anymore. \n+\n+\t   If either operand is a REG that is a known pointer, then it\n+\t   is the base.  */\n \tif (GET_CODE (src_0) == REG && REGNO_POINTER_FLAG (REGNO (src_0)))\n \t  return find_base_value (src_0);\n \n@@ -171,6 +200,9 @@ find_base_value (src)\n    register N has been set in this function.  */\n static char *reg_seen;\n \n+/* */\n+static int unique_id;\n+\n static void\n record_set (dest, set)\n      rtx dest, set;\n@@ -190,21 +222,20 @@ record_set (dest, set)\n \t set).  */\n       if (GET_CODE (set) == CLOBBER)\n \t{\n-\t  reg_base_value[regno] = 0;\n+\t  new_reg_base_value[regno] = 0;\n \t  return;\n \t}\n       src = SET_SRC (set);\n     }\n   else\n     {\n-      static int unique_id;\n       if (reg_seen[regno])\n \t{\n-\t  reg_base_value[regno] = 0;\n+\t  new_reg_base_value[regno] = 0;\n \t  return;\n \t}\n       reg_seen[regno] = 1;\n-      reg_base_value[regno] = gen_rtx (ADDRESS, Pmode,\n+      new_reg_base_value[regno] = gen_rtx (ADDRESS, Pmode,\n \t\t\t\t       GEN_INT (unique_id++));\n       return;\n     }\n@@ -215,27 +246,27 @@ record_set (dest, set)\n      extern int x, y;  int *p = &x; p += (&y-&x);\n      ANSI C does not allow computing the difference of addresses\n      of distinct top level objects.  */\n-  if (reg_base_value[regno])\n+  if (new_reg_base_value[regno])\n     switch (GET_CODE (src))\n       {\n       case LO_SUM:\n       case PLUS:\n       case MINUS:\n \tif (XEXP (src, 0) != dest && XEXP (src, 1) != dest)\n-\t  reg_base_value[regno] = 0;\n+\t  new_reg_base_value[regno] = 0;\n \tbreak;\n       case AND:\n \tif (XEXP (src, 0) != dest || GET_CODE (XEXP (src, 1)) != CONST_INT)\n-\t  reg_base_value[regno] = 0;\n+\t  new_reg_base_value[regno] = 0;\n \tbreak;\n       default:\n-\treg_base_value[regno] = 0;\n+\tnew_reg_base_value[regno] = 0;\n \tbreak;\n       }\n   /* If this is the first set of a register, record the value.  */\n   else if ((regno >= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])\n-\t   && ! reg_seen[regno] && reg_base_value[regno] == 0)\n-    reg_base_value[regno] = find_base_value (src);\n+\t   && ! reg_seen[regno] && new_reg_base_value[regno] == 0)\n+    new_reg_base_value[regno] = find_base_value (src);\n \n   reg_seen[regno] = 1;\n }\n@@ -949,9 +980,41 @@ init_alias_analysis ()\n \t registers.  */\n       reg_base_value_size = maxreg * 2;\n       reg_base_value = (rtx *)oballoc (reg_base_value_size * sizeof (rtx));\n+      new_reg_base_value = (rtx *)alloca (reg_base_value_size * sizeof (rtx));\n       reg_seen = (char *)alloca (reg_base_value_size);\n       bzero ((char *) reg_base_value, reg_base_value_size * sizeof (rtx));\n-      bzero (reg_seen, reg_base_value_size);\n+    }\n+\n+  /* The basic idea is that each pass through this loop will use the\n+     \"constant\" information from the previous pass to propagate alias\n+     information through another level of assignments.\n+\n+     This could get expensive if the assignment chains are long.  Maybe\n+     we should throttle the number of iterations, possibly based on\n+     the optimization level.\n+\n+     We could propagate more information in the first pass by making use\n+     of REG_N_SETS to determine immediately that the alias information\n+     for a pseudo is \"constant\".  */\n+  changed = 1;\n+  while (changed)\n+    {\n+      /* Assume nothing will change this iteration of the loop.  */\n+      changed = 0;\n+\n+      /* Wipe the potential alias information clean for this pass.  */\n+      bzero ((char *) new_reg_base_value, reg_base_value_size * sizeof (rtx));\n+\n+      /* Wipe the reg_seen array clean.  */\n+      bzero ((char *) reg_seen, reg_base_value_size);\n+\n+      /* We want to assign the same IDs each iteration of this loop, so\n+\t start counting from zero each iteration of the loop.  */\n+      unique_id = 0;\n+\n+      /* We're at the start of the funtion each iteration through the\n+\t loop, so we're copying arguments.  */\n+      copying_arguments = 1;\n \n       /* Mark all hard registers which may contain an address.\n \t The stack, frame and argument pointers may contain an address.\n@@ -968,52 +1031,73 @@ init_alias_analysis ()\n \t   argument.  FUNCTION_ARG_REGNO_P tests outgoing register\n \t   numbers, so translate if necessary due to register windows. */\n \tif (FUNCTION_ARG_REGNO_P (OUTGOING_REGNO (i)) && HARD_REGNO_MODE_OK (i, Pmode))\n-\t  reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n-\t\t\t\t       gen_rtx (REG, Pmode, i));\n+\t  new_reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n+\t\t\t\t\t   gen_rtx (REG, Pmode, i));\n \n-      reg_base_value[STACK_POINTER_REGNUM]\n+      new_reg_base_value[STACK_POINTER_REGNUM]\n \t= gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n-      reg_base_value[ARG_POINTER_REGNUM]\n+      new_reg_base_value[ARG_POINTER_REGNUM]\n \t= gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n-      reg_base_value[FRAME_POINTER_REGNUM]\n+      new_reg_base_value[FRAME_POINTER_REGNUM]\n \t= gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-      reg_base_value[HARD_FRAME_POINTER_REGNUM]\n+      new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n \t= gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n #endif\n-    }\n-\n-  copying_arguments = 1;\n-  /* Fill in the entries with known constant values.  */\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    {\n-      if (flag_alias_check && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+      if (struct_value_incoming_rtx\n+\t  && GET_CODE (struct_value_incoming_rtx) == REG)\n+      new_reg_base_value[REGNO (struct_value_incoming_rtx)]\n+\t= gen_rtx (ADDRESS, Pmode, struct_value_incoming_rtx);\n+\n+      if (static_chain_rtx\n+\t  && GET_CODE (static_chain_rtx) == REG)\n+      new_reg_base_value[REGNO (static_chain_rtx)]\n+\t= gen_rtx (ADDRESS, Pmode, static_chain_rtx);\n+\n+      /* Walk the insns adding values to the new_reg_base_value array.  */\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n-\t  /* If this insn has a noalias note, process it,  Otherwise,\n-\t     scan for sets.  A simple set will have no side effects\n-\t     which could change the base value of any other register. */\n-\t  rtx noalias_note;\n-\t  if (GET_CODE (PATTERN (insn)) == SET\n-\t      && (noalias_note = find_reg_note (insn, REG_NOALIAS, NULL_RTX)))\n-\t    record_set (SET_DEST (PATTERN (insn)), 0);\n-\t  else\n-\t    note_stores (PATTERN (insn), record_set);\n+\t  if (flag_alias_check && GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    {\n+\t      /* If this insn has a noalias note, process it,  Otherwise,\n+\t         scan for sets.  A simple set will have no side effects\n+\t         which could change the base value of any other register. */\n+\t      rtx noalias_note;\n+\t      if (GET_CODE (PATTERN (insn)) == SET\n+\t\t  && (noalias_note = find_reg_note (insn,\n+\t\t\t\t\t\t    REG_NOALIAS, NULL_RTX)))\n+\t\trecord_set (SET_DEST (PATTERN (insn)), 0);\n+\t      else\n+\t\tnote_stores (PATTERN (insn), record_set);\n+\t    }\n+\t  else if (GET_CODE (insn) == NOTE\n+\t\t   && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+\t    copying_arguments = 0;\n+\n+\t  if ((set = single_set (insn)) != 0\n+\t      && GET_CODE (SET_DEST (set)) == REG\n+\t      && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n+\t      && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n+\t\t   && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n+\t\t  || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n+\t      && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+\t    {\n+\t      int regno = REGNO (SET_DEST (set));\n+\t      reg_known_value[regno] = XEXP (note, 0);\n+\t      reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t    }\n \t}\n-      else if (GET_CODE (insn) == NOTE\n-\t       && NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n-\tcopying_arguments = 0;\n-\n-      if ((set = single_set (insn)) != 0\n-\t  && GET_CODE (SET_DEST (set)) == REG\n-\t  && REGNO (SET_DEST (set)) >= FIRST_PSEUDO_REGISTER\n-\t  && (((note = find_reg_note (insn, REG_EQUAL, 0)) != 0\n-\t       && REG_N_SETS (REGNO (SET_DEST (set))) == 1)\n-\t      || (note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) != 0)\n-\t  && GET_CODE (XEXP (note, 0)) != EXPR_LIST)\n+\n+      /* Now propagate values from new_reg_base_value to reg_base_value.  */\n+      for (i = 0; i < reg_base_value_size; i++)\n \t{\n-\t  int regno = REGNO (SET_DEST (set));\n-\t  reg_known_value[regno] = XEXP (note, 0);\n-\t  reg_known_equiv_p[regno] = REG_NOTE_KIND (note) == REG_EQUIV;\n+\t  if (new_reg_base_value[i]\n+\t      && new_reg_base_value[i] != reg_base_value[i]\n+\t      && !rtx_equal_p (new_reg_base_value[i], reg_base_value[i]))\n+\t    {\n+\t      reg_base_value[i] = new_reg_base_value[i];\n+\t      changed = 1;\n+\t    }\n \t}\n     }\n \n@@ -1051,6 +1135,7 @@ init_alias_analysis ()\n     }\n   while (changed);\n \n+  new_reg_base_value = 0;\n   reg_seen = 0;\n }\n "}]}