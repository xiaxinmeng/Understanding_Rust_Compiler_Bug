{"sha": "e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAxZmZiNDdjNmZlYzZkNTJmMjU0MzkwYmY4NjNiNGNhMGZhMzJlMg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2019-01-08T17:37:51Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2019-01-08T17:37:51Z"}, "message": "PR c++/88548 - this accepted in static member functions.\n\n\t* parser.c (cp_debug_parser): Adjust printing of\n\tlocal_variables_forbidden_p.\n\t(cp_parser_new): Set local_variables_forbidden_p to 0 rather than false.\n\t(cp_parser_primary_expression): When checking\n\tlocal_variables_forbidden_p, use THIS_FORBIDDEN or\n\tLOCAL_VARS_FORBIDDEN.\n\t(cp_parser_lambda_body): Update the type of\n\tlocal_variables_forbidden_p.  Set it to 0 rather than false.\n\t(cp_parser_condition): Adjust call to cp_parser_declarator.\n\t(cp_parser_explicit_instantiation): Likewise.\n\t(cp_parser_init_declarator): Likewise.\n\t(cp_parser_declarator): New parameter.  Use it.\n\t(cp_parser_direct_declarator): New parameter.  Use it to set\n\tlocal_variables_forbidden_p.  Adjust call to cp_parser_declarator.\n\t(cp_parser_type_id_1): Adjust call to cp_parser_declarator.\n\t(cp_parser_parameter_declaration): Likewise.\n\t(cp_parser_default_argument): Update the type of\n\tlocal_variables_forbidden_p.  Set it to LOCAL_VARS_AND_THIS_FORBIDDEN\n\trather than true.\n\t(cp_parser_member_declaration): Tell cp_parser_declarator if we saw\n\t'static' or 'friend'.\n\t(cp_parser_exception_declaration): Adjust call to cp_parser_declarator.\n\t(cp_parser_late_parsing_default_args): Update the type of\n\tlocal_variables_forbidden_p.  Set it to LOCAL_VARS_AND_THIS_FORBIDDEN\n\trather than true.\n\t(cp_parser_cache_defarg): Adjust call to cp_parser_declarator.\n\t(cp_parser_objc_class_ivars): Likewise.\n\t(cp_parser_objc_struct_declaration): Likewise.\n\t(cp_parser_omp_for_loop_init): Likewise.\n\t* parser.h (cp_parser): Change the type of local_variables_forbidden_p\n\tto unsigned char.\n\t(LOCAL_VARS_FORBIDDEN, LOCAL_VARS_AND_THIS_FORBIDDEN, THIS_FORBIDDEN):\n\tDefine.\n\n\t* g++.dg/cpp0x/this1.C: New test.\n\nFrom-SVN: r267731", "tree": {"sha": "56f5cd1553b0dcfb2afbd48c57e0788f8ba567dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56f5cd1553b0dcfb2afbd48c57e0788f8ba567dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a5474ba24dad14f32e2adfa5fe4d8431df77d4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5474ba24dad14f32e2adfa5fe4d8431df77d4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5474ba24dad14f32e2adfa5fe4d8431df77d4e"}], "stats": {"total": 189, "additions": 153, "deletions": 36}, "files": [{"sha": "f3b5dbe68bc31ff401b005aa063fceca3526b612", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "patch": "@@ -1,3 +1,40 @@\n+2019-01-08  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/88548 - this accepted in static member functions.\n+\t* parser.c (cp_debug_parser): Adjust printing of\n+\tlocal_variables_forbidden_p.\n+\t(cp_parser_new): Set local_variables_forbidden_p to 0 rather than false.\n+\t(cp_parser_primary_expression): When checking\n+\tlocal_variables_forbidden_p, use THIS_FORBIDDEN or\n+\tLOCAL_VARS_FORBIDDEN.\n+\t(cp_parser_lambda_body): Update the type of\n+\tlocal_variables_forbidden_p.  Set it to 0 rather than false.\n+\t(cp_parser_condition): Adjust call to cp_parser_declarator.\n+\t(cp_parser_explicit_instantiation): Likewise.\n+\t(cp_parser_init_declarator): Likewise.\n+\t(cp_parser_declarator): New parameter.  Use it.\n+\t(cp_parser_direct_declarator): New parameter.  Use it to set\n+\tlocal_variables_forbidden_p.  Adjust call to cp_parser_declarator.\n+\t(cp_parser_type_id_1): Adjust call to cp_parser_declarator.\n+\t(cp_parser_parameter_declaration): Likewise.\n+\t(cp_parser_default_argument): Update the type of\n+\tlocal_variables_forbidden_p.  Set it to LOCAL_VARS_AND_THIS_FORBIDDEN\n+\trather than true.\n+\t(cp_parser_member_declaration): Tell cp_parser_declarator if we saw\n+\t'static' or 'friend'.\n+\t(cp_parser_exception_declaration): Adjust call to cp_parser_declarator.\n+\t(cp_parser_late_parsing_default_args): Update the type of\n+\tlocal_variables_forbidden_p.  Set it to LOCAL_VARS_AND_THIS_FORBIDDEN\n+\trather than true.\n+\t(cp_parser_cache_defarg): Adjust call to cp_parser_declarator.\n+\t(cp_parser_objc_class_ivars): Likewise.\n+\t(cp_parser_objc_struct_declaration): Likewise.\n+\t(cp_parser_omp_for_loop_init): Likewise.\n+\t* parser.h (cp_parser): Change the type of local_variables_forbidden_p\n+\tto unsigned char.\n+\t(LOCAL_VARS_FORBIDDEN, LOCAL_VARS_AND_THIS_FORBIDDEN, THIS_FORBIDDEN):\n+\tDefine.\n+\n 2019-01-08  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (start_decl): Improve permerror location."}, {"sha": "ca75c010e22e32fe25ad777a3d50596d5b3bf08a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "patch": "@@ -536,9 +536,12 @@ cp_debug_parser (FILE *file, cp_parser *parser)\n \t\t\t      parser->allow_non_integral_constant_expression_p);\n   cp_debug_print_flag (file, \"Seen non-constant expression\",\n \t\t\t      parser->non_integral_constant_expression_p);\n-  cp_debug_print_flag (file, \"Local names and 'this' forbidden in \"\n-\t\t\t      \"current context\",\n-\t\t\t      parser->local_variables_forbidden_p);\n+  cp_debug_print_flag (file, \"Local names forbidden in current context\",\n+\t\t\t      (parser->local_variables_forbidden_p\n+\t\t\t       & LOCAL_VARS_FORBIDDEN));\n+  cp_debug_print_flag (file, \"'this' forbidden in current context\",\n+\t\t\t      (parser->local_variables_forbidden_p\n+\t\t\t       & THIS_FORBIDDEN));\n   cp_debug_print_flag (file, \"In unbraced linkage specification\",\n \t\t\t      parser->in_unbraced_linkage_specification_p);\n   cp_debug_print_flag (file, \"Parsing a declarator\",\n@@ -2203,9 +2206,10 @@ static tree cp_parser_init_declarator\n    location_t *, tree *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, cp_parser_flags, int *, bool *,\n-   bool, bool);\n+   bool, bool, bool);\n static cp_declarator *cp_parser_direct_declarator\n-  (cp_parser *, cp_parser_declarator_kind, cp_parser_flags, int *, bool, bool);\n+  (cp_parser *, cp_parser_declarator_kind, cp_parser_flags, int *, bool, bool,\n+   bool);\n static enum tree_code cp_parser_ptr_operator\n   (cp_parser *, tree *, cp_cv_quals *, tree *);\n static cp_cv_quals cp_parser_cv_qualifier_seq_opt\n@@ -3951,7 +3955,7 @@ cp_parser_new (void)\n   parser->non_integral_constant_expression_p = false;\n \n   /* Local variable names are not forbidden.  */\n-  parser->local_variables_forbidden_p = false;\n+  parser->local_variables_forbidden_p = 0;\n \n   /* We are not processing an `extern \"C\"' declaration.  */\n   parser->in_unbraced_linkage_specification_p = false;\n@@ -5405,7 +5409,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  /* Recognize the `this' keyword.  */\n \tcase RID_THIS:\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  if (parser->local_variables_forbidden_p)\n+\t  if (parser->local_variables_forbidden_p & THIS_FORBIDDEN)\n \t    {\n \t      error_at (token->location,\n \t\t\t\"%<this%> may not be used in this context\");\n@@ -5681,14 +5685,14 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t      template <int N> struct A {\n \t\t\tint a[B<N>::i];\n \t\t      };\n-\t\t     \n+\n \t\t   is accepted.  At template-instantiation time, we\n \t\t   will check that B<N>::i is actually a constant.  */\n \t\treturn decl;\n \t      }\n \t    /* Check to see if DECL is a local variable in a context\n \t       where that is forbidden.  */\n-\t    if (parser->local_variables_forbidden_p\n+\t    if ((parser->local_variables_forbidden_p & LOCAL_VARS_FORBIDDEN)\n \t\t&& local_variable_p (decl))\n \t      {\n \t\terror_at (id_expression.get_location (),\n@@ -10928,7 +10932,8 @@ static void\n cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n {\n   bool nested = (current_function_decl != NULL_TREE);\n-  bool local_variables_forbidden_p = parser->local_variables_forbidden_p;\n+  unsigned char local_variables_forbidden_p\n+    = parser->local_variables_forbidden_p;\n   bool in_function_body = parser->in_function_body;\n \n   /* The body of a lambda-expression is not a subexpression of the enclosing\n@@ -10945,7 +10950,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n   vec<tree> omp_privatization_save;\n   save_omp_privatization_clauses (omp_privatization_save);\n   /* Clear this in case we're in the middle of a default argument.  */\n-  parser->local_variables_forbidden_p = false;\n+  parser->local_variables_forbidden_p = 0;\n   parser->in_function_body = true;\n \n   {\n@@ -11990,7 +11995,8 @@ cp_parser_condition (cp_parser* parser)\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t\t /*parenthesized_p=*/NULL,\n \t\t\t\t\t /*member_p=*/false,\n-\t\t\t\t\t /*friend_p=*/false);\n+\t\t\t\t\t /*friend_p=*/false,\n+\t\t\t\t\t /*static_p=*/false);\n       /* Parse the attributes.  */\n       attributes = cp_parser_attributes_opt (parser);\n       /* Parse the asm-specification.  */\n@@ -17123,7 +17129,8 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n \t\t\t\t/*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t/*parenthesized_p=*/NULL,\n \t\t\t\t/*member_p=*/false,\n-\t\t\t\t/*friend_p=*/false);\n+\t\t\t\t/*friend_p=*/false,\n+\t\t\t\t/*static_p=*/false);\n       if (declares_class_or_enum & 2)\n \tcp_parser_check_for_definition_in_return_type (declarator,\n \t\t\t\t\t\t       decl_specifiers.type,\n@@ -20068,7 +20075,7 @@ cp_parser_init_declarator (cp_parser* parser,\n     = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t    flags, &ctor_dtor_or_conv_p,\n \t\t\t    /*parenthesized_p=*/NULL,\n-\t\t\t    member_p, friend_p);\n+\t\t\t    member_p, friend_p, /*static_p=*/false);\n   /* Gather up the deferred checks.  */\n   stop_deferring_access_checks ();\n \n@@ -20486,15 +20493,17 @@ cp_parser_init_declarator (cp_parser* parser,\n \n    MEMBER_P is true iff this declarator is a member-declarator.\n \n-   FRIEND_P is true iff this declarator is a friend.  */\n+   FRIEND_P is true iff this declarator is a friend.\n+\n+   STATIC_P is true iff the keyword static was seen.  */\n \n static cp_declarator *\n cp_parser_declarator (cp_parser* parser,\n \t\t      cp_parser_declarator_kind dcl_kind,\n \t\t      cp_parser_flags flags,\n \t\t      int* ctor_dtor_or_conv_p,\n \t\t      bool* parenthesized_p,\n-\t\t      bool member_p, bool friend_p)\n+\t\t      bool member_p, bool friend_p, bool static_p)\n {\n   cp_declarator *declarator;\n   enum tree_code code;\n@@ -20536,7 +20545,7 @@ cp_parser_declarator (cp_parser* parser,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t\t /*parenthesized_p=*/NULL,\n \t\t\t\t\t /*member_p=*/false,\n-\t\t\t\t\t friend_p);\n+\t\t\t\t\t friend_p, /*static_p=*/false);\n \n       /* If we are parsing an abstract-declarator, we must handle the\n \t case where the dependent declarator is absent.  */\n@@ -20555,7 +20564,7 @@ cp_parser_declarator (cp_parser* parser,\n \t\t\t\t\t\t   CPP_OPEN_PAREN);\n       declarator = cp_parser_direct_declarator (parser, dcl_kind,\n \t\t\t\t\t\tflags, ctor_dtor_or_conv_p,\n-\t\t\t\t\t\tmember_p, friend_p);\n+\t\t\t\t\t\tmember_p, friend_p, static_p);\n     }\n \n   if (gnu_attributes && declarator && declarator != cp_error_declarator)\n@@ -20591,15 +20600,15 @@ cp_parser_declarator (cp_parser* parser,\n    of ambiguity we prefer an abstract declarator, as per\n    [dcl.ambig.res].\n    The parser flags FLAGS is used to control type-specifier parsing.\n-   CTOR_DTOR_OR_CONV_P, MEMBER_P, and FRIEND_P are\n+   CTOR_DTOR_OR_CONV_P, MEMBER_P, FRIEND_P, and STATIC_P are\n    as for cp_parser_declarator.  */\n \n static cp_declarator *\n cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t     cp_parser_declarator_kind dcl_kind,\n \t\t\t     cp_parser_flags flags,\n \t\t\t     int* ctor_dtor_or_conv_p,\n-\t\t\t     bool member_p, bool friend_p)\n+\t\t\t     bool member_p, bool friend_p, bool static_p)\n {\n   cp_token *token;\n   cp_declarator *declarator = NULL;\n@@ -20702,6 +20711,11 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  tree attrs;\n \t\t  bool memfn = (member_p || (pushed_scope\n \t\t\t\t\t     && CLASS_TYPE_P (pushed_scope)));\n+\t\t  unsigned char local_variables_forbidden_p\n+\t\t    = parser->local_variables_forbidden_p;\n+\t\t  /* 'this' is not allowed in static member functions.  */\n+\t\t  if (static_p || friend_p)\n+\t\t    parser->local_variables_forbidden_p |= THIS_FORBIDDEN;\n \n \t\t  is_declarator = true;\n \n@@ -20749,6 +20763,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t     return type, so are not those of the declared\n \t\t     function.  */\n \t\t  parser->default_arg_ok_p = false;\n+\n+\t\t  /* Restore the state of local_variables_forbidden_p.  */\n+\t\t  parser->local_variables_forbidden_p\n+\t\t    = local_variables_forbidden_p;\n \t\t}\n \n \t      /* Remove the function parms from scope.  */\n@@ -20779,7 +20797,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t= cp_parser_declarator (parser, dcl_kind, flags,\n \t\t\t\t\tctor_dtor_or_conv_p,\n \t\t\t\t\t/*parenthesized_p=*/NULL,\n-\t\t\t\t\tmember_p, friend_p);\n+\t\t\t\t\tmember_p, friend_p,\n+\t\t\t\t\t/*static_p=*/false);\n \t      parser->in_type_id_in_expr_p = saved_in_type_id_in_expr_p;\n \t      first = false;\n \t      /* Expect a `)'.  */\n@@ -21673,7 +21692,8 @@ cp_parser_type_id_1 (cp_parser *parser, cp_parser_flags flags,\n \t\t\t    CP_PARSER_FLAGS_NONE, NULL,\n \t\t\t    /*parenthesized_p=*/NULL,\n \t\t\t    /*member_p=*/false,\n-\t\t\t    /*friend_p=*/false);\n+\t\t\t    /*friend_p=*/false,\n+\t\t\t    /*static_p=*/false);\n   /* Check to see if there really was a declarator.  */\n   if (!cp_parser_parse_definitely (parser))\n     abstract_declarator = NULL;\n@@ -22258,7 +22278,8 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t\t parenthesized_p,\n \t\t\t\t\t /*member_p=*/false,\n-\t\t\t\t\t /*friend_p=*/false);\n+\t\t\t\t\t /*friend_p=*/false,\n+\t\t\t\t\t /*static_p=*/false);\n       parser->default_arg_ok_p = saved_default_arg_ok_p;\n       /* After the declarator, allow more attributes.  */\n       decl_specifiers.attributes\n@@ -22439,7 +22460,7 @@ cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n {\n   tree default_argument = NULL_TREE;\n   bool saved_greater_than_is_operator_p;\n-  bool saved_local_variables_forbidden_p;\n+  unsigned char saved_local_variables_forbidden_p;\n   bool non_constant_p, is_direct_init;\n \n   /* Make sure that PARSER->GREATER_THAN_IS_OPERATOR_P is\n@@ -22449,7 +22470,7 @@ cp_parser_default_argument (cp_parser *parser, bool template_parm_p)\n   /* Local variable names (and the `this' keyword) may not\n      appear in a default argument.  */\n   saved_local_variables_forbidden_p = parser->local_variables_forbidden_p;\n-  parser->local_variables_forbidden_p = true;\n+  parser->local_variables_forbidden_p = LOCAL_VARS_AND_THIS_FORBIDDEN;\n   /* Parse the assignment-expression.  */\n   if (template_parm_p)\n     push_deferring_access_checks (dk_no_deferred);\n@@ -24468,6 +24489,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      cp_declarator *declarator;\n \t      tree asm_specification;\n \t      int ctor_dtor_or_conv_p;\n+\t      bool static_p = (decl_specifiers.storage_class == sc_static);\n \n \t      /* Parse the declarator.  */\n \t      declarator\n@@ -24476,7 +24498,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t\t\t\t&ctor_dtor_or_conv_p,\n \t\t\t\t\t/*parenthesized_p=*/NULL,\n \t\t\t\t\t/*member_p=*/true,\n-\t\t\t\t\tfriend_p);\n+\t\t\t\t\tfriend_p, static_p);\n \n \t      /* If something went wrong parsing the declarator, make sure\n \t\t that we at least consume some tokens.  */\n@@ -25357,7 +25379,8 @@ cp_parser_exception_declaration (cp_parser* parser)\n \t\t\t\t       /*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t       /*parenthesized_p=*/NULL,\n \t\t\t\t       /*member_p=*/false,\n-\t\t\t\t       /*friend_p=*/false);\n+\t\t\t\t       /*friend_p=*/false,\n+\t\t\t\t       /*static_p=*/false);\n \n   /* Restore the saved message.  */\n   parser->type_definition_forbidden_message = saved_message;\n@@ -28602,7 +28625,7 @@ cp_parser_late_parsing_nsdmi (cp_parser *parser, tree field)\n static void\n cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n {\n-  bool saved_local_variables_forbidden_p;\n+  unsigned char saved_local_variables_forbidden_p;\n   tree parm, parmdecl;\n \n   /* While we're parsing the default args, we might (due to the\n@@ -28614,7 +28637,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n   /* Local variable names (and the `this' keyword) may not appear\n      in a default argument.  */\n   saved_local_variables_forbidden_p = parser->local_variables_forbidden_p;\n-  parser->local_variables_forbidden_p = true;\n+  parser->local_variables_forbidden_p = LOCAL_VARS_AND_THIS_FORBIDDEN;\n \n   push_defarg_context (fn);\n \n@@ -29693,7 +29716,8 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n \t\t\t\t\t    &ctor_dtor_or_conv_p,\n \t\t\t\t\t    /*parenthesized_p=*/NULL,\n \t\t\t\t\t    /*member_p=*/true,\n-\t\t\t\t\t    /*friend_p=*/false);\n+\t\t\t\t\t    /*friend_p=*/false,\n+\t\t\t\t\t    /*static_p=*/false);\n \t\t      peek = cp_lexer_peek_token (parser->lexer);\n \t\t      if (cp_parser_error_occurred (parser))\n \t\t\tbreak;\n@@ -31060,7 +31084,8 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t\t\t\t\t&ctor_dtor_or_conv_p,\n \t\t\t\t\t/*parenthesized_p=*/NULL,\n \t\t\t\t\t/*member_p=*/false,\n-\t\t\t\t\t/*friend_p=*/false);\n+\t\t\t\t\t/*friend_p=*/false,\n+\t\t\t\t\t/*static_p=*/false);\n \t    }\n \n \t  /* Look for attributes that apply to the ivar.  */\n@@ -31618,7 +31643,7 @@ cp_parser_objc_struct_declaration (cp_parser *parser)\n       /* Parse the declarator.  */\n       declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n \t\t\t\t\t CP_PARSER_FLAGS_NONE,\n-\t\t\t\t\t NULL, NULL, false, false);\n+\t\t\t\t\t NULL, NULL, false, false, false);\n \n       /* Look for attributes that apply to the ivar.  */\n       attributes = cp_parser_attributes_opt (parser);\n@@ -36251,7 +36276,8 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t\t\t\t\t /*ctor_dtor_or_conv_p=*/NULL,\n \t\t\t\t\t /*parenthesized_p=*/NULL,\n \t\t\t\t\t /*member_p=*/false,\n-\t\t\t\t\t /*friend_p=*/false);\n+\t\t\t\t\t /*friend_p=*/false,\n+\t\t\t\t\t /*static_p=*/false);\n       attributes = cp_parser_attributes_opt (parser);\n       asm_specification = cp_parser_asm_specification_opt (parser);\n "}, {"sha": "1d6cb2d424c8eb1819844e31dfa5b47058d03676", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "patch": "@@ -282,9 +282,12 @@ struct GTY(()) cp_parser {\n      been seen that makes the expression non-constant.  */\n   bool non_integral_constant_expression_p;\n \n-  /* TRUE if local variable names and `this' are forbidden in the\n-     current context.  */\n-  bool local_variables_forbidden_p;\n+  /* Used to track if local variable names and/or `this' are forbidden\n+     in the current context.  */\n+#define LOCAL_VARS_FORBIDDEN (1 << 0)\n+#define THIS_FORBIDDEN (1 << 1)\n+#define LOCAL_VARS_AND_THIS_FORBIDDEN (LOCAL_VARS_FORBIDDEN | THIS_FORBIDDEN)\n+  unsigned char local_variables_forbidden_p;\n \n   /* TRUE if the declaration we are parsing is part of a\n      linkage-specification of the form `extern string-literal"}, {"sha": "4a70997cbedd6a602aa7c861bcf816d5b2aa30bc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "patch": "@@ -1,3 +1,8 @@\n+2019-01-08  Marek Polacek  <polacek@redhat.com>\n+\n+\tPR c++/88548 - this accepted in static member functions.\n+\t* g++.dg/cpp0x/this1.C: New test.\n+\n 2019-01-08  Martin Liska  <mliska@suse.cz>\n \n \tPR tree-optimization/88753"}, {"sha": "486e0450f4a3cba55cc7ba98b6db978a1b270493", "filename": "gcc/testsuite/g++.dg/cpp0x/this1.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fthis1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e01ffb47c6fec6d52f254390bf863b4ca0fa32e2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fthis1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fthis1.C?ref=e01ffb47c6fec6d52f254390bf863b4ca0fa32e2", "patch": "@@ -0,0 +1,46 @@\n+// PR c++/88548\n+// { dg-do compile { target c++11 } }\n+\n+struct S1 {\n+  int a;\n+  auto m1 () -> decltype(this->a) { return 0; }\n+  auto m2 () -> decltype(this) { return 0; }\n+  void m3 () noexcept(noexcept(this->a)) { }\n+  void m4 () noexcept(noexcept(this)) { }\n+\n+  static auto m5 () -> decltype(this->a) { return 0; } // { dg-error \".this. may not be used in this context\" }\n+  static auto m6 () -> decltype(this) { return 0; } // { dg-error \".this. may not be used in this context\" }\n+  static void m7 () noexcept(noexcept(this->a)) { } // { dg-error \".this. may not be used in this context\" }\n+  static void m8 () noexcept(noexcept(this)) { } // { dg-error \".this. may not be used in this context\" }\n+};\n+\n+template <typename T>\n+struct S2 {\n+  static auto f1(T arg) -> decltype((arg));\n+};\n+\n+struct S3 {\n+  int a;\n+  void f1 () noexcept(noexcept(a)) { }\n+  static void f2() noexcept(noexcept(a)) { }\n+  static auto f3() -> decltype(a);\n+  static auto f4() -> decltype((a));\n+};\n+\n+template<typename T>\n+class S4 {\n+  T i;\n+  friend int foo(const S4 &t) noexcept(noexcept(i)) { return t.i; }\n+};\n+\n+void\n+test ()\n+{\n+  S4<int> t;\n+  foo(t);\n+}\n+\n+struct S5 {\n+  friend auto bar() -> decltype(this); // { dg-error \".this. may not be used in this context\" }\n+  auto bar2() -> decltype(this);\n+};"}]}