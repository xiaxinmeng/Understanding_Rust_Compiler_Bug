{"sha": "3eecc1db4c691a87ef4a229d059aa863066d9a1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VlY2MxZGI0YzY5MWE4N2VmNGEyMjlkMDU5YWE4NjMwNjZkOWExYw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-23T12:24:34Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-06-23T12:24:34Z"}, "message": "c++: CTAD and deduction guide selection [PR86439]\n\nDuring CTAD, we select the best viable deduction guide using\nbuild_new_function_call, which performs overload resolution on the set\nof candidate guides and then forms a call to the guide.  As the PR\npoints out, this latter step is unnecessary and occasionally incorrect\nsince a call to the selected guide may be ill-formed, or forming the\ncall may have side effects such as prematurely deducing the type of a {}.\n\nSo this patch introduces a specialized subroutine based on\nbuild_new_function_call that stops short of building a call to the\nselected function, and makes do_class_deduction use this subroutine\ninstead.  And since a call is no longer built, do_class_deduction\ndoesn't need to set tf_decltype or cp_unevaluated_operand anymore.\n\nThis change causes us to reject some container CTAD examples in the\nlibstdc++ testsuite due to deduction failure for {}, which AFAICT is the\ncorrect behavior.  Previously in e.g. the first removed example\n\n  std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}, {}},\n\nthe type of the {} would get deduced to less<int> as a side effect of\nforming a call to the chosen guide\n\n  template<typename _Key, typename _Tp, typename _Compare = less<_Key>,\n           typename _Allocator = allocator<pair<const _Key, _Tp>>>\n      map(initializer_list<pair<_Key, _Tp>>,\n          _Compare = _Compare(), _Allocator = _Allocator())\n      -> map<_Key, _Tp, _Compare, _Allocator>;\n\nwhich made later overload resolution for the constructor call\nunambiguous.  Now, the type of the {} remains undeduced until\nconstructor overload resolution, and we complain about ambiguity\nfor the two equally good constructor candidates\n\n  map(initializer_list<value_type>,\n      const _Compare& = _Compare(),\n      const allocator_type& = allocator_type())\n\n  map(initializer_list<value_type>, const allocator_type&).\n\nThis patch fixes these problematic container CTAD examples by giving\nthe {} an appropriate concrete type.  Two of these adjusted CTAD\nexamples (one for std::set and one for std::multiset) end up triggering\nan unrelated CTAD bug on trunk, PR101174, so these two adjusted examples\nare commented out for now.\n\n\tPR c++/86439\n\ngcc/cp/ChangeLog:\n\n\t* call.c (print_error_for_call_failure): Constify 'args' parameter.\n\t(perform_dguide_overload_resolution): Define.\n\t* cp-tree.h: (perform_dguide_overload_resolution): Declare.\n\t* pt.c (do_class_deduction): Use perform_dguide_overload_resolution\n\tinstead of build_new_function_call.  Don't use tf_decltype or\n\tset cp_unevaluated_operand.  Remove unnecessary NULL_TREE tests.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/23_containers/map/cons/deduction.cc: Replace ambiguous\n\tCTAD examples.\n\t* testsuite/23_containers/multimap/cons/deduction.cc: Likewise.\n\t* testsuite/23_containers/multiset/cons/deduction.cc: Likewise.\n\tMention one of the replaced examples is broken due to PR101174.\n\t* testsuite/23_containers/set/cons/deduction.cc: Likewise.\n\t* testsuite/23_containers/unordered_map/cons/deduction.cc: Replace\n\tambiguous CTAD examples.\n\t* testsuite/23_containers/unordered_multimap/cons/deduction.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multiset/cons/deduction.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/cons/deduction.cc: Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/class-deduction88.C: New test.\n\t* g++.dg/cpp1z/class-deduction89.C: New test.\n\t* g++.dg/cpp1z/class-deduction90.C: New test.", "tree": {"sha": "87b2a6ecf6bb2952db40b0f76a84c9c99c999671", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87b2a6ecf6bb2952db40b0f76a84c9c99c999671"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3eecc1db4c691a87ef4a229d059aa863066d9a1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eecc1db4c691a87ef4a229d059aa863066d9a1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eecc1db4c691a87ef4a229d059aa863066d9a1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eecc1db4c691a87ef4a229d059aa863066d9a1c/comments", "author": null, "committer": null, "parents": [{"sha": "1e16f2b472c7d253d564556a048dc4ae16119c00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e16f2b472c7d253d564556a048dc4ae16119c00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e16f2b472c7d253d564556a048dc4ae16119c00"}], "stats": {"total": 222, "additions": 170, "deletions": 52}, "files": [{"sha": "aafc7acca24a8f2a66d69623e2f97abb63c1397f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -4629,7 +4629,7 @@ perform_overload_resolution (tree fn,\n    functions.  */\n \n static void\n-print_error_for_call_failure (tree fn, vec<tree, va_gc> *args,\n+print_error_for_call_failure (tree fn, const vec<tree, va_gc> *args,\n \t\t\t      struct z_candidate *candidates)\n {\n   tree targs = NULL_TREE;\n@@ -4654,6 +4654,40 @@ print_error_for_call_failure (tree fn, vec<tree, va_gc> *args,\n     print_z_candidates (loc, candidates);\n }\n \n+/* Perform overload resolution on the set of deduction guides DGUIDES\n+   using ARGS.  Returns the selected deduction guide, or error_mark_node\n+   if overload resolution fails.  */\n+\n+tree\n+perform_dguide_overload_resolution (tree dguides, const vec<tree, va_gc> *args,\n+\t\t\t\t    tsubst_flags_t complain)\n+{\n+  z_candidate *candidates;\n+  bool any_viable_p;\n+  tree result;\n+\n+  gcc_assert (deduction_guide_p (OVL_FIRST (dguides)));\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  void *p = conversion_obstack_alloc (0);\n+\n+  z_candidate *cand = perform_overload_resolution (dguides, args, &candidates,\n+\t\t\t\t\t\t   &any_viable_p, complain);\n+  if (!cand)\n+    {\n+      if (complain & tf_error)\n+\tprint_error_for_call_failure (dguides, args, candidates);\n+      result = error_mark_node;\n+    }\n+  else\n+    result = cand->fn;\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return result;\n+}\n+\n /* Return an expression for a call to FN (a namespace-scope function,\n    or a static member function) with the ARGS.  This may change\n    ARGS.  */"}, {"sha": "6f713719589bc9fda4c814e3ab2e6fd5dace12f7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -6437,6 +6437,8 @@ extern void complain_about_bad_argument\t(location_t arg_loc,\n \t\t\t\t\t\t tree from_type, tree to_type,\n \t\t\t\t\t\t tree fndecl, int parmnum);\n extern void maybe_inform_about_fndecl_for_bogus_argument_init (tree, int);\n+extern tree perform_dguide_overload_resolution\t(tree, const vec<tree, va_gc> *,\n+\t\t\t\t\t\t tsubst_flags_t);\n \n \n /* A class for recording information about access failures (e.g. private"}, {"sha": "732fb405adf44171ff5c206f3d56e3fca55fdf1e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -29382,7 +29382,7 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n     if (tree guide = maybe_aggr_guide (tmpl, init, args))\n       cands = lookup_add (guide, cands);\n \n-  tree call = error_mark_node;\n+  tree fndecl = error_mark_node;\n \n   /* If this is list-initialization and the class has a list constructor, first\n      try deducing from the list as a single argument, as [over.match.list].  */\n@@ -29396,11 +29396,9 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n       }\n   if (list_cands)\n     {\n-      ++cp_unevaluated_operand;\n-      call = build_new_function_call (list_cands, &args, tf_decltype);\n-      --cp_unevaluated_operand;\n+      fndecl = perform_dguide_overload_resolution (list_cands, args, tf_none);\n \n-      if (call == error_mark_node)\n+      if (fndecl == error_mark_node)\n \t{\n \t  /* That didn't work, now try treating the list as a sequence of\n \t     arguments.  */\n@@ -29416,31 +29414,22 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n \t     \"user-declared constructors\", type);\n       return error_mark_node;\n     }\n-  else if (!cands && call == error_mark_node)\n+  else if (!cands && fndecl == error_mark_node)\n     {\n       error (\"cannot deduce template arguments of %qT, as it has no viable \"\n \t     \"deduction guides\", type);\n       return error_mark_node;\n     }\n \n-  if (call == error_mark_node)\n-    {\n-      ++cp_unevaluated_operand;\n-      call = build_new_function_call (cands, &args, tf_decltype);\n-      --cp_unevaluated_operand;\n-    }\n+  if (fndecl == error_mark_node)\n+    fndecl = perform_dguide_overload_resolution (cands, args, tf_none);\n \n-  if (call == error_mark_node)\n+  if (fndecl == error_mark_node)\n     {\n       if (complain & tf_warning_or_error)\n \t{\n \t  error (\"class template argument deduction failed:\");\n-\n-\t  ++cp_unevaluated_operand;\n-\t  call = build_new_function_call (cands, &args,\n-\t\t\t\t\t  complain | tf_decltype);\n-\t  --cp_unevaluated_operand;\n-\n+\t  perform_dguide_overload_resolution (cands, args, complain);\n \t  if (elided)\n \t    inform (input_location, \"explicit deduction guides not considered \"\n \t\t    \"for copy-initialization\");\n@@ -29451,8 +29440,7 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n      constructor is chosen, the initialization is ill-formed.  */\n   else if (flags & LOOKUP_ONLYCONVERTING)\n     {\n-      tree fndecl = cp_get_callee_fndecl_nofold (call);\n-      if (fndecl && DECL_NONCONVERTING_P (fndecl))\n+      if (DECL_NONCONVERTING_P (fndecl))\n \t{\n \t  if (complain & tf_warning_or_error)\n \t    {\n@@ -29470,20 +29458,19 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n \n   /* If CTAD succeeded but the type doesn't have any explicit deduction\n      guides, this deduction might not be what the user intended.  */\n-  if (call != error_mark_node && !any_dguides_p)\n+  if (fndecl != error_mark_node && !any_dguides_p)\n     {\n-      tree fndecl = cp_get_callee_fndecl_nofold (call);\n-      if (fndecl != NULL_TREE\n-\t  && (!DECL_IN_SYSTEM_HEADER (fndecl)\n-\t      || global_dc->dc_warn_system_headers)\n+      if ((!DECL_IN_SYSTEM_HEADER (fndecl)\n+\t   || global_dc->dc_warn_system_headers)\n \t  && warning (OPT_Wctad_maybe_unsupported,\n \t\t      \"%qT may not intend to support class template argument \"\n \t\t      \"deduction\", type))\n \tinform (input_location, \"add a deduction guide to suppress this \"\n \t\t\"warning\");\n     }\n \n-  return cp_build_qualified_type (TREE_TYPE (call), cp_type_quals (ptype));\n+  return cp_build_qualified_type (TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t\t  cp_type_quals (ptype));\n }\n \n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced"}, {"sha": "be38fed2901d891f8dc8297d37308c3d678370e1", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction88.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction88.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction88.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction88.C?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/86439\n+// { dg-do compile { target c++17 } }\n+\n+struct NC {\n+  NC() = default;\n+  NC(NC const&) = delete;\n+  NC& operator=(NC const&) = delete;\n+};\n+\n+template <int>\n+struct C {\n+  C(NC const&);\n+};\n+\n+C(NC) -> C<0>;\n+\n+NC nc;\n+C c(nc);"}, {"sha": "dd89857302211f1170b7bcc5dd57edc6c5e5e70b", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction89.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction89.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction89.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction89.C?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/86439\n+// { dg-do compile { target c++17 } }\n+\n+struct B { };\n+struct C { };\n+\n+template<class T>\n+struct A {\n+  A(T, B);\n+};\n+\n+template<class T>\n+A(T, C) -> A<T>;\n+\n+A a(0, {});"}, {"sha": "8b93193c7b0cf23172c4c5825fc184a728f93868", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction90.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction90.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction90.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction90.C?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/86439\n+// { dg-do compile { target c++17 } }\n+\n+struct less { };\n+struct allocator { };\n+\n+template<class T, class U = less, class V = allocator>\n+struct A {\n+  A(T, U);\n+  A(T, V);\n+};\n+\n+template<class T, class U = less>\n+A(T, U) -> A<T>;\n+\n+A a(0, {}); // { dg-error \"ambiguous\" }"}, {"sha": "e72033c38a6e0b2bec46436f33e305c2f8576d8b", "filename": "libstdc++-v3/testsuite/23_containers/map/cons/deduction.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -40,7 +40,7 @@ static_assert(std::is_same_v<\n */\n \n static_assert(std::is_same_v<\n-\t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}, {}}),\n+\t      decltype(std::map{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}}, std::less<int>{}}),\n \t      std::map<int, double>>);\n \n /* This is not deducible, ambiguous candidates:\n@@ -92,7 +92,7 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::map(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::map<int, double>>);\n \n   static_assert(std::is_same_v<\n@@ -145,7 +145,7 @@ void g()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::map(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::map<int, double>>);\n \n   static_assert(std::is_same_v<\n@@ -195,7 +195,7 @@ void h()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::map(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::map<int, double>>);\n \n   static_assert(std::is_same_v<"}, {"sha": "ffc7502d60cf978a919159c2ca99dc41784e520d", "filename": "libstdc++-v3/testsuite/23_containers/multimap/cons/deduction.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -42,7 +42,7 @@ static_assert(std::is_same_v<\n \n static_assert(std::is_same_v<\n \t      decltype(std::multimap{{std::pair{1, 2.0}, {2, 3.0}, {3, 4.0}},\n-\t\t    {}}),\n+\t\t    std::less<int>{}}),\n \t      std::multimap<int, double>>);\n \n static_assert(std::is_same_v<\n@@ -77,7 +77,7 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap(x.begin(), x.end(),\n-\t\t\t\t       {})),\n+\t\t\t\t       std::less<int>{})),\n \t\tstd::multimap<int, double>>);\n \n   static_assert(std::is_same_v<\n@@ -119,7 +119,7 @@ void g()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap(x.begin(), x.end(),\n-\t\t\t\t       {})),\n+\t\t\t\t       std::less<int>{})),\n \t\tstd::multimap<int, double>>);\n \n   static_assert(std::is_same_v<\n@@ -158,7 +158,7 @@ void h()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multimap(x.begin(), x.end(),\n-\t\t\t\t       {})),\n+\t\t\t\t       std::less<int>{})),\n \t\tstd::multimap<int, double>>);\n \n   static_assert(std::is_same_v<"}, {"sha": "a4ccc6fa467a7b2c12b7a8e4a2f6a1de7b0c627b", "filename": "libstdc++-v3/testsuite/23_containers/multiset/cons/deduction.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -19,9 +19,11 @@ static_assert(std::is_same_v<\n \t      decltype(std::multiset{{1, 2, 3}, std::less<int>{}, {}}),\n \t      std::multiset<int>>);\n \n+/* FIXME: GCC 12 rejects this due to PR c++/101174\n static_assert(std::is_same_v<\n-\t      decltype(std::multiset{{1, 2, 3}, {}}),\n+\t      decltype(std::multiset{{1, 2, 3}, std::less<int>{}}),\n \t      std::multiset<int>>);\n+*/\n \n static_assert(std::is_same_v<\n \t      decltype(std::multiset{{1, 2, 3}, SimpleAllocator<int>{}}),\n@@ -52,7 +54,7 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multiset(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::multiset<int>>);\n \n   static_assert(std::is_same_v<\n@@ -103,7 +105,7 @@ void g()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::multiset(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::multiset<int>>);\n \n   static_assert(std::is_same_v<"}, {"sha": "0ae4c2a5c5ff7fab7d6dc6df834e2ac326d2a770", "filename": "libstdc++-v3/testsuite/23_containers/set/cons/deduction.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -20,10 +20,12 @@ static_assert(std::is_same_v<\n \t\t    std::less<int>{}, {}}),\n \t      std::set<int>>);\n \n+/* FIXME: GCC 12 rejects this due to PR c++/101174\n static_assert(std::is_same_v<\n \t      decltype(std::set{{1, 2, 3},\n-\t\t    {}}),\n+\t\t    std::less<int>{}}),\n \t      std::set<int>>);\n+*/\n \n static_assert(std::is_same_v<\n \t      decltype(std::set{{1, 2, 3},\n@@ -58,7 +60,7 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::set(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::set<int>>);\n \n   static_assert(std::is_same_v<\n@@ -104,7 +106,7 @@ void g()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::set(x.begin(), x.end(),\n-\t\t\t\t  {})),\n+\t\t\t\t  std::less<int>{})),\n \t\tstd::set<int>>);\n \n   static_assert(std::is_same_v<"}, {"sha": "0785447a81bcd5a12c3220bdffb91b9e392716ae", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/cons/deduction.cc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -24,7 +24,13 @@ static_assert(std::is_same_v<\n static_assert(std::is_same_v<\n \t      decltype(std::unordered_map{{std::pair{1, 2.0},\n \t\t      {2, 3.0}, {3, 4.0}},\n-\t\t    {}, std::hash<int>{}, {}}),\n+\t\t    {}, std::hash<int>{}, std::equal_to<int>{}}),\n+\t      std::unordered_map<int, double>>);\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::unordered_map{{std::pair{1, 2.0},\n+\t\t      {2, 3.0}, {3, 4.0}},\n+\t\t    {}, std::hash<int>{}, std::allocator<std::pair<const int, double>>{}}),\n \t      std::unordered_map<int, double>>);\n \n static_assert(std::is_same_v<\n@@ -59,9 +65,14 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::unordered_map{x.begin(), x.end(),\n-\t\t      {}, std::hash<int>{}, {}}),\n+\t\t      {}, std::hash<int>{}, std::equal_to<int>{}}),\n \t\tstd::unordered_map<int, double>>);\n-  \n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::unordered_map{x.begin(), x.end(),\n+\t\t      {}, std::hash<int>{}, std::allocator<std::pair<const int, double>>{}}),\n+\t\tstd::unordered_map<int, double>>);\n+\n   static_assert(std::is_same_v<\n \t\tdecltype(std::unordered_map(x.begin(), x.end(),\n \t\t      {})),"}, {"sha": "d8a6f5136c98ed6af71932171d1cacc4ece465ff", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/cons/deduction.cc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -18,7 +18,13 @@ static_assert(std::is_same_v<\n static_assert(std::is_same_v<\n \t      decltype(std::unordered_multimap{{std::pair{1, 2.0},\n \t\t      {2, 3.0}, {3, 4.0}},\n-\t\t    {}, std::hash<int>{}, {}}),\n+\t\t    {}, std::hash<int>{}, std::equal_to<int>{}}),\n+\t      std::unordered_multimap<int, double>>);\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::unordered_multimap{{std::pair{1, 2.0},\n+\t\t      {2, 3.0}, {3, 4.0}},\n+\t\t    {}, std::hash<int>{}, std::allocator<std::pair<const int, double>>{}}),\n \t      std::unordered_multimap<int, double>>);\n \n static_assert(std::is_same_v<\n@@ -68,9 +74,14 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::unordered_multimap{x.begin(), x.end(),\n-\t\t      {}, std::hash<int>{}, {}}),\n+\t\t      {}, std::hash<int>{}, std::equal_to<int>{}}),\n \t\tstd::unordered_multimap<int, double>>);\n-  \n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::unordered_multimap{x.begin(), x.end(),\n+\t\t      {}, std::hash<int>{}, std::allocator<std::pair<const int, double>>{}}),\n+\t\tstd::unordered_multimap<int, double>>);\n+\n   static_assert(std::is_same_v<\n \t\tdecltype(std::unordered_multimap(x.begin(), x.end(),\n \t\t\t\t  {})),"}, {"sha": "25c2715ea262f1c7eaa232659ea8fef16f3a9a6e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/cons/deduction.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -11,7 +11,12 @@ static_assert(std::is_same_v<\n \n static_assert(std::is_same_v<\n \t      decltype(std::unordered_multiset{{1, 2, 3},\n-\t\t    0, std::hash<int>{}, {}}),\n+\t\t    0, std::hash<int>{}, std::equal_to<int>{}}),\n+\t      std::unordered_multiset<int>>);\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::unordered_multiset{{1, 2, 3},\n+\t\t    0, std::hash<int>{}, std::allocator<int>{}}),\n \t      std::unordered_multiset<int>>);\n \n static_assert(std::is_same_v<\n@@ -78,7 +83,12 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::unordered_multiset{x.begin(), x.end(),\n-\t\t      {}, std::hash<int>{}, {}}),\n+\t\t      {}, std::hash<int>{}, std::equal_to<int>{}}),\n+\t\tstd::unordered_multiset<int>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::unordered_multiset{x.begin(), x.end(),\n+\t\t      {}, std::hash<int>{}, std::allocator<int>{}}),\n \t\tstd::unordered_multiset<int>>);\n \n   static_assert(std::is_same_v<"}, {"sha": "b8c45d2993d6ba6c0a84ff0827fb13e7ef58132a", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/cons/deduction.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3eecc1db4c691a87ef4a229d059aa863066d9a1c/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fcons%2Fdeduction.cc?ref=3eecc1db4c691a87ef4a229d059aa863066d9a1c", "patch": "@@ -11,7 +11,12 @@ static_assert(std::is_same_v<\n \n static_assert(std::is_same_v<\n \t      decltype(std::unordered_set{{1, 2, 3},\n-\t\t    0, std::hash<int>{}, {}}),\n+\t\t    0, std::hash<int>{}, std::equal_to<int>{}}),\n+\t      std::unordered_set<int>>);\n+\n+static_assert(std::is_same_v<\n+\t      decltype(std::unordered_set{{1, 2, 3},\n+\t\t    0, std::hash<int>{}, std::allocator<int>{}}),\n \t      std::unordered_set<int>>);\n \n static_assert(std::is_same_v<\n@@ -73,7 +78,12 @@ void f()\n \n   static_assert(std::is_same_v<\n \t\tdecltype(std::unordered_set{x.begin(), x.end(),\n-\t\t      {}, std::hash<int>{}, {}}),\n+\t\t      {}, std::hash<int>{}, std::equal_to<int>{}}),\n+\t\tstd::unordered_set<int>>);\n+\n+  static_assert(std::is_same_v<\n+\t\tdecltype(std::unordered_set{x.begin(), x.end(),\n+\t\t      {}, std::hash<int>{}, std::allocator<int>{}}),\n \t\tstd::unordered_set<int>>);\n \n   static_assert(std::is_same_v<"}]}