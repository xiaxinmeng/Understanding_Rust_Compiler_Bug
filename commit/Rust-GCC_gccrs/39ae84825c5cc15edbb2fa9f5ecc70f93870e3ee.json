{"sha": "39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "node_id": "C_kwDOANBUbNoAKDM5YWU4NDgyNWM1Y2MxNWVkYmIyZmE5ZjVlY2M3MGY5Mzg3MGUzZWU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-05-20T12:35:54Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-05-20T14:57:22Z"}, "message": "Canonicalize types based on hashing than HirIds and TyTy equality\n\nWhen we compile types for GCC we need to make sure we canonicalize them,\nthis means that for any user defined type such as Structs or Tuples we want\nall expressions or declarations to use the same tree. Even if we have\nduplicate tree's we can end up confusing the middle-end and lose out on\noptimizations as we will be using view_convert_exprs to maintain the\nconsistancy which will marshall between the objects unnessecarily.\n\nThe old method for doing this kept mappings of HirIds which was fine for\nsimple cases but when generics are involved new Id's are generated so this\nmeant we ended up having a vector of pairs {TyTy::BaseType, tree} and we\ndid a liner search to find the relevant TyTy::BaseType that we equaled to.\n\nThis was not only slow but did not handle the cases for generic associated\ntypes or nested generics. So we needed a more general faster implementation\ntherefore hashing. This patch takes the gcc/tree.h type_hash_canon code\nand adds in hashing for RECORD and UNION types. This means we will generate\na duplicate type then hash it and look for an existing type.\n\nThis patch will also allow us to fix how we implement monomorphization of\nfunctions by nesting the hashes behind DefId's.", "tree": {"sha": "802a3e75033824c712556d092fb5d36760d9c399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/802a3e75033824c712556d092fb5d36760d9c399"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad0ea3e0ed288569d52556b9aa796beea73d8a3"}], "stats": {"total": 693, "additions": 291, "deletions": 402}, "files": [{"sha": "5d97a162c30fdbee5c02ed14df09c44e92c785c7", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -130,6 +130,7 @@ GRS_OBJS = \\\n     rust/rust-constexpr.o \\\n     rust/rust-compile-base.o \\\n     rust/rust-tree.o \\\n+    rust/rust-compile-context.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "0595ee905ab9d7eb7f941a73ada53f81c26a84d7", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_BLOCK\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "463ac27aa5a16ceda163914b7f519cb55e37ef25", "filename": "gcc/rust/backend/rust-compile-context.cc", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-context.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.cc?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -0,0 +1,139 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-context.h\"\n+#include \"rust-compile-type.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Context::Context (::Backend *backend)\n+  : backend (backend), resolver (Resolver::Resolver::get ()),\n+    tyctx (Resolver::TypeCheckContext::get ()),\n+    mappings (Analysis::Mappings::get ()), mangler (Mangler ())\n+{\n+  setup_builtins ();\n+}\n+\n+void\n+Context::setup_builtins ()\n+{\n+  auto builtins = resolver->get_builtin_types ();\n+  for (auto it = builtins.begin (); it != builtins.end (); it++)\n+    {\n+      HirId ref;\n+      bool ok = tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref);\n+      rust_assert (ok);\n+\n+      TyTy::BaseType *lookup;\n+      ok = tyctx->lookup_type (ref, &lookup);\n+      rust_assert (ok);\n+\n+      TyTyResolveCompile::compile (this, lookup);\n+    }\n+}\n+\n+hashval_t\n+Context::type_hasher (tree type)\n+{\n+  inchash::hash hstate;\n+\n+  hstate.add_int (TREE_CODE (type));\n+\n+  if (TYPE_NAME (type))\n+    {\n+      hashval_t record_name_hash\n+\t= IDENTIFIER_HASH_VALUE (DECL_NAME (TYPE_NAME (type)));\n+      hstate.add_object (record_name_hash);\n+    }\n+\n+  if (TREE_TYPE (type))\n+    hstate.add_object (TYPE_HASH (TREE_TYPE (type)));\n+\n+  for (tree t = TYPE_ATTRIBUTES (type); t; t = TREE_CHAIN (t))\n+    /* Just the identifier is adequate to distinguish.  */\n+    hstate.add_object (IDENTIFIER_HASH_VALUE (TREE_PURPOSE (t)));\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case METHOD_TYPE:\n+      hstate.add_object (TYPE_HASH (TYPE_METHOD_BASETYPE (type)));\n+      /* FALLTHROUGH. */\n+    case FUNCTION_TYPE:\n+      for (tree t = TYPE_ARG_TYPES (type); t; t = TREE_CHAIN (t))\n+\tif (TREE_VALUE (t) != error_mark_node)\n+\t  hstate.add_object (TYPE_HASH (TREE_VALUE (t)));\n+      break;\n+\n+    case OFFSET_TYPE:\n+      hstate.add_object (TYPE_HASH (TYPE_OFFSET_BASETYPE (type)));\n+      break;\n+\n+      case ARRAY_TYPE: {\n+\tif (TYPE_DOMAIN (type))\n+\t  hstate.add_object (TYPE_HASH (TYPE_DOMAIN (type)));\n+\tif (!AGGREGATE_TYPE_P (TREE_TYPE (type)))\n+\t  {\n+\t    unsigned typeless = TYPE_TYPELESS_STORAGE (type);\n+\t    hstate.add_object (typeless);\n+\t  }\n+      }\n+      break;\n+\n+      case INTEGER_TYPE: {\n+\ttree t = TYPE_MAX_VALUE (type);\n+\tif (!t)\n+\t  t = TYPE_MIN_VALUE (type);\n+\tfor (int i = 0; i < TREE_INT_CST_NUNITS (t); i++)\n+\t  hstate.add_object (TREE_INT_CST_ELT (t, i));\n+\tbreak;\n+      }\n+\n+    case REAL_TYPE:\n+      case FIXED_POINT_TYPE: {\n+\tunsigned prec = TYPE_PRECISION (type);\n+\thstate.add_object (prec);\n+\tbreak;\n+      }\n+\n+    case VECTOR_TYPE:\n+      hstate.add_poly_int (TYPE_VECTOR_SUBPARTS (type));\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      case QUAL_UNION_TYPE: {\n+\tfor (tree t = TYPE_FIELDS (type); t; t = TREE_CHAIN (t))\n+\t  {\n+\t    hashval_t name_hash = IDENTIFIER_HASH_VALUE (DECL_NAME (t));\n+\t    hashval_t type_hash = type_hasher (TREE_TYPE (t));\n+\t    hstate.add_object (name_hash);\n+\t    hstate.add_object (type_hash);\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return hstate.end ();\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "837855492593e87ada06ae204007039ae3cce605", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 17, "deletions": 54, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -24,7 +24,6 @@\n #include \"rust-name-resolver.h\"\n #include \"rust-hir-type-check.h\"\n #include \"rust-backend.h\"\n-#include \"rust-compile-tyty.h\"\n #include \"rust-hir-full.h\"\n #include \"rust-mangle.h\"\n #include \"rust-tree.h\"\n@@ -41,67 +40,31 @@ struct fncontext\n class Context\n {\n public:\n-  Context (::Backend *backend)\n-    : backend (backend), resolver (Resolver::Resolver::get ()),\n-      tyctx (Resolver::TypeCheckContext::get ()),\n-      mappings (Analysis::Mappings::get ()), mangler (Mangler ())\n-  {\n-    // insert the builtins\n-    auto builtins = resolver->get_builtin_types ();\n-    for (auto it = builtins.begin (); it != builtins.end (); it++)\n-      {\n-\tHirId ref;\n-\tbool ok = tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref);\n-\trust_assert (ok);\n-\n-\tTyTy::BaseType *lookup;\n-\tok = tyctx->lookup_type (ref, &lookup);\n-\trust_assert (ok);\n+  Context (::Backend *backend);\n \n-\ttree compiled = TyTyCompile::compile (backend, lookup);\n-\tcompiled_type_map.insert (std::pair<HirId, tree> (ref, compiled));\n-\tbuiltin_range.insert (ref);\n-      }\n-  }\n+  void setup_builtins ();\n \n-  bool lookup_compiled_types (HirId id, tree *type,\n-\t\t\t      const TyTy::BaseType *ref = nullptr)\n+  bool lookup_compiled_types (tree t, tree *type)\n   {\n-    if (ref != nullptr)\n-      {\n-\tfor (auto it = mono.begin (); it != mono.end (); it++)\n-\t  {\n-\t    std::pair<HirId, tree> &val = it->second;\n-\t    const TyTy::BaseType *r = it->first;\n-\n-\t    if (ref->is_equal (*r))\n-\t      {\n-\t\t*type = val.second;\n-\n-\t\treturn true;\n-\t      }\n-\t  }\n-\treturn false;\n-      }\n-\n-    auto it = compiled_type_map.find (id);\n+    hashval_t h = type_hasher (t);\n+    auto it = compiled_type_map.find (h);\n     if (it == compiled_type_map.end ())\n       return false;\n \n     *type = it->second;\n     return true;\n   }\n \n-  void insert_compiled_type (HirId id, tree type,\n-\t\t\t     const TyTy::BaseType *ref = nullptr)\n+  tree insert_compiled_type (tree type)\n   {\n-    rust_assert (builtin_range.find (id) == builtin_range.end ());\n-    compiled_type_map.insert (std::pair<HirId, tree> (id, type));\n-    if (ref != nullptr)\n-      {\n-\tstd::pair<HirId, tree> elem (id, type);\n-\tmono[ref] = std::move (elem);\n-      }\n+    hashval_t h = type_hasher (type);\n+    auto it = compiled_type_map.find (h);\n+    if (it != compiled_type_map.end ())\n+      return it->second;\n+\n+    compiled_type_map.insert ({h, type});\n+    push_type (type);\n+    return type;\n   }\n \n   ::Backend *get_backend () { return backend; }\n@@ -328,26 +291,26 @@ class Context\n   std::vector<tree> &get_const_decls () { return const_decls; }\n   std::vector<tree> &get_func_decls () { return func_decls; }\n \n+  static hashval_t type_hasher (tree type);\n+\n private:\n   ::Backend *backend;\n   Resolver::Resolver *resolver;\n   Resolver::TypeCheckContext *tyctx;\n   Analysis::Mappings *mappings;\n-  std::set<HirId> builtin_range;\n   Mangler mangler;\n \n   // state\n   std::vector<fncontext> fn_stack;\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n-  std::map<HirId, tree> compiled_type_map;\n+  std::map<hashval_t, tree> compiled_type_map;\n   std::map<HirId, tree> compiled_fn_map;\n   std::map<HirId, tree> compiled_consts;\n   std::map<HirId, tree> compiled_labels;\n   std::vector<::std::vector<tree>> statements;\n   std::vector<tree> scope_stack;\n   std::vector<::Bvariable *> loop_value_stack;\n   std::vector<tree> loop_begin_labels;\n-  std::map<const TyTy::BaseType *, std::pair<HirId, tree>> mono;\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n   std::map<HirId, tree> implicit_pattern_bindings;"}, {"sha": "655ffbb263e7bec8c6f3eb35f5aa5640419941c3", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_EXPR\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-block.h\"\n #include \"rust-compile-struct-field-expr.h\""}, {"sha": "f0360bdc7394f3fb9932badafd5cc73be7cdcc21", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_RESOLVE_PATH\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "5f1777736dbfa4e750c43c0c5d9d4acae5e83555", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_STMT\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n #include \"rust-compile-expr.h\"\n \n namespace Rust {"}, {"sha": "6968c069f0fdf93280a4c090783e597260213a77", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_STRUCT_FIELD_EXPR\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "38740274a442a5732f20ff9d137be772cb5ec263", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 127, "deletions": 75, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -21,11 +21,27 @@\n #include \"rust-constexpr.h\"\n \n #include \"tree.h\"\n-#include \"print-tree.h\"\n \n namespace Rust {\n namespace Compile {\n \n+tree\n+TyTyResolveCompile::compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t\t     bool trait_object_mode)\n+{\n+  TyTyResolveCompile compiler (ctx, trait_object_mode);\n+  ty->accept_vis (compiler);\n+\n+  if (compiler.translated != error_mark_node\n+      && TYPE_NAME (compiler.translated) != NULL)\n+    {\n+      // canonicalize the type\n+      compiler.translated = ctx->insert_compiled_type (compiler.translated);\n+    }\n+\n+  return compiler.translated;\n+}\n+\n static const std::string RUST_ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\";\n \n // see: gcc/c/c-decl.cc:8230-8241\n@@ -96,6 +112,7 @@ TyTyResolveCompile::visit (const TyTy::PlaceholderType &type)\n void\n TyTyResolveCompile::visit (const TyTy::ParamType &param)\n {\n+  // FIXME make this reuse the same machinery from constexpr code\n   recursion_count++;\n   rust_assert (recursion_count < kDefaultRecusionLimit);\n \n@@ -163,9 +180,6 @@ TyTyResolveCompile::visit (const TyTy::FnPtr &type)\n void\n TyTyResolveCompile::visit (const TyTy::ADTType &type)\n {\n-  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-    return;\n-\n   tree type_record = error_mark_node;\n   if (!type.is_enum ())\n     {\n@@ -302,14 +316,8 @@ TyTyResolveCompile::visit (const TyTy::ADTType &type)\n \n   std::string named_struct_str\n     = type.get_ident ().path.get () + type.subst_as_string ();\n-  tree named_struct\n-    = ctx->get_backend ()->named_type (named_struct_str, type_record,\n-\t\t\t\t       type.get_ident ().locus);\n-\n-  ctx->push_type (named_struct);\n-  translated = named_struct;\n-\n-  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n void\n@@ -321,10 +329,6 @@ TyTyResolveCompile::visit (const TyTy::TupleType &type)\n       return;\n     }\n \n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type);\n-  if (ok)\n-    return;\n-\n   // create implicit struct\n   std::vector<Backend::typed_identifier> fields;\n   for (size_t i = 0; i < type.num_fields (); i++)\n@@ -345,13 +349,9 @@ TyTyResolveCompile::visit (const TyTy::TupleType &type)\n     }\n \n   tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n-  tree named_struct\n+  translated\n     = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n \t\t\t\t       type.get_ident ().locus);\n-\n-  ctx->push_type (named_struct);\n-  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-  translated = named_struct;\n }\n \n void\n@@ -369,9 +369,6 @@ TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n void\n TyTyResolveCompile::visit (const TyTy::SliceType &type)\n {\n-  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-    return;\n-\n   std::vector<Backend::typed_identifier> fields;\n \n   tree element_type\n@@ -393,77 +390,141 @@ TyTyResolveCompile::visit (const TyTy::SliceType &type)\n \n   std::string named_struct_str\n     = std::string (\"[\") + type.get_element_type ()->get_name () + \"]\";\n-  tree named_struct\n-    = ctx->get_backend ()->named_type (named_struct_str, type_record,\n-\t\t\t\t       type.get_ident ().locus);\n-\n-  ctx->push_type (named_struct);\n-  translated = named_struct;\n-\n-  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  translated = ctx->get_backend ()->named_type (named_struct_str, type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::BoolType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  translated\n+    = ctx->get_backend ()->named_type (\"bool\",\n+\t\t\t\t       ctx->get_backend ()->bool_type (),\n+\t\t\t\t       Linemap::predeclared_location ());\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::IntType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  switch (type.get_int_kind ())\n+    {\n+    case TyTy::IntType::I8:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i8\", ctx->get_backend ()->integer_type (false, 8),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I16:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i16\", ctx->get_backend ()->integer_type (false, 16),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I32:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i32\", ctx->get_backend ()->integer_type (false, 32),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I64:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i64\", ctx->get_backend ()->integer_type (false, 64),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::IntType::I128:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"i128\", ctx->get_backend ()->integer_type (false, 128),\n+\tLinemap::predeclared_location ());\n+      return;\n+    }\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::UintType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  switch (type.get_uint_kind ())\n+    {\n+    case TyTy::UintType::U8:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u8\", ctx->get_backend ()->integer_type (true, 8),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U16:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u16\", ctx->get_backend ()->integer_type (true, 16),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U32:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u32\", ctx->get_backend ()->integer_type (true, 32),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U64:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u64\", ctx->get_backend ()->integer_type (true, 64),\n+\tLinemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::UintType::U128:\n+      translated = ctx->get_backend ()->named_type (\n+\t\"u128\", ctx->get_backend ()->integer_type (true, 128),\n+\tLinemap::predeclared_location ());\n+      return;\n+    }\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::FloatType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  switch (type.get_float_kind ())\n+    {\n+    case TyTy::FloatType::F32:\n+      translated\n+\t= ctx->get_backend ()->named_type (\"f32\",\n+\t\t\t\t\t   ctx->get_backend ()->float_type (32),\n+\t\t\t\t\t   Linemap::predeclared_location ());\n+      return;\n+\n+    case TyTy::FloatType::F64:\n+      translated\n+\t= ctx->get_backend ()->named_type (\"f64\",\n+\t\t\t\t\t   ctx->get_backend ()->float_type (64),\n+\t\t\t\t\t   Linemap::predeclared_location ());\n+      return;\n+    }\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::USizeType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  translated = ctx->get_backend ()->named_type (\n+    \"usize\",\n+    ctx->get_backend ()->integer_type (\n+      true, ctx->get_backend ()->get_pointer_size ()),\n+    Linemap::predeclared_location ());\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::ISizeType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  translated = ctx->get_backend ()->named_type (\n+    \"isize\",\n+    ctx->get_backend ()->integer_type (\n+      false, ctx->get_backend ()->get_pointer_size ()),\n+    Linemap::predeclared_location ());\n }\n \n void\n TyTyResolveCompile::visit (const TyTy::CharType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  translated\n+    = ctx->get_backend ()->named_type (\"char\",\n+\t\t\t\t       ctx->get_backend ()->wchar_type (),\n+\t\t\t\t       Linemap::predeclared_location ());\n }\n \n void\n@@ -501,10 +562,10 @@ TyTyResolveCompile::visit (const TyTy::PointerType &type)\n void\n TyTyResolveCompile::visit (const TyTy::StrType &type)\n {\n-  tree compiled_type = nullptr;\n-  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-  rust_assert (ok);\n-  translated = compiled_type;\n+  tree raw_str = ctx->get_backend ()->raw_str_type ();\n+  translated\n+    = ctx->get_backend ()->named_type (\"str\", raw_str,\n+\t\t\t\t       Linemap::predeclared_location ());\n }\n \n void\n@@ -523,9 +584,6 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n       return;\n     }\n \n-  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-    return;\n-\n   // create implicit struct\n   auto items = type.get_object_items ();\n   std::vector<Backend::typed_identifier> fields;\n@@ -547,14 +605,8 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n   fields.push_back (std::move (vtf));\n \n   tree type_record = ctx->get_backend ()->struct_type (fields);\n-  tree named_struct\n-    = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t       type.get_ident ().locus);\n-\n-  ctx->push_type (named_struct);\n-  translated = named_struct;\n-\n-  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  translated = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n }\n \n } // namespace Compile"}, {"sha": "3e1f903f76154c40646312b46a22e2d66f606199", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -28,12 +28,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n {\n public:\n   static tree compile (Context *ctx, const TyTy::BaseType *ty,\n-\t\t       bool trait_object_mode = false)\n-  {\n-    TyTyResolveCompile compiler (ctx, trait_object_mode);\n-    ty->accept_vis (compiler);\n-    return compiler.translated;\n-  }\n+\t\t       bool trait_object_mode = false);\n \n   static tree get_implicit_enumeral_node_type (Context *ctx);\n \n@@ -62,6 +57,9 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n   void visit (const TyTy::DynamicObjectType &) override;\n   void visit (const TyTy::ClosureType &) override;\n \n+public:\n+  static hashval_t type_hasher (tree type);\n+\n private:\n   TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n     : ctx (ctx), trait_object_mode (trait_object_mode),\n@@ -72,8 +70,8 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n   bool trait_object_mode;\n   tree translated;\n \n+  // FIXME this needs to be derived from the gcc config option\n   size_t recursion_count;\n-\n   static const size_t kDefaultRecusionLimit = 5;\n };\n "}, {"sha": "52ad2f94c1214bcdb59f4a0c90b36885ac1c9f73", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ad0ea3e0ed288569d52556b9aa796beea73d8a3/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=5ad0ea3e0ed288569d52556b9aa796beea73d8a3", "patch": "@@ -1,260 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_COMPILE_TYTY\n-#define RUST_COMPILE_TYTY\n-\n-#include \"rust-system.h\"\n-#include \"rust-location.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-backend.h\"\n-#include \"rust-tyty.h\"\n-#include \"rust-tyty-visitor.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-hir-full.h\"\n-\n-namespace Rust {\n-namespace Compile {\n-\n-class TyTyCompile : public TyTy::TyVisitor\n-{\n-public:\n-  static tree compile (::Backend *backend, TyTy::BaseType *ty)\n-  {\n-    TyTyCompile compiler (backend);\n-    ty->accept_vis (compiler);\n-    rust_assert (compiler.translated != nullptr);\n-    return compiler.translated;\n-  }\n-\n-  void visit (TyTy::ErrorType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::InferType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ADTType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::TupleType &type) override\n-  {\n-    // this interface is only for unit-type the -type interface takes into\n-    // account the context\n-    rust_assert (type.num_fields () == 0);\n-    translated = backend->unit_type ();\n-  }\n-\n-  void visit (TyTy::ArrayType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::SliceType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::PointerType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnPtr &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnType &type) override\n-  {\n-    Backend::typed_identifier receiver;\n-    std::vector<Backend::typed_identifier> parameters;\n-    std::vector<Backend::typed_identifier> results;\n-\n-    if (!type.get_return_type ()->is_unit ())\n-      {\n-\tauto hir_type = type.get_return_type ();\n-\tauto ret = TyTyCompile::compile (backend, hir_type);\n-\tresults.push_back (Backend::typed_identifier (\n-\t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n-      }\n-\n-    for (auto &params : type.get_params ())\n-      {\n-\tauto param_pattern = params.first;\n-\tauto param_tyty = params.second;\n-\tauto compiled_param_type = TyTyCompile::compile (backend, param_tyty);\n-\n-\tauto compiled_param = Backend::typed_identifier (\n-\t  param_pattern->as_string (), compiled_param_type,\n-\t  mappings->lookup_location (param_tyty->get_ref ()));\n-\n-\tparameters.push_back (compiled_param);\n-      }\n-\n-    if (!type.is_varadic ())\n-      translated\n-\t= backend->function_type (receiver, parameters, results, NULL,\n-\t\t\t\t  mappings->lookup_location (type.get_ref ()));\n-    else\n-      translated\n-\t= backend->function_type_varadic (receiver, parameters, results, NULL,\n-\t\t\t\t\t  mappings->lookup_location (\n-\t\t\t\t\t    type.get_ref ()));\n-  }\n-\n-  void visit (TyTy::BoolType &) override\n-  {\n-    translated = backend->named_type (\"bool\", backend->bool_type (),\n-\t\t\t\t      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::IntType &type) override\n-  {\n-    switch (type.get_int_kind ())\n-      {\n-      case TyTy::IntType::I8:\n-\ttranslated\n-\t  = backend->named_type (\"i8\", backend->integer_type (false, 8),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I16:\n-\ttranslated\n-\t  = backend->named_type (\"i16\", backend->integer_type (false, 16),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I32:\n-\ttranslated\n-\t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I64:\n-\ttranslated\n-\t  = backend->named_type (\"i64\", backend->integer_type (false, 64),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::IntType::I128:\n-\ttranslated\n-\t  = backend->named_type (\"i128\", backend->integer_type (false, 128),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-      }\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::UintType &type) override\n-  {\n-    switch (type.get_uint_kind ())\n-      {\n-      case TyTy::UintType::U8:\n-\ttranslated = backend->named_type (\"u8\", backend->integer_type (true, 8),\n-\t\t\t\t\t  Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U16:\n-\ttranslated\n-\t  = backend->named_type (\"u16\", backend->integer_type (true, 16),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U32:\n-\ttranslated\n-\t  = backend->named_type (\"u32\", backend->integer_type (true, 32),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U64:\n-\ttranslated\n-\t  = backend->named_type (\"u64\", backend->integer_type (true, 64),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::UintType::U128:\n-\ttranslated\n-\t  = backend->named_type (\"u128\", backend->integer_type (true, 128),\n-\t\t\t\t Linemap::predeclared_location ());\n-\treturn;\n-      }\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::FloatType &type) override\n-  {\n-    switch (type.get_float_kind ())\n-      {\n-      case TyTy::FloatType::F32:\n-\ttranslated = backend->named_type (\"f32\", backend->float_type (32),\n-\t\t\t\t\t  Linemap::predeclared_location ());\n-\treturn;\n-\n-      case TyTy::FloatType::F64:\n-\ttranslated = backend->named_type (\"f64\", backend->float_type (64),\n-\t\t\t\t\t  Linemap::predeclared_location ());\n-\treturn;\n-      }\n-\n-    gcc_unreachable ();\n-  }\n-\n-  void visit (TyTy::USizeType &) override\n-  {\n-    translated = backend->named_type (\n-      \"usize\", backend->integer_type (true, backend->get_pointer_size ()),\n-      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::ISizeType &) override\n-  {\n-    translated = backend->named_type (\n-      \"isize\", backend->integer_type (false, backend->get_pointer_size ()),\n-      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::CharType &) override\n-  {\n-    translated = backend->named_type (\"char\", backend->wchar_type (),\n-\t\t\t\t      Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::StrType &) override\n-  {\n-    tree raw_str = backend->raw_str_type ();\n-    translated\n-      = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n-  }\n-\n-  void visit (TyTy::NeverType &) override\n-  {\n-    translated = backend->unit_type ();\n-  }\n-\n-  void visit (TyTy::DynamicObjectType &) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ClosureType &) override { gcc_unreachable (); }\n-\n-private:\n-  TyTyCompile (::Backend *backend)\n-    : backend (backend), translated (nullptr),\n-      mappings (Analysis::Mappings::get ())\n-  {}\n-\n-  ::Backend *backend;\n-  tree translated;\n-  Analysis::Mappings *mappings;\n-};\n-\n-} // namespace Compile\n-} // namespace Rust\n-\n-#endif // RUST_COMPILE_TYTY"}, {"sha": "6d5a64f8bce0c7b1dce77c7dd53593ca13601443", "filename": "gcc/rust/backend/rust-mangle.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-mangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee/gcc%2Frust%2Fbackend%2Frust-mangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.h?ref=39ae84825c5cc15edbb2fa9f5ecc70f93870e3ee", "patch": "@@ -17,7 +17,8 @@\n #ifndef RUST_MANGLE_H\n #define RUST_MANGLE_H\n \n-#include \"rust-compile-tyty.h\"\n+#include \"rust-system.h\"\n+#include \"rust-tyty.h\"\n \n namespace Rust {\n namespace Compile {"}]}