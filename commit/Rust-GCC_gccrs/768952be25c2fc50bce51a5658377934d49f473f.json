{"sha": "768952be25c2fc50bce51a5658377934d49f473f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY4OTUyYmUyNWMyZmM1MGJjZTUxYTU2NTgzNzc5MzRkNDlmNDczZg==", "commit": {"author": {"name": "Martin Uecker", "email": "uecker@eecs.berkeley.edu", "date": "2014-12-20T00:29:16Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2014-12-20T00:29:16Z"}, "message": "invoke.texi: Document -Wdiscarded-array-qualifiers.\n\n2014-12-20  Martin Uecker <uecker@eecs.berkeley.edu>\n\n\t* doc/invoke.texi: Document -Wdiscarded-array-qualifiers.\n\t* doc/extend.texi: Document new behavior for pointers to arrays\n\twith qualifiers.\n\nc/\n\t* c-typeck.c: New behavious for pointers to arrays with qualifiers\n        (common-pointer-type): For pointers to arrays take qualifiers from\n\telement type.\n        (build_conditional_expr): Add warnings for lost qualifiers.\n\t(comp-target-types): Allow pointers to arrays with different qualifiers.\n        (convert-for-assignment): Adapt warnings for discarded qualifiers. Add\n\tWARNING_FOR_QUALIFIERS macro and rename WARN_FOR_QUALIFIERS\n        to PEDWARN_FOR_QUALIFIERS.\n\nc-family/\n\t* c.opt (Wdiscarded-array-qualifiers): New option.\n\ntestsuite/\n\t* gcc.dg/Wwrite-strings-1.c: Change dg-warning.\n\t* gcc.dg/array-quals-1.c: Use -Wno-discarded-array-qualifiers.\n\t* gcc.dg/array-quals-2.c: Change dg-options, dg-warning.\n\t* gcc.dg/pointer-array-atomic.c: New test.\n\t* gcc.dg/pointer-array-quals-1.c: New test.\n\t* gcc.dg/pointer-array-quals-2.c: New test (-pedantic-errors).\n\t* gcc.dg/qual-component-1.c: Change dg-options, dg-warnings.\n\nFrom-SVN: r218985", "tree": {"sha": "0a8c1f437c3f3ba1a17e373c8796d2e79deb28f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a8c1f437c3f3ba1a17e373c8796d2e79deb28f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/768952be25c2fc50bce51a5658377934d49f473f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768952be25c2fc50bce51a5658377934d49f473f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768952be25c2fc50bce51a5658377934d49f473f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768952be25c2fc50bce51a5658377934d49f473f/comments", "author": {"login": "uecker", "id": 2036635, "node_id": "MDQ6VXNlcjIwMzY2MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/2036635?v=4", "gravatar_id": "", "url": "https://api.github.com/users/uecker", "html_url": "https://github.com/uecker", "followers_url": "https://api.github.com/users/uecker/followers", "following_url": "https://api.github.com/users/uecker/following{/other_user}", "gists_url": "https://api.github.com/users/uecker/gists{/gist_id}", "starred_url": "https://api.github.com/users/uecker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/uecker/subscriptions", "organizations_url": "https://api.github.com/users/uecker/orgs", "repos_url": "https://api.github.com/users/uecker/repos", "events_url": "https://api.github.com/users/uecker/events{/privacy}", "received_events_url": "https://api.github.com/users/uecker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "189486b85833690ab1ff75c604645ea3d22aa1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/189486b85833690ab1ff75c604645ea3d22aa1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/189486b85833690ab1ff75c604645ea3d22aa1e1"}], "stats": {"total": 716, "additions": 568, "deletions": 148}, "files": [{"sha": "bddb9a8b6fbbfe4b7f0ec4b42ed22e06d66cf968", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -1,3 +1,9 @@\n+2014-12-20  Martin Uecker <uecker@eecs.berkeley.edu>\n+\n+\t* doc/invoke.texi: Document -Wdiscarded-array-qualifiers.\n+\t* doc/extend.texi: Document new behavior for pointers to arrays\n+\twith qualifiers.\n+\n 2014-12-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* hash-table.h (struct pointer_hash): Fix formating."}, {"sha": "7c0538d5da4de5dc5118ce4343f6b08faaf393f6", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -1,3 +1,7 @@\n+2014-12-20  Martin Uecker <uecker@eecs.berkeley.edu>\n+\n+\t* c.opt (Wdiscarded-array-qualifiers): New option.\n+\n 2014-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/63831"}, {"sha": "f86718b26f497560a70654ce9b38f14d75f81347", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -387,6 +387,10 @@ Wdesignated-init\n C ObjC Var(warn_designated_init) Init(1) Warning\n Warn about positional initialization of structs requiring designated initializers\n \n+Wdiscarded-array-qualifiers\n+C ObjC Var(warn_discarded_array_qualifiers) Init(1) Warning\n+Warn if qualifiers on arrays which are pointer targets are discarded\n+\n Wdiscarded-qualifiers\n C ObjC Var(warn_discarded_qualifiers) Init(1) Warning\n Warn if type qualifiers on pointers are discarded"}, {"sha": "1661747d6046d5ef0e7debfbfd6096d99eeea240", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -1,3 +1,14 @@\n+2014-12-20  Martin Uecker <uecker@eecs.berkeley.edu>\n+\n+\t* c-typeck.c: New behavious for pointers to arrays with qualifiers\n+        (common-pointer-type): For pointers to arrays take qualifiers from\n+\telement type.\n+        (build_conditional_expr): Add warnings for lost qualifiers.\n+\t(comp-target-types): Allow pointers to arrays with different qualifiers.\n+        (convert-for-assignment): Adapt warnings for discarded qualifiers. Add\n+\tWARNING_FOR_QUALIFIERS macro and rename WARN_FOR_QUALIFIERS\n+        to PEDWARN_FOR_QUALIFIERS.\n+\n 2014-12-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/64289"}, {"sha": "abd452aed39cf05e262db2054811bf0338af7863", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 206, "deletions": 122, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -673,12 +673,13 @@ common_pointer_type (tree t1, tree t2)\n     mv2 = TYPE_MAIN_VARIANT (pointed_to_2);\n   target = composite_type (mv1, mv2);\n \n+  /* Strip array types to get correct qualifier for pointers to arrays */\n+  quals1 = TYPE_QUALS_NO_ADDR_SPACE (strip_array_types (pointed_to_1));\n+  quals2 = TYPE_QUALS_NO_ADDR_SPACE (strip_array_types (pointed_to_2));\n+\n   /* For function types do not merge const qualifiers, but drop them\n      if used inconsistently.  The middle-end uses these to mark const\n      and noreturn functions.  */\n-  quals1 = TYPE_QUALS_NO_ADDR_SPACE (pointed_to_1);\n-  quals2 = TYPE_QUALS_NO_ADDR_SPACE (pointed_to_2);\n-\n   if (TREE_CODE (pointed_to_1) == FUNCTION_TYPE)\n     target_quals = (quals1 & quals2);\n   else\n@@ -1224,6 +1225,7 @@ static int\n comp_target_types (location_t location, tree ttl, tree ttr)\n {\n   int val;\n+  int val_ped;\n   tree mvl = TREE_TYPE (ttl);\n   tree mvr = TREE_TYPE (ttr);\n   addr_space_t asl = TYPE_ADDR_SPACE (mvl);\n@@ -1235,19 +1237,32 @@ comp_target_types (location_t location, tree ttl, tree ttr)\n   if (!addr_space_superset (asl, asr, &as_common))\n     return 0;\n \n-  /* Do not lose qualifiers on element types of array types that are\n-     pointer targets by taking their TYPE_MAIN_VARIANT.  */\n-  if (TREE_CODE (mvl) != ARRAY_TYPE)\n-    mvl = (TYPE_ATOMIC (mvl)\n-\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvl), TYPE_QUAL_ATOMIC)\n-\t   : TYPE_MAIN_VARIANT (mvl));\n-  if (TREE_CODE (mvr) != ARRAY_TYPE)\n-    mvr = (TYPE_ATOMIC (mvr)\n-\t   ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvr), TYPE_QUAL_ATOMIC)\n-\t   : TYPE_MAIN_VARIANT (mvr));\n+  /* For pedantic record result of comptypes on arrays before losing\n+     qualifiers on the element type below. */\n+  val_ped = 1;\n+\n+  if (TREE_CODE (mvl) == ARRAY_TYPE\n+      && TREE_CODE (mvr) == ARRAY_TYPE)\n+    val_ped = comptypes (mvl, mvr);\n+\n+  /* Qualifiers on element types of array types that are\n+     pointer targets are lost by taking their TYPE_MAIN_VARIANT.  */\n+\n+  mvl = (TYPE_ATOMIC (strip_array_types (mvl))\n+\t ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvl), TYPE_QUAL_ATOMIC)\n+\t : TYPE_MAIN_VARIANT (mvl));\n+\n+  mvr = (TYPE_ATOMIC (strip_array_types (mvr))\n+\t ? c_build_qualified_type (TYPE_MAIN_VARIANT (mvr), TYPE_QUAL_ATOMIC)\n+\t : TYPE_MAIN_VARIANT (mvr));\n+\n   enum_and_int_p = false;\n   val = comptypes_check_enum_int (mvl, mvr, &enum_and_int_p);\n \n+  if (val == 1 && val_ped != 1)\n+    pedwarn (location, OPT_Wpedantic, \"pointers to arrays with different qualifiers \"\n+                                      \"are incompatible in ISO C\");\n+\n   if (val == 2)\n     pedwarn (location, OPT_Wpedantic, \"types are not quite compatible\");\n \n@@ -4609,6 +4624,13 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n       else if (VOID_TYPE_P (TREE_TYPE (type1))\n \t       && !TYPE_ATOMIC (TREE_TYPE (type1)))\n \t{\n+\t  if ((TREE_CODE (TREE_TYPE (type2)) == ARRAY_TYPE)\n+\t      && (TYPE_QUALS (strip_array_types (TREE_TYPE (type2)))\n+\t\t  & ~TYPE_QUALS (TREE_TYPE (type1))))\n+\t    warning_at (colon_loc, OPT_Wdiscarded_array_qualifiers,\n+\t\t\t\"pointer to array loses qualifier \"\n+\t\t\t\"in conditional expression\");\n+\n \t  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)\n \t    pedwarn (colon_loc, OPT_Wpedantic,\n \t\t     \"ISO C forbids conditional expr between \"\n@@ -4619,6 +4641,13 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n       else if (VOID_TYPE_P (TREE_TYPE (type2))\n \t       && !TYPE_ATOMIC (TREE_TYPE (type2)))\n \t{\n+\t  if ((TREE_CODE (TREE_TYPE (type1)) == ARRAY_TYPE)\n+\t      && (TYPE_QUALS (strip_array_types (TREE_TYPE (type1)))\n+\t\t  & ~TYPE_QUALS (TREE_TYPE (type2))))\n+\t    warning_at (colon_loc, OPT_Wdiscarded_array_qualifiers,\n+\t\t\t\"pointer to array loses qualifier \"\n+\t\t\t\"in conditional expression\");\n+\n \t  if (TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE)\n \t    pedwarn (colon_loc, OPT_Wpedantic,\n \t\t     \"ISO C forbids conditional expr between \"\n@@ -5661,7 +5690,7 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n      compile time.  */\n-#define WARN_FOR_ASSIGNMENT(LOCATION, PLOC, OPT, AR, AS, IN, RE)\t \\\n+#define PEDWARN_FOR_ASSIGNMENT(LOCATION, PLOC, OPT, AR, AS, IN, RE)\t \\\n   do {                                                                   \\\n     switch (errtype)                                                     \\\n       {                                                                  \\\n@@ -5688,10 +5717,9 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n-     compile time.  It is the same as WARN_FOR_ASSIGNMENT but with an\n+     compile time.  It is the same as PEDWARN_FOR_ASSIGNMENT but with an\n      extra parameter to enumerate qualifiers.  */\n-\n-#define WARN_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS)  \\\n+#define PEDWARN_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS) \\\n   do {                                                                   \\\n     switch (errtype)                                                     \\\n       {                                                                  \\\n@@ -5716,6 +5744,35 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n       }                                                                  \\\n   } while (0)\n \n+  /* This macro is used to emit diagnostics to ensure that all format\n+     strings are complete sentences, visible to gettext and checked at\n+     compile time.  It is the same as PEDWARN_FOR_QUALIFIERS but uses\n+     warning_at instead of pedwarn.  */\n+#define WARNING_FOR_QUALIFIERS(LOCATION, PLOC, OPT, AR, AS, IN, RE, QUALS) \\\n+  do {                                                                   \\\n+    switch (errtype)                                                     \\\n+      {                                                                  \\\n+      case ic_argpass:                                                   \\\n+        if (warning_at (PLOC, OPT, AR, parmnum, rname, QUALS))           \\\n+          inform ((fundecl && !DECL_IS_BUILTIN (fundecl))                \\\n+                  ? DECL_SOURCE_LOCATION (fundecl) : PLOC,               \\\n+                  \"expected %qT but argument is of type %qT\",            \\\n+                  type, rhstype);                                        \\\n+        break;                                                           \\\n+      case ic_assign:                                                    \\\n+        warning_at (LOCATION, OPT, AS, QUALS);                           \\\n+        break;                                                           \\\n+      case ic_init:                                                      \\\n+        warning_at (LOCATION, OPT, IN, QUALS);                           \\\n+        break;                                                           \\\n+      case ic_return:                                                    \\\n+        warning_at (LOCATION, OPT, RE, QUALS);                           \\\n+        break;                                                           \\\n+      default:                                                           \\\n+        gcc_unreachable ();                                              \\\n+      }                                                                  \\\n+  } while (0)\n+\n   if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n \n@@ -5758,15 +5815,15 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t  && TREE_CODE (type) == ENUMERAL_TYPE\n \t  && TYPE_MAIN_VARIANT (checktype) != TYPE_MAIN_VARIANT (type))\n \t{\n-\t  WARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wc___compat,\n-\t\t\t       G_(\"enum conversion when passing argument \"\n-\t\t\t\t  \"%d of %qE is invalid in C++\"),\n-\t\t\t       G_(\"enum conversion in assignment is \"\n-\t\t\t\t  \"invalid in C++\"),\n-\t\t\t       G_(\"enum conversion in initialization is \"\n-\t\t\t\t  \"invalid in C++\"),\n-\t\t\t       G_(\"enum conversion in return is \"\n-\t\t\t\t  \"invalid in C++\"));\n+\t  PEDWARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wc___compat,\n+\t\t\t          G_(\"enum conversion when passing argument \"\n+\t\t\t\t     \"%d of %qE is invalid in C++\"),\n+\t\t\t          G_(\"enum conversion in assignment is \"\n+\t\t\t\t     \"invalid in C++\"),\n+\t\t\t          G_(\"enum conversion in initialization is \"\n+\t\t\t\t     \"invalid in C++\"),\n+\t\t\t          G_(\"enum conversion in return is \"\n+\t\t\t\t     \"invalid in C++\"));\n \t}\n     }\n \n@@ -5921,34 +5978,34 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t     vice-versa.  */\n \t\t  if (TYPE_QUALS_NO_ADDR_SPACE (ttl)\n \t\t      & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))\n-\t\t    WARN_FOR_QUALIFIERS (location, expr_loc,\n-\t\t\t\t\t OPT_Wdiscarded_qualifiers,\n-\t\t\t\t\t G_(\"passing argument %d of %qE \"\n-\t\t\t\t\t    \"makes %q#v qualified function \"\n-\t\t\t\t\t    \"pointer from unqualified\"),\n-\t\t\t\t\t G_(\"assignment makes %q#v qualified \"\n-\t\t\t\t\t    \"function pointer from \"\n-\t\t\t\t\t    \"unqualified\"),\n-\t\t\t\t\t G_(\"initialization makes %q#v qualified \"\n-\t\t\t\t\t    \"function pointer from \"\n-\t\t\t\t\t    \"unqualified\"),\n-\t\t\t\t\t G_(\"return makes %q#v qualified function \"\n-\t\t\t\t\t    \"pointer from unqualified\"),\n-\t\t\t\t\t TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr));\n+\t\t    PEDWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t\t    OPT_Wdiscarded_qualifiers,\n+\t\t\t\t\t    G_(\"passing argument %d of %qE \"\n+\t\t\t\t\t       \"makes %q#v qualified function \"\n+\t\t\t\t\t       \"pointer from unqualified\"),\n+\t\t\t\t\t    G_(\"assignment makes %q#v qualified \"\n+\t\t\t\t\t       \"function pointer from \"\n+\t\t\t\t\t       \"unqualified\"),\n+\t\t\t\t\t    G_(\"initialization makes %q#v qualified \"\n+\t\t\t\t\t       \"function pointer from \"\n+\t\t\t\t\t       \"unqualified\"),\n+\t\t\t\t\t    G_(\"return makes %q#v qualified function \"\n+\t\t\t\t\t       \"pointer from unqualified\"),\n+\t\t\t\t\t    TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr));\n \t\t}\n \t      else if (TYPE_QUALS_NO_ADDR_SPACE (ttr)\n \t\t       & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))\n-\t\tWARN_FOR_QUALIFIERS (location, expr_loc,\n-\t\t\t\t     OPT_Wdiscarded_qualifiers,\n-\t\t\t\t     G_(\"passing argument %d of %qE discards \"\n-\t\t\t\t\t\"%qv qualifier from pointer target type\"),\n-\t\t\t\t     G_(\"assignment discards %qv qualifier \"\n-\t\t\t\t\t\"from pointer target type\"),\n-\t\t\t\t     G_(\"initialization discards %qv qualifier \"\n-\t\t\t\t\t\"from pointer target type\"),\n-\t\t\t\t     G_(\"return discards %qv qualifier from \"\n-\t\t\t\t\t\"pointer target type\"),\n-\t\t\t\t     TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n+\t\tPEDWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t        OPT_Wdiscarded_qualifiers,\n+\t\t\t\t        G_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t   \"%qv qualifier from pointer target type\"),\n+\t\t\t\t        G_(\"assignment discards %qv qualifier \"\n+\t\t\t\t\t   \"from pointer target type\"),\n+\t\t\t\t        G_(\"initialization discards %qv qualifier \"\n+\t\t\t\t\t   \"from pointer target type\"),\n+\t\t\t\t        G_(\"return discards %qv qualifier from \"\n+\t\t\t\t\t   \"pointer target type\"),\n+\t\t\t\t        TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n \n \t      memb = marginal_memb;\n \t    }\n@@ -6096,42 +6153,69 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t  == c_common_signed_type (mvr))\n \t      && TYPE_ATOMIC (mvl) == TYPE_ATOMIC (mvr)))\n \t{\n-\t  if (pedantic\n+\t  /* Warn about loss of qualifers from pointers to arrays with\n+\t     qualifiers on the element type. */\n+\t  if (TREE_CODE (ttr) == ARRAY_TYPE)\n+\t    {\n+\t      ttr = strip_array_types (ttr);\n+\t      ttl = strip_array_types (ttl);\n+\n+\t      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n+\t\t  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))\n+\t\tWARNING_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t        OPT_Wdiscarded_array_qualifiers,\n+\t\t\t\t        G_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t   \"%qv qualifier from pointer target type\"),\n+\t\t\t\t        G_(\"assignment discards %qv qualifier \"\n+\t\t\t\t\t   \"from pointer target type\"),\n+\t\t\t\t        G_(\"initialization discards %qv qualifier \"\n+\t\t\t\t\t   \"from pointer target type\"),\n+\t\t\t\t        G_(\"return discards %qv qualifier from \"\n+\t\t\t\t\t   \"pointer target type\"),\n+                                        TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n+            }\n+          else if (pedantic\n \t      && ((VOID_TYPE_P (ttl) && TREE_CODE (ttr) == FUNCTION_TYPE)\n \t\t  ||\n \t\t  (VOID_TYPE_P (ttr)\n \t\t   && !null_pointer_constant\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    WARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpedantic,\n-\t\t\t\t G_(\"ISO C forbids passing argument %d of \"\n-\t\t\t\t    \"%qE between function pointer \"\n-\t\t\t\t    \"and %<void *%>\"),\n-\t\t\t\t G_(\"ISO C forbids assignment between \"\n-\t\t\t\t    \"function pointer and %<void *%>\"),\n-\t\t\t\t G_(\"ISO C forbids initialization between \"\n-\t\t\t\t    \"function pointer and %<void *%>\"),\n-\t\t\t\t G_(\"ISO C forbids return between function \"\n-\t\t\t\t    \"pointer and %<void *%>\"));\n+\t    PEDWARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpedantic,\n+\t\t\t\t    G_(\"ISO C forbids passing argument %d of \"\n+\t\t\t\t       \"%qE between function pointer \"\n+\t\t\t\t       \"and %<void *%>\"),\n+\t\t\t\t    G_(\"ISO C forbids assignment between \"\n+\t\t\t\t       \"function pointer and %<void *%>\"),\n+\t\t\t\t    G_(\"ISO C forbids initialization between \"\n+\t\t\t\t       \"function pointer and %<void *%>\"),\n+\t\t\t\t    G_(\"ISO C forbids return between function \"\n+\t\t\t\t       \"pointer and %<void *%>\"));\n \t  /* Const and volatile mean something different for function types,\n \t     so the usual warnings are not appropriate.  */\n \t  else if (TREE_CODE (ttr) != FUNCTION_TYPE\n \t\t   && TREE_CODE (ttl) != FUNCTION_TYPE)\n \t    {\n+\t      /* Don't warn about loss of qualifier for conversions from\n+\t\t qualified void* to pointers to arrays with corresponding\n+\t\t qualifier on the element type. */\n+\t      if (!pedantic)\n+\t        ttl = strip_array_types (ttl);\n+\n \t      /* Assignments between atomic and non-atomic objects are OK.  */\n \t      if (TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttr)\n \t\t  & ~TYPE_QUALS_NO_ADDR_SPACE_NO_ATOMIC (ttl))\n \t\t{\n-\t\t  WARN_FOR_QUALIFIERS (location, expr_loc,\n-\t\t\t\t       OPT_Wdiscarded_qualifiers,\n-\t\t\t\t       G_(\"passing argument %d of %qE discards \"\n-\t\t\t\t\t  \"%qv qualifier from pointer target type\"),\n-\t\t\t\t       G_(\"assignment discards %qv qualifier \"\n-\t\t\t\t\t  \"from pointer target type\"),\n-\t\t\t\t       G_(\"initialization discards %qv qualifier \"\n-\t\t\t\t\t  \"from pointer target type\"),\n-\t\t\t\t       G_(\"return discards %qv qualifier from \"\n-\t\t\t\t\t  \"pointer target type\"),\n-\t\t\t\t       TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n+\t\t  PEDWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t          OPT_Wdiscarded_qualifiers,\n+\t\t\t\t          G_(\"passing argument %d of %qE discards \"\n+\t\t\t\t\t     \"%qv qualifier from pointer target type\"),\n+\t\t\t\t          G_(\"assignment discards %qv qualifier \"\n+\t\t\t\t\t     \"from pointer target type\"),\n+\t\t\t\t          G_(\"initialization discards %qv qualifier \"\n+\t\t\t\t\t     \"from pointer target type\"),\n+\t\t\t\t          G_(\"return discards %qv qualifier from \"\n+\t\t\t\t\t     \"pointer target type\"),\n+\t\t\t\t          TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl));\n \t\t}\n \t      /* If this is not a case of ignoring a mismatch in signedness,\n \t\t no warning.  */\n@@ -6140,15 +6224,15 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t;\n \t      /* If there is a mismatch, do warn.  */\n \t      else if (warn_pointer_sign)\n-\t\tWARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpointer_sign,\n-\t\t\t\t     G_(\"pointer targets in passing argument \"\n-\t\t\t\t\t\"%d of %qE differ in signedness\"),\n-\t\t\t\t     G_(\"pointer targets in assignment \"\n-\t\t\t\t\t\"differ in signedness\"),\n-\t\t\t\t     G_(\"pointer targets in initialization \"\n-\t\t\t\t\t\"differ in signedness\"),\n-\t\t\t\t     G_(\"pointer targets in return differ \"\n-\t\t\t\t\t\"in signedness\"));\n+\t\t PEDWARN_FOR_ASSIGNMENT (location, expr_loc, OPT_Wpointer_sign,\n+\t\t\t\t         G_(\"pointer targets in passing argument \"\n+\t\t\t\t\t    \"%d of %qE differ in signedness\"),\n+\t\t\t\t         G_(\"pointer targets in assignment \"\n+\t\t\t\t\t    \"differ in signedness\"),\n+\t\t\t\t         G_(\"pointer targets in initialization \"\n+\t\t\t\t\t    \"differ in signedness\"),\n+\t\t\t\t         G_(\"pointer targets in return differ \"\n+\t\t\t\t\t    \"in signedness\"));\n \t    }\n \t  else if (TREE_CODE (ttl) == FUNCTION_TYPE\n \t\t   && TREE_CODE (ttr) == FUNCTION_TYPE)\n@@ -6159,31 +6243,31 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_QUALS_NO_ADDR_SPACE (ttl)\n \t\t  & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))\n-\t\tWARN_FOR_QUALIFIERS (location, expr_loc,\n-\t\t\t\t     OPT_Wdiscarded_qualifiers,\n-\t\t\t\t     G_(\"passing argument %d of %qE makes \"\n-\t\t\t\t\t\"%q#v qualified function pointer \"\n-\t\t\t\t\t\"from unqualified\"),\n-\t\t\t\t     G_(\"assignment makes %q#v qualified function \"\n-\t\t\t\t\t\"pointer from unqualified\"),\n-\t\t\t\t     G_(\"initialization makes %q#v qualified \"\n-\t\t\t\t\t\"function pointer from unqualified\"),\n-\t\t\t\t     G_(\"return makes %q#v qualified function \"\n-\t\t\t\t\t\"pointer from unqualified\"),\n-\t\t\t\t     TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr));\n+\t\tPEDWARN_FOR_QUALIFIERS (location, expr_loc,\n+\t\t\t\t        OPT_Wdiscarded_qualifiers,\n+\t\t\t\t        G_(\"passing argument %d of %qE makes \"\n+\t\t\t\t\t   \"%q#v qualified function pointer \"\n+\t\t\t\t\t   \"from unqualified\"),\n+\t\t\t\t        G_(\"assignment makes %q#v qualified function \"\n+\t\t\t\t\t   \"pointer from unqualified\"),\n+\t\t\t\t        G_(\"initialization makes %q#v qualified \"\n+\t\t\t\t\t   \"function pointer from unqualified\"),\n+\t\t\t\t        G_(\"return makes %q#v qualified function \"\n+\t\t\t\t\t   \"pointer from unqualified\"),\n+\t\t\t\t        TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr));\n \t    }\n \t}\n       else\n \t/* Avoid warning about the volatile ObjC EH puts on decls.  */\n \tif (!objc_ok)\n-\t  WARN_FOR_ASSIGNMENT (location, expr_loc,\n-\t\t\t       OPT_Wincompatible_pointer_types,\n-\t\t\t       G_(\"passing argument %d of %qE from \"\n-\t\t\t\t  \"incompatible pointer type\"),\n-\t\t\t       G_(\"assignment from incompatible pointer type\"),\n-\t\t\t       G_(\"initialization from incompatible \"\n-\t\t\t\t  \"pointer type\"),\n-\t\t\t       G_(\"return from incompatible pointer type\"));\n+\t  PEDWARN_FOR_ASSIGNMENT (location, expr_loc,\n+\t\t\t          OPT_Wincompatible_pointer_types,\n+\t\t\t          G_(\"passing argument %d of %qE from \"\n+\t\t\t\t     \"incompatible pointer type\"),\n+\t\t\t          G_(\"assignment from incompatible pointer type\"),\n+\t\t\t          G_(\"initialization from incompatible \"\n+\t\t\t\t     \"pointer type\"),\n+\t\t\t          G_(\"return from incompatible pointer type\"));\n \n       return convert (type, rhs);\n     }\n@@ -6200,31 +6284,31 @@ convert_for_assignment (location_t location, location_t expr_loc, tree type,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n       if (!null_pointer_constant)\n-\tWARN_FOR_ASSIGNMENT (location, expr_loc,\n-\t\t\t     OPT_Wint_conversion,\n-\t\t\t     G_(\"passing argument %d of %qE makes \"\n-\t\t\t\t\"pointer from integer without a cast\"),\n-\t\t\t     G_(\"assignment makes pointer from integer \"\n-\t\t\t\t\"without a cast\"),\n-\t\t\t     G_(\"initialization makes pointer from \"\n-\t\t\t\t\"integer without a cast\"),\n-\t\t\t     G_(\"return makes pointer from integer \"\n-\t\t\t\t\"without a cast\"));\n+\tPEDWARN_FOR_ASSIGNMENT (location, expr_loc,\n+\t\t\t        OPT_Wint_conversion,\n+\t\t\t        G_(\"passing argument %d of %qE makes \"\n+\t\t\t\t   \"pointer from integer without a cast\"),\n+\t\t\t        G_(\"assignment makes pointer from integer \"\n+\t\t\t\t   \"without a cast\"),\n+\t\t\t        G_(\"initialization makes pointer from \"\n+\t\t\t\t   \"integer without a cast\"),\n+\t\t\t        G_(\"return makes pointer from integer \"\n+\t\t\t\t   \"without a cast\"));\n \n       return convert (type, rhs);\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n-      WARN_FOR_ASSIGNMENT (location, expr_loc,\n-\t\t\t   OPT_Wint_conversion,\n-\t\t\t   G_(\"passing argument %d of %qE makes integer \"\n-\t\t\t      \"from pointer without a cast\"),\n-\t\t\t   G_(\"assignment makes integer from pointer \"\n-\t\t\t      \"without a cast\"),\n-\t\t\t   G_(\"initialization makes integer from pointer \"\n-\t\t\t      \"without a cast\"),\n-\t\t\t   G_(\"return makes integer from pointer \"\n-\t\t\t      \"without a cast\"));\n+      PEDWARN_FOR_ASSIGNMENT (location, expr_loc,\n+\t\t\t      OPT_Wint_conversion,\n+\t\t\t      G_(\"passing argument %d of %qE makes integer \"\n+\t\t\t         \"from pointer without a cast\"),\n+\t\t\t      G_(\"assignment makes integer from pointer \"\n+\t\t\t         \"without a cast\"),\n+\t\t\t      G_(\"initialization makes integer from pointer \"\n+\t\t\t         \"without a cast\"),\n+\t\t\t      G_(\"return makes integer from pointer \"\n+\t\t\t         \"without a cast\"));\n       return convert (type, rhs);\n     }\n   else if (codel == BOOLEAN_TYPE && coder == POINTER_TYPE)"}, {"sha": "ffefb673efee243298d688ee9bb859b48c0eca7f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -46,6 +46,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Escaped Newlines::    Slightly looser rules for escaped newlines.\n * Subscripting::        Any array can be subscripted, even if not an lvalue.\n * Pointer Arith::       Arithmetic on @code{void}-pointers and function pointers.\n+* Pointers to Arrays::  Pointers to arrays with qualifiers work as expected.\n * Initializers::        Non-constant initializers.\n * Compound Literals::   Compound literals give structures, unions\n                         or arrays as values.\n@@ -1784,6 +1785,27 @@ and on function types, and returns 1.\n The option @option{-Wpointer-arith} requests a warning if these extensions\n are used.\n \n+@node Pointers to Arrays\n+@section Pointers to arrays with qualifiers work as expected\n+@cindex pointers to arrays\n+@cindex const qualifier\n+\n+In GNU C, pointers to arrays with qualifiers work similar to pointers\n+to other qualified types. For example, a value of type @code{int (*)[5]}\n+can be used to initialize a variable of type @code{const int (*)[5]}.\n+These types are incompatible in ISO C because the @code{const} qualifier\n+is formally attached to the element type of the array and not the\n+array itself.\n+\n+@smallexample\n+extern void\n+transpose (int N, int M, double out[M][N], const double in[N][M]);\n+double x[3][2];\n+double y[2][3];\n+@r{@dots{}}\n+transpose(3, 2, y, x);\n+@end smallexample\n+\n @node Initializers\n @section Non-Constant Initializers\n @cindex initializers, non-constant"}, {"sha": "9f56f42218d567417dfdbd0a59d88e695366069e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -248,7 +248,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wchar-subscripts -Wclobbered  -Wcomment -Wconditionally-supported  @gol\n -Wconversion -Wcoverage-mismatch -Wdate-time -Wdelete-incomplete -Wno-cpp  @gol\n -Wno-deprecated -Wno-deprecated-declarations -Wno-designated-init @gol\n--Wdisabled-optimization -Wno-discarded-qualifiers @gol\n+-Wdisabled-optimization @gol\n+-Wno-discarded-qualifiers -Wno-discarded-array-qualifiers @gol\n -Wno-div-by-zero -Wdouble-promotion -Wempty-body  -Wenum-compare @gol\n -Wno-endif-labels -Werror  -Werror=* @gol\n -Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol\n@@ -4300,9 +4301,18 @@ This warning is enabled by @option{-Wall}.\n @opindex Wdiscarded-qualifiers\n Do not warn if type qualifiers on pointers are being discarded.\n Typically, the compiler will warn if a @code{const char *} variable is\n-passed to a function that takes @code{char *} parameter.  This option\n+passed to a function that takes a @code{char *} parameter.  This option\n can be used to suppress such a warning.\n \n+@item -Wno-discarded-array-qualifiers @r{(C and Objective-C only)}\n+@opindex Wno-discarded-array-qualifiers\n+@opindex Wdiscarded-array-qualifiers\n+Do not warn if type qualifiers on arrays which are pointer targets\n+are being discarded. Typically, the compiler will warn if a\n+@code{const int (*)[]} variable is passed to a function that\n+takes a @code{int (*)[]} parameter.  This option can be used to\n+suppress such a warning.\n+\n @item -Wno-incompatible-pointer-types @r{(C and Objective-C only)}\n @opindex Wno-incompatible-pointer-types\n @opindex Wincompatible-pointer-types"}, {"sha": "fd6c398ef8827eef44788578ddafa0e570b5193c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -1,3 +1,13 @@\n+2014-12-20  Martin Uecker <uecker@eecs.berkeley.edu>\n+\n+\t* gcc.dg/Wwrite-strings-1.c: Change dg-warning.\n+\t* gcc.dg/array-quals-1.c: Use -Wno-discarded-array-qualifiers.\n+\t* gcc.dg/array-quals-2.c: Change dg-options, dg-warning.\n+\t* gcc.dg/pointer-array-atomic.c: New test.\n+\t* gcc.dg/pointer-array-quals-1.c: New test.\n+\t* gcc.dg/pointer-array-quals-2.c: New test (-pedantic-errors).\n+\t* gcc.dg/qual-component-1.c: Change dg-options, dg-warnings.\n+\n 2014-12-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* jit.dg/test-expressions.c (make_tests_of_casts): Add tests of"}, {"sha": "24547d02bd806aede20d3c5dbc96a6d3773a77be", "filename": "gcc/testsuite/gcc.dg/Wwrite-strings-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2FWwrite-strings-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2FWwrite-strings-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWwrite-strings-1.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -5,4 +5,4 @@\n /* { dg-do compile } */\n /* { dg-options \"-Wwrite-strings\" } */\n typedef char T[1];\n-T *p = &\"\"; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+T *p = &\"\"; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */"}, {"sha": "3981c916021d86ed2f89a770099ebed7ce3a2887", "filename": "gcc/testsuite/gcc.dg/array-quals-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-1.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -3,6 +3,7 @@\n    all should end up in a read-only section.  PR c/12165.  */\n /* Origin: Joseph Myers <jsm@polyomino.org.uk> */\n /* { dg-do compile } */\n+/* { dg-options \"-Wno-discarded-array-qualifiers\" } */\n /* The MMIX port always switches to the .data section at the end of a file.  */\n /* { dg-final { scan-assembler-not \"\\\\.data(?!\\\\.rel\\\\.ro)\" { xfail powerpc*-*-aix* mmix-*-* x86_64-*-mingw* } } } */\n static const int a[2] = { 1, 2 };"}, {"sha": "7f33e3fb2ce98f5b9217e7607f388588bf8d0fe1", "filename": "gcc/testsuite/gcc.dg/array-quals-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-quals-2.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -3,12 +3,12 @@\n    lost in forming composite types.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n /* { dg-do compile } */\n-/* { dg-options \"\" } */\n+/* { dg-options \"-pedantic -Wno-discarded-array-qualifiers\" } */\n typedef const char T[1];\n typedef const char T2[1];\n typedef volatile char U[1];\n T *p;\n T2 *p2;\n U *q;\n-void *f(void) { return 1 ? p : q; } /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+void *f(void) { return 1 ? p : q; } /* { dg-warning \"pointers to arrays with different qualifiers\" } */\n T *g(void) { return 1 ? p : p2; }"}, {"sha": "55b58e84e35b588fa2ca2e68e75722bd06500523", "filename": "gcc/testsuite/gcc.dg/pointer-array-atomic.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-atomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-atomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-atomic.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11\" } */\n+/* Origin: Martin Uecker <uecker@eecs.berkeley.edu> */\n+void tvoid(void* x);\n+void transpose0(double* out, _Atomic double* in) { }\n+void transpose1(double out[2][2], _Atomic double in[2][2]) { }\n+void transpose2(double out[2][2][2], _Atomic double in[2][2][2]) { }\n+// return\n+int (*x2(_Atomic int x[3][3]))[3] { return x; } /* { dg-warning \"return from incompatible pointer type\" } */\n+_Atomic int (*x3(int x[3][3]))[3] { return x; } /* { dg-warning \"return from incompatible pointer type\" } */\n+void test(void)\n+{\n+\tdouble x0[2];\n+\tdouble y0[2];\n+\t_Atomic double z0[4];\n+\tdouble x1[2][2];\n+\tdouble y1[2][2];\n+\tdouble o1[2][3];\n+\t_Atomic double z1[2][2];\n+\tdouble x2[2][2][2];\n+\tdouble y2[2][2][2];\n+\tdouble o2[2][2][3];\n+\t_Atomic double z2[2][2][2];\n+\ttvoid(z0);\n+\ttvoid(z1);\n+\ttvoid(z2);\n+\t// passing as arguments\n+\ttranspose0(y0, x0); /* { dg-warning \"passing argument 2 of 'transpose0' from incompatible pointer type\" } */\n+\ttranspose1(y1, o1); /* { dg-warning \"passing argument 2 of 'transpose1' from incompatible pointer type\" } */\n+\ttranspose1(y1, x1); /* { dg-warning \"passing argument 2 of 'transpose1' from incompatible pointer type\" } */\n+\ttranspose2(y2, o2); /* { dg-warning \"passing argument 2 of 'transpose2' from incompatible pointer type\" } */\n+\ttranspose2(y2, x2); /* { dg-warning \"passing argument 2 of 'transpose2' from incompatible pointer type\" } */\n+\t// initialization\n+\t_Atomic double (*x0p) = x0; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+\t_Atomic double (*x1p)[2] = x1; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+\t_Atomic double (*x2p)[2][2] = x2; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+\t// assignment\n+\tx0p = x0; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+\tx1p = x1; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+\tx2p = x2; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+\t// subtraction\n+\t&(x0[1]) - &(z0[0]); /* { dg-error \"invalid operands to binary\" } */\n+\t&(x1[1]) - &(z1[0]); /* { dg-error \"invalid operands to binary\" } */\n+\t&(x2[1]) - &(z2[0]); /* { dg-error \"invalid operands to binary\" } */\n+\t// comparison\n+\tx0 == z0; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx1 == z1; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx2 == z2; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx0 > z0; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx1 > z1; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx2 > z2; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx0 < z0; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx1 < z1; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\tx2 < z2; /* { dg-warning \"comparison of distinct pointer types lacks a cast\" } */\n+\t// conditional expressions\n+\t(void)(1 ? x0 : z0); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x1 : z1); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x2 : z2); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+}\n+"}, {"sha": "921a37e9e0d5b32104c1fa8b73d11ad54c6f927f", "filename": "gcc/testsuite/gcc.dg/pointer-array-quals-1.c", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-1.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -0,0 +1,106 @@\n+/* { dg-do compile } */\n+/* Origin: Martin Uecker <uecker@eecs.berkeley.edu> */\n+/* { dg-options \"-Wdiscarded-array-qualifiers\" } */\n+void tvoid(void* x);\n+void transpose0(double* out, const double* in) { }\n+void transpose1(double out[2][2], const double in[2][2]) { }\n+void transpose2(double out[2][2][2], const double in[2][2][2]) { }\n+// return\n+int (*y2(const int x[3][3]))[3] { return x; } /* { dg-warning \"return discards 'const' qualifier from pointer target type\" } */\n+const int (*y3(int x[3][3]))[3] { return x; }\n+void test(void)\n+{\n+\tdouble x0[2];\n+\tdouble y0[2];\n+\tconst double z0[4];\n+\tdouble x1[2][2];\n+\tdouble y1[2][2];\n+\tdouble o1[2][3];\n+\tconst double z1[2][2];\n+\tdouble x2[2][2][2];\n+\tdouble y2[2][2][2];\n+\tdouble o2[2][2][3];\n+\tconst double z2[2][2][2];\n+\t// void pointers\n+\ttvoid(x0);\n+\ttvoid(x1);\n+\ttvoid(x2);\n+\ttvoid(z0); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z1); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z2); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\tvoid* p;\n+\tconst void* pc;\n+\tp = x0;\n+\tp = x1;\n+\tp = x2;\n+\tp = z0; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z1; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z2; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tpc = x0;\n+\tpc = x1;\n+\tpc = x2;\n+\tpc = z0;\n+\tpc = z1;\n+\tpc = z2;\n+\ttranspose0(pc, p); /* { dg-warning \"passing argument 1 of 'transpose0' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose1(pc, p); /* { dg-warning \"passing argument 1 of 'transpose1' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose2(pc, p); /* { dg-warning \"passing argument 1 of 'transpose2' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose0(p, pc);\n+\ttranspose1(p, pc);\n+\ttranspose2(p, pc);\n+\t// passing as arguments\n+\ttranspose0(y0, x0);\n+\ttranspose1(y1, x1);\n+\ttranspose2(y2, x2);\n+\t// initialization\n+\tconst double (*u0p) = x0;\n+\tconst double (*u1p)[2] = x1;\n+\tconst double (*u2p)[2][2] = x2;\n+\tdouble (*v0p) = z0; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v1p)[2] = z1; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v2p)[2][2] = z2; /* { dg-warning \"initialization discards 'const' qualifier from pointer target type\" } */\n+\t// subtraction\n+\t&(x0[1]) - &(z0[0]);\n+\t&(x1[1]) - &(z1[0]);\n+\t&(x2[1]) - &(z2[0]);\n+\t// comparison\n+\tx0 == z0;\n+\tx1 == z1;\n+\tx2 == z2;\n+\tx0 < z0; \n+\tx1 < z1; \n+\tx2 < z2; \n+\tx0 > z0;\n+\tx1 > z1;\n+\tx2 > z2;\n+\t// assignment\n+\tu0p = x0;\n+\tu1p = x1;\n+\tu2p = x2;\n+\tv0p = z0; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = z1; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = z2; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\t// conditional expressions\n+\t(void)(1 ? x0 : z0);\n+\t(void)(1 ? x1 : z1);\n+\t(void)(1 ? x2 : z2);\n+\t(void)(1 ? x0 : x1); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x1 : x2); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x2 : x0); /* { dg-warning \"pointer type mismatch in conditional expression\" } */\n+\tv0p = (1 ? z0 : v0p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? z1 : v1p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? z2 : v2p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv0p = (1 ? x0 : u0p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? x1 : u1p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? x2 : u2p); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\t(1 ? x0 : z0)[0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x1 : z1)[0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x2 : z2)[0][0][0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\tv0p = (1 ? p : z0); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? p : z1); /* { dg-warning \"pointer to array loses qualifier in conditional expression\" } */\n+\tv2p = (1 ? p : z2); /* { dg-warning \"pointer to array loses qualifier in conditional expression\" } */\n+\tv0p = (1 ? pc : x0); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? pc : x1); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? pc : x2); /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+}\n+"}, {"sha": "30689c7312d56715d8d5115230ae91a1494d40d9", "filename": "gcc/testsuite/gcc.dg/pointer-array-quals-2.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpointer-array-quals-2.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wdiscarded-array-qualifiers -pedantic-errors\" } */\n+/* Origin: Martin Uecker <uecker@eecs.berkeley.edu> */\n+void tvoid(void* x);\n+void transpose0(double* out, const double* in) { }\n+void transpose1(double out[2][2], const double in[2][2]) { }\n+void transpose2(double out[2][2][2], const double in[2][2][2]) { }\n+// return\n+int (*x2(const int x[3][3]))[3] { return x; } /* { dg-error \"pointers to arrays with different qualifiers|return discards\" } */\n+const int (*x3(int x[3][3]))[3] { return x; } /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+void test(void)\n+{\n+\tdouble x0[2];\n+\tdouble y0[2];\n+\tconst double z0[4];\n+\tdouble x1[2][2];\n+\tdouble y1[2][2];\n+\tdouble o1[2][3];\n+\tconst double z1[2][2];\n+\tdouble x2[2][2][2];\n+\tdouble y2[2][2][2];\n+\tdouble o2[2][2][3];\n+\tconst double z2[2][2][2];\n+\t// void pointers\n+\ttvoid(z0); /* { dg-error \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z1); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\ttvoid(z2); /* { dg-warning \"passing argument 1 of 'tvoid' discards 'const' qualifier from pointer target type\" } */\n+\tvoid* p;\n+\tconst void* pc;\n+\tp = x0;\n+\tp = x1;\n+\tp = x2;\n+\tp = z0; /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z1; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tp = z2; /* { dg-warning \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tpc = x0;\n+\tpc = x1;\n+\tpc = x2;\n+\tpc = z0;\n+\tpc = z1;\n+\tpc = z2;\n+\ttranspose0(pc, p); /* { dg-error \"passing argument 1 of 'transpose0' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose1(pc, p); /* { dg-error \"passing argument 1 of 'transpose1' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose2(pc, p); /* { dg-error \"passing argument 1 of 'transpose2' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose0(p, pc);\n+\ttranspose1(p, pc); /* { dg-error \"passing argument 2 of 'transpose1' discards 'const' qualifier from pointer target type\" } */\n+\ttranspose2(p, pc); /* { dg-error \"passing argument 2 of 'transpose2' discards 'const' qualifier from pointer target type\" } */\n+\t// passing as arguments\n+\ttranspose0(y0, x0);\n+\ttranspose1(y1, o1); /* { dg-error \"passing argument 2 of 'transpose1' from incompatible pointer type\" } */\n+\ttranspose1(y1, x1); /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\ttranspose2(y2, o2); /* { dg-error \"passing argument 2 of 'transpose2' from incompatible pointer type\" } */\n+\ttranspose2(y2, x2); /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t// initialization\n+\tconst double (*x0p) = x0;\n+\tconst double (*x1p)[2] = x1; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tconst double (*x2p)[2][2] = x2; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tdouble (*v0p) = z0; /* { dg-error \"initialization discards 'const' qualifier from pointer target type\" } */\n+\tdouble (*v1p)[2] = z1; /* { dg-error \"pointers to arrays with different qualifiers|initialization discards\" } */\n+\tdouble (*v2p)[2][2] = z2; /* { dg-error \"pointers to arrays with different qualifiers|initialization discards\" } */\n+\t// assignment\n+\tx0p = x0;\n+\tx1p = x1; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tx2p = x2; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t// subtraction\n+\t&(x0[1]) - &(z0[0]);\n+\t&(x1[1]) - &(z1[0]); /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t&(x2[1]) - &(z2[0]); /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t// comparison\n+\tx0 == z0;\n+\tx1 == z1; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tx2 == z2; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tx0 < z0;\n+\tx1 < z1; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tx2 < z2; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tx0 > z0;\n+\tx1 > z1; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\tx2 > z2; /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t// conditional expressions\n+\t(void)(1 ? x0 : z0);\n+\t(void)(1 ? x1 : z1); /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t(void)(1 ? x2 : z2); /* { dg-error \"pointers to arrays with different qualifiers\" } */\n+\t(void)(1 ? x0 : x1); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x1 : x2); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\t(void)(1 ? x2 : x0); /* { dg-error \"pointer type mismatch in conditional expression\" } */\n+\tv0p = (1 ? z0 : v0p); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? z1 : v1p); /* { dg-error \"pointers to arrays with different qualifiers|assignment discards\" } */\n+\tv2p = (1 ? z2 : v2p); /* { dg-error \"pointers to arrays with different qualifiers|assignment discards\" } */\n+\tv0p = (1 ? x0 : x0p); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? x1 : x1p); /* { dg-error \"pointers to arrays with different qualifiers|assignment discards\" } */\n+\tv2p = (1 ? x2 : x2p); /* { dg-error \"pointers to arrays with different qualifiers|assignment discards\" } */\n+\t(1 ? x0 : z0)[0] = 1; /* { dg-error \"assignment of read-only location\" } */\n+\t(1 ? x1 : z1)[0][0] = 1; /* { dg-error \"assignment of read-only location|pointers to arrays\" } */\n+\t(1 ? x2 : z2)[0][0][0] = 1; /* { dg-error \"assignment of read-only location|pointers to arrays\" } */\n+\tv0p = (1 ? p : z0); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? p : z1); /* { dg-warning \"pointer to array loses qualifier in conditional expression\" } */\n+\tv2p = (1 ? p : z2); /* { dg-warning \"pointer to array loses qualifier in conditional expression\" } */\n+\tv0p = (1 ? pc : x0); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv1p = (1 ? pc : x1); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+\tv2p = (1 ? pc : x2); /* { dg-error \"assignment discards 'const' qualifier from pointer target type\" } */\n+}\n+"}, {"sha": "4eaa71a2d19acdad57e339e14014c9bc86570926", "filename": "gcc/testsuite/gcc.dg/qual-component-1.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fqual-component-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/768952be25c2fc50bce51a5658377934d49f473f/gcc%2Ftestsuite%2Fgcc.dg%2Fqual-component-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fqual-component-1.c?ref=768952be25c2fc50bce51a5658377934d49f473f", "patch": "@@ -3,7 +3,7 @@\n    union.  Bug 27697 from Frank Victor Fischer.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n /* { dg-do compile } */\n-/* { dg-options \"\" } */\n+/* { dg-options \"-pedantic -Wdiscarded-array-qualifiers\" } */\n \n struct s {\n   int a;\n@@ -110,123 +110,123 @@ g (void)\n     int (*b)[1] = &v1.b;\n     int (*c)[2][3] = &v1.c;\n     int (*cc)[3] = v1.c;\n-    const int (*ff)[3] = v1.c; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    const int (*ff)[3] = v1.c; /* { dg-warning \"pointers to arrays with different qualifiers\" } */\n     a = &v1.a;\n     b = &v1.b;\n     c = &v1.c;\n     cc = v1.c;\n-    ff = v1.c; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    ff = v1.c; /* { dg-warning \"pointers to arrays with different qualifiers\" } */\n   }\n   {\n     const int *d = &v1.d;\n     const int (*e)[1] = &v1.e;\n     const int (*f)[2][3] = &v1.f;\n     const int (*ff)[3] = v1.f;\n-    int (*cc)[3] = v1.f; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v1.f; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v1.d;\n     e = &v1.e;\n     f = &v1.f;\n     ff = v1.f;\n-    cc = v1.f; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v1.f; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n \n   {\n     int *a = &v2->a;\n     int (*b)[1] = &v2->b;\n     int (*c)[2][3] = &v2->c;\n     int (*cc)[3] = v2->c;\n-    const int (*ff)[3] = v2->c; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    const int (*ff)[3] = v2->c; /* { dg-warning \"pointers to arrays with different qualifiers\" } */\n     a = &v2->a;\n     b = &v2->b;\n     c = &v2->c;\n     cc = v2->c;\n-    ff = v2->c; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    ff = v2->c; /* { dg-warning \"pointers to arrays with different qualifiers\" } */\n   }\n   {\n     const int *d = &v2->d;\n     const int (*e)[1] = &v2->e;\n     const int (*f)[2][3] = &v2->f;\n     const int (*ff)[3] = v2->f;\n-    int (*cc)[3] = v2->f; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v2->f; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v2->d;\n     e = &v2->e;\n     f = &v2->f;\n     ff = v2->f;\n-    cc = v2->f; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v2->f; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n \n   {\n     const int *d = &v3->a;\n     const int (*e)[1] = &v3->b;\n     const int (*f)[2][3] = &v3->c;\n     const int (*ff)[3] = v3->c;\n-    int (*cc)[3] = v3->c; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v3->c; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v3->a;\n     e = &v3->b;\n     f = &v3->c;\n     ff = v3->c;\n-    cc = v3->c; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v3->c; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n   {\n     const int *d = &v3->d;\n     const int (*e)[1] = &v3->e;\n     const int (*f)[2][3] = &v3->f;\n     const int (*ff)[3] = v3->f;\n-    int (*cc)[3] = v3->f; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v3->f; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v3->d;\n     e = &v3->e;\n     f = &v3->f;\n     ff = v3->f;\n-    cc = v3->f; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v3->f; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n \n   {\n     const int *d = &v4.a;\n     const int (*e)[1] = &v4.b;\n     const int (*f)[2][3] = &v4.c;\n     const int (*ff)[3] = v4.c;\n-    int (*cc)[3] = v4.c; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v4.c; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v4.a;\n     e = &v4.b;\n     f = &v4.c;\n     ff = v4.c;\n-    cc = v4.c; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v4.c; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n   {\n     const int *d = &v4.d;\n     const int (*e)[1] = &v4.e;\n     const int (*f)[2][3] = &v4.f;\n     const int (*ff)[3] = v4.f;\n-    int (*cc)[3] = v4.f; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v4.f; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v4.d;\n     e = &v4.e;\n     f = &v4.f;\n     ff = v4.f;\n-    cc = v4.f; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v4.f; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n \n   {\n     const int *d = &v5.x.a;\n     const int (*e)[1] = &v5.x.b;\n     const int (*f)[2][3] = &v5.x.c;\n     const int (*ff)[3] = v5.x.c;\n-    int (*cc)[3] = v5.x.c; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v5.x.c; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v5.x.a;\n     e = &v5.x.b;\n     f = &v5.x.c;\n     ff = v5.x.c;\n-    cc = v5.x.c; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v5.x.c; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n   {\n     const int *d = &v5.x.d;\n     const int (*e)[1] = &v5.x.e;\n     const int (*f)[2][3] = &v5.x.f;\n     const int (*ff)[3] = v5.x.f;\n-    int (*cc)[3] = v5.x.f; /* { dg-warning \"initialization from incompatible pointer type\" } */\n+    int (*cc)[3] = v5.x.f; /* { dg-warning \"pointers to arrays with different qualifiers|initialization discards\" } */\n     d = &v5.x.d;\n     e = &v5.x.e;\n     f = &v5.x.f;\n     ff = v5.x.f;\n-    cc = v5.x.f; /* { dg-warning \"assignment from incompatible pointer type\" } */\n+    cc = v5.x.f; /* { dg-warning \"pointers to arrays with different qualifiers|assignment discards\" } */\n   }\n }"}]}