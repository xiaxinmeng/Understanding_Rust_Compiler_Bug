{"sha": "65f914e714d985db7eaaa8e63a210b4fee17b13f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVmOTE0ZTcxNGQ5ODVkYjdlYWFhOGU2M2EyMTBiNGZlZTE3YjEzZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:18:45Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:18:45Z"}, "message": "poly_int: reloading complex subregs\n\nThis patch splits out a condition that is common to both push_reload\nand reload_inner_reg_of_subreg.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* reload.c (complex_word_subreg_p): New function.\n\t(reload_inner_reg_of_subreg, push_reload): Use it.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256159", "tree": {"sha": "3591aef2edb40aa0a22fb32755f6bef1dbdd7c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3591aef2edb40aa0a22fb32755f6bef1dbdd7c1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65f914e714d985db7eaaa8e63a210b4fee17b13f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f914e714d985db7eaaa8e63a210b4fee17b13f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f914e714d985db7eaaa8e63a210b4fee17b13f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f914e714d985db7eaaa8e63a210b4fee17b13f/comments", "author": null, "committer": null, "parents": [{"sha": "00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00224b1a7642e7e35c0ae080ec93caff1ddd4faf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00224b1a7642e7e35c0ae080ec93caff1ddd4faf"}], "stats": {"total": 37, "additions": 26, "deletions": 11}, "files": [{"sha": "93587d7aa82d27cf4f826f6e76e26491d4b71d0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f914e714d985db7eaaa8e63a210b4fee17b13f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f914e714d985db7eaaa8e63a210b4fee17b13f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65f914e714d985db7eaaa8e63a210b4fee17b13f", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* reload.c (complex_word_subreg_p): New function.\n+\t(reload_inner_reg_of_subreg, push_reload): Use it.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "361e7aa03194b02fc67e5c513a40279c96b24852", "filename": "gcc/reload.c", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65f914e714d985db7eaaa8e63a210b4fee17b13f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65f914e714d985db7eaaa8e63a210b4fee17b13f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=65f914e714d985db7eaaa8e63a210b4fee17b13f", "patch": "@@ -811,6 +811,23 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n   return n_reloads;\n }\n \n+/* Return true if:\n+\n+   (a) (subreg:OUTER_MODE REG ...) represents a word or subword subreg\n+       of a multiword value; and\n+\n+   (b) the number of *words* in REG does not match the number of *registers*\n+       in REG.  */\n+\n+static bool\n+complex_word_subreg_p (machine_mode outer_mode, rtx reg)\n+{\n+  machine_mode inner_mode = GET_MODE (reg);\n+  return (GET_MODE_SIZE (outer_mode) <= UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD\n+\t  && GET_MODE_SIZE (inner_mode) / UNITS_PER_WORD != REG_NREGS (reg));\n+}\n+\n /* Return true if X is a SUBREG that will need reloading of its SUBREG_REG\n    expression.  MODE is the mode that X will be used in.  OUTPUT is true if\n    the function is invoked for the output part of an enclosing reload.  */\n@@ -842,11 +859,7 @@ reload_inner_reg_of_subreg (rtx x, machine_mode mode, bool output)\n      INNER is larger than a word and the number of registers in INNER is\n      not the same as the number of words in INNER, then INNER will need\n      reloading (with an in-out reload).  */\n-  return (output\n-\t  && GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (GET_MODE (inner)) > UNITS_PER_WORD\n-\t  && ((GET_MODE_SIZE (GET_MODE (inner)) / UNITS_PER_WORD)\n-\t      != REG_NREGS (inner)));\n+  return output && complex_word_subreg_p (mode, inner);\n }\n \n /* Return nonzero if IN can be reloaded into REGNO with mode MODE without\n@@ -1064,12 +1077,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t      /* The case where out is nonzero\n \t\t is handled differently in the following statement.  */\n \t      && (out == 0 || subreg_lowpart_p (in))\n-\t      && ((GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n-\t\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t       > UNITS_PER_WORD)\n-\t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t/ UNITS_PER_WORD)\n-\t\t       != REG_NREGS (SUBREG_REG (in))))\n+\t      && (complex_word_subreg_p (inmode, SUBREG_REG (in))\n \t\t  || !targetm.hard_regno_mode_ok (subreg_regno (in), inmode)))\n \t  || (secondary_reload_class (1, rclass, inmode, in) != NO_REGS\n \t      && (secondary_reload_class (1, rclass, GET_MODE (SUBREG_REG (in)),"}]}