{"sha": "1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI1MDdiMWUzYzU4YzA2M2I5Y2Y4MDNkZmY4MGMyOGQ0NjI2Y2I1ZA==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-08-20T13:43:32Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-08-20T13:43:32Z"}, "message": "c-format.c/Fortran: Support %wd / host-wide integer in gfc_error\n\nThis patch adds support for the 'll' (long double)\nand 'w' (HOST_WIDE_INT) length modifiers to the\nFortran FE diagnostic function (gfc_error, gfc_warning, ...)\n\ngcc/c-family/ChangeLog:\n\n\t* c-format.c (gcc_gfc_length_specs): Add 'll' and 'w'.\n\t(gcc_gfc_char_table): Add T9L_LL and T9L_ULL to\n\t\"di\" and \"u\", respecitively; fill with BADLEN to match\n\tsize of 'types'.\n\t(get_init_dynamic_hwi): Split off from ...\n\t(init_dynamic_diag_info): ... here. Call it.\n\t(init_dynamic_gfc_info): Call it.\n\ngcc/fortran/ChangeLog:\n\n\t* error.c\n\t(error_uinteger): Take 'long long unsigned' instead\n\tof 'long unsigned' as argumpent.\n\t(error_integer): Take 'long long' instead of 'long'.\n\t(error_hwuint, error_hwint): New.\n\t(error_print): Update to handle 'll' and 'w'\n\tlength modifiers.\n\t* simplify.c (substring_has_constant_len): Use '%wd'\n\tin gfc_error.", "tree": {"sha": "3a61a7da692a0771377ad3b0b7e6209d49dac4c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a61a7da692a0771377ad3b0b7e6209d49dac4c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12f22906d3c025e7edb60e3264dc9cd27a49e3e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f22906d3c025e7edb60e3264dc9cd27a49e3e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f22906d3c025e7edb60e3264dc9cd27a49e3e1"}], "stats": {"total": 259, "additions": 178, "deletions": 81}, "files": [{"sha": "b4cb765a9d349e65c9ce13871c2806965a91dd3f", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 75, "deletions": 67, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "patch": "@@ -546,10 +546,11 @@ static const format_length_info strfmon_length_specs[] =\n };\n \n \n-/* For now, the Fortran front-end routines only use l as length modifier.  */\n+/* Length modifiers used by the fortran/error.c routines.  */\n static const format_length_info gcc_gfc_length_specs[] =\n {\n-  { \"l\", FMT_LEN_l, STD_C89, NO_FMT, 0 },\n+  { \"l\", FMT_LEN_l, STD_C89, \"ll\", FMT_LEN_ll, STD_C89, 0 },\n+  { \"w\", FMT_LEN_w, STD_C89, NO_FMT, 0 },\n   { NO_FMT, NO_FMT, 0 }\n };\n \n@@ -821,10 +822,10 @@ static const format_char_info gcc_cxxdiag_char_table[] =\n static const format_char_info gcc_gfc_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\", NULL },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\", NULL },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\", NULL },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"cR\", NULL },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN, BADLEN }, \"q\", \"\", NULL },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN, BADLEN  }, \"q\", \"\", NULL },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN, BADLEN }, \"q\", \"\", NULL },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN, BADLEN, BADLEN, BADLEN }, \"q\", \"cR\", NULL },\n \n   /* gfc conversion specifiers.  */\n \n@@ -4843,12 +4844,73 @@ init_dynamic_asm_fprintf_info (void)\n     }\n }\n \n+static const format_length_info*\n+get_init_dynamic_hwi (void)\n+{\n+  static tree hwi;\n+  static format_length_info *diag_ls;\n+\n+  if (!hwi)\n+    {\n+      unsigned int i;\n+\n+      /* Find the underlying type for HOST_WIDE_INT.  For the 'w'\n+\t length modifier to work, one must have issued: \"typedef\n+\t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n+\t prior to using that modifier.  */\n+      if ((hwi = maybe_get_identifier (\"__gcc_host_wide_int__\")))\n+\t{\n+\t  hwi = identifier_global_value (hwi);\n+\t  if (hwi)\n+\t    {\n+\t      if (TREE_CODE (hwi) != TYPE_DECL)\n+\t\t{\n+\t\t  error (\"%<__gcc_host_wide_int__%> is not defined as a type\");\n+\t\t  hwi = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  hwi = DECL_ORIGINAL_TYPE (hwi);\n+\t\t  gcc_assert (hwi);\n+\t\t  if (hwi != long_integer_type_node\n+\t\t      && hwi != long_long_integer_type_node)\n+\t\t    {\n+\t\t      error (\"%<__gcc_host_wide_int__%> is not defined\"\n+\t\t\t     \" as %<long%> or %<long long%>\");\n+\t\t      hwi = 0;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      if (!diag_ls)\n+\tdiag_ls = (format_length_info *)\n+\t\t  xmemdup (gcc_diag_length_specs,\n+\t\t\t   sizeof (gcc_diag_length_specs),\n+\t\t\t   sizeof (gcc_diag_length_specs));\n+      if (hwi)\n+\t{\n+\t  /* HOST_WIDE_INT must be one of 'long' or 'long long'.  */\n+\t  i = find_length_info_modifier_index (diag_ls, 'w');\n+\t  if (hwi == long_integer_type_node)\n+\t    diag_ls[i].index = FMT_LEN_l;\n+\t  else if (hwi == long_long_integer_type_node)\n+\t    diag_ls[i].index = FMT_LEN_ll;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+    }\n+  return diag_ls;\n+}\n+\n /* Determine the type of a \"locus\" in the code being compiled for use\n    in GCC's __gcc_gfc__ custom format attribute.  You must have set\n    dynamic_format_types before calling this function.  */\n static void\n init_dynamic_gfc_info (void)\n {\n+  dynamic_format_types[gcc_gfc_format_type].length_char_specs\n+    = get_init_dynamic_hwi ();\n+\n   if (!locus)\n     {\n       static format_char_info *gfc_fci;\n@@ -4985,67 +5047,13 @@ init_dynamic_diag_info (void)\n       || local_event_ptr_node == void_type_node)\n     local_event_ptr_node = get_named_type (\"diagnostic_event_id_t\");\n \n-  static tree hwi;\n-\n-  if (!hwi)\n-    {\n-      static format_length_info *diag_ls;\n-      unsigned int i;\n-\n-      /* Find the underlying type for HOST_WIDE_INT.  For the 'w'\n-\t length modifier to work, one must have issued: \"typedef\n-\t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n-\t prior to using that modifier.  */\n-      if ((hwi = maybe_get_identifier (\"__gcc_host_wide_int__\")))\n-\t{\n-\t  hwi = identifier_global_value (hwi);\n-\t  if (hwi)\n-\t    {\n-\t      if (TREE_CODE (hwi) != TYPE_DECL)\n-\t\t{\n-\t\t  error (\"%<__gcc_host_wide_int__%> is not defined as a type\");\n-\t\t  hwi = 0;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  hwi = DECL_ORIGINAL_TYPE (hwi);\n-\t\t  gcc_assert (hwi);\n-\t\t  if (hwi != long_integer_type_node\n-\t\t      && hwi != long_long_integer_type_node)\n-\t\t    {\n-\t\t      error (\"%<__gcc_host_wide_int__%> is not defined\"\n-\t\t\t     \" as %<long%> or %<long long%>\");\n-\t\t      hwi = 0;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Assign the new data for use.  */\n-\n-      /* All the GCC diag formats use the same length specs.  */\n-      if (!diag_ls)\n-\tdynamic_format_types[gcc_diag_format_type].length_char_specs =\n-\t  dynamic_format_types[gcc_tdiag_format_type].length_char_specs =\n-\t  dynamic_format_types[gcc_cdiag_format_type].length_char_specs =\n-\t  dynamic_format_types[gcc_cxxdiag_format_type].length_char_specs =\n-\t  dynamic_format_types[gcc_dump_printf_format_type].length_char_specs =\n-\t  diag_ls = (format_length_info *)\n-\t\t    xmemdup (gcc_diag_length_specs,\n-\t\t\t     sizeof (gcc_diag_length_specs),\n-\t\t\t     sizeof (gcc_diag_length_specs));\n-      if (hwi)\n-\t{\n-\t  /* HOST_WIDE_INT must be one of 'long' or 'long long'.  */\n-\t  i = find_length_info_modifier_index (diag_ls, 'w');\n-\t  if (hwi == long_integer_type_node)\n-\t    diag_ls[i].index = FMT_LEN_l;\n-\t  else if (hwi == long_long_integer_type_node)\n-\t    diag_ls[i].index = FMT_LEN_ll;\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-    }\n+  /* All the GCC diag formats use the same length specs.  */\n+  dynamic_format_types[gcc_diag_format_type].length_char_specs =\n+    dynamic_format_types[gcc_tdiag_format_type].length_char_specs =\n+    dynamic_format_types[gcc_cdiag_format_type].length_char_specs =\n+    dynamic_format_types[gcc_cxxdiag_format_type].length_char_specs =\n+    dynamic_format_types[gcc_dump_printf_format_type].length_char_specs\n+    = get_init_dynamic_hwi ();\n \n   /* It's safe to \"re-initialize these to the same values.  */\n   dynamic_format_types[gcc_diag_format_type].conversion_specs ="}, {"sha": "5e6e87316a6e63b0145a44bae9602877b009ecf0", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 99, "deletions": 7, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "patch": "@@ -136,7 +136,7 @@ error_string (const char *p)\n #define IBUF_LEN 60\n \n static void\n-error_uinteger (unsigned long int i)\n+error_uinteger (unsigned long long int i)\n {\n   char *p, int_buf[IBUF_LEN];\n \n@@ -156,13 +156,50 @@ error_uinteger (unsigned long int i)\n }\n \n static void\n-error_integer (long int i)\n+error_integer (long long int i)\n {\n-  unsigned long int u;\n+  unsigned long long int u;\n \n   if (i < 0)\n     {\n-      u = (unsigned long int) -i;\n+      u = (unsigned long long int) -i;\n+      error_char ('-');\n+    }\n+  else\n+    u = i;\n+\n+  error_uinteger (u);\n+}\n+\n+\n+static void\n+error_hwuint (unsigned HOST_WIDE_INT i)\n+{\n+  char *p, int_buf[IBUF_LEN];\n+\n+  p = int_buf + IBUF_LEN - 1;\n+  *p-- = '\\0';\n+\n+  if (i == 0)\n+    *p-- = '0';\n+\n+  while (i > 0)\n+    {\n+      *p-- = i % 10 + '0';\n+      i = i / 10;\n+    }\n+\n+  error_string (p + 1);\n+}\n+\n+static void\n+error_hwint (HOST_WIDE_INT i)\n+{\n+  unsigned HOST_WIDE_INT u;\n+\n+  if (i < 0)\n+    {\n+      u = (unsigned HOST_WIDE_INT) -i;\n       error_char ('-');\n     }\n   else\n@@ -482,8 +519,8 @@ static void ATTRIBUTE_GCC_GFC(2,0)\n error_print (const char *type, const char *format0, va_list argp)\n {\n   enum { TYPE_CURRENTLOC, TYPE_LOCUS, TYPE_INTEGER, TYPE_UINTEGER,\n-         TYPE_LONGINT, TYPE_ULONGINT, TYPE_CHAR, TYPE_STRING,\n-\t NOTYPE };\n+\t TYPE_LONGINT, TYPE_ULONGINT, TYPE_LLONGINT, TYPE_ULLONGINT,\n+\t TYPE_HWINT, TYPE_HWUINT, TYPE_CHAR, TYPE_STRING, NOTYPE };\n   struct\n   {\n     int type;\n@@ -494,6 +531,10 @@ error_print (const char *type, const char *format0, va_list argp)\n       unsigned int uintval;\n       long int longintval;\n       unsigned long int ulongintval;\n+      long long int llongintval;\n+      unsigned long long int ullongintval;\n+      HOST_WIDE_INT hwintval;\n+      unsigned HOST_WIDE_INT hwuintval;\n       char charval;\n       const char * stringval;\n     } u;\n@@ -577,14 +618,34 @@ error_print (const char *type, const char *format0, va_list argp)\n \n \t  case 'l':\n \t    c = *format++;\n-\t    if (c == 'u')\n+\t    if (c == 'l')\n+\t      {\n+\t\tc = *format++;\n+\t\tif (c == 'u')\n+\t\t  arg[pos].type = TYPE_ULLONGINT;\n+\t\telse if (c == 'i' || c == 'd')\n+\t\t  arg[pos].type = TYPE_LLONGINT;\n+\t\telse\n+\t\t  gcc_unreachable ();\n+\t      }\n+\t    else if (c == 'u')\n \t      arg[pos].type = TYPE_ULONGINT;\n \t    else if (c == 'i' || c == 'd')\n \t      arg[pos].type = TYPE_LONGINT;\n \t    else\n \t      gcc_unreachable ();\n \t    break;\n \n+\t  case 'w':\n+\t    c = *format++;\n+\t    if (c == 'u')\n+\t      arg[pos].type = TYPE_HWUINT;\n+\t    else if (c == 'i' || c == 'd')\n+\t      arg[pos].type = TYPE_HWINT;\n+\t    else\n+\t      gcc_unreachable ();\n+\t    break;\n+\n \t  case 'c':\n \t    arg[pos].type = TYPE_CHAR;\n \t    break;\n@@ -649,6 +710,22 @@ error_print (const char *type, const char *format0, va_list argp)\n \t    arg[pos].u.ulongintval = va_arg (argp, unsigned long int);\n \t    break;\n \n+\t  case TYPE_LLONGINT:\n+\t    arg[pos].u.llongintval = va_arg (argp, long long int);\n+\t    break;\n+\n+\t  case TYPE_ULLONGINT:\n+\t    arg[pos].u.ullongintval = va_arg (argp, unsigned long long int);\n+\t    break;\n+\n+\t  case TYPE_HWINT:\n+\t    arg[pos].u.hwintval = va_arg (argp, HOST_WIDE_INT);\n+\t    break;\n+\n+\t  case TYPE_HWUINT:\n+\t    arg[pos].u.hwuintval = va_arg (argp, unsigned HOST_WIDE_INT);\n+\t    break;\n+\n \t  case TYPE_CHAR:\n \t    arg[pos].u.charval = (char) va_arg (argp, int);\n \t    break;\n@@ -725,12 +802,27 @@ error_print (const char *type, const char *format0, va_list argp)\n \n \tcase 'l':\n \t  format++;\n+\t  if (*format == 'l')\n+\t    {\n+\t      format++;\n+\t      if (*format == 'u')\n+\t\terror_uinteger (spec[n++].u.ullongintval);\n+\t      else\n+\t\terror_integer (spec[n++].u.llongintval);\n+\t    }\n \t  if (*format == 'u')\n \t    error_uinteger (spec[n++].u.ulongintval);\n \t  else\n \t    error_integer (spec[n++].u.longintval);\n \t  break;\n \n+\tcase 'w':\n+\t  format++;\n+\t  if (*format == 'u')\n+\t    error_hwuint (spec[n++].u.hwintval);\n+\t  else\n+\t    error_hwint (spec[n++].u.hwuintval);\n+\t  break;\n \t}\n     }\n "}, {"sha": "4cb73e836c7e3186066b8d9fee888a6d55d9595a", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b507b1e3c58c063b9cf803dff80c28d4626cb5d/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=1b507b1e3c58c063b9cf803dff80c28d4626cb5d", "patch": "@@ -4552,12 +4552,10 @@ substring_has_constant_len (gfc_expr *e)\n \n   if (istart <= iend)\n     {\n-      char buffer[21];\n       if (istart < 1)\n \t{\n-\t  sprintf (buffer, HOST_WIDE_INT_PRINT_DEC, istart);\n-\t  gfc_error (\"Substring start index (%s) at %L below 1\",\n-\t\t     buffer, &ref->u.ss.start->where);\n+\t  gfc_error (\"Substring start index (%wd) at %L below 1\",\n+\t\t     istart, &ref->u.ss.start->where);\n \t  return false;\n \t}\n \n@@ -4568,9 +4566,8 @@ substring_has_constant_len (gfc_expr *e)\n \tlength = gfc_mpz_get_hwi (ref->u.ss.length->length->value.integer);\n       if (iend > length)\n \t{\n-\t  sprintf (buffer, HOST_WIDE_INT_PRINT_DEC, iend);\n-\t  gfc_error (\"Substring end index (%s) at %L exceeds string length\",\n-\t\t     buffer, &ref->u.ss.end->where);\n+\t  gfc_error (\"Substring end index (%wd) at %L exceeds string length\",\n+\t\t     iend, &ref->u.ss.end->where);\n \t  return false;\n \t}\n       length = iend - istart + 1;"}]}