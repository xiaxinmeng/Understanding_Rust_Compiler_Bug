{"sha": "d77249e795d1e9e1e669c80279cef1df12232089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc3MjQ5ZTc5NWQxZTllMWU2NjljODAyNzljZWYxZGYxMjIzMjA4OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mitchell@dumbledore.codesourcery.com", "date": "2000-01-11T03:15:32Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-11T03:15:32Z"}, "message": "class.c (build_base_field): New function, split out from ...\n\n\t* class.c (build_base_field): New function, split out from ...\n\t(build_base_fields): ... here.  Use it.  Allocate primary bases\n\tfirst, under the new ABI.\n\t(get_vtable_entry): Remove.\n\t(remove_base_field): New function, split out from ...\n\t(remove_base_fields): ... here.  Adjust since primary bases come\n\tfirst under the new ABI.\n\nFrom-SVN: r31315", "tree": {"sha": "226168d842fe40d0ad48426175f1f4c4d1032670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/226168d842fe40d0ad48426175f1f4c4d1032670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d77249e795d1e9e1e669c80279cef1df12232089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77249e795d1e9e1e669c80279cef1df12232089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d77249e795d1e9e1e669c80279cef1df12232089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d77249e795d1e9e1e669c80279cef1df12232089/comments", "author": null, "committer": null, "parents": [{"sha": "d569399b271087152bb6f25e3625f4407dc11153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d569399b271087152bb6f25e3625f4407dc11153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d569399b271087152bb6f25e3625f4407dc11153"}], "stats": {"total": 217, "additions": 135, "deletions": 82}, "files": [{"sha": "c291cb527a936d0cbf9a0aa4d9c8a61a597b02be", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77249e795d1e9e1e669c80279cef1df12232089/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77249e795d1e9e1e669c80279cef1df12232089/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d77249e795d1e9e1e669c80279cef1df12232089", "patch": "@@ -1,5 +1,13 @@\n 2000-01-10  Mark Mitchell  <mitchell@dumbledore.codesourcery.com>\n \n+\t* class.c (build_base_field): New function, split out from ...\n+\t(build_base_fields): ... here.  Use it.  Allocate primary bases\n+\tfirst, under the new ABI.\n+\t(get_vtable_entry): Remove.\n+\t(remove_base_field): New function, split out from ...\n+\t(remove_base_fields): ... here.  Adjust since primary bases come\n+\tfirst under the new ABI.\n+\t\n \t* cp-tree.h (expand_direct_vtbls_init): Remove declaration.\n \t(initialize_vtbl_ptrs): New function.\n \t(expand_indirect_vtbls_init): Change prototype."}, {"sha": "f2fad7c341c9c4af483f354a97c5225863203d9e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 127, "deletions": 82, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d77249e795d1e9e1e669c80279cef1df12232089/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d77249e795d1e9e1e669c80279cef1df12232089/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d77249e795d1e9e1e669c80279cef1df12232089", "patch": "@@ -125,6 +125,7 @@ static void check_field_decl PROTO((tree, tree, int *, int *, int *, int *));\n static void check_field_decls PROTO((tree, tree *, int *, int *, int *, \n \t\t\t\t     int *));\n static int avoid_overlap PROTO((tree, tree, int *));\n+static tree build_base_field PROTO((tree, tree, int *, int *, unsigned int *));\n static tree build_base_fields PROTO((tree, int *));\n static tree build_vbase_pointer_fields PROTO((tree, int *));\n static tree build_vtbl_or_vbase_field PROTO((tree, tree, tree, tree, int *));\n@@ -141,6 +142,7 @@ static void propagate_binfo_offsets PROTO((tree, tree));\n static void layout_basetypes PROTO((tree));\n static tree dfs_set_offset_for_vbases PROTO((tree, void *));\n static void layout_virtual_bases PROTO((tree));\n+static void remove_base_field PROTO((tree, tree, tree *));\n static void remove_base_fields PROTO((tree));\n \n /* Variables shared between class.c and call.c.  */\n@@ -930,34 +932,6 @@ prepare_fresh_vtable (binfo, for_type)\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n }\n \n-#if 0\n-/* Access the virtual function table entry that logically\n-   contains BASE_FNDECL.  VIRTUALS is the virtual function table's\n-   initializer.  We can run off the end, when dealing with virtual\n-   destructors in MI situations, return NULL_TREE in that case.  */\n-\n-static tree\n-get_vtable_entry (virtuals, base_fndecl)\n-     tree virtuals, base_fndecl;\n-{\n-  unsigned HOST_WIDE_INT n = (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n-\t   ? (TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl))\n-\t      & (((unsigned HOST_WIDE_INT)1<<(BITS_PER_WORD-1))-1))\n-\t   : TREE_INT_CST_LOW (DECL_VINDEX (base_fndecl)));\n-\n-#ifdef GATHER_STATISTICS\n-  n_vtable_searches += n;\n-#endif\n-\n-  while (n > 0 && virtuals)\n-    {\n-      --n;\n-      virtuals = TREE_CHAIN (virtuals);\n-    }\n-  return virtuals;\n-}\n-#endif\n-\n /* Change the offset for the FNDECL entry to NEW_OFFSET.  Also update\n    DECL_VINDEX (FNDECL).  */\n \n@@ -3745,6 +3719,59 @@ avoid_overlap (decl, newdecl, empty_p)\n   return 1;\n }\n \n+/* Build a FIELD_DECL for the base given by BINFO in T.  If the new\n+   object is non-empty, clear *EMPTY_P.  Otherwise, set *SAW_EMPTY_P.\n+   *BASE_ALIGN is a running maximum of the alignments of any base\n+   class.  */\n+\n+static tree\n+build_base_field (t, binfo, empty_p, saw_empty_p, base_align)\n+     tree t;\n+     tree binfo;\n+     int *empty_p;\n+     int *saw_empty_p;\n+     unsigned int *base_align;\n+{\n+  tree basetype = BINFO_TYPE (binfo);\n+  tree decl;\n+\n+  if (TYPE_SIZE (basetype) == 0)\n+    /* This error is now reported in xref_tag, thus giving better\n+       location information.  */\n+    return NULL_TREE;\n+  \n+  decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = t;\n+  DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n+  DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n+  \n+  if (flag_new_abi && DECL_SIZE (decl) == integer_zero_node)\n+    {\n+      *saw_empty_p = 1;\n+      return decl;\n+    }\n+\n+  /* The containing class is non-empty because it has a non-empty base\n+     class.  */\n+  *empty_p = 0;\n+      \n+  if (! flag_new_abi)\n+    {\n+      /* Brain damage for backwards compatibility.  For no good\n+\t reason, the old layout_basetypes made every base at least\n+\t as large as the alignment for the bases up to that point,\n+\t gratuitously wasting space.  So we do the same thing\n+\t here.  */\n+      *base_align = MAX (*base_align, DECL_ALIGN (decl));\n+      DECL_SIZE (decl)\n+\t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n+\t\t\t (int) (*base_align)));\n+    }\n+\n+  return decl;\n+}\n+\n /* Returns a list of fields to stand in for the base class subobjects\n    of REC.  These fields are later removed by layout_basetypes.  */\n \n@@ -3756,58 +3783,50 @@ build_base_fields (rec, empty_p)\n   /* Chain to hold all the new FIELD_DECLs which stand in for base class\n      subobjects.  */\n   tree base_decls = NULL_TREE;\n-  tree binfos = TYPE_BINFO_BASETYPES (rec);\n   int n_baseclasses = CLASSTYPE_N_BASECLASSES (rec);\n   tree decl, nextdecl;\n   int i, saw_empty = 0;\n   unsigned int base_align = 0;\n \n+  /* Under the new ABI, the primary base class is always allocated\n+     first.  */\n+  if (flag_new_abi && CLASSTYPE_HAS_PRIMARY_BASE_P (rec))\n+    {\n+      tree primary_base;\n+\n+      primary_base = CLASSTYPE_PRIMARY_BINFO (rec);\n+      base_decls = chainon (build_base_field (rec, \n+\t\t\t\t\t      primary_base,\n+\t\t\t\t\t      empty_p,\n+\t\t\t\t\t      &saw_empty,\n+\t\t\t\t\t      &base_align),\n+\t\t\t    base_decls);\n+    }\n+\n+  /* Now allocate the rest of the bases.  */\n   for (i = 0; i < n_baseclasses; ++i)\n     {\n-      register tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n+      tree base_binfo;\n \n-      if (TYPE_SIZE (basetype) == 0)\n-\t/* This error is now reported in xref_tag, thus giving better\n-\t   location information.  */\n+      /* Under the new ABI, the primary base was already allocated\n+\t above, so we don't need to allocate it again here.  */\n+      if (flag_new_abi && i == CLASSTYPE_VFIELD_PARENT (rec))\n \tcontinue;\n \n+      base_binfo = BINFO_BASETYPE (TYPE_BINFO (rec), i);\n+\n       /* A primary virtual base class is allocated just like any other\n \t base class, but a non-primary virtual base is allocated\n \t later, in layout_basetypes.  */\n       if (TREE_VIA_VIRTUAL (base_binfo) \n-\t  && i != CLASSTYPE_VFIELD_PARENT (rec))\n+\t  && !BINFO_PRIMARY_MARKED_P (base_binfo))\n \tcontinue;\n \n-      decl = build_lang_decl (FIELD_DECL, NULL_TREE, basetype);\n-      DECL_ARTIFICIAL (decl) = 1;\n-      DECL_FIELD_CONTEXT (decl) = DECL_CLASS_CONTEXT (decl) = rec;\n-      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);\n-      DECL_ALIGN (decl) = CLASSTYPE_ALIGN (basetype);\n-      TREE_CHAIN (decl) = base_decls;\n-      base_decls = decl;\n-\n-      if (flag_new_abi && DECL_SIZE (decl) == integer_zero_node)\n-\tsaw_empty = 1;\n-      else\n-\t{\n-\t  /* The containing class is non-empty because it has a\n-\t     non-empty base class.  */\n-\t  *empty_p = 0;\n-\n-\t  if (! flag_new_abi)\n-\t    {\n-\t      /* Brain damage for backwards compatibility.  For no\n-\t\t good reason, the old layout_basetypes made every base\n-\t\t at least as large as the alignment for the bases up\n-\t\t to that point, gratuitously wasting space.  So we do\n-\t\t the same thing here.  */\n-\t      base_align = MAX (base_align, DECL_ALIGN (decl));\n-\t      DECL_SIZE (decl)\n-\t\t= size_int (MAX (TREE_INT_CST_LOW (DECL_SIZE (decl)),\n-\t\t\t\t (int) base_align));\n-\t    }\n-\t}\n+      base_decls = chainon (build_base_field (rec, base_binfo,\n+\t\t\t\t\t      empty_p,\n+\t\t\t\t\t      &saw_empty,\n+\t\t\t\t\t      &base_align),\n+\t\t\t    base_decls);\n     }\n \n   /* Reverse the list of fields so we allocate the bases in the proper\n@@ -4218,6 +4237,34 @@ propagate_binfo_offsets (binfo, offset)\n     }\n }\n \n+/* Remove *FIELD (which corresponds to the base given by BINFO) from\n+   the field list for T.  */\n+\n+static void\n+remove_base_field (t, binfo, field)\n+     tree t;\n+     tree binfo;\n+     tree *field;\n+{\n+  tree basetype = BINFO_TYPE (binfo);\n+  tree offset;\n+\n+  my_friendly_assert (TREE_TYPE (*field) == basetype, 23897);\n+\n+  if (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n+    cp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\t\tbasetype, t);\n+\n+  offset\n+    = size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n+\t\t      BITS_PER_UNIT));\n+  BINFO_OFFSET (binfo) = offset;\n+  propagate_binfo_offsets (binfo, offset);\n+\n+  /* Remove this field.  */\n+  *field = TREE_CHAIN (*field);\n+}\n+\n /* Remove the FIELD_DECLs created for T's base classes in\n    build_base_fields.  Simultaneously, update BINFO_OFFSET for all the\n    bases, except for non-primary virtual baseclasses.  */\n@@ -4244,31 +4291,29 @@ remove_base_fields (t)\n \t\t\t  19991218);\n       field = &TREE_CHAIN (*field);\n     }\n-    \n+\n+  /* Under the new ABI, the primary base is always allocated first.  */\n+  if (flag_new_abi && CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+    remove_base_field (t, CLASSTYPE_PRIMARY_BINFO (t), field);\n+\n+  /* Now remove the rest of the bases.  */\n   for (i = 0; i < CLASSTYPE_N_BASECLASSES (t); i++)\n     {\n-      register tree base_binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n-      register tree basetype = BINFO_TYPE (base_binfo);\n+      tree binfo;\n \n-      /* We treat a primary virtual base class just like an ordinary\n-\t base class.  But, non-primary virtual bases are laid out\n-\t later.  */\n-      if (TREE_VIA_VIRTUAL (base_binfo) && i != CLASSTYPE_VFIELD_PARENT (t))\n+      /* Under the new ABI, we've already removed the primary base\n+\t above.  */\n+      if (flag_new_abi && i == CLASSTYPE_VFIELD_PARENT (t))\n \tcontinue;\n \n-      my_friendly_assert (TREE_TYPE (*field) == basetype, 23897);\n+      binfo = BINFO_BASETYPE (TYPE_BINFO (t), i);\n \n-      if (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n-\tcp_warning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n-\t\t    basetype, t);\n-\n-      BINFO_OFFSET (base_binfo)\n-\t= size_int (CEIL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (*field)),\n-\t\t\t  BITS_PER_UNIT));\n-      propagate_binfo_offsets (base_binfo, BINFO_OFFSET (base_binfo));\n+      /* We treat a primary virtual base class just like an ordinary base\n+\t class.  But, non-primary virtual bases are laid out later.  */\n+      if (TREE_VIA_VIRTUAL (binfo) && !BINFO_PRIMARY_MARKED_P (binfo))\n+\tcontinue;\n \n-      /* Remove this field.  */\n-      *field = TREE_CHAIN (*field);\n+      remove_base_field (t, binfo, field);\n     }\n }\n "}]}