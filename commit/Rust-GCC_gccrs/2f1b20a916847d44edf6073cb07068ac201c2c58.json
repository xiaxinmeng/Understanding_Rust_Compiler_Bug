{"sha": "2f1b20a916847d44edf6073cb07068ac201c2c58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYxYjIwYTkxNjg0N2Q0NGVkZjYwNzNjYjA3MDY4YWMyMDFjMmM1OA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-09-05T07:53:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:53:24Z"}, "message": "exp_ch6.adb (Expand_Call): If an actual is a function call rewritten from object notation...\n\n2005-09-01  Ed Schonberg  <schonberg@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): If an actual is a function call rewritten\n\tfrom object notation, the original node is unanalyzed and carries no\n\tsemantic information, so that accessiblity checks must be performed on\n\tthe type of the actual itself.\n\t(Expand_N_Subprogram_Declaration): Change last actual parameter for\n\tcompatibility with Build_Protected_Sub_Specification.\n\t(Check_Overriding_Inherited_Interfaces): Add suport to handle\n\toverloaded primitives.\n\t(Register_Interface_DT_Entry): Use the new name of the formal\n\tthe the calls to Expand_Interface_Thunk\n\n\t* exp_dbug.ads: Augment comments on encoding of protected types to\n\tinclude the generation of dispatching subprograms when the type\n\timplements at least one interface.\n\n\t* lib.ads: Extend information in Load_Stack to include whether a given\n\tload comes from a Limited_With_Clause.\n\n\t* lib-load.adb (From_Limited_With_Chain): New predicate to determine\n\twhether a potential circularity is harmless, because it includes units\n\tloaded through a limited_with clause. Extends previous treatment which\n\tdid not handle properly arbitrary combinations of limited and\n\tnon-limited clauses.\n\nFrom-SVN: r103861", "tree": {"sha": "81769ea78a2ec7af5e792a2936b265ee2eb8060b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81769ea78a2ec7af5e792a2936b265ee2eb8060b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f1b20a916847d44edf6073cb07068ac201c2c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1b20a916847d44edf6073cb07068ac201c2c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f1b20a916847d44edf6073cb07068ac201c2c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f1b20a916847d44edf6073cb07068ac201c2c58/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f7164706b48fba1c832d74ee787deded16034a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f7164706b48fba1c832d74ee787deded16034a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f7164706b48fba1c832d74ee787deded16034a1"}], "stats": {"total": 493, "additions": 284, "deletions": 209}, "files": [{"sha": "884d549493bd14154e6f3452bb2226085c87423b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 202, "deletions": 183, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=2f1b20a916847d44edf6073cb07068ac201c2c58", "patch": "@@ -34,7 +34,6 @@ with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n-with Exp_Ch11; use Exp_Ch11;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Disp; use Exp_Disp;\n with Exp_Dist; use Exp_Dist;\n@@ -172,10 +171,10 @@ package body Exp_Ch6 is\n         and then In_Open_Scopes (Scope (Etype (Typ)))\n         and then Typ = Base_Type (Typ)\n       then\n-         --  Subp overrides an inherited private operation if there is\n-         --  an inherited operation with a different name than Subp (see\n-         --  Derive_Subprogram) whose Alias is a hidden  subprogram with\n-         --  the same name as Subp.\n+         --  Subp overrides an inherited private operation if there is an\n+         --  inherited operation with a different name than Subp (see\n+         --  Derive_Subprogram) whose Alias is a hidden subprogram with the\n+         --  same name as Subp.\n \n          Op_Elmt := First_Elmt (Op_List);\n          while Present (Op_Elmt) loop\n@@ -211,12 +210,12 @@ package body Exp_Ch6 is\n       --  List of recursive calls in body of procedure\n \n       Shad_List : constant Elist_Id := New_Elmt_List;\n-      --  List of entity id's for entities created to capture the\n-      --  value of referenced globals on entry to the procedure.\n+      --  List of entity id's for entities created to capture the value of\n+      --  referenced globals on entry to the procedure.\n \n       Scop : constant Uint := Scope_Depth (Spec);\n-      --  This is used to record the scope depth of the current\n-      --  procedure, so that we can identify global references.\n+      --  This is used to record the scope depth of the current procedure, so\n+      --  that we can identify global references.\n \n       Max_Vars : constant := 4;\n       --  Do not test more than four global variables\n@@ -359,9 +358,9 @@ package body Exp_Ch6 is\n    --  Start of processing for Detect_Infinite_Recursion\n \n    begin\n-      --  Do not attempt detection in No_Implicit_Conditional mode,\n-      --  since we won't be able to generate the code to handle the\n-      --  recursion in any case.\n+      --  Do not attempt detection in No_Implicit_Conditional mode, since we\n+      --  won't be able to generate the code to handle the recursion in any\n+      --  case.\n \n       if Restriction_Active (No_Implicit_Conditionals) then\n          return;\n@@ -372,25 +371,25 @@ package body Exp_Ch6 is\n       if Traverse_Body (N) = Abandon then\n          return;\n \n-      --  We must have a call, since Has_Recursive_Call was set. If not\n-      --  just ignore (this is only an error check, so if we have a funny\n-      --  situation, due to bugs or errors, we do not want to bomb!)\n+      --  We must have a call, since Has_Recursive_Call was set. If not just\n+      --  ignore (this is only an error check, so if we have a funny situation,\n+      --  due to bugs or errors, we do not want to bomb!)\n \n       elsif Is_Empty_Elmt_List (Call_List) then\n          return;\n       end if;\n \n       --  Here is the case where we detect recursion at compile time\n \n-      --  Push our current scope for analyzing the declarations and\n-      --  code that we will insert for the checking.\n+      --  Push our current scope for analyzing the declarations and code that\n+      --  we will insert for the checking.\n \n       New_Scope (Spec);\n \n-      --  This loop builds temporary variables for each of the\n-      --  referenced globals, so that at the end of the loop the\n-      --  list Shad_List contains these temporaries in one-to-one\n-      --  correspondence with the elements in Var_List.\n+      --  This loop builds temporary variables for each of the referenced\n+      --  globals, so that at the end of the loop the list Shad_List contains\n+      --  these temporaries in one-to-one correspondence with the elements in\n+      --  Var_List.\n \n       Last := Empty;\n       Elm := First_Elmt (Var_List);\n@@ -401,10 +400,10 @@ package body Exp_Ch6 is\n              Chars => New_Internal_Name ('S'));\n          Append_Elmt (Ent, Shad_List);\n \n-         --  Insert a declaration for this temporary at the start of\n-         --  the declarations for the procedure. The temporaries are\n-         --  declared as constant objects initialized to the current\n-         --  values of the corresponding temporaries.\n+         --  Insert a declaration for this temporary at the start of the\n+         --  declarations for the procedure. The temporaries are declared as\n+         --  constant objects initialized to the current values of the\n+         --  corresponding temporaries.\n \n          Decl :=\n            Make_Object_Declaration (Loc,\n@@ -940,7 +939,6 @@ package body Exp_Ch6 is\n \n       procedure Reset_Packed_Prefix is\n          Pfx : Node_Id := Actual;\n-\n       begin\n          loop\n             Set_Analyzed (Pfx, False);\n@@ -953,11 +951,10 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_Actuals\n \n    begin\n-      Formal := First_Formal (Subp);\n-      Actual := First_Actual (N);\n-\n       Post_Call := New_List;\n \n+      Formal := First_Formal (Subp);\n+      Actual := First_Actual (N);\n       while Present (Formal) loop\n          E_Formal := Etype (Formal);\n \n@@ -1155,10 +1152,9 @@ package body Exp_Ch6 is\n \n       if not Is_Empty_List (Post_Call) then\n \n-         --  If call is not a list member, it must be the triggering\n-         --  statement of a triggering alternative or an entry call\n-         --  alternative, and we can add the post call stuff to the\n-         --  corresponding statement list.\n+         --  If call is not a list member, it must be the triggering statement\n+         --  of a triggering alternative or an entry call alternative, and we\n+         --  can add the post call stuff to the corresponding statement list.\n \n          if not Is_List_Member (N) then\n             declare\n@@ -1219,22 +1215,27 @@ package body Exp_Ch6 is\n       Actual        : Node_Id;\n       Formal        : Entity_Id;\n       Prev          : Node_Id := Empty;\n-      Prev_Orig     : Node_Id;\n+\n+      Prev_Orig : Node_Id;\n+      --  Original node for an actual, which may have been rewritten. If the\n+      --  actual is a function call that has been transformed from a selected\n+      --  component, the original node is unanalyzed. Otherwise, it carries\n+      --  semantic information used to generate additional actuals.\n+\n       Scop          : Entity_Id;\n       Extra_Actuals : List_Id := No_List;\n-      Cond          : Node_Id;\n \n       CW_Interface_Formals_Present : Boolean := False;\n \n       procedure Add_Actual_Parameter (Insert_Param : Node_Id);\n       --  Adds one entry to the end of the actual parameter list. Used for\n-      --  default parameters and for extra actuals (for Extra_Formals).\n-      --  The argument is an N_Parameter_Association node.\n+      --  default parameters and for extra actuals (for Extra_Formals). The\n+      --  argument is an N_Parameter_Association node.\n \n       procedure Add_Extra_Actual (Expr : Node_Id; EF : Entity_Id);\n-      --  Adds an extra actual to the list of extra actuals. Expr\n-      --  is the expression for the value of the actual, EF is the\n-      --  entity for the extra formal.\n+      --  Adds an extra actual to the list of extra actuals. Expr is the\n+      --  expression for the value of the actual, EF is the entity for the\n+      --  extra formal.\n \n       function Inherited_From_Formal (S : Entity_Id) return Entity_Id;\n       --  Within an instance, a type derived from a non-tagged formal derived\n@@ -1324,8 +1325,8 @@ package body Exp_Ch6 is\n \n          if Nkind (Parent (S)) /= N_Full_Type_Declaration\n            or else not Is_Derived_Type (Defining_Identifier (Parent (S)))\n-           or else Nkind (Type_Definition (Original_Node (Parent (S))))\n-             /= N_Derived_Type_Definition\n+           or else Nkind (Type_Definition (Original_Node (Parent (S)))) /=\n+                                                   N_Derived_Type_Definition\n            or else not In_Instance\n          then\n             return Empty;\n@@ -1353,31 +1354,29 @@ package body Exp_Ch6 is\n             Gen_Par := Generic_Parent_Type (Parent (Par));\n          end if;\n \n-         --  If the generic parent type is still the generic type, this\n-         --  is a private formal, not a derived formal, and there are no\n-         --  operations inherited from the formal.\n+         --  If the generic parent type is still the generic type, this is a\n+         --  private formal, not a derived formal, and there are no operations\n+         --  inherited from the formal.\n \n          if Nkind (Parent (Gen_Par)) = N_Formal_Type_Declaration then\n             return Empty;\n          end if;\n \n          Gen_Prim := Collect_Primitive_Operations (Gen_Par);\n-         Elmt := First_Elmt (Gen_Prim);\n \n+         Elmt := First_Elmt (Gen_Prim);\n          while Present (Elmt) loop\n             if Chars (Node (Elmt)) = Chars (S) then\n                declare\n                   F1 : Entity_Id;\n                   F2 : Entity_Id;\n-               begin\n \n+               begin\n                   F1 := First_Formal (S);\n                   F2 := First_Formal (Node (Elmt));\n-\n                   while Present (F1)\n                     and then Present (F2)\n                   loop\n-\n                      if Etype (F1) = Etype (F2)\n                        or else Etype (F2) = Gen_Par\n                      then\n@@ -1448,7 +1447,8 @@ package body Exp_Ch6 is\n \n             begin\n                --  The case we catch is where the first argument is obtained\n-               --  using the Identity attribute (which must always be non-null)\n+               --  using the Identity attribute (which must always be\n+               --  non-null).\n \n                if Nkind (FA) = N_Attribute_Reference\n                  and then Attribute_Name (FA) = Name_Identity\n@@ -1490,8 +1490,14 @@ package body Exp_Ch6 is\n          Prev := Actual;\n          Prev_Orig := Original_Node (Prev);\n \n+         if not Analyzed (Prev_Orig)\n+           and then Nkind (Actual) = N_Function_Call\n+         then\n+            Prev_Orig := Prev;\n+         end if;\n+\n          --  Ada 2005 (AI-251): Check if any formal is a class-wide interface\n-         --  to expand it in a further round\n+         --  to expand it in a further round.\n \n          CW_Interface_Formals_Present :=\n            CW_Interface_Formals_Present\n@@ -1539,13 +1545,13 @@ package body Exp_Ch6 is\n                --  test applies to the actual, not the target type.\n \n                declare\n-                  Act_Prev : Node_Id := Prev;\n+                  Act_Prev : Node_Id;\n \n                begin\n-                  --  Test for unchecked conversions as well, which can\n-                  --  occur as out parameter actuals on calls to stream\n-                  --  procedures.\n+                  --  Test for unchecked conversions as well, which can occur\n+                  --  as out parameter actuals on calls to stream procedures.\n \n+                  Act_Prev := Prev;\n                   while Nkind (Act_Prev) = N_Type_Conversion\n                     or else Nkind (Act_Prev) = N_Unchecked_Type_Conversion\n                   loop\n@@ -1669,55 +1675,59 @@ package body Exp_Ch6 is\n             end if;\n          end if;\n \n-         --  Perform the check of 4.6(49) that prevents a null value\n-         --  from being passed as an actual to an access parameter.\n-         --  Note that the check is elided in the common cases of\n-         --  passing an access attribute or access parameter as an\n-         --  actual. Also, we currently don't enforce this check for\n-         --  expander-generated actuals and when -gnatdj is set.\n+         --  Perform the check of 4.6(49) that prevents a null value from being\n+         --  passed as an actual to an access parameter. Note that the check is\n+         --  elided in the common cases of passing an access attribute or\n+         --  access parameter as an actual. Also, we currently don't enforce\n+         --  this check for expander-generated actuals and when -gnatdj is set.\n \n-         if Ekind (Etype (Formal)) /= E_Anonymous_Access_Type\n-           or else Access_Checks_Suppressed (Subp)\n-         then\n-            null;\n+         if Ada_Version >= Ada_05 then\n \n-         elsif Debug_Flag_J then\n-            null;\n+            --  Ada 2005 (AI-231): Check null-excluding access types\n \n-         elsif not Comes_From_Source (Prev) then\n-            null;\n+            if Is_Access_Type (Etype (Formal))\n+              and then Can_Never_Be_Null (Etype (Formal))\n+              and then Nkind (Prev) /= N_Raise_Constraint_Error\n+              and then (Nkind (Prev) = N_Null\n+                          or else not Can_Never_Be_Null (Etype (Prev)))\n+            then\n+               Install_Null_Excluding_Check (Prev);\n+            end if;\n \n-         elsif Is_Entity_Name (Prev)\n-           and then Ekind (Etype (Prev)) = E_Anonymous_Access_Type\n-         then\n-            null;\n+         --  Ada_Version < Ada_05\n \n-         elsif Nkind (Prev) = N_Allocator\n-           or else Nkind (Prev) = N_Attribute_Reference\n-         then\n-            null;\n+         else\n+            if Ekind (Etype (Formal)) /= E_Anonymous_Access_Type\n+              or else Access_Checks_Suppressed (Subp)\n+            then\n+               null;\n \n-         --  Suppress null checks when passing to access parameters\n-         --  of Java subprograms. (Should this be done for other\n-         --  foreign conventions as well ???)\n+            elsif Debug_Flag_J then\n+               null;\n \n-         elsif Convention (Subp) = Convention_Java then\n-            null;\n+            elsif not Comes_From_Source (Prev) then\n+               null;\n \n-            --  Ada 2005 (AI-231): do not force the check in case of Ada 2005\n-            --  unless it is a null-excluding type\n+            elsif Is_Entity_Name (Prev)\n+              and then Ekind (Etype (Prev)) = E_Anonymous_Access_Type\n+            then\n+               null;\n \n-         elsif Ada_Version < Ada_05\n-           or else Can_Never_Be_Null (Etype (Prev))\n-         then\n-            Cond :=\n-              Make_Op_Eq (Loc,\n-                Left_Opnd => Duplicate_Subexpr_No_Checks (Prev),\n-                Right_Opnd => Make_Null (Loc));\n-            Insert_Action (Prev,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition => Cond,\n-                Reason    => CE_Access_Parameter_Is_Null));\n+            elsif Nkind (Prev) = N_Allocator\n+              or else Nkind (Prev) = N_Attribute_Reference\n+            then\n+               null;\n+\n+            --  Suppress null checks when passing to access parameters of Java\n+            --  subprograms. (Should this be done for other foreign conventions\n+            --  as well ???)\n+\n+            elsif Convention (Subp) = Convention_Java then\n+               null;\n+\n+            else\n+               Install_Null_Excluding_Check (Prev);\n+            end if;\n          end if;\n \n          --  Perform appropriate validity checks on parameters that\n@@ -1974,7 +1984,6 @@ package body Exp_Ch6 is\n            or else Is_Generic_Instance (Parent_Subp)\n          then\n             while Present (Formal) loop\n-\n                if Etype (Formal) /= Etype (Parent_Formal)\n                  and then Is_Scalar_Type (Etype (Formal))\n                  and then Ekind (Formal) = E_In_Parameter\n@@ -1989,8 +1998,8 @@ package body Exp_Ch6 is\n                   Enable_Range_Check (Actual);\n \n                elsif Is_Access_Type (Etype (Formal))\n-                 and then Base_Type (Etype (Parent_Formal))\n-                   /= Base_Type (Etype (Actual))\n+                 and then Base_Type (Etype (Parent_Formal)) /=\n+                          Base_Type (Etype (Actual))\n                then\n                   if Ekind (Formal) /= E_In_Parameter then\n                      Rewrite (Actual,\n@@ -2161,9 +2170,10 @@ package body Exp_Ch6 is\n                --------------------------\n \n                function In_Unfrozen_Instance return Boolean is\n-                  S : Entity_Id := Scop;\n+                  S : Entity_Id;\n \n                begin\n+                  S := Scop;\n                   while Present (S)\n                     and then S /= Standard_Standard\n                   loop\n@@ -2183,10 +2193,12 @@ package body Exp_Ch6 is\n             --  Start of processing for Inlined_Subprogram\n \n             begin\n-               --  Verify that the body to inline has already been seen,\n-               --  and that if the body is in the current unit the inlining\n-               --  does not occur earlier. This avoids order-of-elaboration\n-               --  problems in gigi.\n+               --  Verify that the body to inline has already been seen, and\n+               --  that if the body is in the current unit the inlining does\n+               --  not occur earlier. This avoids order-of-elaboration problems\n+               --  in the back end.\n+\n+               --  This should be documented in sinfo/einfo ???\n \n                if No (Spec)\n                  or else Nkind (Spec) /= N_Subprogram_Declaration\n@@ -2683,15 +2695,14 @@ package body Exp_Ch6 is\n                Original_Assignment : constant Node_Id := Parent (N);\n \n             begin\n-               --  Preserve the original assignment node to keep the\n-               --  complete assignment subtree consistent enough for\n-               --  Analyze_Assignment to proceed (specifically, the\n-               --  original Lhs node must still have an assignment\n-               --  statement as its parent).\n+               --  Preserve the original assignment node to keep the complete\n+               --  assignment subtree consistent enough for Analyze_Assignment\n+               --  to proceed (specifically, the original Lhs node must still\n+               --  have an assignment statement as its parent).\n \n-               --  We cannot rely on Original_Node to go back from the\n-               --  block node to the assignment node, because the\n-               --  assignment might already be a rewrite substitution.\n+               --  We cannot rely on Original_Node to go back from the block\n+               --  node to the assignment node, because the assignment might\n+               --  already be a rewrite substitution.\n \n                Discard_Node (Relocate_Node (Original_Assignment));\n                Rewrite (Original_Assignment, Blk);\n@@ -2741,8 +2752,7 @@ package body Exp_Ch6 is\n             if Nkind (N) = N_Identifier\n               and then Present (Entity (N))\n \n-               --  The original node's entity points to the one in the\n-               --  copied body.\n+               --  Original node's entity points to the one in the copied body\n \n               and then Nkind (Entity (N)) = N_Identifier\n               and then Present (Entity (Entity (N)))\n@@ -2781,8 +2791,8 @@ package body Exp_Ch6 is\n       --  Check for special case of To_Address call, and if so, just do an\n       --  unchecked conversion instead of expanding the call. Not only is this\n       --  more efficient, but it also avoids problem with order of elaboration\n-      --  when address clauses are inlined (address expr elaborated at wrong\n-      --  point).\n+      --  when address clauses are inlined (address expression elaborated at\n+      --  wrong point).\n \n       if Subp = RTE (RE_To_Address) then\n          Rewrite (N,\n@@ -2848,15 +2858,14 @@ package body Exp_Ch6 is\n          Ret_Type := Etype (Subp);\n       end if;\n \n-      F := First_Formal (Subp);\n-      A := First_Actual (N);\n-\n       --  Create temporaries for the actuals that are expressions, or that\n       --  are scalars and require copying to preserve semantics.\n \n+      F := First_Formal (Subp);\n+      A := First_Actual (N);\n       while Present (F) loop\n          if Present (Renamed_Object (F)) then\n-            Error_Msg_N (\" cannot inline call to recursive subprogram\", N);\n+            Error_Msg_N (\"cannot inline call to recursive subprogram\", N);\n             return;\n          end if;\n \n@@ -3061,7 +3070,6 @@ package body Exp_Ch6 is\n       --  Cleanup mapping between formals and actuals for other expansions\n \n       F := First_Formal (Subp);\n-\n       while Present (F) loop\n          Set_Renamed_Object (F, Empty);\n          Next_Formal (F);\n@@ -3090,7 +3098,7 @@ package body Exp_Ch6 is\n       ---------------------------\n \n       function Returned_By_Reference return Boolean is\n-         S : Entity_Id := Current_Scope;\n+         S : Entity_Id;\n \n       begin\n          if Is_Return_By_Reference_Type (Typ) then\n@@ -3104,6 +3112,7 @@ package body Exp_Ch6 is\n             --  Verify that the return type of the enclosing function has the\n             --  same constrained status as that of the expression.\n \n+            S := Current_Scope;\n             while Ekind (S) /= E_Function loop\n                S := Scope (S);\n             end loop;\n@@ -3202,9 +3211,9 @@ package body Exp_Ch6 is\n                      --  object is not classwide.\n \n                      Proc := Entity (Name (Parent (N)));\n+\n                      F    := First_Formal (Proc);\n                      A    := First_Actual (Parent (N));\n-\n                      while A /= N loop\n                         Next_Formal (F);\n                         Next_Actual (A);\n@@ -3535,9 +3544,10 @@ package body Exp_Ch6 is\n         and then not Has_Pragma_Pure_Function (Spec_Id)\n       then\n          declare\n-            F : Entity_Id := First_Formal (Spec_Id);\n+            F : Entity_Id;\n \n          begin\n+            F := First_Formal (Spec_Id);\n             while Present (F) loop\n                if Is_Descendent_Of_Address (Etype (F)) then\n                   Set_Is_Pure (Spec_Id, False);\n@@ -3558,7 +3568,7 @@ package body Exp_Ch6 is\n \n       if Init_Or_Norm_Scalars and then Is_Subprogram (Spec_Id) then\n          declare\n-            F : Entity_Id        := First_Formal (Spec_Id);\n+            F : Entity_Id;\n             V : constant Boolean := Validity_Checks_On;\n \n          begin\n@@ -3570,6 +3580,7 @@ package body Exp_Ch6 is\n \n             --  Loop through formals\n \n+            F := First_Formal (Spec_Id);\n             while Present (F) loop\n                if Is_Scalar_Type (Etype (F))\n                  and then Ekind (F) = E_Out_Parameter\n@@ -3589,9 +3600,9 @@ package body Exp_Ch6 is\n \n       Scop := Scope (Spec_Id);\n \n-      --  Add discriminal renamings to protected subprograms.\n-      --  Install new discriminals for expansion of the next\n-      --  subprogram of this protected type, if any.\n+      --  Add discriminal renamings to protected subprograms. Install new\n+      --  discriminals for expansion of the next subprogram of this protected\n+      --  type, if any.\n \n       if Is_List_Member (N)\n         and then Present (Parent (List_Containing (N)))\n@@ -3602,9 +3613,8 @@ package body Exp_Ch6 is\n          Add_Private_Declarations (Declarations (N), Scop, Name_uObject, Loc);\n \n          --  Associate privals and discriminals with the next protected\n-         --  operation body to be expanded. These are used to expand\n-         --  references to private data objects and discriminants,\n-         --  respectively.\n+         --  operation body to be expanded. These are used to expand references\n+         --  to private data objects and discriminants, respectively.\n \n          Next_Op := Next_Protected_Operation (N);\n \n@@ -3633,7 +3643,7 @@ package body Exp_Ch6 is\n       end if;\n \n       --  Returns_By_Ref flag is normally set when the subprogram is frozen\n-      --  but subprograms with no specs are not frozen\n+      --  but subprograms with no specs are not frozen.\n \n       declare\n          Typ  : constant Entity_Id := Etype (Spec_Id);\n@@ -3665,7 +3675,6 @@ package body Exp_Ch6 is\n \n          if Present (Exception_Handlers (H)) then\n             Except_H := First_Non_Pragma (Exception_Handlers (H));\n-\n             while Present (Except_H) loop\n                Add_Return (Statements (Except_H));\n                Next_Non_Pragma (Except_H);\n@@ -3742,7 +3751,6 @@ package body Exp_Ch6 is\n \n          begin\n             Formal := First_Formal (Spec_Id);\n-\n             while Present (Formal) loop\n                Floc := Sloc (Formal);\n \n@@ -3769,18 +3777,6 @@ package body Exp_Ch6 is\n          Expand_Thread_Body;\n       end if;\n \n-      --  If the subprogram does not have pending instantiations, then we\n-      --  must generate the subprogram descriptor now, since the code for\n-      --  the subprogram is complete, and this is our last chance. However\n-      --  if there are pending instantiations, then the code is not\n-      --  complete, and we will delay the generation.\n-\n-      if Is_Subprogram (Spec_Id)\n-        and then not Delay_Subprogram_Descriptors (Spec_Id)\n-      then\n-         Generate_Subprogram_Descriptor_For_Subprogram (N, Spec_Id);\n-      end if;\n-\n       --  Set to encode entity names in package body before gigi is called\n \n       Qualify_Entity_Names (N);\n@@ -3818,8 +3814,8 @@ package body Exp_Ch6 is\n       Prot_Id   : Entity_Id;\n \n    begin\n-      --  Deal with case of protected subprogram. Do not generate\n-      --  protected operation if operation is flagged as eliminated.\n+      --  Deal with case of protected subprogram. Do not generate protected\n+      --  operation if operation is flagged as eliminated.\n \n       if Is_List_Member (N)\n         and then Present (Parent (List_Containing (N)))\n@@ -3833,7 +3829,7 @@ package body Exp_Ch6 is\n               Make_Subprogram_Declaration (Loc,\n                 Specification =>\n                   Build_Protected_Sub_Specification\n-                    (N, Scop, Unprotected => True));\n+                    (N, Scop, Unprotected_Mode));\n \n             --  The protected subprogram is declared outside of the protected\n             --  body. Given that the body has frozen all entities so far, we\n@@ -3907,18 +3903,16 @@ package body Exp_Ch6 is\n       Rec := Make_Identifier (Loc, Name_uObject);\n       Set_Etype (Rec, Corresponding_Record_Type (Scop));\n \n-      --  Find enclosing protected operation, and retrieve its first\n-      --  parameter, which denotes the enclosing protected object.\n-      --  If the enclosing operation is an entry, we are immediately\n-      --  within the protected body, and we can retrieve the object\n-      --  from the service entries procedure. A barrier function has\n-      --  has the same signature as an entry. A barrier function is\n-      --  compiled within the protected object, but unlike protected\n-      --  operations its never needs locks, so that its protected body\n-      --  subprogram points to itself.\n+      --  Find enclosing protected operation, and retrieve its first parameter,\n+      --  which denotes the enclosing protected object. If the enclosing\n+      --  operation is an entry, we are immediately within the protected body,\n+      --  and we can retrieve the object from the service entries procedure. A\n+      --  barrier function has has the same signature as an entry. A barrier\n+      --  function is compiled within the protected object, but unlike\n+      --  protected operations its never needs locks, so that its protected\n+      --  body subprogram points to itself.\n \n       Proc := Current_Scope;\n-\n       while Present (Proc)\n         and then Scope (Proc) /= Scop\n       loop\n@@ -3946,17 +3940,16 @@ package body Exp_Ch6 is\n \n          Set_Entity (Rec, Param);\n \n-         --  Rec is a reference to an entity which will not be in scope\n-         --  when the call is reanalyzed, and needs no further analysis.\n+         --  Rec is a reference to an entity which will not be in scope when\n+         --  the call is reanalyzed, and needs no further analysis.\n \n          Set_Analyzed (Rec);\n \n       else\n-         --  Entry or barrier function for entry body.\n-         --  The first parameter of the entry body procedure is a\n-         --  pointer to the object. We create a local variable\n-         --  of the proper type, duplicating what is done to define\n-         --  _object later on.\n+         --  Entry or barrier function for entry body. The first parameter of\n+         --  the entry body procedure is pointer to the object. We create a\n+         --  local variable of the proper type, duplicating what is done to\n+         --  define _object later on.\n \n          declare\n             Decls : List_Id;\n@@ -3982,9 +3975,8 @@ package body Exp_Ch6 is\n                 Unchecked_Convert_To (Obj_Ptr,\n                   New_Occurrence_Of (Param, Loc)));\n \n-            --  Analyze new actual. Other actuals in calls are already\n-            --  analyzed and the list of actuals is not renalyzed after\n-            --  rewriting.\n+            --  Analyze new actual. Other actuals in calls are already analyzed\n+            --  and the list of actuals is not renalyzed after rewriting.\n \n             Set_Parent (Rec, N);\n             Analyze (Rec);\n@@ -4065,7 +4057,7 @@ package body Exp_Ch6 is\n \n       procedure Check_Overriding_Inherited_Interfaces (E : Entity_Id);\n       --  (Ada 2005): Check if the primitive E covers some interface already\n-      --  implemented by some ancestor of the tagged-type associated with E\n+      --  implemented by some ancestor of the tagged-type associated with E.\n \n       procedure Register_Interface_DT_Entry\n         (Prim                : Entity_Id;\n@@ -4114,29 +4106,56 @@ package body Exp_Ch6 is\n                while Present (Elmt) loop\n                   Prim_Op := Node (Elmt);\n \n-                  if DT_Position (Prim_Op) = DT_Position (E)\n+                  if Chars (Prim_Op) = Chars (E)\n+                    and then Type_Conformant\n+                               (New_Id => Prim_Op,\n+                                Old_Id => E,\n+                                Skip_Controlling_Formals => True)\n+                    and then DT_Position (Prim_Op) = DT_Position (E)\n                     and then Etype (DTC_Entity (Prim_Op)) = RTE (RE_Tag)\n                     and then not Present (Abstract_Interface_Alias (Prim_Op))\n                   then\n-                     if Overriden_Op /= Empty then\n-                        raise Program_Error;\n-                     end if;\n+                     if Overriden_Op = Empty then\n+                        Overriden_Op := Prim_Op;\n+\n+                     --  Additional check to ensure that if two candidates have\n+                     --  been found then they refer to the same subprogram.\n \n-                     Overriden_Op := Prim_Op;\n+                     else\n+                        declare\n+                           A1 : Entity_Id;\n+                           A2 : Entity_Id;\n+\n+                        begin\n+                           A1 := Overriden_Op;\n+                           while Present (Alias (A1)) loop\n+                              A1 := Alias (A1);\n+                           end loop;\n+\n+                           A2 := Prim_Op;\n+                           while Present (Alias (A2)) loop\n+                              A2 := Alias (A2);\n+                           end loop;\n+\n+                           if A1 /= A2 then\n+                              raise Program_Error;\n+                           end if;\n+                        end;\n+                     end if;\n                   end if;\n \n                   Next_Elmt (Elmt);\n                end loop;\n \n-               --  if not found this is the first overriding of some\n-               --  abstract interface\n+               --  If not found this is the first overriding of some abstract\n+               --  interface.\n \n                if Overriden_Op /= Empty then\n-                  Elmt := First_Elmt (Primitive_Operations (Typ));\n \n                   --  Find the entries associated with interfaces that are\n-                  --  alias of this primitive operation in the ancestor\n+                  --  alias of this primitive operation in the ancestor.\n \n+                  Elmt := First_Elmt (Primitive_Operations (Typ));\n                   while Present (Elmt) loop\n                      Prim_Op := Node (Elmt);\n \n@@ -4178,7 +4197,7 @@ package body Exp_Ch6 is\n                             Iface => Iface_Typ);\n \n             --  Generate the code of the thunk only when this primitive\n-            --  operation is associated with a secondary dispatch table\n+            --  operation is associated with a secondary dispatch table.\n \n             if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n                Thunk_Id  := Make_Defining_Identifier (Loc,\n@@ -4188,7 +4207,7 @@ package body Exp_Ch6 is\n                    (N           => Prim,\n                     Thunk_Alias => Alias (Prim),\n                     Thunk_Id    => Thunk_Id,\n-                    Iface_Tag   => Iface_Tag);\n+                    Thunk_Tag   => Iface_Tag);\n \n                Insert_After (N, New_Thunk);\n \n@@ -4238,7 +4257,7 @@ package body Exp_Ch6 is\n                    (N           => Ancestor_Iface_Prim,\n                     Thunk_Alias => Prim_Op,\n                     Thunk_Id    => Thunk_Id,\n-                    Iface_Tag   => Iface_Tag);\n+                    Thunk_Tag   => Iface_Tag);\n \n                Insert_After (N, New_Thunk);\n \n@@ -4279,7 +4298,7 @@ package body Exp_Ch6 is\n \n          else\n             --  Ada 2005 (AI-251): Check if this entry corresponds with\n-            --  a subprogram that covers an abstract interface type\n+            --  a subprogram that covers an abstract interface type.\n \n             if Present (Abstract_Interface_Alias (E)) then\n                Register_Interface_DT_Entry (E);\n@@ -4296,7 +4315,7 @@ package body Exp_Ch6 is\n \n       --  Mark functions that return by reference. Note that it cannot be\n       --  part of the normal semantic analysis of the spec since the\n-      --  underlying returned type may not be known yet (for private types)\n+      --  underlying returned type may not be known yet (for private types).\n \n       declare\n          Typ  : constant Entity_Id := Etype (E);"}, {"sha": "9100d9c2fab727992a384dfdc534c270d15c5d5a", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=2f1b20a916847d44edf6073cb07068ac201c2c58", "patch": "@@ -89,7 +89,7 @@ package Exp_Dbug is\n    --    x\n    --    y.z\n \n-   --  The separating dots are translated into double underscores.\n+   --  The separating dots are translated into double underscores\n \n       -----------------------------\n       -- Handling of Overloading --\n@@ -385,6 +385,28 @@ package Exp_Dbug is\n       --    lock_update1sE\n       --    lock_udpate2sB\n \n+      --  If the protected type implements at least one interface, the\n+      --  following additional operations are created:\n+\n+      --    lock_get\n+\n+      --    lock_set\n+\n+      --  These operations are used to ensure overriding of interface level\n+      --  subprograms and proper dispatching on interface class-wide objects.\n+      --  The bodies of these operations contain calls to their respective\n+      --  protected versions:\n+\n+      --    function lock_get return Integer is\n+      --    begin\n+      --       return lock_getP;\n+      --    end lock_get;\n+\n+      --    procedure lock_set (X : Integer) is\n+      --    begin\n+      --       lock_setP (X);\n+      --    end lock_set;\n+\n    ----------------------------------------------------\n    -- Conversion between Entities and External Names --\n    ----------------------------------------------------\n@@ -686,9 +708,9 @@ package Exp_Dbug is\n       --  follows. In this description, let P represent the current\n       --  bit position in the record.\n \n-      --    1. Initialize P to 0.\n+      --    1. Initialize P to 0\n \n-      --    2. For each field in the record,\n+      --    2. For each field in the record:\n \n       --       2a. If an alignment is given (see below), then round P\n       --       up, if needed, to the next multiple of that alignment.\n@@ -697,7 +719,7 @@ package Exp_Dbug is\n       --       amount (that is, treat it as an offset from the end of the\n       --       preceding record).\n \n-      --       2c. Assign P as the actual position of the field.\n+      --       2c. Assign P as the actual position of the field\n \n       --       2d. Compute the length, L, of the represented field (see below)\n       --       and compute P'=P+L. Unless the field represents a variant part\n@@ -963,7 +985,7 @@ package Exp_Dbug is\n    --  name of the parent unit, to disambiguate child units with the same\n    --  simple name and (of necessity) different parents.\n \n-   --  Note: subprogram renamings are not encoded at the present time.\n+   --  Note: subprogram renamings are not encoded at the present time\n \n    --  The type is an enumeration type with a single enumeration literal\n    --  that is an identifier which describes the renamed variable."}, {"sha": "92e74369c5464f247ca78dc1a968ea721d07c6a3", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=2f1b20a916847d44edf6073cb07068ac201c2c58", "patch": "@@ -53,6 +53,11 @@ package body Lib.Load is\n    -- Local Subprograms --\n    -----------------------\n \n+   function From_Limited_With_Chain (Lim : Boolean) return Boolean;\n+   --  Check whether a possible circular dependence includes units that\n+   --  have been loaded through limited_with clauses, in which case there\n+   --  is no real circularity.\n+\n    function Spec_Is_Irrelevant\n      (Spec_Unit : Unit_Number_Type;\n       Body_Unit : Unit_Number_Type) return Boolean;\n@@ -165,6 +170,30 @@ package body Lib.Load is\n       return Unum;\n    end Create_Dummy_Package_Unit;\n \n+   -----------------------------\n+   -- From_Limited_With_Chain --\n+   -----------------------------\n+\n+   function From_Limited_With_Chain (Lim : Boolean) return Boolean is\n+   begin\n+      --  True if the current load operation is through a limited_with clause\n+\n+      if Lim then\n+         return True;\n+\n+      --  Examine the Load_Stack to locate any previous Limited_with clause\n+\n+      elsif Load_Stack.Last - 1 > Load_Stack.First then\n+         for U in Load_Stack.First .. Load_Stack.Last - 1 loop\n+            if Load_Stack.Table (U).From_Limited_With then\n+               return True;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end From_Limited_With_Chain;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -193,7 +222,7 @@ package body Lib.Load is\n \n    begin\n       Load_Stack.Increment_Last;\n-      Load_Stack.Table (Load_Stack.Last) := Main_Unit;\n+      Load_Stack.Table (Load_Stack.Last) := (Main_Unit, False);\n \n       --  Initialize unit table entry for Main_Unit. Note that we don't know\n       --  the unit name yet, that gets filled in when the parser parses the\n@@ -465,10 +494,11 @@ package body Lib.Load is\n          end loop;\n       end if;\n \n-      --  If we are proceeding with load, then make load stack entry\n+      --  If we are proceeding with load, then make load stack entry,\n+      --  and indicate the kind of with_clause responsible for the load.\n \n       Load_Stack.Increment_Last;\n-      Load_Stack.Table (Load_Stack.Last) := Unum;\n+      Load_Stack.Table (Load_Stack.Last) := (Unum, From_Limited_With);\n \n       --  Case of entry already in table\n \n@@ -489,7 +519,7 @@ package body Lib.Load is\n                        or else Acts_As_Spec (Units.Table (Unum).Cunit))\n            and then (Nkind (Error_Node) /= N_With_Clause\n                        or else not Limited_Present (Error_Node))\n-           and then not From_Limited_With\n+           and then not From_Limited_With_Chain (From_Limited_With)\n          then\n             if Debug_Flag_L then\n                Write_Str (\"  circular dependency encountered\");\n@@ -733,8 +763,10 @@ package body Lib.Load is\n \n       if Load_Stack.Last - 1 > Load_Stack.First then\n          for U in Load_Stack.First .. Load_Stack.Last - 1 loop\n-            Error_Msg_Unit_1 := Unit_Name (Load_Stack.Table (U));\n-            Error_Msg_Unit_2 := Unit_Name (Load_Stack.Table (U + 1));\n+            Error_Msg_Unit_1 :=\n+              Unit_Name (Load_Stack.Table (U).Unit_Number);\n+            Error_Msg_Unit_2 :=\n+              Unit_Name (Load_Stack.Table (U + 1).Unit_Number);\n             Error_Msg (\"$ depends on $!\", Load_Msg_Sloc);\n          end loop;\n       end if;"}, {"sha": "e906ff25610e7d9dd580d73a352eb6abdc54898e", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f1b20a916847d44edf6073cb07068ac201c2c58/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=2f1b20a916847d44edf6073cb07068ac201c2c58", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -239,11 +239,6 @@ package Lib is\n    --  Main_Unit is a body with a separate spec, in which case it is the\n    --  entity for the spec.\n \n-   Unit_Exception_Table_Present : Boolean;\n-   --  Set true if a unit exception table is present for the unit (i.e.\n-   --  zero cost exception handling is active and there is at least one\n-   --  subprogram in the extended unit).\n-\n    -----------------\n    -- Units Table --\n    -----------------\n@@ -623,7 +618,7 @@ package Lib is\n \n    function Generic_Separately_Compiled\n      (Sfile : File_Name_Type) return  Boolean;\n-   --  Same as the previous function, but works directly on a unit file name.\n+   --  Same as the previous function, but works directly on a unit file name\n \n private\n    pragma Inline (Cunit);\n@@ -722,16 +717,23 @@ private\n    type Unit_Ref_Table is array (Pos range <>) of Unit_Number_Type;\n    --  Type to hold list of indirect references to unit number table\n \n-   --  The Load_Stack table contains a list of unit numbers (indexes into the\n-   --  unit table) of units being loaded on a single dependency chain. The\n-   --  First entry is the main unit. The second entry, if present is a unit\n-   --  on which the first unit depends, etc. This stack is used to generate\n-   --  error messages showing the dependency chain if a file is not found.\n-   --  The Load function makes an entry in this table when it is called, and\n-   --  removes the entry just before it returns.\n+   type Load_Stack_Entry is record\n+      Unit_Number       : Unit_Number_Type;\n+      From_Limited_With : Boolean;\n+   end record;\n+\n+   --  The Load_Stack table contains a list of unit numbers (indices into the\n+   --  unit table) of units being loaded on a single dependency chain, and a\n+   --  flag to indicate whether this unit is loaded through a limited_with\n+   --  clause. The First entry is the main unit. The second entry, if present\n+   --  is a unit on which the first unit depends, etc. This stack is used to\n+   --  generate error messages showing the dependency chain if a file is not\n+   --  found, or whether a true circular dependency exists.  The Load_Unit\n+   --  function makes an entry in this table when it is called, and removes\n+   --  the entry just before it returns.\n \n    package Load_Stack is new Table.Table (\n-     Table_Component_Type => Unit_Number_Type,\n+     Table_Component_Type => Load_Stack_Entry,\n      Table_Index_Type     => Nat,\n      Table_Low_Bound      => 0,\n      Table_Initial        => Alloc.Load_Stack_Initial,"}]}