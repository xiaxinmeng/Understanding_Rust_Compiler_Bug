{"sha": "1fb3244aad216c693e0d90f693b2ff4797b4cb63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZiMzI0NGFhZDIxNmM2OTNlMGQ5MGY2OTNiMmZmNDc5N2I0Y2I2Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-01-22T17:39:15Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-01-22T17:39:15Z"}, "message": "re PR c++/9388 ([new parser] ICE in cxx_incomplete_type_diagnostic, at cp/typeck2.c:278)\n\n\tPR c++/9388\n\t* class.c (currently_open_derived_class): Use dependent_type_p.\n\t* cp-tree.h (dependent_type_p): New function.\n\t(dependent_template_arg_p): Likewise.\n\t(dependent_template_p): Likewise.\n\t(type_dependent_expression_p): Likewise.\n\t* parser.c (cp_parser_dependent_type_p): Remove.\n\t(cp_parser_value_dependent_type_p): Likewise.\n\t(cp_parser_type_dependent_expression_p): Likewise.\n\t(cp_parser_dependent_template_arg_p): Likewise.\n\t(cp_parser_dependent_template_id_p): Likewise.\n\t(cp_parser_dependent_template_p): Likewise.\n\t(cp_parser_diagnose_invalid_type_name): Replace\n\tcp_parser_dependent_type_p with dependent_type_p, etc.\n\t(cp_parser_primary_expresion): Likewise.\n\t(cp_parser_nested_name_specifier_opt): Likewise.\n\t(cp_parser_postfix_expression): Likewise.\n\t(cp_parser_unary_expression): Likewise.\n\t(cp_parser_template_name): Likewise.\n\t(cp_parser_class_name): Likewise.\n\t(cp_parser_lookup_name): Likewise.\n\t* pt.c (dependent_type_p): New function.\n\t(value_dependent_expression_p): Likewise.\n\t(type_dependent_expression_p): Likewise.\n\t(dependent_template_arg_p): Likewise.\n\t(dependent_template_id_p): Likewise.\n\t(dependent_template_p): Likewise.\n\n\tPR c++/9285\n\tPR c++/9294\n\t* parser.c (cp_parser_simple_declaration):\n\n\tPR c++/9285\n\tPR c++/9294\n\t* g++.dg/parse/expr2.C: New test.\n\n\tPR c++/9388\n\t* g++.dg/parse/lookup2.C: Likewise.\n\nFrom-SVN: r61596", "tree": {"sha": "7aaeb0692ae8031ae332889f9c66fc242dcf778b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7aaeb0692ae8031ae332889f9c66fc242dcf778b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fb3244aad216c693e0d90f693b2ff4797b4cb63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb3244aad216c693e0d90f693b2ff4797b4cb63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fb3244aad216c693e0d90f693b2ff4797b4cb63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fb3244aad216c693e0d90f693b2ff4797b4cb63/comments", "author": null, "committer": null, "parents": [{"sha": "4888ec5d53eb1207f199f6dd6c152abb61ec9258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4888ec5d53eb1207f199f6dd6c152abb61ec9258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4888ec5d53eb1207f199f6dd6c152abb61ec9258"}], "stats": {"total": 704, "additions": 391, "deletions": 313}, "files": [{"sha": "9ba2af9e2d20e7ac0d3cf8bd97844cc7c68805ef", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -1,3 +1,37 @@\n+2003-01-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9388\n+\t* class.c (currently_open_derived_class): Use dependent_type_p.\n+\t* cp-tree.h (dependent_type_p): New function.\n+\t(dependent_template_arg_p): Likewise.\n+\t(dependent_template_p): Likewise.\n+\t(type_dependent_expression_p): Likewise.\n+\t* parser.c (cp_parser_dependent_type_p): Remove.\n+\t(cp_parser_value_dependent_type_p): Likewise.\n+\t(cp_parser_type_dependent_expression_p): Likewise.\n+\t(cp_parser_dependent_template_arg_p): Likewise.\n+\t(cp_parser_dependent_template_id_p): Likewise.\n+\t(cp_parser_dependent_template_p): Likewise.\n+\t(cp_parser_diagnose_invalid_type_name): Replace\n+\tcp_parser_dependent_type_p with dependent_type_p, etc.\n+\t(cp_parser_primary_expresion): Likewise.\n+\t(cp_parser_nested_name_specifier_opt): Likewise.\n+\t(cp_parser_postfix_expression): Likewise.\n+\t(cp_parser_unary_expression): Likewise.\n+\t(cp_parser_template_name): Likewise.\n+\t(cp_parser_class_name): Likewise.\n+\t(cp_parser_lookup_name): Likewise.\n+\t* pt.c (dependent_type_p): New function.\n+\t(value_dependent_expression_p): Likewise.\n+\t(type_dependent_expression_p): Likewise.\n+\t(dependent_template_arg_p): Likewise.\n+\t(dependent_template_id_p): Likewise.\n+\t(dependent_template_p): Likewise.\n+\t\n+\tPR c++/9285\n+\tPR c++/9294\n+\t* parser.c (cp_parser_simple_declaration): \n+\n 2003-01-21  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tMake-lang.in (cp/decl.o-warn): Add -Wno-error."}, {"sha": "456331f3497616e02f35c2c133fc3b4b6e7076e5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -6001,6 +6001,10 @@ currently_open_derived_class (t)\n {\n   int i;\n \n+  /* The bases of a dependent type are unknown. */\n+  if (dependent_type_p (t))\n+    return NULL_TREE;\n+\n   if (DERIVED_FROM_P (t, current_class_type))\n     return current_class_type;\n "}, {"sha": "787ad0251154225294134cb59d703b3e207a9893", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -4088,6 +4088,10 @@ extern void record_last_problematic_instantiation (void);\n extern tree current_instantiation               (void);\n extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n+extern bool dependent_type_p                    (tree);\n+extern bool dependent_template_arg_p            (tree);\n+extern bool dependent_template_p                (tree);\n+extern bool type_dependent_expression_p         (tree);\n \n /* in repo.c */\n extern void repo_template_used (tree);"}, {"sha": "df9284c8c4990fc9f2a1e6d2d52eea34c03abeed", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 30, "deletions": 313, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -1780,18 +1780,6 @@ static bool cp_parser_is_string_literal\n   PARAMS ((cp_token *));\n static bool cp_parser_is_keyword \n   PARAMS ((cp_token *, enum rid));\n-static bool cp_parser_dependent_type_p\n-  (tree);\n-static bool cp_parser_value_dependent_expression_p\n-  (tree);\n-static bool cp_parser_type_dependent_expression_p\n-  (tree);\n-static bool cp_parser_dependent_template_arg_p\n-  (tree);\n-static bool cp_parser_dependent_template_id_p\n-  (tree, tree);\n-static bool cp_parser_dependent_template_p\n-  (tree);\n static tree cp_parser_scope_through_which_access_occurs\n   (tree, tree, tree);\n \n@@ -1823,283 +1811,6 @@ cp_parser_is_keyword (token, keyword)\n   return token->keyword == keyword;\n }\n \n-/* Returns TRUE if TYPE is dependent, in the sense of\n-   [temp.dep.type].  */\n-\n-static bool\n-cp_parser_dependent_type_p (type)\n-     tree type;\n-{\n-  tree scope;\n-\n-  if (!processing_template_decl)\n-    return false;\n-\n-  /* If the type is NULL, we have not computed a type for the entity\n-     in question; in that case, the type is dependent.  */\n-  if (!type)\n-    return true;\n-\n-  /* Erroneous types can be considered non-dependent.  */\n-  if (type == error_mark_node)\n-    return false;\n-\n-  /* [temp.dep.type]\n-\n-     A type is dependent if it is:\n-\n-     -- a template parameter.  */\n-  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-    return true;\n-  /* -- a qualified-id with a nested-name-specifier which contains a\n-        class-name that names a dependent type or whose unqualified-id\n-\tnames a dependent type.  */\n-  if (TREE_CODE (type) == TYPENAME_TYPE)\n-    return true;\n-  /* -- a cv-qualified type where the cv-unqualified type is\n-        dependent.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-  /* -- a compound type constructed from any dependent type.  */\n-  if (TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n-    return (cp_parser_dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n-\t    || cp_parser_dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE \n-\t\t\t\t\t   (type)));\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   || TREE_CODE (type) == REFERENCE_TYPE)\n-    return cp_parser_dependent_type_p (TREE_TYPE (type));\n-  else if (TREE_CODE (type) == FUNCTION_TYPE\n-\t   || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      tree arg_type;\n-\n-      if (cp_parser_dependent_type_p (TREE_TYPE (type)))\n-\treturn true;\n-      for (arg_type = TYPE_ARG_TYPES (type); \n-\t   arg_type; \n-\t   arg_type = TREE_CHAIN (arg_type))\n-\tif (cp_parser_dependent_type_p (TREE_VALUE (arg_type)))\n-\t  return true;\n-      return false;\n-    }\n-  /* -- an array type constructed from any dependent type or whose\n-        size is specified by a constant expression that is\n-\tvalue-dependent.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      if (TYPE_DOMAIN (type)\n-\t  && ((cp_parser_value_dependent_expression_p \n-\t       (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n-\t      || (cp_parser_type_dependent_expression_p\n-\t\t  (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))))\n-\treturn true;\n-      return cp_parser_dependent_type_p (TREE_TYPE (type));\n-    }\n-  /* -- a template-id in which either the template name is a template\n-        parameter or any of the template arguments is a dependent type or\n-\tan expression that is type-dependent or value-dependent.  \n-\n-     This language seems somewhat confused; for example, it does not\n-     discuss template template arguments.  Therefore, we use the\n-     definition for dependent template arguments in [temp.dep.temp].  */\n-  if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n-      && (cp_parser_dependent_template_id_p\n-\t  (CLASSTYPE_TI_TEMPLATE (type),\n-\t   CLASSTYPE_TI_ARGS (type))))\n-    return true;\n-  else if (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-    return true;\n-  /* All TYPEOF_TYPEs are dependent; if the argument of the `typeof'\n-     expression is not type-dependent, then it should already been\n-     have resolved.  */\n-  if (TREE_CODE (type) == TYPEOF_TYPE)\n-    return true;\n-  /* The standard does not specifically mention types that are local\n-     to template functions or local classes, but they should be\n-     considered dependent too.  For example:\n-\n-       template <int I> void f() { \n-         enum E { a = I }; \n-\t S<sizeof (E)> s;\n-       }\n-\n-     The size of `E' cannot be known until the value of `I' has been\n-     determined.  Therefore, `E' must be considered dependent.  */\n-  scope = TYPE_CONTEXT (type);\n-  if (scope && TYPE_P (scope))\n-    return cp_parser_dependent_type_p (scope);\n-  else if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n-    return cp_parser_type_dependent_expression_p (scope);\n-\n-  /* Other types are non-dependent.  */\n-  return false;\n-}\n-\n-/* Returns TRUE if the EXPRESSION is value-dependent.  */\n-\n-static bool\n-cp_parser_value_dependent_expression_p (tree expression)\n-{\n-  if (!processing_template_decl)\n-    return false;\n-\n-  /* A name declared with a dependent type.  */\n-  if (DECL_P (expression)\n-      && cp_parser_dependent_type_p (TREE_TYPE (expression)))\n-    return true;\n-  /* A non-type template parameter.  */\n-  if ((TREE_CODE (expression) == CONST_DECL\n-       && DECL_TEMPLATE_PARM_P (expression))\n-      || TREE_CODE (expression) == TEMPLATE_PARM_INDEX)\n-    return true;\n-  /* A constant with integral or enumeration type and is initialized \n-     with an expression that is value-dependent.  */\n-  if (TREE_CODE (expression) == VAR_DECL\n-      && DECL_INITIAL (expression)\n-      && (CP_INTEGRAL_TYPE_P (TREE_TYPE (expression))\n-\t  || TREE_CODE (TREE_TYPE (expression)) == ENUMERAL_TYPE)\n-      && cp_parser_value_dependent_expression_p (DECL_INITIAL (expression)))\n-    return true;\n-  /* These expressions are value-dependent if the type to which the\n-     cast occurs is dependent.  */\n-  if ((TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n-       || TREE_CODE (expression) == STATIC_CAST_EXPR\n-       || TREE_CODE (expression) == CONST_CAST_EXPR\n-       || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n-       || TREE_CODE (expression) == CAST_EXPR)\n-      && cp_parser_dependent_type_p (TREE_TYPE (expression)))\n-    return true;\n-  /* A `sizeof' expression where the sizeof operand is a type is\n-     value-dependent if the type is dependent.  If the type was not\n-     dependent, we would no longer have a SIZEOF_EXPR, so any\n-     SIZEOF_EXPR is dependent.  */\n-  if (TREE_CODE (expression) == SIZEOF_EXPR)\n-    return true;\n-  /* A constant expression is value-dependent if any subexpression is\n-     value-dependent.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expression))))\n-    {\n-      switch (TREE_CODE_CLASS (TREE_CODE (expression)))\n-\t{\n-\tcase '1':\n-\t  return (cp_parser_value_dependent_expression_p \n-\t\t  (TREE_OPERAND (expression, 0)));\n-\tcase '<':\n-\tcase '2':\n-\t  return ((cp_parser_value_dependent_expression_p \n-\t\t   (TREE_OPERAND (expression, 0)))\n-\t\t  || (cp_parser_value_dependent_expression_p \n-\t\t      (TREE_OPERAND (expression, 1))));\n-\tcase 'e':\n-\t  {\n-\t    int i;\n-\t    for (i = 0; \n-\t\t i < TREE_CODE_LENGTH (TREE_CODE (expression));\n-\t\t ++i)\n-\t      if (cp_parser_value_dependent_expression_p\n-\t\t  (TREE_OPERAND (expression, i)))\n-\t\treturn true;\n-\t    return false;\n-\t  }\n-\t}\n-    }\n-\n-  /* The expression is not value-dependent.  */\n-  return false;\n-}\n-\n-/* Returns TRUE if the EXPRESSION is type-dependent, in the sense of\n-   [temp.dep.expr].  */\n-\n-static bool\n-cp_parser_type_dependent_expression_p (expression)\n-     tree expression;\n-{\n-  if (!processing_template_decl)\n-    return false;\n-\n-  /* Some expression forms are never type-dependent.  */\n-  if (TREE_CODE (expression) == PSEUDO_DTOR_EXPR\n-      || TREE_CODE (expression) == SIZEOF_EXPR\n-      || TREE_CODE (expression) == ALIGNOF_EXPR\n-      || TREE_CODE (expression) == TYPEID_EXPR\n-      || TREE_CODE (expression) == DELETE_EXPR\n-      || TREE_CODE (expression) == VEC_DELETE_EXPR\n-      || TREE_CODE (expression) == THROW_EXPR)\n-    return false;\n-\n-  /* The types of these expressions depends only on the type to which\n-     the cast occurs.  */\n-  if (TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n-      || TREE_CODE (expression) == STATIC_CAST_EXPR\n-      || TREE_CODE (expression) == CONST_CAST_EXPR\n-      || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n-      || TREE_CODE (expression) == CAST_EXPR)\n-    return cp_parser_dependent_type_p (TREE_TYPE (expression));\n-  /* The types of these expressions depends only on the type created\n-     by the expression.  */\n-  else if (TREE_CODE (expression) == NEW_EXPR\n-\t   || TREE_CODE (expression) == VEC_NEW_EXPR)\n-    return cp_parser_dependent_type_p (TREE_OPERAND (expression, 1));\n-\n-  if (TREE_CODE (expression) == FUNCTION_DECL\n-      && DECL_LANG_SPECIFIC (expression)\n-      && DECL_TEMPLATE_INFO (expression)\n-      && (cp_parser_dependent_template_id_p\n-\t  (DECL_TI_TEMPLATE (expression),\n-\t   INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n-    return true;\n-\n-  return (cp_parser_dependent_type_p (TREE_TYPE (expression)));\n-}\n-\n-/* Returns TRUE if the ARG (a template argument) is dependent.  */\n-\n-static bool\n-cp_parser_dependent_template_arg_p (tree arg)\n-{\n-  if (!processing_template_decl)\n-    return false;\n-\n-  if (TREE_CODE (arg) == TEMPLATE_DECL\n-      || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n-    return cp_parser_dependent_template_p (arg);\n-  else if (TYPE_P (arg))\n-    return cp_parser_dependent_type_p (arg);\n-  else\n-    return (cp_parser_type_dependent_expression_p (arg)\n-\t    || cp_parser_value_dependent_expression_p (arg));\n-}\n-\n-/* Returns TRUE if the specialization TMPL<ARGS> is dependent.  */\n-\n-static bool\n-cp_parser_dependent_template_id_p (tree tmpl, tree args)\n-{\n-  int i;\n-\n-  if (cp_parser_dependent_template_p (tmpl))\n-    return true;\n-  for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-    if (cp_parser_dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-      return true;\n-  return false;\n-}\n-\n-/* Returns TRUE if the template TMPL is dependent.  */\n-\n-static bool\n-cp_parser_dependent_template_p (tree tmpl)\n-{\n-  /* Template template parameters are dependent.  */\n-  if (DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)\n-      || TREE_CODE (tmpl) == TEMPLATE_TEMPLATE_PARM)\n-    return true;\n-  /* So are member templates of dependent classes.  */\n-  if (TYPE_P (CP_DECL_CONTEXT (tmpl)))\n-    return cp_parser_dependent_type_p (DECL_CONTEXT (tmpl));\n-  return false;\n-}\n-\n /* Returns the scope through which DECL is being accessed, or\n    NULL_TREE if DECL is not a member.  If OBJECT_TYPE is non-NULL, we\n    have just seen `x->' or `x.' and OBJECT_TYPE is the type of `*x',\n@@ -2244,7 +1955,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n \t    {\n \t      tree base_type = BINFO_TYPE (b);\n \t      if (CLASS_TYPE_P (base_type) \n-\t\t  && cp_parser_dependent_type_p (base_type))\n+\t\t  && dependent_type_p (base_type))\n \t\t{\n \t\t  tree field;\n \t\t  /* Go from a particular instantiation of the\n@@ -2941,7 +2652,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       its type.  */\n \t    else if (!is_overloaded_fn (decl))\n \t      dependent_p \n-\t\t= cp_parser_dependent_type_p (TREE_TYPE (decl));\n+\t\t= dependent_type_p (TREE_TYPE (decl));\n \t    /* For a set of overloaded functions, check each of the\n \t       functions.  */\n \t    else\n@@ -2961,8 +2672,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t      {\n \t\t\twhile (args)\n \t\t\t  {\n-\t\t\t    if (cp_parser_dependent_template_arg_p\n-\t\t\t\t(TREE_VALUE (args)))\n+\t\t\t    if (dependent_template_arg_p (TREE_VALUE (args)))\n \t\t\t      {\n \t\t\t\tdependent_p = true;\n \t\t\t\tbreak;\n@@ -2974,8 +2684,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t      {\n \t\t\tint i; \n \t\t\tfor (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-\t\t\t  if (cp_parser_dependent_template_arg_p\n-\t\t\t      (TREE_VEC_ELT (args, i)))\n+\t\t\t  if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n \t\t\t    {\n \t\t\t      dependent_p = true;\n \t\t\t      break;\n@@ -2996,10 +2705,10 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t    /* Member functions of dependent classes are\n \t\t       dependent.  */\n \t\t    if (TREE_CODE (fn) == FUNCTION_DECL\n-\t\t\t&& cp_parser_type_dependent_expression_p (fn))\n+\t\t\t&& type_dependent_expression_p (fn))\n \t\t      dependent_p = true;\n \t\t    else if (TREE_CODE (fn) == TEMPLATE_DECL\n-\t\t\t     && cp_parser_dependent_template_p (fn))\n+\t\t\t     && dependent_template_p (fn))\n \t\t      dependent_p = true;\n \t\t    \n \t\t    fns = OVL_NEXT (fns);\n@@ -3611,7 +3320,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t     avoid doing it if the type is already complete.  */\n \t  && !COMPLETE_TYPE_P (parser->scope)\n \t  /* Do not try to complete dependent types.  */\n-\t  && !cp_parser_dependent_type_p (parser->scope))\n+\t  && !dependent_type_p (parser->scope))\n \tcomplete_type (parser->scope);\n     }\n \n@@ -4160,7 +3869,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t   Do Koenig lookup -- unless any of the arguments are\n \t\t   type-dependent.  */\n \t\tfor (arg = args; arg; arg = TREE_CHAIN (arg))\n-\t\t  if (cp_parser_type_dependent_expression_p (TREE_VALUE (arg)))\n+\t\t  if (type_dependent_expression_p (TREE_VALUE (arg)))\n \t\t      break;\n \t\tif (!arg)\n \t\t  {\n@@ -4244,8 +3953,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t      postfix_expression = build_x_arrow (postfix_expression);\n \t    /* Check to see whether or not the expression is\n \t       type-dependent.  */\n-\t    dependent_p = (cp_parser_type_dependent_expression_p \n-\t\t\t   (postfix_expression));\n+\t    dependent_p = (type_dependent_expression_p (postfix_expression));\n \t    /* The identifier following the `->' or `.' is not\n \t       qualified.  */\n \t    parser->scope = NULL_TREE;\n@@ -4554,8 +4262,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t    /* If the type of the operand cannot be determined build a\n \t       SIZEOF_EXPR.  */\n \t    if (TYPE_P (operand)\n-\t\t? cp_parser_dependent_type_p (operand)\n-\t\t: cp_parser_type_dependent_expression_p (operand))\n+\t\t? dependent_type_p (operand)\n+\t\t: type_dependent_expression_p (operand))\n \t      return build_min (SIZEOF_EXPR, size_type_node, operand);\n \t    /* Otherwise, compute the constant value.  */\n \t    else\n@@ -6776,6 +6484,15 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n \t\t\t\t function_definition_allowed_p,\n \t\t\t\t /*member_p=*/false,\n \t\t\t\t &function_definition_p);\n+      /* If an error occurred while parsing tentatively, exit quickly.\n+\t (That usually happens when in the body of a function; each\n+\t statement is treated as a declaration-statement until proven\n+\t otherwise.)  */\n+      if (cp_parser_error_occurred (parser))\n+\t{\n+\t  pop_deferring_access_checks ();\n+\t  return;\n+\t}\n       /* Handle function definitions specially.  */\n       if (function_definition_p)\n \t{\n@@ -8344,7 +8061,7 @@ cp_parser_template_name (parser, template_keyword_p, check_dependency_p)\n   if (DECL_FUNCTION_TEMPLATE_P (decl) || !DECL_P (decl))\n     {\n       tree scope = CP_DECL_CONTEXT (get_first_fn (decl));\n-      if (TYPE_P (scope) && cp_parser_dependent_type_p (scope))\n+      if (TYPE_P (scope) && dependent_type_p (scope))\n \treturn identifier;\n     }\n \n@@ -11507,7 +11224,7 @@ cp_parser_class_name (cp_parser *parser,\n   /* Any name names a type if we're following the `typename' keyword\n      in a qualified name where the enclosing scope is type-dependent.  */\n   typename_p = (typename_keyword_p && scope && TYPE_P (scope)\n-\t\t&& cp_parser_dependent_type_p (scope));\n+\t\t&& dependent_type_p (scope));\n   /* Handle the common case (an identifier, but not a template-id)\n      efficiently.  */\n   if (token->type == CPP_NAME \n@@ -13456,7 +13173,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access,\n   /* Perform the lookup.  */\n   if (parser->scope)\n     { \n-      bool dependent_type_p;\n+      bool dependent_p;\n \n       if (parser->scope == error_mark_node)\n \treturn error_mark_node;\n@@ -13466,12 +13183,12 @@ cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access,\n \t looking up names in uninstantiated templates.  Even then, we\n \t cannot look up the name if the scope is not a class type; it\n \t might, for example, be a template type parameter.  */\n-      dependent_type_p = (TYPE_P (parser->scope)\n-\t\t\t  && !(parser->in_declarator_p\n-\t\t\t       && currently_open_class (parser->scope))\n-\t\t\t  && cp_parser_dependent_type_p (parser->scope));\n+      dependent_p = (TYPE_P (parser->scope)\n+\t\t     && !(parser->in_declarator_p\n+\t\t\t  && currently_open_class (parser->scope))\n+\t\t     && dependent_type_p (parser->scope));\n       if ((check_dependency || !CLASS_TYPE_P (parser->scope))\n-\t   && dependent_type_p)\n+\t   && dependent_p)\n \t{\n \t  if (!is_type)\n \t    decl = build_nt (SCOPE_REF, parser->scope, name);\n@@ -13490,15 +13207,15 @@ cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access,\n \t     otherwise, we would have processed this lookup above.  So\n \t     that PARSER->SCOPE is not considered a dependent base by\n \t     lookup_member, we must enter the scope here.  */\n-\t  if (dependent_type_p)\n+\t  if (dependent_p)\n \t    push_scope (parser->scope);\n \t  /* If the PARSER->SCOPE is a a template specialization, it\n \t     may be instantiated during name lookup.  In that case,\n \t     errors may be issued.  Even if we rollback the current\n \t     tentative parse, those errors are valid.  */\n \t  decl = lookup_qualified_name (parser->scope, name, is_type,\n \t\t\t\t\t/*flags=*/0);\n-\t  if (dependent_type_p)\n+\t  if (dependent_p)\n \t    pop_scope (parser->scope);\n \t}\n       parser->qualifying_scope = parser->scope;"}, {"sha": "9f391ebf0368a57b007c309c5c25e58f7a22675d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -171,6 +171,8 @@ static void copy_default_args_to_explicit_spec PARAMS ((tree));\n static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n static int eq_local_specializations (const void *, const void *);\n static tree template_for_substitution (tree);\n+static bool value_dependent_expression_p (tree);\n+static bool dependent_template_id_p (tree, tree);\n \n /* Make the current scope suitable for access checking when we are\n    processing T.  T can be FUNCTION_DECL for instantiated function\n@@ -11187,4 +11189,283 @@ invalid_nontype_parm_type_p (type, complain)\n   return 1;\n }\n \n+/* Returns TRUE if TYPE is dependent, in the sense of\n+   [temp.dep.type].  */\n+\n+bool\n+dependent_type_p (type)\n+     tree type;\n+{\n+  tree scope;\n+\n+  /* If there are no template parameters in scope, then there can't be\n+     any dependent types.  */\n+  if (!processing_template_decl)\n+    return false;\n+\n+  /* If the type is NULL, we have not computed a type for the entity\n+     in question; in that case, the type is dependent.  */\n+  if (!type)\n+    return true;\n+\n+  /* Erroneous types can be considered non-dependent.  */\n+  if (type == error_mark_node)\n+    return false;\n+\n+  /* [temp.dep.type]\n+\n+     A type is dependent if it is:\n+\n+     -- a template parameter.  */\n+  if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n+    return true;\n+  /* -- a qualified-id with a nested-name-specifier which contains a\n+        class-name that names a dependent type or whose unqualified-id\n+\tnames a dependent type.  */\n+  if (TREE_CODE (type) == TYPENAME_TYPE)\n+    return true;\n+  /* -- a cv-qualified type where the cv-unqualified type is\n+        dependent.  */\n+  type = TYPE_MAIN_VARIANT (type);\n+  /* -- a compound type constructed from any dependent type.  */\n+  if (TYPE_PTRMEM_P (type) || TYPE_PTRMEMFUNC_P (type))\n+    return (dependent_type_p (TYPE_PTRMEM_CLASS_TYPE (type))\n+\t    || dependent_type_p (TYPE_PTRMEM_POINTED_TO_TYPE \n+\t\t\t\t\t   (type)));\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   || TREE_CODE (type) == REFERENCE_TYPE)\n+    return dependent_type_p (TREE_TYPE (type));\n+  else if (TREE_CODE (type) == FUNCTION_TYPE\n+\t   || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      tree arg_type;\n+\n+      if (dependent_type_p (TREE_TYPE (type)))\n+\treturn true;\n+      for (arg_type = TYPE_ARG_TYPES (type); \n+\t   arg_type; \n+\t   arg_type = TREE_CHAIN (arg_type))\n+\tif (dependent_type_p (TREE_VALUE (arg_type)))\n+\t  return true;\n+      return false;\n+    }\n+  /* -- an array type constructed from any dependent type or whose\n+        size is specified by a constant expression that is\n+\tvalue-dependent.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      if (TYPE_DOMAIN (type)\n+\t  && ((value_dependent_expression_p \n+\t       (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+\t      || (type_dependent_expression_p\n+\t\t  (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))))\n+\treturn true;\n+      return dependent_type_p (TREE_TYPE (type));\n+    }\n+  /* -- a template-id in which either the template name is a template\n+        parameter or any of the template arguments is a dependent type or\n+\tan expression that is type-dependent or value-dependent.  \n+\n+     This language seems somewhat confused; for example, it does not\n+     discuss template template arguments.  Therefore, we use the\n+     definition for dependent template arguments in [temp.dep.temp].  */\n+  if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INFO (type)\n+      && (dependent_template_id_p\n+\t  (CLASSTYPE_TI_TEMPLATE (type),\n+\t   CLASSTYPE_TI_ARGS (type))))\n+    return true;\n+  else if (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n+    return true;\n+  /* All TYPEOF_TYPEs are dependent; if the argument of the `typeof'\n+     expression is not type-dependent, then it should already been\n+     have resolved.  */\n+  if (TREE_CODE (type) == TYPEOF_TYPE)\n+    return true;\n+  /* The standard does not specifically mention types that are local\n+     to template functions or local classes, but they should be\n+     considered dependent too.  For example:\n+\n+       template <int I> void f() { \n+         enum E { a = I }; \n+\t S<sizeof (E)> s;\n+       }\n+\n+     The size of `E' cannot be known until the value of `I' has been\n+     determined.  Therefore, `E' must be considered dependent.  */\n+  scope = TYPE_CONTEXT (type);\n+  if (scope && TYPE_P (scope))\n+    return dependent_type_p (scope);\n+  else if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n+    return type_dependent_expression_p (scope);\n+\n+  /* Other types are non-dependent.  */\n+  return false;\n+}\n+\n+/* Returns TRUE if the EXPRESSION is value-dependent.  */\n+\n+static bool\n+value_dependent_expression_p (tree expression)\n+{\n+  if (!processing_template_decl)\n+    return false;\n+\n+  /* A name declared with a dependent type.  */\n+  if (DECL_P (expression)\n+      && dependent_type_p (TREE_TYPE (expression)))\n+    return true;\n+  /* A non-type template parameter.  */\n+  if ((TREE_CODE (expression) == CONST_DECL\n+       && DECL_TEMPLATE_PARM_P (expression))\n+      || TREE_CODE (expression) == TEMPLATE_PARM_INDEX)\n+    return true;\n+  /* A constant with integral or enumeration type and is initialized \n+     with an expression that is value-dependent.  */\n+  if (TREE_CODE (expression) == VAR_DECL\n+      && DECL_INITIAL (expression)\n+      && (CP_INTEGRAL_TYPE_P (TREE_TYPE (expression))\n+\t  || TREE_CODE (TREE_TYPE (expression)) == ENUMERAL_TYPE)\n+      && value_dependent_expression_p (DECL_INITIAL (expression)))\n+    return true;\n+  /* These expressions are value-dependent if the type to which the\n+     cast occurs is dependent.  */\n+  if ((TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n+       || TREE_CODE (expression) == STATIC_CAST_EXPR\n+       || TREE_CODE (expression) == CONST_CAST_EXPR\n+       || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n+       || TREE_CODE (expression) == CAST_EXPR)\n+      && dependent_type_p (TREE_TYPE (expression)))\n+    return true;\n+  /* A `sizeof' expression where the sizeof operand is a type is\n+     value-dependent if the type is dependent.  If the type was not\n+     dependent, we would no longer have a SIZEOF_EXPR, so any\n+     SIZEOF_EXPR is dependent.  */\n+  if (TREE_CODE (expression) == SIZEOF_EXPR)\n+    return true;\n+  /* A constant expression is value-dependent if any subexpression is\n+     value-dependent.  */\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expression))))\n+    {\n+      switch (TREE_CODE_CLASS (TREE_CODE (expression)))\n+\t{\n+\tcase '1':\n+\t  return (value_dependent_expression_p \n+\t\t  (TREE_OPERAND (expression, 0)));\n+\tcase '<':\n+\tcase '2':\n+\t  return ((value_dependent_expression_p \n+\t\t   (TREE_OPERAND (expression, 0)))\n+\t\t  || (value_dependent_expression_p \n+\t\t      (TREE_OPERAND (expression, 1))));\n+\tcase 'e':\n+\t  {\n+\t    int i;\n+\t    for (i = 0; \n+\t\t i < TREE_CODE_LENGTH (TREE_CODE (expression));\n+\t\t ++i)\n+\t      if (value_dependent_expression_p\n+\t\t  (TREE_OPERAND (expression, i)))\n+\t\treturn true;\n+\t    return false;\n+\t  }\n+\t}\n+    }\n+\n+  /* The expression is not value-dependent.  */\n+  return false;\n+}\n+\n+/* Returns TRUE if the EXPRESSION is type-dependent, in the sense of\n+   [temp.dep.expr].  */\n+\n+bool\n+type_dependent_expression_p (expression)\n+     tree expression;\n+{\n+  if (!processing_template_decl)\n+    return false;\n+\n+  /* Some expression forms are never type-dependent.  */\n+  if (TREE_CODE (expression) == PSEUDO_DTOR_EXPR\n+      || TREE_CODE (expression) == SIZEOF_EXPR\n+      || TREE_CODE (expression) == ALIGNOF_EXPR\n+      || TREE_CODE (expression) == TYPEID_EXPR\n+      || TREE_CODE (expression) == DELETE_EXPR\n+      || TREE_CODE (expression) == VEC_DELETE_EXPR\n+      || TREE_CODE (expression) == THROW_EXPR)\n+    return false;\n+\n+  /* The types of these expressions depends only on the type to which\n+     the cast occurs.  */\n+  if (TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n+      || TREE_CODE (expression) == STATIC_CAST_EXPR\n+      || TREE_CODE (expression) == CONST_CAST_EXPR\n+      || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n+      || TREE_CODE (expression) == CAST_EXPR)\n+    return dependent_type_p (TREE_TYPE (expression));\n+  /* The types of these expressions depends only on the type created\n+     by the expression.  */\n+  else if (TREE_CODE (expression) == NEW_EXPR\n+\t   || TREE_CODE (expression) == VEC_NEW_EXPR)\n+    return dependent_type_p (TREE_OPERAND (expression, 1));\n+\n+  if (TREE_CODE (expression) == FUNCTION_DECL\n+      && DECL_LANG_SPECIFIC (expression)\n+      && DECL_TEMPLATE_INFO (expression)\n+      && (dependent_template_id_p\n+\t  (DECL_TI_TEMPLATE (expression),\n+\t   INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n+    return true;\n+\n+  return (dependent_type_p (TREE_TYPE (expression)));\n+}\n+\n+/* Returns TRUE if the ARG (a template argument) is dependent.  */\n+\n+bool\n+dependent_template_arg_p (tree arg)\n+{\n+  if (!processing_template_decl)\n+    return false;\n+\n+  if (TREE_CODE (arg) == TEMPLATE_DECL\n+      || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM)\n+    return dependent_template_p (arg);\n+  else if (TYPE_P (arg))\n+    return dependent_type_p (arg);\n+  else\n+    return (type_dependent_expression_p (arg)\n+\t    || value_dependent_expression_p (arg));\n+}\n+\n+/* Returns TRUE if the specialization TMPL<ARGS> is dependent.  */\n+\n+static bool\n+dependent_template_id_p (tree tmpl, tree args)\n+{\n+  int i;\n+\n+  if (dependent_template_p (tmpl))\n+    return true;\n+  for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+    if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n+      return true;\n+  return false;\n+}\n+\n+/* Returns TRUE if the template TMPL is dependent.  */\n+\n+bool\n+dependent_template_p (tree tmpl)\n+{\n+  /* Template template parameters are dependent.  */\n+  if (DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)\n+      || TREE_CODE (tmpl) == TEMPLATE_TEMPLATE_PARM)\n+    return true;\n+  /* So are member templates of dependent classes.  */\n+  if (TYPE_P (CP_DECL_CONTEXT (tmpl)))\n+    return dependent_type_p (DECL_CONTEXT (tmpl));\n+  return false;\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "cbf0ad94e93452208e6ba8ecc77b4a0fe2da5944", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -1,3 +1,12 @@\n+2003-01-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/9285\n+\tPR c++/9294\n+\t* g++.dg/parse/expr2.C: New test.\n+\n+\tPR c++/9388\n+\t* g++.dg/parse/lookup2.C: Likewise.\n+\n Tue Jan 21 18:01:35 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.c-torture/execute/990208-1.c:  Add noinline attributes as needed."}, {"sha": "32800e4f9cd8fe2f1d629c6665b9347d17480f3c", "filename": "gcc/testsuite/g++.dg/parse/expr2.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fexpr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fexpr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fexpr2.C?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -0,0 +1,8 @@\n+struct X {\n+  X(double *data, double d0, double d1);\n+};\n+\n+int foo(double d0) {\n+  double * data;\n+  X(data,d0,d0);\n+}"}, {"sha": "fcf17cde450eb8753f609faf154e74fb5dfc1db0", "filename": "gcc/testsuite/g++.dg/parse/lookup2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flookup2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fb3244aad216c693e0d90f693b2ff4797b4cb63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flookup2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Flookup2.C?ref=1fb3244aad216c693e0d90f693b2ff4797b4cb63", "patch": "@@ -0,0 +1,21 @@\n+template <typename T> struct A\n+{\n+   typedef int X;\n+};\n+\n+template <typename T> struct B\n+{\n+   typename A<T>::X x;\n+};\n+\n+template <typename T> struct C\n+{\n+   void foo(int);\n+   B<A<T>*> b;\n+};\n+\n+template <typename T> struct D\n+{\n+   enum { e };\n+   void bar() { C<T*>::foo(e); }\n+};"}]}