{"sha": "40b18c0a378124dca8b0f29f798fb47de9516e15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBiMThjMGEzNzgxMjRkY2E4YjBmMjlmNzk4ZmI0N2RlOTUxNmUxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-07-11T17:35:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-07-11T17:35:56Z"}, "message": "stmt.c (parse_output_constraint): New function, split out from ...\n\n\t* stmt.c (parse_output_constraint): New function, split out\n\tfrom ...\n\t(expand_asm_operands): ... here.  Use parse_output_constraint.\n\t* tree.h (parse_output_constraint): Declare it.\n\n\t* semantics.c (finish_asm_stmt): Mark the output operands\n\tto an asm addressable, if necessary.\n\nFrom-SVN: r43941", "tree": {"sha": "57b7a186faa875a9fa8844e89aecf8ef603b8726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57b7a186faa875a9fa8844e89aecf8ef603b8726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40b18c0a378124dca8b0f29f798fb47de9516e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b18c0a378124dca8b0f29f798fb47de9516e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40b18c0a378124dca8b0f29f798fb47de9516e15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40b18c0a378124dca8b0f29f798fb47de9516e15/comments", "author": null, "committer": null, "parents": [{"sha": "a615c28a76cf89e38a5ee5359b9215948c21efe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a615c28a76cf89e38a5ee5359b9215948c21efe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a615c28a76cf89e38a5ee5359b9215948c21efe7"}], "stats": {"total": 393, "additions": 257, "deletions": 136}, "files": [{"sha": "7093a5c048808f35aca7c862d1574bf71da420a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40b18c0a378124dca8b0f29f798fb47de9516e15", "patch": "@@ -1,3 +1,10 @@\n+2001-07-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* stmt.c (parse_output_constraint): New function, split out \n+\tfrom ...\n+\t(expand_asm_operands): ... here.  Use parse_output_constraint.\n+\t* tree.h (parse_output_constraint): Declare it.\n+\n 2001-07-11  Richard Henderson  <rth@redhat.com>\n \n \t* bitmap.c: Comment some functions; fiddle whitespace."}, {"sha": "486533b44cfb9ccb195abeb131311ac3e37aa0c4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=40b18c0a378124dca8b0f29f798fb47de9516e15", "patch": "@@ -1,3 +1,8 @@\n+2001-07-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* semantics.c (finish_asm_stmt): Mark the output operands\n+\tto an asm addressable, if necessary.\n+\n 2001-07-11  Ben Elliston  <bje@redhat.com>\n \n \t* Revert this change -- there is a subtle bug."}, {"sha": "2bb4051affc64317ce3f5b21ed9fbb6e48578ea2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=40b18c0a378124dca8b0f29f798fb47de9516e15", "patch": "@@ -894,23 +894,65 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n     }\n \n   if (!processing_template_decl)\n-    for (t = input_operands; t; t = TREE_CHAIN (t))\n-      {\n-\ttree converted_operand \n-\t  = decay_conversion (TREE_VALUE (t)); \n-\n-\t/* If the type of the operand hasn't been determined (e.g.,\n-\t   because it involves an overloaded function), then issue an\n-\t   error message.  There's no context available to resolve the\n-\t   overloading.  */\n-\tif (TREE_TYPE (converted_operand) == unknown_type_node)\n-\t  {\n-\t    cp_error (\"type of asm operand `%E' could not be determined\", \n-\t\t      TREE_VALUE (t));\n-\t    converted_operand = error_mark_node;\n-\t  }\n-\tTREE_VALUE (t) = converted_operand;\n-      }\n+    {\n+      int i;\n+      int ninputs;\n+      int noutputs;\n+\n+      for (t = input_operands; t; t = TREE_CHAIN (t))\n+\t{\n+\t  tree converted_operand \n+\t    = decay_conversion (TREE_VALUE (t)); \n+\t  \n+\t  /* If the type of the operand hasn't been determined (e.g.,\n+\t     because it involves an overloaded function), then issue\n+\t     an error message.  There's no context available to\n+\t     resolve the overloading.  */\n+\t  if (TREE_TYPE (converted_operand) == unknown_type_node)\n+\t    {\n+\t      cp_error (\"type of asm operand `%E' could not be determined\", \n+\t\t\tTREE_VALUE (t));\n+\t      converted_operand = error_mark_node;\n+\t    }\n+\t  TREE_VALUE (t) = converted_operand;\n+\t}\n+\n+      ninputs = list_length (input_operands);\n+      noutputs = list_length (output_operands);\n+\n+      for (i = 0, t = output_operands; t; t = TREE_CHAIN (t), ++i)\n+\t{\n+\t  bool allows_mem;\n+\t  bool allows_reg;\n+\t  bool is_inout;\n+\t  const char *constraint;\n+\t  tree operand;\n+\n+\t  constraint = TREE_STRING_POINTER (TREE_PURPOSE (t));\n+\t  operand = TREE_VALUE (output_operands);\n+\n+\t  if (!parse_output_constraint (&constraint,\n+\t\t\t\t\ti, ninputs, noutputs,\n+\t\t\t\t\t&allows_mem,\n+\t\t\t\t\t&allows_reg,\n+\t\t\t\t\t&is_inout))\n+\t    {\n+\t      /* By marking the type as erroneous, we will not try to\n+\t\t process this operand again in expand_asm_operands.  */\n+\t      TREE_TYPE (operand) = error_mark_node;\n+\t      continue;\n+\t    }\n+\n+\t  /* If the operand is a DECL that is going to end up in\n+\t     memory, assume it is addressable.  This is a bit more\n+\t     conservative than it would ideally be; the exact test is\n+\t     buried deep in expand_asm_operands and depends on the\n+\t     DECL_RTL for the OPERAND -- which we don't have at this\n+\t     point.  */\n+\t  if (!allows_reg && DECL_P (operand))\n+\t    mark_addressable (operand);\n+\t}\n+    }\n \n   r = build_stmt (ASM_STMT, cv_qualifier, string,\n \t\t  output_operands, input_operands,"}, {"sha": "425c18541a1f54f679601cf92ad6dd9908445a52", "filename": "gcc/stmt.c", "status": "modified", "additions": 172, "deletions": 119, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=40b18c0a378124dca8b0f29f798fb47de9516e15", "patch": "@@ -1292,6 +1292,164 @@ expand_asm (body)\n   last_expr_type = 0;\n }\n \n+/* Parse the output constraint pointed to by *CONSTRAINT_P.  It is the\n+   OPERAND_NUMth output operand, indexed from zero.  There are NINPUTS\n+   inputs and NOUTPUTS outputs to this extended-asm.  Upon return,\n+   *ALLOWS_MEM will be TRUE iff the constraint allows the use of a\n+   memory operand.  Similarly, *ALLOWS_REG will be TRUE iff the\n+   constraint allows the use of a register operand.  And, *IS_INOUT\n+   will be true if the operand is read-write, i.e., if it is used as\n+   an input as well as an output.  If *CONSTRAINT_P is not in\n+   canonical form, it will be made canonical.  (Note that `+' will be\n+   rpelaced with `=' as part of this process.)\n+\n+   Returns TRUE if all went well; FALSE if an error occurred.  */\n+\n+bool\n+parse_output_constraint (constraint_p, \n+\t\t\t operand_num,\n+\t\t\t ninputs,\n+\t\t\t noutputs,\n+\t\t\t allows_mem, \n+\t\t\t allows_reg, \n+\t\t\t is_inout)\n+     const char **constraint_p;\n+     int operand_num;\n+     int ninputs;\n+     int noutputs;\n+     bool *allows_mem;\n+     bool *allows_reg;\n+     bool *is_inout;\n+{\n+  const char *constraint = *constraint_p;\n+  const char *p;\n+\n+  /* Assume the constraint doesn't allow the use of either a register\n+     or memory.  */\n+  *allows_mem = false;\n+  *allows_reg = false;\n+\n+  /* Allow the `=' or `+' to not be at the beginning of the string,\n+     since it wasn't explicitly documented that way, and there is a\n+     large body of code that puts it last.  Swap the character to\n+     the front, so as not to uglify any place else.  */\n+  p = strchr (constraint, '=');\n+  if (!p)\n+    p = strchr (constraint, '+');\n+\n+  /* If the string doesn't contain an `=', issue an error\n+     message.  */\n+  if (!p)\n+    {\n+      error (\"output operand constraint lacks `='\");\n+      return false;\n+    }\n+\n+  /* If the constraint begins with `+', then the operand is both read\n+     from and written to.  */\n+  *is_inout = (*p == '+');\n+\n+  /* Make sure we can specify the matching operand.  */\n+  if (*is_inout && operand_num > 9)\n+    {\n+      error (\"output operand constraint %d contains `+'\", \n+\t     operand_num);\n+      return false;\n+    }\n+\n+  /* Canonicalize the output constraint so that it begins with `='.  */\n+  if (p != constraint || is_inout)\n+    {\n+      char *buf;\n+      size_t c_len = strlen (constraint);\n+\n+      if (p != constraint)\n+\twarning (\"output constraint `%c' for operand %d is not at the beginning\",\n+\t\t *p, operand_num);\n+\n+      /* Make a copy of the constraint.  */\n+      buf = alloca (c_len + 1);\n+      strcpy (buf, constraint);\n+      /* Swap the first character and the `=' or `+'.  */\n+      buf[p - constraint] = buf[0];\n+      /* Make sure the first character is an `='.  (Until we do this,\n+\t it might be a `+'.)  */\n+      buf[0] = '=';\n+      /* Replace the constraint with the canonicalized string.  */\n+      *constraint_p = ggc_alloc_string (buf, c_len);\n+      constraint = *constraint_p;\n+    }\n+\n+  /* Loop through the constraint string.  */\n+  for (p = constraint + 1; *p; ++p)\n+    switch (*p)\n+      {\n+      case '+':\n+      case '=':\n+\terror (\"operand constraint contains '+' or '=' at illegal position.\");\n+\treturn false;\n+\t\n+      case '%':\n+\tif (operand_num + 1 == ninputs + noutputs)\n+\t  {\n+\t    error (\"`%%' constraint used with last operand\");\n+\t    return false;\n+\t  }\n+\tbreak;\n+\n+      case 'V':  case 'm':  case 'o':\n+\t*allows_mem = true;\n+\tbreak;\n+\n+      case '?':  case '!':  case '*':  case '&':  case '#':\n+      case 'E':  case 'F':  case 'G':  case 'H':\n+      case 's':  case 'i':  case 'n':\n+      case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n+      case 'N':  case 'O':  case 'P':  case ',':\n+\tbreak;\n+\n+      case '0':  case '1':  case '2':  case '3':  case '4':\n+      case '5':  case '6':  case '7':  case '8':  case '9':\n+\terror (\"matching constraint not valid in output operand\");\n+\treturn false;\n+\n+      case '<':  case '>':\n+\t/* ??? Before flow, auto inc/dec insns are not supposed to exist,\n+\t   excepting those that expand_call created.  So match memory\n+\t   and hope.  */\n+\t*allows_mem = true;\n+\tbreak;\n+\n+      case 'g':  case 'X':\n+\t*allows_reg = true;\n+\t*allows_mem = true;\n+\tbreak;\n+\t\n+      case 'p': case 'r':\n+\t*allows_reg = true;\n+\tbreak;\n+\n+      default:\n+\tif (!ISALPHA (*p))\n+\t  break;\n+\tif (REG_CLASS_FROM_LETTER (*p) != NO_REGS)\n+\t  *allows_reg = true;\n+#ifdef EXTRA_CONSTRAINT\n+\telse\n+\t  {\n+\t    /* Otherwise we can't assume anything about the nature of\n+\t       the constraint except that it isn't purely registers.\n+\t       Treat it like \"g\" and hope for the best.  */\n+\t    *allows_reg = true;\n+\t    *allows_mem = true;\n+\t  }\n+#endif\n+\tbreak;\n+      }\n+\n+  return true;\n+}\n+\n /* Generate RTL for an asm statement with arguments.\n    STRING is the instruction template.\n    OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n@@ -1411,15 +1569,12 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       tree val = TREE_VALUE (tail);\n       tree type = TREE_TYPE (val);\n       const char *constraint;\n-      char *p;\n-      int c_len;\n-      int j;\n-      int is_inout = 0;\n-      int allows_reg = 0;\n-      int allows_mem = 0;\n+      bool is_inout;\n+      bool allows_reg;\n+      bool allows_mem;\n \n       /* If there's an erroneous arg, emit no insn.  */\n-      if (TREE_TYPE (val) == error_mark_node)\n+      if (type == error_mark_node)\n \treturn;\n \n       /* Make sure constraint has `=' and does not have `+'.  Also, see\n@@ -1429,119 +1584,17 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n       constraint = TREE_STRING_POINTER (TREE_PURPOSE (tail));\n       output_constraints[i] = constraint;\n-      c_len = strlen (constraint);\n-\n-      /* Allow the `=' or `+' to not be at the beginning of the string,\n-\t since it wasn't explicitly documented that way, and there is a\n-\t large body of code that puts it last.  Swap the character to\n-\t the front, so as not to uglify any place else.  */\n-      switch (c_len)\n-\t{\n-\tdefault:\n-\t  if ((p = strchr (constraint, '=')) != NULL)\n-\t    break;\n-\t  if ((p = strchr (constraint, '+')) != NULL)\n-\t    break;\n-\tcase 0:\n-\t  error (\"output operand constraint lacks `='\");\n-\t  return;\n-\t}\n-      j = p - constraint;\n-      is_inout = *p == '+';\n-\n-      if (j || is_inout)\n-\t{\n-\t  /* Have to throw away this constraint string and get a new one.  */\n-\t  char *buf = alloca (c_len + 1);\n-\t  buf[0] = '=';\n-\t  if (j)\n-\t    memcpy (buf + 1, constraint, j);\n-\t  memcpy (buf + 1 + j, p + 1, c_len - j);  /* not -j-1 - copy null */\n-\t  constraint = ggc_alloc_string (buf, c_len);\n-\t  output_constraints[i] = constraint;\n-\n-\t  if (j)\n-\t    warning (\n-\t\t\"output constraint `%c' for operand %d is not at the beginning\",\n-\t\t*p, i);\n-\t}\n-\n-      /* Make sure we can specify the matching operand.  */\n-      if (is_inout && i > 9)\n-\t{\n-\t  error (\"output operand constraint %d contains `+'\", i);\n-\t  return;\n-\t}\n-\n-      for (j = 1; j < c_len; j++)\n-\tswitch (constraint[j])\n-\t  {\n-\t  case '+':\n-\t  case '=':\n-\t    error (\"operand constraint contains '+' or '=' at illegal position.\");\n-\t    return;\n \n-\t  case '%':\n-\t    if (i + 1 == ninputs + noutputs)\n-\t      {\n-\t\terror (\"`%%' constraint used with last operand\");\n-\t\treturn;\n-\t      }\n-\t    break;\n-\n-\t  case '?':  case '!':  case '*':  case '&':  case '#':\n-\t  case 'E':  case 'F':  case 'G':  case 'H':\n-\t  case 's':  case 'i':  case 'n':\n-\t  case 'I':  case 'J':  case 'K':  case 'L':  case 'M':\n-\t  case 'N':  case 'O':  case 'P':  case ',':\n-\t    break;\n-\n-\t  case '0':  case '1':  case '2':  case '3':  case '4':\n-\t  case '5':  case '6':  case '7':  case '8':  case '9':\n-\t    error (\"matching constraint not valid in output operand\");\n-\t    break;\n-\n-\t  case 'V':  case 'm':  case 'o':\n-\t    allows_mem = 1;\n-\t    break;\n-\n-\t  case '<':  case '>':\n-          /* ??? Before flow, auto inc/dec insns are not supposed to exist,\n-             excepting those that expand_call created.  So match memory\n-\t     and hope.  */\n-\t    allows_mem = 1;\n-\t    break;\n-\n-\t  case 'g':  case 'X':\n-\t    allows_reg = 1;\n-\t    allows_mem = 1;\n-\t    break;\n-\n-\t  case 'p': case 'r':\n-\t    allows_reg = 1;\n-\t    break;\n-\n-\t  default:\n-\t    if (! ISALPHA (constraint[j]))\n-\t      {\n-\t\terror (\"invalid punctuation `%c' in constraint\",\n-\t\t       constraint[j]);\n-\t\treturn;\n-\t      }\n-\t    if (REG_CLASS_FROM_LETTER (constraint[j]) != NO_REGS)\n-\t      allows_reg = 1;\n-#ifdef EXTRA_CONSTRAINT\n-\t    else\n-\t      {\n-\t\t/* Otherwise we can't assume anything about the nature of\n-\t\t   the constraint except that it isn't purely registers.\n-\t\t   Treat it like \"g\" and hope for the best.  */\n-\t\tallows_reg = 1;\n-\t\tallows_mem = 1;\n-\t      }\n-#endif\n-\t    break;\n-\t  }\n+      /* Try to parse the output constraint.  If that fails, there's\n+\t no point in going further.  */\n+      if (!parse_output_constraint (&output_constraints[i],\n+\t\t\t\t    i,\n+\t\t\t\t    ninputs,\n+\t\t\t\t    noutputs,\n+\t\t\t\t    &allows_mem,\n+\t\t\t\t    &allows_reg,\n+\t\t\t\t    &is_inout))\n+\treturn;\n \n       /* If an output operand is not a decl or indirect ref and our constraint\n \t allows a register, make a temporary to act as an intermediate."}, {"sha": "d37de69329a34c3babc92d5f92cfcf4a6c0656b0", "filename": "gcc/testsuite/g++.old-deja/g++.other/asm3.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fasm3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fasm3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fasm3.C?ref=40b18c0a378124dca8b0f29f798fb47de9516e15", "patch": "@@ -0,0 +1,11 @@\n+// Build don't link:\n+// Skip if not target: i?86-*-*\n+// Special g++ Options: -O2\n+\n+typedef unsigned long long uint64;\n+uint64 fstps(void)\n+{\n+  uint64 ret;\n+  asm volatile(\"fstps %0\" : \"=m\" (ret));\n+  return ret;\n+}"}, {"sha": "edb344f6991e6027176f0f7059e743c6f4a9dce9", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40b18c0a378124dca8b0f29f798fb47de9516e15/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=40b18c0a378124dca8b0f29f798fb47de9516e15", "patch": "@@ -2851,6 +2851,9 @@ extern int div_and_round_double\t\tPARAMS ((enum tree_code, int,\n /* In stmt.c */\n extern void emit_nop\t\t\tPARAMS ((void));\n extern void expand_computed_goto\tPARAMS ((tree));\n+extern bool parse_output_constraint     PARAMS ((const char **,\n+\t\t\t\t\t\t int, int, int,\n+\t\t\t\t\t\t bool *, bool *, bool *));\n extern void expand_asm_operands\t\tPARAMS ((tree, tree, tree, tree, int,\n \t\t\t\t\t\t const char *, int));\n extern int any_pending_cleanups\t\tPARAMS ((int));"}]}