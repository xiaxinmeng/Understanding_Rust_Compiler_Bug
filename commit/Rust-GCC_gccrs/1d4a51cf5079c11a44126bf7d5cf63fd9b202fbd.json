{"sha": "1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ0YTUxY2Y1MDc5YzExYTQ0MTI2YmY3ZDVjZjYzZmQ5YjIwMmZiZA==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2018-07-31T08:42:21Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2018-07-31T08:42:21Z"}, "message": "Reverting 'AsyncI/O patch committed' as it is breaking bare-metal builds.\n\n2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tRevert 'AsyncI/O patch committed'\n\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* gfortran.texi: Add description of asynchronous I/O.\n\t* trans-decl.c (gfc_finish_var_decl): Treat asynchronous variables\n\tas volatile.\n\t* trans-io.c (gfc_build_io_library_fndecls): Rename st_wait to\n\tst_wait_async and change argument spec from \".X\" to \".w\".\n\t(gfc_trans_wait): Pass ID argument via reference.\n\n2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tRevert 'AsyncI/O patch committed'\n\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* gfortran.dg/f2003_inquire_1.f03: Add write statement.\n\t* gfortran.dg/f2003_io_1.f03: Add wait statement.\n\n2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tRevert 'AsyncI/O patch committed'\n\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* Makefile.am: Add async.c to gfor_io_src.\n\tAdd async.h to gfor_io_headers.\n\t* Makefile.in: Regenerated.\n\t* gfortran.map: Add _gfortran_st_wait_async.\n\t* io/async.c: New file.\n\t* io/async.h: New file.\n\t* io/close.c: Include async.h.\n\t(st_close): Call async_wait for an asynchronous unit.\n\t* io/file_pos.c (st_backspace): Likewise.\n\t(st_endfile): Likewise.\n\t(st_rewind): Likewise.\n\t(st_flush): Likewise.\n\t* io/inquire.c: Add handling for asynchronous PENDING\n\tand ID arguments.\n\t* io/io.h (st_parameter_dt): Add async bit.\n\t(st_parameter_wait): Correct.\n\t(gfc_unit): Add au pointer.\n\t(st_wait_async): Add prototype.\n\t(transfer_array_inner): Likewise.\n\t(st_write_done_worker): Likewise.\n\t* io/open.c: Include async.h.\n\t(new_unit): Initialize asynchronous unit.\n\t* io/transfer.c (async_opt): New struct.\n\t(wrap_scalar_transfer): New function.\n\t(transfer_integer): Call wrap_scalar_transfer to do the work.\n\t(transfer_real): Likewise.\n\t(transfer_real_write): Likewise.\n\t(transfer_character): Likewise.\n\t(transfer_character_wide): Likewise.\n\t(transfer_complex): Likewise.\n\t(transfer_array_inner): New function.\n\t(transfer_array): Call transfer_array_inner.\n\t(transfer_derived): Call wrap_scalar_transfer.\n\t(data_transfer_init): Check for asynchronous I/O.\n\tPerform a wait operation on any pending asynchronous I/O\n\tif the data transfer is synchronous. Copy PDT and enqueue\n\tthread for data transfer.\n\t(st_read_done_worker): New function.\n\t(st_read_done): Enqueue transfer or call st_read_done_worker.\n\t(st_write_done_worker): New function.\n\t(st_write_done): Enqueue transfer or call st_read_done_worker.\n\t(st_wait): Document as no-op for compatibility reasons.\n\t(st_wait_async): New function.\n\t* io/unit.c (insert_unit): Use macros LOCK, UNLOCK and TRYLOCK;\n\tadd NOTE where necessary.\n\t(get_gfc_unit): Likewise.\n\t(init_units): Likewise.\n\t(close_unit_1): Likewise. Call async_close if asynchronous.\n\t(close_unit): Use macros LOCK and UNLOCK.\n\t(finish_last_advance_record): Likewise.\n\t(newunit_alloc): Likewise.\n\t* io/unix.c (find_file): Likewise.\n\t(flush_all_units_1): Likewise.\n\t(flush_all_units): Likewise.\n\t* libgfortran.h (generate_error_common): Add prototype.\n\t* runtime/error.c: Include io.h and async.h.\n\t(generate_error_common): New function.\n\n2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\tRevert 'AsyncI/O patch committed'.\n\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n\n\tPR fortran/25829\n\t* testsuite/libgomp.fortran/async_io_1.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_2.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_3.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_4.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_5.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_6.f90: New test.\n\t* testsuite/libgomp.fortran/async_io_7.f90: New test.\n\nFrom-SVN: r263082", "tree": {"sha": "b84d7bd3f44ac09a6d9dee531a4e6509440ef56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b84d7bd3f44ac09a6d9dee531a4e6509440ef56a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58691d4a04c2c8d81298441a7621e6e6df69b21a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58691d4a04c2c8d81298441a7621e6e6df69b21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58691d4a04c2c8d81298441a7621e6e6df69b21a"}], "stats": {"total": 2022, "additions": 254, "deletions": 1768}, "files": [{"sha": "9454102afdbf78ed4c7552f054abf2df18218d3d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -1,3 +1,17 @@\n+2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tRevert 'AsyncI/O patch committed'\n+\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* gfortran.texi: Add description of asynchronous I/O.\n+\t* trans-decl.c (gfc_finish_var_decl): Treat asynchronous variables\n+\tas volatile.\n+\t* trans-io.c (gfc_build_io_library_fndecls): Rename st_wait to\n+\tst_wait_async and change argument spec from \".X\" to \".w\".\n+\t(gfc_trans_wait): Pass ID argument via reference.\n+\n 2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n \tThomas Koenig <tkoenig@gcc.gnu.org>\n "}, {"sha": "d6bb7aae49478fdd233d79e3d068e327bfe8e0d4", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -879,7 +879,8 @@ than @code{(/.../)}.  Type-specification for array constructors like\n @item Extensions to the specification and initialization expressions,\n including the support for intrinsics with real and complex arguments.\n \n-@item Support for the asynchronous input/output.\n+@item Support for the asynchronous input/output syntax; however, the\n+data transfer is currently always synchronously performed. \n \n @item\n @cindex @code{FLUSH} statement\n@@ -1182,7 +1183,6 @@ might in some way or another become visible to the programmer.\n * Files opened without an explicit ACTION= specifier::\n * File operations on symbolic links::\n * File format of unformatted sequential files::\n-* Asynchronous I/O::\n @end menu\n \n \n@@ -1486,20 +1486,6 @@ program main\n end program main\n @end smallexample\n \n-@node Asynchronous I/O\n-@section Asynchronous I/O\n-@cindex input/output, asynchronous\n-@cindex asynchronous I/O\n-\n-Asynchronous I/O is supported if the program is linked against the\n-POSIX thread library. If that is not the case, all I/O is performed\n-as synchronous.\n-\n-On some systems, such as Darwin or Solaris, the POSIX thread library\n-is always linked in, so asynchronous I/O is always performed. On other\n-sytems, such as Linux, it is necessary to specify @option{-pthread},\n-@option{-lpthread} or @option{-fopenmp} during the linking step.\n-\n @c ---------------------------------------------------------------------\n @c Extensions\n @c ---------------------------------------------------------------------"}, {"sha": "08c1ebd2d4b9734e3ec34c3a805f64c5dc90ae93", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -698,8 +698,7 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n \t      && CLASS_DATA (sym)->ts.u.derived->attr.has_dtio_procs)))\n     TREE_STATIC (decl) = 1;\n \n-  /* Treat asynchronous variables the same as volatile, for now.  */\n-  if (sym->attr.volatile_ || sym->attr.asynchronous)\n+  if (sym->attr.volatile_)\n     {\n       TREE_THIS_VOLATILE (decl) = 1;\n       TREE_SIDE_EFFECTS (decl) = 1;"}, {"sha": "2626c4651e2d78702cb156983fff54b35de5a7d2", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -438,9 +438,10 @@ gfc_build_io_library_fndecls (void)\n \tget_identifier (PREFIX(\"st_iolength\")), \".w\",\n \tvoid_type_node, 1, dt_parm_type);\n \n+  /* TODO: Change when asynchronous I/O is implemented.  */\n   parm_type = build_pointer_type (st_parameter[IOPARM_ptype_wait].type);\n   iocall[IOCALL_WAIT] = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"st_wait_async\")), \".w\",\n+\tget_identifier (PREFIX(\"st_wait\")), \".X\",\n \tvoid_type_node, 1, parm_type);\n \n   parm_type = build_pointer_type (st_parameter[IOPARM_ptype_filepos].type);\n@@ -1526,7 +1527,7 @@ gfc_trans_wait (gfc_code * code)\n     mask |= IOPARM_common_err;\n \n   if (p->id)\n-    mask |= set_parameter_ref (&block, &post_block, var, IOPARM_wait_id, p->id);\n+    mask |= set_parameter_value (&block, var, IOPARM_wait_id, p->id);\n \n   set_parameter_const (&block, var, IOPARM_common_flags, mask);\n "}, {"sha": "eb6474211c0e1961e4205d8d6183ad47428d4b39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -1,3 +1,13 @@\n+2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tRevert 'AsyncI/O patch committed'\n+\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* gfortran.dg/f2003_inquire_1.f03: Add write statement.\n+\t* gfortran.dg/f2003_io_1.f03: Add wait statement.\n+\n 2018-07-30  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/85160"}, {"sha": "e51f619c863a5358989e6f025e84d9dcaa27cd8f", "filename": "gcc/testsuite/gfortran.dg/f2003_inquire_1.f03", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_inquire_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_inquire_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_inquire_1.f03?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -7,12 +7,10 @@\n open(10, file='mydata_f2003_inquire_1', asynchronous=\"yes\", blank=\"null\", &\n & decimal=\"comma\", encoding=\"utf-8\", sign=\"plus\")\n \n-write (10,*, asynchronous=\"yes\", id=vid) 'asdf'\n-wait (10)\n-\n inquire(unit=10, round=sround, sign=ssign, size=vsize, id=vid, &\n & pending=vpending, asynchronous=sasynchronous, decimal=sdecimal, &\n & encoding=sencoding)\n+\n if (ssign.ne.\"PLUS\") STOP 1\n if (sasynchronous.ne.\"YES\") STOP 2\n if (sdecimal.ne.\"COMMA\") STOP 3"}, {"sha": "8021d7906fd1463df53a002f8ec27d7c396a8597", "filename": "gcc/testsuite/gfortran.dg/f2003_io_1.f03", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ff2003_io_1.f03?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -13,7 +13,6 @@\n write(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"comma\", id=j) a\n rewind(10)\n read(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"comma\", blank=\"zero\") b\n-wait(10)\n if (any(b.ne.23.45)) STOP 1\n \n c = 3.14\n@@ -25,7 +24,6 @@\n write(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"point\") a\n rewind(10)\n read(10,'(10f8.3)', asynchronous=\"yes\", decimal=\"point\") b\n-wait (10)\n if (any(b.ne.23.45)) STOP 3\n \n wait(unit=10, err=25, iostat=istat, iomsg=msg, end=35, id=j)"}, {"sha": "850c8a1341b1a81075bccae36fef75faf02658cd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -1,3 +1,68 @@\n+2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tRevert 'AsyncI/O patch committed'\n+\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* Makefile.am: Add async.c to gfor_io_src.\n+\tAdd async.h to gfor_io_headers.\n+\t* Makefile.in: Regenerated.\n+\t* gfortran.map: Add _gfortran_st_wait_async.\n+\t* io/async.c: New file.\n+\t* io/async.h: New file.\n+\t* io/close.c: Include async.h.\n+\t(st_close): Call async_wait for an asynchronous unit.\n+\t* io/file_pos.c (st_backspace): Likewise.\n+\t(st_endfile): Likewise.\n+\t(st_rewind): Likewise.\n+\t(st_flush): Likewise.\n+\t* io/inquire.c: Add handling for asynchronous PENDING\n+\tand ID arguments.\n+\t* io/io.h (st_parameter_dt): Add async bit.\n+\t(st_parameter_wait): Correct.\n+\t(gfc_unit): Add au pointer.\n+\t(st_wait_async): Add prototype.\n+\t(transfer_array_inner): Likewise.\n+\t(st_write_done_worker): Likewise.\n+\t* io/open.c: Include async.h.\n+\t(new_unit): Initialize asynchronous unit.\n+\t* io/transfer.c (async_opt): New struct.\n+\t(wrap_scalar_transfer): New function.\n+\t(transfer_integer): Call wrap_scalar_transfer to do the work.\n+\t(transfer_real): Likewise.\n+\t(transfer_real_write): Likewise.\n+\t(transfer_character): Likewise.\n+\t(transfer_character_wide): Likewise.\n+\t(transfer_complex): Likewise.\n+\t(transfer_array_inner): New function.\n+\t(transfer_array): Call transfer_array_inner.\n+\t(transfer_derived): Call wrap_scalar_transfer.\n+\t(data_transfer_init): Check for asynchronous I/O.\n+\tPerform a wait operation on any pending asynchronous I/O\n+\tif the data transfer is synchronous. Copy PDT and enqueue\n+\tthread for data transfer.\n+\t(st_read_done_worker): New function.\n+\t(st_read_done): Enqueue transfer or call st_read_done_worker.\n+\t(st_write_done_worker): New function.\n+\t(st_write_done): Enqueue transfer or call st_read_done_worker.\n+\t(st_wait): Document as no-op for compatibility reasons.\n+\t(st_wait_async): New function.\n+\t* io/unit.c (insert_unit): Use macros LOCK, UNLOCK and TRYLOCK;\n+\tadd NOTE where necessary.\n+\t(get_gfc_unit): Likewise.\n+\t(init_units): Likewise.\n+\t(close_unit_1): Likewise. Call async_close if asynchronous.\n+\t(close_unit): Use macros LOCK and UNLOCK.\n+\t(finish_last_advance_record): Likewise.\n+\t(newunit_alloc): Likewise.\n+\t* io/unix.c (find_file): Likewise.\n+\t(flush_all_units_1): Likewise.\n+\t(flush_all_units): Likewise.\n+\t* libgfortran.h (generate_error_common): Add prototype.\n+\t* runtime/error.c: Include io.h and async.h.\n+\t(generate_error_common): New function.\n+\n 2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n \tThomas Koenig <tkoenig@gcc.gnu.org>\n "}, {"sha": "5831631ddfbae48e52287720b9c7ccb01821ec3c", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -100,17 +100,15 @@ io/transfer128.c \\\n io/unit.c \\\n io/unix.c \\\n io/write.c \\\n-io/fbuf.c \\\n-io/async.c\n+io/fbuf.c\n \n endif\n \n gfor_io_headers= \\\n io/io.h \\\n io/fbuf.h \\\n io/format.h \\\n-io/unix.h \\\n-io/async.h\n+io/unix.h\n \n gfor_helper_src= \\\n intrinsics/associated.c \\"}, {"sha": "b66a91bfde39a1abfd931f3619f4be008ca32edc", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -70,8 +70,7 @@ target_triplet = @target@\n @LIBGFOR_MINIMAL_FALSE@io/unit.c \\\n @LIBGFOR_MINIMAL_FALSE@io/unix.c \\\n @LIBGFOR_MINIMAL_FALSE@io/write.c \\\n-@LIBGFOR_MINIMAL_FALSE@io/fbuf.c \\\n-@LIBGFOR_MINIMAL_FALSE@io/async.c\n+@LIBGFOR_MINIMAL_FALSE@io/fbuf.c\n \n @LIBGFOR_MINIMAL_FALSE@am__append_3 = \\\n @LIBGFOR_MINIMAL_FALSE@intrinsics/access.c \\\n@@ -353,7 +352,7 @@ am__objects_47 = $(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n @LIBGFOR_MINIMAL_FALSE@\tinquire.lo intrinsics.lo list_read.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tlock.lo open.lo read.lo transfer.lo \\\n @LIBGFOR_MINIMAL_FALSE@\ttransfer128.lo unit.lo unix.lo write.lo \\\n-@LIBGFOR_MINIMAL_FALSE@\tfbuf.lo async.lo\n+@LIBGFOR_MINIMAL_FALSE@\tfbuf.lo\n am__objects_49 = size_from_kind.lo $(am__objects_48)\n @LIBGFOR_MINIMAL_FALSE@am__objects_50 = access.lo c99_functions.lo \\\n @LIBGFOR_MINIMAL_FALSE@\tchdir.lo chmod.lo clock.lo cpu_time.lo \\\n@@ -651,8 +650,7 @@ gfor_io_headers = \\\n io/io.h \\\n io/fbuf.h \\\n io/format.h \\\n-io/unix.h \\\n-io/async.h\n+io/unix.h\n \n gfor_helper_src = intrinsics/associated.c intrinsics/abort.c \\\n \tintrinsics/args.c intrinsics/cshift0.c intrinsics/eoshift0.c \\\n@@ -1553,7 +1551,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/any_l8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/args.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/associated.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/async.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/backtrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bessel_r16.Plo@am__quote@\n@@ -5817,13 +5814,6 @@ fbuf.lo: io/fbuf.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o fbuf.lo `test -f 'io/fbuf.c' || echo '$(srcdir)/'`io/fbuf.c\n \n-async.lo: io/async.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT async.lo -MD -MP -MF $(DEPDIR)/async.Tpo -c -o async.lo `test -f 'io/async.c' || echo '$(srcdir)/'`io/async.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/async.Tpo $(DEPDIR)/async.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='io/async.c' object='async.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o async.lo `test -f 'io/async.c' || echo '$(srcdir)/'`io/async.c\n-\n associated.lo: intrinsics/associated.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT associated.lo -MD -MP -MF $(DEPDIR)/associated.Tpo -c -o associated.lo `test -f 'intrinsics/associated.c' || echo '$(srcdir)/'`intrinsics/associated.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/associated.Tpo $(DEPDIR)/associated.Plo"}, {"sha": "78f8d7e97069082c88e21c254cb48e357c732cf6", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -1483,8 +1483,3 @@ GFORTRAN_C99_8 {\n     y1f;\n     ynf;\n };\n-\n-GFORTRAN_9 {\n-  global:\n-  _gfortran_st_wait_async;\n-};"}, {"sha": "b32af16ccb423f6f32d7cef7fa7567d79ec12d12", "filename": "libgfortran/io/async.c", "status": "removed", "additions": 0, "deletions": 483, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgfortran%2Fio%2Fasync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgfortran%2Fio%2Fasync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.c?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,483 +0,0 @@\n-/* Copyright (C) 2018 Free Software Foundation, Inc.\n-   Contributed by Nicolas Koenig\n-\n-   This file is part of the GNU Fortran runtime library (libgfortran).\n-\n-   Libgfortran is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgfortran is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"libgfortran.h\"\n-\n-#define _GTHREAD_USE_COND_INIT_FUNC\n-#include \"../../libgcc/gthr.h\"\n-#include \"io.h\"\n-#include \"fbuf.h\"\n-#include \"format.h\"\n-#include \"unix.h\"\n-#include <string.h>\n-#include <assert.h>\n-\n-#include <sys/types.h>\n-\n-#include \"async.h\"\n-\n-DEBUG_LINE (__thread const char *aio_prefix = MPREFIX);\n-\n-DEBUG_LINE (__gthread_mutex_t debug_queue_lock = __GTHREAD_MUTEX_INIT;)\n-DEBUG_LINE (aio_lock_debug *aio_debug_head = NULL;)\n-\n-/* Current unit for asynchronous I/O.  Needed for error reporting.  */\n-\n-__thread gfc_unit *thread_unit = NULL;\n-\n-/* Queue entry for the asynchronous I/O entry.  */\n-typedef struct transfer_queue\n-{\n-  enum aio_do type;\n-  struct transfer_queue *next;\n-  struct st_parameter_dt *new_pdt;\n-  transfer_args arg;\n-  _Bool has_id;\n-  int read_flag;\n-} transfer_queue;\n-\n-struct error {\n-  st_parameter_dt *dtp;\n-  int id;\n-};\n-\n-/* Helper function to exchange the old vs. a new PDT.  */\n-\n-static void\n-update_pdt (st_parameter_dt **old, st_parameter_dt *new) {\n-  st_parameter_dt *temp;\n-  NOTE (\"Changing pdts, current_unit = %p\", (void *) (new->u.p.current_unit));\n-  temp = *old;\n-  *old = new;\n-  if (temp)\n-    free (temp);\n-}\n-\n-/* Destroy an adv_cond structure.  */\n-\n-static void\n-destroy_adv_cond (struct adv_cond *ac)\n-{\n-  T_ERROR (__gthread_mutex_destroy, &ac->lock);\n-  T_ERROR (__gthread_cond_destroy, &ac->signal);\n-}\n-\n-/* Function invoked as start routine for a new asynchronous I/O unit.\n-   Contains the main loop for accepting requests and handling them.  */\n-\n-static void *\n-async_io (void *arg)\n-{\n-  DEBUG_LINE (aio_prefix = TPREFIX);\n-  transfer_queue *ctq = NULL, *prev = NULL;\n-  gfc_unit *u = (gfc_unit *) arg;\n-  async_unit *au = u->au;\n-  LOCK (&au->lock);\n-  thread_unit = u;\n-  au->thread = __gthread_self ();\n-  while (true)\n-    {\n-      /* Main loop.  At this point, au->lock is always held. */\n-      WAIT_SIGNAL_MUTEX (&au->work, au->tail != NULL, &au->lock);\n-      LOCK (&au->lock);\n-      ctq = au->head;\n-      prev = NULL;\n-      /* Loop over the queue entries until they are finished.  */\n-      while (ctq)\n-\t{\n-\t  if (prev)\n-\t    free (prev);\n-\t  prev = ctq;\n-\t  if (!au->error.has_error)\n-\t    {\n-\t      UNLOCK (&au->lock);\n-\n-\t      switch (ctq->type)\n-\t\t{\n-\t\tcase AIO_WRITE_DONE:\n-\t\t  NOTE (\"Finalizing write\");\n-\t\t  st_write_done_worker (au->pdt);\n-\t\t  UNLOCK (&au->io_lock);\n-\t\t  break;\n-\n-\t\tcase AIO_READ_DONE:\n-\t\t  NOTE (\"Finalizing read\");\n-\t\t  st_read_done_worker (au->pdt);\n-\t\t  UNLOCK (&au->io_lock);\n-\t\t  break;\n-\n-\t\tcase AIO_DATA_TRANSFER_INIT:\n-\t\t  NOTE (\"Data transfer init\");\n-\t\t  LOCK (&au->io_lock);\n-\t\t  update_pdt (&au->pdt, ctq->new_pdt);\n-\t\t  data_transfer_init_worker (au->pdt, ctq->read_flag);\n-\t\t  break;\n-\n-\t\tcase AIO_TRANSFER_SCALAR:\n-\t\t  NOTE (\"Starting scalar transfer\");\n-\t\t  ctq->arg.scalar.transfer (au->pdt, ctq->arg.scalar.arg_bt,\n-\t\t\t\t\t    ctq->arg.scalar.data,\n-\t\t\t\t\t    ctq->arg.scalar.i,\n-\t\t\t\t\t    ctq->arg.scalar.s1,\n-\t\t\t\t\t    ctq->arg.scalar.s2);\n-\t\t  break;\n-\n-\t\tcase AIO_TRANSFER_ARRAY:\n-\t\t  NOTE (\"Starting array transfer\");\n-\t\t  NOTE (\"ctq->arg.array.desc = %p\",\n-\t\t\t(void *) (ctq->arg.array.desc));\n-\t\t  transfer_array_inner (au->pdt, ctq->arg.array.desc,\n-\t\t\t\t\tctq->arg.array.kind,\n-\t\t\t\t\tctq->arg.array.charlen);\n-\t\t  free (ctq->arg.array.desc);\n-\t\t  break;\n-\n-\t\tcase AIO_CLOSE:\n-\t\t  NOTE (\"Received AIO_CLOSE\");\n-\t\t  goto finish_thread;\n-\n-\t\tdefault:\n-\t\t  internal_error (NULL, \"Invalid queue type\");\n-\t\t  break;\n-\t\t}\n-\t      LOCK (&au->lock);\n-\t      if (unlikely (au->error.has_error))\n-\t\tau->error.last_good_id = au->id.low - 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (ctq->type == AIO_WRITE_DONE || ctq->type == AIO_READ_DONE)\n-\t\t{\n-\t\t  UNLOCK (&au->io_lock);\n-\t\t}\n-\t      else if (ctq->type == AIO_CLOSE)\n-\t\t{\n-\t\t  NOTE (\"Received AIO_CLOSE during error condition\");\n-\t\t  UNLOCK (&au->lock);\n-\t\t  goto finish_thread;\n-\t\t}\n-\t    }\n-\n-  \t  NOTE (\"Next ctq, current id: %d\", au->id.low);\n-  \t  if (ctq->has_id && au->id.waiting == au->id.low++)\n-\t    SIGNAL (&au->id.done);\n-\n-\t  ctq = ctq->next;\n-\t}\n-      au->tail = NULL;\n-      au->head = NULL;\n-      au->empty = 1;\n-      UNLOCK (&au->lock);\n-      SIGNAL (&au->emptysignal);\n-      LOCK (&au->lock);\n-    }\n- finish_thread:\n-  au->tail = NULL;\n-  au->head = NULL;\n-  au->empty = 1;\n-  SIGNAL (&au->emptysignal);\n-  free (ctq);\n-  return NULL;\n-}\n-\n-/* Free an asynchronous unit.  */\n-\n-static void\n-free_async_unit (async_unit *au)\n-{\n-  if (au->tail)\n-    internal_error (NULL, \"Trying to free nonempty asynchronous unit\");\n-\n-  destroy_adv_cond (&au->work);\n-  destroy_adv_cond (&au->emptysignal);\n-  destroy_adv_cond (&au->id.done);\n-  T_ERROR (__gthread_mutex_destroy, &au->lock);\n-  free (au);\n-}\n-\n-/* Initialize an adv_cond structure.  */\n-\n-static void\n-init_adv_cond (struct adv_cond *ac)\n-{\n-  ac->pending = 0;\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&ac->lock);\n-  __gthread_cond_init_function (&ac->signal);\n-}\n-\n-/* Initialize an asyncronous unit, returning zero on success,\n- nonzero on failure.  It also sets u->au.  */\n-\n-void\n-init_async_unit (gfc_unit *u)\n-{\n-  async_unit *au;\n-  if (!__gthread_active_p ())\n-    {\n-      u->au = NULL;\n-      return;\n-    }\n-  \n-  au = (async_unit *) xmalloc (sizeof (async_unit));\n-  u->au = au;\n-  init_adv_cond (&au->work);\n-  init_adv_cond (&au->emptysignal);\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&au->lock);\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&au->io_lock);\n-  LOCK (&au->lock);\n-  T_ERROR (__gthread_create, &au->thread, &async_io, (void *) u);\n-  au->pdt = NULL;\n-  au->head = NULL;\n-  au->tail = NULL;\n-  au->empty = true;\n-  au->id.waiting = -1;\n-  au->id.low = 0;\n-  au->id.high = 0;\n-  au->error.fatal_error = 0;\n-  au->error.has_error = 0;\n-  au->error.last_good_id = 0;\n-  init_adv_cond (&au->id.done);\n-  UNLOCK (&au->lock);\n-}\n-\n-/* Enqueue a transfer statement.  */\n-\n-void\n-enqueue_transfer (async_unit *au, transfer_args *arg, enum aio_do type)\n-{\n-  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n-  tq->arg = *arg;\n-  tq->type = type;\n-  tq->has_id = 0;\n-  LOCK (&au->lock);\n-  if (!au->tail)\n-    au->head = tq;\n-  else\n-    au->tail->next = tq;\n-  au->tail = tq;\n-  REVOKE_SIGNAL (&(au->emptysignal));\n-  au->empty = false;\n-  UNLOCK (&au->lock);\n-  SIGNAL (&au->work);\n-}\n-\n-/* Enqueue an st_write_done or st_read_done which contains an ID.  */\n-\n-int\n-enqueue_done_id (async_unit *au, enum aio_do type)\n-{\n-  int ret;\n-  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n-\n-  tq->type = type;\n-  tq->has_id = 1;\n-  LOCK (&au->lock);\n-  if (!au->tail)\n-    au->head = tq;\n-  else\n-    au->tail->next = tq;\n-  au->tail = tq;\n-  REVOKE_SIGNAL (&(au->emptysignal));\n-  au->empty = false;\n-  ret = au->id.high++;\n-  NOTE (\"Enqueue id: %d\", ret);\n-  UNLOCK (&au->lock);\n-  SIGNAL (&au->work);\n-  return ret;\n-}\n-\n-/* Enqueue an st_write_done or st_read_done without an ID.  */\n-\n-void\n-enqueue_done (async_unit *au, enum aio_do type)\n-{\n-  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n-  tq->type = type;\n-  tq->has_id = 0;\n-  LOCK (&au->lock);\n-  if (!au->tail)\n-    au->head = tq;\n-  else\n-    au->tail->next = tq;\n-  au->tail = tq;\n-  REVOKE_SIGNAL (&(au->emptysignal));\n-  au->empty = false;\n-  UNLOCK (&au->lock);\n-  SIGNAL (&au->work);\n-}\n-\n-/* Enqueue a CLOSE statement.  */\n-\n-void\n-enqueue_close (async_unit *au)\n-{\n-  transfer_queue *tq = calloc (sizeof (transfer_queue), 1);\n-\n-  tq->type = AIO_CLOSE;\n-  LOCK (&au->lock);\n-  if (!au->tail)\n-    au->head = tq;\n-  else\n-    au->tail->next = tq;\n-  au->tail = tq;\n-  REVOKE_SIGNAL (&(au->emptysignal));\n-  au->empty = false;\n-  UNLOCK (&au->lock);\n-  SIGNAL (&au->work);\n-}\n-\n-/* The asynchronous unit keeps the currently active PDT around.\n-   This function changes that to the current one.  */\n-\n-void\n-enqueue_data_transfer_init (async_unit *au, st_parameter_dt *dt, int read_flag)\n-{\n-  st_parameter_dt *new = xmalloc (sizeof (st_parameter_dt));\n-  transfer_queue *tq = xmalloc (sizeof (transfer_queue));\n-\n-  memcpy ((void *) new, (void *) dt, sizeof (st_parameter_dt));\n-\n-  NOTE (\"dt->internal_unit_desc = %p\", dt->internal_unit_desc);\n-  NOTE (\"common.flags & mask = %d\", dt->common.flags & IOPARM_LIBRETURN_MASK);\n-  tq->next = NULL;\n-  tq->type = AIO_DATA_TRANSFER_INIT;\n-  tq->read_flag = read_flag;\n-  tq->has_id = 0;\n-  tq->new_pdt = new;\n-  LOCK (&au->lock);\n-\n-  if (!au->tail)\n-    au->head = tq;\n-  else\n-    au->tail->next = tq;\n-  au->tail = tq;\n-  REVOKE_SIGNAL (&(au->emptysignal));\n-  au->empty = 0;\n-  UNLOCK (&au->lock);\n-  SIGNAL (&au->work);\n-}\n-\n-/* Collect the errors that may have happened asynchronously.  Return true if\n-   an error has been encountered.  */\n-\n-bool\n-collect_async_errors (st_parameter_common *cmp, async_unit *au)\n-{\n-  bool has_error = au->error.has_error;\n-\n-  if (has_error)\n-    {\n-      if (generate_error_common (cmp, au->error.family, au->error.message))\n-\t{\n-\t  au->error.has_error = 0;\n-\t  au->error.cmp = NULL;\n-\t}\n-      else\n-\t{\n-\t  /* The program will exit later.  */\n-\t  au->error.fatal_error = true;\n-\t}\n-    }\n-  return has_error;\n-}\n-\n-/* Perform a wait operation on an asynchronous unit with an ID specified,\n-   which means collecting the errors that may have happened asynchronously.\n-   Return true if an error has been encountered.  */\n-\n-bool\n-async_wait_id (st_parameter_common *cmp, async_unit *au, int i)\n-{\n-  bool ret;\n-\n-  if (au == NULL)\n-    return false;\n-\n-  if (cmp == NULL)\n-    cmp = au->error.cmp;\n-\n-  if (au->error.has_error)\n-    {\n-      if (i <= au->error.last_good_id)\n-\treturn false;\n-\n-      return collect_async_errors (cmp, au);\n-    }\n-\n-  LOCK (&au->lock);\n-  NOTE (\"Waiting for id %d\", i);\n-  if (au->id.waiting < i)\n-    au->id.waiting = i;\n-  UNLOCK (&au->lock);\n-  SIGNAL (&(au->work));\n-  LOCK (&au->lock);\n-  WAIT_SIGNAL_MUTEX (&(au->id.done),\n-\t\t     (au->id.low >= au->id.waiting || au->empty), &au->lock);\n-  LOCK (&au->lock);\n-  ret = collect_async_errors (cmp, au);\n-  UNLOCK (&au->lock);\n-  return ret;\n-}\n-\n-/* Perform a wait operation an an asynchronous unit without an ID.  */\n-\n-bool\n-async_wait (st_parameter_common *cmp, async_unit *au)\n-{\n-  bool ret;\n-\n-  if (au == NULL)\n-    return false;\n-\n-  if (cmp == NULL)\n-    cmp = au->error.cmp;\n-\n-  SIGNAL (&(au->work));\n-  LOCK (&(au->lock));\n-\n-  if (au->empty)\n-    {\n-      ret = collect_async_errors (cmp, au);\n-      UNLOCK (&au->lock);\n-      return ret;\n-    }\n-\n-  WAIT_SIGNAL_MUTEX (&(au->emptysignal), (au->empty), &au->lock);\n-  ret = collect_async_errors (cmp, au);\n-  return ret;\n-}\n-\n-/* Close an asynchronous unit.  */\n-\n-void\n-async_close (async_unit *au)\n-{\n-  if (au == NULL)\n-    return;\n-\n-  NOTE (\"Closing async unit\");\n-  enqueue_close (au);\n-  T_ERROR (__gthread_join, au->thread, NULL);\n-  free_async_unit (au);\n-}"}, {"sha": "3581ae65931104574de31aa3051436d64b818cb3", "filename": "libgfortran/io/async.h", "status": "removed", "additions": 0, "deletions": 378, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgfortran%2Fio%2Fasync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgfortran%2Fio%2Fasync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fasync.h?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,378 +0,0 @@\n-/* Copyright (C) 2018 Free Software Foundation, Inc.\n-   Contributed by Nicolas Koenig\n-\n-   This file is part of the GNU Fortran runtime library (libgfortran).\n-\n-   Libgfortran is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   Libgfortran is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   Under Section 7 of GPL version 3, you are granted additional\n-   permissions described in the GCC Runtime Library Exception, version\n-   3.1, as published by the Free Software Foundation.\n-\n-   You should have received a copy of the GNU General Public License and\n-   a copy of the GCC Runtime Library Exception along with this program;\n-   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef ASYNC_H\n-#define ASYNC_H\n-\n-/* Defining DEBUG_ASYNC will enable somewhat verbose debugging\n-   output for async I/O.  */\n-\n-#define DEBUG_ASYNC\n-#undef DEBUG_ASYNC\n-\n-#ifdef DEBUG_ASYNC\n-\n-/* Define this if you want to use ANSI color escape sequences in your\n-   debugging output.  */\n-\n-#define DEBUG_COLOR\n-\n-#ifdef DEBUG_COLOR\n-#define MPREFIX \"\\033[30;46mM:\\033[0m \"\n-#define TPREFIX \"\\033[37;44mT:\\033[0m \"\n-#define RPREFIX \"\\033[37;41mR:\\033[0m \"\n-#define DEBUG_RED \"\\033[31m\"\n-#define DEBUG_ORANGE \"\\033[33m\"\n-#define DEBUG_GREEN \"\\033[32m\"\n-#define DEBUG_DARKRED \"\\033[31;2m\"\n-#define DEBUG_PURPLE \"\\033[35m\"\n-#define DEBUG_NORM \"\\033[0m\"\n-#define DEBUG_REVERSE_RED \"\\033[41;37m\"\n-#define DEBUG_BLUE \"\\033[34m\"\n-\n-#else\n-\n-#define MPREFIX \"M: \"\n-#define TPREFIX \"T: \"\n-#define RPREFIX \"\"\n-#define DEBUG_RED \"\"\n-#define DEBUG_ORANGE \"\"\n-#define DEBUG_GREEN \"\"\n-#define DEBUG_DARKRED \"\"\n-#define DEBUG_PURPLE \"\"\n-#define DEBUG_NORM \"\"\n-#define DEBUG_REVERSE_RED \"\"\n-#define DEBUG_BLUE \"\"\n-\n-#endif\n-\n-#define DEBUG_PRINTF(...) fprintf (stderr,__VA_ARGS__)\n-\n-#define IN_DEBUG_QUEUE(mutex) ({\t\t\\\n-      __label__ end;\t\t\t\t\\\n-      aio_lock_debug *curr = aio_debug_head;\t\\\n-      while (curr) {\t\t\t\t\\\n-\tif (curr->m == mutex) {\t\t\t\\\n-\t  goto end;\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-\tcurr = curr->next;\t\t\t\\\n-      }\t\t\t\t\t\t\\\n-    end:;\t\t\t\t\t\\\n-      curr;\t\t\t\t\t\\\n-    })\n-\n-#define TAIL_DEBUG_QUEUE ({\t\t\t\\\n-      aio_lock_debug *curr = aio_debug_head;\t\\\n-      while (curr && curr->next) {\t\t\\\n-\tcurr = curr->next;\t\t\t\\\n-      }\t\t\t\t\t\t\\\n-      curr;\t\t\t\t\t\\\n-    })\n-\n-#define CHECK_LOCK(mutex, status) do {\t\t\t\t\t\\\n-    aio_lock_debug *curr;\t\t\t\t\t\t\\\n-    INTERN_LOCK (&debug_queue_lock);\t\t\t\t\t\\\n-    if (__gthread_mutex_trylock (mutex)) {\t\t\t\t\\\n-      if ((curr = IN_DEBUG_QUEUE (mutex))) {\t\t\t\t\\\n-\tsprintf (status, DEBUG_RED \"%s():%d\" DEBUG_NORM, curr->func, curr->line); \\\n-      } else\t\t\t\t\t\t\t\t\\\n-\tsprintf (status, DEBUG_RED \"unknown\" DEBUG_NORM);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    else {\t\t\t\t\t\t\t\t\\\n-      __gthread_mutex_unlock (mutex);\t\t\t\t\t\\\n-      sprintf (status, DEBUG_GREEN \"unlocked\" DEBUG_NORM);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    INTERN_UNLOCK (&debug_queue_lock);\t\t\t\t\t\\\n-  }while (0)\n-\n-#define T_ERROR(func, ...) do {\t\t\t\t\\\n-    int t_error_temp;\t\t\t\t\t\\\n-    t_error_temp = func(__VA_ARGS__);\t\t\t\\\n-    if (t_error_temp)\t\t\t\t\t\\\n-      ERROR (t_error_temp, \"args: \" #__VA_ARGS__ \"\\n\");\t\\\n-  } while (0)\n-\n-#define NOTE(str, ...) do{\t\t\t\t\t\t\\\n-    char note_str[200];\t\t\t\t\t\t\t\\\n-    sprintf (note_str, \"%s\" DEBUG_PURPLE \"NOTE: \" DEBUG_NORM str, aio_prefix, ##__VA_ARGS__); \\\n-    DEBUG_PRINTF (\"%-90s %20s():%-5d\\n\", note_str, __FUNCTION__, __LINE__); \\\n-  }while (0);\n-\n-#define ERROR(errnum, str, ...) do{\t\t\t\t\t\\\n-    char note_str[200];\t\t\t\t\t\t\t\\\n-    sprintf (note_str, \"%s\" DEBUG_REVERSE_RED \"ERROR:\" DEBUG_NORM \" [%d] \" str, aio_prefix, \\\n-\t    errnum, ##__VA_ARGS__);\t\t\t\t\t\\\n-    DEBUG_PRINTF (\"%-68s %s():%-5d\\n\", note_str, __FUNCTION__, __LINE__);\t\\\n-  }while (0)\n-\n-#define MUTEX_DEBUG_ADD(mutex) do {\t\t\\\n-    aio_lock_debug *n;\t\t\t\t\\\n-    n = malloc (sizeof(aio_lock_debug));\t\\\n-    n->prev = TAIL_DEBUG_QUEUE;\t\t\t\\\n-    if (n->prev)\t\t\t\t\\\n-      n->prev->next = n;\t\t\t\\\n-    n->next = NULL;\t\t\t\t\\\n-    n->line = __LINE__;\t\t\t\t\\\n-    n->func = __FUNCTION__;\t\t\t\\\n-    n->m = mutex;\t\t\t\t\\\n-    if (!aio_debug_head) {\t\t\t\\\n-      aio_debug_head = n;\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  } while (0)\n-\n-#define UNLOCK(mutex) do {\t\t\t\t\t\t\\\n-    aio_lock_debug *curr;\t\t\t\t\t\t\\\n-    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_GREEN \"UNLOCK: \" DEBUG_NORM #mutex, \\\n-\t\t __FUNCTION__, __LINE__, (void *) mutex);\t\t\\\n-    INTERN_LOCK (&debug_queue_lock);\t\t\t\t\t\\\n-    curr = IN_DEBUG_QUEUE (mutex);\t\t\t\t\t\\\n-    if (curr)\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (curr->prev)\t\t\t\t\t\t\t\\\n-\t  curr->prev->next = curr->next;\t\t\t\t\\\n-\tif (curr->next) {\t\t\t\t\t\t\\\n-\t  curr->next->prev = curr->prev;\t\t\t\t\\\n-\t  if (curr == aio_debug_head)\t\t\t\t\t\\\n-\t    aio_debug_head = curr->next;\t\t\t\t\\\n-\t} else {\t\t\t\t\t\t\t\\\n-\t  if (curr == aio_debug_head)\t\t\t\t\t\\\n-\t    aio_debug_head = NULL;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\tfree (curr);\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    INTERN_UNLOCK (&debug_queue_lock);\t\t\t\t\t\\\n-    INTERN_UNLOCK (mutex);\t\t\t\t\t\t\\\n-  }while (0)\n-\n-#define TRYLOCK(mutex) ({\t\t\t\t\t\t\\\n-\t\t\t char status[200];\t\t\t\t\\\n-\t\t\t int res;\t\t\t\t\t\\\n-\t\t\t aio_lock_debug *curr;\t\t\t\t\\\n-\t\t\t res = __gthread_mutex_trylock (mutex);\t\t\\\n-\t\t\t INTERN_LOCK (&debug_queue_lock);\t\t\\\n-\t\t\t if (res) {\t\t\t\t\t\\\n-\t\t\t   if ((curr = IN_DEBUG_QUEUE (mutex))) {\t\\\n-\t\t\t     sprintf (status, DEBUG_RED \"%s():%d\" DEBUG_NORM, curr->func, curr->line);\t\\\n-\t\t\t   } else\t\t\t\t\t\\\n-\t\t\t     sprintf (status, DEBUG_RED \"unknown\" DEBUG_NORM);\t\\\n-\t\t\t }\t\t\t\t\t\t\\\n-\t\t\t else {\t\t\t\t\t\t\\\n-\t\t\t   sprintf (status, DEBUG_GREEN \"unlocked\" DEBUG_NORM);\t\\\n-\t\t\t   MUTEX_DEBUG_ADD (mutex);\t\t\t\\\n-\t\t\t }\t\t\t\t\t\t\\\n-\t\t\t DEBUG_PRINTF (\"%s%-44s prev: %-35s %20s():%-5d %18p\\n\", aio_prefix, \\\n-\t\t\t\t      DEBUG_DARKRED \"TRYLOCK: \" DEBUG_NORM #mutex, status, __FUNCTION__, __LINE__, \\\n-\t\t\t\t      (void *) mutex);\t\t\t\\\n-\t\t\t INTERN_UNLOCK (&debug_queue_lock);\t\t\\\n-\t\t\t res;\t\t\t\t\t\t\\\n-    })\n-\n-#define LOCK(mutex) do {\t\t\t\t\t\t\\\n-    char status[200];\t\t\t\t\t\t\t\\\n-    CHECK_LOCK (mutex, status);\t\t\t\t\t\t\\\n-    DEBUG_PRINTF (\"%s%-42s prev: %-35s %20s():%-5d %18p\\n\", aio_prefix,\t\\\n-\t\t DEBUG_RED \"LOCK: \" DEBUG_NORM #mutex, status, __FUNCTION__, __LINE__, (void *) mutex); \\\n-    INTERN_LOCK (mutex);\t\t\t\t\t\t\t\\\n-    INTERN_LOCK (&debug_queue_lock);\t\t\t\t\t\\\n-    MUTEX_DEBUG_ADD (mutex);\t\t\t\t\t\t\\\n-    INTERN_UNLOCK (&debug_queue_lock);\t\t\t\t\t\\\n-    DEBUG_PRINTF (\"%s\" DEBUG_RED \"ACQ:\" DEBUG_NORM \" %-30s %78p\\n\", aio_prefix, #mutex, mutex); \\\n-  } while (0)\n-\n-#define DEBUG_LINE(...) __VA_ARGS__\n-\n-#else\n-#define DEBUG_PRINTF(...) {}\n-#define CHECK_LOCK(au, mutex, status) {}\n-#define NOTE(str, ...) {}\n-#define DEBUG_LINE(...)\n-#define T_ERROR(func, ...) func(__VA_ARGS__)\n-#define LOCK(mutex) INTERN_LOCK (mutex)\n-#define UNLOCK(mutex) INTERN_UNLOCK (mutex)\n-#define TRYLOCK(mutex) (__gthread_mutex_trylock (mutex))\n-#endif\n-\n-#define INTERN_LOCK(mutex) T_ERROR (__gthread_mutex_lock, mutex);\n-\n-#define INTERN_UNLOCK(mutex) T_ERROR (__gthread_mutex_unlock, mutex);\n-\n-#define SIGNAL(advcond) do{\t\t\t\t\t\t\\\n-    INTERN_LOCK (&(advcond)->lock);\t\t\t\t\t\\\n-    (advcond)->pending = 1;\t\t\t\t\t\t\\\n-    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \"SIGNAL: \" DEBUG_NORM \\\n-\t\t #advcond, __FUNCTION__, __LINE__, (void *) advcond);\t\\\n-    T_ERROR (__gthread_cond_broadcast, &(advcond)->signal);\t\t\\\n-    INTERN_UNLOCK (&(advcond)->lock);\t\t\t\t\t\\\n-  } while (0)\n-\n-#define WAIT_SIGNAL_MUTEX(advcond, condition, mutex) do{\t\t\\\n-    __label__ finish;\t\t       \t\t\t\t\t\\\n-    INTERN_LOCK (&((advcond)->lock));\t\t\t\t\t\\\n-    DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_BLUE \"WAITING: \" DEBUG_NORM \\\n-\t\t #advcond, __FUNCTION__, __LINE__, (void *) advcond);\t\\\n-    if ((advcond)->pending || (condition)){\t\t\t\t\\\n-      UNLOCK (mutex);\t\t\t\t\t\t\t\\\n-      goto finish;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-    UNLOCK (mutex);\t\t\t\t\t\t\t\\\n-     while (!__gthread_cond_wait(&(advcond)->signal, &(advcond)->lock)) {\t\\\n-       { int cond;\t\t\t\t\t\t\t\\\n-\t LOCK (mutex); cond = condition; UNLOCK (mutex);\t\\\n-\t   if (cond){\t\t\t\t\t\t\t\\\n-\t     DEBUG_PRINTF (\"%s%-75s %20s():%-5d %18p\\n\", aio_prefix, DEBUG_ORANGE \"REC: \" DEBUG_NORM \\\n-\t\t  #advcond,  __FUNCTION__, __LINE__, (void *)advcond);\t\\\n-\t   break;\t\t\t\t      \t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  finish:\t\t\t\t\t\t\t\t\\\n-\t\t (advcond)->pending = 0;\t\t\t\t\\\n-\t\t INTERN_UNLOCK (&((advcond)->lock));\t\t\t\\\n-\t\t } while (0)\n-\n-#define REVOKE_SIGNAL(advcond) do{\t\t\\\n-    INTERN_LOCK (&(advcond)->lock);\t\t\\\n-    (advcond)->pending = 0;\t\t\t\\\n-    INTERN_UNLOCK (&(advcond)->lock);\t\t\\\n-  } while (0)\n-\n-DEBUG_LINE (extern __thread const char *aio_prefix);\n-\n-DEBUG_LINE (typedef struct aio_lock_debug{\n-  __gthread_mutex_t *m;\n-  int line;\n-  const char *func;\n-  struct aio_lock_debug *next;\n-  struct aio_lock_debug *prev;\n-} aio_lock_debug;)\n-\n-DEBUG_LINE (extern aio_lock_debug *aio_debug_head;)\n-DEBUG_LINE (extern __gthread_mutex_t debug_queue_lock;)\n-\n-/* Thread - local storage of the current unit we are looking at. Needed for\n-   error reporting.  */\n-\n-extern __thread gfc_unit *thread_unit;\n-\n-enum aio_do {\n-  AIO_INVALID = 0,\n-  AIO_DATA_TRANSFER_INIT,\n-  AIO_TRANSFER_SCALAR,\n-  AIO_TRANSFER_ARRAY,\n-  AIO_WRITE_DONE,\n-  AIO_READ_DONE,\n-  AIO_CLOSE\n-};\n-\n-typedef union transfer_args\n-{\n-  struct\n-  {\n-    void (*transfer) (struct st_parameter_dt *, bt, void *, int, size_t, size_t);\n-    bt arg_bt;\n-    void *data;\n-    int i;\n-    size_t s1;\n-    size_t s2;\n-  } scalar;\n-  struct\n-  {\n-    gfc_array_char *desc;\n-    int kind;\n-    gfc_charlen_type charlen;\n-  } array;\n-} transfer_args;\n-\n-struct adv_cond\n-{\n-  int pending;\n-  __gthread_mutex_t lock;\n-  __gthread_cond_t signal;\n-};\n-\n-typedef struct async_unit\n-{\n-  pthread_mutex_t lock;      /* Lock for manipulating the queue structure.  */\n-  pthread_mutex_t io_lock;   /* Lock for doing actual I/O. */\n-  struct adv_cond work;\n-  struct adv_cond emptysignal;\n-  struct st_parameter_dt *pdt;\n-  pthread_t thread;\n-  struct transfer_queue *head;\n-  struct transfer_queue *tail;\n-  struct\n-  {\n-    int waiting;\n-    int low;\n-    int high;\n-    struct adv_cond done;\n-  } id;\n-\n-  bool empty;\n-\n-  struct {\n-    const char *message;\n-    st_parameter_common *cmp;\n-    bool has_error;\n-    int last_good_id;\n-    int family;\n-    bool fatal_error;\n-  } error;\n-\n-} async_unit;\n-\n-void init_async_unit (gfc_unit *);\n-internal_proto (init_async_unit);\n-\n-bool async_wait (st_parameter_common *, async_unit *);\n-internal_proto (async_wait);\n-\n-bool async_wait_id (st_parameter_common *, async_unit *, int);\n-internal_proto (async_wait_id);\n-\n-bool collect_async_errors (st_parameter_common *, async_unit *);\n-internal_proto (collect_async_errors); \n-\n-void async_close (async_unit *);\n-internal_proto (async_close);\n-\n-void enqueue_transfer (async_unit * au, transfer_args * arg, enum aio_do);\n-internal_proto (enqueue_transfer);\n-\n-void enqueue_done (async_unit *, enum aio_do type);\n-internal_proto (enqueue_done);\n-\n-int enqueue_done_id (async_unit *, enum aio_do type);\n-internal_proto (enqueue_done_id);\n-\n-void enqueue_init (async_unit *);\n-internal_proto (enqueue_init);\n-\n-void enqueue_data_transfer_init (async_unit *, st_parameter_dt *, int);\n-internal_proto (enqueue_data_transfer_init);\n-\n-void enqueue_close (async_unit *);\n-internal_proto (enqueue_close);\n-\n-#endif"}, {"sha": "2117c40ac0d1f455ea6f123f6526e9d8492f672e", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -24,7 +24,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"io.h\"\n #include \"unix.h\"\n-#include \"async.h\"\n #include <limits.h>\n \n typedef enum\n@@ -58,21 +57,13 @@ st_close (st_parameter_close *clp)\n     find_option (&clp->common, clp->status, clp->status_len,\n \t\t status_opt, \"Bad STATUS parameter in CLOSE statement\");\n \n-  u = find_unit (clp->common.unit);\n-\n-  if (u && u->au)\n-    if (async_wait (&(clp->common), u->au))\n-      {\n-\tlibrary_end ();\n-\treturn;\n-      }\n-\n   if ((clp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n   {\n     library_end ();\n     return;\n   }\n \n+  u = find_unit (clp->common.unit);\n   if (u != NULL)\n     {\n       if (close_share (u) < 0)"}, {"sha": "75f58f0f7587df0864c075b7e393aadc93d53f5d", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -25,7 +25,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"io.h\"\n #include \"fbuf.h\"\n #include \"unix.h\"\n-#include \"async.h\"\n #include <string.h>\n \n /* file_pos.c-- Implement the file positioning statements, i.e. BACKSPACE,\n@@ -188,7 +187,6 @@ void\n st_backspace (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n-  bool needs_unlock = false;\n \n   library_start (&fpp->common);\n \n@@ -216,17 +214,6 @@ st_backspace (st_parameter_filepos *fpp)\n       goto done;\n     }\n \n-  if (u->au)\n-    {\n-      if (async_wait (&(fpp->common), u->au))\n-\treturn;\n-      else\n-\t{\n-\t  needs_unlock = true;\n-\t  LOCK (&u->au->io_lock);\n-\t}\n-    }\n-\n   /* Make sure format buffer is flushed and reset.  */\n   if (u->flags.form == FORM_FORMATTED)\n     {\n@@ -280,12 +267,7 @@ st_backspace (st_parameter_filepos *fpp)\n \n  done:\n   if (u != NULL)\n-    {\n-      unlock_unit (u);\n-\n-      if (u->au && needs_unlock)\n-\tUNLOCK (&u->au->io_lock);\n-    }\n+    unlock_unit (u);\n \n   library_end ();\n }\n@@ -298,7 +280,6 @@ void\n st_endfile (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n-  bool needs_unlock = false;\n \n   library_start (&fpp->common);\n \n@@ -313,17 +294,6 @@ st_endfile (st_parameter_filepos *fpp)\n \t  goto done;\n \t}\n \n-      if (u->au)\n-\t{\n-\t  if (async_wait (&(fpp->common), u->au))\n-\t    return;\n-\t  else\n-\t    {\n-\t      needs_unlock = true;\n-\t      LOCK (&u->au->io_lock);\n-\t    }\n-\t}\n-\n       if (u->flags.access == ACCESS_SEQUENTIAL\n       \t  && u->endfile == AFTER_ENDFILE)\n \t{\n@@ -406,11 +376,8 @@ st_endfile (st_parameter_filepos *fpp)\n \t}\n     }\n \n- done:\n-  if (u->au && needs_unlock)\n-    UNLOCK (&u->au->io_lock);\n-\n-  unlock_unit (u);\n+  done:\n+    unlock_unit (u);\n \n   library_end ();\n }\n@@ -423,7 +390,6 @@ void\n st_rewind (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n-  bool needs_unlock = true;\n \n   library_start (&fpp->common);\n \n@@ -435,17 +401,6 @@ st_rewind (st_parameter_filepos *fpp)\n \t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n       else\n \t{\n-\t  if (u->au)\n-\t    {\n-\t      if (async_wait (&(fpp->common), u->au))\n-\t\treturn;\n-\t      else\n-\t\t{\n-\t\t  needs_unlock = true;\n-\t\t  LOCK (&u->au->io_lock);\n-\t\t}\n-\t    }\n-\n \t  /* If there are previously written bytes from a write with ADVANCE=\"no\",\n \t     add a record marker before performing the ENDFILE.  */\n \n@@ -481,10 +436,6 @@ st_rewind (st_parameter_filepos *fpp)\n \t}\n       /* Update position for INQUIRE.  */\n       u->flags.position = POSITION_REWIND;\n-\n-      if (u->au && needs_unlock)\n-\tUNLOCK (&u->au->io_lock);\n-\n       unlock_unit (u);\n     }\n \n@@ -499,24 +450,12 @@ void\n st_flush (st_parameter_filepos *fpp)\n {\n   gfc_unit *u;\n-  bool needs_unlock = false;\n \n   library_start (&fpp->common);\n \n   u = find_unit (fpp->common.unit);\n   if (u != NULL)\n     {\n-      if (u->au)\n-\t{\n-\t  if (async_wait (&(fpp->common), u->au))\n-\t    return;\n-\t  else\n-\t    {\n-\t      needs_unlock = true;\n-\t      LOCK (&u->au->io_lock);\n-\t    }\n-\t}\n-\n       /* Make sure format buffer is flushed.  */\n       if (u->flags.form == FORM_FORMATTED)\n         fbuf_flush (u, u->mode);\n@@ -530,8 +469,5 @@ st_flush (st_parameter_filepos *fpp)\n     generate_error (&fpp->common, LIBERROR_BAD_OPTION,\n \t\t\t\"Specified UNIT in FLUSH is not connected\");\n \n-  if (needs_unlock)\n-    UNLOCK (&u->au->io_lock);\n-\n   library_end ();\n }"}, {"sha": "047be39ec7af0f26e47620288422ddb8054aefa8", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -26,7 +26,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* Implement the non-IOLENGTH variant of the INQUIRY statement */\n \n #include \"io.h\"\n-#include \"async.h\"\n #include \"unix.h\"\n #include <string.h>\n \n@@ -282,6 +281,12 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit *u)\n     {\n       GFC_INTEGER_4 cf2 = iqp->flags2;\n \n+      if ((cf2 & IOPARM_INQUIRE_HAS_PENDING) != 0)\n+\t*iqp->pending = 0;\n+  \n+      if ((cf2 & IOPARM_INQUIRE_HAS_ID) != 0)\n+        *iqp->id = 0;\n+\n       if ((cf2 & IOPARM_INQUIRE_HAS_ENCODING) != 0)\n \t{\n \t  if (u == NULL || u->flags.form != FORM_FORMATTED)\n@@ -327,41 +332,19 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit *u)\n \t  if (u == NULL)\n \t    p = undefined;\n \t  else\n+\t    switch (u->flags.async)\n \t    {\n-\t      switch (u->flags.async)\n-\t\t{\n-\t\tcase ASYNC_YES:\n-\t\t  p = yes;\n-\t\t  break;\n-\t\tcase ASYNC_NO:\n-\t\t  p = no;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  internal_error (&iqp->common, \"inquire_via_unit(): Bad async\");\n-\t\t}\n+\t      case ASYNC_YES:\n+\t\tp = yes;\n+\t\tbreak;\n+\t      case ASYNC_NO:\n+\t\tp = no;\n+\t\tbreak;\n+\t      default:\n+\t\tinternal_error (&iqp->common, \"inquire_via_unit(): Bad async\");\n \t    }\n-\t  cf_strcpy (iqp->asynchronous, iqp->asynchronous_len, p);\n-\t}\n \n-      if ((cf2 & IOPARM_INQUIRE_HAS_PENDING) != 0)\n-\t{\n-\t  if (u->au == NULL)\n-\t    *(iqp->pending) = 0;\n-\t  else\n-\t    {\n-\t      LOCK (&(u->au->lock));\n-\t      if ((cf2 & IOPARM_INQUIRE_HAS_ID) != 0)\n-\t\t{\n-\t\t  int id;\n-\t\t  id = *(iqp->id);\n-\t\t  *(iqp->pending) = id > u->au->id.low;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  *(iqp->pending) = ! u->au->empty;\n-\t\t}\n-\t      UNLOCK (&(u->au->lock));\n-\t    }\n+\t  cf_strcpy (iqp->asynchronous, iqp->asynchronous_len, p);\n \t}\n \n       if ((cf2 & IOPARM_INQUIRE_HAS_SIGN) != 0)"}, {"sha": "ccbaf47ff907ab5aa797c9bff4502df5f3bfc31f", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -531,9 +531,7 @@ typedef struct st_parameter_dt\n \t  /* A flag used to identify when a non-standard expanded namelist read\n \t     has occurred.  */\n \t  unsigned expanded_read : 1;\n-\t  /* Flag to indicate if the statement has async=\"YES\". */\n-\t  unsigned async : 1;\n-\t  /* 12 unused bits.  */\n+\t  /* 13 unused bits.  */\n \n \t  int child_saved_iostat;\n \t  int nml_delim;\n@@ -592,7 +590,7 @@ extern char check_st_parameter_dt[sizeof (((st_parameter_dt *) 0)->u.pad)\n typedef struct\n {\n   st_parameter_common common;\n-  GFC_INTEGER_4 *id;\n+  CHARACTER1 (id);\n }\n st_parameter_wait;\n \n@@ -661,9 +659,6 @@ typedef struct gfc_unit\n \n   int continued;\n \n-  /* Contains the pointer to the async unit.  */\n-  struct async_unit *au;\n-\n   __gthread_mutex_t lock;\n   /* Number of threads waiting to acquire this unit's lock.\n      When non-zero, close_unit doesn't only removes the unit\n@@ -820,18 +815,11 @@ extern void next_record (st_parameter_dt *, int);\n internal_proto(next_record);\n \n extern void st_wait (st_parameter_wait *);\n-export_proto (st_wait);\n-\n-extern void st_wait_async (st_parameter_wait *);\n-export_proto (st_wait_async);\n+export_proto(st_wait);\n \n extern void hit_eof (st_parameter_dt *);\n internal_proto(hit_eof);\n \n-extern void transfer_array_inner (st_parameter_dt *, gfc_array_char *, int,\n-\t\t\t\t  gfc_charlen_type);\n-internal_proto (transfer_array_inner);\n-\n /* read.c */\n \n extern void set_integer (void *, GFC_INTEGER_LARGEST, int);\n@@ -1000,14 +988,3 @@ memset4 (gfc_char4_t *p, gfc_char4_t c, int k)\n \n #endif\n \n-extern void\n-st_write_done_worker (st_parameter_dt *);\n-internal_proto (st_write_done_worker);\n-\n-extern void\n-st_read_done_worker (st_parameter_dt *);\n-internal_proto (st_read_done_worker);\n-\n-extern void\n-data_transfer_init_worker (st_parameter_dt *, int);\n-internal_proto (data_transfer_init_worker);"}, {"sha": "05aac8f6a8b8de72c3fb8db6fc69e62c809d4734", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -26,7 +26,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"io.h\"\n #include \"fbuf.h\"\n #include \"unix.h\"\n-#include \"async.h\"\n \n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n@@ -652,12 +651,8 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags *flags)\n   else\n     u->fbuf = NULL;\n \n-  /* Check if asynchrounous.  */\n-  if (flags->async == ASYNC_YES)\n-    init_async_unit (u);\n-  else\n-    u->au = NULL;\n-\n+    \n+    \n   return u;\n \n  cleanup:"}, {"sha": "976020af448019dbe236ffa5b521f83f1fd7daf6", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -30,7 +30,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <string.h>\n #include <ctype.h>\n #include <assert.h>\n-#include \"async.h\"\n \n typedef unsigned char uchar;\n \n@@ -43,7 +42,6 @@ typedef unsigned char uchar;\n void\n set_integer (void *dest, GFC_INTEGER_LARGEST value, int length)\n {\n-  NOTE (\"set_integer: %lld %p\", (long long int) value, dest);\n   switch (length)\n     {\n #ifdef HAVE_GFC_INTEGER_16"}, {"sha": "df33bed1561db6a55ec114e90bf4254817a98754", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 57, "deletions": 252, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -31,7 +31,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"fbuf.h\"\n #include \"format.h\"\n #include \"unix.h\"\n-#include \"async.h\"\n #include <string.h>\n #include <errno.h>\n \n@@ -185,12 +184,6 @@ static const st_option pad_opt[] = {\n   {NULL, 0}\n };\n \n-static const st_option async_opt[] = {\n-  {\"yes\", ASYNC_YES},\n-  {\"no\", ASYNC_NO},\n-  {NULL, 0}\n-};\n-\n typedef enum\n { FORMATTED_SEQUENTIAL, UNFORMATTED_SEQUENTIAL,\n   FORMATTED_DIRECT, UNFORMATTED_DIRECT, FORMATTED_STREAM, UNFORMATTED_STREAM\n@@ -1601,8 +1594,7 @@ formatted_transfer_scalar_read (st_parameter_dt *dtp, bt type, void *p, int kind\n \t\tread_f (dtp, f, p, kind);\n \t\tbreak;\n \t      default:\n-\t\tinternal_error (&dtp->common,\n-\t\t\t\t\"formatted_transfer (): Bad type\");\n+\t\tinternal_error (&dtp->common, \"formatted_transfer(): Bad type\");\n \t    }\n \t  break;\n \n@@ -2074,7 +2066,7 @@ formatted_transfer_scalar_write (st_parameter_dt *dtp, bt type, void *p, int kin\n \t\tbreak;\n \t      default:\n \t\tinternal_error (&dtp->common,\n-\t\t\t\t\"formatted_transfer (): Bad type\");\n+\t\t\t\t\"formatted_transfer(): Bad type\");\n \t    }\n \t  break;\n \n@@ -2289,38 +2281,6 @@ formatted_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n     }\n }\n \n-/* Wrapper function for I/O of scalar types.  If this should be an async I/O\n-   request, queue it.  For a synchronous write on an async unit, perform the\n-   wait operation and return an error.  For all synchronous writes, call the\n-   right transfer function.  */\n-\n-static void\n-wrap_scalar_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n-\t\t      size_t size, size_t n_elem)\n-{\n-  if (dtp->u.p.current_unit && dtp->u.p.current_unit->au)\n-    {\n-      if (dtp->u.p.async)\n-\t{\n-\t  transfer_args args;\n-\t  args.scalar.transfer = dtp->u.p.transfer;\n-\t  args.scalar.arg_bt = type;\n-\t  args.scalar.data = p;\n-\t  args.scalar.i = kind;\n-\t  args.scalar.s1 = size;\n-\t  args.scalar.s2 = n_elem;\n-\t  enqueue_transfer (dtp->u.p.current_unit->au, &args,\n-\t\t\t    AIO_TRANSFER_SCALAR);\n-\t  return;\n-\t}\n-    }\n-  /* Come here if there was no asynchronous I/O to be scheduled.  */\n-  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n-    return;\n-\n-  dtp->u.p.transfer (dtp, type, p, kind, size, 1);\n-}\n-\n \n /* Data transfer entry points.  The type of the data entity is\n    implicit in the subroutine call.  This prevents us from having to\n@@ -2329,7 +2289,9 @@ wrap_scalar_transfer (st_parameter_dt *dtp, bt type, void *p, int kind,\n void\n transfer_integer (st_parameter_dt *dtp, void *p, int kind)\n {\n-    wrap_scalar_transfer (dtp, BT_INTEGER, p, kind, kind, 1);\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+    return;\n+  dtp->u.p.transfer (dtp, BT_INTEGER, p, kind, kind, 1);\n }\n \n void\n@@ -2345,7 +2307,7 @@ transfer_real (st_parameter_dt *dtp, void *p, int kind)\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   size = size_from_real_kind (kind);\n-  wrap_scalar_transfer (dtp, BT_REAL, p, kind, size, 1);\n+  dtp->u.p.transfer (dtp, BT_REAL, p, kind, size, 1);\n }\n \n void\n@@ -2357,7 +2319,9 @@ transfer_real_write (st_parameter_dt *dtp, void *p, int kind)\n void\n transfer_logical (st_parameter_dt *dtp, void *p, int kind)\n {\n-  wrap_scalar_transfer (dtp, BT_LOGICAL, p, kind, kind, 1);\n+  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n+    return;\n+  dtp->u.p.transfer (dtp, BT_LOGICAL, p, kind, kind, 1);\n }\n \n void\n@@ -2381,7 +2345,7 @@ transfer_character (st_parameter_dt *dtp, void *p, gfc_charlen_type len)\n     p = empty_string;\n \n   /* Set kind here to 1.  */\n-  wrap_scalar_transfer (dtp, BT_CHARACTER, p, 1, len, 1);\n+  dtp->u.p.transfer (dtp, BT_CHARACTER, p, 1, len, 1);\n }\n \n void\n@@ -2405,7 +2369,7 @@ transfer_character_wide (st_parameter_dt *dtp, void *p, gfc_charlen_type len, in\n     p = empty_string;\n \n   /* Here we pass the actual kind value.  */\n-  wrap_scalar_transfer (dtp, BT_CHARACTER, p, kind, len, 1);\n+  dtp->u.p.transfer (dtp, BT_CHARACTER, p, kind, len, 1);\n }\n \n void\n@@ -2421,7 +2385,7 @@ transfer_complex (st_parameter_dt *dtp, void *p, int kind)\n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n   size = size_from_complex_kind (kind);\n-  wrap_scalar_transfer (dtp, BT_COMPLEX, p, kind, size, 1);\n+  dtp->u.p.transfer (dtp, BT_COMPLEX, p, kind, size, 1);\n }\n \n void\n@@ -2431,8 +2395,8 @@ transfer_complex_write (st_parameter_dt *dtp, void *p, int kind)\n }\n \n void\n-transfer_array_inner (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n-\t\t      gfc_charlen_type charlen)\n+transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n+\t\tgfc_charlen_type charlen)\n {\n   index_type count[GFC_MAX_DIMENSIONS];\n   index_type extent[GFC_MAX_DIMENSIONS];\n@@ -2443,7 +2407,7 @@ transfer_array_inner (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n   bt iotype;\n \n   /* Adjust item_count before emitting error message.  */\n-\n+ \n   if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n     return;\n \n@@ -2506,36 +2470,6 @@ transfer_array_inner (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n     }\n }\n \n-void\n-transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n-\t        gfc_charlen_type charlen)\n-{\n-  if ((dtp->common.flags & IOPARM_LIBRETURN_MASK) != IOPARM_LIBRETURN_OK)\n-    return;\n-\n-  if (dtp->u.p.current_unit && dtp->u.p.current_unit->au)\n-    {\n-      if (dtp->u.p.async)\n-\t{\n-\t  transfer_args args;\n-\t  size_t sz = sizeof (gfc_array_char)\n-\t\t\t+ sizeof (descriptor_dimension)\n-       \t\t\t* GFC_DESCRIPTOR_RANK (desc);\n-\t  args.array.desc = xmalloc (sz);\n-\t  NOTE (\"desc = %p\", (void *) args.array.desc);\n-\t  memcpy (args.array.desc, desc, sz);\n-\t  args.array.kind = kind;\n-\t  args.array.charlen = charlen;\n-\t  enqueue_transfer (dtp->u.p.current_unit->au, &args,\n-\t\t\t    AIO_TRANSFER_ARRAY);\n-\t  return;\n-\t}\n-    }\n-  /* Come here if there was no asynchronous I/O to be scheduled.  */\n-  transfer_array_inner (dtp, desc, kind, charlen);\n-}\n-\n-\n void\n transfer_array_write (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n \t\t      gfc_charlen_type charlen)\n@@ -2558,7 +2492,7 @@ transfer_derived (st_parameter_dt *parent, void *dtio_source, void *dtio_proc)\n       else\n \tparent->u.p.fdtio_ptr = (formatted_dtio) dtio_proc;\n     }\n-  wrap_scalar_transfer (parent, BT_CLASS, dtio_source, 0, 0, 1);\n+  parent->u.p.transfer (parent, BT_CLASS, dtio_source, 0, 0, 1);\n }\n \n \n@@ -2733,9 +2667,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   unit_flags u_flags;  /* Used for creating a unit if needed.  */\n   GFC_INTEGER_4 cf = dtp->common.flags;\n   namelist_info *ionml;\n-  async_unit *au;\n-\n-  NOTE (\"data_transfer_init\");\n \n   ionml = ((cf & IOPARM_DT_IONML_SET) != 0) ? dtp->u.p.ionml : NULL;\n \n@@ -2762,9 +2693,9 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     }\n   else if (dtp->u.p.current_unit->s == NULL)\n     {  /* Open the unit with some default flags.  */\n-      st_parameter_open opp;\n-      unit_convert conv;\n-      NOTE (\"Open the unit with some default flags.\");\n+       st_parameter_open opp;\n+       unit_convert conv;\n+\n       memset (&u_flags, '\\0', sizeof (u_flags));\n       u_flags.access = ACCESS_SEQUENTIAL;\n       u_flags.action = ACTION_READWRITE;\n@@ -2839,42 +2770,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   else if (dtp->u.p.current_unit->internal_unit_kind > 0)\n     dtp->u.p.unit_is_internal = 1;\n \n-  if ((cf & IOPARM_DT_HAS_ASYNCHRONOUS) != 0)\n-    {\n-      int f;\n-      f = find_option (&dtp->common, dtp->asynchronous, dtp->asynchronous_len,\n-\t\t       async_opt, \"Bad ASYNCHRONOUS in data transfer \"\n-\t\t       \"statement\");\n-      if (f == ASYNC_YES && dtp->u.p.current_unit->flags.async != ASYNC_YES)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n-\t\t\t  \"ASYNCHRONOUS transfer without \"\n-\t\t\t  \"ASYHCRONOUS='YES' in OPEN\");\n-\t  return;\n-\t}\n-      dtp->u.p.async = f == ASYNC_YES;\n-    }\n-\n-  au = dtp->u.p.current_unit->au;\n-  if (au)\n-    {\n-      if (dtp->u.p.async)\n-\t{\n-\t  /* If this is an asynchronous I/O statement, collect errors and\n-\t     return if there are any.  */\n-\t  if (collect_async_errors (&dtp->common, au))\n-\t    return;\n-\t}\n-      else\n-\t{\n-\t  /* Synchronous statement: Perform a wait operation for any pending\n-\t     asynchronous I/O.  This needs to be done before all other error\n-\t     checks.  See F2008, 9.6.4.1.  */\n-\t  if (async_wait (&(dtp->common), au))\n-\t    return;\n-\t}\n-    }\n-\n   /* Check the action.  */\n \n   if (read_flag && dtp->u.p.current_unit->flags.action == ACTION_WRITE)\n@@ -3114,57 +3009,6 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   if (dtp->u.p.current_unit->pad_status == PAD_UNSPECIFIED)\n \tdtp->u.p.current_unit->pad_status = dtp->u.p.current_unit->flags.pad;\n \n-  /* Set up the subroutine that will handle the transfers.  */\n-\n-  if (read_flag)\n-    {\n-      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n-\tdtp->u.p.transfer = unformatted_read;\n-      else\n-\t{\n-\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n-\t    dtp->u.p.transfer = list_formatted_read;\n-\t  else\n-\t    dtp->u.p.transfer = formatted_transfer;\n-\t}\n-    }\n-  else\n-    {\n-      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n-\tdtp->u.p.transfer = unformatted_write;\n-      else\n-\t{\n-\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n-\t    dtp->u.p.transfer = list_formatted_write;\n-\t  else\n-\t    dtp->u.p.transfer = formatted_transfer;\n-\t}\n-    }\n-\n-  if (au)\n-    {\n-      NOTE (\"enqueue_data_transfer\");\n-      enqueue_data_transfer_init (au, dtp, read_flag);\n-    }\n-  else\n-    {\n-      NOTE (\"invoking data_transfer_init_worker\");\n-      data_transfer_init_worker (dtp, read_flag);\n-    }\n-}\n-\n-void\n-data_transfer_init_worker (st_parameter_dt *dtp, int read_flag)\n-{\n-  GFC_INTEGER_4 cf = dtp->common.flags;\n-\n-  NOTE (\"starting worker...\");\n-\n-  if (read_flag && dtp->u.p.current_unit->flags.form != FORM_UNFORMATTED\n-      && ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n-      && dtp->u.p.current_unit->child_dtio  == 0)\n-    dtp->u.p.current_unit->last_char = EOF - 1;\n-\n   /* Check to see if we might be reading what we wrote before  */\n \n   if (dtp->u.p.mode != dtp->u.p.current_unit->mode\n@@ -3291,6 +3135,38 @@ data_transfer_init_worker (st_parameter_dt *dtp, int read_flag)\n \n   pre_position (dtp);\n \n+\n+  /* Set up the subroutine that will handle the transfers.  */\n+\n+  if (read_flag)\n+    {\n+      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tdtp->u.p.transfer = unformatted_read;\n+      else\n+\t{\n+\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+\t    {\n+\t      if (dtp->u.p.current_unit->child_dtio  == 0)\n+\t        dtp->u.p.current_unit->last_char = EOF - 1;\n+\t      dtp->u.p.transfer = list_formatted_read;\n+\t    }\n+\t  else\n+\t    dtp->u.p.transfer = formatted_transfer;\n+\t}\n+    }\n+  else\n+    {\n+      if (dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n+\tdtp->u.p.transfer = unformatted_write;\n+      else\n+\t{\n+\t  if ((cf & IOPARM_DT_LIST_FORMAT) != 0)\n+\t    dtp->u.p.transfer = list_formatted_write;\n+\t  else\n+\t    dtp->u.p.transfer = formatted_transfer;\n+\t}\n+    }\n+\n   /* Make sure that we don't do a read after a nonadvancing write.  */\n \n   if (read_flag)\n@@ -4223,7 +4099,7 @@ extern void st_read_done (st_parameter_dt *);\n export_proto(st_read_done);\n \n void\n-st_read_done_worker (st_parameter_dt *dtp)\n+st_read_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n \n@@ -4251,38 +4127,14 @@ st_read_done_worker (st_parameter_dt *dtp)\n \t  free_format_data (dtp->u.p.fmt);\n \t  free_format (dtp);\n \t}\n-    }\n-}\n-\n-void\n-st_read_done (st_parameter_dt *dtp)\n-{\n-  if (dtp->u.p.current_unit)\n-    {\n-      if (dtp->u.p.current_unit->au)\n-\t{\n-\t  if (dtp->common.flags & IOPARM_DT_HAS_ID)\n-\t    *dtp->id = enqueue_done_id (dtp->u.p.current_unit->au, AIO_READ_DONE);  \n-\t  else\n-\t    {\n-\t      enqueue_done (dtp->u.p.current_unit->au, AIO_READ_DONE);\n-\t      /* An asynchronous unit without ASYNCHRONOUS=\"YES\" - make this\n-\t\t synchronous by performing a wait operation.  */\n-\t      if (!dtp->u.p.async)\n-\t\tasync_wait (&dtp->common, dtp->u.p.current_unit->au);\n-\t    }\n-\t}\n-      else\n-\tst_read_done_worker (dtp);\n-\n       unlock_unit (dtp->u.p.current_unit);\n     }\n \n   library_end ();\n }\n \n extern void st_write (st_parameter_dt *);\n-export_proto (st_write);\n+export_proto(st_write);\n \n void\n st_write (st_parameter_dt *dtp)\n@@ -4291,9 +4143,11 @@ st_write (st_parameter_dt *dtp)\n   data_transfer_init (dtp, 0);\n }\n \n+extern void st_write_done (st_parameter_dt *);\n+export_proto(st_write_done);\n \n void\n-st_write_done_worker (st_parameter_dt *dtp)\n+st_write_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n \n@@ -4342,65 +4196,16 @@ st_write_done_worker (st_parameter_dt *dtp)\n \t  free_format_data (dtp->u.p.fmt);\n \t  free_format (dtp);\n \t}\n-    }\n-}\n-\n-extern void st_write_done (st_parameter_dt *);\n-export_proto(st_write_done);\n-\n-void\n-st_write_done (st_parameter_dt *dtp)\n-{\n-  if (dtp->u.p.current_unit)\n-    {\n-      if (dtp->u.p.current_unit->au)\n-\t{\n-\t  if (dtp->common.flags & IOPARM_DT_HAS_ID)\n-\t    *dtp->id = enqueue_done_id (dtp->u.p.current_unit->au,\n-\t\t\t\t\tAIO_WRITE_DONE);\n-\t  else\n-\t    {\n-\t      enqueue_done (dtp->u.p.current_unit->au, AIO_WRITE_DONE);\n-\t      /* An asynchronous unit without ASYNCHRONOUS=\"YES\" - make this\n-\t\t synchronous by performing a wait operation.  */\n-\t      if (!dtp->u.p.async)\n-\t\tasync_wait (&dtp->common, dtp->u.p.current_unit->au);\n-\t    }\n-\t}\n-      else\n-\tst_write_done_worker (dtp);\n-\n       unlock_unit (dtp->u.p.current_unit);\n     }\n-\n   library_end ();\n }\n \n-/* Wait operation.  We need to keep around the do-nothing version\n- of st_wait for compatibility with previous versions, which had marked\n- the argument as unused (and thus liable to be removed).\n-\n- TODO: remove at next bump in version number.  */\n \n+/* F2003: This is a stub for the runtime portion of the WAIT statement.  */\n void\n st_wait (st_parameter_wait *wtp __attribute__((unused)))\n {\n-  return;\n-}\n-\n-void\n-st_wait_async (st_parameter_wait *wtp)\n-{\n-  gfc_unit *u = find_unit (wtp->common.unit);\n-  if (u->au)\n-    {\n-      if (wtp->common.flags & IOPARM_WAIT_HAS_ID)\n-\tasync_wait_id (&(wtp->common), u->au, *wtp->id);\n-      else\n-\tasync_wait (&(wtp->common), u->au);\n-    }\n-\n-  unlock_unit (u);\n }\n \n "}, {"sha": "559dba92635754c50a20cf4ea9b1a34cbc6dfb22", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -27,7 +27,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"fbuf.h\"\n #include \"format.h\"\n #include \"unix.h\"\n-#include \"async.h\"\n #include <string.h>\n #include <assert.h>\n \n@@ -241,7 +240,7 @@ insert_unit (int n)\n #else\n   __GTHREAD_MUTEX_INIT_FUNCTION (&u->lock);\n #endif\n-  LOCK (&u->lock);\n+  __gthread_mutex_lock (&u->lock);\n   u->priority = pseudo_random ();\n   unit_root = insert (u, unit_root);\n   return u;\n@@ -328,9 +327,7 @@ get_gfc_unit (int n, int do_create)\n   gfc_unit *p;\n   int c, created = 0;\n \n-  NOTE (\"Unit n=%d, do_create = %d\", n, do_create);\n-  LOCK (&unit_lock);\n-\n+  __gthread_mutex_lock (&unit_lock);\n retry:\n   for (c = 0; c < CACHE_SIZE; c++)\n     if (unit_cache[c] != NULL && unit_cache[c]->unit_number == n)\n@@ -369,34 +366,34 @@ get_gfc_unit (int n, int do_create)\n     {\n       /* Newly created units have their lock held already\n \t from insert_unit.  Just unlock UNIT_LOCK and return.  */\n-      UNLOCK (&unit_lock);\n+      __gthread_mutex_unlock (&unit_lock);\n       return p;\n     }\n \n found:\n   if (p != NULL && (p->child_dtio == 0))\n     {\n       /* Fast path.  */\n-      if (! TRYLOCK (&p->lock))\n+      if (! __gthread_mutex_trylock (&p->lock))\n \t{\n \t  /* assert (p->closed == 0); */\n-\t  UNLOCK (&unit_lock);\n+\t  __gthread_mutex_unlock (&unit_lock);\n \t  return p;\n \t}\n \n       inc_waiting_locked (p);\n     }\n \n \n-  UNLOCK (&unit_lock);\n+  __gthread_mutex_unlock (&unit_lock);\n \n   if (p != NULL && (p->child_dtio == 0))\n     {\n-      LOCK (&p->lock);\n+      __gthread_mutex_lock (&p->lock);\n       if (p->closed)\n \t{\n-\t  LOCK (&unit_lock);\n-\t  UNLOCK (&p->lock);\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&p->lock);\n \t  if (predec_waiting_locked (p) == 0)\n \t    destroy_unit_mutex (p);\n \t  goto retry;\n@@ -643,7 +640,7 @@ init_units (void)\n \n       fbuf_init (u, 0);\n \n-      UNLOCK (&u->lock);\n+      __gthread_mutex_unlock (&u->lock);\n     }\n \n   if (options.stdout_unit >= 0)\n@@ -674,7 +671,7 @@ init_units (void)\n \n       fbuf_init (u, 0);\n \n-      UNLOCK (&u->lock);\n+      __gthread_mutex_unlock (&u->lock);\n     }\n \n   if (options.stderr_unit >= 0)\n@@ -705,13 +702,13 @@ init_units (void)\n       fbuf_init (u, 256);  /* 256 bytes should be enough, probably not doing\n                               any kind of exotic formatting to stderr.  */\n \n-      UNLOCK (&u->lock);\n+      __gthread_mutex_unlock (&u->lock);\n     }\n   /* The default internal units.  */\n   u = insert_unit (GFC_INTERNAL_UNIT);\n-  UNLOCK (&u->lock);\n+  __gthread_mutex_unlock (&u->lock);\n   u = insert_unit (GFC_INTERNAL_UNIT4);\n-  UNLOCK (&u->lock);\n+  __gthread_mutex_unlock (&u->lock);\n }\n \n \n@@ -720,9 +717,6 @@ close_unit_1 (gfc_unit *u, int locked)\n {\n   int i, rc;\n \n-  if (u->au)\n-    async_close (u->au);\n-\n   /* If there are previously written bytes from a write with ADVANCE=\"no\"\n      Reposition the buffer before closing.  */\n   if (u->previous_nonadvancing_write)\n@@ -732,7 +726,7 @@ close_unit_1 (gfc_unit *u, int locked)\n \n   u->closed = 1;\n   if (!locked)\n-    LOCK (&unit_lock);\n+    __gthread_mutex_lock (&unit_lock);\n \n   for (i = 0; i < CACHE_SIZE; i++)\n     if (unit_cache[i] == u)\n@@ -750,7 +744,7 @@ close_unit_1 (gfc_unit *u, int locked)\n     newunit_free (u->unit_number);\n \n   if (!locked)\n-    UNLOCK (&u->lock);\n+    __gthread_mutex_unlock (&u->lock);\n \n   /* If there are any threads waiting in find_unit for this unit,\n      avoid freeing the memory, the last such thread will free it\n@@ -759,17 +753,15 @@ close_unit_1 (gfc_unit *u, int locked)\n     destroy_unit_mutex (u);\n \n   if (!locked)\n-    UNLOCK (&unit_lock);\n+    __gthread_mutex_unlock (&unit_lock);\n \n   return rc;\n }\n \n void\n unlock_unit (gfc_unit *u)\n {\n-  NOTE (\"unlock_unit = %d\", u->unit_number);\n-  UNLOCK (&u->lock);\n-  NOTE (\"unlock_unit done\");\n+  __gthread_mutex_unlock (&u->lock);\n }\n \n /* close_unit()-- Close a unit.  The stream is closed, and any memory\n@@ -793,10 +785,10 @@ close_unit (gfc_unit *u)\n void\n close_units (void)\n {\n-  LOCK (&unit_lock);\n+  __gthread_mutex_lock (&unit_lock);\n   while (unit_root != NULL)\n     close_unit_1 (unit_root, 1);\n-  UNLOCK (&unit_lock);\n+  __gthread_mutex_unlock (&unit_lock);\n \n   free (newunits);\n \n@@ -903,7 +895,7 @@ finish_last_advance_record (gfc_unit *u)\n int\n newunit_alloc (void)\n {\n-  LOCK (&unit_lock);\n+  __gthread_mutex_lock (&unit_lock);\n   if (!newunits)\n     {\n       newunits = xcalloc (16, 1);\n@@ -917,7 +909,7 @@ newunit_alloc (void)\n         {\n           newunits[ii] = true;\n           newunit_lwi = ii + 1;\n-\t  UNLOCK (&unit_lock);\n+\t  __gthread_mutex_unlock (&unit_lock);\n           return -ii + NEWUNIT_START;\n         }\n     }\n@@ -930,7 +922,7 @@ newunit_alloc (void)\n   memset (newunits + old_size, 0, old_size);\n   newunits[old_size] = true;\n   newunit_lwi = old_size + 1;\n-    UNLOCK (&unit_lock);\n+    __gthread_mutex_unlock (&unit_lock);\n   return -old_size + NEWUNIT_START;\n }\n "}, {"sha": "a8fd07a5f3b92112df355ab7f0a26a59f4c0f2ba", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -27,7 +27,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"io.h\"\n #include \"unix.h\"\n-#include \"async.h\"\n #include <limits.h>\n \n #ifdef HAVE_UNISTD_H\n@@ -1743,7 +1742,7 @@ find_file (const char *file, gfc_charlen_type file_len)\n   id = id_from_path (path);\n #endif\n \n-  LOCK (&unit_lock);\n+  __gthread_mutex_lock (&unit_lock);\n retry:\n   u = find_file0 (unit_root, FIND_FILE0_ARGS);\n   if (u != NULL)\n@@ -1752,20 +1751,20 @@ find_file (const char *file, gfc_charlen_type file_len)\n       if (! __gthread_mutex_trylock (&u->lock))\n \t{\n \t  /* assert (u->closed == 0); */\n-\t  UNLOCK (&unit_lock);\n+\t  __gthread_mutex_unlock (&unit_lock);\n \t  goto done;\n \t}\n \n       inc_waiting_locked (u);\n     }\n-  UNLOCK (&unit_lock);\n+  __gthread_mutex_unlock (&unit_lock);\n   if (u != NULL)\n     {\n-      LOCK (&u->lock);\n+      __gthread_mutex_lock (&u->lock);\n       if (u->closed)\n \t{\n-\t  LOCK (&unit_lock);\n-\t  UNLOCK (&u->lock);\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n \t  if (predec_waiting_locked (u) == 0)\n \t    free (u);\n \t  goto retry;\n@@ -1795,7 +1794,7 @@ flush_all_units_1 (gfc_unit *u, int min_unit)\n \t    return u;\n \t  if (u->s)\n \t    sflush (u->s);\n-\t  UNLOCK (&u->lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n \t}\n       u = u->right;\n     }\n@@ -1808,31 +1807,31 @@ flush_all_units (void)\n   gfc_unit *u;\n   int min_unit = 0;\n \n-  LOCK (&unit_lock);\n+  __gthread_mutex_lock (&unit_lock);\n   do\n     {\n       u = flush_all_units_1 (unit_root, min_unit);\n       if (u != NULL)\n \tinc_waiting_locked (u);\n-      UNLOCK (&unit_lock);\n+      __gthread_mutex_unlock (&unit_lock);\n       if (u == NULL)\n \treturn;\n \n-      LOCK (&u->lock);\n+      __gthread_mutex_lock (&u->lock);\n \n       min_unit = u->unit_number + 1;\n \n       if (u->closed == 0)\n \t{\n \t  sflush (u->s);\n-\t  LOCK (&unit_lock);\n-\t  UNLOCK (&u->lock);\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n \t  (void) predec_waiting_locked (u);\n \t}\n       else\n \t{\n-\t  LOCK (&unit_lock);\n-\t  UNLOCK (&u->lock);\n+\t  __gthread_mutex_lock (&unit_lock);\n+\t  __gthread_mutex_unlock (&u->lock);\n \t  if (predec_waiting_locked (u) == 0)\n \t    free (u);\n \t}"}, {"sha": "2b75fbf904dbc36fa4d72ee5bfe0f0af75956fd8", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -738,9 +738,6 @@ internal_proto(translate_error);\n extern void generate_error (st_parameter_common *, int, const char *);\n iexport_proto(generate_error);\n \n-extern bool generate_error_common (st_parameter_common *, int, const char *);\n-iexport_proto(generate_error_common);\n-\n extern void generate_warning (st_parameter_common *, const char *);\n internal_proto(generate_warning);\n \n@@ -1746,7 +1743,5 @@ void cshift1_16_c16 (gfc_array_c16 * const restrict,\n internal_proto(cshift1_16_c16);\n #endif\n \n-/* Define this if we support asynchronous I/O on this platform.  This\n-   currently requires weak symbols.  */\n \n #endif  /* LIBGFOR_H  */"}, {"sha": "1a53e2f72f138c0c06d5b84aeb5ea3b24108c08e", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 19, "deletions": 56, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -24,9 +24,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n \n #include \"libgfortran.h\"\n-#include \"io.h\"\n-#include \"async.h\"\n-\n #include <assert.h>\n #include <string.h>\n #include <errno.h>\n@@ -529,38 +526,24 @@ translate_error (int code)\n }\n \n \n-/* Worker function for generate_error and generate_error_async.  Return true\n-   if a straight return is to be done, zero if the program should abort. */\n+/* generate_error()-- Come here when an error happens.  This\n+ * subroutine is called if it is possible to continue on after the error.\n+ * If an IOSTAT or IOMSG variable exists, we set it.  If IOSTAT or\n+ * ERR labels are present, we return, otherwise we terminate the program\n+ * after printing a message.  The error code is always required but the\n+ * message parameter can be NULL, in which case a string describing\n+ * the most recent operating system error is used. */\n \n-bool\n-generate_error_common (st_parameter_common *cmp, int family, const char *message)\n+void\n+generate_error (st_parameter_common *cmp, int family, const char *message)\n {\n   char errmsg[STRERR_MAXSZ];\n-  gfc_unit *u;\n-\n-  NOTE (\"Entering generate_error_common\");\n-\n-  u = thread_unit;\n-  if (u && u->au)\n-    {\n-      if (u->au->error.has_error)\n-\treturn true;\n-\n-      if (__gthread_equal (u->au->thread, __gthread_self ()))\n-\t{\n-\t  u->au->error.has_error = 1;\n-\t  u->au->error.cmp = cmp;\n-\t  u->au->error.family = family;\n-\t  u->au->error.message = message;\n-\t  return true;\n-\t}\n-    }\n \n   /* If there was a previous error, don't mask it with another\n      error message, EOF or EOR condition.  */\n \n   if ((cmp->flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_ERROR)\n-    return true;\n+    return;\n \n   /* Set the error status.  */\n   if ((cmp->flags & IOPARM_HAS_IOSTAT))\n@@ -579,56 +562,36 @@ generate_error_common (st_parameter_common *cmp, int family, const char *message\n   switch (family)\n     {\n     case LIBERROR_EOR:\n-      cmp->flags |= IOPARM_LIBRETURN_EOR;  NOTE(\"EOR\");\n+      cmp->flags |= IOPARM_LIBRETURN_EOR;\n       if ((cmp->flags & IOPARM_EOR))\n-\treturn true;\n+\treturn;\n       break;\n \n     case LIBERROR_END:\n-      cmp->flags |= IOPARM_LIBRETURN_END; NOTE(\"END\");\n+      cmp->flags |= IOPARM_LIBRETURN_END;\n       if ((cmp->flags & IOPARM_END))\n-\treturn true;\n+\treturn;\n       break;\n \n     default:\n-      cmp->flags |= IOPARM_LIBRETURN_ERROR; NOTE(\"ERROR\");\n+      cmp->flags |= IOPARM_LIBRETURN_ERROR;\n       if ((cmp->flags & IOPARM_ERR))\n-\treturn true;\n+\treturn;\n       break;\n     }\n \n   /* Return if the user supplied an iostat variable.  */\n   if ((cmp->flags & IOPARM_HAS_IOSTAT))\n-    return true;\n+    return;\n \n-  /* Return code, caller is responsible for terminating\n-   the program if necessary.  */\n+  /* Terminate the program */\n \n   recursion_check ();\n   show_locus (cmp);\n   estr_write (\"Fortran runtime error: \");\n   estr_write (message);\n   estr_write (\"\\n\");\n-  return false;\n-}\n-\n-/* generate_error()-- Come here when an error happens.  This\n- * subroutine is called if it is possible to continue on after the error.\n- * If an IOSTAT or IOMSG variable exists, we set it.  If IOSTAT or\n- * ERR labels are present, we return, otherwise we terminate the program\n- * after printing a message.  The error code is always required but the\n- * message parameter can be NULL, in which case a string describing\n- * the most recent operating system error is used.\n- * If the error is for an asynchronous unit and if the program is currently\n- * executing the asynchronous thread, just mark the error and return.  */\n-\n-void\n-generate_error (st_parameter_common *cmp, int family, const char *message)\n-{\n-  if (generate_error_common (cmp, family, message))\n-    return;\n-\n-  exit_error(2);\n+  exit_error (2);\n }\n iexport(generate_error);\n "}, {"sha": "0cce3715b843b659d80976c7d24b5f85fa346ee3", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=1d4a51cf5079c11a44126bf7d5cf63fd9b202fbd", "patch": "@@ -1,3 +1,18 @@\n+2018-07-31  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\tRevert 'AsyncI/O patch committed'.\n+\t2018-07-25  Nicolas Koenig  <koenigni@gcc.gnu.org>\n+\t\tThomas Koenig <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/25829\n+\t* testsuite/libgomp.fortran/async_io_1.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_2.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_3.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_4.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_5.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_6.f90: New test.\n+\t* testsuite/libgomp.fortran/async_io_7.f90: New test.\n+\n 2018-07-30  Tom de Vries  <tdevries@suse.de>\n \n \t* plugin/plugin-nvptx.c (MIN, MAX): Redefine."}, {"sha": "07721bb230ac9403a69f08a30422b1fc39d25699", "filename": "libgomp/testsuite/libgomp.fortran/async_io_1.f90", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_1.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,48 +0,0 @@\n-! { dg-do run }\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-! Check basic functionality of async I/O\n-program main\n-  implicit none\n-  integer:: i=1, j=2, k, l\n-  real :: a, b, c, d\n-  character(3), parameter:: yes=\"yes\"\n-  character(4) :: str\n-  complex :: cc, dd\n-  integer, dimension(4):: is = [0, 1, 2, 3]\n-  integer, dimension(4):: res\n-  character(10) :: inq\n-\n-  open (10, file='a.dat', asynchronous=yes)\n-  cc = (1.5, 0.5)\n-  inquire (10,asynchronous=inq)\n-  if (inq /= \"YES\") stop 1\n-  write (10,*,asynchronous=yes) 4, 3\n-  write (10,*,asynchronous=yes) 2, 1\n-  write (10,*,asynchronous=yes) 1.0, 3.0\n-  write (10,'(A)', asynchronous=yes) 'asdf'\n-  write (10,*, asynchronous=yes) cc\n-  close (10)\n-  open (20, file='a.dat', asynchronous=yes)\n-  read (20, *, asynchronous=yes) i, j\n-  read (20, *, asynchronous=yes) k, l\n-  read (20, *, asynchronous=yes) a, b\n-  read (20,'(A4)',asynchronous=yes) str\n-  read (20,*, asynchronous=yes) dd\n-  wait (20)\n-  if (i /= 4 .or. j /= 3) stop 2\n-  if (k /= 2 .or. l /= 1) stop 3\n-  if (a /= 1.0 .or. b /= 3.0) stop 4\n-  if (str /= 'asdf') stop 5\n-  if (cc /= dd) stop 6\n-  close (20,status=\"delete\")\n-\n-  open(10, file='c.dat', asynchronous=yes) \n-  write(10, *, asynchronous=yes) is\n-  close(10)\n-  open(20, file='c.dat', asynchronous=yes) \n-  read(20, *, asynchronous=yes) res\n-  wait (20)\n-  if (any(res /= is)) stop 7\n-  close (20,status=\"delete\")\n-end program"}, {"sha": "440d46e94639920b98b25115a180c9e337a3cb93", "filename": "libgomp/testsuite/libgomp.fortran/async_io_2.f90", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_2.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,18 +0,0 @@\n-! { dg-do  run }\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-program main\n-  implicit none\n-  integer :: i, ios\n-  character(len=100) :: iom\n-  open (10,file=\"tst.dat\")\n-  write (10,'(A4)') 'asdf'\n-  close(10)\n-  i = 234\n-  open(10,file=\"tst.dat\", asynchronous=\"yes\")\n-  read (10,'(I4)',asynchronous=\"yes\") i\n-  iom = ' '\n-  wait (10,iostat=ios,iomsg=iom)\n-  if (iom == ' ') stop 1\n-  close(10,status=\"delete\")\n-end program main"}, {"sha": "7d5124868cfcb00fdbd61d22aecd812a7386a8e8", "filename": "libgomp/testsuite/libgomp.fortran/async_io_3.f90", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_3.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,16 +0,0 @@\n-\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-! { dg-do run }\n-program main\n-  integer :: i\n-  open (10,file=\"tst.dat\")\n-  write (10,'(A4)') 'asdf'\n-  close(10)\n-  i = 234\n-  open(10,file=\"tst.dat\", asynchronous=\"yes\")\n-  read (10,'(I4)',asynchronous=\"yes\") i\n-  wait(10)\n-end program main\n-! { dg-output \"Fortran runtime error: Bad value during integer read\" }\n-! { dg-final { remote_file build delete \"tst.dat\" } }"}, {"sha": "a21ffaef4788b15a466c6d9d370fcd8b0fb2cc2d", "filename": "libgomp/testsuite/libgomp.fortran/async_io_4.f90", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_4.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,90 +0,0 @@\n-! { dg-do run { target fd_truncate } }\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-\n-! Test BACKSPACE for synchronous and asynchronous I/O\n-program main\n-  \n-  integer i, n, nr\n-  real x(10), y(10)\n-\n-  ! PR libfortran/20068\n-  open (20, status='scratch', asynchronous=\"yes\")\n-  write (20,*, asynchronous=\"yes\" ) 1\n-  write (20,*, asynchronous=\"yes\") 2\n-  write (20,*, asynchronous=\"yes\") 3\n-  rewind (20)\n-  i = 41\n-  read (20,*, asynchronous=\"yes\") i\n-  wait (20)\n-  if (i .ne. 1) STOP 1\n-  write (*,*) ' '\n-  backspace (20)\n-  i = 42\n-  read (20,*, asynchronous=\"yes\") i\n-  close (20)\n-  if (i .ne. 1) STOP 2\n-\n-  ! PR libfortran/20125\n-  open (20, status='scratch', asynchronous=\"yes\")\n-  write (20,*, asynchronous=\"yes\") 7\n-  backspace (20)\n-  read (20,*, asynchronous=\"yes\") i\n-  wait (20)\n-  if (i .ne. 7) STOP 3\n-  close (20)\n-\n-  open (20, status='scratch', form='unformatted')\n-  write (20) 8\n-  backspace (20)\n-  read (20) i\n-  if (i .ne. 8) STOP 4\n-  close (20)\n-\n-  ! PR libfortran/20471\n-  do n = 1, 10\n-     x(n) = sqrt(real(n))\n-  end do\n-  open (3, form='unformatted', status='scratch')\n-  write (3) (x(n),n=1,10)\n-  backspace (3)\n-  rewind (3)\n-  read (3) (y(n),n=1,10)\n-\n-  do n = 1, 10\n-     if (abs(x(n)-y(n)) > 0.00001) STOP 5\n-  end do\n-  close (3)\n-\n-  ! PR libfortran/20156\n-  open (3, form='unformatted', status='scratch')\n-  do i = 1, 5\n-     x(1) = i\n-     write (3) n, (x(n),n=1,10)\n-  end do\n-  nr = 0\n-  rewind (3)\n-20 continue\n-  read (3,end=30,err=90) n, (x(n),n=1,10)\n-  nr = nr + 1\n-  goto 20\n-30 continue\n-  if (nr .ne. 5) STOP 6\n-\n-  do i = 1, nr+1\n-     backspace (3)\n-  end do\n-\n-  do i = 1, nr\n-     read(3,end=70,err=90) n, (x(n),n=1,10)\n-     if (abs(x(1) - i) .gt. 0.001) STOP 7\n-  end do\n-  close (3)\n-  stop\n-\n-70 continue\n-  STOP 8\n-90 continue\n-  STOP 9\n-\n-end program"}, {"sha": "916e78aa001da3c94e73ec483d38628c5b5dbb7c", "filename": "libgomp/testsuite/libgomp.fortran/async_io_5.f90", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_5.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,132 +0,0 @@\n-! { dg-do run }\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-! PR55818 Reading a REAL from a file which doesn't end in a new line fails\n-! Test case from PR reporter.\n-implicit none\n-integer :: stat\n-!integer :: var ! << works\n-real    :: var ! << fails\n-character(len=10)    :: cvar ! << fails\n-complex :: cval\n-logical :: lvar\n-\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"1\", new_line(\"\")\n-write(99) \"2\", new_line(\"\")\n-write(99) \"3\"\n-close(99)\n-\n-! Test character kind\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) cvar\n-if (stat /= 0 .or. cvar /= \"1\") STOP 1\n-read (99,*, iostat=stat) cvar\n-if (stat /= 0 .or. cvar /= \"2\") STOP 2\n-read (99,*, iostat=stat) cvar              ! << FAILS: stat /= 0\n-if (stat /= 0 .or. cvar /= \"3\") STOP 3 ! << aborts here\n-\n-! Test real kind\n-rewind(99)\n-read (99,*, iostat=stat) var\n-if (stat /= 0 .or. var /= 1.0) STOP 4\n-read (99,*, iostat=stat) var\n-if (stat /= 0 .or. var /= 2.0) STOP 5\n-read (99,*, iostat=stat) var ! << FAILS: stat /= 0\n-if (stat /= 0 .or. var /= 3.0) STOP 6\n-close(99, status=\"delete\")\n-\n-! Test real kind with exponents\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"1.0e3\", new_line(\"\")\n-write(99) \"2.0e-03\", new_line(\"\")\n-write(99) \"3.0e2\"\n-close(99)\n-\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 7\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 8\n-read (99,*) var ! << FAILS: stat /= 0\n-if (stat /= 0) STOP 9\n-close(99, status=\"delete\")\n-\n-! Test logical kind\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"Tru\", new_line(\"\")\n-write(99) \"fal\", new_line(\"\")\n-write(99) \"t\"\n-close(99)\n-\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) lvar\n-if (stat /= 0 .or. (.not.lvar)) STOP 10\n-read (99,*, iostat=stat) lvar\n-if (stat /= 0 .or. lvar) STOP 11\n-read (99,*) lvar ! << FAILS: stat /= 0\n-if (stat /= 0 .or. (.not.lvar)) STOP 12\n-close(99, status=\"delete\")\n-\n-! Test combinations of Inf and Nan\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"infinity\", new_line(\"\")\n-write(99) \"nan\", new_line(\"\")\n-write(99) \"infinity\"\n-close(99)\n-\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 13\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 14\n-read (99,*) var          ! << FAILS: stat /= 0\n-if (stat /= 0) STOP 1! << aborts here\n-close(99, status=\"delete\")\n-\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"infinity\", new_line(\"\")\n-write(99) \"inf\", new_line(\"\")\n-write(99) \"nan\"\n-close(99)\n-\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 15\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 16\n-read (99,*) var          ! << FAILS: stat /= 0\n-if (stat /= 0) STOP 2! << aborts here\n-close(99, status=\"delete\")\n-\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"infinity\", new_line(\"\")\n-write(99) \"nan\", new_line(\"\")\n-write(99) \"inf\"\n-close(99)\n-\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 17\n-read (99,*, iostat=stat) var\n-if (stat /= 0) STOP 18\n-read (99,*) var          ! << FAILS: stat /= 0\n-if (stat /= 0) STOP 3! << aborts here\n-close(99, status=\"delete\")\n-\n-! Test complex kind\n-open(99, file=\"test.dat\", access=\"stream\", form=\"unformatted\", status=\"new\")\n-write(99) \"(1,2)\", new_line(\"\")\n-write(99) \"(2,3)\", new_line(\"\")\n-write(99) \"(4,5)\"\n-close(99)\n-\n-open(99, file=\"test.dat\")\n-read (99,*, iostat=stat) cval\n-if (stat /= 0 .or. cval /= cmplx(1,2)) STOP 19\n-read (99,*, iostat=stat) cval\n-if (stat /= 0 .or. cval /= cmplx(2,3)) STOP 20\n-read (99,*, iostat=stat) cval      ! << FAILS: stat /= 0, value is okay\n-if (stat /= 0 .or. cval /= cmplx(4,5)) STOP 21\n-close(99, status=\"delete\")\n-end"}, {"sha": "f19c0379202129162f59d78f86f203d4c699505b", "filename": "libgomp/testsuite/libgomp.fortran/async_io_6.f90", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_6.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,30 +0,0 @@\n-! { dg-do run }\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-! PR 22390 Implement flush statement\n-program flush_1\n-\n-   character(len=256) msg\n-   integer ios\n-\n-   open (unit=10, access='SEQUENTIAL', status='SCRATCH')\n-\n-   write (10, *) 42\n-   flush 10\n-\n-   write (10, *) 42\n-   flush(10)\n-\n-   write (10, *) 42\n-   flush(unit=10, iostat=ios)\n-   if (ios /= 0) STOP 1\n-\n-   write (10, *) 42\n-   flush (unit=10, err=20)\n-   goto 30\n-20 STOP 2\n-30 continue\n-\n-   call flush(10)\n-\n-end program flush_1"}, {"sha": "a7ce9ba47a7cabbf0915ebb54c02ceaaa12d45a7", "filename": "libgomp/testsuite/libgomp.fortran/async_io_7.f90", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58691d4a04c2c8d81298441a7621e6e6df69b21a/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_7.f90?ref=58691d4a04c2c8d81298441a7621e6e6df69b21a", "patch": "@@ -1,22 +0,0 @@\n-! { dg-do run }\n-!TODO: Move these testcases to gfortran testsuite\n-! once compilation with pthreads is supported there\n-! PR40008 F2008: Add NEWUNIT= for OPEN statement \n-! Contributed by Jerry DeLisle <jvdelisle@gcc.gnu.org>\n-program newunit_1\n-  character(len=25) :: str\n-  integer(1) :: myunit, myunit2\n-  myunit = 25\n-  str = \"bad\"\n-  open(newunit=myunit, status=\"scratch\")\n-  open(newunit = myunit2, file=\"newunit_1file\")\n-  write(myunit,'(e24.15e2)') 1.0d0\n-  write(myunit2,*) \"abcdefghijklmnop\"\n-  flush(myunit)\n-  rewind(myunit)\n-  rewind(myunit2)\n-  read(myunit2,'(a)') str\n-  if (str.ne.\" abcdefghijklmnop\") STOP 1\n-  close(myunit)\n-  close(myunit2, status=\"delete\")\n-end program newunit_1"}]}