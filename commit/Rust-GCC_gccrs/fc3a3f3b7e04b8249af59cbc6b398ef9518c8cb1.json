{"sha": "fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzYTNmM2I3ZTA0YjgyNDlhZjU5Y2JjNmIzOThlZjk1MThjOGNiMQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2014-07-29T13:03:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T13:03:49Z"}, "message": "einfo.ads, einfo.adb (Static_Real_Or_String_Predicate): New function\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, einfo.adb (Static_Real_Or_String_Predicate): New function\n\t(Set_Static_Real_Or_String_Predicate): New procedure\n\t* sem_ch13.adb (Build_Predicate_Functions): Accomodate static\n\tstring predicates (Is_Predicate_Static): Handle static string\n\tpredicates.\n\t* sem_eval.adb (Real_Or_String_Static_Predicate_Matches):\n\tNew procedure (Check_Expression_Against_Static_Predicate):\n\tDeal with static string predicates, now fully implemented\n\t(Eval_Relational_Op): Allow string equality/inequality as static\n\tif not comes from source.\n\nFrom-SVN: r213162", "tree": {"sha": "96eaf0caa622ad17bfc1d6319c02b1109f2c0ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96eaf0caa622ad17bfc1d6319c02b1109f2c0ead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/comments", "author": null, "committer": null, "parents": [{"sha": "60f908dd027ea9561239e46b55246da68839b18b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60f908dd027ea9561239e46b55246da68839b18b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60f908dd027ea9561239e46b55246da68839b18b"}], "stats": {"total": 281, "additions": 247, "deletions": 34}, "files": [{"sha": "9aa5cb098ca5802eac5777ad43535cfdc001dc19", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "patch": "@@ -1,3 +1,16 @@\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Static_Real_Or_String_Predicate): New function\n+\t(Set_Static_Real_Or_String_Predicate): New procedure\n+\t* sem_ch13.adb (Build_Predicate_Functions): Accomodate static\n+\tstring predicates (Is_Predicate_Static): Handle static string\n+\tpredicates.\n+\t* sem_eval.adb (Real_Or_String_Static_Predicate_Matches):\n+\tNew procedure (Check_Expression_Against_Static_Predicate):\n+\tDeal with static string predicates, now fully implemented\n+\t(Eval_Relational_Op): Allow string equality/inequality as static\n+\tif not comes from source.\n+\n 2014-07-29  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_aggr.adb, exp_ch5.adb, sem_ch5.adb, exp_util.adb, einfo.adb,"}, {"sha": "5da314a9ea4a6b167ffc74c5fed06464681337cd", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "patch": "@@ -223,6 +223,7 @@ package body Einfo is\n    --    PPC_Wrapper                     Node25\n    --    Related_Array_Object            Node25\n    --    Static_Discrete_Predicate       List25\n+   --    Static_Real_Or_String_Predicate Node25\n    --    Task_Body_Procedure             Node25\n \n    --    Dispatch_Table_Wrappers         Elist26\n@@ -2977,6 +2978,12 @@ package body Einfo is\n       return List25 (Id);\n    end Static_Discrete_Predicate;\n \n+   function Static_Real_Or_String_Predicate (Id : E) return N is\n+   begin\n+      pragma Assert (Is_Real_Type (Id) or else Is_String_Type (Id));\n+      return Node25 (Id);\n+   end Static_Real_Or_String_Predicate;\n+\n    function Status_Flag_Or_Transient_Decl (Id : E) return N is\n    begin\n       pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n@@ -5767,6 +5774,13 @@ package body Einfo is\n       Set_List25 (Id, V);\n    end Set_Static_Discrete_Predicate;\n \n+   procedure Set_Static_Real_Or_String_Predicate (Id : E; V : N) is\n+   begin\n+      pragma Assert ((Is_Real_Type (Id) or else Is_String_Type (Id))\n+                      and then Has_Predicates (Id));\n+      Set_Node25 (Id, V);\n+   end Set_Static_Real_Or_String_Predicate;\n+\n    procedure Set_Status_Flag_Or_Transient_Decl (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind_In (Id, E_Constant, E_Variable));\n@@ -9399,13 +9413,12 @@ package body Einfo is\n               E_Entry_Family                               =>\n             Write_Str (\"PPC_Wrapper\");\n \n-         when E_Enumeration_Type                           |\n-              E_Enumeration_Subtype                        |\n-              E_Modular_Integer_Type                       |\n-              E_Modular_Integer_Subtype                    |\n-              E_Signed_Integer_Subtype                     =>\n+         when Discrete_Kind                                =>\n             Write_Str (\"Static_Discrete_Predicate\");\n \n+         when Real_Kind                                    =>\n+            Write_Str (\"Static_Real_Or_String_Predicate\");\n+\n          when others                                       =>\n             Write_Str (\"Field25??\");\n       end case;"}, {"sha": "41f134cd03dd6e37d76277a85e35956492b32e8b", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "patch": "@@ -3899,7 +3899,7 @@ package Einfo is\n \n --    Static_Discrete_Predicate (List25)\n --       Defined in discrete types/subtypes with static predicates (with the\n---       two flags Has_Predicates set and Has_Static_Predicate set). Set if the\n+--       two flags Has_Predicates and Has_Static_Predicate set). Set if the\n --       type/subtype has a static predicate. Points to a list of expression\n --       and N_Range nodes that represent the predicate in canonical form. The\n --       canonical form has entries sorted in ascending order, with duplicates\n@@ -3908,6 +3908,26 @@ package Einfo is\n --       are fully analyzed and typed with the base type of the subtype. Note\n --       that all entries are static and have values within the subtype range.\n \n+--    Static_Real_Or_String_Predicate (Node25)\n+--       Defined in real types/subtypes with static predicates (with the two\n+--       flags Has_Predicates and Has_Static_Predicate set). Set if the type\n+--       or subtype has a static predicate. Points to the return expression\n+--       of the predicate function. This is the original expression given as\n+--       the predicate except that occurrences of the type are replaced by\n+--       occurrences of the formal parameter of the predicate function (note\n+--       that the spec of this function including this formal parameter name)\n+--       is available from the Subprograms_For_Type field (it can be accessed\n+--       as Predicate_Function (typ). Also, in the case where a predicate is\n+--       inherited, the expression is of the form:\n+--\n+--         expression AND THEN xxxPredicate (typ2 (ent))\n+--\n+--       where typ2 is the type from which the predicate is inherited, ent is\n+--       the entity for the current predicate function, and xxxPredicate is the\n+--       inherited predicate (from typ2). Finally for a predicate that inherits\n+--       from another predicate but does not add a predicate of its own, the\n+--       expression may consist of the above xxxPredicate call on its own.\n+\n --    Status_Flag_Or_Transient_Decl (Node15)\n --       Defined in variables and constants. Applies to objects that require\n --       special treatment by the finalization machinery, such as extended\n@@ -5452,6 +5472,7 @@ package Einfo is\n    --    Scalar_Range                        (Node20)\n    --    Delta_Value                         (Ureal18)\n    --    Small_Value                         (Ureal21)\n+   --    Static_Real_Or_String_Predicate     (Node25)\n    --    Has_Machine_Radix_Clause            (Flag83)\n    --    Machine_Radix_10                    (Flag84)\n    --    Aft_Value                           (synth)\n@@ -5557,6 +5578,7 @@ package Einfo is\n    --    Float_Rep                           (Uint10)   (Float_Rep_Kind)\n    --    Default_Aspect_Value                (Node19)   (base type only)\n    --    Scalar_Range                        (Node20)\n+   --    Static_Real_Or_String_Predicate     (Node25)\n    --    Machine_Emax_Value                  (synth)\n    --    Machine_Emin_Value                  (synth)\n    --    Machine_Mantissa_Value              (synth)\n@@ -5777,6 +5799,7 @@ package Einfo is\n    --    Delta_Value                         (Ureal18)\n    --    Default_Aspect_Value                (Node19)   (base type only)\n    --    Scalar_Range                        (Node20)\n+   --    Static_Real_Or_String_Predicate     (Node25)\n    --    Small_Value                         (Ureal21)\n    --    Has_Small_Clause                    (Flag67)\n    --    Aft_Value                           (synth)\n@@ -6048,6 +6071,7 @@ package Einfo is\n    --  E_String_Subtype\n    --    First_Index                         (Node17)\n    --    Component_Type                      (Node20)   (base type only)\n+   --    Static_Real_Or_String_Predicate     (Node25)\n    --    Is_Constrained                      (Flag12)\n    --    Next_Index                          (synth)\n    --    Number_Dimensions                   (synth)\n@@ -6791,6 +6815,7 @@ package Einfo is\n    function Static_Elaboration_Desired          (Id : E) return B;\n    function Static_Initialization               (Id : E) return N;\n    function Static_Discrete_Predicate           (Id : E) return S;\n+   function Static_Real_Or_String_Predicate     (Id : E) return N;\n    function Status_Flag_Or_Transient_Decl       (Id : E) return E;\n    function Storage_Size_Variable               (Id : E) return E;\n    function Stored_Constraint                   (Id : E) return L;\n@@ -7425,6 +7450,7 @@ package Einfo is\n    procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n    procedure Set_Static_Initialization           (Id : E; V : N);\n    procedure Set_Static_Discrete_Predicate       (Id : E; V : S);\n+   procedure Set_Static_Real_Or_String_Predicate (Id : E; V : N);\n    procedure Set_Status_Flag_Or_Transient_Decl   (Id : E; V : E);\n    procedure Set_Storage_Size_Variable           (Id : E; V : E);\n    procedure Set_Stored_Constraint               (Id : E; V : L);\n@@ -8209,6 +8235,7 @@ package Einfo is\n    pragma Inline (Static_Elaboration_Desired);\n    pragma Inline (Static_Initialization);\n    pragma Inline (Static_Discrete_Predicate);\n+   pragma Inline (Static_Real_Or_String_Predicate);\n    pragma Inline (Status_Flag_Or_Transient_Decl);\n    pragma Inline (Storage_Size_Variable);\n    pragma Inline (Stored_Constraint);\n@@ -8642,6 +8669,7 @@ package Einfo is\n    pragma Inline (Set_Static_Elaboration_Desired);\n    pragma Inline (Set_Static_Initialization);\n    pragma Inline (Set_Static_Discrete_Predicate);\n+   pragma Inline (Set_Static_Real_Or_String_Predicate);\n    pragma Inline (Set_Status_Flag_Or_Transient_Decl);\n    pragma Inline (Set_Storage_Size_Variable);\n    pragma Inline (Set_Stored_Constraint);"}, {"sha": "73dc3c5ec1e8964a427f998dd8b7c7c42a60bc70", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "patch": "@@ -8002,10 +8002,16 @@ package body Sem_Ch13 is\n          --  yes even if we have an explicit Dynamic_Predicate present.\n \n          declare\n-            PS : constant Boolean := Is_Predicate_Static (Expr, Object_Name);\n+            PS : Boolean;\n             EN : Node_Id;\n \n          begin\n+            if not Is_Scalar_Type (Typ) and then not Is_String_Type (Typ) then\n+               PS := False;\n+            else\n+               PS := Is_Predicate_Static (Expr, Object_Name);\n+            end if;\n+\n             --  Case where we have a predicate-static aspect\n \n             if PS then\n@@ -8033,6 +8039,11 @@ package body Sem_Ch13 is\n                   if No (Static_Discrete_Predicate (Typ)) then\n                      Set_Has_Static_Predicate (Typ, False);\n                   end if;\n+\n+               --  For real or string subtype, save predicate expression\n+\n+               elsif Is_Real_Type (Typ) or else Is_String_Type (Typ) then\n+                  Set_Static_Real_Or_String_Predicate (Typ, Expr);\n                end if;\n \n             --  Case of dynamic predicate (expression is not predicate-static)\n@@ -8060,14 +8071,13 @@ package body Sem_Ch13 is\n                --  Now post appropriate message\n \n                if Has_Static_Predicate_Aspect (Typ) then\n-                  if Is_Scalar_Type (Typ) then\n+                  if Is_Scalar_Type (Typ) or else Is_String_Type (Typ) then\n                      Error_Msg_F\n                        (\"expression is not predicate-static (RM 4.3.2(16-22))\",\n                         EN);\n                   else\n-                     Error_Msg_FE\n-                       (\"static predicate not allowed for non-scalar type&\",\n-                        EN, Typ);\n+                     Error_Msg_F\n+                       (\"static predicate requires scalar or string type\", EN);\n                   end if;\n                end if;\n             end if;\n@@ -10362,6 +10372,9 @@ package body Sem_Ch13 is\n    -- Is_Predicate_Static --\n    -------------------------\n \n+   --  Note: the basic legality of the expression has already been checked, so\n+   --  we don't need to worry about cases or ranges on strings for example.\n+\n    function Is_Predicate_Static\n      (Expr : Node_Id;\n       Nam  : Name_Id) return Boolean\n@@ -10462,12 +10475,6 @@ package body Sem_Ch13 is\n    --  Start of processing for Is_Predicate_Static\n \n    begin\n-      --  Only scalar types can be predicate-static\n-\n-      if not Is_Scalar_Type (Etype (Expr)) then\n-         return False;\n-      end if;\n-\n       --  Predicate_Static means one of the following holds. Numbers are the\n       --  corresponding paragraph numbers in (RM 3.2.4(16-22)).\n \n@@ -10502,7 +10509,20 @@ package body Sem_Ch13 is\n       --  operand is the current instance, and the other is a static\n       --  expression.\n \n+      --  Note: the RM is clearly wrong here in not excluding string types.\n+      --  Without this exclusion, we would allow expressions like X > \"ABC\"\n+      --  to be considered as predicate-static, which is clearly not intended,\n+      --  since the idea is for predicate-static to be a subset of normal\n+      --  static expressions (and \"DEF\" > \"ABC\" is not a static expression).\n+\n+      --  However, we do allow internally generated (not from source) equality\n+      --  and inequality operations to be valid on strings (this helps deal\n+      --  with cases where we transform A in \"ABC\" to A = \"ABC).\n+\n       elsif Nkind (Expr) in N_Op_Compare\n+        and then ((not Is_String_Type (Etype (Left_Opnd (Expr))))\n+                    or else (Nkind_In (Expr, N_Op_Eq, N_Op_Ne)\n+                              and then not Comes_From_Source (Expr)))\n         and then ((Is_Type_Ref (Left_Opnd (Expr))\n                     and then Is_OK_Static_Expression (Right_Opnd (Expr)))\n                   or else"}, {"sha": "44344ceaa5a316575039ff023200e59ff93103cf", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 156, "deletions": 17, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=fc3a3f3b7e04b8249af59cbc6b398ef9518c8cb1", "patch": "@@ -227,6 +227,16 @@ package body Sem_Eval is\n    --  this is an illegality if N is static, and should generate a warning\n    --  otherwise.\n \n+   function Real_Or_String_Static_Predicate_Matches\n+     (Val : Node_Id;\n+      Typ : Entity_Id) return Boolean;\n+   --  This is the function used to evaluate real or string static predicates.\n+   --  Val is an unanalyzed N_Real_Literal or N_String_Literal node, which\n+   --  represents the value to be tested against the predicate. Typ is the\n+   --  type with the predicate, from which the predicate expression can be\n+   --  extracted. The result returned is True if the given value satisfies\n+   --  the predicate.\n+\n    procedure Rewrite_In_Raise_CE (N : Node_Id; Exp : Node_Id);\n    --  N and Exp are nodes representing an expression, Exp is known to raise\n    --  CE. N is rewritten in term of Exp in the optimal way.\n@@ -339,23 +349,36 @@ package body Sem_Eval is\n       --  an explicitly specified Dynamic_Predicate whose expression met the\n       --  rules for being predicate-static).\n \n-      --  If we are not generating code, nothing more to do (why???)\n+      --  Case of real static predicate\n \n-      if Operating_Mode < Generate_Code then\n-         return;\n-      end if;\n+      if Is_Real_Type (Typ) then\n+         if Real_Or_String_Static_Predicate_Matches\n+              (Val => Make_Real_Literal (Sloc (Expr), Expr_Value_R (Expr)),\n+               Typ => Typ)\n+         then\n+            return;\n+         end if;\n \n-      --  If we have the real case, then for now, not implemented\n+      --  Case of string static predicate\n \n-      if not Is_Discrete_Type (Typ) then\n-         Error_Msg_N (\"??real predicate not applied\", Expr);\n-         return;\n-      end if;\n+      elsif Is_String_Type (Typ) then\n+         if Real_Or_String_Static_Predicate_Matches\n+           (Val => Expr_Value_S (Expr),\n+            Typ => Typ)\n+         then\n+            return;\n+         end if;\n \n-      --  If static predicate matches, nothing to do\n+      --  Case of discrete static predicate\n \n-      if Choices_Match (Expr, Static_Discrete_Predicate (Typ)) = Match then\n-         return;\n+      else\n+         pragma Assert (Is_Discrete_Type (Typ));\n+\n+         --  If static predicate matches, nothing to do\n+\n+         if Choices_Match (Expr, Static_Discrete_Predicate (Typ)) = Match then\n+            return;\n+         end if;\n       end if;\n \n       --  Here we know that the predicate will fail\n@@ -3052,6 +3075,10 @@ package body Sem_Eval is\n    --  both operands are static (RM 4.9(7), 4.9(20)), except that for strings,\n    --  the result is never static, even if the operands are.\n \n+   --  However, for internally generated nodes, we allow string equality and\n+   --  inequality to be static. This is because we rewrite A in \"ABC\" as an\n+   --  equality test A = \"ABC\", and the former is definitely static.\n+\n    procedure Eval_Relational_Op (N : Node_Id) is\n       Left   : constant Node_Id   := Left_Opnd (N);\n       Right  : constant Node_Id   := Right_Opnd (N);\n@@ -3289,9 +3316,16 @@ package body Sem_Eval is\n \n          --  Only comparisons of scalars can give static results. In\n          --  particular, comparisons of strings never yield a static\n-         --  result, even if both operands are static strings.\n+         --  result, even if both operands are static strings, except that\n+         --  as noted above, we allow equality/inequality for strings.\n+\n+         if Is_String_Type (Typ)\n+           and then not Comes_From_Source (N)\n+           and then Nkind_In (N, N_Op_Eq, N_Op_Ne)\n+         then\n+            null;\n \n-         if not Is_Scalar_Type (Typ) then\n+         elsif not Is_Scalar_Type (Typ) then\n             Is_Static_Expression := False;\n             Set_Is_Static_Expression (N, False);\n          end if;\n@@ -3307,9 +3341,8 @@ package body Sem_Eval is\n             Otype := Find_Universal_Operator_Type (N);\n          end if;\n \n-         --  For static real type expressions, we cannot use\n-         --  Compile_Time_Compare since it worries about run-time\n-         --  results which are not exact.\n+         --  For static real type expressions, do not use Compile_Time_Compare\n+         --  since it worries about run-time results which are not exact.\n \n          if Is_Static_Expression and then Is_Real_Type (Typ) then\n             declare\n@@ -5322,6 +5355,112 @@ package body Sem_Eval is\n       end if;\n    end Predicates_Match;\n \n+   ---------------------------------------------\n+   -- Real_Or_String_Static_Predicate_Matches --\n+   ---------------------------------------------\n+\n+   function Real_Or_String_Static_Predicate_Matches\n+     (Val : Node_Id;\n+      Typ : Entity_Id) return Boolean\n+   is\n+      Expr : constant Node_Id := Static_Real_Or_String_Predicate (Typ);\n+      --  The predicate expression from the type\n+\n+      Pfun : constant Entity_Id := Predicate_Function (Typ);\n+      --  The entity for the predicate function\n+\n+      Ent_Name : constant Name_Id := Chars (First_Formal (Pfun));\n+      --  The name of the formal of the predicate function. Occurrences of the\n+      --  type name in Expr have been rewritten as references to this formal,\n+      --  and it has a unique name, so we can identify references by this name.\n+\n+      Copy : Node_Id;\n+      --  Copy of the predicate function tree\n+\n+      function Process (N : Node_Id) return Traverse_Result;\n+      --  Function used to process nodes during the traversal in which we will\n+      --  find occurrences of the entity name, and replace such occurrences\n+      --  by a real literal with the value to be tested.\n+\n+      procedure Traverse is new Traverse_Proc (Process);\n+      --  The actual traversal procedure\n+\n+      -------------\n+      -- Process --\n+      -------------\n+\n+      function Process (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Identifier and then Chars (N) = Ent_Name then\n+            declare\n+               Nod : constant Node_Id := New_Copy (Val);\n+            begin\n+               Set_Sloc (Nod, Sloc (N));\n+               Rewrite (N, Nod);\n+               return Skip;\n+            end;\n+\n+         else\n+            return OK;\n+         end if;\n+      end Process;\n+\n+   --  Start of processing for Real_Or_String_Static_Predicate_Matches\n+\n+   begin\n+      --  First deal with special case of inherited predicate, where the\n+      --  predicate expression looks like:\n+\n+      --     Expr and then xxPredicate (typ (Ent))\n+\n+      --  where Expr is the predicate expression for this level, and the\n+      --  right operand is the call to evaluate the inherited predicate.\n+\n+      if Nkind (Expr) = N_And_Then\n+        and then Nkind (Right_Opnd (Expr)) = N_Function_Call\n+      then\n+         --  OK we have the inherited case, so make a call to evaluate the\n+         --  inherited predicate. If that fails, so do we!\n+\n+         if not\n+           Real_Or_String_Static_Predicate_Matches\n+             (Val => Val,\n+              Typ => Etype (First_Formal (Entity (Name (Right_Opnd (Expr))))))\n+         then\n+            return False;\n+         end if;\n+\n+         --  Use the left operand for the continued processing\n+\n+         Copy := Copy_Separate_Tree (Left_Opnd (Expr));\n+\n+      --  Case where call to predicate function appears on its own\n+\n+      elsif Nkind (Expr) =  N_Function_Call then\n+\n+         --  Here the result is just the result of calling the inner predicate\n+\n+         return\n+           Real_Or_String_Static_Predicate_Matches\n+             (Val => Val,\n+              Typ => Etype (First_Formal (Entity (Name (Expr)))));\n+\n+      --  If no inherited predicate, copy whole expression\n+\n+      else\n+         Copy := Copy_Separate_Tree (Expr);\n+      end if;\n+\n+      --  Now we replace occurrences of the entity by the value\n+\n+      Traverse (Copy);\n+\n+      --  And analyze the resulting static expression to see if it is True\n+\n+      Analyze_And_Resolve (Copy, Standard_Boolean);\n+      return Is_True (Expr_Value (Copy));\n+   end Real_Or_String_Static_Predicate_Matches;\n+\n    -------------------------\n    -- Rewrite_In_Raise_CE --\n    -------------------------"}]}