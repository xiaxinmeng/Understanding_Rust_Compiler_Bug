{"sha": "c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc0NDBkODhjNzJkYzMzY2E4YTUwYjk2YjhmNWIxM2M5MGY5ZTBiZg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-09-24T13:57:28Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Working on consolidating some other parsing functions", "tree": {"sha": "ececd09a5e5ca3d6a49bb0ccdaf403455f9745f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ececd09a5e5ca3d6a49bb0ccdaf403455f9745f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2109985cb4397f7133b46368e00a50e1630d765d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2109985cb4397f7133b46368e00a50e1630d765d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2109985cb4397f7133b46368e00a50e1630d765d"}], "stats": {"total": 379, "additions": 241, "deletions": 138}, "files": [{"sha": "72957df2e1435775deebb3e652de773daae1e3e8", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 235, "deletions": 138, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "patch": "@@ -2759,73 +2759,179 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n }\n \n /* Parses lifetime generic parameters (pointers). Will also consume any trailing\n- * comma. */\n+ * comma. No extra checks for end token. */\n template <typename ManagedTokenSource>\n std::vector<std::unique_ptr<AST::LifetimeParam> >\n Parser<ManagedTokenSource>::parse_lifetime_params ()\n {\n   std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n \n-  // TODO: think of better control structure than infinite loop with break on\n-  // failure?\n-  while (true)\n+  // if end_token is not specified, it defaults to EOF, so should work fine\n+  while (lexer.peek_token ()->get_id () != end_token)\n     {\n       AST::LifetimeParam lifetime_param = parse_lifetime_param ();\n \n       if (lifetime_param.is_error ())\n \t{\n-\t  // break if fails to parse\n+\t  // can't treat as error as only way to get out with trailing comma\n \t  break;\n \t}\n \n       lifetime_params.push_back (std::unique_ptr<AST::LifetimeParam> (\n-\tnew AST::LifetimeParam (lifetime_param)));\n+\tnew AST::LifetimeParam (std::move (lifetime_param))));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n \t  break;\n+\n+      // skip commas, including trailing commas\n+      lexer.skip_token ();\n+    }\n+\n+  lifetime_params.shrink_to_fit ();\n+\n+  return lifetime_params;\n+}\n+\n+/* Parses lifetime generic parameters (pointers). Will also consume any trailing\n+ * comma. Has extra is_end_token predicate checking. */\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<std::unique_ptr<AST::LifetimeParam> >\n+Parser<ManagedTokenSource>::parse_lifetime_params (EndTokenPred is_end_token)\n+{\n+  std::vector<std::unique_ptr<AST::LifetimeParam> > lifetime_params;\n+\n+  // if end_token is not specified, it defaults to EOF, so should work fine\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n+    {\n+      AST::LifetimeParam lifetime_param = parse_lifetime_param ();\n+\n+      if (lifetime_param.is_error ())\n+\t{\n+      // TODO: is it worth throwing away all lifetime params just because one failed?\n+      rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse lifetime param in lifetime params\");\n+      return {};\n \t}\n+\n+      lifetime_params.push_back (std::unique_ptr<AST::LifetimeParam> (\n+\tnew AST::LifetimeParam (std::move (lifetime_param))));\n+\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\t  break;\n+\n       // skip commas, including trailing commas\n       lexer.skip_token ();\n     }\n \n+  lifetime_params.shrink_to_fit ();\n+\n   return lifetime_params;\n }\n \n /* Parses lifetime generic parameters (objects). Will also consume any trailing\n- * comma.\n+ * comma. No extra checks for end token.\n  * TODO: is this best solution? implements most of the same algorithm. */\n template <typename ManagedTokenSource>\n std::vector<AST::LifetimeParam>\n Parser<ManagedTokenSource>::parse_lifetime_params_objs ()\n {\n   std::vector<AST::LifetimeParam> lifetime_params;\n \n-  // TODO: think of better control structure than infinite loop with break on\n-  // failure?\n+  // bad control structure as end token cannot be guaranteed\n   while (true)\n     {\n       AST::LifetimeParam lifetime_param = parse_lifetime_param ();\n \n       if (lifetime_param.is_error ())\n \t{\n-\t  // break if fails to parse\n+    // not an error as only way to exit if trailing comma\n \t  break;\n \t}\n \n-      lifetime_params.push_back (lifetime_param);\n+      lifetime_params.push_back (std::move (lifetime_param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n \t  break;\n+\n+      // skip commas, including trailing commas\n+      lexer.skip_token ();\n+    }\n+\n+  lifetime_params.shrink_to_fit ();\n+\n+  return lifetime_params;\n+}\n+\n+/* Parses lifetime generic parameters (objects). Will also consume any trailing\n+ * comma. Has extra is_end_token predicate checking.\n+ * TODO: is this best solution? implements most of the same algorithm. */\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<AST::LifetimeParam>\n+Parser<ManagedTokenSource>::parse_lifetime_params_objs (EndTokenPred is_end_token)\n+{\n+  std::vector<AST::LifetimeParam> lifetime_params;\n+\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n+    {\n+      AST::LifetimeParam lifetime_param = parse_lifetime_param ();\n+\n+      if (lifetime_param.is_error ())\n+\t{\n+      // TODO: is it worth throwing away all lifetime params just because one failed?\n+      rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse lifetime param in lifetime params\");\n+      return {};\n \t}\n+\n+      lifetime_params.push_back (std::move (lifetime_param));\n+\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\t  break;\n+\n       // skip commas, including trailing commas\n       lexer.skip_token ();\n     }\n \n+  lifetime_params.shrink_to_fit ();\n+\n   return lifetime_params;\n }\n \n+/* Parses various types of generic parameters (templated). Will also consume any trailing\n+ * comma. Has extra is_end_token predicate checking.\n+ * TODO: is this best solution? implements most of the same algorithm. */\n+template <typename ManagedTokenSource>\n+template <typename ParseFunction, typename EndTokenPred>\n+auto\n+Parser<ManagedTokenSource>::parse_generic_params (ParseFunction parsing_function, EndTokenPred is_end_token, std::string error_msg) -> std::vector<decltype(parsing_function ())>\n+{\n+  std::vector<decltype(parsing_function ())> params;\n+\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n+    {\n+      auto param = parsing_function ();\n+\n+      if (param.is_error ())\n+\t{\n+      // TODO: is it worth throwing away all params just because one failed?\n+      rust_error_at (lexer.peek_token ()->get_locus (), error_msg.c_str ());\n+      return {};\n+\t}\n+\n+      params.push_back (std::move (param));\n+\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\t  break;\n+\n+      // skip commas, including trailing commas\n+      lexer.skip_token ();\n+    }\n+\n+  params.shrink_to_fit ();\n+\n+  return params;\n+}\n+\n /* Parses a single lifetime generic parameter (not including comma). */\n template <typename ManagedTokenSource>\n AST::LifetimeParam\n@@ -2841,8 +2947,8 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n       // if lifetime is missing, must not be a lifetime param, so return null\n       return AST::LifetimeParam::create_error ();\n     }\n-  // TODO: does this always create a named lifetime? or can a different type be\n-  // made?\n+  /* TODO: does this always create a named lifetime? or can a different type be\n+   * made? */\n   AST::Lifetime lifetime (AST::Lifetime::NAMED, lifetime_tok->get_str (),\n \t\t\t  lifetime_tok->get_locus ());\n \n@@ -3199,7 +3305,8 @@ Parser<ManagedTokenSource>::parse_for_lifetimes ()\n       return params;\n     }\n \n-  params = parse_lifetime_params_objs ();\n+  // cannot specify end token due to parsing problems with '>' tokens being nested\n+  params = parse_lifetime_params_objs (is_right_angle_tok);\n \n   if (!skip_generics_right_angle ())\n     {\n@@ -5546,6 +5653,8 @@ Parser<ManagedTokenSource>::parse_type_path ()\n       t = lexer.peek_token ();\n     }\n \n+  segments.shrink_to_fit ();\n+\n   return AST::TypePath (std::move (segments), Linemap::unknown_location (),\n \t\t\thas_opening_scope_resolution);\n }\n@@ -5654,14 +5763,14 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \n   // skip any trailing commas\n   if (lexer.peek_token ()->get_id () == COMMA)\n-    {\n       lexer.skip_token ();\n-    }\n \n   if (!skip_generics_right_angle ())\n-    {\n       return AST::GenericArgs::create_empty ();\n-    }\n+\n+  lifetime_args.shrink_to_fit ();\n+  type_args.shrink_to_fit ();\n+  binding_args.shrink_to_fit ();\n \n   return AST::GenericArgs (std::move (lifetime_args), std::move (type_args),\n \t\t\t   std::move (binding_args), locus);\n@@ -5716,8 +5825,8 @@ Parser<ManagedTokenSource>::parse_type_path_segment ()\n       return nullptr;\n     }\n \n-  // lookahead to determine if variants exist - only consume scope resolution\n-  // then\n+  /* lookahead to determine if variants exist - only consume scope resolution\n+   * then */\n   bool has_separating_scope_resolution = false;\n   const_TokenPtr next = lexer.peek_token (1);\n   if (lexer.peek_token ()->get_id () == SCOPE_RESOLUTION\n@@ -5779,27 +5888,24 @@ Parser<ManagedTokenSource>::parse_type_path_function ()\n   // parse function inputs\n   std::vector<std::unique_ptr<AST::Type> > inputs;\n \n-  // TODO: think of better control structure\n-  while (true)\n+  while (lexer.peek_token ()->get_id () != RIGHT_PAREN)\n     {\n       std::unique_ptr<AST::Type> type = parse_type ();\n       if (type == nullptr)\n \t{\n-\t  // not necessarily an error\n-\t  break;\n+\t  // this is an error as there should've been a ')' there if there wasn't a type\n+    rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse type in parameters of type path function\");\n+    // skip somewhere?\n+    return AST::TypePathFunction::create_error ();\n \t}\n \n       inputs.push_back (std::move (type));\n \n       // skip commas, including trailing commas\n       if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n \t  break;\n-\t}\n-      else\n-\t{\n+\n \t  lexer.skip_token ();\n-\t}\n     }\n \n   if (!skip_token (RIGHT_PAREN))\n@@ -5870,6 +5976,8 @@ Parser<ManagedTokenSource>::parse_path_in_expression ()\n       t = lexer.peek_token ();\n     }\n \n+  segments.shrink_to_fit ();\n+\n   return AST::PathInExpression (std::move (segments), locus,\n \t\t\t\thas_opening_scope_resolution,\n \t\t\t\tstd::vector<AST::Attribute> ());\n@@ -5993,8 +6101,8 @@ AST::QualifiedPathType\n Parser<ManagedTokenSource>::parse_qualified_path_type (bool pratt_parse)\n {\n   Location locus = Linemap::unknown_location ();\n-  // TODO: should this actually be error? is there anywhere where this could be\n-  // valid?\n+  /* TODO: should this actually be error? is there anywhere where this could be\n+   * valid? */\n   if (!pratt_parse)\n     {\n       locus = lexer.peek_token ()->get_locus ();\n@@ -6038,8 +6146,8 @@ Parser<ManagedTokenSource>::parse_qualified_path_type (bool pratt_parse)\n \t}\n     }\n \n-  // NOTE: should actually be a right-angle token, so skip_generics_right_angle\n-  // shouldn't be required\n+  /* NOTE: should actually be a right-angle token, so skip_generics_right_angle\n+   * shouldn't be required */\n   if (!skip_token (RIGHT_ANGLE))\n     {\n       // skip after somewhere?\n@@ -6066,6 +6174,7 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_type ()\n \n   // parse path segments\n   std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  segments.reserve (1);\n \n   // parse initial required segment\n   if (!expect_token (SCOPE_RESOLUTION))\n@@ -6110,6 +6219,8 @@ Parser<ManagedTokenSource>::parse_qualified_path_in_type ()\n       t = lexer.peek_token ();\n     }\n \n+  segments.shrink_to_fit ();\n+\n   return AST::QualifiedPathInType (std::move (qual_path_type),\n \t\t\t\t   std::move (segments), locus);\n }\n@@ -6211,8 +6322,8 @@ AST::Method\n Parser<ManagedTokenSource>::parse_method ()\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n-  // Note: as a result of the above, this will not attempt to disambiguate a\n-  // function parse qualifiers\n+  /* Note: as a result of the above, this will not attempt to disambiguate a\n+   * function parse qualifiers */\n   AST::FunctionQualifiers qualifiers = parse_function_qualifiers ();\n \n   skip_token (FN_TOK);\n@@ -6250,9 +6361,7 @@ Parser<ManagedTokenSource>::parse_method ()\n \n   // skip comma if it exists\n   if (lexer.peek_token ()->get_id () == COMMA)\n-    {\n       lexer.skip_token ();\n-    }\n \n   // parse function parameters\n   std::vector<AST::FunctionParam> function_params = parse_function_params ();\n@@ -7316,13 +7425,9 @@ Parser<ManagedTokenSource>::parse_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-    {\n       locus = lexer.peek_token ()->get_locus ();\n-    }\n   else\n-    {\n       locus = label.get_locus ();\n-    }\n   skip_token (LOOP);\n \n   // parse loop body, which is required\n@@ -7348,13 +7453,9 @@ Parser<ManagedTokenSource>::parse_while_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-    {\n       locus = lexer.peek_token ()->get_locus ();\n-    }\n   else\n-    {\n       locus = label.get_locus ();\n-    }\n   skip_token (WHILE);\n \n   // ensure it isn't a while let loop\n@@ -7379,8 +7480,8 @@ Parser<ManagedTokenSource>::parse_while_loop_expr (\n       // skip somewhere?\n       return nullptr;\n     }\n-  // TODO: check that it isn't struct expression here? actually, probably in\n-  // semantic analysis\n+  /* TODO: check that it isn't struct expression here? actually, probably in\n+   * semantic analysis */\n \n   // parse loop body (required)\n   std::unique_ptr<AST::BlockExpr> body = parse_block_expr ();\n@@ -7407,17 +7508,13 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-    {\n       locus = lexer.peek_token ()->get_locus ();\n-    }\n   else\n-    {\n       locus = label.get_locus ();\n-    }\n   skip_token (WHILE);\n \n-  // check for possible accidental recognition of a while loop as a while let\n-  // loop\n+  /* check for possible accidental recognition of a while loop as a while let\n+   * loop */\n   if (lexer.peek_token ()->get_id () != LET)\n     {\n       rust_error_at (lexer.peek_token ()->get_locus (),\n@@ -7440,8 +7537,8 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n       return nullptr;\n     }\n \n-  // parse predicate expression, which is required (and HACK to prevent struct\n-  // expr)\n+  /* parse predicate expression, which is required (and HACK to prevent struct\n+   * expr) */\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n   std::unique_ptr<AST::Expr> predicate_expr\n@@ -7453,8 +7550,8 @@ Parser<ManagedTokenSource>::parse_while_let_loop_expr (\n       // skip somewhere?\n       return nullptr;\n     }\n-  // TODO: ensure that struct expression is not parsed? Actually, probably in\n-  // semantic analysis.\n+  /* TODO: ensure that struct expression is not parsed? Actually, probably in\n+   * semantic analysis. */\n \n   // parse loop body, which is required\n   std::unique_ptr<AST::BlockExpr> body = parse_block_expr ();\n@@ -7481,13 +7578,9 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (\n {\n   Location locus = Linemap::unknown_location ();\n   if (label.is_error ())\n-    {\n       locus = lexer.peek_token ()->get_locus ();\n-    }\n   else\n-    {\n       locus = label.get_locus ();\n-    }\n   skip_token (FOR);\n \n   // parse pattern, which is required\n@@ -7506,8 +7599,8 @@ Parser<ManagedTokenSource>::parse_for_loop_expr (\n       return nullptr;\n     }\n \n-  // parse iterator expression, which is required - also HACK to prevent struct\n-  // expr\n+  /* parse iterator expression, which is required - also HACK to prevent struct\n+   * expr */\n   ParseRestrictions no_struct_expr;\n   no_struct_expr.can_be_struct_expr = false;\n   std::unique_ptr<AST::Expr> expr\n@@ -7724,6 +7817,8 @@ Parser<ManagedTokenSource>::parse_match_expr (\n       return nullptr;\n     }\n \n+  match_arms.shrink_to_fit ();\n+\n   return std::unique_ptr<AST::MatchExpr> (\n     new AST::MatchExpr (std::move (scrutinee), std::move (match_arms),\n \t\t\tstd::move (inner_attrs), std::move (outer_attrs),\n@@ -7852,6 +7947,8 @@ Parser<ManagedTokenSource>::parse_match_arm_patterns (TokenId end_token_id)\n       t = lexer.peek_token ();\n     }\n \n+  patterns.shrink_to_fit ();\n+\n   return patterns;\n }\n \n@@ -7986,7 +8083,9 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \t{\n \t  // single-element array expression\n \t  std::vector<std::unique_ptr<AST::Expr> > exprs;\n+    exprs.reserve (1);\n \t  exprs.push_back (std::move (initial_expr));\n+    exprs.shrink_to_fit ();\n \n \t  std::unique_ptr<AST::ArrayElemsValues> array_elems (\n \t    new AST::ArrayElemsValues (std::move (exprs)));\n@@ -8028,6 +8127,8 @@ Parser<ManagedTokenSource>::parse_array_expr (\n \n \t  skip_token (RIGHT_SQUARE);\n \n+    exprs.shrink_to_fit ();\n+\n \t  std::unique_ptr<AST::ArrayElemsValues> array_elems (\n \t    new AST::ArrayElemsValues (std::move (exprs)));\n \t  return std::unique_ptr<AST::ArrayExpr> (\n@@ -8262,8 +8363,8 @@ Parser<ManagedTokenSource>::parse_type ()\n       // reference type\n       return parse_reference_type ();\n       case LIFETIME: {\n-\t// probably a lifetime bound, so probably type param bounds in\n-\t// TraitObjectType\n+\t/* probably a lifetime bound, so probably type param bounds in\n+\t * TraitObjectType */\n \tstd::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n \t  = parse_type_param_bounds ();\n \n@@ -8332,8 +8433,8 @@ Parser<ManagedTokenSource>::parse_type ()\n \t\tnew AST::TraitBound (std::move (path), locus, false, false));\n \t      bounds.push_back (std::move (path_bound));\n \n-\t      // parse rest of bounds - FIXME: better way to find when to stop\n-\t      // parsing\n+\t      /* parse rest of bounds - FIXME: better way to find when to stop\n+\t       * parsing */\n \t      while (t->get_id () == PLUS)\n \t\t{\n \t\t  lexer.skip_token ();\n@@ -8360,9 +8461,9 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  }\n       }\n     case LEFT_PAREN:\n-      // tuple type or parenthesised type - requires further disambiguation (the\n-      // usual) ok apparently can be a parenthesised TraitBound too, so could be\n-      // TraitObjectTypeOneBound or TraitObjectType\n+      /* tuple type or parenthesised type - requires further disambiguation (the\n+       * usual). ok apparently can be a parenthesised TraitBound too, so could be\n+       * TraitObjectTypeOneBound or TraitObjectType */\n       return parse_paren_prefixed_type ();\n     case FOR:\n       // TraitObjectTypeOneBound or BareFunctionType\n@@ -8378,8 +8479,8 @@ Parser<ManagedTokenSource>::parse_type ()\n       lexer.skip_token ();\n       if (lexer.peek_token ()->get_id () == LIFETIME)\n \t{\n-\t  // cannot be one bound because lifetime prevents it from being\n-\t  // traitbound\n+\t  /* cannot be one bound because lifetime prevents it from being\n+\t   * traitbound */\n \t  std::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n \t    = parse_type_param_bounds ();\n \n@@ -8449,8 +8550,8 @@ Parser<ManagedTokenSource>::parse_type ()\n \n \tif (lexer.peek_token ()->get_id () == LIFETIME)\n \t  {\n-\t    // cannot be one bound because lifetime prevents it from being\n-\t    // traitbound\n+\t    /* cannot be one bound because lifetime prevents it from being\n+\t     * traitbound */\n \t    std::vector<std::unique_ptr<AST::TypeParamBound> > bounds\n \t      = parse_type_param_bounds ();\n \n@@ -8537,8 +8638,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n \n   // skip left delim\n   lexer.skip_token ();\n-  // while next token isn't close delim, parse comma-separated types, saving\n-  // whether trailing comma happens\n+  /* while next token isn't close delim, parse comma-separated types, saving\n+   * whether trailing comma happens */\n   const_TokenPtr t = lexer.peek_token ();\n   bool trailing_comma = true;\n   std::vector<std::unique_ptr<AST::Type> > types;\n@@ -8620,8 +8721,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n \t{\n \t  // release vector pointer\n \t  std::unique_ptr<AST::Type> released_ptr (types[0].release ());\n-\t  // HACK: attempt to convert to trait bound. if fails, parenthesised\n-\t  // type\n+\t  /* HACK: attempt to convert to trait bound. if fails, parenthesised\n+\t   * type */\n \t  std::unique_ptr<AST::TraitBound> converted_bound (\n \t    released_ptr->to_trait_bound (true));\n \t  if (converted_bound == nullptr)\n@@ -8656,8 +8757,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n       return std::unique_ptr<AST::TupleType> (\n \tnew AST::TupleType (std::move (types), left_delim_locus));\n     }\n-  // TODO: ensure that this ensures that dynamic dispatch for traits is not lost\n-  // somehow\n+  /* TODO: ensure that this ensures that dynamic dispatch for traits is not lost\n+   * somehow */\n }\n \n /* Parses a type that has 'for' as its first character. This means it has a \"for\n@@ -8705,8 +8806,8 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n \t      new AST::TraitObjectTypeOneBound (std::move (bound), for_locus));\n \t  }\n \n-\t// more than one bound trait type (or at least parsed as it - could be\n-\t// trailing '+') create trait bound pointer and bounds\n+\t/* more than one bound trait type (or at least parsed as it - could be\n+\t * trailing '+') create trait bound pointer and bounds */\n \tstd::unique_ptr<AST::TraitBound> initial_bound (\n \t  new AST::TraitBound (std::move (path), for_locus, false, false,\n \t\t\t       std::move (for_lifetimes)));\n@@ -9063,9 +9164,9 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n       // reference type\n       return parse_reference_type ();\n       case LIFETIME: {\n-\t// probably a lifetime bound, so probably type param bounds in\n-\t// TraitObjectType this is not allowed, but detection here for error\n-\t// message\n+\t/* probably a lifetime bound, so probably type param bounds in\n+\t * TraitObjectType. this is not allowed, but detection here for error\n+\t * message */\n \trust_error_at (t->get_locus (),\n \t\t       \"lifetime bounds (i.e. in type param bounds, in \"\n \t\t       \"TraitObjectType) are not allowed as TypeNoBounds\");\n@@ -9139,9 +9240,9 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \t  }\n       }\n     case LEFT_PAREN:\n-      // tuple type or parenthesised type - requires further disambiguation (the\n-      // usual) ok apparently can be a parenthesised TraitBound too, so could be\n-      // TraitObjectTypeOneBound\n+      /* tuple type or parenthesised type - requires further disambiguation (the\n+       * usual). ok apparently can be a parenthesised TraitBound too, so could be\n+       * TraitObjectTypeOneBound */\n       return parse_paren_prefixed_type_no_bounds ();\n     case FOR:\n     case ASYNC:\n@@ -9155,9 +9256,9 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n       lexer.skip_token ();\n       if (lexer.peek_token ()->get_id () == LIFETIME)\n \t{\n-\t  // cannot be one bound because lifetime prevents it from being\n-\t  // traitbound not allowed as type no bounds, only here for error\n-\t  // message\n+\t  /* cannot be one bound because lifetime prevents it from being\n+\t   * traitbound not allowed as type no bounds, only here for error\n+\t   * message */\n \t  rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t\t \"lifetime (probably lifetime bound, in type param \"\n \t\t\t \"bounds, in ImplTraitType) is \"\n@@ -9208,8 +9309,8 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \n \tif (lexer.peek_token ()->get_id () == LIFETIME)\n \t  {\n-\t    // means that cannot be TraitObjectTypeOneBound - so here for error\n-\t    // message\n+\t    /* means that cannot be TraitObjectTypeOneBound - so here for error\n+\t     * message */\n \t    rust_error_at (lexer.peek_token ()->get_locus (),\n \t\t\t   \"lifetime as bound in TraitObjectTypeOneBound \"\n \t\t\t   \"is not allowed, so cannot be TypeNoBounds\");\n@@ -9272,8 +9373,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n \n   // skip left delim\n   lexer.skip_token ();\n-  // while next token isn't close delim, parse comma-separated types, saving\n-  // whether trailing comma happens\n+  /* while next token isn't close delim, parse comma-separated types, saving\n+   * whether trailing comma happens */\n   const_TokenPtr t = lexer.peek_token ();\n   bool trailing_comma = true;\n   std::vector<std::unique_ptr<AST::Type> > types;\n@@ -9322,8 +9423,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n \t{\n \t  // release vector pointer\n \t  std::unique_ptr<AST::Type> released_ptr (types[0].release ());\n-\t  // HACK: attempt to convert to trait bound. if fails, parenthesised\n-\t  // type\n+\t  /* HACK: attempt to convert to trait bound. if fails, parenthesised\n+\t   * type */\n \t  std::unique_ptr<AST::TraitBound> converted_bound (\n \t    released_ptr->to_trait_bound (true));\n \t  if (converted_bound == nullptr)\n@@ -9358,8 +9459,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type_no_bounds ()\n       return std::unique_ptr<AST::TupleType> (\n \tnew AST::TupleType (std::move (types), left_paren_locus));\n     }\n-  // TODO: ensure that this ensures that dynamic dispatch for traits is not lost\n-  // somehow\n+  /* TODO: ensure that this ensures that dynamic dispatch for traits is not lost\n+   * somehow */\n }\n \n /* Parses a literal pattern or range pattern. Assumes that literals passed in\n@@ -9410,9 +9511,7 @@ Parser<ManagedTokenSource>::parse_literal_or_range_pattern ()\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n \t\t\t \"token type '%s' cannot be parsed as range pattern \"\n-\t\t\t \"bound or literal after \"\n-\t\t\t \"minus \"\n-\t\t\t \"symbol\",\n+\t\t\t \"bound or literal after minus symbol\",\n \t\t\t range_lower->get_token_description ());\n \t  return nullptr;\n \t}\n@@ -9515,8 +9614,7 @@ Parser<ManagedTokenSource>::parse_range_pattern_bound ()\n \tdefault:\n \t  rust_error_at (range_lower->get_locus (),\n \t\t\t \"token type '%s' cannot be parsed as range pattern \"\n-\t\t\t \"bound after minus \"\n-\t\t\t \"symbol\",\n+\t\t\t \"bound after minus symbol\",\n \t\t\t range_lower->get_token_description ());\n \t  return nullptr;\n \t}\n@@ -9616,9 +9714,9 @@ Parser<ManagedTokenSource>::parse_pattern ()\n     case MUT:\n       return parse_identifier_pattern ();\n     case IDENTIFIER:\n-      // if identifier with no scope resolution afterwards, identifier pattern.\n-      // if scope resolution afterwards, path pattern (or range pattern or\n-      // struct pattern or tuple struct pattern) or macro invocation\n+      /* if identifier with no scope resolution afterwards, identifier pattern.\n+       * if scope resolution afterwards, path pattern (or range pattern or\n+       * struct pattern or tuple struct pattern) or macro invocation */\n       return parse_ident_leading_pattern ();\n     case AMP:\n     case LOGICAL_AND:\n@@ -10394,9 +10492,9 @@ Parser<ManagedTokenSource>::parse_struct_pattern_elems ()\n       t = lexer.peek_token ();\n     }\n \n-  // FIXME: this method of parsing prevents parsing any outer attributes on the\n-  // .. also there seems to be no distinction between having etc and not having\n-  // etc.\n+  /* FIXME: this method of parsing prevents parsing any outer attributes on the\n+   * .. - also there seems to be no distinction between having etc and not having\n+   * etc. */\n   if (lexer.peek_token ()->get_id () == DOT_DOT)\n     {\n       lexer.skip_token ();\n@@ -10591,9 +10689,9 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n        * separate it from the good code. */\n       // case UNION:\n       case UNSAFE: { // maybe - unsafe traits are a thing\n-\t// if any of these (should be all possible VisItem prefixes), parse a\n-\t// VisItem can't parse item because would require reparsing outer\n-\t// attributes\n+\t/* if any of these (should be all possible VisItem prefixes), parse a\n+\t * VisItem - can't parse item because would require reparsing outer\n+\t * attributes */\n \tconst_TokenPtr t2 = lexer.peek_token (1);\n \tswitch (t2->get_id ())\n \t  {\n@@ -10755,8 +10853,8 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n       gcc_fallthrough ();\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n       default: {\n-\t// expression statement (without block) or expression itself - parse\n-\t// expression then make it statement if semi afterwards\n+\t/* expression statement (without block) or expression itself - parse\n+\t * expression then make it statement if semi afterwards */\n \n \tstd::unique_ptr<AST::ExprWithoutBlock> expr\n \t  = parse_expr_without_block ();\n@@ -10869,8 +10967,7 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t     * unless a semicolon is explicitly put at the end. this is not\n \t     * necessarily true (i.e. context-dependence) and so may have to be\n \t     * fixed up via HACKs in semantic analysis (by checking whether it\n-\t     * is the last elem in the vector).\n-\t     */\n+\t     * is the last elem in the vector). */\n \n \t    if (lexer.peek_token ()->get_id () == SEMICOLON)\n \t      {\n@@ -11407,8 +11504,8 @@ std::unique_ptr<AST::Expr>\n Parser<ManagedTokenSource>::parse_expr (std::vector<AST::Attribute> outer_attrs,\n \t\t\t\t\tParseRestrictions restrictions)\n {\n-  // HACK: only call parse_expr(LBP_LOWEST) after ensuring it is not an\n-  // expression with block?\n+  /* HACK: only call parse_expr(LBP_LOWEST) after ensuring it is not an\n+   * expression with block? */\n   return parse_expr (LBP_LOWEST, std::move (outer_attrs), restrictions);\n }\n \n@@ -11443,14 +11540,14 @@ Parser<ManagedTokenSource>::null_denotation (\n \t  // expression is just its VAR_DECL that was stored in the Symbol at\n       declaration return Tree(s->get_tree_decl(), tok->get_locus());\n       }*/\n-      // symbol table must be created in semantic analysis pass, so can't use\n-      // this\n+      /* symbol table must be created in semantic analysis pass, so can't use\n+       * this */\n       case IDENTIFIER: {\n \t// DEBUG\n \tfprintf (stderr, \"beginning null denotation identifier handling\\n\");\n \n-\t// best option: parse as path, then extract identifier, macro,\n-\t// struct/enum, or just path info from it\n+\t/* best option: parse as path, then extract identifier, macro,\n+\t * struct/enum, or just path info from it */\n \tAST::PathInExpression path = parse_path_in_expression_pratt (tok);\n \n \t// DEBUG:\n@@ -11496,9 +11593,9 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\t  // assume path is returned if not single segment\n \t\t  if (path.is_single_segment ())\n \t\t    {\n-\t\t      // have to return an identifier expression or something,\n-\t\t      // idk HACK: may have to become permanent, but this is my\n-\t\t      // current identifier expression\n+\t\t      // have to return an identifier expression or something\n+          /* HACK: may have to become permanent, but this is my\n+\t\t       * current identifier expression */\n \t\t      return std::unique_ptr<AST::IdentifierExpr> (\n \t\t\tnew AST::IdentifierExpr (tok->get_str (),\n \t\t\t\t\t\t tok->get_locus ()));\n@@ -11519,8 +11616,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \t\tif (path.is_single_segment ())\n \t\t  {\n \t\t    // have to return an identifier expression or something, idk\n-\t\t    // HACK: may have to become permanent, but this is my\n-\t\t    // current identifier expression\n+\t\t    /* HACK: may have to become permanent, but this is my\n+\t\t     * current identifier expression */\n \t\t    return std::unique_ptr<AST::IdentifierExpr> (\n \t\t      new AST::IdentifierExpr (tok->get_str (),\n \t\t\t\t\t       tok->get_locus ()));\n@@ -11537,8 +11634,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \t    if (path.is_single_segment ())\n \t      {\n \t\t// have to return an identifier expression or something, idk\n-\t\t// HACK: may have to become permanent, but this is my current\n-\t\t// identifier expression\n+\t\t/* HACK: may have to become permanent, but this is my current\n+\t\t * identifier expression */\n \t\treturn std::unique_ptr<AST::IdentifierExpr> (\n \t\t  new AST::IdentifierExpr (tok->get_str (), tok->get_locus ()));\n \t      }\n@@ -11549,10 +11646,10 @@ Parser<ManagedTokenSource>::null_denotation (\n \t  }\n \tgcc_unreachable ();\n       }\n-      // FIXME: delegate to parse_literal_expr instead? would have to rejig\n-      // tokens and whatever.\n-      // FIXME: could also be path expression (and hence macro expression,\n-      // struct/enum expr)\n+      /* FIXME: delegate to parse_literal_expr instead? would have to rejig\n+       * tokens and whatever. */\n+      /* FIXME: could also be path expression (and hence macro expression,\n+       * struct/enum expr) */\n       case LEFT_ANGLE: {\n \t// qualified path\n \t// HACK: add outer attrs to path\n@@ -11658,8 +11755,8 @@ Parser<ManagedTokenSource>::null_denotation (\n \t      print_type(expr.get_type()));\n \t    return Tree::error();\n \t}*/\n-\t// FIXME: type checking for boolean or integer expressions in semantic\n-\t// analysis\n+\t/* FIXME: type checking for boolean or integer expressions in semantic\n+\t * analysis */\n \n \t// FIXME: allow outer attributes on these expressions\n \treturn std::unique_ptr<AST::NegationExpr> ("}, {"sha": "c1055004ad66f385d4a4b3e574262464e3791055", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=c7440d88c72dc33ca8a50b96b8f5b13c90f9e0bf", "patch": "@@ -150,7 +150,13 @@ template <typename ManagedTokenSource> class Parser\n   parse_generic_params_in_angles ();\n   std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n+  template <typename EndTokenPred>\n+  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params (EndTokenPred is_end_token);\n   std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::LifetimeParam> parse_lifetime_params_objs (EndTokenPred is_end_token);\n+  template <typename ParseFunction, typename EndTokenPred>\n+  auto parse_generic_params (ParseFunction parsing_function, EndTokenPred is_end_token, std::string error_msg = \"failed to parse generic param in generic params\") -> std::vector<decltype(parsing_function ())>;\n   AST::LifetimeParam parse_lifetime_param ();\n   std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params ();\n   std::unique_ptr<AST::TypeParam> parse_type_param ();"}]}