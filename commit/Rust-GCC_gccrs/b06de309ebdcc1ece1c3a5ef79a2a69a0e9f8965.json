{"sha": "b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "node_id": "C_kwDOANBUbNoAKGIwNmRlMzA5ZWJkY2MxZWNlMWMzYTVlZjc5YTJhNjlhMGU5Zjg5NjU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-18T21:00:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-18T21:00:27Z"}, "message": "Merge #841\n\n841: Add support for enums on the match expression r=philberty a=philberty\n\nThis adds in the initial support MatchExpression which allows us to start testing much\r\nmore complex rust code. Ideally we can now start targeing the #682 to find nasty bugs\r\nearly as possible.\r\n\r\nThis takes the MatchExpr and generates a SWITCH_EXPR with associated\r\nCASE_LABEL_EXPR's for the variants that the qualifier contains.\r\n\r\nTo improve this support in order to take advantage of SWITCH_ALL_CASES_P\r\nto add error checking for all cases being covered. This will require changes\r\nto the enum data structure to use ENUMERAL_TYPES instead of the flat i64\r\nso the enumerable type contains the list of all possible permutations.\r\n\r\nThis patch is the first pass at the MatchExpr as the patch is already pretty\r\nlarge and serves as a base to move forward.\r\n\r\nFixes #190\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "0cfaf806ac4ef1afbd32014133611c6e4cbf3305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cfaf806ac4ef1afbd32014133611c6e4cbf3305"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhvkvrCRBK7hj4Ov3rIwAAKrwIACwand+awELYG0cUbWa68mAf\nCO/nmKhX7uzmhhm2d2/T86DLL+gn8aK3+CZmudcgRUwqh7rXcUbv26vfb4hZRfzu\nyW3+lOl3RcfUJf8CCOE0ywXTckrrOev8i+chuYmSJpIc2c0u+nAcyi9iMvqwTp0Y\niBUW9+0NZnGuQ064ymbHhXXJ5tcEUCHV7zbx5Jph5pYCfCn1gARkHHgfjVQejBds\nJ3pCN2SCdKw4UQbCJuGPE/0kasZ/7bn3+AIQJGaGua520IV2ti0PYq/Y/TDY+8Xg\ngr0MK6qNzt4h4L7mfdwqFxjBEeOhZcMiGlnlkZetkH1BrWXzsJyEE8jK1U4r+SQ=\n=1JA9\n-----END PGP SIGNATURE-----\n", "payload": "tree 0cfaf806ac4ef1afbd32014133611c6e4cbf3305\nparent a8a345642a2a150a35b68e2f19b90abf105700c5\nparent 52ee02f4012d0d5d4363ebb4e71e57b053acf072\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639861227 +0000\ncommitter GitHub <noreply@github.com> 1639861227 +0000\n\nMerge #841\n\n841: Add support for enums on the match expression r=philberty a=philberty\n\nThis adds in the initial support MatchExpression which allows us to start testing much\r\nmore complex rust code. Ideally we can now start targeing the #682 to find nasty bugs\r\nearly as possible.\r\n\r\nThis takes the MatchExpr and generates a SWITCH_EXPR with associated\r\nCASE_LABEL_EXPR's for the variants that the qualifier contains.\r\n\r\nTo improve this support in order to take advantage of SWITCH_ALL_CASES_P\r\nto add error checking for all cases being covered. This will require changes\r\nto the enum data structure to use ENUMERAL_TYPES instead of the flat i64\r\nso the enumerable type contains the list of all possible permutations.\r\n\r\nThis patch is the first pass at the MatchExpr as the patch is already pretty\r\nlarge and serves as a base to move forward.\r\n\r\nFixes #190\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8a345642a2a150a35b68e2f19b90abf105700c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8a345642a2a150a35b68e2f19b90abf105700c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8a345642a2a150a35b68e2f19b90abf105700c5"}, {"sha": "52ee02f4012d0d5d4363ebb4e71e57b053acf072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ee02f4012d0d5d4363ebb4e71e57b053acf072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ee02f4012d0d5d4363ebb4e71e57b053acf072"}], "stats": {"total": 591, "additions": 591, "deletions": 0}, "files": [{"sha": "3554982ed4b659a2b63179bf9c729e770b9045f4", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -94,6 +94,7 @@ GRS_OBJS = \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\\n+    rust/rust-compile-pattern.o \\\n     rust/rust-base62.o \\\n     rust/rust-compile-expr.o \\\n     rust/rust-compile-type.o \\"}, {"sha": "896d42e403b30e8de8cd8818debace500ebb35ed", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -233,6 +233,21 @@ class Context\n     return true;\n   }\n \n+  void insert_pattern_binding (HirId id, tree binding)\n+  {\n+    implicit_pattern_bindings[id] = binding;\n+  }\n+\n+  bool lookup_pattern_binding (HirId id, tree *binding)\n+  {\n+    auto it = implicit_pattern_bindings.find (id);\n+    if (it == implicit_pattern_bindings.end ())\n+      return false;\n+\n+    *binding = it->second;\n+    return true;\n+  }\n+\n   void push_fn (tree fn, ::Bvariable *ret_addr)\n   {\n     fn_stack.push_back (fncontext{fn, ret_addr});\n@@ -326,6 +341,7 @@ class Context\n   std::map<const TyTy::BaseType *, std::pair<HirId, tree>> mono;\n   std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n+  std::map<HirId, tree> implicit_pattern_bindings;\n \n   // To GCC middle-end\n   std::vector<tree> type_decls;"}, {"sha": "b77a4d5d57c128cac062538c79cb10d69cd542c9", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -24,6 +24,9 @@\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n+#include \"rust-compile-pattern.h\"\n+\n+#include \"fold-const.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -154,6 +157,175 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n \t\t\t\t\t\tknown_valid, expr.get_locus ());\n }\n \n+void\n+CompileExpr::visit (HIR::MatchExpr &expr)\n+{\n+  // https://gcc.gnu.org/onlinedocs/gccint/Basic-Statements.html#Basic-Statements\n+  // TODO\n+  // SWITCH_ALL_CASES_P is true if the switch includes a default label or the\n+  // case label ranges cover all possible values of the condition expression\n+\n+  /* Switch expression.\n+\n+     TREE_TYPE is the original type of the condition, before any\n+     language required type conversions.  It may be NULL, in which case\n+     the original type and final types are assumed to be the same.\n+\n+     Operand 0 is the expression used to perform the branch,\n+     Operand 1 is the body of the switch, which probably contains\n+       CASE_LABEL_EXPRs.  It may also be NULL, in which case operand 2\n+       must not be NULL.  */\n+  // DEFTREECODE (SWITCH_EXPR, \"switch_expr\", tcc_statement, 2)\n+\n+  /* Used to represent a case label.\n+\n+     Operand 0 is CASE_LOW.  It may be NULL_TREE, in which case the label\n+       is a 'default' label.\n+     Operand 1 is CASE_HIGH.  If it is NULL_TREE, the label is a simple\n+       (one-value) case label.  If it is non-NULL_TREE, the case is a range.\n+     Operand 2 is CASE_LABEL, which has the corresponding LABEL_DECL.\n+     Operand 3 is CASE_CHAIN.  This operand is only used in tree-cfg.c to\n+       speed up the lookup of case labels which use a particular edge in\n+       the control flow graph.  */\n+  // DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", tcc_statement, 4)\n+\n+  TyTy::BaseType *scrutinee_expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\texpr.get_scrutinee_expr ()->get_mappings ().get_hirid (),\n+\t&scrutinee_expr_tyty))\n+    {\n+      translated = ctx->get_backend ()->error_expression ();\n+      return;\n+    }\n+\n+  rust_assert (scrutinee_expr_tyty->get_kind () == TyTy::TypeKind::ADT);\n+\n+  // this will need to change but for now the first pass implementation, lets\n+  // assert this is the case\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (scrutinee_expr_tyty);\n+  rust_assert (adt->is_enum ());\n+  rust_assert (adt->number_of_variants () > 0);\n+\n+  TyTy::BaseType *expr_tyty = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       &expr_tyty))\n+    {\n+      translated = ctx->get_backend ()->error_expression ();\n+      return;\n+    }\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  Bvariable *tmp = NULL;\n+  bool needs_temp = !expr_tyty->is_unit ();\n+  if (needs_temp)\n+    {\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree block_type = TyTyResolveCompile::compile (ctx, expr_tyty);\n+\n+      bool is_address_taken = false;\n+      tree ret_var_stmt = nullptr;\n+      tmp = ctx->get_backend ()->temporary_variable (\n+\tfnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n+\texpr.get_locus (), &ret_var_stmt);\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  // lets compile the scrutinee expression\n+  tree match_scrutinee_expr\n+    = CompileExpr::Compile (expr.get_scrutinee_expr ().get (), ctx);\n+\n+  // need to access the qualifier field, if we use QUAL_UNION_TYPE this would be\n+  // DECL_QUALIFIER i think. For now this will just access the first record\n+  // field and its respective qualifier because it will always be set because\n+  // this is all a big special union\n+  tree scrutinee_first_record_expr\n+    = ctx->get_backend ()->struct_field_expression (\n+      match_scrutinee_expr, 0, expr.get_scrutinee_expr ()->get_locus ());\n+  tree match_scrutinee_expr_qualifier_expr\n+    = ctx->get_backend ()->struct_field_expression (\n+      scrutinee_first_record_expr, 0, expr.get_scrutinee_expr ()->get_locus ());\n+\n+  // setup the end label so the cases can exit properly\n+  tree fndecl = fnctx.fndecl;\n+  Location end_label_locus = expr.get_locus (); // FIXME\n+  tree end_label\n+    = ctx->get_backend ()->label (fndecl,\n+\t\t\t\t  \"\" /* empty creates an artificial label */,\n+\t\t\t\t  end_label_locus);\n+  tree end_label_decl_statement\n+    = ctx->get_backend ()->label_definition_statement (end_label);\n+\n+  // setup the switch-body-block\n+  Location start_location; // FIXME\n+  Location end_location;   // FIXME\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree switch_body_block\n+    = ctx->get_backend ()->block (fndecl, enclosing_scope, {}, start_location,\n+\t\t\t\t  end_location);\n+  ctx->push_block (switch_body_block);\n+\n+  for (auto &kase : expr.get_match_cases ())\n+    {\n+      // for now lets just get single pattern's working\n+      HIR::MatchArm &kase_arm = kase.get_arm ();\n+      rust_assert (kase_arm.get_patterns ().size () > 0);\n+\n+      // generate implicit label\n+      Location arm_locus = kase_arm.get_patterns ().at (0)->get_locus ();\n+      tree case_label = ctx->get_backend ()->label (\n+\tfndecl, \"\" /* empty creates an artificial label */, arm_locus);\n+\n+      // not sure if we need to add this to the block or if the CASE_LABEL_EXPR\n+      // does this implicitly\n+      //\n+      // tree case_label_decl_statement\n+      //   = ctx->get_backend ()->label_definition_statement (case_label);\n+\n+      // setup the bindings for the block\n+      for (auto &kase_pattern : kase_arm.get_patterns ())\n+\t{\n+\t  tree switch_kase_expr\n+\t    = CompilePatternCaseLabelExpr::Compile (kase_pattern.get (),\n+\t\t\t\t\t\t    case_label, ctx);\n+\t  // ctx->add_statement (case_label_decl_statement);\n+\t  ctx->add_statement (switch_kase_expr);\n+\n+\t  CompilePatternBindings::Compile (kase_pattern.get (),\n+\t\t\t\t\t   match_scrutinee_expr, ctx);\n+\t}\n+\n+      // compile the expr and setup the assignment if required when tmp != NULL\n+      tree kase_expr_tree = CompileExpr::Compile (kase.get_expr ().get (), ctx);\n+      if (tmp != NULL)\n+\t{\n+\t  tree result_reference\n+\t    = ctx->get_backend ()->var_expression (tmp, arm_locus);\n+\t  tree assignment = ctx->get_backend ()->assignment_statement (\n+\t    fnctx.fndecl, result_reference, kase_expr_tree, arm_locus);\n+\t  ctx->add_statement (assignment);\n+\t}\n+\n+      // go to end label\n+      tree goto_end_label = build1_loc (arm_locus.gcc_location (), GOTO_EXPR,\n+\t\t\t\t\tvoid_type_node, end_label);\n+      ctx->add_statement (goto_end_label);\n+    }\n+\n+  // setup the switch expression\n+  tree match_body = ctx->pop_block ();\n+  tree match_expr_stmt\n+    = build2_loc (expr.get_locus ().gcc_location (), SWITCH_EXPR,\n+\t\t  TREE_TYPE (match_scrutinee_expr_qualifier_expr),\n+\t\t  match_scrutinee_expr_qualifier_expr, match_body);\n+  ctx->add_statement (match_expr_stmt);\n+  ctx->add_statement (end_label_decl_statement);\n+\n+  if (tmp != NULL)\n+    {\n+      translated = ctx->get_backend ()->var_expression (tmp, expr.get_locus ());\n+    }\n+}\n+\n void\n CompileExpr::visit (HIR::CallExpr &expr)\n {"}, {"sha": "dc4f90937c242c0e68516f56d0060e477e91d6a3", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -221,6 +221,10 @@ class CompileExpr : public HIRCompileBase\n \ttranslated\n \t  = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n       }\n+    else if (ctx->lookup_pattern_binding (ref, &translated))\n+      {\n+\treturn;\n+      }\n     else\n       {\n \trust_fatal_error (expr.get_locus (),\n@@ -1043,6 +1047,8 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::DereferenceExpr &expr) override;\n \n+  void visit (HIR::MatchExpr &expr) override;\n+\n protected:\n   tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t  TyTy::BaseType *receiver,"}, {"sha": "e634dbd03c35e7e79c33112f290910e786ea981d", "filename": "gcc/rust/backend/rust-compile-pattern.cc", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.cc?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -0,0 +1,218 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-pattern.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::PathInExpression &pattern)\n+{\n+  // lookup the type\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (pattern.get_mappings ().get_hirid (),\n+\t\t\t\t      &lookup);\n+  rust_assert (ok);\n+\n+  // this must be an enum\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+  rust_assert (adt->is_enum ());\n+\n+  // lookup the variant\n+  HirId variant_id;\n+  ok = ctx->get_tyctx ()->lookup_variant_definition (\n+    pattern.get_mappings ().get_hirid (), &variant_id);\n+  rust_assert (ok);\n+\n+  TyTy::VariantDef *variant = nullptr;\n+  ok = adt->lookup_variant_by_id (variant_id, &variant);\n+  rust_assert (ok);\n+\n+  mpz_t disciminantl;\n+  if (variant->get_variant_type () == TyTy::VariantDef::VariantType::NUM)\n+    {\n+      mpz_init_set_ui (disciminantl, variant->get_discriminant ());\n+    }\n+  else\n+    {\n+      HirId variant_id = variant->get_id ();\n+      mpz_init_set_ui (disciminantl, variant_id);\n+    }\n+\n+  tree t = TyTyResolveCompile::get_implicit_enumeral_node_type (ctx);\n+  tree case_low\n+    = double_int_to_tree (t, mpz_get_double_int (t, disciminantl, true));\n+\n+  case_label_expr\n+    = build_case_label (case_low, NULL_TREE, associated_case_label);\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::StructPattern &pattern)\n+{\n+  CompilePatternCaseLabelExpr::visit (pattern.get_path ());\n+}\n+\n+void\n+CompilePatternCaseLabelExpr::visit (HIR::TupleStructPattern &pattern)\n+{\n+  CompilePatternCaseLabelExpr::visit (pattern.get_path ());\n+}\n+\n+// setup the bindings\n+\n+void\n+CompilePatternBindings::visit (HIR::TupleStructPattern &pattern)\n+{\n+  // lookup the type\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    pattern.get_path ().get_mappings ().get_hirid (), &lookup);\n+  rust_assert (ok);\n+\n+  // this must be an enum\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+  rust_assert (adt->is_enum ());\n+\n+  // lookup the variant\n+  HirId variant_id;\n+  ok = ctx->get_tyctx ()->lookup_variant_definition (\n+    pattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+  rust_assert (ok);\n+\n+  int variant_index = -1;\n+  TyTy::VariantDef *variant = nullptr;\n+  ok = adt->lookup_variant_by_id (variant_id, &variant, &variant_index);\n+  rust_assert (ok);\n+\n+  rust_assert (variant->get_variant_type ()\n+\t       == TyTy::VariantDef::VariantType::TUPLE);\n+\n+  std::unique_ptr<HIR::TupleStructItems> &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case HIR::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case HIR::TupleStructItems::NO_RANGE: {\n+\tHIR::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<HIR::TupleStructItemsNoRange &> (*items.get ());\n+\n+\trust_assert (items_no_range.get_patterns ().size ()\n+\t\t     == variant->num_fields ());\n+\n+\t// we are offsetting by + 1 here since the first field in the record\n+\t// is always the discriminator\n+\tsize_t tuple_field_index = 1;\n+\tfor (auto &pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    tree variant_accessor\n+\t      = ctx->get_backend ()->struct_field_expression (\n+\t\tmatch_scrutinee_expr, variant_index, pattern->get_locus ());\n+\n+\t    tree binding = ctx->get_backend ()->struct_field_expression (\n+\t      variant_accessor, tuple_field_index++, pattern->get_locus ());\n+\n+\t    ctx->insert_pattern_binding (\n+\t      pattern->get_pattern_mappings ().get_hirid (), binding);\n+\t  }\n+      }\n+      break;\n+    }\n+}\n+\n+void\n+CompilePatternBindings::visit (HIR::StructPattern &pattern)\n+{\n+  // lookup the type\n+  TyTy::BaseType *lookup = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    pattern.get_path ().get_mappings ().get_hirid (), &lookup);\n+  rust_assert (ok);\n+\n+  // this must be an enum\n+  rust_assert (lookup->get_kind () == TyTy::TypeKind::ADT);\n+  TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (lookup);\n+  rust_assert (adt->is_enum ());\n+\n+  // lookup the variant\n+  HirId variant_id;\n+  ok = ctx->get_tyctx ()->lookup_variant_definition (\n+    pattern.get_path ().get_mappings ().get_hirid (), &variant_id);\n+  rust_assert (ok);\n+\n+  int variant_index = -1;\n+  TyTy::VariantDef *variant = nullptr;\n+  ok = adt->lookup_variant_by_id (variant_id, &variant, &variant_index);\n+  rust_assert (ok);\n+\n+  rust_assert (variant->get_variant_type ()\n+\t       == TyTy::VariantDef::VariantType::STRUCT);\n+\n+  auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n+  for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())\n+    {\n+      switch (field->get_item_type ())\n+\t{\n+\t  case HIR::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case HIR::StructPatternField::ItemType::IDENT: {\n+\t    HIR::StructPatternFieldIdent &ident\n+\t      = static_cast<HIR::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    tree variant_accessor\n+\t      = ctx->get_backend ()->struct_field_expression (\n+\t\tmatch_scrutinee_expr, variant_index, ident.get_locus ());\n+\n+\t    size_t offs = 0;\n+\t    ok\n+\t      = variant->lookup_field (ident.get_identifier (), nullptr, &offs);\n+\t    rust_assert (ok);\n+\n+\t    // we are offsetting by + 1 here since the first field in the record\n+\t    // is always the discriminator\n+\t    tree binding = ctx->get_backend ()->struct_field_expression (\n+\t      variant_accessor, offs + 1, ident.get_locus ());\n+\n+\t    ctx->insert_pattern_binding (ident.get_mappings ().get_hirid (),\n+\t\t\t\t\t binding);\n+\t  }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "e49f75c70c7b5b16b9ead90013492515b274ada5", "filename": "gcc/rust/backend/rust-compile-pattern.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-pattern.h?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompilePatternCaseLabelExpr : public HIRCompileBase\n+{\n+  using Rust::Compile::HIRCompileBase::visit;\n+\n+public:\n+  static tree Compile (HIR::Pattern *pattern, tree associated_case_label,\n+\t\t       Context *ctx)\n+  {\n+    CompilePatternCaseLabelExpr compiler (ctx, associated_case_label);\n+    pattern->accept_vis (compiler);\n+    return compiler.case_label_expr;\n+  }\n+\n+  void visit (HIR::PathInExpression &pattern) override;\n+\n+  void visit (HIR::StructPattern &pattern) override;\n+\n+  void visit (HIR::TupleStructPattern &pattern) override;\n+\n+private:\n+  CompilePatternCaseLabelExpr (Context *ctx, tree associated_case_label)\n+    : HIRCompileBase (ctx), case_label_expr (error_mark_node),\n+      associated_case_label (associated_case_label)\n+  {}\n+\n+  tree case_label_expr;\n+  tree associated_case_label;\n+};\n+\n+class CompilePatternBindings : public HIRCompileBase\n+{\n+  using Rust::Compile::HIRCompileBase::visit;\n+\n+public:\n+  static void Compile (HIR::Pattern *pattern, tree match_scrutinee_expr,\n+\t\t       Context *ctx)\n+  {\n+    CompilePatternBindings compiler (ctx, match_scrutinee_expr);\n+    pattern->accept_vis (compiler);\n+  }\n+\n+  void visit (HIR::StructPattern &pattern) override;\n+\n+  void visit (HIR::TupleStructPattern &pattern) override;\n+\n+private:\n+  CompilePatternBindings (Context *ctx, tree match_scrutinee_expr)\n+    : HIRCompileBase (ctx), match_scrutinee_expr (match_scrutinee_expr)\n+  {}\n+\n+  tree match_scrutinee_expr;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "2393b157324bc116cb51412fafadb69b2fd3445f", "filename": "gcc/testsuite/rust/execute/torture/match1.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch1.rs?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -0,0 +1,58 @@\n+// { dg-output \"Foo::A\\nFoo::B\\nFoo::C x\\nFoo::D 20 80\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+enum Foo {\n+    A,\n+    B,\n+    C(char),\n+    D { x: i64, y: i64 },\n+}\n+\n+fn inspect(f: Foo) {\n+    match f {\n+        Foo::A => unsafe {\n+            let a = \"Foo::A\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        },\n+        Foo::B => unsafe {\n+            let a = \"Foo::B\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        },\n+        Foo::C(x) => unsafe {\n+            let a = \"Foo::C %c\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, x);\n+        },\n+        Foo::D { x, y } => unsafe {\n+            let a = \"Foo::D %i %i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, x, y);\n+        },\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = Foo::A;\n+    let b = Foo::B;\n+    let c = Foo::C('x');\n+    let d = Foo::D { x: 20, y: 80 };\n+\n+    inspect(a);\n+    inspect(b);\n+    inspect(c);\n+    inspect(d);\n+\n+    0\n+}"}, {"sha": "4a018c13cd2af3d11eb61cd80804eab607b7ce57", "filename": "gcc/testsuite/rust/execute/torture/match2.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fmatch2.rs?ref=b06de309ebdcc1ece1c3a5ef79a2a69a0e9f8965", "patch": "@@ -0,0 +1,42 @@\n+// { dg-output \"123\\n80\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+enum Foo {\n+    C(i32),\n+    D { x: i32, y: i32 },\n+}\n+\n+fn inspect(f: Foo) -> i32 {\n+    match f {\n+        Foo::C(x) => x,\n+        Foo::D { x, y } => y,\n+        // { dg-warning \"unused name .x.\" \"\" { target *-*-* } .-1 }\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = Foo::C(123);\n+    let b = Foo::D { x: 20, y: 80 };\n+\n+    let result = inspect(a);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, result);\n+    }\n+\n+    let result = inspect(b);\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, result);\n+    }\n+\n+    0\n+}"}]}