{"sha": "ca617fd2144dd58a2d26887239e86e5b32eba87c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2MTdmZDIxNDRkZDU4YTJkMjY4ODcyMzllODZlNWIzMmViYTg3Yw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-09-26T14:28:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-09-26T14:28:13Z"}, "message": "graphite-scop-detection.c (scop_detection::build_scop_depth): Rewrite, fold in ...\n\n2017-09-26  Richard Biener  <rguenther@suse.de>\n\n\t* graphite-scop-detection.c (scop_detection::build_scop_depth): Rewrite,\n\tfold in ...\n\t(scop_detection::build_scop_breadth): ... this.  Removed.\n\t(scop_detection::loop_is_valid_in_scop): Fold into single caller.\n\t(scop_detection::harmful_stmt_in_bb): Likewise.\n\t(scop_detection::graphite_can_represent_stmt): Likewise.\n\t(scop_detection::loop_body_is_valid_scop): Likewise.  Remove recursion.\n\t(scop_detection::can_represent_loop): Remove recursion, fold in ...\n\t(scop_detection::can_represent_loop_1): ... this.  Removed.\n\t(scop_detection::harmful_loop_in_region): Simplify after inlining\n\tthe above and remove more quadraticness.\n\t(build_scops): Adjust.\n\t* tree-data-ref.c (loop_nest_has_data_refs): Remove pointless\n\tquadraticness.\n\nFrom-SVN: r253203", "tree": {"sha": "d76b80720d49418a36166446048474c205a0b04a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d76b80720d49418a36166446048474c205a0b04a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca617fd2144dd58a2d26887239e86e5b32eba87c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca617fd2144dd58a2d26887239e86e5b32eba87c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca617fd2144dd58a2d26887239e86e5b32eba87c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca617fd2144dd58a2d26887239e86e5b32eba87c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "343cb5897c673cb75233f4d0a991c0bec11c1f53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/343cb5897c673cb75233f4d0a991c0bec11c1f53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/343cb5897c673cb75233f4d0a991c0bec11c1f53"}], "stats": {"total": 382, "additions": 115, "deletions": 267}, "files": [{"sha": "e7256d4b64c40607942f275e82543129987d5212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca617fd2144dd58a2d26887239e86e5b32eba87c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca617fd2144dd58a2d26887239e86e5b32eba87c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca617fd2144dd58a2d26887239e86e5b32eba87c", "patch": "@@ -1,3 +1,20 @@\n+2017-09-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* graphite-scop-detection.c (scop_detection::build_scop_depth): Rewrite,\n+\tfold in ...\n+\t(scop_detection::build_scop_breadth): ... this.  Removed.\n+\t(scop_detection::loop_is_valid_in_scop): Fold into single caller.\n+\t(scop_detection::harmful_stmt_in_bb): Likewise.\n+\t(scop_detection::graphite_can_represent_stmt): Likewise.\n+\t(scop_detection::loop_body_is_valid_scop): Likewise.  Remove recursion.\n+\t(scop_detection::can_represent_loop): Remove recursion, fold in ...\n+\t(scop_detection::can_represent_loop_1): ... this.  Removed.\n+\t(scop_detection::harmful_loop_in_region): Simplify after inlining\n+\tthe above and remove more quadraticness.\n+\t(build_scops): Adjust.\n+\t* tree-data-ref.c (loop_nest_has_data_refs): Remove pointless\n+\tquadraticness.\n+\n 2017-09-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82267"}, {"sha": "90156bbbe76db626e762e598142c8adacfd159d0", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 98, "deletions": 256, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca617fd2144dd58a2d26887239e86e5b32eba87c/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca617fd2144dd58a2d26887239e86e5b32eba87c/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=ca617fd2144dd58a2d26887239e86e5b32eba87c", "patch": "@@ -362,17 +362,7 @@ class scop_detection\n \n   /* Build scop outer->inner if possible.  */\n \n-  sese_l build_scop_depth (sese_l s, loop_p loop);\n-\n-  /* If loop and loop->next are valid scops, try to merge them.  */\n-\n-  sese_l build_scop_breadth (sese_l s1, loop_p loop);\n-\n-  /* Return true when LOOP is a valid scop, that is a Static Control Part, a\n-     region of code that can be represented in the polyhedral model.  SCOP\n-     defines the region we analyse.  */\n-\n-  bool loop_is_valid_in_scop (loop_p loop, sese_l scop) const;\n+  void build_scop_depth (loop_p loop);\n \n   /* Return true when BEGIN is the preheader edge of a loop with a single exit\n      END.  */\n@@ -398,18 +388,6 @@ class scop_detection\n \n   void remove_intersecting_scops (sese_l s1);\n \n-  /* Return true when the body of LOOP has statements that can be represented\n-     as a valid scop.  */\n-\n-  bool loop_body_is_valid_scop (loop_p loop, sese_l scop) const;\n-\n-  /* Return true when BB contains a harmful operation for a scop: that\n-     can be a function call with side effects, the induction variables\n-     are not linear with respect to SCOP, etc.  The current open\n-     scop should end before this statement.  */\n-\n-  bool harmful_stmt_in_bb (sese_l scop, basic_block bb) const;\n-\n   /* Return true when a statement in SCOP cannot be represented by Graphite.\n      The assumptions are that L1 dominates L2, and SCOP->entry dominates L1.\n      Limit the number of bbs between adjacent loops to\n@@ -467,19 +445,12 @@ class scop_detection\n      FIXME: For the moment, graphite cannot be used on loops that iterate using\n      induction variables that wrap.  */\n \n-  static bool can_represent_loop_1 (loop_p loop, sese_l scop);\n-\n-  /* Return true when all the loops within LOOP can be represented by\n-     Graphite.  */\n-\n   static bool can_represent_loop (loop_p loop, sese_l scop);\n \n   /* Returns the number of pbbs that are in loops contained in SCOP.  */\n \n   static int nb_pbbs_in_loops (scop_p scop);\n \n-  static bool graphite_can_represent_stmt (sese_l, gimple *, basic_block);\n-\n private:\n   vec<sese_l> scops;\n };\n@@ -673,90 +644,55 @@ scop_detection::merge_sese (sese_l first, sese_l second) const\n       return invalid_sese;\n     }\n \n-  /* Analyze all the BBs in new sese.  */\n-  if (harmful_loop_in_region (combined))\n-    return invalid_sese;\n-\n   DEBUG_PRINT (dp << \"[merged-sese] s1: \"; print_sese (dump_file, combined));\n \n   return combined;\n }\n \n /* Build scop outer->inner if possible.  */\n \n-sese_l\n-scop_detection::build_scop_depth (sese_l s, loop_p loop)\n-{\n-  if (!loop)\n-    return s;\n-\n-  DEBUG_PRINT (dp << \"[Depth loop_\" << loop->num << \"]\\n\");\n-  s = build_scop_depth (s, loop->inner);\n-\n-  sese_l s2 = merge_sese (s, get_sese (loop));\n-  if (!s2)\n-    {\n-      /* s might be a valid scop, so return it and start analyzing from the\n-\t adjacent loop.  */\n-      build_scop_depth (invalid_sese, loop->next);\n-      return s;\n-    }\n-\n-  if (!loop_is_valid_in_scop (loop, s2))\n-    return build_scop_depth (invalid_sese, loop->next);\n-\n-  return build_scop_breadth (s2, loop);\n-}\n-\n-/* If loop and loop->next are valid scops, try to merge them.  */\n-\n-sese_l\n-scop_detection::build_scop_breadth (sese_l s1, loop_p loop)\n+void\n+scop_detection::build_scop_depth (loop_p loop)\n {\n-  if (!loop)\n-    return s1;\n-  DEBUG_PRINT (dp << \"[Breadth loop_\" << loop->num << \"]\\n\");\n-  gcc_assert (s1);\n-\n-  loop_p l = loop;\n-  sese_l s2 = build_scop_depth (invalid_sese, l->next);\n-  if (!s2)\n+  sese_l s = invalid_sese;\n+  loop = loop->inner;\n+  while (loop)\n     {\n-      if (s1)\n-\tadd_scop (s1);\n-      return s1;\n-    }\n-\n-  sese_l combined = merge_sese (s1, s2);\n-\n-  /* Combining adjacent loops may add unrelated loops into the\n-     region so we have to check all sub-loops of the outer loop\n-     that are in the combined region.  */\n-  if (combined)\n-    for (l = loop_outer (loop)->inner; l; l = l->next)\n-      if (bb_in_sese_p (l->header, combined)\n-\t  && ! loop_is_valid_in_scop (l, combined))\n+      sese_l next = get_sese (loop);\n+      if (! next\n+\t  || harmful_loop_in_region (next))\n \t{\n-\t  combined = invalid_sese;\n-\t  break;\n+\t  if (s)\n+\t    add_scop (s);\n+\t  build_scop_depth (loop);\n+\t  s = invalid_sese;\n \t}\n-\n-  if (combined)\n-    s1 = combined;\n-  else\n-    add_scop (s2);\n-\n-  if (s1)\n-    add_scop (s1);\n-  return s1;\n+      else if (! s)\n+\ts = next;\n+      else\n+\t{\n+\t  sese_l combined = merge_sese (s, next);\n+\t  if (! combined\n+\t      || harmful_loop_in_region (combined))\n+\t    {\n+\t      add_scop (s);\n+\t      s = next;\n+\t    }\n+\t  else\n+\t    s = combined;\n+\t}\n+      loop = loop->next;\n+    }\n+  if (s)\n+    add_scop (s);\n }\n \n /* Returns true when Graphite can represent LOOP in SCOP.\n    FIXME: For the moment, graphite cannot be used on loops that iterate using\n    induction variables that wrap.  */\n \n bool\n-scop_detection::can_represent_loop_1 (loop_p loop, sese_l scop)\n+scop_detection::can_represent_loop (loop_p loop, sese_l scop)\n {\n   tree niter;\n   struct tree_niter_desc niter_desc;\n@@ -772,53 +708,6 @@ scop_detection::can_represent_loop_1 (loop_p loop, sese_l scop)\n     && graphite_can_represent_expr (scop, loop, niter);\n }\n \n-/* Return true when all the loops within LOOP can be represented by\n-   Graphite.  */\n-\n-bool\n-scop_detection::can_represent_loop (loop_p loop, sese_l scop)\n-{\n-  if (!can_represent_loop_1 (loop, scop))\n-    return false;\n-  for (loop_p inner = loop->inner; inner; inner = inner->next)\n-    if (!can_represent_loop (inner, scop))\n-      return false;\n-  return true;\n-}\n-\n-/* Return true when LOOP is a valid scop, that is a Static Control Part, a\n-   region of code that can be represented in the polyhedral model.  SCOP\n-   defines the region we analyse.  */\n-\n-bool\n-scop_detection::loop_is_valid_in_scop (loop_p loop, sese_l scop) const\n-{\n-  if (!scop)\n-    return false;\n-\n-  if (!optimize_loop_nest_for_speed_p (loop))\n-    {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\"\n-\t\t      << loop->num << \" is not on a hot path.\\n\");\n-      return false;\n-    }\n-\n-  if (!can_represent_loop (loop, scop))\n-    {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] cannot represent loop_\"\n-\t\t      << loop->num << \"\\n\");\n-      return false;\n-    }\n-\n-  if (loop_body_is_valid_scop (loop, scop))\n-    {\n-      DEBUG_PRINT (dp << \"[valid-scop] loop_\" << loop->num\n-\t\t      << \" is a valid scop.\\n\");\n-      return true;\n-    }\n-  return false;\n-}\n-\n /* Return true when BEGIN is the preheader edge of a loop with a single exit\n    END.  */\n \n@@ -914,14 +803,12 @@ scop_detection::harmful_loop_in_region (sese_l scop) const\n       loop_p loop = bb->loop_father;\n       if (loop_in_sese_p (loop, scop))\n \tbitmap_set_bit (loops, loop->num);\n-      else\n-\t{\n-\t  /* We only check for harmful statements in basic blocks not part of\n-\t     any loop fully contained in the scop: other bbs are checked below\n-\t     in loop_is_valid_in_scop.  */\n-\t  if (harmful_stmt_in_bb (scop, bb))\n-\t    return true;\n-\t}\n+\n+      /* Check for harmful statements in basic blocks part of the region.  */\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t   !gsi_end_p (gsi); gsi_next (&gsi))\n+\tif (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))\n+\t  return true;\n \n       if (bb != exit_bb)\n \tfor (basic_block dom = first_dom_son (CDI_DOMINATORS, bb);\n@@ -939,8 +826,41 @@ scop_detection::harmful_loop_in_region (sese_l scop) const\n       loop_p loop = (*current_loops->larray)[j];\n       gcc_assert (loop->num == (int) j);\n \n-      if (!loop_is_valid_in_scop (loop, scop))\n-\treturn true;\n+      /* Check if the loop nests are to be optimized for speed.  */\n+      if (! loop->inner\n+\t  && ! optimize_loop_for_speed_p (loop))\n+\t{\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\"\n+\t\t       << loop->num << \" is not on a hot path.\\n\");\n+\t  return true;\n+\t}\n+\n+      if (! can_represent_loop (loop, scop))\n+\t{\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] cannot represent loop_\"\n+\t\t       << loop->num << \"\\n\");\n+\t  return true;\n+\t}\n+\n+      if (! loop_ivs_can_be_represented (loop))\n+\t{\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\" << loop->num\n+\t\t       << \"IV cannot be represented.\\n\");\n+\t  return true;\n+\t}\n+\n+      /* Check if all loop nests have at least one data reference.\n+\t ???  This check is expensive and loops premature at this point.\n+\t If important to retain we can pre-compute this for all innermost\n+\t loops and reject those when we build a SESE region for a loop\n+\t during SESE discovery.  */\n+      if (! loop->inner\n+\t  && ! loop_nest_has_data_refs (loop))\n+\t{\n+\t  DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\" << loop->num\n+\t\t       << \"does not have any data reference.\\n\");\n+\t  return true;\n+\t}\n     }\n \n   return false;\n@@ -1181,14 +1101,32 @@ stmt_has_side_effects (gimple *stmt)\n   return false;\n }\n \n-/* Returns true if STMT can be represented in polyhedral model. LABEL,\n-   simple COND stmts, pure calls, and assignments can be repesented.  */\n+/* Return true only when STMT is simple enough for being handled by Graphite.\n+   This depends on SCOP, as the parameters are initialized relatively to\n+   this basic block, the linear functions are initialized based on the outermost\n+   loop containing STMT inside the SCOP.  BB is the place where we try to\n+   evaluate the STMT.  */\n \n bool\n-scop_detection::graphite_can_represent_stmt (sese_l scop, gimple *stmt,\n-\t\t\t\t\t     basic_block bb)\n+scop_detection::stmt_simple_for_scop_p (sese_l scop, gimple *stmt,\n+\t\t\t\t\tbasic_block bb) const\n {\n-  loop_p loop = bb->loop_father;\n+  gcc_assert (scop);\n+\n+  if (is_gimple_debug (stmt))\n+    return true;\n+\n+  if (stmt_has_side_effects (stmt))\n+    return false;\n+\n+  if (!stmt_has_simple_data_refs_p (scop, stmt))\n+    {\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n+\t\t      << \"Graphite cannot handle data-refs in stmt:\\n\";\n+\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS););\n+      return false;\n+    }\n+\n   switch (gimple_code (stmt))\n     {\n     case GIMPLE_LABEL:\n@@ -1214,6 +1152,7 @@ scop_detection::graphite_can_represent_stmt (sese_l scop, gimple *stmt,\n \t    return false;\n \t  }\n \n+\tloop_p loop = bb->loop_father;\n \tfor (unsigned i = 0; i < 2; ++i)\n \t  {\n \t    tree op = gimple_op (stmt, i);\n@@ -1246,99 +1185,6 @@ scop_detection::graphite_can_represent_stmt (sese_l scop, gimple *stmt,\n     }\n }\n \n-/* Return true only when STMT is simple enough for being handled by Graphite.\n-   This depends on SCOP, as the parameters are initialized relatively to\n-   this basic block, the linear functions are initialized based on the outermost\n-   loop containing STMT inside the SCOP.  BB is the place where we try to\n-   evaluate the STMT.  */\n-\n-bool\n-scop_detection::stmt_simple_for_scop_p (sese_l scop, gimple *stmt,\n-\t\t\t\t\tbasic_block bb) const\n-{\n-  gcc_assert (scop);\n-\n-  if (is_gimple_debug (stmt))\n-    return true;\n-\n-  if (stmt_has_side_effects (stmt))\n-    return false;\n-\n-  if (!stmt_has_simple_data_refs_p (scop, stmt))\n-    {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n-\t\t      << \"Graphite cannot handle data-refs in stmt:\\n\";\n-\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS););\n-      return false;\n-    }\n-\n-  return graphite_can_represent_stmt (scop, stmt, bb);\n-}\n-\n-/* Return true when BB contains a harmful operation for a scop: that\n-   can be a function call with side effects, the induction variables\n-   are not linear with respect to SCOP, etc.  The current open\n-   scop should end before this statement.  */\n-\n-bool\n-scop_detection::harmful_stmt_in_bb (sese_l scop, basic_block bb) const\n-{\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Return true when the body of LOOP has statements that can be represented as a\n-   valid scop.  */\n-\n-bool\n-scop_detection::loop_body_is_valid_scop (loop_p loop, sese_l scop) const\n-{\n-  if (!loop_ivs_can_be_represented (loop))\n-    {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\" << loop->num\n-\t\t      << \"IV cannot be represented.\\n\");\n-      return false;\n-    }\n-\n-  if (!loop_nest_has_data_refs (loop))\n-    {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\" << loop->num\n-\t\t      << \"does not have any data reference.\\n\");\n-      return false;\n-    }\n-\n-  basic_block *bbs = get_loop_body (loop);\n-  for (unsigned i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block bb = bbs[i];\n-\n-      if (harmful_stmt_in_bb (scop, bb))\n-\t{\n-\t  free (bbs);\n-\t  return false;\n-\t}\n-    }\n-  free (bbs);\n-\n-  if (loop->inner)\n-    {\n-      loop = loop->inner;\n-      while (loop)\n-\t{\n-\t  if (!loop_body_is_valid_scop (loop, scop))\n-\t    return false;\n-\t  loop = loop->next;\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n /* Returns the number of pbbs that are in loops contained in SCOP.  */\n \n int\n@@ -1857,12 +1703,8 @@ build_scops (vec<scop_p> *scops)\n   if (dump_file)\n     dp.set_dump_file (dump_file);\n \n-  /* ???  We walk the loop tree assuming loop->next is ordered.\n-     This is not so but we'd be free to order it here.  */\n   scop_detection sb;\n-  sese_l tem = sb.build_scop_depth (scop_detection::invalid_sese,\n-\t\t\t\t    current_loops->tree_root);\n-  gcc_assert (! tem);\n+  sb.build_scop_depth (current_loops->tree_root);\n \n   /* Now create scops from the lightweight SESEs.  */\n   vec<sese_l> scops_l = sb.get_scops ();"}, {"sha": "a414fbfe0f2a00c80073ee3fc69b7701788fe1ee", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca617fd2144dd58a2d26887239e86e5b32eba87c/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca617fd2144dd58a2d26887239e86e5b32eba87c/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ca617fd2144dd58a2d26887239e86e5b32eba87c", "patch": "@@ -4944,17 +4944,6 @@ loop_nest_has_data_refs (loop_p loop)\n \t}\n     }\n   free (bbs);\n-\n-  if (loop->inner)\n-    {\n-      loop = loop->inner;\n-      while (loop)\n-\t{\n-\t  if (loop_nest_has_data_refs (loop))\n-\t    return true;\n-\t  loop = loop->next;\n-\t}\n-    }\n   return false;\n }\n "}]}