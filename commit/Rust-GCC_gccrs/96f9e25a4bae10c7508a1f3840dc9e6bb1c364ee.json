{"sha": "96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmOWUyNWE0YmFlMTBjNzUwOGExZjM4NDBkYzllNmJiMWMzNjRlZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-11-04T10:29:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-11-04T10:29:42Z"}, "message": "re PR tree-optimization/58946 (internal compiler error: in operator[], at vec.h:722)\n\n\tPR tree-optimization/58946\n\t* tree-ssa-reassoc.c (maybe_optimize_range_tests): Update all\n\tbbs with bbinfo[idx].op != NULL before all blocks with\n\tbbinfo[idx].op == NULL.\n\n\t* gcc.c-torture/compile/pr58946.c: New test.\n\nFrom-SVN: r204348", "tree": {"sha": "0600acd22da34ca748ed2f509270cae293c49961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0600acd22da34ca748ed2f509270cae293c49961"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2546da0b1dbea46d587ad14103a80ab4e3be94ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2546da0b1dbea46d587ad14103a80ab4e3be94ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2546da0b1dbea46d587ad14103a80ab4e3be94ab"}], "stats": {"total": 103, "additions": 74, "deletions": 29}, "files": [{"sha": "7306064b140ec24e32ea4d514ec278e2622cea90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "patch": "@@ -1,3 +1,10 @@\n+2013-11-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/58946\n+\t* tree-ssa-reassoc.c (maybe_optimize_range_tests): Update all\n+\tbbs with bbinfo[idx].op != NULL before all blocks with\n+\tbbinfo[idx].op == NULL.\n+\n 2013-11-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/avr/avr-log.c (avr_double_int_pop_digit): Delete."}, {"sha": "ad988239b381512699c7bab9b2ab28c17200bab5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "patch": "@@ -1,3 +1,8 @@\n+2013-11-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/58946\n+\t* gcc.c-torture/compile/pr58946.c: New test.\n+\n 2013-11-03  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52071"}, {"sha": "0ec5eba16f0cd52ddd5c48f63c684db717be2d99", "filename": "gcc/testsuite/gcc.c-torture/compile/pr58946.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58946.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58946.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58946.c?ref=96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "patch": "@@ -0,0 +1,20 @@\n+/* PR tree-optimization/58946 */\n+\n+int\n+foo (unsigned int c)\n+{\n+  unsigned int d, e, f;\n+  if ((int) c < 0)\n+    d = 0;\n+  else\n+    d = c;\n+  if (d == 0)\n+    e = __INT_MAX__ + 1U;\n+  else\n+    e = d;\n+  if ((int) e < 0)\n+    f = 0;\n+  else\n+    f = e;\n+  return f;\n+}"}, {"sha": "538a8ef0e4a25e874b97ff9dc1f772544b2f3b53", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=96f9e25a4bae10c7508a1f3840dc9e6bb1c364ee", "patch": "@@ -2657,6 +2657,7 @@ maybe_optimize_range_tests (gimple stmt)\n   edge e;\n   vec<operand_entry_t> ops = vNULL;\n   vec<inter_bb_range_test_entry> bbinfo = vNULL;\n+  bool any_changes = false;\n \n   /* Consider only basic blocks that end with GIMPLE_COND or\n      a cast statement satisfying final_range_test_p.  All\n@@ -2870,41 +2871,31 @@ maybe_optimize_range_tests (gimple stmt)\n \tbreak;\n     }\n   if (ops.length () > 1)\n+    any_changes = optimize_range_tests (ERROR_MARK, &ops);\n+  if (any_changes)\n     {\n       unsigned int idx;\n-      bool any_changes = optimize_range_tests (ERROR_MARK, &ops);\n-      for (bb = last_bb, idx = 0; any_changes; bb = single_pred (bb), idx++)\n+      /* update_ops relies on has_single_use predicates returning the\n+\t same values as it did during get_ops earlier.  Additionally it\n+\t never removes statements, only adds new ones and it should walk\n+\t from the single imm use and check the predicate already before\n+\t making those changes.\n+\t On the other side, the handling of GIMPLE_COND directly can turn\n+\t previously multiply used SSA_NAMEs into single use SSA_NAMEs, so\n+\t it needs to be done in a separate loop afterwards.  */\n+      for (bb = last_bb, idx = 0; ; bb = single_pred (bb), idx++)\n \t{\n-\t  if (bbinfo[idx].first_idx < bbinfo[idx].last_idx)\n+\t  if (bbinfo[idx].first_idx < bbinfo[idx].last_idx\n+\t      && bbinfo[idx].op != NULL_TREE)\n \t    {\n-\t      gimple stmt = last_stmt (bb);\n \t      tree new_op;\n \n-\t      if (bbinfo[idx].op == NULL_TREE)\n-\t\t{\n-\t\t  if (ops[bbinfo[idx].first_idx]->op != NULL_TREE)\n-\t\t    {\n-\t\t      if (integer_zerop (ops[bbinfo[idx].first_idx]->op))\n-\t\t\tgimple_cond_make_false (stmt);\n-\t\t      else if (integer_onep (ops[bbinfo[idx].first_idx]->op))\n-\t\t\tgimple_cond_make_true (stmt);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  gimple_cond_set_code (stmt, NE_EXPR);\n-\t\t\t  gimple_cond_set_lhs (stmt,\n-\t\t\t\t\t       ops[bbinfo[idx].first_idx]->op);\n-\t\t\t  gimple_cond_set_rhs (stmt, boolean_false_node);\n-\t\t\t}\n-\t\t      update_stmt (stmt);\n-\t\t    }\n-\t\t  bbinfo[idx].op = new_op = boolean_false_node;\n-\t\t}\n-\t      else\n-\t\tnew_op = update_ops (bbinfo[idx].op,\n-\t\t\t\t     (enum tree_code)\n-\t\t\t\t     ops[bbinfo[idx].first_idx]->rank,\n-\t\t\t\t     ops, &bbinfo[idx].first_idx,\n-\t\t\t\t     loop_containing_stmt (stmt));\n+\t      stmt = last_stmt (bb);\n+\t      new_op = update_ops (bbinfo[idx].op,\n+\t\t\t\t   (enum tree_code)\n+\t\t\t\t   ops[bbinfo[idx].first_idx]->rank,\n+\t\t\t\t   ops, &bbinfo[idx].first_idx,\n+\t\t\t\t   loop_containing_stmt (stmt));\n \t      if (new_op == NULL_TREE)\n \t\t{\n \t\t  gcc_assert (bb == last_bb);\n@@ -2956,6 +2947,28 @@ maybe_optimize_range_tests (gimple stmt)\n \t  if (bb == first_bb)\n \t    break;\n \t}\n+      for (bb = last_bb, idx = 0; ; bb = single_pred (bb), idx++)\n+\t{\n+\t  if (bbinfo[idx].first_idx < bbinfo[idx].last_idx\n+\t      && bbinfo[idx].op == NULL_TREE\n+\t      && ops[bbinfo[idx].first_idx]->op != NULL_TREE)\n+\t    {\n+\t      stmt = last_stmt (bb);\n+\t      if (integer_zerop (ops[bbinfo[idx].first_idx]->op))\n+\t\tgimple_cond_make_false (stmt);\n+\t      else if (integer_onep (ops[bbinfo[idx].first_idx]->op))\n+\t\tgimple_cond_make_true (stmt);\n+\t      else\n+\t\t{\n+\t\t  gimple_cond_set_code (stmt, NE_EXPR);\n+\t\t  gimple_cond_set_lhs (stmt, ops[bbinfo[idx].first_idx]->op);\n+\t\t  gimple_cond_set_rhs (stmt, boolean_false_node);\n+\t\t}\n+\t      update_stmt (stmt);\n+\t    }\n+\t  if (bb == first_bb)\n+\t    break;\n+\t}\n     }\n   bbinfo.release ();\n   ops.release ();"}]}