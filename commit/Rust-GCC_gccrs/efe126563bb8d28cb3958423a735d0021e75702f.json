{"sha": "efe126563bb8d28cb3958423a735d0021e75702f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlMTI2NTYzYmI4ZDI4Y2IzOTU4NDIzYTczNWQwMDIxZTc1NzAyZg==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-09-19T14:16:01Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-09-19T14:16:01Z"}, "message": "Use post-dom info to update if/switch predicate\n\n2019-09-19  Feng Xue  <fxue@os.amperecomputing.com>\n\n        * ipa-fnsummary.c (set_cond_stmt_execution_predicate): Do not compute\n        trivial predicate for condition branch.\n        (set_switch_stmt_execution_predicate): Do not compute trivial predicate\n        for switch case.\n        (compute_bb_predicates): Update predicate based on post-dominating\n        relationship.\n        (analyze_function_body): Calculate post-dominating information.\n\n2019-09-19  Feng Xue  <fxue@os.amperecomputing.com>\n\n        * gcc.dg/ipa/pr91089.c: Add a new function and pattern.\n\nFrom-SVN: r275963", "tree": {"sha": "4b84282f7c918cd7fd020036d4a789c154be8d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b84282f7c918cd7fd020036d4a789c154be8d0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efe126563bb8d28cb3958423a735d0021e75702f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe126563bb8d28cb3958423a735d0021e75702f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efe126563bb8d28cb3958423a735d0021e75702f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe126563bb8d28cb3958423a735d0021e75702f/comments", "author": null, "committer": null, "parents": [{"sha": "c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c449d3ae28ff4e133114fb67dbf7dcc7a95ca5d5"}], "stats": {"total": 140, "additions": 128, "deletions": 12}, "files": [{"sha": "279974cfab5dc2068bad34c84ca4657a245eb507", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=efe126563bb8d28cb3958423a735d0021e75702f", "patch": "@@ -1,3 +1,13 @@\n+2019-09-19  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\t* ipa-fnsummary.c (set_cond_stmt_execution_predicate): Do not compute\n+\ttrivial predicate for condition branch.\n+\t(set_switch_stmt_execution_predicate): Do not compute trivial predicate\n+\tfor switch case.\n+\t(compute_bb_predicates): Update predicate based on post-dominating\n+\trelationship.\n+\t(analyze_function_body): Calculate post-dominating information.\n+\n 2019-09-19  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vectorizable_condition): Take an int"}, {"sha": "6de060aa3fc7439ddf6937f205963972b5d20962", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=efe126563bb8d28cb3958423a735d0021e75702f", "patch": "@@ -1197,8 +1197,14 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t\t      ? code : inverted_code);\n \t  /* invert_tree_comparison will return ERROR_MARK on FP\n \t     comparsions that are not EQ/NE instead of returning proper\n-\t     unordered one.  Be sure it is not confused with NON_CONSTANT.  */\n-\t  if (this_code != ERROR_MARK)\n+\t     unordered one.  Be sure it is not confused with NON_CONSTANT.\n+\n+\t     And if the edge's target is the final block of diamond CFG graph\n+\t     of this conditional statement, we do not need to compute\n+\t     predicate for the edge because the final block's predicate must\n+\t     be at least as that of the first block of the statement.  */\n+\t  if (this_code != ERROR_MARK\n+\t      && !dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n \t    {\n \t      predicate p\n \t\t= add_condition (summary, index, size, &aggpos, this_code,\n@@ -1282,18 +1288,38 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       *(predicate *) e->aux = false;\n     }\n \n+  e = gimple_switch_edge (cfun, last, 0);\n+  /* Set BOUND_COUNT to maximum count to bypass computing predicate for\n+     default case if its target basic block is in convergence point of all\n+     switch cases, which can be determined by checking whether it\n+     post-dominates the switch statement.  */\n+  if (dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n+    bound_count = INT_MAX;\n+\n   n = gimple_switch_num_labels (last);\n   for (case_idx = 1; case_idx < n; ++case_idx)\n     {\n       tree cl = gimple_switch_label (last, case_idx);\n-      tree min, max;\n+      tree min = CASE_LOW (cl);\n+      tree max = CASE_HIGH (cl);\n       predicate p;\n \n-      e = gimple_switch_edge (cfun, last, case_idx);\n-      min = CASE_LOW (cl);\n-      max = CASE_HIGH (cl);\n+      /* The case value might not have same type as switch expression,\n+\t extend the value based on the expression type.  */\n+      if (TREE_TYPE (min) != type)\n+\tmin = wide_int_to_tree (type, wi::to_wide (min));\n \n       if (!max)\n+\tmax = min;\n+      else if (TREE_TYPE (max) != type)\n+\tmax = wide_int_to_tree (type, wi::to_wide (max));\n+\n+      /* The case's target basic block is in convergence point of all switch\n+\t cases, its predicate should be at least as that of the switch\n+\t statement.  */\n+      if (dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n+\tp = true;\n+      else if (min == max)\n \tp = add_condition (summary, index, size, &aggpos, EQ_EXPR,\n \t\t\t   unshare_expr_without_location (min));\n       else\n@@ -1305,6 +1331,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t      unshare_expr_without_location (max));\n \t  p = p1 & p2;\n \t}\n+      e = gimple_switch_edge (cfun, last, case_idx);\n       *(class predicate *) e->aux\n \t= p.or_with (summary->conds, *(class predicate *) e->aux);\n \n@@ -1334,9 +1361,6 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t    }\n \t}\n \n-      if (!max)\n-\tmax = min;\n-\n       /* Create/extend a case range.  And we count endpoints of range set,\n \t this number nearly equals to number of conditions that we will create\n \t for predicate of default case.  */\n@@ -1463,10 +1487,10 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t    break;\n \t\t}\n \t    }\n-\t  if (p == false)\n-\t    gcc_checking_assert (!bb->aux);\n-\t  else\n+\t  if (p != false)\n \t    {\n+\t      basic_block pdom_bb;\n+\n \t      if (!bb->aux)\n \t\t{\n \t\t  done = false;\n@@ -1485,6 +1509,34 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t      *((predicate *) bb->aux) = p;\n \t\t    }\n \t\t}\n+\n+\t      /* For switch/if statement, we can OR-combine predicates of all\n+\t\t its cases/branches to get predicate for basic block in their\n+\t\t convergence point, but sometimes this will generate very\n+\t\t complicated predicate.  Actually, we can get simplified\n+\t\t predicate in another way by using the fact that predicate\n+\t\t for a basic block must also hold true for its post dominators.\n+\t\t To be specific, basic block in convergence point of\n+\t\t conditional statement should include predicate of the\n+\t\t statement.  */\n+\t      pdom_bb = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n+\t      if (pdom_bb == EXIT_BLOCK_PTR_FOR_FN (my_function) || !pdom_bb)\n+\t\t;\n+\t      else if (!pdom_bb->aux)\n+\t\t{\n+\t\t  done = false;\n+\t\t  pdom_bb->aux = edge_predicate_pool.allocate ();\n+\t\t  *((predicate *) pdom_bb->aux) = p;\n+\t\t}\n+\t      else if (p != *(predicate *) pdom_bb->aux)\n+\t\t{\n+\t\t  p = p.or_with (summary->conds, *(predicate *)pdom_bb->aux);\n+\t\t  if (p != *(predicate *) pdom_bb->aux)\n+\t\t    {\n+\t\t      done = false;\n+\t\t      *((predicate *) pdom_bb->aux) = p;\n+\t\t    }\n+\t\t}\n \t    }\n \t}\n     }\n@@ -2089,6 +2141,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   if (opt_for_fn (node->decl, optimize))\n     {\n       calculate_dominance_info (CDI_DOMINATORS);\n+      calculate_dominance_info (CDI_POST_DOMINATORS);\n       if (!early)\n         loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n       else\n@@ -2469,6 +2522,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       else if (!ipa_edge_args_sum)\n \tipa_free_all_node_params ();\n       free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n     }\n   if (dump_file)\n     {"}, {"sha": "79de33c63fd2e261948df3f61037a9ead960c99f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efe126563bb8d28cb3958423a735d0021e75702f", "patch": "@@ -1,8 +1,13 @@\n+2019-09-19  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\t* gcc.dg/ipa/pr91089.c: Add a new function and pattern.\n+\n 2019-09-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91812\n \t* gcc.dg/torture/pr91812.c: New testcase.\n \n+>>>>>>> .r275960\n 2019-09-19  Tom Tromey  <tromey@adacore.com>\n \n \t* gnat.dg/bias1.adb: New testcase."}, {"sha": "7509c6222632ceacf3edc77296ab36d461928a87", "filename": "gcc/testsuite/gcc.dg/ipa/pr91089.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe126563bb8d28cb3958423a735d0021e75702f/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c?ref=efe126563bb8d28cb3958423a735d0021e75702f", "patch": "@@ -41,6 +41,52 @@ int callee (int i)\n   return data += i;\n }\n \n+int fn2 ();\n+\n+int callee_complex_predicate (int i)\n+{\n+  switch (i )\n+    {\n+      case 0:\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+      case 1:\n+\tfn ();\n+\tfn ();\n+      case -1:\n+\tfn ();\n+      case -2:\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tdata += i;\n+\tbreak;\n+    }\n+\n+  if (i == 1000)\n+    {\n+      int j;\n+\n+      for (j = 0; j < 100; j++)\n+\tfn2 ();\n+    }\n+  return i + 3;\n+}\n+\n int caller ()\n {\n   return callee (-127) +\n@@ -60,3 +106,4 @@ int caller ()\n /* { dg-final { scan-ipa-dump \"op0 != 0\"   \"fnsummary\" } } */\n /* { dg-final { scan-ipa-dump \"op0 < 5\"    \"fnsummary\" } } */\n /* { dg-final { scan-ipa-dump \"op0 > 7\"    \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"loop depth: 1 .+ time:\\[ \\]*\\[0-9\\]+ predicate: \\\\(op0 == 1000\\\\)\\[\\r\\n]+\" \"fnsummary\" } } */"}]}