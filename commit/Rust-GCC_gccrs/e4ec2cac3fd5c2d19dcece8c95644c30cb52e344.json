{"sha": "e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRlYzJjYWMzZmQ1YzJkMTlkY2VjZThjOTU2NDRjMzBjYjUyZTM0NA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2002-02-09T02:18:12Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2002-02-09T02:18:12Z"}, "message": "hooks.c: New file.\n\n* hooks.c: New file.\n* hooks.h: New file.\n* Makefile.in (HOOKS_H): New.\n(TARGET_DEF_H): Added $(HOOKS_H).\n(OBJS): Added hooks.o.\n(cfgcleanup.o, bb-reorder.o): Added target.h.\n(hooks.o): Added dependencies.\n* target-def.h (TARGET_CANNOT_MODIFY_JUMPS_P): New, added to...\n(TARGET_INITIALIZER): this.\n* doc/tm.texi (TARGET_CANNOT_MODIFY_JUMPS_P): Document.\n* target.h (struct gcc_target): Added cannot_modify_jumps_p.\n* bb-reorder.c: Include target.h.\n(reorder_basic_blocks): Skip if cannot modify jumps.\n* cfgcleanup.c: Include target.h.\n(try_optimize_cfg): Skip merge blocking if cannot modify jumps.\n\nFrom-SVN: r49627", "tree": {"sha": "923f3420128e009083834e0d815322b5f11fff42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/923f3420128e009083834e0d815322b5f11fff42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/comments", "author": null, "committer": null, "parents": [{"sha": "b6459d9a78a55b0a1906357552ccff2d2769fa8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6459d9a78a55b0a1906357552ccff2d2769fa8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6459d9a78a55b0a1906357552ccff2d2769fa8a"}], "stats": {"total": 375, "additions": 245, "deletions": 130}, "files": [{"sha": "7c2267c670c4081bd46e996808b4cbfd4b3e244b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -1,3 +1,21 @@\n+2002-02-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* hooks.c: New file.\n+\t* hooks.h: New file.\n+\t* Makefile.in (HOOKS_H): New.\n+\t(TARGET_DEF_H): Added $(HOOKS_H).\n+\t(OBJS): Added hooks.o.\n+\t(cfgcleanup.o, bb-reorder.o): Added target.h.\n+\t(hooks.o): Added dependencies.\n+\t* target-def.h (TARGET_CANNOT_MODIFY_JUMPS_P): New, added to...\n+\t(TARGET_INITIALIZER): this.\n+\t* doc/tm.texi (TARGET_CANNOT_MODIFY_JUMPS_P): Document.\n+\t* target.h (struct gcc_target): Added cannot_modify_jumps_p.\n+\t* bb-reorder.c: Include target.h.\n+\t(reorder_basic_blocks): Skip if cannot modify jumps.\n+\t* cfgcleanup.c: Include target.h.\n+\t(try_optimize_cfg): Skip merge blocking if cannot modify jumps.\n+\n 2002-02-08  Chris Demetriou  <cgd@broadcom.com>\n \n         * config/mips/mips.md (casesi_internal, casesi_internal_di):"}, {"sha": "59f1d3aff3de1a23e8feba7620c4a82b9bb0a415", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -543,7 +543,8 @@ HCONFIG_H = hconfig.h $(build_xm_file_list)\n CONFIG_H = $(GCONFIG_H) insn-constants.h insn-flags.h\n TCONFIG_H = tconfig.h $(xm_file_list)\n TARGET_H = target.h\n-TARGET_DEF_H = target-def.h\n+HOOKS_H = hooks.h\n+TARGET_DEF_H = target-def.h $(HOOKS_H)\n TM_P_H = tm_p.h $(tm_p_file_list) tm-preds.h\n \n MACHMODE_H = machmode.h machmode.def\n@@ -718,7 +719,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t\\\n  df.o diagnostic.o doloop.o dominance.o dwarf2asm.o dwarf2out.o dwarfout.o \\\n  emit-rtl.o except.o explow.o expmed.o expr.o final.o flow.o \t\t\\\n  fold-const.o function.o gcse.o genrtl.o ggc-common.o global.o graph.o\t\\\n- haifa-sched.o hash.o hashtable.o ifcvt.o insn-attrtab.o insn-emit.o\t\\\n+ haifa-sched.o hash.o hashtable.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o \\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t\\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o \t\\\n  loop.o mbchar.o optabs.o params.o predict.o print-rtl.o print-tree.o\t\\\n@@ -1495,7 +1496,7 @@ cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) flags.h insn-config.h \\\n    function.h except.h $(GGC_H) \n cfgcleanup.o : cfgcleanup.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TIMEVAR_H)\\\n    $(BASIC_BLOCK_H) hard-reg-set.h output.h flags.h $(RECOG_H) toplev.h \\\n-   $(GGC_H) insn-config.h cselib.h $(TM_P_H)\n+   $(GGC_H) insn-config.h cselib.h $(TARGET_H) $(TM_P_H)\n cfgloop.o : cfgloop.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) hard-reg-set.h \\\n@@ -1564,8 +1565,8 @@ predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) function.h except.h $(EXPR_H) $(TM_P_H) $(PREDICT_H)\n lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) toplev.h $(RTL_H) $(GGC_H)\n-bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h\n+bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n+   flags.h $(BASIC_BLOCK_H) hard-reg-set.h output.h cfglayout.h $(TARGET_H)\n cfglayout.o : cfglayout.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    insn-config.h $(BASIC_BLOCK_H) hard-reg-set.h output.h function.h \\\n    cfglayout.h\n@@ -1579,6 +1580,7 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) toplev.h \\\n dependence.o : dependence.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) \\\n    $(C_COMMON_H) flags.h varray.h $(EXPR_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) $(PARAMS_H) toplev.h\n+hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) $(HOOKS_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) $(GGC_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\"}, {"sha": "2578604889ec59ca76be6d57b19c7b0db0b67b43", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -1,5 +1,5 @@\n /* Basic block reordering routines for the GNU compiler.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -89,6 +89,7 @@\n #include \"flags.h\"\n #include \"output.h\"\n #include \"cfglayout.h\"\n+#include \"target.h\"\n \n /* Local function prototypes.  */\n static void make_reorder_chain\t\tPARAMS ((void));\n@@ -260,6 +261,9 @@ reorder_basic_blocks ()\n   if (n_basic_blocks <= 1)\n     return;\n \n+  if ((* targetm.cannot_modify_jumps_p) ())\n+    return;\n+\n   cfg_layout_initialize ();\n \n   make_reorder_chain ();"}, {"sha": "d9f9cf261e5c10afbe7dcfabd6a22d1b1f9b4f0b", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 133, "deletions": 123, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -44,6 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"cselib.h\"\n #include \"tm_p.h\"\n+#include \"target.h\"\n \n #include \"obstack.h\"\n \n@@ -1531,149 +1532,158 @@ try_optimize_cfg (mode)\n   for (i = 0; i < n_basic_blocks; i++)\n     update_forwarder_flag (BASIC_BLOCK (i));\n \n-  /* Attempt to merge blocks as made possible by edge removal.  If a block\n-     has only one successor, and the successor has only one predecessor,\n-     they may be combined.  */\n-  do\n+  if (! (* targetm.cannot_modify_jumps_p) ())\n     {\n-      changed = false;\n-      iterations++;\n-\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \"\\n\\ntry_optimize_cfg iteration %i\\n\\n\",\n-\t\t iterations);\n-\n-      for (i = 0; i < n_basic_blocks;)\n+      /* Attempt to merge blocks as made possible by edge removal.  If\n+\t a block has only one successor, and the successor has only\n+\t one predecessor, they may be combined.  */\n+      do\n \t{\n-\t  basic_block c, b = BASIC_BLOCK (i);\n-\t  edge s;\n-\t  bool changed_here = false;\n+\t  changed = false;\n+\t  iterations++;\n+\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"\\n\\ntry_optimize_cfg iteration %i\\n\\n\",\n+\t\t     iterations);\n \n-\t  /* Delete trivially dead basic blocks.  */\n-\t  while (b->pred == NULL)\n+\t  for (i = 0; i < n_basic_blocks;)\n \t    {\n-\t      c = BASIC_BLOCK (b->index - 1);\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Deleting block %i.\\n\", b->index);\n+\t      basic_block c, b = BASIC_BLOCK (i);\n+\t      edge s;\n+\t      bool changed_here = false;\n \n-\t      flow_delete_block (b);\n-\t      changed = true;\n-\t      b = c;\n-\t    }\n+\t      /* Delete trivially dead basic blocks.  */\n+\t      while (b->pred == NULL)\n+\t\t{\n+\t\t  c = BASIC_BLOCK (b->index - 1);\n+\t\t  if (rtl_dump_file)\n+\t\t    fprintf (rtl_dump_file, \"Deleting block %i.\\n\",\n+\t\t\t     b->index);\n+\n+\t\t  flow_delete_block (b);\n+\t\t  changed = true;\n+\t\t  b = c;\n+\t\t}\n \n-\t  /* Remove code labels no longer used.  Don't do this before\n-\t     CALL_PLACEHOLDER is removed, as some branches may be hidden\n-\t     within.  */\n-\t  if (b->pred->pred_next == NULL\n-\t      && (b->pred->flags & EDGE_FALLTHRU)\n-\t      && !(b->pred->flags & EDGE_COMPLEX)\n-\t      && GET_CODE (b->head) == CODE_LABEL\n-\t      && (!(mode & CLEANUP_PRE_SIBCALL)\n-\t\t  || !tail_recursion_label_p (b->head))\n-\t      /* If the previous block ends with a branch to this block,\n-\t\t we can't delete the label.  Normally this is a condjump\n-\t\t that is yet to be simplified, but if CASE_DROPS_THRU,\n-\t\t this can be a tablejump with some element going to the\n-\t\t same place as the default (fallthru).  */\n-\t      && (b->pred->src == ENTRY_BLOCK_PTR\n-\t\t  || GET_CODE (b->pred->src->end) != JUMP_INSN\n-\t\t  || ! label_is_jump_target_p (b->head, b->pred->src->end)))\n-\t    {\n-\t      rtx label = b->head;\n+\t      /* Remove code labels no longer used.  Don't do this\n+\t\t before CALL_PLACEHOLDER is removed, as some branches\n+\t\t may be hidden within.  */\n+\t      if (b->pred->pred_next == NULL\n+\t\t  && (b->pred->flags & EDGE_FALLTHRU)\n+\t\t  && !(b->pred->flags & EDGE_COMPLEX)\n+\t\t  && GET_CODE (b->head) == CODE_LABEL\n+\t\t  && (!(mode & CLEANUP_PRE_SIBCALL)\n+\t\t      || !tail_recursion_label_p (b->head))\n+\t\t  /* If the previous block ends with a branch to this\n+\t\t     block, we can't delete the label.  Normally this\n+\t\t     is a condjump that is yet to be simplified, but\n+\t\t     if CASE_DROPS_THRU, this can be a tablejump with\n+\t\t     some element going to the same place as the\n+\t\t     default (fallthru).  */\n+\t\t  && (b->pred->src == ENTRY_BLOCK_PTR\n+\t\t      || GET_CODE (b->pred->src->end) != JUMP_INSN\n+\t\t      || ! label_is_jump_target_p (b->head,\n+\t\t\t\t\t\t   b->pred->src->end)))\n+\t\t{\n+\t\t  rtx label = b->head;\n \n-\t      b->head = NEXT_INSN (b->head);\n-\t      delete_insn_chain (label, label);\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n-\t\t\t b->index);\n-\t    }\n+\t\t  b->head = NEXT_INSN (b->head);\n+\t\t  delete_insn_chain (label, label);\n+\t\t  if (rtl_dump_file)\n+\t\t    fprintf (rtl_dump_file, \"Deleted label in block %i.\\n\",\n+\t\t\t     b->index);\n+\t\t}\n \n-\t  /* If we fall through an empty block, we can remove it.  */\n-\t  if (b->pred->pred_next == NULL\n-\t      && (b->pred->flags & EDGE_FALLTHRU)\n-\t      && GET_CODE (b->head) != CODE_LABEL\n-\t      && FORWARDER_BLOCK_P (b)\n-\t      /* Note that forwarder_block_p true ensures that there\n-\t\t is a successor for this block.  */\n-\t      && (b->succ->flags & EDGE_FALLTHRU)\n-\t      && n_basic_blocks > 1)\n-\t    {\n-\t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n-\t\t\t b->index);\n+\t      /* If we fall through an empty block, we can remove it.  */\n+\t      if (b->pred->pred_next == NULL\n+\t\t  && (b->pred->flags & EDGE_FALLTHRU)\n+\t\t  && GET_CODE (b->head) != CODE_LABEL\n+\t\t  && FORWARDER_BLOCK_P (b)\n+\t\t  /* Note that forwarder_block_p true ensures that\n+\t\t     there is a successor for this block.  */\n+\t\t  && (b->succ->flags & EDGE_FALLTHRU)\n+\t\t  && n_basic_blocks > 1)\n+\t\t{\n+\t\t  if (rtl_dump_file)\n+\t\t    fprintf (rtl_dump_file,\n+\t\t\t     \"Deleting fallthru block %i.\\n\",\n+\t\t\t     b->index);\n+\n+\t\t  c = BASIC_BLOCK (b->index ? b->index - 1 : 1);\n+\t\t  redirect_edge_succ_nodup (b->pred, b->succ->dest);\n+\t\t  flow_delete_block (b);\n+\t\t  changed = true;\n+\t\t  b = c;\n+\t\t}\n \n-\t      c = BASIC_BLOCK (b->index ? b->index - 1 : 1);\n-\t      redirect_edge_succ_nodup (b->pred, b->succ->dest);\n-\t      flow_delete_block (b);\n-\t      changed = true;\n-\t      b = c;\n-\t    }\n+\t      /* Merge blocks.  Loop because chains of blocks might be\n+\t\t combineable.  */\n+\t      while ((s = b->succ) != NULL\n+\t\t     && s->succ_next == NULL\n+\t\t     && !(s->flags & EDGE_COMPLEX)\n+\t\t     && (c = s->dest) != EXIT_BLOCK_PTR\n+\t\t     && c->pred->pred_next == NULL\n+\t\t     /* If the jump insn has side effects,\n+\t\t\twe can't kill the edge.  */\n+\t\t     && (GET_CODE (b->end) != JUMP_INSN\n+\t\t\t || onlyjump_p (b->end))\n+\t\t     && merge_blocks (s, b, c, mode))\n+\t\tchanged_here = true;\n+\n+\t      /* Simplify branch over branch.  */\n+\t      if ((mode & CLEANUP_EXPENSIVE) && try_simplify_condjump (b))\n+\t\t{\n+\t\t  BB_SET_FLAG (b, BB_UPDATE_LIFE);\n+\t\t  changed_here = true;\n+\t\t}\n \n-\t  /* Merge blocks.  Loop because chains of blocks might be\n-\t     combineable.  */\n-\t  while ((s = b->succ) != NULL\n-\t\t && s->succ_next == NULL\n-\t         && !(s->flags & EDGE_COMPLEX)\n-\t\t && (c = s->dest) != EXIT_BLOCK_PTR\n-\t\t && c->pred->pred_next == NULL\n-\t\t /* If the jump insn has side effects,\n-\t\t    we can't kill the edge.  */\n-\t\t && (GET_CODE (b->end) != JUMP_INSN\n-\t\t     || onlyjump_p (b->end))\n-\t\t && merge_blocks (s, b, c, mode))\n-\t    changed_here = true;\n-\n-\t  /* Simplify branch over branch.  */\n-\t  if ((mode & CLEANUP_EXPENSIVE) && try_simplify_condjump (b))\n-\t    {\n-\t      BB_SET_FLAG (b, BB_UPDATE_LIFE);\n-\t      changed_here = true;\n-\t    }\n+\t      /* If B has a single outgoing edge, but uses a\n+\t\t non-trivial jump instruction without side-effects, we\n+\t\t can either delete the jump entirely, or replace it\n+\t\t with a simple unconditional jump.  Use\n+\t\t redirect_edge_and_branch to do the dirty work.  */\n+\t      if (b->succ\n+\t\t  && ! b->succ->succ_next\n+\t\t  && b->succ->dest != EXIT_BLOCK_PTR\n+\t\t  && onlyjump_p (b->end)\n+\t\t  && redirect_edge_and_branch (b->succ, b->succ->dest))\n+\t\t{\n+\t\t  BB_SET_FLAG (b, BB_UPDATE_LIFE);\n+\t\t  update_forwarder_flag (b);\n+\t\t  changed_here = true;\n+\t\t}\n \n-\t  /* If B has a single outgoing edge, but uses a non-trivial jump\n-\t     instruction without side-effects, we can either delete the\n-\t     jump entirely, or replace it with a simple unconditional jump.\n-\t     Use redirect_edge_and_branch to do the dirty work.  */\n-\t  if (b->succ\n-\t      && ! b->succ->succ_next\n-\t      && b->succ->dest != EXIT_BLOCK_PTR\n-\t      && onlyjump_p (b->end)\n-\t      && redirect_edge_and_branch (b->succ, b->succ->dest))\n-\t    {\n-\t      BB_SET_FLAG (b, BB_UPDATE_LIFE);\n-\t      update_forwarder_flag (b);\n-\t      changed_here = true;\n-\t    }\n+\t      /* Simplify branch to branch.  */\n+\t      if (try_forward_edges (mode, b))\n+\t\tchanged_here = true;\n \n-\t  /* Simplify branch to branch.  */\n-\t  if (try_forward_edges (mode, b))\n-\t    changed_here = true;\n+\t      /* Look for shared code between blocks.  */\n+\t      if ((mode & CLEANUP_CROSSJUMP)\n+\t\t  && try_crossjump_bb (mode, b))\n+\t\tchanged_here = true;\n \n-\t  /* Look for shared code between blocks.  */\n-\t  if ((mode & CLEANUP_CROSSJUMP)\n-\t      && try_crossjump_bb (mode, b))\n-\t    changed_here = true;\n+\t      /* Don't get confused by the index shift caused by\n+\t\t deleting blocks.  */\n+\t      if (!changed_here)\n+\t\ti = b->index + 1;\n+\t      else\n+\t\tchanged = true;\n+\t    }\n \n-\t  /* Don't get confused by the index shift caused by deleting\n-\t     blocks.  */\n-\t  if (!changed_here)\n-\t    i = b->index + 1;\n-\t  else\n+\t  if ((mode & CLEANUP_CROSSJUMP)\n+\t      && try_crossjump_bb (mode, EXIT_BLOCK_PTR))\n \t    changed = true;\n-\t}\n-\n-      if ((mode & CLEANUP_CROSSJUMP)\n-\t  && try_crossjump_bb (mode, EXIT_BLOCK_PTR))\n-\tchanged = true;\n \n #ifdef ENABLE_CHECKING\n-      if (changed)\n-\tverify_flow_info ();\n+\t  if (changed)\n+\t    verify_flow_info ();\n #endif\n \n-      changed_overall |= changed;\n+\t  changed_overall |= changed;\n+\t}\n+      while (changed);\n     }\n-  while (changed);\n \n   if (mode & CLEANUP_CROSSJUMP)\n     remove_fake_edges ();"}, {"sha": "3cb5c68c5faf9430bd4b1cc9569240c6336d7b10", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -8616,3 +8616,18 @@ object files that are not referenced from @code{main} and uses export\n lists.\n \n @end table\n+\n+@deftypefn {Target Hook} bool TARGET_CANNOT_MODIFY_JUMPS_P (void)\n+This target hook returns @code{true} past the point in which new jump\n+instructions could be created.  On machines that require a register for\n+every jump such as the SHmedia ISA of SH5, this point would typically be\n+reload, so this target hook should be defined to a function such as:\n+\n+@smallexample\n+static bool\n+cannot_modify_jumps_past_reload_p ()\n+@{\n+  return (reload_completed || reload_in_progress);\n+@}\n+@end smallexample\n+@end deftypefn"}, {"sha": "387f4db961a8697b7af3cee8499c31385d804680", "filename": "gcc/hooks.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -0,0 +1,34 @@\n+/* General-purpose hooks.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+/* This file contains generic hooks that can be used as defaults for\n+   target or language-dependent hook initializers.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"hooks.h\"\n+\n+/* Generic hook that takes no arguments and returns false.  */\n+bool\n+hook_void_bool_false ()\n+{\n+  return false;\n+}"}, {"sha": "7a8daa55d7fd52502e44b28eb98e6fbd5946f4a7", "filename": "gcc/hooks.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -0,0 +1,22 @@\n+/* General-purpose hooks.\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+ In other words, you are welcome to use, share and improve this program.\n+ You are forbidden to forbid anyone else to use, share and improve\n+ what you give them.   Help stamp out software-hoarding!  */\n+\n+bool hook_void_bool_false PARAMS ((void));"}, {"sha": "71987f5caf6b30474c2395ed056f3e59ddcf0bb9", "filename": "gcc/target-def.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -175,6 +175,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SECTION_TYPE_FLAGS default_section_type_flags\n #endif\n \n+/* In hook.c.  */\n+#define TARGET_CANNOT_MODIFY_JUMPS_P hook_void_bool_false\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -192,5 +195,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_EXPAND_BUILTIN,\t\t\t\\\n   TARGET_SECTION_TYPE_FLAGS,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n-  TARGET_HAVE_CTORS_DTORS\t\t\t\\\n+  TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n+  TARGET_CANNOT_MODIFY_JUMPS_P\t\t\t\\\n }\n+\n+#include \"hooks.h\""}, {"sha": "5ee9aa64d57746a499e5f47d334d2244120c4223", "filename": "gcc/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4ec2cac3fd5c2d19dcece8c95644c30cb52e344/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e4ec2cac3fd5c2d19dcece8c95644c30cb52e344", "patch": "@@ -184,6 +184,10 @@ struct gcc_target\n   /* True if \"native\" constructors and destructors are supported,\n      false if we're using collect2 for the job.  */\n   bool have_ctors_dtors;\n+\n+  /* True if new jumps cannot be created, to replace existing ones or\n+     not, at the current point in the compilation.  */\n+  bool (* cannot_modify_jumps_p) PARAMS ((void));\n };\n \n extern struct gcc_target targetm;"}]}