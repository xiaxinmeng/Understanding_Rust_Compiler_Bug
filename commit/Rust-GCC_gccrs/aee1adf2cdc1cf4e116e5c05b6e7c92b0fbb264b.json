{"sha": "aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "node_id": "C_kwDOANBUbNoAKGFlZTFhZGYyY2RjMWNmNGUxMTZlNWMwNWI2ZTdjOTJiMGZiYjI2NGI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-23T14:14:58Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-23T23:51:26Z"}, "message": "analyzer: handle __attribute__((const)) [PR104434]\n\nWhen testing -fanalyzer on openblas-0.3, I noticed slightly over 2000\nfalse positives from -Wanalyzer-malloc-leak on code like this:\n\n        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n            pt_t = (lapack_complex_float*)\n                LAPACKE_malloc( sizeof(lapack_complex_float) *\n                                ldpt_t * MAX(1,n) );\n            [...snip...]\n        }\n\n        [...snip lots of code...]\n\n        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n            LAPACKE_free( pt_t );\n        }\n\nwhere LAPACKE_lsame is a char-comparison function implemented in a\ndifferent TU.\nThe analyzer naively considers the execution path where:\n  LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' )\nis true at the malloc guard, but then false at the free guard, which\nis thus a memory leak.\n\nThis patch makes -fanalyer respect __attribute__((const)), so that the\nanalyzer treats such functions as returning the same value when given\nthe same inputs.\n\nI've filed https://github.com/xianyi/OpenBLAS/issues/3543 suggesting that\nLAPACKE_lsame be annotated with __attribute__((const)); with that, and\nwith this patch, the false positives seem to be fixed.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104434\n\t* analyzer.h (class const_fn_result_svalue): New decl.\n\t* region-model-impl-calls.cc (call_details::get_manager): New.\n\t* region-model-manager.cc\n\t(region_model_manager::get_or_create_const_fn_result_svalue): New.\n\t(region_model_manager::log_stats): Log\n\tm_const_fn_result_values_map.\n\t* region-model.cc (const_fn_p): New.\n\t(maybe_get_const_fn_result): New.\n\t(region_model::on_call_pre): Handle fndecls with\n\t__attribute__((const)) by calling the above rather than making\n\ta conjured_svalue.\n\t* region-model.h (visitor::visit_const_fn_result_svalue): New.\n\t(region_model_manager::get_or_create_const_fn_result_svalue): New\n\tdecl.\n\t(region_model_manager::const_fn_result_values_map_t): New typedef.\n\t(region_model_manager::m_const_fn_result_values_map): New field.\n\t(call_details::get_manager): New decl.\n\t* svalue.cc (svalue::cmp_ptr): Handle SK_CONST_FN_RESULT.\n\t(const_fn_result_svalue::dump_to_pp): New.\n\t(const_fn_result_svalue::dump_input): New.\n\t(const_fn_result_svalue::accept): New.\n\t* svalue.h (enum svalue_kind): Add SK_CONST_FN_RESULT.\n\t(svalue::dyn_cast_const_fn_result_svalue): New.\n\t(class const_fn_result_svalue): New.\n\t(is_a_helper <const const_fn_result_svalue *>::test): New.\n\t(template <> struct default_hash_traits<const_fn_result_svalue::key_t>):\n\tNew.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104434\n\t* gcc.dg/analyzer/attr-const-1.c: New test.\n\t* gcc.dg/analyzer/attr-const-2.c: New test.\n\t* gcc.dg/analyzer/attr-const-3.c: New test.\n\t* gcc.dg/analyzer/pr104434-const.c: New test.\n\t* gcc.dg/analyzer/pr104434-nonconst.c: New test.\n\t* gcc.dg/analyzer/pr104434.h: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "aecbdc03e6faa33ed77e493db72d474f8b58c7e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aecbdc03e6faa33ed77e493db72d474f8b58c7e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcea7c1ef6586bb1eb0144b741969748cbd780b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdcea7c1ef6586bb1eb0144b741969748cbd780b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdcea7c1ef6586bb1eb0144b741969748cbd780b"}], "stats": {"total": 960, "additions": 954, "deletions": 6}, "files": [{"sha": "36db4f2b53855ee91523e9ce50a86b6e101a1885", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -54,6 +54,7 @@ class svalue;\n   class compound_svalue;\n   class conjured_svalue;\n   class asm_output_svalue;\n+  class const_fn_result_svalue;\n typedef hash_set<const svalue *> svalue_set;\n class region;\n   class frame_region;"}, {"sha": "65daa342824c02a07abee7737801a04171a1003f", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -80,6 +80,14 @@ call_details::call_details (const gcall *call, region_model *model,\n     }\n }\n \n+/* Get the manager from m_model.  */\n+\n+region_model_manager *\n+call_details::get_manager () const\n+{\n+  return m_model->get_manager ();\n+}\n+\n /* Get any uncertainty_t associated with the region_model_context.  */\n \n uncertainty_t *"}, {"sha": "bc8f554580b6608eb692b45ff05832107a283ade", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -1232,6 +1232,32 @@ get_or_create_asm_output_svalue (tree type,\n   return asm_output_sval;\n }\n \n+\n+/* Return the svalue * of type TYPE for the result of a call to FNDECL\n+   with __attribute__((const)), given INPUTS as inputs.  */\n+\n+const svalue *\n+region_model_manager::\n+get_or_create_const_fn_result_svalue (tree type,\n+\t\t\t\t      tree fndecl,\n+\t\t\t\t      const vec<const svalue *> &inputs)\n+{\n+  gcc_assert (type);\n+  gcc_assert (fndecl);\n+  gcc_assert (DECL_P (fndecl));\n+  gcc_assert (TREE_READONLY (fndecl));\n+  gcc_assert (inputs.length () <= const_fn_result_svalue::MAX_INPUTS);\n+\n+  const_fn_result_svalue::key_t key (type, fndecl, inputs);\n+  if (const_fn_result_svalue **slot = m_const_fn_result_values_map.get (key))\n+    return *slot;\n+  const_fn_result_svalue *const_fn_result_sval\n+    = new const_fn_result_svalue (type, fndecl, inputs);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (const_fn_result_sval);\n+  m_const_fn_result_values_map.put (key, const_fn_result_sval);\n+  return const_fn_result_sval;\n+}\n+\n /* Given STRING_CST, a STRING_CST and BYTE_OFFSET_CST a constant,\n    attempt to get the character at that offset, returning either\n    the svalue for the character constant, or NULL if unsuccessful.  */\n@@ -1671,6 +1697,8 @@ region_model_manager::log_stats (logger *logger, bool show_objs) const\n   log_uniq_map (logger, show_objs, \"conjured_svalue\", m_conjured_values_map);\n   log_uniq_map (logger, show_objs, \"asm_output_svalue\",\n \t\tm_asm_output_values_map);\n+  log_uniq_map (logger, show_objs, \"const_fn_result_svalue\",\n+\t\tm_const_fn_result_values_map);\n \n   logger->log (\"max accepted svalue num_nodes: %i\",\n \t       m_max_complexity.m_num_nodes);"}, {"sha": "5cfa3543f17eb931da67648a4912cca2880e121a", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -1207,6 +1207,51 @@ region_model::check_call_args (const call_details &cd) const\n     cd.get_arg_svalue (arg_idx);\n }\n \n+/* Return true if CD is known to be a call to a function with\n+   __attribute__((const)).  */\n+\n+static bool\n+const_fn_p (const call_details &cd)\n+{\n+  tree fndecl = cd.get_fndecl_for_call ();\n+  if (!fndecl)\n+    return false;\n+  gcc_assert (DECL_P (fndecl));\n+  return TREE_READONLY (fndecl);\n+}\n+\n+/* If this CD is known to be a call to a function with\n+   __attribute__((const)), attempt to get a const_fn_result_svalue\n+   based on the arguments, or return NULL otherwise.  */\n+\n+static const svalue *\n+maybe_get_const_fn_result (const call_details &cd)\n+{\n+  if (!const_fn_p (cd))\n+    return NULL;\n+\n+  unsigned num_args = cd.num_args ();\n+  if (num_args > const_fn_result_svalue::MAX_INPUTS)\n+    /* Too many arguments.  */\n+    return NULL;\n+\n+  auto_vec<const svalue *> inputs (num_args);\n+  for (unsigned arg_idx = 0; arg_idx < num_args; arg_idx++)\n+    {\n+      const svalue *arg_sval = cd.get_arg_svalue (arg_idx);\n+      if (!arg_sval->can_have_associated_state_p ())\n+\treturn NULL;\n+      inputs.quick_push (arg_sval);\n+    }\n+\n+  region_model_manager *mgr = cd.get_manager ();\n+  const svalue *sval\n+    = mgr->get_or_create_const_fn_result_svalue (cd.get_lhs_type (),\n+\t\t\t\t\t\t cd.get_fndecl_for_call (),\n+\t\t\t\t\t\t inputs);\n+  return sval;\n+}\n+\n /* Update this model for the CALL stmt, using CTXT to report any\n    diagnostics - the first half.\n \n@@ -1245,10 +1290,16 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n   if (tree lhs = gimple_call_lhs (call))\n     {\n       const region *lhs_region = get_lvalue (lhs, ctxt);\n-      const svalue *sval\n-\t= m_mgr->get_or_create_conjured_svalue (TREE_TYPE (lhs), call,\n-\t\t\t\t\t\tlhs_region);\n-      purge_state_involving (sval, ctxt);\n+      const svalue *sval = maybe_get_const_fn_result (cd);\n+      if (!sval)\n+\t{\n+\t  /* For the common case of functions without __attribute__((const)),\n+\t     use a conjured value, and purge any prior state involving that\n+\t     value (in case this is in a loop).  */\n+\t  sval = m_mgr->get_or_create_conjured_svalue (TREE_TYPE (lhs), call,\n+\t\t\t\t\t\t       lhs_region);\n+\t  purge_state_involving (sval, ctxt);\n+\t}\n       set_value (lhs_region, sval, ctxt);\n     }\n "}, {"sha": "aa489d06a38eb9fad18bb20faf81f8783bbd793b", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -224,6 +224,7 @@ class visitor\n   virtual void visit_compound_svalue (const compound_svalue *) {}\n   virtual void visit_conjured_svalue (const conjured_svalue *) {}\n   virtual void visit_asm_output_svalue (const asm_output_svalue *) {}\n+  virtual void visit_const_fn_result_svalue (const const_fn_result_svalue *) {}\n \n   virtual void visit_region (const region *) {}\n };\n@@ -282,6 +283,10 @@ class region_model_manager\n \t\t\t\t   const gasm *asm_stmt,\n \t\t\t\t   unsigned output_idx,\n \t\t\t\t   const vec<const svalue *> &inputs);\n+  const svalue *\n+  get_or_create_const_fn_result_svalue (tree type,\n+\t\t\t\t\ttree fndecl,\n+\t\t\t\t\tconst vec<const svalue *> &inputs);\n \n   const svalue *maybe_get_char_from_string_cst (tree string_cst,\n \t\t\t\t\t\ttree byte_offset_cst);\n@@ -436,6 +441,10 @@ class region_model_manager\n \t\t   asm_output_svalue *> asm_output_values_map_t;\n   asm_output_values_map_t m_asm_output_values_map;\n \n+  typedef hash_map<const_fn_result_svalue::key_t,\n+\t\t   const_fn_result_svalue *> const_fn_result_values_map_t;\n+  const_fn_result_values_map_t m_const_fn_result_values_map;\n+\n   bool m_checking_feasibility;\n \n   /* \"Dynamically-allocated\" svalue instances.\n@@ -496,6 +505,7 @@ class call_details\n   call_details (const gcall *call, region_model *model,\n \t\tregion_model_context *ctxt);\n \n+  region_model_manager *get_manager () const;\n   region_model_context *get_ctxt () const { return m_ctxt; }\n   uncertainty_t *get_uncertainty () const;\n   tree get_lhs_type () const { return m_lhs_type; }"}, {"sha": "553edae7250d62bb7767bc8805be24d7a4e84a2f", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -540,6 +540,26 @@ svalue::cmp_ptr (const svalue *sval1, const svalue *sval2)\n \treturn 0;\n       }\n       break;\n+    case SK_CONST_FN_RESULT:\n+      {\n+\tconst const_fn_result_svalue *const_fn_result_sval1\n+\t  = (const const_fn_result_svalue *)sval1;\n+\tconst const_fn_result_svalue *const_fn_result_sval2\n+\t  = (const const_fn_result_svalue *)sval2;\n+\tint d1 = DECL_UID (const_fn_result_sval1->get_fndecl ());\n+\tint d2 = DECL_UID (const_fn_result_sval2->get_fndecl ());\n+\tif (int cmp_fndecl = d1 - d2)\n+\t  return cmp_fndecl;\n+\tif (int cmp = ((int)const_fn_result_sval1->get_num_inputs ()\n+\t\t       - (int)const_fn_result_sval2->get_num_inputs ()))\n+\t  return cmp;\n+\tfor (unsigned i = 0; i < const_fn_result_sval1->get_num_inputs (); i++)\n+\t  if (int input_cmp\n+\t      = svalue::cmp_ptr (const_fn_result_sval1->get_input (i),\n+\t\t\t\t const_fn_result_sval2->get_input (i)))\n+\t    return input_cmp;\n+\treturn 0;\n+      }\n     }\n }\n \n@@ -1892,6 +1912,59 @@ asm_output_svalue::accept (visitor *v) const\n     m_input_arr[i]->accept (v);\n }\n \n+/* class const_fn_result_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for const_fn_result_svalue.  */\n+\n+void\n+const_fn_result_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_printf (pp, \"CONST_FN_RESULT(%qD, {\", m_fndecl);\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  dump_input (pp, i, m_input_arr[i], simple);\n+\t}\n+      pp_string (pp, \"})\");\n+    }\n+  else\n+    {\n+      pp_printf (pp, \"CONST_FN_RESULT(%qD, {\", m_fndecl);\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  dump_input (pp, i, m_input_arr[i], simple);\n+\t}\n+      pp_string (pp, \"})\");\n+    }\n+}\n+\n+/* Subroutine of const_fn_result_svalue::dump_to_pp.  */\n+\n+void\n+const_fn_result_svalue::dump_input (pretty_printer *pp,\n+\t\t\t\t    unsigned input_idx,\n+\t\t\t\t    const svalue *sval,\n+\t\t\t\t    bool simple) const\n+{\n+  pp_printf (pp, \"arg%i: \", input_idx);\n+  sval->dump_to_pp (pp, simple);\n+}\n+\n+/* Implementation of svalue::accept vfunc for const_fn_result_svalue.  */\n+\n+void\n+const_fn_result_svalue::accept (visitor *v) const\n+{\n+  v->visit_const_fn_result_svalue (this);\n+  for (unsigned i = 0; i < m_num_inputs; i++)\n+    m_input_arr[i]->accept (v);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "8040712ec2eb5d9c2025be60867fce6848cc495d", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 131, "deletions": 2, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -48,7 +48,8 @@ enum svalue_kind\n   SK_WIDENING,\n   SK_COMPOUND,\n   SK_CONJURED,\n-  SK_ASM_OUTPUT\n+  SK_ASM_OUTPUT,\n+  SK_CONST_FN_RESULT\n };\n \n /* svalue and its subclasses.\n@@ -77,7 +78,9 @@ enum svalue_kind\n      compound_svalue (SK_COMPOUND): a mapping of bit-ranges to svalues\n      conjured_svalue (SK_CONJURED): a value arising from a stmt\n      asm_output_svalue (SK_ASM_OUTPUT): an output from a deterministic\n-       asm stmt.  */\n+       asm stmt.\n+     const_fn_result_svalue (SK_CONST_FN_RESULT): the return value from\n+       a function with __attribute((const)) for given inputs.  */\n \n /* An abstract base class representing a value held by a region of memory.  */\n \n@@ -129,6 +132,8 @@ class svalue\n   dyn_cast_conjured_svalue () const { return NULL; }\n   virtual const asm_output_svalue *\n   dyn_cast_asm_output_svalue () const { return NULL; }\n+  virtual const const_fn_result_svalue *\n+  dyn_cast_const_fn_result_svalue () const { return NULL; }\n \n   tree maybe_get_constant () const;\n   const region *maybe_get_region () const;\n@@ -1535,4 +1540,128 @@ template <> struct default_hash_traits<asm_output_svalue::key_t>\n {\n   static const bool empty_zero_p = true;\n };\n+\n+namespace ana {\n+\n+/* The return value from a function with __attribute((const)) for given\n+   inputs, provided that we don't have too many inputs, and all of them\n+   are deterministic.\n+\n+   Comparisons of variables that share the same const_fn_result_svalue are known\n+   to be equal, even if we don't know what the value is.  */\n+\n+class const_fn_result_svalue : public svalue\n+{\n+public:\n+  /* Imposing an upper limit and using a (small) array allows key_t\n+     to avoid memory management.  */\n+  static const unsigned MAX_INPUTS = 2;\n+\n+  /* A support class for uniquifying instances of const_fn_result_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type,\n+\t   tree fndecl,\n+\t   const vec<const svalue *> &inputs)\n+    : m_type (type), m_fndecl (fndecl),\n+      m_num_inputs (inputs.length ())\n+    {\n+      gcc_assert (inputs.length () <= MAX_INPUTS);\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\tm_input_arr[i] = inputs[i];\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      hstate.add_ptr (m_fndecl);\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\thstate.add_ptr (m_input_arr[i]);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      if (!(m_type == other.m_type\n+\t    && m_fndecl == other.m_fndecl\n+\t    && m_num_inputs == other.m_num_inputs))\n+\treturn false;\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\tif (m_input_arr[i] != other.m_input_arr[i])\n+\t  return false;\n+      return true;\n+    }\n+\n+    /* Use m_fndecl to mark empty/deleted.  */\n+    void mark_deleted () { m_fndecl = reinterpret_cast<tree> (1); }\n+    void mark_empty () { m_fndecl = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_fndecl == reinterpret_cast<tree> (1);\n+    }\n+    bool is_empty () const { return m_fndecl == NULL; }\n+\n+    tree m_type;\n+    tree m_fndecl;\n+    unsigned m_num_inputs;\n+    const svalue *m_input_arr[MAX_INPUTS];\n+  };\n+\n+  const_fn_result_svalue (tree type,\n+\t\t\t  tree fndecl,\n+\t\t\t  const vec<const svalue *> &inputs)\n+  : svalue (complexity::from_vec_svalue (inputs), type),\n+    m_fndecl (fndecl),\n+    m_num_inputs (inputs.length ())\n+  {\n+    gcc_assert (inputs.length () <= MAX_INPUTS);\n+    for (unsigned i = 0; i < m_num_inputs; i++)\n+      m_input_arr[i] = inputs[i];\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE\n+  {\n+    return SK_CONST_FN_RESULT;\n+  }\n+  const const_fn_result_svalue *\n+  dyn_cast_const_fn_result_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  tree get_fndecl () const { return m_fndecl; }\n+  unsigned get_num_inputs () const { return m_num_inputs; }\n+  const svalue *get_input (unsigned idx) const { return m_input_arr[idx]; }\n+\n+ private:\n+  void dump_input (pretty_printer *pp,\n+\t\t   unsigned input_idx,\n+\t\t   const svalue *sval,\n+\t\t   bool simple) const;\n+\n+  tree m_fndecl;\n+  unsigned m_num_inputs;\n+  const svalue *m_input_arr[MAX_INPUTS];\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const const_fn_result_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_CONST_FN_RESULT;\n+}\n+\n+template <> struct default_hash_traits<const_fn_result_svalue::key_t>\n+: public member_function_hash_traits<const_fn_result_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n+\n #endif /* GCC_ANALYZER_SVALUE_H */"}, {"sha": "39e813f14c6d8ccfdc183c4d9df4630f9478c6ac", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-const-1.c", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-1.c?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -0,0 +1,152 @@\n+/* Verify that we handle functions with __attribute__ ((const)) correctly.  */\n+\n+#include \"analyzer-decls.h\"\n+\n+extern int nonconst_fn (int);\n+\n+extern int const_fn_0 () __attribute__ ((const));\n+extern int const_fn_1 (int) __attribute__ ((const));\n+extern int const_fn_2 (int, int) __attribute__ ((const));\n+extern int const_fn_3 (int, int, int) __attribute__ ((const));\n+extern int const_fn_variadic (int, ...) __attribute__ ((const));\n+\n+/* Verify that functions without __attribute__ ((const)) have a different\n+   result each time.  */\n+\n+void test_nonconst_fn (int x, int y)\n+{\n+  int x_1 = nonconst_fn (x);\n+  int x_2 = nonconst_fn (x);\n+  int y_1 = nonconst_fn (y);\n+  int y_2 = nonconst_fn (y);\n+  __analyzer_eval (x_1 == x_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (y_1 == y_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (x_1 == y_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* Verify functions with __attribute__ ((const)) have the same result\n+   for the same arguments.  */\n+\n+ /* 0 args.  */\n+\n+extern int other_const_fn_0 () __attribute__ ((const));\n+\n+void test_const_fn_0 (void)\n+{\n+  int a = const_fn_0 ();\n+  int b = const_fn_0 ();\n+  int c = other_const_fn_0 ();\n+  int d = other_const_fn_0 ();\n+  __analyzer_eval (a == b); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (c == d); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (a == c); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* 1 arg.  */\n+\n+void test_const_fn_1 (int x, int y)\n+{\n+  int x_1 = const_fn_1 (x);\n+  int x_2 = const_fn_1 (x);\n+  int y_1 = const_fn_1 (y);\n+  int y_2 = const_fn_1 (y);\n+  __analyzer_eval (x_1 == x_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y_1 == y_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x_1 == y_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* 2 args.  */\n+\n+void test_const_fn_2 (int x, int y, int p, int q)\n+{\n+  int xy_1 = const_fn_2 (x, y);\n+  int xy_2 = const_fn_2 (x, y);\n+  int pq_1 = const_fn_2 (p, q);\n+  int pq_2 = const_fn_2 (p, q);\n+  __analyzer_eval (xy_1 == xy_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (pq_1 == pq_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (xy_1 == pq_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* We don't handle above 2 args.  */\n+\n+void test_const_fn_3 (int x, int y, int z, int p, int q, int r)\n+{\n+  int xyz_1 = const_fn_3 (x, y, z);\n+  int xyz_2 = const_fn_3 (x, y, z);\n+  int pqr_1 = const_fn_3 (p, q, r);\n+  int pqr_2 = const_fn_3 (p, q, r);\n+  __analyzer_eval (xyz_1 == xyz_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (pqr_1 == pqr_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (xyz_1 == pqr_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* Variadic fn, with various numbers of extra args.  */\n+\n+void test_const_fn_variadic (int x, int y, int z, int p, int q, int r)\n+{\n+  /* 0 extra args, for 1 arg in total.  */\n+  int x_1 = const_fn_variadic (x);\n+  int x_2 = const_fn_variadic (x);\n+  int p_1 = const_fn_variadic (p);\n+  int p_2 = const_fn_variadic (p);\n+  __analyzer_eval (x_1 == x_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p_1 == p_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x_1 == p_1); /* { dg-warning \"UNKNOWN\" } */\n+\n+  /* 1 extra arg, for 2 args in total.  */\n+  int xy_1 = const_fn_variadic (x, y);\n+  int xy_2 = const_fn_variadic (x, y);\n+  int pq_1 = const_fn_variadic (p, q);\n+  int pq_2 = const_fn_variadic (p, q);\n+  __analyzer_eval (xy_1 == xy_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (pq_1 == pq_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (xy_1 == pq_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (x_1 == xy_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (p_1 == pq_1); /* { dg-warning \"UNKNOWN\" } */\n+\n+  /* Above that, we don't track results.  */\n+  int xyz_1 = const_fn_variadic (x, y, z);\n+  int xyz_2 = const_fn_variadic (x, y, z);\n+  int pqr_1 = const_fn_variadic (p, q, r);\n+  int pqr_2 = const_fn_variadic (p, q, r);\n+  __analyzer_eval (xyz_1 == xyz_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (pqr_1 == pqr_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (xyz_1 == x_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (xyz_1 == xy_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (xyz_1 == pqr_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* Builtins with __attribute__ ((const)).  */\n+\n+void test_builtin_isascii (int x, int y)\n+{\n+  int x_1 = __builtin_isascii (x);\n+  int x_2 = __builtin_isascii (x);\n+  int y_1 = __builtin_isascii (y);\n+  int y_2 = __builtin_isascii (y);\n+  __analyzer_eval (x_1 == x_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y_1 == y_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x_1 == y_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test_builtin_popcount (unsigned x, unsigned y)\n+{\n+  unsigned x_1 = __builtin_popcount (x);\n+  unsigned x_2 = __builtin_popcount (x);\n+  unsigned y_1 = __builtin_popcount (y);\n+  unsigned y_2 = __builtin_popcount (y);\n+  __analyzer_eval (x_1 == x_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (y_1 == y_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x_1 == y_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test_loop (void)\n+{\n+  for (int i = 0; i < 100; i++)\n+    {\n+      int iter_val_a = const_fn_1 (i);\n+      int iter_val_b = const_fn_1 (i);\n+      __analyzer_eval (iter_val_a == iter_val_b); /* { dg-warning \"TRUE\" } */\n+    }\n+}"}, {"sha": "ab79514acf8613e9fe787c9e17baf3653936d432", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-const-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-2.c?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -0,0 +1,16 @@\n+extern int const_p (int) __attribute__((const));\n+extern void do_stuff (void);\n+\n+void test (int a)\n+{\n+  void *p;\n+  if (const_p (a))\n+    {\n+      p = __builtin_malloc (1024);\n+      if (!p)\n+\treturn;\n+    }\n+  do_stuff ();\n+  if (const_p (a))\n+    __builtin_free (p); /* { dg-bogus \"uninit\" } */\n+}"}, {"sha": "2e6ccda74dce27e69a381f9685efa090bdbc899a", "filename": "gcc/testsuite/gcc.dg/analyzer/attr-const-3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fattr-const-3.c?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -0,0 +1,26 @@\n+/* Verify that we handle unknown values passed to  __attribute__ ((const))\n+   (by imposing a complexity limit).  */\n+\n+/* { dg-additional-options \"--param analyzer-max-svalue-depth=0\" } */\n+\n+#include \"analyzer-decls.h\"\n+\n+extern int const_fn_1 (int) __attribute__ ((const));\n+\n+void test_const_fn_1 (int x, int y)\n+{\n+  int x_1 = const_fn_1 (x);\n+  int x_2 = const_fn_1 (x);\n+  int y_1 = const_fn_1 (y);\n+  int y_2 = const_fn_1 (y);\n+  __analyzer_eval (x_1 == x_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (y_1 == y_2); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (x_1 == y_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test_2 (int x)\n+{\n+  int once = const_fn_1 (x);\n+  int again = const_fn_1 (once);\n+  __analyzer_eval (once == again); /* { dg-warning \"UNKNOWN\" } */  \n+}"}, {"sha": "eacf3f6cfd759cefafe676b7e520198f99b78302", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104434-const.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434-const.c?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -0,0 +1,173 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#include \"pr104434.h\"\n+\n+/* Declare LAPACKE_lsame with __attribute__((const)).  */\n+int LAPACKE_lsame( char ca, char cb ) __attribute__((const));\n+\n+/* Testcase adapted/reduced from\n+     https://github.com/xianyi/OpenBLAS/blob/c5f280a7f0e875d83833d895b2b8b0e341efabf4/lapack-netlib/LAPACKE/src/lapacke_cgbbrd_work.c\n+   which has this license text.  */\n+\n+/*****************************************************************************\n+  Copyright (c) 2014, Intel Corp.\n+  All rights reserved.\n+\n+  Redistribution and use in source and binary forms, with or without\n+  modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+    * Neither the name of Intel Corporation nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+\n+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+  THE POSSIBILITY OF SUCH DAMAGE.\n+*****************************************************************************\n+* Contents: Native middle-level C interface to LAPACK function cgbbrd\n+* Author: Intel Corporation\n+* Generated November 2015\n+*****************************************************************************/\n+\n+lapack_int LAPACKE_cgbbrd_work( int matrix_layout, char vect, lapack_int m,\n+                                lapack_int n, lapack_int ncc, lapack_int kl,\n+                                lapack_int ku, lapack_complex_float* ab,\n+                                lapack_int ldab, float* d, float* e,\n+                                lapack_complex_float* q, lapack_int ldq,\n+                                lapack_complex_float* pt, lapack_int ldpt,\n+                                lapack_complex_float* c, lapack_int ldc,\n+                                lapack_complex_float* work, float* rwork )\n+{\n+    lapack_int info = 0;\n+    if( matrix_layout == LAPACK_COL_MAJOR ) {\n+        /* Call LAPACK function and adjust info */\n+        LAPACK_cgbbrd( &vect, &m, &n, &ncc, &kl, &ku, ab, &ldab, d, e, q, &ldq,\n+                       pt, &ldpt, c, &ldc, work, rwork, &info );\n+        if( info < 0 ) {\n+            info = info - 1;\n+        }\n+    } else if( matrix_layout == LAPACK_ROW_MAJOR ) {\n+        lapack_int ldab_t = MAX(1,kl+ku+1);\n+        lapack_int ldc_t = MAX(1,m);\n+        lapack_int ldpt_t = MAX(1,n);\n+        lapack_int ldq_t = MAX(1,m);\n+        lapack_complex_float* ab_t = NULL;\n+        lapack_complex_float* q_t = NULL;\n+        lapack_complex_float* pt_t = NULL;\n+        lapack_complex_float* c_t = NULL;\n+        /* Check leading dimension(s) */\n+        if( ldab < n ) {\n+            info = -9;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        if( ldc < ncc ) {\n+            info = -17;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        if( ldpt < n ) {\n+            info = -15;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        if( ldq < m ) {\n+            info = -13;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        /* Allocate memory for temporary array(s) */\n+        ab_t = (lapack_complex_float*)\n+            LAPACKE_malloc( sizeof(lapack_complex_float) * ldab_t * MAX(1,n) );\n+        if( ab_t == NULL ) {\n+            info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+            goto exit_level_0;\n+        }\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n+            q_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldq_t * MAX(1,m) );\n+            if( q_t == NULL ) {\n+                info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+                goto exit_level_1;\n+            }\n+        }\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            pt_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldpt_t * MAX(1,n) );\n+            if( pt_t == NULL ) {\n+                info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+                goto exit_level_2;\n+            }\n+        }\n+        if( ncc != 0 ) {\n+            c_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldc_t * MAX(1,ncc) );\n+            if( c_t == NULL ) {\n+                info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+                goto exit_level_3;\n+            }\n+        }\n+        /* Transpose input matrices */\n+        LAPACKE_cgb_trans( matrix_layout, m, n, kl, ku, ab, ldab, ab_t, ldab_t );\n+        if( ncc != 0 ) {\n+            LAPACKE_cge_trans( matrix_layout, m, ncc, c, ldc, c_t, ldc_t );\n+        }\n+        /* Call LAPACK function and adjust info */\n+        LAPACK_cgbbrd( &vect, &m, &n, &ncc, &kl, &ku, ab_t, &ldab_t, d, e, q_t,\n+                       &ldq_t, pt_t, &ldpt_t, c_t, &ldc_t, work, rwork, &info );\n+        if( info < 0 ) {\n+            info = info - 1;\n+        }\n+        /* Transpose output matrices */\n+        LAPACKE_cgb_trans( LAPACK_COL_MAJOR, m, n, kl, ku, ab_t, ldab_t, ab,\n+                           ldab );\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n+            LAPACKE_cge_trans( LAPACK_COL_MAJOR, m, m, q_t, ldq_t, q, ldq );\n+        }\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            LAPACKE_cge_trans( LAPACK_COL_MAJOR, n, n, pt_t, ldpt_t, pt, ldpt );\n+        }\n+        if( ncc != 0 ) {\n+            LAPACKE_cge_trans( LAPACK_COL_MAJOR, m, ncc, c_t, ldc_t, c, ldc );\n+        }\n+        /* Release memory and exit */\n+        if( ncc != 0 ) {\n+            LAPACKE_free( c_t );\n+        }\n+exit_level_3:\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            LAPACKE_free( pt_t );\n+        }\n+exit_level_2:\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n+            LAPACKE_free( q_t );\n+        }\n+exit_level_1:\n+        LAPACKE_free( ab_t );\n+exit_level_0:\n+        if( info == LAPACK_TRANSPOSE_MEMORY_ERROR ) {\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+        }\n+    } else {\n+        info = -1;\n+        LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+    }\n+    return info; /* { dg-bogus \"leak of 'q_t'\" \"leak of q_t\" } */\n+    /* { dg-bogus \"leak of 'pt_t'\" \"leak of pt_t\" { target *-*-* } .-1 } */\n+}"}, {"sha": "6bcb5bfc8140e1ab09538cba8112829b8cbcccc4", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104434-nonconst.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434-nonconst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434-nonconst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434-nonconst.c?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -0,0 +1,173 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+#include \"pr104434.h\"\n+\n+/* Declare LAPACKE_lsame *without* __attribute__((const)).  */\n+int LAPACKE_lsame( char ca, char cb );\n+\n+/* Testcase adapted/reduced from\n+     https://github.com/xianyi/OpenBLAS/blob/c5f280a7f0e875d83833d895b2b8b0e341efabf4/lapack-netlib/LAPACKE/src/lapacke_cgbbrd_work.c\n+   which has this license text.  */\n+\n+/*****************************************************************************\n+  Copyright (c) 2014, Intel Corp.\n+  All rights reserved.\n+\n+  Redistribution and use in source and binary forms, with or without\n+  modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+    * Neither the name of Intel Corporation nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+\n+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+  THE POSSIBILITY OF SUCH DAMAGE.\n+*****************************************************************************\n+* Contents: Native middle-level C interface to LAPACK function cgbbrd\n+* Author: Intel Corporation\n+* Generated November 2015\n+*****************************************************************************/\n+\n+lapack_int LAPACKE_cgbbrd_work( int matrix_layout, char vect, lapack_int m,\n+                                lapack_int n, lapack_int ncc, lapack_int kl,\n+                                lapack_int ku, lapack_complex_float* ab,\n+                                lapack_int ldab, float* d, float* e,\n+                                lapack_complex_float* q, lapack_int ldq,\n+                                lapack_complex_float* pt, lapack_int ldpt,\n+                                lapack_complex_float* c, lapack_int ldc,\n+                                lapack_complex_float* work, float* rwork )\n+{\n+    lapack_int info = 0;\n+    if( matrix_layout == LAPACK_COL_MAJOR ) {\n+        /* Call LAPACK function and adjust info */\n+        LAPACK_cgbbrd( &vect, &m, &n, &ncc, &kl, &ku, ab, &ldab, d, e, q, &ldq,\n+                       pt, &ldpt, c, &ldc, work, rwork, &info );\n+        if( info < 0 ) {\n+            info = info - 1;\n+        }\n+    } else if( matrix_layout == LAPACK_ROW_MAJOR ) {\n+        lapack_int ldab_t = MAX(1,kl+ku+1);\n+        lapack_int ldc_t = MAX(1,m);\n+        lapack_int ldpt_t = MAX(1,n);\n+        lapack_int ldq_t = MAX(1,m);\n+        lapack_complex_float* ab_t = NULL;\n+        lapack_complex_float* q_t = NULL;\n+        lapack_complex_float* pt_t = NULL;\n+        lapack_complex_float* c_t = NULL;\n+        /* Check leading dimension(s) */\n+        if( ldab < n ) {\n+            info = -9;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        if( ldc < ncc ) {\n+            info = -17;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        if( ldpt < n ) {\n+            info = -15;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        if( ldq < m ) {\n+            info = -13;\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+            return info;\n+        }\n+        /* Allocate memory for temporary array(s) */\n+        ab_t = (lapack_complex_float*)\n+            LAPACKE_malloc( sizeof(lapack_complex_float) * ldab_t * MAX(1,n) );\n+        if( ab_t == NULL ) {\n+            info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+            goto exit_level_0;\n+        }\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n+            q_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldq_t * MAX(1,m) );\n+            if( q_t == NULL ) {\n+                info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+                goto exit_level_1;\n+            }\n+        }\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            pt_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldpt_t * MAX(1,n) );\n+            if( pt_t == NULL ) {\n+                info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+                goto exit_level_2;\n+            }\n+        }\n+        if( ncc != 0 ) {\n+            c_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldc_t * MAX(1,ncc) );\n+            if( c_t == NULL ) {\n+                info = LAPACK_TRANSPOSE_MEMORY_ERROR;\n+                goto exit_level_3;\n+            }\n+        }\n+        /* Transpose input matrices */\n+        LAPACKE_cgb_trans( matrix_layout, m, n, kl, ku, ab, ldab, ab_t, ldab_t );\n+        if( ncc != 0 ) {\n+            LAPACKE_cge_trans( matrix_layout, m, ncc, c, ldc, c_t, ldc_t );\n+        }\n+        /* Call LAPACK function and adjust info */\n+        LAPACK_cgbbrd( &vect, &m, &n, &ncc, &kl, &ku, ab_t, &ldab_t, d, e, q_t,\n+                       &ldq_t, pt_t, &ldpt_t, c_t, &ldc_t, work, rwork, &info );\n+        if( info < 0 ) {\n+            info = info - 1;\n+        }\n+        /* Transpose output matrices */\n+        LAPACKE_cgb_trans( LAPACK_COL_MAJOR, m, n, kl, ku, ab_t, ldab_t, ab,\n+                           ldab );\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n+            LAPACKE_cge_trans( LAPACK_COL_MAJOR, m, m, q_t, ldq_t, q, ldq );\n+        }\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            LAPACKE_cge_trans( LAPACK_COL_MAJOR, n, n, pt_t, ldpt_t, pt, ldpt );\n+        }\n+        if( ncc != 0 ) {\n+            LAPACKE_cge_trans( LAPACK_COL_MAJOR, m, ncc, c_t, ldc_t, c, ldc );\n+        }\n+        /* Release memory and exit */\n+        if( ncc != 0 ) {\n+            LAPACKE_free( c_t );\n+        }\n+exit_level_3:\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            LAPACKE_free( pt_t );\n+        }\n+exit_level_2:\n+        if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'q' ) ) {\n+            LAPACKE_free( q_t );\n+        }\n+exit_level_1:\n+        LAPACKE_free( ab_t );\n+exit_level_0:\n+        if( info == LAPACK_TRANSPOSE_MEMORY_ERROR ) {\n+            LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+        }\n+    } else {\n+        info = -1;\n+        LAPACKE_xerbla( \"LAPACKE_cgbbrd_work\", info );\n+    }\n+    return info; /* { dg-warning \"leak of 'q_t'\" \"leak of q_t\" } */\n+    /* { dg-warning \"leak of 'pt_t'\" \"leak of pt_t\" { target *-*-* } .-1 } */\n+}"}, {"sha": "473cc673f430c067c7cc696f82f94583bacea0fe", "filename": "gcc/testsuite/gcc.dg/analyzer/pr104434.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr104434.h?ref=aee1adf2cdc1cf4e116e5c05b6e7c92b0fbb264b", "patch": "@@ -0,0 +1,108 @@\n+/* Shared header for testing memory leak false positives seen in OpenBLAS,\n+   e.g. in lapacke_cgbbrd_work.c.\n+\n+   The code is of the form:\n+\n+   if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            pt_t = (lapack_complex_float*)\n+                LAPACKE_malloc( sizeof(lapack_complex_float) *\n+                                ldpt_t * MAX(1,n) );\n+      ...snip...\n+   }\n+\n+   [...snip lots of code...]\n+\n+   if( LAPACKE_lsame( vect, 'b' ) || LAPACKE_lsame( vect, 'p' ) ) {\n+            LAPACKE_free( pt_t );\n+   }\n+\n+   where LAPACKE_lsame is a case-insensitive comparison, implemented in its\n+   own source file.  Without __attribute__((const)) on LAPACKE_lsame, the\n+   analyzer considers the execution paths where the malloc is called, and\n+   then the free is not called.  With __attribute__((const)), the analyzer\n+   ought to rule out such paths.  */\n+\n+#define NULL ((void *)0)\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void *malloc (size_t __size)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__malloc__))\n+  __attribute__ ((__alloc_size__ (1)))\n+  __attribute__ ((__warn_unused_result__));\n+extern void free (void *__ptr)\n+  __attribute__ ((__nothrow__ , __leaf__));\n+\n+/* Header adapted/reduced from\n+     https://github.com/xianyi/OpenBLAS/\n+   which has this license text.  */\n+\n+/*****************************************************************************\n+  Copyright (c) 2014, Intel Corp.\n+  All rights reserved.\n+\n+  Redistribution and use in source and binary forms, with or without\n+  modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright\n+      notice, this list of conditions and the following disclaimer in the\n+      documentation and/or other materials provided with the distribution.\n+    * Neither the name of Intel Corporation nor the names of its contributors\n+      may be used to endorse or promote products derived from this software\n+      without specific prior written permission.\n+\n+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+  THE POSSIBILITY OF SUCH DAMAGE.\n+*****************************************************************************/\n+\n+#define lapack_int     int\n+#define lapack_logical lapack_int\n+\n+#define LAPACKE_malloc( size ) malloc( size )\n+#define LAPACKE_free( p )      free( p )\n+\n+#define LAPACK_ROW_MAJOR               101\n+#define LAPACK_COL_MAJOR               102\n+\n+#define LAPACK_TRANSPOSE_MEMORY_ERROR  -1011\n+\n+#define MAX(x,y) (((x) > (y)) ? (x) : (y))\n+\n+#define LAPACK_GLOBAL(lcname,UCNAME)  lcname##_\n+\n+typedef float _Complex lapack_complex_float;\n+\n+void LAPACKE_xerbla( const char *name, int info );\n+\n+void LAPACKE_cgb_trans( int matrix_layout, int m, int n,\n+                        int kl, int ku,\n+                        const lapack_complex_float *in, int ldin,\n+                        lapack_complex_float *out, int ldout );\n+void LAPACKE_cge_trans( int matrix_layout, int m, int n,\n+                        const lapack_complex_float* in, int ldin,\n+                        lapack_complex_float* out, int ldout );\n+\n+#define LAPACK_cgbbrd LAPACK_GLOBAL(cgbbrd,CGBBRD)\n+void LAPACK_cgbbrd(\n+    char const* vect,\n+    lapack_int const* m, lapack_int const* n, lapack_int const* ncc, lapack_int const* kl, lapack_int const* ku,\n+    lapack_complex_float* AB, lapack_int const* ldab,\n+    float* D,\n+    float* E,\n+    lapack_complex_float* Q, lapack_int const* ldq,\n+    lapack_complex_float* PT, lapack_int const* ldpt,\n+    lapack_complex_float* C, lapack_int const* ldc,\n+    lapack_complex_float* work,\n+    float* rwork,\n+    lapack_int* info );"}]}