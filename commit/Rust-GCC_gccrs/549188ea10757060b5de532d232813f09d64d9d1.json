{"sha": "549188ea10757060b5de532d232813f09d64d9d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5MTg4ZWExMDc1NzA2MGI1ZGU1MzJkMjMyODEzZjA5ZDY0ZDlkMQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:42Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:42Z"}, "message": "OpenACC 2.6 deep copy: Fortran front-end parts\n\n        gcc/fortran/\n        * gfortran.h (gfc_omp_map_op): Add OMP_MAP_ATTACH, OMP_MAP_DETACH.\n        * openmp.c (gfc_match_omp_variable_list): Add allow_derived parameter.\n        Parse derived-type member accesses if true.\n        (omp_mask2): Add OMP_CLAUSE_ATTACH and OMP_CLAUSE_DETACH.\n        (gfc_match_omp_map_clause): Add allow_derived parameter.  Pass to\n        gfc_match_omp_variable_list.\n        (gfc_match_omp_clauses): Support attach and detach.  Support derived\n        types for appropriate OpenACC directives.\n        (OACC_PARALLEL_CLAUSES, OACC_SERIAL_CLAUSES, OACC_KERNELS_CLAUSES,\n        OACC_DATA_CLAUSES, OACC_ENTER_DATA_CLAUSES): Add OMP_CLAUSE_ATTACH.\n        (OACC_EXIT_DATA_CLAUSES): Add OMP_CLAUSE_DETACH.\n        (check_symbol_not_pointer): Don't disallow pointer objects of derived\n        type.\n        (resolve_oacc_data_clauses): Don't disallow allocatable derived types.\n        (resolve_omp_clauses): Perform duplicate checking only for non-derived\n        type component accesses (plain variables and arrays or array sections).\n        Support component refs.\n        * trans-expr.c (gfc_conv_component_ref,\n        conv_parent_component_references): Make global.\n        (gfc_maybe_dereference_var): New function, broken out of...\n        (gfc_conv_variable): ...here.  Call above function.\n        * trans-openmp.c (gfc_omp_privatize_by_reference): Support component\n        refs.\n        (gfc_trans_omp_array_section): New function, broken out of...\n        (gfc_trans_omp_clauses): ...here.  Support component refs/derived\n        types, attach and detach clauses.\n        * trans.h (gfc_conv_component_ref, conv_parent_component_references,\n        gfc_maybe_dereference_var): Add prototypes.\n\n        gcc/testsuite/\n        * gfortran.dg/goacc/derived-types.f90: New test.\n        * gfortran.dg/goacc/derived-types-2.f90: New test.\n        * gfortran.dg/goacc/derived-types-3.f90: New test.\n        * gfortran.dg/goacc/data-clauses.f95: Adjust for expected errors.\n        * gfortran.dg/goacc/enter-exit-data.f95: Likewise.\n\nFrom-SVN: r279628", "tree": {"sha": "781ffdac59753e02eefac9cac647d862d6782a83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/781ffdac59753e02eefac9cac647d862d6782a83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/549188ea10757060b5de532d232813f09d64d9d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549188ea10757060b5de532d232813f09d64d9d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/549188ea10757060b5de532d232813f09d64d9d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/549188ea10757060b5de532d232813f09d64d9d1/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "519d7496beac32c26448c1d0eea176c90f543702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/519d7496beac32c26448c1d0eea176c90f543702", "html_url": "https://github.com/Rust-GCC/gccrs/commit/519d7496beac32c26448c1d0eea176c90f543702"}], "stats": {"total": 848, "additions": 613, "deletions": 235}, "files": [{"sha": "d87a107cc16a81b3bf8ffc22642b582088c49c30", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -1,3 +1,34 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gfortran.h (gfc_omp_map_op): Add OMP_MAP_ATTACH, OMP_MAP_DETACH.\n+\t* openmp.c (gfc_match_omp_variable_list): Add allow_derived parameter.\n+\tParse derived-type member accesses if true.\n+\t(omp_mask2): Add OMP_CLAUSE_ATTACH and OMP_CLAUSE_DETACH.\n+\t(gfc_match_omp_map_clause): Add allow_derived parameter.  Pass to\n+\tgfc_match_omp_variable_list.\n+\t(gfc_match_omp_clauses): Support attach and detach.  Support derived\n+\ttypes for appropriate OpenACC directives.\n+\t(OACC_PARALLEL_CLAUSES, OACC_SERIAL_CLAUSES, OACC_KERNELS_CLAUSES,\n+\tOACC_DATA_CLAUSES, OACC_ENTER_DATA_CLAUSES): Add OMP_CLAUSE_ATTACH.\n+\t(OACC_EXIT_DATA_CLAUSES): Add OMP_CLAUSE_DETACH.\n+\t(check_symbol_not_pointer): Don't disallow pointer objects of derived\n+\ttype.\n+\t(resolve_oacc_data_clauses): Don't disallow allocatable derived types.\n+\t(resolve_omp_clauses): Perform duplicate checking only for non-derived\n+\ttype component accesses (plain variables and arrays or array sections).\n+\tSupport component refs.\n+\t* trans-expr.c (gfc_conv_component_ref,\n+\tconv_parent_component_references): Make global.\n+\t(gfc_maybe_dereference_var): New function, broken out of...\n+\t(gfc_conv_variable): ...here.  Call above function.\n+\t* trans-openmp.c (gfc_omp_privatize_by_reference): Support component\n+\trefs.\n+\t(gfc_trans_omp_array_section): New function, broken out of...\n+\t(gfc_trans_omp_clauses): ...here.  Support component refs/derived\n+\ttypes, attach and detach clauses.\n+\t* trans.h (gfc_conv_component_ref, conv_parent_component_references,\n+\tgfc_maybe_dereference_var): Add prototypes.\n+\n 2019-12-19 Mark Eggleston  <mark.eggleston@codethink.com>\n \n \tPR fortran/92896"}, {"sha": "7919b690ec0709619c35c828a677b7187412248d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -1193,10 +1193,12 @@ enum gfc_omp_map_op\n {\n   OMP_MAP_ALLOC,\n   OMP_MAP_IF_PRESENT,\n+  OMP_MAP_ATTACH,\n   OMP_MAP_TO,\n   OMP_MAP_FROM,\n   OMP_MAP_TOFROM,\n   OMP_MAP_DELETE,\n+  OMP_MAP_DETACH,\n   OMP_MAP_FORCE_ALLOC,\n   OMP_MAP_FORCE_TO,\n   OMP_MAP_FORCE_FROM,"}, {"sha": "97d90ef55829bd857e1c286161812c893aee206f", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 115, "deletions": 51, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -233,7 +233,8 @@ static match\n gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n \t\t\t     bool allow_common, bool *end_colon = NULL,\n \t\t\t     gfc_omp_namelist ***headp = NULL,\n-\t\t\t     bool allow_sections = false)\n+\t\t\t     bool allow_sections = false,\n+\t\t\t     bool allow_derived = false)\n {\n   gfc_omp_namelist *head, *tail, *p;\n   locus old_loc, cur_loc;\n@@ -259,7 +260,8 @@ gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n \tcase MATCH_YES:\n \t  gfc_expr *expr;\n \t  expr = NULL;\n-\t  if (allow_sections && gfc_peek_ascii_char () == '(')\n+\t  if ((allow_sections && gfc_peek_ascii_char () == '(')\n+\t      || (allow_derived && gfc_peek_ascii_char () == '%'))\n \t    {\n \t      gfc_current_locus = cur_loc;\n \t      m = gfc_match_variable (&expr, 0);\n@@ -797,7 +799,7 @@ enum omp_mask1\n   OMP_MASK1_LAST\n };\n \n-/* OpenACC 2.0 specific clauses. */\n+/* OpenACC 2.0+ specific clauses. */\n enum omp_mask2\n {\n   OMP_CLAUSE_ASYNC,\n@@ -824,6 +826,8 @@ enum omp_mask2\n   OMP_CLAUSE_TILE,\n   OMP_CLAUSE_IF_PRESENT,\n   OMP_CLAUSE_FINALIZE,\n+  OMP_CLAUSE_ATTACH,\n+  OMP_CLAUSE_DETACH,\n   /* This must come last.  */\n   OMP_MASK2_LAST\n };\n@@ -928,10 +932,11 @@ omp_inv_mask::omp_inv_mask (const omp_mask &m) : omp_mask (m)\n \n static bool\n gfc_match_omp_map_clause (gfc_omp_namelist **list, gfc_omp_map_op map_op,\n-\t\t\t  bool allow_common)\n+\t\t\t  bool allow_common, bool allow_derived)\n {\n   gfc_omp_namelist **head = NULL;\n-  if (gfc_match_omp_variable_list (\"\", list, allow_common, NULL, &head, true)\n+  if (gfc_match_omp_variable_list (\"\", list, allow_common, NULL, &head, true,\n+\t\t\t\t   allow_derived)\n       == MATCH_YES)\n     {\n       gfc_omp_namelist *n;\n@@ -953,6 +958,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n {\n   gfc_omp_clauses *c = gfc_get_omp_clauses ();\n   locus old_loc;\n+  /* Determine whether we're dealing with an OpenACC directive that permits\n+     derived type member accesses.  This in particular disallows\n+     \"!$acc declare\" from using such accesses, because it's not clear if/how\n+     that should work.  */\n+  bool allow_derived = (openacc\n+\t\t\t&& ((mask & OMP_CLAUSE_ATTACH)\n+\t\t\t    || (mask & OMP_CLAUSE_DETACH)\n+\t\t\t    || (mask & OMP_CLAUSE_HOST_SELF)));\n \n   gcc_checking_assert (OMP_MASK1_LAST <= 64 && OMP_MASK2_LAST <= 64);\n   *cp = NULL;\n@@ -1026,6 +1039,12 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_ATTACH)\n+\t      && gfc_match (\"attach ( \") == MATCH_YES\n+\t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t\t   OMP_MAP_ATTACH, false,\n+\t\t\t\t\t   allow_derived))\n+\t    continue;\n \t  break;\n \tcase 'c':\n \t  if ((mask & OMP_CLAUSE_COLLAPSE)\n@@ -1053,15 +1072,17 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_COPY)\n \t      && gfc_match (\"copy ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_TOFROM, true))\n+\t\t\t\t\t   OMP_MAP_TOFROM, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if (mask & OMP_CLAUSE_COPYIN)\n \t    {\n \t      if (openacc)\n \t\t{\n \t\t  if (gfc_match (\"copyin ( \") == MATCH_YES\n \t\t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t\t   OMP_MAP_TO, true))\n+\t\t\t\t\t\t   OMP_MAP_TO, true,\n+\t\t\t\t\t\t   allow_derived))\n \t\t    continue;\n \t\t}\n \t      else if (gfc_match_omp_variable_list (\"copyin (\",\n@@ -1072,7 +1093,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_COPYOUT)\n \t      && gfc_match (\"copyout ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FROM, true))\n+\t\t\t\t\t   OMP_MAP_FROM, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_COPYPRIVATE)\n \t      && gfc_match_omp_variable_list (\"copyprivate (\",\n@@ -1082,7 +1103,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_CREATE)\n \t      && gfc_match (\"create ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_ALLOC, true))\n+\t\t\t\t\t   OMP_MAP_ALLOC, true, allow_derived))\n \t    continue;\n \t  break;\n \tcase 'd':\n@@ -1118,7 +1139,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_DELETE)\n \t      && gfc_match (\"delete ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_RELEASE, true))\n+\t\t\t\t\t   OMP_MAP_RELEASE, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_DEPEND)\n \t      && gfc_match (\"depend ( \") == MATCH_YES)\n@@ -1161,6 +1183,12 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      else\n \t\tgfc_current_locus = old_loc;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_DETACH)\n+\t      && gfc_match (\"detach ( \") == MATCH_YES\n+\t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n+\t\t\t\t\t   OMP_MAP_DETACH, false,\n+\t\t\t\t\t   allow_derived))\n+\t    continue;\n \t  if ((mask & OMP_CLAUSE_DEVICE)\n \t      && !openacc\n \t      && c->device == NULL\n@@ -1170,12 +1198,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      && openacc\n \t      && gfc_match (\"device ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FORCE_TO, true))\n+\t\t\t\t\t   OMP_MAP_FORCE_TO, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_DEVICEPTR)\n \t      && gfc_match (\"deviceptr ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FORCE_DEVICEPTR, false))\n+\t\t\t\t\t   OMP_MAP_FORCE_DEVICEPTR, false,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_DEVICE_RESIDENT)\n \t      && gfc_match_omp_variable_list\n@@ -1253,7 +1283,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_HOST_SELF)\n \t      && gfc_match (\"host ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FORCE_FROM, true))\n+\t\t\t\t\t   OMP_MAP_FORCE_FROM, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  break;\n \tcase 'i':\n@@ -1449,7 +1480,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_NO_CREATE)\n \t      && gfc_match (\"no_create ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_IF_PRESENT, true))\n+\t\t\t\t\t   OMP_MAP_IF_PRESENT, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_NOGROUP)\n \t      && !c->nogroup\n@@ -1530,47 +1562,49 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_COPY)\n \t      && gfc_match (\"pcopy ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_TOFROM, true))\n+\t\t\t\t\t   OMP_MAP_TOFROM, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_COPYIN)\n \t      && gfc_match (\"pcopyin ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_TO, true))\n+\t\t\t\t\t   OMP_MAP_TO, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_COPYOUT)\n \t      && gfc_match (\"pcopyout ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FROM, true))\n+\t\t\t\t\t   OMP_MAP_FROM, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_CREATE)\n \t      && gfc_match (\"pcreate ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_ALLOC, true))\n+\t\t\t\t\t   OMP_MAP_ALLOC, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_PRESENT)\n \t      && gfc_match (\"present ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FORCE_PRESENT, false))\n+\t\t\t\t\t   OMP_MAP_FORCE_PRESENT, false,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_COPY)\n \t      && gfc_match (\"present_or_copy ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_TOFROM, true))\n+\t\t\t\t\t   OMP_MAP_TOFROM, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_COPYIN)\n \t      && gfc_match (\"present_or_copyin ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_TO, true))\n+\t\t\t\t\t   OMP_MAP_TO, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_COPYOUT)\n \t      && gfc_match (\"present_or_copyout ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FROM, true))\n+\t\t\t\t\t   OMP_MAP_FROM, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_CREATE)\n \t      && gfc_match (\"present_or_create ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_ALLOC, true))\n+\t\t\t\t\t   OMP_MAP_ALLOC, true, allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_PRIORITY)\n \t      && c->priority == NULL\n@@ -1688,8 +1722,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \n \t      if (gfc_match_omp_variable_list (\" :\",\n \t\t\t\t\t       &c->lists[OMP_LIST_REDUCTION],\n-\t\t\t\t\t       false, NULL, &head,\n-\t\t\t\t\t       openacc) == MATCH_YES)\n+\t\t\t\t\t       false, NULL, &head, openacc,\n+\t\t\t\t\t       allow_derived) == MATCH_YES)\n \t\t{\n \t\t  gfc_omp_namelist *n;\n \t\t  if (rop == OMP_REDUCTION_NONE)\n@@ -1788,7 +1822,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_HOST_SELF)\n \t      && gfc_match (\"self ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n-\t\t\t\t\t   OMP_MAP_FORCE_FROM, true))\n+\t\t\t\t\t   OMP_MAP_FORCE_FROM, true,\n+\t\t\t\t\t   allow_derived))\n \t    continue;\n \t  if ((mask & OMP_CLAUSE_SEQ)\n \t      && !c->seq\n@@ -1963,23 +1998,23 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n    | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_NO_CREATE | OMP_CLAUSE_PRESENT\t      \\\n    | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE      \\\n-   | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n+   | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT | OMP_CLAUSE_ATTACH)\n #define OACC_KERNELS_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_NUM_GANGS\t      \\\n    | OMP_CLAUSE_NUM_WORKERS | OMP_CLAUSE_VECTOR_LENGTH | OMP_CLAUSE_DEVICEPTR \\\n    | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_NO_CREATE | OMP_CLAUSE_PRESENT\t      \\\n-   | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n+   | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT | OMP_CLAUSE_ATTACH)\n #define OACC_SERIAL_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_REDUCTION\t      \\\n    | OMP_CLAUSE_COPY | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT\t\t      \\\n    | OMP_CLAUSE_CREATE | OMP_CLAUSE_NO_CREATE | OMP_CLAUSE_PRESENT\t      \\\n    | OMP_CLAUSE_DEVICEPTR | OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE      \\\n-   | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT)\n+   | OMP_CLAUSE_DEFAULT | OMP_CLAUSE_WAIT | OMP_CLAUSE_ATTACH)\n #define OACC_DATA_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_DEVICEPTR  | OMP_CLAUSE_COPY\t      \\\n    | OMP_CLAUSE_COPYIN | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_CREATE\t\t      \\\n-   | OMP_CLAUSE_NO_CREATE | OMP_CLAUSE_PRESENT)\n+   | OMP_CLAUSE_NO_CREATE | OMP_CLAUSE_PRESENT | OMP_CLAUSE_ATTACH)\n #define OACC_LOOP_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_COLLAPSE) | OMP_CLAUSE_GANG | OMP_CLAUSE_WORKER\t      \\\n    | OMP_CLAUSE_VECTOR | OMP_CLAUSE_SEQ | OMP_CLAUSE_INDEPENDENT\t      \\\n@@ -2002,10 +2037,11 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n    | OMP_CLAUSE_DEVICE | OMP_CLAUSE_WAIT | OMP_CLAUSE_IF_PRESENT)\n #define OACC_ENTER_DATA_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT\t      \\\n-   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_CREATE)\n+   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_CREATE | OMP_CLAUSE_ATTACH)\n #define OACC_EXIT_DATA_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_IF) | OMP_CLAUSE_ASYNC | OMP_CLAUSE_WAIT\t      \\\n-   | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_DELETE | OMP_CLAUSE_FINALIZE)\n+   | OMP_CLAUSE_COPYOUT | OMP_CLAUSE_DELETE | OMP_CLAUSE_FINALIZE\t      \\\n+   | OMP_CLAUSE_DETACH)\n #define OACC_WAIT_CLAUSES \\\n   omp_mask (OMP_CLAUSE_ASYNC)\n #define OACC_ROUTINE_CLAUSES \\\n@@ -3853,9 +3889,6 @@ resolve_nonnegative_int_expr (gfc_expr *expr, const char *clause)\n static void\n check_symbol_not_pointer (gfc_symbol *sym, locus loc, const char *name)\n {\n-  if (sym->ts.type == BT_DERIVED && sym->attr.pointer)\n-    gfc_error (\"POINTER object %qs of derived type in %s clause at %L\",\n-\t       sym->name, name, &loc);\n   if (sym->ts.type == BT_DERIVED && sym->attr.cray_pointer)\n     gfc_error (\"Cray pointer object %qs of derived type in %s clause at %L\",\n \t       sym->name, name, &loc);\n@@ -3896,9 +3929,6 @@ check_array_not_assumed (gfc_symbol *sym, locus loc, const char *name)\n static void\n resolve_oacc_data_clauses (gfc_symbol *sym, locus loc, const char *name)\n {\n-  if (sym->ts.type == BT_DERIVED && sym->attr.allocatable)\n-    gfc_error (\"ALLOCATABLE object %qs of derived type in %s clause at %L\",\n-\t       sym->name, name, &loc);\n   if ((sym->ts.type == BT_ASSUMED && sym->attr.allocatable)\n       || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)\n \t  && CLASS_DATA (sym)->attr.allocatable))\n@@ -4281,11 +4311,26 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t&& (list != OMP_LIST_REDUCTION || !openacc))\n       for (n = omp_clauses->lists[list]; n; n = n->next)\n \t{\n-\t  if (n->sym->mark)\n-\t    gfc_error (\"Symbol %qs present on multiple clauses at %L\",\n-\t\t       n->sym->name, &n->where);\n-\t  else\n-\t    n->sym->mark = 1;\n+\t  bool array_only_p = true;\n+\t  /* Disallow duplicate bare variable references and multiple\n+\t     subarrays of the same array here, but allow multiple components of\n+\t     the same (e.g. derived-type) variable.  For the latter, duplicate\n+\t     components are detected elsewhere.  */\n+\t  if (openacc && n->expr && n->expr->expr_type == EXPR_VARIABLE)\n+\t    for (gfc_ref *ref = n->expr->ref; ref; ref = ref->next)\n+\t      if (ref->type != REF_ARRAY)\n+\t\t{\n+\t\t  array_only_p = false;\n+\t\t  break;\n+\t\t}\n+\t  if (array_only_p)\n+\t    {\n+\t      if (n->sym->mark)\n+\t\tgfc_error (\"Symbol %qs present on multiple clauses at %L\",\n+\t\t\t   n->sym->name, &n->where);\n+\t      else\n+\t\tn->sym->mark = 1;\n+\t    }\n \t}\n \n   gcc_assert (OMP_LIST_LASTPRIVATE == OMP_LIST_FIRSTPRIVATE + 1);\n@@ -4476,23 +4521,42 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t\t \"are allowed on ORDERED directive at %L\",\n \t\t\t\t &n->where);\n \t\t  }\n+\t\tgfc_ref *array_ref = NULL;\n+\t\tbool resolved = false;\n \t\tif (n->expr)\n \t\t  {\n-\t\t    if (!gfc_resolve_expr (n->expr)\n+\t\t    array_ref = n->expr->ref;\n+\t\t    resolved = gfc_resolve_expr (n->expr);\n+\n+\t\t    /* Look through component refs to find last array\n+\t\t       reference.  */\n+\t\t    if (openacc && resolved)\n+\t\t      while (array_ref\n+\t\t\t     && (array_ref->type == REF_COMPONENT\n+\t\t\t\t || (array_ref->type == REF_ARRAY\n+\t\t\t\t     && array_ref->next\n+\t\t\t\t     && (array_ref->next->type\n+\t\t\t\t\t == REF_COMPONENT))))\n+\t\t\tarray_ref = array_ref->next;\n+\t\t  }\n+\t\tif (array_ref\n+\t\t    || (n->expr\n+\t\t\t&& (!resolved || n->expr->expr_type != EXPR_VARIABLE)))\n+\t\t  {\n+\t\t    if (!resolved\n \t\t\t|| n->expr->expr_type != EXPR_VARIABLE\n-\t\t\t|| n->expr->ref == NULL\n-\t\t\t|| n->expr->ref->next\n-\t\t\t|| n->expr->ref->type != REF_ARRAY)\n+\t\t\t|| array_ref->next\n+\t\t\t|| array_ref->type != REF_ARRAY)\n \t\t      gfc_error (\"%qs in %s clause at %L is not a proper \"\n \t\t\t\t \"array section\", n->sym->name, name,\n \t\t\t\t &n->where);\n-\t\t    else if (n->expr->ref->u.ar.codimen)\n-\t\t      gfc_error (\"Coarrays not supported in %s clause at %L\",\n-\t\t\t\t name, &n->where);\n+\t\t    else if (gfc_is_coindexed (n->expr))\n+\t\t      gfc_error (\"Entry shall not be coindexed in %s \"\n+\t\t\t\t \"clause at %L\", name, &n->where);\n \t\t    else\n \t\t      {\n \t\t\tint i;\n-\t\t\tgfc_array_ref *ar = &n->expr->ref->u.ar;\n+\t\t\tgfc_array_ref *ar = &array_ref->u.ar;\n \t\t\tfor (i = 0; i < ar->dimen; i++)\n \t\t\t  if (ar->stride[i])\n \t\t\t    {"}, {"sha": "61ba4a6afc0b3bb0fc955e8902628e4d115d33e3", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 94, "deletions": 90, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -2423,7 +2423,7 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind,\n \n /* Convert a derived type component reference.  */\n \n-static void\n+void\n gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n {\n   gfc_component *c;\n@@ -2513,7 +2513,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n \n /* This function deals with component references to components of the\n    parent type for derived type extensions.  */\n-static void\n+void\n conv_parent_component_references (gfc_se * se, gfc_ref * ref)\n {\n   gfc_component *c;\n@@ -2579,6 +2579,95 @@ conv_inquiry (gfc_se * se, gfc_ref * ref, gfc_expr *expr, gfc_typespec *ts)\n   se->expr = res;\n }\n \n+/* Dereference VAR where needed if it is a pointer, reference, etc.\n+   according to Fortran semantics.  */\n+\n+tree\n+gfc_maybe_dereference_var (gfc_symbol *sym, tree var, bool descriptor_only_p,\n+\t\t\t   bool is_classarray)\n+{\n+  /* Characters are entirely different from other types, they are treated\n+     separately.  */\n+  if (sym->ts.type == BT_CHARACTER)\n+    {\n+      /* Dereference character pointer dummy arguments\n+\t or results.  */\n+      if ((sym->attr.pointer || sym->attr.allocatable)\n+\t  && (sym->attr.dummy\n+\t      || sym->attr.function\n+\t      || sym->attr.result))\n+\tvar = build_fold_indirect_ref_loc (input_location, var);\n+    }\n+  else if (!sym->attr.value)\n+    {\n+      /* Dereference temporaries for class array dummy arguments.  */\n+      if (sym->attr.dummy && is_classarray\n+\t  && GFC_ARRAY_TYPE_P (TREE_TYPE (var)))\n+\t{\n+\t  if (!descriptor_only_p)\n+\t    var = GFC_DECL_SAVED_DESCRIPTOR (var);\n+\n+\t  var = build_fold_indirect_ref_loc (input_location, var);\n+\t}\n+\n+      /* Dereference non-character scalar dummy arguments.  */\n+      if (sym->attr.dummy && !sym->attr.dimension\n+\t  && !(sym->attr.codimension && sym->attr.allocatable)\n+\t  && (sym->ts.type != BT_CLASS\n+\t      || (!CLASS_DATA (sym)->attr.dimension\n+\t\t  && !(CLASS_DATA (sym)->attr.codimension\n+\t\t       && CLASS_DATA (sym)->attr.allocatable))))\n+\tvar = build_fold_indirect_ref_loc (input_location, var);\n+\n+      /* Dereference scalar hidden result.  */\n+      if (flag_f2c && sym->ts.type == BT_COMPLEX\n+\t  && (sym->attr.function || sym->attr.result)\n+\t  && !sym->attr.dimension && !sym->attr.pointer\n+\t  && !sym->attr.always_explicit)\n+\tvar = build_fold_indirect_ref_loc (input_location, var);\n+\n+      /* Dereference non-character, non-class pointer variables.\n+\t These must be dummies, results, or scalars.  */\n+      if (!is_classarray\n+\t  && (sym->attr.pointer || sym->attr.allocatable\n+\t      || gfc_is_associate_pointer (sym)\n+\t      || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n+\t  && (sym->attr.dummy\n+\t      || sym->attr.function\n+\t      || sym->attr.result\n+\t      || (!sym->attr.dimension\n+\t\t  && (!sym->attr.codimension || !sym->attr.allocatable))))\n+\tvar = build_fold_indirect_ref_loc (input_location, var);\n+      /* Now treat the class array pointer variables accordingly.  */\n+      else if (sym->ts.type == BT_CLASS\n+\t       && sym->attr.dummy\n+\t       && (CLASS_DATA (sym)->attr.dimension\n+\t\t   || CLASS_DATA (sym)->attr.codimension)\n+\t       && ((CLASS_DATA (sym)->as\n+\t\t    && CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n+\t\t   || CLASS_DATA (sym)->attr.allocatable\n+\t\t   || CLASS_DATA (sym)->attr.class_pointer))\n+\tvar = build_fold_indirect_ref_loc (input_location, var);\n+      /* And the case where a non-dummy, non-result, non-function,\n+\t non-allotable and non-pointer classarray is present.  This case was\n+\t previously covered by the first if, but with introducing the\n+\t condition !is_classarray there, that case has to be covered\n+\t explicitly.  */\n+      else if (sym->ts.type == BT_CLASS\n+\t       && !sym->attr.dummy\n+\t       && !sym->attr.function\n+\t       && !sym->attr.result\n+\t       && (CLASS_DATA (sym)->attr.dimension\n+\t\t   || CLASS_DATA (sym)->attr.codimension)\n+\t       && (sym->assoc\n+\t\t   || !CLASS_DATA (sym)->attr.allocatable)\n+\t       && !CLASS_DATA (sym)->attr.class_pointer)\n+\tvar = build_fold_indirect_ref_loc (input_location, var);\n+    }\n+\n+  return var;\n+}\n+\n /* Return the contents of a variable. Also handles reference/pointer\n    variables (all Fortran pointer references are implicit).  */\n \n@@ -2685,94 +2774,9 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  return;\n \t}\n \n-\n-      /* Dereference the expression, where needed. Since characters\n-\t are entirely different from other types, they are treated\n-\t separately.  */\n-      if (sym->ts.type == BT_CHARACTER)\n-\t{\n-\t  /* Dereference character pointer dummy arguments\n-\t     or results.  */\n-\t  if ((sym->attr.pointer || sym->attr.allocatable)\n-\t      && (sym->attr.dummy\n-\t\t  || sym->attr.function\n-\t\t  || sym->attr.result))\n-\t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n-\n-\t}\n-      else if (!sym->attr.value)\n-\t{\n-\t  /* Dereference temporaries for class array dummy arguments.  */\n-\t  if (sym->attr.dummy && is_classarray\n-\t      && GFC_ARRAY_TYPE_P (TREE_TYPE (se->expr)))\n-\t    {\n-\t      if (!se->descriptor_only)\n-\t\tse->expr = GFC_DECL_SAVED_DESCRIPTOR (se->expr);\n-\n-\t      se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t      se->expr);\n-\t    }\n-\n-\t  /* Dereference non-character scalar dummy arguments.  */\n-\t  if (sym->attr.dummy && !sym->attr.dimension\n-\t      && !(sym->attr.codimension && sym->attr.allocatable)\n-\t      && (sym->ts.type != BT_CLASS\n-\t\t  || (!CLASS_DATA (sym)->attr.dimension\n-\t\t      && !(CLASS_DATA (sym)->attr.codimension\n-\t\t\t   && CLASS_DATA (sym)->attr.allocatable))))\n-\t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n-\n-          /* Dereference scalar hidden result.  */\n-\t  if (flag_f2c && sym->ts.type == BT_COMPLEX\n-\t      && (sym->attr.function || sym->attr.result)\n-\t      && !sym->attr.dimension && !sym->attr.pointer\n-\t      && !sym->attr.always_explicit)\n-\t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n-\n-\t  /* Dereference non-character, non-class pointer variables.\n-\t     These must be dummies, results, or scalars.  */\n-\t  if (!is_classarray\n-\t      && (sym->attr.pointer || sym->attr.allocatable\n-\t\t  || gfc_is_associate_pointer (sym)\n-\t\t  || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n-\t      && (sym->attr.dummy\n-\t\t  || sym->attr.function\n-\t\t  || sym->attr.result\n-\t\t  || (!sym->attr.dimension\n-\t\t      && (!sym->attr.codimension || !sym->attr.allocatable))))\n-\t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n-\t  /* Now treat the class array pointer variables accordingly.  */\n-\t  else if (sym->ts.type == BT_CLASS\n-\t\t   && sym->attr.dummy\n-\t\t   && (CLASS_DATA (sym)->attr.dimension\n-\t\t       || CLASS_DATA (sym)->attr.codimension)\n-\t\t   && ((CLASS_DATA (sym)->as\n-\t\t\t&& CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n-\t\t       || CLASS_DATA (sym)->attr.allocatable\n-\t\t       || CLASS_DATA (sym)->attr.class_pointer))\n-\t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n-\t  /* And the case where a non-dummy, non-result, non-function,\n-\t     non-allotable and non-pointer classarray is present.  This case was\n-\t     previously covered by the first if, but with introducing the\n-\t     condition !is_classarray there, that case has to be covered\n-\t     explicitly.  */\n-\t  else if (sym->ts.type == BT_CLASS\n-\t\t   && !sym->attr.dummy\n-\t\t   && !sym->attr.function\n-\t\t   && !sym->attr.result\n-\t\t   && (CLASS_DATA (sym)->attr.dimension\n-\t\t       || CLASS_DATA (sym)->attr.codimension)\n-\t\t   && (sym->assoc\n-\t\t       || !CLASS_DATA (sym)->attr.allocatable)\n-\t\t   && !CLASS_DATA (sym)->attr.class_pointer)\n-\t    se->expr = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\tse->expr);\n-\t}\n+      /* Dereference the expression, where needed.  */\n+      se->expr = gfc_maybe_dereference_var (sym, se->expr, se->descriptor_only,\n+\t\t\t\t\t    is_classarray);\n \n       ref = expr->ref;\n     }"}, {"sha": "c9f4bd29ced42f1f17aed9917d29791dd96197a1", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 222, "deletions": 64, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -174,6 +174,9 @@ gfc_omp_privatize_by_reference (const_tree decl)\n \n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n+      while (TREE_CODE (decl) == COMPONENT_REF)\n+\tdecl = TREE_OPERAND (decl, 1);\n+\n       /* Array POINTER/ALLOCATABLE have aggregate types, all user variables\n \t that have POINTER_TYPE type and aren't scalar pointers, scalar\n \t allocatables, Cray pointees or C pointers are supposed to be\n@@ -2058,6 +2061,91 @@ gfc_convert_expr_to_tree (stmtblock_t *block, gfc_expr *expr)\n \n static vec<tree, va_heap, vl_embed> *doacross_steps;\n \n+\n+/* Translate an array section or array element.  */\n+\n+static void\n+gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n+\t\t\t     tree decl, bool element, gomp_map_kind ptr_kind,\n+\t\t\t     tree node, tree &node2, tree &node3, tree &node4)\n+{\n+  gfc_se se;\n+  tree ptr, ptr2;\n+\n+  gfc_init_se (&se, NULL);\n+\n+  if (element)\n+    {\n+      gfc_conv_expr_reference (&se, n->expr);\n+      gfc_add_block_to_block (block, &se.pre);\n+      ptr = se.expr;\n+      OMP_CLAUSE_SIZE (node) = TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+    }\n+  else\n+    {\n+      gfc_conv_expr_descriptor (&se, n->expr);\n+      ptr = gfc_conv_array_data (se.expr);\n+      tree type = TREE_TYPE (se.expr);\n+      gfc_add_block_to_block (block, &se.pre);\n+      OMP_CLAUSE_SIZE (node) = gfc_full_array_size (block, se.expr,\n+\t\t\t\t\t\t    GFC_TYPE_ARRAY_RANK (type));\n+      tree elemsz = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+      elemsz = fold_convert (gfc_array_index_type, elemsz);\n+      OMP_CLAUSE_SIZE (node) = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t\t    OMP_CLAUSE_SIZE (node), elemsz);\n+    }\n+  gfc_add_block_to_block (block, &se.post);\n+  ptr = fold_convert (build_pointer_type (char_type_node), ptr);\n+  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (decl))\n+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl)))\n+      && ptr_kind == GOMP_MAP_POINTER)\n+    {\n+      node4 = build_omp_clause (input_location,\n+\t\t\t\tOMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (node4, GOMP_MAP_POINTER);\n+      OMP_CLAUSE_DECL (node4) = decl;\n+      OMP_CLAUSE_SIZE (node4) = size_int (0);\n+      decl = build_fold_indirect_ref (decl);\n+    }\n+  ptr = fold_convert (sizetype, ptr);\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+    {\n+      tree type = TREE_TYPE (decl);\n+      ptr2 = gfc_conv_descriptor_data_get (decl);\n+      node2 = build_omp_clause (input_location,\n+\t\t\t\tOMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n+      OMP_CLAUSE_DECL (node2) = decl;\n+      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n+      node3 = build_omp_clause (input_location,\n+\t\t\t\tOMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (node3, ptr_kind);\n+      OMP_CLAUSE_DECL (node3)\n+\t= gfc_conv_descriptor_data_get (decl);\n+      if (ptr_kind == GOMP_MAP_ATTACH_DETACH)\n+\tSTRIP_NOPS (OMP_CLAUSE_DECL (node3));\n+    }\n+  else\n+    {\n+      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+\tptr2 = build_fold_addr_expr (decl);\n+      else\n+\t{\n+\t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (decl)));\n+\t  ptr2 = decl;\n+\t}\n+      node3 = build_omp_clause (input_location,\n+\t\t\t\tOMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (node3, ptr_kind);\n+      OMP_CLAUSE_DECL (node3) = decl;\n+    }\n+  ptr2 = fold_convert (sizetype, ptr2);\n+  OMP_CLAUSE_SIZE (node3)\n+    = fold_build2 (MINUS_EXPR, sizetype, ptr, ptr2);\n+}\n+\n static tree\n gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t       locus where, bool declare_simd = false)\n@@ -2389,7 +2477,8 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  || GFC_DECL_GET_SCALAR_ALLOCATABLE (decl)\n \t\t\t  || GFC_DECL_CRAY_POINTEE (decl)\n \t\t\t  || GFC_DESCRIPTOR_TYPE_P\n-\t\t\t\t\t(TREE_TYPE (TREE_TYPE (decl)))))\n+\t\t\t\t\t(TREE_TYPE (TREE_TYPE (decl)))\n+\t\t\t  || n->sym->ts.type == BT_DERIVED))\n \t\t    {\n \t\t      tree orig_decl = decl;\n \t\t      node4 = build_omp_clause (input_location,\n@@ -2411,7 +2500,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t  decl = build_fold_indirect_ref (decl);\n \t\t\t}\n \t\t    }\n-\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))\n+\t\t      && n->u.map_op != OMP_MAP_ATTACH\n+\t\t      && n->u.map_op != OMP_MAP_DETACH)\n \t\t    {\n \t\t      tree type = TREE_TYPE (decl);\n \t\t      tree ptr = gfc_conv_descriptor_data_get (decl);\n@@ -2542,83 +2633,144 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  else\n \t\t    OMP_CLAUSE_DECL (node) = decl;\n \t\t}\n-\t      else\n+\t      else if (n->expr\n+\t\t       && n->expr->expr_type == EXPR_VARIABLE\n+\t\t       && n->expr->ref->type == REF_COMPONENT)\n \t\t{\n-\t\t  tree ptr, ptr2;\n+\t\t  gfc_ref *lastcomp;\n+\n+\t\t  for (gfc_ref *ref = n->expr->ref; ref; ref = ref->next)\n+\t\t    if (ref->type == REF_COMPONENT)\n+\t\t      lastcomp = ref;\n+\n+\t\t  symbol_attribute sym_attr;\n+\n+\t\t  sym_attr = lastcomp->u.c.component->attr;\n+\n \t\t  gfc_init_se (&se, NULL);\n-\t\t  if (n->expr->ref->u.ar.type == AR_ELEMENT)\n+\n+\t\t  if (!sym_attr.dimension\n+\t\t      && lastcomp->u.c.component->ts.type != BT_DERIVED)\n \t\t    {\n-\t\t      gfc_conv_expr_reference (&se, n->expr);\n+\t\t      /* Last component is a scalar.  */\n+\t\t      gfc_conv_expr (&se, n->expr);\n \t\t      gfc_add_block_to_block (block, &se.pre);\n-\t\t      ptr = se.expr;\n-\t\t      OMP_CLAUSE_SIZE (node)\n-\t\t\t= TYPE_SIZE_UNIT (TREE_TYPE (ptr));\n+\t\t      OMP_CLAUSE_DECL (node) = se.expr;\n+\t\t      gfc_add_block_to_block (block, &se.post);\n+\t\t      goto finalize_map_clause;\n \t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      gfc_conv_expr_descriptor (&se, n->expr);\n-\t\t      ptr = gfc_conv_array_data (se.expr);\n-\t\t      tree type = TREE_TYPE (se.expr);\n-\t\t      gfc_add_block_to_block (block, &se.pre);\n-\t\t      OMP_CLAUSE_SIZE (node)\n-\t\t\t= gfc_full_array_size (block, se.expr,\n-\t\t\t\t\t       GFC_TYPE_ARRAY_RANK (type));\n-\t\t      tree elemsz\n-\t\t\t= TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-\t\t      elemsz = fold_convert (gfc_array_index_type, elemsz);\n-\t\t      OMP_CLAUSE_SIZE (node)\n-\t\t\t= fold_build2 (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t       OMP_CLAUSE_SIZE (node), elemsz);\n-\t\t    }\n-\t\t  gfc_add_block_to_block (block, &se.post);\n-\t\t  ptr = fold_convert (build_pointer_type (char_type_node),\n-\t\t\t\t      ptr);\n-\t\t  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n \n-\t\t  if (POINTER_TYPE_P (TREE_TYPE (decl))\n-\t\t      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n+\t\t  se.expr = gfc_maybe_dereference_var (n->sym, decl);\n+\n+\t\t  for (gfc_ref *ref = n->expr->ref;\n+\t\t       ref && ref != lastcomp->next;\n+\t\t       ref = ref->next)\n \t\t    {\n-\t\t      node4 = build_omp_clause (input_location,\n-\t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (node4, GOMP_MAP_POINTER);\n-\t\t      OMP_CLAUSE_DECL (node4) = decl;\n-\t\t      OMP_CLAUSE_SIZE (node4) = size_int (0);\n-\t\t      decl = build_fold_indirect_ref (decl);\n+\t\t      if (ref->type == REF_COMPONENT)\n+\t\t\t{\n+\t\t\t  if (ref->u.c.sym->attr.extension)\n+\t\t\t    conv_parent_component_references (&se, ref);\n+\n+\t\t\t  gfc_conv_component_ref (&se, ref);\n+\t\t\t}\n+\t\t      else\n+\t\t\tsorry (\"unhandled derived-type component\");\n \t\t    }\n-\t\t  ptr = fold_convert (sizetype, ptr);\n-\t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\n+\t\t  tree inner = se.expr;\n+\n+\t\t  /* Last component is a derived type.  */\n+\t\t  if (lastcomp->u.c.component->ts.type == BT_DERIVED)\n \t\t    {\n-\t\t      tree type = TREE_TYPE (decl);\n-\t\t      ptr2 = gfc_conv_descriptor_data_get (decl);\n-\t\t      node2 = build_omp_clause (input_location,\n-\t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n-\t\t      OMP_CLAUSE_DECL (node2) = decl;\n-\t\t      OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n-\t\t      node3 = build_omp_clause (input_location,\n-\t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n-\t\t      OMP_CLAUSE_DECL (node3)\n-\t\t\t= gfc_conv_descriptor_data_get (decl);\n+\t\t      if (sym_attr.allocatable || sym_attr.pointer)\n+\t\t\t{\n+\t\t\t  tree data = inner;\n+\t\t\t  tree size = TYPE_SIZE_UNIT (TREE_TYPE (inner));\n+\n+\t\t\t  OMP_CLAUSE_DECL (node)\n+\t\t\t    = build_fold_indirect_ref (data);\n+\t\t\t  OMP_CLAUSE_SIZE (node) = size;\n+\t\t\t  node2 = build_omp_clause (input_location,\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node2,\n+\t\t\t\t\t\t   GOMP_MAP_ATTACH_DETACH);\n+\t\t\t  OMP_CLAUSE_DECL (node2) = data;\n+\t\t\t  OMP_CLAUSE_SIZE (node2) = size_int (0);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  OMP_CLAUSE_DECL (node) = decl;\n+\t\t\t  OMP_CLAUSE_SIZE (node)\n+\t\t\t    = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n+\t\t\t}\n \t\t    }\n-\t\t  else\n+\t\t  else if (lastcomp->next\n+\t\t\t   && lastcomp->next->type == REF_ARRAY\n+\t\t\t   && lastcomp->next->u.ar.type == AR_FULL)\n \t\t    {\n-\t\t      if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n-\t\t\tptr2 = build_fold_addr_expr (decl);\n-\t\t      else\n+\t\t      /* Just pass the (auto-dereferenced) decl through for\n+\t\t\t bare attach and detach clauses.  */\n+\t\t      if (n->u.map_op == OMP_MAP_ATTACH\n+\t\t\t  || n->u.map_op == OMP_MAP_DETACH)\n \t\t\t{\n-\t\t\t  gcc_assert (POINTER_TYPE_P (TREE_TYPE (decl)));\n-\t\t\t  ptr2 = decl;\n+\t\t\t  OMP_CLAUSE_DECL (node) = inner;\n+\t\t\t  OMP_CLAUSE_SIZE (node) = size_zero_node;\n+\t\t\t  goto finalize_map_clause;\n \t\t\t}\n-\t\t      node3 = build_omp_clause (input_location,\n-\t\t\t\t\t\tOMP_CLAUSE_MAP);\n-\t\t      OMP_CLAUSE_SET_MAP_KIND (node3, GOMP_MAP_POINTER);\n-\t\t      OMP_CLAUSE_DECL (node3) = decl;\n+\n+\t\t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (inner)))\n+\t\t\t{\n+\t\t\t  tree type = TREE_TYPE (inner);\n+\t\t\t  tree ptr = gfc_conv_descriptor_data_get (inner);\n+\t\t\t  ptr = build_fold_indirect_ref (ptr);\n+\t\t\t  OMP_CLAUSE_DECL (node) = ptr;\n+\t\t\t  node2 = build_omp_clause (input_location,\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node2, GOMP_MAP_TO_PSET);\n+\t\t\t  OMP_CLAUSE_DECL (node2) = inner;\n+\t\t\t  OMP_CLAUSE_SIZE (node2) = TYPE_SIZE_UNIT (type);\n+\t\t\t  node3 = build_omp_clause (input_location,\n+\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (node3,\n+\t\t\t\t\t\t   GOMP_MAP_ATTACH_DETACH);\n+\t\t\t  OMP_CLAUSE_DECL (node3)\n+\t\t\t    = gfc_conv_descriptor_data_get (inner);\n+\t\t\t  STRIP_NOPS (OMP_CLAUSE_DECL (node3));\n+\t\t\t  OMP_CLAUSE_SIZE (node3) = size_int (0);\n+\t\t\t  int rank = GFC_TYPE_ARRAY_RANK (type);\n+\t\t\t  OMP_CLAUSE_SIZE (node)\n+\t\t\t    = gfc_full_array_size (block, inner, rank);\n+\t\t\t  tree elemsz\n+\t\t\t    = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n+\t\t\t  elemsz = fold_convert (gfc_array_index_type, elemsz);\n+\t\t\t  OMP_CLAUSE_SIZE (node)\n+\t\t\t    = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t\t   OMP_CLAUSE_SIZE (node), elemsz);\n+\t\t\t}\n+\t\t      else\n+\t\t\tOMP_CLAUSE_DECL (node) = inner;\n \t\t    }\n-\t\t  ptr2 = fold_convert (sizetype, ptr2);\n-\t\t  OMP_CLAUSE_SIZE (node3)\n-\t\t    = fold_build2 (MINUS_EXPR, sizetype, ptr, ptr2);\n+\t\t  else  /* An array element or section.  */\n+\t\t    {\n+\t\t      bool element\n+\t\t\t= (lastcomp->next\n+\t\t\t   && lastcomp->next->type == REF_ARRAY\n+\t\t\t   && lastcomp->next->u.ar.type == AR_ELEMENT);\n+\n+\t\t      gfc_trans_omp_array_section (block, n, inner, element,\n+\t\t\t\t\t\t   GOMP_MAP_ATTACH_DETACH,\n+\t\t\t\t\t\t   node, node2, node3, node4);\n+\t\t    }\n+\t\t}\n+\t      else  /* An array element or array section.  */\n+\t\t{\n+\t\t  bool element = n->expr->ref->u.ar.type == AR_ELEMENT;\n+\t\t  gfc_trans_omp_array_section (block, n, decl, element,\n+\t\t\t\t\t       GOMP_MAP_POINTER, node, node2,\n+\t\t\t\t\t       node3, node4);\n \t\t}\n+\n+\t      finalize_map_clause:\n \t      switch (n->u.map_op)\n \t\t{\n \t\tcase OMP_MAP_ALLOC:\n@@ -2627,6 +2779,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tcase OMP_MAP_IF_PRESENT:\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_IF_PRESENT);\n \t\t  break;\n+\t\tcase OMP_MAP_ATTACH:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_ATTACH);\n+\t\t  break;\n \t\tcase OMP_MAP_TO:\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_TO);\n \t\t  break;\n@@ -2651,6 +2806,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tcase OMP_MAP_DELETE:\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DELETE);\n \t\t  break;\n+\t\tcase OMP_MAP_DETACH:\n+\t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_DETACH);\n+\t\t  break;\n \t\tcase OMP_MAP_FORCE_ALLOC:\n \t\t  OMP_CLAUSE_SET_MAP_KIND (node, GOMP_MAP_FORCE_ALLOC);\n \t\t  break;"}, {"sha": "4358ba017fdbd7b14bd8ff13c88912cc72d6f25b", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -565,6 +565,14 @@ tree gfc_conv_expr_present (gfc_symbol *);\n /* Convert a missing, dummy argument into a null or zero.  */\n void gfc_conv_missing_dummy (gfc_se *, gfc_expr *, gfc_typespec, int);\n \n+/* Lowering of component references.  */\n+void gfc_conv_component_ref (gfc_se * se, gfc_ref * ref);\n+void conv_parent_component_references (gfc_se * se, gfc_ref * ref);\n+\n+/* Automatically dereference var.  */\n+tree gfc_maybe_dereference_var (gfc_symbol *, tree, bool desc_only = false,\n+\t\t\t\tbool is_classarray = false);\n+\n /* Generate code to allocate a string temporary.  */\n tree gfc_conv_string_tmp (gfc_se *, tree, tree);\n /* Get the string length variable belonging to an expression.  */"}, {"sha": "8c2abb64d37ef9ed4f16ace03652f33d93d987a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -1,3 +1,11 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+        * gfortran.dg/goacc/derived-types.f90: New test.\n+        * gfortran.dg/goacc/derived-types-2.f90: New test.\n+        * gfortran.dg/goacc/derived-types-3.f90: New test.\n+        * gfortran.dg/goacc/data-clauses.f95: Adjust for expected errors.\n+        * gfortran.dg/goacc/enter-exit-data.f95: Likewise.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "cc68e408e1fbcb82c956f20750698e5c54f98884", "filename": "gcc/testsuite/gfortran.dg/goacc/data-clauses.f95", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-clauses.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-clauses.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fdata-clauses.f95?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -39,9 +39,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel copy (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel copy (tip)\n   !$acc end parallel\n-  !$acc parallel copy (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel copy (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) copy (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -54,9 +54,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel copyin (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel copyin (tip)\n   !$acc end parallel\n-  !$acc parallel copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel copyin (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) copyin (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -71,9 +71,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel copyout (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel copyout (tip)\n   !$acc end parallel\n-  !$acc parallel copyout (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel copyout (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) copyout (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -90,9 +90,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel create (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel create (tip)\n   !$acc end parallel\n-  !$acc parallel create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel create (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) create (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -134,7 +134,7 @@ subroutine foo (vi, asa)\n \n   !$acc parallel present (tip) ! { dg-error \"POINTER\" }\n   !$acc end parallel\n-  !$acc parallel present (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel present (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) present (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -165,9 +165,9 @@ subroutine foo (vi, asa)\n   !$acc end parallel\n \n \n-  !$acc parallel present_or_copy (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel present_or_copy (tip)\n   !$acc end parallel\n-  !$acc parallel present_or_copy (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel present_or_copy (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) present_or_copy (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -190,9 +190,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel present_or_copyin (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel present_or_copyin (tip)\n   !$acc end parallel\n-  !$acc parallel present_or_copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel present_or_copyin (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -217,9 +217,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel present_or_copyout (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel present_or_copyout (tip)\n   !$acc end parallel\n-  !$acc parallel present_or_copyout (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel present_or_copyout (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) present_or_copyout (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -246,9 +246,9 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n \n-  !$acc parallel present_or_create (tip) ! { dg-error \"POINTER\" }\n+  !$acc parallel present_or_create (tip)\n   !$acc end parallel\n-  !$acc parallel present_or_create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc parallel present_or_create (tia)\n   !$acc end parallel\n   !$acc parallel deviceptr (i) present_or_create (i) ! { dg-error \"multiple clauses\" }\n   !$acc end parallel\n@@ -277,4 +277,4 @@ subroutine foo (vi, asa)\n   !$acc end data\n \n   end subroutine foo\n-end module test\n\\ No newline at end of file\n+end module test"}, {"sha": "d01583fac890c5397d9545eef508e8ebd1586ed2", "filename": "gcc/testsuite/gfortran.dg/goacc/derived-types-2.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types-2.f90?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -0,0 +1,14 @@\n+module bar\n+  type :: type1\n+     real(8), pointer, public :: p(:) => null()\n+  end type\n+  type :: type2\n+     class(type1), pointer :: p => null()\n+  end type\n+end module\n+\n+subroutine foo (var)\n+   use bar\n+   type(type2), intent(inout) :: var\n+   !$acc enter data create(var%p%p)\n+end subroutine"}, {"sha": "9619e2fe1f3ae1510ecf2bab03fddaa004e99b92", "filename": "gcc/testsuite/gfortran.dg/goacc/derived-types-3.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types-3.f90?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -0,0 +1,12 @@\n+module bar\n+  type :: type1\n+     integer :: a(5)\n+     integer :: b(5)\n+  end type\n+end module\n+\n+subroutine foo\n+   use bar\n+   type(type1) :: var\n+   !$acc enter data copyin(var%a) copyin(var%a) ! { dg-error \".var\\.a. appears more than once in map clauses\" }\n+end subroutine"}, {"sha": "5fb29816c42f6dc93c306e236c71bad528abea01", "filename": "gcc/testsuite/gfortran.dg/goacc/derived-types.f90", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fderived-types.f90?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -0,0 +1,77 @@\n+! Test ACC UPDATE with derived types.\n+\n+module dt\n+  integer, parameter :: n = 10\n+  type inner\n+     integer :: d(n)\n+  end type inner\n+  type dtype\n+     integer(8) :: a, b, c(n)\n+     type(inner) :: in\n+  end type dtype\n+end module dt\n+\n+program derived_acc\n+  use dt\n+  \n+  implicit none\n+  type(dtype):: var\n+  integer i\n+  !$acc declare create(var)\n+  !$acc declare pcopy(var%a) ! { dg-error \"Syntax error in OpenMP\" }\n+\n+  !$acc update host(var)\n+  !$acc update host(var%a)\n+  !$acc update device(var)\n+  !$acc update device(var%a)\n+  !$acc update self(var)\n+  !$acc update self(var%a)\n+  \n+  !$acc enter data copyin(var)\n+  !$acc enter data copyin(var%a)\n+\n+  !$acc exit data copyout(var)\n+  !$acc exit data copyout(var%a)\n+\n+  !$acc data copy(var)\n+  !$acc end data\n+\n+  !$acc data copyout(var%a)\n+  !$acc end data\n+\n+  !$acc parallel loop pcopyout(var)\n+  do i = 1, 10\n+  end do  \n+  !$acc end parallel loop\n+\n+  !$acc parallel loop copyout(var%a)\n+  do i = 1, 10\n+  end do\n+  !$acc end parallel loop\n+\n+  !$acc parallel pcopy(var)\n+  !$acc end parallel\n+\n+  !$acc parallel pcopy(var%a)\n+  do i = 1, 10\n+  end do\n+  !$acc end parallel\n+  \n+  !$acc kernels pcopyin(var)\n+  !$acc end kernels\n+\n+  !$acc kernels pcopy(var%a)\n+  do i = 1, 10\n+  end do\n+  !$acc end kernels\n+\n+  !$acc kernels loop pcopyin(var)\n+  do i = 1, 10\n+  end do\n+  !$acc end kernels loop\n+\n+  !$acc kernels loop pcopy(var%a)\n+  do i = 1, 10\n+  end do\n+  !$acc end kernels loop\n+end program derived_acc"}, {"sha": "c2a497963181822d476c91830807a2ae2d9c62be", "filename": "gcc/testsuite/gfortran.dg/goacc/enter-exit-data.f95", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fenter-exit-data.f95", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/549188ea10757060b5de532d232813f09d64d9d1/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fenter-exit-data.f95", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Fenter-exit-data.f95?ref=549188ea10757060b5de532d232813f09d64d9d1", "patch": "@@ -44,14 +44,14 @@ subroutine foo (vi)\n   !$acc enter data wait (i, 1) \n   !$acc enter data wait (a) ! { dg-error \"INTEGER\" }\n   !$acc enter data wait (b(5:6)) ! { dg-error \"INTEGER\" }\n-  !$acc enter data copyin (tip) ! { dg-error \"POINTER\" }\n-  !$acc enter data copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n-  !$acc enter data create (tip) ! { dg-error \"POINTER\" }\n-  !$acc enter data create (tia) ! { dg-error \"ALLOCATABLE\" }\n-  !$acc enter data present_or_copyin (tip) ! { dg-error \"POINTER\" }\n-  !$acc enter data present_or_copyin (tia) ! { dg-error \"ALLOCATABLE\" }\n-  !$acc enter data present_or_create (tip) ! { dg-error \"POINTER\" }\n-  !$acc enter data present_or_create (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc enter data copyin (tip)\n+  !$acc enter data copyin (tia)\n+  !$acc enter data create (tip)\n+  !$acc enter data create (tia)\n+  !$acc enter data present_or_copyin (tip)\n+  !$acc enter data present_or_copyin (tia)\n+  !$acc enter data present_or_create (tip)\n+  !$acc enter data present_or_create (tia)\n   !$acc enter data copyin (i) create (i) ! { dg-error \"multiple clauses\" }\n   !$acc enter data copyin (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n   !$acc enter data create (i) present_or_copyin (i) ! { dg-error \"multiple clauses\" }\n@@ -79,10 +79,10 @@ subroutine foo (vi)\n   !$acc exit data wait (i, 1) \n   !$acc exit data wait (a) ! { dg-error \"INTEGER\" }\n   !$acc exit data wait (b(5:6)) ! { dg-error \"INTEGER\" }\n-  !$acc exit data copyout (tip) ! { dg-error \"POINTER\" }\n-  !$acc exit data copyout (tia) ! { dg-error \"ALLOCATABLE\" }\n-  !$acc exit data delete (tip) ! { dg-error \"POINTER\" }\n-  !$acc exit data delete (tia) ! { dg-error \"ALLOCATABLE\" }\n+  !$acc exit data copyout (tip)\n+  !$acc exit data copyout (tia)\n+  !$acc exit data delete (tip)\n+  !$acc exit data delete (tia)\n   !$acc exit data copyout (i) delete (i) ! { dg-error \"multiple clauses\" }\n   !$acc exit data finalize\n   !$acc exit data finalize copyout (i)"}]}