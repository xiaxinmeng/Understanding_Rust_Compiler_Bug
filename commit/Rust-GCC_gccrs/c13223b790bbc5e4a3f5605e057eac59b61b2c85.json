{"sha": "c13223b790bbc5e4a3f5605e057eac59b61b2c85", "node_id": "C_kwDOANBUbNoAKGMxMzIyM2I3OTBiYmM1ZTRhM2Y1NjA1ZTA1N2VhYzU5YjYxYjJjODU", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-08-04T01:04:22Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-09-07T00:38:18Z"}, "message": "Extend vectorizer to handle nonlinear induction for neg, mul/lshift/rshift with a constant.\n\nFor neg, the patch create a vec_init as [ a, -a, a, -a, ...  ] and no\nvec_step is needed to update vectorized iv since vf is always multiple\nof 2(negative * negative is positive).\n\nFor shift, the patch create a vec_init as [ a, a >> c, a >> 2*c, ..]\nas vec_step as [ c * nunits, c * nunits, c * nunits, ... ], vectorized iv is\nupdated as vec_def = vec_init >>/<< vec_step.\n\nFor mul, the patch create a vec_init as [ a, a * c, a * pow(c, 2), ..]\nas vec_step as [ pow(c,nunits), pow(c,nunits),...] iv is updated as vec_def =\nvec_init * vec_step.\n\nThe patch handles nonlinear iv for\n1. Integer type only, floating point is not handled.\n2. No slp_node.\n3. iv_loop should be same as vector loop, not nested loop.\n4. No UD is created, for mul, use unsigned mult to avoid UD, for\n   shift, shift count should be less than type precision.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/103144\n\t* tree-vect-loop.cc (vect_is_nonlinear_iv_evolution): New function.\n\t(vect_analyze_scalar_cycles_1): Detect nonlinear iv by upper function.\n\t(vect_create_nonlinear_iv_init): New function.\n\t(vect_peel_nonlinear_iv_init): Ditto.\n\t(vect_create_nonlinear_iv_step): Ditto\n\t(vect_create_nonlinear_iv_vec_step): Ditto\n\t(vect_update_nonlinear_iv): Ditto\n\t(vectorizable_nonlinear_induction): Ditto.\n\t(vectorizable_induction): Call\n\tvectorizable_nonlinear_induction when induction_type is not\n\tvect_step_op_add.\n\t* tree-vect-loop-manip.cc (vect_update_ivs_after_vectorizer):\n\tUpdate nonlinear iv for epilogue loop.\n\t* tree-vectorizer.h (enum vect_induction_op_type): New enum.\n\t(STMT_VINFO_LOOP_PHI_EVOLUTION_TYPE): New Macro.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr103144-mul-1.c: New test.\n\t* gcc.target/i386/pr103144-mul-2.c: New test.\n\t* gcc.target/i386/pr103144-neg-1.c: New test.\n\t* gcc.target/i386/pr103144-neg-2.c: New test.\n\t* gcc.target/i386/pr103144-shift-1.c: New test.\n\t* gcc.target/i386/pr103144-shift-2.c: New test.", "tree": {"sha": "81b0c81278cccab858a26aca5cb9528059db4b9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b0c81278cccab858a26aca5cb9528059db4b9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c13223b790bbc5e4a3f5605e057eac59b61b2c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13223b790bbc5e4a3f5605e057eac59b61b2c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13223b790bbc5e4a3f5605e057eac59b61b2c85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13223b790bbc5e4a3f5605e057eac59b61b2c85/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25aeb92221659067b5d83c6ca1639374ce9be555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25aeb92221659067b5d83c6ca1639374ce9be555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25aeb92221659067b5d83c6ca1639374ce9be555"}], "stats": {"total": 1076, "additions": 1062, "deletions": 14}, "files": [{"sha": "640c34fd959b60b86f5378753b1425a11b91b10f", "filename": "gcc/testsuite/gcc.target/i386/pr103144-mul-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-mul-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-mul-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-mul-1.c?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fvect-cost-model=unlimited -fdump-tree-vect-details -mprefer-vector-width=256\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 4 \"vect\" } } */\n+\n+#define N 10000\n+\n+void\n+__attribute__((noipa))\n+foo_mul (int* a, int b)\n+{\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b *= 3;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_mul_const (int* a)\n+{\n+  int b = 1;\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b *= 3;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_mul_peel (int* a, int b)\n+{\n+  for (int i = 0; i != 39; i++)\n+    {\n+      a[i] = b;\n+      b *= 3;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_mul_peel_const (int* a)\n+{\n+  int b = 1;\n+  for (int i = 0; i != 39; i++)\n+    {\n+      a[i] = b;\n+      b *= 3;\n+    }\n+}"}, {"sha": "39fdea3a69dd7b56737a9dae00dcf93d09001147", "filename": "gcc/testsuite/gcc.target/i386/pr103144-mul-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-mul-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-mul-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-mul-2.c?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fvect-cost-model=unlimited -mprefer-vector-width=256\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#include \"avx2-check.h\"\n+#include <string.h>\n+#include \"pr103144-mul-1.c\"\n+\n+typedef int v8si __attribute__((vector_size(32)));\n+\n+void\n+avx2_test (void)\n+{\n+  int* epi32_exp = (int*) malloc (N * sizeof (int));\n+  int* epi32_dst = (int*) malloc (N * sizeof (int));\n+\n+  __builtin_memset (epi32_exp, 0, N * sizeof (int));\n+  int b = 8;\n+  v8si init = __extension__(v8si) { b, b * 3, b * 9, b * 27, b * 81, b * 243, b * 729, b * 2187 };\n+\n+  for (int i = 0; i != N / 8; i++)\n+    {\n+      memcpy (epi32_exp + i * 8, &init, 32);\n+      init *= 6561;\n+    }\n+\n+  foo_mul (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_mul_peel (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, 39 * 4) != 0)\n+    __builtin_abort ();\n+\n+  init = __extension__(v8si) { 1, 3, 9, 27, 81, 243, 729, 2187 };\n+  for (int i = 0; i != N / 8; i++)\n+    {\n+      memcpy (epi32_exp + i * 8, &init, 32);\n+      init *= 6561;\n+    }\n+\n+  foo_mul_const (epi32_dst);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_mul_peel_const (epi32_dst);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, 39 * 4) != 0)\n+    __builtin_abort ();\n+\n+  return;\n+}"}, {"sha": "f87b1d6e52916eba4000d1c63c8ba2f3c186b47a", "filename": "gcc/testsuite/gcc.target/i386/pr103144-neg-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-neg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-neg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-neg-1.c?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fvect-cost-model=unlimited -fdump-tree-vect-details -mprefer-vector-width=256\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 4 \"vect\" } } */\n+\n+#define N 10000\n+\n+void\n+__attribute__((noipa))\n+foo_neg (int* a, int b)\n+{\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b = -b;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_neg_const (int* a)\n+{\n+  int b = 1;\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b = -b;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_neg_peel (int* a, int b, int n)\n+{\n+  for (int i = 0; i != n; i++)\n+    {\n+      a[i] = b;\n+      b = -b;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_neg_const_peel (int* a, int n)\n+{\n+  int b = 1;\n+  for (int i = 0; i != n; i++)\n+    {\n+      a[i] = b;\n+      b = -b;\n+    }\n+}"}, {"sha": "bb8c22b9f9ed69db9321f5e6ae4fcee1aeaec2e2", "filename": "gcc/testsuite/gcc.target/i386/pr103144-neg-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-neg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-neg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-neg-2.c?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fvect-cost-model=unlimited -mprefer-vector-width=256\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#include \"avx2-check.h\"\n+#include <string.h>\n+#include \"pr103144-neg-1.c\"\n+\n+void\n+avx2_test (void)\n+{\n+  int* epi32_exp = (int*) malloc (N * sizeof (int));\n+  int* epi32_dst = (int*) malloc (N * sizeof (int));\n+  long long* epi64_exp = (long long*) malloc (N * sizeof (int));\n+\n+  __builtin_memset (epi32_exp, 0, N * sizeof (int));\n+  int b = 100;\n+\n+  for (int i = 0; i != N / 2; i++)\n+    epi64_exp[i] = ((long long) b) | (((long long) -b) << 32);\n+    \n+  memcpy (epi32_exp, epi64_exp, N * sizeof (int));\n+  foo_neg (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_neg_peel (epi32_dst, b, 39);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, 39 * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i != N / 2; i++)\n+    epi64_exp[i] = ((long long) 1) | (((long long) -1) << 32);\n+    \n+  memcpy (epi32_exp, epi64_exp, N * sizeof (int));\n+  foo_neg_const (epi32_dst);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_neg_const_peel (epi32_dst, 39);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, 39 * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  return;\n+}"}, {"sha": "2a6920350dd866324b28e6d9c7a8e3590af73fb4", "filename": "gcc/testsuite/gcc.target/i386/pr103144-shift-1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-shift-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-shift-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-shift-1.c?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fvect-cost-model=unlimited -fdump-tree-vect-details -mprefer-vector-width=256\" } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 6 \"vect\" } } */\n+\n+#define N 10000\n+void\n+__attribute__((noipa))\n+foo_shl (int* a, int b)\n+{\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b <<= 1;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_ashr (int* a, int b)\n+{\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b >>= 1;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_lshr (unsigned int* a, unsigned int b)\n+{\n+  for (int i = 0; i != N; i++)\n+    {\n+      a[i] = b;\n+      b >>= 1U;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_shl_peel (int* a, int b)\n+{\n+  for (int i = 0; i != 39; i++)\n+    {\n+      a[i] = b;\n+      b <<= 1;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_ashr_peel (int* a, int b)\n+{\n+  for (int i = 0; i != 39; i++)\n+    {\n+      a[i] = b;\n+      b >>= 1;\n+    }\n+}\n+\n+void\n+__attribute__((noipa))\n+foo_lshr_peel (unsigned int* a, unsigned int b)\n+{\n+  for (int i = 0; i != 39; i++)\n+    {\n+      a[i] = b;\n+      b >>= 1U;\n+    }\n+}"}, {"sha": "6f477191d96e5676b39de539fbe808e41be2bc14", "filename": "gcc/testsuite/gcc.target/i386/pr103144-shift-2.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-shift-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-shift-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr103144-shift-2.c?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx2 -ftree-vectorize -fvect-cost-model=unlimited -mprefer-vector-width=256\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#include \"avx2-check.h\"\n+#include <string.h>\n+#include \"pr103144-shift-1.c\"\n+\n+typedef int v8si __attribute__((vector_size(32)));\n+typedef unsigned int v8usi __attribute__((vector_size(32)));\n+\n+void\n+avx2_test (void)\n+{\n+  int* epi32_exp = (int*) malloc (N * sizeof (int));\n+  int* epi32_dst = (int*) malloc (N * sizeof (int));\n+  unsigned int* epu32_exp = (unsigned int*) malloc (N * sizeof (int));\n+  unsigned int* epu32_dst = (unsigned int*) malloc (N * sizeof (int));\n+\n+  __builtin_memset (epi32_exp, 0, N * sizeof (int));\n+  int b = 8;\n+  v8si init = __extension__(v8si) { b, b << 1, b << 2, b << 3, b << 4, b << 5, b << 6, b << 7 };\n+\n+  for (int i = 0; i != N / 8; i++)\n+    {\n+      memcpy (epi32_exp + i * 8, &init, 32);\n+      init <<= 8;\n+    }\n+\n+  foo_shl (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_shl_peel (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, 39 * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  b = -11111;\n+  init = __extension__(v8si) { b, b >> 1, b >> 2, b >> 3, b >> 4, b >> 5, b >> 6, b >> 7 };\n+  for (int i = 0; i != N / 8; i++)\n+    {\n+      memcpy (epi32_exp + i * 8, &init, 32);\n+      init >>= 8;\n+    }\n+\n+  foo_ashr (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_ashr_peel (epi32_dst, b);\n+  if (__builtin_memcmp (epi32_dst, epi32_exp, 39 * sizeof (int)) != 0)\n+    {\n+      for (int i = 0; i != 39; i++)\n+\t{\n+\t  printf (\"epi32_dst[%d] is %d ----\", i, epi32_dst[i]);\n+\t  printf (\"epi32_exp[%d] is %d\\n\", i, epi32_exp[i]);\n+\t}\n+         __builtin_abort ();\n+    }\n+\n+  __builtin_memset (epu32_exp, 0, N * sizeof (int));\n+  unsigned int c = 11111111;\n+  v8usi initu = __extension__(v8usi) { c, c >> 1U, c >> 2U, c >> 3U, c >> 4U, c >> 5U, c >> 6U, c >> 7U };\n+  for (int i = 0; i != N / 8; i++)\n+    {\n+      memcpy (epu32_exp + i * 8, &initu, 32);\n+      initu >>= 8U;\n+    }\n+\n+  foo_lshr (epu32_dst, c);\n+  if (__builtin_memcmp (epu32_dst, epu32_exp, N * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  foo_lshr_peel (epu32_dst, c);\n+  if (__builtin_memcmp (epu32_dst, epu32_exp, 39 * sizeof (int)) != 0)\n+    __builtin_abort ();\n+\n+  return;\n+}"}, {"sha": "74b221a973cc7128a15b4e1b164b42de53302c60", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -1560,15 +1560,28 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n       gcc_assert (!tree_is_chrec (step_expr));\n \n       init_expr = PHI_ARG_DEF_FROM_EDGE (phi, loop_preheader_edge (loop));\n+      gimple_seq stmts = NULL;\n+      enum vect_induction_op_type induction_type\n+\t= STMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (phi_info);\n \n-      off = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n-\t\t\t fold_convert (TREE_TYPE (step_expr), niters),\n-\t\t\t step_expr);\n-      if (POINTER_TYPE_P (type))\n-\tni = fold_build_pointer_plus (init_expr, off);\n+      if (induction_type == vect_step_op_add)\n+\t{\n+\t  off = fold_build2 (MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t     fold_convert (TREE_TYPE (step_expr), niters),\n+\t\t\t     step_expr);\n+\t  if (POINTER_TYPE_P (type))\n+\t    ni = fold_build_pointer_plus (init_expr, off);\n+\t  else\n+\t    ni = fold_build2 (PLUS_EXPR, type,\n+\t\t\t      init_expr, fold_convert (type, off));\n+\t}\n+      /* Don't bother call vect_peel_nonlinear_iv_init.  */\n+      else if (induction_type == vect_step_op_neg)\n+\tni = init_expr;\n       else\n-\tni = fold_build2 (PLUS_EXPR, type,\n-\t\t\t  init_expr, fold_convert (type, off));\n+\tni = vect_peel_nonlinear_iv_init (&stmts, init_expr,\n+\t\t\t\t\t  niters, step_expr,\n+\t\t\t\t\t  induction_type);\n \n       var = create_tmp_var (type, \"tmp\");\n \n@@ -1577,9 +1590,15 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n       ni_name = force_gimple_operand (ni, &new_stmts, false, var);\n       /* Exit_bb shouldn't be empty.  */\n       if (!gsi_end_p (last_gsi))\n-\tgsi_insert_seq_after (&last_gsi, new_stmts, GSI_SAME_STMT);\n+\t{\n+\t  gsi_insert_seq_after (&last_gsi, stmts, GSI_SAME_STMT);\n+\t  gsi_insert_seq_after (&last_gsi, new_stmts, GSI_SAME_STMT);\n+\t}\n       else\n-\tgsi_insert_seq_before (&last_gsi, new_stmts, GSI_SAME_STMT);\n+\t{\n+\t  gsi_insert_seq_before (&last_gsi, stmts, GSI_SAME_STMT);\n+\t  gsi_insert_seq_before (&last_gsi, new_stmts, GSI_SAME_STMT);\n+\t}\n \n       /* Fix phi expressions in the successor bb.  */\n       adjust_phi_and_debug_stmts (phi1, update_e, ni_name);"}, {"sha": "8f88f1755be0efe6ccdd50a45c2b2e9755707f89", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 673, "deletions": 5, "changes": 678, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -425,6 +425,77 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n   return true;\n }\n \n+/* Function vect_is_nonlinear_iv_evolution\n+\n+   Only support nonlinear induction for integer type\n+   1. neg\n+   2. mul by constant\n+   3. lshift/rshift by constant.\n+\n+   For neg induction, return a fake step as integer -1.  */\n+static bool\n+vect_is_nonlinear_iv_evolution (class loop* loop, stmt_vec_info stmt_info,\n+\t\t\t\tgphi* loop_phi_node, tree *init, tree *step)\n+{\n+  tree init_expr, ev_expr, result, op1, op2;\n+  gimple* def;\n+\n+  if (gimple_phi_num_args (loop_phi_node) != 2)\n+    return false;\n+\n+  init_expr = PHI_ARG_DEF_FROM_EDGE (loop_phi_node, loop_preheader_edge (loop));\n+  ev_expr = PHI_ARG_DEF_FROM_EDGE (loop_phi_node, loop_latch_edge (loop));\n+\n+  /* Support nonlinear induction only for integer type.  */\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (init_expr)))\n+    return false;\n+\n+  *init = init_expr;\n+  result = PHI_RESULT (loop_phi_node);\n+\n+  if (TREE_CODE (ev_expr) != SSA_NAME\n+      || ((def = SSA_NAME_DEF_STMT (ev_expr)), false)\n+      || !is_gimple_assign (def))\n+    return false;\n+\n+  enum tree_code t_code = gimple_assign_rhs_code (def);\n+  switch (t_code)\n+    {\n+    case NEGATE_EXPR:\n+      if (gimple_assign_rhs1 (def) != result)\n+\treturn false;\n+      *step = build_int_cst (TREE_TYPE (init_expr), -1);\n+      STMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (stmt_info) = vect_step_op_neg;\n+      break;\n+\n+    case RSHIFT_EXPR:\n+    case LSHIFT_EXPR:\n+    case MULT_EXPR:\n+      op1 = gimple_assign_rhs1 (def);\n+      op2 = gimple_assign_rhs2 (def);\n+      if (TREE_CODE (op2) != INTEGER_CST\n+\t  || op1 != result)\n+\treturn false;\n+      *step = op2;\n+      if (t_code == LSHIFT_EXPR)\n+\tSTMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (stmt_info) = vect_step_op_shl;\n+      else if (t_code == RSHIFT_EXPR)\n+\tSTMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (stmt_info) = vect_step_op_shr;\n+      /* NEGATE_EXPR and MULT_EXPR are both vect_step_op_mul.  */\n+      else\n+\tSTMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (stmt_info) = vect_step_op_mul;\n+      break;\n+\n+    default:\n+      return false;\n+    }\n+\n+  STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED (stmt_info) = *init;\n+  STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info) = *step;\n+\n+  return true;\n+}\n+\n /* Return true if PHI, described by STMT_INFO, is the inner PHI in\n    what we are assuming is a double reduction.  For example, given\n    a structure like this:\n@@ -513,11 +584,16 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, class loop *loop,\n \t    = evolution_part_in_loop_num (access_fn, loop->num);\n \t}\n \n-      if (!access_fn\n-\t  || vect_inner_phi_in_double_reduction_p (loop_vinfo, phi)\n-\t  || !vect_is_simple_iv_evolution (loop->num, access_fn, &init, &step)\n-\t  || (LOOP_VINFO_LOOP (loop_vinfo) != loop\n-\t      && TREE_CODE (step) != INTEGER_CST))\n+      if ((!access_fn\n+\t   || vect_inner_phi_in_double_reduction_p (loop_vinfo, phi)\n+\t   || !vect_is_simple_iv_evolution (loop->num, access_fn,\n+\t\t\t\t\t    &init, &step)\n+\t   || (LOOP_VINFO_LOOP (loop_vinfo) != loop\n+\t       && TREE_CODE (step) != INTEGER_CST))\n+\t  /* Only handle nonlinear iv for same loop.  */\n+\t  && (LOOP_VINFO_LOOP (loop_vinfo) != loop\n+\t      || !vect_is_nonlinear_iv_evolution (loop, stmt_vinfo,\n+\t\t\t\t\t\t  phi, &init, &step)))\n \t{\n \t  worklist.safe_push (stmt_vinfo);\n \t  continue;\n@@ -8233,6 +8309,591 @@ vect_can_vectorize_without_simd_p (code_helper code)\n \t  && vect_can_vectorize_without_simd_p (tree_code (code)));\n }\n \n+/* Create vector init for vectorized iv.  */\n+static tree\n+vect_create_nonlinear_iv_init (gimple_seq* stmts, tree init_expr,\n+\t\t\t       tree step_expr, poly_uint64 nunits,\n+\t\t\t       tree vectype,\n+\t\t\t       enum vect_induction_op_type induction_type)\n+{\n+  unsigned HOST_WIDE_INT const_nunits;\n+  tree vec_shift, vec_init, new_name;\n+  unsigned i;\n+  tree itype = TREE_TYPE (vectype);\n+\n+  /* iv_loop is the loop to be vectorized. Create:\n+     vec_init = [X, X+S, X+2*S, X+3*S] (S = step_expr, X = init_expr).  */\n+  new_name = gimple_convert (stmts, itype, init_expr);\n+  switch (induction_type)\n+    {\n+    case vect_step_op_shr:\n+    case vect_step_op_shl:\n+      /* Build the Initial value from shift_expr.  */\n+      vec_init = gimple_build_vector_from_val (stmts,\n+\t\t\t\t\t       vectype,\n+\t\t\t\t\t       new_name);\n+      vec_shift = gimple_build (stmts, VEC_SERIES_EXPR, vectype,\n+\t\t\t\tbuild_zero_cst (itype), step_expr);\n+      vec_init = gimple_build (stmts,\n+\t\t\t       (induction_type == vect_step_op_shr\n+\t\t\t\t? RSHIFT_EXPR : LSHIFT_EXPR),\n+\t\t\t       vectype, vec_init, vec_shift);\n+      break;\n+\n+    case vect_step_op_neg:\n+      {\n+\tvec_init = gimple_build_vector_from_val (stmts,\n+\t\t\t\t\t\t vectype,\n+\t\t\t\t\t\t new_name);\n+\ttree vec_neg = gimple_build (stmts, NEGATE_EXPR,\n+\t\t\t\t     vectype, vec_init);\n+\t/* The encoding has 2 interleaved stepped patterns.  */\n+\tvec_perm_builder sel (nunits, 2, 3);\n+\tsel.quick_grow (6);\n+\tfor (i = 0; i < 3; i++)\n+\t  {\n+\t    sel[2 * i] = i;\n+\t    sel[2 * i + 1] = i + nunits;\n+\t  }\n+\tvec_perm_indices indices (sel, 2, nunits);\n+\ttree perm_mask_even\n+\t  = vect_gen_perm_mask_checked (vectype, indices);\n+\tvec_init = gimple_build (stmts, VEC_PERM_EXPR,\n+\t\t\t\t vectype,\n+\t\t\t\t vec_init, vec_neg,\n+\t\t\t\t perm_mask_even);\n+      }\n+      break;\n+\n+    case vect_step_op_mul:\n+      {\n+\t/* Use unsigned mult to avoid UD integer overflow.  */\n+\tgcc_assert (nunits.is_constant (&const_nunits));\n+\ttree utype = unsigned_type_for (itype);\n+\ttree uvectype = build_vector_type (utype,\n+\t\t\t\t\t   TYPE_VECTOR_SUBPARTS (vectype));\n+\tnew_name = gimple_convert (stmts, utype, new_name);\n+\tvec_init = gimple_build_vector_from_val (stmts,\n+\t\t\t\t\t\t uvectype,\n+\t\t\t\t\t\t new_name);\n+\ttree_vector_builder elts (uvectype, const_nunits, 1);\n+\ttree elt_step = build_one_cst (utype);\n+\n+\telts.quick_push (elt_step);\n+\tfor (i = 1; i < const_nunits; i++)\n+\t  {\n+\t    /* Create: new_name_i = new_name + step_expr.  */\n+\t    elt_step = gimple_build (stmts, MULT_EXPR,\n+\t\t\t\t     utype, elt_step, step_expr);\n+\t    elts.quick_push (elt_step);\n+\t  }\n+\t/* Create a vector from [new_name_0, new_name_1, ...,\n+\t   new_name_nunits-1].  */\n+\ttree vec_mul = gimple_build_vector (stmts, &elts);\n+\tvec_init = gimple_build (stmts, MULT_EXPR, uvectype,\n+\t\t\t\t vec_init, vec_mul);\n+\tvec_init = gimple_convert (stmts, vectype, vec_init);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return vec_init;\n+}\n+\n+/* Peel init_expr by skip_niter for induction_type.  */\n+tree\n+vect_peel_nonlinear_iv_init (gimple_seq* stmts, tree init_expr,\n+\t\t\t     tree skip_niters, tree step_expr,\n+\t\t\t     enum vect_induction_op_type induction_type)\n+{\n+  gcc_assert (TREE_CODE (skip_niters) == INTEGER_CST);\n+  tree type = TREE_TYPE (init_expr);\n+  unsigned prec = TYPE_PRECISION (type);\n+  switch (induction_type)\n+    {\n+    case vect_step_op_neg:\n+      if (TREE_INT_CST_LOW (skip_niters) % 2)\n+\tinit_expr = gimple_build (stmts, NEGATE_EXPR, type, init_expr);\n+      /* else no change.  */\n+      break;\n+\n+    case vect_step_op_shr:\n+    case vect_step_op_shl:\n+      skip_niters = gimple_convert (stmts, type, skip_niters);\n+      step_expr = gimple_build (stmts, MULT_EXPR, type, step_expr, skip_niters);\n+      /* When shift mount >= precision, need to avoid UD.\n+\t In the original loop, there's no UD, and according to semantic,\n+\t init_expr should be 0 for lshr, ashl, and >>= (prec - 1) for ashr.  */\n+      if (!tree_fits_uhwi_p (step_expr)\n+\t  || tree_to_uhwi (step_expr) >= prec)\n+\t{\n+\t  if (induction_type == vect_step_op_shl\n+\t      || TYPE_UNSIGNED (type))\n+\t    init_expr = build_zero_cst (type);\n+\t  else\n+\t    init_expr = gimple_build (stmts, RSHIFT_EXPR, type,\n+\t\t\t\t      init_expr,\n+\t\t\t\t      wide_int_to_tree (type, prec - 1));\n+\t}\n+      else\n+\tinit_expr = gimple_build (stmts, (induction_type == vect_step_op_shr\n+\t\t\t\t\t  ? RSHIFT_EXPR : LSHIFT_EXPR),\n+\t\t\t\t  type, init_expr, step_expr);\n+      break;\n+\n+    case vect_step_op_mul:\n+      {\n+\ttree utype = unsigned_type_for (type);\n+\tinit_expr = gimple_convert (stmts, utype, init_expr);\n+\tunsigned skipn = TREE_INT_CST_LOW (skip_niters);\n+\twide_int begin = wi::to_wide (step_expr);\n+\tfor (unsigned i = 0; i != skipn - 1; i++)\n+\t  begin = wi::mul (begin, wi::to_wide (step_expr));\n+\ttree mult_expr = wide_int_to_tree (utype, begin);\n+\tinit_expr = gimple_build (stmts, MULT_EXPR, utype, init_expr, mult_expr);\n+\tinit_expr = gimple_convert (stmts, type, init_expr);\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return init_expr;\n+}\n+\n+/* Create vector step for vectorized iv.  */\n+static tree\n+vect_create_nonlinear_iv_step (gimple_seq* stmts, tree step_expr,\n+\t\t\t       poly_uint64 vf,\n+\t\t\t       enum vect_induction_op_type induction_type)\n+{\n+  tree expr = build_int_cst (TREE_TYPE (step_expr), vf);\n+  tree new_name = NULL;\n+  /* Step should be pow (step, vf) for mult induction.  */\n+  if (induction_type == vect_step_op_mul)\n+    {\n+      gcc_assert (vf.is_constant ());\n+      wide_int begin = wi::to_wide (step_expr);\n+\n+      for (unsigned i = 0; i != vf.to_constant () - 1; i++)\n+\tbegin = wi::mul (begin, wi::to_wide (step_expr));\n+\n+      new_name = wide_int_to_tree (TREE_TYPE (step_expr), begin);\n+    }\n+  else if (induction_type == vect_step_op_neg)\n+    /* Do nothing.  */\n+    ;\n+  else\n+    new_name = gimple_build (stmts, MULT_EXPR, TREE_TYPE (step_expr),\n+\t\t\t     expr, step_expr);\n+  return new_name;\n+}\n+\n+static tree\n+vect_create_nonlinear_iv_vec_step (loop_vec_info loop_vinfo,\n+\t\t\t\t   stmt_vec_info stmt_info,\n+\t\t\t\t   tree new_name, tree vectype,\n+\t\t\t\t   enum vect_induction_op_type induction_type)\n+{\n+  /* No step is needed for neg induction.  */\n+  if (induction_type == vect_step_op_neg)\n+    return NULL;\n+\n+  tree t = unshare_expr (new_name);\n+  gcc_assert (CONSTANT_CLASS_P (new_name)\n+\t      || TREE_CODE (new_name) == SSA_NAME);\n+  tree new_vec = build_vector_from_val (vectype, t);\n+  tree vec_step = vect_init_vector (loop_vinfo, stmt_info,\n+\t\t\t\t    new_vec, vectype, NULL);\n+  return vec_step;\n+}\n+\n+/* Update vectorized iv with vect_step, induc_def is init.  */\n+static tree\n+vect_update_nonlinear_iv (gimple_seq* stmts, tree vectype,\n+\t\t\t  tree induc_def, tree vec_step,\n+\t\t\t  enum vect_induction_op_type induction_type)\n+{\n+  tree vec_def = induc_def;\n+  switch (induction_type)\n+    {\n+    case vect_step_op_mul:\n+      {\n+\t/* Use unsigned mult to avoid UD integer overflow.  */\n+\ttree uvectype\n+\t  = build_vector_type (unsigned_type_for (TREE_TYPE (vectype)),\n+\t\t\t       TYPE_VECTOR_SUBPARTS (vectype));\n+\tvec_def = gimple_convert (stmts, uvectype, vec_def);\n+\tvec_step = gimple_convert (stmts, uvectype, vec_step);\n+\tvec_def = gimple_build (stmts, MULT_EXPR, uvectype,\n+\t\t\t\tvec_def, vec_step);\n+\tvec_def = gimple_convert (stmts, vectype, vec_def);\n+      }\n+      break;\n+\n+    case vect_step_op_shr:\n+      vec_def = gimple_build (stmts, RSHIFT_EXPR, vectype,\n+\t\t\t      vec_def, vec_step);\n+      break;\n+\n+    case vect_step_op_shl:\n+      vec_def = gimple_build (stmts, LSHIFT_EXPR, vectype,\n+\t\t\t      vec_def, vec_step);\n+      break;\n+    case vect_step_op_neg:\n+      vec_def = induc_def;\n+      /* Do nothing.  */\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return vec_def;\n+\n+}\n+/* Function vectorizable_induction\n+\n+   Check if STMT_INFO performs an nonlinear induction computation that can be\n+   vectorized. If VEC_STMT is also passed, vectorize the induction PHI: create\n+   a vectorized phi to replace it, put it in VEC_STMT, and add it to the same\n+   basic block.\n+   Return true if STMT_INFO is vectorizable in this way.  */\n+\n+static bool\n+vectorizable_nonlinear_induction (loop_vec_info loop_vinfo,\n+\t\t\t\t  stmt_vec_info stmt_info,\n+\t\t\t\t  gimple **vec_stmt, slp_tree slp_node,\n+\t\t\t\t  stmt_vector_for_cost *cost_vec)\n+{\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  unsigned ncopies;\n+  bool nested_in_vect_loop = false;\n+  class loop *iv_loop;\n+  tree vec_def;\n+  edge pe = loop_preheader_edge (loop);\n+  basic_block new_bb;\n+  tree vec_init, vec_step;\n+  tree new_name;\n+  gimple *new_stmt;\n+  gphi *induction_phi;\n+  tree induc_def, vec_dest;\n+  tree init_expr, step_expr;\n+  tree niters_skip;\n+  poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  unsigned i;\n+  gimple_stmt_iterator si;\n+\n+  gphi *phi = dyn_cast <gphi *> (stmt_info->stmt);\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  enum vect_induction_op_type induction_type\n+    = STMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (stmt_info);\n+\n+  gcc_assert (induction_type > vect_step_op_add);\n+\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = vect_get_num_copies (loop_vinfo, vectype);\n+  gcc_assert (ncopies >= 1);\n+\n+  /* FORNOW. Only handle nonlinear induction in the same loop.  */\n+  if (nested_in_vect_loop_p (loop, stmt_info))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"nonlinear induction in nested loop.\\n\");\n+      return false;\n+    }\n+\n+  iv_loop = loop;\n+  gcc_assert (iv_loop == (gimple_bb (phi))->loop_father);\n+\n+  /* TODO: Support slp for nonlinear iv. There should be separate vector iv\n+     update for each iv and a permutation to generate wanted vector iv.  */\n+  if (slp_node)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"SLP induction not supported for nonlinear\"\n+\t\t\t \" induction.\\n\");\n+      return false;\n+    }\n+\n+  /* Init_expr will be update by vect_update_ivs_after_vectorizer,\n+     if niters is unkown:\n+     For shift, when shift mount >= precision, there would be UD.\n+     For mult, don't known how to generate\n+     init_expr * pow (step, niters) for variable niters.\n+     For neg, it should be ok, since niters of vectorized main loop\n+     will always be multiple of 2.  */\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && induction_type != vect_step_op_neg)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Peeling for epilogue is not supported\"\n+\t\t\t \" for nonlinear induction except neg\"\n+\t\t\t \" when iteration count is unknown.\\n\");\n+      return false;\n+    }\n+\n+  /* Also doens't support peel for neg when niter is variable.\n+     ??? generate something like niter_expr & 1 ? init_expr : -init_expr?  */\n+  niters_skip = LOOP_VINFO_MASK_SKIP_NITERS (loop_vinfo);\n+  if (niters_skip != NULL_TREE\n+      && TREE_CODE (niters_skip) != INTEGER_CST)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Peeling for alignement is not supported\"\n+\t\t\t \" for nonlinear induction when niters_skip\"\n+\t\t\t \" is not constant.\\n\");\n+      return false;\n+    }\n+\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && induction_type == vect_step_op_mul)\n+  if (!INTEGRAL_TYPE_P (TREE_TYPE (vectype)))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"floating point nonlinear induction vectorization\"\n+\t\t\t \" not supported.\\n\");\n+      return false;\n+    }\n+\n+  step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_info);\n+  init_expr = vect_phi_initial_value (phi);\n+  gcc_assert (step_expr != NULL_TREE && init_expr != NULL\n+\t      && TREE_CODE (step_expr) == INTEGER_CST);\n+  /* step_expr should be aligned with init_expr,\n+     .i.e. uint64 a >> 1, step is int, but vector<uint64> shift is used.  */\n+  step_expr = fold_convert (TREE_TYPE (vectype), step_expr);\n+\n+  if (TREE_CODE (init_expr) == INTEGER_CST)\n+    init_expr = fold_convert (TREE_TYPE (vectype), init_expr);\n+  else\n+    gcc_assert (tree_nop_conversion_p (TREE_TYPE (vectype),\n+\t\t\t\t       TREE_TYPE (init_expr)));\n+\n+  switch (induction_type)\n+    {\n+    case vect_step_op_neg:\n+      if (TREE_CODE (init_expr) != INTEGER_CST\n+\t  && TREE_CODE (init_expr) != REAL_CST)\n+\t{\n+\t  /* Check for backend support of NEGATE_EXPR and vec_perm.  */\n+\t  if (!directly_supported_p (NEGATE_EXPR, vectype))\n+\t    return false;\n+\n+\t  /* The encoding has 2 interleaved stepped patterns.  */\n+\t  vec_perm_builder sel (nunits, 2, 3);\n+\t  machine_mode mode = TYPE_MODE (vectype);\n+\t  sel.quick_grow (6);\n+\t  for (i = 0; i < 3; i++)\n+\t    {\n+\t      sel[i * 2] = i;\n+\t      sel[i * 2 + 1] = i + nunits;\n+\t    }\n+\t  vec_perm_indices indices (sel, 2, nunits);\n+\t  if (!can_vec_perm_const_p (mode, mode, indices))\n+\t    return false;\n+\t}\n+      break;\n+\n+    case vect_step_op_mul:\n+      {\n+\t/* Check for backend support of MULT_EXPR.  */\n+\tif (!directly_supported_p (MULT_EXPR, vectype))\n+\t  return false;\n+\n+\t/* ?? How to construct vector step for variable number vector.\n+\t   [ 1, step, pow (step, 2), pow (step, 4), .. ].  */\n+\tif (!vf.is_constant ())\n+\t  return false;\n+      }\n+      break;\n+\n+    case vect_step_op_shr:\n+      /* Check for backend support of RSHIFT_EXPR.  */\n+      if (!directly_supported_p (RSHIFT_EXPR, vectype, optab_vector))\n+\treturn false;\n+\n+      /* Don't shift more than type precision to avoid UD.  */\n+      if (!tree_fits_uhwi_p (step_expr)\n+\t  || maybe_ge (nunits * tree_to_uhwi (step_expr),\n+\t\t       TYPE_PRECISION (TREE_TYPE (init_expr))))\n+\treturn false;\n+      break;\n+\n+    case vect_step_op_shl:\n+      /* Check for backend support of RSHIFT_EXPR.  */\n+      if (!directly_supported_p (LSHIFT_EXPR, vectype, optab_vector))\n+\treturn false;\n+\n+      /* Don't shift more than type precision to avoid UD.  */\n+      if (!tree_fits_uhwi_p (step_expr)\n+\t  || maybe_ge (nunits * tree_to_uhwi (step_expr),\n+\t\t       TYPE_PRECISION (TREE_TYPE (init_expr))))\n+\treturn false;\n+\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      unsigned inside_cost = 0, prologue_cost = 0;\n+      /* loop cost for vec_loop. Neg induction doesn't have any\n+\t inside_cost.  */\n+      inside_cost = record_stmt_cost (cost_vec, ncopies, vector_stmt,\n+\t\t\t\t      stmt_info, 0, vect_body);\n+\n+      /* loop cost for vec_loop. Neg induction doesn't have any\n+\t inside_cost.  */\n+      if (induction_type == vect_step_op_neg)\n+\tinside_cost = 0;\n+\n+      /* prologue cost for vec_init and vec_step.  */\n+      prologue_cost = record_stmt_cost (cost_vec, 2, scalar_to_vec,\n+\t\t\t\t\tstmt_info, 0, vect_prologue);\n+\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"vect_model_induction_cost: inside_cost = %d, \"\n+\t\t\t \"prologue_cost = %d. \\n\", inside_cost,\n+\t\t\t prologue_cost);\n+\n+      STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n+      DUMP_VECT_SCOPE (\"vectorizable_nonlinear_induction\");\n+      return true;\n+    }\n+\n+  /* Transform.  */\n+\n+  /* Compute a vector variable, initialized with the first VF values of\n+     the induction variable.  E.g., for an iv with IV_PHI='X' and\n+     evolution S, for a vector of 4 units, we want to compute:\n+     [X, X + S, X + 2*S, X + 3*S].  */\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform induction phi.\\n\");\n+\n+  pe = loop_preheader_edge (iv_loop);\n+  /* Find the first insertion point in the BB.  */\n+  basic_block bb = gimple_bb (phi);\n+  si = gsi_after_labels (bb);\n+\n+  gimple_seq stmts = NULL;\n+\n+  /* If we are using the loop mask to \"peel\" for alignment then we need\n+     to adjust the start value here.  */\n+  if (niters_skip != NULL_TREE)\n+    init_expr = vect_peel_nonlinear_iv_init (&stmts, init_expr, niters_skip,\n+\t\t\t\t\t     step_expr, induction_type);\n+\n+  vec_init = vect_create_nonlinear_iv_init (&stmts, init_expr,\n+\t\t\t\t\t    step_expr, nunits, vectype,\n+\t\t\t\t\t    induction_type);\n+  if (stmts)\n+    {\n+      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+      gcc_assert (!new_bb);\n+    }\n+\n+  stmts = NULL;\n+  new_name = vect_create_nonlinear_iv_step (&stmts, step_expr,\n+\t\t\t\t\t    vf, induction_type);\n+  if (stmts)\n+    {\n+      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+      gcc_assert (!new_bb);\n+    }\n+\n+  vec_step = vect_create_nonlinear_iv_vec_step (loop_vinfo, stmt_info,\n+\t\t\t\t\t\tnew_name, vectype,\n+\t\t\t\t\t\tinduction_type);\n+  /* Create the following def-use cycle:\n+     loop prolog:\n+     vec_init = ...\n+     vec_step = ...\n+     loop:\n+     vec_iv = PHI <vec_init, vec_loop>\n+     ...\n+     STMT\n+     ...\n+     vec_loop = vec_iv + vec_step;  */\n+\n+  /* Create the induction-phi that defines the induction-operand.  */\n+  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n+  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n+  induc_def = PHI_RESULT (induction_phi);\n+\n+  /* Create the iv update inside the loop.  */\n+  stmts = NULL;\n+  vec_def = vect_update_nonlinear_iv (&stmts, vectype,\n+\t\t\t\t      induc_def, vec_step,\n+\t\t\t\t      induction_type);\n+\n+  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n+  new_stmt = SSA_NAME_DEF_STMT (vec_def);\n+\n+  /* Set the arguments of the phi node:  */\n+  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n+  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n+\t       UNKNOWN_LOCATION);\n+\n+  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (induction_phi);\n+  *vec_stmt = induction_phi;\n+\n+  /* In case that vectorization factor (VF) is bigger than the number\n+     of elements that we can fit in a vectype (nunits), we have to generate\n+     more than one vector stmt - i.e - we need to \"unroll\" the\n+     vector stmt by a factor VF/nunits.  For more details see documentation\n+     in vectorizable_operation.  */\n+\n+  if (ncopies > 1)\n+    {\n+      stmts = NULL;\n+      /* FORNOW. This restriction should be relaxed.  */\n+      gcc_assert (!nested_in_vect_loop);\n+\n+      new_name = vect_create_nonlinear_iv_step (&stmts, step_expr,\n+\t\t\t\t\t\tnunits, induction_type);\n+\n+      vec_step = vect_create_nonlinear_iv_vec_step (loop_vinfo, stmt_info,\n+\t\t\t\t\t\t    new_name, vectype,\n+\t\t\t\t\t\t    induction_type);\n+      vec_def = induc_def;\n+      for (i = 1; i < ncopies; i++)\n+\t{\n+\t  /* vec_i = vec_prev + vec_step.  */\n+\t  stmts = NULL;\n+\t  vec_def = vect_update_nonlinear_iv (&stmts, vectype,\n+\t\t\t\t\t      vec_def, vec_step,\n+\t\t\t\t\t      induction_type);\n+\t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n+\t  new_stmt = SSA_NAME_DEF_STMT (vec_def);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n+\t}\n+    }\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"transform induction: created def-use cycle: %G%G\",\n+\t\t     (gimple *) induction_phi, SSA_NAME_DEF_STMT (vec_def));\n+\n+  return true;\n+}\n+\n /* Function vectorizable_induction\n \n    Check if STMT_INFO performs an induction computation that can be vectorized.\n@@ -8263,6 +8924,8 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n   unsigned i;\n   tree expr;\n   gimple_stmt_iterator si;\n+  enum vect_induction_op_type induction_type\n+    = STMT_VINFO_LOOP_PHI_EVOLUTION_TYPE (stmt_info);\n \n   gphi *phi = dyn_cast <gphi *> (stmt_info->stmt);\n   if (!phi)\n@@ -8275,6 +8938,11 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n     return false;\n \n+  /* Handle nonlinear induction in a separate place.  */\n+  if (induction_type != vect_step_op_add)\n+    return vectorizable_nonlinear_induction (loop_vinfo, stmt_info,\n+\t\t\t\t\t     vec_stmt, slp_node, cost_vec);\n+\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n "}, {"sha": "5e75ed1532b3143426faf41afde986bcb259e830", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13223b790bbc5e4a3f5605e057eac59b61b2c85/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c13223b790bbc5e4a3f5605e057eac59b61b2c85", "patch": "@@ -68,6 +68,15 @@ enum vect_def_type {\n   vect_unknown_def_type\n };\n \n+/* Define operation type of linear/non-linear induction variable.  */\n+enum vect_induction_op_type {\n+   vect_step_op_add = 0,\n+   vect_step_op_neg,\n+   vect_step_op_mul,\n+   vect_step_op_shl,\n+   vect_step_op_shr\n+};\n+\n /* Define type of reduction.  */\n enum vect_reduction_type {\n   TREE_CODE_REDUCTION,\n@@ -1190,6 +1199,7 @@ class _stmt_vec_info {\n      the version here.  */\n   tree loop_phi_evolution_base_unchanged;\n   tree loop_phi_evolution_part;\n+  enum vect_induction_op_type loop_phi_evolution_type;\n \n   /* Used for various bookkeeping purposes, generally holding a pointer to\n      some other stmt S that is in some way \"related\" to this stmt.\n@@ -1423,6 +1433,7 @@ struct gather_scatter_info {\n   ((S)->dr_aux.dr && DR_GROUP_FIRST_ELEMENT(S))\n #define STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED(S) (S)->loop_phi_evolution_base_unchanged\n #define STMT_VINFO_LOOP_PHI_EVOLUTION_PART(S) (S)->loop_phi_evolution_part\n+#define STMT_VINFO_LOOP_PHI_EVOLUTION_TYPE(S) (S)->loop_phi_evolution_type\n #define STMT_VINFO_MIN_NEG_DIST(S)\t(S)->min_neg_dist\n #define STMT_VINFO_REDUC_TYPE(S)\t(S)->reduc_type\n #define STMT_VINFO_REDUC_CODE(S)\t(S)->reduc_code\n@@ -2329,6 +2340,10 @@ extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *);\n extern tree cse_and_gimplify_to_preheader (loop_vec_info, tree);\n \n+/* Nonlinear induction.  */\n+extern tree vect_peel_nonlinear_iv_init (gimple_seq*, tree, tree,\n+\t\t\t\t\t tree, enum vect_induction_op_type);\n+\n /* In tree-vect-slp.cc.  */\n extern void vect_slp_init (void);\n extern void vect_slp_fini (void);"}]}