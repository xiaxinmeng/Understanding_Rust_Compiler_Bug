{"sha": "7e4dc511b073113b428eaa0bd9d7cc4c2c589329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0ZGM1MTFiMDczMTEzYjQyOGVhYTBiZDlkN2NjNGMyYzU4OTMyOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T17:36:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T17:36:40Z"}, "message": "(simplify_comparison): Narrow comparison for AND's that are ZERO_EXTENDs.\n\nCan widen for all comparisons if inputs are both sign extended.\n\nFrom-SVN: r7363", "tree": {"sha": "6ac6fe9f1707286dccb93143ef897fc2d4472c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ac6fe9f1707286dccb93143ef897fc2d4472c7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e4dc511b073113b428eaa0bd9d7cc4c2c589329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4dc511b073113b428eaa0bd9d7cc4c2c589329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4dc511b073113b428eaa0bd9d7cc4c2c589329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4dc511b073113b428eaa0bd9d7cc4c2c589329/comments", "author": null, "committer": null, "parents": [{"sha": "5f40cc2da4ba2f44be72bd35a03c3270061472e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f40cc2da4ba2f44be72bd35a03c3270061472e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f40cc2da4ba2f44be72bd35a03c3270061472e9"}], "stats": {"total": 76, "additions": 50, "deletions": 26}, "files": [{"sha": "cec950b41fdd6bee4eeef3508c7458b6de420cd9", "filename": "gcc/combine.c", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4dc511b073113b428eaa0bd9d7cc4c2c589329/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4dc511b073113b428eaa0bd9d7cc4c2c589329/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7e4dc511b073113b428eaa0bd9d7cc4c2c589329", "patch": "@@ -8590,32 +8590,58 @@ simplify_comparison (code, pop0, pop1)\n \t and the operand's possibly nonzero bits are 0xffffff01; in that case\n \t if we only care about QImode, we don't need the AND).  This case\n \t occurs if the output mode of an scc insn is not SImode and\n-\t STORE_FLAG_VALUE == 1 (e.g., the 386).  */\n+\t STORE_FLAG_VALUE == 1 (e.g., the 386).\n+\n+\t Similarly, check for a case where the AND's are ZERO_EXTEND\n+\t operations from some narrower mode even though a SUBREG is not\n+\t present.  */\n \n       else if  (GET_CODE (op0) == AND && GET_CODE (op1) == AND\n \t\t&& GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t\t&& GET_CODE (XEXP (op1, 1)) == CONST_INT\n-\t\t&& GET_CODE (XEXP (op0, 0)) == SUBREG\n-\t\t&& GET_CODE (XEXP (op1, 0)) == SUBREG\n-\t\t&& (GET_MODE_SIZE (GET_MODE (XEXP (op0, 0)))\n-\t\t    > GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0)))))\n-\t\t&& (GET_MODE (SUBREG_REG (XEXP (op0, 0)))\n-\t\t    == GET_MODE (SUBREG_REG (XEXP (op1, 0))))\n-\t\t&& (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n-\t\t    <= HOST_BITS_PER_WIDE_INT)\n-\t\t&& (nonzero_bits (SUBREG_REG (XEXP (op0, 0)),\n-\t\t\t\t      GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n-\t\t    & ~ INTVAL (XEXP (op0, 1))) == 0\n-\t\t&& (nonzero_bits (SUBREG_REG (XEXP (op1, 0)),\n-\t\t\t\t      GET_MODE (SUBREG_REG (XEXP (op1, 0))))\n-\t\t    & ~ INTVAL (XEXP (op1, 1))) == 0)\n+\t\t&& GET_CODE (XEXP (op1, 1)) == CONST_INT)\n \t{\n-\t  op0 = SUBREG_REG (XEXP (op0, 0));\n-\t  op1 = SUBREG_REG (XEXP (op1, 0));\n+\t  rtx inner_op0 = XEXP (op0, 0);\n+\t  rtx inner_op1 = XEXP (op1, 0);\n+\t  HOST_WIDE_INT c0 = INTVAL (XEXP (op0, 1));\n+\t  HOST_WIDE_INT c1 = INTVAL (XEXP (op1, 1));\n+\t  int changed = 0;\n+\t\t\n+\t  if (GET_CODE (inner_op0) == SUBREG && GET_CODE (inner_op1) == SUBREG\n+\t      && (GET_MODE_SIZE (GET_MODE (inner_op0))\n+\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (inner_op0))))\n+\t      && (GET_MODE (SUBREG_REG (inner_op0))\n+\t\t  == GET_MODE (SUBREG_REG (inner_op1)))\n+\t      && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n+\t\t  <= HOST_BITS_PER_WIDE_INT)\n+\t      && (0 == (~c0) & nonzero_bits (SUBREG_REG (inner_op0),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (op0))))\n+\t      && (0 == (~c1) & nonzero_bits (SUBREG_REG (inner_op1),\n+\t\t\t\t\t     GET_MODE (SUBREG_REG (inner_op1)))))\n+\t    {\n+\t      op0 = SUBREG_REG (inner_op0);\n+\t      op1 = SUBREG_REG (inner_op1);\n+\n+\t      /* The resulting comparison is always unsigned since we masked\n+\t\t off the original sign bit. */\n+\t      code = unsigned_condition (code);\n+\n+\t      changed = 1;\n+\t    }\n \n-\t  /* the resulting comparison is always unsigned since we masked off\n-\t     the original sign bit. */\n-\t  code = unsigned_condition (code);\n+\t  else if (c0 == c1)\n+\t    for (tmode = GET_CLASS_NARROWEST_MODE\n+\t\t (GET_MODE_CLASS (GET_MODE (op0)));\n+\t\t tmode != GET_MODE (op0); tmode = GET_MODE_WIDER_MODE (tmode))\n+\t      if (c0 == GET_MODE_MASK (tmode))\n+\t\t{\n+\t\t  op0 = gen_lowpart_for_combine (tmode, inner_op0);\n+\t\t  op1 = gen_lowpart_for_combine (tmode, inner_op1);\n+\t\t  changed = 1;\n+\t\t  break;\n+\t\t}\n+\n+\t  if (! changed)\n+\t    break;\n \t}\n \n       /* If both operands are NOT, we can strip off the outer operation\n@@ -9417,15 +9443,13 @@ simplify_comparison (code, pop0, pop1)\n \t  /* If the only nonzero bits in OP0 and OP1 are those in the\n \t     narrower mode and this is an equality or unsigned comparison,\n \t     we can use the wider mode.  Similarly for sign-extended\n-\t     values and equality or signed comparisons.  */\n+\t     values, in which case it is true for all comparisons.  */\n \t  if (((code == EQ || code == NE\n \t\t|| code == GEU || code == GTU || code == LEU || code == LTU)\n \t       && (nonzero_bits (op0, tmode) & ~ GET_MODE_MASK (mode)) == 0\n \t       && (nonzero_bits (op1, tmode) & ~ GET_MODE_MASK (mode)) == 0)\n-\t      || ((code == EQ || code == NE\n-\t\t   || code == GE || code == GT || code == LE || code == LT)\n-\t\t  && (num_sign_bit_copies (op0, tmode)\n-\t\t      > GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))\n+\t      || ((num_sign_bit_copies (op0, tmode)\n+\t\t   > GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))\n \t\t  && (num_sign_bit_copies (op1, tmode)\n \t\t      > GET_MODE_BITSIZE (tmode) - GET_MODE_BITSIZE (mode))))\n \t    {"}]}