{"sha": "be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxNzhlY2Q1YWMxZmUxNTEwZDk2MGZmOTVjNjZkMGZmODMxYWZlMQ==", "commit": {"author": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-07-09T08:11:59Z"}, "committer": {"name": "Matthew Malcomson", "email": "matthew.malcomson@arm.com", "date": "2020-07-09T08:18:16Z"}, "message": "aarch64: Introduce SLS mitigation for RET and BR instructions\n\nInstructions following RET or BR are not necessarily executed.  In order\nto avoid speculation past RET and BR we can simply append a speculation\nbarrier.\n\nSince these speculation barriers will not be architecturally executed,\nthey are not expected to add a high performance penalty.\n\nThe speculation barrier is to be SB when targeting architectures which\nhave this enabled, and DSB SY + ISB otherwise.\n\nWe add tests for each of the cases where such an instruction was seen.\n\nThis is implemented by modifying each machine description pattern that\nemits either a RET or a BR instruction.  We choose not to use something\nlike `TARGET_ASM_FUNCTION_EPILOGUE` since it does not affect the\n`indirect_jump`, `jump`, `sibcall_insn` and `sibcall_value_insn`\npatterns and we find it preferable to implement the functionality in the\nsame way for every pattern.\n\nThere is one particular case which is slightly tricky.  The\nimplementation of TARGET_ASM_TRAMPOLINE_TEMPLATE uses a BR which needs\nto be mitigated against.  The trampoline template is used *once* per\ncompilation unit, and the TRAMPOLINE_SIZE is exposed to the user via the\nbuiltin macro __LIBGCC_TRAMPOLINE_SIZE__.\nIn the future we may implement function specific attributes to turn on\nand off hardening on a per-function basis.\nThe fixed nature of the trampoline described above implies it will be\nsafer to ensure this speculation barrier is always used.\n\nTesting:\n  Bootstrap and regtest done on aarch64-none-linux\n  Used a temporary hack(1) to use these options on every test in the\n  testsuite and a script to check that the output never emitted an\n  unmitigated RET or BR.\n\n1) Temporary hack was a change to the testsuite to always use\n`-save-temps` and run a script on the assembly output of those\ncompilations which produced one to ensure every RET or BR is immediately\nfollowed by a speculation barrier.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-protos.h (aarch64_sls_barrier): New.\n\t* config/aarch64/aarch64.c (aarch64_output_casesi): Emit\n\tspeculation barrier after BR instruction if needs be.\n\t(aarch64_trampoline_init): Handle ptr_mode value & adjust size\n\tof code copied.\n\t(aarch64_sls_barrier): New.\n\t(aarch64_asm_trampoline_template): Add needed barriers.\n\t* config/aarch64/aarch64.h (AARCH64_ISA_SB): New.\n\t(TARGET_SB): New.\n\t(TRAMPOLINE_SIZE): Account for barrier.\n\t* config/aarch64/aarch64.md (indirect_jump, *casesi_dispatch,\n\tsimple_return, *do_return, *sibcall_insn, *sibcall_value_insn):\n\tEmit barrier if needs be, also account for possible barrier using\n\t\"sls_length\" attribute.\n\t(sls_length): New attribute.\n\t(length): Determine default using any non-default sls_length\n\tvalue.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/sls-mitigation/sls-miti-retbr.c: New test.\n\t* gcc.target/aarch64/sls-mitigation/sls-miti-retbr-pacret.c:\n\tNew test.\n\t* gcc.target/aarch64/sls-mitigation/sls-mitigation.exp: New file.\n\t* lib/target-supports.exp (check_effective_target_aarch64_asm_sb_ok):\n\tNew proc.", "tree": {"sha": "26d74bec899719f0f9a699cf0b9d708e336a67c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26d74bec899719f0f9a699cf0b9d708e336a67c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/comments", "author": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmalcomson", "id": 57484298, "node_id": "MDQ6VXNlcjU3NDg0Mjk4", "avatar_url": "https://avatars.githubusercontent.com/u/57484298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmalcomson", "html_url": "https://github.com/mmalcomson", "followers_url": "https://api.github.com/users/mmalcomson/followers", "following_url": "https://api.github.com/users/mmalcomson/following{/other_user}", "gists_url": "https://api.github.com/users/mmalcomson/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmalcomson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmalcomson/subscriptions", "organizations_url": "https://api.github.com/users/mmalcomson/orgs", "repos_url": "https://api.github.com/users/mmalcomson/repos", "events_url": "https://api.github.com/users/mmalcomson/events{/privacy}", "received_events_url": "https://api.github.com/users/mmalcomson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ba2a9b77bec7eacaf066801f22d1c366a2bc86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9ba2a9b77bec7eacaf066801f22d1c366a2bc86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9ba2a9b77bec7eacaf066801f22d1c366a2bc86"}], "stats": {"total": 347, "additions": 320, "deletions": 27}, "files": [{"sha": "b035e4ec78e2ef1c9a931148dffacf6a50345b84", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -780,6 +780,7 @@ extern const atomic_ool_names aarch64_ool_ldeor_names;\n \n tree aarch64_resolve_overloaded_builtin_general (location_t, tree, void *);\n \n+const char *aarch64_sls_barrier (int);\n extern bool aarch64_harden_sls_retbr_p (void);\n extern bool aarch64_harden_sls_blr_p (void);\n "}, {"sha": "863d18849ade59dc725025e6a237faa37356f936", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -10843,16 +10843,27 @@ aarch64_asm_trampoline_template (FILE *f)\n \n   if (TARGET_ILP32)\n     {\n-      asm_fprintf (f, \"\\tldr\\tw%d, .+12\\n\", IP1_REGNUM - R0_REGNUM);\n-      asm_fprintf (f, \"\\tldr\\tw%d, .+12\\n\", STATIC_CHAIN_REGNUM - R0_REGNUM);\n+      asm_fprintf (f, \"\\tldr\\tw%d, .+20\\n\", IP1_REGNUM - R0_REGNUM);\n+      asm_fprintf (f, \"\\tldr\\tw%d, .+20\\n\", STATIC_CHAIN_REGNUM - R0_REGNUM);\n     }\n   else\n     {\n-      asm_fprintf (f, \"\\tldr\\t%s, .+12\\n\", reg_names [IP1_REGNUM]);\n-      asm_fprintf (f, \"\\tldr\\t%s, .+16\\n\", reg_names [STATIC_CHAIN_REGNUM]);\n+      asm_fprintf (f, \"\\tldr\\t%s, .+20\\n\", reg_names [IP1_REGNUM]);\n+      asm_fprintf (f, \"\\tldr\\t%s, .+24\\n\", reg_names [STATIC_CHAIN_REGNUM]);\n     }\n   asm_fprintf (f, \"\\tbr\\t%s\\n\", reg_names [IP1_REGNUM]);\n \n+  /* We always emit a speculation barrier.\n+     This is because the same trampoline template is used for every nested\n+     function.  Since nested functions are not particularly common or\n+     performant we don't worry too much about the extra instructions to copy\n+     around.\n+     This is not yet a problem, since we have not yet implemented function\n+     specific attributes to choose between hardening against straight line\n+     speculation or not, but such function specific attributes are likely to\n+     happen in the future.  */\n+  asm_fprintf (f, \"\\tdsb\\tsy\\n\\tisb\\n\");\n+\n   assemble_aligned_integer (POINTER_BYTES, const0_rtx);\n   assemble_aligned_integer (POINTER_BYTES, const0_rtx);\n }\n@@ -10861,10 +10872,14 @@ static void\n aarch64_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n   rtx fnaddr, mem, a_tramp;\n-  const int tramp_code_sz = 16;\n+  const int tramp_code_sz = 24;\n \n   /* Don't need to copy the trailing D-words, we fill those in below.  */\n-  emit_block_move (m_tramp, assemble_trampoline_template (),\n+  /* We create our own memory address in Pmode so that `emit_block_move` can\n+     use parts of the backend which expect Pmode addresses.  */\n+  rtx temp = convert_memory_address (Pmode, XEXP (m_tramp, 0));\n+  emit_block_move (gen_rtx_MEM (BLKmode, temp),\n+\t\t   assemble_trampoline_template (),\n \t\t   GEN_INT (tramp_code_sz), BLOCK_OP_NORMAL);\n   mem = adjust_address (m_tramp, ptr_mode, tramp_code_sz);\n   fnaddr = XEXP (DECL_RTL (fndecl), 0);\n@@ -11055,6 +11070,8 @@ aarch64_output_casesi (rtx *operands)\n   output_asm_insn (buf, operands);\n   output_asm_insn (patterns[index][1], operands);\n   output_asm_insn (\"br\\t%3\", operands);\n+  output_asm_insn (aarch64_sls_barrier (aarch64_harden_sls_retbr_p ()),\n+\t\t   operands);\n   assemble_label (asm_out_file, label);\n   return \"\";\n }\n@@ -22931,6 +22948,22 @@ aarch64_file_end_indicate_exec_stack ()\n #undef GNU_PROPERTY_AARCH64_FEATURE_1_BTI\n #undef GNU_PROPERTY_AARCH64_FEATURE_1_AND\n \n+/* Helper function for straight line speculation.\n+   Return what barrier should be emitted for straight line speculation\n+   mitigation.\n+   When not mitigating against straight line speculation this function returns\n+   an empty string.\n+   When mitigating against straight line speculation, use:\n+   * SB when the v8.5-A SB extension is enabled.\n+   * DSB+ISB otherwise.  */\n+const char *\n+aarch64_sls_barrier (int mitigation_required)\n+{\n+  return mitigation_required\n+    ? (TARGET_SB ? \"sb\" : \"dsb\\tsy\\n\\tisb\")\n+    : \"\";\n+}\n+\n /* Target-specific selftests.  */\n \n #if CHECKING_P"}, {"sha": "7bb0f147eb81a271319b3134fdd18db7a6fa52bf", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -281,6 +281,7 @@ extern unsigned aarch64_architecture_version;\n #define AARCH64_ISA_F32MM\t   (aarch64_isa_flags & AARCH64_FL_F32MM)\n #define AARCH64_ISA_F64MM\t   (aarch64_isa_flags & AARCH64_FL_F64MM)\n #define AARCH64_ISA_BF16\t   (aarch64_isa_flags & AARCH64_FL_BF16)\n+#define AARCH64_ISA_SB\t\t   (aarch64_isa_flags & AARCH64_FL_SB)\n \n /* Crypto is an optional extension to AdvSIMD.  */\n #define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)\n@@ -378,6 +379,9 @@ extern unsigned aarch64_architecture_version;\n #define TARGET_FIX_ERR_A53_835769_DEFAULT 1\n #endif\n \n+/* SB instruction is enabled through +sb.  */\n+#define TARGET_SB (AARCH64_ISA_SB)\n+\n /* Apply the workaround for Cortex-A53 erratum 835769.  */\n #define TARGET_FIX_ERR_A53_835769\t\\\n   ((aarch64_fix_a53_err835769 == 2)\t\\\n@@ -1075,8 +1079,10 @@ typedef struct\n \n #define RETURN_ADDR_RTX aarch64_return_addr\n \n-/* BTI c + 3 insns + 2 pointer-sized entries.  */\n-#define TRAMPOLINE_SIZE\t(TARGET_ILP32 ? 24 : 32)\n+/* BTI c + 3 insns\n+   + sls barrier of DSB + ISB.\n+   + 2 pointer-sized entries.  */\n+#define TRAMPOLINE_SIZE\t(24 + (TARGET_ILP32 ? 8 : 16))\n \n /* Trampolines contain dwords, so must be dword aligned.  */\n #define TRAMPOLINE_ALIGNMENT 64"}, {"sha": "3c363337926ad5fcfd05abf6b7551a991ca9664e", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -407,10 +407,25 @@\n ;; Attribute that specifies whether the alternative uses MOVPRFX.\n (define_attr \"movprfx\" \"no,yes\" (const_string \"no\"))\n \n+;; Attribute to specify that an alternative has the length of a single\n+;; instruction plus a speculation barrier.\n+(define_attr \"sls_length\" \"none,retbr,casesi\" (const_string \"none\"))\n+\n (define_attr \"length\" \"\"\n   (cond [(eq_attr \"movprfx\" \"yes\")\n            (const_int 8)\n-        ] (const_int 4)))\n+\n+\t (eq_attr \"sls_length\" \"retbr\")\n+\t   (cond [(match_test \"!aarch64_harden_sls_retbr_p ()\") (const_int 4)\n+\t\t  (match_test \"TARGET_SB\") (const_int 8)]\n+\t\t (const_int 12))\n+\n+\t (eq_attr \"sls_length\" \"casesi\")\n+\t   (cond [(match_test \"!aarch64_harden_sls_retbr_p ()\") (const_int 16)\n+\t\t  (match_test \"TARGET_SB\") (const_int 20)]\n+\t\t (const_int 24))\n+\t]\n+\t  (const_int 4)))\n \n ;; Strictly for compatibility with AArch32 in pipeline models, since AArch64 has\n ;; no predicated insns.\n@@ -447,8 +462,12 @@\n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:DI 0 \"register_operand\" \"r\"))]\n   \"\"\n-  \"br\\\\t%0\"\n-  [(set_attr \"type\" \"branch\")]\n+  {\n+    output_asm_insn (\"br\\\\t%0\", operands);\n+    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());\n+  }\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"sls_length\" \"retbr\")]\n )\n \n (define_insn \"jump\"\n@@ -765,7 +784,7 @@\n   \"*\n   return aarch64_output_casesi (operands);\n   \"\n-  [(set_attr \"length\" \"16\")\n+  [(set_attr \"sls_length\" \"casesi\")\n    (set_attr \"type\" \"branch\")]\n )\n \n@@ -844,18 +863,23 @@\n   [(return)]\n   \"\"\n   {\n+    const char *ret = NULL;\n     if (aarch64_return_address_signing_enabled ()\n \t&& TARGET_ARMV8_3\n \t&& !crtl->calls_eh_return)\n       {\n \tif (aarch64_ra_sign_key == AARCH64_KEY_B)\n-\t  return \"retab\";\n+\t  ret = \"retab\";\n \telse\n-\t  return \"retaa\";\n+\t  ret = \"retaa\";\n       }\n-    return \"ret\";\n+    else\n+      ret = \"ret\";\n+    output_asm_insn (ret, operands);\n+    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());\n   }\n-  [(set_attr \"type\" \"branch\")]\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"sls_length\" \"retbr\")]\n )\n \n (define_expand \"return\"\n@@ -867,8 +891,12 @@\n (define_insn \"simple_return\"\n   [(simple_return)]\n   \"\"\n-  \"ret\"\n-  [(set_attr \"type\" \"branch\")]\n+  {\n+    output_asm_insn (\"ret\", operands);\n+    return aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());\n+  }\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"sls_length\" \"retbr\")]\n )\n \n (define_insn \"*cb<optab><mode>1\"\n@@ -1066,10 +1094,16 @@\n    (unspec:DI [(match_operand:DI 2 \"const_int_operand\")] UNSPEC_CALLEE_ABI)\n    (return)]\n   \"SIBLING_CALL_P (insn)\"\n-  \"@\n-   br\\\\t%0\n-   b\\\\t%c0\"\n-  [(set_attr \"type\" \"branch, branch\")]\n+  {\n+    if (which_alternative == 0)\n+      {\n+\toutput_asm_insn (\"br\\\\t%0\", operands);\n+\treturn aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());\n+      }\n+    return \"b\\\\t%c0\";\n+  }\n+  [(set_attr \"type\" \"branch, branch\")\n+   (set_attr \"sls_length\" \"retbr,none\")]\n )\n \n (define_insn \"*sibcall_value_insn\"\n@@ -1080,10 +1114,16 @@\n    (unspec:DI [(match_operand:DI 3 \"const_int_operand\")] UNSPEC_CALLEE_ABI)\n    (return)]\n   \"SIBLING_CALL_P (insn)\"\n-  \"@\n-   br\\\\t%1\n-   b\\\\t%c1\"\n-  [(set_attr \"type\" \"branch, branch\")]\n+  {\n+    if (which_alternative == 0)\n+      {\n+\toutput_asm_insn (\"br\\\\t%1\", operands);\n+\treturn aarch64_sls_barrier (aarch64_harden_sls_retbr_p ());\n+      }\n+    return \"b\\\\t%c1\";\n+  }\n+  [(set_attr \"type\" \"branch, branch\")\n+   (set_attr \"sls_length\" \"retbr,none\")]\n )\n \n ;; Call subroutine returning any type."}, {"sha": "fa1887a71e75d11be6cfff8bb5a7f4d89627d01f", "filename": "gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr-pacret.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-retbr-pacret.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-retbr-pacret.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-retbr-pacret.c?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -0,0 +1,21 @@\n+/* Avoid ILP32 since pacret is only available for LP64 */\n+/* { dg-do compile { target { ! ilp32 } } } */\n+/* { dg-additional-options \"-mharden-sls=retbr -mbranch-protection=pac-ret -march=armv8.3-a\" } */\n+\n+/* Testing the do_return pattern for retaa and retab.  */\n+long retbr_subcall(void);\n+long retbr_do_return_retaa(void)\n+{\n+    return retbr_subcall()+1;\n+}\n+\n+__attribute__((target(\"branch-protection=pac-ret+b-key\")))\n+long retbr_do_return_retab(void)\n+{\n+    return retbr_subcall()+1;\n+}\n+\n+/* Ensure there are no BR or RET instructions which are not directly followed\n+   by a speculation barrier.  */\n+/* { dg-final { scan-assembler-not {\\t(br|ret|retaa|retab)\\tx[0-9][0-9]?\\n\\t(?!dsb\\tsy\\n\\tisb)} } } */\n+/* { dg-final { scan-assembler-not {ret\\t} } } */"}, {"sha": "76b8d03afe499227c359245251dbebc0ab453c7d", "filename": "gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-miti-retbr.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-retbr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-retbr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-miti-retbr.c?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -0,0 +1,119 @@\n+/* We ensure that -Wpedantic is off since it complains about the trampolines\n+   we explicitly want to test.  */\n+/* { dg-additional-options \"-mharden-sls=retbr -Wno-pedantic \" } */\n+/*\n+   Ensure that the SLS hardening of RET and BR leaves no unprotected RET/BR\n+   instructions.\n+  */\n+typedef int (foo) (int, int);\n+typedef void (bar) (int, int);\n+struct sls_testclass {\n+    foo *x;\n+    bar *y;\n+    int left;\n+    int right;\n+};\n+\n+int\n+retbr_sibcall_value_insn (struct sls_testclass x)\n+{\n+  return x.x(x.left, x.right);\n+}\n+\n+void\n+retbr_sibcall_insn (struct sls_testclass x)\n+{\n+  x.y(x.left, x.right);\n+}\n+\n+/* Aim to test two different returns.\n+   One that introduces a tail call in the middle of the function, and one that\n+   has a normal return.  */\n+int\n+retbr_multiple_returns (struct sls_testclass x)\n+{\n+  int temp;\n+  if (x.left % 10)\n+    return x.x(x.left, 100);\n+  else if (x.right % 20)\n+    {\n+      return x.x(x.left * x.right, 100);\n+    }\n+  temp = x.left % x.right;\n+  temp *= 100;\n+  temp /= 2;\n+  return temp % 3;\n+}\n+\n+void\n+retbr_multiple_returns_void (struct sls_testclass x)\n+{\n+  if (x.left % 10)\n+    {\n+      x.y(x.left, 100);\n+    }\n+  else if (x.right % 20)\n+    {\n+      x.y(x.left * x.right, 100);\n+    }\n+  return;\n+}\n+\n+/* Testing the casesi jump via register.  */\n+__attribute__ ((optimize (\"Os\")))\n+int\n+retbr_casesi_dispatch (struct sls_testclass x)\n+{\n+  switch (x.left)\n+    {\n+    case -5:\n+      return -2;\n+    case -3:\n+      return -1;\n+    case 0:\n+      return 0;\n+    case 3:\n+      return 1;\n+    case 5:\n+      break;\n+    default:\n+      __builtin_unreachable ();\n+    }\n+  return x.right;\n+}\n+\n+/* Testing the BR in trampolines is mitigated against.  */\n+void f1 (void *);\n+void f3 (void *, void (*)(void *));\n+void f2 (void *);\n+\n+int\n+retbr_trampolines (void *a, int b)\n+{\n+  if (!b)\n+    {\n+      f1 (a);\n+      return 1;\n+    }\n+  if (b)\n+    {\n+      void retbr_tramp_internal (void *c)\n+      {\n+\tif (c == a)\n+\t  f2 (c);\n+      }\n+      f3 (a, retbr_tramp_internal);\n+    }\n+  return 0;\n+}\n+\n+/* Testing the indirect_jump pattern.  */\n+void\n+retbr_indirect_jump (int *buf)\n+{\n+  __builtin_longjmp(buf, 1);\n+}\n+\n+/* Ensure there are no BR or RET instructions which are not directly followed\n+   by a speculation barrier.  */\n+/* { dg-final { scan-assembler-not {\\t(br|ret|retaa|retab)\\tx[0-9][0-9]?\\n\\t(?!dsb\\tsy\\n\\tisb|sb)} } } */"}, {"sha": "812250379f877b3a924667c6e53b06cd7fecca7b", "filename": "gcc/testsuite/gcc.target/aarch64/sls-mitigation/sls-mitigation.exp", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-mitigation.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-mitigation.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsls-mitigation%2Fsls-mitigation.exp?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -0,0 +1,73 @@\n+#  Regression driver for SLS mitigation on AArch64.\n+#  Copyright (C) 2020 Free Software Foundation, Inc.\n+#  Contributed by ARM Ltd.\n+#\n+#  This file is part of GCC.\n+#\n+#  GCC is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3, or (at your option)\n+#  any later version.\n+#\n+#  GCC is distributed in the hope that it will be useful, but\n+#  WITHOUT ANY WARRANTY; without even the implied warranty of\n+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+#  General Public License for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.  */\n+\n+# Exit immediately if this isn't an AArch64 target.\n+if {![istarget aarch64*-*-*] } then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+load_lib torture-options.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" \"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+torture-init\n+\n+# Use different architectures as well as the normal optimisation options.\n+# (i.e. use both SB and DSB+ISB barriers).\n+\n+set save-dg-do-what-default ${dg-do-what-default}\n+# Main loop.\n+# Run with torture tests (i.e. a bunch of different optimisation levels) just\n+# to increase test coverage.\n+set dg-do-what-default assemble\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cCS\\]]] \\\n+\t\"-save-temps\" $DEFAULT_CFLAGS\n+\n+# Run the same tests but this time with SB extension.\n+# Since not all supported assemblers will support that extension we decide\n+# whether to assemble or just compile based on whether the extension is\n+# supported for the available assembler.\n+\n+set templist {}\n+foreach x $DG_TORTURE_OPTIONS {\n+  lappend templist \"$x -march=armv8.3-a+sb \"\n+  lappend templist \"$x -march=armv8-a+sb \"\n+}\n+set-torture-options $templist\n+if { [check_effective_target_aarch64_asm_sb_ok] } {\n+    set dg-do-what-default assemble\n+} else {\n+    set dg-do-what-default compile\n+}\n+gcc-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cCS\\]]] \\\n+\t\"-save-temps\" $DEFAULT_CFLAGS\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+torture-finish\n+dg-finish"}, {"sha": "19aa51d3e3f3ab2c1c120fddbec064ecfb430272", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be178ecd5ac1fe1510d960ff95c66d0ff831afe1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=be178ecd5ac1fe1510d960ff95c66d0ff831afe1", "patch": "@@ -9431,7 +9431,7 @@ proc check_effective_target_aarch64_tiny { } {\n # various architecture extensions via the .arch_extension pseudo-op.\n \n foreach { aarch64_ext } { \"fp\" \"simd\" \"crypto\" \"crc\" \"lse\" \"dotprod\" \"sve\"\n-\t\t\t  \"i8mm\" \"f32mm\" \"f64mm\" \"bf16\" } {\n+\t\t\t  \"i8mm\" \"f32mm\" \"f64mm\" \"bf16\" \"sb\" } {\n     eval [string map [list FUNC $aarch64_ext] {\n \tproc check_effective_target_aarch64_asm_FUNC_ok { } {\n \t  if { [istarget aarch64*-*-*] } {"}]}