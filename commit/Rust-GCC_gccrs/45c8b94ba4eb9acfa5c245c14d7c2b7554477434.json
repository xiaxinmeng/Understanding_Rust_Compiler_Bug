{"sha": "45c8b94ba4eb9acfa5c245c14d7c2b7554477434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVjOGI5NGJhNGViOWFjZmE1YzI0NWMxNGQ3YzJiNzU1NDQ3NzQzNA==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-09-26T10:46:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-26T10:46:22Z"}, "message": "sem_ch4.adb (Analyze_Qualified_Expression): Apply name resolution rule for qualified expressions properly...\n\n2007-09-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Qualified_Expression): Apply name resolution\n\trule for qualified expressions properly, to detect improper conversions\n\tand resolve some cases of overloading.\n\nFrom-SVN: r128803", "tree": {"sha": "a8dd6f0424df16b23ad39c54bcd57abf73603192", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8dd6f0424df16b23ad39c54bcd57abf73603192"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45c8b94ba4eb9acfa5c245c14d7c2b7554477434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c8b94ba4eb9acfa5c245c14d7c2b7554477434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c8b94ba4eb9acfa5c245c14d7c2b7554477434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c8b94ba4eb9acfa5c245c14d7c2b7554477434/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71f6218033d31975d39c2bb3a4f282ecc3e754dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71f6218033d31975d39c2bb3a4f282ecc3e754dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71f6218033d31975d39c2bb3a4f282ecc3e754dd"}], "stats": {"total": 64, "additions": 54, "deletions": 10}, "files": [{"sha": "d2a12e6c5c631447222623432483205d744c4360", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45c8b94ba4eb9acfa5c245c14d7c2b7554477434/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45c8b94ba4eb9acfa5c245c14d7c2b7554477434/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=45c8b94ba4eb9acfa5c245c14d7c2b7554477434", "patch": "@@ -354,11 +354,15 @@ package body Sem_Ch4 is\n          Set_Etype (Acc_Type, Acc_Type);\n          Init_Size_Align (Acc_Type);\n          Find_Type (Subtype_Mark (E));\n-         Type_Id := Entity (Subtype_Mark (E));\n-         Check_Fully_Declared (Type_Id, N);\n+\n+         --  Analyze the qualified expression, and apply the name resolution\n+         --  rule given in  4.7 (3).\n+\n+         Analyze (E);\n+         Type_Id := Etype (E);\n          Set_Directly_Designated_Type (Acc_Type, Type_Id);\n \n-         Analyze_And_Resolve (Expression (E), Type_Id);\n+         Resolve (Expression (E), Type_Id);\n \n          if Is_Limited_Type (Type_Id)\n            and then Comes_From_Source (N)\n@@ -373,11 +377,12 @@ package body Sem_Ch4 is\n          --  A qualified expression requires an exact match of the type,\n          --  class-wide matching is not allowed.\n \n-         if Is_Class_Wide_Type (Type_Id)\n-           and then Base_Type (Etype (Expression (E))) /= Base_Type (Type_Id)\n-         then\n-            Wrong_Type (Expression (E), Type_Id);\n-         end if;\n+         --  if Is_Class_Wide_Type (Type_Id)\n+         --    and then Base_Type\n+         --       (Etype (Expression (E))) /= Base_Type (Type_Id)\n+         --  then\n+         --     Wrong_Type (Expression (E), Type_Id);\n+         --  end if;\n \n          Check_Non_Static_Context (Expression (E));\n \n@@ -924,14 +929,18 @@ package body Sem_Ch4 is\n       --  Check for not-yet-implemented cases of AI-318. We only need to check\n       --  for inherently limited types, because other limited types will be\n       --  returned by copy, which works just fine.\n+      --  If the context is an attribute reference 'Class, this is really a\n+      --  type conversion, which is illegal, and will be caught elsewhere.\n \n       if Ada_Version >= Ada_05\n         and then not Debug_Flag_Dot_L\n         and then Is_Inherently_Limited_Type (Etype (N))\n         and then (Nkind (Parent (N)) = N_Selected_Component\n                    or else Nkind (Parent (N)) = N_Indexed_Component\n                    or else Nkind (Parent (N)) = N_Slice\n-                   or else Nkind (Parent (N)) = N_Attribute_Reference)\n+                   or else\n+                    (Nkind (Parent (N)) = N_Attribute_Reference\n+                       and then Attribute_Name (Parent (N)) /= Name_Class))\n       then\n          Error_Msg_N (\"(Ada 2005) limited function call in this context\" &\n                       \" is not yet implemented\", N);\n@@ -2520,19 +2529,54 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Qualified_Expression (N : Node_Id) is\n       Mark : constant Entity_Id := Subtype_Mark (N);\n+      Expr : constant Node_Id   := Expression (N);\n+      I    : Interp_Index;\n+      It   : Interp;\n       T    : Entity_Id;\n \n    begin\n+      Analyze_Expression (Expr);\n+\n       Set_Etype (N, Any_Type);\n       Find_Type (Mark);\n       T := Entity (Mark);\n+      Set_Etype (N, T);\n \n       if T = Any_Type then\n          return;\n       end if;\n \n       Check_Fully_Declared (T, N);\n-      Analyze_Expression (Expression (N));\n+\n+      --  If expected type is class-wide, check for exact match before\n+      --  expansion, because if the expression is a dispatching call it\n+      --  may be rewritten as explicit dereference with class-wide result.\n+      --  If expression is overloaded, retain only interpretations that\n+      --  will yield exact matches.\n+\n+      if Is_Class_Wide_Type (T) then\n+         if not Is_Overloaded (Expr) then\n+            if  Base_Type (Etype (Expr)) /= Base_Type (T) then\n+               if Nkind (Expr) = N_Aggregate then\n+                  Error_Msg_N (\"type of aggregate cannot be class-wide\", Expr);\n+               else\n+                  Wrong_Type (Expr, T);\n+               end if;\n+            end if;\n+\n+         else\n+            Get_First_Interp (Expr, I, It);\n+\n+            while Present (It.Nam) loop\n+               if Base_Type (It.Typ) /= Base_Type (T) then\n+                  Remove_Interp (I);\n+               end if;\n+\n+               Get_Next_Interp (I, It);\n+            end loop;\n+         end if;\n+      end if;\n+\n       Set_Etype  (N, T);\n    end Analyze_Qualified_Expression;\n "}]}