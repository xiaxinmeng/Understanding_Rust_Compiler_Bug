{"sha": "decd8fb0128870d0d768ba53dae626913d6d9c54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVjZDhmYjAxMjg4NzBkMGQ3NjhiYTUzZGFlNjI2OTEzZDZkOWM1NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-02-18T08:16:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-02-18T08:22:14Z"}, "message": "i386: Fix up df uses in i386 splitters [PR99104]\n\nThe following testcase started ICEing with my recent changes to enable\nsplit4 after sel-sched, but it seems the bug is more general.\nSome of the i386 splitter condition functions use and rely on df, but\nthe split passes don't really df_analyze/df_finish_pass, so the DF info\nmay be stale or not computed at all - the particular ICE is because\nthere is a new bb and df_get_live_out (bb) returns NULL on it as the\nlive or lr problem has not been computed yet.\n\nThis patch fixes it by not calling ix86_ok_to_clobber_flags from\nix86_avoid_lea_for_add where it wasn't ever needed because the splitters\nusing that function as condition have (clobber FLAGS) in their pattern.\nAnd, changes the ix86_avoid_lea_for_addr using splitter from normal splitter\nto peephole2 splitter that uses peep2_regno_dead_p infrastructure to\ndetermine if FLAGS is dead.  Also, it saves and restores recog_data\nvariable around the call to distance_non_agu_define and doesn't call\nextract_insn_data there, because split_insns or peephole2_insns just\nclear recog_data.insn and then fill in recog_data.operand array, and so\nmight not match what extract_insn will do on the insn at all.\n\n2021-02-18  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/99104\n\t* config/i386/i386.c (distance_non_agu_define): Don't call\n\textract_insn_cached here.\n\t(ix86_lea_outperforms): Save and restore recog_data around call\n\tto distance_non_agu_define and distance_agu_use.\n\t(ix86_ok_to_clobber_flags): Remove.\n\t(ix86_avoid_lea_for_add): Don't call ix86_ok_to_clobber_flags.\n\t(ix86_avoid_lea_for_addr): Likewise.  Adjust function comment.\n\t* config/i386/i386.md (*lea<mode>): Change from define_insn_and_split\n\tinto define_insn.  Move the splitting to define_peephole2 and\n\tcheck there using peep2_regno_dead_p if FLAGS_REG is dead.\n\n\t* gcc.dg/pr99104.c: New test.", "tree": {"sha": "ae887dcb73eff52a46fac59816c262ac73380c75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae887dcb73eff52a46fac59816c262ac73380c75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/decd8fb0128870d0d768ba53dae626913d6d9c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/decd8fb0128870d0d768ba53dae626913d6d9c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/decd8fb0128870d0d768ba53dae626913d6d9c54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/decd8fb0128870d0d768ba53dae626913d6d9c54/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acc0ee5c0731a70f15662146fc4f9dc949980aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acc0ee5c0731a70f15662146fc4f9dc949980aa2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acc0ee5c0731a70f15662146fc4f9dc949980aa2"}], "stats": {"total": 112, "additions": 39, "deletions": 73}, "files": [{"sha": "aa50cf718a94739ad2199a7cfdc3062b28ebe119", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/decd8fb0128870d0d768ba53dae626913d6d9c54/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/decd8fb0128870d0d768ba53dae626913d6d9c54/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=decd8fb0128870d0d768ba53dae626913d6d9c54", "patch": "@@ -14754,11 +14754,6 @@ distance_non_agu_define (unsigned int regno1, unsigned int regno2,\n \t}\n     }\n \n-  /* get_attr_type may modify recog data.  We want to make sure\n-     that recog data is valid for instruction INSN, on which\n-     distance_non_agu_define is called.  INSN is unchanged here.  */\n-  extract_insn_cached (insn);\n-\n   if (!found)\n     return -1;\n \n@@ -14928,17 +14923,15 @@ ix86_lea_outperforms (rtx_insn *insn, unsigned int regno0, unsigned int regno1,\n       return true;\n     }\n \n-  rtx_insn *rinsn = recog_data.insn;\n+  /* Remember recog_data content.  */\n+  struct recog_data_d recog_data_save = recog_data;\n \n   dist_define = distance_non_agu_define (regno1, regno2, insn);\n   dist_use = distance_agu_use (regno0, insn);\n \n-  /* distance_non_agu_define can call extract_insn_cached.  If this function\n-     is called from define_split conditions, that can break insn splitting,\n-     because split_insns works by clearing recog_data.insn and then modifying\n-     recog_data.operand array and match the various split conditions.  */\n-  if (recog_data.insn != rinsn)\n-    recog_data.insn = NULL;\n+  /* distance_non_agu_define can call get_attr_type which can call\n+     recog_memoized, restore recog_data back to previous content.  */\n+  recog_data = recog_data_save;\n \n   if (dist_define < 0 || dist_define >= LEA_MAX_STALL)\n     {\n@@ -14968,38 +14961,6 @@ ix86_lea_outperforms (rtx_insn *insn, unsigned int regno0, unsigned int regno1,\n   return dist_define >= dist_use;\n }\n \n-/* Return true if it is legal to clobber flags by INSN and\n-   false otherwise.  */\n-\n-static bool\n-ix86_ok_to_clobber_flags (rtx_insn *insn)\n-{\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-  df_ref use;\n-  bitmap live;\n-\n-  while (insn)\n-    {\n-      if (NONDEBUG_INSN_P (insn))\n-\t{\n-\t  FOR_EACH_INSN_USE (use, insn)\n-\t    if (DF_REF_REG_USE_P (use) && DF_REF_REGNO (use) == FLAGS_REG)\n-\t      return false;\n-\n-\t  if (insn_defines_reg (FLAGS_REG, INVALID_REGNUM, insn))\n-\t    return true;\n-\t}\n-\n-      if (insn == BB_END (bb))\n-\tbreak;\n-\n-      insn = NEXT_INSN (insn);\n-    }\n-\n-  live = df_get_live_out(bb);\n-  return !REGNO_REG_SET_P (live, FLAGS_REG);\n-}\n-\n /* Return true if we need to split op0 = op1 + op2 into a sequence of\n    move and add to avoid AGU stalls.  */\n \n@@ -15012,10 +14973,6 @@ ix86_avoid_lea_for_add (rtx_insn *insn, rtx operands[])\n   if (!TARGET_OPT_AGU || optimize_function_for_size_p (cfun))\n     return false;\n \n-  /* Check it is correct to split here.  */\n-  if (!ix86_ok_to_clobber_flags(insn))\n-    return false;\n-\n   regno0 = true_regnum (operands[0]);\n   regno1 = true_regnum (operands[1]);\n   regno2 = true_regnum (operands[2]);\n@@ -15051,7 +15008,7 @@ ix86_use_lea_for_mov (rtx_insn *insn, rtx operands[])\n }\n \n /* Return true if we need to split lea into a sequence of\n-   instructions to avoid AGU stalls. */\n+   instructions to avoid AGU stalls during peephole2. */\n \n bool\n ix86_avoid_lea_for_addr (rtx_insn *insn, rtx operands[])\n@@ -15071,10 +15028,6 @@ ix86_avoid_lea_for_addr (rtx_insn *insn, rtx operands[])\n \t  && REG_P (XEXP (operands[1], 0))))\n     return false;\n \n-  /* Check if it is OK to split here.  */\n-  if (!ix86_ok_to_clobber_flags (insn))\n-    return false;\n-\n   ok = ix86_decompose_address (operands[1], &parts);\n   gcc_assert (ok);\n "}, {"sha": "333dc9ac7c6e68af77acb41cd6f8a2d4cca1822c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/decd8fb0128870d0d768ba53dae626913d6d9c54/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/decd8fb0128870d0d768ba53dae626913d6d9c54/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=decd8fb0128870d0d768ba53dae626913d6d9c54", "patch": "@@ -5176,7 +5176,7 @@\n \f\n ;; Load effective address instructions\n \n-(define_insn_and_split \"*lea<mode>\"\n+(define_insn \"*lea<mode>\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n \t(match_operand:SWI48 1 \"address_no_seg_operand\" \"Ts\"))]\n   \"ix86_hardreg_mov_ok (operands[0], operands[1])\"\n@@ -5189,38 +5189,36 @@\n   else \n     return \"lea{<imodesuffix>}\\t{%E1, %0|%0, %E1}\";\n }\n-  \"reload_completed && ix86_avoid_lea_for_addr (insn, operands)\"\n+  [(set_attr \"type\" \"lea\")\n+   (set (attr \"mode\")\n+     (if_then_else\n+       (match_operand 1 \"SImode_address_operand\")\n+       (const_string \"SI\")\n+       (const_string \"<MODE>\")))])\n+\n+(define_peephole2\n+  [(set (match_operand:SWI48 0 \"register_operand\")\n+\t(match_operand:SWI48 1 \"address_no_seg_operand\"))]\n+  \"ix86_hardreg_mov_ok (operands[0], operands[1])\n+   && peep2_regno_dead_p (0, FLAGS_REG)\n+   && ix86_avoid_lea_for_addr (peep2_next_insn (0), operands)\"\n   [(const_int 0)]\n {\n   machine_mode mode = <MODE>mode;\n-  rtx pat;\n-\n-  /* ix86_avoid_lea_for_addr re-recognizes insn and may\n-     change operands[] array behind our back.  */\n-  pat = PATTERN (curr_insn);\n-\n-  operands[0] = SET_DEST (pat);\n-  operands[1] = SET_SRC (pat);\n \n   /* Emit all operations in SImode for zero-extended addresses.  */\n   if (SImode_address_operand (operands[1], VOIDmode))\n     mode = SImode;\n \n-  ix86_split_lea_for_addr (curr_insn, operands, mode);\n+  ix86_split_lea_for_addr (peep2_next_insn (0), operands, mode);\n \n   /* Zero-extend return register to DImode for zero-extended addresses.  */\n   if (mode != <MODE>mode)\n-    emit_insn (gen_zero_extendsidi2\n-    \t       (operands[0], gen_lowpart (mode, operands[0])));\n+    emit_insn (gen_zero_extendsidi2 (operands[0],\n+\t\t\t\t     gen_lowpart (mode, operands[0])));\n \n   DONE;\n-}\n-  [(set_attr \"type\" \"lea\")\n-   (set (attr \"mode\")\n-     (if_then_else\n-       (match_operand 1 \"SImode_address_operand\")\n-       (const_string \"SI\")\n-       (const_string \"<MODE>\")))])\n+})\n \f\n ;; Add instructions\n "}, {"sha": "807e1da4090803f7e6aac1312aff0ef6838d0aeb", "filename": "gcc/testsuite/gcc.dg/pr99104.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/decd8fb0128870d0d768ba53dae626913d6d9c54/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99104.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/decd8fb0128870d0d768ba53dae626913d6d9c54/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99104.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr99104.c?ref=decd8fb0128870d0d768ba53dae626913d6d9c54", "patch": "@@ -0,0 +1,15 @@\n+/* PR target/99104 */\n+/* { dg-do compile { target int128 } } */\n+/* { dg-options \"-O2 -fsel-sched-pipelining -fselective-scheduling2 -funroll-loops\" } */\n+\n+__int128 a;\n+int b;\n+int foo (void);\n+\n+int __attribute__ ((simd))\n+bar (void)\n+{\n+  a = ~a;\n+  if (foo ())\n+    b = 0;\n+}"}]}