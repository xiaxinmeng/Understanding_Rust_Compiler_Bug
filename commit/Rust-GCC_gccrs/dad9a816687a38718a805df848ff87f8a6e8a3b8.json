{"sha": "dad9a816687a38718a805df848ff87f8a6e8a3b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFkOWE4MTY2ODdhMzg3MThhODA1ZGY4NDhmZjg3ZjhhNmU4YTNiOA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-02-15T09:39:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:39:41Z"}, "message": "exp_intr.adb (Expand_Unc_Deallocation): Correct error of bad analyze call.\n\n2006-02-13  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_intr.adb (Expand_Unc_Deallocation): Correct error of bad analyze\n\tcall.\n\nFrom-SVN: r111067", "tree": {"sha": "d000d70f0d5ceb86bd35af03b394f3f2d1b92753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d000d70f0d5ceb86bd35af03b394f3f2d1b92753"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dad9a816687a38718a805df848ff87f8a6e8a3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad9a816687a38718a805df848ff87f8a6e8a3b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad9a816687a38718a805df848ff87f8a6e8a3b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad9a816687a38718a805df848ff87f8a6e8a3b8/comments", "author": null, "committer": null, "parents": [{"sha": "0273bbb409468d108c9f1c316c7d1e9f554c7275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0273bbb409468d108c9f1c316c7d1e9f554c7275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0273bbb409468d108c9f1c316c7d1e9f554c7275"}], "stats": {"total": 96, "additions": 43, "deletions": 53}, "files": [{"sha": "f5e4bdaa6be36dc012c8a72725e9bd4894cc35f3", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 43, "deletions": 53, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad9a816687a38718a805df848ff87f8a6e8a3b8/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad9a816687a38718a805df848ff87f8a6e8a3b8/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=dad9a816687a38718a805df848ff87f8a6e8a3b8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -705,11 +705,25 @@ package body Exp_Intr is\n       Free_Cod  : List_Id;\n       Blk       : Node_Id;\n \n+      Arg_Known_Non_Null : constant Boolean := Known_Non_Null (N);\n+      --  This captures whether we know the argument to be non-null so that\n+      --  we can avoid the test. The reason that we need to capture this is\n+      --  that we analyze some generated statements before properly attaching\n+      --  them to the tree, and that can disturb current value settings.\n+\n    begin\n       if No_Pool_Assigned (Rtyp) then\n          Error_Msg_N (\"?deallocation from empty storage pool\", N);\n       end if;\n \n+      --  Nothing to do if we know the argument is null\n+\n+      if Known_Null (N) then\n+         return;\n+      end if;\n+\n+      --  Processing for pointer to controlled type\n+\n       if Controlled_Type (Desig_T) then\n          Deref :=\n            Make_Explicit_Dereference (Loc,\n@@ -761,6 +775,11 @@ package body Exp_Intr is\n               (Handled_Statement_Sequence (Blk), Entity (Identifier (Blk)));\n             Append (Blk, Stmts);\n \n+            --  We kill saved current values, since analyzing statements not\n+            --  properly attached to the tree can set wrong current values.\n+\n+            Kill_Current_Values;\n+\n          else\n             Append_List_To (Stmts, Free_Cod);\n          end if;\n@@ -917,58 +936,6 @@ package body Exp_Intr is\n \n       Set_Expression (Free_Node, Free_Arg);\n \n-      --  Make implicit if statement. We omit this if we are the then part\n-      --  of a test of the form:\n-\n-      --    if not (Arg = null) then\n-\n-      --  i.e. if the test is explicit in the source. Arg must be a simple\n-      --  identifier for the purposes of this special test. Note that the\n-      --  use of /= in the source is always transformed into the above form.\n-\n-      declare\n-         Test_Needed : Boolean := True;\n-         P           : constant Node_Id := Parent (N);\n-         C           : Node_Id;\n-\n-      begin\n-         if Nkind (Arg) = N_Identifier\n-           and then Nkind (P) =  N_If_Statement\n-           and then First (Then_Statements (P)) = N\n-         then\n-            if Nkind (Condition (P)) = N_Op_Not then\n-               C := Right_Opnd (Condition (P));\n-\n-               if Nkind (C) = N_Op_Eq\n-                 and then Nkind (Left_Opnd (C)) = N_Identifier\n-                 and then Chars (Arg) = Chars (Left_Opnd (C))\n-                 and then Nkind (Right_Opnd (C)) = N_Null\n-               then\n-                  Test_Needed := False;\n-               end if;\n-            end if;\n-         end if;\n-\n-         --  Generate If_Statement if needed\n-\n-         if Test_Needed then\n-            Gen_Code :=\n-              Make_Implicit_If_Statement (N,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd  => Duplicate_Subexpr (Arg),\n-                    Right_Opnd => Make_Null (Loc)),\n-                Then_Statements => Stmts);\n-\n-         else\n-            Gen_Code :=\n-              Make_Block_Statement (Loc,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => Stmts));\n-         end if;\n-      end;\n-\n       --  Only remaining step is to set result to null, or generate a\n       --  raise of constraint error if the target object is \"not null\".\n \n@@ -989,6 +956,29 @@ package body Exp_Intr is\n          end;\n       end if;\n \n+      --  If we know the argument is non-null, then make a block statement\n+      --  that contains the required statements, no need for a test.\n+\n+      if Arg_Known_Non_Null then\n+         Gen_Code :=\n+           Make_Block_Statement (Loc,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+             Statements => Stmts));\n+\n+      --  If the argument may be null, wrap the statements inside an IF that\n+      --  does an explicit test to exclude the null case.\n+\n+      else\n+         Gen_Code :=\n+           Make_Implicit_If_Statement (N,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd  => Duplicate_Subexpr (Arg),\n+                 Right_Opnd => Make_Null (Loc)),\n+             Then_Statements => Stmts);\n+      end if;\n+\n       --  Rewrite the call\n \n       Rewrite (N, Gen_Code);"}]}