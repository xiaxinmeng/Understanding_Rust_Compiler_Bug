{"sha": "10e1540cdf2509d5414e5a2bc205b0811cf80637", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlMTU0MGNkZjI1MDlkNTQxNGU1YTJiYzIwNWIwODExY2Y4MDYzNw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2019-11-01T12:59:25Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-11-01T12:59:25Z"}, "message": "[C++ PATCH] cleanup check_field_decls\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-11/msg00012.html\n\tcp/\n\t* class.c (check_field_decls): Refactor.\n\n\ttestsuite/\n\t* g++.dg/template/fn.C: New.\n\nFrom-SVN: r277707", "tree": {"sha": "ee175398b0fbe64b9d75bb547b35c4c635400f3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee175398b0fbe64b9d75bb547b35c4c635400f3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e1540cdf2509d5414e5a2bc205b0811cf80637", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e1540cdf2509d5414e5a2bc205b0811cf80637", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e1540cdf2509d5414e5a2bc205b0811cf80637", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e1540cdf2509d5414e5a2bc205b0811cf80637/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9de3d4f0493871f054a163917cf7695d66cb23ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9de3d4f0493871f054a163917cf7695d66cb23ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9de3d4f0493871f054a163917cf7695d66cb23ad"}], "stats": {"total": 298, "additions": 159, "deletions": 139}, "files": [{"sha": "0b828528958b702457c96471216229695981eef7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10e1540cdf2509d5414e5a2bc205b0811cf80637", "patch": "@@ -1,3 +1,7 @@\n+2019-11-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* class.c (check_field_decls): Refactor.\n+\n 2019-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/90947"}, {"sha": "3572707415660b9a09478a2ebf552ad010936c5d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 141, "deletions": 139, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=10e1540cdf2509d5414e5a2bc205b0811cf80637", "patch": "@@ -3448,114 +3448,108 @@ check_field_decl (tree field,\n        operator taking a const reference.\n \n    All of these flags should be initialized before calling this\n-   function.\n-\n-   Returns a pointer to the end of the TYPE_FIELDs chain; additional\n-   fields can be added by adding to this chain.  */\n+   function.   */\n \n static void\n check_field_decls (tree t, tree *access_decls,\n \t\t   int *cant_have_const_ctor_p,\n \t\t   int *no_const_asn_ref_p)\n {\n-  tree *field;\n-  tree *next;\n   int cant_pack = 0;\n-  int field_access = -1;\n \n   /* Assume there are no access declarations.  */\n   *access_decls = NULL_TREE;\n-  /* Assume this class has no pointer members.  */\n-  bool has_pointers = false;\n-  /* Assume none of the members of this class have default\n-     initializations.  */\n-  bool any_default_members = false;\n-  /* Assume none of the non-static data members are of non-volatile literal\n-     type.  */\n+  /* Effective C has things to say about classes with pointer members.  */\n+  tree pointer_member = NULL_TREE;\n+  /* Default initialized members affect the whole class.  */\n+  tree default_init_member = NULL_TREE;\n+  /* Lack of any non-static data member of non-volatile literal\n+     type affects a union.  */\n   bool found_nv_literal_p = false;\n+  /* Standard layout requires all FIELDS have same access.  */\n+  int field_access = -1;\n \n-  for (field = &TYPE_FIELDS (t); *field; field = next)\n+  for (tree field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n     {\n-      tree x = *field;\n-      tree type = TREE_TYPE (x);\n-      int this_field_access;\n-\n-      next = &DECL_CHAIN (x);\n+      tree type = TREE_TYPE (field);\n \n-      if (TREE_CODE (x) == USING_DECL)\n+      switch (TREE_CODE (field))\n \t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\n+\tcase USING_DECL:\n \t  /* Save the access declarations for our caller.  */\n-\t  *access_decls = tree_cons (NULL_TREE, x, *access_decls);\n-\t  continue;\n-\t}\n+\t  *access_decls = tree_cons (NULL_TREE, field, *access_decls);\n+\t  break;\n \n-      if (TREE_CODE (x) == TYPE_DECL\n-\t  || TREE_CODE (x) == TEMPLATE_DECL)\n-\tcontinue;\n+\tcase TYPE_DECL:\n+\tcase TEMPLATE_DECL:\n+\t  break;\n \n-      if (TREE_CODE (x) == FUNCTION_DECL)\n-\t/* FIXME: We should fold in the checking from check_methods.  */\n-\tcontinue;\n+\tcase FUNCTION_DECL:\n+\t  /* FIXME: We should fold in the checking from check_methods.  */\n+\t  break;\n \n-      /* If we've gotten this far, it's a data member, possibly static,\n-\t or an enumerator.  */\n-      if (TREE_CODE (x) != CONST_DECL)\n-\tDECL_CONTEXT (x) = t;\n+\tcase CONST_DECL:\n+\t  DECL_NONLOCAL (field) = 1;\n+\t  break;\n+\t  \n+\tcase VAR_DECL:\n+\t  if (TREE_CODE (t) == UNION_TYPE\n+\t      && cxx_dialect < cxx11)\n+\t    {\n+\t      /* [class.union]\n \n-      /* When this goes into scope, it will be a non-local reference.  */\n-      DECL_NONLOCAL (x) = 1;\n+\t\t (C++98) If a union contains a static data member,\n+\t\t ... the program is ill-formed.  */\n+\t      if (cxx_dialect < cxx11)\n+\t\terror (\"in C++98 %q+D may not be static because it is \"\n+\t\t       \"a member of a union\", field);\n+\t    }\n+\t  goto data_member;\n+\t  \n+\tcase FIELD_DECL:\n+\t  if (TREE_CODE (t) == UNION_TYPE)\n+\t    {\n+\t      /* [class.union]\n \n-      if (TREE_CODE (t) == UNION_TYPE)\n-\t{\n-\t  /* [class.union] (C++98)\n+\t\t If a union contains ... or a [non-static data] member\n+\t\t of reference type, the program is ill-formed.  */\n+\t      if (TYPE_REF_P (type))\n+\t\terror (\"non-static data member %q+D in a union may not \"\n+\t\t       \"have reference type %qT\", field, type);\n+\t    }\n \n-\t     If a union contains a static data member, or a member of\n-\t     reference type, the program is ill-formed.\n+\tdata_member:\n+\t  /* Common VAR_DECL & FIELD_DECL processing.  */\n+\t  DECL_CONTEXT (field) = t;\n+\t  DECL_NONLOCAL (field) = 1;\n \n-\t     In C++11 [class.union] says:\n-\t     If a union contains a non-static data member of reference type\n-\t     the program is ill-formed.  */\n-\t  if (VAR_P (x) && cxx_dialect < cxx11)\n+\t  /* Template instantiation can cause this.  Perhaps this\n+\t     should be a specific instantiation check?  */\n+\t  if (TREE_CODE (type) == FUNCTION_TYPE)\n \t    {\n-\t      error (\"in C++98 %q+D may not be static because it is \"\n-\t\t     \"a member of a union\", x);\n-\t      continue;\n+\t      error (\"data member %q+D invalidly declared function type\", field);\n+\t      type = build_pointer_type (type);\n+\t      TREE_TYPE (field) = type;\n \t    }\n-\t  if (TYPE_REF_P (type)\n-\t      && TREE_CODE (x) == FIELD_DECL)\n+\t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t    {\n-\t      error (\"non-static data member %q+D in a union may not \"\n-\t\t     \"have reference type %qT\", x, type);\n-\t      continue;\n+\t      error (\"data member %q+D invalidly declared method type\", field);\n+\t      type = build_pointer_type (type);\n+\t      TREE_TYPE (field) = type;\n \t    }\n-\t}\n \n-      /* Perform error checking that did not get done in\n-\t grokdeclarator.  */\n-      if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t{\n-\t  error (\"field %q+D invalidly declared function type\", x);\n-\t  type = build_pointer_type (type);\n-\t  TREE_TYPE (x) = type;\n-\t}\n-      else if (TREE_CODE (type) == METHOD_TYPE)\n-\t{\n-\t  error (\"field %q+D invalidly declared method type\", x);\n-\t  type = build_pointer_type (type);\n-\t  TREE_TYPE (x) = type;\n+\t  break;\n \t}\n \n-      if (type == error_mark_node)\n+      if (TREE_CODE (field) != FIELD_DECL)\n \tcontinue;\n \n-      if (TREE_CODE (x) == CONST_DECL || VAR_P (x))\n+      if (type == error_mark_node)\n \tcontinue;\n \n-      /* Now it can only be a FIELD_DECL.  */\n-\n-      if (TREE_PRIVATE (x) || TREE_PROTECTED (x))\n-\tCLASSTYPE_NON_AGGREGATE (t) = 1;\n-\n       /* If it is not a union and at least one non-static data member is\n \t non-literal, the whole class becomes non-literal.  Per Core/1453,\n \t volatile non-static data members and base classes are also not allowed.\n@@ -3570,22 +3564,30 @@ check_field_decls (tree t, tree *access_decls,\n \t    found_nv_literal_p = true;\n \t}\n \n-      /* A standard-layout class is a class that:\n-\t ...\n-\t has the same access control (Clause 11) for all non-static data members,\n-         ...  */\n-      this_field_access = TREE_PROTECTED (x) ? 1 : TREE_PRIVATE (x) ? 2 : 0;\n-      if (field_access == -1)\n-\tfield_access = this_field_access;\n-      else if (this_field_access != field_access)\n-\tCLASSTYPE_NON_STD_LAYOUT (t) = 1;\n+      int this_field_access = (TREE_PROTECTED (field) ? 1\n+\t\t\t       : TREE_PRIVATE (field) ? 2 : 0);\n+      if (field_access != this_field_access)\n+\t{\n+\t  /* A standard-layout class is a class that:\n+\n+\t     ... has the same access control (Clause 11) for all\n+\t     non-static data members, */\n+\t  if (field_access < 0)\n+\t    field_access = this_field_access;\n+\t  else\n+\t    CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n+\n+\t  /* Aggregates must be public.  */\n+\t  if (this_field_access)\n+\t    CLASSTYPE_NON_AGGREGATE (t) = 1;\n+\t}\n \n       /* If this is of reference type, check if it needs an init.  */\n       if (TYPE_REF_P (type))\n \t{\n \t  CLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n \t  CLASSTYPE_NON_STD_LAYOUT (t) = 1;\n-\t  if (DECL_INITIAL (x) == NULL_TREE)\n+\t  if (DECL_INITIAL (field) == NULL_TREE)\n \t    SET_CLASSTYPE_REF_FIELDS_NEED_INIT (t, 1);\n \t  if (cxx_dialect < cxx11)\n \t    {\n@@ -3604,35 +3606,32 @@ check_field_decls (tree t, tree *access_decls,\n \t{\n \t  if (!layout_pod_type_p (type) && !TYPE_PACKED (type))\n \t    {\n-\t      warning_at\n-\t\t(DECL_SOURCE_LOCATION (x), 0,\n-\t\t \"ignoring packed attribute because of unpacked non-POD field %q#D\",\n-\t\t x);\n+\t      warning_at (DECL_SOURCE_LOCATION (field), 0,\n+\t\t\t  \"ignoring packed attribute because of\"\n+\t\t\t  \" unpacked non-POD field %q#D\", field);\n \t      cant_pack = 1;\n \t    }\n-\t  else if (DECL_C_BIT_FIELD (x)\n-\t\t   || TYPE_ALIGN (TREE_TYPE (x)) > BITS_PER_UNIT)\n-\t    DECL_PACKED (x) = 1;\n+\t  else if (DECL_C_BIT_FIELD (field)\n+\t\t   || TYPE_ALIGN (TREE_TYPE (field)) > BITS_PER_UNIT)\n+\t    DECL_PACKED (field) = 1;\n \t}\n \n-      if (DECL_C_BIT_FIELD (x)\n-\t  && integer_zerop (DECL_BIT_FIELD_REPRESENTATIVE (x)))\n+      if (DECL_C_BIT_FIELD (field)\n+\t  && integer_zerop (DECL_BIT_FIELD_REPRESENTATIVE (field)))\n \t/* We don't treat zero-width bitfields as making a class\n \t   non-empty.  */\n \t;\n-      else if (field_poverlapping_p (x) && is_empty_class (type))\n-\t{\n-\t  /* Empty data members also don't make a class non-empty.  */\n-\t  CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) = 1;\n-\t}\n+      else if (field_poverlapping_p (field) && is_empty_class (type))\n+\t/* Empty data members also don't make a class non-empty.  */\n+\tCLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) = 1;\n       else\n \t{\n \t  /* The class is non-empty.  */\n \t  CLASSTYPE_EMPTY_P (t) = 0;\n \t  /* The class is not even nearly empty.  */\n \t  CLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n-\t  /* If one of the data members contains an empty class,\n-\t     so does T.  */\n+\t  /* If one of the data members contains an empty class, so\n+\t     does T.  */\n \t  if (CLASS_TYPE_P (type)\n \t      && CLASSTYPE_CONTAINS_EMPTY_CLASS_P (type))\n \t    CLASSTYPE_CONTAINS_EMPTY_CLASS_P (t) = 1;\n@@ -3643,7 +3642,7 @@ check_field_decls (tree t, tree *access_decls,\n \t for pointers to functions or pointers to members.  */\n       if (TYPE_PTR_P (type)\n \t  && !TYPE_PTRFN_P (type))\n-\thas_pointers = true;\n+\tpointer_member = field;\n \n       if (CLASS_TYPE_P (type))\n \t{\n@@ -3653,31 +3652,25 @@ check_field_decls (tree t, tree *access_decls,\n \t    SET_CLASSTYPE_READONLY_FIELDS_NEED_INIT (t, 1);\n \t}\n \n-      if (DECL_MUTABLE_P (x) || TYPE_HAS_MUTABLE_P (type))\n+      if (DECL_MUTABLE_P (field) || TYPE_HAS_MUTABLE_P (type))\n \tCLASSTYPE_HAS_MUTABLE (t) = 1;\n \n-      if (DECL_MUTABLE_P (x))\n+      if (DECL_MUTABLE_P (field))\n \t{\n-\t  if (CP_TYPE_CONST_P (type))\n-\t    {\n-\t      error (\"member %q+D cannot be declared both %<const%> \"\n-\t\t     \"and %<mutable%>\", x);\n-\t      continue;\n-\t    }\n \t  if (TYPE_REF_P (type))\n-\t    {\n-\t      error (\"member %q+D cannot be declared as a %<mutable%> \"\n-\t\t     \"reference\", x);\n-\t      continue;\n-\t    }\n+\t    error (\"member %q+D cannot be declared as a %<mutable%> \"\n+\t\t   \"reference\", field);\n+\t  else if (CP_TYPE_CONST_P (type))\n+\t    error (\"member %q+D cannot be declared both %<const%> \"\n+\t\t   \"and %<mutable%>\", field);\n \t}\n \n       if (! layout_pod_type_p (type))\n \t/* DR 148 now allows pointers to members (which are POD themselves),\n \t   to be allowed in POD structs.  */\n \tCLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n \n-      if (field_poverlapping_p (x))\n+      if (field_poverlapping_p (field))\n \t/* A potentially-overlapping non-static data member makes the class\n \t   non-layout-POD.  */\n \tCLASSTYPE_NON_LAYOUT_POD_P (t) = 1;\n@@ -3690,28 +3683,34 @@ check_field_decls (tree t, tree *access_decls,\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n \t If the type and width are valid, we'll also set DECL_BIT_FIELD.  */\n-      if (DECL_C_BIT_FIELD (x))\n-\tcheck_bitfield_decl (x);\n+      if (DECL_C_BIT_FIELD (field))\n+\tcheck_bitfield_decl (field);\n \n-      if (check_field_decl (x, t, cant_have_const_ctor_p, no_const_asn_ref_p))\n+      if (check_field_decl (field, t,\n+\t\t\t    cant_have_const_ctor_p, no_const_asn_ref_p))\n \t{\n-\t  if (any_default_members\n+\t  if (default_init_member\n \t      && TREE_CODE (t) == UNION_TYPE)\n-\t    error (\"multiple fields in union %qT initialized\", t);\n-\t  any_default_members = true;\n+\t    {\n+\t      error (\"multiple fields in union %qT initialized\", t);\n+\t      inform (DECL_SOURCE_LOCATION (default_init_member),\n+\t\t      \"initialized member %q+D declared here\",\n+\t\t      default_init_member);\n+\t    }\n+\t  default_init_member = field;\n \t}\n \n       /* Now that we've removed bit-field widths from DECL_INITIAL,\n \t anything left in DECL_INITIAL is an NSDMI that makes the class\n \t non-aggregate in C++11.  */\n-      if (DECL_INITIAL (x) && cxx_dialect < cxx14)\n+      if (DECL_INITIAL (field) && cxx_dialect < cxx14)\n \tCLASSTYPE_NON_AGGREGATE (t) = true;\n \n-      /* If any field is const, the structure type is pseudo-const.  */\n       if (CP_TYPE_CONST_P (type))\n \t{\n+\t  /* If any field is const, the structure type is pseudo-const.  */\n \t  C_TYPE_FIELDS_READONLY (t) = 1;\n-\t  if (DECL_INITIAL (x) == NULL_TREE)\n+\t  if (DECL_INITIAL (field) == NULL_TREE)\n \t    SET_CLASSTYPE_READONLY_FIELDS_NEED_INIT (t, 1);\n \t  if (cxx_dialect < cxx11)\n \t    {\n@@ -3735,10 +3734,10 @@ check_field_decls (tree t, tree *access_decls,\n       /* Core issue 80: A nonstatic data member is required to have a\n \t different name from the class iff the class has a\n \t user-declared constructor.  */\n-      if (constructor_name_p (DECL_NAME (x), t)\n+      if (constructor_name_p (DECL_NAME (field), t)\n \t  && TYPE_HAS_USER_CONSTRUCTOR (t))\n-\tpermerror (DECL_SOURCE_LOCATION (x),\n-\t\t   \"field %q#D with same name as class\", x);\n+\tpermerror (DECL_SOURCE_LOCATION (field),\n+\t\t   \"field %q#D with same name as class\", field);\n     }\n \n   /* Per CWG 2096, a type is a literal type if it is a union, and at least\n@@ -3761,28 +3760,31 @@ check_field_decls (tree t, tree *access_decls,\n \n      This seems enough for practical purposes.  */\n   if (warn_ecpp\n-      && has_pointers\n+      && pointer_member\n       && TYPE_HAS_USER_CONSTRUCTOR (t)\n       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n       && !(TYPE_HAS_COPY_CTOR (t) && TYPE_HAS_COPY_ASSIGN (t)))\n     {\n-      warning (OPT_Weffc__, \"%q#T has pointer data members\", t);\n-\n-      if (! TYPE_HAS_COPY_CTOR (t))\n+      if (warning (OPT_Weffc__, \"%q#T has pointer data members\", t))\n \t{\n-\t  warning (OPT_Weffc__,\n-\t\t   \"  but does not override %<%T(const %T&)%>\", t, t);\n-\t  if (!TYPE_HAS_COPY_ASSIGN (t))\n-\t    warning (OPT_Weffc__, \"  or %<operator=(const %T&)%>\", t);\n+\t  if (! TYPE_HAS_COPY_CTOR (t))\n+\t    {\n+\t      warning (OPT_Weffc__,\n+\t\t       \"  but does not override %<%T(const %T&)%>\", t, t);\n+\t      if (!TYPE_HAS_COPY_ASSIGN (t))\n+\t\twarning (OPT_Weffc__, \"  or %<operator=(const %T&)%>\", t);\n+\t    }\n+\t  else if (! TYPE_HAS_COPY_ASSIGN (t))\n+\t    warning (OPT_Weffc__,\n+\t\t     \"  but does not override %<operator=(const %T&)%>\", t);\n+\t  inform (DECL_SOURCE_LOCATION (pointer_member),\n+\t\t  \"pointer member %q+D declared here\", pointer_member);\n \t}\n-      else if (! TYPE_HAS_COPY_ASSIGN (t))\n-\twarning (OPT_Weffc__,\n-\t\t \"  but does not override %<operator=(const %T&)%>\", t);\n     }\n \n   /* Non-static data member initializers make the default constructor\n      non-trivial.  */\n-  if (any_default_members)\n+  if (default_init_member)\n     {\n       TYPE_NEEDS_CONSTRUCTING (t) = true;\n       TYPE_HAS_COMPLEX_DFLT (t) = true;"}, {"sha": "3955329a656cbfb998241846317004f7e15d329f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=10e1540cdf2509d5414e5a2bc205b0811cf80637", "patch": "@@ -1,3 +1,7 @@\n+2019-11-01  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/template/fn.C: New.\n+\n 2019-11-01  Kewen Lin  <linkw@gcc.gnu.org>\n \n \tPR testsuite/92127"}, {"sha": "6b5f09ae2d01a39328c0dc5481f202552ccefc08", "filename": "gcc/testsuite/g++.dg/template/fn.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e1540cdf2509d5414e5a2bc205b0811cf80637/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffn.C?ref=10e1540cdf2509d5414e5a2bc205b0811cf80637", "patch": "@@ -0,0 +1,10 @@\n+// instantiation cannot turn a data member into a function!\n+\n+typedef int (frib) (int);\n+\n+template <typename T> class X \n+{\n+  T v; // { dg-error \"declared function\" }\n+};\n+\n+X<frib> v;"}]}