{"sha": "5a28e2727f718f14a2afccf16c4dda814af5b6f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyOGUyNzI3ZjcxOGYxNGEyYWZjY2YxNmM0ZGRhODE0YWY1YjZmOA==", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-01-31T14:53:30Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2020-01-31T15:13:05Z"}, "message": "[amdgcn] Scale number of threads/workers with VGPR usage\n\n2020-01-31  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\n\tgcc/\n\t* config/gcn/mkoffload.c (process_asm): Add sgpr_count and vgpr_count\n\tto definition of hsa_kernel_description.  Parse assembly to find SGPR\n\tand VGPR count of kernel and store in hsa_kernel_description.\n\n\tlibgomp/\n\t* plugin/plugin-gcn.c (struct hsa_kernel_description): Add sgpr_count\n\tand vgpr_count fields.\n\t(struct kernel_info): Add a field for a hsa_kernel_description.\n\t(run_kernel): Reduce the number of threads/workers if the requested\n\tnumber would require too many VGPRs.\n\t(init_basic_kernel_info): Initialize description field with\n\tthe hsa_kernel_description entry for the kernel.", "tree": {"sha": "0d286ca3d9f96a1418b9792a72ce2a4f4a54421b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d286ca3d9f96a1418b9792a72ce2a4f4a54421b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a28e2727f718f14a2afccf16c4dda814af5b6f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a28e2727f718f14a2afccf16c4dda814af5b6f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a28e2727f718f14a2afccf16c4dda814af5b6f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a28e2727f718f14a2afccf16c4dda814af5b6f8/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a97d9eae4543a995f895e6739530f55f5d039a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a97d9eae4543a995f895e6739530f55f5d039a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a97d9eae4543a995f895e6739530f55f5d039a7"}], "stats": {"total": 106, "additions": 100, "deletions": 6}, "files": [{"sha": "78a831086775c96ef071dd3a24a590722523959a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a28e2727f718f14a2afccf16c4dda814af5b6f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a28e2727f718f14a2afccf16c4dda814af5b6f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a28e2727f718f14a2afccf16c4dda814af5b6f8", "patch": "@@ -1,3 +1,9 @@\n+2020-01-31  Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* config/gcn/mkoffload.c (process_asm): Add sgpr_count and vgpr_count\n+\tto definition of hsa_kernel_description.  Parse assembly to find SGPR\n+\tand VGPR count of kernel and store in hsa_kernel_description.\n+\n 2020-01-31  Tamar Christina  <tamar.christina@arm.com>\n \n \tPR rtl-optimization/91838"}, {"sha": "723da108b655b148b5e06b1f9ed20b7de4e9482b", "filename": "gcc/config/gcn/mkoffload.c", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a28e2727f718f14a2afccf16c4dda814af5b6f8/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a28e2727f718f14a2afccf16c4dda814af5b6f8/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.c?ref=5a28e2727f718f14a2afccf16c4dda814af5b6f8", "patch": "@@ -211,26 +211,34 @@ access_check (const char *name, int mode)\n static void\n process_asm (FILE *in, FILE *out, FILE *cfile)\n {\n-  int fn_count = 0, var_count = 0, dims_count = 0;\n-  struct obstack fns_os, vars_os, varsizes_os, dims_os;\n+  int fn_count = 0, var_count = 0, dims_count = 0, regcount_count = 0;\n+  struct obstack fns_os, vars_os, varsizes_os, dims_os, regcounts_os;\n   obstack_init (&fns_os);\n   obstack_init (&vars_os);\n   obstack_init (&varsizes_os);\n   obstack_init (&dims_os);\n+  obstack_init (&regcounts_os);\n \n   struct oaccdims\n   {\n     int d[3];\n     char *name;\n   } dim;\n \n+  struct regcount\n+  {\n+    int sgpr_count;\n+    int vgpr_count;\n+    char *kernel_name;\n+  } regcount;\n+\n   /* Always add _init_array and _fini_array as kernels.  */\n   obstack_ptr_grow (&fns_os, xstrdup (\"_init_array\"));\n   obstack_ptr_grow (&fns_os, xstrdup (\"_fini_array\"));\n   fn_count += 2;\n \n   char buf[1000];\n-  enum { IN_CODE, IN_VARS, IN_FUNCS } state = IN_CODE;\n+  enum { IN_CODE, IN_AMD_KERNEL_CODE_T, IN_VARS, IN_FUNCS } state = IN_CODE;\n   while (fgets (buf, sizeof (buf), in))\n     {\n       switch (state)\n@@ -243,6 +251,22 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t\tobstack_grow (&dims_os, &dim, sizeof (dim));\n \t\tdims_count++;\n \t      }\n+\t    else if (sscanf (buf, \" .amdgpu_hsa_kernel %ms\\n\",\n+\t\t\t     &regcount.kernel_name) == 1)\n+\t      break;\n+\n+\t    break;\n+\t  }\n+\tcase IN_AMD_KERNEL_CODE_T:\n+\t  {\n+\t    gcc_assert (regcount.kernel_name);\n+\t    if (sscanf (buf, \" wavefront_sgpr_count = %d\\n\",\n+\t\t\t&regcount.sgpr_count) == 1)\n+\t      break;\n+\t    else if (sscanf (buf, \" workitem_vgpr_count = %d\\n\",\n+\t\t\t     &regcount.vgpr_count) == 1)\n+\t      break;\n+\n \t    break;\n \t  }\n \tcase IN_VARS:\n@@ -282,19 +306,36 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \tstate = IN_VARS;\n       else if (sscanf (buf, \" .section .gnu.offload_funcs%c\", &dummy) > 0)\n \tstate = IN_FUNCS;\n+      else if (sscanf (buf, \" .amd_kernel_code_%c\", &dummy) > 0)\n+\t{\n+\t  state = IN_AMD_KERNEL_CODE_T;\n+\t  regcount.sgpr_count = regcount.vgpr_count = -1;\n+\t}\n       else if (sscanf (buf, \" .section %c\", &dummy) > 0\n \t       || sscanf (buf, \" .text%c\", &dummy) > 0\n \t       || sscanf (buf, \" .bss%c\", &dummy) > 0\n \t       || sscanf (buf, \" .data%c\", &dummy) > 0\n \t       || sscanf (buf, \" .ident %c\", &dummy) > 0)\n \tstate = IN_CODE;\n+      else if (sscanf (buf, \" .end_amd_kernel_code_%c\", &dummy) > 0)\n+\t{\n+\t  state = IN_CODE;\n+\t  gcc_assert (regcount.kernel_name != NULL\n+\t\t      && regcount.sgpr_count >= 0\n+\t\t      && regcount.vgpr_count >= 0);\n+\t  obstack_grow (&regcounts_os, &regcount, sizeof (regcount));\n+\t  regcount_count++;\n+\t  regcount.kernel_name = NULL;\n+\t  regcount.sgpr_count = regcount.vgpr_count = -1;\n+\t}\n \n-      if (state == IN_CODE)\n+      if (state == IN_CODE || state == IN_AMD_KERNEL_CODE_T)\n \tfputs (buf, out);\n     }\n \n   char **fns = XOBFINISH (&fns_os, char **);\n   struct oaccdims *dims = XOBFINISH (&dims_os, struct oaccdims *);\n+  struct regcount *regcounts = XOBFINISH (&regcounts_os, struct regcount *);\n \n   fprintf (cfile, \"#include <stdlib.h>\\n\");\n   fprintf (cfile, \"#include <stdbool.h>\\n\\n\");\n@@ -322,22 +363,33 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n   fprintf (cfile, \"static const struct hsa_kernel_description {\\n\"\n \t   \"  const char *name;\\n\"\n \t   \"  int oacc_dims[3];\\n\"\n+\t   \"  int sgpr_count;\\n\"\n+\t   \"  int vgpr_count;\\n\"\n \t   \"} gcn_kernels[] = {\\n  \");\n   dim.d[0] = dim.d[1] = dim.d[2] = 0;\n   const char *comma;\n   for (comma = \"\", i = 0; i < fn_count; comma = \",\\n  \", i++)\n     {\n       /* Find if we recorded dimensions for this function.  */\n       int *d = dim.d;\t\t/* Previously zeroed.  */\n+      int sgpr_count = 0;\n+      int vgpr_count = 0;\n       for (int j = 0; j < dims_count; j++)\n \tif (strcmp (fns[i], dims[j].name) == 0)\n \t  {\n \t    d = dims[j].d;\n \t    break;\n \t  }\n+      for (int j = 0; j < regcount_count; j++)\n+\tif (strcmp (fns[i], regcounts[j].kernel_name) == 0)\n+\t  {\n+\t    sgpr_count = regcounts[j].sgpr_count;\n+\t    vgpr_count = regcounts[j].vgpr_count;\n+\t    break;\n+\t  }\n \n-      fprintf (cfile, \"%s{\\\"%s\\\", {%d, %d, %d}}\", comma,\n-\t       fns[i], d[0], d[1], d[2]);\n+      fprintf (cfile, \"%s{\\\"%s\\\", {%d, %d, %d}, %d, %d}\", comma,\n+\t       fns[i], d[0], d[1], d[2], sgpr_count, vgpr_count);\n \n       free (fns[i]);\n     }\n@@ -346,7 +398,10 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n   obstack_free (&fns_os, NULL);\n   for (i = 0; i < dims_count; i++)\n     free (dims[i].name);\n+  for (i = 0; i < regcount_count; i++)\n+    free (regcounts[i].kernel_name);\n   obstack_free (&dims_os, NULL);\n+  obstack_free (&regcounts_os, NULL);\n }\n \n /* Embed an object file into a C source file.  */"}, {"sha": "557bec34f2f067f8ff451ed53b1f2cf1cfb3b860", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a28e2727f718f14a2afccf16c4dda814af5b6f8/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a28e2727f718f14a2afccf16c4dda814af5b6f8/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=5a28e2727f718f14a2afccf16c4dda814af5b6f8", "patch": "@@ -1,3 +1,13 @@\n+2020-01-31  Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\n+\t* plugin/plugin-gcn.c (struct hsa_kernel_description): Add sgpr_count\n+\tand vgpr_count fields.\n+\t(struct kernel_info): Add a field for a hsa_kernel_description.\n+\t(run_kernel): Reduce the number of threads/workers if the requested\n+\tnumber would require too many VGPRs.\n+\t(init_basic_kernel_info): Initialize description field with\n+\tthe hsa_kernel_description entry for the kernel.\n+\n 2020-01-29  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR bootstrap/93409"}, {"sha": "25547ef12e81b70990d7be246f39be23f97d23f3", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a28e2727f718f14a2afccf16c4dda814af5b6f8/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a28e2727f718f14a2afccf16c4dda814af5b6f8/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=5a28e2727f718f14a2afccf16c4dda814af5b6f8", "patch": "@@ -371,6 +371,8 @@ struct hsa_kernel_description\n {\n   const char *name;\n   int oacc_dims[3];  /* Only present for GCN kernels.  */\n+  int sgpr_count;\n+  int vpgr_count;\n };\n \n /* Mkoffload uses this structure to describe an offload variable.  */\n@@ -478,6 +480,8 @@ struct kernel_info\n   struct agent_info *agent;\n   /* The specific module where the kernel takes place.  */\n   struct module_info *module;\n+  /* Information provided by mkoffload associated with the kernel.  */\n+  struct hsa_kernel_description *description;\n   /* Mutex enforcing that at most once thread ever initializes a kernel for\n      use.  A thread should have locked agent->module_rwlock for reading before\n      acquiring it.  */\n@@ -2102,6 +2106,24 @@ run_kernel (struct kernel_info *kernel, void *vars,\n \t    struct GOMP_kernel_launch_attributes *kla,\n \t    struct goacc_asyncqueue *aq, bool module_locked)\n {\n+  GCN_DEBUG (\"SGPRs: %d, VGPRs: %d\\n\", kernel->description->sgpr_count,\n+\t     kernel->description->vpgr_count);\n+\n+  /* Reduce the number of threads/workers if there are insufficient\n+     VGPRs available to run the kernels together.  */\n+  if (kla->ndim == 3 && kernel->description->vpgr_count > 0)\n+    {\n+      int granulated_vgprs = (kernel->description->vpgr_count + 3) & ~3;\n+      int max_threads = (256 / granulated_vgprs) * 4;\n+      if (kla->gdims[2] > max_threads)\n+\t{\n+\t  GCN_WARNING (\"Too many VGPRs required to support %d threads/workers\"\n+\t\t       \" per team/gang - reducing to %d threads/workers.\\n\",\n+\t\t       kla->gdims[2], max_threads);\n+\t  kla->gdims[2] = max_threads;\n+\t}\n+    }\n+\n   GCN_DEBUG (\"GCN launch on queue: %d:%d\\n\", kernel->agent->device_id,\n \t     (aq ? aq->id : 0));\n   GCN_DEBUG (\"GCN launch attribs: gdims:[\");\n@@ -2303,6 +2325,7 @@ init_basic_kernel_info (struct kernel_info *kernel,\n   kernel->agent = agent;\n   kernel->module = module;\n   kernel->name = d->name;\n+  kernel->description = d;\n   if (pthread_mutex_init (&kernel->init_mutex, NULL))\n     {\n       GOMP_PLUGIN_error (\"Failed to initialize a GCN kernel mutex\");"}]}