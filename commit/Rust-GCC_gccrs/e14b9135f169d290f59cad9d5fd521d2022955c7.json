{"sha": "e14b9135f169d290f59cad9d5fd521d2022955c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE0YjkxMzVmMTY5ZDI5MGY1OWNhZDlkNWZkNTIxZDIwMjI5NTVjNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-01T19:18:56Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-01T19:18:56Z"}, "message": "compiler: Use backend interface for heap expressions.\n\nFrom-SVN: r209983", "tree": {"sha": "c8f2e8aa8863578dafa94ae1aed58c20613f5004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8f2e8aa8863578dafa94ae1aed58c20613f5004"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e14b9135f169d290f59cad9d5fd521d2022955c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14b9135f169d290f59cad9d5fd521d2022955c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e14b9135f169d290f59cad9d5fd521d2022955c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14b9135f169d290f59cad9d5fd521d2022955c7/comments", "author": null, "committer": null, "parents": [{"sha": "b6799f373ac288dc5de71240a13488e9e3530f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6799f373ac288dc5de71240a13488e9e3530f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6799f373ac288dc5de71240a13488e9e3530f2a"}], "stats": {"total": 52, "additions": 29, "deletions": 23}, "files": [{"sha": "275bee53e0d185a3452487ad681e2309cd17fb7d", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14b9135f169d290f59cad9d5fd521d2022955c7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14b9135f169d290f59cad9d5fd521d2022955c7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e14b9135f169d290f59cad9d5fd521d2022955c7", "patch": "@@ -13798,30 +13798,31 @@ class Heap_expression : public Expression\n tree\n Heap_expression::do_get_tree(Translate_context* context)\n {\n-  tree expr_tree = this->expr_->get_tree(context);\n-  if (expr_tree == error_mark_node || TREE_TYPE(expr_tree) == error_mark_node)\n+  if (this->expr_->is_error_expression() || this->expr_->type()->is_error())\n     return error_mark_node;\n \n-  Expression* alloc =\n-      Expression::make_allocation(this->expr_->type(), this->location());\n-\n+  Location loc = this->location();\n   Gogo* gogo = context->gogo();\n-  Btype* btype = this->expr_->type()->get_backend(gogo);\n-  size_t expr_size = gogo->backend()->type_size(btype);\n-  tree space = alloc->get_tree(context);\n-  if (expr_size == 0)\n-    return space;\n-\n-  space = save_expr(space);\n-  tree ref = build_fold_indirect_ref_loc(this->location().gcc_location(),\n-                                         space);\n-  TREE_THIS_NOTRAP(ref) = 1;\n-  tree ret = build2(COMPOUND_EXPR,\n-                    type_to_tree(this->type()->get_backend(gogo)),\n-\t\t    build2(MODIFY_EXPR, void_type_node, ref, expr_tree),\n-\t\t    space);\n-  SET_EXPR_LOCATION(ret, this->location().gcc_location());\n-  return ret;\n+  Btype* btype = this->type()->get_backend(gogo);\n+  Expression* alloc = Expression::make_allocation(this->expr_->type(), loc);\n+  Bexpression* space = tree_to_expr(alloc->get_tree(context));\n+\n+  Bstatement* decl;\n+  Named_object* fn = context->function();\n+  go_assert(fn != NULL);\n+  Bfunction* fndecl = fn->func_value()->get_or_make_decl(gogo, fn);\n+  Bvariable* space_temp =\n+    gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n+\t\t\t\t\tspace, true, loc, &decl);\n+  space = gogo->backend()->var_expression(space_temp, loc);\n+  Bexpression* ref = gogo->backend()->indirect_expression(space, true, loc);\n+\n+  Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n+  Bstatement* assn = gogo->backend()->assignment_statement(ref, bexpr, loc);\n+  decl = gogo->backend()->compound_statement(decl, assn);\n+  space = gogo->backend()->var_expression(space_temp, loc);\n+  Bexpression* ret = gogo->backend()->compound_expression(decl, space, loc);\n+  return expr_to_tree(ret);\n }\n \n // Dump ast representation for a heap expression."}, {"sha": "ab54f8491e3c56a17b422b97eef25eaae55cfe0a", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14b9135f169d290f59cad9d5fd521d2022955c7/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14b9135f169d290f59cad9d5fd521d2022955c7/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=e14b9135f169d290f59cad9d5fd521d2022955c7", "patch": "@@ -1147,8 +1147,6 @@ Gogo::write_globals()\n           Bstatement* var_init_stmt = NULL;\n \t  if (!var->has_pre_init())\n \t    {\n-              Bexpression* var_binit = var->get_init(this, NULL);\n-\n               // If the backend representation of the variable initializer is\n               // constant, we can just set the initial value using\n               // global_var_set_init instead of during the init() function.\n@@ -1168,6 +1166,13 @@ Gogo::write_globals()\n                       init_cast->is_immutable() && !var_type->has_pointer();\n                 }\n \n+\t      // Non-constant variable initializations might need to create\n+\t      // temporary variables, which will need the initialization\n+\t      // function as context.\n+              if (!is_constant_initializer && init_fndecl == NULL)\n+\t\tinit_fndecl = this->initialization_function_decl();\n+              Bexpression* var_binit = var->get_init(this, init_fndecl);\n+\n               if (var_binit == NULL)\n \t\t;\n \t      else if (is_constant_initializer)"}]}