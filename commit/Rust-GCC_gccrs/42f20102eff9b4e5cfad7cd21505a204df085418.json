{"sha": "42f20102eff9b4e5cfad7cd21505a204df085418", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmMjAxMDJlZmY5YjRlNWNmYWQ3Y2QyMTUwNWEyMDRkZjA4NTQxOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-27T15:01:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-27T15:01:57Z"}, "message": "libgo: update to go1.8rc3\n    \n    Reviewed-on: https://go-review.googlesource.com/35844\n\nFrom-SVN: r244981", "tree": {"sha": "a9cbfe963d60748568459d9a15c3c4c1086bdac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9cbfe963d60748568459d9a15c3c4c1086bdac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42f20102eff9b4e5cfad7cd21505a204df085418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f20102eff9b4e5cfad7cd21505a204df085418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42f20102eff9b4e5cfad7cd21505a204df085418", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42f20102eff9b4e5cfad7cd21505a204df085418/comments", "author": null, "committer": null, "parents": [{"sha": "3f54004b095d1cd513e63753ee0f8f9f13698347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f54004b095d1cd513e63753ee0f8f9f13698347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f54004b095d1cd513e63753ee0f8f9f13698347"}], "stats": {"total": 481, "additions": 389, "deletions": 92}, "files": [{"sha": "fa155a238d6430621f1717ffb5026c5f195b7b10", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -1,4 +1,4 @@\n-59f181b6fda68ece22882945853ca2df9dbf1c88\n+2a5f65a98ca483aad2dd74dc2636a7baecc59cf2\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "8b33af3b6b0b4dc095a289b1ca5eaac196d96c3b", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -1 +1 @@\n-go1.8rc2\n+go1.8rc3"}, {"sha": "f26c3660e4b809a1ea76d13b4d1a2176fdf419d4", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -3787,3 +3787,26 @@ GLOBL \u00b7constants<>(SB),8,$8\n \ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n \ttg.run(\"build\", \"p\")\n }\n+\n+// Issue 18778.\n+func TestDotDotDotOutsideGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.tempFile(\"pkgs/a.go\", `package x`)\n+\ttg.tempFile(\"pkgs/a_test.go\", `package x_test\n+import \"testing\"\n+func TestX(t *testing.T) {}`)\n+\n+\ttg.tempFile(\"pkgs/a/a.go\", `package a`)\n+\ttg.tempFile(\"pkgs/a/a_test.go\", `package a_test\n+import \"testing\"\n+func TestA(t *testing.T) {}`)\n+\n+\ttg.cd(tg.path(\"pkgs\"))\n+\ttg.run(\"build\", \"./...\")\n+\ttg.run(\"test\", \"./...\")\n+\ttg.run(\"list\", \"./...\")\n+\ttg.grepStdout(\"pkgs$\", \"expected package not listed\")\n+\ttg.grepStdout(\"pkgs/a\", \"expected package not listed\")\n+}"}, {"sha": "61c1b9960ead782fe75cd592427472da62caaab5", "filename": "libgo/go/cmd/go/pkg.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -433,7 +433,7 @@ func setErrorPos(p *Package, importPos []token.Position) *Package {\n func cleanImport(path string) string {\n \torig := path\n \tpath = pathpkg.Clean(path)\n-\tif strings.HasPrefix(orig, \"./\") && path != \"..\" && path != \".\" && !strings.HasPrefix(path, \"../\") {\n+\tif strings.HasPrefix(orig, \"./\") && path != \"..\" && !strings.HasPrefix(path, \"../\") {\n \t\tpath = \"./\" + path\n \t}\n \treturn path"}, {"sha": "feb91223a9e9b99f48fa65e041afd6f7d309e791", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -1357,16 +1357,7 @@ func (db *DB) begin(ctx context.Context, opts *TxOptions, strategy connReuseStra\n \t\tcancel: cancel,\n \t\tctx:    ctx,\n \t}\n-\tgo func(tx *Tx) {\n-\t\tselect {\n-\t\tcase <-tx.ctx.Done():\n-\t\t\tif !tx.isDone() {\n-\t\t\t\t// Discard and close the connection used to ensure the transaction\n-\t\t\t\t// is closed and the resources are released.\n-\t\t\t\ttx.rollback(true)\n-\t\t\t}\n-\t\t}\n-\t}(tx)\n+\tgo tx.awaitDone()\n \treturn tx, nil\n }\n \n@@ -1388,6 +1379,11 @@ func (db *DB) Driver() driver.Driver {\n type Tx struct {\n \tdb *DB\n \n+\t// closemu prevents the transaction from closing while there\n+\t// is an active query. It is held for read during queries\n+\t// and exclusively during close.\n+\tclosemu sync.RWMutex\n+\n \t// dc is owned exclusively until Commit or Rollback, at which point\n \t// it's returned with putConn.\n \tdc  *driverConn\n@@ -1413,6 +1409,20 @@ type Tx struct {\n \tctx context.Context\n }\n \n+// awaitDone blocks until the context in Tx is canceled and rolls back\n+// the transaction if it's not already done.\n+func (tx *Tx) awaitDone() {\n+\t// Wait for either the transaction to be committed or rolled\n+\t// back, or for the associated context to be closed.\n+\t<-tx.ctx.Done()\n+\n+\t// Discard and close the connection used to ensure the\n+\t// transaction is closed and the resources are released.  This\n+\t// rollback does nothing if the transaction has already been\n+\t// committed or rolled back.\n+\ttx.rollback(true)\n+}\n+\n func (tx *Tx) isDone() bool {\n \treturn atomic.LoadInt32(&tx.done) != 0\n }\n@@ -1424,16 +1434,31 @@ var ErrTxDone = errors.New(\"sql: Transaction has already been committed or rolle\n // close returns the connection to the pool and\n // must only be called by Tx.rollback or Tx.Commit.\n func (tx *Tx) close(err error) {\n+\ttx.closemu.Lock()\n+\tdefer tx.closemu.Unlock()\n+\n \ttx.db.putConn(tx.dc, err)\n \ttx.cancel()\n \ttx.dc = nil\n \ttx.txi = nil\n }\n \n+// hookTxGrabConn specifies an optional hook to be called on\n+// a successful call to (*Tx).grabConn. For tests.\n+var hookTxGrabConn func()\n+\n func (tx *Tx) grabConn(ctx context.Context) (*driverConn, error) {\n+\tselect {\n+\tdefault:\n+\tcase <-ctx.Done():\n+\t\treturn nil, ctx.Err()\n+\t}\n \tif tx.isDone() {\n \t\treturn nil, ErrTxDone\n \t}\n+\tif hookTxGrabConn != nil { // test hook\n+\t\thookTxGrabConn()\n+\t}\n \treturn tx.dc, nil\n }\n \n@@ -1503,6 +1528,9 @@ func (tx *Tx) Rollback() error {\n // for the execution of the returned statement. The returned statement\n // will run in the transaction context.\n func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error) {\n+\ttx.closemu.RLock()\n+\tdefer tx.closemu.RUnlock()\n+\n \t// TODO(bradfitz): We could be more efficient here and either\n \t// provide a method to take an existing Stmt (created on\n \t// perhaps a different Conn), and re-create it on this Conn if\n@@ -1567,6 +1595,9 @@ func (tx *Tx) Prepare(query string) (*Stmt, error) {\n // The returned statement operates within the transaction and will be closed\n // when the transaction has been committed or rolled back.\n func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt {\n+\ttx.closemu.RLock()\n+\tdefer tx.closemu.RUnlock()\n+\n \t// TODO(bradfitz): optimize this. Currently this re-prepares\n \t// each time. This is fine for now to illustrate the API but\n \t// we should really cache already-prepared statements\n@@ -1618,6 +1649,9 @@ func (tx *Tx) Stmt(stmt *Stmt) *Stmt {\n // ExecContext executes a query that doesn't return rows.\n // For example: an INSERT and UPDATE.\n func (tx *Tx) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error) {\n+\ttx.closemu.RLock()\n+\tdefer tx.closemu.RUnlock()\n+\n \tdc, err := tx.grabConn(ctx)\n \tif err != nil {\n \t\treturn nil, err\n@@ -1661,6 +1695,9 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \n // QueryContext executes a query that returns rows, typically a SELECT.\n func (tx *Tx) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error) {\n+\ttx.closemu.RLock()\n+\tdefer tx.closemu.RUnlock()\n+\n \tdc, err := tx.grabConn(ctx)\n \tif err != nil {\n \t\treturn nil, err\n@@ -2038,25 +2075,21 @@ type Rows struct {\n \t// closed value is 1 when the Rows is closed.\n \t// Use atomic operations on value when checking value.\n \tclosed    int32\n-\tctxClose  chan struct{} // closed when Rows is closed, may be null.\n+\tcancel    func() // called when Rows is closed, may be nil.\n \tlastcols  []driver.Value\n \tlasterr   error       // non-nil only if closed is true\n \tcloseStmt *driverStmt // if non-nil, statement to Close on close\n }\n \n func (rs *Rows) initContextClose(ctx context.Context) {\n-\tif ctx.Done() == context.Background().Done() {\n-\t\treturn\n-\t}\n+\tctx, rs.cancel = context.WithCancel(ctx)\n+\tgo rs.awaitDone(ctx)\n+}\n \n-\trs.ctxClose = make(chan struct{})\n-\tgo func() {\n-\t\tselect {\n-\t\tcase <-ctx.Done():\n-\t\t\trs.Close()\n-\t\tcase <-rs.ctxClose:\n-\t\t}\n-\t}()\n+// awaitDone blocks until the rows are closed or the context canceled.\n+func (rs *Rows) awaitDone(ctx context.Context) {\n+\t<-ctx.Done()\n+\trs.Close()\n }\n \n // Next prepares the next result row for reading with the Scan method. It\n@@ -2314,7 +2347,9 @@ func (rs *Rows) Scan(dest ...interface{}) error {\n \treturn nil\n }\n \n-var rowsCloseHook func(*Rows, *error)\n+// rowsCloseHook returns a function so tests may install the\n+// hook throug a test only mutex.\n+var rowsCloseHook = func() func(*Rows, *error) { return nil }\n \n func (rs *Rows) isClosed() bool {\n \treturn atomic.LoadInt32(&rs.closed) != 0\n@@ -2328,13 +2363,15 @@ func (rs *Rows) Close() error {\n \tif !atomic.CompareAndSwapInt32(&rs.closed, 0, 1) {\n \t\treturn nil\n \t}\n-\tif rs.ctxClose != nil {\n-\t\tclose(rs.ctxClose)\n-\t}\n+\n \terr := rs.rowsi.Close()\n-\tif fn := rowsCloseHook; fn != nil {\n+\tif fn := rowsCloseHook(); fn != nil {\n \t\tfn(rs, &err)\n \t}\n+\tif rs.cancel != nil {\n+\t\trs.cancel()\n+\t}\n+\n \tif rs.closeStmt != nil {\n \t\trs.closeStmt.Close()\n \t}"}, {"sha": "898df3b455b22cac915bdb19510cc9ba22f83cbe", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 99, "deletions": 24, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"runtime\"\n \t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -326,9 +327,7 @@ func TestQueryContext(t *testing.T) {\n \n \t// And verify that the final rows.Next() call, which hit EOF,\n \t// also closed the rows connection.\n-\tif n := db.numFreeConns(); n != 1 {\n-\t\tt.Fatalf(\"free conns after query hitting EOF = %d; want 1\", n)\n-\t}\n+\twaitForFree(t, db, 5*time.Second, 1)\n \tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n \t\tt.Errorf(\"executed %d Prepare statements; want 1\", prepares)\n \t}\n@@ -345,6 +344,18 @@ func waitCondition(waitFor, checkEvery time.Duration, fn func() bool) bool {\n \treturn false\n }\n \n+// waitForFree checks db.numFreeConns until either it equals want or\n+// the maxWait time elapses.\n+func waitForFree(t *testing.T, db *DB, maxWait time.Duration, want int) {\n+\tvar numFree int\n+\tif !waitCondition(maxWait, 5*time.Millisecond, func() bool {\n+\t\tnumFree = db.numFreeConns()\n+\t\treturn numFree == want\n+\t}) {\n+\t\tt.Fatalf(\"free conns after hitting EOF = %d; want %d\", numFree, want)\n+\t}\n+}\n+\n func TestQueryContextWait(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n \tdefer closeDB(t, db)\n@@ -361,9 +372,7 @@ func TestQueryContextWait(t *testing.T) {\n \t}\n \n \t// Verify closed rows connection after error condition.\n-\tif n := db.numFreeConns(); n != 1 {\n-\t\tt.Fatalf(\"free conns after query hitting EOF = %d; want 1\", n)\n-\t}\n+\twaitForFree(t, db, 5*time.Second, 1)\n \tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n \t\tt.Errorf(\"executed %d Prepare statements; want 1\", prepares)\n \t}\n@@ -388,13 +397,7 @@ func TestTxContextWait(t *testing.T) {\n \t\tt.Fatalf(\"expected QueryContext to error with context deadline exceeded but returned %v\", err)\n \t}\n \n-\tvar numFree int\n-\tif !waitCondition(5*time.Second, 5*time.Millisecond, func() bool {\n-\t\tnumFree = db.numFreeConns()\n-\t\treturn numFree == 0\n-\t}) {\n-\t\tt.Fatalf(\"free conns after hitting EOF = %d; want 0\", numFree)\n-\t}\n+\twaitForFree(t, db, 5*time.Second, 0)\n \n \t// Ensure the dropped connection allows more connections to be made.\n \t// Checked on DB Close.\n@@ -471,9 +474,7 @@ func TestMultiResultSetQuery(t *testing.T) {\n \n \t// And verify that the final rows.Next() call, which hit EOF,\n \t// also closed the rows connection.\n-\tif n := db.numFreeConns(); n != 1 {\n-\t\tt.Fatalf(\"free conns after query hitting EOF = %d; want 1\", n)\n-\t}\n+\twaitForFree(t, db, 5*time.Second, 1)\n \tif prepares := numPrepares(t, db) - prepares0; prepares != 1 {\n \t\tt.Errorf(\"executed %d Prepare statements; want 1\", prepares)\n \t}\n@@ -1135,6 +1136,24 @@ func TestQueryRowClosingStmt(t *testing.T) {\n \t}\n }\n \n+var atomicRowsCloseHook atomic.Value // of func(*Rows, *error)\n+\n+func init() {\n+\trowsCloseHook = func() func(*Rows, *error) {\n+\t\tfn, _ := atomicRowsCloseHook.Load().(func(*Rows, *error))\n+\t\treturn fn\n+\t}\n+}\n+\n+func setRowsCloseHook(fn func(*Rows, *error)) {\n+\tif fn == nil {\n+\t\t// Can't change an atomic.Value back to nil, so set it to this\n+\t\t// no-op func instead.\n+\t\tfn = func(*Rows, *error) {}\n+\t}\n+\tatomicRowsCloseHook.Store(fn)\n+}\n+\n // Test issue 6651\n func TestIssue6651(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n@@ -1147,17 +1166,18 @@ func TestIssue6651(t *testing.T) {\n \t\treturn fmt.Errorf(want)\n \t}\n \tdefer func() { rowsCursorNextHook = nil }()\n+\n \terr := db.QueryRow(\"SELECT|people|name|\").Scan(&v)\n \tif err == nil || err.Error() != want {\n \t\tt.Errorf(\"error = %q; want %q\", err, want)\n \t}\n \trowsCursorNextHook = nil\n \n \twant = \"error in rows.Close\"\n-\trowsCloseHook = func(rows *Rows, err *error) {\n+\tsetRowsCloseHook(func(rows *Rows, err *error) {\n \t\t*err = fmt.Errorf(want)\n-\t}\n-\tdefer func() { rowsCloseHook = nil }()\n+\t})\n+\tdefer setRowsCloseHook(nil)\n \terr = db.QueryRow(\"SELECT|people|name|\").Scan(&v)\n \tif err == nil || err.Error() != want {\n \t\tt.Errorf(\"error = %q; want %q\", err, want)\n@@ -1830,7 +1850,9 @@ func TestStmtCloseDeps(t *testing.T) {\n \t\tdb.dumpDeps(t)\n \t}\n \n-\tif len(stmt.css) > nquery {\n+\tif !waitCondition(5*time.Second, 5*time.Millisecond, func() bool {\n+\t\treturn len(stmt.css) <= nquery\n+\t}) {\n \t\tt.Errorf(\"len(stmt.css) = %d; want <= %d\", len(stmt.css), nquery)\n \t}\n \n@@ -2576,10 +2598,10 @@ func TestIssue6081(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\trowsCloseHook = func(rows *Rows, err *error) {\n+\tsetRowsCloseHook(func(rows *Rows, err *error) {\n \t\t*err = driver.ErrBadConn\n-\t}\n-\tdefer func() { rowsCloseHook = nil }()\n+\t})\n+\tdefer setRowsCloseHook(nil)\n \tfor i := 0; i < 10; i++ {\n \t\trows, err := stmt.Query()\n \t\tif err != nil {\n@@ -2642,7 +2664,10 @@ func TestIssue18429(t *testing.T) {\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}\n-\t\t\trows, err := tx.QueryContext(ctx, \"WAIT|\"+qwait+\"|SELECT|people|name|\")\n+\t\t\t// This is expected to give a cancel error many, but not all the time.\n+\t\t\t// Test failure will happen with a panic or other race condition being\n+\t\t\t// reported.\n+\t\t\trows, _ := tx.QueryContext(ctx, \"WAIT|\"+qwait+\"|SELECT|people|name|\")\n \t\t\tif rows != nil {\n \t\t\t\trows.Close()\n \t\t\t}\n@@ -2655,6 +2680,56 @@ func TestIssue18429(t *testing.T) {\n \ttime.Sleep(milliWait * 3 * time.Millisecond)\n }\n \n+// TestIssue18719 closes the context right before use. The sql.driverConn\n+// will nil out the ci on close in a lock, but if another process uses it right after\n+// it will panic with on the nil ref.\n+//\n+// See https://golang.org/cl/35550 .\n+func TestIssue18719(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tdefer cancel()\n+\n+\ttx, err := db.BeginTx(ctx, nil)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\thookTxGrabConn = func() {\n+\t\tcancel()\n+\n+\t\t// Wait for the context to cancel and tx to rollback.\n+\t\tfor tx.isDone() == false {\n+\t\t\ttime.Sleep(time.Millisecond * 3)\n+\t\t}\n+\t}\n+\tdefer func() { hookTxGrabConn = nil }()\n+\n+\t// This call will grab the connection and cancel the context\n+\t// after it has done so. Code after must deal with the canceled state.\n+\trows, err := tx.QueryContext(ctx, \"SELECT|people|name|\")\n+\tif err != nil {\n+\t\trows.Close()\n+\t\tt.Fatalf(\"expected error %v but got %v\", nil, err)\n+\t}\n+\n+\t// Rows may be ignored because it will be closed when the context is canceled.\n+\n+\t// Do not explicitly rollback. The rollback will happen from the\n+\t// canceled context.\n+\n+\t// Wait for connections to return to pool.\n+\tvar numOpen int\n+\tif !waitCondition(5*time.Second, 5*time.Millisecond, func() bool {\n+\t\tnumOpen = db.numOpenConns()\n+\t\treturn numOpen == 0\n+\t}) {\n+\t\tt.Fatalf(\"open conns after hitting EOF = %d; want 0\", numOpen)\n+\t}\n+}\n+\n func TestConcurrency(t *testing.T) {\n \tdoConcurrentTest(t, new(concurrentDBQueryTest))\n \tdoConcurrentTest(t, new(concurrentDBExecTest))"}, {"sha": "ea432860a8e5ac2b159b48fbb8941182108fec00", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -733,7 +733,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int) {\n \n \tcase *ast.FuncLit:\n \t\tp.expr(x.Type)\n-\t\tp.adjBlock(p.distanceFrom(x.Type.Pos()), blank, x.Body)\n+\t\tp.funcBody(p.distanceFrom(x.Type.Pos()), blank, x.Body)\n \n \tcase *ast.ParenExpr:\n \t\tif _, hasParens := x.X.(*ast.ParenExpr); hasParens {\n@@ -825,6 +825,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int) {\n \t\tif x.Type != nil {\n \t\t\tp.expr1(x.Type, token.HighestPrec, depth)\n \t\t}\n+\t\tp.level++\n \t\tp.print(x.Lbrace, token.LBRACE)\n \t\tp.exprList(x.Lbrace, x.Elts, 1, commaTerm, x.Rbrace)\n \t\t// do not insert extra line break following a /*-style comment\n@@ -837,6 +838,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int) {\n \t\t\tmode |= noExtraBlank\n \t\t}\n \t\tp.print(mode, x.Rbrace, token.RBRACE, mode)\n+\t\tp.level--\n \n \tcase *ast.Ellipsis:\n \t\tp.print(token.ELLIPSIS)\n@@ -1557,18 +1559,23 @@ func (p *printer) bodySize(b *ast.BlockStmt, maxSize int) int {\n \treturn bodySize\n }\n \n-// adjBlock prints an \"adjacent\" block (e.g., a for-loop or function body) following\n-// a header (e.g., a for-loop control clause or function signature) of given headerSize.\n+// funcBody prints a function body following a function header of given headerSize.\n // If the header's and block's size are \"small enough\" and the block is \"simple enough\",\n // the block is printed on the current line, without line breaks, spaced from the header\n // by sep. Otherwise the block's opening \"{\" is printed on the current line, followed by\n // lines for the block's statements and its closing \"}\".\n //\n-func (p *printer) adjBlock(headerSize int, sep whiteSpace, b *ast.BlockStmt) {\n+func (p *printer) funcBody(headerSize int, sep whiteSpace, b *ast.BlockStmt) {\n \tif b == nil {\n \t\treturn\n \t}\n \n+\t// save/restore composite literal nesting level\n+\tdefer func(level int) {\n+\t\tp.level = level\n+\t}(p.level)\n+\tp.level = 0\n+\n \tconst maxSize = 100\n \tif headerSize+p.bodySize(b, maxSize) <= maxSize {\n \t\tp.print(sep, b.Lbrace, token.LBRACE)\n@@ -1613,7 +1620,7 @@ func (p *printer) funcDecl(d *ast.FuncDecl) {\n \t}\n \tp.expr(d.Name)\n \tp.signature(d.Type.Params, d.Type.Results)\n-\tp.adjBlock(p.distanceFrom(d.Pos()), vtab, d.Body)\n+\tp.funcBody(p.distanceFrom(d.Pos()), vtab, d.Body)\n }\n \n func (p *printer) decl(decl ast.Decl) {"}, {"sha": "be61dad590eea02012364ae32c9c602d256f9c11", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -58,6 +58,7 @@ type printer struct {\n \t// Current state\n \toutput      []byte       // raw printer result\n \tindent      int          // current indentation\n+\tlevel       int          // level == 0: outside composite literal; level > 0: inside composite literal\n \tmode        pmode        // current printer mode\n \timpliedSemi bool         // if set, a linebreak implies a semicolon\n \tlastTok     token.Token  // last token printed (token.ILLEGAL if it's whitespace)\n@@ -744,15 +745,19 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (wro\n \t\t// follows on the same line but is not a comma, and not a \"closing\"\n \t\t// token immediately following its corresponding \"opening\" token,\n \t\t// add an extra separator unless explicitly disabled. Use a blank\n-\t\t// as separator unless we have pending linebreaks and they are not\n-\t\t// disabled, in which case we want a linebreak (issue 15137).\n+\t\t// as separator unless we have pending linebreaks, they are not\n+\t\t// disabled, and we are outside a composite literal, in which case\n+\t\t// we want a linebreak (issue 15137).\n+\t\t// TODO(gri) This has become overly complicated. We should be able\n+\t\t// to track whether we're inside an expression or statement and\n+\t\t// use that information to decide more directly.\n \t\tneedsLinebreak := false\n \t\tif p.mode&noExtraBlank == 0 &&\n \t\t\tlast.Text[1] == '*' && p.lineFor(last.Pos()) == next.Line &&\n \t\t\ttok != token.COMMA &&\n \t\t\t(tok != token.RPAREN || p.prevOpen == token.LPAREN) &&\n \t\t\t(tok != token.RBRACK || p.prevOpen == token.LBRACK) {\n-\t\t\tif p.containsLinebreak() && p.mode&noExtraLinebreak == 0 {\n+\t\t\tif p.containsLinebreak() && p.mode&noExtraLinebreak == 0 && p.level == 0 {\n \t\t\t\tneedsLinebreak = true\n \t\t\t} else {\n \t\t\t\tp.writeByte(' ', 1)"}, {"sha": "8b3a94ddcd03a0ac75ab7e6c2bbfa5dbb88c2b95", "filename": "libgo/go/go/printer/testdata/comments2.golden", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.golden?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -103,3 +103,62 @@ label:\n \tmask := uint64(1)<<c - 1\t\t// Allocation mask\n \tused := atomic.LoadUint64(&h.used)\t// Current allocations\n }\n+\n+// Test cases for issue 18782\n+var _ = [][]int{\n+\t/*       a, b, c, d, e */\n+\t/* a */ {0, 0, 0, 0, 0},\n+\t/* b */ {0, 5, 4, 4, 4},\n+\t/* c */ {0, 4, 5, 4, 4},\n+\t/* d */ {0, 4, 4, 5, 4},\n+\t/* e */ {0, 4, 4, 4, 5},\n+}\n+\n+var _ = T{ /* a */ 0}\n+\n+var _ = T{ /* a */ /* b */ 0}\n+\n+var _ = T{\t/* a */\t/* b */\n+\t/* c */ 0,\n+}\n+\n+var _ = T{\t/* a */\t/* b */\n+\t/* c */\n+\t/* d */ 0,\n+}\n+\n+var _ = T{\n+\t/* a */\n+\t/* b */ 0,\n+}\n+\n+var _ = T{ /* a */ {}}\n+\n+var _ = T{ /* a */ /* b */ {}}\n+\n+var _ = T{\t/* a */\t/* b */\n+\t/* c */ {},\n+}\n+\n+var _ = T{\t/* a */\t/* b */\n+\t/* c */\n+\t/* d */ {},\n+}\n+\n+var _ = T{\n+\t/* a */\n+\t/* b */ {},\n+}\n+\n+var _ = []T{\n+\tfunc() {\n+\t\tvar _ = [][]int{\n+\t\t\t/*       a, b, c, d, e */\n+\t\t\t/* a */ {0, 0, 0, 0, 0},\n+\t\t\t/* b */ {0, 5, 4, 4, 4},\n+\t\t\t/* c */ {0, 4, 5, 4, 4},\n+\t\t\t/* d */ {0, 4, 4, 5, 4},\n+\t\t\t/* e */ {0, 4, 4, 4, 5},\n+\t\t}\n+\t},\n+}"}, {"sha": "8d38c4194bbcd73e3ba0f58d59775edfa09b6501", "filename": "libgo/go/go/printer/testdata/comments2.input", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fcomments2.input?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -103,3 +103,66 @@ label:\n    mask := uint64(1)<<c - 1 // Allocation mask\n    used := atomic.LoadUint64(&h.used) // Current allocations\n }\n+\n+// Test cases for issue 18782\n+var _ = [][]int{\n+   /*       a, b, c, d, e */\n+   /* a */ {0, 0, 0, 0, 0},\n+   /* b */ {0, 5, 4, 4, 4},\n+   /* c */ {0, 4, 5, 4, 4},\n+   /* d */ {0, 4, 4, 5, 4},\n+   /* e */ {0, 4, 4, 4, 5},\n+}\n+\n+var _ = T{ /* a */ 0,\n+}\n+\n+var _ = T{ /* a */ /* b */ 0,\n+}\n+\n+var _ = T{ /* a */ /* b */\n+   /* c */ 0,\n+}\n+\n+var _ = T{ /* a */ /* b */\n+   /* c */\n+   /* d */ 0,\n+}\n+\n+var _ = T{\n+   /* a */\n+   /* b */ 0,\n+}\n+\n+var _ = T{ /* a */ {},\n+}\n+\n+var _ = T{ /* a */ /* b */ {},\n+}\n+\n+var _ = T{ /* a */ /* b */\n+   /* c */ {},\n+}\n+\n+var _ = T{ /* a */ /* b */\n+   /* c */\n+   /* d */ {},\n+}\n+\n+var _ = T{\n+   /* a */\n+   /* b */ {},\n+}\n+\n+var _ = []T{\n+   func() {\n+      var _ = [][]int{\n+         /*       a, b, c, d, e */\n+         /* a */ {0, 0, 0, 0, 0},\n+         /* b */ {0, 5, 4, 4, 4},\n+         /* c */ {0, 4, 5, 4, 4},\n+         /* d */ {0, 4, 4, 5, 4},\n+         /* e */ {0, 4, 4, 4, 5},\n+      }\n+   },\n+}"}, {"sha": "0005538e70bd80ba432489360d1fea76dd62a4df", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -413,11 +413,12 @@ func (c *Client) checkRedirect(req *Request, via []*Request) error {\n \n // redirectBehavior describes what should happen when the\n // client encounters a 3xx status code from the server\n-func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirectMethod string, shouldRedirect bool) {\n+func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirectMethod string, shouldRedirect, includeBody bool) {\n \tswitch resp.StatusCode {\n \tcase 301, 302, 303:\n \t\tredirectMethod = reqMethod\n \t\tshouldRedirect = true\n+\t\tincludeBody = false\n \n \t\t// RFC 2616 allowed automatic redirection only with GET and\n \t\t// HEAD requests. RFC 7231 lifts this restriction, but we still\n@@ -429,6 +430,7 @@ func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirect\n \tcase 307, 308:\n \t\tredirectMethod = reqMethod\n \t\tshouldRedirect = true\n+\t\tincludeBody = true\n \n \t\t// Treat 307 and 308 specially, since they're new in\n \t\t// Go 1.8, and they also require re-sending the request body.\n@@ -449,7 +451,7 @@ func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirect\n \t\t\tshouldRedirect = false\n \t\t}\n \t}\n-\treturn redirectMethod, shouldRedirect\n+\treturn redirectMethod, shouldRedirect, includeBody\n }\n \n // Do sends an HTTP request and returns an HTTP response, following\n@@ -492,11 +494,14 @@ func (c *Client) Do(req *Request) (*Response, error) {\n \t}\n \n \tvar (\n-\t\tdeadline       = c.deadline()\n-\t\treqs           []*Request\n-\t\tresp           *Response\n-\t\tcopyHeaders    = c.makeHeadersCopier(req)\n+\t\tdeadline    = c.deadline()\n+\t\treqs        []*Request\n+\t\tresp        *Response\n+\t\tcopyHeaders = c.makeHeadersCopier(req)\n+\n+\t\t// Redirect behavior:\n \t\tredirectMethod string\n+\t\tincludeBody    bool\n \t)\n \tuerr := func(err error) error {\n \t\treq.closeBody()\n@@ -534,7 +539,7 @@ func (c *Client) Do(req *Request) (*Response, error) {\n \t\t\t\tCancel:   ireq.Cancel,\n \t\t\t\tctx:      ireq.ctx,\n \t\t\t}\n-\t\t\tif ireq.GetBody != nil {\n+\t\t\tif includeBody && ireq.GetBody != nil {\n \t\t\t\treq.Body, err = ireq.GetBody()\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, uerr(err)\n@@ -598,7 +603,7 @@ func (c *Client) Do(req *Request) (*Response, error) {\n \t\t}\n \n \t\tvar shouldRedirect bool\n-\t\tredirectMethod, shouldRedirect = redirectBehavior(req.Method, resp, reqs[0])\n+\t\tredirectMethod, shouldRedirect, includeBody = redirectBehavior(req.Method, resp, reqs[0])\n \t\tif !shouldRedirect {\n \t\t\treturn resp, nil\n \t\t}"}, {"sha": "4f674dd8d6c785ca45b06781f2b2a247344db6ce", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -360,25 +360,25 @@ func TestPostRedirects(t *testing.T) {\n \twantSegments := []string{\n \t\t`POST / \"first\"`,\n \t\t`POST /?code=301&next=302 \"c301\"`,\n-\t\t`GET /?code=302 \"c301\"`,\n-\t\t`GET / \"c301\"`,\n+\t\t`GET /?code=302 \"\"`,\n+\t\t`GET / \"\"`,\n \t\t`POST /?code=302&next=302 \"c302\"`,\n-\t\t`GET /?code=302 \"c302\"`,\n-\t\t`GET / \"c302\"`,\n+\t\t`GET /?code=302 \"\"`,\n+\t\t`GET / \"\"`,\n \t\t`POST /?code=303&next=301 \"c303wc301\"`,\n-\t\t`GET /?code=301 \"c303wc301\"`,\n-\t\t`GET / \"c303wc301\"`,\n+\t\t`GET /?code=301 \"\"`,\n+\t\t`GET / \"\"`,\n \t\t`POST /?code=304 \"c304\"`,\n \t\t`POST /?code=305 \"c305\"`,\n \t\t`POST /?code=307&next=303,308,302 \"c307\"`,\n \t\t`POST /?code=303&next=308,302 \"c307\"`,\n-\t\t`GET /?code=308&next=302 \"c307\"`,\n+\t\t`GET /?code=308&next=302 \"\"`,\n \t\t`GET /?code=302 \"c307\"`,\n-\t\t`GET / \"c307\"`,\n+\t\t`GET / \"\"`,\n \t\t`POST /?code=308&next=302,301 \"c308\"`,\n \t\t`POST /?code=302&next=301 \"c308\"`,\n-\t\t`GET /?code=301 \"c308\"`,\n-\t\t`GET / \"c308\"`,\n+\t\t`GET /?code=301 \"\"`,\n+\t\t`GET / \"\"`,\n \t\t`POST /?code=404 \"c404\"`,\n \t}\n \twant := strings.Join(wantSegments, \"\\n\")\n@@ -399,20 +399,20 @@ func TestDeleteRedirects(t *testing.T) {\n \twantSegments := []string{\n \t\t`DELETE / \"first\"`,\n \t\t`DELETE /?code=301&next=302,308 \"c301\"`,\n-\t\t`GET /?code=302&next=308 \"c301\"`,\n-\t\t`GET /?code=308 \"c301\"`,\n+\t\t`GET /?code=302&next=308 \"\"`,\n+\t\t`GET /?code=308 \"\"`,\n \t\t`GET / \"c301\"`,\n \t\t`DELETE /?code=302&next=302 \"c302\"`,\n-\t\t`GET /?code=302 \"c302\"`,\n-\t\t`GET / \"c302\"`,\n+\t\t`GET /?code=302 \"\"`,\n+\t\t`GET / \"\"`,\n \t\t`DELETE /?code=303 \"c303\"`,\n-\t\t`GET / \"c303\"`,\n+\t\t`GET / \"\"`,\n \t\t`DELETE /?code=307&next=301,308,303,302,304 \"c307\"`,\n \t\t`DELETE /?code=301&next=308,303,302,304 \"c307\"`,\n-\t\t`GET /?code=308&next=303,302,304 \"c307\"`,\n+\t\t`GET /?code=308&next=303,302,304 \"\"`,\n \t\t`GET /?code=303&next=302,304 \"c307\"`,\n-\t\t`GET /?code=302&next=304 \"c307\"`,\n-\t\t`GET /?code=304 \"c307\"`,\n+\t\t`GET /?code=302&next=304 \"\"`,\n+\t\t`GET /?code=304 \"\"`,\n \t\t`DELETE /?code=308&next=307 \"c308\"`,\n \t\t`DELETE /?code=307 \"c308\"`,\n \t\t`DELETE / \"c308\"`,\n@@ -432,7 +432,11 @@ func testRedirectsByMethod(t *testing.T, method string, table []redirectTest, wa\n \tts = httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tlog.Lock()\n \t\tslurp, _ := ioutil.ReadAll(r.Body)\n-\t\tfmt.Fprintf(&log.Buffer, \"%s %s %q\\n\", r.Method, r.RequestURI, slurp)\n+\t\tfmt.Fprintf(&log.Buffer, \"%s %s %q\", r.Method, r.RequestURI, slurp)\n+\t\tif cl := r.Header.Get(\"Content-Length\"); r.Method == \"GET\" && len(slurp) == 0 && (r.ContentLength != 0 || cl != \"\") {\n+\t\t\tfmt.Fprintf(&log.Buffer, \" (but with body=%T, content-length = %v, %q)\", r.Body, r.ContentLength, cl)\n+\t\t}\n+\t\tlog.WriteByte('\\n')\n \t\tlog.Unlock()\n \t\turlQuery := r.URL.Query()\n \t\tif v := urlQuery.Get(\"code\"); v != \"\" {\n@@ -475,7 +479,24 @@ func testRedirectsByMethod(t *testing.T, method string, table []redirectTest, wa\n \twant = strings.TrimSpace(want)\n \n \tif got != want {\n-\t\tt.Errorf(\"Log differs.\\n Got:\\n%s\\nWant:\\n%s\\n\", got, want)\n+\t\tgot, want, lines := removeCommonLines(got, want)\n+\t\tt.Errorf(\"Log differs after %d common lines.\\n\\nGot:\\n%s\\n\\nWant:\\n%s\\n\", lines, got, want)\n+\t}\n+}\n+\n+func removeCommonLines(a, b string) (asuffix, bsuffix string, commonLines int) {\n+\tfor {\n+\t\tnl := strings.IndexByte(a, '\\n')\n+\t\tif nl < 0 {\n+\t\t\treturn a, b, commonLines\n+\t\t}\n+\t\tline := a[:nl+1]\n+\t\tif !strings.HasPrefix(b, line) {\n+\t\t\treturn a, b, commonLines\n+\t\t}\n+\t\tcommonLines++\n+\t\ta = a[len(line):]\n+\t\tb = b[len(line):]\n \t}\n }\n "}, {"sha": "73dd56e8c426562c966aaf56954a06b4655e9517", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -5277,7 +5277,7 @@ func TestServerHijackGetsBackgroundByte_big(t *testing.T) {\n \t\tdefer conn.Close()\n \t\tslurp, err := ioutil.ReadAll(buf.Reader)\n \t\tif err != nil {\n-\t\t\tt.Error(\"Copy: %v\", err)\n+\t\t\tt.Errorf(\"Copy: %v\", err)\n \t\t}\n \t\tallX := true\n \t\tfor _, v := range slurp {"}, {"sha": "bdf0043f12b9033bc60d5a87b60284f8561135a3", "filename": "libgo/merge.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42f20102eff9b4e5cfad7cd21505a204df085418/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=42f20102eff9b4e5cfad7cd21505a204df085418", "patch": "@@ -71,7 +71,9 @@ merge() {\n   elif test -f ${old}; then\n     # The file exists in the old version.\n     if ! test -f ${libgo}; then\n-      echo \"merge.sh: $name: skipping: exists in old and new git, but not in libgo\"\n+      if ! cmp -s ${old} ${new}; then\n+        echo \"merge.sh: $name: skipping: exists in old and new git, but not in libgo\"\n+      fi\n       continue\n     fi\n     if cmp -s ${old} ${libgo}; then"}]}