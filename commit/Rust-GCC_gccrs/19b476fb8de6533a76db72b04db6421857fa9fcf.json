{"sha": "19b476fb8de6533a76db72b04db6421857fa9fcf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTliNDc2ZmI4ZGU2NTMzYTc2ZGI3MmIwNGRiNjQyMTg1N2ZhOWZjZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-17T11:21:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-17T11:21:50Z"}, "message": "class.c (handle_using_decl): Use OVL_FIRST, ovl_iterator.\n\n\t* class.c (handle_using_decl): Use OVL_FIRST, ovl_iterator.\n\t(maybe_warn_about_overly_private_class): Use ovl_iterator.\n\t(method_name_cmp, resort_method_name_cmp): Use OVL_NAME.\n\t(resort_type_method_vec, finish_struct_methods): Use OVL_FIRST.\n\t(get_base_fndecls): Use ovl_iterator.\n\t(warn_hidden): Use OVL_NAME, ovl_iterator.\n\t(add_implicitly_declared_members): Use ovl_iterator.\n\t* constraint.cc (normalize_template_id_expression): Use OVL_FIRST,\n\tflatten nested if.\n\t(finish_shorthand_constraint): Simplify, use ovl_make.\n\t* pt.c (make_constrained_auto): Simplify.  Use ovl_make.\n\t* search.c (shared_member_p): Use ovl_iterator.\n\t(lookup_field_fuzzy_info::fuzzy_lookup_fn): Use OVL_NAME.\n\t(lookup_conversion_operator): Use OVL_FIRST.\n\t(lookup_fnfiels_idx_nolazy): Use OVL_FIRST, OVL_NAME.\n\t(look_for_overrides_here): Use ovl_iterator.\n\t(lookup_conversions_r): Use OVL_FIRST, OVL_NAME, ovl_iterator.\n\t* typeck.c (build_x_unary_op): Use ovl_make.\n\nFrom-SVN: r248144", "tree": {"sha": "042127f3d15deb7b400008fd7dce4637752906c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/042127f3d15deb7b400008fd7dce4637752906c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19b476fb8de6533a76db72b04db6421857fa9fcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b476fb8de6533a76db72b04db6421857fa9fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b476fb8de6533a76db72b04db6421857fa9fcf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b476fb8de6533a76db72b04db6421857fa9fcf/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "142473df8ea4f3ff7ebd480bf827bfb795da6861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/142473df8ea4f3ff7ebd480bf827bfb795da6861", "html_url": "https://github.com/Rust-GCC/gccrs/commit/142473df8ea4f3ff7ebd480bf827bfb795da6861"}], "stats": {"total": 231, "additions": 108, "deletions": 123}, "files": [{"sha": "923e2eac146f7ad80986a28e1e4436b1b49b545c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=19b476fb8de6533a76db72b04db6421857fa9fcf", "patch": "@@ -1,3 +1,24 @@\n+2017-05-17  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* class.c (handle_using_decl): Use OVL_FIRST, ovl_iterator.\n+\t(maybe_warn_about_overly_private_class): Use ovl_iterator.\n+\t(method_name_cmp, resort_method_name_cmp): Use OVL_NAME.\n+\t(resort_type_method_vec, finish_struct_methods): Use OVL_FIRST.\n+\t(get_base_fndecls): Use ovl_iterator.\n+\t(warn_hidden): Use OVL_NAME, ovl_iterator.\n+\t(add_implicitly_declared_members): Use ovl_iterator.\n+\t* constraint.cc (normalize_template_id_expression): Use OVL_FIRST,\n+\tflatten nested if.\n+\t(finish_shorthand_constraint): Simplify, use ovl_make.\n+\t* pt.c (make_constrained_auto): Simplify.  Use ovl_make.\n+\t* search.c (shared_member_p): Use ovl_iterator.\n+\t(lookup_field_fuzzy_info::fuzzy_lookup_fn): Use OVL_NAME.\n+\t(lookup_conversion_operator): Use OVL_FIRST.\n+\t(lookup_fnfiels_idx_nolazy): Use OVL_FIRST, OVL_NAME.\n+\t(look_for_overrides_here): Use ovl_iterator.\n+\t(lookup_conversions_r): Use OVL_FIRST, OVL_NAME, ovl_iterator.\n+\t* typeck.c (build_x_unary_op): Use ovl_make.\n+\n 2017-05-17  Martin Liska  <mliska@suse.cz>\n \n \t* class.c (dump_class_hierarchy): Introduce dump_flags_t type and"}, {"sha": "bda4c103f2a899ba200fe5180e5c7c29bb75669c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=19b476fb8de6533a76db72b04db6421857fa9fcf", "patch": "@@ -1359,7 +1359,7 @@ handle_using_decl (tree using_decl, tree t)\n \t\t\t     tf_warning_or_error);\n   if (old_value)\n     {\n-      old_value = OVL_CURRENT (old_value);\n+      old_value = OVL_FIRST (old_value);\n \n       if (DECL_P (old_value) && DECL_CONTEXT (old_value) == t)\n \t/* OK */;\n@@ -1396,10 +1396,10 @@ handle_using_decl (tree using_decl, tree t)\n \n   /* Make type T see field decl FDECL with access ACCESS.  */\n   if (flist)\n-    for (; flist; flist = OVL_NEXT (flist))\n+    for (ovl_iterator iter (flist); iter; ++iter)\n       {\n-\tadd_method (t, OVL_CURRENT (flist), using_decl);\n-\talter_access (t, OVL_CURRENT (flist), access);\n+\tadd_method (t, *iter, true);\n+\talter_access (t, *iter, access);\n       }\n   else\n     alter_access (t, decl, access);\n@@ -2245,7 +2245,7 @@ maybe_warn_about_overly_private_class (tree t)\n       && (!CLASSTYPE_LAZY_DEFAULT_CTOR (t)\n \t  || !CLASSTYPE_LAZY_COPY_CTOR (t)))\n     {\n-      int nonprivate_ctor = 0;\n+      bool nonprivate_ctor = false;\n \n       /* If a non-template class does not define a copy\n \t constructor, one is defined for it, enabling it to avoid\n@@ -2258,25 +2258,20 @@ maybe_warn_about_overly_private_class (tree t)\n \t complete non-template or fully instantiated classes have this\n \t flag set.  */\n       if (!TYPE_HAS_COPY_CTOR (t))\n-\tnonprivate_ctor = 1;\n+\tnonprivate_ctor = true;\n       else\n-\tfor (fn = CLASSTYPE_CONSTRUCTORS (t); fn; fn = OVL_NEXT (fn))\n-\t  {\n-\t    tree ctor = OVL_CURRENT (fn);\n-\t    /* Ideally, we wouldn't count copy constructors (or, in\n-\t       fact, any constructor that takes an argument of the\n-\t       class type as a parameter) because such things cannot\n-\t       be used to construct an instance of the class unless\n-\t       you already have one.  But, for now at least, we're\n-\t       more generous.  */\n-\t    if (! TREE_PRIVATE (ctor))\n-\t      {\n-\t\tnonprivate_ctor = 1;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\n-      if (nonprivate_ctor == 0)\n+\tfor (ovl_iterator iter (CLASSTYPE_CONSTRUCTORS (t));\n+\t     !nonprivate_ctor && iter; ++iter)\n+\t  /* Ideally, we wouldn't count copy constructors (or, in\n+\t     fact, any constructor that takes an argument of the class\n+\t     type as a parameter) because such things cannot be used\n+\t     to construct an instance of the class unless you already\n+\t     have one.  But, for now at least, we're more\n+\t     generous.  */\n+\t  if (! TREE_PRIVATE (*iter))\n+\t    nonprivate_ctor = true;\n+\n+      if (!nonprivate_ctor)\n \t{\n \t  warning (OPT_Wctor_dtor_privacy,\n \t\t   \"%q#T only defines private constructors and has no friends\",\n@@ -2305,7 +2300,7 @@ method_name_cmp (const void* m1_p, const void* m2_p)\n     return -1;\n   if (*m2 == NULL_TREE)\n     return 1;\n-  if (DECL_NAME (OVL_CURRENT (*m1)) < DECL_NAME (OVL_CURRENT (*m2)))\n+  if (OVL_NAME (*m1) < OVL_NAME (*m2))\n     return -1;\n   return 1;\n }\n@@ -2325,8 +2320,8 @@ resort_method_name_cmp (const void* m1_p, const void* m2_p)\n   if (*m2 == NULL_TREE)\n     return 1;\n   {\n-    tree d1 = DECL_NAME (OVL_CURRENT (*m1));\n-    tree d2 = DECL_NAME (OVL_CURRENT (*m2));\n+    tree d1 = OVL_NAME (*m1);\n+    tree d2 = OVL_NAME (*m2);\n     resort_data.new_value (&d1, resort_data.cookie);\n     resort_data.new_value (&d2, resort_data.cookie);\n     if (d1 < d2)\n@@ -2353,7 +2348,7 @@ resort_type_method_vec (void* obj,\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        vec_safe_iterate (method_vec, slot, &fn);\n        ++slot)\n-    if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+    if (!DECL_CONV_FN_P (OVL_FIRST (fn)))\n       break;\n \n   if (len - slot > 1)\n@@ -2398,7 +2393,7 @@ finish_struct_methods (tree t)\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        method_vec->iterate (slot, &fn_fields);\n        ++slot)\n-    if (!DECL_CONV_FN_P (OVL_CURRENT (fn_fields)))\n+    if (!DECL_CONV_FN_P (OVL_FIRST (fn_fields)))\n       break;\n   if (len - slot > 1)\n     qsort (method_vec->address () + slot,\n@@ -2973,19 +2968,16 @@ modify_all_vtables (tree t, tree virtuals)\n static void\n get_basefndecls (tree name, tree t, vec<tree> *base_fndecls)\n {\n-  tree methods;\n   int n_baseclasses = BINFO_N_BASE_BINFOS (TYPE_BINFO (t));\n   int i;\n \n   /* Find virtual functions in T with the indicated NAME.  */\n   i = lookup_fnfields_1 (t, name);\n   bool found_decls = false;\n   if (i != -1)\n-    for (methods = (*CLASSTYPE_METHOD_VEC (t))[i];\n-\t methods;\n-\t methods = OVL_NEXT (methods))\n+    for (ovl_iterator iter ((*CLASSTYPE_METHOD_VEC (t))[i]); iter; ++iter)\n       {\n-\ttree method = OVL_CURRENT (methods);\n+\ttree method = *iter;\n \n \tif (TREE_CODE (method) == FUNCTION_DECL\n \t    && DECL_VINDEX (method))\n@@ -3065,16 +3057,14 @@ warn_hidden (tree t)\n        vec_safe_iterate (method_vec, i, &fns);\n        ++i)\n     {\n-      tree fn;\n-      tree name;\n       tree fndecl;\n       tree base_binfo;\n       tree binfo;\n       int j;\n \n       /* All functions in this slot in the CLASSTYPE_METHOD_VEC will\n \t have the same name.  Figure out what name that is.  */\n-      name = DECL_NAME (OVL_CURRENT (fns));\n+      tree name = OVL_NAME (fns);\n       /* There are no possibly hidden functions yet.  */\n       auto_vec<tree, 20> base_fndecls;\n       /* Iterate through all of the base classes looking for possibly\n@@ -3091,9 +3081,9 @@ warn_hidden (tree t)\n \tcontinue;\n \n       /* Remove any overridden functions.  */\n-      for (fn = fns; fn; fn = OVL_NEXT (fn))\n+      for (ovl_iterator iter (fns); iter; ++iter)\n \t{\n-\t  fndecl = OVL_CURRENT (fn);\n+\t  fndecl = *iter;\n \t  if (TREE_CODE (fndecl) == FUNCTION_DECL\n \t      && DECL_VINDEX (fndecl))\n \t    {\n@@ -3455,9 +3445,8 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n \t  tree ctor_list = decl;\n \t  location_t loc = input_location;\n \t  input_location = DECL_SOURCE_LOCATION (using_decl);\n-\t  if (ctor_list)\n-\t    for (; ctor_list; ctor_list = OVL_NEXT (ctor_list))\n-\t      one_inherited_ctor (OVL_CURRENT (ctor_list), t, using_decl);\n+\t  for (ovl_iterator iter (ctor_list); iter; ++iter)\n+\t    one_inherited_ctor (*iter, t, using_decl);\n \t  *access_decls = TREE_CHAIN (*access_decls);\n \t  input_location = loc;\n \t}"}, {"sha": "6fd4bde22e57bdd03bb4d35e9177f5104caa28d5", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=19b476fb8de6533a76db72b04db6421857fa9fcf", "patch": "@@ -738,17 +738,13 @@ normalize_template_id_expression (tree t)\n     }\n \n   /* Check that we didn't refer to a function concept like a variable.  */\n-  tree tmpl = TREE_OPERAND (t, 0);\n-  if (TREE_CODE (tmpl) == OVERLOAD)\n+  tree fn = OVL_FIRST (TREE_OPERAND (t, 0));\n+  if (TREE_CODE (fn) == TEMPLATE_DECL\n+      && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))\n     {\n-      tree fn = OVL_FUNCTION (tmpl);\n-      if (TREE_CODE (fn) == TEMPLATE_DECL\n-          && DECL_DECLARED_CONCEPT_P (DECL_TEMPLATE_RESULT (fn)))\n-        {\n-          error_at (location_of (t),\n-                    \"invalid reference to function concept %qD\", fn);\n-          return error_mark_node;\n-        }\n+      error_at (location_of (t),\n+\t\t\"invalid reference to function concept %qD\", fn);\n+      return error_mark_node;\n     }\n \n   return build_nt (PRED_CONSTR, t);\n@@ -1283,15 +1279,9 @@ finish_shorthand_constraint (tree decl, tree constr)\n   /* Build the concept check. If it the constraint needs to be\n      applied to all elements of the parameter pack, then make\n      the constraint an expansion. */\n-  tree check;\n   tree tmpl = DECL_TI_TEMPLATE (con);\n-  if (VAR_P (con))\n-    check = build_concept_check (tmpl, arg, args);\n-  else\n-    {\n-      tree ovl = build_overload (tmpl, NULL_TREE);\n-      check = build_concept_check (ovl, arg, args);\n-    }\n+  tree check = VAR_P (con) ? tmpl : ovl_make (tmpl);\n+  check = build_concept_check (check, arg, args);\n \n   /* Make the check a pack expansion if needed.\n "}, {"sha": "45f878e26f444e4aad9e52d6c9f2e79fe93d512c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=19b476fb8de6533a76db72b04db6421857fa9fcf", "patch": "@@ -24653,11 +24653,8 @@ make_constrained_auto (tree con, tree args)\n \n   /* Build the constraint. */\n   tree tmpl = DECL_TI_TEMPLATE (con);\n-  tree expr;\n-  if (VAR_P (con))\n-    expr = build_concept_check (tmpl, type, args);\n-  else\n-    expr = build_concept_check (build_overload (tmpl, NULL_TREE), type, args);\n+  tree expr = VAR_P (con) ? tmpl : ovl_make (tmpl);\n+  expr = build_concept_check (expr, type, args);\n \n   tree constr = normalize_expression (expr);\n   PLACEHOLDER_TYPE_CONSTRAINTS (type) = constr;"}, {"sha": "4d41f989094fc747adb79f964714f933d0f72205", "filename": "gcc/cp/search.c", "status": "modified", "additions": 46, "deletions": 58, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=19b476fb8de6533a76db72b04db6421857fa9fcf", "patch": "@@ -1047,13 +1047,9 @@ shared_member_p (tree t)\n     return 1;\n   if (is_overloaded_fn (t))\n     {\n-      t = get_fns (t);\n-      for (; t; t = OVL_NEXT (t))\n-\t{\n-\t  tree fn = OVL_CURRENT (t);\n-\t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n-\t    return 0;\n-\t}\n+      for (ovl_iterator iter (get_fns (t)); iter; ++iter)\n+\tif (DECL_NONSTATIC_MEMBER_FUNCTION_P (*iter))\n+\t  return 0;\n       return 1;\n     }\n   return 0;\n@@ -1396,7 +1392,7 @@ lookup_field_fuzzy_info::fuzzy_lookup_fnfields (tree type)\n \n   for (i = 0; vec_safe_iterate (method_vec, i, &fn); ++i)\n     if (fn)\n-      m_candidates.safe_push (DECL_NAME (OVL_CURRENT (fn)));\n+      m_candidates.safe_push (OVL_NAME (fn));\n }\n \n /* Locate all fields within TYPE, append them to m_candidates.  */\n@@ -1550,7 +1546,7 @@ lookup_conversion_operator (tree class_type, tree type)\n \t     the class.  Therefore, if FN is not a conversion\n \t     operator, there is no matching conversion operator in\n \t     CLASS_TYPE.  */\n-\t  fn = OVL_CURRENT (fn);\n+\t  fn = OVL_FIRST (fn);\n \t  if (!DECL_CONV_FN_P (fn))\n \t    break;\n \n@@ -1575,7 +1571,6 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n {\n   vec<tree, va_gc> *method_vec;\n   tree fn;\n-  tree tmp;\n   size_t i;\n \n   if (!CLASS_TYPE_P (type))\n@@ -1607,7 +1602,7 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        vec_safe_iterate (method_vec, i, &fn);\n        ++i)\n-    if (!DECL_CONV_FN_P (OVL_CURRENT (fn)))\n+    if (!DECL_CONV_FN_P (OVL_FIRST (fn)))\n       break;\n \n   /* If the type is complete, use binary search.  */\n@@ -1625,8 +1620,8 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n \t  if (GATHER_STATISTICS)\n \t    n_outer_fields_searched++;\n \n-\t  tmp = (*method_vec)[i];\n-\t  tmp = DECL_NAME (OVL_CURRENT (tmp));\n+\t  tree tmp = (*method_vec)[i];\n+\t  tmp = OVL_NAME (tmp);\n \t  if (tmp > name)\n \t    hi = i;\n \t  else if (tmp < name)\n@@ -1640,7 +1635,7 @@ lookup_fnfields_idx_nolazy (tree type, tree name)\n       {\n \tif (GATHER_STATISTICS)\n \t  n_outer_fields_searched++;\n-\tif (DECL_NAME (OVL_CURRENT (fn)) == name)\n+\tif (OVL_NAME (fn) == name)\n \t  return i;\n       }\n \n@@ -2433,28 +2428,25 @@ look_for_overrides_here (tree type, tree fndecl)\n   else\n     ix = lookup_fnfields_1 (type, DECL_NAME (fndecl));\n   if (ix >= 0)\n-    {\n-      tree fns = (*CLASSTYPE_METHOD_VEC (type))[ix];\n+    for (ovl_iterator iter ((*CLASSTYPE_METHOD_VEC (type))[ix]); iter; ++iter)\n+      {\n+\ttree fn = *iter;\n \n-      for (; fns; fns = OVL_NEXT (fns))\n-\t{\n-\t  tree fn = OVL_CURRENT (fns);\n+\tif (!DECL_VIRTUAL_P (fn))\n+\t  /* Not a virtual.  */;\n+\telse if (DECL_CONTEXT (fn) != type)\n+\t  /* Introduced with a using declaration.  */;\n+\telse if (DECL_STATIC_FUNCTION_P (fndecl))\n+\t  {\n+\t    tree btypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t    tree dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+\t    if (compparms (TREE_CHAIN (btypes), dtypes))\n+\t      return fn;\n+\t  }\n+\telse if (same_signature_p (fndecl, fn))\n+\t  return fn;\n+      }\n \n-\t  if (!DECL_VIRTUAL_P (fn))\n-\t    /* Not a virtual.  */;\n-\t  else if (DECL_CONTEXT (fn) != type)\n-\t    /* Introduced with a using declaration.  */;\n-\t  else if (DECL_STATIC_FUNCTION_P (fndecl))\n-\t    {\n-\t      tree btypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-\t      tree dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-\t      if (compparms (TREE_CHAIN (btypes), dtypes))\n-\t\treturn fn;\n-\t    }\n-\t  else if (same_signature_p (fndecl, fn))\n-\t    return fn;\n-\t}\n-    }\n   return NULL_TREE;\n }\n \n@@ -2797,35 +2789,31 @@ lookup_conversions_r (tree binfo,\n        vec_safe_iterate (method_vec, i, &conv);\n        ++i)\n     {\n-      tree cur = OVL_CURRENT (conv);\n+      tree cur = OVL_FIRST (conv);\n \n       if (!DECL_CONV_FN_P (cur))\n \tbreak;\n \n       if (TREE_CODE (cur) == TEMPLATE_DECL)\n-\t{\n-\t  /* Only template conversions can be overloaded, and we must\n-\t     flatten them out and check each one individually.  */\n-\t  tree tpls;\n-\n-\t  for (tpls = conv; tpls; tpls = OVL_NEXT (tpls))\n-\t    {\n-\t      tree tpl = OVL_CURRENT (tpls);\n-\t      tree type = DECL_CONV_FN_TYPE (tpl);\n+\t/* Only template conversions can be overloaded, and we must\n+\t   flatten them out and check each one individually.  */\n+\tfor (ovl_iterator iter (conv); iter; ++iter)\n+\t  {\n+\t    tree tpl = *iter;\n+\t    tree type = DECL_CONV_FN_TYPE (tpl);\n \n-\t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n-\t\t\t\t      type, parent_tpl_convs, other_tpl_convs))\n-\t\t{\n-\t\t  my_tpl_convs = tree_cons (binfo, tpl, my_tpl_convs);\n-\t\t  TREE_TYPE (my_tpl_convs) = type;\n-\t\t  if (virtual_depth)\n-\t\t    {\n-\t\t      TREE_STATIC (my_tpl_convs) = 1;\n-\t\t      my_virtualness = 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+\t    if (check_hidden_convs (binfo, virtual_depth, virtualness,\n+\t\t\t\t    type, parent_tpl_convs, other_tpl_convs))\n+\t      {\n+\t\tmy_tpl_convs = tree_cons (binfo, tpl, my_tpl_convs);\n+\t\tTREE_TYPE (my_tpl_convs) = type;\n+\t\tif (virtual_depth)\n+\t\t  {\n+\t\t    TREE_STATIC (my_tpl_convs) = 1;\n+\t\t    my_virtualness = 1;\n+\t\t  }\n+\t      }\n+\t  }\n       else\n \t{\n \t  tree name = DECL_NAME (cur);\n@@ -2891,7 +2879,7 @@ lookup_conversions_r (tree binfo,\n \n   /* Unmark the conversions found at this level  */\n   for (conv = my_convs; conv; conv = TREE_CHAIN (conv))\n-    IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (conv)))) = 0;\n+    IDENTIFIER_MARKED (OVL_NAME (TREE_VALUE (conv))) = 0;\n \n   *convs = split_conversions (my_convs, parent_convs,\n \t\t\t      child_convs, other_convs);"}, {"sha": "13d90a6573d55481c63702c82f42e0c050e23325", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b476fb8de6533a76db72b04db6421857fa9fcf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=19b476fb8de6533a76db72b04db6421857fa9fcf", "patch": "@@ -5519,7 +5519,7 @@ build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n \t\t pointer-to-member.  */\n \t      xarg = build2 (OFFSET_REF, TREE_TYPE (xarg),\n \t\t\t     TREE_OPERAND (xarg, 0),\n-\t\t\t     ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n+\t\t\t     ovl_make (TREE_OPERAND (xarg, 1)));\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n \t    }\n \t}"}]}