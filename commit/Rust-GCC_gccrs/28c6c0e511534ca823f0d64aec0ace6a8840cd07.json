{"sha": "28c6c0e511534ca823f0d64aec0ace6a8840cd07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhjNmMwZTUxMTUzNGNhODIzZjBkNjRhZWMwYWNlNmE4ODQwY2QwNw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-05-12T18:34:54Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2016-05-12T18:34:54Z"}, "message": "i386.md (*call_got_x32): Change operand 0 to DImode before it is passed to ix86_output_call_operand.\n\n\t* config/i386/i386.md (*call_got_x32): Change operand 0 to\n\tDImode before it is passed to ix86_output_call_operand.\n\t(*call_value_got_x32): Ditto for operand 1.\n\nFrom-SVN: r236182", "tree": {"sha": "b9b2aba96fc06d6bab438674c751adadf151bdd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9b2aba96fc06d6bab438674c751adadf151bdd1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28c6c0e511534ca823f0d64aec0ace6a8840cd07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c6c0e511534ca823f0d64aec0ace6a8840cd07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c6c0e511534ca823f0d64aec0ace6a8840cd07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c6c0e511534ca823f0d64aec0ace6a8840cd07/comments", "author": null, "committer": null, "parents": [{"sha": "ada2eb687fd49e37664b92a59dbed55f19e62eb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ada2eb687fd49e37664b92a59dbed55f19e62eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ada2eb687fd49e37664b92a59dbed55f19e62eb8"}], "stats": {"total": 43, "additions": 26, "deletions": 17}, "files": [{"sha": "65014e939bf504112bf67a982841a0c39e6d84e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c6c0e511534ca823f0d64aec0ace6a8840cd07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c6c0e511534ca823f0d64aec0ace6a8840cd07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28c6c0e511534ca823f0d64aec0ace6a8840cd07", "patch": "@@ -1,3 +1,9 @@\n+2016-05-12  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (*call_got_x32): Change operand 0 to\n+\tDImode before it is passed to ix86_output_call_operand.\n+\t(*call_value_got_x32): Ditto for operand 1.\n+\n 2016-05-12  Jiong Wang  <jiong.wang@arm.com>\n \n \tPR rtl-optimization/70904\n@@ -30,8 +36,8 @@\n \tPR tree-optimization/71062\n \t* tree-ssa-alias.h (struct pt_solution): Add vars_contains_restrict\n \tfield.\n-\t* tree-ssa-structalias.c (set_uids_in_ptset): Set vars_contains_restrict\n-\tif the var is a restrict tag.\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Set\n+\tvars_contains_restrict if the var is a restrict tag.\n \t* tree-ssa-alias.c (ptrs_compare_unequal): If vars_contains_restrict\n \tdo not disambiguate pointers against it.\n \t(dump_points_to_solution): Re-structure and adjust for new\n@@ -40,8 +46,8 @@\n \n 2016-05-12  Martin Liska  <mliska@suse.cz>\n \n-\t* doc/invoke.texi: Explain connection between -fsanitize-recover=address\n-\tand ASAN_OPTIONS=\"halt_on_error=1\".\n+\t* doc/invoke.texi: Explain connection between\n+\t-fsanitize-recover=address and ASAN_OPTIONS=\"halt_on_error=1\".\n \n 2016-05-12  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n@@ -148,14 +154,11 @@\n \tbit instead of being a separate word.  Split -mpower9-dform into\n \ttwo switches, -mpower9-dform-scalar and -mpower9-dform-vector.\n \t* config/rs6000/rs6000.c (RELOAD_REG_QUAD_OFFSET): New addr_mask\n-\tfor the register class supporting 128-bit quad word memory\n-\toffsets.\n+\tfor the register class supporting 128-bit quad word memory offsets.\n \t(mode_supports_vsx_dform_quad): Helper function to return if the\n \tregister class uses quad word memory offsets.\n-\t(rs6000_debug_addr_mask): Add support for quad word memory\n-\toffsets.\n-\t(rs6000_debug_reg_global): Always print if we are using LRA or\n-\tnot.\n+\t(rs6000_debug_addr_mask): Add support for quad word memory offsets.\n+\t(rs6000_debug_reg_global): Always print if we are using LRA or not.\n \t(rs6000_setup_reg_addr_masks): If ISA 3.0 vector d-form\n \tinstructions are enabled, set up the appropriate addr_masks for\n \t128-bit types.\n@@ -214,7 +217,7 @@\n \t* config/rs6000/rs6000-cpus.def (ISA_3_0_MASKS_SERVER): Use\n \t-mpower9-dform-scalar instead of -mpower9-dform.  Add note not to\n \tinclude -mpower9-dform-vector until we switch over to LRA.\n-\t(POWERPC_MASKS): Add -mlra. Split -mpower9-dform into two. \n+\t(POWERPC_MASKS): Add -mlra. Split -mpower9-dform into two.\n \tswitches, -mpower9-dform-scalar and -mpower9-dform-vector.\n \t* config/rs6000/rs6000-protos.h (quad_address_p): Add declaration.\n \t* doc/invoke.texi (RS/6000 and PowerPC Options): Add documentation"}, {"sha": "02a0055cd5130116ef07e09143abecb8c0a244c9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28c6c0e511534ca823f0d64aec0ace6a8840cd07/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28c6c0e511534ca823f0d64aec0ace6a8840cd07/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=28c6c0e511534ca823f0d64aec0ace6a8840cd07", "patch": "@@ -11950,7 +11950,10 @@\n \t\t   (match_operand:SI 0 \"GOT_memory_operand\" \"Bg\")))\n \t (match_operand 1))]\n   \"TARGET_X32\"\n-  \"* return ix86_output_call_insn (insn, operands[0]);\"\n+{\n+  rtx fnaddr = gen_const_mem (DImode, XEXP (operands[0], 0));\n+  return ix86_output_call_insn (insn, fnaddr);\n+}\n   [(set_attr \"type\" \"call\")])\n \n ;; Since sibcall never returns, we can only use call-clobbered register\n@@ -11963,8 +11966,8 @@\n \t (match_operand 2))]\n   \"!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n {\n-  rtx fnaddr = gen_rtx_PLUS (Pmode, operands[0], operands[1]);\n-  fnaddr = gen_const_mem (Pmode, fnaddr);\n+  rtx fnaddr = gen_rtx_PLUS (SImode, operands[0], operands[1]);\n+  fnaddr = gen_const_mem (SImode, fnaddr);\n   return ix86_output_call_insn (insn, fnaddr);\n }\n   [(set_attr \"type\" \"call\")])\n@@ -12143,7 +12146,10 @@\n \t\t  (match_operand:SI 1 \"GOT_memory_operand\" \"Bg\")))\n \t      (match_operand 2)))]\n   \"TARGET_X32\"\n-  \"* return ix86_output_call_insn (insn, operands[1]);\"\n+{\n+  rtx fnaddr = gen_const_mem (DImode, XEXP (operands[1], 0));\n+  return ix86_output_call_insn (insn, fnaddr);\n+}\n   [(set_attr \"type\" \"callv\")])\n \n ;; Since sibcall never returns, we can only use call-clobbered register\n@@ -12157,8 +12163,8 @@\n \t (match_operand 3)))]\n   \"!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)\"\n {\n-  rtx fnaddr = gen_rtx_PLUS (Pmode, operands[1], operands[2]);\n-  fnaddr = gen_const_mem (Pmode, fnaddr);\n+  rtx fnaddr = gen_rtx_PLUS (SImode, operands[1], operands[2]);\n+  fnaddr = gen_const_mem (SImode, fnaddr);\n   return ix86_output_call_insn (insn, fnaddr);\n }\n   [(set_attr \"type\" \"callv\")])"}]}