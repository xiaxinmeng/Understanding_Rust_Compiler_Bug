{"sha": "704686049d5eb2d54fe62585d2c17c5ef00dbb83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0Njg2MDQ5ZDVlYjJkNTRmZTYyNTg1ZDJjMTdjNWVmMDBkYmI4Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-07-13T06:25:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-07-13T06:25:04Z"}, "message": "gimplify.c (struct gimplify_omp_ctx): Add order_concurrent member.\n\n\t* gimplify.c (struct gimplify_omp_ctx): Add order_concurrent member.\n\t(omp_notice_threadprivate_variable): Diagnose threadprivate variable\n\tuses inside of order(concurrent) constructs.\n\t(gimplify_scan_omp_clauses): Set ctx->order_concurrent if\n\tOMP_CLAUSE_ORDER is seen.\n\t* omp-low.c (struct omp_context): Add order_concurrent member.\n\t(scan_sharing_clauses): Set ctx->order_concurrent if\n\tOMP_CLAUSE_ORDER is seen.\n\t(check_omp_nesting_restrictions): Diagnose ordered or atomic inside\n\tof simd order(concurrent).  Diagnose constructs not allowed inside of\n\tfor order(concurrent).\n\t(setjmp_or_longjmp_p): Add a context and TREE_PUBLIC check to avoid\n\tcomplaining about static double setjmp (double); or class static\n\tmethods or non-global namespace setjmps.\n\t(omp_runtime_api_call): New function.\n\t(scan_omp_1_stmt): Diagnose OpenMP runtime API calls inside of\n\torder(concurrent) loops.\n\n\t* c-c++-common/gomp/order-3.c: New test.\n\t* c-c++-common/gomp/order-4.c: New test.\n\nFrom-SVN: r273464", "tree": {"sha": "0278c5ad8b6326931917d793acc35b41b2a6b73f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0278c5ad8b6326931917d793acc35b41b2a6b73f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/704686049d5eb2d54fe62585d2c17c5ef00dbb83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704686049d5eb2d54fe62585d2c17c5ef00dbb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/704686049d5eb2d54fe62585d2c17c5ef00dbb83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704686049d5eb2d54fe62585d2c17c5ef00dbb83/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf85a0385f07887c35c32d62cf9d015b4ae58d22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf85a0385f07887c35c32d62cf9d015b4ae58d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf85a0385f07887c35c32d62cf9d015b4ae58d22"}], "stats": {"total": 455, "additions": 444, "deletions": 11}, "files": [{"sha": "1c6f4adfd064a75b264664d86c9c9000cf1396ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=704686049d5eb2d54fe62585d2c17c5ef00dbb83", "patch": "@@ -1,3 +1,23 @@\n+2019-07-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (struct gimplify_omp_ctx): Add order_concurrent member.\n+\t(omp_notice_threadprivate_variable): Diagnose threadprivate variable\n+\tuses inside of order(concurrent) constructs.\n+\t(gimplify_scan_omp_clauses): Set ctx->order_concurrent if\n+\tOMP_CLAUSE_ORDER is seen.\n+\t* omp-low.c (struct omp_context): Add order_concurrent member.\n+\t(scan_sharing_clauses): Set ctx->order_concurrent if\n+\tOMP_CLAUSE_ORDER is seen.\n+\t(check_omp_nesting_restrictions): Diagnose ordered or atomic inside\n+\tof simd order(concurrent).  Diagnose constructs not allowed inside of\n+\tfor order(concurrent).\n+\t(setjmp_or_longjmp_p): Add a context and TREE_PUBLIC check to avoid\n+\tcomplaining about static double setjmp (double); or class static\n+\tmethods or non-global namespace setjmps.\n+\t(omp_runtime_api_call): New function.\n+\t(scan_omp_1_stmt): Diagnose OpenMP runtime API calls inside of\n+\torder(concurrent) loops.\n+\n 2019-07-12  Martin Sebor  <msebor@redhat.com>\n \n \t* doc/invoke.texi (ssa-name-def-chain-limit): Document new --param."}, {"sha": "66df5c5adc9590bd4e134e13b2a08c13fb6a87a6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=704686049d5eb2d54fe62585d2c17c5ef00dbb83", "patch": "@@ -222,6 +222,7 @@ struct gimplify_omp_ctx\n   bool distribute;\n   bool target_firstprivatize_array_bases;\n   bool add_safelen1;\n+  bool order_concurrent;\n   int defaultmap[4];\n };\n \n@@ -7025,14 +7026,24 @@ omp_notice_threadprivate_variable (struct gimplify_omp_ctx *ctx, tree decl,\n   struct gimplify_omp_ctx *octx;\n \n   for (octx = ctx; octx; octx = octx->outer_context)\n-    if ((octx->region_type & ORT_TARGET) != 0)\n+    if ((octx->region_type & ORT_TARGET) != 0\n+\t|| octx->order_concurrent)\n       {\n \tn = splay_tree_lookup (octx->variables, (splay_tree_key)decl);\n \tif (n == NULL)\n \t  {\n-\t    error (\"threadprivate variable %qE used in target region\",\n-\t\t   DECL_NAME (decl));\n-\t    error_at (octx->location, \"enclosing target region\");\n+\t    if (octx->order_concurrent)\n+\t      {\n+\t\terror (\"threadprivate variable %qE used in a region with\"\n+\t\t       \" %<order(concurrent)%> clause\", DECL_NAME (decl));\n+\t\terror_at (octx->location, \"enclosing region\");\n+\t      }\n+\t    else\n+\t      {\n+\t\terror (\"threadprivate variable %qE used in target region\",\n+\t\t       DECL_NAME (decl));\n+\t\terror_at (octx->location, \"enclosing target region\");\n+\t      }\n \t    splay_tree_insert (octx->variables, (splay_tree_key)decl, 0);\n \t  }\n \tif (decl2)\n@@ -9263,11 +9274,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n-\tcase OMP_CLAUSE_ORDER:\n \tcase OMP_CLAUSE_IF_PRESENT:\n \tcase OMP_CLAUSE_FINALIZE:\n \t  break;\n \n+\tcase OMP_CLAUSE_ORDER:\n+\t  ctx->order_concurrent = true;\n+\t  break;\n+\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \t  enum gimplify_defaultmap_kind gdmkmin, gdmkmax;\n \t  switch (OMP_CLAUSE_DEFAULTMAP_CATEGORY (c))"}, {"sha": "01cf728fc424342255ab64f23f1f8dc89dd365eb", "filename": "gcc/omp-low.c", "status": "modified", "additions": 159, "deletions": 6, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=704686049d5eb2d54fe62585d2c17c5ef00dbb83", "patch": "@@ -150,6 +150,9 @@ struct omp_context\n \n   /* True in the second simd loop of for simd with inscan reductions.  */\n   bool for_simd_scan_phase;\n+\n+  /* True if there is order(concurrent) clause on the construct.  */\n+  bool order_concurrent;\n };\n \n static splay_tree all_contexts;\n@@ -1390,6 +1393,10 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_ORDER:\n+\t  ctx->order_concurrent = true;\n+\t  break;\n+\n \tcase OMP_CLAUSE_NOWAIT:\n \tcase OMP_CLAUSE_ORDERED:\n \tcase OMP_CLAUSE_COLLAPSE:\n@@ -1402,7 +1409,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n-\tcase OMP_CLAUSE_ORDER:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_GANG:\n@@ -2669,9 +2675,20 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t  && gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n \tctx = ctx->outer;\n       if (gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-\t  && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n+\t  && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_KIND_SIMD)\n \t{\n \t  c = NULL_TREE;\n+\t  if (ctx->order_concurrent\n+\t      && (gimple_code (stmt) == GIMPLE_OMP_ORDERED\n+\t\t  || gimple_code (stmt) == GIMPLE_OMP_ATOMIC_LOAD\n+\t\t  || gimple_code (stmt) == GIMPLE_OMP_ATOMIC_STORE))\n+\t    {\n+\t      error_at (gimple_location (stmt),\n+\t\t\t\"OpenMP constructs other than %<parallel%> or\"\n+\t\t\t\" %<simd%> may not be nested inside a region with\"\n+\t\t\t\" the %<order(concurrent)%> clause\");\n+\t      return false;\n+\t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_ORDERED)\n \t    {\n \t      c = gimple_omp_ordered_clauses (as_a <gomp_ordered *> (stmt));\n@@ -2717,6 +2734,18 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n \t      return false;\n \t    }\n \t}\n+      else if (ctx->order_concurrent\n+\t       && gimple_code (stmt) != GIMPLE_OMP_PARALLEL\n+\t       && (gimple_code (stmt) != GIMPLE_OMP_FOR\n+\t\t   || gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_SIMD)\n+\t       && gimple_code (stmt) != GIMPLE_OMP_SCAN)\n+\t{\n+\t  error_at (gimple_location (stmt),\n+\t\t    \"OpenMP constructs other than %<parallel%> or\"\n+\t\t    \" %<simd%> may not be nested inside a region with\"\n+\t\t    \" the %<order(concurrent)%> clause\");\n+\t  return false;\n+\t}\n     }\n   switch (gimple_code (stmt))\n     {\n@@ -3323,12 +3352,123 @@ setjmp_or_longjmp_p (const_tree fndecl)\n     return true;\n \n   tree declname = DECL_NAME (fndecl);\n-  if (!declname)\n+  if (!declname\n+      || (DECL_CONTEXT (fndecl) != NULL_TREE\n+          && TREE_CODE (DECL_CONTEXT (fndecl)) != TRANSLATION_UNIT_DECL)\n+      || !TREE_PUBLIC (fndecl))\n     return false;\n+\n   const char *name = IDENTIFIER_POINTER (declname);\n   return !strcmp (name, \"setjmp\") || !strcmp (name, \"longjmp\");\n }\n \n+/* Return true if FNDECL is an omp_* runtime API call.  */\n+\n+static bool\n+omp_runtime_api_call (const_tree fndecl)\n+{\n+  tree declname = DECL_NAME (fndecl);\n+  if (!declname\n+      || (DECL_CONTEXT (fndecl) != NULL_TREE\n+          && TREE_CODE (DECL_CONTEXT (fndecl)) != TRANSLATION_UNIT_DECL)\n+      || !TREE_PUBLIC (fndecl))\n+    return false;\n+\n+  const char *name = IDENTIFIER_POINTER (declname);\n+  if (strncmp (name, \"omp_\", 4) != 0)\n+    return false;\n+\n+  static const char *omp_runtime_apis[] =\n+    {\n+      /* This array has 3 sections.  First omp_* calls that don't\n+\t have any suffixes.  */\n+      \"target_alloc\",\n+      \"target_associate_ptr\",\n+      \"target_disassociate_ptr\",\n+      \"target_free\",\n+      \"target_is_present\",\n+      \"target_memcpy\",\n+      \"target_memcpy_rect\",\n+      NULL,\n+      /* Now omp_* calls that are available as omp_* and omp_*_.  */\n+      \"capture_affinity\",\n+      \"destroy_lock\",\n+      \"destroy_nest_lock\",\n+      \"display_affinity\",\n+      \"get_active_level\",\n+      \"get_affinity_format\",\n+      \"get_cancellation\",\n+      \"get_default_device\",\n+      \"get_dynamic\",\n+      \"get_initial_device\",\n+      \"get_level\",\n+      \"get_max_active_levels\",\n+      \"get_max_task_priority\",\n+      \"get_max_threads\",\n+      \"get_nested\",\n+      \"get_num_devices\",\n+      \"get_num_places\",\n+      \"get_num_procs\",\n+      \"get_num_teams\",\n+      \"get_num_threads\",\n+      \"get_partition_num_places\",\n+      \"get_place_num\",\n+      \"get_proc_bind\",\n+      \"get_team_num\",\n+      \"get_thread_limit\",\n+      \"get_thread_num\",\n+      \"get_wtick\",\n+      \"get_wtime\",\n+      \"in_final\",\n+      \"in_parallel\",\n+      \"init_lock\",\n+      \"init_nest_lock\",\n+      \"is_initial_device\",\n+      \"pause_resource\",\n+      \"pause_resource_all\",\n+      \"set_affinity_format\",\n+      \"set_lock\",\n+      \"set_nest_lock\",\n+      \"test_lock\",\n+      \"test_nest_lock\",\n+      \"unset_lock\",\n+      \"unset_nest_lock\",\n+      NULL,\n+      /* And finally calls available as omp_*, omp_*_ and omp_*_8_.  */\n+      \"get_ancestor_thread_num\",\n+      \"get_partition_place_nums\",\n+      \"get_place_num_procs\",\n+      \"get_place_proc_ids\",\n+      \"get_schedule\",\n+      \"get_team_size\",\n+      \"set_default_device\",\n+      \"set_dynamic\",\n+      \"set_max_active_levels\",\n+      \"set_nested\",\n+      \"set_num_threads\",\n+      \"set_schedule\"\n+    };\n+\n+  int mode = 0;\n+  for (unsigned i = 0; i < ARRAY_SIZE (omp_runtime_apis); i++)\n+    {\n+      if (omp_runtime_apis[i] == NULL)\n+\t{\n+\t  mode++;\n+\t  continue;\n+\t}\n+      size_t len = strlen (omp_runtime_apis[i]);\n+      if (strncmp (name + 4, omp_runtime_apis[i], len) == 0\n+\t  && (name[4 + len] == '\\0'\n+\t      || (mode > 0\n+\t\t  && name[4 + len] == '_'\n+\t\t  && (name[4 + len + 1] == '\\0'\n+\t\t      || (mode > 1\n+\t\t\t  && strcmp (name + 4 + len + 1, \"8_\") == 0)))))\n+\treturn true;\n+    }\n+  return false;\n+}\n \n /* Helper function for scan_omp.\n \n@@ -3354,10 +3494,10 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n       tree fndecl = gimple_call_fndecl (stmt);\n       if (fndecl)\n \t{\n-\t  if (setjmp_or_longjmp_p (fndecl)\n-\t      && ctx\n+\t  if (ctx\n \t      && gimple_code (ctx->stmt) == GIMPLE_OMP_FOR\n-\t      && gimple_omp_for_kind (ctx->stmt) & GF_OMP_FOR_SIMD)\n+\t      && gimple_omp_for_kind (ctx->stmt) == GF_OMP_FOR_SIMD\n+\t      && setjmp_or_longjmp_p (fndecl))\n \t    {\n \t      remove = true;\n \t      error_at (gimple_location (stmt),\n@@ -3378,6 +3518,19 @@ scan_omp_1_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t      default:\n \t\tbreak;\n \t      }\n+\t  else if (ctx)\n+\t    {\n+\t      omp_context *octx = ctx;\n+\t      if (gimple_code (ctx->stmt) == GIMPLE_OMP_SCAN && ctx->outer)\n+\t\toctx = ctx->outer;\n+\t      if (octx->order_concurrent && omp_runtime_api_call (fndecl))\n+\t\t{\n+\t\t  remove = true;\n+\t\t  error_at (gimple_location (stmt),\n+\t\t\t    \"OpenMP runtime API call %qD in a region with \"\n+\t\t\t    \"%<order(concurrent)%> clause\", fndecl);\n+\t\t}\n+\t    }\n \t}\n     }\n   if (remove)"}, {"sha": "dccf6ee594aa15fc5582c264a78ddc6137c15a6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=704686049d5eb2d54fe62585d2c17c5ef00dbb83", "patch": "@@ -1,3 +1,8 @@\n+2019-07-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/gomp/order-3.c: New test.\n+\t* c-c++-common/gomp/order-4.c: New test.\n+\n 2019-07-12  Bill Seurer  <seurer@linux.vnet.ibm.com>\n \n \t* gcc.dg/tree-ssa/vector-7.c: Fix typo."}, {"sha": "225d0ccf3bba7f396e28d5403d3fb0e07c30a39e", "filename": "gcc/testsuite/c-c++-common/gomp/order-3.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-3.c?ref=704686049d5eb2d54fe62585d2c17c5ef00dbb83", "patch": "@@ -0,0 +1,212 @@\n+void foo (void);\n+int v;\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+int omp_get_thread_num (void);\n+int omp_get_num_threads (void);\n+int omp_target_is_present (const void *, int);\n+int omp_get_cancellation (void);\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+void\n+f1 (int *a)\n+{\n+  int i;\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp parallel\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      foo ();\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp simd\t\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      foo ();\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      foo ();\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      v++;\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic read\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n+    }\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_thread_num ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_num_threads ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_target_is_present (a + i, 0);\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_cancellation ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}\n+\n+void\n+f2 (int *a)\n+{\n+  int i;\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp parallel\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      foo ();\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp simd\t\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than '#pragma omp ordered simd' or '#pragma omp atomic' may not be nested inside 'simd' region\" } */\n+      foo ();\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      foo ();\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      v++;\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic read\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n+    }\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_thread_num ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_num_threads ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_target_is_present (a + i, 0);\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp for simd order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_cancellation ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}\n+\n+void\n+f3 (int *a)\n+{\n+  int i;\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp parallel\n+      foo ();\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp simd\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp critical\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      foo ();\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp ordered simd\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      foo ();\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      v++;\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic read\n+      a[i] = v;\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp atomic write\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c++ } } */\n+      v = a[i];\t\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" \"\" { target c } } */\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      #pragma omp task\t\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      a[i]++;\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    {\n+      int j;\n+      #pragma omp taskloop\t\t/* { dg-error \"OpenMP constructs other than 'parallel' or 'simd' may not be nested inside a region with the 'order\\\\(concurrent\\\\)' clause\" } */\n+      for (j = 0; j < 64; j++)\n+\ta[64 * i + j] = i + j;\n+    }\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_thread_num ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_thread_num\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_num_threads ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_num_threads\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_target_is_present (a + i, 0);\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_target_is_present\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+  #pragma omp for order(concurrent)\n+  for (i = 0; i < 64; i++)\n+    a[i] += omp_get_cancellation ();\t/* { dg-error \"OpenMP runtime API call '\\[^\\n\\r]*omp_get_cancellation\\[^\\n\\r]*' in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}"}, {"sha": "f916772ceea7f6043f0835815dd785e69360faf8", "filename": "gcc/testsuite/c-c++-common/gomp/order-4.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704686049d5eb2d54fe62585d2c17c5ef00dbb83/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Forder-4.c?ref=704686049d5eb2d54fe62585d2c17c5ef00dbb83", "patch": "@@ -0,0 +1,29 @@\n+int t;\n+#pragma omp threadprivate(t)\n+\n+void\n+f1 (void)\n+{\n+  int i;\n+  #pragma omp simd order(concurrent)\t/* { dg-error \"enclosing region\" } */\n+  for (i = 0; i < 64; i++)\n+    t++;\t/* { dg-error \"threadprivate variable 't' used in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i;\n+  #pragma omp for simd order(concurrent)\t/* { dg-error \"enclosing region\" } */\n+  for (i = 0; i < 64; i++)\t\t\t/* { dg-error \"enclosing region\" \"\" { target c++ } } */\n+    t++;\t/* { dg-error \"threadprivate variable 't' used in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}\n+\n+void\n+f3 (void)\n+{\n+  int i;\n+  #pragma omp for order(concurrent)\t/* { dg-error \"enclosing region\" } */\n+  for (i = 0; i < 64; i++)\n+    t++;\t/* { dg-error \"threadprivate variable 't' used in a region with 'order\\\\(concurrent\\\\)' clause\" } */\n+}"}]}