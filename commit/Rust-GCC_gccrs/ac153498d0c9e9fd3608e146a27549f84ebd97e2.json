{"sha": "ac153498d0c9e9fd3608e146a27549f84ebd97e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMxNTM0OThkMGM5ZTlmZDM2MDhlMTQ2YTI3NTQ5Zjg0ZWJkOTdlMg==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-01-14T19:11:55Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1993-01-14T19:11:55Z"}, "message": "(move patterns): Reorganize pattern order.\n\n(move patterns): Reorganize pattern order.  Cleanup.  Merge\nCONST_INT patterns into main patterns for SImode, HImode, QImode.\nAdd patterns to recognize predecrement cases in SImode, HImode,\nQImode.  Remove 'y' constraint from SImode recognizer.\n(main MImode, QImode recognizers): Handle SAR move from greg.\nChange constaints to match the SImode pattern.\n(cmov): Move near other conditional patterns.\n(all file): Replace all occurences of srcsi_operand with move_operand.\nReplace `ldo X(0),d' with `ldi X,d'.\n(rotlsi3): Remove SET_ATTRs.\n(rotrsi3): Likewise.\n\nFrom-SVN: r3232", "tree": {"sha": "d8f7746edaf521a0a51ddf91d10f047399856c88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8f7746edaf521a0a51ddf91d10f047399856c88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac153498d0c9e9fd3608e146a27549f84ebd97e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac153498d0c9e9fd3608e146a27549f84ebd97e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac153498d0c9e9fd3608e146a27549f84ebd97e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac153498d0c9e9fd3608e146a27549f84ebd97e2/comments", "author": null, "committer": null, "parents": [{"sha": "cc81e6253b50a6d819d5fbffaecceec38726c39d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc81e6253b50a6d819d5fbffaecceec38726c39d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc81e6253b50a6d819d5fbffaecceec38726c39d"}], "stats": {"total": 368, "additions": 174, "deletions": 194}, "files": [{"sha": "9032b3175e38bcdf08383318401ec9ac301e4024", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 174, "deletions": 194, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac153498d0c9e9fd3608e146a27549f84ebd97e2/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac153498d0c9e9fd3608e146a27549f84ebd97e2/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ac153498d0c9e9fd3608e146a27549f84ebd97e2", "patch": "@@ -446,8 +446,48 @@\n  }\"\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"2,3\")])\n- \n-;; Conditionals\n+\n+;;; Experimental conditional move\n+\n+(define_insn \"cmov\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+        (if_then_else:SI\n+\t (match_operator 5 \"comparison_operator\"\n+                         [(match_operand:SI 3 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 4 \"arith5_operand\" \"rL,rL\")])\n+         (match_operand:SI 1 \"arith11_operand\" \"0,rI\")\n+         (match_operand:SI 2 \"arith11_operand\" \"rI,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[4]) == CONST_INT)\n+    {\n+      if (! (GET_CODE (operands[5]) == EQ || GET_CODE (operands[5]) == NE))\n+\tPUT_CODE (operands[5], reverse_relop (GET_CODE (operands[5])));\n+      output_asm_insn (\\\"comiclr,%C5 %4,%3,0\\\", operands);\n+    }\n+  else\n+    output_asm_insn (\\\"comclr,%C5 %3,%4,0\\\", operands);\n+  if (which_alternative == 0)\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\toutput_asm_insn (\\\"ldi %2,%0\\\", operands);\n+      else \n+\toutput_asm_insn (\\\"copy %2,%0\\\", operands);\n+    }\n+  else\n+    {\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\toutput_asm_insn (\\\"ldi %1,%0\\\", operands);\n+      else \n+\toutput_asm_insn (\\\"copy %1,%0\\\", operands);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\" \"multi,multi\")\n+   (set_attr \"length\" \"2,2\")])\n+\n+;; Conditional Branches\n \n (define_expand \"beq\"\n   [(set (pc)\n@@ -758,46 +798,6 @@\n   DONE;\n }\")\n \n-;;; Experimental\n-\n-(define_insn \"cmov\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-        (if_then_else:SI\n-\t (match_operator 5 \"comparison_operator\"\n-                         [(match_operand:SI 3 \"register_operand\" \"r,r\")\n-\t\t\t  (match_operand:SI 4 \"arith5_operand\" \"rL,rL\")])\n-         (match_operand:SI 1 \"arith11_operand\" \"0,rI\")\n-         (match_operand:SI 2 \"arith11_operand\" \"rI,0\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[4]) == CONST_INT)\n-    {\n-      if (! (GET_CODE (operands[5]) == EQ || GET_CODE (operands[5]) == NE))\n-\tPUT_CODE (operands[5], reverse_relop (GET_CODE (operands[5])));\n-      output_asm_insn (\\\"comiclr,%C5 %4,%3,0\\\", operands);\n-    }\n-  else\n-    output_asm_insn (\\\"comclr,%C5 %3,%4,0\\\", operands);\n-  if (which_alternative == 0)\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\toutput_asm_insn (\\\"ldo %2(0),%0\\\", operands);\n-      else \n-\toutput_asm_insn (\\\"copy %2,%0\\\", operands);\n-    }\n-  else\n-    {\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\toutput_asm_insn (\\\"ldo %1(0),%0\\\", operands);\n-      else \n-\toutput_asm_insn (\\\"copy %1,%0\\\", operands);\n-    }\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\" \"multi,multi\")\n-   (set_attr \"length\" \"2,2\")])\n-\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"fp_reg_operand\" \"=fx\")\n \t(match_operand:SI 1 \"short_memory_operand\" \"T\"))]\n@@ -826,21 +826,72 @@\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\"\n-\t\t\t  \"=r,r,Q,*q,!*r,!fx,!fx\")\n-\t(match_operand:SI 1 \"move_operand\" \"rM,Q,rM,rM,!fxy,!*r,!fx\"))]\n+  [(set (match_operand:SI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,*q,!*r,!fx,!fx\")\n+\t(match_operand:SI 1 \"move_operand\" \"rM,J,N,K,Q,rM,rM,!fx,!*r,!fx\"))]\n   \"register_operand (operands[0], SImode)\n    || reg_or_0_operand (operands[1], SImode)\"\n   \"@\n    copy %r1,%0\n+   ldi %1,%0\n+   ldil l'%1,%0\n+   zdepi %Z1,%0\n    ldw%M1 %1,%0\n    stw%M0 %r1,%0\n    mtsar %r1\n    fstws %1,-16(30)\\;ldw -16(30),%0\n    stw %1,-16(30)\\;fldws -16(30),%0\n    fcpy,sgl %1,%0\"\n-  [(set_attr \"type\" \"move,load,store,move,load,fpload,fpalu\")\n-   (set_attr \"length\" \"1,1,1,1,2,2,1\")])\n+  [(set_attr \"type\" \"move,move,move,move,load,store,move,load,fpload,fpalu\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,1,2,2,1\")])\n+\n+;; Load indexed.  We don't use unscaled modes since they can't be used\n+;; unless we can tell which of the registers is the base and which is\n+;; the index, due to PA's idea of segment selection using the top bits\n+;; of the base register.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 4))\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"ldwx,s %1(0,%2),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"1\")])\n+\n+;; Load or store with base-register modification.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 3 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SI 2 \"pre_cint_operand\" \"\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"*\n+{\n+  if (INTVAL (operands[2]) < 0)\n+    return \\\"ldwm %2(0,%0),%3\\\";\n+  return \\\"ldws,mb %2(0,%0),%3\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SI 2 \"pre_cint_operand\" \"\")))\n+\t(match_operand:SI 3 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"*\n+{\n+  if (INTVAL (operands[2]) < 0)\n+    return \\\"stwm %r3,%2(0,%0)\\\";\n+  return \\\"stws,mb %r3,%2(0,%0)\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"1\")])\n \n ;; For pic\n (define_insn \"\"\n@@ -866,35 +917,6 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"3\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"INT_14_BITS (operands[1]) || (INTVAL (operands[1]) & 0x7ff) == 0\"\n-  \"*\n-{\n-  if (INT_14_BITS (operands[1]))\n-    return \\\"ldo %1(0),%0\\\";\n-  else\n-    return \\\"ldil L'%1,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"depi_cint_operand\" \"\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[4];\n-  xoperands[0] = operands[0];\n-  compute_xdepi_operands_from_integer (INTVAL (operands[1]), xoperands);\n-  output_asm_insn (\\\"zdepi %1,%2,%3,%0\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n-\n ;; For kernel code always use addil; else we can lose due to a linker\n ;; bug involving absolute symbols and \"ldil;add\" style relocations\n (define_insn \"\"\n@@ -931,8 +953,6 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-;; The following two patterns should be for using ldil to load constants\n-;; (which include addresses of read_only_operands)\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(high:SI (match_operand 1 \"\" \"\")))]\n@@ -941,14 +961,6 @@\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(high:HI (match_operand 1 \"\" \"\")))]\n-  \"check_pic (1)\"\n-  \"ldil L'%G1,%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n-\n ;; lo_sum of a function address when TARGET_SHARED_LIBS\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -966,8 +978,6 @@\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"ldo R'%G2(%1),%0\"\n-  ;; Need to set length for this arith insn because operand2\n-  ;; is not an \"arith_operand\".\n   [(set_attr \"length\" \"1\")])\n \n (define_expand \"movhi\"\n@@ -981,46 +991,61 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q,!*r,!fx,!fx\")\n-\t(match_operand:HI 1 \"move_operand\" \"rM,Q,rM,fx,*r,!fx\"))]\n+  [(set (match_operand:HI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,*q,!*r,!fx,!fx\")\n+\t(match_operand:HI 1 \"move_operand\" \"rM,J,N,K,Q,rM,rM,!fx,!*r,!fx\"))]\n   \"register_operand (operands[0], HImode)\n    || reg_or_0_operand (operands[1], HImode)\"\n   \"@\n    copy %r1,%0\n+   ldi %1,%0\n+   ldil l'%1,%0\n+   zdepi %Z1,%0\n    ldh%M1 %1,%0\n    sth%M0 %r1,%0\n+   mtsar %r1\n    fstws %1,-16(30)\\;ldw -16(30),%0\n    stw %1,-16(30)\\;fldws -16(30),%0\n    fcpy,sgl %1,%0\"\n-  [(set_attr \"type\" \"move,load,store,load,fpload,fpalu\")\n-   (set_attr \"length\" \"1,1,1,2,2,1\")])\n+  [(set_attr \"type\" \"move,move,move,move,load,store,move,load,fpload,fpalu\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,1,2,2,1\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operand:HI 1 \"const_int_operand\" \"\"))]\n-  \"INT_14_BITS (operands[1]) || (INTVAL (operands[1]) & 0x7ff) == 0\"\n-  \"*\n-{\n-  if (INT_14_BITS (operands[1]))\n-    return \\\"ldo %1(0),%0\\\";\n-  else\n-    return \\\"ldil L'%1,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"move\")\n+\t(mem:HI (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t  (const_int 2))\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n+  \"! TARGET_DISABLE_INDEXING\"\n+  \"ldhx,s %2(0,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"1\")])\n \n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operand:HI 1 \"depi_cint_operand\" \"\"))]\n+  [(set (match_operand:HI 3 \"register_operand\" \"=r\")\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"*\n-{\n-  rtx xoperands[4];\n-  xoperands[0] = operands[0];\n-  compute_xdepi_operands_from_integer (INTVAL (operands[1]), xoperands);\n-  output_asm_insn (\\\"zdepi %1,%2,%3,%0\\\", xoperands);\n-  return \\\"\\\";\n-}\"\n+  \"ldhs,mb %2(0,%0),%3\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\")))\n+\t(match_operand:HI 3 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"sths,mb %r3,%2(0,%0)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(high:HI (match_operand 1 \"\" \"\")))]\n+  \"check_pic (1)\"\n+  \"ldil L'%G1,%0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"1\")])\n \n@@ -1043,87 +1068,46 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,Q,!*r,!fx,!fx\")\n-\t(match_operand:QI 1 \"move_operand\" \"rM,Q,rM,fx,*r,fx\"))]\n+  [(set (match_operand:QI 0 \"reg_or_nonsymb_mem_operand\" \"=r,r,r,r,r,Q,*q,!*r,!fx,!fx\")\n+\t(match_operand:QI 1 \"move_operand\" \"rM,J,N,K,Q,rM,rM,!fx,!*r,!fx\"))]\n   \"register_operand (operands[0], QImode)\n    || reg_or_0_operand (operands[1], QImode)\"\n   \"@\n    copy %r1,%0\n+   ldi %1,%0\n+   ldil l'%1,%0\n+   zdepi %Z1,%0\n    ldb%M1 %1,%0\n    stb%M0 %r1,%0\n+   mtsar %r1\n    fstws %1,-16(30)\\;ldw -16(30),%0\n    stw %1,-16(30)\\;fldws -16(30),%0\n    fcpy,sgl %1,%0\"\n-  [(set_attr \"type\" \"move,load,store,load,fpload,fpalu\")\n-   (set_attr \"length\" \"1,1,1,2,2,1\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"immediate_operand\" \"J\"))]\n-  \"\"\n-  \"ldo %1(0),%0\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"length\" \"1\")])\n+  [(set_attr \"type\" \"move,move,move,move,load,store,move,load,fpload,fpalu\")\n+   (set_attr \"length\" \"1,1,1,1,1,1,1,2,2,1\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(subreg:QI (lo_sum:SI (match_operand:QI 1 \"register_operand\" \"r\")\n-\t\t\t      (match_operand 2 \"immediate_operand\" \"i\")) 0))]\n+  [(set (match_operand:QI 3 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\"))))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"ldo R'%G2(%1),%0\"\n-  [(set_attr \"length\" \"1\")])\n-\n-;; Sneaky ways of using index modes\n-;; We don't use unscaled modes since they can't be used unless we can tell\n-;; which of the registers is the base and which is the index, due to PA's\n-;; idea of segment selection using the top bits of the base register.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 4))\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"ldwx,s %1(0,%2),%0\"\n+  \"ldbs,mb %2(0,%0),%3\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"1\")])\n \n-; this will never match\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-;\t(mem:SI (match_operand:SI 1 \"register_operand\" \"+r\")))\n-;   (set (match_dup 1)\n-;\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-;\t\t\t  (const_int 4))\n-;\t\t (match_dup 1)))]\n-;  \"! TARGET_DISABLE_INDEXING\"\n-;  \"ldwx,sm %2(0,%1),%0\"\n-;  [(set_attr \"type\" \"load\")\n-;   (set_attr \"length\" \"1\")])\n-\n (define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mem:HI (plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 2))\n-\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n-  \"! TARGET_DISABLE_INDEXING\"\n-  \"ldhx,s %2(0,%1),%0\"\n-  [(set_attr \"type\" \"load\")\n+  [(set (mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t (match_operand:SI 2 \"int5_operand\" \"L\")))\n+\t(match_operand:QI 3 \"reg_or_0_operand\" \"rM\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"stbs,mb %r3,%2(0,%0)\"\n+  [(set_attr \"type\" \"store\")\n    (set_attr \"length\" \"1\")])\n \n-; this will never match\n-;(define_insn \"\"\n-;  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-;\t(mem:HI (match_operand:SI 1 \"register_operand\" \"+r\")))\n-;   (set (match_dup 1)\n-;\t(plus:SI (mult:SI (match_operand:SI 2 \"register_operand\" \"r\")\n-;\t\t\t  (const_int 2))\n-;\t\t (match_dup 1)))]\n-;  \"! TARGET_DISABLE_INDEXING\"\n-;  \"ldhx,sm %2(0,%1),%0\"\n-;  [(set_attr \"type\" \"load\")\n-;   (set_attr \"length\" \"1\")])\n-\n ;; The definition of this insn does not really explain what it does,\n ;; but it should suffice\n ;; that anything generated as this insn will be recognized as one\n@@ -1301,9 +1285,9 @@\n \n       operands[0] = operand_subword (op0, 0, 0, DImode);\n       if (INTVAL (op1) < 0)\n-\toutput_asm_insn (\\\"ldo -1(0),%0\\\", operands);\n+\toutput_asm_insn (\\\"ldi -1,%0\\\", operands);\n       else\n-\toutput_asm_insn (\\\"ldo 0(0),%0\\\", operands);\n+\toutput_asm_insn (\\\"ldi 0,%0\\\", operands);\n       return \\\"\\\";\n     }\n   else if (GET_CODE (op1) == CONST_DOUBLE)\n@@ -1750,8 +1734,8 @@\n \n ;; The mulsi3 insns set up registers for the millicode call.\n (define_expand \"mulsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (reg:SI 26))\n@@ -1795,8 +1779,8 @@\n \n ;;; Division and mod.\n (define_expand \"divsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (div:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (reg:SI 26))\n@@ -1840,8 +1824,8 @@\n  [(set_attr \"type\" \"milli\")])\n \n (define_expand \"udivsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (udiv:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (reg:SI 26))\n@@ -1885,8 +1869,8 @@\n  [(set_attr \"type\" \"milli\")])\n \n (define_expand \"modsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (reg:SI 26))\n@@ -1926,8 +1910,8 @@\n   [(set_attr \"type\" \"milli\")])\n \n (define_expand \"umodsi3\"\n-  [(set (reg:SI 26) (match_operand:SI 1 \"srcsi_operand\" \"\"))\n-   (set (reg:SI 25) (match_operand:SI 2 \"srcsi_operand\" \"\"))\n+  [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n+   (set (reg:SI 25) (match_operand:SI 2 \"move_operand\" \"\"))\n    (parallel [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n \t      (clobber (match_operand:SI 3 \"register_operand\" \"\"))\n \t      (clobber (reg:SI 26))\n@@ -2186,7 +2170,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=fx\")\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"fx\")))]\n   \"\"\n-  \"fsub,sgl 0, %1,%0\"\n+  \"fsub,sgl 0,%1,%0\"\n   [(set_attr \"type\" \"fpalu\")])\n \n (define_insn \"absdf2\"\n@@ -2383,9 +2367,7 @@\n     return \\\"shd %1,%1,%2,%0\\\";\n   else\n     return \\\"vshd %1,%1,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"1\")])\n+}\")\n \n (define_insn \"rotlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2396,9 +2378,7 @@\n {\n   operands[2] = gen_rtx (CONST_INT, VOIDmode, (32 - INTVAL (operands[2])) & 31);\n   return \\\"shd %1,%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"binary\")\n-   (set_attr \"length\" \"1\")])\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}]}