{"sha": "34489eb2af3bbb7be101bc838615cf4a4dc6828d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0ODllYjJhZjNiYmI3YmUxMDFiYzgzODYxNWNmNGE0ZGM2ODI4ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-25T22:18:08Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-10-25T22:18:08Z"}, "message": "compiler: improve name mangling for packpaths\n    \n    The current implementation of Gogo::pkgpath_for_symbol was written in\n    a way that allowed two distinct package paths to map to the same\n    symbol, which could cause collisions at link- time or compile-time.\n    \n    Switch to a better mangling scheme to insure that we get a unique\n    packagepath symbol for each package. In the new scheme instead of having\n    separate mangling schemes for identifiers and package paths, the\n    main identifier mangler (\"go_encode_id\") now handles mangling of\n    both packagepath characters and identifier characters.\n    \n    The new mangling scheme is more intrusive: \"foo/bar.Baz\" is mangled as\n    \"foo..z2fbar.Baz\" instead of \"foo_bar.Baz\". To mitigate this, this\n    patch also adds a demangling capability so that function names\n    returned from runtime.CallersFrames are converted back to their\n    original unmangled form.\n    \n    Changing the pkgpath_for_symbol scheme requires updating a number of\n    //go:linkname directives and C \"__asm__\" directives to match the new\n    scheme, as well as updating the 'gotest' driver (which makes\n    assumptions about the correct mapping from pkgpath symbol to package\n    name).\n    \n    Fixes golang/go#27534.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/135455\n\nFrom-SVN: r265510", "tree": {"sha": "0dbda78980d4553fdaeee92ca666d72a2ab95213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dbda78980d4553fdaeee92ca666d72a2ab95213"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34489eb2af3bbb7be101bc838615cf4a4dc6828d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34489eb2af3bbb7be101bc838615cf4a4dc6828d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34489eb2af3bbb7be101bc838615cf4a4dc6828d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34489eb2af3bbb7be101bc838615cf4a4dc6828d/comments", "author": null, "committer": null, "parents": [{"sha": "fc756f9f460d5f0ec73a72128645fdb39fec77a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc756f9f460d5f0ec73a72128645fdb39fec77a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc756f9f460d5f0ec73a72128645fdb39fec77a0"}], "stats": {"total": 675, "additions": 481, "deletions": 194}, "files": [{"sha": "188ada01a3c637f162575c2a4292b66f888c6307", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -1,4 +1,4 @@\n-771668f7137e560b2ef32c8799e5f8b4c4ee14a9\n+407a59831ea4fbfe03f0887c40497b73939e7c44\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "7c7aa13ea1c9505e306026027e7722ad38677f33", "filename": "gcc/go/gofrontend/go-encode-id.cc", "status": "modified", "additions": 82, "deletions": 11, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.cc?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -1,4 +1,4 @@\n-// go-encode-id.cc -- Go identifier encoding hooks\n+// go-encode-id.cc -- Go identifier and packagepath encoding/decoding hooks\n \n // Copyright 2016 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n@@ -82,10 +82,10 @@ fetch_utf8_char(const char* p, unsigned int* pc)\n   return len;\n }\n \n-// Encode an identifier using ASCII characters.  The encoding is\n-// described in detail near the end of the long comment at the start\n-// of names.cc.  Short version: translate all non-ASCII-alphanumeric\n-// characters into ..uXXXX or ..UXXXXXXXX.\n+// Encode an identifier using assembler-friendly characters. The encoding is\n+// described in detail near the end of the long comment at the start of\n+// names.cc. Short version: translate all non-ASCII-alphanumeric characters into\n+// ..uXXXX or ..UXXXXXXXX, translate ASCII non-alphanumerics into \".zXX\".\n \n std::string\n go_encode_id(const std::string &id)\n@@ -97,7 +97,8 @@ go_encode_id(const std::string &id)\n     }\n \n   // The encoding is only unambiguous if the input string does not\n-  // contain ..u or ..U.\n+  // contain ..z, ..u or ..U.\n+  go_assert(id.find(\"..z\") == std::string::npos);\n   go_assert(id.find(\"..u\") == std::string::npos);\n   go_assert(id.find(\"..U\") == std::string::npos);\n \n@@ -116,17 +117,16 @@ go_encode_id(const std::string &id)\n     {\n       unsigned int c;\n       size_t len = fetch_utf8_char(p, &c);\n-      if (len == 1)\n+      if (len == 1 && !char_needs_encoding(c))\n \t{\n-\t  // At this point we should only be seeing alphanumerics or\n-\t  // underscore or dot.\n-\t  go_assert(!char_needs_encoding(c));\n \t  ret += c;\n \t}\n       else\n \t{\n \t  char buf[16];\n-\t  if (c < 0x10000)\n+          if (len == 1)\n+            snprintf(buf, sizeof buf, \"..z%02x\", c);\n+\t  else if (c < 0x10000)\n \t    snprintf(buf, sizeof buf, \"..u%04x\", c);\n \t  else\n \t    snprintf(buf, sizeof buf, \"..U%08x\", c);\n@@ -143,6 +143,77 @@ go_encode_id(const std::string &id)\n   return ret;\n }\n \n+// Convert a hex digit string to a unicode codepoint. No checking\n+// to insure that the hex digit is meaningful.\n+\n+static unsigned\n+hex_digits_to_unicode_codepoint(const char *digits, unsigned ndig)\n+{\n+  unsigned result = 0;\n+  for (unsigned i = 0; i < ndig; ++i) {\n+    result <<= 4;\n+    result |= Lex::hex_val(digits[i]);\n+  }\n+  return result;\n+}\n+\n+// Decode/demangle a mangled string produced by go_encode_id(). Returns\n+// empty string if demangling process fails in some way.  At the moment\n+// this routine is unused; there is an equivalent routine in the runtime\n+// used for demangling symbols appearing in stack traces.\n+\n+std::string\n+go_decode_id(const std::string &encoded)\n+{\n+  std::string ret;\n+  const char* p = encoded.c_str();\n+  const char* pend = p + encoded.length();\n+  const Location loc = Linemap::predeclared_location();\n+\n+  // Special case for initial \"_\", in case it was introduced\n+  // as a way to prevent encoded symbol starting with \".\".\n+  if (*p == '_' && (strncmp(p+1, \"..u\", 3) == 0 || strncmp(p+1, \"..U\", 3) == 0))\n+    p++;\n+\n+  while (p < pend)\n+    {\n+      if (strncmp(p, \"..z\", 3) == 0)\n+        {\n+          const char* digits = p+3;\n+          if (strlen(digits) < 2)\n+            return \"\";\n+          unsigned rune = hex_digits_to_unicode_codepoint(digits, 2);\n+          Lex::append_char(rune, true, &ret, loc);\n+          p += 5;\n+        }\n+      else if (strncmp(p, \"..u\", 3) == 0)\n+        {\n+          const char* digits = p+3;\n+          if (strlen(digits) < 4)\n+            return \"\";\n+          unsigned rune = hex_digits_to_unicode_codepoint(digits, 4);\n+          Lex::append_char(rune, true, &ret, loc);\n+          p += 7;\n+        }\n+      else if (strncmp(p, \"..U\", 3) == 0)\n+        {\n+          const char* digits = p+3;\n+          if (strlen(digits) < 8)\n+            return \"\";\n+          unsigned rune = hex_digits_to_unicode_codepoint(digits, 8);\n+          Lex::append_char(rune, true, &ret, loc);\n+          p += 11;\n+        }\n+      else\n+        {\n+          ret += *p;\n+          p += 1;\n+        }\n+    }\n+\n+  return ret;\n+}\n+\n std::string\n go_selectively_encode_id(const std::string &id)\n {"}, {"sha": "70126bae9d171b8f252943d8e0a0cc12c1cf94b9", "filename": "gcc/go/gofrontend/go-encode-id.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-encode-id.h?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -20,6 +20,11 @@ go_id_needs_encoding(const std::string& str);\n extern std::string\n go_encode_id(const std::string &id);\n \n+// Decodes an encoded ID, returning the original string handed off to\n+// go_encode_id().\n+extern std::string\n+go_decode_id(const std::string &id);\n+\n // Returns the empty string if the specified name needs encoding,\n // otherwise invokes go_encode_id on the name and returns the result.\n extern std::string"}, {"sha": "70af6273b017f65c14de2984f10f64cf99c47ea9", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -256,26 +256,11 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n   this->globals_->add_function_declaration(\"delete\", NULL, delete_type, loc);\n }\n \n-// Convert a pkgpath into a string suitable for a symbol.  Note that\n-// this transformation is convenient but imperfect.  A -fgo-pkgpath\n-// option of a/b_c will conflict with a -fgo-pkgpath option of a_b/c,\n-// possibly leading to link time errors.\n-\n std::string\n Gogo::pkgpath_for_symbol(const std::string& pkgpath)\n {\n-  std::string s = pkgpath;\n-  for (size_t i = 0; i < s.length(); ++i)\n-    {\n-      char c = s[i];\n-      if ((c >= 'a' && c <= 'z')\n-\t  || (c >= 'A' && c <= 'Z')\n-\t  || (c >= '0' && c <= '9'))\n-\t;\n-      else\n-\ts[i] = '_';\n-    }\n-  return s;\n+  go_assert(!pkgpath.empty());\n+  return go_encode_id(pkgpath);\n }\n \n // Get the package path to use for type reflection data.  This should\n@@ -319,6 +304,32 @@ Gogo::set_prefix(const std::string& arg)\n   this->prefix_from_option_ = true;\n }\n \n+// Given a name which may or may not have been hidden, append the\n+// appropriate version of the name to the result string. Take care\n+// to avoid creating a sequence that will be rejected by go_encode_id\n+// (avoid ..u, ..U, ..z).\n+void\n+Gogo::append_possibly_hidden_name(std::string *result, const std::string& name)\n+{\n+  // FIXME: This adds in pkgpath twice for hidden symbols, which is\n+  // less than ideal.\n+  if (!Gogo::is_hidden_name(name))\n+    (*result) += name;\n+  else\n+    {\n+      std::string n = \".\";\n+      std::string pkgpath = Gogo::hidden_name_pkgpath(name);\n+      char lastR = result->at(result->length() - 1);\n+      char firstP = pkgpath.at(0);\n+      if (lastR == '.' && (firstP == 'u' || firstP == 'U' || firstP == 'z'))\n+        n = \"_.\";\n+      n.append(pkgpath);\n+      n.append(1, '.');\n+      n.append(Gogo::unpack_hidden_name(name));\n+      (*result) += n;\n+    }\n+}\n+\n // Munge name for use in an error message.\n \n std::string"}, {"sha": "48359ebe560afb66066a802d9d679021e82c303c", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -199,26 +199,10 @@ class Gogo\n     return name.substr(1, name.rfind('.') - 1);\n   }\n \n-  // Given a name which may or may not have been hidden, return the\n-  // name to use within a mangled symbol name.\n-  static std::string\n-  mangle_possibly_hidden_name(const std::string& name)\n-  { \n-    // FIXME: This adds in pkgpath twice for hidden symbols, which is\n-    // less than ideal.\n-    std::string n;\n-    if (!Gogo::is_hidden_name(name))\n-      n = name;\n-    else\n-      {\n-        n = \".\";\n-        std::string pkgpath = Gogo::hidden_name_pkgpath(name);\n-        n.append(Gogo::pkgpath_for_symbol(pkgpath));\n-        n.append(1, '.');\n-        n.append(Gogo::unpack_hidden_name(name));\n-      }\n-    return n;\n-  }\n+  // Given a name which may or may not have been hidden, append the\n+  // appropriate version of the name to the result string.\n+  static void\n+  append_possibly_hidden_name(std::string *result, const std::string& name);\n \n   // Given a name which may or may not have been hidden, return the\n   // name to use in an error message."}, {"sha": "75e37f84bdc8d4cd0d5ae878d3352e2a97ee8a72", "filename": "gcc/go/gofrontend/lex.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Flex.h?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -440,6 +440,10 @@ class Lex\n   static bool\n   is_unicode_space(unsigned int c);\n \n+  // Convert the specified hex char into an unsigned integer value.\n+  static unsigned\n+  hex_val(char c);\n+\n  private:\n   ssize_t\n   get_line();\n@@ -462,9 +466,6 @@ class Lex\n   octal_value(char c)\n   { return c - '0'; }\n \n-  static unsigned\n-  hex_val(char c);\n-\n   Token\n   make_invalid_token()\n   { return Token::make_invalid_token(this->location()); }"}, {"sha": "d9ae59105df7c41856c7c21b295275c7a649df99", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -33,7 +33,7 @@\n // variable, is simply \"PKGPATH.NAME\".  Note that NAME is not the\n // packed form used for the \"hidden\" name internally in the compiler;\n // it is the name that appears in the source code.  PKGPATH is the\n-// -fgo-pkgpath option as adjusted by Gogo::pkgpath_for_symbol.  Note\n+// -fgo-pkgpath option as adjusted by Gogo::pkgpath_for_symbol. Note\n // that PKGPATH can not contain a dot and neither can NAME.  Also,\n // NAME may not begin with a digit.  NAME may require further encoding\n // for non-ASCII characters as described below, but until that\n@@ -188,12 +188,17 @@\n // encoding unambiguous, we introduce it with two consecutive dots.\n // This is followed by the letter u and four hex digits or the letter\n // U and eight digits, just as in the language only using ..u and ..U\n-// instead of \\u and \\U.  Since before this encoding names can never\n-// contain consecutive dots followed by 'u' or 'U', and after this\n-// encoding \"..u\" and \"..U\" are followed by a known number of\n+// instead of \\u and \\U.  The compiler also produces identifiers that\n+// are qualified by package path, which means that there may also be ASCII\n+// characters that are not assembler-friendly (ex: '=', '/'). The encoding\n+// scheme translates such characters into the \"..zNN\" where NN is the\n+// hex value for the character. Since before this encoding names can never\n+// contain consecutive dots followed by 'z', 'u' or 'U', and after this\n+// encoding \"..z\", \"..u\" and \"..U\" are followed by a known number of\n // characters, this is unambiguous.\n //\n // Demangling these names is straightforward:\n+//  - replace ..zXX with an ASCII character\n //  - replace ..uXXXX with a unicode character\n //  - replace ..UXXXXXXXX with a unicode character\n //  - replace .D, where D is a digit, with the character from the above\n@@ -215,9 +220,9 @@ Gogo::function_asm_name(const std::string& go_name, const Package* package,\n   if (rtype != NULL)\n     ret = rtype->deref()->mangled_name(this);\n   else if (package == NULL)\n-    ret = this->pkgpath_symbol();\n+    ret = this->pkgpath();\n   else\n-    ret = package->pkgpath_symbol();\n+    ret = package->pkgpath();\n   ret.push_back('.');\n   // Check for special names that will break if we use\n   // Gogo::unpack_hidden_name.\n@@ -268,7 +273,7 @@ Gogo::stub_method_name(const Package* package, const std::string& mname)\n \n   // We are creating a stub method for an unexported method of an\n   // imported embedded type.  We need to disambiguate the method name.\n-  std::string ret = this->pkgpath_symbol_for_package(mpkgpath);\n+  std::string ret = mpkgpath;\n   ret.push_back('.');\n   ret.append(Gogo::unpack_hidden_name(mname));\n   ret.append(\"..stub\");\n@@ -302,9 +307,9 @@ Gogo::global_var_asm_name(const std::string& go_name, const Package* package)\n {\n   std::string ret;\n   if (package == NULL)\n-    ret = this->pkgpath_symbol();\n+    ret = this->pkgpath();\n   else\n-    ret = package->pkgpath_symbol();\n+    ret = package->pkgpath();\n   ret.append(1, '.');\n   ret.append(Gogo::unpack_hidden_name(go_name));\n   return go_encode_id(ret);\n@@ -341,7 +346,7 @@ Gogo::thunk_name()\n   char thunk_name[50];\n   snprintf(thunk_name, sizeof thunk_name, \"..thunk%d\", thunk_count);\n   ++thunk_count;\n-  std::string ret = this->pkgpath_symbol();\n+  std::string ret = this->pkgpath();\n   return ret + thunk_name;\n }\n \n@@ -370,7 +375,7 @@ Gogo::init_function_name()\n   char buf[30];\n   snprintf(buf, sizeof buf, \"..init%d\", init_count);\n   ++init_count;\n-  std::string ret = this->pkgpath_symbol();\n+  std::string ret = this->pkgpath();\n   return ret + buf;\n }\n \n@@ -726,7 +731,7 @@ Struct_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \n \t  if (!p->is_anonymous())\n \t    {\n-\t      ret->append(Gogo::mangle_possibly_hidden_name(p->field_name()));\n+              Gogo::append_possibly_hidden_name(ret, p->field_name());\n \t      ret->push_back(' ');\n \t    }\n \n@@ -827,7 +832,7 @@ Interface_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n \n \t  if (!p->name().empty())\n \t    {\n-\t      ret->append(Gogo::mangle_possibly_hidden_name(p->name()));\n+              Gogo::append_possibly_hidden_name(ret, p->name());\n \t      ret->push_back(' ');\n \t    }\n \n@@ -854,9 +859,9 @@ Forward_declaration_type::do_mangled_name(Gogo* gogo, std::string* ret) const\n     {\n       const Named_object* no = this->named_object();\n       if (no->package() == NULL)\n-\tret->append(gogo->pkgpath_symbol());\n+\tret->append(gogo->pkgpath());\n       else\n-\tret->append(no->package()->pkgpath_symbol());\n+\tret->append(no->package()->pkgpath());\n       ret->push_back('.');\n       ret->append(Gogo::unpack_hidden_name(no->name()));\n     }\n@@ -894,18 +899,18 @@ Named_type::append_mangled_type_name(Gogo* gogo, bool use_alias,\n \t  if (rcvr != NULL)\n \t    ret->append(rcvr->type()->deref()->mangled_name(gogo));\n \t  else if (this->in_function_->package() == NULL)\n-\t    ret->append(gogo->pkgpath_symbol());\n+\t    ret->append(gogo->pkgpath());\n \t  else\n-\t    ret->append(this->in_function_->package()->pkgpath_symbol());\n+\t    ret->append(this->in_function_->package()->pkgpath());\n \t  ret->push_back('.');\n \t  ret->append(Gogo::unpack_hidden_name(this->in_function_->name()));\n \t}\n       else\n \t{\n \t  if (no->package() == NULL)\n-\t    ret->append(gogo->pkgpath_symbol());\n+\t    ret->append(gogo->pkgpath());\n \t  else\n-\t    ret->append(no->package()->pkgpath_symbol());\n+\t    ret->append(no->package()->pkgpath());\n \t}\n       ret->push_back('.');\n     }\n@@ -951,22 +956,22 @@ Gogo::type_descriptor_name(Type* type, Named_type* nt)\n \t  if (rcvr != NULL)\n \t    ret.append(rcvr->type()->deref()->mangled_name(this));\n \t  else if (in_function->package() == NULL)\n-\t    ret.append(this->pkgpath_symbol());\n+\t    ret.append(this->pkgpath());\n \t  else\n-\t    ret.append(in_function->package()->pkgpath_symbol());\n+\t    ret.append(in_function->package()->pkgpath());\n \t  ret.push_back('.');\n \t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n \t  ret.push_back('.');\n \t}\n \n       if (no->package() == NULL)\n-\tret.append(this->pkgpath_symbol());\n+\tret.append(this->pkgpath());\n       else\n-\tret.append(no->package()->pkgpath_symbol());\n+\tret.append(no->package()->pkgpath());\n       ret.push_back('.');\n     }\n \n-  ret.append(Gogo::mangle_possibly_hidden_name(no->name()));\n+  Gogo::append_possibly_hidden_name(&ret, no->name());\n \n   if (in_function != NULL && index > 0)\n     {"}, {"sha": "8e7567b5b0e9ccdb0e8604cb550b4b33bebcfca9", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -229,6 +229,8 @@ var exportHeader = flag.String(\"exportheader\", \"\", \"where to write export header\n var gccgo = flag.Bool(\"gccgo\", false, \"generate files for use with gccgo\")\n var gccgoprefix = flag.String(\"gccgoprefix\", \"\", \"-fgo-prefix option used with gccgo\")\n var gccgopkgpath = flag.String(\"gccgopkgpath\", \"\", \"-fgo-pkgpath option used with gccgo\")\n+var gccgoMangleCheckDone bool\n+var gccgoNewmanglingInEffect bool\n var importRuntimeCgo = flag.Bool(\"import_runtime_cgo\", true, \"import runtime/cgo in generated code\")\n var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generated code\")\n var goarch, goos string"}, {"sha": "60b2c116ba5aedff826ef98c3eecb61025e8731a", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 105, "deletions": 6, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -15,7 +15,9 @@ import (\n \t\"go/printer\"\n \t\"go/token\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n \t\"regexp\"\n \t\"sort\"\n@@ -1191,12 +1193,91 @@ func (p *Package) writeExportHeader(fgcch io.Writer) {\n \tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n }\n \n-// Return the package prefix when using gccgo.\n-func (p *Package) gccgoSymbolPrefix() string {\n-\tif !*gccgo {\n-\t\treturn \"\"\n+// gccgoUsesNewMangling returns whether gccgo uses the new collision-free\n+// packagepath mangling scheme (see determineGccgoManglingScheme for more\n+// info).\n+func gccgoUsesNewMangling() bool {\n+\tif !gccgoMangleCheckDone {\n+\t\tgccgoNewmanglingInEffect = determineGccgoManglingScheme()\n+\t\tgccgoMangleCheckDone = true\n+\t}\n+\treturn gccgoNewmanglingInEffect\n+}\n+\n+const mangleCheckCode = `\n+package l\u00e4ufer\n+func Run(x int) int {\n+  return 1\n+}\n+`\n+\n+// determineGccgoManglingScheme performs a runtime test to see which\n+// flavor of packagepath mangling gccgo is using. Older versions of\n+// gccgo use a simple mangling scheme where there can be collisions\n+// between packages whose paths are different but mangle to the same\n+// string. More recent versions of gccgo use a new mangler that avoids\n+// these collisions. Return value is whether gccgo uses the new mangling.\n+func determineGccgoManglingScheme() bool {\n+\n+\t// Emit a small Go file for gccgo to compile.\n+\tfilepat := \"*_gccgo_manglecheck.go\"\n+\tvar f *os.File\n+\tvar err error\n+\tif f, err = ioutil.TempFile(*objDir, filepat); err != nil {\n+\t\tfatalf(\"%v\", err)\n+\t}\n+\tgofilename := f.Name()\n+\tdefer os.Remove(gofilename)\n+\n+\tif err = ioutil.WriteFile(gofilename, []byte(mangleCheckCode), 0666); err != nil {\n+\t\tfatalf(\"%v\", err)\n+\t}\n+\n+\t// Compile with gccgo, capturing generated assembly.\n+\tgccgocmd := os.Getenv(\"GCCGO\")\n+\tif gccgocmd == \"\" {\n+\t\tgpath, gerr := exec.LookPath(\"gccgo\")\n+\t\tif gerr != nil {\n+\t\t\tfatalf(\"unable to locate gccgo: %v\", gerr)\n+\t\t}\n+\t\tgccgocmd = gpath\n+\t}\n+\tcmd := exec.Command(gccgocmd, \"-S\", \"-o\", \"-\", gofilename)\n+\tbuf, cerr := cmd.CombinedOutput()\n+\tif cerr != nil {\n+\t\tfatalf(\"%s\", err)\n+\t}\n+\n+\t// New mangling: expect go.l..u00e4ufer.Run\n+\t// Old mangling: expect go.l__ufer.Run\n+\treturn regexp.MustCompile(`go\\.l\\.\\.u00e4ufer\\.Run`).Match(buf)\n+}\n+\n+// gccgoPkgpathToSymbolNew converts a package path to a gccgo-style\n+// package symbol.\n+func gccgoPkgpathToSymbolNew(ppath string) string {\n+\tbsl := []byte{}\n+\tchanged := false\n+\tfor _, c := range []byte(ppath) {\n+\t\tswitch {\n+\t\tcase 'A' <= c && c <= 'Z', 'a' <= c && c <= 'z',\n+\t\t\t'0' <= c && c <= '9', '_' == c:\n+\t\t\tbsl = append(bsl, c)\n+\t\tdefault:\n+\t\t\tchanged = true\n+\t\t\tencbytes := []byte(fmt.Sprintf(\"..z%02x\", c))\n+\t\t\tbsl = append(bsl, encbytes...)\n+\t\t}\n+\t}\n+\tif !changed {\n+\t\treturn ppath\n \t}\n+\treturn string(bsl)\n+}\n \n+// gccgoPkgpathToSymbolOld converts a package path to a gccgo-style\n+// package symbol using the older mangling scheme.\n+func gccgoPkgpathToSymbolOld(ppath string) string {\n \tclean := func(r rune) rune {\n \t\tswitch {\n \t\tcase 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',\n@@ -1205,14 +1286,32 @@ func (p *Package) gccgoSymbolPrefix() string {\n \t\t}\n \t\treturn '_'\n \t}\n+\treturn strings.Map(clean, ppath)\n+}\n+\n+// gccgoPkgpathToSymbol converts a package path to a mangled packagepath\n+// symbol.\n+func gccgoPkgpathToSymbol(ppath string) string {\n+\tif gccgoUsesNewMangling() {\n+\t\treturn gccgoPkgpathToSymbolNew(ppath)\n+\t} else {\n+\t\treturn gccgoPkgpathToSymbolOld(ppath)\n+\t}\n+}\n+\n+// Return the package prefix when using gccgo.\n+func (p *Package) gccgoSymbolPrefix() string {\n+\tif !*gccgo {\n+\t\treturn \"\"\n+\t}\n \n \tif *gccgopkgpath != \"\" {\n-\t\treturn strings.Map(clean, *gccgopkgpath)\n+\t\treturn gccgoPkgpathToSymbol(*gccgopkgpath)\n \t}\n \tif *gccgoprefix == \"\" && p.PackageName == \"main\" {\n \t\treturn \"main\"\n \t}\n-\tprefix := strings.Map(clean, *gccgoprefix)\n+\tprefix := gccgoPkgpathToSymbol(*gccgoprefix)\n \tif prefix == \"\" {\n \t\tprefix = \"go\"\n \t}"}, {"sha": "1ee1ff61a065edfcd6cf7aafdd063733dcd28452", "filename": "libgo/go/internal/bytealg/bytealg.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Finternal%2Fbytealg%2Fbytealg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Finternal%2Fbytealg%2Fbytealg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fbytealg%2Fbytealg.c?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -38,7 +38,7 @@ static const void *goMemmem(const void *in, size_t inl, const void *s, size_t sl\n #endif\n \n intgo Compare(struct __go_open_array, struct __go_open_array)\n-  __asm__(GOSYM_PREFIX \"internal_bytealg.Compare\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.Compare\")\n   __attribute__((no_split_stack));\n \n intgo Compare(struct __go_open_array a, struct __go_open_array b)\n@@ -67,7 +67,7 @@ intgo Compare(struct __go_open_array a, struct __go_open_array b)\n }\n \n _Bool Equal(struct __go_open_array, struct __go_open_array)\n-  __asm__(GOSYM_PREFIX \"internal_bytealg.Equal\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.Equal\")\n   __attribute__((no_split_stack));\n \n _Bool Equal(struct __go_open_array a, struct __go_open_array b)\n@@ -82,7 +82,7 @@ _Bool Equal(struct __go_open_array a, struct __go_open_array b)\n }\n \n intgo IndexByte(struct __go_open_array, byte)\n-  __asm__(GOSYM_PREFIX \"internal_bytealg.IndexByte\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.IndexByte\")\n   __attribute__((no_split_stack));\n \n intgo IndexByte(struct __go_open_array b, byte c)\n@@ -98,7 +98,7 @@ intgo IndexByte(struct __go_open_array b, byte c)\n \n \n intgo IndexByteString(String, byte)\n-  __asm__(GOSYM_PREFIX \"internal_bytealg.IndexByteString\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.IndexByteString\")\n   __attribute__((no_split_stack));\n \n intgo IndexByteString(String s, byte c)\n@@ -113,7 +113,7 @@ intgo IndexByteString(String s, byte c)\n }\n \n intgo Index(struct __go_open_array, struct __go_open_array)\n-  __asm__(GOSYM_PREFIX \"internal_bytealg.Index\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.Index\")\n   __attribute__((no_split_stack));\n \n intgo Index(struct __go_open_array a, struct __go_open_array b)\n@@ -128,7 +128,7 @@ intgo Index(struct __go_open_array a, struct __go_open_array b)\n }\n \n intgo IndexString(String, String)\n-  __asm__(GOSYM_PREFIX \"internal_bytealg.IndexString\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fbytealg.IndexString\")\n   __attribute__((no_split_stack));\n \n intgo IndexString(String a, String b)"}, {"sha": "f9ebd8be45d630592a9a5c52ef122303709d20de", "filename": "libgo/go/internal/cpu/cpu_gccgo.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Finternal%2Fcpu%2Fcpu_gccgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Finternal%2Fcpu%2Fcpu_gccgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fcpu%2Fcpu_gccgo.c?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -21,7 +21,7 @@ struct cpuid_ret {\n };\n \n struct cpuid_ret cpuid(uint32_t, uint32_t)\n-  __asm__(GOSYM_PREFIX \"internal_cpu.cpuid\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fcpu.cpuid\")\n   __attribute__((no_split_stack));\n \n struct cpuid_ret cpuid(uint32_t eaxArg, uint32_t ecxArg) {\n@@ -45,7 +45,7 @@ struct xgetbv_ret {\n };\n \n struct xgetbv_ret xgetbv(void)\n-  __asm__(GOSYM_PREFIX \"internal_cpu.xgetbv\")\n+  __asm__(GOSYM_PREFIX \"internal..z2fcpu.xgetbv\")\n   __attribute__((no_split_stack));\n \n #pragma GCC push_options"}, {"sha": "03d8d6a48d57186ac7245d991b0ba3198fb6a5fb", "filename": "libgo/go/runtime/atomic_pointer.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fatomic_pointer.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -52,10 +52,10 @@ func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n // We cannot just call the runtime routines, because the race detector expects\n // to be able to intercept the sync/atomic forms but not the runtime forms.\n \n-//go:linkname sync_atomic_StoreUintptr sync_atomic.StoreUintptr\n+//go:linkname sync_atomic_StoreUintptr sync..z2fatomic.StoreUintptr\n func sync_atomic_StoreUintptr(ptr *uintptr, new uintptr)\n \n-//go:linkname sync_atomic_StorePointer sync_atomic.StorePointer\n+//go:linkname sync_atomic_StorePointer sync..z2fatomic.StorePointer\n //go:nosplit\n func sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer) {\n \tif writeBarrier.enabled {\n@@ -64,10 +64,10 @@ func sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer) {\n \tsync_atomic_StoreUintptr((*uintptr)(unsafe.Pointer(ptr)), uintptr(new))\n }\n \n-//go:linkname sync_atomic_SwapUintptr sync_atomic.SwapUintptr\n+//go:linkname sync_atomic_SwapUintptr sync..z2fatomic.SwapUintptr\n func sync_atomic_SwapUintptr(ptr *uintptr, new uintptr) uintptr\n \n-//go:linkname sync_atomic_SwapPointer sync_atomic.SwapPointer\n+//go:linkname sync_atomic_SwapPointer sync..z2fatomic.SwapPointer\n //go:nosplit\n func sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer {\n \tif writeBarrier.enabled {\n@@ -77,10 +77,10 @@ func sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Poi\n \treturn old\n }\n \n-//go:linkname sync_atomic_CompareAndSwapUintptr sync_atomic.CompareAndSwapUintptr\n+//go:linkname sync_atomic_CompareAndSwapUintptr sync..z2fatomic.CompareAndSwapUintptr\n func sync_atomic_CompareAndSwapUintptr(ptr *uintptr, old, new uintptr) bool\n \n-//go:linkname sync_atomic_CompareAndSwapPointer sync_atomic.CompareAndSwapPointer\n+//go:linkname sync_atomic_CompareAndSwapPointer sync..z2fatomic.CompareAndSwapPointer\n //go:nosplit\n func sync_atomic_CompareAndSwapPointer(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {\n \tif writeBarrier.enabled {"}, {"sha": "e7cf1b4102d254dbc60d4a83134fd2a5f78bcff1", "filename": "libgo/go/runtime/cpuprof.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fcpuprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcpuprof.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -186,7 +186,7 @@ func CPUProfile() []byte {\n \tpanic(\"CPUProfile no longer available\")\n }\n \n-//go:linkname runtime_pprof_runtime_cyclesPerSecond runtime_pprof.runtime_cyclesPerSecond\n+//go:linkname runtime_pprof_runtime_cyclesPerSecond runtime..z2fpprof.runtime_cyclesPerSecond\n func runtime_pprof_runtime_cyclesPerSecond() int64 {\n \treturn tickspersecond()\n }\n@@ -197,7 +197,7 @@ func runtime_pprof_runtime_cyclesPerSecond() int64 {\n // on has been returned, readProfile returns eof=true.\n // The caller must save the returned data and tags before calling readProfile again.\n //\n-//go:linkname runtime_pprof_readProfile runtime_pprof.readProfile\n+//go:linkname runtime_pprof_readProfile runtime..z2fpprof.readProfile\n func runtime_pprof_readProfile() ([]uint64, []unsafe.Pointer, bool) {\n \tlock(&cpuprof.lock)\n \tlog := cpuprof.log"}, {"sha": "309eddd818d79417b1c63548aa10f986cece32b7", "filename": "libgo/go/runtime/debug/stack_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug%2Fstack_test.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -51,10 +51,10 @@ func TestStack(t *testing.T) {\n \t\tn++\n \t}\n \tn++\n-\tframe(\"stack.go\", \"runtime_debug.Stack\")\n+\tframe(\"stack.go\", \"debug.Stack\")\n \tframe(\"stack_test.go\", \"ptrmethod\")\n \tframe(\"stack_test.go\", \"method\")\n-\tframe(\"stack_test.go\", \"runtime_debug_test.TestStack\")\n+\tframe(\"stack_test.go\", \"test.TestStack\")\n \tframe(\"testing.go\", \"\")\n }\n "}, {"sha": "5ebebf6947412bce43b957595feead9223858022", "filename": "libgo/go/runtime/heapdump.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fheapdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fheapdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fheapdump.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -16,7 +16,7 @@ import (\n \t\"unsafe\"\n )\n \n-//go:linkname runtime_debug_WriteHeapDump runtime_debug.WriteHeapDump\n+//go:linkname runtime_debug_WriteHeapDump runtime..z2fdebug.WriteHeapDump\n func runtime_debug_WriteHeapDump(fd uintptr) {\n \tstopTheWorld(\"write heap dump\")\n "}, {"sha": "b87fae96bd30f6a374f1e93880b94b6930d59dab", "filename": "libgo/go/runtime/internal/atomic/atomic.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Finternal%2Fatomic%2Fatomic.c?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -7,7 +7,7 @@\n #include \"runtime.h\"\n \n uint32_t Load (uint32_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Load\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Load\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -17,7 +17,7 @@ Load (uint32_t *ptr)\n }\n \n void *Loadp (void *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loadp\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loadp\")\n   __attribute__ ((no_split_stack));\n \n void *\n@@ -27,7 +27,7 @@ Loadp (void *ptr)\n }\n \n uint64_t Load64 (uint64_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Load64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Load64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -39,7 +39,7 @@ Load64 (uint64_t *ptr)\n }\n \n uintptr_t Loaduintptr (uintptr_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loaduintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loaduintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -49,7 +49,7 @@ Loaduintptr (uintptr_t *ptr)\n }\n \n uintgo Loaduint (uintgo *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loaduint\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loaduint\")\n   __attribute__ ((no_split_stack));\n \n uintgo\n@@ -59,7 +59,7 @@ Loaduint (uintgo *ptr)\n }\n \n int64_t Loadint64 (int64_t *ptr)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Loadint64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Loadint64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -71,7 +71,7 @@ Loadint64 (int64_t *ptr)\n }\n \n uint32_t Xadd (uint32_t *ptr, int32_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xadd\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xadd\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -81,7 +81,7 @@ Xadd (uint32_t *ptr, int32_t delta)\n }\n \n uint64_t Xadd64 (uint64_t *ptr, int64_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xadd64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xadd64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -93,7 +93,7 @@ Xadd64 (uint64_t *ptr, int64_t delta)\n }\n \n uintptr_t Xadduintptr (uintptr_t *ptr, uintptr_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xadduintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xadduintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -103,7 +103,7 @@ Xadduintptr (uintptr_t *ptr, uintptr_t delta)\n }\n \n int64_t Xaddint64 (int64_t *ptr, int64_t delta)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xaddint64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xaddint64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -115,7 +115,7 @@ Xaddint64 (int64_t *ptr, int64_t delta)\n }\n \n uint32_t Xchg (uint32_t *ptr, uint32_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xchg\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xchg\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -125,7 +125,7 @@ Xchg (uint32_t *ptr, uint32_t new)\n }\n \n uint64_t Xchg64 (uint64_t *ptr, uint64_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xchg64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xchg64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -137,7 +137,7 @@ Xchg64 (uint64_t *ptr, uint64_t new)\n }\n \n uintptr_t Xchguintptr (uintptr_t *ptr, uintptr_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Xchguintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Xchguintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -147,7 +147,7 @@ Xchguintptr (uintptr_t *ptr, uintptr_t new)\n }\n \n void And8 (uint8_t *ptr, uint8_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.And8\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.And8\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -157,7 +157,7 @@ And8 (uint8_t *ptr, uint8_t val)\n }\n \n void Or8 (uint8_t *ptr, uint8_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Or8\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Or8\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -167,7 +167,7 @@ Or8 (uint8_t *ptr, uint8_t val)\n }\n \n _Bool Cas (uint32_t *ptr, uint32_t old, uint32_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Cas\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Cas\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -177,7 +177,7 @@ Cas (uint32_t *ptr, uint32_t old, uint32_t new)\n }\n \n _Bool Cas64 (uint64_t *ptr, uint64_t old, uint64_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Cas64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Cas64\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -189,7 +189,7 @@ Cas64 (uint64_t *ptr, uint64_t old, uint64_t new)\n }\n \n _Bool Casp1 (void **ptr, void *old, void *new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Casp1\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Casp1\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -199,7 +199,7 @@ Casp1 (void **ptr, void *old, void *new)\n }\n \n _Bool Casuintptr (uintptr_t *ptr, uintptr_t old, uintptr_t new)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Casuintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Casuintptr\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -209,7 +209,7 @@ Casuintptr (uintptr_t *ptr, uintptr_t old, uintptr_t new)\n }\n \n void Store (uint32_t *ptr, uint32_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Store\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Store\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -219,7 +219,7 @@ Store (uint32_t *ptr, uint32_t val)\n }\n \n void Store64 (uint64_t *ptr, uint64_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Store64\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Store64\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -231,7 +231,7 @@ Store64 (uint64_t *ptr, uint64_t val)\n }\n \n void Storeuintptr (uintptr_t *ptr, uintptr_t val)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.Storeuintptr\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.Storeuintptr\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -241,7 +241,7 @@ Storeuintptr (uintptr_t *ptr, uintptr_t val)\n }\n \n void StorepNoWB (void *ptr, void *val)\n-  __asm__ (GOSYM_PREFIX \"runtime_internal_atomic.StorepNoWB\")\n+  __asm__ (GOSYM_PREFIX \"runtime..z2finternal..z2fatomic.StorepNoWB\")\n   __attribute__ ((no_split_stack));\n \n void"}, {"sha": "de84084b391ca73259d688fa67f514395e1a5b5c", "filename": "libgo/go/runtime/mgc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fmgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fmgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -219,7 +219,7 @@ func gcenable() {\n \tmemstats.enablegc = true // now that runtime is initialized, GC is okay\n }\n \n-//go:linkname setGCPercent runtime_debug.setGCPercent\n+//go:linkname setGCPercent runtime..z2fdebug.setGCPercent\n func setGCPercent(in int32) (out int32) {\n \tlock(&mheap_.lock)\n \tout = gcpercent"}, {"sha": "eb98083fecc3fbdad065b0bb412752ace37d36fa", "filename": "libgo/go/runtime/mheap.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fmheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fmheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmheap.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -1165,7 +1165,7 @@ func (h *mheap) scavenge(k int32, now, limit uint64) {\n \t}\n }\n \n-//go:linkname runtime_debug_freeOSMemory runtime_debug.freeOSMemory\n+//go:linkname runtime_debug_freeOSMemory runtime..z2fdebug.freeOSMemory\n func runtime_debug_freeOSMemory() {\n \tGC()\n \tsystemstack(func() { mheap_.scavenge(-1, ^uint64(0), 0) })"}, {"sha": "8aac8502e0bc1403b5b573053a92b494874d1a02", "filename": "libgo/go/runtime/mstats.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fmstats.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fmstats.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmstats.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -477,7 +477,7 @@ func readmemstats_m(stats *MemStats) {\n \tstats.StackSys += stats.StackInuse\n }\n \n-//go:linkname readGCStats runtime_debug.readGCStats\n+//go:linkname readGCStats runtime..z2fdebug.readGCStats\n func readGCStats(pauses *[]uint64) {\n \tsystemstack(func() {\n \t\treadGCStats_m(pauses)"}, {"sha": "907c31975c75f6dc0774cd35043fe4fb60293da7", "filename": "libgo/go/runtime/net_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fnet_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fnet_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnet_plan9.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -8,12 +8,12 @@ import (\n \t_ \"unsafe\"\n )\n \n-//go:linkname runtime_ignoreHangup internal_poll.runtime_ignoreHangup\n+//go:linkname runtime_ignoreHangup internal..z2fpoll.runtime_ignoreHangup\n func runtime_ignoreHangup() {\n \tgetg().m.ignoreHangup = true\n }\n \n-//go:linkname runtime_unignoreHangup internal_poll.runtime_unignoreHangup\n+//go:linkname runtime_unignoreHangup internal..z2fpoll.runtime_unignoreHangup\n func runtime_unignoreHangup(sig string) {\n \tgetg().m.ignoreHangup = false\n }"}, {"sha": "6016b7d64f5a694b5e58267d5a11179e897267f5", "filename": "libgo/go/runtime/netpoll.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fnetpoll.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -85,7 +85,7 @@ var (\n \tnetpollWaiters uint32\n )\n \n-//go:linkname poll_runtime_pollServerInit internal_poll.runtime_pollServerInit\n+//go:linkname poll_runtime_pollServerInit internal..z2fpoll.runtime_pollServerInit\n func poll_runtime_pollServerInit() {\n \tnetpollinit()\n \tatomic.Store(&netpollInited, 1)\n@@ -95,15 +95,15 @@ func netpollinited() bool {\n \treturn atomic.Load(&netpollInited) != 0\n }\n \n-//go:linkname poll_runtime_pollServerDescriptor internal_poll.runtime_pollServerDescriptor\n+//go:linkname poll_runtime_pollServerDescriptor internal..z2fpoll.runtime_pollServerDescriptor\n \n // poll_runtime_pollServerDescriptor returns the descriptor being used,\n // or ^uintptr(0) if the system does not use a poll descriptor.\n func poll_runtime_pollServerDescriptor() uintptr {\n \treturn netpolldescriptor()\n }\n \n-//go:linkname poll_runtime_pollOpen internal_poll.runtime_pollOpen\n+//go:linkname poll_runtime_pollOpen internal..z2fpoll.runtime_pollOpen\n func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {\n \tpd := pollcache.alloc()\n \tlock(&pd.lock)\n@@ -127,7 +127,7 @@ func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {\n \treturn pd, int(errno)\n }\n \n-//go:linkname poll_runtime_pollClose internal_poll.runtime_pollClose\n+//go:linkname poll_runtime_pollClose internal..z2fpoll.runtime_pollClose\n func poll_runtime_pollClose(pd *pollDesc) {\n \tif !pd.closing {\n \t\tthrow(\"runtime: close polldesc w/o unblock\")\n@@ -149,7 +149,7 @@ func (c *pollCache) free(pd *pollDesc) {\n \tunlock(&c.lock)\n }\n \n-//go:linkname poll_runtime_pollReset internal_poll.runtime_pollReset\n+//go:linkname poll_runtime_pollReset internal..z2fpoll.runtime_pollReset\n func poll_runtime_pollReset(pd *pollDesc, mode int) int {\n \terr := netpollcheckerr(pd, int32(mode))\n \tif err != 0 {\n@@ -163,7 +163,7 @@ func poll_runtime_pollReset(pd *pollDesc, mode int) int {\n \treturn 0\n }\n \n-//go:linkname poll_runtime_pollWait internal_poll.runtime_pollWait\n+//go:linkname poll_runtime_pollWait internal..z2fpoll.runtime_pollWait\n func poll_runtime_pollWait(pd *pollDesc, mode int) int {\n \terr := netpollcheckerr(pd, int32(mode))\n \tif err != 0 {\n@@ -185,15 +185,15 @@ func poll_runtime_pollWait(pd *pollDesc, mode int) int {\n \treturn 0\n }\n \n-//go:linkname poll_runtime_pollWaitCanceled internal_poll.runtime_pollWaitCanceled\n+//go:linkname poll_runtime_pollWaitCanceled internal..z2fpoll.runtime_pollWaitCanceled\n func poll_runtime_pollWaitCanceled(pd *pollDesc, mode int) {\n \t// This function is used only on windows after a failed attempt to cancel\n \t// a pending async IO operation. Wait for ioready, ignore closing or timeouts.\n \tfor !netpollblock(pd, int32(mode), true) {\n \t}\n }\n \n-//go:linkname poll_runtime_pollSetDeadline internal_poll.runtime_pollSetDeadline\n+//go:linkname poll_runtime_pollSetDeadline internal..z2fpoll.runtime_pollSetDeadline\n func poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {\n \tlock(&pd.lock)\n \tif pd.closing {\n@@ -263,7 +263,7 @@ func poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {\n \t}\n }\n \n-//go:linkname poll_runtime_pollUnblock internal_poll.runtime_pollUnblock\n+//go:linkname poll_runtime_pollUnblock internal..z2fpoll.runtime_pollUnblock\n func poll_runtime_pollUnblock(pd *pollDesc) {\n \tlock(&pd.lock)\n \tif pd.closing {"}, {"sha": "f428827232a9c59023e16228bc322b640a7fe3d7", "filename": "libgo/go/runtime/pprof/mprof_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -87,19 +87,19 @@ func TestMemoryProfiler(t *testing.T) {\n \n \t\tfmt.Sprintf(`%v: %v \\[%v: %v\\] @ 0x[0-9,a-f x]+\n #\t0x[0-9,a-f]+\tpprof\\.allocatePersistent1K\\+0x[0-9,a-f]+\t.*/mprof_test\\.go:40\n-#\t0x[0-9,a-f]+\truntime_pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test\\.go:74\n+#\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test\\.go:74\n `, 32*memoryProfilerRun, 1024*memoryProfilerRun, 32*memoryProfilerRun, 1024*memoryProfilerRun),\n \n \t\tfmt.Sprintf(`0: 0 \\[%v: %v\\] @ 0x[0-9,a-f x]+\n #\t0x[0-9,a-f]+\tpprof\\.allocateTransient1M\\+0x[0-9,a-f]+\t.*/mprof_test.go:21\n-#\t0x[0-9,a-f]+\truntime_pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:72\n+#\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:72\n `, (1<<10)*memoryProfilerRun, (1<<20)*memoryProfilerRun),\n \n \t\t// This should start with \"0: 0\" but gccgo's imprecise\n \t\t// GC means that sometimes the value is not collected.\n \t\tfmt.Sprintf(`(0|%v): (0|%v) \\[%v: %v\\] @ 0x[0-9,a-f x]+\n #\t0x[0-9,a-f]+\tpprof\\.allocateTransient2M\\+0x[0-9,a-f]+\t.*/mprof_test.go:27\n-#\t0x[0-9,a-f]+\truntime_pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:73\n+#\t0x[0-9,a-f]+\truntime/pprof\\.TestMemoryProfiler\\+0x[0-9,a-f]+\t.*/mprof_test.go:73\n `, memoryProfilerRun, (2<<20)*memoryProfilerRun, memoryProfilerRun, (2<<20)*memoryProfilerRun),\n \n \t\t// This should start with \"0: 0\" but gccgo's imprecise"}, {"sha": "bb16924e01c6d158456a474541d083505c50ab08", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -4670,7 +4670,7 @@ func runqsteal(_p_, p2 *p, stealRunNextG bool) *g {\n \treturn gp\n }\n \n-//go:linkname setMaxThreads runtime_debug.setMaxThreads\n+//go:linkname setMaxThreads runtime..z2fdebug.setMaxThreads\n func setMaxThreads(in int) (out int) {\n \tlock(&sched.lock)\n \tout = int(sched.maxmcount)\n@@ -4716,13 +4716,13 @@ func sync_runtime_procUnpin() {\n \tprocUnpin()\n }\n \n-//go:linkname sync_atomic_runtime_procPin sync_atomic.runtime_procPin\n+//go:linkname sync_atomic_runtime_procPin sync..z2fatomic.runtime_procPin\n //go:nosplit\n func sync_atomic_runtime_procPin() int {\n \treturn procPin()\n }\n \n-//go:linkname sync_atomic_runtime_procUnpin sync_atomic.runtime_procUnpin\n+//go:linkname sync_atomic_runtime_procUnpin sync..z2fatomic.runtime_procUnpin\n //go:nosplit\n func sync_atomic_runtime_procUnpin() {\n \tprocUnpin()"}, {"sha": "fc655cc80199e1913048bd196a805a191a975dbb", "filename": "libgo/go/runtime/proflabel.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fproflabel.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fproflabel.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproflabel.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -8,7 +8,7 @@ import \"unsafe\"\n \n var labelSync uintptr\n \n-//go:linkname runtime_setProfLabel runtime_pprof.runtime_setProfLabel\n+//go:linkname runtime_setProfLabel runtime..z2fpprof.runtime_setProfLabel\n func runtime_setProfLabel(labels unsafe.Pointer) {\n \t// Introduce race edge for read-back via profile.\n \t// This would more properly use &getg().labels as the sync address,\n@@ -34,7 +34,7 @@ func runtime_setProfLabel(labels unsafe.Pointer) {\n \tgetg().labels = labels\n }\n \n-//go:linkname runtime_getProfLabel runtime_pprof.runtime_getProfLabel\n+//go:linkname runtime_getProfLabel runtime..z2fpprof.runtime_getProfLabel\n func runtime_getProfLabel() unsafe.Pointer {\n \treturn getg().labels\n }"}, {"sha": "358df111b553741da9c10a0818af4bda01b4b597", "filename": "libgo/go/runtime/rdebug.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Frdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Frdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Frdebug.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -11,14 +11,14 @@ import _ \"unsafe\" // for go:linkname\n // maxstacksize.\n var maxstacksize uintptr = 1 << 20 // enough until runtime.main sets it for real\n \n-//go:linkname setMaxStack runtime_debug.setMaxStack\n+//go:linkname setMaxStack runtime..z2fdebug.setMaxStack\n func setMaxStack(in int) (out int) {\n \tout = int(maxstacksize)\n \tmaxstacksize = uintptr(in)\n \treturn out\n }\n \n-//go:linkname setPanicOnFault runtime_debug.setPanicOnFault\n+//go:linkname setPanicOnFault runtime..z2fdebug.setPanicOnFault\n func setPanicOnFault(new bool) (old bool) {\n \t_g_ := getg()\n \told = _g_.paniconfault"}, {"sha": "050f180c4076a4d0aac0332e560518fc196cd4c5", "filename": "libgo/go/runtime/runtime1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fruntime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fruntime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime1.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -413,7 +413,7 @@ func parsedebugvars() {\n \ttraceback_env = traceback_cache\n }\n \n-//go:linkname setTraceback runtime_debug.SetTraceback\n+//go:linkname setTraceback runtime..z2fdebug.SetTraceback\n func setTraceback(level string) {\n \tvar t uint32\n \tswitch level {"}, {"sha": "273e8aa54d9e4025bcd89ed23a86ea8a8e54eda8", "filename": "libgo/go/runtime/sema.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fsema.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fsema.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsema.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -56,7 +56,7 @@ func sync_runtime_Semacquire(addr *uint32) {\n \tsemacquire1(addr, false, semaBlockProfile)\n }\n \n-//go:linkname poll_runtime_Semacquire internal_poll.runtime_Semacquire\n+//go:linkname poll_runtime_Semacquire internal..z2fpoll.runtime_Semacquire\n func poll_runtime_Semacquire(addr *uint32) {\n \tsemacquire1(addr, false, semaBlockProfile)\n }\n@@ -71,7 +71,7 @@ func sync_runtime_SemacquireMutex(addr *uint32, lifo bool) {\n \tsemacquire1(addr, lifo, semaBlockProfile|semaMutexProfile)\n }\n \n-//go:linkname poll_runtime_Semrelease internal_poll.runtime_Semrelease\n+//go:linkname poll_runtime_Semrelease internal..z2fpoll.runtime_Semrelease\n func poll_runtime_Semrelease(addr *uint32) {\n \tsemrelease(addr)\n }"}, {"sha": "1a29b207f818bc246ba85724ed46d3537123db30", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -117,7 +117,7 @@ Send:\n \n // Called to receive the next queued signal.\n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_recv os_signal.signal_recv\n+//go:linkname signal_recv os..z2fsignal.signal_recv\n func signal_recv() uint32 {\n \tfor {\n \t\t// Serve any signals from local copy.\n@@ -161,7 +161,7 @@ func signal_recv() uint32 {\n // the signal(s) in question, and here we are just waiting to make sure\n // that all the signals have been delivered to the user channels\n // by the os/signal package.\n-//go:linkname signalWaitUntilIdle os_signal.signalWaitUntilIdle\n+//go:linkname signalWaitUntilIdle os..z2fsignal.signalWaitUntilIdle\n func signalWaitUntilIdle() {\n \t// Although the signals we care about have been removed from\n \t// sig.wanted, it is possible that another thread has received\n@@ -181,7 +181,7 @@ func signalWaitUntilIdle() {\n }\n \n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_enable os_signal.signal_enable\n+//go:linkname signal_enable os..z2fsignal.signal_enable\n func signal_enable(s uint32) {\n \tif !sig.inuse {\n \t\t// The first call to signal_enable is for us\n@@ -208,7 +208,7 @@ func signal_enable(s uint32) {\n }\n \n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_disable os_signal.signal_disable\n+//go:linkname signal_disable os..z2fsignal.signal_disable\n func signal_disable(s uint32) {\n \tif s >= uint32(len(sig.wanted)*32) {\n \t\treturn\n@@ -221,7 +221,7 @@ func signal_disable(s uint32) {\n }\n \n // Must only be called from a single goroutine at a time.\n-//go:linkname signal_ignore os_signal.signal_ignore\n+//go:linkname signal_ignore os..z2fsignal.signal_ignore\n func signal_ignore(s uint32) {\n \tif s >= uint32(len(sig.wanted)*32) {\n \t\treturn\n@@ -248,7 +248,7 @@ func sigInitIgnored(s uint32) {\n }\n \n // Checked by signal handlers.\n-//go:linkname signal_ignored os_signal.signal_ignored\n+//go:linkname signal_ignored os..z2fsignal.signal_ignored\n func signal_ignored(s uint32) bool {\n \ti := atomic.Load(&sig.ignored[s/32])\n \treturn i&(1<<(s&31)) != 0"}, {"sha": "d137122137cb124a0a323a0b837d07f3f5f4cf55", "filename": "libgo/go/runtime/symtab.go", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fsymtab.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Fsymtab.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsymtab.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -83,6 +83,11 @@ func (ci *Frames) Next() (frame Frame, more bool) {\n \tif function == \"\" && file == \"\" {\n \t\treturn Frame{}, more\n \t}\n+\n+\t// Demangle function name if needed.\n+\tfunction = demangleSymbol(function)\n+\n+\t// Create entry.\n \tentry := funcentry(pc - 1)\n \tf := &Func{name: function, entry: entry}\n \n@@ -182,6 +187,75 @@ func (f *Func) FileLine(pc uintptr) (file string, line int) {\n \treturn file, line\n }\n \n+func hexval(b byte) uint {\n+\tif b >= '0' && b <= '9' {\n+\t\treturn uint(b - '0')\n+\t}\n+\tif b >= 'a' && b <= 'f' {\n+\t\treturn uint(b-'a') + 10\n+\t}\n+\treturn 0\n+}\n+\n+func hexDigitsToRune(digits []byte, ndig int) rune {\n+\tresult := uint(0)\n+\tfor i := 0; i < ndig; i++ {\n+\t\tresult <<= uint(4)\n+\t\tresult |= hexval(digits[i])\n+\t}\n+\treturn rune(result)\n+}\n+\n+// Perform an in-place decoding on the input byte slice. This looks\n+// for \"..z<hex 2 >\", \"..u<hex x 4>\" and \"..U<hex x 8>\" and overwrites\n+// with the encoded bytes corresponding to the unicode in question.\n+// Return value is the number of bytes taken by the result.\n+\n+func decodeIdentifier(bsl []byte) int {\n+\tj := 0\n+\tfor i := 0; i < len(bsl); i++ {\n+\t\tb := bsl[i]\n+\n+\t\tif i+1 < len(bsl) && bsl[i] == '.' && bsl[i+1] == '.' {\n+\t\t\tif i+4 < len(bsl) && bsl[i+2] == 'z' {\n+\t\t\t\tdigits := bsl[i+3:]\n+\t\t\t\tr := hexDigitsToRune(digits, 2)\n+\t\t\t\tnc := encoderune(bsl[j:], r)\n+\t\t\t\tj += nc\n+\t\t\t\ti += 4\n+\t\t\t\tcontinue\n+\t\t\t} else if i+6 < len(bsl) && bsl[i+2] == 'u' {\n+\t\t\t\tdigits := bsl[i+3:]\n+\t\t\t\tr := hexDigitsToRune(digits, 4)\n+\t\t\t\tnc := encoderune(bsl[j:], r)\n+\t\t\t\tj += nc\n+\t\t\t\ti += 6\n+\t\t\t\tcontinue\n+\t\t\t} else if i+10 < len(bsl) && bsl[i+2] == 'U' {\n+\t\t\t\tdigits := bsl[i+3:]\n+\t\t\t\tr := hexDigitsToRune(digits, 8)\n+\t\t\t\tnc := encoderune(bsl[j:], r)\n+\t\t\t\tj += nc\n+\t\t\t\ti += 10\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tbsl[j] = b\n+\t\tj += 1\n+\t}\n+\treturn j\n+}\n+\n+// Demangle a function symbol. Applies the reverse of go_encode_id()\n+// as used in the compiler.\n+\n+func demangleSymbol(s string) string {\n+\tbsl := []byte(s)\n+\tnchars := decodeIdentifier(bsl)\n+\tbsl = bsl[:nchars]\n+\treturn string(bsl)\n+}\n+\n // implemented in go-caller.c\n func funcfileline(uintptr, int32) (string, string, int)\n func funcentry(uintptr) uintptr"}, {"sha": "ea61baa9195fe65176a310cb22956c6357bf29c7", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -441,7 +441,7 @@ func badTimer() {\n \n // Entry points for net, time to call nanotime.\n \n-//go:linkname poll_runtimeNano internal_poll.runtimeNano\n+//go:linkname poll_runtimeNano internal..z2fpoll.runtimeNano\n func poll_runtimeNano() int64 {\n \treturn nanotime()\n }"}, {"sha": "530d5e4c86e4948f5b576b9cecbc8fda062cfaa1", "filename": "libgo/go/runtime/trace.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Ftrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Ftrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -1143,7 +1143,7 @@ func traceNextGC() {\n // To access runtime functions from runtime/trace.\n // See runtime/trace/annotation.go\n \n-//go:linkname trace_userTaskCreate runtime_trace.userTaskCreate\n+//go:linkname trace_userTaskCreate runtime..z2ftrace.userTaskCreate\n func trace_userTaskCreate(id, parentID uint64, taskType string) {\n \tif !trace.enabled {\n \t\treturn\n@@ -1161,12 +1161,12 @@ func trace_userTaskCreate(id, parentID uint64, taskType string) {\n \ttraceReleaseBuffer(pid)\n }\n \n-//go:linkname trace_userTaskEnd runtime_trace.userTaskEnd\n+//go:linkname trace_userTaskEnd runtime..z2ftrace.userTaskEnd\n func trace_userTaskEnd(id uint64) {\n \ttraceEvent(traceEvUserTaskEnd, 2, id)\n }\n \n-//go:linkname trace_userRegion runtime_trace.userRegion\n+//go:linkname trace_userRegion runtime..z2ftrace.userRegion\n func trace_userRegion(id, mode uint64, name string) {\n \tif !trace.enabled {\n \t\treturn\n@@ -1183,7 +1183,7 @@ func trace_userRegion(id, mode uint64, name string) {\n \ttraceReleaseBuffer(pid)\n }\n \n-//go:linkname trace_userLog runtime_trace.userLog\n+//go:linkname trace_userLog runtime..z2ftrace.userLog\n func trace_userLog(id uint64, category, message string) {\n \tif !trace.enabled {\n \t\treturn"}, {"sha": "7347cea71b22ea0597797957eca00d0910229237", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -110,9 +110,14 @@ func showframe(name string, gp *g) bool {\n }\n \n // isExportedRuntime reports whether name is an exported runtime function.\n-// It is only for runtime functions, so ASCII A-Z is fine.\n+// It is only for runtime functions, so ASCII A-Z is fine. Here also check\n+// for mangled functions from runtime/<...>, which will be prefixed with\n+// \"runtime..z2f\".\n func isExportedRuntime(name string) bool {\n \tconst n = len(\"runtime.\")\n+\tif hasprefix(name, \"runtime..z2f\") {\n+\t\treturn true\n+\t}\n \treturn len(name) > n && name[:n] == \"runtime.\" && 'A' <= name[n] && name[n] <= 'Z'\n }\n "}, {"sha": "6cc730ffe5592cec07545416babd826c0ae58c80", "filename": "libgo/go/sync/atomic/atomic.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fatomic%2Fatomic.c?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -9,7 +9,7 @@\n #include \"runtime.h\"\n \n int32_t SwapInt32 (int32_t *, int32_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.SwapInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapInt32\")\n   __attribute__ ((no_split_stack));\n \n int32_t\n@@ -19,7 +19,7 @@ SwapInt32 (int32_t *addr, int32_t new)\n }\n \n int64_t SwapInt64 (int64_t *, int64_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.SwapInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapInt64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -31,7 +31,7 @@ SwapInt64 (int64_t *addr, int64_t new)\n }\n \n uint32_t SwapUint32 (uint32_t *, uint32_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.SwapUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapUint32\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -41,7 +41,7 @@ SwapUint32 (uint32_t *addr, uint32_t new)\n }\n \n uint64_t SwapUint64 (uint64_t *, uint64_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.SwapUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapUint64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -53,7 +53,7 @@ SwapUint64 (uint64_t *addr, uint64_t new)\n }\n \n uintptr_t SwapUintptr (uintptr_t *, uintptr_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.SwapUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.SwapUintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -63,7 +63,7 @@ SwapUintptr (uintptr_t *addr, uintptr_t new)\n }\n \n _Bool CompareAndSwapInt32 (int32_t *, int32_t, int32_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapInt32\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -73,7 +73,7 @@ CompareAndSwapInt32 (int32_t *val, int32_t old, int32_t new)\n }\n \n _Bool CompareAndSwapInt64 (int64_t *, int64_t, int64_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapInt64\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -85,7 +85,7 @@ CompareAndSwapInt64 (int64_t *val, int64_t old, int64_t new)\n }\n \n _Bool CompareAndSwapUint32 (uint32_t *, uint32_t, uint32_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapUint32\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -95,7 +95,7 @@ CompareAndSwapUint32 (uint32_t *val, uint32_t old, uint32_t new)\n }\n \n _Bool CompareAndSwapUint64 (uint64_t *, uint64_t, uint64_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapUint64\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -107,7 +107,7 @@ CompareAndSwapUint64 (uint64_t *val, uint64_t old, uint64_t new)\n }\n \n _Bool CompareAndSwapUintptr (uintptr_t *, uintptr_t, uintptr_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.CompareAndSwapUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.CompareAndSwapUintptr\")\n   __attribute__ ((no_split_stack));\n \n _Bool\n@@ -117,7 +117,7 @@ CompareAndSwapUintptr (uintptr_t *val, uintptr_t old, uintptr_t new)\n }\n \n int32_t AddInt32 (int32_t *, int32_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.AddInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddInt32\")\n   __attribute__ ((no_split_stack));\n \n int32_t\n@@ -127,7 +127,7 @@ AddInt32 (int32_t *val, int32_t delta)\n }\n \n uint32_t AddUint32 (uint32_t *, uint32_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.AddUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddUint32\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -137,7 +137,7 @@ AddUint32 (uint32_t *val, uint32_t delta)\n }\n \n int64_t AddInt64 (int64_t *, int64_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.AddInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddInt64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -149,7 +149,7 @@ AddInt64 (int64_t *val, int64_t delta)\n }\n \n uint64_t AddUint64 (uint64_t *, uint64_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.AddUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddUint64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -161,7 +161,7 @@ AddUint64 (uint64_t *val, uint64_t delta)\n }\n \n uintptr_t AddUintptr (uintptr_t *, uintptr_t)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.AddUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.AddUintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -171,7 +171,7 @@ AddUintptr (uintptr_t *val, uintptr_t delta)\n }\n \n int32_t LoadInt32 (int32_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.LoadInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadInt32\")\n   __attribute__ ((no_split_stack));\n \n int32_t\n@@ -186,7 +186,7 @@ LoadInt32 (int32_t *addr)\n }\n \n int64_t LoadInt64 (int64_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.LoadInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadInt64\")\n   __attribute__ ((no_split_stack));\n \n int64_t\n@@ -203,7 +203,7 @@ LoadInt64 (int64_t *addr)\n }\n \n uint32_t LoadUint32 (uint32_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.LoadUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadUint32\")\n   __attribute__ ((no_split_stack));\n \n uint32_t\n@@ -218,7 +218,7 @@ LoadUint32 (uint32_t *addr)\n }\n \n uint64_t LoadUint64 (uint64_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.LoadUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadUint64\")\n   __attribute__ ((no_split_stack));\n \n uint64_t\n@@ -235,7 +235,7 @@ LoadUint64 (uint64_t *addr)\n }\n \n uintptr_t LoadUintptr (uintptr_t *addr)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.LoadUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadUintptr\")\n   __attribute__ ((no_split_stack));\n \n uintptr_t\n@@ -250,7 +250,7 @@ LoadUintptr (uintptr_t *addr)\n }\n \n void *LoadPointer (void **addr)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.LoadPointer\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.LoadPointer\")\n   __attribute__ ((no_split_stack));\n \n void *\n@@ -265,7 +265,7 @@ LoadPointer (void **addr)\n }\n \n void StoreInt32 (int32_t *addr, int32_t val)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.StoreInt32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreInt32\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -279,7 +279,7 @@ StoreInt32 (int32_t *addr, int32_t val)\n }\n \n void StoreInt64 (int64_t *addr, int64_t val)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.StoreInt64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreInt64\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -295,7 +295,7 @@ StoreInt64 (int64_t *addr, int64_t val)\n }\n \n void StoreUint32 (uint32_t *addr, uint32_t val)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.StoreUint32\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreUint32\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -309,7 +309,7 @@ StoreUint32 (uint32_t *addr, uint32_t val)\n }\n \n void StoreUint64 (uint64_t *addr, uint64_t val)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.StoreUint64\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreUint64\")\n   __attribute__ ((no_split_stack));\n \n void\n@@ -325,7 +325,7 @@ StoreUint64 (uint64_t *addr, uint64_t val)\n }\n \n void StoreUintptr (uintptr_t *addr, uintptr_t val)\n-  __asm__ (GOSYM_PREFIX \"sync_atomic.StoreUintptr\")\n+  __asm__ (GOSYM_PREFIX \"sync..z2fatomic.StoreUintptr\")\n   __attribute__ ((no_split_stack));\n \n void"}, {"sha": "f1309aba39a3db359282755de7420ed5a881245d", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34489eb2af3bbb7be101bc838615cf4a4dc6828d/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=34489eb2af3bbb7be101bc838615cf4a4dc6828d", "patch": "@@ -504,6 +504,35 @@ localname() {\n \techo $1 | sed 's/^main\\./__main__./'\n }\n \n+# Takes a list of tests derived from 'nm' output (whose symbols are mangled)\n+# and emits a demangled list of tests, using only the terminal package.\n+# Example:\n+#\n+#    Original symbol:   foo/bar/leaf.Mumble\n+#    Mangled symbol:    foo..z2fbar..z2fleaf.Mumble\n+#    Returned:          leaf.Mumble\n+#\n+symtogo() {\n+  local s=\"\"\n+  local result=\"\"\n+  local ndots=\"\"\n+  for tp in $*\n+  do\n+    s=$(echo $tp | sed -e 's/\\.\\.z2f/%/g' | sed -e 's/.*%//')\n+    # screen out methods (X.Y.Z)\n+    ndots=$(echo $s | sed -e 's/\\./ /g' | wc -w)\n+    if [ $ndots -ne 2 ]; then\n+      continue\n+    fi\n+    if [ -z \"${result}\" ]; then\n+      result=\"${s}\"\n+    else\n+      result=\"${result} ${s}\"\n+    fi\n+  done\n+  echo \"$result\" | sed -e 's/ /\\n/g'\n+}\n+\n {\n \ttext=\"T\"\n \n@@ -514,26 +543,27 @@ localname() {\n \t    text=\"[TD]\"\n \tfi\n \n-\tsymtogo='sed -e s/_test\\([^A-Za-z0-9]\\)/XXXtest\\1/ -e s/.*_\\([^_]*\\.\\)/\\1/ -e s/XXXtest/_test/'\n-\n \t# test functions are named TestFoo\n \t# the grep -v eliminates methods and other special names\n \t# that have multiple dots.\n \tpattern='Test([^a-z].*)?'\n \t# The -p option tells GNU nm not to sort.\n \t# The -v option tells Solaris nm to sort by value.\n-\ttests=$($NM -p -v _gotest_.o $xofile | egrep \" $text .*\\.\"$pattern'$' | grep -v '[^ ]\\..*\\.' | fgrep -v ' __go_' | sed 's/.* //' | $symtogo)\n+        testsyms=$($NM -p -v _gotest_.o $xofile | egrep \" $text .*\\.\"$pattern'$' | fgrep -v ' __go_' | egrep -v '\\.\\.\\w+$' | sed 's/.* //')\n+        tests=$(symtogo \"$testsyms\")\n \tif [ \"x$tests\" = x ]; then\n \t\techo 'gotest: warning: no tests matching '$pattern in _gotest_.o $xofile 1>&2\n \t\texit 2\n \tfi\n \t# benchmarks are named BenchmarkFoo.\n \tpattern='Benchmark([^a-z].*)?'\n-\tbenchmarks=$($NM -p -v _gotest_.o $xofile | egrep \" $text .*\\.\"$pattern'$' | grep -v '[^ ]\\..*\\.' | fgrep -v ' __go_' | sed 's/.* //' | $symtogo)\n+\tbenchmarksyms=$($NM -p -v _gotest_.o $xofile | egrep \" $text .*\\.\"$pattern'$' | fgrep -v ' __go_' | egrep -v '\\.\\.\\w+$' | sed 's/.* //')\n+        benchmarks=$(symtogo \"$benchmarksyms\")\n \n \t# examples are named ExampleFoo\n \tpattern='Example([^a-z].*)?'\n-\texamples=$($NM -p -v _gotest_.o $xofile | egrep \" $text .*\\.\"$pattern'$' | grep -v '[^ ]\\..*\\.' | fgrep -v ' __go_' | sed 's/.* //' | $symtogo)\n+\texamplesyms=$($NM -p -v _gotest_.o $xofile | egrep \" $text .*\\.\"$pattern'$' | fgrep -v ' __go_' | egrep -v '\\.\\.\\w+$' | sed 's/.* //')\n+\texamples=$(symtogo \"$examplesyms\")\n \n \t# package spec\n \techo 'package main'"}]}