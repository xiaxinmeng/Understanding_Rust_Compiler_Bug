{"sha": "f5db965fda4963a26a8e8d6943fb2cab8c590847", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkYjk2NWZkYTQ5NjNhMjZhOGU4ZDY5NDNmYjJjYWI4YzU5MDg0Nw==", "commit": {"author": {"name": "Ilya Tocar", "email": "ilya.tocar@intel.com", "date": "2014-10-17T15:11:51Z"}, "committer": {"name": "Ilya Tocar", "email": "tocarip@gcc.gnu.org", "date": "2014-10-17T15:11:51Z"}, "message": "AVX512. 63.1 Update permute expanding.\n\ngcc/\n2014-10-17  Ilya Tocar  <ilya.tocar@intel.com>\n\n\t* config/i386/i386.c (MAX_VECT_LEN): Move earlier.\n\t(expand_vec_perm_d): Ditto.\n\t(ix86_expand_vec_perm_vpermi2): Handle V8HImode, V16HImode, V32HImode,\n\tV32HImode, V4SImode, V8SImode, V4SFmode, V8SFmode, V2DImode, V4DImode,\n\tV4DFmode.\n\t(ix86_expand_vec_perm): Update call to ix86_expand_vec_perm_vpermi2.\n\t(ix86_expand_sse_unpack): Handle V64QImode.\n\t(expand_vec_perm_blend): Update conditions for TARGET, handle\n\tV8DFmode, V16SFmode, V32HImode, V64QImode, V16SImode, V8DImode.\n\t(expand_vec_perm_pshufb): Handle V64QImode.\n\t(expand_vec_perm_1): Handle V64QImode, V32HImode, V16SImode, V16SFmode,\n\tV8DFmode, V8DImode, V4DFmode, V2DFmode, V8SFmode, V4SFmode.\n\t(ix86_expand_vec_perm_const_1): Call  ix86_expand_vec_perm_vpermi2.\n\t(ix86_vectorize_vec_perm_const_ok): Handle V32HImode, V64QImode.\n\t(ix86_expand_vecop_qihi): Handle V64QImode.\n\t* config/i386/sse.md (define_mode_iterator VI1_AVX512): New.\n\t(define_mode_iterator VEC_PERM_AVX2): Add V32HI.\n\t(define_mode_iterator VEC_PERM_CONST): Add V32HI.\n\t(define_insn \"<ssse3_avx2>_pshufb<mode>3<mask_name>\"): Add masking.\n\t(mul<mode>3): Use VI1_AVX512.\n\t(<sse2_avx2>_packsswb): Ditto.\n\t(<sse2_avx2>_packuswb): Ditto.\n\t(<ssse3_avx2>_pshufb<mode>3): Ditto.\n\t(<shift_insn><mode>3): Ditto.\n\nFrom-SVN: r216405", "tree": {"sha": "e4010a1c57fb70c7facda21938e93f6ebcab1e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4010a1c57fb70c7facda21938e93f6ebcab1e01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5db965fda4963a26a8e8d6943fb2cab8c590847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5db965fda4963a26a8e8d6943fb2cab8c590847", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5db965fda4963a26a8e8d6943fb2cab8c590847", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5db965fda4963a26a8e8d6943fb2cab8c590847/comments", "author": {"login": "TocarIP", "id": 16836375, "node_id": "MDQ6VXNlcjE2ODM2Mzc1", "avatar_url": "https://avatars.githubusercontent.com/u/16836375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TocarIP", "html_url": "https://github.com/TocarIP", "followers_url": "https://api.github.com/users/TocarIP/followers", "following_url": "https://api.github.com/users/TocarIP/following{/other_user}", "gists_url": "https://api.github.com/users/TocarIP/gists{/gist_id}", "starred_url": "https://api.github.com/users/TocarIP/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TocarIP/subscriptions", "organizations_url": "https://api.github.com/users/TocarIP/orgs", "repos_url": "https://api.github.com/users/TocarIP/repos", "events_url": "https://api.github.com/users/TocarIP/events{/privacy}", "received_events_url": "https://api.github.com/users/TocarIP/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cad7438c759d387e5b05ba52f8dd43c7550e90f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad7438c759d387e5b05ba52f8dd43c7550e90f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad7438c759d387e5b05ba52f8dd43c7550e90f5"}], "stats": {"total": 364, "additions": 282, "deletions": 82}, "files": [{"sha": "af39978c997a1d7ef1a707c93f662a3b35e40987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5db965fda4963a26a8e8d6943fb2cab8c590847/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5db965fda4963a26a8e8d6943fb2cab8c590847/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5db965fda4963a26a8e8d6943fb2cab8c590847", "patch": "@@ -1,3 +1,30 @@\n+2014-10-17  Ilya Tocar  <ilya.tocar@intel.com>\n+\n+\t* config/i386/i386.c (MAX_VECT_LEN): Move earlier.\n+\t(expand_vec_perm_d): Ditto.\n+\t(ix86_expand_vec_perm_vpermi2): Handle V8HImode, V16HImode, V32HImode,\n+\tV32HImode, V4SImode, V8SImode, V4SFmode, V8SFmode, V2DImode, V4DImode,\n+\tV4DFmode.\n+\t(ix86_expand_vec_perm): Update call to ix86_expand_vec_perm_vpermi2.\n+\t(ix86_expand_sse_unpack): Handle V64QImode.\n+\t(expand_vec_perm_blend): Update conditions for TARGET, handle\n+\tV8DFmode, V16SFmode, V32HImode, V64QImode, V16SImode, V8DImode.\n+\t(expand_vec_perm_pshufb): Handle V64QImode.\n+\t(expand_vec_perm_1): Handle V64QImode, V32HImode, V16SImode, V16SFmode,\n+\tV8DFmode, V8DImode, V4DFmode, V2DFmode, V8SFmode, V4SFmode.\n+\t(ix86_expand_vec_perm_const_1): Call  ix86_expand_vec_perm_vpermi2.\n+\t(ix86_vectorize_vec_perm_const_ok): Handle V32HImode, V64QImode.\n+\t(ix86_expand_vecop_qihi): Handle V64QImode.\n+\t* config/i386/sse.md (define_mode_iterator VI1_AVX512): New.\n+\t(define_mode_iterator VEC_PERM_AVX2): Add V32HI.\n+\t(define_mode_iterator VEC_PERM_CONST): Add V32HI.\n+\t(define_insn \"<ssse3_avx2>_pshufb<mode>3<mask_name>\"): Add masking.\n+\t(mul<mode>3): Use VI1_AVX512.\n+\t(<sse2_avx2>_packsswb): Ditto.\n+\t(<sse2_avx2>_packuswb): Ditto.\n+\t(<ssse3_avx2>_pshufb<mode>3): Ditto.\n+\t(<shift_insn><mode>3): Ditto.\n+\n 2014-10-17  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* config/i386/i386.c (ix86_expand_sse2_mulvxdi3): Refactor"}, {"sha": "33b21f442e8e63d881adb4067f2420b87f310ccb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 230, "deletions": 62, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5db965fda4963a26a8e8d6943fb2cab8c590847/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5db965fda4963a26a8e8d6943fb2cab8c590847/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f5db965fda4963a26a8e8d6943fb2cab8c590847", "patch": "@@ -21407,35 +21407,132 @@ ix86_expand_int_vcond (rtx operands[])\n   return true;\n }\n \n+/* AVX512F does support 64-byte integer vector operations,\n+   thus the longest vector we are faced with is V64QImode.  */\n+#define MAX_VECT_LEN\t64\n+\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool one_operand_p;\n+  bool testing_p;\n+};\n+\n static bool\n-ix86_expand_vec_perm_vpermi2 (rtx target, rtx op0, rtx mask, rtx op1)\n+ix86_expand_vec_perm_vpermi2 (rtx target, rtx op0, rtx mask, rtx op1,\n+\t\t\t      struct expand_vec_perm_d *d)\n {\n-  enum machine_mode mode = GET_MODE (op0);\n+  /* ix86_expand_vec_perm_vpermi2 is called from both const and non-const\n+     expander, so args are either in d, or in op0, op1 etc.  */\n+  enum machine_mode mode = GET_MODE (d ? d->op0 : op0);\n+  enum machine_mode maskmode = mode;\n+  rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;\n+\n   switch (mode)\n     {\n+    case V8HImode:\n+      if (TARGET_AVX512VL && TARGET_AVX512BW)\n+\tgen = gen_avx512vl_vpermi2varv8hi3;\n+      break;\n+    case V16HImode:\n+      if (TARGET_AVX512VL && TARGET_AVX512BW)\n+\tgen = gen_avx512vl_vpermi2varv16hi3;\n+      break;\n+    case V32HImode:\n+      if (TARGET_AVX512BW)\n+\tgen = gen_avx512bw_vpermi2varv32hi3;\n+      break;\n+    case V4SImode:\n+      if (TARGET_AVX512VL)\n+\tgen = gen_avx512vl_vpermi2varv4si3;\n+      break;\n+    case V8SImode:\n+      if (TARGET_AVX512VL)\n+\tgen = gen_avx512vl_vpermi2varv8si3;\n+      break;\n     case V16SImode:\n-      emit_insn (gen_avx512f_vpermi2varv16si3 (target, op0,\n-\t\t\t\t\t       force_reg (V16SImode, mask),\n-\t\t\t\t\t       op1));\n-      return true;\n+      if (TARGET_AVX512F)\n+\tgen = gen_avx512f_vpermi2varv16si3;\n+      break;\n+    case V4SFmode:\n+      if (TARGET_AVX512VL)\n+\t{\n+\t  gen = gen_avx512vl_vpermi2varv4sf3;\n+\t  maskmode = V4SImode;\n+\t}\n+      break;\n+    case V8SFmode:\n+      if (TARGET_AVX512VL)\n+\t{\n+\t  gen = gen_avx512vl_vpermi2varv8sf3;\n+\t  maskmode = V8SImode;\n+\t}\n+      break;\n     case V16SFmode:\n-      emit_insn (gen_avx512f_vpermi2varv16sf3 (target, op0,\n-\t\t\t\t\t       force_reg (V16SImode, mask),\n-\t\t\t\t\t       op1));\n-      return true;\n+      if (TARGET_AVX512F)\n+\t{\n+\t  gen = gen_avx512f_vpermi2varv16sf3;\n+\t  maskmode = V16SImode;\n+\t}\n+      break;\n+    case V2DImode:\n+      if (TARGET_AVX512VL)\n+\tgen = gen_avx512vl_vpermi2varv2di3;\n+      break;\n+    case V4DImode:\n+      if (TARGET_AVX512VL)\n+\tgen = gen_avx512vl_vpermi2varv4di3;\n+      break;\n     case V8DImode:\n-      emit_insn (gen_avx512f_vpermi2varv8di3 (target, op0,\n-\t\t\t\t\t      force_reg (V8DImode, mask),\n-\t\t\t\t\t      op1));\n-      return true;\n+      if (TARGET_AVX512F)\n+\tgen = gen_avx512f_vpermi2varv8di3;\n+      break;\n+    case V2DFmode:\n+      if (TARGET_AVX512VL)\n+\t{\n+\t  gen = gen_avx512vl_vpermi2varv2df3;\n+\t  maskmode = V2DImode;\n+\t}\n+      break;\n+    case V4DFmode:\n+      if (TARGET_AVX512VL)\n+\t{\n+\t  gen = gen_avx512vl_vpermi2varv4df3;\n+\t  maskmode = V4DImode;\n+\t}\n+      break;\n     case V8DFmode:\n-      emit_insn (gen_avx512f_vpermi2varv8df3 (target, op0,\n-\t\t\t\t\t      force_reg (V8DImode, mask),\n-\t\t\t\t\t      op1));\n-      return true;\n+      if (TARGET_AVX512F)\n+\t{\n+\t  gen = gen_avx512f_vpermi2varv8df3;\n+\t  maskmode = V8DImode;\n+\t}\n+      break;\n     default:\n-      return false;\n+      break;\n     }\n+\n+  if (gen == NULL)\n+    return false;\n+\n+  /* ix86_expand_vec_perm_vpermi2 is called from both const and non-const\n+     expander, so args are either in d, or in op0, op1 etc.  */\n+  if (d)\n+    {\n+      rtx vec[64];\n+      target = d->target;\n+      op0 = d->op0;\n+      op1 = d->op1;\n+      for (int i = 0; i < d->nelt; ++i)\n+\tvec[i] = GEN_INT (d->perm[i]);\n+      mask = gen_rtx_CONST_VECTOR (maskmode, gen_rtvec_v (d->nelt, vec));\n+    }\n+\n+  emit_insn (gen (target, op0, force_reg (maskmode, mask), op1));\n+  return true;\n }\n \n /* Expand a variable vector permutation.  */\n@@ -21458,8 +21555,7 @@ ix86_expand_vec_perm (rtx operands[])\n   e = GET_MODE_UNIT_SIZE (mode);\n   gcc_assert (w <= 64);\n \n-  if (TARGET_AVX512F\n-      && ix86_expand_vec_perm_vpermi2 (target, op0, mask, op1))\n+  if (ix86_expand_vec_perm_vpermi2 (target, op0, mask, op1, NULL))\n     return;\n \n   if (TARGET_AVX2)\n@@ -21831,6 +21927,15 @@ ix86_expand_sse_unpack (rtx dest, rtx src, bool unsigned_p, bool high_p)\n \n       switch (imode)\n \t{\n+\tcase V64QImode:\n+\t  if (unsigned_p)\n+\t    unpack = gen_avx512bw_zero_extendv32qiv32hi2;\n+\t  else\n+\t    unpack = gen_avx512bw_sign_extendv32qiv32hi2;\n+\t  halfmode = V32QImode;\n+\t  extract\n+\t    = high_p ? gen_vec_extract_hi_v64qi : gen_vec_extract_lo_v64qi;\n+\t  break;\n \tcase V32QImode:\n \t  if (unsigned_p)\n \t    unpack = gen_avx2_zero_extendv16qiv16hi2;\n@@ -39679,20 +39784,6 @@ x86_emit_floatuns (rtx operands[2])\n   emit_label (donelab);\n }\n \f\n-/* AVX512F does support 64-byte integer vector operations,\n-   thus the longest vector we are faced with is V64QImode.  */\n-#define MAX_VECT_LEN\t64\n-\n-struct expand_vec_perm_d\n-{\n-  rtx target, op0, op1;\n-  unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n-  unsigned char nelt;\n-  bool one_operand_p;\n-  bool testing_p;\n-};\n-\n static bool canonicalize_perm (struct expand_vec_perm_d *d);\n static bool expand_vec_perm_1 (struct expand_vec_perm_d *d);\n static bool expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d);\n@@ -42862,7 +42953,10 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n \n   if (d->one_operand_p)\n     return false;\n-  if (TARGET_AVX2 && GET_MODE_SIZE (vmode) == 32)\n+  if (TARGET_AVX512F && GET_MODE_SIZE (vmode) == 64\n+      && GET_MODE_SIZE (GET_MODE_INNER (vmode)) >= 4)\n+    ;\n+  else if (TARGET_AVX2 && GET_MODE_SIZE (vmode) == 32)\n     ;\n   else if (TARGET_AVX && (vmode == V4DFmode || vmode == V8SFmode))\n     ;\n@@ -42893,12 +42987,18 @@ expand_vec_perm_blend (struct expand_vec_perm_d *d)\n \n   switch (vmode)\n     {\n+    case V8DFmode:\n+    case V16SFmode:\n     case V4DFmode:\n     case V8SFmode:\n     case V2DFmode:\n     case V4SFmode:\n     case V8HImode:\n     case V8SImode:\n+    case V32HImode:\n+    case V64QImode:\n+    case V16SImode:\n+    case V8DImode:\n       for (i = 0; i < nelt; ++i)\n \tmask |= (d->perm[i] >= nelt) << i;\n       break;\n@@ -43121,9 +43221,9 @@ static bool\n expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n {\n   unsigned i, nelt, eltsz, mask;\n-  unsigned char perm[32];\n+  unsigned char perm[64];\n   enum machine_mode vmode = V16QImode;\n-  rtx rperm[32], vperm, target, op0, op1;\n+  rtx rperm[64], vperm, target, op0, op1;\n \n   nelt = d->nelt;\n \n@@ -43212,6 +43312,19 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \t\t  return false;\n \t    }\n \t}\n+      else if (GET_MODE_SIZE (d->vmode) == 64)\n+\t{\n+\t  if (!TARGET_AVX512BW)\n+\t    return false;\n+\t  if (vmode == V64QImode)\n+\t    {\n+\t      /* vpshufb only works intra lanes, it is not\n+\t\t possible to shuffle bytes in between the lanes.  */\n+\t      for (i = 0; i < nelt; ++i)\n+\t\tif ((d->perm[i] ^ i) & (nelt / 4))\n+\t\t  return false;\n+\t    }\n+\t}\n       else\n \treturn false;\n     }\n@@ -43229,6 +43342,8 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \tmask = 2 * nelt - 1;\n       else if (vmode == V16QImode)\n \tmask = nelt - 1;\n+      else if (vmode == V64QImode)\n+\tmask = nelt / 4 - 1;\n       else\n \tmask = nelt / 2 - 1;\n \n@@ -43254,6 +43369,8 @@ expand_vec_perm_pshufb (struct expand_vec_perm_d *d)\n \temit_insn (gen_ssse3_pshufbv16qi3 (target, op0, vperm));\n       else if (vmode == V32QImode)\n \temit_insn (gen_avx2_pshufbv32qi3 (target, op0, vperm));\n+      else if (vmode == V64QImode)\n+\temit_insn (gen_avx512bw_pshufbv64qi3 (target, op0, vperm));\n       else if (vmode == V8SFmode)\n \temit_insn (gen_avx2_permvarv8sf (target, op0, vperm));\n       else\n@@ -43309,12 +43426,24 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \t  rtx (*gen) (rtx, rtx) = NULL;\n \t  switch (d->vmode)\n \t    {\n+\t    case V64QImode:\n+\t      if (TARGET_AVX512BW)\n+\t\tgen = gen_avx512bw_vec_dupv64qi;\n+\t      break;\n \t    case V32QImode:\n \t      gen = gen_avx2_pbroadcastv32qi_1;\n \t      break;\n+\t    case V32HImode:\n+\t      if (TARGET_AVX512BW)\n+\t\tgen = gen_avx512bw_vec_dupv32hi;\n+\t      break;\n \t    case V16HImode:\n \t      gen = gen_avx2_pbroadcastv16hi_1;\n \t      break;\n+\t    case V16SImode:\n+\t      if (TARGET_AVX512F)\n+\t\tgen = gen_avx512f_vec_dupv16si;\n+\t      break;\n \t    case V8SImode:\n \t      gen = gen_avx2_pbroadcastv8si_1;\n \t      break;\n@@ -43324,9 +43453,21 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \t    case V8HImode:\n \t      gen = gen_avx2_pbroadcastv8hi;\n \t      break;\n+\t    case V16SFmode:\n+\t      if (TARGET_AVX512F)\n+\t\tgen = gen_avx512f_vec_dupv16sf;\n+\t      break;\n \t    case V8SFmode:\n \t      gen = gen_avx2_vec_dupv8sf_1;\n \t      break;\n+\t    case V8DFmode:\n+\t      if (TARGET_AVX512F)\n+\t\tgen = gen_avx512f_vec_dupv8df;\n+\t      break;\n+\t    case V8DImode:\n+\t      if (TARGET_AVX512F)\n+\t\tgen = gen_avx512f_vec_dupv8di;\n+\t      break;\n \t    /* For other modes prefer other shuffles this function creates.  */\n \t    default: break;\n \t    }\n@@ -43411,23 +43552,10 @@ expand_vec_perm_1 (struct expand_vec_perm_d *d)\n \n   /* Try the AVX2 vpalignr instruction.  */\n   if (expand_vec_perm_palignr (d, true))\n-    return true;\n \n   /* Try the AVX512F vpermi2 instructions.  */\n-  if (TARGET_AVX512F)\n-    {\n-      rtx vec[64];\n-      enum machine_mode mode = d->vmode;\n-      if (mode == V8DFmode)\n-\tmode = V8DImode;\n-      else if (mode == V16SFmode)\n-\tmode = V16SImode;\n-      for (i = 0; i < nelt; ++i)\n-\tvec[i] = GEN_INT (d->perm[i]);\n-      rtx mask = gen_rtx_CONST_VECTOR (mode, gen_rtvec_v (nelt, vec));\n-      if (ix86_expand_vec_perm_vpermi2 (d->target, d->op0, mask, d->op1))\n-\treturn true;\n-    }\n+  if (ix86_expand_vec_perm_vpermi2 (NULL_RTX, NULL_RTX, NULL_RTX, NULL_RTX, d))\n+    return true;\n \n   return false;\n }\n@@ -45214,21 +45342,56 @@ ix86_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n \n   /* Given sufficient ISA support we can just return true here\n      for selected vector modes.  */\n-  if (d.vmode == V16SImode || d.vmode == V16SFmode\n-      || d.vmode == V8DFmode || d.vmode == V8DImode)\n-    /* All implementable with a single vpermi2 insn.  */\n-    return true;\n-  if (GET_MODE_SIZE (d.vmode) == 16)\n+  switch (d.vmode)\n     {\n+    case V16SFmode:\n+    case V16SImode:\n+    case V8DImode:\n+    case V8DFmode:\n+      if (TARGET_AVX512F)\n+\t/* All implementable with a single vpermi2 insn.  */\n+\treturn true;\n+      break;\n+    case V32HImode:\n+      if (TARGET_AVX512BW)\n+\t/* All implementable with a single vpermi2 insn.  */\n+\treturn true;\n+      break;\n+    case V8SImode:\n+    case V8SFmode:\n+    case V4DFmode:\n+    case V4DImode:\n+      if (TARGET_AVX512VL)\n+\t/* All implementable with a single vpermi2 insn.  */\n+\treturn true;\n+      break;\n+    case V16HImode:\n+      if (TARGET_AVX2)\n+\t/* Implementable with 4 vpshufb insns, 2 vpermq and 3 vpor insns.  */\n+\treturn true;\n+      break;\n+    case V32QImode:\n+      if (TARGET_AVX2)\n+\t/* Implementable with 4 vpshufb insns, 2 vpermq and 3 vpor insns.  */\n+\treturn true;\n+      break;\n+    case V4SImode:\n+    case V4SFmode:\n+    case V8HImode:\n+    case V16QImode:\n       /* All implementable with a single vpperm insn.  */\n       if (TARGET_XOP)\n \treturn true;\n       /* All implementable with 2 pshufb + 1 ior.  */\n       if (TARGET_SSSE3)\n \treturn true;\n+      break;\n+    case V2DImode:\n+    case V2DFmode:\n       /* All implementable with shufpd or unpck[lh]pd.  */\n-      if (d.nelt == 2)\n-\treturn true;\n+      return true;\n+    default:\n+      return false;\n     }\n \n   /* Extract the values from the vector CST into the permutation\n@@ -45348,6 +45511,11 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n       gen_il = gen_avx2_interleave_lowv32qi;\n       gen_ih = gen_avx2_interleave_highv32qi;\n       break;\n+    case V64QImode:\n+      himode = V32HImode;\n+      gen_il = gen_avx512bw_interleave_lowv64qi;\n+      gen_ih = gen_avx512bw_interleave_highv64qi;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -45408,15 +45576,15 @@ ix86_expand_vecop_qihi (enum rtx_code code, rtx dest, rtx op1, rtx op2)\n     {\n       /* For SSE2, we used an full interleave, so the desired\n \t results are in the even elements.  */\n-      for (i = 0; i < 32; ++i)\n+      for (i = 0; i < 64; ++i)\n \td.perm[i] = i * 2;\n     }\n   else\n     {\n       /* For AVX, the interleave used above was not cross-lane.  So the\n \t extraction is evens but with the second and third quarter swapped.\n \t Happily, that is even one insn shorter than even extraction.  */\n-      for (i = 0; i < 32; ++i)\n+      for (i = 0; i < 64; ++i)\n \td.perm[i] = i * 2 + ((i & 24) == 8 ? 16 : (i & 24) == 16 ? -16 : 0);\n     }\n "}, {"sha": "81570459eb7a3d619b8873533fc6dad2617a9dde", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5db965fda4963a26a8e8d6943fb2cab8c590847/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5db965fda4963a26a8e8d6943fb2cab8c590847/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=f5db965fda4963a26a8e8d6943fb2cab8c590847", "patch": "@@ -301,6 +301,9 @@\n (define_mode_iterator VI1_AVX2\n   [(V32QI \"TARGET_AVX2\") V16QI])\n \n+(define_mode_iterator VI1_AVX512\n+  [(V64QI \"TARGET_AVX512BW\") (V32QI \"TARGET_AVX2\") V16QI])\n+\n (define_mode_iterator VI2_AVX2\n   [(V32HI \"TARGET_AVX512BW\") (V16HI \"TARGET_AVX2\") V8HI])\n \n@@ -9246,9 +9249,9 @@\n    (set_attr \"mode\" \"TI\")])\n \n (define_expand \"mul<mode>3<mask_name>\"\n-  [(set (match_operand:VI1_AVX2 0 \"register_operand\")\n-\t(mult:VI1_AVX2 (match_operand:VI1_AVX2 1 \"register_operand\")\n-\t\t       (match_operand:VI1_AVX2 2 \"register_operand\")))]\n+  [(set (match_operand:VI1_AVX512 0 \"register_operand\")\n+\t(mult:VI1_AVX512 (match_operand:VI1_AVX512 1 \"register_operand\")\n+\t\t       (match_operand:VI1_AVX512 2 \"register_operand\")))]\n   \"TARGET_SSE2 && <mask_mode512bit_condition> && <mask_avx512bw_condition>\"\n {\n   ix86_expand_vecop_qihi (MULT, operands[0], operands[1], operands[2]);\n@@ -10652,7 +10655,8 @@\n    (V8SI \"TARGET_AVX2\") (V4DI \"TARGET_AVX2\")\n    (V8SF \"TARGET_AVX2\") (V4DF \"TARGET_AVX2\")\n    (V16SF \"TARGET_AVX512F\") (V8DF \"TARGET_AVX512F\")\n-   (V16SI \"TARGET_AVX512F\") (V8DI \"TARGET_AVX512F\")])\n+   (V16SI \"TARGET_AVX512F\") (V8DI \"TARGET_AVX512F\")\n+   (V32HI \"TARGET_AVX512BW\")])\n \n (define_expand \"vec_perm<mode>\"\n   [(match_operand:VEC_PERM_AVX2 0 \"register_operand\")\n@@ -10673,7 +10677,8 @@\n    (V8SI \"TARGET_AVX\") (V4DI \"TARGET_AVX\")\n    (V32QI \"TARGET_AVX2\") (V16HI \"TARGET_AVX2\")\n    (V16SI \"TARGET_AVX512F\") (V8DI \"TARGET_AVX512F\")\n-   (V16SF \"TARGET_AVX512F\") (V8DF \"TARGET_AVX512F\")])\n+   (V16SF \"TARGET_AVX512F\") (V8DF \"TARGET_AVX512F\")\n+   (V32HI \"TARGET_AVX512BW\")])\n \n (define_expand \"vec_perm_const<mode>\"\n   [(match_operand:VEC_PERM_CONST 0 \"register_operand\")\n@@ -11037,8 +11042,8 @@\n })\n \n (define_insn \"<sse2_avx2>_packsswb<mask_name>\"\n-  [(set (match_operand:VI1_AVX2 0 \"register_operand\" \"=x,v\")\n-\t(vec_concat:VI1_AVX2\n+  [(set (match_operand:VI1_AVX512 0 \"register_operand\" \"=x,x\")\n+\t(vec_concat:VI1_AVX512\n \t  (ss_truncate:<ssehalfvecmode>\n \t    (match_operand:<sseunpackmode> 1 \"register_operand\" \"0,v\"))\n \t  (ss_truncate:<ssehalfvecmode>\n@@ -11071,8 +11076,8 @@\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n (define_insn \"<sse2_avx2>_packuswb<mask_name>\"\n-  [(set (match_operand:VI1_AVX2 0 \"register_operand\" \"=x,v\")\n-\t(vec_concat:VI1_AVX2\n+  [(set (match_operand:VI1_AVX512 0 \"register_operand\" \"=x,x\")\n+\t(vec_concat:VI1_AVX512\n \t  (us_truncate:<ssehalfvecmode>\n \t    (match_operand:<sseunpackmode> 1 \"register_operand\" \"0,v\"))\n \t  (us_truncate:<ssehalfvecmode>\n@@ -13650,21 +13655,21 @@\n    (set (attr \"prefix_rex\") (symbol_ref \"x86_extended_reg_mentioned_p (insn)\"))\n    (set_attr \"mode\" \"DI\")])\n \n-(define_insn \"<ssse3_avx2>_pshufb<mode>3\"\n-  [(set (match_operand:VI1_AVX2 0 \"register_operand\" \"=x,x\")\n-\t(unspec:VI1_AVX2\n-\t  [(match_operand:VI1_AVX2 1 \"register_operand\" \"0,x\")\n-\t   (match_operand:VI1_AVX2 2 \"nonimmediate_operand\" \"xm,xm\")]\n+(define_insn \"<ssse3_avx2>_pshufb<mode>3<mask_name>\"\n+  [(set (match_operand:VI1_AVX512 0 \"register_operand\" \"=x,v\")\n+\t(unspec:VI1_AVX512\n+\t  [(match_operand:VI1_AVX512 1 \"register_operand\" \"0,v\")\n+\t   (match_operand:VI1_AVX512 2 \"nonimmediate_operand\" \"xm,vm\")]\n \t  UNSPEC_PSHUFB))]\n-  \"TARGET_SSSE3\"\n+  \"TARGET_SSSE3 && <mask_mode512bit_condition> && <mask_avx512bw_condition>\"\n   \"@\n    pshufb\\t{%2, %0|%0, %2}\n-   vpshufb\\t{%2, %1, %0|%0, %1, %2}\"\n+   vpshufb\\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}\"\n   [(set_attr \"isa\" \"noavx,avx\")\n    (set_attr \"type\" \"sselog1\")\n    (set_attr \"prefix_data16\" \"1,*\")\n    (set_attr \"prefix_extra\" \"1\")\n-   (set_attr \"prefix\" \"orig,vex\")\n+   (set_attr \"prefix\" \"orig,maybe_evex\")\n    (set_attr \"btver2_decode\" \"vector,vector\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n@@ -16047,9 +16052,9 @@\n    (set_attr \"mode\" \"TI\")])\n \n (define_expand \"<shift_insn><mode>3\"\n-  [(set (match_operand:VI1_AVX2 0 \"register_operand\")\n-\t(any_shift:VI1_AVX2\n-\t  (match_operand:VI1_AVX2 1 \"register_operand\")\n+  [(set (match_operand:VI1_AVX512 0 \"register_operand\")\n+\t(any_shift:VI1_AVX512\n+\t  (match_operand:VI1_AVX512 1 \"register_operand\")\n \t  (match_operand:SI 2 \"nonmemory_operand\")))]\n   \"TARGET_SSE2\"\n {"}]}