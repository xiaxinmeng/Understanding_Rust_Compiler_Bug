{"sha": "c85f8dbb173f45053f6d8849d27adc98d9668769", "node_id": "C_kwDOANBUbNoAKGM4NWY4ZGJiMTczZjQ1MDUzZjZkODg0OWQyN2FkYzk4ZDk2Njg3Njk", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-11-02T17:11:02Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-11-16T21:29:09Z"}, "message": "c++: P2448 - Relaxing some constexpr restrictions [PR106649]\n\nThis patch implements C++23 P2448, which lifts more restrictions on the\nconstexpr keyword.  It's effectively going the way of being just a hint\n(hello, inline!).\n\nThis gist is relatively simple: in C++23, a constexpr function's return\ntype/parameter type doesn't have to be a literal type; and you can have\na constexpr function for which no invocation satisfies the requirements\nof a core constant expression.  For example,\n\n  void f(int& i); // not constexpr\n\n  constexpr void g(int& i) {\n    f(i); // unconditionally calls a non-constexpr function\n  }\n\nis now OK, even though there isn't an invocation of 'g' that would be\na constant expression.  Maybe 'f' will be made constexpr soon, or maybe\nthis depends on the version of C++ used, and similar.  The patch is\nunfortunately not that trivial.  The important bit is to use the new\nrequire_potential_rvalue_constant_expression_fncheck in\nmaybe_save_constexpr_fundef (and where appropriate).  It has a new flag\nthat says that we're checking the body of a constexpr function, and in\nthat case it's OK to find constructs that aren't a constant expression.\n\nSince it's useful to be able to check for problematic constructs even\nin C++23, this patch implements a new warning, -Winvalid-constexpr,\nwhich is a pedwarn turned on by default in C++20 and earlier, and which\ncan be turned on in C++23 as well, in which case it's an ordinary warning.\nThis I implemented by using the new function constexpr_error, used in\np_c_e_1 and friends.  (In some cases I believe fundef_p will be always\nfalse (= hard error), but it made sense to me to be consistent and use\nconstexpr_error throughout p_c_e_1.)\n\nWhile working on this I think I found a bug, see constexpr-nonlit15.C\nand <https://gcc.gnu.org/PR107598>.  This patch doesn't address that.\n\nThis patch includes changes to diagnose the problem if the user doesn't\nuse -Winvalid-constexpr and calls a constexpr function that in fact isn't\nconstexpr-ready yet: maybe_save_constexpr_fundef registers the function\nif warn_invalid_constexpr is 0 and explain_invalid_constexpr_fn then\ngives the diagnostic.\n\n\tPR c++/106649\n\ngcc/c-family/ChangeLog:\n\n\t* c-cppbuiltin.cc (c_cpp_builtins): Update value of __cpp_constexpr for\n\tC++23.\n\t* c-opts.cc (c_common_post_options): Set warn_invalid_constexpr\n\tdepending on cxx_dialect.\n\t* c.opt (Winvalid-constexpr): New option.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (constexpr_error): New function.\n\t(is_valid_constexpr_fn): Use constexpr_error.\n\t(maybe_save_constexpr_fundef): Call\n\trequire_potential_rvalue_constant_expression_fncheck rather than\n\trequire_potential_rvalue_constant_expression.  Register the\n\tfunction if -Wno-invalid-constexpr was specified.\n\t(explain_invalid_constexpr_fn): Don't return early if a function marked\n\t'constexpr' that isn't actually a constant expression was called.\n\t(non_const_var_error): Add a bool parameter.  Use constexpr_error.\n\t(inline_asm_in_constexpr_error): Likewise.\n\t(cxx_eval_constant_expression): Adjust calls to non_const_var_error\n\tand inline_asm_in_constexpr_error.\n\t(potential_constant_expression_1): Add a bool parameter.  Use\n\tconstexpr_error.\n\t(require_potential_rvalue_constant_expression_fncheck): New function.\n\t* cp-tree.h (require_potential_rvalue_constant_expression_fncheck):\n\tDeclare.\n\t* method.cc (struct comp_info): Call\n\trequire_potential_rvalue_constant_expression_fncheck rather than\n\trequire_potential_rvalue_constant_expression.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Document -Winvalid-constexpr.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/constexpr-ctor2.C: Expect an error in c++20_down only.\n\t* g++.dg/cpp0x/constexpr-default-ctor.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-diag3.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-ex1.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-friend.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-generated1.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-ice5.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-ice6.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-memfn1.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-neg2.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-non-const-arg.C: Likewise.\n\t* g++.dg/cpp0x/constexpr-reinterpret1.C: Likewise.\n\t* g++.dg/cpp0x/pr65327.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-105050.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-89285-2.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-89285.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-89785-2.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-neg1.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-nsdmi7b.C: Likewise.\n\t* g++.dg/cpp1y/constexpr-throw.C: Likewise.\n\t* g++.dg/cpp23/constexpr-nonlit3.C: Remove dg-error.\n\t* g++.dg/cpp23/constexpr-nonlit6.C: Call the test functions.\n\t* g++.dg/cpp23/feat-cxx2b.C: Adjust the expected value of\n\t__cpp_constexpr.\n\t* g++.dg/cpp2a/consteval3.C: Remove dg-error.\n\t* g++.dg/cpp2a/constexpr-new7.C: Expect an error in c++20_down only.\n\t* g++.dg/cpp2a/constexpr-try5.C: Remove dg-error.\n\t* g++.dg/cpp2a/spaceship-constexpr1.C: Expect an error in c++20_down\n\tonly.\n\t* g++.dg/cpp2a/spaceship-eq3.C: Likewise.\n\t* g++.dg/diagnostic/constexpr1.C: Remove dg-error.\n\t* g++.dg/gomp/pr79664.C: Use -Winvalid-constexpr -pedantic-errors.\n\t* g++.dg/ubsan/vptr-4.C: Likewise.\n\t* g++.dg/cpp23/constexpr-nonlit10.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit11.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit12.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit13.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit14.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit15.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit16.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit8.C: New test.\n\t* g++.dg/cpp23/constexpr-nonlit9.C: New test.", "tree": {"sha": "5709041b56579f5b413fcd128f85d39accfd9554", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5709041b56579f5b413fcd128f85d39accfd9554"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c85f8dbb173f45053f6d8849d27adc98d9668769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85f8dbb173f45053f6d8849d27adc98d9668769", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c85f8dbb173f45053f6d8849d27adc98d9668769", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c85f8dbb173f45053f6d8849d27adc98d9668769/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbdce6adb748b95be219f2f5fb97f844a0f9b840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbdce6adb748b95be219f2f5fb97f844a0f9b840", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbdce6adb748b95be219f2f5fb97f844a0f9b840"}], "stats": {"total": 861, "additions": 715, "deletions": 146}, "files": [{"sha": "26447d02097a4c879171219aee7bfbadc6322ab1", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -1074,7 +1074,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  /* Set feature test macros for C++23.  */\n \t  cpp_define (pfile, \"__cpp_size_t_suffix=202011L\");\n \t  cpp_define (pfile, \"__cpp_if_consteval=202106L\");\n-\t  cpp_define (pfile, \"__cpp_constexpr=202110L\");\n+\t  cpp_define (pfile, \"__cpp_constexpr=202207L\");\n \t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202211L\");\n \t  cpp_define (pfile, \"__cpp_named_character_escapes=202207L\");\n \t  cpp_define (pfile, \"__cpp_static_call_operator=202207L\");"}, {"sha": "70745aa4e7c2d73a8c27907e270fb19a0f37e3d1", "filename": "gcc/c-family/c-opts.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fc-family%2Fc-opts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fc-family%2Fc-opts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.cc?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -1059,6 +1059,10 @@ c_common_post_options (const char **pfilename)\n   if (flag_sized_deallocation == -1)\n     flag_sized_deallocation = (cxx_dialect >= cxx14);\n \n+  /* Pedwarn about invalid constexpr functions before C++23.  */\n+  if (warn_invalid_constexpr == -1)\n+    warn_invalid_constexpr = (cxx_dialect < cxx23);\n+\n   /* char8_t support is implicitly enabled in C++20 and C2X.  */\n   if (flag_char8_t == -1)\n     flag_char8_t = (cxx_dialect >= cxx20) || flag_isoc2x;"}, {"sha": "3daeab85531d270c1d0097bac26027b3a81b99fc", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -817,6 +817,10 @@ Wint-to-pointer-cast\n C ObjC C++ ObjC++ Var(warn_int_to_pointer_cast) Init(1) Warning\n Warn when there is a cast to a pointer from an integer of a different size.\n \n+Winvalid-constexpr\n+C++ ObjC++ Var(warn_invalid_constexpr) Init(-1) Warning\n+Warn when a function never produces a constant expression.\n+\n Winvalid-offsetof\n C++ ObjC++ Var(warn_invalid_offsetof) Init(1) Warning\n Warn about invalid uses of the \\\"offsetof\\\" macro."}, {"sha": "a390cf921f3899fb72b1c6175ff03b272976c62f", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 201, "deletions": 98, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -139,6 +139,42 @@ ensure_literal_type_for_constexpr_object (tree decl)\n   return decl;\n }\n \n+/* Issue a diagnostic with text GMSGID for constructs that are invalid in\n+   constexpr functions.  CONSTEXPR_FUNDEF_P is true if we're checking\n+   a constexpr function body; if so, don't report hard errors and issue\n+   a pedwarn pre-C++23, or a warning in C++23, if requested by\n+   -Winvalid-constexpr.  Otherwise, we're not in the context where we are\n+   checking if a function can be marked 'constexpr', so give a hard error.  */\n+\n+ATTRIBUTE_GCC_DIAG(3,4)\n+static bool\n+constexpr_error (location_t location, bool constexpr_fundef_p,\n+\t\t const char *gmsgid, ...)\n+{\n+  diagnostic_info diagnostic;\n+  va_list ap;\n+  rich_location richloc (line_table, location);\n+  va_start (ap, gmsgid);\n+  bool ret;\n+  if (!constexpr_fundef_p)\n+    {\n+      /* Report an error that cannot be suppressed.  */\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc, DK_ERROR);\n+      ret = diagnostic_report_diagnostic (global_dc, &diagnostic);\n+    }\n+  else if (warn_invalid_constexpr)\n+    {\n+      diagnostic_set_info (&diagnostic, gmsgid, &ap, &richloc,\n+\t\t\t   cxx_dialect < cxx23 ? DK_PEDWARN : DK_WARNING);\n+      diagnostic.option_index = OPT_Winvalid_constexpr;\n+      ret = diagnostic_report_diagnostic (global_dc, &diagnostic);\n+    }\n+  else\n+    ret = false;\n+  va_end (ap);\n+  return ret;\n+}\n+\n struct constexpr_fundef_hasher : ggc_ptr_hash<constexpr_fundef>\n {\n   static hashval_t hash (const constexpr_fundef *);\n@@ -208,9 +244,11 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t    if (complain)\n \t      {\n \t\tauto_diagnostic_group d;\n-\t\terror (\"invalid type for parameter %d of %<constexpr%> \"\n-\t\t       \"function %q+#D\", DECL_PARM_INDEX (parm), fun);\n-\t\texplain_non_literal_class (TREE_TYPE (parm));\n+\t\tif (constexpr_error (input_location, /*constexpr_fundef_p*/true,\n+\t\t\t\t     \"invalid type for parameter %d of \"\n+\t\t\t\t     \"%<constexpr%> function %q+#D\",\n+\t\t\t\t     DECL_PARM_INDEX (parm), fun))\n+\t\t  explain_non_literal_class (TREE_TYPE (parm));\n \t      }\n \t  }\n     }\n@@ -242,9 +280,10 @@ is_valid_constexpr_fn (tree fun, bool complain)\n \t  if (complain)\n \t    {\n \t      auto_diagnostic_group d;\n-\t      error (\"invalid return type %qT of %<constexpr%> function %q+D\",\n-\t\t     rettype, fun);\n-\t      explain_non_literal_class (rettype);\n+\t      if (constexpr_error (input_location, /*constexpr_fundef_p*/true,\n+\t\t\t\t   \"invalid return type %qT of %<constexpr%> \"\n+\t\t\t\t   \"function %q+D\", rettype, fun))\n+\t\texplain_non_literal_class (rettype);\n \t    }\n \t}\n \n@@ -918,7 +957,7 @@ maybe_save_constexpr_fundef (tree fun)\n \n   bool potential = potential_rvalue_constant_expression (massaged);\n   if (!potential && complain)\n-    require_potential_rvalue_constant_expression (massaged);\n+    require_potential_rvalue_constant_expression_fncheck (massaged);\n \n   if (DECL_CONSTRUCTOR_P (fun) && potential\n       && !DECL_DEFAULTED_FN (fun))\n@@ -933,11 +972,16 @@ maybe_save_constexpr_fundef (tree fun)\n \t  massaged = DECL_SAVED_TREE (fun);\n \t  potential = potential_rvalue_constant_expression (massaged);\n \t  if (!potential && complain)\n-\t    require_potential_rvalue_constant_expression (massaged);\n+\t    require_potential_rvalue_constant_expression_fncheck (massaged);\n \t}\n     }\n \n-  if (!potential && complain)\n+  if (!potential && complain\n+      /* If -Wno-invalid-constexpr was specified, we haven't complained\n+\t about non-constant expressions yet.  Register the function and\n+\t complain in explain_invalid_constexpr_fn if the function is\n+\t called.  */\n+      && warn_invalid_constexpr != 0)\n     return;\n \n   if (implicit)\n@@ -996,19 +1040,27 @@ register_constexpr_fundef (const constexpr_fundef &value)\n   **slot = value;\n }\n \n-/* FUN is a non-constexpr function called in a context that requires a\n-   constant expression.  If it comes from a constexpr template, explain why\n-   the instantiation isn't constexpr.  */\n+/* FUN is a non-constexpr (or, with -Wno-invalid-constexpr, a constexpr\n+   function called in a context that requires a constant expression).\n+   If it comes from a constexpr template, explain why the instantiation\n+   isn't constexpr.  Otherwise, explain why the function cannot be used\n+   in a constexpr context.  */\n \n void\n explain_invalid_constexpr_fn (tree fun)\n {\n   static hash_set<tree> *diagnosed;\n   tree body;\n+  /* In C++23, a function marked 'constexpr' may not actually be a constant\n+     expression.  We haven't diagnosed the problem yet: -Winvalid-constexpr\n+     wasn't enabled.  The function was called, so diagnose why it cannot be\n+     used in a constant expression.  */\n+  if (warn_invalid_constexpr == 0 && DECL_DECLARED_CONSTEXPR_P (fun))\n+    /* Go on.  */;\n   /* Only diagnose defaulted functions, lambdas, or instantiations.  */\n-  if (!DECL_DEFAULTED_FN (fun)\n-      && !LAMBDA_TYPE_P (CP_DECL_CONTEXT (fun))\n-      && !is_instantiation_of_constexpr (fun))\n+  else if (!DECL_DEFAULTED_FN (fun)\n+\t   && !LAMBDA_TYPE_P (CP_DECL_CONTEXT (fun))\n+\t   && !is_instantiation_of_constexpr (fun))\n     {\n       inform (DECL_SOURCE_LOCATION (fun), \"%qD declared here\", fun);\n       return;\n@@ -5612,11 +5664,12 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n }\n \n /* Complain about R, a VAR_DECL, not being usable in a constant expression.\n+   FUNDEF_P is true if we're checking a constexpr function body.\n    Shared between potential_constant_expression and\n    cxx_eval_constant_expression.  */\n \n static void\n-non_const_var_error (location_t loc, tree r)\n+non_const_var_error (location_t loc, tree r, bool fundef_p)\n {\n   auto_diagnostic_group d;\n   tree type = TREE_TYPE (r);\n@@ -5625,20 +5678,21 @@ non_const_var_error (location_t loc, tree r)\n       || DECL_NAME (r) == heap_vec_uninit_identifier\n       || DECL_NAME (r) == heap_vec_identifier)\n     {\n-      error_at (loc, \"the content of uninitialized storage is not usable \"\n-\t\t\"in a constant expression\");\n-      inform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n+      if (constexpr_error (loc, fundef_p, \"the content of uninitialized \"\n+\t\t\t   \"storage is not usable in a constant expression\"))\n+\tinform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n       return;\n     }\n   if (DECL_NAME (r) == heap_deleted_identifier)\n     {\n-      error_at (loc, \"use of allocated storage after deallocation in a \"\n-\t\t\"constant expression\");\n-      inform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n+      if (constexpr_error (loc, fundef_p, \"use of allocated storage after \"\n+\t\t\t   \"deallocation in a constant expression\"))\n+\tinform (DECL_SOURCE_LOCATION (r), \"allocated here\");\n       return;\n     }\n-  error_at (loc, \"the value of %qD is not usable in a constant \"\n-\t    \"expression\", r);\n+  if (!constexpr_error (loc, fundef_p, \"the value of %qD is not usable in \"\n+\t\t\t\"a constant expression\", r))\n+    return;\n   /* Avoid error cascade.  */\n   if (DECL_INITIAL (r) == error_mark_node)\n     return;\n@@ -6697,15 +6751,17 @@ lookup_placeholder (const constexpr_ctx *ctx, value_cat lval, tree type)\n   return ob;\n }\n \n-/* Complain about an attempt to evaluate inline assembly.  */\n+/* Complain about an attempt to evaluate inline assembly.  If FUNDEF_P is\n+   true, we're checking a constexpr function body.  */\n \n static void\n-inline_asm_in_constexpr_error (location_t loc)\n+inline_asm_in_constexpr_error (location_t loc, bool fundef_p)\n {\n   auto_diagnostic_group d;\n-  error_at (loc, \"inline assembly is not a constant expression\");\n-  inform (loc, \"only unevaluated inline assembly is allowed in a \"\n-\t  \"%<constexpr%> function in C++20\");\n+  if (constexpr_error (loc, fundef_p, \"inline assembly is not a \"\n+\t\t       \"constant expression\"))\n+    inform (loc, \"only unevaluated inline assembly is allowed in a \"\n+\t    \"%<constexpr%> function in C++20\");\n }\n \n /* We're getting the constant value of DECL in a manifestly constant-evaluated\n@@ -6983,7 +7039,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (DECL_P (r))\n \t{\n \t  if (!ctx->quiet)\n-\t    non_const_var_error (loc, r);\n+\t    non_const_var_error (loc, r, /*fundef_p*/false);\n \t  *non_constant_p = true;\n \t}\n       break;\n@@ -7874,7 +7930,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case ASM_EXPR:\n       if (!ctx->quiet)\n-\tinline_asm_in_constexpr_error (loc);\n+\tinline_asm_in_constexpr_error (loc, /*constexpr_fundef_p*/false);\n       *non_constant_p = true;\n       return t;\n \n@@ -8759,7 +8815,8 @@ check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n    diagnostic as appropriate under control of FLAGS.  If WANT_RVAL is true,\n    an lvalue-rvalue conversion is implied.  If NOW is true, we want to\n    consider the expression in the current context, independent of constexpr\n-   substitution.\n+   substitution.  If FUNDEF_P is true, we're checking a constexpr function body\n+   and hard errors should not be reported by constexpr_error.\n \n    C++0x [expr.const] used to say\n \n@@ -8776,10 +8833,12 @@ check_for_return_continue (tree *tp, int *walk_subtrees, void *data)\n \n static bool\n potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n-\t\t\t\t tsubst_flags_t flags, tree *jump_target)\n+\t\t\t\t bool fundef_p, tsubst_flags_t flags,\n+\t\t\t\t tree *jump_target)\n {\n #define RECUR(T,RV) \\\n-  potential_constant_expression_1 ((T), (RV), strict, now, flags, jump_target)\n+  potential_constant_expression_1 ((T), (RV), strict, now, fundef_p, flags, \\\n+\t\t\t\t   jump_target)\n \n   enum { any = false, rval = true };\n   int i;\n@@ -8801,8 +8860,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n   if (TREE_THIS_VOLATILE (t) && want_rval)\n     {\n       if (flags & tf_error)\n-\terror_at (loc, \"lvalue-to-rvalue conversion of a volatile lvalue \"\n-\t\t  \"%qE with type %qT\", t, TREE_TYPE (t));\n+\tconstexpr_error (loc, fundef_p, \"lvalue-to-rvalue conversion of \"\n+\t\t\t \"a volatile lvalue %qE with type %qT\", t,\n+\t\t\t TREE_TYPE (t));\n       return false;\n     }\n   if (CONSTANT_CLASS_P (t))\n@@ -8861,7 +8921,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t    /* An empty class has no data to read.  */\n \t    return true;\n \t  if (flags & tf_error)\n-\t    error (\"%qE is not a constant expression\", t);\n+\t    constexpr_error (input_location, fundef_p,\n+\t\t\t     \"%qE is not a constant expression\", t);\n \t  return false;\n \t}\n       return true;\n@@ -8910,7 +8971,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t      {\n \t\t/* fold_call_expr can't do anything with IFN calls.  */\n \t\tif (flags & tf_error)\n-\t\t  error_at (loc, \"call to internal function %qE\", t);\n+\t\t  constexpr_error (loc, fundef_p,\n+\t\t\t\t   \"call to internal function %qE\", t);\n \t\treturn false;\n \t      }\n \t  }\n@@ -8940,12 +9002,11 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t\t|| !is_std_construct_at (current_function_decl))\n \t\t    && !cxx_dynamic_cast_fn_p (fun))\n \t\t  {\n-\t\t    if (flags & tf_error)\n-\t\t      {\n-\t\t\terror_at (loc, \"call to non-%<constexpr%> function %qD\",\n-\t\t\t\t  fun);\n-\t\t\texplain_invalid_constexpr_fn (fun);\n-\t\t      }\n+\t\t    if ((flags & tf_error)\n+\t\t\t&& constexpr_error (loc, fundef_p,\n+\t\t\t\t\t    \"call to non-%<constexpr%> \"\n+\t\t\t\t\t    \"function %qD\", fun))\n+\t\t      explain_invalid_constexpr_fn (fun);\n \t\t    return false;\n \t\t  }\n \t\t/* A call to a non-static member function takes the address\n@@ -8962,8 +9023,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t       constexpr substitution might not use the value.  */\n \t\t    bool sub_now = false;\n \t\t    if (!potential_constant_expression_1 (x, rval, strict,\n-\t\t\t\t\t\t\t  sub_now, flags,\n-\t\t\t\t\t\t\t  jump_target))\n+\t\t\t\t\t\t\t  sub_now, fundef_p,\n+\t\t\t\t\t\t\t  flags, jump_target))\n \t\t      return false;\n \t\t    i = 1;\n \t\t  }\n@@ -8997,7 +9058,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t       substitution might not use the value of the argument.  */\n \t    bool sub_now = false;\n \t    if (!potential_constant_expression_1 (x, rv, strict,\n-\t\t\t\t\t\t  sub_now, flags, jump_target))\n+\t\t\t\t\t\t  sub_now, fundef_p, flags,\n+\t\t\t\t\t\t  jump_target))\n \t      return false;\n           }\n         return true;\n@@ -9035,9 +9097,10 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t      if (flags & tf_error)\n \t\t{\n \t\t  tree cap = DECL_CAPTURED_VARIABLE (t);\n-\t\t  error (\"lambda capture of %qE is not a constant expression\",\n-\t\t\t cap);\n-\t\t  if (decl_constant_var_p (cap))\n+\t\t  if (constexpr_error (input_location, fundef_p,\n+\t\t\t\t       \"lambda capture of %qE is not a \"\n+\t\t\t\t       \"constant expression\", cap)\n+\t\t      && decl_constant_var_p (cap))\n \t\t    inform (input_location, \"because it is used as a glvalue\");\n \t\t}\n \t      return false;\n@@ -9060,8 +9123,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  && COMPLETE_TYPE_P (TREE_TYPE (t))\n \t  && !is_really_empty_class (TREE_TYPE (t), /*ignore_vptr*/false))\n         {\n-          if (flags & tf_error)\n-\t    non_const_var_error (loc, t);\n+\t  if (flags & tf_error)\n+\t    non_const_var_error (loc, t, fundef_p);\n           return false;\n         }\n       return true;\n@@ -9070,7 +9133,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       if (REINTERPRET_CAST_P (t))\n \t{\n \t  if (flags & tf_error)\n-\t    error_at (loc, \"%<reinterpret_cast%> is not a constant expression\");\n+\t    constexpr_error (loc, fundef_p, \"%<reinterpret_cast%> is not a \"\n+\t\t\t     \"constant expression\");\n \t  return false;\n \t}\n       /* FALLTHRU */\n@@ -9092,8 +9156,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\t&& !integer_zerop (from))\n \t      {\n \t\tif (flags & tf_error)\n-\t\t  error_at (loc,\n-\t\t\t    \"%<reinterpret_cast%> from integer to pointer\");\n+\t\t  constexpr_error (loc, fundef_p,\n+\t\t\t\t   \"%<reinterpret_cast%> from integer to \"\n+\t\t\t\t   \"pointer\");\n \t\treturn false;\n \t      }\n \t  }\n@@ -9165,7 +9230,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t    if (!var_in_maybe_constexpr_fn (x))\n \t      {\n \t\tif (flags & tf_error)\n-\t\t  error_at (loc, \"use of %<this%> in a constant expression\");\n+\t\t  constexpr_error (loc, fundef_p, \"use of %<this%> in a \"\n+\t\t\t\t   \"constant expression\");\n \t\treturn false;\n \t      }\n \t    return true;\n@@ -9313,8 +9379,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t/* In C++17 lambdas can be constexpr, don't give up yet.  */\n \treturn true;\n       else if (flags & tf_error)\n-\terror_at (loc, \"lambda-expression is not a constant expression \"\n-\t\t  \"before C++17\");\n+\tconstexpr_error (loc, fundef_p, \"lambda-expression is not a \"\n+\t\t\t \"constant expression before C++17\");\n       return false;\n \n     case NEW_EXPR:\n@@ -9325,8 +9391,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t/* In C++20, new-expressions are potentially constant.  */\n \treturn true;\n       else if (flags & tf_error)\n-\terror_at (loc, \"new-expression is not a constant expression \"\n-\t\t  \"before C++20\");\n+\tconstexpr_error (loc, fundef_p, \"new-expression is not a \"\n+\t\t\t \"constant expression before C++20\");\n       return false;\n \n     case DYNAMIC_CAST_EXPR:\n@@ -9375,21 +9441,22 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case AT_ENCODE_EXPR:\n     fail:\n       if (flags & tf_error)\n-\terror_at (loc, \"expression %qE is not a constant expression\", t);\n+\t constexpr_error (loc, fundef_p, \"expression %qE is not a constant \"\n+\t\t\t  \"expression\", t);\n       return false;\n \n     case ASM_EXPR:\n       if (flags & tf_error)\n-\tinline_asm_in_constexpr_error (loc);\n+\tinline_asm_in_constexpr_error (loc, fundef_p);\n       return false;\n \n     case OBJ_TYPE_REF:\n       if (cxx_dialect >= cxx20)\n \t/* In C++20 virtual calls can be constexpr, don't give up yet.  */\n \treturn true;\n       else if (flags & tf_error)\n-\terror_at (loc,\n-\t\t  \"virtual functions cannot be %<constexpr%> before C++20\");\n+\tconstexpr_error (loc, fundef_p, \"virtual functions cannot be \"\n+\t\t\t \"%<constexpr%> before C++20\");\n       return false;\n \n     case TYPEID_EXPR:\n@@ -9404,8 +9471,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t    && TYPE_POLYMORPHIC_P (TREE_TYPE (e)))\n           {\n             if (flags & tf_error)\n-\t      error_at (loc, \"%<typeid%> is not a constant expression \"\n-\t\t\t\"because %qE is of polymorphic type\", e);\n+\t      constexpr_error (loc, fundef_p, \"%<typeid%> is not a \"\n+\t\t\t       \"constant expression because %qE is \"\n+\t\t\t       \"of polymorphic type\", e);\n             return false;\n           }\n         return true;\n@@ -9465,9 +9533,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t   constant expression.  */\n \t{\n \t  if (flags & tf_error)\n-\t    error_at (loc,\n-\t\t      \"cast to non-integral type %qT in a constant expression\",\n-\t\t      TREE_TYPE (t));\n+\t    constexpr_error (loc, fundef_p,\n+\t\t\t     \"cast to non-integral type %qT in a constant \"\n+\t\t\t     \"expression\", TREE_TYPE (t));\n \t  return false;\n \t}\n       /* This might be a conversion from a class to a (potentially) literal\n@@ -9523,15 +9591,17 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  if (CP_DECL_THREAD_LOCAL_P (tmp) && !DECL_REALLY_EXTERN (tmp))\n \t    {\n \t      if (flags & tf_error)\n-\t\terror_at (DECL_SOURCE_LOCATION (tmp), \"%qD defined \"\n-\t\t\t  \"%<thread_local%> in %<constexpr%> context\", tmp);\n+\t\tconstexpr_error (DECL_SOURCE_LOCATION (tmp), fundef_p,\n+\t\t\t\t \"%qD defined %<thread_local%> in \"\n+\t\t\t\t \"%<constexpr%> context\", tmp);\n \t      return false;\n \t    }\n \t  else if (TREE_STATIC (tmp))\n \t    {\n \t      if (flags & tf_error)\n-\t\terror_at (DECL_SOURCE_LOCATION (tmp), \"%qD defined \"\n-\t\t\t  \"%<static%> in %<constexpr%> context\", tmp);\n+\t\tconstexpr_error (DECL_SOURCE_LOCATION (tmp), fundef_p,\n+\t\t\t\t \"%qD defined %<static%> in %<constexpr%> \"\n+\t\t\t\t \"context\", tmp);\n \t      return false;\n \t    }\n \t  else if (!check_for_uninitialized_const_var\n@@ -9554,9 +9624,10 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  if (flags & tf_error)\n \t    {\n \t      auto_diagnostic_group d;\n-\t      error_at (loc, \"temporary of non-literal type %qT in a \"\n-\t\t\t\"constant expression\", TREE_TYPE (t));\n-\t      explain_non_literal_class (TREE_TYPE (t));\n+\t      if (constexpr_error (loc, fundef_p,\n+\t\t\t\t   \"temporary of non-literal type %qT in a \"\n+\t\t\t\t   \"constant expression\", TREE_TYPE (t)))\n+\t\texplain_non_literal_class (TREE_TYPE (t));\n \t    }\n \t  return false;\n \t}\n@@ -9603,7 +9674,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \tif (integer_zerop (denom))\n \t  {\n \t    if (flags & tf_error)\n-\t      error (\"division by zero is not a constant expression\");\n+\t      constexpr_error (input_location, fundef_p,\n+\t\t\t       \"division by zero is not a constant expression\");\n \t    return false;\n \t  }\n \telse\n@@ -9704,7 +9776,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       if (COND_EXPR_IS_VEC_DELETE (t) && cxx_dialect < cxx20)\n \t{\n \t  if (flags & tf_error)\n-\t    error_at (loc, \"%<delete[]%> is not a constant expression\");\n+\t    constexpr_error (loc, fundef_p, \"%<delete[]%> is not a \"\n+\t\t\t     \"constant expression\");\n \t  return false;\n \t}\n       /* Fall through.  */\n@@ -9734,7 +9807,7 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t{\n \t  tree this_jump_target = tmp;\n \t  if (potential_constant_expression_1 (TREE_OPERAND (t, i),\n-\t\t\t\t\t       want_rval, strict, now,\n+\t\t\t\t\t       want_rval, strict, now, fundef_p,\n \t\t\t\t\t       tf_none, &this_jump_target))\n \t    {\n \t      if (returns (&this_jump_target))\n@@ -9772,9 +9845,11 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       if (flags & tf_error)\n \t{\n \t  if (TREE_CODE (t) == IF_STMT)\n-\t    error_at (loc, \"neither branch of %<if%> is a constant expression\");\n+\t    constexpr_error (loc, fundef_p, \"neither branch of %<if%> is a \"\n+\t\t\t     \"constant expression\");\n \t  else\n-\t    error_at (loc, \"expression %qE is not a constant expression\", t);\n+\t    constexpr_error (loc, fundef_p, \"expression %qE is not a \"\n+\t\t\t     \"constant expression\", t);\n \t}\n       return false;\n \n@@ -9783,8 +9858,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \treturn true;\n       if (flags & tf_error)\n \t{\n-\t  error_at (loc, \"non-constant array initialization\");\n-\t  diagnose_non_constexpr_vec_init (t);\n+\t  if (constexpr_error (loc, fundef_p, \"non-constant array \"\n+\t\t\t       \"initialization\"))\n+\t    diagnose_non_constexpr_vec_init (t);\n \t}\n       return false;\n \n@@ -9813,7 +9889,8 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t    return true;\n \t  }\n \tif (flags & tf_error)\n-\t  error_at (loc, \"%<goto%> is not a constant expression\");\n+\t  constexpr_error (loc, fundef_p, \"%<goto%> is not a constant \"\n+\t\t\t   \"expression\");\n \treturn false;\n       }\n \n@@ -9822,8 +9899,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n       if (DECL_ARTIFICIAL (t) || cxx_dialect >= cxx23)\n \treturn true;\n       else if (flags & tf_error)\n-\terror_at (loc, \"label definition in %<constexpr%> function only \"\n-\t\t       \"available with %<-std=c++2b%> or %<-std=gnu++2b%>\");\n+\tconstexpr_error (loc, fundef_p, \"label definition in %<constexpr%> \"\n+\t\t\t \"function only available with %<-std=c++2b%> or \"\n+\t\t\t \"%<-std=gnu++2b%>\");\n       return false;\n \n     case ANNOTATE_EXPR:\n@@ -9861,21 +9939,22 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \n bool\n potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n-\t\t\t\t tsubst_flags_t flags)\n+\t\t\t\t bool fundef_p, tsubst_flags_t flags)\n {\n   if (flags & tf_error)\n     {\n       /* Check potentiality quietly first, as that could be performed more\n \t efficiently in some cases (currently only for TRUTH_*_EXPR).  If\n \t that fails, replay the check noisily to give errors.  */\n       flags &= ~tf_error;\n-      if (potential_constant_expression_1 (t, want_rval, strict, now, flags))\n+      if (potential_constant_expression_1 (t, want_rval, strict, now, fundef_p,\n+\t\t\t\t\t   flags))\n \treturn true;\n       flags |= tf_error;\n     }\n \n   tree target = NULL_TREE;\n-  return potential_constant_expression_1 (t, want_rval, strict, now,\n+  return potential_constant_expression_1 (t, want_rval, strict, now, fundef_p,\n \t\t\t\t\t  flags, &target);\n }\n \n@@ -9884,23 +9963,28 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n bool\n potential_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, true, false, tf_none);\n+  return potential_constant_expression_1 (t, /*want_rval*/false, /*strict*/true,\n+\t\t\t\t\t  /*now*/false, /*fundef_p*/false,\n+\t\t\t\t\t  tf_none);\n }\n \n /* As above, but require a constant rvalue.  */\n \n bool\n potential_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, true, false, tf_none);\n+  return potential_constant_expression_1 (t, /*want_rval*/true, /*strict*/true,\n+\t\t\t\t\t  /*now*/false, /*fundef_p*/false,\n+\t\t\t\t\t  tf_none);\n }\n \n /* Like above, but complain about non-constant expressions.  */\n \n bool\n require_potential_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, true, false,\n+  return potential_constant_expression_1 (t, /*want_rval*/false, /*strict*/true,\n+\t\t\t\t\t  /*now*/false, /*fundef_p*/false,\n \t\t\t\t\t  tf_warning_or_error);\n }\n \n@@ -9909,7 +9993,18 @@ require_potential_constant_expression (tree t)\n bool\n require_potential_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, true, false,\n+  return potential_constant_expression_1 (t, /*want_rval*/true, /*strict*/true,\n+\t\t\t\t\t  /*now*/false, /*fundef_p*/false,\n+\t\t\t\t\t  tf_warning_or_error);\n+}\n+\n+/* Like require_potential_rvalue_constant_expression, but fundef_p is true.  */\n+\n+bool\n+require_potential_rvalue_constant_expression_fncheck (tree t)\n+{\n+  return potential_constant_expression_1 (t, /*want_rval*/true, /*strict*/true,\n+\t\t\t\t\t  /*now*/false, /*fundef_p*/true,\n \t\t\t\t\t  tf_warning_or_error);\n }\n \n@@ -9918,7 +10013,8 @@ require_potential_rvalue_constant_expression (tree t)\n bool\n require_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, true, true,\n+  return potential_constant_expression_1 (t, /*want_rval*/true, /*strict*/true,\n+\t\t\t\t\t  /*now*/true, /*fundef_p*/false,\n \t\t\t\t\t  tf_warning_or_error);\n }\n \n@@ -9932,23 +10028,28 @@ require_rvalue_constant_expression (tree t)\n bool\n is_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, true, true, tf_none);\n+  return potential_constant_expression_1 (t, /*want_rval*/false, /*strict*/true,\n+\t\t\t\t\t  /*now*/true, /*fundef_p*/false,\n+\t\t\t\t\t  tf_none);\n }\n \n /* As above, but expect an rvalue.  */\n \n bool\n is_rvalue_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, true, true, true, tf_none);\n+  return potential_constant_expression_1 (t, /*want_rval*/true, /*strict*/true,\n+\t\t\t\t\t  /*now*/true, /*fundef_p*/false,\n+\t\t\t\t\t  tf_none);\n }\n \n /* Like above, but complain about non-constant expressions.  */\n \n bool\n require_constant_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, true, true,\n+  return potential_constant_expression_1 (t, /*want_rval*/false, /*strict*/true,\n+\t\t\t\t\t  /*now*/true, /*fundef_p*/false,\n \t\t\t\t\t  tf_warning_or_error);\n }\n \n@@ -9958,7 +10059,9 @@ require_constant_expression (tree t)\n bool\n is_static_init_expression (tree t)\n {\n-  return potential_constant_expression_1 (t, false, false, true, tf_none);\n+  return potential_constant_expression_1 (t, /*want_rval*/false,\n+\t\t\t\t\t  /*strict*/false, /*now*/true,\n+\t\t\t\t\t  /*fundef_p*/false, tf_none);\n }\n \n /* Returns true if T is a potential constant expression that is not"}, {"sha": "811a8345712faf31f1271301fabd96708b101dc1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -8450,6 +8450,7 @@ extern bool require_potential_constant_expression (tree);\n extern bool require_constant_expression (tree);\n extern bool require_rvalue_constant_expression (tree);\n extern bool require_potential_rvalue_constant_expression (tree);\n+extern bool require_potential_rvalue_constant_expression_fncheck (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE,\n \t\t\t\t\t\t tsubst_flags_t = tf_error);\n inline tree cxx_constant_value (tree t, tsubst_flags_t complain)"}, {"sha": "1e962b6e3b1e761d616fdbe5895b7374984f8fda", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -1332,7 +1332,7 @@ struct comp_info\n \t&& !potential_rvalue_constant_expression (expr))\n       {\n \tif (was_constexp)\n-\t  require_potential_rvalue_constant_expression (expr);\n+\t  require_potential_rvalue_constant_expression_fncheck (expr);\n \telse\n \t  constexp = false;\n       }\n@@ -2670,13 +2670,17 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n      requirements of a constexpr constructor (7.1.5), the\n      implicitly-defined default constructor is constexpr.\n \n+     C++20:\n      The implicitly-defined copy/move assignment operator is constexpr if\n       - X is a literal type, and\n       - the assignment operator selected to copy/move each direct base class\n \tsubobject is a constexpr function, and\n       - for each non-static data member of X that is of class type (or array\n \tthereof), the assignment operator selected to copy/move that\n-\tmember is a constexpr function.  */\n+\tmember is a constexpr function.\n+\n+      C++23:\n+      The implicitly-defined copy/move assignment operator is constexpr.  */\n   if (constexpr_p)\n     *constexpr_p = (SFK_CTOR_P (sfk)\n \t\t    || (SFK_ASSIGN_P (sfk) && cxx_dialect >= cxx14)"}, {"sha": "31d031cd25cc4111cdb24ccc83387067943d10b4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -256,7 +256,7 @@ in the following sections.\n -Wno-deprecated-enum-enum-conversion -Wno-deprecated-enum-float-conversion @gol\n -Weffc++  -Wno-exceptions -Wextra-semi  -Wno-inaccessible-base @gol\n -Wno-inherited-variadic-ctor  -Wno-init-list-lifetime @gol\n--Winvalid-imported-macros @gol\n+-Winvalid-constexpr -Winvalid-imported-macros @gol\n -Wno-invalid-offsetof  -Wno-literal-suffix @gol\n -Wmismatched-new-delete -Wmismatched-tags @gol\n -Wmultiple-inheritance  -Wnamespaces  -Wnarrowing @gol\n@@ -3766,6 +3766,32 @@ the variable declaration statement.\n \n @end itemize\n \n+@item -Winvalid-constexpr\n+@opindex Winvalid-constexpr\n+@opindex Wno-invalid-constexpr\n+\n+Warn when a function never produces a constant expression.  In C++20\n+and earlier, for every @code{constexpr} function and function template,\n+there must be at least one set of function arguments in at least one\n+instantiation such that an invocation of the function or constructor\n+could be an evaluated subexpression of a core constant expression.\n+C++23 removed this restriction, so it's possible to have a function\n+or a function template marked @code{constexpr} for which no invocation\n+satisfies the requirements of a core constant expression.\n+\n+This warning is enabled as a pedantic warning by default in C++20 and\n+earlier.  In C++23, @option{-Winvalid-constexpr} can be turned on, in\n+which case it will be an ordinary warning.  For example:\n+\n+@smallexample\n+void f (int& i);\n+constexpr void\n+g (int& i)\n+@{\n+  f(i); // warns by default in C++20, in C++23 only with -Winvalid-constexpr\n+@}\n+@end smallexample\n+\n @item -Winvalid-imported-macros\n @opindex Winvalid-imported-macros\n @opindex Wno-invalid-imported-macros"}, {"sha": "eabc586385fdeead84417e1164f80b05eae5ff17", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ctor2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor2.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -7,5 +7,5 @@ struct A\n \n struct B : A\n {\n-  constexpr B(): A() { }\t// { dg-error \"A::A\" }\n+  constexpr B(): A() { }\t// { dg-error \"A::A\" \"\" { target c++20_down } }\n };"}, {"sha": "2f9fbfb596aea8d6e73f82020973edc6635a7e37", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-default-ctor.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-default-ctor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-default-ctor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-default-ctor.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -7,6 +7,6 @@ struct A {\n struct B: A { };\n constexpr int f(B b) { return b.i; }\n \n-struct C { C(); };\t       // { dg-message \"\" }\n-struct D: C { };\t       // { dg-message \"\" }\n-constexpr int g(D d) { return 42; } // { dg-error \"invalid type\" }\n+struct C { C(); };\t       // { dg-message \"\" \"\" { target c++20_down } }\n+struct D: C { };\t       // { dg-message \"\" \"\" { target c++20_down } }\n+constexpr int g(D d) { return 42; } // { dg-error \"invalid type\" \"\" { target c++20_down } }"}, {"sha": "5eedf42ba36bd6c86062922abae58e2b3c0aafc9", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-diag3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag3.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -37,7 +37,7 @@ struct base\t\t       // { dg-message \"no .constexpr. constructor\" \"\" { target { !\n \n struct derived : public base\t// { dg-message \"base class\" \"\" { target { ! implicit_constexpr } } }\n {\n-  constexpr derived(): base() { } // { dg-error \"non-.constexpr. function\" \"\" { target { ! implicit_constexpr } } }\n+  constexpr derived(): base() { } // { dg-error \"non-.constexpr. function\" \"\" { target { { ! implicit_constexpr } && c++20_down } } }\n };\n \n constexpr derived obj;\t\t// { dg-error \"not literal\" \"\" { target { ! implicit_constexpr } } }"}, {"sha": "48281a477844d06ccad6e1384a063f3cbcd329c9", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ex1.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ex1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -87,7 +87,8 @@ struct resource {\n   }\n };\n constexpr resource f(resource d)\n-{ return d; }                  // { dg-error \"non-.constexpr.\" \"\" { target { ! implicit_constexpr } } }\n+{ return d; }                  // { dg-error \"non-.constexpr.\" \"\" { target { { ! implicit_constexpr } && c++20_down } } }\n+// { dg-error \"non-.constexpr.\" \"\" { target c++23 } .-2 }\n constexpr resource d = f(9);   // { dg-message \".constexpr.\" \"\" { target { ! implicit_constexpr } } }\n \n // 4.4 floating-point constant expressions"}, {"sha": "3d171822855631587b3675dd6d328a0c8f0b3530", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-friend.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -5,7 +5,7 @@ struct A { A(); };\n \n struct B {\n   friend constexpr int f(B) { return 0; } // OK\n-  friend constexpr int f(A) { return 0; } // { dg-error \"constexpr\" }\n+  friend constexpr int f(A) { return 0; } // { dg-error \"constexpr\" \"\" { target c++20_down } }\n };\n \n template <class T>"}, {"sha": "98235719546dcf4d6c3928a0c5c09f9d3a462568", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-generated1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-generated1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-generated1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-generated1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -9,7 +9,7 @@ int g();\n \n // We should complain about this.\n template<> constexpr int A<int>::f()\n-{ return g(); }\t\t\t// { dg-error \"non-.constexpr.\" }\n+{ return g(); }\t\t\t// { dg-error \"non-.constexpr.\" \"\" { target c++20_down } }\n \n // But not about this.\n struct B"}, {"sha": "70327fc414acb945d76e55eb26d13a3bf0beab47", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ice5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice5.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -9,5 +9,5 @@ struct A\n struct B\n {\n   A a[1];\n-  constexpr B() : a() {} // { dg-error \"non-constant|non-.constexpr.\" \"\" { target { ! implicit_constexpr } } }\n+  constexpr B() : a() {} // { dg-error \"non-constant|non-.constexpr.\" \"\" { target { { ! implicit_constexpr } && c++20_down } } }\n };"}, {"sha": "7eabd333758063f540049d7132a0ab9c26e93c00", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ice6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ice6.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -6,6 +6,6 @@ struct A\n   A(int);\n };\n \n-struct B : A {};                   // { dg-message \"\" }\n+struct B : A {};                   // { dg-message \"\" \"\" { target c++20_down } }\n \n-constexpr int foo(B) { return 0; } // { dg-error \"invalid type\" }\n+constexpr int foo(B) { return 0; } // { dg-error \"invalid type\" \"\" { target c++20_down } }"}, {"sha": "0c95961c730ae1f8ff9e6aeabf2131b716a93af5", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-memfn1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-memfn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-memfn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-memfn1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -13,6 +13,6 @@ constexpr X X::g(X x) { return x; }\n struct Y\n {\n   Y() { }\n-  constexpr Y f(Y y) { return y; }  // { dg-error \"constexpr\" \"\" { target { ! implicit_constexpr } } }\n-  static constexpr Y g(Y y) { return y; } // { dg-error \"constexpr\" \"\" { target { ! implicit_constexpr } } }\n+  constexpr Y f(Y y) { return y; }  // { dg-error \"constexpr\" \"\" { target { { ! implicit_constexpr } && c++20_down } } }\n+  static constexpr Y g(Y y) { return y; } // { dg-error \"constexpr\" \"\" { target { { ! implicit_constexpr } && c++20_down } } }\n };"}, {"sha": "47f7fb05e29a6996c017b5fe9774fff4e7819f6b", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-neg2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg2.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -18,10 +18,10 @@ constexpr int three = one() ? 3 : nonconst_func(0);\n constexpr int bogus() { return zero () ? 3 : nonconst_func(0); } // { dg-error \"nonconst_func\" }\n \n // Correctly rejected (not sure why).\n-constexpr int correct_error() { return nonconst_func(0); } // { dg-error \"nonconst_func\" }\n+constexpr int correct_error() { return nonconst_func(0); } // { dg-error \"nonconst_func\" \"\" { target c++20_down } }\n \n // Correctly rejected.\n constexpr int z = bogus();\t// { dg-error \"\" }\n \n // This is also correctly rejected.\n-constexpr int correct_failure() { return 0 ? 3 : nonconst_func(0); } // { dg-error \"nonconst_func\" }\n+constexpr int correct_failure() { return 0 ? 3 : nonconst_func(0); } // { dg-error \"nonconst_func\" \"\" { target c++20_down } }"}, {"sha": "abbc70368d46e4444e04ebe4d2c8464ff2b1ede9", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-non-const-arg.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-non-const-arg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-non-const-arg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-non-const-arg.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -10,7 +10,7 @@ struct B {\n int global;\t\t\t// { dg-message \"not const\" }\n \n struct D : B {\n-  constexpr D() : B(global) { }   // { dg-error \"global|argument\" }\n+  constexpr D() : B(global) { }   // { dg-error \"global|argument\" \"\" { target c++20_down } }\n };\n \n struct A2 {"}, {"sha": "4e19cd36a9f6675fe7dcca9555570b60c18db2cf", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-reinterpret1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-reinterpret1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -17,7 +17,7 @@ public:\n   constexpr static Inner & getInner()\n   /* I am surprised this is considered a constexpr */\n   {\n-    return *((Inner *)4); // { dg-error \"reinterpret_cast\" }\n+    return *((Inner *)4); // { dg-error \"reinterpret_cast\" \"\" { target c++20_down } }\n   }\n };\n "}, {"sha": "b3ef57eec5f8a32b02c5aa7272f15d2dfd3239a4", "filename": "gcc/testsuite/g++.dg/cpp0x/pr65327.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65327.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65327.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65327.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -14,5 +14,5 @@ foo ()\n constexpr volatile int // { dg-warning \"deprecated\" \"\" { target c++2a } }\n bar ()\n {\n-  return i;  // { dg-error \"lvalue-to-rvalue conversion of a volatile lvalue\" }\n+  return i;  // { dg-error \"lvalue-to-rvalue conversion of a volatile lvalue\" \"\" { target c++20_down } }\n }"}, {"sha": "e5d53c9817b656ceff613e76c3b42418b4fce74f", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-105050.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-105050.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-105050.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-105050.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -5,7 +5,7 @@ void g();\n void h();\n \n constexpr void f(int* p, int* q) {\n-  if (p != q && *p < 0) // { dg-error \"neither branch of 'if' is a constant expression\" }\n+  if (p != q && *p < 0) // { dg-error \"neither branch of 'if' is a constant expression\" \"\" { target c++20_down } }\n     g();\n   else\n     h();"}, {"sha": "7b129fcee7a530bb33b7f65bd5a08be6ba70a8cb", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-89285-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285-2.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -10,7 +10,7 @@ struct B {\n     int *c = &x->a;\n     while (*c)\n       c = reinterpret_cast<int *>((reinterpret_cast<char *>(c) + *c));\n-    *c = reinterpret_cast<char *>(this) - reinterpret_cast<char *>(c); // { dg-error \"reinterpret_cast\" }\n+    *c = reinterpret_cast<char *>(this) - reinterpret_cast<char *>(c); // { dg-error \"reinterpret_cast\" \"\" { target c++20_down } }\n   }\n };\n struct C : A {"}, {"sha": "fe0b8570ca2261827782fd4a7635c2fcf6430511", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-89285.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89285.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -10,7 +10,7 @@ struct B {\n     int *c = &x->a;\n     while (*c)\n       c = reinterpret_cast<int *>((reinterpret_cast<char *>(c) + *c));\n-    *c = reinterpret_cast<char *>(this) - reinterpret_cast<char *>(c);\t// { dg-error \"reinterpret_cast\" }\n+    *c = reinterpret_cast<char *>(this) - reinterpret_cast<char *>(c);\t// { dg-error \"reinterpret_cast\" \"\" { target c++20_down } }\n   }\n };\n struct C : A {"}, {"sha": "7afd9d24e983ba9089f6e62e1f5661e4cf631087", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-89785-2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89785-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89785-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-89785-2.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -11,7 +11,7 @@ foo (int x)\n     case 2:\n       break;\n     }\n-  throw 42;\t// { dg-error \"is not a constant expression\" }\n+  throw 42;\t// { dg-error \"is not a constant expression\" \"\" { target c++20_down } }\n   return 0;\n }\n \n@@ -29,7 +29,7 @@ bar (int x)\n \t    continue;\n \t  break;\n \t}\n-      throw -42;\t// { dg-error \"is not a constant expression\" }\n+      throw -42;\t// { dg-error \"is not a constant expression\" \"\" { target c++20_down } }\n     }\n   while (0);\n   return x;"}, {"sha": "53b5dd50f517c73c76bab598fbf7eede8c448970", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-neg1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-neg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-neg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-neg1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -3,7 +3,7 @@\n struct A { A(); };\n \n constexpr int f(int i) {\n-  static int j = i;\t\t// { dg-error \"static\" }\n+  static int j = i;\t\t// { dg-error \"static\" \"\" { target c++20_down } }\n   thread_local int l = i;\t// { dg-error \"thread_local\" \"\" { target c++20_down } }\n   goto foo;\t\t\t// { dg-error \"goto\" \"\" { target c++20_down } }\n  foo:"}, {"sha": "a410e4826647f50663ee8df7fad8cae760b1b7c6", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-nsdmi7b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi7b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi7b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi7b.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -21,7 +21,7 @@ bar()\n   A a = foo();\n   a.p->n = 5;\n   return a;\n-} // { dg-error \"non-.constexpr.\" }\n+} // { dg-error \"non-.constexpr.\" \"\" { target c++20_down } }\n \n constexpr int\n baz()"}, {"sha": "3592874468693aed51ceaab188494ddc1630d735", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-throw.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-throw.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-throw.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-throw.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -7,18 +7,18 @@ constexpr void f1() {\n \n constexpr void f2() {\n   if (true)\n-    throw;\t// { dg-error \"not a constant expression\" }\n+    throw;\t// { dg-error \"not a constant expression\" \"\" { target c++20_down } }\n }\n \n constexpr void f3() {\n   if (false)\n     ;\n   else\n-    throw;\t// { dg-error \"not a constant expression\" }\n+    throw;\t// { dg-error \"not a constant expression\" \"\" { target c++20_down } }\n }\n \n constexpr void f4() {\n-  throw;\t// { dg-error \"not a constant expression\" }\n+  throw;\t// { dg-error \"not a constant expression\" \"\" { target c++20_down } }\n }\n \n constexpr int fun(int n) {"}, {"sha": "48706f7b66e95a65b2e918b89e62057d2ecdfbda", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit10.C", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit10.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,96 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"-Winvalid-constexpr -pedantic-errors\" }\n+\n+// No constexpr constructors = not a literal type.\n+struct NonLiteral {\n+  NonLiteral() {}\n+};\n+\n+// C++23: It is possible to write a constexpr function for which no\n+// invocation satisfies the requirements of a core constant expression.\n+constexpr NonLiteral\n+fn0 (int) // { dg-warning \"invalid return type\" }\n+{\n+  return NonLiteral{};\n+}\n+\n+constexpr int\n+fn1 (NonLiteral) // { dg-warning \"invalid type\" }\n+{\n+  return 42;\n+}\n+\n+// From P2448.\n+void f(int& i) {\n+    i = 0;\n+}\n+\n+constexpr void g(int& i) {\n+    f(i); // { dg-warning \"call to\" }\n+}\n+\n+// [dcl.constexpr] used to have this.\n+constexpr int f(bool b)\n+  { return b ? throw 0 : 0; }           // OK\n+constexpr int f() { return f(true); }   // ill-formed, no diagnostic required\n+\n+struct B {\n+  constexpr B(int) : i(0) { }\n+  int i;\n+};\n+\n+int global;\n+\n+struct D : B {\n+  constexpr D() : B(global) { } // { dg-warning \"not usable\" }\n+  // ill-formed, no diagnostic required\n+  // lvalue-to-rvalue conversion on non-constant global\n+};\n+\n+// If no specialization of the template would satisfy the requirements\n+// for a constexpr function when considered as a non-template function,\n+// the template is ill-formed, no diagnostic required.\n+template<typename>\n+constexpr void\n+fn2 ()\n+{\n+  int i = 42;\n+  f (i);\n+}\n+\n+void\n+fn3 ()\n+{\n+  fn2<int>();\n+}\n+\n+constexpr volatile int cvi = 10;\n+\n+constexpr int\n+fn4 ()\n+{\n+  return cvi;  // { dg-warning \"lvalue-to-rvalue conversion\" }\n+}\n+\n+constexpr unsigned int\n+fn5 (int *p)\n+{\n+  unsigned int *q = reinterpret_cast<unsigned int *>(p); // { dg-warning \"reinterpret_cast\" }\n+  return *q;\n+}\n+\n+constexpr int\n+fn6 (int i)\n+{\n+  void *p = (void *) 1LL; // { dg-warning \".reinterpret_cast. from integer to pointer\" }\n+  return 42;\n+}\n+\n+constexpr int\n+fn7 (int i)\n+{\n+  static int s = i; // { dg-warning \"static\" }\n+  return s;\n+}"}, {"sha": "a7114bc66cbd9d10c3bac3de0e70571188a3eef3", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit11.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit11.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,53 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"-Winvalid-constexpr -pedantic-errors\" }\n+\n+// [dcl.constexpr]/4 used to say:\n+// The definition of a constexpr constructor whose function-body\n+// is not = delete shall additionally satisfy the following requirements:\n+// (4.1) for a non-delegating constructor, every constructor selected to initialize non-static data members and base class subobjects shall be a constexpr constructor;\n+// (4.2) for a delegating constructor, the target constructor shall be a constexpr constructor.\n+\n+// This continues to be OK.\n+struct Length {\n+  constexpr explicit Length(int i = 0) : val(i) { }\n+private:\n+  int val;\n+};\n+\n+struct X {\n+  X() {}\n+  X(int i_) : i(i_) {}\n+  int i;\n+};\n+\n+struct S {\n+  X x;\n+  // Calls a non-constexpr constructor X::X(int).\n+  constexpr S(int i) : x(i) { } // { dg-warning \"call to\" }\n+  S(int, int) { }\n+  // Target constructor isn't constexpr.\n+  constexpr S() : S(42, 42) { } // { dg-warning \"call to\" }\n+};\n+\n+namespace N1 {\n+struct X {\n+  void x();\n+};\n+struct Y {\n+  X x;\n+  constexpr void y() { x.x(); } // { dg-warning \"call to\" }\n+};\n+}\n+\n+void g();\n+\n+struct A {\n+  constexpr A() { g(); } // { dg-warning \"call to\" }\n+};\n+\n+struct B {\n+  constexpr B& operator=(const B&) { g(); return *this; } // { dg-warning \"call to\" }\n+  constexpr B& operator=(B&&) { g(); return *this; } // { dg-warning \"call to\" }\n+};"}, {"sha": "8f003b8019070fc9f7d7b0a239a180d0dbb7684e", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit12.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit12.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++23 } }\n+// Test that we get a diagnostic even in C++23 if you do call the function.\n+\n+constexpr unsigned int\n+fn0 (const int *p)\n+{\n+  return *reinterpret_cast<unsigned const int *>(p); // { dg-error \".reinterpret_cast. is not a constant expression\" }\n+}\n+\n+constexpr void *\n+fn1 (int i)\n+{\n+  return (void *) 1LL; // { dg-error \".reinterpret_cast.\" }\n+}\n+\n+void\n+g ()\n+{\n+  constexpr int i = 42;\n+  constexpr auto a1 = fn0 (&i);\n+  constexpr auto a2 = fn1 (i); // { dg-error \"called in a constant expression\" }\n+}"}, {"sha": "7997e8e2c3c6670521bbea0e3a04ec388e0ca146", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit13.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit13.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"-Winvalid-constexpr\" }\n+\n+constexpr volatile int i = 10;\n+\n+constexpr int\n+bar ()\n+{\n+  return i;  // { dg-warning \"lvalue-to-rvalue conversion of a volatile lvalue\" }\n+}\n+\n+constexpr int x = bar (); // { dg-error \"called in a constant expression\" }"}, {"sha": "f79ff15cbe2c87b6876d432a23302793ecfc9ab2", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit14.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit14.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"\" }\n+// The definition of a constexpr destructor whose function-body is not\n+//  =delete shall additionally satisfy the following requirement:\n+//  (5.1) for every subobject of class type or (possibly multi-dimensional)\n+//  array thereof, that class type shall have a constexpr destructor.\n+\n+struct B {\n+  B() { }\n+  ~B() { }\n+};\n+\n+struct T : B {\n+  constexpr ~T() { }\t// { dg-warning \"call to\" \"\" { target c++20_down } }\n+};\n+\n+struct S {\n+  constexpr S() = default;              // was error: implicit S() is not constexpr, now OK\n+  ~S() noexcept(false) = default;       // OK, despite mismatched exception specification\n+private:\n+  int i;\n+  S(S&);                                // OK: private copy constructor\n+};\n+S::S(S&) = default;                     // OK: defines copy constructor"}, {"sha": "aa35fa881894801839384ea4afeb46f331ef3474", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit15.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit15.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++23 } }\n+// { dg-options \"-Winvalid-constexpr\" }\n+// A copy/move assignment operator for a class X that is defaulted and\n+// not defined as deleted is implicitly defined when it is odr-used,\n+// when it is needed for constant evaluation, or when it is explicitly\n+// defaulted after its first declaration.\n+// The implicitly-defined copy/move assignment operator is constexpr.\n+\n+struct S {\n+  constexpr S() {}\n+  S& operator=(const S&) = default;\n+  S& operator=(S&&) = default;\n+};\n+\n+struct U {\n+  constexpr U& operator=(const U&) = default;\n+  constexpr U& operator=(U&&) = default;\n+};\n+\n+constexpr void\n+g ()\n+{\n+  S a;\n+  S b;\n+  b = a;\n+  b = S{};\n+\n+  U u, v;\n+  u = v;\n+  u = U{};\n+}\n+\n+static_assert ((g(), true), \"\");"}, {"sha": "a6c4d19ffc6576242706486d2cb3f993a3d66580", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit16.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit16.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++20 } }\n+// { dg-options \"\" }\n+\n+template <typename T>\n+struct Wrapper {\n+    constexpr Wrapper() = default;\n+    constexpr Wrapper(Wrapper const&) = default;\n+    constexpr Wrapper(T const& t) : t(t) { }\n+\n+    constexpr T get() const { return t; }\n+    constexpr bool operator==(Wrapper const&) const = default; // { dg-warning \"call to\" \"\" { target c++20_down } }\n+private:\n+    T t;\n+};\n+\n+struct X {\n+    X();\n+    bool operator==(X const&) const;\n+};\n+\n+Wrapper<X> x;"}, {"sha": "2238db911571fc59d6a83c0073c7b41ca3b75395", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit3.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -5,6 +5,6 @@ constexpr int\n foo ()\n {\n   goto lab;\t// { dg-error \"'goto' in 'constexpr' function only available with\" \"\" { target c++20_down } }\n-lab:\t\t// { dg-error \"'goto' is not a constant expression\" \"\" { target { c++23 } } .-1 }\n+lab:\n   return 1;\n }"}, {"sha": "a143693831857831d54cfe0fda91c638db538081", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit6.C", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit6.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -18,8 +18,19 @@ bar ()\n }\n \n constexpr int\n-baz (int x)\n+baz ()\n {\n   thread_local int a;\t// { dg-error \"'a' defined 'thread_local' in 'constexpr' context\" }\n   return ++a;\n }\n+\n+// In C++23, we get errors about the non-constant expressions only if we\n+// actually call the functions in a constexpr context.\n+\n+void\n+test ()\n+{\n+  constexpr int a = foo (); // { dg-error \"constant expression\" }\n+  constexpr int b = bar (); // { dg-error \"constant expression\" }\n+  constexpr int c = baz (); // { dg-error \"constant expression\" }\n+}"}, {"sha": "3fb1b93bd0739fefe7f8a16cf2714e8b02ddc0cd", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit8.C", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit8.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,96 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"\" }\n+\n+// No constexpr constructors = not a literal type.\n+struct NonLiteral {\n+  NonLiteral() {}\n+};\n+\n+// C++23: It is possible to write a constexpr function for which no\n+// invocation satisfies the requirements of a core constant expression.\n+constexpr NonLiteral\n+fn0 (int) // { dg-warning \"invalid return type\" \"\" { target c++20_down } }\n+{\n+  return NonLiteral{};\n+}\n+\n+constexpr int\n+fn1 (NonLiteral) // { dg-warning \"invalid type\" \"\" { target c++20_down } }\n+{\n+  return 42;\n+}\n+\n+// From P2448.\n+void f(int& i) {\n+    i = 0;\n+}\n+\n+constexpr void g(int& i) {\n+    f(i); // { dg-warning \"call to\" \"\" { target c++20_down } }\n+}\n+\n+// [dcl.constexpr] used to have this.\n+constexpr int f(bool b)\n+  { return b ? throw 0 : 0; }           // OK\n+constexpr int f() { return f(true); }   // ill-formed, no diagnostic required\n+\n+struct B {\n+  constexpr B(int) : i(0) { }\n+  int i;\n+};\n+\n+int global;\n+\n+struct D : B {\n+  constexpr D() : B(global) { } // { dg-warning \"not usable\" \"\" { target c++20_down } }\n+  // ill-formed, no diagnostic required\n+  // lvalue-to-rvalue conversion on non-constant global\n+};\n+\n+// If no specialization of the template would satisfy the requirements\n+// for a constexpr function when considered as a non-template function,\n+// the template is ill-formed, no diagnostic required.\n+template<typename>\n+constexpr void\n+fn2 ()\n+{\n+  int i = 42;\n+  f (i);\n+}\n+\n+void\n+fn3 ()\n+{\n+  fn2<int>();\n+}\n+\n+constexpr volatile int cvi = 10;\n+\n+constexpr int\n+fn4 ()\n+{\n+  return cvi;  // { dg-warning \"lvalue-to-rvalue conversion\" \"\" { target c++20_down } }\n+}\n+\n+constexpr unsigned int\n+fn5 (int *p)\n+{\n+  unsigned int *q = reinterpret_cast<unsigned int *>(p); // { dg-warning \"reinterpret_cast\" \"\" { target c++20_down } }\n+  return *q;\n+}\n+\n+constexpr int\n+fn6 (int i)\n+{\n+  void *p = (void *) 1LL; // { dg-warning \".reinterpret_cast. from integer to pointer\" \"\" { target c++20_down } }\n+  return 42;\n+}\n+\n+constexpr int\n+fn7 (int i)\n+{\n+  static int s = i; // { dg-error \"static\" \"\" { target c++20_down } }\n+  return s;\n+}"}, {"sha": "228e90f14c1b1cc81d59b166c92e93dfd0bb3499", "filename": "gcc/testsuite/g++.dg/cpp23/constexpr-nonlit9.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fconstexpr-nonlit9.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -0,0 +1,53 @@\n+// PR c++/106649\n+// P2448 - Relaxing some constexpr restrictions\n+// { dg-do compile { target c++14 } }\n+// { dg-options \"\" }\n+\n+// [dcl.constexpr]/4 used to say:\n+// The definition of a constexpr constructor whose function-body\n+// is not = delete shall additionally satisfy the following requirements:\n+// (4.1) for a non-delegating constructor, every constructor selected to initialize non-static data members and base class subobjects shall be a constexpr constructor;\n+// (4.2) for a delegating constructor, the target constructor shall be a constexpr constructor.\n+\n+// This continues to be OK.\n+struct Length {\n+  constexpr explicit Length(int i = 0) : val(i) { }\n+private:\n+  int val;\n+};\n+\n+struct X {\n+  X() {}\n+  X(int i_) : i(i_) {}\n+  int i;\n+};\n+\n+struct S {\n+  X x;\n+  // Calls a non-constexpr constructor X::X(int).\n+  constexpr S(int i) : x(i) { } // { dg-warning \"call to\" \"\" { target c++20_down } }\n+  S(int, int) { }\n+  // Target constructor isn't constexpr.\n+  constexpr S() : S(42, 42) { } // { dg-warning \"call to\" \"\" { target c++20_down } }\n+};\n+\n+namespace N1 {\n+struct X {\n+  void x();\n+};\n+struct Y {\n+  X x;\n+  constexpr void y() { x.x(); } // { dg-warning \"call to\" \"\" { target c++20_down } }\n+};\n+}\n+\n+void g();\n+\n+struct A {\n+  constexpr A() { g(); } // { dg-warning \"call to\" \"\" { target c++20_down } }\n+};\n+\n+struct B {\n+  constexpr B& operator=(const B&) { g(); return *this; } // { dg-warning \"call to\" \"\" { target c++20_down } }\n+  constexpr B& operator=(B&&) { g(); return *this; } // { dg-warning \"call to\" \"\" { target c++20_down } }\n+};"}, {"sha": "3ce36e45cb7212deddd99ff7225aa502a0a60bec", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -134,8 +134,8 @@\n \n #ifndef __cpp_constexpr\n #  error \"__cpp_constexpr\"\n-#elif __cpp_constexpr != 202110\n-#  error \"__cpp_constexpr != 202110\"\n+#elif __cpp_constexpr != 202207\n+#  error \"__cpp_constexpr != 202207\"\n #endif\n \n #ifndef __cpp_decltype_auto"}, {"sha": "627ab142d5a55a3dbf912c5fdbf6eebab2691a93", "filename": "gcc/testsuite/g++.dg/cpp2a/consteval3.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconsteval3.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -57,7 +57,6 @@ consteval int\n f13 (int x)\n {\n   static int a = 5;\t\t// { dg-error \"'a' defined 'static' in 'consteval' function only available with\" \"\" { target c++20_only } }\n-\t\t\t\t// { dg-error \"'a' defined 'static' in 'constexpr' context\" \"\" { target c++23 } .-1 }\n   thread_local int b = 6;\t// { dg-error \"'b' defined 'thread_local' in 'consteval' function only available with\" \"\" { target c++20_only } }\n   return x;\n }"}, {"sha": "b2c98853882209570c5a7ad17a75aa1b0d25bc24", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-new7.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-new7.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -13,7 +13,7 @@ void *operator new (std::size_t) noexcept;\n constexpr bool\n foo ()\n {\n-  auto p = static_cast<int *> (::operator new (sizeof (int)));\t// { dg-error \"call to non-'constexpr' function\" }\n+  auto p = static_cast<int *> (::operator new (sizeof (int)));\t// { dg-error \"call to non-'constexpr' function\" \"\" { target c++20_down } }\n   *p = 1;\n   ::operator delete (p);\n   return false;\n@@ -24,7 +24,7 @@ struct S { constexpr S () : s (0) {} int s; };\n constexpr bool\n bar ()\n {\n-  auto p = static_cast<S *> (::operator new (sizeof (S)));\t// { dg-error \"call to non-'constexpr' function\" }\n+  auto p = static_cast<S *> (::operator new (sizeof (S)));\t// { dg-error \"call to non-'constexpr' function\" \"\" { target c++20_down } }\n   auto q = new (p) S ();\n   q->s++;\n   q->~S ();"}, {"sha": "eb66105d7c493a3d2dd37c2b444197e3d75e267c", "filename": "gcc/testsuite/g++.dg/cpp2a/constexpr-try5.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-try5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-try5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconstexpr-try5.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -6,7 +6,6 @@ constexpr int foo ()\n try {\t\t\t// { dg-warning \"function-try-block body of 'constexpr' function only available with\" \"\" { target c++17_down } }\n   int a;\t\t// { dg-error \"uninitialized variable 'a' in 'constexpr' function\" \"\" { target c++17_down } }\n   static double b = 1.0;// { dg-error \"'b' defined 'static' in 'constexpr' function only available with\" \"\" { target c++20_down } }\n-\t\t\t// { dg-error \"'b' defined 'static' in 'constexpr' context\" \"\" { target c++23 } .-1 }\n   goto l;\t\t// { dg-error \"'goto' in 'constexpr' function only available with\" \"\" { target c++20_down } }\n   l:;\n   return 0;\n@@ -22,7 +21,6 @@ constexpr int bar ()\n {\n   int a;\t\t// { dg-error \"uninitialized variable 'a' in 'constexpr' function\" \"\" { target c++17_down } }\n   static long double b = 3.0;// { dg-error \"'b' defined 'static' in 'constexpr' function only available with\" \"\" { target c++20_down } }\n-\t\t\t// { dg-error \"'b' defined 'static' in 'constexpr' context\" \"\" { target c++23 } .-1 }\n   goto l;\t\t// { dg-error \"'goto' in 'constexpr' function only available with\" \"\" { target c++20_down } }\n   l:;\n   try {\t\t\t// { dg-warning \"'try' in 'constexpr' function only available with\" \"\" { target c++17_down } }"}, {"sha": "fb62ecbfdb5ef38930e76ea25f55c3961a559c29", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-constexpr1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-constexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-constexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-constexpr1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -9,7 +9,7 @@ struct A\n struct B\n {\n   A a;\n-  bool operator==(const B&) const = default; // { dg-error \"A::operator==\" \"\" { target { ! implicit_constexpr } } }\n+  bool operator==(const B&) const = default; // { dg-error \"A::operator==\" \"\" { target { { ! implicit_constexpr } && c++20_down } } }\n };\n \n constexpr bool x = B() == B();\t// { dg-error \"non-.constexpr\" \"\" { target { ! implicit_constexpr } } }"}, {"sha": "69eaa7b9b209d274772097334dfeafeb2ea75818", "filename": "gcc/testsuite/g++.dg/cpp2a/spaceship-eq3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fspaceship-eq3.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -7,8 +7,8 @@ struct A {\n struct D\n {\n   A i;\n-  bool operator==(const D& x) const = default; // { dg-error \"A::operator==\" }\n-  bool operator!=(const D& z) const = default; // { dg-error \"D::operator==\" }\n+  bool operator==(const D& x) const = default; // { dg-error \"A::operator==\" \"\" { target c++20_down } }\n+  bool operator!=(const D& z) const = default; // { dg-error \"D::operator==\" \"\" { target c++20_down } }\n };\n \n constexpr D d{A()};"}, {"sha": "19242d15ba8236c83538d9094d1ac3c34fdb4641", "filename": "gcc/testsuite/g++.dg/diagnostic/constexpr1.C", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fconstexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fconstexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdiagnostic%2Fconstexpr1.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -1,7 +1,5 @@\n // { dg-do compile { target c++11 } }\n \n constexpr int foo() { thread_local int i __attribute__((unused)) {}; return 1; }  // { dg-error \"40:.i. defined .thread_local.\" \"\" { target c++20_down } }\n-// { dg-error \"40:.i. defined .thread_local. in .constexpr. context\" \"\" { target c++23 } .-1 }\n \n constexpr int bar() { static int i __attribute__((unused)) {}; return 1; }  // { dg-error \"34:.i. defined .static.\" \"\" { target c++20_down } }\n-// { dg-error \"34:.i. defined .static. in .constexpr. context\" \"\" { target c++23 } .-1 }"}, {"sha": "f4c30c0b3f49780439ea4dfc7630063acab3d12e", "filename": "gcc/testsuite/g++.dg/gomp/pr79664.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr79664.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr79664.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr79664.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -1,6 +1,6 @@\n // PR c++/79664\n // { dg-do compile }\n-// { dg-options \"-std=c++14 -fopenmp\" }\n+// { dg-options \"-std=c++14 -fopenmp -Winvalid-constexpr -pedantic-errors\" }\n \n constexpr int\n f1 ()"}, {"sha": "1efd3f77a5598f8d5e59298139b15f32db5961e7", "filename": "gcc/testsuite/g++.dg/ubsan/vptr-4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c85f8dbb173f45053f6d8849d27adc98d9668769/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fvptr-4.C?ref=c85f8dbb173f45053f6d8849d27adc98d9668769", "patch": "@@ -1,7 +1,7 @@\n // Verify that -fsanitize=vptr downcast instrumentation works properly\n // inside of constexpr.\n // { dg-do compile }\n-// { dg-options \"-std=c++11 -fsanitize=vptr\" }\n+// { dg-options \"-std=c++11 -fsanitize=vptr -Winvalid-constexpr -pedantic-errors\" }\n \n struct S {\n   constexpr S() : a(0) {}"}]}