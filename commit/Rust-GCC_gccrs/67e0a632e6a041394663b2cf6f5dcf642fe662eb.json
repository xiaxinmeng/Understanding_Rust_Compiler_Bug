{"sha": "67e0a632e6a041394663b2cf6f5dcf642fe662eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdlMGE2MzJlNmEwNDEzOTQ2NjNiMmNmNmY1ZGNmNjQyZmU2NjJlYg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2006-05-30T16:54:08Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2006-05-30T16:54:08Z"}, "message": "cse.c (validate_canon_reg, cse_insn): Don't change insns without calling recog.\n\n2006-05-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* cse.c (validate_canon_reg, cse_insn): Don't change insns without\n\tcalling recog.\n\nFrom-SVN: r114241", "tree": {"sha": "32876cb8b388444f43ea53dad4890c74c0bff90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32876cb8b388444f43ea53dad4890c74c0bff90e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67e0a632e6a041394663b2cf6f5dcf642fe662eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e0a632e6a041394663b2cf6f5dcf642fe662eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67e0a632e6a041394663b2cf6f5dcf642fe662eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e0a632e6a041394663b2cf6f5dcf642fe662eb/comments", "author": null, "committer": null, "parents": [{"sha": "70233f378882c295d33065075e476487c1bd1729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70233f378882c295d33065075e476487c1bd1729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70233f378882c295d33065075e476487c1bd1729"}], "stats": {"total": 27, "additions": 8, "deletions": 19}, "files": [{"sha": "5f5eb4cc2e702b4a2da38a51ccd728c4288e1fa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67e0a632e6a041394663b2cf6f5dcf642fe662eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67e0a632e6a041394663b2cf6f5dcf642fe662eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67e0a632e6a041394663b2cf6f5dcf642fe662eb", "patch": "@@ -1,3 +1,8 @@\n+2006-05-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\n+\t* cse.c (validate_canon_reg, cse_insn): Don't change insns without\n+\tcalling recog.\n+\n 2006-05-30  Roger Sayle  <roger@eyesopen.com>\n \n \t* simplify-rtx.c (simplify_binary_operation): Unfactor the shift"}, {"sha": "29e20cc5f43affaa1e4a9ffc30c41fdb4d95b403", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67e0a632e6a041394663b2cf6f5dcf642fe662eb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67e0a632e6a041394663b2cf6f5dcf642fe662eb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=67e0a632e6a041394663b2cf6f5dcf642fe662eb", "patch": "@@ -2728,17 +2728,10 @@ static void\n validate_canon_reg (rtx *xloc, rtx insn)\n {\n   rtx new = canon_reg (*xloc, insn);\n-  int insn_code;\n \n   /* If replacing pseudo with hard reg or vice versa, ensure the\n      insn remains valid.  Likewise if the insn has MATCH_DUPs.  */\n-  if (insn != 0 && new != 0\n-      && REG_P (new) && REG_P (*xloc)\n-      && (((REGNO (new) < FIRST_PSEUDO_REGISTER)\n-\t   != (REGNO (*xloc) < FIRST_PSEUDO_REGISTER))\n-\t  || GET_MODE (new) != GET_MODE (*xloc)\n-\t  || (insn_code = recog_memoized (insn)) < 0\n-\t  || insn_data[insn_code].n_dups > 0))\n+  if (insn != 0 && new != 0)\n     validate_change (insn, xloc, new, 1);\n   else\n     *xloc = new;\n@@ -2748,8 +2741,7 @@ validate_canon_reg (rtx *xloc, rtx insn)\n    replace each register reference inside it\n    with the \"oldest\" equivalent register.\n \n-   If INSN is nonzero and we are replacing a pseudo with a hard register\n-   or vice versa, validate_change is used to ensure that INSN remains valid\n+   If INSN is nonzero validate_change is used to ensure that INSN remains valid\n    after we make our substitution.  The calls are made with IN_GROUP nonzero\n    so apply_change_group must be called upon the outermost return from this\n    function (unless INSN is zero).  The result of apply_change_group can\n@@ -4943,17 +4935,9 @@ cse_insn (rtx insn, rtx libcall_insn)\n       rtx dest = SET_DEST (sets[i].rtl);\n       rtx src = SET_SRC (sets[i].rtl);\n       rtx new = canon_reg (src, insn);\n-      int insn_code;\n \n       sets[i].orig_src = src;\n-      if ((REG_P (new) && REG_P (src)\n-\t   && ((REGNO (new) < FIRST_PSEUDO_REGISTER)\n-\t       != (REGNO (src) < FIRST_PSEUDO_REGISTER)))\n-\t  || (insn_code = recog_memoized (insn)) < 0\n-\t  || insn_data[insn_code].n_dups > 0)\n-\tvalidate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n-      else\n-\tSET_SRC (sets[i].rtl) = new;\n+      validate_change (insn, &SET_SRC (sets[i].rtl), new, 1);\n \n       if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{"}]}