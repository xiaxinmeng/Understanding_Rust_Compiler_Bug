{"sha": "5602f58c633e51b03b5f18bbd65924b4b842d075", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYwMmY1OGM2MzNlNTFiMDNiNWYxOGJiZDY1OTI0YjRiODQyZDA3NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:14:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:14:59Z"}, "message": "[40/77] Use scalar_int_mode for extraction_insn fields\n\ninsv, extv and eztzv modify or read a field in a register or\nmemory.  The field always has a scalar integer mode, while the\nregister or memory either has a scalar integer mode or BLKmode.\nThe mode of the bit position is also a scalar integer.\n\nThis patch uses the type system to make that explicit.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* optabs-query.h (extraction_insn::struct_mode): Change type to\n\topt_scalar_int_mode and update comment.\n\t(extraction_insn::field_mode): Change type to scalar_int_mode.\n\t(extraction_insn::pos_mode): Likewise.\n\t* combine.c (make_extraction): Update accordingly.\n\t* optabs-query.c (get_traditional_extraction_insn): Likewise.\n\t(get_optab_extraction_insn): Likewise.\n\t* recog.c (simplify_while_replacing): Likewise.\n\t* expmed.c (narrow_bit_field_mem): Change the type of the mode\n\tparameter to opt_scalar_int_mode.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251492", "tree": {"sha": "d8955268a1ac99ffbf94233ae93e5a60a4f5595a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8955268a1ac99ffbf94233ae93e5a60a4f5595a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5602f58c633e51b03b5f18bbd65924b4b842d075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5602f58c633e51b03b5f18bbd65924b4b842d075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5602f58c633e51b03b5f18bbd65924b4b842d075", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5602f58c633e51b03b5f18bbd65924b4b842d075/comments", "author": null, "committer": null, "parents": [{"sha": "ae9270466ed530df375bcaf6b3d834dbef6e3965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9270466ed530df375bcaf6b3d834dbef6e3965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9270466ed530df375bcaf6b3d834dbef6e3965"}], "stats": {"total": 103, "additions": 62, "deletions": 41}, "files": [{"sha": "be66c5dfcc7c5c14b7df887d72ca6fd8d7eb7c16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5602f58c633e51b03b5f18bbd65924b4b842d075", "patch": "@@ -1,3 +1,18 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* optabs-query.h (extraction_insn::struct_mode): Change type to\n+\topt_scalar_int_mode and update comment.\n+\t(extraction_insn::field_mode): Change type to scalar_int_mode.\n+\t(extraction_insn::pos_mode): Likewise.\n+\t* combine.c (make_extraction): Update accordingly.\n+\t* optabs-query.c (get_traditional_extraction_insn): Likewise.\n+\t(get_optab_extraction_insn): Likewise.\n+\t* recog.c (simplify_while_replacing): Likewise.\n+\t* expmed.c (narrow_bit_field_mem): Change the type of the mode\n+\tparameter to opt_scalar_int_mode.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "25e68313167d7e901e16c0f8efc3b2b01754cda1", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5602f58c633e51b03b5f18bbd65924b4b842d075", "patch": "@@ -7619,7 +7619,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   if (get_best_reg_extraction_insn (&insn, pattern,\n \t\t\t\t    GET_MODE_BITSIZE (inner_mode), mode))\n     {\n-      wanted_inner_reg_mode = insn.struct_mode;\n+      wanted_inner_reg_mode = insn.struct_mode.require ();\n       pos_mode = insn.pos_mode;\n       extraction_mode = insn.field_mode;\n     }"}, {"sha": "dabde4e53ff74f4283a88e7f6a5fa3cba18d67a2", "filename": "gcc/expmed.c", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=5602f58c633e51b03b5f18bbd65924b4b842d075", "patch": "@@ -411,31 +411,33 @@ flip_storage_order (machine_mode mode, rtx x)\n   return result;\n }\n \n-/* Adjust bitfield memory MEM so that it points to the first unit of mode\n-   MODE that contains a bitfield of size BITSIZE at bit position BITNUM.\n-   If MODE is BLKmode, return a reference to every byte in the bitfield.\n-   Set *NEW_BITNUM to the bit position of the field within the new memory.  */\n+/* If MODE is set, adjust bitfield memory MEM so that it points to the\n+   first unit of mode MODE that contains a bitfield of size BITSIZE at\n+   bit position BITNUM.  If MODE is not set, return a BLKmode reference\n+   to every byte in the bitfield.  Set *NEW_BITNUM to the bit position\n+   of the field within the new memory.  */\n \n static rtx\n-narrow_bit_field_mem (rtx mem, machine_mode mode,\n+narrow_bit_field_mem (rtx mem, opt_scalar_int_mode mode,\n \t\t      unsigned HOST_WIDE_INT bitsize,\n \t\t      unsigned HOST_WIDE_INT bitnum,\n \t\t      unsigned HOST_WIDE_INT *new_bitnum)\n {\n-  if (mode == BLKmode)\n+  scalar_int_mode imode;\n+  if (mode.exists (&imode))\n+    {\n+      unsigned int unit = GET_MODE_BITSIZE (imode);\n+      *new_bitnum = bitnum % unit;\n+      HOST_WIDE_INT offset = (bitnum - *new_bitnum) / BITS_PER_UNIT;\n+      return adjust_bitfield_address (mem, imode, offset);\n+    }\n+  else\n     {\n       *new_bitnum = bitnum % BITS_PER_UNIT;\n       HOST_WIDE_INT offset = bitnum / BITS_PER_UNIT;\n       HOST_WIDE_INT size = ((*new_bitnum + bitsize + BITS_PER_UNIT - 1)\n \t\t\t    / BITS_PER_UNIT);\n-      return adjust_bitfield_address_size (mem, mode, offset, size);\n-    }\n-  else\n-    {\n-      unsigned int unit = GET_MODE_BITSIZE (mode);\n-      *new_bitnum = bitnum % unit;\n-      HOST_WIDE_INT offset = (bitnum - *new_bitnum) / BITS_PER_UNIT;\n-      return adjust_bitfield_address (mem, mode, offset);\n+      return adjust_bitfield_address_size (mem, BLKmode, offset, size);\n     }\n }\n "}, {"sha": "b4a4976350d5fa39a03697ddee9770127ea5d49e", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=5602f58c633e51b03b5f18bbd65924b4b842d075", "patch": "@@ -100,9 +100,14 @@ get_traditional_extraction_insn (extraction_insn *insn,\n     pos_mode = word_mode;\n \n   insn->icode = icode;\n-  insn->field_mode = field_mode;\n-  insn->struct_mode = (type == ET_unaligned_mem ? byte_mode : struct_mode);\n-  insn->pos_mode = pos_mode;\n+  insn->field_mode = as_a <scalar_int_mode> (field_mode);\n+  if (type == ET_unaligned_mem)\n+    insn->struct_mode = byte_mode;\n+  else if (struct_mode == BLKmode)\n+    insn->struct_mode = opt_scalar_int_mode ();\n+  else\n+    insn->struct_mode = as_a <scalar_int_mode> (struct_mode);\n+  insn->pos_mode = as_a <scalar_int_mode> (pos_mode);\n   return true;\n }\n \n@@ -126,12 +131,17 @@ get_optab_extraction_insn (struct extraction_insn *insn,\n \n   const struct insn_data_d *data = &insn_data[icode];\n \n+  machine_mode pos_mode = data->operand[pos_op].mode;\n+  if (pos_mode == VOIDmode)\n+    pos_mode = word_mode;\n+\n   insn->icode = icode;\n-  insn->field_mode = mode;\n-  insn->struct_mode = (type == ET_unaligned_mem ? BLKmode : mode);\n-  insn->pos_mode = data->operand[pos_op].mode;\n-  if (insn->pos_mode == VOIDmode)\n-    insn->pos_mode = word_mode;\n+  insn->field_mode = as_a <scalar_int_mode> (mode);\n+  if (type == ET_unaligned_mem)\n+    insn->struct_mode = opt_scalar_int_mode ();\n+  else\n+    insn->struct_mode = insn->field_mode;\n+  insn->pos_mode = as_a <scalar_int_mode> (pos_mode);\n   return true;\n }\n "}, {"sha": "1612fc80a03ef96982e1e3df55f20aaca3cddfc3", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=5602f58c633e51b03b5f18bbd65924b4b842d075", "patch": "@@ -141,16 +141,17 @@ struct extraction_insn\n   enum insn_code icode;\n \n   /* The mode that the structure operand should have.  This is byte_mode\n-     when using the legacy insv, extv and extzv patterns to access memory.  */\n-  machine_mode struct_mode;\n+     when using the legacy insv, extv and extzv patterns to access memory.\n+     If no mode is given, the structure is a BLKmode memory.  */\n+  opt_scalar_int_mode struct_mode;\n \n   /* The mode of the field to be inserted or extracted, and by extension\n      the mode of the insertion or extraction itself.  */\n-  machine_mode field_mode;\n+  scalar_int_mode field_mode;\n \n   /* The mode of the field's bit position.  This is only important\n      when the position is variable rather than constant.  */\n-  machine_mode pos_mode;\n+  scalar_int_mode pos_mode;\n };\n \n bool get_best_reg_extraction_insn (extraction_insn *,"}, {"sha": "4a54e88f5e8b0c76a99865536592c0f39dad396e", "filename": "gcc/recog.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5602f58c633e51b03b5f18bbd65924b4b842d075/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=5602f58c633e51b03b5f18bbd65924b4b842d075", "patch": "@@ -663,25 +663,18 @@ simplify_while_replacing (rtx *loc, rtx to, rtx_insn *object,\n \t\t\t\t\tMEM_ADDR_SPACE (XEXP (x, 0)))\n \t  && !MEM_VOLATILE_P (XEXP (x, 0)))\n \t{\n-\t  machine_mode wanted_mode = VOIDmode;\n \t  int pos = INTVAL (XEXP (x, 2));\n-\n+\t  machine_mode new_mode = is_mode;\n \t  if (GET_CODE (x) == ZERO_EXTRACT && targetm.have_extzv ())\n-\t    {\n-\t      wanted_mode = insn_data[targetm.code_for_extzv].operand[1].mode;\n-\t      if (wanted_mode == VOIDmode)\n-\t\twanted_mode = word_mode;\n-\t    }\n+\t    new_mode = insn_data[targetm.code_for_extzv].operand[1].mode;\n \t  else if (GET_CODE (x) == SIGN_EXTRACT && targetm.have_extv ())\n-\t    {\n-\t      wanted_mode = insn_data[targetm.code_for_extv].operand[1].mode;\n-\t      if (wanted_mode == VOIDmode)\n-\t\twanted_mode = word_mode;\n-\t    }\n+\t    new_mode = insn_data[targetm.code_for_extv].operand[1].mode;\n+\t  scalar_int_mode wanted_mode = (new_mode == VOIDmode\n+\t\t\t\t\t ? word_mode\n+\t\t\t\t\t : as_a <scalar_int_mode> (new_mode));\n \n \t  /* If we have a narrower mode, we can do something.  */\n-\t  if (wanted_mode != VOIDmode\n-\t      && GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n+\t  if (GET_MODE_SIZE (wanted_mode) < GET_MODE_SIZE (is_mode))\n \t    {\n \t      int offset = pos / BITS_PER_UNIT;\n \t      rtx newmem;"}]}