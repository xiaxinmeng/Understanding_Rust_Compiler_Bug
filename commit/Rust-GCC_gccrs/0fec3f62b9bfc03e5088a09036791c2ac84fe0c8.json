{"sha": "0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZlYzNmNjJiOWJmYzAzZTUwODhhMDkwMzY3OTFjMmFjODRmZTBjOA==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-05-08T09:47:33Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-05-13T02:14:57Z"}, "message": "Document more x86 operand modifier.\n\nDocuments operand modifiers which are available in asm stmt but missing in document.\n\n | Modifier | Description | Available in asm stmt | Existed in documentation |\n | --- | --- | ------- | ----- |\n | L,W,B,Q,S,T | print the opcode suffix for specified size of operand. | Available | Not |\n | C | print opcode suffix for set/cmov insn. | Not | - |\n | c | like C, but print reversed condition | Not | - |\n | F,f | likewise, but for floating-point. | Not | - |\n | O | if HAVE_AS_IX86_CMOV_SUN_SYNTAX, expand to \"w.\", \"l.\" or \"q.\", otherwise nothing | Not | - |\n | R | print embedded rounding and sae. | Available | Not |\n | r | print only sae. | Available | Not |\n | z | print the opcode suffix for the size of the current operand. | Available | Existed |\n | Z | likewise, with special suffixes for x87 instructions. | Availble | Not |\n | * | print a star (in certain assembler syntax) | Not | - |\n | A | print an absolute memory reference. | Available | Existed |\n | E | print address with DImode register names if TARGET_64BIT. | Available | Existed |\n | w | print the operand as if it's a \"word\" (HImode) even if it isn't. | Available | Existed |\n | s | print a shift double count, followed by the assemblers argument delimiter. | Available | Not |\n | b | print the QImode name of the register for the indicated operand %b0 would print %al if operands[0] is reg 0. | Available | Existed |\n | w | likewise, print the HImode name of the register. | Available | Existed |\n | k | likewise, print the SImode name of the register. | Available | Existed |\n | q | likewise, print the DImode name of the register. | Available | Existed |\n | x | likewise, print the V4SFmode name of the register. | Available | Not |\n | t | likewise, print the V8SFmode name of the register. | Available | Not |\n | g | likewise, print the V16SFmode name of the register. | Avaliable | Not |\n | h | print the QImode name for a \"high\" register, either ah, bh, ch or dh. | Available | Existed |\n | y | print \"st(0)\" instead of \"st\" as a register. | Available | Not |\n | d | print duplicated register operand for AVX instruction. | Available | Not |\n | D | print condition for SSE cmp instruction. | Not | - |\n | P | if PIC, print an @PLT suffix. | Available | Existed |\n | p | print raw symbol name. | Available | Existed |\n | X | don't print any sort of PIC '@' suffix for a symbol. | Not | - |\n | & | print some in-use local-dynamic symbol name. | Not | - |\n | H | print a memory address offset by 8; used for sse high-parts | Available | Existed |\n | Y | print condition for XOP pcom* instruction. | Not | - |\n | V | print naked full integer register name without %. | Available | Existed |\n | + | print a branch hint as 'cs' or 'ds' prefix | Not | - |\n | ; | print a semicolon (after prefixes due to bug in older gas). | Not | - |\n | ~ | print \"i\" if TARGET_AVX2, \"f\" otherwise. | Not | - |\n | ^ | print addr32 prefix if TARGET_64BIT and Pmode != word_mode | Not | - |\n | M | print addr32 prefix for TARGET_X32 with VSIB address. | Not | - |\n | ! | print NOTRACK prefix for jxx/call/ret instructions if required. | Not | - |\n | N | print maskz if it's constant 0 operand. | Available | Not |\n | I | print comparision predicate operand for sse cmp condition. | Not | - |\n\ngcc/ChangeLog\n\n\tPR target/94118\n\t * doc/extend.texi (x86Operandmodifiers): Document more x86\n\t operand modifier.\n\t * gcc/config/i386/i386.c: Add comment for operand modifier N\n\t and I.\n\nModified-by: liuhongt <hongtao.liu@intel.com>", "tree": {"sha": "216e121522f3cdf9d5cc164fb31e14a6b9e7449b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/216e121522f3cdf9d5cc164fb31e14a6b9e7449b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9042fea9722a928de2c85e1c9462ab0d3380135a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9042fea9722a928de2c85e1c9462ab0d3380135a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9042fea9722a928de2c85e1c9462ab0d3380135a"}], "stats": {"total": 104, "additions": 102, "deletions": 2}, "files": [{"sha": "a7c8adecb9d10b3a85b7ed7b3b6ebe63da50eb0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "patch": "@@ -1,3 +1,11 @@\n+2020-05-13  Hongtao Liu  <hongtao.liu@intel.com>\n+\n+\tPR target/94118\n+\t * doc/extend.texi (x86Operandmodifiers): Document more x86\n+\t operand modifier.\n+\t * gcc/config/i386/i386.c: Add comment for operand modifier N\n+\t and I.\n+\n 2020-05-12  Giuliano Belinassi  <giuliano.belinassi@usp.br>\n \n \t* tree-vrp.c (class vrp_insert): New."}, {"sha": "f7a4bae49bbd085c882c7838b2b4fb2fb1acaada", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "patch": "@@ -12506,6 +12506,8 @@ print_reg (rtx x, int code, FILE *file)\n    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode\n    M -- print addr32 prefix for TARGET_X32 with VSIB address.\n    ! -- print NOTRACK prefix for jxx/call/ret instructions if required.\n+   N -- print maskz if it's constant 0 operand.\n+   I -- print comparision predicate operand for sse cmp condition.\n  */\n \n void"}, {"sha": "1c275ff1d2c7912e0dadf275f9771e56332f1d13", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fec3f62b9bfc03e5088a09036791c2ac84fe0c8/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0fec3f62b9bfc03e5088a09036791c2ac84fe0c8", "patch": "@@ -10431,6 +10431,15 @@ for the @samp{att} and @samp{intel} dialects of assembler:\n @item @code{%3}\n @tab @code{$.L3}\n @tab @code{OFFSET FLAT:.L3}\n+@item @code{%4}\n+@tab @code{$8}\n+@tab @code{8}\n+@item @code{%5}\n+@tab @code{%xmm0}\n+@tab @code{xmm0}\n+@item @code{%7}\n+@tab @code{$0}\n+@tab @code{0}\n @end multitable\n \n The table below shows the list of supported modifiers and their effects.\n@@ -10447,17 +10456,32 @@ The table below shows the list of supported modifiers and their effects.\n @tab @code{%b0}\n @tab @code{%al}\n @tab @code{al}\n+@item @code{B}\n+@tab print the opcode suffix of b.\n+@tab @code{%B0}\n+@tab @code{b}\n+@tab\n @item @code{c}\n @tab Require a constant operand and print the constant expression with no punctuation.\n @tab @code{%c1}\n @tab @code{2}\n @tab @code{2}\n+@item @code{d}\n+@tab print duplicated register operand for AVX instruction.\n+@tab @code{%d5}\n+@tab @code{%xmm0, %xmm0}\n+@tab @code{xmm0, xmm0}\n @item @code{E}\n @tab Print the address in Double Integer (DImode) mode (8 bytes) when the target is 64-bit.\n Otherwise mode is unspecified (VOIDmode).\n @tab @code{%E1}\n @tab @code{%(rax)}\n @tab @code{[rax]}\n+@item @code{g}\n+@tab Print the V16SFmode name of the register.\n+@tab @code{%g0}\n+@tab @code{%zmm0}\n+@tab @code{zmm0}\n @item @code{h}\n @tab Print the QImode name for a ``high'' register.\n @tab @code{%h0}\n@@ -10479,6 +10503,16 @@ high 8 bytes of SSE values. For a memref in (%rax), it generates\n @tab @code{%l3}\n @tab @code{.L3}\n @tab @code{.L3}\n+@item @code{L}\n+@tab print the opcode suffix of l.\n+@tab @code{%L0}\n+@tab @code{l}\n+@tab\n+@item @code{N}\n+@tab print maskz.\n+@tab @code{%N7}\n+@tab @code{@{z@}}\n+@tab @code{@{z@}}\n @item @code{p}\n @tab Print raw symbol name (without syntax-specific prefixes).\n @tab @code{%p2}\n@@ -10494,20 +10528,76 @@ issue the bare constant. See @code{p} above.\n @tab @code{%q0}\n @tab @code{%rax}\n @tab @code{rax}\n+@item @code{Q}\n+@tab print the opcode suffix of q.\n+@tab @code{%Q0}\n+@tab @code{q}\n+@tab\n+@item @code{R}\n+@tab print embedded rounding and sae.\n+@tab @code{%R4}\n+@tab @code{@{rn-sae@}, }\n+@tab @code{, @{rn-sae@}}\n+@item @code{r}\n+@tab print only sae.\n+@tab @code{%r4}\n+@tab @code{@{sae@}, }\n+@tab @code{, @{sae@}}\n+@item @code{s}\n+@tab print a shift double count, followed by the assemblers argument\n+delimiterprint the opcode suffix of s.\n+@tab @code{%s1}\n+@tab @code{$2, }\n+@tab @code{2, }\n+@item @code{S}\n+@tab print the opcode suffix of s.\n+@tab @code{%S0}\n+@tab @code{s}\n+@tab\n+@item @code{t}\n+@tab print the V8SFmode name of the register.\n+@tab @code{%t5}\n+@tab @code{%ymm0}\n+@tab @code{ymm0}\n+@item @code{T}\n+@tab print the opcode suffix of t.\n+@tab @code{%T0}\n+@tab @code{t}\n+@tab\n+@item @code{V}\n+@tab print naked full integer register name without %.\n+@tab @code{%V0}\n+@tab @code{eax}\n+@tab @code{eax}\n @item @code{w}\n @tab Print the HImode name of the register.\n @tab @code{%w0}\n @tab @code{%ax}\n @tab @code{ax}\n+@item @code{W}\n+@tab print the opcode suffix of w.\n+@tab @code{%W0}\n+@tab @code{w}\n+@tab\n+@item @code{x}\n+@tab print the V4SFmode name of the register.\n+@tab @code{%x5}\n+@tab @code{%xmm0}\n+@tab @code{xmm0}\n+@item @code{y}\n+@tab print \"st(0)\" instead of \"st\" as a register.\n+@tab @code{%y6}\n+@tab @code{%st(0)}\n+@tab @code{st(0)}\n @item @code{z}\n @tab Print the opcode suffix for the size of the current integer operand (one of @code{b}/@code{w}/@code{l}/@code{q}).\n @tab @code{%z0}\n @tab @code{l}\n @tab \n+@item @code{Z}\n+@tab Like @code{z}, with special suffixes for x87 instructions.\n @end multitable\n \n-@code{V} is a special modifier which prints the name of the full integer\n-register without @code{%}.\n \n @anchor{x86floatingpointasmoperands}\n @subsubsection x86 Floating-Point @code{asm} Operands"}]}