{"sha": "cbb409451baa17eed88f57e0b575ff5f6b01fab5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiNDA5NDUxYmFhMTdlZWQ4OGY1N2UwYjU3NWZmNWY2YjAxZmFiNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-12-05T15:50:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-12-05T15:50:06Z"}, "message": "cp-tree.h (IDENTIFIER_VIRTUAL_P): Document.\n\ncp:\n\t* cp-tree.h (IDENTIFIER_VIRTUAL_P): Document.\n\t(get_matching_virtual): Remove.\n\t(look_for_overrides): Declare new function.\n\t* decl.c (grokfndecl): Don't set IDENTIFIER_VIRTUAL_P or\n\tDECL_VINDEX here.\n\t* class.c (check_for_override): Move base class iteration code\n\tto look_for_overrides.\n\t* search.c (next_baselink): Remove.\n\t(get_virtuals_named_this): Remove.\n\t(get_virtual_destructor): Remove.\n\t(tree_has_any_destructors_p): Remove.\n\t(struct gvnt_info): Remove.\n\t(check_final_overrider): Remove `virtual' from error messages.\n\t(get_matching_virtuals): Remove. Move functionality to ...\n\t(look_for_overrides): ... here, and ...\n\t(look_for_overrides_r): ... here. Set DECL_VIRTUAL_P, if found\n\tto be overriding.\ntestsuite:\n\t* g++.old-deja/g++.h/spec6.C: Remove some of the XFAILS.\n\t* g++.old-deja/g++.other/virtual10.C: New test.\n\nFrom-SVN: r38040", "tree": {"sha": "af97c282c8bf12e05febc3bd5655a95d3b143a54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af97c282c8bf12e05febc3bd5655a95d3b143a54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb409451baa17eed88f57e0b575ff5f6b01fab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb409451baa17eed88f57e0b575ff5f6b01fab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb409451baa17eed88f57e0b575ff5f6b01fab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb409451baa17eed88f57e0b575ff5f6b01fab5/comments", "author": null, "committer": null, "parents": [{"sha": "61402b802aafc9dfc34536858decdefce1748bf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61402b802aafc9dfc34536858decdefce1748bf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61402b802aafc9dfc34536858decdefce1748bf6"}], "stats": {"total": 403, "additions": 156, "deletions": 247}, "files": [{"sha": "10fff7f054452371a07cddb5c2c48abceb044af8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -1,3 +1,23 @@\n+2000-12-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (IDENTIFIER_VIRTUAL_P): Document.\n+\t(get_matching_virtual): Remove.\n+\t(look_for_overrides): Declare new function.\n+\t* decl.c (grokfndecl): Don't set IDENTIFIER_VIRTUAL_P or\n+\tDECL_VINDEX here.\n+\t* class.c (check_for_override): Move base class iteration code\n+\tto look_for_overrides.\n+\t* search.c (next_baselink): Remove.\n+\t(get_virtuals_named_this): Remove.\n+\t(get_virtual_destructor): Remove.\n+\t(tree_has_any_destructors_p): Remove.\n+\t(struct gvnt_info): Remove.\n+\t(check_final_overrider): Remove `virtual' from error messages.\n+\t(get_matching_virtuals): Remove. Move functionality to ...\n+\t(look_for_overrides): ... here, and ...\n+\t(look_for_overrides_r): ... here. Set DECL_VIRTUAL_P, if found\n+\tto be overriding.\n+\n 2000-12-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* typeck.c (get_delta_difference): If via a virtual base,"}, {"sha": "ff3d26456c00a5dbeeef572dc3b976049da6a880", "filename": "gcc/cp/class.c", "status": "modified", "additions": 17, "deletions": 49, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -2910,56 +2910,24 @@ static void\n check_for_override (decl, ctype)\n      tree decl, ctype;\n {\n-  tree binfos = BINFO_BASETYPES (TYPE_BINFO (ctype));\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  int virtualp = DECL_VIRTUAL_P (decl);\n-  int found_overriden_fn = 0;\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    /* In [temp.mem] we have:\n \n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      if (TYPE_POLYMORPHIC_P (BINFO_TYPE (base_binfo)))\n-\t{\n-\t  tree tmp = get_matching_virtual\n-\t    (base_binfo, decl, DECL_DESTRUCTOR_P (decl));\n-\n-\t  if (tmp && !found_overriden_fn)\n-\t    {\n-\t      /* If this function overrides some virtual in some base\n-\t\t class, then the function itself is also necessarily\n-\t\t virtual, even if the user didn't explicitly say so.  */\n-\t      DECL_VIRTUAL_P (decl) = 1;\n-\n-\t      /* The TMP we really want is the one from the deepest\n-\t\t baseclass on this path, taking care not to\n-\t\t duplicate if we have already found it (via another\n-\t\t path to its virtual baseclass.  */\n-\t      if (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE)\n-\t\t{\n-\t\t  cp_error_at (\"`static %#D' cannot be declared\", decl);\n-\t\t  cp_error_at (\"  since `virtual %#D' declared in base class\",\n-\t\t\t       tmp);\n-\t\t  break;\n-\t\t}\n-\t      virtualp = 1;\n-\n-\t      /* Set DECL_VINDEX to a value that is neither an\n-\t\t INTEGER_CST nor the error_mark_node so that\n-\t\t add_virtual_function will realize this is an\n-\t\t overridden function.  */\n-\t      DECL_VINDEX (decl) \n-\t\t= tree_cons (tmp, NULL_TREE, DECL_VINDEX (decl));\n-\t      \n-\t      /* We now know that DECL overrides something,\n-\t\t which is all that is important.  But, we must\n-\t\t continue to iterate through all the base-classes\n-\t\t in order to allow get_matching_virtual to check for\n-\t\t various illegal overrides.  */\n-\t      found_overriden_fn = 1;\n-\t    }\n-\t}\n-    }\n-  if (virtualp)\n+         A specialization of a member function template does not\n+         override a virtual function from a base class.  */\n+    return;\n+  if ((DECL_DESTRUCTOR_P (decl)\n+       || IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)))\n+      && look_for_overrides (ctype, decl)\n+      && !DECL_STATIC_FUNCTION_P (decl))\n+    {\n+      /* Set DECL_VINDEX to a value that is neither an\n+\t INTEGER_CST nor the error_mark_node so that\n+\t add_virtual_function will realize this is an\n+\t overriding function.  */\n+      DECL_VINDEX (decl) = decl;\n+    }\n+  if (DECL_VIRTUAL_P (decl))\n     {\n       if (DECL_VINDEX (decl) == NULL_TREE)\n \tDECL_VINDEX (decl) = error_mark_node;"}, {"sha": "5b7eca90ac057988b455029c661c2c9ede36989d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -514,7 +514,8 @@ struct tree_srcloc\n #define SET_IDENTIFIER_ERROR_LOCUS(NODE,VALUE)\t\\\n \tSET_LANG_ID(NODE, VALUE, error_locus)\n \n-\n+/* Nonzero if this identifier is used as a virtual function name somewhere\n+   (optimizes searches).  */\n #define IDENTIFIER_VIRTUAL_P(NODE) TREE_LANG_FLAG_1(NODE)\n \n /* Nonzero if this identifier is the prefix for a mangled C++ operator\n@@ -4250,7 +4251,7 @@ extern tree lookup_field\t\t\tPARAMS ((tree, tree, int, int));\n extern int lookup_fnfields_1                    PARAMS ((tree, tree));\n extern tree lookup_fnfields\t\t\tPARAMS ((tree, tree, int));\n extern tree lookup_member\t\t\tPARAMS ((tree, tree, int, int));\n-extern tree get_matching_virtual\t\tPARAMS ((tree, tree, int));\n+extern int look_for_overrides\t\t\tPARAMS ((tree, tree));\n extern void get_pure_virtuals\t\t        PARAMS ((tree));\n extern tree init_vbase_pointers\t\t\tPARAMS ((tree, tree));\n extern void get_vbase_types\t\t\tPARAMS ((tree));"}, {"sha": "24b24dfbe301edd6f8280333e7ac9e93d0c867cb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -9038,12 +9038,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     return decl;\n \n   if (virtualp)\n-    {\n-      DECL_VIRTUAL_P (decl) = 1;\n-      if (DECL_VINDEX (decl) == NULL_TREE)\n-\tDECL_VINDEX (decl) = error_mark_node;\n-      IDENTIFIER_VIRTUAL_P (DECL_NAME (decl)) = 1;\n-    }\n+    DECL_VIRTUAL_P (decl) = 1;\n \n   return decl;\n }"}, {"sha": "601f08b0dc13dc34999607f23c59c24b939951f6", "filename": "gcc/cp/search.c", "status": "modified", "additions": 88, "deletions": 186, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -83,7 +83,6 @@ struct vbase_info\n   tree inits;\n };\n \n-static tree next_baselink PARAMS ((tree));\n static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n static tree lookup_field_1 PARAMS ((tree, tree));\n static int lookup_fnfields_here PARAMS ((tree, tree));\n@@ -110,11 +109,9 @@ static tree dfs_push_type_decls PARAMS ((tree, void *));\n static tree dfs_push_decls PARAMS ((tree, void *));\n static tree dfs_unuse_fields PARAMS ((tree, void *));\n static tree add_conversions PARAMS ((tree, void *));\n-static tree get_virtuals_named_this PARAMS ((tree, tree));\n-static tree get_virtual_destructor PARAMS ((tree, void *));\n-static tree tree_has_any_destructor_p PARAMS ((tree, void *));\n static int covariant_return_p PARAMS ((tree, tree));\n static int check_final_overrider PARAMS ((tree, tree));\n+static int look_for_overrides_r PARAMS ((tree, tree));\n static struct search_level *push_search_level\n \tPARAMS ((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n@@ -124,7 +121,6 @@ static tree bfs_walk\n \t       void *));\n static tree lookup_field_queue_p PARAMS ((tree, void *));\n static tree lookup_field_r PARAMS ((tree, void *));\n-static tree get_virtuals_named_this_r PARAMS ((tree, void *));\n static tree context_for_name_lookup PARAMS ((tree));\n static tree canonical_binfo PARAMS ((tree));\n static tree shared_marked_p PARAMS ((tree, void *));\n@@ -1867,87 +1863,6 @@ dfs_walk (binfo, fn, qfn, data)\n   return dfs_walk_real (binfo, 0, fn, qfn, data);\n }\n \n-struct gvnt_info \n-{\n-  /* The name of the function we are looking for.  */\n-  tree name;\n-  /* The overloaded functions we have found.  */\n-  tree fields;\n-};\n-\n-/* Called from get_virtuals_named_this via bfs_walk.  */\n-\n-static tree\n-get_virtuals_named_this_r (binfo, data)\n-     tree binfo;\n-     void *data;\n-{\n-  struct gvnt_info *gvnti = (struct gvnt_info *) data;\n-  tree type = BINFO_TYPE (binfo);\n-  int idx;\n-\n-  idx = lookup_fnfields_here (BINFO_TYPE (binfo), gvnti->name);\n-  if (idx >= 0)\n-    gvnti->fields\n-      = tree_cons (binfo, \n-\t\t   TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx),\n-\t\t   gvnti->fields);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Return the virtual functions with the indicated NAME in the type\n-   indicated by BINFO.  The result is a TREE_LIST whose TREE_PURPOSE\n-   indicates the base class from which the TREE_VALUE (an OVERLOAD or\n-   just a FUNCTION_DECL) originated.  */\n-\n-static tree\n-get_virtuals_named_this (binfo, name)\n-     tree binfo;\n-     tree name;\n-{\n-  struct gvnt_info gvnti;\n-  tree fields;\n-\n-  gvnti.name = name;\n-  gvnti.fields = NULL_TREE;\n-\n-  bfs_walk (binfo, get_virtuals_named_this_r, 0, &gvnti);\n-\n-  /* Get to the function decls, and return the first virtual function\n-     with this name, if there is one.  */\n-  for (fields = gvnti.fields; fields; fields = next_baselink (fields))\n-    {\n-      tree fndecl;\n-\n-      for (fndecl = TREE_VALUE (fields); fndecl; fndecl = OVL_NEXT (fndecl))\n-\tif (DECL_VINDEX (OVL_CURRENT (fndecl)))\n-\t  return fields;\n-    }\n-  return NULL_TREE;\n-}\n-\n-static tree\n-get_virtual_destructor (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree type = BINFO_TYPE (binfo);\n-  if (TYPE_HAS_DESTRUCTOR (type)\n-      && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1)))\n-    return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1);\n-  return 0;\n-}\n-\n-static tree\n-tree_has_any_destructor_p (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree type = BINFO_TYPE (binfo);\n-  return TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type) ? binfo : NULL_TREE;\n-}\n-\n /* Returns > 0 if a function with type DRETTYPE overriding a function\n    with type BRETTYPE is covariant, as defined in [class.virtual].\n \n@@ -2026,124 +1941,128 @@ check_final_overrider (overrider, basefn)\n \n       if (pedantic && i == -1)\n \t{\n-\t  cp_pedwarn_at (\"invalid covariant return type for `virtual %#D'\", overrider);\n-\t  cp_pedwarn_at (\"  overriding `virtual %#D' (must be pointer or reference to class)\", basefn);\n+\t  cp_pedwarn_at (\"invalid covariant return type for `%#D'\", overrider);\n+\t  cp_pedwarn_at (\"  overriding `%#D' (must be pointer or reference to class)\", basefn);\n \t}\n     }\n   else if (IS_AGGR_TYPE_2 (base_return, over_return)\n \t   && same_or_base_type_p (base_return, over_return))\n     {\n-      cp_error_at (\"invalid covariant return type for `virtual %#D'\", overrider);\n-      cp_error_at (\"  overriding `virtual %#D' (must use pointer or reference)\", basefn);\n+      cp_error_at (\"invalid covariant return type for `%#D'\", overrider);\n+      cp_error_at (\"  overriding `%#D' (must use pointer or reference)\", basefn);\n       return 0;\n     }\n   else if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (overrider)) == NULL_TREE)\n     {\n-      cp_error_at (\"conflicting return type specified for `virtual %#D'\", overrider);\n-      cp_error_at (\"  overriding `virtual %#D'\", basefn);\n+      cp_error_at (\"conflicting return type specified for `%#D'\", overrider);\n+      cp_error_at (\"  overriding `%#D'\", basefn);\n       SET_IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (overrider),\n                                   DECL_CONTEXT (overrider));\n       return 0;\n     }\n   \n   /* Check throw specifier is subset.  */\n-  /* XXX At the moment, punt on an overriding artificial function. We\n-     don't generate its exception specifier, so can't check it properly.  */\n+  /* XXX At the moment, punt with artificial functions. We\n+     don't generate their exception specifiers, so can't check properly.  */\n   if (! DECL_ARTIFICIAL (overrider)\n       && !comp_except_specs (base_throw, over_throw, 0))\n     {\n-      cp_error_at (\"looser throw specifier for `virtual %#F'\", overrider);\n-      cp_error_at (\"  overriding `virtual %#F'\", basefn);\n+      cp_error_at (\"looser throw specifier for `%#F'\", overrider);\n+      cp_error_at (\"  overriding `%#F'\", basefn);\n       return 0;\n     }\n   return 1;\n }\n \n-/* Given a class type TYPE, and a function decl FNDECL, look for a\n-   virtual function in TYPE's hierarchy which FNDECL could match as a\n-   virtual function.  It doesn't matter which one we find.\n-\n-   DTORP is nonzero if we are looking for a destructor.  Destructors\n-   need special treatment because they do not match by name.  */\n+/* Given a class TYPE, and a function decl FNDECL, look for\n+   virtual functions in TYPE's hierarchy which FNDECL overrides.\n+   We do not look in TYPE itself, only its bases.\n+   \n+   Returns non-zero, if we find any. Set FNDECL's DECL_VIRTUAL_P, if we\n+   find that it overrides anything.\n+   \n+   We check that every function which is overridden, is correctly\n+   overridden.  */\n \n-tree\n-get_matching_virtual (binfo, fndecl, dtorp)\n-     tree binfo, fndecl;\n-     int dtorp;\n+int\n+look_for_overrides (type, fndecl)\n+     tree type, fndecl;\n {\n-  tree tmp = NULL_TREE;\n+  tree binfo = TYPE_BINFO (type);\n+  tree basebinfos = BINFO_BASETYPES (binfo);\n+  int nbasebinfos = basebinfos ? TREE_VEC_LENGTH (basebinfos) : 0;\n+  int ix;\n+  int found = 0;\n \n-  if (TREE_CODE (fndecl) == TEMPLATE_DECL)\n-    /* In [temp.mem] we have:\n+  for (ix = 0; ix != nbasebinfos; ix++)\n+    {\n+      tree basetype = BINFO_TYPE (TREE_VEC_ELT (basebinfos, ix));\n+      \n+      if (TYPE_POLYMORPHIC_P (basetype))\n+        found += look_for_overrides_r (basetype, fndecl);\n+    }\n+  return found;\n+}\n \n-         A specialization of a member function template does not\n-         override a virtual function from a base class.  */\n-    return NULL_TREE;\n+/* Look in TYPE for virtual functions overridden by FNDECL. Check both\n+   TYPE itself and its bases. */\n \n-  /* Breadth first search routines start searching basetypes\n-     of TYPE, so we must perform first ply of search here.  */\n-  if (dtorp)\n-    return bfs_walk (binfo, get_virtual_destructor,\n-\t\t     tree_has_any_destructor_p, 0);\n+static int\n+look_for_overrides_r (type, fndecl)\n+     tree type, fndecl;\n+{\n+  int ix;\n+  \n+  if (DECL_DESTRUCTOR_P (fndecl))\n+    ix = CLASSTYPE_DESTRUCTOR_SLOT;\n   else\n+    ix = lookup_fnfields_here (type, DECL_NAME (fndecl));\n+  if (ix >= 0)\n     {\n-      tree drettype, dtypes, btypes, instptr_type;\n-      tree baselink, best = NULL_TREE;\n-      tree declarator = DECL_NAME (fndecl);\n-      if (IDENTIFIER_VIRTUAL_P (declarator) == 0)\n-\treturn NULL_TREE;\n-\n-      baselink = get_virtuals_named_this (binfo, declarator);\n-      if (baselink == NULL_TREE)\n-\treturn NULL_TREE;\n-\n-      drettype = TREE_TYPE (TREE_TYPE (fndecl));\n-      dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n-      if (DECL_STATIC_FUNCTION_P (fndecl))\n-\tinstptr_type = NULL_TREE;\n-      else\n-\tinstptr_type = TREE_TYPE (TREE_VALUE (dtypes));\n-\n-      for (; baselink; baselink = next_baselink (baselink))\n-\t{\n-\t  tree tmps;\n-\t  for (tmps = TREE_VALUE (baselink); tmps; tmps = OVL_NEXT (tmps))\n+      tree fns = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), ix);\n+      tree dtypes = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+      tree thistype = DECL_STATIC_FUNCTION_P (fndecl)\n+                      ? NULL_TREE : TREE_TYPE (TREE_VALUE (dtypes));\n+  \n+      for (; fns; fns = OVL_NEXT (fns))\n+        {\n+          tree fn = OVL_CURRENT (fns);\n+          tree btypes = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+          \n+          if (!DECL_VIRTUAL_P (fn))\n+            ;\n+\t  else if (thistype == NULL_TREE)\n \t    {\n-\t      tmp = OVL_CURRENT (tmps);\n-\t      if (! DECL_VINDEX (tmp))\n-\t\tcontinue;\n-\n-\t      btypes = TYPE_ARG_TYPES (TREE_TYPE (tmp));\n-\t      if (instptr_type == NULL_TREE)\n-\t\t{\n-\t\t  if (compparms (TREE_CHAIN (btypes), dtypes))\n-\t\t    /* Caller knows to give error in this case.  */\n-\t\t    return tmp;\n-\t\t  return NULL_TREE;\n-\t\t}\n-\n-\t      if (/* The first parameter is the `this' parameter,\n-\t\t     which has POINTER_TYPE, and we can therefore\n-\t\t     safely use TYPE_QUALS, rather than\n+\t      if (compparms (TREE_CHAIN (btypes), dtypes))\n+                {\n+                  /* A static member function cannot match an inherited\n+                     virtual member function.  */\n+                  cp_error_at (\"`%#D' cannot be declared\", fndecl);\n+                  cp_error_at (\"  since `%#D' declared in base class\", fn);\n+                  return 1;\n+                }\n+            }\n+          else\n+            {\n+              if (/* The first parameter is the `this' parameter,\n+\t             which has POINTER_TYPE, and we can therefore\n+\t             safely use TYPE_QUALS, rather than\n \t\t     CP_TYPE_QUALS.  */\n-\t\t  (TYPE_QUALS (TREE_TYPE (TREE_VALUE (btypes)))\n-\t\t   == TYPE_QUALS (instptr_type))\n-\t\t  && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes)))\n-\t\t{\n-\t          check_final_overrider (fndecl, tmp);\n-\n-\t\t  /* FNDECL overrides this function.  We continue to\n-\t\t     check all the other functions in order to catch\n-\t\t     errors; it might be that in some other baseclass\n-\t\t     a virtual function was declared with the same\n-\t\t     parameter types, but a different return type.  */\n-\t\t  best = tmp;\n-\t\t}\n+\t          (TYPE_QUALS (TREE_TYPE (TREE_VALUE (btypes)))\n+\t           == TYPE_QUALS (thistype))\n+\t          && compparms (TREE_CHAIN (btypes), TREE_CHAIN (dtypes)))\n+                {\n+                  /* It's definitely virtual, even if not explicitly set.  */\n+                  DECL_VIRTUAL_P (fndecl) = 1;\n+\t          check_final_overrider (fndecl, fn);\n+\t      \n+\t          return 1;\n+\t        }\n \t    }\n \t}\n-\n-      return best;\n     }\n+  /* We failed to find one declared in this class. Look in its bases.  */\n+  return look_for_overrides (type, fndecl);\n }\n \n /* A queue function for dfs_walk that skips any nonprimary virtual\n@@ -2320,23 +2239,6 @@ get_pure_virtuals (type)\n \t}\n     }\n }\n-\n-static tree\n-next_baselink (baselink)\n-     tree baselink;\n-{\n-  tree tmp = TREE_TYPE (baselink);\n-  baselink = TREE_CHAIN (baselink);\n-  while (tmp)\n-    {\n-      /* @@ does not yet add previous base types.  */\n-      baselink = tree_cons (TREE_PURPOSE (tmp), TREE_VALUE (tmp),\n-\t\t\t    baselink);\n-      TREE_TYPE (baselink) = TREE_TYPE (tmp);\n-      tmp = TREE_CHAIN (tmp);\n-    }\n-  return baselink;\n-}\n \f\n /* DEPTH-FIRST SEARCH ROUTINES.  */\n "}, {"sha": "be99b9943561431e00b26a2e7fc4a31267ef9f47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -1,3 +1,8 @@\n+2000-12-05  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.h/spec6.C: Remove some of the XFAILS.\n+\t* g++.old-deja/g++.other/virtual10.C: New test.\n+\n 2000-12-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.old-deja/g++.mike/pmf5.C: Remove test."}, {"sha": "b6cd06a04128f428559c691b168df30031a142ac", "filename": "gcc/testsuite/g++.old-deja/g++.eh/spec6.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -92,7 +92,7 @@ struct A\n   virtual void wobble(int) throw(E *);    // ERROR - overriding \n   virtual void wabble(int) throw(E *);\n   virtual void wubble(int) throw(E *, H *);\n-  virtual ~A() throw();                   // ERROR - overriding XFAIL\n+  virtual ~A() throw();                   // ERROR - overriding\n };\n \n struct B : A\n@@ -133,9 +133,7 @@ struct C : A, A1\n \n struct D : A, A1\n {\n-  // The xfail here is because we don't have the check in the right place to\n-  // catch dtor failings.\n-  virtual ~D() throw(int); // ERROR - looser throw - A::~A() - XFAIL\n+  virtual ~D() throw(int); // ERROR - looser throw - A::~A()\n };\n \n // [except.spec] 5, types shall not be defined in exception specifiers"}, {"sha": "020a08214c56a76592097cebf285ab19f67c3f5c", "filename": "gcc/testsuite/g++.old-deja/g++.other/virtual10.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb409451baa17eed88f57e0b575ff5f6b01fab5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual10.C?ref=cbb409451baa17eed88f57e0b575ff5f6b01fab5", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 14 Nov 2000 <nathan@codesourcery.com>\n+\n+// We failed to spot a static member which overrode a virtual\n+\n+struct A\n+{\n+  virtual int foo (char);\n+  static int foo ();\n+  virtual int foo (int);    // ERROR - this function\n+  static int foo (float);\n+  virtual int foo (double);\n+};\n+\n+struct B : A\n+{\n+  static int foo (int);   // ERROR - cannot override\n+};"}]}