{"sha": "f883e0a7dc171a20708b7d60fccdca05bb71de32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4M2UwYTdkYzE3MWEyMDcwOGI3ZDYwZmNjZGNhMDViYjcxZGUzMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-06-26T00:28:15Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-06-26T00:28:15Z"}, "message": "alias.c (record_alias_subset, [...]): Fix -Wc++-compat and/or -Wcast-qual warnings.\n\n\t* alias.c (record_alias_subset, init_alias_analysis): Fix\n\t-Wc++-compat and/or -Wcast-qual warnings.\n\t* attribs.c (lookup_attribute_spec): Likewise.\n\t* bb-reorder.c (find_traces, rotate_loop, find_traces_1_round,\n\tcopy_bb, connect_traces,\n\tfind_rarely_executed_basic_blocks_and_cr): Likewise.\n\t* bt-load.c (find_btr_def_group, add_btr_def, new_btr_user,\n\tnote_btr_set, migrate_btr_defs): Likewise.\n\t* builtins.c (result_vector, expand_builtin_memcpy,\n\texpand_builtin_mempcpy_args, expand_builtin_strncpy,\n\tbuiltin_memset_read_str, expand_builtin_printf,\n\tfold_builtin_memchr, rewrite_call_expr, fold_builtin_printf):\n\tLikewise.\n\t* caller-save.c (mark_set_regs): Likewise.\n\t* calls.c (expand_call, emit_library_call_value_1): Likewise.\n\t* cgraph.c (cgraph_edge): Likewise.\n\t* combine.c (likely_spilled_retval_1): Likewise.\n\t* coverage.c (htab_counts_entry_hash, htab_counts_entry_eq,\n\thtab_counts_entry_del, get_coverage_counts): Likewise.\n\t* cselib.c (new_elt_list, new_elt_loc_list, entry_and_rtx_equal_p,\n\tnew_cselib_val): Likewise.\n\t* dbgcnt.c (dbg_cnt_process_opt): Likewise.\n\t* dbxout.c (dbxout_init, dbxout_type, output_used_types_helper):\n\tLikewise.\n\t* df-core.c (df_compact_blocks): Likewise.\n\t* df-problems.c (df_grow_bb_info, df_chain_create): Likewise.\n\t* df-scan.c (df_grow_reg_info, df_ref_create,\n\tdf_insn_create_insn_record, df_insn_rescan, df_notes_rescan,\n\tdf_ref_compare, df_ref_create_structure, df_bb_refs_record,\n\tdf_record_entry_block_defs, df_record_exit_block_uses,\n\tdf_bb_verify): Likewise.\n\t* df.h (DF_REF_EXTRACT_WIDTH_CONST, DF_REF_EXTRACT_OFFSET_CONST,\n\tDF_REF_EXTRACT_MODE_CONST): New.\n\t* dominance.c (get_immediate_dominator, get_dominated_by,\n\tnearest_common_dominator, root_of_dom_tree,\n\titerate_fix_dominators, first_dom_son, next_dom_son): Fix\n\t-Wc++-compat and/or -Wcast-qual warnings.\n\t* dse.c (clear_alias_set_lookup, get_group_info, gen_rtx_MEM,\n\trecord_store, replace_read, check_mem_read_rtx, scan_insn,\n\tdse_step1, dse_record_singleton_alias_set): Likewise.\n\t* dwarf2asm.c (dw2_force_const_mem): Likewise.\n\nFrom-SVN: r137137", "tree": {"sha": "3626ec88a0d5007c7aaf8ffc7c298754080ebf83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3626ec88a0d5007c7aaf8ffc7c298754080ebf83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f883e0a7dc171a20708b7d60fccdca05bb71de32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f883e0a7dc171a20708b7d60fccdca05bb71de32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f883e0a7dc171a20708b7d60fccdca05bb71de32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f883e0a7dc171a20708b7d60fccdca05bb71de32/comments", "author": null, "committer": null, "parents": [{"sha": "1b4572a81dd40921680e70eef7469f0c80bc20e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b4572a81dd40921680e70eef7469f0c80bc20e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b4572a81dd40921680e70eef7469f0c80bc20e0"}], "stats": {"total": 307, "additions": 176, "deletions": 131}, "files": [{"sha": "dceb80f05adbb68d22d672171e1bb1dc0806c2c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -1,3 +1,47 @@\n+2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* alias.c (record_alias_subset, init_alias_analysis): Fix\n+\t-Wc++-compat and/or -Wcast-qual warnings.\n+\t* attribs.c (lookup_attribute_spec): Likewise.\n+\t* bb-reorder.c (find_traces, rotate_loop, find_traces_1_round,\n+\tcopy_bb, connect_traces,\n+\tfind_rarely_executed_basic_blocks_and_cr): Likewise.\n+\t* bt-load.c (find_btr_def_group, add_btr_def, new_btr_user,\n+\tnote_btr_set, migrate_btr_defs): Likewise.\n+\t* builtins.c (result_vector, expand_builtin_memcpy,\n+\texpand_builtin_mempcpy_args, expand_builtin_strncpy,\n+\tbuiltin_memset_read_str, expand_builtin_printf,\n+\tfold_builtin_memchr, rewrite_call_expr, fold_builtin_printf):\n+\tLikewise.\n+\t* caller-save.c (mark_set_regs): Likewise.\n+\t* calls.c (expand_call, emit_library_call_value_1): Likewise.\n+\t* cgraph.c (cgraph_edge): Likewise.\n+\t* combine.c (likely_spilled_retval_1): Likewise.\n+\t* coverage.c (htab_counts_entry_hash, htab_counts_entry_eq,\n+\thtab_counts_entry_del, get_coverage_counts): Likewise.\n+\t* cselib.c (new_elt_list, new_elt_loc_list, entry_and_rtx_equal_p,\n+\tnew_cselib_val): Likewise.\n+\t* dbgcnt.c (dbg_cnt_process_opt): Likewise.\n+\t* dbxout.c (dbxout_init, dbxout_type, output_used_types_helper):\n+\tLikewise.\n+\t* df-core.c (df_compact_blocks): Likewise.\n+\t* df-problems.c (df_grow_bb_info, df_chain_create): Likewise.\n+\t* df-scan.c (df_grow_reg_info, df_ref_create,\n+\tdf_insn_create_insn_record, df_insn_rescan, df_notes_rescan,\n+\tdf_ref_compare, df_ref_create_structure, df_bb_refs_record,\n+\tdf_record_entry_block_defs, df_record_exit_block_uses,\n+\tdf_bb_verify): Likewise.\n+\t* df.h (DF_REF_EXTRACT_WIDTH_CONST, DF_REF_EXTRACT_OFFSET_CONST,\n+\tDF_REF_EXTRACT_MODE_CONST): New.\n+\t* dominance.c (get_immediate_dominator, get_dominated_by,\n+\tnearest_common_dominator, root_of_dom_tree,\n+\titerate_fix_dominators, first_dom_son, next_dom_son): Fix\n+\t-Wc++-compat and/or -Wcast-qual warnings.\n+\t* dse.c (clear_alias_set_lookup, get_group_info, gen_rtx_MEM,\n+\trecord_store, replace_read, check_mem_read_rtx, scan_insn,\n+\tdse_step1, dse_record_singleton_alias_set): Likewise.\n+\t* dwarf2asm.c (dw2_force_const_mem): Likewise.\n+\n 2008-06-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* dwarf2out.c (new_cfi, queue_reg_save, dwarf2out_begin_prologue,"}, {"sha": "684205cd89e35ce1bb80135cfd0e78de80a814cb", "filename": "gcc/alias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -713,7 +713,7 @@ record_alias_subset (alias_set_type superset, alias_set_type subset)\n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n-      superset_entry = ggc_alloc (sizeof (struct alias_set_entry));\n+      superset_entry = GGC_NEW (struct alias_set_entry);\n       superset_entry->alias_set = superset;\n       superset_entry->children\n \t= splay_tree_new_ggc (splay_tree_compare_ints);\n@@ -2412,8 +2412,8 @@ init_alias_analysis (void)\n   timevar_push (TV_ALIAS_ANALYSIS);\n \n   reg_known_value_size = maxreg - FIRST_PSEUDO_REGISTER;\n-  reg_known_value = ggc_calloc (reg_known_value_size, sizeof (rtx));\n-  reg_known_equiv_p = xcalloc (reg_known_value_size, sizeof (bool));\n+  reg_known_value = GGC_CNEWVEC (rtx, reg_known_value_size);\n+  reg_known_equiv_p = XCNEWVEC (bool, reg_known_value_size);\n \n   /* If we have memory allocated from the previous run, use it.  */\n   if (old_reg_base_value)"}, {"sha": "3c60e8bd96790d611ee45a87c06cf08d475eb1f5", "filename": "gcc/attribs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -206,8 +206,9 @@ lookup_attribute_spec (tree name)\n   attr.str = IDENTIFIER_POINTER (name);\n   attr.length = IDENTIFIER_LENGTH (name);\n   extract_attribute_substring (&attr);\n-  return htab_find_with_hash (attribute_hash, &attr,\n-\t\t\t      substring_hash (attr.str, attr.length));\n+  return (const struct attribute_spec *)\n+    htab_find_with_hash (attribute_hash, &attr,\n+\t\t\t substring_hash (attr.str, attr.length));\n }\n \f\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,"}, {"sha": "b36c6c24bb3b45bda6cbfcbc1a148fba89d2921d", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -278,7 +278,7 @@ find_traces (int *n_traces, struct trace *traces)\n \t  basic_block bb;\n \t  fprintf (dump_file, \"Trace %d (round %d):  \", i + 1,\n \t\t   traces[i].round + 1);\n-\t  for (bb = traces[i].first; bb != traces[i].last; bb = bb->aux)\n+\t  for (bb = traces[i].first; bb != traces[i].last; bb = (basic_block) bb->aux)\n \t    fprintf (dump_file, \"%d [%d] \", bb->index, bb->frequency);\n \t  fprintf (dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n \t}\n@@ -358,7 +358,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t}\n \t    }\n \t}\n-      bb = bb->aux;\n+      bb = (basic_block) bb->aux;\n     }\n   while (bb != back_edge->dest);\n \n@@ -368,15 +368,15 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t the trace.  */\n       if (back_edge->dest == trace->first)\n \t{\n-\t  trace->first = best_bb->aux;\n+\t  trace->first = (basic_block) best_bb->aux;\n \t}\n       else\n \t{\n \t  basic_block prev_bb;\n \n \t  for (prev_bb = trace->first;\n \t       prev_bb->aux != back_edge->dest;\n-\t       prev_bb = prev_bb->aux)\n+\t       prev_bb = (basic_block) prev_bb->aux)\n \t    ;\n \t  prev_bb->aux = best_bb->aux;\n \n@@ -442,7 +442,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       fibheapkey_t key;\n       edge_iterator ei;\n \n-      bb = fibheap_extract_min (*heap);\n+      bb = (basic_block) fibheap_extract_min (*heap);\n       bbd[bb->index].heap = NULL;\n       bbd[bb->index].node = NULL;\n \n@@ -780,7 +780,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n \n       new_size = MAX (last_basic_block, new_bb->index + 1);\n       new_size = GET_ARRAY_SIZE (new_size);\n-      bbd = xrealloc (bbd, new_size * sizeof (bbro_basic_block_data));\n+      bbd = XRESIZEVEC (bbro_basic_block_data, bbd, new_size);\n       for (i = array_size; i < new_size; i++)\n \t{\n \t  bbd[i].start_of_trace = -1;\n@@ -1143,7 +1143,7 @@ connect_traces (int n_traces, struct trace *traces)\n       basic_block bb;\n \n       fprintf (dump_file, \"Final order:\\n\");\n-      for (bb = traces[0].first; bb; bb = bb->aux)\n+      for (bb = traces[0].first; bb; bb = (basic_block) bb->aux)\n \tfprintf (dump_file, \"%d \", bb->index);\n       fprintf (dump_file, \"\\n\");\n       fflush (dump_file);\n@@ -1251,8 +1251,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge **crossing_edges,\n \t  if (i == *max_idx)\n \t    {\n \t      *max_idx *= 2;\n-\t      *crossing_edges = xrealloc (*crossing_edges,\n-\t\t\t\t\t (*max_idx) * sizeof (edge));\n+\t      *crossing_edges = XRESIZEVEC (edge, *crossing_edges, *max_idx);\n \t    }\n \t  (*crossing_edges)[i++] = e;\n \t}"}, {"sha": "b0a7fdb4a21db10962a86e6e7fd9dae2147461fe", "filename": "gcc/bt-load.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -279,8 +279,7 @@ find_btr_def_group (btr_def_group *all_btr_def_groups, btr_def def)\n \n       if (!this_group)\n \t{\n-\t  this_group = obstack_alloc (&migrate_btrl_obstack,\n-\t\t\t\t      sizeof (struct btr_def_group_s));\n+\t  this_group = XOBNEW (&migrate_btrl_obstack, struct btr_def_group_s);\n \t  this_group->src = def_src;\n \t  this_group->members = NULL;\n \t  this_group->next = *all_btr_def_groups;\n@@ -303,7 +302,7 @@ add_btr_def (fibheap_t all_btr_defs, basic_block bb, int insn_luid, rtx insn,\n \t     btr_def_group *all_btr_def_groups)\n {\n   btr_def this\n-    = obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_def_s));\n+    = XOBNEW (&migrate_btrl_obstack, struct btr_def_s);\n   this->bb = bb;\n   this->luid = insn_luid;\n   this->insn = insn;\n@@ -354,7 +353,7 @@ new_btr_user (basic_block bb, int insn_luid, rtx insn)\n \tusep = NULL;\n     }\n   use = usep ? *usep : NULL_RTX;\n-  user = obstack_alloc (&migrate_btrl_obstack, sizeof (struct btr_user_s));\n+  user = XOBNEW (&migrate_btrl_obstack, struct btr_user_s);\n   user->bb = bb;\n   user->luid = insn_luid;\n   user->insn = insn;\n@@ -425,7 +424,7 @@ typedef struct {\n static void\n note_btr_set (rtx dest, const_rtx set ATTRIBUTE_UNUSED, void *data)\n {\n-  defs_uses_info *info = data;\n+  defs_uses_info *info = (defs_uses_info *) data;\n   int regno, end_regno;\n \n   if (!REG_P (dest))\n@@ -1428,14 +1427,14 @@ migrate_btr_defs (enum reg_class btr_class, int allow_callee_save)\n \t  first_btr = reg;\n       }\n \n-  btrs_live = xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n-  btrs_live_at_end = xcalloc (n_basic_blocks, sizeof (HARD_REG_SET));\n+  btrs_live = XCNEWVEC (HARD_REG_SET, n_basic_blocks);\n+  btrs_live_at_end = XCNEWVEC (HARD_REG_SET, n_basic_blocks);\n \n   build_btr_def_use_webs (all_btr_defs);\n \n   while (!fibheap_empty (all_btr_defs))\n     {\n-      btr_def def = fibheap_extract_min (all_btr_defs);\n+      btr_def def = (btr_def) fibheap_extract_min (all_btr_defs);\n       int min_cost = -fibheap_min_key (all_btr_defs);\n       if (migrate_btr_def (def, min_cost))\n \t{"}, {"sha": "1039c603795287a35d290c1b3635ed8a1a07170c", "filename": "gcc/builtins.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -1292,7 +1292,7 @@ result_vector (int savep, rtx result)\n   int regno, size, align, nelts;\n   enum machine_mode mode;\n   rtx reg, mem;\n-  rtx *savevec = alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n+  rtx *savevec = XALLOCAVEC (rtx, FIRST_PSEUDO_REGISTER);\n \n   size = nelts = 0;\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n@@ -3327,11 +3327,13 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \t  && GET_CODE (len_rtx) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t\t  (void *) src_str, dest_align, false))\n+\t\t\t\t  CONST_CAST (char *, src_str),\n+\t\t\t\t  dest_align, false))\n \t{\n \t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n \t\t\t\t      builtin_memcpy_read_str,\n-\t\t\t\t      (void *) src_str, dest_align, false, 0);\n+\t\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t\t      dest_align, false, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3440,14 +3442,15 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n \t  && GET_CODE (len_rtx) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) INTVAL (len_rtx) <= strlen (src_str) + 1\n \t  && can_store_by_pieces (INTVAL (len_rtx), builtin_memcpy_read_str,\n-\t\t\t\t  (void *) src_str, dest_align, false))\n+\t\t\t\t  CONST_CAST (char *, src_str),\n+\t\t\t\t  dest_align, false))\n \t{\n \t  dest_mem = get_memory_rtx (dest, len);\n \t  set_mem_align (dest_mem, dest_align);\n \t  dest_mem = store_by_pieces (dest_mem, INTVAL (len_rtx),\n \t\t\t\t      builtin_memcpy_read_str,\n-\t\t\t\t      (void *) src_str, dest_align,\n-\t\t\t\t      false, endp);\n+\t\t\t\t      CONST_CAST (char *, src_str),\n+\t\t\t\t      dest_align, false, endp);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3789,13 +3792,14 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n \t  if (!p || dest_align == 0 || !host_integerp (len, 1)\n \t      || !can_store_by_pieces (tree_low_cst (len, 1),\n \t\t\t\t       builtin_strncpy_read_str,\n-\t\t\t\t       (void *) p, dest_align, false))\n+\t\t\t\t       CONST_CAST (char *, p),\n+\t\t\t\t       dest_align, false))\n \t    return NULL_RTX;\n \n \t  dest_mem = get_memory_rtx (dest, len);\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_strncpy_read_str,\n-\t\t\t   (void *) p, dest_align, false, 0);\n+\t\t\t   CONST_CAST (char *, p), dest_align, false, 0);\n \t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n@@ -3813,7 +3817,7 @@ builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode mode)\n {\n   const char *c = (const char *) data;\n-  char *p = alloca (GET_MODE_SIZE (mode));\n+  char *p = XALLOCAVEC (char, GET_MODE_SIZE (mode));\n \n   memset (p, *c, GET_MODE_SIZE (mode));\n \n@@ -3837,7 +3841,7 @@ builtin_memset_gen_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n   if (size == 1)\n     return (rtx) data;\n \n-  p = alloca (size);\n+  p = XALLOCAVEC (char, size);\n   memset (p, 1, size);\n   coeff = c_readstr (p, mode);\n \n@@ -5311,7 +5315,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \t    {\n \t      /* Create a NUL-terminated string that's one char shorter\n \t\t than the original, stripping off the trailing '\\n'.  */\n-\t      char *newstr = alloca (len);\n+\t      char *newstr = XALLOCAVEC (char, len);\n \t      memcpy (newstr, fmt_str, len - 1);\n \t      newstr[len - 1] = 0;\n \t      arg = build_string_literal (len, newstr);\n@@ -8902,7 +8906,7 @@ fold_builtin_memchr (tree arg1, tree arg2, tree len, tree type)\n \t  if (target_char_cast (arg2, &c))\n \t    return NULL_TREE;\n \n-\t  r = memchr (p1, c, tree_low_cst (len, 1));\n+\t  r = (char *) memchr (p1, c, tree_low_cst (len, 1));\n \n \t  if (r == NULL)\n \t    return build_int_cst (TREE_TYPE (arg1), 0);\n@@ -10752,7 +10756,7 @@ rewrite_call_expr (tree exp, int skip, tree fndecl, int n, ...)\n       int i, j;\n       va_list ap;\n \n-      buffer = alloca (nargs * sizeof (tree));\n+      buffer = XALLOCAVEC (tree, nargs);\n       va_start (ap, n);\n       for (i = 0; i < n; i++)\n \tbuffer[i] = va_arg (ap, tree);\n@@ -12469,7 +12473,7 @@ fold_builtin_printf (tree fndecl, tree fmt, tree arg, bool ignore,\n \t    {\n \t      /* Create a NUL-terminated string that's one char shorter\n \t\t than the original, stripping off the trailing '\\n'.  */\n-\t      char *newstr = alloca (len);\n+\t      char *newstr = XALLOCAVEC (char, len);\n \t      memcpy (newstr, str, len - 1);\n \t      newstr[len - 1] = 0;\n "}, {"sha": "f8a3c3877752006d3770ffbb47ff2defe1f240eb", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -516,7 +516,7 @@ static void\n mark_set_regs (rtx reg, const_rtx setter ATTRIBUTE_UNUSED, void *data)\n {\n   int regno, endregno, i;\n-  HARD_REG_SET *this_insn_sets = data;\n+  HARD_REG_SET *this_insn_sets = (HARD_REG_SET *) data;\n \n   if (GET_CODE (reg) == SUBREG)\n     {"}, {"sha": "79dc47b98fa16802be9ef874258e1cec278bae70", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -2214,7 +2214,7 @@ expand_call (tree exp, rtx target, int ignore)\n     n_named_args = num_actuals;\n \n   /* Make a vector to hold all the information about each arg.  */\n-  args = alloca (num_actuals * sizeof (struct arg_data));\n+  args = XALLOCAVEC (struct arg_data, num_actuals);\n   memset (args, 0, num_actuals * sizeof (struct arg_data));\n \n   /* Build up entries in the ARGS array, compute the size of the\n@@ -3316,7 +3316,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      of the full argument passing conventions to limit complexity here since\n      library functions shouldn't have many args.  */\n \n-  argvec = alloca ((nargs + 1) * sizeof (struct arg));\n+  argvec = XALLOCAVEC (struct arg, nargs + 1);\n   memset (argvec, 0, (nargs + 1) * sizeof (struct arg));\n \n #ifdef INIT_CUMULATIVE_LIBCALL_ARGS"}, {"sha": "17ee8f0a63af52a6fff5ae2f095d6f3064895170", "filename": "gcc/cgraph.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -262,8 +262,9 @@ cgraph_edge (struct cgraph_node *node, tree call_stmt)\n   int n = 0;\n \n   if (node->call_site_hash)\n-    return htab_find_with_hash (node->call_site_hash, call_stmt,\n-      \t\t\t\thtab_hash_pointer (call_stmt));\n+    return (struct cgraph_edge *)\n+      htab_find_with_hash (node->call_site_hash, call_stmt,\n+\t\t\t   htab_hash_pointer (call_stmt));\n \n   /* This loop may turn out to be performance problem.  In such case adding\n      hashtables into call nodes with very many edges is probably best"}, {"sha": "59586a8bf18aed80c65e2dc7adc51161634270b2", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -2021,7 +2021,8 @@ struct likely_spilled_retval_info\n static void\n likely_spilled_retval_1 (rtx x, const_rtx set, void *data)\n {\n-  struct likely_spilled_retval_info *info = data;\n+  struct likely_spilled_retval_info *const info =\n+    (struct likely_spilled_retval_info *) data;\n   unsigned regno, nregs;\n   unsigned new_mask;\n "}, {"sha": "6432bb1f59ac2d905831bfff7ce94456578b3687", "filename": "gcc/coverage.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -141,24 +141,24 @@ get_gcov_unsigned_t (void)\n static hashval_t\n htab_counts_entry_hash (const void *of)\n {\n-  const counts_entry_t *entry = of;\n+  const counts_entry_t *const entry = (const counts_entry_t *) of;\n \n   return entry->ident * GCOV_COUNTERS + entry->ctr;\n }\n \n static int\n htab_counts_entry_eq (const void *of1, const void *of2)\n {\n-  const counts_entry_t *entry1 = of1;\n-  const counts_entry_t *entry2 = of2;\n+  const counts_entry_t *const entry1 = (const counts_entry_t *) of1;\n+  const counts_entry_t *const entry2 = (const counts_entry_t *) of2;\n \n   return entry1->ident == entry2->ident && entry1->ctr == entry2->ctr;\n }\n \n static void\n htab_counts_entry_del (void *of)\n {\n-  counts_entry_t *entry = of;\n+  counts_entry_t *const entry = (counts_entry_t *) of;\n \n   free (entry->counts);\n   free (entry);\n@@ -343,7 +343,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n \n   elt.ident = current_function_funcdef_no + 1;\n   elt.ctr = counter;\n-  entry = htab_find (counts_hash, &elt);\n+  entry = (counts_entry_t *) htab_find (counts_hash, &elt);\n   if (!entry)\n     {\n       warning (0, \"no coverage for function %qs found\", IDENTIFIER_POINTER"}, {"sha": "d50d0c44f1798851d4b778e0063150482824f880", "filename": "gcc/cselib.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -142,7 +142,7 @@ static inline struct elt_list *\n new_elt_list (struct elt_list *next, cselib_val *elt)\n {\n   struct elt_list *el;\n-  el = pool_alloc (elt_list_pool);\n+  el = (struct elt_list *) pool_alloc (elt_list_pool);\n   el->next = next;\n   el->elt = elt;\n   return el;\n@@ -155,7 +155,7 @@ static inline struct elt_loc_list *\n new_elt_loc_list (struct elt_loc_list *next, rtx loc)\n {\n   struct elt_loc_list *el;\n-  el = pool_alloc (elt_loc_list_pool);\n+  el = (struct elt_loc_list *) pool_alloc (elt_loc_list_pool);\n   el->next = next;\n   el->loc = loc;\n   el->setting_insn = cselib_current_insn;\n@@ -232,7 +232,7 @@ entry_and_rtx_equal_p (const void *entry, const void *x_arg)\n {\n   struct elt_loc_list *l;\n   const cselib_val *const v = (const cselib_val *) entry;\n-  rtx x = (rtx) x_arg;\n+  rtx x = CONST_CAST_RTX ((const_rtx)x_arg);\n   enum machine_mode mode = GET_MODE (x);\n \n   gcc_assert (GET_CODE (x) != CONST_INT && GET_CODE (x) != CONST_FIXED\n@@ -749,7 +749,7 @@ cselib_hash_rtx (rtx x, int create)\n static inline cselib_val *\n new_cselib_val (unsigned int value, enum machine_mode mode)\n {\n-  cselib_val *e = pool_alloc (cselib_val_pool);\n+  cselib_val *e = (cselib_val *) pool_alloc (cselib_val_pool);\n \n   gcc_assert (value);\n \n@@ -759,7 +759,7 @@ new_cselib_val (unsigned int value, enum machine_mode mode)\n      precisely when we can have VALUE RTXen (when cselib is active)\n      so we don't need to put them in garbage collected memory.\n      ??? Why should a VALUE be an RTX in the first place?  */\n-  e->val_rtx = pool_alloc (value_pool);\n+  e->val_rtx = (rtx) pool_alloc (value_pool);\n   memset (e->val_rtx, 0, RTX_HDR_SIZE);\n   PUT_CODE (e->val_rtx, VALUE);\n   PUT_MODE (e->val_rtx, mode);"}, {"sha": "6d101a6a2cc04a62b36cbba4bae192e09a1063da", "filename": "gcc/dbgcnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdbgcnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdbgcnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -129,7 +129,7 @@ dbg_cnt_process_opt (const char *arg)\n \n    if (next == NULL || *next != 0)\n      {\n-       char *buffer = alloca (arg - start + 2);\n+       char *buffer = XALLOCAVEC (char, arg - start + 2);\n        sprintf (buffer, \"%*c\", (int)(1 + (arg - start)), '^');\n        error (\"Can not find a valid counter:value pair:\");\n        error (\"-fdbg-cnt=%s\", start);"}, {"sha": "9505875307551a5c225fa545d0de4457b4ea1256", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -996,7 +996,7 @@ dbxout_init (const char *input_file_name)\n   const char *mapped_name;\n \n   typevec_len = 100;\n-  typevec = ggc_calloc (typevec_len, sizeof typevec[0]);\n+  typevec = GGC_CNEWVEC (struct typeinfo, typevec_len);\n \n   /* stabstr_ob contains one string, which will be just fine with\n      1-byte alignment.  */\n@@ -1709,8 +1709,7 @@ dbxout_type (tree type, int full)\n \n       if (next_type_number == typevec_len)\n \t{\n-\t  typevec\n-\t    = ggc_realloc (typevec, (typevec_len * 2 * sizeof typevec[0]));\n+\t  typevec = GGC_RESIZEVEC (struct typeinfo, typevec, typevec_len * 2);\n \t  memset (typevec + typevec_len, 0, typevec_len * sizeof typevec[0]);\n \t  typevec_len *= 2;\n \t}\n@@ -2404,8 +2403,8 @@ dbxout_expand_expr (tree expr)\n static int\n output_used_types_helper (void **slot, void *data)\n {\n-  tree type = *slot;\n-  VEC(tree, heap) **types_p = data;\n+  tree type = (tree) *slot;\n+  VEC(tree, heap) **types_p = (VEC(tree, heap) **) data;\n \n   if ((TREE_CODE (type) == RECORD_TYPE\n        || TREE_CODE (type) == UNION_TYPE"}, {"sha": "8e6a4e148254e6d2b0f1a893abc270deb46bbff2", "filename": "gcc/df-core.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -1455,7 +1455,7 @@ df_compact_blocks (void)\n   void **problem_temps;\n   int size = last_basic_block * sizeof (void *);\n   bitmap tmp = BITMAP_ALLOC (&df_bitmap_obstack);\n-  problem_temps = xmalloc (size);\n+  problem_temps = XNEWVAR (void *, size);\n \n   for (p = 0; p < df->num_problems_defined; p++)\n     {"}, {"sha": "28c99638ec3f814927d1f8af4f37be580ef8a179", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -109,8 +109,7 @@ df_grow_bb_info (struct dataflow *dflow)\n   if (dflow->block_info_size < new_size)\n     {\n       new_size += new_size / 4;\n-      dflow->block_info = xrealloc (dflow->block_info, \n-\t\t\t\t    new_size *sizeof (void*));\n+      dflow->block_info = XRESIZEVEC (void *, dflow->block_info, new_size);\n       memset (dflow->block_info + dflow->block_info_size, 0,\n \t      (new_size - dflow->block_info_size) *sizeof (void *));\n       dflow->block_info_size = new_size;\n@@ -1862,7 +1861,7 @@ struct df_link *\n df_chain_create (struct df_ref *src, struct df_ref *dst)\n {\n   struct df_link *head = DF_REF_CHAIN (src);\n-  struct df_link *link = pool_alloc (df_chain->block_pool);\n+  struct df_link *link = (struct df_link *) pool_alloc (df_chain->block_pool);\n   \n   DF_REF_CHAIN (src) = link;\n   link->next = head;"}, {"sha": "87dda3a7b2c90ab24b0820218b11209800e4a7fa", "filename": "gcc/df-scan.c", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -477,34 +477,28 @@ df_grow_reg_info (void)\n   if (df->regs_size < new_size)\n     {\n       new_size += new_size / 4;\n-      df->def_regs = xrealloc (df->def_regs, \n-\t\t\t       new_size *sizeof (struct df_reg_info*));\n-      df->use_regs = xrealloc (df->use_regs, \n-\t\t\t       new_size *sizeof (struct df_reg_info*));\n-      df->eq_use_regs = xrealloc (df->eq_use_regs, \n-\t\t\t\t  new_size *sizeof (struct df_reg_info*));\n-      df->def_info.begin = xrealloc (df->def_info.begin, \n-\t\t\t\t      new_size *sizeof (int));\n-      df->def_info.count = xrealloc (df->def_info.count, \n-\t\t\t\t      new_size *sizeof (int));\n-      df->use_info.begin = xrealloc (df->use_info.begin, \n-\t\t\t\t      new_size *sizeof (int));\n-      df->use_info.count = xrealloc (df->use_info.count, \n-\t\t\t\t      new_size *sizeof (int));\n+      df->def_regs = XRESIZEVEC (struct df_reg_info *, df->def_regs, new_size);\n+      df->use_regs = XRESIZEVEC (struct df_reg_info *, df->use_regs, new_size);\n+      df->eq_use_regs = XRESIZEVEC (struct df_reg_info *, df->eq_use_regs,\n+\t\t\t\t    new_size);\n+      df->def_info.begin = XRESIZEVEC (unsigned, df->def_info.begin, new_size);\n+      df->def_info.count = XRESIZEVEC (unsigned, df->def_info.count, new_size);\n+      df->use_info.begin = XRESIZEVEC (unsigned, df->use_info.begin, new_size);\n+      df->use_info.count = XRESIZEVEC (unsigned, df->use_info.count, new_size);\n       df->regs_size = new_size;\n     }\n \n   for (i = df->regs_inited; i < max_reg; i++)\n     {\n       struct df_reg_info *reg_info;\n \n-      reg_info = pool_alloc (problem_data->reg_pool);\n+      reg_info = (struct df_reg_info *) pool_alloc (problem_data->reg_pool);\n       memset (reg_info, 0, sizeof (struct df_reg_info));\n       df->def_regs[i] = reg_info;\n-      reg_info = pool_alloc (problem_data->reg_pool);\n+      reg_info = (struct df_reg_info *) pool_alloc (problem_data->reg_pool);\n       memset (reg_info, 0, sizeof (struct df_reg_info));\n       df->use_regs[i] = reg_info;\n-      reg_info = pool_alloc (problem_data->reg_pool);\n+      reg_info = (struct df_reg_info *) pool_alloc (problem_data->reg_pool);\n       memset (reg_info, 0, sizeof (struct df_reg_info));\n       df->eq_use_regs[i] = reg_info;\n       df->def_info.begin[i] = 0;\n@@ -524,8 +518,7 @@ df_grow_ref_info (struct df_ref_info *ref_info, unsigned int new_size)\n {\n   if (ref_info->refs_size < new_size)\n     {\n-      ref_info->refs = xrealloc (ref_info->refs, \n-\t\t\t\t new_size *sizeof (struct df_ref *));\n+      ref_info->refs = XRESIZEVEC (struct df_ref *, ref_info->refs, new_size);\n       memset (ref_info->refs + ref_info->refs_size, 0,\n \t      (new_size - ref_info->refs_size) *sizeof (struct df_ref *));\n       ref_info->refs_size = new_size;\n@@ -562,8 +555,7 @@ df_grow_insn_info (void)\n   if (DF_INSN_SIZE () < new_size)\n     {\n       new_size += new_size / 4;\n-      df->insns = xrealloc (df->insns, \n-\t\t\t    new_size *sizeof (struct df_insn_info *));\n+      df->insns = XRESIZEVEC (struct df_insn_info *, df->insns, new_size);\n       memset (df->insns + df->insns_size, 0,\n \t      (new_size - DF_INSN_SIZE ()) *sizeof (struct df_insn_info *));\n       DF_INSN_SIZE () = new_size;\n@@ -703,7 +695,7 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n   ref_rec = *ref_rec_ptr;\n   if (count)\n     {\n-      ref_rec = xrealloc (ref_rec, (count+2) * sizeof (struct df_ref*));\n+      ref_rec = XRESIZEVEC (struct df_ref *, ref_rec, count+2);\n       *ref_rec_ptr = ref_rec;\n       ref_rec[count] = ref;\n       ref_rec[count+1] = NULL;\n@@ -929,7 +921,7 @@ df_insn_create_insn_record (rtx insn)\n   insn_rec = DF_INSN_INFO_GET (insn);\n   if (!insn_rec)\n     {\n-      insn_rec = pool_alloc (problem_data->insn_pool);\n+      insn_rec = (struct df_insn_info *) pool_alloc (problem_data->insn_pool);\n       DF_INSN_INFO_SET (insn, insn_rec);\n     }\n   memset (insn_rec, 0, sizeof (struct df_insn_info));\n@@ -1101,10 +1093,10 @@ df_insn_rescan (rtx insn)\n   struct df_insn_info *insn_info = NULL;\n   basic_block bb = BLOCK_FOR_INSN (insn);\n   struct df_collection_rec collection_rec;\n-  collection_rec.def_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.eq_use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.mw_vec = alloca (sizeof (struct df_mw_hardreg*) * 100);\n+  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 100);\n \n   if ((!df) || (!INSN_P (insn)))\n     return false;\n@@ -2048,8 +2040,8 @@ df_notes_rescan (rtx insn)\n       unsigned int num_deleted;\n \n       memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-      collection_rec.eq_use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-      collection_rec.mw_vec = alloca (sizeof (struct df_mw_hardreg*) * 1000);\n+      collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+      collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 1000);\n \n       num_deleted = df_mw_hardreg_chain_delete_eq_uses (insn_info);\n       df_ref_chain_delete (insn_info->eq_uses);\n@@ -2199,12 +2191,12 @@ df_ref_compare (const void *r1, const void *r2)\n      at ref1.  */\n   if (DF_REF_FLAGS_IS_SET (ref1, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n     {\n-      if (DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n-\treturn DF_REF_EXTRACT_OFFSET (ref1) - DF_REF_EXTRACT_OFFSET (ref2);\n-      if (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n-\treturn DF_REF_EXTRACT_WIDTH (ref1) - DF_REF_EXTRACT_WIDTH (ref2);\n-      if (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2))\n-\treturn DF_REF_EXTRACT_MODE (ref1) - DF_REF_EXTRACT_MODE (ref2);\n+      if (DF_REF_EXTRACT_OFFSET_CONST (ref1) != DF_REF_EXTRACT_OFFSET_CONST (ref2))\n+\treturn DF_REF_EXTRACT_OFFSET_CONST (ref1) - DF_REF_EXTRACT_OFFSET_CONST (ref2);\n+      if (DF_REF_EXTRACT_WIDTH_CONST (ref1) != DF_REF_EXTRACT_WIDTH_CONST (ref2))\n+\treturn DF_REF_EXTRACT_WIDTH_CONST (ref1) - DF_REF_EXTRACT_WIDTH_CONST (ref2);\n+      if (DF_REF_EXTRACT_MODE_CONST (ref1) != DF_REF_EXTRACT_MODE_CONST (ref2))\n+\treturn DF_REF_EXTRACT_MODE_CONST (ref1) - DF_REF_EXTRACT_MODE_CONST (ref2);\n     }\n   return 0;\n }\n@@ -2604,13 +2596,13 @@ df_ref_create_structure (struct df_collection_rec *collection_rec,\n \n   if (ref_flags & (DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n     {\n-      this_ref = pool_alloc (problem_data->ref_extract_pool);\n+      this_ref = (struct df_ref *) pool_alloc (problem_data->ref_extract_pool);\n       DF_REF_EXTRACT_WIDTH (this_ref) = width;\n       DF_REF_EXTRACT_OFFSET (this_ref) = offset;\n       DF_REF_EXTRACT_MODE (this_ref) = mode;\n     }\n   else\n-    this_ref = pool_alloc (problem_data->ref_pool);\n+    this_ref = (struct df_ref *) pool_alloc (problem_data->ref_pool);\n   DF_REF_ID (this_ref) = -1;\n   DF_REF_REG (this_ref) = reg;\n   DF_REF_REGNO (this_ref) =  regno;\n@@ -2709,7 +2701,7 @@ df_ref_record (struct df_collection_rec *collection_rec,\n \t    ref_flags |= DF_REF_PARTIAL;\n \t  ref_flags |= DF_REF_MW_HARDREG;\n \n-\t  hardreg = pool_alloc (problem_data->mw_reg_pool);\n+\t  hardreg = (struct df_mw_hardreg *) pool_alloc (problem_data->mw_reg_pool);\n \t  hardreg->type = ref_type;\n \t  hardreg->flags = ref_flags;\n \t  hardreg->mw_reg = reg;\n@@ -3482,10 +3474,10 @@ df_bb_refs_record (int bb_index, bool scan_insns)\n   int luid = 0;\n   struct df_scan_bb_info *bb_info;\n   struct df_collection_rec collection_rec;\n-  collection_rec.def_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.eq_use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.mw_vec = alloca (sizeof (struct df_mw_hardreg*) * 100);\n+  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 100);\n \n   if (!df)\n     return;\n@@ -3772,7 +3764,7 @@ df_record_entry_block_defs (bitmap entry_block_defs)\n {\n   struct df_collection_rec collection_rec;\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.def_vec = alloca (sizeof (struct df_ref*) * FIRST_PSEUDO_REGISTER);\n+  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, FIRST_PSEUDO_REGISTER);\n \n   df_entry_block_defs_collect (&collection_rec, entry_block_defs);\n \n@@ -3943,7 +3935,7 @@ df_record_exit_block_uses (bitmap exit_block_uses)\n {\n   struct df_collection_rec collection_rec;\n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.use_vec = alloca (sizeof (struct df_ref*) * FIRST_PSEUDO_REGISTER);\n+  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, FIRST_PSEUDO_REGISTER);\n \n   df_exit_block_uses_collect (&collection_rec, exit_block_uses);\n \n@@ -4317,10 +4309,10 @@ df_bb_verify (basic_block bb)\n   struct df_collection_rec collection_rec;\n   \n   memset (&collection_rec, 0, sizeof (struct df_collection_rec));\n-  collection_rec.def_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.eq_use_vec = alloca (sizeof (struct df_ref*) * 1000);\n-  collection_rec.mw_vec = alloca (sizeof (struct df_mw_hardreg*) * 100);\n+  collection_rec.def_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.eq_use_vec = XALLOCAVEC (struct df_ref *, 1000);\n+  collection_rec.mw_vec = XALLOCAVEC (struct df_mw_hardreg *, 100);\n \n   gcc_assert (bb_info);\n "}, {"sha": "93c0bbb080a9d619fd14bd9a78361d38d5deef39", "filename": "gcc/df.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -637,8 +637,11 @@ struct df\n /* The following two macros may only be applied if one of \n    DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT is true. */ \n #define DF_REF_EXTRACT_WIDTH(REF) (((struct df_ref_extract *)(REF))->width)\n+#define DF_REF_EXTRACT_WIDTH_CONST(REF) (((const struct df_ref_extract *)(REF))->width)\n #define DF_REF_EXTRACT_OFFSET(REF) (((struct df_ref_extract *)(REF))->offset)\n+#define DF_REF_EXTRACT_OFFSET_CONST(REF) (((const struct df_ref_extract *)(REF))->offset)\n #define DF_REF_EXTRACT_MODE(REF) (((struct df_ref_extract *)(REF))->mode)\n+#define DF_REF_EXTRACT_MODE_CONST(REF) (((const struct df_ref_extract *)(REF))->mode)\n /* Macros to determine the reference type.  */\n \n #define DF_REF_REG_DEF_P(REF) (DF_REF_TYPE (REF) == DF_REF_REG_DEF)"}, {"sha": "b4dff4c6c16c30cfd5f0d77bb370031589fce4b0", "filename": "gcc/dominance.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -706,7 +706,7 @@ get_immediate_dominator (enum cdi_direction dir, basic_block bb)\n   if (!node->father)\n     return NULL;\n \n-  return node->father->data;\n+  return (basic_block) node->father->data;\n }\n \n /* Set the immediate dominator of the block possibly removing\n@@ -749,9 +749,9 @@ get_dominated_by (enum cdi_direction dir, basic_block bb)\n   if (!son)\n     return NULL;\n \n-  VEC_safe_push (basic_block, heap, bbs, son->data);\n+  VEC_safe_push (basic_block, heap, bbs, (basic_block) son->data);\n   for (ason = son->right, n = 1; ason != son; ason = ason->right)\n-    VEC_safe_push (basic_block, heap, bbs, ason->data);\n+    VEC_safe_push (basic_block, heap, bbs, (basic_block) ason->data);\n \n   return bbs;\n }\n@@ -823,7 +823,7 @@ nearest_common_dominator (enum cdi_direction dir, basic_block bb1, basic_block b\n   if (!bb2)\n     return bb1;\n \n-  return et_nca (bb1->dom[dir_index], bb2->dom[dir_index])->data;\n+  return (basic_block) et_nca (bb1->dom[dir_index], bb2->dom[dir_index])->data;\n }\n \n \n@@ -1103,7 +1103,7 @@ prune_bbs_to_update_dominators (VEC (basic_block, heap) *bbs,\n static basic_block\n root_of_dom_tree (enum cdi_direction dir, basic_block bb)\n {\n-  return et_root (bb->dom[dom_convert_dir_to_idx (dir)])->data;\n+  return (basic_block) et_root (bb->dom[dom_convert_dir_to_idx (dir)])->data;\n }\n \n /* See the comment in iterate_fix_dominators.  Finds the immediate dominators\n@@ -1313,10 +1313,10 @@ iterate_fix_dominators (enum cdi_direction dir, VEC (basic_block, heap) *bbs,\n \t  dom_i = (size_t) *pointer_map_contains (map, dom);\n \n \t  /* Do not include parallel edges to G.  */\n-\t  if (bitmap_bit_p (g->vertices[dom_i].data, i))\n+\t  if (bitmap_bit_p ((bitmap) g->vertices[dom_i].data, i))\n \t    continue;\n \n-\t  bitmap_set_bit (g->vertices[dom_i].data, i);\n+\t  bitmap_set_bit ((bitmap) g->vertices[dom_i].data, i);\n \t  add_edge (g, dom_i, i);\n \t}\n     }\n@@ -1394,7 +1394,7 @@ first_dom_son (enum cdi_direction dir, basic_block bb)\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *son = bb->dom[dir_index]->son;\n \n-  return son ? son->data : NULL;\n+  return (basic_block) (son ? son->data : NULL);\n }\n \n /* Returns the next dominance son after BB in the dominator or postdominator\n@@ -1406,7 +1406,7 @@ next_dom_son (enum cdi_direction dir, basic_block bb)\n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *next = bb->dom[dir_index]->right;\n \n-  return next->father->son == next ? NULL : next->data;\n+  return (basic_block) (next->father->son == next ? NULL : next->data);\n }\n \n /* Return dominance availability for dominance info DIR.  */"}, {"sha": "b65a72b90d0a5ab6cca8c9cd47179430a816a7e8", "filename": "gcc/dse.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -592,7 +592,7 @@ clear_alias_set_lookup (alias_set_type alias_set)\n   slot = htab_find_slot (clear_alias_mode_table, &tmp_holder, NO_INSERT);\n   gcc_assert (*slot);\n   \n-  return *slot;\n+  return (struct clear_alias_mode_holder *) *slot;\n }\n \n \n@@ -638,7 +638,8 @@ get_group_info (rtx base)\n     {\n       if (!clear_alias_group)\n \t{\n-\t  clear_alias_group = gi = pool_alloc (rtx_group_info_pool);\n+\t  clear_alias_group = gi =\n+\t    (group_info_t) pool_alloc (rtx_group_info_pool);\n \t  memset (gi, 0, sizeof (struct group_info));\n \t  gi->id = rtx_group_next_id++;\n \t  gi->store1_n = BITMAP_ALLOC (NULL);\n@@ -658,7 +659,7 @@ get_group_info (rtx base)\n \n   if (gi == NULL)\n     {\n-      *slot = gi = pool_alloc (rtx_group_info_pool);\n+      *slot = gi = (group_info_t) pool_alloc (rtx_group_info_pool);\n       gi->rtx_base = base;\n       gi->id = rtx_group_next_id++;\n       gi->base_mem = gen_rtx_MEM (QImode, base);\n@@ -1246,7 +1247,7 @@ record_store (rtx body, bb_info_t bb_info)\n       if (clear_alias_group->offset_map_size_p < spill_alias_set)\n \tclear_alias_group->offset_map_size_p = spill_alias_set;\n   \n-      store_info = pool_alloc (rtx_store_info_pool);\n+      store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n \n       if (dump_file)\n \tfprintf (dump_file, \" processing spill store %d(%s)\\n\",\n@@ -1260,7 +1261,7 @@ record_store (rtx body, bb_info_t bb_info)\n       group_info_t group \n \t= VEC_index (group_info_t, rtx_group_vec, group_id);\n       \n-      store_info = pool_alloc (rtx_store_info_pool);\n+      store_info = (store_info_t) pool_alloc (rtx_store_info_pool);\n       set_usage_bits (group, offset, width);\n \n       if (dump_file)\n@@ -1277,7 +1278,7 @@ record_store (rtx body, bb_info_t bb_info)\n \tinsn_info->stack_pointer_based = true;\n       insn_info->contains_cselib_groups = true;\n \n-      store_info = pool_alloc (cse_store_info_pool);\n+      store_info = (store_info_t) pool_alloc (cse_store_info_pool);\n       group_id = -1;\n \n       if (dump_file)\n@@ -1603,7 +1604,8 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \n   if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n-      deferred_change_t deferred_change = pool_alloc (deferred_change_pool);\n+      deferred_change_t deferred_change =\n+\t(deferred_change_t) pool_alloc (deferred_change_pool);\n       \n       /* Insert this right before the store insn where it will be safe\n \t from later insns that might change it before the read.  */\n@@ -1713,7 +1715,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n   else\n     width = GET_MODE_SIZE (GET_MODE (mem));\n \n-  read_info = pool_alloc (read_info_pool);\n+  read_info = (read_info_t) pool_alloc (read_info_pool);\n   read_info->group_id = group_id;\n   read_info->mem = mem;\n   read_info->alias_set = spill_alias_set;\n@@ -1933,7 +1935,7 @@ static void\n scan_insn (bb_info_t bb_info, rtx insn)\n {\n   rtx body;\n-  insn_info_t insn_info = pool_alloc (insn_info_pool);\n+  insn_info_t insn_info = (insn_info_t) pool_alloc (insn_info_pool);\n   int mems_found = 0;\n   memset (insn_info, 0, sizeof (struct insn_info));\n \n@@ -2124,7 +2126,7 @@ dse_step1 (void)\n   FOR_ALL_BB (bb)\n     {\n       insn_info_t ptr;\n-      bb_info_t bb_info = pool_alloc (bb_info_pool);\n+      bb_info_t bb_info = (bb_info_t) pool_alloc (bb_info_pool);\n \n       memset (bb_info, 0, sizeof (struct bb_info));\n       bitmap_set_bit (all_blocks, bb->index);\n@@ -2425,7 +2427,8 @@ dse_record_singleton_alias_set (alias_set_type alias_set,\n   slot = htab_find_slot (clear_alias_mode_table, &tmp_holder, INSERT);\n   gcc_assert (*slot == NULL);\n \n-  *slot = entry = pool_alloc (clear_alias_mode_pool);\n+  *slot = entry =\n+    (struct clear_alias_mode_holder *) pool_alloc (clear_alias_mode_pool);\n   entry->alias_set = alias_set;\n   entry->mode = mode;\n }"}, {"sha": "ea19b793df5f76a38f5d2013c1da78c8f03df205", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f883e0a7dc171a20708b7d60fccdca05bb71de32/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=f883e0a7dc171a20708b7d60fccdca05bb71de32", "patch": "@@ -757,7 +757,7 @@ dw2_force_const_mem (rtx x, bool public)\n \n       if (public && USE_LINKONCE_INDIRECT)\n \t{\n-\t  char *ref_name = alloca (strlen (str) + sizeof \"DW.ref.\");\n+\t  char *ref_name = XALLOCAVEC (char, strlen (str) + sizeof \"DW.ref.\");\n \n \t  sprintf (ref_name, \"DW.ref.%s\", str);\n \t  id = get_identifier (ref_name);"}]}