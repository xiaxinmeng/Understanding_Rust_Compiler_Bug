{"sha": "540a22d243966d1b882db26b17fe674467e2a169", "node_id": "C_kwDOANBUbNoAKDU0MGEyMmQyNDM5NjZkMWI4ODJkYjI2YjE3ZmU2NzQ0NjdlMmExNjk", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2023-01-04T18:34:21Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2023-02-04T13:03:54Z"}, "message": "libstdc++: Optimize basic_string move assignment\n\nSince resolution of Issue 2593 [1] we can consider that equal allocators\nbefore the propagate-on-move-assignment operations will still be equal\nafterward.\n\nSo we can extend the optimization of transfering the storage of the move-to\ninstance to the move-from one that is currently limited to always equal\nallocators.\n\n[1] https://cplusplus.github.io/LWG/issue2593\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/basic_string.h (operator=(basic_string&&)): Transfer move-to\n\tstorage to the move-from instance when allocators are equal.\n\t* testsuite/21_strings/basic_string/allocator/char/move_assign.cc (test04):\n\tNew test case.", "tree": {"sha": "3d5616980078acbf6d95ed2f778b91d566d6bb87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d5616980078acbf6d95ed2f778b91d566d6bb87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/540a22d243966d1b882db26b17fe674467e2a169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540a22d243966d1b882db26b17fe674467e2a169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/540a22d243966d1b882db26b17fe674467e2a169", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540a22d243966d1b882db26b17fe674467e2a169/comments", "author": null, "committer": null, "parents": [{"sha": "49e52115b09b477382fef6f04fd7b4d1641f902c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49e52115b09b477382fef6f04fd7b4d1641f902c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49e52115b09b477382fef6f04fd7b4d1641f902c"}], "stats": {"total": 63, "additions": 57, "deletions": 6}, "files": [{"sha": "c81dc0d425a0ae648c46f520b603971978413281", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540a22d243966d1b882db26b17fe674467e2a169/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540a22d243966d1b882db26b17fe674467e2a169/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=540a22d243966d1b882db26b17fe674467e2a169", "patch": "@@ -844,9 +844,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       operator=(basic_string&& __str)\n       noexcept(_Alloc_traits::_S_nothrow_move())\n       {\n+\tconst bool __equal_allocs = _Alloc_traits::_S_always_equal()\n+\t  || _M_get_allocator() == __str._M_get_allocator();\n \tif (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()\n-\t    && !_Alloc_traits::_S_always_equal()\n-\t    && _M_get_allocator() != __str._M_get_allocator())\n+\t    && !__equal_allocs)\n \t  {\n \t    // Destroy existing storage before replacing allocator.\n \t    _M_destroy(_M_allocated_capacity);\n@@ -868,16 +869,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t\t_M_set_length(__str.size());\n \t      }\n \t  }\n-\telse if (_Alloc_traits::_S_propagate_on_move_assign()\n-\t    || _Alloc_traits::_S_always_equal()\n-\t    || _M_get_allocator() == __str._M_get_allocator())\n+\telse if (_Alloc_traits::_S_propagate_on_move_assign() || __equal_allocs)\n \t  {\n \t    // Just move the allocated pointer, our allocator can free it.\n \t    pointer __data = nullptr;\n \t    size_type __capacity;\n \t    if (!_M_is_local())\n \t      {\n-\t\tif (_Alloc_traits::_S_always_equal())\n+\t\tif (__equal_allocs)\n \t\t  {\n \t\t    // __str can reuse our existing storage.\n \t\t    __data = _M_data();"}, {"sha": "21e0b1cb4f44f21fa1ad7625feae8aedb055a1bf", "filename": "libstdc++-v3/testsuite/21_strings/basic_string/allocator/char/move_assign.cc", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540a22d243966d1b882db26b17fe674467e2a169/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fchar%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540a22d243966d1b882db26b17fe674467e2a169/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fchar%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fbasic_string%2Fallocator%2Fchar%2Fmove_assign.cc?ref=540a22d243966d1b882db26b17fe674467e2a169", "patch": "@@ -28,6 +28,8 @@ const C c = 'a';\n using traits = std::char_traits<C>;\n \n using __gnu_test::propagating_allocator;\n+using __gnu_test::tracker_allocator_counter;\n+using __gnu_test::tracker_allocator;\n \n void test01()\n {\n@@ -146,10 +148,60 @@ void test03()\n   VERIFY(7 == v8.get_allocator().get_personality());\n }\n \n+void test04()\n+{\n+  typedef propagating_allocator<C, true, tracker_allocator<C>> alloc_type;\n+  typedef std::basic_string<C, traits, alloc_type> test_type;\n+\n+  {\n+    tracker_allocator_counter::reset();\n+    test_type v1(alloc_type(1));\n+    v1 = \"abcdefghijklmnopqr10\";\n+    auto ref_alloc_count = tracker_allocator_counter::get_allocation_count();\n+\n+    test_type v2(alloc_type(2));\n+    v2 = \"abcdefghijklmnopqr20\";\n+    v2 = std::move(v1);\n+    VERIFY(1 == v1.get_allocator().get_personality());\n+    VERIFY(1 == v2.get_allocator().get_personality());\n+\n+    VERIFY( tracker_allocator_counter::get_allocation_count() == 2 * ref_alloc_count );\n+    VERIFY( tracker_allocator_counter::get_deallocation_count() == ref_alloc_count );\n+\n+    v1 = \"abcdefghijklmnopqr11\";\n+\n+    VERIFY( tracker_allocator_counter::get_allocation_count() == 3 * ref_alloc_count );\n+  }\n+\n+  {\n+    tracker_allocator_counter::reset();\n+    test_type v1(alloc_type(1));\n+    v1 = \"abcdefghijklmnopqr10\";\n+    auto ref_alloc_count = tracker_allocator_counter::get_allocation_count();\n+\n+    test_type v2(alloc_type(1));\n+    v2 = \"abcdefghijklmnopqr20\";\n+    v2 = std::move(v1);\n+    VERIFY(1 == v1.get_allocator().get_personality());\n+    VERIFY(1 == v2.get_allocator().get_personality());\n+\n+    VERIFY( tracker_allocator_counter::get_allocation_count() == 2 * ref_alloc_count );\n+    VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+\n+    v1 = \"abcdefghijklmnopqr11\";\n+\n+    VERIFY( tracker_allocator_counter::get_allocation_count() == 2 * ref_alloc_count );\n+  }\n+\n+  VERIFY( tracker_allocator_counter::get_allocation_count() ==\n+\t  tracker_allocator_counter::get_deallocation_count() );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n   return 0;\n }"}]}