{"sha": "02ef74bad652522a2e424f3ffafff2452c4da105", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlZjc0YmFkNjUyNTIyYTJlNDI0ZjNmZmFmZmYyNDUyYzRkYTEwNQ==", "commit": {"author": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2020-01-09T19:37:18Z"}, "committer": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2020-07-10T15:18:26Z"}, "message": "RS6000, add VSX mask manipulation support\n\ngcc/ChangeLog\n\n2020-07-09  Carl Love  <cel@us.ibm.com>\n\n\t* config/rs6000/vsx.md  (VSX_MM): New define_mode_iterator.\n\t(VSX_MM4): New define_mode_iterator.\n\t(vec_mtvsrbmi): New define_insn.\n\t(vec_mtvsr_<mode>): New define_insn.\n\t(vec_cntmb_<mode>): New define_insn.\n\t(vec_extract_<mode>): New define_insn.\n\t(vec_expand_<mode>): New define_insn.\n\t(define_c_enum unspec): Add entries UNSPEC_MTVSBM, UNSPEC_VCNTMB,\n\tUNSPEC_VEXTRACT, UNSPEC_VEXPAND.\n\t* config/rs6000/altivec.h ( vec_genbm, vec_genhm, vec_genwm,\n\tvec_gendm, vec_genqm, vec_cntm, vec_expandm, vec_extractm): Add\n\tdefines.\n\t* config/rs6000/rs6000-builtin.def: Add defines BU_P10_2, BU_P10_1.\n\t(BU_P10_1): Add definitions for mtvsrbm, mtvsrhm, mtvsrwm,\n\tmtvsrdm, mtvsrqm, vexpandmb, vexpandmh, vexpandmw, vexpandmd,\n\tvexpandmq, vextractmb, vextractmh, vextractmw, vextractmd, vextractmq.\n\t(BU_P10_2): Add definitions for cntmbb, cntmbh, cntmbw, cntmbd.\n\t(BU_P10_OVERLOAD_1): Add definitions for mtvsrbm, mtvsrhm,\n\tmtvsrwm, mtvsrdm, mtvsrqm, vexpandm, vextractm.\n\t(BU_P10_OVERLOAD_2): Add defition for cntm.\n\t* config/rs6000/rs6000-call.c (rs6000_expand_binop_builtin): Add\n\tchecks for CODE_FOR_vec_cntmbb_v16qi, CODE_FOR_vec_cntmb_v8hi,\n\tCODE_FOR_vec_cntmb_v4si, CODE_FOR_vec_cntmb_v2di.\n\t(altivec_overloaded_builtins): Add overloaded argument entries for\n\tP10_BUILTIN_VEC_MTVSRBM, P10_BUILTIN_VEC_MTVSRHM,\n\tP10_BUILTIN_VEC_MTVSRWM, P10_BUILTIN_VEC_MTVSRDM,\n\tP10_BUILTIN_VEC_MTVSRQM, P10_BUILTIN_VEC_VCNTMBB,\n\tP10_BUILTIN_VCNTMBB, P10_BUILTIN_VCNTMBH,\n\tP10_BUILTIN_VCNTMBW, P10_BUILTIN_VCNTMBD,\n\tP10_BUILTIN_VEXPANDMB, P10_BUILTIN_VEXPANDMH,\n\tP10_BUILTIN_VEXPANDMW, P10_BUILTIN_VEXPANDMD,\n\tP10_BUILTIN_VEXPANDMQ, P10_BUILTIN_VEXTRACTMB,\n\tP10_BUILTIN_VEXTRACTMH, P10_BUILTIN_VEXTRACTMW,\n\tP10_BUILTIN_VEXTRACTMD, P10_BUILTIN_VEXTRACTMQ.\n\t(builtin_function_type): Add case entries for P10_BUILTIN_MTVSRBM,\n\tP10_BUILTIN_MTVSRHM, P10_BUILTIN_MTVSRWM, P10_BUILTIN_MTVSRDM,\n\tP10_BUILTIN_MTVSRQM, P10_BUILTIN_VCNTMBB, P10_BUILTIN_VCNTMBH,\n\tP10_BUILTIN_VCNTMBW, P10_BUILTIN_VCNTMBD,\n\tP10_BUILTIN_VEXPANDMB, P10_BUILTIN_VEXPANDMH,\n\tP10_BUILTIN_VEXPANDMW, P10_BUILTIN_VEXPANDMD,\n\tP10_BUILTIN_VEXPANDMQ.\n\t* config/rs6000/rs6000-builtin.def (altivec_overloaded_builtins): Add\n\tentries\tfor MTVSRBM, MTVSRHM, MTVSRWM, MTVSRDM, MTVSRQM, VCNTM,\n\tVEXPANDM, VEXTRACTM.\n\ngcc/testsuite/ChangeLog\n\n2020-07-09  Carl Love  <cel@us.ibm.com>\n\t* gcc.target/powerpc/vsx_mask-count-runnable.c: New test case.\n\t* gcc.target/powerpc/vsx_mask-expand-runnable.c: New test case.\n\t* gcc.target/powerpc/vsx_mask-extract-runnable.c: New test case.\n\t* gcc.target/powerpc/vsx_mask-move-runnable.c: New test case.", "tree": {"sha": "a7184ef4ad23f840fa4b5cfe077a78f6b8641ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7184ef4ad23f840fa4b5cfe077a78f6b8641ee8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02ef74bad652522a2e424f3ffafff2452c4da105", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ef74bad652522a2e424f3ffafff2452c4da105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ef74bad652522a2e424f3ffafff2452c4da105", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ef74bad652522a2e424f3ffafff2452c4da105/comments", "author": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "committer": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5b4b64d25a36f085ab90efc3d54c025a7fff49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f5b4b64d25a36f085ab90efc3d54c025a7fff49"}], "stats": {"total": 900, "additions": 899, "deletions": 1}, "files": [{"sha": "6c4312492f1981bbdb06e11dbd8f0d98fed4a83a", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -711,6 +711,16 @@ __altivec_scalar_pred(vec_any_nle,\n \n #define vec_strir_p(a)\t__builtin_vec_strir_p (a)\n #define vec_stril_p(a)\t__builtin_vec_stril_p (a)\n+\n+/* VSX Mask Manipulation builtin. */\n+#define vec_genbm __builtin_vec_mtvsrbm\n+#define vec_genhm __builtin_vec_mtvsrhm\n+#define vec_genwm __builtin_vec_mtvsrwm\n+#define vec_gendm __builtin_vec_mtvsrdm\n+#define vec_genqm __builtin_vec_mtvsrqm\n+#define vec_cntm __builtin_vec_cntm\n+#define vec_expandm __builtin_vec_vexpandm\n+#define vec_extractm __builtin_vec_vextractm\n #endif\n \n #endif /* _ALTIVEC_H */"}, {"sha": "f7037552faf0e97d4eb69b873cbbfb204b6d2b67", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -1128,6 +1128,22 @@\n \t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n \t\t     | RS6000_BTC_TERNARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P10_1(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_1 (P10_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vec\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P10,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P10_2(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_2 (P10_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vec\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P10,\t\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n #endif\n \n \f\n@@ -2720,6 +2736,26 @@ BU_P10V_1 (VSTRIHR_P, \"vstrihr_p\", CONST, vstrir_p_v8hi)\n BU_P10V_1 (VSTRIBL_P, \"vstribl_p\", CONST, vstril_p_v16qi)\n BU_P10V_1 (VSTRIHL_P, \"vstrihl_p\", CONST, vstril_p_v8hi)\n \n+BU_P10V_1 (MTVSRBM, \"mtvsrbm\", CONST, vec_mtvsr_v16qi)\n+BU_P10V_1 (MTVSRHM, \"mtvsrhm\", CONST, vec_mtvsr_v8hi)\n+BU_P10V_1 (MTVSRWM, \"mtvsrwm\", CONST, vec_mtvsr_v4si)\n+BU_P10V_1 (MTVSRDM, \"mtvsrdm\", CONST, vec_mtvsr_v2di)\n+BU_P10V_1 (MTVSRQM, \"mtvsrqm\", CONST, vec_mtvsr_v1ti)\n+BU_P10V_2 (VCNTMBB, \"cntmbb\", CONST, vec_cntmb_v16qi)\n+BU_P10V_2 (VCNTMBH, \"cntmbh\", CONST, vec_cntmb_v8hi)\n+BU_P10V_2 (VCNTMBW, \"cntmbw\", CONST, vec_cntmb_v4si)\n+BU_P10V_2 (VCNTMBD, \"cntmbd\", CONST, vec_cntmb_v2di)\n+BU_P10V_1 (VEXPANDMB, \"vexpandmb\", CONST, vec_expand_v16qi)\n+BU_P10V_1 (VEXPANDMH, \"vexpandmh\", CONST, vec_expand_v8hi)\n+BU_P10V_1 (VEXPANDMW, \"vexpandmw\", CONST, vec_expand_v4si)\n+BU_P10V_1 (VEXPANDMD, \"vexpandmd\", CONST, vec_expand_v2di)\n+BU_P10V_1 (VEXPANDMQ, \"vexpandmq\", CONST, vec_expand_v1ti)\n+BU_P10V_1 (VEXTRACTMB, \"vextractmb\", CONST, vec_extract_v16qi)\n+BU_P10V_1 (VEXTRACTMH, \"vextractmh\", CONST, vec_extract_v8hi)\n+BU_P10V_1 (VEXTRACTMW, \"vextractmw\", CONST, vec_extract_v4si)\n+BU_P10V_1 (VEXTRACTMD, \"vextractmd\", CONST, vec_extract_v2di)\n+BU_P10V_1 (VEXTRACTMQ, \"vextractmq\", CONST, vec_extract_v1ti)\n+\n /* Overloaded vector builtins for ISA 3.1 (power10).  */\n BU_P10_OVERLOAD_2 (CLRL, \"clrl\")\n BU_P10_OVERLOAD_2 (CLRR, \"clrr\")\n@@ -2736,6 +2772,15 @@ BU_P10_OVERLOAD_1 (VSTRIL, \"stril\")\n BU_P10_OVERLOAD_1 (VSTRIR_P, \"strir_p\")\n BU_P10_OVERLOAD_1 (VSTRIL_P, \"stril_p\")\n \f\n+BU_P10_OVERLOAD_1 (MTVSRBM, \"mtvsrbm\")\n+BU_P10_OVERLOAD_1 (MTVSRHM, \"mtvsrhm\")\n+BU_P10_OVERLOAD_1 (MTVSRWM, \"mtvsrwm\")\n+BU_P10_OVERLOAD_1 (MTVSRDM, \"mtvsrdm\")\n+BU_P10_OVERLOAD_1 (MTVSRQM, \"mtvsrqm\")\n+BU_P10_OVERLOAD_2 (VCNTM, \"cntm\")\n+BU_P10_OVERLOAD_1 (VEXPANDM, \"vexpandm\")\n+BU_P10_OVERLOAD_1 (VEXTRACTM, \"vextractm\")\n+\n /* 1 argument crypto functions.  */\n BU_CRYPTO_1 (VSBOX,\t\t\"vsbox\",\t  CONST, crypto_vsbox_v2di)\n BU_CRYPTO_1 (VSBOX_BE,\t\t\"vsbox_be\",\t  CONST, crypto_vsbox_v16qi)"}, {"sha": "5ec3f2c55add4e2facfff0bdc9a254a68a127130", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -5635,6 +5635,52 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n   { P10_BUILTIN_VEC_VSTRIR_P, P10_BUILTIN_VSTRIHR_P,\n     RS6000_BTI_INTSI, RS6000_BTI_V8HI, 0, 0 },\n \n+  { P10_BUILTIN_VEC_MTVSRBM, P10_BUILTIN_MTVSRBM,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI, 0, 0 },\n+  { P10_BUILTIN_VEC_MTVSRHM, P10_BUILTIN_MTVSRHM,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_UINTDI, 0, 0 },\n+  { P10_BUILTIN_VEC_MTVSRWM, P10_BUILTIN_MTVSRWM,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_UINTDI, 0, 0 },\n+  { P10_BUILTIN_VEC_MTVSRDM, P10_BUILTIN_MTVSRDM,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_UINTDI, 0, 0 },\n+  { P10_BUILTIN_VEC_MTVSRQM, P10_BUILTIN_MTVSRQM,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_UINTDI, 0, 0 },\n+\n+  { P10_BUILTIN_VEC_VCNTM, P10_BUILTIN_VCNTMBB,\n+    RS6000_BTI_unsigned_long_long,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTQI, 0 },\n+  { P10_BUILTIN_VEC_VCNTM, P10_BUILTIN_VCNTMBH,\n+    RS6000_BTI_unsigned_long_long,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_UINTQI, 0 },\n+  { P10_BUILTIN_VEC_VCNTM, P10_BUILTIN_VCNTMBW,\n+    RS6000_BTI_unsigned_long_long,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_UINTQI, 0 },\n+  { P10_BUILTIN_VEC_VCNTM, P10_BUILTIN_VCNTMBD,\n+    RS6000_BTI_unsigned_long_long,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_UINTQI, 0 },\n+\n+  { P10_BUILTIN_VEC_VEXPANDM, P10_BUILTIN_VEXPANDMB,\n+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXPANDM, P10_BUILTIN_VEXPANDMH,\n+    RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V8HI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXPANDM, P10_BUILTIN_VEXPANDMW,\n+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXPANDM, P10_BUILTIN_VEXPANDMD,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXPANDM, P10_BUILTIN_VEXPANDMQ,\n+    RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI, 0, 0 },\n+\n+  { P10_BUILTIN_VEC_VEXTRACTM, P10_BUILTIN_VEXTRACTMB,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V16QI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXTRACTM, P10_BUILTIN_VEXTRACTMH,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V8HI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXTRACTM, P10_BUILTIN_VEXTRACTMW,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V4SI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXTRACTM, P10_BUILTIN_VEXTRACTMD,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, 0, 0 },\n+  { P10_BUILTIN_VEC_VEXTRACTM, P10_BUILTIN_VEXTRACTMQ,\n+    RS6000_BTI_INTSI, RS6000_BTI_unsigned_V1TI, 0, 0 },\n+\n   { RS6000_BUILTIN_NONE, RS6000_BUILTIN_NONE, 0, 0, 0, 0 }\n };\n \f\n@@ -9040,7 +9086,11 @@ rs6000_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n \t   || icode == CODE_FOR_unpackkf\n \t   || icode == CODE_FOR_unpacktf\n \t   || icode == CODE_FOR_unpackif\n-\t   || icode == CODE_FOR_unpacktd)\n+\t   || icode == CODE_FOR_unpacktd\n+\t   || icode == CODE_FOR_vec_cntmb_v16qi\n+\t   || icode == CODE_FOR_vec_cntmb_v8hi\n+\t   || icode == CODE_FOR_vec_cntmb_v4si\n+\t   || icode == CODE_FOR_vec_cntmb_v2di)\n     {\n       /* Only allow 1-bit unsigned literals. */\n       STRIP_NOPS (arg1);\n@@ -13672,6 +13722,20 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,\n     case MISC_BUILTIN_CBCDTD:\n     case VSX_BUILTIN_XVCVSPBF16:\n     case VSX_BUILTIN_XVCVBF16SP:\n+    case P10_BUILTIN_MTVSRBM:\n+    case P10_BUILTIN_MTVSRHM:\n+    case P10_BUILTIN_MTVSRWM:\n+    case P10_BUILTIN_MTVSRDM:\n+    case P10_BUILTIN_MTVSRQM:\n+    case P10_BUILTIN_VCNTMBB:\n+    case P10_BUILTIN_VCNTMBH:\n+    case P10_BUILTIN_VCNTMBW:\n+    case P10_BUILTIN_VCNTMBD:\n+    case P10_BUILTIN_VEXPANDMB:\n+    case P10_BUILTIN_VEXPANDMH:\n+    case P10_BUILTIN_VEXPANDMW:\n+    case P10_BUILTIN_VEXPANDMD:\n+    case P10_BUILTIN_VEXPANDMQ:\n       h.uns_p[0] = 1;\n       h.uns_p[1] = 1;\n       break;"}, {"sha": "f75377135ba3808ee1430fe8c9c54da167ab4bd4", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -263,6 +263,10 @@\n ;; Mode attribute to give the suffix for the splat instruction\n (define_mode_attr VSX_SPLAT_SUFFIX [(V16QI \"b\") (V8HI \"h\")])\n \n+;; Iterator for the move to mask instructions\n+(define_mode_iterator VSX_MM [V16QI V8HI V4SI V2DI V1TI])\n+(define_mode_iterator VSX_MM4 [V16QI V8HI V4SI V2DI])\n+\n ;; Constants for creating unspecs\n (define_c_enum \"unspec\"\n   [UNSPEC_VSX_CONCAT\n@@ -347,6 +351,10 @@\n    UNSPEC_VSX_FIRST_MISMATCH_INDEX\n    UNSPEC_VSX_FIRST_MISMATCH_EOS_INDEX\n    UNSPEC_XXGENPCV\n+   UNSPEC_MTVSBM\n+   UNSPEC_VCNTMB\n+   UNSPEC_VEXPAND\n+   UNSPEC_VEXTRACT\n   ])\n \n (define_int_iterator XVCVBF16\t[UNSPEC_VSX_XVCVSPBF16\n@@ -5729,3 +5737,44 @@\n   \"TARGET_POWER10\"\n   \"<xvcvbf16> %x0,%x1\"\n   [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"vec_mtvsrbmi\"\n+  [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"=v\")\n+        (unspec:V16QI [(match_operand:QI 1 \"u6bit_cint_operand\" \"n\")]\n+        UNSPEC_MTVSBM))]\n+  \"TARGET_POWER10\"\n+  \"mtvsrbmi %0,%1\"\n+)\n+\n+(define_insn \"vec_mtvsr_<mode>\"\n+  [(set (match_operand:VSX_MM 0 \"altivec_register_operand\" \"=v\")\n+        (unspec:VSX_MM [(match_operand:DI 1 \"gpc_reg_operand\" \"r\")]\n+        UNSPEC_MTVSBM))]\n+  \"TARGET_POWER10\"\n+  \"mtvsr<wd>m %0,%1\";\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"vec_cntmb_<mode>\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+        (unspec:DI [(match_operand:VSX_MM4 1 \"altivec_register_operand\" \"v\")\n+                    (match_operand:QI 2 \"const_0_to_1_operand\" \"n\")]\n+        UNSPEC_VCNTMB))]\n+  \"TARGET_POWER10\"\n+  \"vcntmb<VSX_MM_SUFFIX> %0,%1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"vec_extract_<mode>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:VSX_MM 1 \"altivec_register_operand\" \"v\")]\n+\tUNSPEC_VEXTRACT))]\n+  \"TARGET_POWER10\"\n+  \"vextract<VSX_MM_SUFFIX>m %0,%1\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"vec_expand_<mode>\"\n+  [(set (match_operand:VSX_MM 0 \"vsx_register_operand\" \"=v\")\n+        (unspec:VSX_MM [(match_operand:VSX_MM 1 \"vsx_register_operand\" \"v\")]\n+        UNSPEC_VEXPAND))]\n+  \"TARGET_POWER10\"\n+  \"vexpand<VSX_MM_SUFFIX>m %0,%1\"\n+  [(set_attr \"type\" \"vecsimple\")])"}, {"sha": "f1e3860ee43c8645da56af0fc6e72a03cc88d345", "filename": "gcc/testsuite/gcc.target/powerpc/vsx_mask-count-runnable.c", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-count-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-count-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-count-runnable.c?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -0,0 +1,149 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mcpu=power10 -O2\" } */\n+/* { dg-require-effective-target power10_hw } */\n+\n+/* Check that the expected 128-bit instructions are generated if the processor\n+   supports the 128-bit integer instructions. */\n+/* { dg-final { scan-assembler-times {\\mvcntmbb\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvcntmbh\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvcntmbw\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvcntmbd\\M} 1 } } */\n+\n+#define DEBUG 0\n+\n+#if DEBUG\n+#include <stdio.h>\n+#include <stdlib.h>\n+#endif\n+#include <altivec.h>\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i, num_elements;\n+  unsigned long long arg1;\n+  \n+  vector unsigned char  vbc_result_bi, vbc_expected_result_bi;\n+  vector unsigned short vbc_result_hi, vbc_expected_result_hi;\n+  vector unsigned int  vbc_result_wi, vbc_expected_result_wi;\n+  vector unsigned long long vbc_result_di, vbc_expected_result_di;\n+  vector __uint128_t vbc_result_qi, vbc_expected_result_qi;\n+\n+  unsigned int result_wi, expected_result_wi;\n+  unsigned long long result, expected_result;\n+  const unsigned char mp=1;\n+  vector unsigned char vbc_bi_src;\n+  vector unsigned short vbc_hi_src;\n+  vector unsigned int vbc_wi_src;\n+  vector unsigned long long vbc_di_src;\n+  vector __uint128_t vbc_qi_src;\n+  \n+  /* vcntmbb */\n+  num_elements = 16;\n+  vbc_bi_src[0] = 0xFF;\n+  vbc_bi_src[1] = 0xFF;\n+  vbc_bi_src[2] = 0x0;\n+  vbc_bi_src[3] = 0x0;\n+  vbc_bi_src[4] = 0x0;\n+  vbc_bi_src[5] = 0x0;\n+  vbc_bi_src[6] = 0xFF;\n+  vbc_bi_src[7] = 0xFF;\n+  vbc_bi_src[8] = 0x0;\n+  vbc_bi_src[9] = 0x0;\n+  vbc_bi_src[10] = 0x0;\n+  vbc_bi_src[11] = 0x0;\n+  vbc_bi_src[12] = 0x0;\n+  vbc_bi_src[13] = 0xFF;\n+  vbc_bi_src[14] = 0xFF;\n+  vbc_bi_src[15] = 0xFF;\n+\n+  expected_result = 7;\n+\n+  result = vec_cntm (vbc_bi_src, 1);\n+  /* Note count is put in bits[0:7], IBM numbering, of the 64-bit result */\n+  result = result >> (64-8);\n+  \n+  if (result != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: char vec_cntm(arg) \");\n+    printf(\"count %llu does not match expected count = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vcntmhb */\n+  num_elements = 8;\n+  vbc_hi_src[0] = 0xFFFF;\n+  vbc_hi_src[1] = 0xFFFF;\n+  vbc_hi_src[2] = 0x0;\n+  vbc_hi_src[3] = 0x0;\n+  vbc_hi_src[4] = 0x0;\n+  vbc_hi_src[5] = 0x0;\n+  vbc_hi_src[6] = 0xFFFF;\n+  vbc_hi_src[7] = 0xFFFF;\n+\n+  expected_result = 4;\n+\n+  result = vec_cntm (vbc_hi_src, 1);\n+  /* Note count is put in bits[0:6], IBM numbering, of the 64-bit result */\n+  result = result >> (64-7);\n+  \n+  if (result != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: short vec_cntm(arg) \");\n+    printf(\"count %llu does not match expected count = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vcntmwb */\n+  num_elements = 4;\n+  vbc_wi_src[0] = 0xFFFFFFFF;\n+  vbc_wi_src[1] = 0xFFFFFFFF;\n+  vbc_wi_src[2] = 0x0;\n+  vbc_wi_src[3] = 0x0;\n+\n+  expected_result = 2;\n+\n+  result = vec_cntm (vbc_wi_src, 1);\n+  /* Note count is put in bits[0:5], IBM numbering, of the 64-bit result */\n+  result = result >> (64-6);\n+  \n+  if (result != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: word vec_cntm(arg) \");\n+    printf(\"count %llu does not match expected count = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vcntmdb */\n+  num_elements = 2;\n+  vbc_di_src[0] = 0xFFFFFFFFFFFFFFFFULL;\n+  vbc_di_src[1] = 0xFFFFFFFFFFFFFFFFULL;\n+\n+  expected_result = 2;\n+\n+  result = vec_cntm (vbc_di_src, 1);\n+  /* Note count is put in bits[0:4], IBM numbering, of the 64-bit result */\n+  result = result >> (64-5);\n+\n+  if (result != expected_result) {\n+#if DEBUG\n+    printf(\"ERROR: double vec_cntm(arg) \");\n+    printf(\"count %llu does not match expected count = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  return 0;\n+}"}, {"sha": "0c5695e48076e00848f59dab4fb3c565d535dabf", "filename": "gcc/testsuite/gcc.target/powerpc/vsx_mask-expand-runnable.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-expand-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-expand-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-expand-runnable.c?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -0,0 +1,194 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mcpu=power10 -O2\" } */\n+/* { dg-require-effective-target power10_hw } */\n+\n+/* Check that the expected 128-bit instructions are generated if the processor\n+   supports the 128-bit integer instructions. */\n+/* { dg-final { scan-assembler-times {\\mvexpandbm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvexpandhm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvexpandwm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvexpanddm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvexpandqm\\M} 1 } } */\n+\n+#define DEBUG 0\n+\n+#if DEBUG\n+#include <stdio.h>\n+#include <stdlib.h>\n+#endif\n+#include <altivec.h>\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i, num_elements;\n+  unsigned long long arg1;\n+  \n+  vector unsigned char  vbc_result_bi, vbc_expected_result_bi;\n+  vector unsigned short vbc_result_hi, vbc_expected_result_hi;\n+  vector unsigned int  vbc_result_wi, vbc_expected_result_wi;\n+  vector unsigned long long vbc_result_di, vbc_expected_result_di;\n+  vector __uint128_t vbc_result_qi, vbc_expected_result_qi;\n+\n+  unsigned int result_wi, expected_result_wi;\n+  unsigned long long result, expected_result;\n+  const unsigned char mp=1;\n+  vector unsigned char vbc_bi_src;\n+  vector unsigned short vbc_hi_src;\n+  vector unsigned int vbc_wi_src;\n+  vector unsigned long long vbc_di_src;\n+  vector __uint128_t vbc_qi_src;\n+  \n+  /* vexpandbm */\n+  num_elements = 16;\n+  vbc_bi_src[0] = 0xFF;\n+  vbc_bi_src[1] = 0xFF;\n+  vbc_bi_src[2] = 0x0;\n+  vbc_bi_src[3] = 0x0;\n+  vbc_bi_src[4] = 0x0;\n+  vbc_bi_src[5] = 0x0;\n+  vbc_bi_src[6] = 0xFF;\n+  vbc_bi_src[7] = 0xFF;\n+  vbc_bi_src[8] = 0x0;\n+  vbc_bi_src[9] = 0x0;\n+  vbc_bi_src[10] = 0x0;\n+  vbc_bi_src[11] = 0x0;\n+  vbc_bi_src[12] = 0x0;\n+  vbc_bi_src[13] = 0xFF;\n+  vbc_bi_src[14] = 0xFF;\n+  vbc_bi_src[15] = 0xFF;\n+\n+  vbc_expected_result_bi[0] = 0xFF;\n+  vbc_expected_result_bi[1] = 0xFF;\n+  vbc_expected_result_bi[2] = 0x0;\n+  vbc_expected_result_bi[3] = 0x0;\n+  vbc_expected_result_bi[4] = 0x0;\n+  vbc_expected_result_bi[5] = 0x0;\n+  vbc_expected_result_bi[6] = 0xFF;\n+  vbc_expected_result_bi[7] = 0xFF;\n+  vbc_expected_result_bi[8] = 0x0;\n+  vbc_expected_result_bi[9] = 0x0;\n+  vbc_expected_result_bi[10] = 0x0;\n+  vbc_expected_result_bi[11] = 0x0;\n+  vbc_expected_result_bi[12] = 0x0;\n+  vbc_expected_result_bi[13] = 0xFF;\n+  vbc_expected_result_bi[14] = 0xFF;\n+  vbc_expected_result_bi[15] = 0xFF;\n+\n+  vbc_result_bi = vec_expandm (vbc_bi_src);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_bi[i] != vbc_expected_result_bi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: char vec_expandm(arg) \");\n+      printf(\"element %d, 0x%x does not match expected value = 0x%x\\n\",\n+\t     i, vbc_result_bi[i], vbc_expected_result_bi[i]);\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  /* vexpandhm */\n+  num_elements = 8;\n+  vbc_hi_src[0] = 0x0;\n+  vbc_hi_src[1] = 0xFFFF;\n+  vbc_hi_src[2] = 0x0;\n+  vbc_hi_src[3] = 0xFFFF;\n+  vbc_hi_src[4] = 0x0;\n+  vbc_hi_src[5] = 0x0;\n+  vbc_hi_src[6] = 0xFFFF;\n+  vbc_hi_src[7] = 0xFFFF;\n+\n+  vbc_expected_result_hi[0] = 0x0;\n+  vbc_expected_result_hi[1] = 0xFFFF;\n+  vbc_expected_result_hi[2] = 0x0;\n+  vbc_expected_result_hi[3] = 0xFFFF;\n+  vbc_expected_result_hi[4] = 0x0;\n+  vbc_expected_result_hi[5] = 0x0;\n+  vbc_expected_result_hi[6] = 0xFFFF;\n+  vbc_expected_result_hi[7] = 0xFFFF;\n+\n+  vbc_result_hi = vec_expandm (vbc_hi_src);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_hi[i] != vbc_expected_result_hi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: short vec_expandm(arg) \");\n+      printf(\"element %d, 0x%x does not match expected value = 0x%x\\n\",\n+\t     i, vbc_result_hi[i], vbc_expected_result_hi[i]);\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+  \n+  /* vexpandwm */\n+  num_elements = 4;\n+  vbc_wi_src[0] = 0x0;\n+  vbc_wi_src[1] = 0xFFFFFFFF;\n+  vbc_wi_src[2] = 0x0;\n+  vbc_wi_src[3] = 0xFFFFFFFF;\n+\n+  vbc_expected_result_wi[0] = 0x0;\n+  vbc_expected_result_wi[1] = 0xFFFFFFFF;\n+  vbc_expected_result_wi[2] = 0x0;\n+  vbc_expected_result_wi[3] = 0xFFFFFFFF;\n+\n+  vbc_result_wi = vec_expandm (vbc_wi_src);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_wi[i] != vbc_expected_result_wi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: int vec_expandm(arg) \");\n+      printf(\"element %d, 0x%x does not match expected value = 0x%x\\n\",\n+\t     i, vbc_result_wi[i], vbc_expected_result_wi[i]);\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+  \n+  /* vexpanddm */\n+  num_elements = 2;\n+  vbc_di_src[0] = 0x0;\n+  vbc_di_src[1] = 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vbc_expected_result_di[0] = 0x0;\n+  vbc_expected_result_di[1] = 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vbc_result_di = vec_expandm (vbc_di_src);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_di[i] != vbc_expected_result_di[i]) {\n+#if DEBUG\n+      printf(\"ERROR: double vec_expandm(arg) \");\n+      printf(\"element %d, 0x%llx does not match expected value = 0x%llx\\n\",\n+\t     i, vbc_result_di[i], vbc_expected_result_di[i]);\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+  \n+  /* vexpandqm */\n+  num_elements = 1;\n+  vbc_qi_src[0] = 0x0;\n+\n+  vbc_expected_result_qi[0] = 0x0;\n+\n+  vbc_result_qi = vec_expandm (vbc_qi_src);\n+  \n+  if (vbc_result_qi[0] != vbc_expected_result_qi[0]) {\n+#if DEBUG\n+    printf(\"ERROR: quad vec_expandm(arg) \");\n+    printf(\"element %d, 0x%x does not match expected value = 0x%x\\n\",\n+\t   0, vbc_result_qi[i], vbc_expected_result_qi[i]);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  return 0;\n+}"}, {"sha": "93c3c720246dbdf5be2291c97f08543e9a7f5561", "filename": "gcc/testsuite/gcc.target/powerpc/vsx_mask-extract-runnable.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-extract-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-extract-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-extract-runnable.c?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -0,0 +1,162 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mcpu=power10 -O2\" } */\n+/* { dg-require-effective-target power10_hw } */\n+\n+/* Check that the expected 128-bit instructions are generated if the processor\n+   supports the 128-bit integer instructions. */\n+/* { dg-final { scan-assembler-times {\\mvextractbm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvextracthm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvextractwm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvextractdm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mvextractqm\\M} 1 } } */\n+\n+\n+#define DEBUG 0\n+\n+#if DEBUG\n+#include <stdio.h>\n+#include <stdlib.h>\n+#endif\n+#include <altivec.h>\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i, num_elements;\n+  unsigned long long arg1;\n+  \n+  vector unsigned char  vbc_result_bi, vbc_expected_result_bi;\n+  vector unsigned short vbc_result_hi, vbc_expected_result_hi;\n+  vector unsigned int  vbc_result_wi, vbc_expected_result_wi;\n+  vector unsigned long long vbc_result_di, vbc_expected_result_di;\n+  vector __uint128_t vbc_result_qi, vbc_expected_result_qi;\n+\n+  unsigned int result_wi, expected_result_wi;\n+  unsigned long long result, expected_result;\n+  const unsigned char mp=1;\n+  vector unsigned char vbc_bi_src;\n+  vector unsigned short vbc_hi_src;\n+  vector unsigned int vbc_wi_src;\n+  vector unsigned long long vbc_di_src;\n+  vector __uint128_t vbc_qi_src;\n+  \n+/* vextractbm */\n+  num_elements = 8;\n+  vbc_bi_src[0] = 0xFF;\n+  vbc_bi_src[1] = 0xFF;\n+  vbc_bi_src[2] = 0x0;\n+  vbc_bi_src[3] = 0x0;\n+  vbc_bi_src[4] = 0x0;\n+  vbc_bi_src[5] = 0x0;\n+  vbc_bi_src[6] = 0xFF;\n+  vbc_bi_src[7] = 0xFF;\n+  vbc_bi_src[8] = 0xFF;\n+  vbc_bi_src[9] = 0xFF;\n+  vbc_bi_src[10] = 0xFF;\n+  vbc_bi_src[11] = 0xFF;\n+  vbc_bi_src[12] = 0xFF;\n+  vbc_bi_src[13] = 0x0;\n+  vbc_bi_src[14] = 0xFF;\n+  vbc_bi_src[15] = 0xFF;\n+\n+  expected_result_wi = 0b1101111111000011;\n+\n+  result_wi = vec_extractm (vbc_bi_src);\n+  \n+  if (result_wi != expected_result_wi) {\n+#if DEBUG\n+    printf(\"ERROR: short vec_extractm(%d) \", vbc_bi_src);\n+    printf(\"result %llu does not match expected result = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+    /* vextracthm */\n+  num_elements = 8;\n+  vbc_hi_src[0] = 0xFFFF;\n+  vbc_hi_src[1] = 0xFFFF;\n+  vbc_hi_src[2] = 0x0;\n+  vbc_hi_src[3] = 0x0;\n+  vbc_hi_src[4] = 0x0;\n+  vbc_hi_src[5] = 0x0;\n+  vbc_hi_src[6] = 0xFFFF;\n+  vbc_hi_src[7] = 0xFFFF;\n+\n+  expected_result_wi = 0b11000011;\n+\n+  result_wi = vec_extractm (vbc_hi_src);\n+  \n+  if (result_wi != expected_result_wi) {\n+#if DEBUG\n+    printf(\"ERROR: short vec_extractm(%d) \", vbc_hi_src);\n+    printf(\"result %llu does not match expected result = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vextractwm */\n+  num_elements = 4;\n+  vbc_wi_src[0] = 0xFFFFFFFF;\n+  vbc_wi_src[1] = 0xFFFFFFFF;\n+  vbc_wi_src[2] = 0x0;\n+  vbc_wi_src[3] = 0x0;\n+\n+  expected_result_wi = 0b0011;\n+\n+  result_wi = vec_extractm (vbc_wi_src);\n+  \n+  if (result_wi != expected_result_wi) {\n+#if DEBUG\n+    printf(\"ERROR: word vec_extractm(%d) \", vbc_wi_src);\n+    printf(\"result %llu does not match expected result = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vextractdm */\n+  num_elements = 2;\n+  vbc_di_src[0] = 0xFFFFFFFFFFFFFFFF;\n+  vbc_di_src[1] = 0xFFFFFFFFFFFFFFFF;\n+\n+  expected_result_wi = 0b11;\n+\n+  result_wi = vec_extractm (vbc_di_src);\n+  \n+  if (result_wi != expected_result_wi) {\n+#if DEBUG\n+    printf(\"ERROR: double vec_extractm(%lld) \", vbc_di_src);\n+    printf(\"result %llu does not match expected result = %llu\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  /* vextractqm */\n+  num_elements = 1;\n+  vbc_qi_src[0] = 0x1;\n+  vbc_qi_src[0] = vbc_qi_src[0] << 127;\n+  \n+  expected_result_wi = 1;\n+\n+  result_wi = vec_extractm (vbc_qi_src);\n+  \n+  if (result_wi != expected_result_wi) {\n+#if DEBUG\n+    printf(\"ERROR: quad vec_extractm(arg) \");\n+    printf(\"result 0x%x does not match expected result = 0x%x\\n\",\n+\t   result, expected_result);\n+#else\n+    abort();\n+#endif\n+  }\n+\n+  return 0;\n+}"}, {"sha": "41dee583e590aac9863eb634d737154fcb8b3082", "filename": "gcc/testsuite/gcc.target/powerpc/vsx_mask-move-runnable.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-move-runnable.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02ef74bad652522a2e424f3ffafff2452c4da105/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-move-runnable.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx_mask-move-runnable.c?ref=02ef74bad652522a2e424f3ffafff2452c4da105", "patch": "@@ -0,0 +1,225 @@\n+/* { dg-do run } */\n+/* { dg-options \"-mcpu=power10 -O2\" } */\n+/* { dg-require-effective-target power10_hw } */\n+\n+/* Check that the expected 128-bit instructions are generated if the processor\n+   supports the 128-bit integer instructions. */\n+/* { dg-final { scan-assembler-times {\\mmtvsrbm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrhm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrwm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrdm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrqm\\M} 1 } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrbmi\\M} 2 } } */\n+\n+#define DEBUG 0\n+\n+#if DEBUG\n+#include <stdio.h>\n+#include <stdlib.h>\n+#endif\n+#include <altivec.h>\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i, num_elements;\n+  unsigned long long arg1;\n+  \n+  vector unsigned char  vbc_result_bi, vbc_expected_result_bi;\n+  vector unsigned short vbc_result_hi, vbc_expected_result_hi;\n+  vector unsigned int  vbc_result_wi, vbc_expected_result_wi;\n+  vector unsigned long long vbc_result_di, vbc_expected_result_di;\n+  vector __uint128_t vbc_result_qi, vbc_expected_result_qi;\n+\n+  unsigned int result_wi, expected_result_wi;\n+  unsigned long long result, expected_result;\n+  const unsigned char mp=1;\n+  vector unsigned char vbc_bi_src;\n+  vector unsigned short vbc_hi_src;\n+  vector unsigned int vbc_wi_src;\n+  vector unsigned long long vbc_di_src;\n+  vector __uint128_t vbc_qi_src;\n+  \n+ /* mtvsrbmi */\n+  num_elements = 16;\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_bi[i] = 0x0;\n+\n+  vbc_expected_result_bi[0] = 0xFF;\n+  vbc_expected_result_bi[2] = 0xFF;\n+\n+  vbc_result_bi = vec_genbm(5);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_bi[i] != vbc_expected_result_bi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_genbm(const 5) \");\n+      printf(\"element %d equals 0x%x does not match expected_result = 0x%x\",\n+\t     i, vbc_result_bi[i], vbc_expected_result_bi[i]);\n+      printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  /* mtvsrbm */\n+  num_elements = 16;\n+  /* -O2 should generate mtvsrbmi as argument will fit in 6-bit field. */\n+  arg1 = 3;\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_bi[i] = 0x0;\n+\n+  vbc_expected_result_bi[1] = 0xFF;\n+  vbc_expected_result_bi[0] = 0xFF;\n+\n+  vbc_result_bi = vec_genbm(arg1);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_bi[i] != vbc_expected_result_bi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_genbm(%d) \", arg1);\n+      printf(\"element %d equals 0x%x does not match expected_result = 0x%x\",\n+\t     i, vbc_result_bi[i], vbc_expected_result_bi[i]);\n+      printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  num_elements = 16;\n+  /* Should generate mtvsrbm as argument will not fit in 6-bit field. */\n+  arg1 = 0xEA;   // 234 decimal\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_bi[i] = 0x0;\n+\n+  vbc_expected_result_bi[7] = 0xFF;\n+  vbc_expected_result_bi[6] = 0xFF;\n+  vbc_expected_result_bi[5] = 0xFF;\n+  vbc_expected_result_bi[3] = 0xFF;\n+  vbc_expected_result_bi[1] = 0xFF;\n+\n+  vbc_result_bi = vec_genbm(arg1);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_bi[i] != vbc_expected_result_bi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_genbm(%d) \", arg1);\n+      printf(\"element %d equals 0x%x does not match expected_result = 0x%x\",\n+\t     i, vbc_result_bi[i], vbc_expected_result_bi[i]);\n+      printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  /* mtvsrhm */\n+  num_elements = 8;\n+  arg1 = 5;\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_hi[i] = 0x0;\n+\n+  vbc_expected_result_hi[2] = 0xFFFF;\n+  vbc_expected_result_hi[0] = 0xFFFF;\n+\n+  vbc_result_hi = vec_genhm(arg1);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_hi[i] != vbc_expected_result_hi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_genhm(%d) \", arg1);\n+      printf(\"element %d equals 0x%x does not match expected_result = 0x%x\",\n+\t     i, vbc_result_hi[i], vbc_expected_result_hi[i]);\n+      printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  /* mtvsrwm */\n+  num_elements = 4;\n+  arg1 = 7;\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_wi[i] = 0x0;\n+\n+  vbc_expected_result_wi[2] = 0xFFFFFFFF;\n+  vbc_expected_result_wi[1] = 0xFFFFFFFF;\n+  vbc_expected_result_wi[0] = 0xFFFFFFFF;\n+\n+  vbc_result_wi = vec_genwm(arg1);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_wi[i] != vbc_expected_result_wi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_genwm(%d) \", arg1);\n+      printf(\"element %d equals 0x%x does not match expected_result = 0x%x\",\n+\t     i, vbc_result_wi[i], vbc_expected_result_wi[i]);\n+      printf(\"\\n\\n\");\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  /* mtvsrdm */\n+  num_elements = 2;\n+  arg1 = 1;\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_di[i] = 0x0;\n+\n+  vbc_expected_result_di[1] = 0x0;\n+  vbc_expected_result_di[0] = 0xFFFFFFFFFFFFFFFF;\n+\n+  vbc_result_di = vec_gendm(arg1);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_di[i] != vbc_expected_result_di[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_gendm(%d) \", arg1);\n+      printf(\"element %d equals 0x%llx does not match expected_result = \",\n+\t     i, vbc_result_di[i]);\n+      printf(\"0x%llx\\n\\n\", vbc_expected_result_di[i]);\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  /* mtvsrqm */\n+  num_elements = 1;\n+  arg1 = 1;\n+  \n+  for (i = 0; i<num_elements; i++)\n+    vbc_expected_result_qi[i] = 0x0;\n+\n+  vbc_expected_result_qi[0] = 0xFFFFFFFFFFFFFFFFULL;\n+  vbc_expected_result_qi[0] = (vbc_expected_result_qi[0] << 64)\n+    | 0xFFFFFFFFFFFFFFFFULL;\n+\n+  vbc_result_qi = vec_genqm(arg1);\n+  \n+  for (i = 0; i<num_elements; i++) {\n+    if (vbc_result_qi[i] != vbc_expected_result_qi[i]) {\n+#if DEBUG\n+      printf(\"ERROR: vec_genqm(%d) \", arg1);\n+      printf(\"element %d equals 0x%llx does not match expected_result = \",\n+\t     i, vbc_result_qi[i]);\n+      printf(\"0x%llx\\n\\n\", vbc_expected_result_qi[i]);\n+#else\n+    abort();\n+#endif\n+    }\n+  }\n+\n+  return 0;\n+}"}]}