{"sha": "78df6221f9530b27251f81a3ec7c8052c92fb059", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhkZjYyMjFmOTUzMGIyNzI1MWY4MWEzZWM3YzgwNTJjOTJmYjA1OQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-08-13T19:53:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-08-13T19:53:37Z"}, "message": "decl.c (gnat_to_gnu_entity): Replace True with true.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Replace True with true.\n\t(is_cplusplus_method): Likewise, and False with false.\n\t(components_need_strict_alignment): Likewise.\n\t* gcc-interface/misc.c (gnat_init_gcc_fp): Likewise.\n\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Likewise.\n\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n\t(add_cleanup): Likewise.\n\t(Sloc_to_locus1): Likewise.\n\t(Sloc_to_locus): Likewise.\n\t(set_expr_location_from_node): Likewise.\n\t* gcc-interface/utils.c (potential_alignment_gap): Likewise.\n\nFrom-SVN: r201704", "tree": {"sha": "378d48e22c9553fb3aa3a141e889d8a4895ca5dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/378d48e22c9553fb3aa3a141e889d8a4895ca5dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78df6221f9530b27251f81a3ec7c8052c92fb059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78df6221f9530b27251f81a3ec7c8052c92fb059", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78df6221f9530b27251f81a3ec7c8052c92fb059", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78df6221f9530b27251f81a3ec7c8052c92fb059/comments", "author": null, "committer": null, "parents": [{"sha": "1d3db14c1e2c8d5cf8ba179897657fd26410879e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3db14c1e2c8d5cf8ba179897657fd26410879e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3db14c1e2c8d5cf8ba179897657fd26410879e"}], "stats": {"total": 52, "additions": 33, "deletions": 19}, "files": [{"sha": "17774187dc8928654c8a3b3a94773c35de0d3938", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78df6221f9530b27251f81a3ec7c8052c92fb059", "patch": "@@ -1,3 +1,17 @@\n+2013-08-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Replace True with true.\n+\t(is_cplusplus_method): Likewise, and False with false.\n+\t(components_need_strict_alignment): Likewise.\n+\t* gcc-interface/misc.c (gnat_init_gcc_fp): Likewise.\n+\t* gcc-interface/trans.c (Loop_Statement_to_gnu): Likewise.\n+\t(Handled_Sequence_Of_Statements_to_gnu): Likewise.\n+\t(add_cleanup): Likewise.\n+\t(Sloc_to_locus1): Likewise.\n+\t(Sloc_to_locus): Likewise.\n+\t(set_expr_location_from_node): Likewise.\n+\t* gcc-interface/utils.c (potential_alignment_gap): Likewise.\n+\n 2013-08-13  Thomas Quinot  <quinot@adacore.com>\n \n \t* gcc-interface/trans.c (set_end_locus_from_node): Clear column info"}, {"sha": "551ab4454b11499e1ac318d5fae963c2a86caa44", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=78df6221f9530b27251f81a3ec7c8052c92fb059", "patch": "@@ -4830,7 +4830,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   if (is_type && (!gnu_decl || this_made_decl))\n     {\n       /* Process the attributes, if not already done.  Note that the type is\n-\t already defined so we cannot pass True for IN_PLACE here.  */\n+\t already defined so we cannot pass true for IN_PLACE here.  */\n       process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \n       /* Tell the middle-end that objects of tagged types are guaranteed to\n@@ -5449,26 +5449,26 @@ bool\n is_cplusplus_method (Entity_Id gnat_entity)\n {\n   if (Convention (gnat_entity) != Convention_CPP)\n-    return False;\n+    return false;\n \n   /* This is the main case: C++ method imported as a primitive operation.  */\n   if (Is_Dispatching_Operation (gnat_entity))\n-    return True;\n+    return true;\n \n   /* A thunk needs to be handled like its associated primitive operation.  */\n   if (Is_Subprogram (gnat_entity) && Is_Thunk (gnat_entity))\n-    return True;\n+    return true;\n \n   /* C++ classes with no virtual functions can be imported as limited\n      record types, but we need to return true for the constructors.  */\n   if (Is_Constructor (gnat_entity))\n-    return True;\n+    return true;\n \n   /* This is set on the E_Subprogram_Type built for a dispatching call.  */\n   if (Is_Dispatch_Table_Entity (gnat_entity))\n-    return True;\n+    return true;\n \n-  return False;\n+  return false;\n }\n \n /* Finalize the processing of From_With_Type incomplete types.  */\n@@ -6727,13 +6727,13 @@ components_need_strict_alignment (Node_Id component_list)\n       Entity_Id gnat_field = Defining_Entity (component_decl);\n \n       if (Is_Aliased (gnat_field))\n-\treturn True;\n+\treturn true;\n \n       if (Strict_Alignment (Etype (gnat_field)))\n-\treturn True;\n+\treturn true;\n     }\n \n-  return False;\n+  return false;\n }\n \n /* Return true if TYPE is a type with variable size or a padding type with a"}, {"sha": "3abe57b6bd97b58b38dee44389b6cfe8d4624931", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=78df6221f9530b27251f81a3ec7c8052c92fb059", "patch": "@@ -385,13 +385,13 @@ void\n gnat_init_gcc_fp (void)\n {\n   /* Disable FP optimizations that ignore the signedness of zero if\n-     S'Signed_Zeros is True, but don't override the user if not.  */\n+     S'Signed_Zeros is true, but don't override the user if not.  */\n   if (Signed_Zeros_On_Target)\n     flag_signed_zeros = 1;\n   else if (!global_options_set.x_flag_signed_zeros)\n     flag_signed_zeros = 0;\n \n-  /* Assume that FP operations can trap if S'Machine_Overflow is True,\n+  /* Assume that FP operations can trap if S'Machine_Overflow is true,\n      but don't override the user if not.\n \n      ??? Alpha/VMS enables FP traps without declaring it.  */"}, {"sha": "4048e0aefe95047f152dbdac1fe15b9b61fa6f49", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=78df6221f9530b27251f81a3ec7c8052c92fb059", "patch": "@@ -2721,7 +2721,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \n       /* First, if we have computed a small number of invariant conditions for\n \t range checks applied to the iteration variable, then initialize these\n-\t conditions in front of the loop.  Otherwise, leave them set to True.\n+\t conditions in front of the loop.  Otherwise, leave them set to true.\n \n \t ??? The heuristics need to be improved, by taking into account the\n \t     following datapoints:\n@@ -4658,7 +4658,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n            implicit transient block does not incorrectly inherit the slocs\n            of a decision, which would otherwise confuse control flow based\n            coverage analysis tools.  */\n-\tset_expr_location_from_node1 (gnu_result, gnat_node, True);\n+\tset_expr_location_from_node1 (gnu_result, gnat_node, true);\n     }\n   else\n     gnu_result = gnu_inner_block;\n@@ -7416,7 +7416,7 @@ static void\n add_cleanup (tree gnu_cleanup, Node_Id gnat_node)\n {\n   if (Present (gnat_node))\n-    set_expr_location_from_node1 (gnu_cleanup, gnat_node, True);\n+    set_expr_location_from_node1 (gnu_cleanup, gnat_node, true);\n   append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n }\n \n@@ -9032,7 +9032,7 @@ maybe_implicit_deref (tree exp)\n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n    location and false if it doesn't.  In the former case, set the Gigi global\n    variable REF_FILENAME to the simple debug file name as given by sinput.\n-   If clear_column is True, set column information to 0.  */\n+   If clear_column is true, set column information to 0.  */\n \n static bool\n Sloc_to_locus1 (Source_Ptr Sloc, location_t *locus, bool clear_column)\n@@ -9073,7 +9073,7 @@ Sloc_to_locus1 (Source_Ptr Sloc, location_t *locus, bool clear_column)\n bool\n Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n {\n-  return Sloc_to_locus1 (Sloc, locus, False);\n+  return Sloc_to_locus1 (Sloc, locus, false);\n }\n \n /* Similar to set_expr_location, but start with the Sloc of GNAT_NODE and\n@@ -9095,7 +9095,7 @@ set_expr_location_from_node1 (tree node, Node_Id gnat_node, bool clear_column)\n static void\n set_expr_location_from_node (tree node, Node_Id gnat_node)\n {\n-  set_expr_location_from_node1 (node, gnat_node, False);\n+  set_expr_location_from_node1 (node, gnat_node, false);\n }\n \n /* More elaborate version of set_expr_location_from_node to be used in more"}, {"sha": "2c3e096f120ca2c1d88c77ba1c15b3195ac8ad0f", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78df6221f9530b27251f81a3ec7c8052c92fb059/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=78df6221f9530b27251f81a3ec7c8052c92fb059", "patch": "@@ -2573,7 +2573,7 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n   if (!prev_field)\n     return false;\n \n-  /* If the previous field is a union type, then return False: The only\n+  /* If the previous field is a union type, then return false: The only\n      time when such a field is not the last field of the record is when\n      there are other components at fixed positions after it (meaning there\n      was a rep clause for every field), in which case we don't want the"}]}