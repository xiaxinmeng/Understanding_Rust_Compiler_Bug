{"sha": "01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiMWVmYWExNDM5ZTZjYmY0NDU2NjM1NGRjY2U5YTk2ZDVjNmY1ZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-10-25T21:06:38Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-10-25T21:06:38Z"}, "message": "2013-10-25  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* config/rs6000/rs6000-protos.h\n\t(rs6000_secondary_memory_needed_mode): New prototype.\n\t* config/rs6000/rs6000.c: Include ira.h.\n\t(TARGET_LRA_P): Redefine.\n\t(rs6000_legitimate_offset_address_p): Call\n\tlegitimate_constant_pool_address_p in strict mode for LRA.\n\t(rs6000_legitimate_address_p): Ditto.\n\t(legitimate_lo_sum_address_p): Add code for LRA.\n\tUse lra_in_progress.\n\t(rs6000_emit_move): Add LRA version of code to generate load/store\n\tof SDmode values.\n\t(rs6000_secondary_memory_needed_mode): New.\n\t(rs6000_alloc_sdmode_stack_slot): Do nothing for LRA.\n\t(rs6000_secondary_reload_class): Return NO_REGS for LRA for\n\tconstants, memory, and FP registers.\n\t(rs6000_lra_p): New.\n\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED_MODE): New\n\tmacro.\n\t* config/rs6000/rs6000.opt (mlra): New option.\n\t* lra-spills.c (lra_final_code_change): Remove useless move insns.\n\nFrom-SVN: r204079", "tree": {"sha": "2ee1cb8d7e34ed805e6e3c69b0f6076f88fa163a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ee1cb8d7e34ed805e6e3c69b0f6076f88fa163a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ff4317f1cfddf2e015db24a673e3ea5bf188920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff4317f1cfddf2e015db24a673e3ea5bf188920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff4317f1cfddf2e015db24a673e3ea5bf188920"}], "stats": {"total": 166, "additions": 159, "deletions": 7}, "files": [{"sha": "d12077147cbace0653924476599f6943134ebfaa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "patch": "@@ -1,3 +1,26 @@\n+2013-10-25  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* config/rs6000/rs6000-protos.h\n+\t(rs6000_secondary_memory_needed_mode): New prototype.\n+\t* config/rs6000/rs6000.c: Include ira.h.\n+\t(TARGET_LRA_P): Redefine.\n+\t(rs6000_legitimate_offset_address_p): Call\n+\tlegitimate_constant_pool_address_p in strict mode for LRA.\n+\t(rs6000_legitimate_address_p): Ditto.\n+\t(legitimate_lo_sum_address_p): Add code for LRA.\n+\tUse lra_in_progress.\n+\t(rs6000_emit_move): Add LRA version of code to generate load/store\n+\tof SDmode values.\n+\t(rs6000_secondary_memory_needed_mode): New.\n+\t(rs6000_alloc_sdmode_stack_slot): Do nothing for LRA.\n+\t(rs6000_secondary_reload_class): Return NO_REGS for LRA for\n+\tconstants, memory, and FP registers.\n+\t(rs6000_lra_p): New.\n+\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED_MODE): New\n+\tmacro.\n+\t* config/rs6000/rs6000.opt (mlra): New option.\n+\t* lra-spills.c (lra_final_code_change): Remove useless move insns.\n+\n 2013-10-25  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* tree-ssa-math-opts.c (convert_plusminus_to_widen): Call"}, {"sha": "c35e44dd7e050fecec5bc0489ddb9cb1d3ee68ab", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "patch": "@@ -126,6 +126,8 @@ extern void rs6000_split_multireg_move (rtx, rtx);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, enum machine_mode);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (enum machine_mode);\n+extern enum machine_mode rs6000_secondary_memory_needed_mode (enum\n+\t\t\t\t\t\t\t      machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, enum machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (enum machine_mode, rtx,"}, {"sha": "1006eece07b3d97402014dd03a667fea8bc5ed64", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 108, "deletions": 6, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "patch": "@@ -55,6 +55,7 @@\n #include \"intl.h\"\n #include \"params.h\"\n #include \"tm-constrs.h\"\n+#include \"ira.h\"\n #include \"opts.h\"\n #include \"tree-vectorizer.h\"\n #include \"dumpfile.h\"\n@@ -1554,6 +1555,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_MODE_DEPENDENT_ADDRESS_P\n #define TARGET_MODE_DEPENDENT_ADDRESS_P rs6000_mode_dependent_address_p\n \n+#undef TARGET_LRA_P\n+#define TARGET_LRA_P rs6000_lra_p\n+\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE rs6000_can_eliminate\n \n@@ -6226,7 +6230,7 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x,\n     return false;\n   if (!reg_offset_addressing_ok_p (mode))\n     return virtual_stack_registers_memory_p (x);\n-  if (legitimate_constant_pool_address_p (x, mode, strict))\n+  if (legitimate_constant_pool_address_p (x, mode, strict || lra_in_progress))\n     return true;\n   if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n     return false;\n@@ -6366,19 +6370,31 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n \n   if (TARGET_ELF || TARGET_MACHO)\n     {\n+      bool large_toc_ok;\n+\n       if (DEFAULT_ABI != ABI_AIX && DEFAULT_ABI != ABI_DARWIN && flag_pic)\n \treturn false;\n-      if (TARGET_TOC)\n+      /* LRA don't use LEGITIMIZE_RELOAD_ADDRESS as it usually calls\n+\t push_reload from reload pass code.  LEGITIMIZE_RELOAD_ADDRESS\n+\t recognizes some LO_SUM addresses as valid although this\n+\t function says opposite.  In most cases, LRA through different\n+\t transformations can generate correct code for address reloads.\n+\t It can not manage only some LO_SUM cases.  So we need to add\n+\t code analogous to one in rs6000_legitimize_reload_address for\n+\t LOW_SUM here saying that some addresses are still valid.  */\n+      large_toc_ok = (lra_in_progress && TARGET_CMODEL != CMODEL_SMALL\n+\t\t      && small_toc_ref (x, VOIDmode));\n+      if (TARGET_TOC && ! large_toc_ok)\n \treturn false;\n       if (GET_MODE_NUNITS (mode) != 1)\n \treturn false;\n-      if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+      if (! lra_in_progress && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n \t  && !(/* ??? Assume floating point reg based on mode?  */\n \t       TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n \t       && (mode == DFmode || mode == DDmode)))\n \treturn false;\n \n-      return CONSTANT_P (x);\n+      return CONSTANT_P (x) || large_toc_ok;\n     }\n \n   return false;\n@@ -7368,7 +7384,8 @@ rs6000_legitimate_address_p (enum machine_mode mode, rtx x, bool reg_ok_strict)\n   if (reg_offset_p && legitimate_small_data_p (mode, x))\n     return 1;\n   if (reg_offset_p\n-      && legitimate_constant_pool_address_p (x, mode, reg_ok_strict))\n+      && legitimate_constant_pool_address_p (x, mode,\n+\t\t\t\t\t     reg_ok_strict || lra_in_progress))\n     return 1;\n   /* For TImode, if we have load/store quad and TImode in VSX registers, only\n      allow register indirect addresses.  This will allow the values to go in\n@@ -7654,6 +7671,7 @@ rs6000_conditional_register_usage (void)\n \t  fixed_regs[i] = call_used_regs[i] = call_really_used_regs[i] = 1;\n     }\n }\n+\n \f\n /* Try to output insns to set TARGET equal to the constant C if it can\n    be done in less than N insns.  Do all computations in MODE.\n@@ -8058,6 +8076,68 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n     cfun->machine->sdmode_stack_slot =\n       eliminate_regs (cfun->machine->sdmode_stack_slot, VOIDmode, NULL_RTX);\n \n+\n+  if (lra_in_progress\n+      && mode == SDmode\n+      && REG_P (operands[0]) && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER\n+      && reg_preferred_class (REGNO (operands[0])) == NO_REGS\n+      && (REG_P (operands[1])\n+\t  || (GET_CODE (operands[1]) == SUBREG\n+\t      && REG_P (SUBREG_REG (operands[1])))))\n+    {\n+      int regno = REGNO (GET_CODE (operands[1]) == SUBREG\n+\t\t\t ? SUBREG_REG (operands[1]) : operands[1]);\n+      enum reg_class cl;\n+\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  cl = reg_preferred_class (regno);\n+\t  gcc_assert (cl != NO_REGS);\n+\t  regno = ira_class_hard_regs[cl][0];\n+\t}\n+      if (FP_REGNO_P (regno))\n+\t{\n+\t  if (GET_MODE (operands[0]) != DDmode)\n+\t    operands[0] = gen_rtx_SUBREG (DDmode, operands[0], 0);\n+\t  emit_insn (gen_movsd_store (operands[0], operands[1]));\n+\t}\n+      else if (INT_REGNO_P (regno))\n+\temit_insn (gen_movsd_hardfloat (operands[0], operands[1]));\n+      else\n+\tgcc_unreachable();\n+      return;\n+    }\n+  if (lra_in_progress\n+      && mode == SDmode\n+      && (REG_P (operands[0])\n+\t  || (GET_CODE (operands[0]) == SUBREG\n+\t      && REG_P (SUBREG_REG (operands[0]))))\n+      && REG_P (operands[1]) && REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER\n+      && reg_preferred_class (REGNO (operands[1])) == NO_REGS)\n+    {\n+      int regno = REGNO (GET_CODE (operands[0]) == SUBREG\n+\t\t\t ? SUBREG_REG (operands[0]) : operands[0]);\n+      enum reg_class cl;\n+\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  cl = reg_preferred_class (regno);\n+\t  gcc_assert (cl != NO_REGS);\n+\t  regno = ira_class_hard_regs[cl][0];\n+\t}\n+      if (FP_REGNO_P (regno))\n+\t{\n+\t  if (GET_MODE (operands[1]) != DDmode)\n+\t    operands[1] = gen_rtx_SUBREG (DDmode, operands[1], 0);\n+\t  emit_insn (gen_movsd_load (operands[0], operands[1]));\n+\t}\n+      else if (INT_REGNO_P (regno))\n+\temit_insn (gen_movsd_hardfloat (operands[0], operands[1]));\n+      else\n+\tgcc_unreachable();\n+      return;\n+    }\n+\n   if (reload_in_progress\n       && mode == SDmode\n       && cfun->machine->sdmode_stack_slot != NULL_RTX\n@@ -14905,6 +14985,17 @@ rs6000_secondary_memory_needed_rtx (enum machine_mode mode)\n   return ret;\n }\n \n+/* Return the mode to be used for memory when a secondary memory\n+   location is needed.  For SDmode values we need to use DDmode, in\n+   all other cases we can use the same mode.  */\n+enum machine_mode\n+rs6000_secondary_memory_needed_mode (enum machine_mode mode)\n+{\n+  if (mode == SDmode)\n+    return DDmode;\n+  return mode;\n+}\n+\n static tree\n rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n@@ -15798,6 +15889,10 @@ rs6000_alloc_sdmode_stack_slot (void)\n   gimple_stmt_iterator gsi;\n \n   gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n+  /* We use a different approach for dealing with the secondary\n+     memory in LRA.  */\n+  if (ira_use_lra_p)\n+    return;\n \n   if (TARGET_NO_SDMODE_STACK)\n     return;\n@@ -16019,7 +16114,7 @@ rs6000_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n   /* Constants, memory, and FP registers can go into FP registers.  */\n   if ((regno == -1 || FP_REGNO_P (regno))\n       && (rclass == FLOAT_REGS || rclass == NON_SPECIAL_REGS))\n-    return (mode != SDmode) ? NO_REGS : GENERAL_REGS;\n+    return (mode != SDmode || lra_in_progress) ? NO_REGS : GENERAL_REGS;\n \n   /* Memory, and FP/altivec registers can go into fp/altivec registers under\n      VSX.  However, for scalar variables, use the traditional floating point\n@@ -29364,6 +29459,13 @@ rs6000_libcall_value (enum machine_mode mode)\n }\n \n \n+/* Return true if we use LRA instead of reload pass.  */\n+static bool\n+rs6000_lra_p (void)\n+{\n+  return rs6000_lra_flag;\n+}\n+\n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n    Frame pointer elimination is automatically handled.\n "}, {"sha": "f13951eb23555305b8a069cced1c08b1ffe003a3", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "patch": "@@ -1488,6 +1488,13 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n   rs6000_secondary_memory_needed_rtx (MODE)\n \n+/* Specify the mode to be used for memory when a secondary memory\n+   location is needed.  For cpus that cannot load/store SDmode values\n+   from the 64-bit FP registers without using a full 64-bit\n+   load/store, we need a wider mode.  */\n+#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n+  rs6000_secondary_memory_needed_mode (MODE)\n+\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n "}, {"sha": "94e4b3883dcdeff6863d9266e349bca5775fcc1b", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "patch": "@@ -449,6 +449,10 @@ mlong-double-\n Target RejectNegative Joined UInteger Var(rs6000_long_double_type_size) Save\n -mlong-double-<n>\tSpecify size of long double (64 or 128 bits)\n \n+mlra\n+Target Report Var(rs6000_lra_flag) Init(0) Save\n+Use LRA instead of reload\n+\n msched-costly-dep=\n Target RejectNegative Joined Var(rs6000_sched_costly_dep_str)\n Determine which dependences between insns are considered costly"}, {"sha": "73a90a836dabcba32a9610996af4596abe85a05e", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b1efaa1439e6cbf44566354dcce9a96d5c6f5e/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=01b1efaa1439e6cbf44566354dcce9a96d5c6f5e", "patch": "@@ -625,7 +625,7 @@ lra_final_code_change (void)\n {\n   int i, hard_regno;\n   basic_block bb;\n-  rtx insn, curr;\n+  rtx insn, curr, set;\n   int max_regno = max_reg_num ();\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n@@ -661,5 +661,19 @@ lra_final_code_change (void)\n \t      }\n \t  if (insn_change_p)\n \t    lra_update_operator_dups (id);\n+\n+\t  if ((set = single_set (insn)) != NULL\n+\t      && REG_P (SET_SRC (set)) && REG_P (SET_DEST (set))\n+\t      && REGNO (SET_SRC (set)) == REGNO (SET_DEST (set)))\n+\t    {\n+\t      /* Remove an useless move insn.  IRA can generate move\n+\t\t insns involving pseudos.  It is better remove them\n+\t\t earlier to speed up compiler a bit.  It is also\n+\t\t better to do it here as they might not pass final RTL\n+\t\t check in LRA, (e.g. insn moving a control register\n+\t\t into itself).  */\n+\t      lra_invalidate_insn_data (insn);\n+\t      delete_insn (insn);\n+\t    }\n \t}\n }"}]}