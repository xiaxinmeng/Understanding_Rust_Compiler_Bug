{"sha": "a3a0db2eb9a89957d478bce7132e19d0492eb96d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhMGRiMmViOWE4OTk1N2Q0NzhiY2U3MTMyZTE5ZDA0OTJlYjk2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:55:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:55:43Z"}, "message": "prj-makr.adb (Process_Directory): Put file name in canonical case before matching against the patterns.\n\n\t* prj-makr.adb (Process_Directory): Put file name in canonical case\n\tbefore matching against the patterns.\n\tIf gnatname has been invoked as <prefix>-gnatname\n\tthen invoke the compiler as <prefix>-gcc, not just \"gcc\".\n\nFrom-SVN: r94819", "tree": {"sha": "cc687c95ee7270932641e3965b2827b6d50dfca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc687c95ee7270932641e3965b2827b6d50dfca3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3a0db2eb9a89957d478bce7132e19d0492eb96d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a0db2eb9a89957d478bce7132e19d0492eb96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a0db2eb9a89957d478bce7132e19d0492eb96d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a0db2eb9a89957d478bce7132e19d0492eb96d/comments", "author": null, "committer": null, "parents": [{"sha": "3536d406b5a5d065dcfc43b434f99118eab96fa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3536d406b5a5d065dcfc43b434f99118eab96fa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3536d406b5a5d065dcfc43b434f99118eab96fa9"}], "stats": {"total": 84, "additions": 58, "deletions": 26}, "files": [{"sha": "22f94aeae4c64f5c4f2044cc0a23451f467d98f8", "filename": "gcc/ada/prj-makr.adb", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3a0db2eb9a89957d478bce7132e19d0492eb96d/gcc%2Fada%2Fprj-makr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3a0db2eb9a89957d478bce7132e19d0492eb96d/gcc%2Fada%2Fprj-makr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-makr.adb?ref=a3a0db2eb9a89957d478bce7132e19d0492eb96d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 2001-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -44,14 +44,13 @@ with GNAT.OS_Lib;               use GNAT.OS_Lib;\n with GNAT.Regexp;               use GNAT.Regexp;\n \n with System.Case_Util;          use System.Case_Util;\n+with System.CRTL;\n \n package body Prj.Makr is\n \n    function Dup (Fd : File_Descriptor) return File_Descriptor;\n-   pragma Import (C, Dup);\n \n    procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n-   pragma Import (C, Dup2);\n \n    Gcc : constant String := \"gcc\";\n    Gcc_Path : String_Access := null;\n@@ -64,11 +63,11 @@ package body Prj.Makr is\n    Naming_File_Suffix      : constant String := \"_naming\";\n    Source_List_File_Suffix : constant String := \"_source_list.txt\";\n \n-   Output_FD   : File_Descriptor;\n-   --  To save the project file and its naming project file.\n+   Output_FD : File_Descriptor;\n+   --  To save the project file and its naming project file\n \n    procedure Write_Eol;\n-   --  Output an empty line.\n+   --  Output an empty line\n \n    procedure Write_A_Char (C : Character);\n    --  Write one character to Output_FD\n@@ -84,6 +83,26 @@ package body Prj.Makr is\n       Table_Increment      => 10,\n       Table_Name           => \"Prj.Makr.Processed_Directories\");\n \n+   ---------\n+   -- Dup --\n+   ---------\n+\n+   function Dup  (Fd : File_Descriptor) return File_Descriptor is\n+   begin\n+      return File_Descriptor (System.CRTL.dup (Integer (Fd)));\n+   end Dup;\n+\n+   ----------\n+   -- Dup2 --\n+   ----------\n+\n+   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor) is\n+      Fd : Integer;\n+      pragma Warnings (Off, Fd);\n+   begin\n+      Fd := System.CRTL.dup2 (Integer (Old_Fd), Integer (New_Fd));\n+   end Dup2;\n+\n    ----------\n    -- Make --\n    ----------\n@@ -160,19 +179,17 @@ package body Prj.Makr is\n       -----------------------\n \n       procedure Process_Directory (Dir_Name : String; Recursively : Boolean) is\n-         Matched  : Matched_Type := False;\n-         Str      : String (1 .. 2_000);\n-         Last     : Natural;\n-         Dir      : Dir_Type;\n-         Process  : Boolean := True;\n-\n-         Temp_File_Name : String_Access := null;\n-\n+         Matched : Matched_Type := False;\n+         Str     : String (1 .. 2_000);\n+         Canon   : String (1 .. 2_000);\n+         Last    : Natural;\n+         Dir     : Dir_Type;\n+         Process : Boolean := True;\n+\n+         Temp_File_Name         : String_Access := null;\n          Save_Last_Pragma_Index : Natural := 0;\n-\n-         File_Name_Id : Name_Id := No_Name;\n-\n-         SFN_Prag : SFN_Pragma;\n+         File_Name_Id           : Name_Id := No_Name;\n+         SFN_Prag               : SFN_Pragma;\n \n       begin\n          --  Avoid processing the same directory more than once\n@@ -195,12 +212,11 @@ package body Prj.Makr is\n             Processed_Directories.Table (Processed_Directories.Last) :=\n               new String'(Dir_Name);\n \n-            --  Get the source file names from the directory.\n-            --  Fails if the directory does not exist.\n+            --  Get the source file names from the directory. Fails if the\n+            --  directory does not exist.\n \n             begin\n                Open (Dir, Dir_Name);\n-\n             exception\n                when Directory_Error =>\n                   Prj.Com.Fail (\"cannot open directory \"\"\", Dir_Name, \"\"\"\");\n@@ -212,6 +228,13 @@ package body Prj.Makr is\n                Read (Dir, Str, Last);\n                exit File_Loop when Last = 0;\n \n+               --  Copy the file name and put it in canonical case to match\n+               --  against the patterns that have themselves already been put\n+               --  in canonical case.\n+\n+               Canon (1 .. Last) := Str (1 .. Last);\n+               Canonical_Case_File_Name (Canon (1 .. Last));\n+\n                if Is_Regular_File\n                  (Dir_Name & Directory_Separator & Str (1 .. Last))\n                then\n@@ -226,7 +249,7 @@ package body Prj.Makr is\n \n                   for Index in Excluded_Expressions'Range loop\n                      if\n-                       Match (Str (1 .. Last), Excluded_Expressions (Index))\n+                       Match (Canon (1 .. Last), Excluded_Expressions (Index))\n                      then\n                         Matched := Excluded;\n                         exit;\n@@ -242,7 +265,8 @@ package body Prj.Makr is\n \n                      for Index in Regular_Expressions'Range loop\n                         if\n-                          Match (Str (1 .. Last), Regular_Expressions (Index))\n+                          Match\n+                            (Canon (1 .. Last), Regular_Expressions (Index))\n                         then\n                            Matched := True;\n                            exit;\n@@ -270,10 +294,18 @@ package body Prj.Makr is\n \n                      begin\n                         --  If we don't have the path of the compiler yet,\n-                        --  get it now.\n+                        --  get it now. The compiler name may have a prefix,\n+                        --  so we get the potentially prefixed name.\n \n                         if Gcc_Path = null then\n-                           Gcc_Path := Locate_Exec_On_Path (Gcc);\n+                           declare\n+                              Prefix_Gcc : String_Access :=\n+                                             Program_Name (Gcc);\n+                           begin\n+                              Gcc_Path :=\n+                                Locate_Exec_On_Path (Prefix_Gcc.all);\n+                              Free (Prefix_Gcc);\n+                           end;\n \n                            if Gcc_Path = null then\n                               Prj.Com.Fail (\"could not locate \" & Gcc);\n@@ -538,7 +570,7 @@ package body Prj.Makr is\n \n                      if Matched /= Excluded then\n                         for Index in Foreign_Expressions'Range loop\n-                           if Match (Str (1 .. Last),\n+                           if Match (Canon (1 .. Last),\n                                      Foreign_Expressions (Index))\n                            then\n                               Matched := True;"}]}