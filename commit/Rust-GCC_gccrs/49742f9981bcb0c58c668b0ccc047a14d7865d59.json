{"sha": "49742f9981bcb0c58c668b0ccc047a14d7865d59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3NDJmOTk4MWJjYjBjNThjNjY4YjBjY2MwNDdhMTRkNzg2NWQ1OQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-25T08:52:51Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-09-25T08:52:51Z"}, "message": "[multiple changes]\n\n2017-09-25  Doug Rupp  <rupp@adacore.com>\n\n\t* libgnarl/s-taprop__linux.adb (Compute_Base_Monotonic_Clock): Refine.\n\n2017-09-25  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_imgv.adb (Is_User_Defined_Enumeration_Type): New subprogram.\n\t(Expand_User_Defined_Enumeration_Image): New subprogram.\n\t(Expand_Image_Attribute): Enable speed-optimized expansion of\n\tuser-defined enumeration types when we are compiling with optimizations\n\tenabled.\n\n2017-09-25  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_util.adb (Has_Null_Abstract_State): Remove, as an exactly same\n\troutine is already provided by Einfo.\n\t* einfo.adb (Has_Null_Abstract_State): Replace with the body from\n\tSem_Util, which had better comments and avoided double calls to\n\tAbstract_State.\n\nFrom-SVN: r253138", "tree": {"sha": "e3811b8ab201c8f7bf6d12f899c3d7b960f13665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3811b8ab201c8f7bf6d12f899c3d7b960f13665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49742f9981bcb0c58c668b0ccc047a14d7865d59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49742f9981bcb0c58c668b0ccc047a14d7865d59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49742f9981bcb0c58c668b0ccc047a14d7865d59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49742f9981bcb0c58c668b0ccc047a14d7865d59/comments", "author": null, "committer": null, "parents": [{"sha": "7b6078223126fb3927b8199d9048e4f0cccc17e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b6078223126fb3927b8199d9048e4f0cccc17e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b6078223126fb3927b8199d9048e4f0cccc17e9"}], "stats": {"total": 253, "additions": 214, "deletions": 39}, "files": [{"sha": "e30918503997ca1053cad8615a3e53edeae65f97", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=49742f9981bcb0c58c668b0ccc047a14d7865d59", "patch": "@@ -1,3 +1,23 @@\n+2017-09-25  Doug Rupp  <rupp@adacore.com>\n+\n+\t* libgnarl/s-taprop__linux.adb (Compute_Base_Monotonic_Clock): Refine.\n+\n+2017-09-25  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_imgv.adb (Is_User_Defined_Enumeration_Type): New subprogram.\n+\t(Expand_User_Defined_Enumeration_Image): New subprogram.\n+\t(Expand_Image_Attribute): Enable speed-optimized expansion of\n+\tuser-defined enumeration types when we are compiling with optimizations\n+\tenabled.\n+\n+2017-09-25  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_util.adb (Has_Null_Abstract_State): Remove, as an exactly same\n+\troutine is already provided by Einfo.\n+\t* einfo.adb (Has_Null_Abstract_State): Replace with the body from\n+\tSem_Util, which had better comments and avoided double calls to\n+\tAbstract_State.\n+\n 2017-09-25  Bob Duff  <duff@adacore.com>\n \n \t* exp_ch3.adb: Rename Comp_Type_Simple to be Comp_Simple_Init."}, {"sha": "e947cba2088faa38abedca55addc50d748a2f83f", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=49742f9981bcb0c58c668b0ccc047a14d7865d59", "patch": "@@ -7707,12 +7707,17 @@ package body Einfo is\n    -----------------------------\n \n    function Has_Null_Abstract_State (Id : E) return B is\n-   begin\n       pragma Assert (Ekind_In (Id, E_Generic_Package, E_Package));\n \n+      States : constant Elist_Id := Abstract_States (Id);\n+\n+   begin\n+      --  Check first available state of related package. A null abstract\n+      --  state always appears as the sole element of the state list.\n+\n       return\n-        Present (Abstract_States (Id))\n-          and then Is_Null_State (Node (First_Elmt (Abstract_States (Id))));\n+        Present (States)\n+          and then Is_Null_State (Node (First_Elmt (States)));\n    end Has_Null_Abstract_State;\n \n    ---------------------------------"}, {"sha": "4f12a8c1d01785ad365630949595a844f30954f0", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 180, "deletions": 4, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=49742f9981bcb0c58c668b0ccc047a14d7865d59", "patch": "@@ -263,10 +263,176 @@ package body Exp_Imgv is\n    --  position of the enumeration value in the enumeration type.\n \n    procedure Expand_Image_Attribute (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Exprs     : constant List_Id    := Expressions (N);\n-      Pref      : constant Node_Id    := Prefix (N);\n-      Expr      : constant Node_Id    := Relocate_Node (First (Exprs));\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Exprs : constant List_Id    := Expressions (N);\n+      Expr  : constant Node_Id    := Relocate_Node (First (Exprs));\n+      Pref  : constant Node_Id    := Prefix (N);\n+\n+      function Is_User_Defined_Enumeration_Type\n+        (Typ : Entity_Id) return Boolean;\n+      --  Return True if Typ is an user-defined enumeration type\n+\n+      procedure Expand_User_Defined_Enumeration_Image;\n+      --  Expand attribute 'Image in user-defined enumeration types avoiding\n+      --  string copy.\n+\n+      -------------------------------------------\n+      -- Expand_User_Defined_Enumeration_Image --\n+      -------------------------------------------\n+\n+      procedure Expand_User_Defined_Enumeration_Image is\n+         Ins_List : constant List_Id   := New_List;\n+         P1_Id    : constant Entity_Id := Make_Temporary (Loc, 'P');\n+         P2_Id    : constant Entity_Id := Make_Temporary (Loc, 'P');\n+         P3_Id    : constant Entity_Id := Make_Temporary (Loc, 'P');\n+         P4_Id    : constant Entity_Id := Make_Temporary (Loc, 'P');\n+         Ptyp     : constant Entity_Id := Entity (Pref);\n+         Rtyp     : constant Entity_Id := Root_Type (Ptyp);\n+         S1_Id    : constant Entity_Id := Make_Temporary (Loc, 'S');\n+\n+      begin\n+         --  Apply a validity check, since it is a bit drastic to get a\n+         --  completely junk image value for an invalid value.\n+\n+         if not Expr_Known_Valid (Expr) then\n+            Insert_Valid_Check (Expr);\n+         end if;\n+\n+         --  Generate:\n+         --    P1 : constant Natural := Pos;\n+\n+         Append_To (Ins_List,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => P1_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (Standard_Natural, Loc),\n+             Constant_Present    => True,\n+             Expression =>\n+               Convert_To (Standard_Natural,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Pos,\n+                   Prefix         => New_Occurrence_Of (Ptyp, Loc),\n+                   Expressions    => New_List (Expr)))));\n+\n+         --  Compute the index of the string start generating:\n+         --    P2 : constant Natural := call_put_enumN (P1);\n+\n+         Append_To (Ins_List,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => P2_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (Standard_Natural, Loc),\n+             Constant_Present    => True,\n+             Expression =>\n+               Convert_To (Standard_Natural,\n+                 Make_Indexed_Component (Loc,\n+                   Prefix      =>\n+                     New_Occurrence_Of (Lit_Indexes (Rtyp), Loc),\n+                   Expressions =>\n+                     New_List (New_Occurrence_Of (P1_Id, Loc))))));\n+\n+         --  Compute the index of the next value generating:\n+         --    P3 : constant Natural := call_put_enumN (P1 + 1);\n+\n+         declare\n+            Add_Node : constant Node_Id := New_Op_Node (N_Op_Add, Loc);\n+\n+         begin\n+            Set_Left_Opnd  (Add_Node, New_Occurrence_Of (P1_Id, Loc));\n+            Set_Right_Opnd (Add_Node, Make_Integer_Literal (Loc, 1));\n+\n+            Append_To (Ins_List,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => P3_Id,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Standard_Natural, Loc),\n+                Constant_Present    => True,\n+                Expression =>\n+                  Convert_To (Standard_Natural,\n+                    Make_Indexed_Component (Loc,\n+                      Prefix      =>\n+                        New_Occurrence_Of (Lit_Indexes (Rtyp), Loc),\n+                      Expressions =>\n+                        New_List (Add_Node)))));\n+         end;\n+\n+         --  Generate:\n+         --    S4 : String renames call_put_enumS (S2 .. S3 - 1);\n+\n+         declare\n+            Sub_Node : constant Node_Id := New_Op_Node (N_Op_Subtract, Loc);\n+\n+         begin\n+            Set_Left_Opnd  (Sub_Node, New_Occurrence_Of (P3_Id, Loc));\n+            Set_Right_Opnd (Sub_Node, Make_Integer_Literal (Loc, 1));\n+\n+            Append_To (Ins_List,\n+              Make_Object_Renaming_Declaration (Loc,\n+                Defining_Identifier => P4_Id,\n+                Subtype_Mark        =>\n+                  New_Occurrence_Of (Standard_String, Loc),\n+                Name                =>\n+                  Make_Slice (Loc,\n+                    Prefix         =>\n+                      New_Occurrence_Of (Lit_Strings (Rtyp), Loc),\n+                    Discrete_Range =>\n+                      Make_Range (Loc,\n+                        Low_Bound  => New_Occurrence_Of (P2_Id, Loc),\n+                        High_Bound => Sub_Node))));\n+         end;\n+\n+         --  Generate:\n+         --    subtype S1 is string (1 .. P3 - P2);\n+\n+         declare\n+            HB : constant Node_Id := New_Op_Node (N_Op_Subtract, Loc);\n+\n+         begin\n+            Set_Left_Opnd  (HB, New_Occurrence_Of (P3_Id, Loc));\n+            Set_Right_Opnd (HB, New_Occurrence_Of (P2_Id, Loc));\n+\n+            Append_To (Ins_List,\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => S1_Id,\n+                Subtype_Indication  =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Occurrence_Of (Standard_String, Loc),\n+                    Constraint   =>\n+                      Make_Index_Or_Discriminant_Constraint (Loc,\n+                        Constraints => New_List (\n+                          Make_Range (Loc,\n+                            Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                            High_Bound => HB))))));\n+         end;\n+\n+         --  Insert all the above declarations before N. We suppress checks\n+         --  because everything is in range at this stage.\n+\n+         Insert_Actions (N, Ins_List, Suppress => All_Checks);\n+\n+         Rewrite (N,\n+           Unchecked_Convert_To (S1_Id,\n+             New_Occurrence_Of (P4_Id, Loc)));\n+         Analyze_And_Resolve (N, Standard_String);\n+      end Expand_User_Defined_Enumeration_Image;\n+\n+      --------------------------------------\n+      -- Is_User_Defined_Enumeration_Type --\n+      --------------------------------------\n+\n+      function Is_User_Defined_Enumeration_Type\n+        (Typ : Entity_Id) return Boolean is\n+      begin\n+         return Ekind (Typ) = E_Enumeration_Type\n+           and then Typ /= Standard_Boolean\n+           and then Typ /= Standard_Character\n+           and then Typ /= Standard_Wide_Character\n+           and then Typ /= Standard_Wide_Wide_Character;\n+      end Is_User_Defined_Enumeration_Type;\n+\n+      --  Local variables\n+\n       Imid      : RE_Id;\n       Ptyp      : Entity_Id;\n       Rtyp      : Entity_Id;\n@@ -288,6 +454,16 @@ package body Exp_Imgv is\n       if Is_Object_Image (Pref) then\n          Rewrite_Object_Image (N, Pref, Name_Image, Standard_String);\n          return;\n+\n+      --  Enable speed optimized expansion of user-defined enumeration types\n+      --  if we are compiling with optimizations enabled. Otherwise the call\n+      --  will be expanded into a call to the runtime library.\n+\n+      elsif Optimization_Level > 0\n+        and then Is_User_Defined_Enumeration_Type (Root_Type (Entity (Pref)))\n+      then\n+         Expand_User_Defined_Enumeration_Image;\n+         return;\n       end if;\n \n       Ptyp := Entity (Pref);"}, {"sha": "0be44edec7eacbb0a0bb4ddcbe3d64c540e0695e", "filename": "gcc/ada/libgnarl/s-taprop__linux.adb", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb?ref=49742f9981bcb0c58c668b0ccc047a14d7865d59", "patch": "@@ -38,7 +38,9 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Interfaces.C; use Interfaces; use type Interfaces.C.int;\n+with Interfaces.C; use Interfaces;\n+use type Interfaces.C.int;\n+use type Interfaces.C.long;\n \n with System.Task_Info;\n with System.Tasking.Debug;\n@@ -64,7 +66,6 @@ package body System.Task_Primitives.Operations is\n    use System.Parameters;\n    use System.OS_Primitives;\n    use System.Task_Info;\n-   use type Interfaces.C.long;\n \n    ----------------\n    -- Local Data --\n@@ -316,12 +317,9 @@ package body System.Task_Primitives.Operations is\n              TS_Aft0.tv_nsec - TS_Bef0.tv_nsec))\n             --  The most recent calls to clock_gettime were more better.\n          then\n-            TS_Bef0.tv_sec := TS_Bef.tv_sec;\n-            TS_Bef0.tv_nsec := TS_Bef.tv_nsec;\n-            TS_Aft0.tv_sec := TS_Aft.tv_sec;\n-            TS_Aft0.tv_nsec := TS_Aft.tv_nsec;\n-            TS_Mon0.tv_sec := TS_Mon.tv_sec;\n-            TS_Mon0.tv_nsec := TS_Mon.tv_nsec;\n+            TS_Bef0 := TS_Bef;\n+            TS_Aft0 := TS_Aft;\n+            TS_Mon0 := TS_Mon;\n          end if;\n       end loop;\n "}, {"sha": "20cda2d800ea2ce166790ca5a2c853adc85e14d7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49742f9981bcb0c58c668b0ccc047a14d7865d59/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=49742f9981bcb0c58c668b0ccc047a14d7865d59", "patch": "@@ -3138,34 +3138,10 @@ package body Sem_Util is\n    ---------------------------\n \n    procedure Check_No_Hidden_State (Id : Entity_Id) is\n-      function Has_Null_Abstract_State (Pkg : Entity_Id) return Boolean;\n-      --  Determine whether the entity of a package denoted by Pkg has a null\n-      --  abstract state.\n-\n-      -----------------------------\n-      -- Has_Null_Abstract_State --\n-      -----------------------------\n-\n-      function Has_Null_Abstract_State (Pkg : Entity_Id) return Boolean is\n-         States : constant Elist_Id := Abstract_States (Pkg);\n-\n-      begin\n-         --  Check first available state of related package. A null abstract\n-         --  state always appears as the sole element of the state list.\n-\n-         return\n-           Present (States)\n-             and then Is_Null_State (Node (First_Elmt (States)));\n-      end Has_Null_Abstract_State;\n-\n-      --  Local variables\n-\n       Context     : Entity_Id := Empty;\n       Not_Visible : Boolean   := False;\n       Scop        : Entity_Id;\n \n-   --  Start of processing for Check_No_Hidden_State\n-\n    begin\n       pragma Assert (Ekind_In (Id, E_Abstract_State, E_Variable));\n "}]}