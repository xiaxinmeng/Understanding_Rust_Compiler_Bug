{"sha": "a212a5d408ce85d717a166103601f596b58da9af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxMmE1ZDQwOGNlODVkNzE3YTE2NjEwMzYwMWY1OTZiNThkYTlhZg==", "commit": {"author": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2009-11-15T04:10:20Z"}, "committer": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2009-11-15T04:10:20Z"}, "message": "PR target/21078, 21080\n\nPR target/21078, 21080\n* config/avr/avr.c (avr_return_addr_rtx): New function for\nbuiltin_return_address.\n(expand_prologue): Calculate stack usage.\n(avr_asm_function_end_prologue): Output stack size and offset label.\n* config/avr/avr.h (RETURN_ADDR_RTX): Replace.\n(machine_function): Add stack_usage.\n* config/avr/avr-protos.h (avr_return_addr_rtx): New function.\n\nFrom-SVN: r154188", "tree": {"sha": "6acbfe49dc093b58ca7e058662c88af688c730d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6acbfe49dc093b58ca7e058662c88af688c730d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a212a5d408ce85d717a166103601f596b58da9af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a212a5d408ce85d717a166103601f596b58da9af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a212a5d408ce85d717a166103601f596b58da9af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a212a5d408ce85d717a166103601f596b58da9af/comments", "author": null, "committer": null, "parents": [{"sha": "de8caa8cf818f016d6ce5ad6bfade2c34426d6e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de8caa8cf818f016d6ce5ad6bfade2c34426d6e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de8caa8cf818f016d6ce5ad6bfade2c34426d6e6"}], "stats": {"total": 57, "additions": 55, "deletions": 2}, "files": [{"sha": "0ee4395b163cb706e9ad23cb5df3c57f7b5caa09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a212a5d408ce85d717a166103601f596b58da9af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a212a5d408ce85d717a166103601f596b58da9af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a212a5d408ce85d717a166103601f596b58da9af", "patch": "@@ -1,3 +1,14 @@\n+2009-11-14  Andy Hutchinson   <hutchinsonandy@gcc.gnu.org>\n+\n+\tPR target/21078, 21080\n+\t* config/avr/avr.c (avr_return_addr_rtx): New function for\n+\tbuiltin_return_address.\n+\t(expand_prologue): Calculate stack usage.\n+\t(avr_asm_function_end_prologue): Output stack size and offset label.\n+\t* config/avr/avr.h (RETURN_ADDR_RTX): Replace.\n+\t(machine_function): Add stack_usage.\n+\t* config/avr/avr-protos.h (avr_return_addr_rtx): New function.\n+\n 2009-11-14  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/iq2000/iq2000.c (iq2000_function_value): Make static, add"}, {"sha": "e014085ac34cb344a757001cc4d1108c3fd2e3ef", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a212a5d408ce85d717a166103601f596b58da9af/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a212a5d408ce85d717a166103601f596b58da9af/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=a212a5d408ce85d717a166103601f596b58da9af", "patch": "@@ -39,6 +39,7 @@ extern int avr_simple_epilogue (void);\n extern void gas_output_limited_string (FILE *file, const char *str);\n extern void gas_output_ascii (FILE *file, const char *str, size_t length);\n extern int avr_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern rtx avr_return_addr_rtx (int count, const_rtx tem);\n \n #ifdef TREE_CODE\n extern void asm_output_external (FILE *file, tree decl, char *name);"}, {"sha": "b1713a89c20621caa7232babac308202931d3ff0", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a212a5d408ce85d717a166103601f596b58da9af/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a212a5d408ce85d717a166103601f596b58da9af/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=a212a5d408ce85d717a166103601f596b58da9af", "patch": "@@ -461,6 +461,31 @@ rtx avr_builtin_setjmp_frame_value (void)\n \t\t\t gen_int_mode (STARTING_FRAME_OFFSET, Pmode));\n }\n \n+/* Return contents of MEM at frame pointer + stack size + 1 (+2 if 3 byte PC).\n+   This is return address of function.  */\n+rtx \n+avr_return_addr_rtx (int count, const_rtx tem)\n+{\n+  rtx r;\n+    \n+  /* Can only return this functions return address. Others not supported.  */\n+  if (count)\n+     return NULL;\n+\n+  if (AVR_3_BYTE_PC)\n+    {\n+      r = gen_rtx_SYMBOL_REF (Pmode, \".L__stack_usage+2\");\n+      warning (0, \"'builtin_return_address' contains only 2 bytes of address\");\n+    }\n+  else\n+    r = gen_rtx_SYMBOL_REF (Pmode, \".L__stack_usage+1\");\n+\n+  r = gen_rtx_PLUS (Pmode, tem, r);\n+  r = gen_frame_mem (Pmode, memory_address (Pmode, r));\n+  r = gen_rtx_ROTATE (HImode, r, GEN_INT (8));\n+  return  r;\n+}\n+\n /* Return 1 if the function epilogue is just a single \"ret\".  */\n \n int\n@@ -560,6 +585,7 @@ expand_prologue (void)\n   cfun->machine->is_signal = signal_function_p (current_function_decl);\n   cfun->machine->is_OS_task = avr_OS_task_function_p (current_function_decl);\n   cfun->machine->is_OS_main = avr_OS_main_function_p (current_function_decl);\n+  cfun->machine->stack_usage = 0;\n   \n   /* Prologue: naked.  */\n   if (cfun->machine->is_naked)\n@@ -588,17 +614,20 @@ expand_prologue (void)\n       /* Push zero reg.  */\n       insn = emit_move_insn (pushbyte, zero_reg_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      cfun->machine->stack_usage++;\n \n       /* Push tmp reg.  */\n       insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      cfun->machine->stack_usage++;\n \n       /* Push SREG.  */\n       insn = emit_move_insn (tmp_reg_rtx, \n                              gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      cfun->machine->stack_usage++;\n \n       /* Push RAMPZ.  */\n       if(AVR_HAVE_RAMPZ \n@@ -609,6 +638,7 @@ expand_prologue (void)\n           RTX_FRAME_RELATED_P (insn) = 1;\n           insn = emit_move_insn (pushbyte, tmp_reg_rtx);\n           RTX_FRAME_RELATED_P (insn) = 1;\n+          cfun->machine->stack_usage++;\n         }\n \t\n       /* Clear zero reg.  */\n@@ -630,6 +660,7 @@ expand_prologue (void)\n         emit_insn (gen_call_prologue_saves (gen_int_mode (live_seq, HImode),\n \t\t\t\t\t    gen_int_mode (size + live_seq, HImode)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      cfun->machine->stack_usage += size + live_seq;\n     }\n   else\n     {\n@@ -641,6 +672,7 @@ expand_prologue (void)\n               /* Emit push of register to save.  */\n               insn=emit_move_insn (pushbyte, gen_rtx_REG (QImode, reg));\n               RTX_FRAME_RELATED_P (insn) = 1;\n+              cfun->machine->stack_usage++;\n             }\n         }\n       if (frame_pointer_needed)\n@@ -650,6 +682,7 @@ expand_prologue (void)\n               /* Push frame pointer.  */\n \t      insn = emit_move_insn (pushword, frame_pointer_rtx);\n               RTX_FRAME_RELATED_P (insn) = 1;\n+\t      cfun->machine->stack_usage += 2;\n \t    }\n \n           if (!size)\n@@ -756,6 +789,7 @@ expand_prologue (void)\n \t\temit_insn (sp_plus_insns);\n               else\n \t\temit_insn (fp_plus_insns);\n+\t      cfun->machine->stack_usage += size;\n             }\n         }\n     }\n@@ -785,6 +819,11 @@ avr_asm_function_end_prologue (FILE *file)\n     }\n   fprintf (file, \"/* frame size = \" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n                  get_frame_size());\n+  fprintf (file, \"/* stack size = %d */\\n\",\n+                 cfun->machine->stack_usage);\n+  /* Create symbol stack offset here so all functions have it. Add 1 to stack\n+     usage for offset so that SP + .L__stack_offset = return address.  */\n+  fprintf (file, \".L__stack_usage = %d\\n\", cfun->machine->stack_usage);\n }\n \n "}, {"sha": "4e07a2ecdedf7354af90ab0fa750a4ce479a98f9", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a212a5d408ce85d717a166103601f596b58da9af/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a212a5d408ce85d717a166103601f596b58da9af/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=a212a5d408ce85d717a166103601f596b58da9af", "patch": "@@ -367,8 +367,7 @@ enum reg_class {\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n   OFFSET = avr_initial_elimination_offset (FROM, TO)\n \n-#define RETURN_ADDR_RTX(count, x) \\\n-  gen_rtx_MEM (Pmode, memory_address (Pmode, plus_constant (tem, 1)))\n+#define RETURN_ADDR_RTX(count, tem) avr_return_addr_rtx (count, tem)\n \n /* Don't use Push rounding. expr.c: emit_single_push_insn is broken \n    for POST_DEC targets (PR27386).  */\n@@ -857,4 +856,7 @@ struct GTY(()) machine_function\n   /* 'true' - if current function is a 'main' function \n      as specified by the \"OS_main\" attribute.  */\n   int is_OS_main;\n+  \n+  /* Current function stack size.  */\n+  int stack_usage;\n };"}]}