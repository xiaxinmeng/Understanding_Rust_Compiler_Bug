{"sha": "b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmZjRmNWMwZDYxZTUyZTI3YTA3MjdhZTllMDExYWFiNTI1Y2NmZA==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2018-10-30T19:59:41Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2018-10-30T19:59:41Z"}, "message": "Implement P0892R2, explicit(bool).\n\n\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_explicit_bool.\n\n\t* call.c (add_template_candidate_real): Return if the declaration is\n\texplicit and we're only looking for non-converting constructor.\n\t* cp-tree.h (lang_decl_fn): Add has_dependent_explicit_spec_p bit.\n\t(DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P): New macro.\n\t(cp_decl_specifier_seq): Add explicit_specifier field.\n\t(build_explicit_specifier, store_explicit_specifier): Declare.\n\t* decl.c (grokdeclarator): Call store_explicit_specifier.\n\t(build_explicit_specifier): New function.\n\t* parser.c (cp_parser_function_specifier_opt) <case RID_EXPLICIT>:\n\tParse C++20 explicit(bool).\n\t* pt.c (store_explicit_specifier, lookup_explicit_specifier): New.\n\t(tsubst_function_decl): Handle explicit(dependent-expr).\n\n\t* g++.dg/cpp2a/explicit1.C: New test.\n\t* g++.dg/cpp2a/explicit10.C: New test.\n\t* g++.dg/cpp2a/explicit11.C: New test.\n\t* g++.dg/cpp2a/explicit12.C: New test.\n\t* g++.dg/cpp2a/explicit13.C: New test.\n\t* g++.dg/cpp2a/explicit2.C: New test.\n\t* g++.dg/cpp2a/explicit3.C: New test.\n\t* g++.dg/cpp2a/explicit4.C: New test.\n\t* g++.dg/cpp2a/explicit5.C: New test.\n\t* g++.dg/cpp2a/explicit6.C: New test.\n\t* g++.dg/cpp2a/explicit7.C: New test.\n\t* g++.dg/cpp2a/explicit8.C: New test.\n\t* g++.dg/cpp2a/explicit9.C: New test.\n\n\t* testsuite/20_util/any/cons/explicit.cc: Adjust dg-error.\n\t* testsuite/20_util/pair/cons/explicit_construct.cc: Likewise.\n\t* testsuite/20_util/tuple/cons/explicit_construct.cc: Likewise.\n\nFrom-SVN: r265641", "tree": {"sha": "c6e4a49a90145c7f755d5dde23b9b457c4d25a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e4a49a90145c7f755d5dde23b9b457c4d25a0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d42623b370f4b3f11074ae783709c2b8a7fb65a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d42623b370f4b3f11074ae783709c2b8a7fb65a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d42623b370f4b3f11074ae783709c2b8a7fb65a"}], "stats": {"total": 707, "additions": 663, "deletions": 44}, "files": [{"sha": "ace36fb30e8d2116763c96528dd3bc10a5e58c1d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -1,3 +1,8 @@\n+2018-10-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tImplement P0892R2, explicit(bool).\n+\t* c-cppbuiltin.c (c_cpp_builtins): Define __cpp_explicit_bool.\n+\n 2018-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \t* name-hint.h (name_hint::take_deferred): New member function."}, {"sha": "b085cf9201fdf01c20185ea262b597cbca6306b7", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -955,7 +955,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t}\n       if (cxx_dialect > cxx14)\n \t{\n-\t  /* Set feature test macros for C++1z.  */\n+\t  /* Set feature test macros for C++17.  */\n \t  cpp_define (pfile, \"__cpp_unicode_characters=201411\");\n \t  cpp_define (pfile, \"__cpp_static_assert=201411\");\n \t  cpp_define (pfile, \"__cpp_namespace_attributes=201411\");\n@@ -975,6 +975,11 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_structured_bindings=201606\");\n \t  cpp_define (pfile, \"__cpp_variadic_using=201611\");\n \t}\n+      if (cxx_dialect > cxx17)\n+\t{\n+\t  /* Set feature test macros for C++2a.  */\n+\t  cpp_define (pfile, \"__cpp_explicit_bool=201806\");\n+\t}\n       if (flag_concepts)\n \tcpp_define (pfile, \"__cpp_concepts=201507\");\n       if (flag_tm)"}, {"sha": "d76d3177a1c5ffa6a9a3fed04069ac0602fe1dbf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -1,3 +1,19 @@\n+2018-10-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tImplement P0892R2, explicit(bool).\n+\t* call.c (add_template_candidate_real): Return if the declaration is\n+\texplicit and we're only looking for non-converting constructor.\n+\t* cp-tree.h (lang_decl_fn): Add has_dependent_explicit_spec_p bit.\n+\t(DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P): New macro.\n+\t(cp_decl_specifier_seq): Add explicit_specifier field.\n+\t(build_explicit_specifier, store_explicit_specifier): Declare.\n+\t* decl.c (grokdeclarator): Call store_explicit_specifier.\n+\t(build_explicit_specifier): New function.\n+\t* parser.c (cp_parser_function_specifier_opt) <case RID_EXPLICIT>:\n+\tParse C++20 explicit(bool).\n+\t* pt.c (store_explicit_specifier, lookup_explicit_specifier): New.\n+\t(tsubst_function_decl): Handle explicit(dependent-expr).\n+\n 2018-10-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (grokdeclarator): Use declarator->id_loc in diagnostic"}, {"sha": "6f401567c2e198674204e0d265ed67a57f3e45f2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -3251,6 +3251,12 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n       goto fail;\n     }\n \n+  /* Now the explicit specifier might have been deduced; check if this\n+     declaration is explicit.  If it is and we're ignoring non-converting\n+     constructors, don't add this function to the set of candidates.  */\n+  if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (fn))\n+    return NULL;\n+\n   if (DECL_CONSTRUCTOR_P (fn) && nargs == 2)\n     {\n       tree arg_types = FUNCTION_FIRST_USER_PARMTYPE (fn);"}, {"sha": "c9427a0b624d921ed3c30cb71c991c87aa5dbf78", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -2587,7 +2587,8 @@ struct GTY(()) lang_decl_fn {\n   unsigned this_thunk_p : 1;\n   unsigned hidden_friend_p : 1;\n   unsigned omp_declare_reduction_p : 1;\n-  unsigned spare : 13;\n+  unsigned has_dependent_explicit_spec_p : 1;\n+  unsigned spare : 12;\n \n   /* 32-bits padding on 64-bit host.  */\n \n@@ -3033,6 +3034,12 @@ struct GTY(()) lang_decl {\n #define DECL_PURE_VIRTUAL_P(NODE) \\\n   (LANG_DECL_FN_CHECK (NODE)->pure_virtual)\n \n+/* Nonzero for FUNCTION_DECL means that this member function (either\n+   a constructor or a conversion function) has an explicit specifier\n+   with a value-dependent expression.  */\n+#define DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P(NODE) \\\n+  (LANG_DECL_FN_CHECK (NODE)->has_dependent_explicit_spec_p)\n+\n /* True (in a FUNCTION_DECL) if NODE is a virtual function that is an\n    invalid overrider for a function from a base class.  Once we have\n    complained about an invalid overrider we avoid complaining about it\n@@ -5748,6 +5755,8 @@ struct cp_decl_specifier_seq {\n   /* If non-NULL, a built-in type that the user attempted to redefine\n      to some other type.  */\n   tree redefined_builtin_type;\n+  /* The explicit-specifier, if any.  */\n+  tree explicit_specifier;\n   /* The storage class specified -- or sc_none if no storage class was\n      explicitly specified.  */\n   cp_storage_class storage_class;\n@@ -6375,6 +6384,7 @@ extern tree cxx_maybe_build_cleanup\t\t(tree, tsubst_flags_t);\n extern bool check_array_designated_initializer  (constructor_elt *,\n \t\t\t\t\t\t unsigned HOST_WIDE_INT);\n extern bool check_for_uninitialized_const_var   (tree, bool, tsubst_flags_t);\n+extern tree build_explicit_specifier\t\t(tree, tsubst_flags_t);\n \n /* in decl2.c */\n extern void record_mangling\t\t\t(tree, bool);\n@@ -6772,6 +6782,7 @@ extern bool dguide_name_p\t\t\t(tree);\n extern bool deduction_guide_p\t\t\t(const_tree);\n extern bool copy_guide_p\t\t\t(const_tree);\n extern bool template_guide_p\t\t\t(const_tree);\n+extern void store_explicit_specifier\t\t(tree, tree);\n \n /* in repo.c */\n extern void init_repo\t\t\t\t(void);"}, {"sha": "11320b65e715ffcc1fe15c4f888c09bf2b122e52", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -12382,6 +12382,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t       is called a converting constructor.  */\n \t    if (explicitp == 2)\n \t      DECL_NONCONVERTING_P (decl) = 1;\n+\n+\t    if (declspecs->explicit_specifier)\n+\t      store_explicit_specifier (decl, declspecs->explicit_specifier);\n \t  }\n \telse if (!staticp && !dependent_type_p (type)\n \t\t && !COMPLETE_TYPE_P (complete_type (type))\n@@ -16562,4 +16565,20 @@ require_deduced_type (tree decl, tsubst_flags_t complain)\n   return true;\n }\n \n+/* Create a representation of the explicit-specifier with\n+   constant-expression of EXPR.  COMPLAIN is as for tsubst.  */\n+\n+tree\n+build_explicit_specifier (tree expr, tsubst_flags_t complain)\n+{\n+  if (processing_template_decl && value_dependent_expression_p (expr))\n+    /* Wait for instantiation, tsubst_function_decl will handle it.  */\n+    return expr;\n+\n+  expr = build_converted_constant_expr (boolean_type_node, expr, complain);\n+  expr = instantiate_non_dependent_expr (expr);\n+  expr = cxx_constant_value (expr);\n+  return expr;\n+}\n+\n #include \"gt-cp-decl.h\""}, {"sha": "206ceb048d41e3e5f0ce9dc1f2bb072c4c0a1fe4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -13897,6 +13897,9 @@ cp_parser_storage_class_specifier_opt (cp_parser* parser)\n      virtual\n      explicit\n \n+   C++2A Extension:\n+     explicit(constant-expression)\n+\n    Returns an IDENTIFIER_NODE corresponding to the keyword used.\n    Updates DECL_SPECS, if it is non-NULL.  */\n \n@@ -13923,8 +13926,53 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n       break;\n \n     case RID_EXPLICIT:\n-      set_and_check_decl_spec_loc (decl_specs, ds_explicit, token);\n-      break;\n+      {\n+\ttree id = cp_lexer_consume_token (parser->lexer)->u.value;\n+\t/* If we see '(', it's C++20 explicit(bool).  */\n+\ttree expr;\n+\tif (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+\t  {\n+\t    matching_parens parens;\n+\t    parens.consume_open (parser);\n+\n+\t    /* New types are not allowed in an explicit-specifier.  */\n+\t    const char *saved_message\n+\t      = parser->type_definition_forbidden_message;\n+\t    parser->type_definition_forbidden_message\n+\t      = G_(\"types may not be defined in explicit-specifier\");\n+\n+\t    if (cxx_dialect < cxx2a)\n+\t      pedwarn (token->location, 0,\n+\t\t       \"%<explicit(bool)%> only available with -std=c++2a \"\n+\t\t       \"or -std=gnu++2a\");\n+\n+\t    /* Parse the constant-expression.  */\n+\t    expr = cp_parser_constant_expression (parser);\n+\n+\t    /* Restore the saved message.  */\n+\t    parser->type_definition_forbidden_message = saved_message;\n+\t    parens.require_close (parser);\n+\t  }\n+\telse\n+\t  /* The explicit-specifier explicit without a constant-expression is\n+\t     equivalent to the explicit-specifier explicit(true).  */\n+\t  expr = boolean_true_node;\n+\n+\t/* [dcl.fct.spec]\n+\t   \"the constant-expression, if supplied, shall be a contextually\n+\t   converted constant expression of type bool.\"  */\n+\texpr = build_explicit_specifier (expr, tf_warning_or_error);\n+\t/* We could evaluate it -- mark the decl as appropriate.  */\n+\tif (expr == boolean_true_node)\n+\t  set_and_check_decl_spec_loc (decl_specs, ds_explicit, token);\n+\telse if (expr == boolean_false_node)\n+\t  /* Don't mark the decl as explicit.  */;\n+\telse if (decl_specs)\n+\t  /* The expression was value-dependent.  Remember it so that we can\n+\t     substitute it later.  */\n+\t  decl_specs->explicit_specifier = expr;\n+\treturn id;\n+      }\n \n     default:\n       return NULL_TREE;"}, {"sha": "fc6cf98950195af21b008ab8c654dcb79be5bd48", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -12803,6 +12803,28 @@ tsubst_default_arguments (tree fn, tsubst_flags_t complain)\n \t\t\t\t\t\t    complain);\n }\n \n+/* Hash table mapping a FUNCTION_DECL to its dependent explicit-specifier.  */\n+static GTY((cache)) tree_cache_map *explicit_specifier_map;\n+\n+/* Store a pair to EXPLICIT_SPECIFIER_MAP.  */\n+\n+void\n+store_explicit_specifier (tree v, tree t)\n+{\n+  if (!explicit_specifier_map)\n+    explicit_specifier_map = tree_cache_map::create_ggc (37);\n+  DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P (v) = true;\n+  explicit_specifier_map->put (v, t);\n+}\n+\n+/* Lookup an element in EXPLICIT_SPECIFIER_MAP.  */\n+\n+static tree\n+lookup_explicit_specifier (tree v)\n+{\n+  return *explicit_specifier_map->get (v);\n+}\n+\n /* Subroutine of tsubst_decl for the case when T is a FUNCTION_DECL.  */\n \n static tree\n@@ -12943,6 +12965,17 @@ tsubst_function_decl (tree t, tree args, tsubst_flags_t complain,\n     DECL_INITIAL (r) = NULL_TREE;\n   DECL_CONTEXT (r) = ctx;\n \n+  /* Handle explicit(dependent-expr).  */\n+  if (DECL_HAS_DEPENDENT_EXPLICIT_SPEC_P (t))\n+    {\n+      tree spec = lookup_explicit_specifier (t);\n+      spec = tsubst_copy_and_build (spec, args, complain, in_decl,\n+\t\t\t\t    /*function_p=*/false,\n+\t\t\t\t    /*i_c_e_p=*/true);\n+      spec = build_explicit_specifier (spec, complain);\n+      DECL_NONCONVERTING_P (r) = (spec == boolean_true_node);\n+    }\n+\n   /* OpenMP UDRs have the only argument a reference to the declared\n      type.  We want to diagnose if the declared type is a reference,\n      which is invalid, but as references to references are usually"}, {"sha": "cab592771963b921f41cace0983e141333356426", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -1,3 +1,20 @@\n+2018-10-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tImplement P0892R2, explicit(bool).\n+\t* g++.dg/cpp2a/explicit1.C: New test.\n+\t* g++.dg/cpp2a/explicit10.C: New test.\n+\t* g++.dg/cpp2a/explicit11.C: New test.\n+\t* g++.dg/cpp2a/explicit12.C: New test.\n+\t* g++.dg/cpp2a/explicit13.C: New test.\n+\t* g++.dg/cpp2a/explicit2.C: New test.\n+\t* g++.dg/cpp2a/explicit3.C: New test.\n+\t* g++.dg/cpp2a/explicit4.C: New test.\n+\t* g++.dg/cpp2a/explicit5.C: New test.\n+\t* g++.dg/cpp2a/explicit6.C: New test.\n+\t* g++.dg/cpp2a/explicit7.C: New test.\n+\t* g++.dg/cpp2a/explicit8.C: New test.\n+\t* g++.dg/cpp2a/explicit9.C: New test.\n+\n 2018-10-30  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/87708"}, {"sha": "b39f90f3397fbbe208d6090e7529626329f5e216", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit1.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit1.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,63 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+constexpr int fn0 () { return 0; }\n+constexpr int fn1 () { return 1; }\n+\n+struct S {\n+  explicit(true) S(int);\n+  explicit(1 == 0) S(int, int);\n+  explicit(fn0()) S(int, int, int);\n+  explicit(fn1()) S(int, int, int, int);\n+};\n+\n+struct X {\n+  static const bool value = true;\n+  static constexpr bool foo () { return 1; }\n+};\n+\n+struct T {\n+  explicit(true ? 1 : throw 1) T(int);\n+  explicit(true || true ? 1 : throw 1) T(int, int);\n+  explicit(X::value) T(int, int, int);\n+  explicit(X::foo ()) T(int, int, int, int);\n+};\n+\n+struct W {\n+  constexpr operator bool() { return true; };\n+};\n+\n+struct W2 {\n+  constexpr operator bool() { return false; };\n+};\n+\n+struct U {\n+  explicit(W()) U(int);\n+  explicit(W2()) U(int, int);\n+};\n+\n+int\n+main ()\n+{\n+  S s1 = { 1 }; // { dg-error \"converting\" }\n+  S s1x{ 1 };\n+  S s2 = { 2, 3 };\n+  S s3 = { 4, 5, 6 };\n+  S s4 = { 7, 8, 9, 10 }; // { dg-error \"converting\" }\n+  S s4x{ 7, 8, 9, 10 };\n+\n+  T t1 = { 1 }; // { dg-error \"converting\" }\n+  T t2 = { 1, 2 }; // { dg-error \"converting\" }\n+  T t3 = { 1, 2, 3 }; // { dg-error \"converting\" }\n+  T t4 = { 1, 2, 3, 4 }; // { dg-error \"converting\" }\n+  T t5{ 1 };\n+  T t6{ 1, 2 };\n+  T t7{ 1, 2, 3 };\n+  T t8{ 1, 2, 3, 4 };\n+\n+  U u1 = { 1 }; // { dg-error \"converting\" }\n+  U u2{ 1 };\n+  U u3 = { 1, 2 };\n+  U u4 { 1, 2 };\n+}"}, {"sha": "c8701551c9af5b0d383c04a25b1ec3aeed4a88e7", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit10.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit10.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,32 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+#include <type_traits>\n+\n+class A {};\n+class B : public A {};\n+class C {};\n+class D { public: operator C() { return c; }  C c; };\n+\n+template <typename T1, typename T2>\n+struct S {\n+  explicit(!std::is_convertible_v<T1, T2>)\n+  S(T1, T2) { }\n+};\n+\n+void\n+foo ()\n+{\n+  A a;\n+  B b;\n+  C c;\n+  D d;\n+\n+  S<int, int> s{ 1, 2 };\n+  S<int, int> s2 = { 1, 2 };\n+  S<B*, A*> s3 = { &b, &a };\n+  S<A*, B*> s4 = { &a, &b }; // { dg-error \"converting\" }\n+  S<B*, C*> s5 = { &b, &c }; // { dg-error \"converting\" }\n+  S<D, C> s6 = { d, c };\n+}"}, {"sha": "ad1bed5b3f063678386b35e25838b1bdf49d7878", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit11.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit11.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,29 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -pedantic\" }\n+\n+template<typename T>\n+struct A {\n+  explicit A(const T&, ...) noexcept;\n+  A(T&&, ...);\n+};\n+\n+int i;\n+A a1 = { i, i }; // { dg-error \"deduction|cannot\" }\n+A a2{ i, i };\n+A a3{ 0, i };\n+A a4 = { 0, i };\n+\n+template<typename T> A(const T&, const T&) -> A<T&>;\n+template<typename T> explicit A(T&&, T&&) -> A<T>;\n+\n+A a5 = { 0, 1 }; // { dg-error \"deduction|ambiguous\" }\n+A a6{ 0, 1 };\n+\n+template<typename T>\n+struct B {\n+  template<typename U> using TA = T;\n+  template<typename U> B(U, TA<U>);\n+};\n+\n+B b{(int *)0, (char *)0};"}, {"sha": "6db3157580bb9fb6b61f4fae7a78593ebbf69cde", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit12.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit12.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,23 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+template<typename> struct A {\n+  template<typename T, int N = 0>\n+  explicit(N) operator T();\n+};\n+\n+template<typename> struct B {\n+  template<typename T, int N = 1>\n+  explicit(N) operator T();\n+};\n+\n+void\n+bar ()\n+{\n+  A<int> a;\n+  int i = a;\n+\n+  B<int> b;\n+  int j = b; // { dg-error \"cannot convert\" }\n+}"}, {"sha": "4747ebd3df4a3cd81f0d9a2acdfecf730bd9ea4f", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit13.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit13.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,35 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+template<int M = 0> struct A {\n+  template<typename T, int N = 0>\n+  explicit(N + M) operator T();\n+};\n+\n+template<int M = 1> struct B {\n+  template<typename T, int N = 1>\n+  explicit(N * M) operator T();\n+};\n+\n+void\n+bar ()\n+{\n+  A a;\n+  int i = a;\n+\n+  A<0> a0;\n+  int i0 = a0;\n+\n+  A<1> a1;\n+  int i1 = a1; // { dg-error \"cannot convert\" }\n+\n+  B b;\n+  int j = b; // { dg-error \"cannot convert\" }\n+\n+  B<0> b0;\n+  int j0 = b0;\n+\n+  B<1> b1;\n+  int j1 = b1; // { dg-error \"cannot convert\" }\n+}"}, {"sha": "7d1748c0f5e3def47197295cc45cb05d8edda96f", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit2.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit2.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,25 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+int foo() { return 42; }\n+int g;\n+\n+struct S {\n+  explicit(foo()) S(int); // { dg-error \"call to\" }\n+  explicit(int) S(int, int); // { dg-error \"expected\" }\n+  explicit(false ? 1 : throw 1) S(int, int, int); // { dg-error \"not a constant\" }\n+};\n+\n+struct S2 {\n+  explicit(true) S2();\n+  explicit(false) S2(); // { dg-error \"cannot be overloaded\" }\n+};\n+\n+int\n+main ()\n+{\n+  S s1 = { 1 };\n+  S s2 = { 1, 2 }; // { dg-error \"could not convert\" }\n+  S s3 = { 1, 2, 3 };\n+}"}, {"sha": "7c495a3640bcf38d64e990f7efc5e6cd24f7af97", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit3.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,24 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+#include <type_traits>\n+\n+template <typename T1, typename T2>\n+struct pair {\n+    template <typename U1=T1, typename U2=T2,\n+        std::enable_if_t<\n+            std::is_constructible_v<T1, U1> &&\n+            std::is_constructible_v<T2, U2>\n+        , int> = 0>\n+    explicit(!std::is_convertible_v<U1, T1> ||\n+        !std::is_convertible_v<U2, T2>)\n+    constexpr pair(U1&&, U2&&) { }\n+};\n+\n+void\n+foo ()\n+{\n+  pair<int, int> p{1, 2};\n+  pair<int, int> p2 = {1, 2};\n+}"}, {"sha": "822a1f155b4b895d803b7ce2fceec99731e622f3", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit4.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit4.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,41 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+template<int T = 1>\n+struct S {\n+  explicit(T) S(int);\n+  explicit(!T) S(int, int);\n+};\n+\n+template<typename T, int N>\n+struct S2 {\n+  explicit(N) S2(T);\n+};\n+\n+template<typename T>\n+struct S3 {\n+  explicit((T) 1.0) S3(int);\n+};\n+\n+int\n+main ()\n+{\n+  S<> s1 = { 1 }; // { dg-error \"converting\" }\n+  S<true> s2 = { 1 }; // { dg-error \"converting\" }\n+  S<false> s3 = { 1 };\n+  S<> s4{ 1 };\n+  S<true> s5{ 1 };\n+  S<> s6 = { 1, 2 };\n+  S<true> s7 = { 1, 2 };\n+  S<false> s8 = { 1, 2 }; // { dg-error \"converting\" }\n+  S<false> s9{ 1, 2 };\n+\n+  const int x = 1;\n+  S<x> s10 = { 1 }; // { dg-error \"converting\" }\n+  S<x> s11{ 2 };\n+\n+  S2<int, true> s12 = { 1 }; // { dg-error \"converting\" }\n+\n+  S3<int> s13 = { 1 }; // { dg-error \"converting\" }\n+}"}, {"sha": "70a106f1fcb25d9c4a353858ddb5966c3bc8a100", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit5.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit5.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,71 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+constexpr int fn0 () { return 0; }\n+constexpr int fn1 () { return 1; }\n+\n+struct S0 {\n+  explicit(false) operator int();\n+  explicit(1 == 0) operator double();\n+  explicit(fn0()) operator char();\n+};\n+\n+struct S1 {\n+  explicit(true) operator int();\n+  explicit(1 == 1) operator double();\n+  explicit(fn1()) operator char();\n+};\n+\n+struct X {\n+  static const bool value = true;\n+  static constexpr bool foo () { return 1; }\n+};\n+\n+struct T {\n+  explicit(true ? 1 : throw 1) operator int();\n+  explicit(true || true ? 1 : throw 1) operator double();\n+  explicit(X::value) operator char();\n+  explicit(X::foo ()) operator long();\n+};\n+\n+struct W {\n+  constexpr operator bool() { return true; };\n+};\n+\n+struct W2 {\n+  constexpr operator bool() { return false; };\n+};\n+\n+struct U1 {\n+  explicit(W()) operator int();\n+};\n+\n+struct U2 {\n+  explicit(W2()) operator int();\n+};\n+\n+int\n+main ()\n+{\n+  S0 s0;\n+  S1 s1;\n+  int i0 = s0;\n+  int i1 = s1; // { dg-error \"cannot convert\" }\n+  double d0 = s0;\n+  double d1 = s1; // { dg-error \"cannot convert\" }\n+  char c0 = s0;\n+  char c1 = s1; // { dg-error \"cannot convert\" }\n+\n+  T t;\n+  int i2 = t; // { dg-error \"cannot convert\" }\n+  double d2 = t; // { dg-error \"cannot convert\" }\n+  char c2 = t; // { dg-error \"cannot convert\" }\n+  long l1 = t; // { dg-error \"cannot convert\" }\n+\n+  U1 u1;\n+  int i3 = u1; // { dg-error \"cannot convert\" }\n+\n+  U2 u2;\n+  int i4 = u2;\n+}"}, {"sha": "10134680ed312e3fac9953078e5923becc033213", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit6.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit6.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,41 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+template<int T = 1>\n+struct S {\n+  explicit(T) operator int();\n+};\n+\n+template<typename T, int N>\n+struct R {\n+  explicit(N) operator T();\n+};\n+\n+template<typename T>\n+struct U {\n+  explicit((T) 1.0) operator T();\n+};\n+\n+int\n+main ()\n+{\n+  S s;\n+  int i1 = s; // { dg-error \"cannot convert\" }\n+  S<true> s2;\n+  int i2 = s2; // { dg-error \"cannot convert\" }\n+  S<false> s3;\n+  int i3 = s3;\n+  int i4{s};\n+  int i5{s2};\n+  int i6{s3};\n+\n+  R<int, true> r;\n+  int i7 = r; // { dg-error \"cannot convert\" }\n+  R<int, false> r2;\n+  int i8 = r2;\n+\n+  U<int> u;\n+  int i9 = u; // { dg-error \"cannot convert\" }\n+  int i10{u};\n+}"}, {"sha": "dfa4e138d4cb0364152bd514b5b3c517b6a57828", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit7.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit7.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,22 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+template<typename T>\n+struct B {\n+  static const T value = true;\n+};\n+\n+struct X {\n+  template<typename T>\n+  explicit(B<T>::value) operator T();\n+};\n+\n+int\n+main ()\n+{\n+  X x;\n+  int i = x.operator int();\n+  int i3 = x; // { dg-error \"cannot convert\" }\n+  int i2{x};\n+}"}, {"sha": "bf2f9ed99177130530b6de8af5a87be051a759bb", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit8.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit8.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,24 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a\" }\n+\n+struct X {\n+  template<typename T, int N = 1>\n+  explicit(N) operator T();\n+};\n+\n+int\n+main ()\n+{\n+  X x;\n+  int i = x; // { dg-error \"cannot convert\" }\n+  int i2{x};\n+  double d = x; // { dg-error \"cannot convert\" }\n+  double d2{x};\n+  char c = x; // { dg-error \"cannot convert\" }\n+  char c2{x};\n+  long l = x; // { dg-error \"cannot convert\" }\n+  long l2{x};\n+  int *p = x; // { dg-error \"cannot convert\" }\n+  int *p2{x};\n+}"}, {"sha": "6568e5c6661f942195e05c2dc806d7608eaa71ff", "filename": "gcc/testsuite/g++.dg/cpp2a/explicit9.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fexplicit9.C?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -0,0 +1,22 @@\n+// P0892R2\n+// { dg-do compile }\n+// { dg-options \"-std=c++2a -fconcepts\" }\n+\n+#include <type_traits>\n+\n+template <typename T1, typename T2>\n+struct pair {\n+    template <typename U1=T1, typename U2=T2>\n+        requires std::is_constructible_v<T1, U1> &&\n+            std::is_constructible_v<T2, U2>\n+    explicit(!std::is_convertible_v<U1, T1> ||\n+        !std::is_convertible_v<U2, T2>)\n+    constexpr pair(U1&&, U2&&) { }\n+};\n+\n+void\n+foo ()\n+{\n+  pair<int, int> p{1, 2};\n+  pair<int, int> p2 = {1, 2};\n+}"}, {"sha": "d9d4f0e64e0fbf557968c080aef302010fa874f1", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -1,3 +1,10 @@\n+2018-10-30  Marek Polacek  <polacek@redhat.com>\n+\n+\tImplement P0892R2, explicit(bool).\n+\t* testsuite/20_util/any/cons/explicit.cc: Adjust dg-error.\n+\t* testsuite/20_util/pair/cons/explicit_construct.cc: Likewise.\n+\t* testsuite/20_util/tuple/cons/explicit_construct.cc: Likewise.\n+\n 2018-10-30  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/87809"}, {"sha": "3c13a86a2c9a838eceaa561c18d4c4c1d31ea6cc", "filename": "libstdc++-v3/testsuite/20_util/any/cons/explicit.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fany%2Fcons%2Fexplicit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fany%2Fcons%2Fexplicit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fany%2Fcons%2Fexplicit.cc?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -24,7 +24,7 @@\n \n int main()\n {\n-  std::any a = {std::in_place_type<int>, 42}; // { dg-error \"converting\" }\n+  std::any a = {std::in_place_type<int>, 42}; // { dg-error \"convert\" }\n   std::any a2 = {std::in_place_type<std::vector<int>>,\n-\t\t {42, 666}}; // { dg-error \"converting\" }\n+\t\t {42, 666}}; // { dg-error \"convert\" }\n }"}, {"sha": "6185ed6cdbcea69b1ec4b8c4c7865fda061af5f6", "filename": "libstdc++-v3/testsuite/20_util/pair/cons/explicit_construct.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpair%2Fcons%2Fexplicit_construct.cc?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -37,7 +37,7 @@ struct ExplicitDefaultDefault\n \n std::pair<int, int> f1() {return {1,2};}\n \n-std::pair<Explicit, Explicit> f2() {return {1,2};} // { dg-error \"explicit\" }\n+std::pair<Explicit, Explicit> f2() {return {1,2};} // { dg-error \"could not convert\" }\n \n std::pair<long, long> f3() {return std::pair<int, int>{1,2};}\n \n@@ -52,7 +52,7 @@ std::pair<int, int> v0{1,2};\n \n std::pair<Explicit, Explicit> v1{1,2};\n \n-std::pair<Explicit, Explicit> v2 = {1,2}; // { dg-error \"explicit\" }\n+std::pair<Explicit, Explicit> v2 = {1,2}; // { dg-error \"could not convert\" }\n \n std::pair<Explicit, Explicit> v3{std::pair<int,int>{1,2}};\n \n@@ -83,12 +83,12 @@ void f7(std::pair<long, long>) {}\n \n std::pair<ExplicitDefault, int> f8()\n {\n-  return {}; // { dg-error \"explicit\" }\n+  return {}; // { dg-error \"could not convert\" }\n }\n \n std::pair<ExplicitDefaultDefault, int> f9()\n {\n-  return {}; // { dg-error \"explicit\" }\n+  return {}; // { dg-error \"could not convert\" }\n }\n \n void f10(std::pair<ExplicitDefault, int>) {}\n@@ -99,16 +99,16 @@ void test_arg_passing()\n {\n   f6(v0); // { dg-error \"could not convert\" }\n   f6(v1);\n-  f6({1,2}); // { dg-error \"explicit\" }\n+  f6({1,2}); // { dg-error \"could not convert\" }\n   f6(std::pair<Explicit, Explicit>{});\n   f6(std::pair<int, int>{}); // { dg-error \"could not convert\" }\n   f7(v0);\n   f7(v6);\n   f7({1,2});\n   f7(std::pair<int, int>{});\n   f7(std::pair<long, long>{});\n-  f10({}); // { dg-error \"explicit\" }\n-  f11({}); // { dg-error \"explicit\" }\n+  f10({}); // { dg-error \"could not convert\" }\n+  f11({}); // { dg-error \"could not convert\" }\n   f10(std::pair<ExplicitDefault, int>{});\n   f11(std::pair<ExplicitDefaultDefault, int>{});\n }\n@@ -130,6 +130,6 @@ std::pair<int*, ExplicitMoveOnly> v14{0, MoveOnly{}};\n std::pair<ExplicitMoveOnly, int*> v15{MoveOnly{}, 0};\n \n std::pair<int*, ExplicitMoveOnly> v16 =\n-  {0, MoveOnly{}}; // { dg-error \"explicit\" }\n+  {0, MoveOnly{}}; // { dg-error \"could not convert\" }\n std::pair<ExplicitMoveOnly, int*> v17 =\n-  {MoveOnly{}, 0}; // { dg-error \"explicit\" }\n+  {MoveOnly{}, 0}; // { dg-error \"could not convert\" }"}, {"sha": "6874be40f71c59fb22e54beebcfa93bceee403ba", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/explicit_construct.cc", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fexplicit_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fexplicit_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fexplicit_construct.cc?ref=b5ff4f5c0d61e52e27a0727ae9e011aab525ccfd", "patch": "@@ -43,11 +43,11 @@ std::tuple<int, int> f1b() {return {1,2};}\n std::tuple<int, int, int> f1c() {return {1,2,3};}\n \n std::tuple<Explicit> f2_a()\n-{return {1};} // { dg-error \"explicit\" }\n+{return {1};} // { dg-error \"could not convert\" }\n std::tuple<Explicit, Explicit> f2_b()\n-{return {1,2};} // { dg-error \"explicit\" }\n+{return {1,2};} // { dg-error \"could not convert\" }\n std::tuple<Explicit, Explicit, Explicit> f2_c()\n-{return {1,2,3};} // { dg-error \"explicit\" }\n+{return {1,2,3};} // { dg-error \"could not convert\" }\n \n std::tuple<long> f3_a() {return std::tuple<int>{1};}\n std::tuple<long, long> f3_b() {return std::tuple<int, int>{1,2};}\n@@ -71,22 +71,22 @@ std::tuple<long, long> f5_b() {return {1,2};}\n std::tuple<long, long, long> f5_c() {return {1,2,3};}\n \n std::tuple<ExplicitDefault> f6_a()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n std::tuple<ExplicitDefault, ExplicitDefault> f6_b()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n std::tuple<ExplicitDefault, ExplicitDefault, ExplicitDefault> f6_c()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n std::tuple<ExplicitDefault, int> f6_d()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n \n std::tuple<ExplicitDefaultDefault> f7_a()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n std::tuple<ExplicitDefaultDefault, ExplicitDefaultDefault> f7_b()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n std::tuple<ExplicitDefaultDefault,\n            ExplicitDefaultDefault,\n            ExplicitDefaultDefault> f7_c()\n-{return {};} // { dg-error \"explicit\" }\n+{return {};} // { dg-error \"could not convert\" }\n \n std::tuple<int, int> fp1() {return std::pair<int, int>{1,2}; }\n std::tuple<long, long> fp2() {return std::pair<int, int>{1,2}; }\n@@ -101,9 +101,9 @@ std::tuple<Explicit> v1_a{1};\n std::tuple<Explicit, Explicit> v1_b{1,2};\n std::tuple<Explicit, Explicit, Explicit> v1_c{1,2,3};\n \n-std::tuple<Explicit> v2_a = {1}; // { dg-error \"explicit\" }\n-std::tuple<Explicit, Explicit> v2_b = {1,2}; // { dg-error \"explicit\" }\n-std::tuple<Explicit, Explicit, Explicit> v2_c = {1,2,3}; // { dg-error \"explicit\" }\n+std::tuple<Explicit> v2_a = {1}; // { dg-error \"could not convert\" }\n+std::tuple<Explicit, Explicit> v2_b = {1,2}; // { dg-error \"could not convert\" }\n+std::tuple<Explicit, Explicit, Explicit> v2_c = {1,2,3}; // { dg-error \"could not convert\" }\n \n std::tuple<Explicit> v3_a{std::tuple<int>{1}};\n std::tuple<Explicit, Explicit> v3_b{std::tuple<int,int>{1,2}};\n@@ -194,11 +194,11 @@ std::tuple<long, long, long>\n   v31_c{std::allocator_arg, std::allocator<int>{}, 1,2,3};\n \n std::tuple<Explicit> v32_a\n-  = {std::allocator_arg, std::allocator<int>{ }, 1}; // { dg-error \"explicit\" }\n+  = {std::allocator_arg, std::allocator<int>{ }, 1}; // { dg-error \"could not convert\" }\n std::tuple<Explicit, Explicit> v32_b\n-  = {std::allocator_arg, std::allocator<int>{}, 1, 2}; // { dg-error \"explicit\" }\n+  = {std::allocator_arg, std::allocator<int>{}, 1, 2}; // { dg-error \"could not convert\" }\n std::tuple<Explicit, Explicit, Explicit> v32_c\n-  = {std::allocator_arg, std::allocator<int>{}, 1,2,3}; // { dg-error \"explicit\" }\n+  = {std::allocator_arg, std::allocator<int>{}, 1,2,3}; // { dg-error \"could not convert\" }\n \n std::tuple<int, int> v33{std::allocator_arg, std::allocator<int>{},\n   std::pair<int, int>{1, 2}};\n@@ -216,7 +216,7 @@ std::tuple<long, long> v37 = {std::allocator_arg, std::allocator<int>{},\n   std::pair<int, int>{1, 2}};\n \n std::tuple<Explicit, Explicit> v38\n-= {std::allocator_arg, std::allocator<int>{}, std::pair<int, int>{1, 2}}; // { dg-error \"explicit\" }\n+= {std::allocator_arg, std::allocator<int>{}, std::pair<int, int>{1, 2}}; // { dg-error \"could not convert\" }\n \n std::tuple<int, int> v39{std::allocator_arg, std::allocator<int>{}, v20};\n \n@@ -230,18 +230,18 @@ std::tuple<int, int> v42 = {std::allocator_arg, std::allocator<int>{}, v20};\n std::tuple<long, long> v43 = {std::allocator_arg, std::allocator<int>{}, v20};\n \n std::tuple<Explicit, Explicit> v44\n-= {std::allocator_arg, std::allocator<int>{ }, v20}; // { dg-error \"explicit\" }\n+= {std::allocator_arg, std::allocator<int>{ }, v20}; // { dg-error \"could not convert\" }\n std::tuple<ExplicitDefault> v45_a{};\n std::tuple<ExplicitDefault, int> v45_b{};\n \n-std::tuple<ExplicitDefault> v46_a = {}; // { dg-error \"explicit\" }\n-std::tuple<ExplicitDefault, int> v46_b = {}; // { dg-error \"explicit\" }\n+std::tuple<ExplicitDefault> v46_a = {}; // { dg-error \"could not convert\" }\n+std::tuple<ExplicitDefault, int> v46_b = {}; // { dg-error \"could not convert\" }\n \n std::tuple<ExplicitDefaultDefault> v47_a{};\n std::tuple<ExplicitDefaultDefault, int> v47_b{};\n \n-std::tuple<ExplicitDefaultDefault> v48_a = {}; // { dg-error \"explicit\" }\n-std::tuple<ExplicitDefaultDefault, int> v48_b = { }; // { dg-error \"explicit\" }\n+std::tuple<ExplicitDefaultDefault> v48_a = {}; // { dg-error \"could not convert\" }\n+std::tuple<ExplicitDefaultDefault, int> v48_b = { }; // { dg-error \"could not convert\" }\n \n \n struct DeletedCopy\n@@ -293,9 +293,9 @@ void test_arg_passing()\n   f8_b(v1_b);\n   f8_c(v1_c);\n \n-  f8_a({1}); // { dg-error \"explicit\" }\n-  f8_b({1,2}); // { dg-error \"explicit\" }\n-  f8_c({1,2,3}); // { dg-error \"explicit\" }\n+  f8_a({1}); // { dg-error \"could not convert\" }\n+  f8_b({1,2}); // { dg-error \"could not convert\" }\n+  f8_c({1,2,3}); // { dg-error \"could not convert\" }\n \n   f8_a(std::tuple<Explicit>{});\n   f8_b(std::tuple<Explicit, Explicit>{});\n@@ -328,10 +328,10 @@ void test_arg_passing()\n   f9_b(std::tuple<long, long>{});\n   f9_c(std::tuple<long, long, long>{});\n \n-  f10_a({}); // { dg-error \"explicit\" }\n-  f10_b({}); // { dg-error \"explicit\" }\n-  f11_a({}); // { dg-error \"explicit\" }\n-  f11_b({}); // { dg-error \"explicit\" }\n+  f10_a({}); // { dg-error \"could not convert\" }\n+  f10_b({}); // { dg-error \"could not convert\" }\n+  f11_a({}); // { dg-error \"could not convert\" }\n+  f11_b({}); // { dg-error \"could not convert\" }\n \n   f10_a(std::tuple<ExplicitDefault>{});\n   f10_b(std::tuple<ExplicitDefault, int>{});"}]}