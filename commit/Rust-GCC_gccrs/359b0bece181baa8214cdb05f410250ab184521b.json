{"sha": "359b0bece181baa8214cdb05f410250ab184521b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU5YjBiZWNlMTgxYmFhODIxNGNkYjA1ZjQxMDI1MGFiMTg0NTIxYg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-05-28T05:44:06Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-05-28T05:44:06Z"}, "message": "cppexp.c (interpret_number): Optimize for single-digit and less-than-half-precision cases.\n\n\t* cppexp.c (interpret_number): Optimize for single-digit\n\tand less-than-half-precision cases.\n\t(num_trim, num_positive, num_div_op): Cast constants.\n\nFrom-SVN: r53943", "tree": {"sha": "fa31880fa9853874795b66e561a88817cc69b1e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa31880fa9853874795b66e561a88817cc69b1e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/359b0bece181baa8214cdb05f410250ab184521b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359b0bece181baa8214cdb05f410250ab184521b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/359b0bece181baa8214cdb05f410250ab184521b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359b0bece181baa8214cdb05f410250ab184521b/comments", "author": null, "committer": null, "parents": [{"sha": "ee4586c531acb384bb480bbddfb83d4723f1ed49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee4586c531acb384bb480bbddfb83d4723f1ed49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee4586c531acb384bb480bbddfb83d4723f1ed49"}], "stats": {"total": 78, "additions": 57, "deletions": 21}, "files": [{"sha": "32c1c57d83cdc3220d3f483bf496ff2223a846ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359b0bece181baa8214cdb05f410250ab184521b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359b0bece181baa8214cdb05f410250ab184521b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=359b0bece181baa8214cdb05f410250ab184521b", "patch": "@@ -1,3 +1,9 @@\n+2002-05-28  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppexp.c (interpret_number): Optimize for single-digit\n+\tand less-than-half-precision cases.\n+\t(num_trim, num_positive, num_div_op): Cast constants.\n+\n 2002-05-27  Roger Sayle  <roger@eyesopen.com>\n \n \t* c-common.c: Add support for __attribute__((nothrow)) to specify"}, {"sha": "c76e330fc28a90777c23ca6a0b2e6d0d9e6fa09e", "filename": "gcc/cppexp.c", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359b0bece181baa8214cdb05f410250ab184521b/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359b0bece181baa8214cdb05f410250ab184521b/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=359b0bece181baa8214cdb05f410250ab184521b", "patch": "@@ -176,21 +176,31 @@ interpret_number (pfile, tok)\n      const cpp_token *tok;\n {\n   cpp_num result;\n-  const uchar *start = tok->val.str.text;\n-  const uchar *end = start + tok->val.str.len;\n-  const uchar *p = start;\n+  cpp_num_part max;\n+  const uchar *p = tok->val.str.text;\n+  const uchar *end;\n   const struct suffix *sufftab;\n-  size_t precision = CPP_OPTION (pfile, precision);\n-  unsigned int i, nsuff, base = 10, c = 0, largest_digit = 0;\n-  bool overflow = false;\n+  size_t precision;\n+  unsigned int i, nsuff, base, c;\n+  bool overflow, big_digit;\n \n-  result.low = result.high = 0;\n+  result.low = 0;\n+  result.high = 0;\n   result.unsignedp = 0;\n   result.overflow = 0;\n \n+  /* Common case of a single digit.  */\n+  end = p + tok->val.str.len;\n+  if (tok->val.str.len == 1 && (unsigned int) (p[0] - '0') <= 9)\n+    {\n+      result.low = p[0] - '0';\n+      return result;\n+    }\n+\n+  base = 10;\n   if (p[0] == '0')\n     {\n-      if (end - start >= 3 && (p[1] == 'x' || p[1] == 'X'))\n+      if (end - p >= 3 && (p[1] == 'x' || p[1] == 'X'))\n \t{\n \t  p += 2;\n \t  base = 16;\n@@ -202,6 +212,18 @@ interpret_number (pfile, tok)\n \t}\n     }\n \n+  c = 0;\n+  overflow = big_digit = false;\n+  precision = CPP_OPTION (pfile, precision);\n+\n+  /* We can add a digit to numbers less than this without needing\n+     double integers.  9 is the maximum digit for octal and decimal;\n+     for hex it is annihilated by the division anyway.  */\n+  max = ~(cpp_num_part) 0;\n+  if (precision < PART_PRECISION)\n+    max >>= PART_PRECISION - precision;\n+  max = (max - 9) / base + 1;\n+\n   for(; p < end; p++)\n     {\n       c = *p;\n@@ -211,10 +233,18 @@ interpret_number (pfile, tok)\n       else\n \tbreak;\n \n-      result = append_digit (result, c, base, precision);\n-      overflow |= result.overflow;\n-      if (largest_digit < c)\n-\tlargest_digit = c;\n+      if (c >= base)\n+\tbig_digit = true;\n+\n+      /* Strict inequality for when max is set to zero.  */\n+      if (result.low < max)\n+\tresult.low = result.low * base + c;\n+      else\n+\t{\n+\t  result = append_digit (result, c, base, precision);\n+\t  overflow |= result.overflow;\n+\t  max = 0;\n+\t}\n     }\n \n   if (p < end)\n@@ -256,7 +286,7 @@ interpret_number (pfile, tok)\n \t\t   \"too many 'l' suffixes in integer constant\");\n     }\n \n-  if (base <= largest_digit)\n+  if (big_digit)\n     cpp_error (pfile, DL_PEDWARN,\n \t       \"integer constant contains digits beyond the radix\");\n \n@@ -787,12 +817,12 @@ num_trim (num, precision)\n     {\n       precision -= PART_PRECISION;\n       if (precision < PART_PRECISION)\n-\tnum.high &= (1UL << precision) - 1;\n+\tnum.high &= ((cpp_num_part) 1 << precision) - 1;\n     }\n   else\n     {\n       if (precision < PART_PRECISION)\n-\tnum.low &= (1UL << precision) - 1;\n+\tnum.low &= ((cpp_num_part) 1 << precision) - 1;\n       num.high = 0;\n     }\n \n@@ -808,10 +838,10 @@ num_positive (num, precision)\n   if (precision > PART_PRECISION)\n     {\n       precision -= PART_PRECISION;\n-      return (num.high & (1UL << (precision - 1))) == 0;\n+      return (num.high & (cpp_num_part) 1 << (precision - 1)) == 0;\n     }\n \n-  return (num.low & (1UL << (precision - 1))) == 0;\n+  return (num.low & (cpp_num_part) 1 << (precision - 1)) == 0;\n }\n \n /* Returns the negative of NUM.  */\n@@ -1245,7 +1275,7 @@ num_div_op (pfile, lhs, rhs, op)\n   if (rhs.high)\n     {\n       i = precision - 1;\n-      mask = 1UL << (i - PART_PRECISION);\n+      mask = (cpp_num_part) 1 << (i - PART_PRECISION);\n       for (; ; i--, mask >>= 1)\n \tif (rhs.high & mask)\n \t  break;\n@@ -1256,7 +1286,7 @@ num_div_op (pfile, lhs, rhs, op)\n \ti = precision - PART_PRECISION - 1;\n       else\n \ti = precision - 1;\n-      mask = 1UL << i;\n+      mask = (cpp_num_part) 1 << i;\n       for (; ; i--, mask >>= 1)\n \tif (rhs.low & mask)\n \t  break;\n@@ -1284,9 +1314,9 @@ num_div_op (pfile, lhs, rhs, op)\n \t{\n \t  lhs = num_binary_op (pfile, lhs, sub, CPP_MINUS);\n \t  if (i >= PART_PRECISION)\n-\t    result.high |= 1UL << (i - PART_PRECISION);\n+\t    result.high |= (cpp_num_part) 1 << (i - PART_PRECISION);\n \t  else\n-\t    result.low |= 1UL << i;\n+\t    result.low |= (cpp_num_part) 1 << i;\n \t}\n       if (i-- == 0)\n \tbreak;"}]}