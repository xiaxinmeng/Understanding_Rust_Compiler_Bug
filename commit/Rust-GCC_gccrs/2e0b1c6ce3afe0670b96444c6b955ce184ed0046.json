{"sha": "2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUwYjFjNmNlM2FmZTA2NzBiOTY0NDRjNmI5NTVjZTE4NGVkMDA0Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-26T20:16:21Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-26T20:16:21Z"}, "message": "libstdc++: Fix internet socket option classes\n\nSimilar to the previous commit, this fixes various problems with the\nsocket options classes in the <internet> header:\n\n- The constructors were not noexcept.\n- The __sockopt_base<T>::value() member function was present\n  unconditionally (so was defined for socket_base::linger which is\n  incorrect).\n- The __socket_crtp<C, T>::operator=(T) assignment operator was not\n  noexcept, and was hidden in the derived classes.\n- The MulticastSocketOptions incorrectly used a union, incorrectly\n  defined resize and const data() member functions, and their\n  constructors were unimplemented.\n\nAlso, where appropriate:\n\n- Use class instead of struct for the socket option types.\n- Define the _S_level and _S_name constants as private.\n- Declare the __socket_crtp base as a friend.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/experimental/internet (tcp::no_delay, v6_only)\n\t(unicast::hops, multicast::hops, multicast::enable_loopback):\n\tChange access of base class and static data members. Add\n\tusing-declaration for __socket_crtp::operator=(_Tp).\n\t(multicast::__mcastopt): New type.\n\t(multicast::join_group, multicast::leave_group): Derive from\n\t__mcastopt for common implementation.\n\t* include/experimental/socket: Add comment.\n\t* testsuite/experimental/net/internet/socket/opt.cc: New test.\n\t* testsuite/experimental/net/socket/socket_base.cc: Check for\n\tprotected constructor/destructor of socket_base. Check for\n\texplicit constructors of socket option classes.", "tree": {"sha": "491b77ba5e207d3b291eeba854415aec3ca07016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/491b77ba5e207d3b291eeba854415aec3ca07016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06c86a4f210c76a157512a2963e6c31302d161cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06c86a4f210c76a157512a2963e6c31302d161cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06c86a4f210c76a157512a2963e6c31302d161cb"}], "stats": {"total": 353, "additions": 251, "deletions": 102}, "files": [{"sha": "2e3fd06ead2113c1ad9bc9aab53811feab2354be", "filename": "libstdc++-v3/include/experimental/internet", "status": "modified", "additions": 86, "deletions": 99, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Finternet?ref=2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "patch": "@@ -52,7 +52,7 @@\n # include <arpa/inet.h>\t\t// inet_ntop\n #endif\n #ifdef _GLIBCXX_HAVE_NETINET_IN_H\n-# include <netinet/in.h>\t// IPPROTO_IP\n+# include <netinet/in.h>\t// IPPROTO_IP, IPPROTO_IPV6, in_addr, in6_addr\n #endif\n #ifdef _GLIBCXX_HAVE_NETINET_TCP_H\n # include <netinet/tcp.h>\t// TCP_NODELAY\n@@ -2078,6 +2078,7 @@ namespace ip\n     struct no_delay : __sockopt_crtp<no_delay, bool>\n     {\n       using __sockopt_crtp::__sockopt_crtp;\n+      using __sockopt_crtp::operator=;\n \n       static const int _S_level = IPPROTO_TCP;\n       static const int _S_name = TCP_NODELAY;\n@@ -2157,20 +2158,26 @@ namespace ip\n   /// @}\n \n   /// Restrict a socket created for an IPv6 protocol to IPv6 only.\n-  struct v6_only : __sockopt_crtp<v6_only, bool>\n+  class v6_only : public __sockopt_crtp<v6_only, bool>\n   {\n+  public:\n     using __sockopt_crtp::__sockopt_crtp;\n+    using __sockopt_crtp::operator=;\n \n+  private:\n+    friend __sockopt_crtp<v6_only, bool>;\n     static const int _S_level = IPPROTO_IPV6;\n     static const int _S_name = IPV6_V6ONLY;\n   };\n \n   namespace unicast\n   {\n     /// Set the default number of hops (TTL) for outbound datagrams.\n-    struct hops : __sockopt_crtp<hops>\n+    class hops : public __sockopt_crtp<hops>\n     {\n+    public:\n       using __sockopt_crtp::__sockopt_crtp;\n+      using __sockopt_crtp::operator=;\n \n       template<typename _Protocol>\n \tint\n@@ -2186,130 +2193,111 @@ namespace ip\n \n   namespace multicast\n   {\n-    /// Request that a socket joins a multicast group.\n-    struct join_group\n+    class __mcastopt\n     {\n+    public:\n       explicit\n-      join_group(const address&);\n+      __mcastopt(const address& __grp) noexcept\n+      : __mcastopt(__grp.is_v4() ? __mcastopt(__grp.to_v4()) : __mcastopt(__grp.to_v6()))\n+      { }\n \n       explicit\n-      join_group(const address_v4&, const address_v4& = address_v4::any());\n+      __mcastopt(const address_v4& __grp,\n+\t\t const address_v4& __iface = address_v4::any()) noexcept\n+      {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\t_M_v4.imr_multiaddr.s_addr = __grp.to_uint();\n+\t_M_v4.imr_interface.s_addr = __iface.to_uint();\n+#else\n+\t_M_v4.imr_multiaddr.s_addr = __builtin_bswap32(__grp.to_uint());\n+\t_M_v4.imr_interface.s_addr = __builtin_bswap32(__iface.to_uint());\n+#endif\n+      }\n \n       explicit\n-      join_group(const address_v6&, unsigned int = 0);\n+      __mcastopt(const address_v6& __grp, unsigned int __iface = 0) noexcept\n+      {\n+\tconst auto __addr = __grp.to_bytes();\n+\t__builtin_memcpy(_M_v6.ipv6mr_multiaddr.s6_addr, __addr.data(), 16);\n+\t_M_v6.ipv6mr_interface = __iface;\n+      }\n \n       template<typename _Protocol>\n \tint\n \tlevel(const _Protocol& __p) const noexcept\n \t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n \n-      template<typename _Protocol>\n-\tint\n-\tname(const _Protocol& __p) const noexcept\n-\t{\n-\t  return __p.family() == AF_INET6\n-\t    ? IPV6_JOIN_GROUP : IP_ADD_MEMBERSHIP;\n-\t}\n-      template<typename _Protocol>\n-\tvoid*\n-\tdata(const _Protocol&) noexcept\n-\t{ return std::addressof(_M_value); }\n-\n       template<typename _Protocol>\n \tconst void*\n-\tdata(const _Protocol&) const noexcept\n-\t{ return std::addressof(_M_value); }\n+\tdata(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? &_M_v6 : &_M_v4; }\n \n       template<typename _Protocol>\n \tsize_t\n \tsize(const _Protocol& __p) const noexcept\n-\t{\n-\t  return __p.family() == AF_INET6\n-\t    ? sizeof(_M_value._M_v6) : sizeof(_M_value._M_v4);\n-\t}\n-\n-      template<typename _Protocol>\n-\tvoid\n-\tresize(const _Protocol& __p, size_t __s)\n-\t{\n-\t  if (__s != size(__p))\n-\t    __throw_length_error(\"invalid value for socket option resize\");\n-\t}\n+\t{ return __p.family() == AF_INET6 ? sizeof(_M_v6) : sizeof(_M_v4); }\n \n-    protected:\n-      union\n-      {\n-\tipv6_mreq _M_v6;\n-\tip_mreq _M_v4;\n-      } _M_value;\n+    private:\n+      ipv6_mreq _M_v6 = {};\n+      ip_mreq _M_v4 = {};\n     };\n \n-    /// Request that a socket leaves a multicast group.\n-    struct leave_group\n+    /// Request that a socket joins a multicast group.\n+    class join_group : private __mcastopt\n     {\n-      explicit\n-      leave_group(const address&);\n-\n-      explicit\n-      leave_group(const address_v4&, const address_v4& = address_v4::any());\n-\n-      explicit\n-      leave_group(const address_v6&, unsigned int = 0);\n-\n-      template<typename _Protocol>\n-\tint\n-\tlevel(const _Protocol& __p) const noexcept\n-\t{ return __p.family() == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP; }\n+    public:\n+      using __mcastopt::__mcastopt;\n+      using __mcastopt::level;\n+      using __mcastopt::data;\n+      using __mcastopt::size;\n \n       template<typename _Protocol>\n \tint\n \tname(const _Protocol& __p) const noexcept\n \t{\n-\t  return __p.family() == AF_INET6\n-\t    ? IPV6_LEAVE_GROUP : IP_DROP_MEMBERSHIP;\n+\t  if (__p.family() == AF_INET6)\n+\t    return IPV6_JOIN_GROUP;\n+\t  return IP_ADD_MEMBERSHIP;\n \t}\n-      template<typename _Protocol>\n-\tvoid*\n-\tdata(const _Protocol&) noexcept\n-\t{ return std::addressof(_M_value); }\n-\n-      template<typename _Protocol>\n-\tconst void*\n-\tdata(const _Protocol&) const noexcept\n-\t{ return std::addressof(_M_value); }\n+    };\n \n-      template<typename _Protocol>\n-\tsize_t\n-\tsize(const _Protocol& __p) const noexcept\n-\t{\n-\t  return __p.family() == AF_INET6\n-\t    ? sizeof(_M_value._M_v6) : sizeof(_M_value._M_v4);\n-\t}\n+    /// Request that a socket leaves a multicast group.\n+    class leave_group : private __mcastopt\n+    {\n+    public:\n+      using __mcastopt::__mcastopt;\n+      using __mcastopt::level;\n+      using __mcastopt::data;\n+      using __mcastopt::size;\n \n       template<typename _Protocol>\n-\tvoid\n-\tresize(const _Protocol& __p, size_t __s)\n+\tint\n+\tname(const _Protocol& __p) const noexcept\n \t{\n-\t  if (__s != size(__p))\n-\t    __throw_length_error(\"invalid value for socket option resize\");\n+\t  if (__p.family() == AF_INET6)\n+\t    return IPV6_LEAVE_GROUP;\n+\t  return IP_DROP_MEMBERSHIP;\n \t}\n-\n-    protected:\n-      union\n-      {\n-\tipv6_mreq _M_v6;\n-\tip_mreq _M_v4;\n-      } _M_value;\n     };\n \n     /// Specify the network interface for outgoing multicast datagrams.\n     class outbound_interface\n     {\n+    public:\n       explicit\n-      outbound_interface(const address_v4&);\n+      outbound_interface(const address_v4& __v4) noexcept\n+      {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+\t_M_v4.s_addr = __v4.to_uint();\n+#else\n+\t_M_v4.s_addr = __builtin_bswap32(__v4.to_uint());\n+#endif\n+      }\n \n       explicit\n-      outbound_interface(unsigned int);\n+      outbound_interface(unsigned int __v6) noexcept\n+      : _M_v4(), _M_v6(__v6)\n+      { }\n \n       template<typename _Protocol>\n \tint\n@@ -2326,28 +2314,25 @@ namespace ip\n \n       template<typename _Protocol>\n \tconst void*\n-\tdata(const _Protocol&) const noexcept\n-\t{ return std::addressof(_M_value); }\n+\tdata(const _Protocol& __p) const noexcept\n+\t{ return __p.family() == AF_INET6 ? &_M_v6 : &_M_v4; }\n \n       template<typename _Protocol>\n \tsize_t\n \tsize(const _Protocol& __p) const noexcept\n-\t{\n-\t  return __p.family() == AF_INET6\n-\t    ? sizeof(_M_value._M_v6) : sizeof(_M_value._M_v4);\n-\t}\n+\t{ return __p.family() == AF_INET6 ? sizeof(_M_v6) : sizeof(_M_v4); }\n \n-    protected:\n-      union {\n-\tunsigned _M_v6;\n-\tin_addr _M_v4;\n-      } _M_value;\n+    private:\n+      in_addr _M_v4;\n+      unsigned _M_v6 = 0;\n     };\n \n     /// Set the default number of hops (TTL) for outbound datagrams.\n-    struct hops : __sockopt_crtp<hops>\n+    class hops : public __sockopt_crtp<hops>\n     {\n+    public:\n       using __sockopt_crtp::__sockopt_crtp;\n+      using __sockopt_crtp::operator=;\n \n       template<typename _Protocol>\n \tint\n@@ -2364,9 +2349,11 @@ namespace ip\n     };\n \n     /// Set whether datagrams are delivered back to the local application.\n-    struct enable_loopback : __sockopt_crtp<enable_loopback>\n+    class enable_loopback : public __sockopt_crtp<enable_loopback, bool>\n     {\n+    public:\n       using __sockopt_crtp::__sockopt_crtp;\n+      using __sockopt_crtp::operator=;\n \n       template<typename _Protocol>\n \tint"}, {"sha": "18849f607f8aea4c64a64074060cbd15c340304e", "filename": "libstdc++-v3/include/experimental/socket", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket?ref=2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "patch": "@@ -419,6 +419,8 @@ inline namespace v1\n     noexcept\n   { return __f1 = (__f1 ^ __f2); }\n \n+  // TODO define socket_base static constants in .so for C++14 mode\n+\n #if _GLIBCXX_HAVE_UNISTD_H\n \n   class __socket_impl"}, {"sha": "68bac84a8b1b4ed0341f8d88f597603950ffd283", "filename": "libstdc++-v3/testsuite/experimental/net/internet/socket/opt.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fsocket%2Fopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fsocket%2Fopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Finternet%2Fsocket%2Fopt.cc?ref=2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "patch": "@@ -0,0 +1,151 @@\n+// { dg-do run { target c++14 } }\n+\n+#include <experimental/internet>\n+#include <testsuite_common_types.h>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+template<typename C, typename T, typename P>\n+void check_gettable_sockopt(P p, C c = C())\n+{\n+  static_assert( is_same<decltype(declval<const C&>().level(p)), int>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().level(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<const C&>().name(p)), int>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().name(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<C&>().data(p)), void*>(), \"\" );\n+  static_assert( noexcept(declval<C&>().data(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<const C&>().size(p)), size_t>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().size(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<C&>().resize(p, 0)), void>(), \"\" );\n+  static_assert( ! noexcept(declval<C&>().resize(p, 0)), \"\" );\n+\n+  VERIFY(c.size(p) == sizeof(T));\n+}\n+\n+template<typename C, typename T, typename P>\n+void check_settable_sockopt(P p, C c = C())\n+{\n+  static_assert( is_same<decltype(declval<const C&>().level(p)), int>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().level(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<const C&>().name(p)), int>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().name(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<const C&>().data(p)), const void*>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().data(p)), \"\" );\n+\n+  static_assert( is_same<decltype(declval<C&>().size(p)), size_t>(), \"\" );\n+  static_assert( noexcept(declval<C&>().size(p)), \"\" );\n+\n+  VERIFY(c.size(p) == sizeof(T));\n+}\n+\n+template<typename C, typename T = int>\n+void check_boolean_sockopt()\n+{\n+  namespace ip = std::experimental::net::ip;\n+  check_gettable_sockopt<C, T>(ip::tcp::v4());\n+  check_settable_sockopt<C, T>(ip::tcp::v4());\n+\n+  static_assert( is_destructible<C>(), \"\" );\n+  static_assert( is_nothrow_default_constructible<C>(), \"\" );\n+  static_assert( is_nothrow_copy_constructible<C>(), \"\" );\n+  static_assert( is_nothrow_copy_assignable<C>(), \"\" );\n+\n+  static_assert( is_nothrow_constructible<C, bool>(), \"\" );\n+  static_assert( is_nothrow_assignable<C&, bool>(), \"\" );\n+\n+  static_assert( is_same<decltype(declval<const C&>().value()), bool>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().value()), \"\" );\n+\n+  static_assert( is_same<decltype(static_cast<bool>(declval<const C&>())), bool>(), \"\" );\n+  static_assert( noexcept(static_cast<bool>(declval<const C&>())), \"\" );\n+\n+  static_assert( is_same<decltype(!declval<const C&>()), bool>(), \"\" );\n+  static_assert( noexcept(!declval<const C&>()), \"\" );\n+}\n+\n+template<typename C, typename T = int>\n+void check_integer_sockopt()\n+{\n+  namespace ip = std::experimental::net::ip;\n+  check_gettable_sockopt<C, T>(ip::tcp::v4());\n+  check_settable_sockopt<C, T>(ip::tcp::v4());\n+\n+  static_assert( is_destructible<C>(), \"\" );\n+  static_assert( is_nothrow_default_constructible<C>(), \"\" );\n+  static_assert( is_nothrow_copy_constructible<C>(), \"\" );\n+  static_assert( is_nothrow_copy_assignable<C>(), \"\" );\n+\n+  static_assert( is_nothrow_constructible<C, int>(), \"\" );\n+  static_assert( is_nothrow_assignable<C&, int>(), \"\" );\n+\n+  static_assert( is_same<decltype(declval<const C&>().value()), int>(), \"\" );\n+  static_assert( noexcept(declval<const C&>().value()), \"\" );\n+}\n+\n+template<typename C>\n+void check_mcast_sockopt(C& c)\n+{\n+  namespace ip = std::experimental::net::ip;\n+  static_assert( is_destructible<C>(), \"\" );\n+  static_assert( is_copy_constructible<C>(), \"\" );\n+  static_assert( is_copy_assignable<C>(), \"\" );\n+\n+  check_settable_sockopt<C, ipv6_mreq>(ip::tcp::v6(), c);\n+  check_settable_sockopt<C, ip_mreq>(ip::tcp::v4(), c);\n+\n+  static_assert( is_nothrow_constructible<C, const ip::address&>(), \"\" );\n+  static_assert( ! is_convertible<const ip::address&, C>(), \"explicit\" );\n+  static_assert( is_nothrow_constructible<C, const ip::address_v4&>(), \"\" );\n+  static_assert( ! is_convertible<const ip::address_v4&, C>(), \"explicit\" );\n+  static_assert( is_nothrow_constructible<C, const ip::address_v4&, const ip::address_v4&>(), \"\" );\n+  static_assert( is_nothrow_constructible<C, const ip::address_v6&>(), \"\" );\n+  static_assert( ! is_convertible<const ip::address_v6&, C>(), \"explicit\" );\n+  static_assert( is_nothrow_constructible<C, const ip::address_v6&, unsigned>(), \"\" );\n+}\n+\n+void test_option_types()\n+{\n+  namespace ip = std::experimental::net::ip;\n+#if __has_include(<netinet/in.h>)\n+  check_boolean_sockopt<ip::tcp::no_delay>();\n+\n+  check_boolean_sockopt<ip::v6_only>();\n+\n+  check_integer_sockopt<ip::unicast::hops>();\n+\n+  ip::multicast::join_group join(ip::address_v4::any());\n+  check_mcast_sockopt(join);\n+\n+  ip::multicast::leave_group leave(ip::address_v4::any());\n+  check_mcast_sockopt(leave);\n+\n+  using outbound_if = ip::multicast::outbound_interface;\n+  outbound_if oif(ip::address_v4::any());\n+  check_settable_sockopt<outbound_if, unsigned>(ip::tcp::v6(), oif);\n+  check_settable_sockopt<outbound_if, ::in_addr>(ip::tcp::v4(), oif);\n+  static_assert( is_destructible<outbound_if>(), \"\" );\n+  static_assert( ! is_default_constructible<outbound_if>(), \"\" );\n+  static_assert( is_nothrow_copy_constructible<outbound_if>(), \"\" );\n+  static_assert( is_nothrow_copy_assignable<outbound_if>(), \"\" );\n+  static_assert( is_nothrow_constructible<outbound_if, const ip::address_v4&>(), \"\" );\n+  static_assert( ! is_convertible<const ip::address_v4&, outbound_if>(), \"explicit\" );\n+  static_assert( is_nothrow_constructible<outbound_if, unsigned>(), \"\" );\n+  static_assert( ! is_convertible<unsigned, outbound_if>(), \"explicit\" );\n+\n+  check_integer_sockopt<ip::multicast::hops>();\n+\n+  check_boolean_sockopt<ip::multicast::enable_loopback>();\n+#endif\n+}\n+\n+int main()\n+{\n+  test_option_types();\n+}"}, {"sha": "1c02c5a09dac69ad0a2fe662a36c2d381895f17f", "filename": "libstdc++-v3/testsuite/experimental/net/socket/socket_base.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fsocket%2Fsocket_base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e0b1c6ce3afe0670b96444c6b955ce184ed0046/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fsocket%2Fsocket_base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fsocket%2Fsocket_base.cc?ref=2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "patch": "@@ -24,6 +24,12 @@\n using S = std::experimental::net::socket_base;\n using namespace std;\n \n+static_assert( ! is_default_constructible<S>(), \"protected\" );\n+static_assert( ! is_destructible<S>(), \"protected\" );\n+struct Sock : S { };\n+static_assert( is_default_constructible<Sock>(), \"\" );\n+static_assert( is_destructible<Sock>(), \"\" );\n+\n // Dummy protocol\n struct P\n {\n@@ -34,9 +40,6 @@ struct P\n   };\n };\n \n-static_assert( ! is_default_constructible<S>(), \"\" );\n-static_assert( ! is_destructible<S>(), \"\" );\n-\n template<typename C, typename T>\n void check_gettable_sockopt()\n {\n@@ -92,6 +95,7 @@ void check_boolean_sockopt()\n   static_assert( is_nothrow_copy_assignable<C>(), \"\" );\n \n   static_assert( is_nothrow_constructible<C, bool>(), \"\" );\n+  static_assert( ! is_convertible<bool, C>(), \"constructor is explicit\" );\n   static_assert( is_nothrow_assignable<C&, bool>(), \"\" );\n \n   static_assert( is_same<decltype(declval<const C&>().value()), bool>(), \"\" );\n@@ -116,6 +120,7 @@ void check_integer_sockopt()\n   static_assert( is_nothrow_copy_assignable<C>(), \"\" );\n \n   static_assert( is_nothrow_constructible<C, int>(), \"\" );\n+  static_assert( ! is_convertible<int, C>(), \"constructor is explicit\" );\n   static_assert( is_nothrow_assignable<C&, int>(), \"\" );\n \n   static_assert( is_same<decltype(declval<const C&>().value()), int>(), \"\" );\n@@ -124,6 +129,7 @@ void check_integer_sockopt()\n \n void test_option_types()\n {\n+#if __has_include(<socket.h>)\n   check_boolean_sockopt<S::broadcast>();\n \n   check_boolean_sockopt<S::debug>();\n@@ -163,10 +169,12 @@ void test_option_types()\n   check_integer_sockopt<S::send_buffer_size>();\n \n   check_integer_sockopt<S::send_low_watermark>();\n+#endif\n }\n \n void test_constants()\n {\n+#if __has_include(<socket.h>)\n   static_assert( is_enum<S::shutdown_type>::value, \"\" );\n   static_assert( S::shutdown_receive != S::shutdown_send, \"\" );\n   static_assert( S::shutdown_receive != S::shutdown_both, \"\" );\n@@ -183,6 +191,7 @@ void test_constants()\n \n   auto m = &S::max_listen_connections;\n   static_assert( is_same<decltype(m), const int*>::value, \"\" );\n+#endif\n }\n \n int main()"}]}