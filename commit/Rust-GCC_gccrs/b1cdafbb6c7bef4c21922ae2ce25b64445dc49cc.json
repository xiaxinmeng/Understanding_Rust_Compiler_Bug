{"sha": "b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFjZGFmYmI2YzdiZWY0YzIxOTIyYWUyY2UyNWI2NDQ0NWRjNDljYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-09-29T11:24:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-09-29T11:24:13Z"}, "message": "recog.c (recog_memoized): Rename to recog_memoized_1.\n\n\n\t* recog.c (recog_memoized): Rename to recog_memoized_1.\n\t* recog.h (recog_memoized): Rename to recog_memoized_1.\n\t(recog_memoized): New macro.\n\t* rtl.h (single_set): Rename to single_set_1\n\t(single_set): New macro.\n\t* rtlanal.c (single_set): Rename to single_set_1;  expect clobbers\n\tto be last.\n\n\t* i386.md (strmovsi_1, strmovhi_1 strmovqi_1):\n\tDo not use match_dup of input operands at outputs.\n\tUse register_operand for memory expression.\n\t(rep_movsi): Put use last, canonicalize.\n\tUse register_operand for memory expression.\n\t(rep_movqi): Put use last.\n\tUse register_operand for memory expression.\n\t(strsetsi_1, strset_hi_1, strsetqi_1): Do not use match_dup\n\tof input operands at outputs.  Use register_operand for memory\n\texpression.\n\t(rep_stossi): Put use last; canonicalize; fix match_dup in\n\tthe address expression\n\t(rep_stosqi): Likewise.\n\t(memcmp expander): Update calls.\n\t(cmpstrsi_nz_1, cmpstrsi_1, strlensi_1): Avoid match_dups in\n\tthe clobbers.\n\n\t* i386.md (fp_jcc_3, fp_jcc_4, jp_fcc_5): if_then_else operand is\n\tVOIDmode.\n\t(fp_jcc_4, fp_jcc_3): Refuse unordered comparisons.\n\nFrom-SVN: r36664", "tree": {"sha": "daf24fe6a604f9c91a67080db41f6d3f1e17db76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daf24fe6a604f9c91a67080db41f6d3f1e17db76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/comments", "author": null, "committer": null, "parents": [{"sha": "073427934aba95f673cbd8578ad36ac3d6055b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073427934aba95f673cbd8578ad36ac3d6055b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/073427934aba95f673cbd8578ad36ac3d6055b05"}], "stats": {"total": 229, "additions": 137, "deletions": 92}, "files": [{"sha": "fef5c52cfba6bc55f2723bfa837263249444f66a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "patch": "@@ -125,6 +125,7 @@ extern int ix86_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern void ix86_sched_init PARAMS ((FILE *, int));\n extern int ix86_sched_reorder PARAMS ((FILE *, int, rtx *, int, int));\n extern int ix86_variable_issue PARAMS ((FILE *, int, rtx, int));\n+extern enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n \n #ifdef TREE_CODE\n extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));"}, {"sha": "5521ea291a9e3a397df795aa51e9c7d7fa28b35d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "patch": "@@ -388,7 +388,6 @@ static void put_condition_code PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t       int, int, FILE *));\n static enum rtx_code unsigned_comparison PARAMS ((enum rtx_code code));\n static rtx ix86_expand_int_compare PARAMS ((enum rtx_code, rtx, rtx));\n-static enum machine_mode ix86_fp_compare_mode PARAMS ((enum rtx_code));\n static enum rtx_code ix86_prepare_fp_compare_args PARAMS ((enum rtx_code,\n \t\t\t\t\t\t\t   rtx *, rtx *));\n static rtx gen_push PARAMS ((rtx));\n@@ -4635,7 +4634,7 @@ ix86_expand_int_compare (code, op0, op1)\n /* Figure out whether to use ordered or unordered fp comparisons.\n    Return the appropriate mode to use.  */\n \n-static enum machine_mode\n+enum machine_mode\n ix86_fp_compare_mode (code)\n      enum rtx_code code;\n {"}, {"sha": "db8be567a43e3a56955d0833f945ac06abd583ba", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "patch": "@@ -8539,7 +8539,7 @@\n \n (define_insn \"*fp_jcc_3\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CCFP 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"nonimmediate_operand\" \"fm\")])\n \t  (label_ref (match_operand 3 \"\" \"\"))\n@@ -8550,12 +8550,14 @@\n   \"TARGET_80387\n    && (GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode)\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\"\n+   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n+   && SELECT_CC_MODE (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2]) == CCFPmode\"\n   \"#\")\n \n (define_insn \"*fp_jcc_4\"\n   [(set (pc)\n-\t(if_then_else (match_operator:CCFP 0 \"comparison_operator\"\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n \t\t\t[(match_operand 1 \"register_operand\" \"f\")\n \t\t\t (match_operand 2 \"nonimmediate_operand\" \"fm\")])\n \t  (pc)\n@@ -8566,7 +8568,9 @@\n   \"TARGET_80387\n    && (GET_MODE (operands[1]) == SFmode || GET_MODE (operands[1]) == DFmode)\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n-   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\"\n+   && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n+   && SELECT_CC_MODE (GET_CODE (operands[0]),\n+\t\t      operands[1], operands[2]) == CCFPmode\"\n   \"#\")\n \n (define_insn \"*fp_jcc_5\"\n@@ -10003,10 +10007,10 @@\n   [(set (mem:SI (match_operand:SI 2 \"register_operand\" \"0\"))\n \t(mem:SI (match_operand:SI 3 \"register_operand\" \"1\")))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n+\t(plus:SI (match_dup 2)\n \t\t (const_int 4)))\n    (set (match_operand:SI 1 \"register_operand\" \"=S\")\n-\t(plus:SI (match_dup 1)\n+\t(plus:SI (match_dup 3)\n \t\t (const_int 4)))\n    (use (reg:SI 19))]\n   \"TARGET_SINGLE_STRINGOP || optimize_size\"\n@@ -10019,10 +10023,10 @@\n   [(set (mem:HI (match_operand:SI 2 \"register_operand\" \"0\"))\n \t(mem:HI (match_operand:SI 3 \"register_operand\" \"1\")))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n+\t(plus:SI (match_dup 2)\n \t\t (const_int 2)))\n    (set (match_operand:SI 1 \"register_operand\" \"=S\")\n-\t(plus:SI (match_dup 1)\n+\t(plus:SI (match_dup 3)\n \t\t (const_int 2)))\n    (use (reg:SI 19))]\n   \"TARGET_SINGLE_STRINGOP || optimize_size\"\n@@ -10035,10 +10039,10 @@\n   [(set (mem:QI (match_operand:SI 2 \"register_operand\" \"0\"))\n \t(mem:QI (match_operand:SI 3 \"register_operand\" \"1\")))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n+\t(plus:SI (match_dup 2)\n \t\t (const_int 1)))\n    (set (match_operand:SI 1 \"register_operand\" \"=S\")\n-\t(plus:SI (match_dup 1)\n+\t(plus:SI (match_dup 3)\n \t\t (const_int 1)))\n    (use (reg:SI 19))]\n   \"TARGET_SINGLE_STRINGOP || optimize_size\"\n@@ -10047,21 +10051,18 @@\n    (set_attr \"memory\" \"both\")\n    (set_attr \"mode\" \"QI\")])\n \n-;; It might seem that operands 3 & 4 could use predicate register_operand.\n-;; But strength reduction might offset the MEM expression.  So we let\n-;; reload put the address into %edi & %esi.\n-\n (define_insn \"rep_movsi\"\n   [(set (match_operand:SI 2 \"register_operand\" \"=c\") (const_int 0))\n-   (use (match_operand:SI 5 \"register_operand\" \"2\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\") \n-        (plus:SI (match_operand:SI 3 \"address_operand\" \"0\")\n-\t         (ashift:SI (match_dup 5) (const_int 2))))\n+        (plus:SI (ashift:SI (match_operand:SI 5 \"register_operand\" \"2\")\n+\t\t\t    (const_int 2))\n+\t\t (match_operand:SI 3 \"register_operand\" \"0\")))\n    (set (match_operand:SI 1 \"register_operand\" \"=S\") \n-        (plus:SI (match_operand:SI 4 \"address_operand\" \"1\")\n-\t         (ashift:SI (match_dup 5) (const_int 2))))\n+        (plus:SI (ashift:SI (match_dup 5) (const_int 2))\n+\t\t (match_operand:SI 4 \"register_operand\" \"1\")))\n    (set (mem:BLK (match_dup 3))\n \t(mem:BLK (match_dup 4)))\n+   (use (match_dup 5))\n    (use (reg:SI 19))]\n   \"\"\n   \"rep\\;movsl|rep movsd\"\n@@ -10072,13 +10073,14 @@\n \n (define_insn \"rep_movqi\"\n   [(set (match_operand:SI 2 \"register_operand\" \"=c\") (const_int 0))\n-   (use (match_operand:SI 5 \"register_operand\" \"2\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\") \n-        (plus:SI (match_operand:SI 3 \"address_operand\" \"0\") (match_dup 5)))\n+        (plus:SI (match_operand:SI 3 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 5 \"register_operand\" \"2\")))\n    (set (match_operand:SI 1 \"register_operand\" \"=S\") \n-        (plus:SI (match_operand:SI 4 \"address_operand\" \"1\") (match_dup 5)))\n+        (plus:SI (match_operand:SI 4 \"register_operand\" \"1\") (match_dup 5)))\n    (set (mem:BLK (match_dup 3))\n \t(mem:BLK (match_dup 4)))\n+   (use (match_dup 5))\n    (use (reg:SI 19))]\n   \"\"\n   \"rep\\;movsb|rep movsb\"\n@@ -10307,7 +10309,7 @@\n   [(set (mem:SI (match_operand:SI 1 \"register_operand\" \"0\"))\n \t(match_operand:SI 2 \"register_operand\" \"a\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n+\t(plus:SI (match_dup 1)\n \t\t (const_int 4)))\n    (use (reg:SI 19))]\n   \"TARGET_SINGLE_STRINGOP || optimize_size\"\n@@ -10320,7 +10322,7 @@\n   [(set (mem:HI (match_operand:SI 1 \"register_operand\" \"0\"))\n \t(match_operand:HI 2 \"register_operand\" \"a\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n+\t(plus:SI (match_dup 1)\n \t\t (const_int 2)))\n    (use (reg:SI 19))]\n   \"TARGET_SINGLE_STRINGOP || optimize_size\"\n@@ -10333,7 +10335,7 @@\n   [(set (mem:QI (match_operand:SI 1 \"register_operand\" \"0\"))\n \t(match_operand:QI 2 \"register_operand\" \"a\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\")\n-\t(plus:SI (match_dup 0)\n+\t(plus:SI (match_dup 1)\n \t\t (const_int 1)))\n    (use (reg:SI 19))]\n   \"TARGET_SINGLE_STRINGOP || optimize_size\"\n@@ -10342,19 +10344,16 @@\n    (set_attr \"memory\" \"store\")\n    (set_attr \"mode\" \"QI\")])\n \n-;; It might seem that operand 0 could use predicate register_operand.\n-;; But strength reduction might offset the MEM expression.  So we let\n-;; reload put the address into %edi.\n-\n (define_insn \"rep_stossi\"\n   [(set (match_operand:SI 1 \"register_operand\" \"=c\") (const_int 0))\n-   (use (match_operand:SI 2 \"register_operand\" \"a\"))\n-   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\") \n-        (plus:SI (match_operand:SI 3 \"address_operand\" \"0\")\n-\t         (ashift:SI (match_dup 3) (const_int 2))))\n+        (plus:SI (ashift:SI (match_operand:SI 4 \"register_operand\" \"1\")\n+\t\t\t    (const_int 2))\n+\t\t (match_operand:SI 3 \"register_operand\" \"0\")))\n    (set (mem:BLK (match_dup 3))\n \t(const_int 0))\n+   (use (match_operand:SI 2 \"register_operand\" \"a\"))\n+   (use (match_dup 4))\n    (use (reg:SI 19))]\n   \"\"\n   \"rep\\;stosl|rep stosd\"\n@@ -10365,12 +10364,13 @@\n \n (define_insn \"rep_stosqi\"\n   [(set (match_operand:SI 1 \"register_operand\" \"=c\") (const_int 0))\n-   (use (match_operand:QI 2 \"register_operand\" \"a\"))\n-   (use (match_operand:SI 4 \"register_operand\" \"1\"))\n    (set (match_operand:SI 0 \"register_operand\" \"=D\") \n-        (plus:SI (match_operand:SI 3 \"address_operand\" \"0\") (match_dup 3)))\n+        (plus:SI (match_operand:SI 3 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 4 \"register_operand\" \"1\")))\n    (set (mem:BLK (match_dup 3))\n \t(const_int 0))\n+   (use (match_operand:QI 2 \"register_operand\" \"a\"))\n+   (use (match_dup 4))\n    (use (reg:SI 19))]\n   \"\"\n   \"rep\\;stosb|rep stosb\"\n@@ -10413,12 +10413,14 @@\n \t  emit_move_insn (operands[0], const0_rtx);\n \t  DONE;\n \t}\n-      emit_insn (gen_cmpstrsi_nz_1 (addr1, addr2, countreg, align));\n+      emit_insn (gen_cmpstrsi_nz_1 (addr1, addr2, countreg, align,\n+\t\t\t\t    addr1, addr2, countreg));\n     }\n   else\n     {\n       emit_insn (gen_cmpsi_1 (countreg, countreg));\n-      emit_insn (gen_cmpstrsi_1 (addr1, addr2, countreg, align));\n+      emit_insn (gen_cmpstrsi_1 (addr1, addr2, countreg, align,\n+\t\t\t\t addr1, addr2, countreg));\n     }\n \n   outlow = gen_lowpart (QImode, out);\n@@ -10448,21 +10450,17 @@\n \n ;; memcmp recognizers.  The `cmpsb' opcode does nothing if the count is\n ;; zero.  Emit extra code to make sure that a zero-length compare is EQ.\n-;;\n-;; It might seem that operands 0 & 1 could use predicate register_operand.\n-;; But strength reduction might offset the MEM expression.  So we let\n-;; reload put the address into %edi & %esi.\n \n (define_insn \"cmpstrsi_nz_1\"\n   [(set (reg:CC 17)\n-\t(compare:CC (mem:BLK (match_operand:SI 0 \"address_operand\" \"S\"))\n-\t\t    (mem:BLK (match_operand:SI 1 \"address_operand\" \"D\"))))\n-   (use (match_operand:SI 2 \"register_operand\" \"c\"))\n+\t(compare:CC (mem:BLK (match_operand:SI 4 \"register_operand\" \"0\"))\n+\t\t    (mem:BLK (match_operand:SI 5 \"register_operand\" \"1\"))))\n+   (use (match_operand:SI 6 \"register_operand\" \"2\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (use (reg:SI 19))\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))\n-   (clobber (match_dup 2))]\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=S\"))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=D\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=c\"))]\n   \"\"\n   \"repz{\\;| }cmpsb\"\n   [(set_attr \"type\" \"str\")\n@@ -10473,17 +10471,17 @@\n \n (define_insn \"cmpstrsi_1\"\n   [(set (reg:CC 17)\n-\t(if_then_else:CC (ne (match_operand:SI 2 \"register_operand\" \"c\")\n+\t(if_then_else:CC (ne (match_operand:SI 6 \"register_operand\" \"2\")\n \t\t\t     (const_int 0))\n-\t  (compare:SI (mem:BLK (match_operand:SI 0 \"address_operand\" \"S\"))\n-\t\t      (mem:BLK (match_operand:SI 1 \"address_operand\" \"D\")))\n+\t  (compare:SI (mem:BLK (match_operand:SI 4 \"register_operand\" \"0\"))\n+\t\t      (mem:BLK (match_operand:SI 5 \"register_operand\" \"1\")))\n \t  (const_int 0)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (use (reg:CC 17))\n    (use (reg:SI 19))\n-   (clobber (match_dup 0))\n-   (clobber (match_dup 1))\n-   (clobber (match_dup 2))]\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=S\"))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=D\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"=c\"))]\n   \"\"\n   \"repz{\\;| }cmpsb\"\n   [(set_attr \"type\" \"str\")\n@@ -10547,25 +10545,21 @@\n \n       emit_insn (gen_cld ());\n       emit_insn (gen_strlensi_1 (scratch1, scratch3, eoschar,\n-\t\t\t\t align, constm1_rtx));\n+\t\t\t\t align, constm1_rtx, scratch3));\n       emit_insn (gen_one_cmplsi2 (scratch2, scratch1));\n       emit_insn (gen_addsi3 (out, scratch2, constm1_rtx));\n     }\n   DONE;\n }\")\n \n-;; It might seem that operands 0 & 1 could use predicate register_operand.\n-;; But strength reduction might offset the MEM expression.  So we let\n-;; reload put the address into %edi.\n-\n (define_insn \"strlensi_1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&c\")\n-\t(unspec:SI [(mem:BLK (match_operand:SI 1 \"address_operand\" \"D\"))\n+\t(unspec:SI [(mem:BLK (match_operand:SI 5 \"register_operand\" \"1\"))\n \t\t    (match_operand:QI 2 \"general_operand\" \"a\")\n \t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")\n \t\t    (match_operand:SI 4 \"immediate_operand\" \"0\")] 0))\n    (use (reg:SI 19))\n-   (clobber (match_dup 1))\n+   (clobber (match_operand:SI 1 \"register_operand\" \"=D\"))\n    (clobber (reg:CC 17))]\n   \"\"\n   \"repnz{\\;| }scasb\""}, {"sha": "248f8d8afed6c8833d8c17d6e8adc282279eb86e", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "patch": "@@ -112,7 +112,7 @@ init_recog ()\n    through this one.  (The only exception is in combine.c.)  */\n \n int\n-recog_memoized (insn)\n+recog_memoized_1 (insn)\n      rtx insn;\n {\n   if (INSN_CODE (insn) < 0)"}, {"sha": "825f09705d49a7fa380be20946490e2a64b6927e", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "patch": "@@ -1329,6 +1329,12 @@ extern void set_unique_reg_note         PARAMS ((rtx, enum reg_note, rtx));\n \n /* Functions in rtlanal.c */\n \n+/* Single set is implemented as macro for performance reasons.  */\n+#define single_set(I) (INSN_P (I) \\\n+\t\t       ? (GET_CODE (PATTERN (I)) == SET \\\n+\t\t\t  ? PATTERN (I) : single_set_1 (I)) \\\n+\t\t       : NULL_RTX)\n+\n extern int rtx_unstable_p\t\tPARAMS ((rtx));\n extern int rtx_varies_p\t\t\tPARAMS ((rtx));\n extern int rtx_addr_varies_p\t\tPARAMS ((rtx));\n@@ -1347,7 +1353,7 @@ extern int no_jumps_between_p\t\tPARAMS ((rtx, rtx));\n extern int modified_in_p\t\tPARAMS ((rtx, rtx));\n extern int insn_dependent_p\t\tPARAMS ((rtx, rtx));\n extern int reg_set_p\t\t\tPARAMS ((rtx, rtx));\n-extern rtx single_set\t\t\tPARAMS ((rtx));\n+extern rtx single_set_1\t\t\tPARAMS ((rtx));\n extern int multiple_sets\t\tPARAMS ((rtx));\n extern rtx find_last_value\t\tPARAMS ((rtx, rtx *, rtx, int));\n extern int refers_to_regno_p\t\tPARAMS ((unsigned int, unsigned int,"}, {"sha": "0d922c66c437ad9717eb3303427a1161e62d2869", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 72, "deletions": 27, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b1cdafbb6c7bef4c21922ae2ce25b64445dc49cc", "patch": "@@ -842,46 +842,91 @@ insn_dependent_p_1 (x, pat, data)\n    will not be used, which we ignore.  */\n \n rtx\n-single_set (insn)\n+single_set_1 (insn)\n      rtx insn;\n {\n   rtx set;\n+  rtx pat = PATTERN (insn);\n   int i;\n   \n-  if (! INSN_P (insn))\n-    return 0;\n-\n-  if (GET_CODE (PATTERN (insn)) == SET)\n-    return PATTERN (insn);\n-  \n-  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+  if (GET_CODE (pat) == PARALLEL)\n     {\n-      for (i = 0, set = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n+      rtx x, sub;\n+      /* This part is is performance critical for targets that use a lot of\n+\t parallels, such as i386.  We want to accept as single set\n+\t instructions even an instructions with multiple sets where only\n+\t one has live result, but we attempt to delay this tests only for\n+\t multiple set instructions to reduce amount of calls to\n+\t find_reg_note and side_effects_p.\n+       \n+\t We expect the \"common\" instruction to be parallel with first SET\n+\t followed by the clobbers.  So first we get the set, then look\n+\t if it is followed by USE or CLOBBER. If so, we just return expect\n+\t no SETs after these.  When SET is followed by another SET, we\n+\t continue by the clomplex loop trought all members of PARALLEL.\n+       */\n+#ifdef ENABLE_CHECKING\n+      if (XVECLEN (pat, 0) < 2)\n+\tabort ();\n+#endif\n+      set = XVECEXP (pat, 0, 0);\n+      switch (GET_CODE (set))\n \t{\n-\t  rtx sub = XVECEXP (PATTERN (insn), 0, i);\n-\n-\t  switch (GET_CODE (sub))\n+#ifdef ENABLE_CHECKING\n+\t  case USE:\n+\t  case CLOBBER:\n+\t    /* Instruction should not consist only from USEs and CLOBBERS,\n+\t       since then gcc is allowed to remove it entirely.  In case\n+\t       something else is present, it should be first in the pattern.  */\n+\t    abort();\n+#endif\n+\t  case SET:\n+\t    break;\n+\t  default:\n+\t    return NULL_RTX;\n+\t}\n+      x = XVECEXP (pat, 0, 1);\n+      switch (GET_CODE (x))\n+\t{\n+\tcase USE:\n+\tcase CLOBBER:\n+#ifdef ENABLE_CHECKING\n+\t  /* The USEs and CLOBBERs should always come last in the pattern.  */\n+\t  for (i = XVECLEN (pat, 0) - 1; i > 1; i--)\n+\t    if (GET_CODE (XVECEXP (pat, 0, i)) != USE\n+\t\t&& GET_CODE (XVECEXP (pat, 0, i)) != CLOBBER)\n+\t      abort();\n+#endif\n+\t    return set;\n+\tcase SET:\n+\t  /* Multiple set insns - we are off the critical path now.  */\n+\t  for (i = XVECLEN (pat, 0) - 1; i > 0; i--)\n \t    {\n-\t    case USE:\n-\t    case CLOBBER:\n-\t      break;\n-\n-\t    case SET:\n-\t      if (! find_reg_note (insn, REG_UNUSED, SET_DEST (sub))\n-\t\t  || side_effects_p (sub))\n+\t      sub = XVECEXP (pat, 0, i);\n+\t      switch GET_CODE (sub)\n \t\t{\n-\t\t  if (set)\n-\t\t    return 0;\n-\t\t  else\n+\t\tcase USE:\n+\t\tcase CLOBBER:\n+\t\t  break;\n+\n+\t\tcase SET:\n+\t\t  if (!set\n+\t\t      || (find_reg_note (insn, REG_UNUSED, SET_DEST (set))\n+\t\t\t  && side_effects_p (set)))\n \t\t    set = sub;\n-\t\t}\n-\t      break;\n+\t\t  else if (! find_reg_note (insn, REG_UNUSED, SET_DEST (sub))\n+\t\t\t   || side_effects_p (sub))\n+\t\t    return NULL_RTX;\n+\t\t  break;\n \n-\t    default:\n-\t      return 0;\n+\t\tdefault:\n+\t\t  return NULL_RTX;\n+\t\t}\n \t    }\n+\t  return set;\n+\tdefault:\n+\t  return NULL_RTX;\n \t}\n-      return set;\n     }\n   \n   return 0;"}]}