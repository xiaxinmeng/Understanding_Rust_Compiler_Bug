{"sha": "ed239f5a439be5360c431fea7ff3063c6d844692", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQyMzlmNWE0MzliZTUzNjBjNDMxZmVhN2ZmMzA2M2M2ZDg0NDY5Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-19T20:38:07Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-19T20:38:07Z"}, "message": "tree.def (VIEW_CONVERT_EXPR): New tree code.\n\n\t* tree.def (VIEW_CONVERT_EXPR): New tree code.\n\t* tree.h (handled_component_p): New declaration.\n\t* alias.c (handled_component_p): Move function from here ...\n\t* expr.c (handled_component_p): ... to here and non longer static.\n\t(is_zeros_p, case VIEW_CONVERT_EXPR): New case.\n\t(store_field): Remove unneeded MEM_COPY_ATTRIBUTES call.\n\t(get_inner_reference): Handle VIEW_CONVERT_EXPR.\n\t(expand_expr, case VAR_DECL): Clean up handling of re-layout case.\n\t(expand_expr, case VIEW_CONVERT_EXPR): New case.\n\t(expand_expr, cse ADDR_EXPR): No need to copy if already\n\tBIGGEST_ALIGNMENT.\n\t* fold-const.c (fold, case VIEW_CONVERT_EXPR): New case.\n\t* varasm.c (initializer_constant_value_p, case VIEW_CONVERT_EXPR): New.\n\t(output_constant): Handle VIEW_CONVERT_EXPR.\n\t* dwarf2out.c (loc-descriptor_from_tree, add_bound_info):\n\tAdd new case for VIEW_CONVERT_EXPR.\n\nFrom-SVN: r47179", "tree": {"sha": "2542ba620d211064d29aeacfe75ac81b9312fd17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2542ba620d211064d29aeacfe75ac81b9312fd17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed239f5a439be5360c431fea7ff3063c6d844692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed239f5a439be5360c431fea7ff3063c6d844692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed239f5a439be5360c431fea7ff3063c6d844692", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed239f5a439be5360c431fea7ff3063c6d844692/comments", "author": null, "committer": null, "parents": [{"sha": "a5a9cb26e59353c633db9c6eb2eac959d1b3e697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a9cb26e59353c633db9c6eb2eac959d1b3e697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a9cb26e59353c633db9c6eb2eac959d1b3e697"}], "stats": {"total": 197, "additions": 160, "deletions": 37}, "files": [{"sha": "6cae9dc73eef8d8e2484ac87f47f49dc1df3c42e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -1,3 +1,22 @@\n+Mon Nov 19 15:13:43 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* tree.def (VIEW_CONVERT_EXPR): New tree code.\n+\t* tree.h (handled_component_p): New declaration.\n+\t* alias.c (handled_component_p): Move function from here ...\n+\t* expr.c (handled_component_p): ... to here and non longer static.\n+\t(is_zeros_p, case VIEW_CONVERT_EXPR): New case.\n+\t(store_field): Remove unneeded MEM_COPY_ATTRIBUTES call.\n+\t(get_inner_reference): Handle VIEW_CONVERT_EXPR.\n+\t(expand_expr, case VAR_DECL): Clean up handling of re-layout case.\n+\t(expand_expr, case VIEW_CONVERT_EXPR): New case.\n+\t(expand_expr, cse ADDR_EXPR): No need to copy if already\n+\tBIGGEST_ALIGNMENT.\n+\t* fold-const.c (fold, case VIEW_CONVERT_EXPR): New case.\n+\t* varasm.c (initializer_constant_value_p, case VIEW_CONVERT_EXPR): New.\n+\t(output_constant): Handle VIEW_CONVERT_EXPR.\n+\t* dwarf2out.c (loc-descriptor_from_tree, add_bound_info):\n+\tAdd new case for VIEW_CONVERT_EXPR.\n+\n 2001-11-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* a29k/unix.h (ASM_FILE_START): Const-ify."}, {"sha": "a92cf857844f63de38cd86ad0ae65296eef51423", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -95,7 +95,6 @@ static void record_set\t\t\tPARAMS ((rtx, rtx, void *));\n static rtx find_base_term\t\tPARAMS ((rtx));\n static int base_alias_check\t\tPARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t\t enum machine_mode));\n-static int handled_component_p\t\tPARAMS ((tree));\n static rtx find_base_value\t\tPARAMS ((rtx));\n static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n@@ -399,31 +398,6 @@ find_base_decl (t)\n     }\n }\n \n-/* Return 1 if T is an expression that get_inner_reference handles.  */\n-\n-static int\n-handled_component_p (t)\n-     tree t;\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case BIT_FIELD_REF:\n-    case COMPONENT_REF:\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-    case NON_LVALUE_EXPR:\n-      return 1;\n-\n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-      return (TYPE_MODE (TREE_TYPE (t))\n-\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0))));\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n /* Return 1 if all the nested component references handled by\n    get_inner_reference in T are such that we can address the object in T.  */\n "}, {"sha": "164b05112813145645ebac6b4e19fee69924cd41", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -7929,6 +7929,7 @@ loc_descriptor_from_tree (loc, addressp)\n     case NOP_EXPR:\n     case CONVERT_EXPR:\n     case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n     case SAVE_EXPR:\n       return loc_descriptor_from_tree (TREE_OPERAND (loc, 0), addressp);\n \n@@ -8849,6 +8850,7 @@ add_bound_info (subrange_die, bound_attr, bound)\n     case CONVERT_EXPR:\n     case NOP_EXPR:\n     case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n       add_bound_info (subrange_die, bound_attr, TREE_OPERAND (bound, 0));\n       break;\n "}, {"sha": "0c5429ec1873180781e8c0a667888a723df9b49b", "filename": "gcc/expr.c", "status": "modified", "additions": 115, "deletions": 4, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -4360,6 +4360,7 @@ is_zeros_p (exp)\n     case CONVERT_EXPR:\n     case NOP_EXPR:\n     case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n       return is_zeros_p (TREE_OPERAND (exp, 0));\n \n     case INTEGER_CST:\n@@ -5151,7 +5152,6 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n       rtx blk_object = copy_rtx (object);\n \n       PUT_MODE (blk_object, BLKmode);\n-      MEM_COPY_ATTRIBUTES (blk_object, object);\n \n       if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n \temit_move_insn (object, target);\n@@ -5451,6 +5451,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  continue;\n \t}\n       else if (TREE_CODE (exp) != NON_LVALUE_EXPR\n+\t       && TREE_CODE (exp) != VIEW_CONVERT_EXPR\n \t       && ! ((TREE_CODE (exp) == NOP_EXPR\n \t\t      || TREE_CODE (exp) == CONVERT_EXPR)\n \t\t     && (TYPE_MODE (TREE_TYPE (exp))\n@@ -5479,6 +5480,32 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n   return exp;\n }\n \n+/* Return 1 if T is an expression that get_inner_reference handles.  */\n+\n+int\n+handled_component_p (t)\n+     tree t;\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case BIT_FIELD_REF:\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case NON_LVALUE_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      return 1;\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      return (TYPE_MODE (TREE_TYPE (t))\n+\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0))));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Subroutine of expand_exp: compute memory_usage from modifier.  */\n \n static enum memory_use_mode\n@@ -6287,9 +6314,19 @@ expand_expr (exp, target, tmode, modifier)\n       if (DECL_SIZE (exp) == 0 && COMPLETE_TYPE_P (TREE_TYPE (exp))\n \t  && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n \t{\n+\t  rtx value = DECL_RTL_IF_SET (exp);\n+\n \t  layout_decl (exp, 0);\n-\t  PUT_MODE (DECL_RTL (exp), DECL_MODE (exp));\n-\t  set_mem_align (DECL_RTL (exp), DECL_ALIGN (exp));\n+\n+\t  /* If the RTL was already set, update its mode and memory\n+\t     attributes.  */\n+\t  if (value != 0)\n+\t    {\n+\t      PUT_MODE (value, DECL_MODE (exp));\n+\t      SET_DECL_RTL (exp, 0);\n+\t      set_mem_attributes (value, exp, 1);\n+\t      SET_DECL_RTL (exp, value);\n+\t    }\n \t}\n \n       /* Although static-storage variables start off initialized, according to\n@@ -7500,6 +7537,79 @@ expand_expr (exp, target, tmode, modifier)\n \t\t      TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n       return target;\n \n+    case VIEW_CONVERT_EXPR:\n+      op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, mode, 0);\n+\n+      /* If the input and output modes are both the same, we are done.\n+\t Otherwise, if neither mode is BLKmode and both are within a word, we\n+\t can use gen_lowpart.  If neither is true, store the operand into\n+\t memory and convert the MEM to the new mode.  */\n+      if (TYPE_MODE (type) == GET_MODE (op0))\n+\t;\n+      else if (TYPE_MODE (type) != BLKmode && GET_MODE (op0) != BLKmode\n+\t       && GET_MODE_SIZE (TYPE_MODE (type)) <= UNITS_PER_WORD\n+\t       && GET_MODE_SIZE (GET_MODE (op0)) <= UNITS_PER_WORD)\n+\top0 = gen_lowpart (TYPE_MODE (type), op0);\n+      else\n+\t{\n+\t  tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t  enum machine_mode non_blkmode\n+\t    = GET_MODE (op0) == BLKmode ? TYPE_MODE (type) : GET_MODE (op0);\n+\n+\t  if (CONSTANT_P (op0))\n+\t    op0 = validize_mem (force_const_mem (TYPE_MODE (inner_type), op0));\n+\t  else\n+\t    {\n+\t      if (target == 0 || GET_MODE (target) != TYPE_MODE (inner_type))\n+\t\ttarget\n+\t\t  = assign_stack_temp_for_type (TYPE_MODE (inner_type),\n+\t\t\t\t\t\tGET_MODE_SIZE (non_blkmode),\n+\t\t\t\t\t\t0, inner_type);\n+\n+\t      if (GET_MODE (target) == BLKmode)\n+\t\temit_block_move (target, op0,\n+\t\t\t\t expr_size (TREE_OPERAND (exp, 0)));\n+\t      else\n+\t\temit_move_insn (target, op0);\n+\n+\t      op0 = target;\n+\t    }\n+\t}\n+\n+      if (GET_CODE (op0) == MEM)\n+\t{\n+\t  op0 = copy_rtx (op0);\n+\n+\t  /* If the output type is such that the operand is known to be\n+\t     aligned, indicate that it is.  Otherwise, we need only be\n+\t     concerned about alignment for non-BLKmode results.  */\n+\t  if (TYPE_ALIGN_OK (type))\n+\t    set_mem_align (op0, MAX (MEM_ALIGN (op0), TYPE_ALIGN (type)));\n+\t  else if (TYPE_MODE (type) != BLKmode && STRICT_ALIGNMENT\n+\t\t   && MEM_ALIGN (op0) < GET_MODE_ALIGNMENT (TYPE_MODE (type)))\n+\t    {\n+\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t      HOST_WIDE_INT temp_size = MAX (int_size_in_bytes (inner_type),\n+\t\t\t\t\t     GET_MODE_SIZE (TYPE_MODE (type)));\n+\t      rtx new = assign_stack_temp_for_type (TYPE_MODE (type),\n+\t\t\t\t\t\t    temp_size, 0, type);\n+\t      rtx new_with_op0_mode = copy_rtx (new);\n+\n+\t      PUT_MODE (new_with_op0_mode, GET_MODE (op0));\n+\t      if (GET_MODE (op0) == BLKmode)\n+\t\temit_block_move (new_with_op0_mode, op0,\n+\t\t\t\t GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))));\n+\t      else\n+\t\temit_move_insn (new_with_op0_mode, op0);\n+\n+\t      op0 = new;\n+\t    }\n+      \n+\t  PUT_MODE (op0, TYPE_MODE (type));\n+\t}\n+\n+      return op0;\n+\n     case PLUS_EXPR:\n       /* We come here from MINUS_EXPR when the second operand is a\n          constant.  */\n@@ -8668,7 +8778,8 @@ expand_expr (exp, target, tmode, modifier)\n \t     strict alignment.  */\n \t  if (STRICT_ALIGNMENT && GET_MODE (op0) == BLKmode\n \t      && (TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (exp, 0)))\n-\t\t  > MEM_ALIGN (op0)))\n+\t\t  > MEM_ALIGN (op0))\n+\t      && MEM_ALIGN (op0) < BIGGEST_ALIGNMENT)\n \t    {\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t      rtx new"}, {"sha": "2083c55abfaba78ee51da7b14fc34a846c1a3e18", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -5308,6 +5308,12 @@ fold (expr)\n \t}\n       return fold_convert (t, arg0);\n \n+    case VIEW_CONVERT_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (t, 0)) == VIEW_CONVERT_EXPR)\n+\treturn build1 (VIEW_CONVERT_EXPR, type,\n+\t\t       TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n+      return t;\n+\n #if 0  /* This loses on &\"foo\"[0].  */\n     case ARRAY_REF:\n \t{"}, {"sha": "c4f08cf5f0d2fa426d97232d793b54dd6b63c2d1", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -691,6 +691,13 @@ DEFTREECODE (NOP_EXPR, \"nop_expr\", '1', 1)\n /* Value is same as argument, but guaranteed not an lvalue.  */\n DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n \n+/* Represents viewing something of one type as being of a second type.\n+   This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n+   the idiom *(type2 *)&X in C.  The only operand is the value to be\n+   viewed as being of another type.  It is undefined if the type of the\n+   input and of the expression have different sizes.  */\n+DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", '1', 1)\n+\n /* Represents something we computed once and will use multiple times.\n    First operand is that expression.  Second is the function decl\n    in which the SAVE_EXPR was created.  The third operand is the RTL,"}, {"sha": "c28edf12df6160744e03f82d0aa06c6031dcd253", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -2587,6 +2587,10 @@ extern tree get_inner_reference\t\tPARAMS ((tree, HOST_WIDE_INT *,\n \t\t\t\t\t\t enum machine_mode *, int *,\n \t\t\t\t\t\t int *));\n \n+/* Return 1 if T is an expression that get_inner_reference handles.  */\n+\n+extern int handled_component_p\t\tPARAMS ((tree));\n+\n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */\n "}, {"sha": "32dabe82d0824931d1b7661de50eaf6b35899759", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed239f5a439be5360c431fea7ff3063c6d844692/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ed239f5a439be5360c431fea7ff3063c6d844692", "patch": "@@ -4288,6 +4288,7 @@ initializer_constant_valid_p (value, endtype)\n     case FDESC_EXPR:\n       return staticp (TREE_OPERAND (value, 0)) ? TREE_OPERAND (value, 0) : 0;\n \n+    case VIEW_CONVERT_EXPR:\n     case NON_LVALUE_EXPR:\n       return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n \n@@ -4442,10 +4443,9 @@ output_constant (exp, size, align)\n {\n   enum tree_code code = TREE_CODE (TREE_TYPE (exp));\n \n-  /* Some front-ends use constants other than the standard\n-     language-indepdent varieties, but which may still be output\n-     directly.  Give the front-end a chance to convert EXP to a\n-     language-independent representation.  */\n+  /* Some front-ends use constants other than the standard language-indepdent\n+     varieties, but which may still be output directly.  Give the front-end a\n+     chance to convert EXP to a language-independent representation.  */\n   if (lang_expand_constant)\n     {\n       exp = (*lang_expand_constant) (exp);\n@@ -4462,9 +4462,9 @@ output_constant (exp, size, align)\n   while ((TREE_CODE (exp) == NOP_EXPR\n \t  && (TREE_TYPE (exp) == TREE_TYPE (TREE_OPERAND (exp, 0))\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (exp))))\n-\t || (TREE_CODE (exp) == CONVERT_EXPR\n-\t     && code == UNION_TYPE)\n-\t || TREE_CODE (exp) == NON_LVALUE_EXPR)\n+\t || (TREE_CODE (exp) == CONVERT_EXPR && code == UNION_TYPE)\n+\t || TREE_CODE (exp) == NON_LVALUE_EXPR\n+\t || TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n     {\n       exp = TREE_OPERAND (exp, 0);\n       code = TREE_CODE (TREE_TYPE (exp));"}]}