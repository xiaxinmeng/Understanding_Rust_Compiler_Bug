{"sha": "b9a6624012d373b43c70193b13fd226f7e5b4c24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlhNjYyNDAxMmQzNzNiNDNjNzAxOTNiMTNmZDIyNmY3ZTViNGMyNA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-08-24T07:56:56Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-08-24T07:56:56Z"}, "message": "bb-reorder.c (copy_bb, [...]): Add argument to duplicate_block.\n\n\t* bb-reorder.c (copy_bb, duplicate_computed_gotos): Add argument\n\tto duplicate_block.\n\t* cfghooks.c (duplicate_block): Added position where to place\n\tnew block as argument.\n\t* cfghooks.h (duplicate_block): Declaration changed.\n\t* cfglayout.c (copy_bbs): Add argument after.  Pass it to\n\tduplicate_block.\n\t* cfglayout.h (copy_bbs): Declaration changed.\n\t* cfgloop.h (loop_version): Declaration changed.\n\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Pass\n\tposition to copy_bbs.\n\t(loop_version): Pass position to duplicate_loop_to_header_edge.\n\tAdd place_after argument and position new blocks according to\n\tit.\n\t* modulo-sched.c (sms_schedule): Pass place_after argument\n\tto loop_version.\n\t* tracer.c (tail_duplicate): Pass argument to duplicate_block.\n\t* tree-cfg.c (split_edge_bb_loc): New function.\n\t(tree_split_edge, tree_duplicate_sese_region): Use split_edge_bb_loc\n\tto determine position of new blocks.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Pass argument\n\tto loop_version.\n\t* tree-ssa-threadupdate.c (create_block_for_threading): Pass\n\targument to duplicate_block.\n\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg):\n\tPass position to copy_bbs.\n\nFrom-SVN: r103437", "tree": {"sha": "bc85c149f3a2ee968ec2f35b28ea170572c7b44d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc85c149f3a2ee968ec2f35b28ea170572c7b44d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9a6624012d373b43c70193b13fd226f7e5b4c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a6624012d373b43c70193b13fd226f7e5b4c24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a6624012d373b43c70193b13fd226f7e5b4c24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a6624012d373b43c70193b13fd226f7e5b4c24/comments", "author": null, "committer": null, "parents": [{"sha": "87de2376fdeee0702f6df2ed1ec96681796640a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87de2376fdeee0702f6df2ed1ec96681796640a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87de2376fdeee0702f6df2ed1ec96681796640a6"}], "stats": {"total": 166, "additions": 122, "deletions": 44}, "files": [{"sha": "533b33d13cddfc0ae25bf34b466074f767ca79b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -1,3 +1,32 @@\n+2005-08-24  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* bb-reorder.c (copy_bb, duplicate_computed_gotos): Add argument\n+\tto duplicate_block.\n+\t* cfghooks.c (duplicate_block): Added position where to place\n+\tnew block as argument.\n+\t* cfghooks.h (duplicate_block): Declaration changed.\n+\t* cfglayout.c (copy_bbs): Add argument after.  Pass it to\n+\tduplicate_block.\n+\t* cfglayout.h (copy_bbs): Declaration changed.\n+\t* cfgloop.h (loop_version): Declaration changed.\n+\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Pass\n+\tposition to copy_bbs.\n+\t(loop_version): Pass position to duplicate_loop_to_header_edge.\n+\tAdd place_after argument and position new blocks according to\n+\tit.\n+\t* modulo-sched.c (sms_schedule): Pass place_after argument\n+\tto loop_version.\n+\t* tracer.c (tail_duplicate): Pass argument to duplicate_block.\n+\t* tree-cfg.c (split_edge_bb_loc): New function.\n+\t(tree_split_edge, tree_duplicate_sese_region): Use split_edge_bb_loc\n+\tto determine position of new blocks.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_loop): Pass argument\n+\tto loop_version.\n+\t* tree-ssa-threadupdate.c (create_block_for_threading): Pass\n+\targument to duplicate_block.\n+\t* tree-vectorizer.c (slpeel_tree_duplicate_loop_to_edge_cfg):\n+\tPass position to copy_bbs.\n+\n 2005-08-24  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* fold-const.c (ptr_difference_const): Use"}, {"sha": "c5de2352fa2fc2a81f4ffd931df7100b308b5656", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -758,7 +758,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n {\n   basic_block new_bb;\n \n-  new_bb = duplicate_block (old_bb, e);\n+  new_bb = duplicate_block (old_bb, e, bb);\n   BB_COPY_PARTITION (new_bb, old_bb);\n \n   gcc_assert (e->dest == new_bb);\n@@ -2072,7 +2072,7 @@ duplicate_computed_gotos (void)\n       if (!bitmap_bit_p (candidates, single_succ (bb)->index))\n \tcontinue;\n \n-      new_bb = duplicate_block (single_succ (bb), single_succ_edge (bb));\n+      new_bb = duplicate_block (single_succ (bb), single_succ_edge (bb), bb);\n       new_bb->aux = bb->aux;\n       bb->aux = new_bb;\n       new_bb->il.rtl->visited = 1;"}, {"sha": "138bc4ab2ae7d5d5033237281d6ce77e62244f41", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -691,10 +691,11 @@ can_duplicate_block_p (basic_block bb)\n }\n \n /* Duplicates basic block BB and redirects edge E to it.  Returns the\n-   new basic block.  */\n+   new basic block.  The new basic block is placed after the basic block\n+   AFTER.  */\n \n basic_block\n-duplicate_block (basic_block bb, edge e)\n+duplicate_block (basic_block bb, edge e, basic_block after)\n {\n   edge s, n;\n   basic_block new_bb;\n@@ -713,6 +714,8 @@ duplicate_block (basic_block bb, edge e)\n #endif\n \n   new_bb = cfg_hooks->duplicate_block (bb);\n+  if (after)\n+    move_block_after (new_bb, after);\n \n   new_bb->loop_depth = bb->loop_depth;\n   new_bb->flags = bb->flags;"}, {"sha": "8d5222a5f13ae35e2b21cfc495409d2eac6f9434", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -157,7 +157,7 @@ extern void tidy_fallthru_edges (void);\n extern void predict_edge (edge e, enum br_predictor predictor, int probability);\n extern bool predicted_by_p (basic_block bb, enum br_predictor predictor);\n extern bool can_duplicate_block_p (basic_block);\n-extern basic_block duplicate_block (basic_block, edge);\n+extern basic_block duplicate_block (basic_block, edge, basic_block);\n extern bool block_ends_with_call_p (basic_block bb);\n extern bool block_ends_with_condjump_p (basic_block bb);\n extern int flow_call_edges_add (sbitmap);"}, {"sha": "9cc2f8fa7097327f03971d6007b82424489a1fdf", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -1243,12 +1243,15 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n    is copied, we do not set the new blocks as header or latch.\n \n    Created copies of N_EDGES edges in array EDGES are stored in array NEW_EDGES,\n-   also in the same order.  */\n+   also in the same order.\n+   \n+   Newly created basic blocks are put after the basic block AFTER in the\n+   instruction stream, and the order of the blocks in BBS array is preserved.  */\n \n void\n copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n \t  edge *edges, unsigned num_edges, edge *new_edges,\n-\t  struct loop *base)\n+\t  struct loop *base, basic_block after)\n {\n   unsigned i, j;\n   basic_block bb, new_bb, dom_bb;\n@@ -1259,7 +1262,8 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n     {\n       /* Duplicate.  */\n       bb = bbs[i];\n-      new_bb = new_bbs[i] = duplicate_block (bb, NULL);\n+      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after);\n+      after = new_bb;\n       bb->flags |= BB_DUPLICATED;\n       /* Add to loop.  */\n       add_bb_to_loop (new_bb, bb->loop_father->copy);"}, {"sha": "52bd4e9ee140e33744572c3153af137a4b12e2b7", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -31,7 +31,8 @@ extern void insn_locators_initialize (void);\n extern void reemit_insn_block_notes (void);\n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n-\t\t      edge *, unsigned, edge *, struct loop *);\n+\t\t      edge *, unsigned, edge *, struct loop *,\n+\t\t      basic_block);\n extern rtx duplicate_insn_chain (rtx, rtx);\n \n #endif /* GCC_CFGLAYOUT_H */"}, {"sha": "b237631433ddd10e5664d8868070bfd32f5dc891", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -309,7 +309,7 @@ extern bool duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n extern struct loop *loopify (struct loops *, edge, edge,\n \t\t\t     basic_block, edge, edge, bool);\n struct loop * loop_version (struct loops *, struct loop *, void *,\n-\t\t\t    basic_block *);\t\t\t     \n+\t\t\t    basic_block *, bool);\n extern bool remove_path (struct loops *, edge);\n extern edge split_loop_bb (basic_block, void *);\n "}, {"sha": "806daa789f717fc861b6b22fe46f386da653ec0d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 49, "deletions": 21, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -860,6 +860,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   int p, freq_in, freq_le, freq_out_orig;\n   int prob_pass_thru, prob_pass_wont_exit, prob_pass_main;\n   int add_irreducible_flag;\n+  basic_block place_after;\n \n   gcc_assert (e->dest == loop->header);\n   gcc_assert (ndupl > 0);\n@@ -871,7 +872,10 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       gcc_assert (!flow_bb_inside_loop_p (loop, orig->dest));\n     }\n \n-  bbs = get_loop_body (loop);\n+  n = loop->num_nodes;\n+  bbs = get_loop_body_in_dom_order (loop);\n+  gcc_assert (bbs[0] == loop->header);\n+  gcc_assert (bbs[n  - 1] == loop->latch);\n \n   /* Check whether duplication is possible.  */\n   if (!can_copy_bbs_p (bbs, loop->num_nodes))\n@@ -975,8 +979,6 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \n   loop->copy = target;\n \n-  n = loop->num_nodes;\n-\n   first_active = xmalloc (n * sizeof (basic_block));\n   if (is_latch)\n     {\n@@ -995,13 +997,16 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n   spec_edges[SE_ORIG] = orig;\n   spec_edges[SE_LATCH] = latch_edge;\n \n+  place_after = e->src;\n   for (j = 0; j < ndupl; j++)\n     {\n       /* Copy loops.  */\n       copy_loops_to (loops, orig_loops, n_orig_loops, target);\n \n       /* Copy bbs.  */\n-      copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop);\n+      copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop,\n+\t\tplace_after);\n+      place_after = new_spec_edges[SE_LATCH]->src;\n \n       if (flags & DLTHE_RECORD_COPY_NUMBER)\n \tfor (i = 0; i < n; i++)\n@@ -1039,7 +1044,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t  redirect_edge_and_branch_force (new_spec_edges[SE_LATCH],\n \t\t\t\t\t  loop->header);\n \t  set_immediate_dominator (CDI_DOMINATORS, new_bbs[0], latch);\n-\t  latch = loop->latch = new_bbs[1];\n+\t  latch = loop->latch = new_bbs[n - 1];\n \t  e = latch_edge = new_spec_edges[SE_LATCH];\n \t}\n       else\n@@ -1060,7 +1065,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       if (!first_active_latch)\n \t{\n \t  memcpy (first_active, new_bbs, n * sizeof (basic_block));\n-\t  first_active_latch = new_bbs[1];\n+\t  first_active_latch = new_bbs[n - 1];\n \t}\n \n       /* Set counts and frequencies.  */\n@@ -1426,21 +1431,26 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n \n /* Main entry point for Loop Versioning transformation.\n    \n-This transformation given a condition and a loop, creates\n--if (condition) { loop_copy1 } else { loop_copy2 },\n-where loop_copy1 is the loop transformed in one way, and loop_copy2\n-is the loop transformed in another way (or unchanged). 'condition'\n-may be a run time test for things that were not resolved by static\n-analysis (overlapping ranges (anti-aliasing), alignment, etc.).  */\n+   This transformation given a condition and a loop, creates\n+   -if (condition) { loop_copy1 } else { loop_copy2 },\n+   where loop_copy1 is the loop transformed in one way, and loop_copy2\n+   is the loop transformed in another way (or unchanged). 'condition'\n+   may be a run time test for things that were not resolved by static\n+   analysis (overlapping ranges (anti-aliasing), alignment, etc.).\n+\n+   If PLACE_AFTER is true, we place the new loop after LOOP in the\n+   instruction stream, otherwise it is placed before LOOP.  */\n \n struct loop *\n loop_version (struct loops *loops, struct loop * loop, \n-\t      void *cond_expr, basic_block *condition_bb)\n+\t      void *cond_expr, basic_block *condition_bb,\n+\t      bool place_after)\n {\n   basic_block first_head, second_head;\n   edge entry, latch_edge, exit, true_edge, false_edge;\n   int irred_flag;\n   struct loop *nloop;\n+  basic_block cond_bb;\n \n   /* CHECKME: Loop versioning does not handle nested loop at this point.  */\n   if (loop->inner)\n@@ -1464,21 +1474,24 @@ loop_version (struct loops *loops, struct loop * loop,\n   second_head = entry->dest;\n \n   /* Split loop entry edge and insert new block with cond expr.  */\n-  *condition_bb =  lv_adjust_loop_entry_edge (first_head, second_head,\n-\t\t\t\t\t      entry, cond_expr);\n-  if (!*condition_bb)\n+  cond_bb =  lv_adjust_loop_entry_edge (first_head, second_head,\n+\t\t\t\t\tentry, cond_expr);\n+  if (condition_bb)\n+    *condition_bb = cond_bb;\n+\n+  if (!cond_bb)\n     {\n       entry->flags |= irred_flag;\n       return NULL;\n     }\n \n   latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n   \n-  extract_cond_bb_edges (*condition_bb, &true_edge, &false_edge);\n+  extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n   nloop = loopify (loops,\n \t\t   latch_edge,\n \t\t   single_pred_edge (get_bb_copy (loop->header)),\n-\t\t   *condition_bb, true_edge, false_edge,\n+\t\t   cond_bb, true_edge, false_edge,\n \t\t   false /* Do not redirect all edges.  */);\n \n   exit = loop->single_exit;\n@@ -1489,15 +1502,30 @@ loop_version (struct loops *loops, struct loop * loop,\n   lv_flush_pending_stmts (latch_edge);\n \n   /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */ \n-  extract_cond_bb_edges (*condition_bb, &true_edge, &false_edge);\n+  extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n   lv_flush_pending_stmts (false_edge);\n   /* Adjust irreducible flag.  */\n   if (irred_flag)\n     {\n-      (*condition_bb)->flags |= BB_IRREDUCIBLE_LOOP;\n+      cond_bb->flags |= BB_IRREDUCIBLE_LOOP;\n       loop_preheader_edge (loop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n       loop_preheader_edge (nloop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n-      single_pred_edge ((*condition_bb))->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      single_pred_edge (cond_bb)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+    }\n+\n+  if (place_after)\n+    {\n+      basic_block *bbs = get_loop_body_in_dom_order (nloop), after;\n+      unsigned i;\n+\n+      after = loop->latch;\n+\n+      for (i = 0; i < nloop->num_nodes; i++)\n+\t{\n+\t  move_block_after (bbs[i], after);\n+\t  after = bbs[i];\n+\t}\n+      free (bbs);\n     }\n \n   /* At this point condition_bb is loop predheader with two successors, "}, {"sha": "ed06fc466200ab57cc36572d140d6783647bf7e6", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -1261,7 +1261,8 @@ sms_schedule (FILE *dump_file)\n \t\t  rtx comp_rtx = gen_rtx_fmt_ee (GT, VOIDmode, count_reg,\n \t\t\t\t\t\t GEN_INT(stage_count));\n \n-\t\t  nloop = loop_version (loops, loop, comp_rtx, &condition_bb);\n+\t\t  nloop = loop_version (loops, loop, comp_rtx, &condition_bb,\n+\t\t\t\t\ttrue);\n \t\t}\n \n \t      /* Set new iteration count of loop kernel.  */"}, {"sha": "27f06c57d896ed2448500a5032d1dce8341b11e6", "filename": "gcc/tracer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -281,7 +281,7 @@ tail_duplicate (void)\n \t      e = find_edge (bb, bb2);\n \n \t      nduplicated += counts [bb2->index];\n-\t      bb2 = duplicate_block (bb2, e);\n+\t      bb2 = duplicate_block (bb2, e, bb);\n \n \t      /* Reconsider the original copy of block we've duplicated.\n \t         Removing the most common predecessor may make it to be"}, {"sha": "7a0bf1b9102c467d7c9d485d150519b29c448b8c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -3037,6 +3037,22 @@ reinstall_phi_args (edge new_edge, edge old_edge)\n   PENDING_STMT (old_edge) = NULL;\n }\n \n+/* Returns the basic block after that the new basic block created\n+   by splitting edge EDGE_IN should be placed.  Tries to keep the new block\n+   near its \"logical\" location.  This is of most help to humans looking\n+   at debugging dumps.  */\n+\n+static basic_block\n+split_edge_bb_loc (edge edge_in)\n+{\n+  basic_block dest = edge_in->dest;\n+\n+  if (dest->prev_bb && find_edge (dest->prev_bb, dest))\n+    return edge_in->src;\n+  else\n+    return dest->prev_bb;\n+}\n+\n /* Split a (typically critical) edge EDGE_IN.  Return the new block.\n    Abort on abnormal edges.  */\n \n@@ -3052,13 +3068,7 @@ tree_split_edge (edge edge_in)\n   src = edge_in->src;\n   dest = edge_in->dest;\n \n-  /* Place the new block in the block list.  Try to keep the new block\n-     near its \"logical\" location.  This is of most help to humans looking\n-     at debugging dumps.  */\n-  if (dest->prev_bb && find_edge (dest->prev_bb, dest))\n-    after_bb = edge_in->src;\n-  else\n-    after_bb = dest->prev_bb;\n+  after_bb = split_edge_bb_loc (edge_in);\n \n   new_bb = create_empty_bb (after_bb);\n   new_bb->frequency = EDGE_FREQUENCY (edge_in);\n@@ -4346,7 +4356,8 @@ tree_duplicate_sese_region (edge entry, edge exit,\n \tentry_freq = total_freq;\n     }\n \n-  copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop);\n+  copy_bbs (region, n_region, region_copy, &exit, 1, &exit_copy, loop,\n+\t    split_edge_bb_loc (entry));\n   if (total_count)\n     {\n       scale_bbs_frequencies_gcov_type (region, n_region,"}, {"sha": "d0625c52ec955486c067c3dd0bd476ff3a49c195", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -282,5 +282,5 @@ tree_unswitch_loop (struct loops *loops, struct loop *loop,\n   gcc_assert (loop->inner == NULL);\n \n   return loop_version (loops, loop, unshare_expr (cond), \n-\t\t       &condition_bb);\n+\t\t       &condition_bb, false);\n }"}, {"sha": "1b7733b0c9b878f3d26711c8f5a2f18568dcc2c0", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -199,7 +199,7 @@ create_block_for_threading (basic_block bb, struct redirection_data *rd)\n {\n   /* We can use the generic block duplication code and simply remove\n      the stuff we do not need.  */\n-  rd->dup_block = duplicate_block (bb, NULL);\n+  rd->dup_block = duplicate_block (bb, NULL, NULL);\n \n   /* Zero out the profile, since the block is unreachable for now.  */\n   rd->dup_block->frequency = 0;"}, {"sha": "84ed5a90c3b477965334a65f2f0092b60898d1f2", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a6624012d373b43c70193b13fd226f7e5b4c24/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=b9a6624012d373b43c70193b13fd226f7e5b4c24", "patch": "@@ -862,7 +862,8 @@ slpeel_tree_duplicate_loop_to_edge_cfg (struct loop *loop, struct loops *loops,\n   new_bbs = xmalloc (sizeof (basic_block) * loop->num_nodes);\n \n   copy_bbs (bbs, loop->num_nodes, new_bbs,\n-\t    &loop->single_exit, 1, &new_loop->single_exit, NULL);\n+\t    &loop->single_exit, 1, &new_loop->single_exit, NULL,\n+\t    e->src);\n \n   /* Duplicating phi args at exit bbs as coming \n      also from exit of duplicated loop.  */"}]}