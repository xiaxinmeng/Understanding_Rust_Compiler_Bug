{"sha": "0566484a15d36465693a4afb06538d63925579b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2NjQ4NGExNWQzNjQ2NTY5M2E0YWZiMDY1MzhkNjM5MjU1NzliNA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:30:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T09:30:31Z"}, "message": "[multiple changes]\n\n2015-01-06  Pierre-Marie Derodat  <derodat@adacore.com>\n\n\t* scos.ads: Update documentation about the SCO table build\n\tprocess and about table records format.\n\t* par_sco.ads (SCO_Record): Rename to SCO_Record_Raw.\n\t(SCO_Record_Filtered): New procedure.\n\t(Set_SCO_Logical_Operator): New procedure.\n\t(dsco): Update documentation.\n\t* par_sco.adb: Update library-level comments.\n\t(SCO_Generation_State_Type): New type.\n\t(SCO_Generation_State): New variable.\n\t(SCO_Raw_Table): New package instanciation.\n\t(Condition_Pragma_Hash_Table): Rename to SCO_Raw_Hash_Table.\n\t(\"<\"): New.\n\t(Tristate): New type.\n\t(Is_Logical_Operator): Return Tristate and update documentation.\n\t(Has_Decision): Update call to Is_Logical_Operator and complete\n\tdocumentation.\n\t(Set_Table_Entry): Rename to Set_Raw_Table_Entry, update\n\tcomment, add an assertion for state checking and change\n\treferences to SCO_Table into SCO_Raw_Table.\n\t(dsco): Refactor to dump the raw and the filtered tables.\n\t(Process_Decisions.Output_Decision_Operand): Handle putative\n\tshort-circuit operators.\n\t(Process_Decisions.Output_Element): Update references\n\tto Set_Table_Entry and to Condition_Pragma_Hash_Table.\n\t(Process_Decisions.Process_Decision_Operand): Update call\n\tto Is_Logical_Operator.\n\t(Process_Decisions.Process_Node): Handle putative short-circuit\n\toperators and change references to\n\tSCO_Table into SCO_Raw_Table.\n\t(SCO_Output): Add an assertion\n\tfor state checking and remove code that used to stamp out SCO entries.\n\t(SCO_Pragma_Disabled): Change reference to SCO_Table\n\tinto SCO_Raw_Table.\n\t(SCO_Record): Rename to SCO_Record_Raw,\n\tadd an assertion for state checking and change references\n\tto SCO_Table into SCO_Raw_Table.\n\t(Set_SCO_Condition): Add an assertion for state checking, update\n\treferences to Condition_Pragma_Hash_Table and change references to\n\tSCO_Table into SCO_Raw_Table.\n\t(Set_SCO_Pragma_Enabled): Add an assertion for state checking and\n\tchange references to SCO_Table into SCO_Raw_Table.\n\t(Set_SCO_Logical_Operator): New procedure.\n\t(Traverse_Declarations_Or_Statements.Set_Statement_Entry): Update\n\treferences to Set_Table_Entry and to Condition_Pragma_Hash_Table.\n\t(SCO_Record_Fildered): New procedure.\n\t* gnat1drv.adb (Gnat1drv): Invoke the SCO filtering pass.\n\t* lib-writ.adb (Write_ALI): Invoke the SCO filtering pass and\n\toutput SCOs.\n\t* par-load.adb (Load): Update reference to SCO_Record.\n\t* par.adb (Par): Update reference to SCO_Record.\n\t* put_scos.adb (Put_SCOs): Add an assertion to check that no\n\tputative SCO condition reaches this end.\n\t* sem_ch10.adb (Analyze_Proper_Body): Update reference to SCO_Record.\n\t* sem_res.adb (Resolve_Logical_Op): Validate putative SCOs\n\twhen corresponding to an \"and\"/\"or\" operator affected by the\n\tShort_Circuit_And_Or pragma.\n\n2015-01-06  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Use_Package): Give more specific error\n\tmsg for attempted USE of generic subprogram or subprogram.\n\nFrom-SVN: r219234", "tree": {"sha": "ff4fe4260a64b68180a5c1b4cb5184120bf30148", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff4fe4260a64b68180a5c1b4cb5184120bf30148"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0566484a15d36465693a4afb06538d63925579b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0566484a15d36465693a4afb06538d63925579b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0566484a15d36465693a4afb06538d63925579b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0566484a15d36465693a4afb06538d63925579b4/comments", "author": null, "committer": null, "parents": [{"sha": "72eaa365121eec76a29a0a231c4edfff28f2a250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72eaa365121eec76a29a0a231c4edfff28f2a250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72eaa365121eec76a29a0a231c4edfff28f2a250"}], "stats": {"total": 1008, "additions": 861, "deletions": 147}, "files": [{"sha": "93bbd583132310500cb7d220aebd48f17c95f27e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -1,3 +1,67 @@\n+2015-01-06  Pierre-Marie Derodat  <derodat@adacore.com>\n+\n+\t* scos.ads: Update documentation about the SCO table build\n+\tprocess and about table records format.\n+\t* par_sco.ads (SCO_Record): Rename to SCO_Record_Raw.\n+\t(SCO_Record_Filtered): New procedure.\n+\t(Set_SCO_Logical_Operator): New procedure.\n+\t(dsco): Update documentation.\n+\t* par_sco.adb: Update library-level comments.\n+\t(SCO_Generation_State_Type): New type.\n+\t(SCO_Generation_State): New variable.\n+\t(SCO_Raw_Table): New package instanciation.\n+\t(Condition_Pragma_Hash_Table): Rename to SCO_Raw_Hash_Table.\n+\t(\"<\"): New.\n+\t(Tristate): New type.\n+\t(Is_Logical_Operator): Return Tristate and update documentation.\n+\t(Has_Decision): Update call to Is_Logical_Operator and complete\n+\tdocumentation.\n+\t(Set_Table_Entry): Rename to Set_Raw_Table_Entry, update\n+\tcomment, add an assertion for state checking and change\n+\treferences to SCO_Table into SCO_Raw_Table.\n+\t(dsco): Refactor to dump the raw and the filtered tables.\n+\t(Process_Decisions.Output_Decision_Operand): Handle putative\n+\tshort-circuit operators.\n+\t(Process_Decisions.Output_Element): Update references\n+\tto Set_Table_Entry and to Condition_Pragma_Hash_Table.\n+\t(Process_Decisions.Process_Decision_Operand): Update call\n+\tto Is_Logical_Operator.\n+\t(Process_Decisions.Process_Node): Handle putative short-circuit\n+\toperators and change references to\n+\tSCO_Table into SCO_Raw_Table.\n+\t(SCO_Output): Add an assertion\n+\tfor state checking and remove code that used to stamp out SCO entries.\n+\t(SCO_Pragma_Disabled): Change reference to SCO_Table\n+\tinto SCO_Raw_Table.\n+\t(SCO_Record): Rename to SCO_Record_Raw,\n+\tadd an assertion for state checking and change references\n+\tto SCO_Table into SCO_Raw_Table.\n+\t(Set_SCO_Condition): Add an assertion for state checking, update\n+\treferences to Condition_Pragma_Hash_Table and change references to\n+\tSCO_Table into SCO_Raw_Table.\n+\t(Set_SCO_Pragma_Enabled): Add an assertion for state checking and\n+\tchange references to SCO_Table into SCO_Raw_Table.\n+\t(Set_SCO_Logical_Operator): New procedure.\n+\t(Traverse_Declarations_Or_Statements.Set_Statement_Entry): Update\n+\treferences to Set_Table_Entry and to Condition_Pragma_Hash_Table.\n+\t(SCO_Record_Fildered): New procedure.\n+\t* gnat1drv.adb (Gnat1drv): Invoke the SCO filtering pass.\n+\t* lib-writ.adb (Write_ALI): Invoke the SCO filtering pass and\n+\toutput SCOs.\n+\t* par-load.adb (Load): Update reference to SCO_Record.\n+\t* par.adb (Par): Update reference to SCO_Record.\n+\t* put_scos.adb (Put_SCOs): Add an assertion to check that no\n+\tputative SCO condition reaches this end.\n+\t* sem_ch10.adb (Analyze_Proper_Body): Update reference to SCO_Record.\n+\t* sem_res.adb (Resolve_Logical_Op): Validate putative SCOs\n+\twhen corresponding to an \"and\"/\"or\" operator affected by the\n+\tShort_Circuit_And_Or pragma.\n+\n+2015-01-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Use_Package): Give more specific error\n+\tmsg for attempted USE of generic subprogram or subprogram.\n+\n 2015-01-06  Robert Dewar  <dewar@adacore.com>\n \n \t* s-valllu.adb, a-tiinau.adb, a-timoau.adb, a-ztinau.adb, a-ztmoau.adb,"}, {"sha": "9e77996a97ce7f4ade0ee08ba73ac2cefc6f1d55", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -1279,6 +1279,13 @@ begin\n          Write_ALI (Object => True);\n       end if;\n \n+      --  Some back ends (for instance Gigi) are known to rely on SCOs for code\n+      --  generation. Make sure they are available.\n+\n+      if Generate_SCO then\n+         Par_SCO.SCO_Record_Filtered;\n+      end if;\n+\n       --  Back end needs to explicitly unlock tables it needs to touch\n \n       Atree.Lock;"}, {"sha": "0e6aec6de0c896d23c4e80e77f85784125cf6a97", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -1494,6 +1494,7 @@ package body Lib.Writ is\n       --  Output SCO information if present\n \n       if Generate_SCO then\n+         SCO_Record_Filtered;\n          SCO_Output;\n       end if;\n "}, {"sha": "7415253ee4310e1ad29cabeff21a84744db22445", "filename": "gcc/ada/par-load.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-load.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -285,7 +285,7 @@ begin\n             Main_Unit_Entity := Cunit_Entity (Unum);\n \n             if Generate_SCO then\n-               SCO_Record (Unum);\n+               SCO_Record_Raw (Unum);\n             end if;\n          end if;\n "}, {"sha": "83f320b324e50136b8cb83364ebdda28d55541bb", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -1658,7 +1658,7 @@ begin\n       --  Here we make the SCO table entries for the main unit\n \n       if Generate_SCO then\n-         SCO_Record (Main_Unit);\n+         SCO_Record_Raw (Main_Unit);\n       end if;\n \n       --  Remaining steps are to create implicit label declarations and to load"}, {"sha": "406d152b6437d9383ada76993aa58ea92862c2c8", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 731, "deletions": 126, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -44,9 +44,45 @@ with Table;\n \n with GNAT.HTable;      use GNAT.HTable;\n with GNAT.Heap_Sort_G;\n+with GNAT.Table;\n \n package body Par_SCO is\n \n+   --------------------------\n+   -- First-pass SCO table --\n+   --------------------------\n+\n+   --  The Short_Circuit_And_Or pragma enables one to use AND and OR operators\n+   --  in source code while the ones used with booleans will be interpreted as\n+   --  their short circuit alternatives (AND THEN and OR ELSE). Thus, the true\n+   --  meaning of these operators is known only after the semantic analysis.\n+\n+   --  However, decision SCOs include short circuit operators only. The SCO\n+   --  information generation pass must be done before expansion, hence before\n+   --  the semantic analysis. Because of this, the SCO information generation\n+   --  is done in two passes.\n+\n+   --  The first one (SCO_Record_Raw, before semantic analysis) completes the\n+   --  SCO_Raw_Table assuming all AND/OR operators are short circuit ones.\n+   --  Then, the semantic analysis determines which operators are promoted to\n+   --  short circuit ones. Finally, the second pass (SCO_Record_Filtered)\n+   --  translates the SCO_Raw_Table to SCO_Table, taking care of removing the\n+   --  remaining AND/OR operators and of adjusting decisions accordingly\n+   --  (splitting decisions, removing empty ones, etc.).\n+\n+   type SCO_Generation_State_Type is (None, Raw, Filtered);\n+   SCO_Generation_State : SCO_Generation_State_Type := None;\n+   --  Keep track of the SCO generation state: this will prevent us from\n+   --  running some steps multiple times (the second pass has to be started\n+   --  from multiple places).\n+\n+   package SCO_Raw_Table is new GNAT.Table (\n+     Table_Component_Type => SCO_Table_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 500,\n+     Table_Increment      => 300);\n+\n    -----------------------\n    -- Unit Number Table --\n    -----------------------\n@@ -67,14 +103,15 @@ package body Par_SCO is\n      Table_Increment      => 200,\n      Table_Name           => \"SCO_Unit_Number_Entry\");\n \n-   ---------------------------------\n-   -- Condition/Pragma Hash Table --\n-   ---------------------------------\n+   ------------------------------------------\n+   -- Condition/Operator/Pragma Hash Table --\n+   ------------------------------------------\n \n    --  We need to be able to get to conditions quickly for handling the calls\n    --  to Set_SCO_Condition efficiently, and similarly to get to pragmas to\n-   --  handle calls to Set_SCO_Pragma_Enabled. For this purpose we identify the\n-   --  conditions and pragmas in the table by their starting sloc, and use this\n+   --  handle calls to Set_SCO_Pragma_Enabled (the same holds for operators and\n+   --  Set_SCO_Logical_Operator). For this purpose we identify the conditions,\n+   --  operators and pragmas in the table by their starting sloc, and use this\n    --  hash table to map from these sloc values to SCO_Table indexes.\n \n    type Header_Num is new Integer range 0 .. 996;\n@@ -86,7 +123,10 @@ package body Par_SCO is\n    function Equal (F1, F2 : Source_Ptr) return Boolean;\n    --  Function to test two keys for equality\n \n-   package Condition_Pragma_Hash_Table is new Simple_HTable\n+   function \"<\" (S1, S2 : Source_Location) return Boolean;\n+   --  Function to test for source locations order\n+\n+   package SCO_Raw_Hash_Table is new Simple_HTable\n      (Header_Num, Int, 0, Source_Ptr, Hash, Equal);\n    --  The actual hash table\n \n@@ -98,12 +138,20 @@ package body Par_SCO is\n    --  N is the node for a subexpression. Returns True if the subexpression\n    --  contains a nested decision (i.e. either is a logical operator, or\n    --  contains a logical operator in its subtree).\n+   --\n+   --  This must be used in the first pass (SCO_Record_Raw) only: here AND/OR\n+   --  operators are considered as short circuit, just in case the\n+   --  Short_Circuit_And_Or pragma is used: only real short circuit operations\n+   --  will be kept in the secord pass.\n \n-   function Is_Logical_Operator (N : Node_Id) return Boolean;\n+   type Tristate is (False, True, Unknown);\n+\n+   function Is_Logical_Operator (N : Node_Id) return Tristate;\n    --  N is the node for a subexpression. This procedure determines whether N\n-   --  a logical operator (including short circuit conditions, but excluding\n-   --  OR and AND) and returns True if so. Note that in cases where True is\n-   --  returned, callers assume Nkind (N) in N_Op.\n+   --  is a logical operator: True for short circuit conditions, Unknown for OR\n+   --  and AND (the Short_Circuit_And_Or pragma may be used) and False\n+   --  otherwise. Note that in cases where True is returned, callers assume\n+   --  Nkind (N) in N_Op.\n \n    function To_Source_Location (S : Source_Ptr) return Source_Location;\n    --  Converts Source_Ptr value to Source_Location (line/col) format\n@@ -125,15 +173,15 @@ package body Par_SCO is\n       Pragma_Sloc : Source_Ptr);\n    --  Calls above procedure for each element of the list L\n \n-   procedure Set_Table_Entry\n+   procedure Set_Raw_Table_Entry\n      (C1                 : Character;\n       C2                 : Character;\n       From               : Source_Ptr;\n       To                 : Source_Ptr;\n       Last               : Boolean;\n       Pragma_Sloc        : Source_Ptr := No_Location;\n       Pragma_Aspect_Name : Name_Id    := No_Name);\n-   --  Append an entry to SCO_Table with fields set as per arguments\n+   --  Append an entry to SCO_Raw_Table with fields set as per arguments\n \n    type Dominant_Info is record\n       K : Character;\n@@ -192,6 +240,56 @@ package body Par_SCO is\n    ----------\n \n    procedure dsco is\n+      procedure Dump_Entry (Index : Nat; T : SCO_Table_Entry);\n+      --  Dump a SCO table entry\n+\n+      ----------------\n+      -- Dump_Entry --\n+      ----------------\n+\n+      procedure Dump_Entry (Index : Nat; T : SCO_Table_Entry) is\n+      begin\n+         Write_Str  (\"  \");\n+         Write_Int  (Index);\n+         Write_Char ('.');\n+\n+         if T.C1 /= ' ' then\n+            Write_Str  (\"  C1 = '\");\n+            Write_Char (T.C1);\n+            Write_Char (''');\n+         end if;\n+\n+         if T.C2 /= ' ' then\n+            Write_Str  (\"  C2 = '\");\n+            Write_Char (T.C2);\n+            Write_Char (''');\n+         end if;\n+\n+         if T.From /= No_Source_Location then\n+            Write_Str (\"  From = \");\n+            Write_Int (Int (T.From.Line));\n+            Write_Char (':');\n+            Write_Int (Int (T.From.Col));\n+         end if;\n+\n+         if T.To /= No_Source_Location then\n+            Write_Str (\"  To = \");\n+            Write_Int (Int (T.To.Line));\n+            Write_Char (':');\n+            Write_Int (Int (T.To.Col));\n+         end if;\n+\n+         if T.Last then\n+            Write_Str (\"  True\");\n+         else\n+            Write_Str (\"  False\");\n+         end if;\n+\n+         Write_Eol;\n+      end Dump_Entry;\n+\n+   --  Start of processing for dsco\n+\n    begin\n       --  Dump SCO unit table\n \n@@ -205,7 +303,7 @@ package body Par_SCO is\n          begin\n             Write_Str (\"  \");\n             Write_Int (Int (Index));\n-            Write_Str (\".  Dep_Num = \");\n+            Write_Str (\"  Dep_Num = \");\n             Write_Int (Int (UTE.Dep_Num));\n             Write_Str (\"  From = \");\n             Write_Int (Int (UTE.From));\n@@ -239,55 +337,28 @@ package body Par_SCO is\n          end loop;\n       end if;\n \n-      --  Dump SCO table itself\n+      --  Dump SCO raw-table\n \n       Write_Eol;\n-      Write_Line (\"SCO Table\");\n+      Write_Line (\"SCO Raw Table\");\n       Write_Line (\"---------\");\n \n-      for Index in 1 .. SCO_Table.Last loop\n-         declare\n-            T : SCO_Table_Entry renames SCO_Table.Table (Index);\n-\n-         begin\n-            Write_Str  (\"  \");\n-            Write_Int  (Index);\n-            Write_Char ('.');\n-\n-            if T.C1 /= ' ' then\n-               Write_Str  (\"  C1 = '\");\n-               Write_Char (T.C1);\n-               Write_Char (''');\n-            end if;\n-\n-            if T.C2 /= ' ' then\n-               Write_Str  (\"  C2 = '\");\n-               Write_Char (T.C2);\n-               Write_Char (''');\n-            end if;\n-\n-            if T.From /= No_Source_Location then\n-               Write_Str (\"  From = \");\n-               Write_Int (Int (T.From.Line));\n-               Write_Char (':');\n-               Write_Int (Int (T.From.Col));\n-            end if;\n+      if SCO_Generation_State = Filtered then\n+         Write_Line (\"Empty (free'd after second pass)\");\n+      else\n+         for Index in 1 .. SCO_Raw_Table.Last loop\n+            Dump_Entry (Index, SCO_Raw_Table.Table (Index));\n+         end loop;\n+      end if;\n \n-            if T.To /= No_Source_Location then\n-               Write_Str (\"  To = \");\n-               Write_Int (Int (T.To.Line));\n-               Write_Char (':');\n-               Write_Int (Int (T.To.Col));\n-            end if;\n+      --  Dump SCO table itself\n \n-            if T.Last then\n-               Write_Str (\"  True\");\n-            else\n-               Write_Str (\"  False\");\n-            end if;\n+      Write_Eol;\n+      Write_Line (\"SCO Filtered Table\");\n+      Write_Line (\"---------\");\n \n-            Write_Eol;\n-         end;\n+      for Index in 1 .. SCO_Table.Last loop\n+         Dump_Entry (Index, SCO_Table.Table (Index));\n       end loop;\n    end dsco;\n \n@@ -300,6 +371,16 @@ package body Par_SCO is\n       return F1 = F2;\n    end Equal;\n \n+   -------\n+   -- < --\n+   -------\n+\n+   function \"<\" (S1, S2 : Source_Location) return Boolean is\n+   begin\n+      return S1.Line < S2.Line\n+        or else (S1.Line = S2.Line and then S1.Col < S2.Col);\n+   end \"<\";\n+\n    ------------------\n    -- Has_Decision --\n    ------------------\n@@ -317,7 +398,14 @@ package body Par_SCO is\n \n       function Check_Node (N : Node_Id) return Traverse_Result is\n       begin\n-         if Is_Logical_Operator (N) or else Nkind (N) = N_If_Expression then\n+         --  If we are not sure this is a logical operator (AND and OR may be\n+         --  turned into logical operators with the Short_Circuit_And_Or\n+         --  pragma), assume it is. Putative decisions will be discarded if\n+         --  needed in the secord pass.\n+\n+         if Is_Logical_Operator (N) /= False\n+            or else Nkind (N) = N_If_Expression\n+         then\n             return Abandon;\n          else\n             return OK;\n@@ -359,9 +447,15 @@ package body Par_SCO is\n    -- Is_Logical_Operator --\n    -------------------------\n \n-   function Is_Logical_Operator (N : Node_Id) return Boolean is\n+   function Is_Logical_Operator (N : Node_Id) return Tristate is\n    begin\n-      return Nkind_In (N, N_Op_Not, N_And_Then, N_Or_Else);\n+      if Nkind_In (N, N_Op_Not, N_And_Then, N_Or_Else) then\n+         return True;\n+      elsif Nkind_In (N, N_Op_And, N_Op_Or) then\n+         return Unknown;\n+      else\n+         return False;\n+      end if;\n    end Is_Logical_Operator;\n \n    -----------------------\n@@ -441,38 +535,54 @@ package body Par_SCO is\n       -----------------------------\n \n       procedure Output_Decision_Operand (N : Node_Id) is\n-         C : Character;\n-         L : Node_Id;\n+         C1, C2 : Character;\n+         --  C1 holds a character that identifies the operation while C2\n+         --  indicates whether we are sure (' ') or not ('?') this operation\n+         --  belongs to the decision. '?' entries will be filtered out in the\n+         --  second (SCO_Record_Filtered) pass.\n+\n+         L      : Node_Id;\n+         T      : Tristate;\n \n       begin\n          if No (N) then\n             return;\n+         end if;\n+\n+         T := Is_Logical_Operator (N);\n \n          --  Logical operator\n \n-         elsif Is_Logical_Operator (N) then\n+         if T /= False then\n             if Nkind (N) = N_Op_Not then\n-               C := '!';\n+               C1 := '!';\n                L := Empty;\n \n             else\n                L := Left_Opnd (N);\n \n                if Nkind_In (N, N_Op_Or, N_Or_Else) then\n-                  C := '|';\n-\n+                  C1 := '|';\n                else pragma Assert (Nkind_In (N, N_Op_And, N_And_Then));\n-                  C := '&';\n+                  C1 := '&';\n                end if;\n             end if;\n \n-            Set_Table_Entry\n-              (C1   => C,\n-               C2   => ' ',\n+            if T = True then\n+               C2 := ' ';\n+            else\n+               C2 := '?';\n+            end if;\n+\n+            Set_Raw_Table_Entry\n+              (C1   => C1,\n+               C2   => C2,\n                From => Sloc (N),\n                To   => No_Location,\n                Last => False);\n \n+            SCO_Raw_Hash_Table.Set (Sloc (N), SCO_Raw_Table.Last);\n+\n             Output_Decision_Operand (L);\n             Output_Decision_Operand (Right_Opnd (N));\n \n@@ -492,13 +602,13 @@ package body Par_SCO is\n          LSloc : Source_Ptr;\n       begin\n          Sloc_Range (N, FSloc, LSloc);\n-         Set_Table_Entry\n+         Set_Raw_Table_Entry\n            (C1   => ' ',\n             C2   => 'c',\n             From => FSloc,\n             To   => LSloc,\n             Last => False);\n-         Condition_Pragma_Hash_Table.Set (FSloc, SCO_Table.Last);\n+         SCO_Raw_Hash_Table.Set (FSloc, SCO_Raw_Table.Last);\n       end Output_Element;\n \n       -------------------\n@@ -561,7 +671,7 @@ package body Par_SCO is\n                raise Program_Error;\n          end case;\n \n-         Set_Table_Entry\n+         Set_Raw_Table_Entry\n            (C1                 => T,\n             C2                 => ' ',\n             From               => Loc,\n@@ -574,7 +684,7 @@ package body Par_SCO is\n          --  pragma, enter a hash table entry now.\n \n          if T = 'a' then\n-            Condition_Pragma_Hash_Table.Set (Loc, SCO_Table.Last);\n+            SCO_Raw_Hash_Table.Set (Loc, SCO_Raw_Table.Last);\n          end if;\n       end Output_Header;\n \n@@ -584,7 +694,7 @@ package body Par_SCO is\n \n       procedure Process_Decision_Operand (N : Node_Id) is\n       begin\n-         if Is_Logical_Operator (N) then\n+         if Is_Logical_Operator (N) /= False then\n             if Nkind (N) /= N_Op_Not then\n                Process_Decision_Operand (Left_Opnd (N));\n                X_Not_Decision := False;\n@@ -608,7 +718,7 @@ package body Par_SCO is\n             --  Logical operators, output table entries and then process\n             --  operands recursively to deal with nested conditions.\n \n-            when N_And_Then | N_Or_Else  | N_Op_Not =>\n+            when N_And_Then | N_Or_Else | N_Op_Not | N_Op_And | N_Op_Or =>\n                declare\n                   T : Character;\n \n@@ -625,7 +735,7 @@ package body Par_SCO is\n                   --  Output header for sequence\n \n                   X_Not_Decision := T = 'X' and then Nkind (N) = N_Op_Not;\n-                  Mark := SCO_Table.Last;\n+                  Mark := SCO_Raw_Table.Last;\n                   Output_Header (T);\n \n                   --  Output the decision\n@@ -637,12 +747,12 @@ package body Par_SCO is\n                   --  it, so delete it.\n \n                   if X_Not_Decision then\n-                     SCO_Table.Set_Last (Mark);\n+                     SCO_Raw_Table.Set_Last (Mark);\n \n                   --  Otherwise, set Last in last table entry to mark end\n \n                   else\n-                     SCO_Table.Table (SCO_Table.Last).Last := True;\n+                     SCO_Raw_Table.Table (SCO_Raw_Table.Last).Last := True;\n                   end if;\n \n                   --  Process any embedded decisions\n@@ -696,14 +806,14 @@ package body Par_SCO is\n       --  or short circuit form) appearing as the operand of an IF, WHILE,\n       --  EXIT WHEN, or special PRAGMA construct.\n \n-      if T /= 'X' and then not Is_Logical_Operator (N) then\n+      if T /= 'X' and then Is_Logical_Operator (N) = False then\n          Output_Header (T);\n          Output_Element (N);\n \n          --  Change Last in last table entry to True to mark end of\n          --  sequence, which is this case is only one element long.\n \n-         SCO_Table.Table (SCO_Table.Last).Last := True;\n+         SCO_Raw_Table.Table (SCO_Raw_Table.Last).Last := True;\n       end if;\n \n       Traverse (N);\n@@ -767,10 +877,9 @@ package body Par_SCO is\n    procedure SCO_Output is\n       procedure Populate_SCO_Instance_Table is\n         new Sinput.Iterate_On_Instances (Record_Instance);\n-\n-      SCO_Index : Nat;\n-\n    begin\n+      pragma Assert (SCO_Generation_State = Filtered);\n+\n       if Debug_Flag_Dot_OO then\n          dsco;\n       end if;\n@@ -835,25 +944,6 @@ package body Par_SCO is\n          end;\n       end loop;\n \n-      --  Stamp out SCO entries for decisions in disabled constructs (pragmas\n-      --  or aspects).\n-\n-      SCO_Index := 1;\n-      while SCO_Index <= SCO_Table.Last loop\n-         if Is_Decision (SCO_Table.Table (SCO_Index).C1)\n-           and then SCO_Pragma_Disabled\n-                      (SCO_Table.Table (SCO_Index).Pragma_Sloc)\n-         then\n-            loop\n-               SCO_Table.Table (SCO_Index).C1 := ASCII.NUL;\n-               exit when SCO_Table.Table (SCO_Index).Last;\n-               SCO_Index := SCO_Index + 1;\n-            end loop;\n-         end if;\n-\n-         SCO_Index := SCO_Index + 1;\n-      end loop;\n-\n       --  Now the tables are all setup for output to the ALI file\n \n       Write_SCOs_To_ALI_File;\n@@ -871,7 +961,7 @@ package body Par_SCO is\n          return False;\n       end if;\n \n-      Index := Condition_Pragma_Hash_Table.Get (Loc);\n+      Index := SCO_Raw_Hash_Table.Get (Loc);\n \n       --  The test here for zero is to deal with possible previous errors, and\n       --  for the case of pragma statement SCOs, for which we always set the\n@@ -880,7 +970,8 @@ package body Par_SCO is\n \n       if Index /= 0 then\n          declare\n-            T : SCO_Table_Entry renames SCO_Table.Table (Index);\n+            T : SCO_Table_Entry renames SCO_Raw_Table.Table (Index);\n+\n          begin\n             case T.C1 is\n                when 'S' =>\n@@ -913,11 +1004,11 @@ package body Par_SCO is\n       end if;\n    end SCO_Pragma_Disabled;\n \n-   ----------------\n-   -- SCO_Record --\n-   ----------------\n+   --------------------\n+   -- SCO_Record_Raw --\n+   --------------------\n \n-   procedure SCO_Record (U : Unit_Number_Type) is\n+   procedure SCO_Record_Raw (U : Unit_Number_Type) is\n       Lu   : Node_Id;\n       From : Nat;\n \n@@ -942,9 +1033,15 @@ package body Par_SCO is\n          pragma Assert (No (Actions (ADN)));\n       end Traverse_Aux_Decls;\n \n-   --  Start of processing for SCO_Record\n+   --  Start of processing for SCO_Record_Raw\n \n    begin\n+      --  It is legitimate to run this pass multiple times (once per unit) so\n+      --  run it even if it was already run before.\n+\n+      pragma Assert (SCO_Generation_State in None .. Raw);\n+      SCO_Generation_State := Raw;\n+\n       --  Ignore call if not generating code and generating SCO's\n \n       if not (Generate_SCO and then Operating_Mode = Generate_Code) then\n@@ -961,7 +1058,7 @@ package body Par_SCO is\n \n       --  Otherwise record starting entry\n \n-      From := SCO_Table.Last + 1;\n+      From := SCO_Raw_Table.Last + 1;\n \n       --  Get Unit (checking case of subunit)\n \n@@ -1004,16 +1101,21 @@ package body Par_SCO is\n          File_Name  => null,\n          File_Index => Get_Source_File_Index (Sloc (Lu)),\n          From       => From,\n-         To         => SCO_Table.Last));\n+         To         => SCO_Raw_Table.Last));\n \n       SCO_Unit_Number_Table.Append (U);\n-   end SCO_Record;\n+   end SCO_Record_Raw;\n \n    -----------------------\n    -- Set_SCO_Condition --\n    -----------------------\n \n    procedure Set_SCO_Condition (Cond : Node_Id; Val : Boolean) is\n+\n+      --  SCO annotations are not processed after the filtering pass\n+\n+      pragma Assert (not Generate_SCO or else SCO_Generation_State = Raw);\n+\n       Orig  : constant Node_Id := Original_Node (Cond);\n       Index : Nat;\n       Start : Source_Ptr;\n@@ -1023,7 +1125,7 @@ package body Par_SCO is\n                                   (False => 'f', True => 't');\n    begin\n       Sloc_Range (Orig, Start, Dummy);\n-      Index := Condition_Pragma_Hash_Table.Get (Start);\n+      Index := SCO_Raw_Hash_Table.Get (Start);\n \n       --  Index can be zero for boolean expressions that do not have SCOs\n       --  (simple decisions outside of a control flow structure), or in case\n@@ -1033,16 +1135,45 @@ package body Par_SCO is\n          return;\n \n       else\n-         pragma Assert (SCO_Table.Table (Index).C1 = ' ');\n-         SCO_Table.Table (Index).C2 := Constant_Condition_Code (Val);\n+         pragma Assert (SCO_Raw_Table.Table (Index).C1 = ' ');\n+         SCO_Raw_Table.Table (Index).C2 := Constant_Condition_Code (Val);\n       end if;\n    end Set_SCO_Condition;\n \n+   ------------------------------\n+   -- Set_SCO_Logical_Operator --\n+   ------------------------------\n+\n+   procedure Set_SCO_Logical_Operator (Op : Node_Id) is\n+\n+      --  SCO annotations are not processed after the filtering pass\n+\n+      pragma Assert (not Generate_SCO or else SCO_Generation_State = Raw);\n+\n+      Orig      : constant Node_Id := Original_Node (Op);\n+      Orig_Sloc : constant Source_Ptr := Sloc (Orig);\n+      Index     : constant Nat := SCO_Raw_Hash_Table.Get (Orig_Sloc);\n+\n+   begin\n+      --  All (putative) logical operators are supposed to have their own entry\n+      --  in the SCOs table. However, the semantic analysis may invoke this\n+      --  subprogram with nodes that are out of the SCO generation scope.\n+\n+      if Index /= 0 then\n+         SCO_Raw_Table.Table (Index).C2 := ' ';\n+      end if;\n+   end Set_SCO_Logical_Operator;\n+\n    ----------------------------\n    -- Set_SCO_Pragma_Enabled --\n    ----------------------------\n \n    procedure Set_SCO_Pragma_Enabled (Loc : Source_Ptr) is\n+\n+      --  SCO annotations are not processed after the filtering pass\n+\n+      pragma Assert (not Generate_SCO or else SCO_Generation_State = Raw);\n+\n       Index : Nat;\n \n    begin\n@@ -1060,7 +1191,7 @@ package body Par_SCO is\n       --  generic case, the call to this procedure is made on a copy of the\n       --  original node, so we can't use the Node_Id value.\n \n-      Index := Condition_Pragma_Hash_Table.Get (Loc);\n+      Index := SCO_Raw_Hash_Table.Get (Loc);\n \n       --  A zero index here indicates that semantic analysis found an\n       --  activated pragma at Loc which does not have a corresponding pragma\n@@ -1074,7 +1205,7 @@ package body Par_SCO is\n \n       else\n          declare\n-            T : SCO_Table_Entry renames SCO_Table.Table (Index);\n+            T : SCO_Table_Entry renames SCO_Raw_Table.Table (Index);\n \n          begin\n             --  Note: may be called multiple times for the same sloc, so\n@@ -1103,11 +1234,11 @@ package body Par_SCO is\n       end if;\n    end Set_SCO_Pragma_Enabled;\n \n-   ---------------------\n-   -- Set_Table_Entry --\n-   ---------------------\n+   -------------------------\n+   -- Set_Raw_Table_Entry --\n+   -------------------------\n \n-   procedure Set_Table_Entry\n+   procedure Set_Raw_Table_Entry\n      (C1                 : Character;\n       C2                 : Character;\n       From               : Source_Ptr;\n@@ -1116,16 +1247,17 @@ package body Par_SCO is\n       Pragma_Sloc        : Source_Ptr := No_Location;\n       Pragma_Aspect_Name : Name_Id    := No_Name)\n    is\n+      pragma Assert (SCO_Generation_State = Raw);\n    begin\n-      SCO_Table.Append\n+      SCO_Raw_Table.Append\n         ((C1                 => C1,\n           C2                 => C2,\n           From               => To_Source_Location (From),\n           To                 => To_Source_Location (To),\n           Last               => Last,\n           Pragma_Sloc        => Pragma_Sloc,\n           Pragma_Aspect_Name => Pragma_Aspect_Name));\n-   end Set_Table_Entry;\n+   end Set_Raw_Table_Entry;\n \n    ------------------------\n    -- To_Source_Location --\n@@ -1286,7 +1418,7 @@ package body Par_SCO is\n                      if Current_Dominant.K /= 'E' then\n                         To := No_Location;\n                      end if;\n-                     Set_Table_Entry\n+                     Set_Raw_Table_Entry\n                        (C1                 => '>',\n                         C2                 => Current_Dominant.K,\n                         From               => From,\n@@ -1310,8 +1442,8 @@ package body Par_SCO is\n \n                if SCE.Typ = 'p' then\n                   Pragma_Sloc := SCE.From;\n-                  Condition_Pragma_Hash_Table.Set\n-                    (Pragma_Sloc, SCO_Table.Last + 1);\n+                  SCO_Raw_Hash_Table.Set\n+                    (Pragma_Sloc, SCO_Raw_Table.Last + 1);\n                   Pragma_Aspect_Name := Pragma_Name (SCE.N);\n                   pragma Assert (Pragma_Aspect_Name /= No_Name);\n \n@@ -1320,7 +1452,7 @@ package body Par_SCO is\n                   pragma Assert (Pragma_Aspect_Name /= No_Name);\n                end if;\n \n-               Set_Table_Entry\n+               Set_Raw_Table_Entry\n                  (C1                 => 'S',\n                   C2                 => SCE.Typ,\n                   From               => SCE.From,\n@@ -2275,4 +2407,477 @@ package body Par_SCO is\n          D => Dom_Info);\n    end Traverse_Subprogram_Or_Task_Body;\n \n+   -------------------------\n+   -- SCO_Record_Filtered --\n+   -------------------------\n+\n+   procedure SCO_Record_Filtered is\n+      type Decision is record\n+         Kind : Character;\n+         --  Type of the SCO decision (see comments for SCO_Table_Entry.C1)\n+\n+         Sloc : Source_Location;\n+\n+         Top  : Nat;\n+         --  Index in the SCO_Raw_Table for the root operator/condition for the\n+         --  expression that controls the decision.\n+      end record;\n+      --  Decision descriptor: used to gather information about a candidate\n+      --  SCO decision.\n+\n+      package Pending_Decisions is new Table.Table\n+        (Table_Component_Type => Decision,\n+         Table_Index_Type     => Nat,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 1000,\n+         Table_Increment      => 200,\n+         Table_Name           => \"Filter_Pending_Decisions\");\n+      --  Table used to hold decisions to process during the collection pass\n+\n+      function Is_Decision (Idx : Nat) return Boolean;\n+      --  Return if the expression tree starting at Idx has adjacent nested\n+      --  nodes that make a decision.\n+\n+      procedure Search_Nested_Decisions (Idx : in out Nat);\n+      --  Collect decisions to add to the filtered SCO table starting at the\n+      --  node at Idx in the SCO raw table. This node must not be part of an\n+      --  already-processed decision. Set Idx to the first node index passed\n+      --  the whole expression tree.\n+\n+      procedure Skip_Decision\n+        (Idx                      : in out Nat;\n+         Process_Nested_Decisions : Boolean);\n+      --  Skip all the nodes that belong to the decision starting at Idx. If\n+      --  Process_Nested_Decision, call Search_Nested_Decisions on the first\n+      --  nested nodes that do not belong to the decision. Set Idx to the first\n+      --  node index passed the whole expression tree.\n+\n+      procedure Collect_Decisions\n+        (D    : Decision;\n+         Next : out Nat);\n+      --  Collect decisions to add to the filtered SCO table starting at the\n+      --  D decision (including it and its nested operators/conditions). Set\n+      --  Next to the first node index passed the whole decision.\n+\n+      procedure Compute_Range\n+        (Idx  : in out Nat;\n+         From : out Source_Location;\n+         To   : out Source_Location);\n+      --  Compute the source location range for the expression tree starting at\n+      --  Idx in the SCO raw table. Store its bounds in From and To.\n+\n+      procedure Add_Expression_Tree (Idx : in out Nat);\n+      --  Add SCO raw table entries for the decision controlling expression\n+      --  tree starting at Idx to the filtered SCO table.\n+\n+      procedure Process_Pending_Decisions\n+        (Original_Decision : SCO_Table_Entry);\n+      --  Complete the filtered SCO table using collected decisions. Output\n+      --  decisions inherit the pragma information from the original decision.\n+\n+      -----------------\n+      -- Is_Decision --\n+      -----------------\n+\n+      function Is_Decision (Idx : Nat) return Boolean is\n+         Index : Nat := Idx;\n+\n+      begin\n+         loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Index);\n+\n+            begin\n+               case T.C1 is\n+                  when ' ' =>\n+                     return False;\n+\n+                  when '!' =>\n+\n+                     --  This is a decision iff the only operand of the NOT\n+                     --  operator could be a standalone decision.\n+\n+                     Index := Idx + 1;\n+\n+                  when others =>\n+\n+                     --  This node is a logical operator (and thus could be a\n+                     --  standalone decision) iff it is a short circuit\n+                     --  operator.\n+\n+                     return T.C2 /= '?';\n+\n+               end case;\n+            end;\n+         end loop;\n+      end Is_Decision;\n+\n+      -----------------------------\n+      -- Search_Nested_Decisions --\n+      -----------------------------\n+\n+      procedure Search_Nested_Decisions (Idx : in out Nat)\n+      is\n+      begin\n+         loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n+\n+            begin\n+               case T.C1 is\n+                  when ' ' =>\n+                     Idx := Idx + 1;\n+                     exit;\n+\n+                  when '!' =>\n+                     Collect_Decisions\n+                       ((Kind => 'X',\n+                         Sloc => T.From,\n+                         Top  => Idx),\n+                        Idx);\n+                     exit;\n+\n+                  when others =>\n+                     if T.C2 = '?' then\n+\n+                        --  This in not a logical operator: start looking for\n+                        --  nested decisions from here. Recurse over the left\n+                        --  child and let the loop take care of the right one.\n+\n+                        Idx := Idx + 1;\n+                        Search_Nested_Decisions (Idx);\n+\n+                     else\n+                        --  We found a nested decision\n+\n+                        Collect_Decisions\n+                          ((Kind => 'X',\n+                            Sloc => T.From,\n+                            Top  => Idx),\n+                            Idx);\n+                        exit;\n+                     end if;\n+               end case;\n+            end;\n+         end loop;\n+      end Search_Nested_Decisions;\n+\n+      -------------------\n+      -- Skip_Decision --\n+      -------------------\n+\n+      procedure Skip_Decision\n+        (Idx                      : in out Nat;\n+         Process_Nested_Decisions : Boolean)\n+      is\n+      begin\n+         loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n+\n+            begin\n+               Idx := Idx + 1;\n+\n+               case T.C1 is\n+                  when ' ' =>\n+                     exit;\n+\n+                  when '!' =>\n+\n+                     --  This NOT operator belongs to the outside decision:\n+                     --  just skip it.\n+\n+                     null;\n+\n+                  when others =>\n+                     if T.C2 = '?' and then Process_Nested_Decisions then\n+\n+                        --  This in not a logical operator: start looking for\n+                        --  nested decisions from here. Recurse over the left\n+                        --  child and let the loop take care of the right one.\n+\n+                        Search_Nested_Decisions (Idx);\n+\n+                     else\n+                        --  This is a logical operator, so it belongs to the\n+                        --  outside decision: skip its left child, then let the\n+                        --  loop take care of the right one.\n+\n+                        Skip_Decision (Idx, Process_Nested_Decisions);\n+                     end if;\n+               end case;\n+            end;\n+         end loop;\n+      end Skip_Decision;\n+\n+      -----------------------\n+      -- Collect_Decisions --\n+      -----------------------\n+\n+      procedure Collect_Decisions\n+        (D    : Decision;\n+         Next : out Nat)\n+      is\n+         Idx : Nat := D.Top;\n+      begin\n+         if D.Kind /= 'X' or else Is_Decision (D.Top) then\n+            Pending_Decisions.Append (D);\n+         end if;\n+\n+         Skip_Decision (Idx, True);\n+         Next := Idx;\n+      end Collect_Decisions;\n+\n+      -------------------\n+      -- Compute_Range --\n+      -------------------\n+\n+      procedure Compute_Range\n+        (Idx  : in out Nat;\n+         From : out Source_Location;\n+         To   : out Source_Location)\n+      is\n+         Sloc_F, Sloc_T : Source_Location := No_Source_Location;\n+\n+         procedure Process_One;\n+         --  Process one node of the tree, and recurse over children. Update\n+         --  Idx during the traversal.\n+\n+         -----------------\n+         -- Process_One --\n+         -----------------\n+\n+         procedure Process_One is\n+         begin\n+            if Sloc_F = No_Source_Location\n+                 or else\n+               SCO_Raw_Table.Table (Idx).From < Sloc_F\n+            then\n+               Sloc_F := SCO_Raw_Table.Table (Idx).From;\n+            end if;\n+            if Sloc_T = No_Source_Location\n+                 or else\n+               Sloc_T < SCO_Raw_Table.Table (Idx).To\n+            then\n+               Sloc_T := SCO_Raw_Table.Table (Idx).To;\n+            end if;\n+\n+            if SCO_Raw_Table.Table (Idx).C1 = ' ' then\n+\n+               --  This is a condition: nothing special to do\n+\n+               Idx := Idx + 1;\n+\n+            elsif SCO_Raw_Table.Table (Idx).C1 = '!' then\n+\n+               --  The \"not\" operator has only one operand\n+\n+               Idx := Idx + 1;\n+               Process_One;\n+\n+            else\n+               --  This is an AND THEN or OR ELSE logical operator: follow the\n+               --  left, then the right operands.\n+\n+               Idx := Idx + 1;\n+\n+               Process_One;\n+               Process_One;\n+            end if;\n+         end Process_One;\n+\n+      --  Start of processing for Compute_Range\n+\n+      begin\n+         Process_One;\n+         From := Sloc_F;\n+         To := Sloc_T;\n+      end Compute_Range;\n+\n+      -------------------------\n+      -- Add_Expression_Tree --\n+      -------------------------\n+\n+      procedure Add_Expression_Tree (Idx : in out Nat)\n+      is\n+         Node_Idx : constant Nat := Idx;\n+         T        : SCO_Table_Entry renames SCO_Raw_Table.Table (Node_Idx);\n+         From, To : Source_Location;\n+\n+      begin\n+         case T.C1 is\n+            when ' ' =>\n+\n+               --  This is a single condition. Add an entry for it and move on\n+\n+               SCO_Table.Append (T);\n+               Idx := Idx + 1;\n+\n+            when '!' =>\n+\n+               --  This is a NOT operator: add an entry for it and browse its\n+               --  only child.\n+\n+               SCO_Table.Append (T);\n+               Idx := Idx + 1;\n+               Add_Expression_Tree (Idx);\n+\n+            when others =>\n+\n+               --  This must be an AND/OR/AND THEN/OR ELSE operator\n+\n+               if T.C2 = '?' then\n+\n+                  --  This is not a short circuit operator: consider this one\n+                  --  and all its children as a single condition.\n+\n+                  Compute_Range (Idx, From, To);\n+                  SCO_Table.Append\n+                    ((From               => From,\n+                      To                 => To,\n+                      C1                 => ' ',\n+                      C2                 => 'c',\n+                      Last               => False,\n+                      Pragma_Sloc        => No_Location,\n+                      Pragma_Aspect_Name => No_Name));\n+\n+               else\n+                  --  This is a real short circuit operator: add an entry for\n+                  --  it and browse its children.\n+\n+                  SCO_Table.Append (T);\n+                  Idx := Idx + 1;\n+                  Add_Expression_Tree (Idx);\n+                  Add_Expression_Tree (Idx);\n+               end if;\n+         end case;\n+      end Add_Expression_Tree;\n+\n+      -------------------------------\n+      -- Process_Pending_Decisions --\n+      -------------------------------\n+\n+      procedure Process_Pending_Decisions\n+        (Original_Decision : SCO_Table_Entry)\n+      is\n+      begin\n+         for Index in 1 .. Pending_Decisions.Last loop\n+            declare\n+               D   : Decision renames Pending_Decisions.Table (Index);\n+               Idx : Nat := D.Top;\n+\n+            begin\n+               --  Add a SCO table entry for the decision itself\n+\n+               pragma Assert (D.Kind /= ' ');\n+\n+               SCO_Table.Append\n+                 ((To                 => No_Source_Location,\n+                   From               => D.Sloc,\n+                   C1                 => D.Kind,\n+                   C2                 => ' ',\n+                   Last               => False,\n+                   Pragma_Sloc        => Original_Decision.Pragma_Sloc,\n+                   Pragma_Aspect_Name =>\n+                      Original_Decision.Pragma_Aspect_Name));\n+\n+               --  Then add ones for its nested operators/operands. Do not\n+               --  forget to tag its *last* entry as such.\n+\n+               Add_Expression_Tree (Idx);\n+               SCO_Table.Table (SCO_Table.Last).Last := True;\n+            end;\n+         end loop;\n+\n+         --  Clear the pending decisions list\n+         Pending_Decisions.Set_Last (0);\n+      end Process_Pending_Decisions;\n+\n+   --  Start of processing for SCO_Record_Filtered\n+\n+   begin\n+      --  Filtering must happen only once: do nothing if it this pass was\n+      --  already run.\n+\n+      if SCO_Generation_State = Filtered then\n+         return;\n+      else\n+         pragma Assert (SCO_Generation_State = Raw);\n+         SCO_Generation_State := Filtered;\n+      end if;\n+\n+      --  Loop through all SCO entries under SCO units\n+\n+      for Unit_Idx in 1 .. SCO_Unit_Table.Last loop\n+         declare\n+            Unit : SCO_Unit_Table_Entry\n+               renames SCO_Unit_Table.Table (Unit_Idx);\n+\n+            Idx : Nat := Unit.From;\n+            --  Index of the current SCO raw table entry\n+\n+            New_From : constant Nat := SCO_Table.Last + 1;\n+            --  After copying SCO enties of interest to the final table, we\n+            --  will have to change the From/To indexes this unit targets.\n+            --  This constant keeps track of the new From index.\n+\n+         begin\n+            while Idx <= Unit.To loop\n+               declare\n+                  T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n+\n+               begin\n+                  case T.C1 is\n+\n+                     --  Decision (of any kind, including pragmas and aspects)\n+\n+                     when 'E' | 'G' | 'I' | 'W' | 'X' | 'P' | 'a' | 'A' =>\n+                        if SCO_Pragma_Disabled (T.Pragma_Sloc) then\n+\n+                           --  Skip SCO entries for decisions in disabled\n+                           --  constructs (pragmas or aspects).\n+\n+                           Idx := Idx + 1;\n+                           Skip_Decision (Idx, False);\n+\n+                        else\n+                           Collect_Decisions\n+                             ((Kind => T.C1,\n+                               Sloc => T.From,\n+                               Top  => Idx + 1),\n+                              Idx);\n+                           Process_Pending_Decisions (T);\n+                        end if;\n+\n+                     --  There is no translation/filtering to do for other kind\n+                     --  of SCO items (statements, dominance markers, etc.).\n+\n+                     when '|' | '&' | '!' | ' ' =>\n+\n+                        --  SCO logical operators and conditions cannot exist\n+                        --  on their own: they must be inside a decision (such\n+                        --  entries must have been skipped by\n+                        --  Collect_Decisions).\n+\n+                        raise Program_Error;\n+\n+                     when others =>\n+                        SCO_Table.Append (T);\n+                        Idx := Idx + 1;\n+                  end case;\n+               end;\n+            end loop;\n+\n+            --  Now, update the SCO entry indexes in the unit entry\n+\n+            Unit.From := New_From;\n+            Unit.To := SCO_Table.Last;\n+         end;\n+      end loop;\n+\n+      --  Then clear the raw table to free bytes\n+\n+      SCO_Raw_Table.Free;\n+   end SCO_Record_Filtered;\n+\n end Par_SCO;"}, {"sha": "29dfe7e388669193e46efc3ac1ccf1f07b870a8b", "filename": "gcc/ada/par_sco.ads", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar_sco.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fpar_sco.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.ads?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,7 +38,7 @@ package Par_SCO is\n    procedure Initialize;\n    --  Initialize internal tables for a new compilation\n \n-   procedure SCO_Record (U : Unit_Number_Type);\n+   procedure SCO_Record_Raw (U : Unit_Number_Type);\n    --  This procedure scans the tree for the unit identified by U, populating\n    --  internal tables recording the SCO information. Note that this is done\n    --  before any semantic analysis/expansion happens.\n@@ -49,6 +49,9 @@ package Par_SCO is\n    --  by Val. The condition is identified by the First_Sloc value in the\n    --  original tree associated with Cond.\n \n+   procedure Set_SCO_Logical_Operator (Op : Node_Id);\n+   --  Mark some putative logical operator as a short circuit one\n+\n    procedure Set_SCO_Pragma_Enabled (Loc : Source_Ptr);\n    --  This procedure is called from Sem_Prag when a pragma is enabled (i.e.\n    --  when the Pragma_Enabled flag is set). Loc is the Sloc of the N_Pragma\n@@ -60,14 +63,19 @@ package Par_SCO is\n    function SCO_Pragma_Disabled (Loc : Source_Ptr) return Boolean;\n    --  True if Loc is the source location of a disabled pragma\n \n+   procedure SCO_Record_Filtered;\n+   --  This procedure filters remaining putative AND/OR short-circuit operators\n+   --  from the internal SCO raw table after the semantic analysis and fills\n+   --  the filtered SCO table.\n+\n    procedure SCO_Output;\n    --  Outputs SCO lines for all units, with appropriate section headers, as\n    --  recorded by previous calls to SCO_Record, possibly modified by calls to\n    --  Set_SCO_Condition.\n \n    procedure dsco;\n-   --  Debug routine to dump internal SCO table. This is a raw format dump\n-   --  showing exactly what the table contains.\n+   --  Debug routine to dump internal SCO tables. This is a raw format dump\n+   --  showing exactly what the tables contain.\n \n    procedure pscos;\n    --  Debugging procedure to output contents of SCO binary tables in the"}, {"sha": "c4200907f20705c2cd05589451dd757b553b61e6", "filename": "gcc/ada/put_scos.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fput_scos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fput_scos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -260,6 +260,7 @@ begin\n                               T.C1 = '|'\n                            then\n                               Write_Info_Char (T.C1);\n+                              pragma Assert (T.C2 /= '?');\n                               Output_Source_Location (T.From);\n \n                            else"}, {"sha": "5dca074af8a0c272ee0c2b8da2c1f569b7e783d7", "filename": "gcc/ada/put_scos.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fput_scos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fput_scos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_scos.ads?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2009-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2009-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "4f5bb57d7446d76b05654d39f3dda426f4efc742", "filename": "gcc/ada/scos.ads", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fscos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fscos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscos.ads?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -443,8 +443,8 @@ package SCOs is\n    --    SCO contexts, the only pragmas with decisions are Assert, Check,\n    --    dyadic Debug, Precondition and Postcondition). These entries will\n    --    be omitted in output if the pragma is disabled (see comments for\n-   --    statement entries). This is achieved by setting C1 to NUL for all\n-   --    SCO entries of the decision.\n+   --    statement entries): this filtering is achieved during the second pass\n+   --    of SCO generation (Par_SCO.SCO_Record_Filtered).\n \n    --    Decision (ASPECT)\n    --      C1   = 'A'\n@@ -467,7 +467,7 @@ package SCOs is\n \n    --    Operator\n    --      C1   = '!', '&', '|'\n-   --      C2   = ' '\n+   --      C2   = ' '/'?'/ (Logical operator/Putative one)\n    --      From = location of NOT/AND/OR token\n    --      To   = No_Source_Location\n    --      Last = False\n@@ -511,6 +511,14 @@ package SCOs is\n \n       To : Nat;\n       --  Ending index in SCO_Table of SCO information for this unit\n+\n+      --  Warning: SCOs generation (in Par_SCO) is done in two passes, which\n+      --  communicate through an intermediate table (Par_SCO.SCO_Raw_Table).\n+      --  Before the second pass executes, From and To actually reference index\n+      --  in the internal table: SCO_Table is empty. Then, at the end of the\n+      --  second pass, these indexes are updated in order to reference indexes\n+      --  in SCO_Table.\n+\n    end record;\n \n    package SCO_Unit_Table is new GNAT.Table ("}, {"sha": "3f47deef43d317ce36ac166e1e7a1ce564e9cca0", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -1855,7 +1855,7 @@ package body Sem_Ch10 is\n                       In_Extended_Main_Source_Unit\n                         (Cunit_Entity (Current_Sem_Unit))\n                   then\n-                     SCO_Record (Unum);\n+                     SCO_Record_Raw (Unum);\n                   end if;\n \n                   --  Analyze the unit if semantics active"}, {"sha": "84c5ae553dfd7cc33bb16fe798a204bd29f4a076", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -3551,10 +3551,22 @@ package body Sem_Ch8 is\n             if Ekind (Pack) /= E_Package and then Etype (Pack) /= Any_Type then\n                if Ekind (Pack) = E_Generic_Package then\n                   Error_Msg_N  -- CODEFIX\n-                   (\"a generic package is not allowed in a use clause\",\n-                      Pack_Name);\n+                    (\"a generic package is not allowed in a use clause\",\n+                     Pack_Name);\n+\n+               elsif Ekind_In (Pack, E_Generic_Function, E_Generic_Package)\n+               then\n+                  Error_Msg_N  -- CODEFIX\n+                    (\"a generic subprogram is not allowed in a use clause\",\n+                     Pack_Name);\n+\n+               elsif Ekind_In (Pack, E_Function, E_Procedure, E_Operator) then\n+                  Error_Msg_N  -- CODEFIX\n+                    (\"a subprogram is not allowed in a use clause\",\n+                     Pack_Name);\n+\n                else\n-                  Error_Msg_N (\"& is not a usable package\", Pack_Name);\n+                  Error_Msg_N (\"& is not allowed in a use clause\", Pack_Name);\n                end if;\n \n             else"}, {"sha": "dedacd5af41bd97092f5f2c9211268d8c763ce8d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0566484a15d36465693a4afb06538d63925579b4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=0566484a15d36465693a4afb06538d63925579b4", "patch": "@@ -46,6 +46,7 @@ with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Output;   use Output;\n+with Par_SCO;  use Par_SCO;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -8188,11 +8189,11 @@ package body Sem_Res is\n    procedure Resolve_Generalized_Indexing (N : Node_Id; Typ : Entity_Id) is\n       Indexing : constant Node_Id := Generalized_Indexing (N);\n       Call     : Node_Id;\n-      Indices  : List_Id;\n+      Indexes  : List_Id;\n       Pref     : Node_Id;\n \n    begin\n-      --  In ASIS mode, propagate the information about the indices back to\n+      --  In ASIS mode, propagate the information about the indexes back to\n       --  to the original indexing node. The generalized indexing is either\n       --  a function call, or a dereference of one. The actuals include the\n       --  prefix of the original node, which is the container expression.\n@@ -8209,9 +8210,9 @@ package body Sem_Res is\n          end loop;\n \n          if Nkind (Call) = N_Function_Call then\n-            Indices := Parameter_Associations (Call);\n-            Pref := Remove_Head (Indices);\n-            Set_Expressions (N, Indices);\n+            Indexes := Parameter_Associations (Call);\n+            Pref := Remove_Head (Indexes);\n+            Set_Expressions (N, Indexes);\n             Set_Prefix (N, Pref);\n          end if;\n \n@@ -8658,6 +8659,13 @@ package body Sem_Res is\n         and then B_Typ = Standard_Boolean\n         and then Nkind_In (N, N_Op_And, N_Op_Or)\n       then\n+         --  Mark the corresponding putative SCO operator as truly a logical\n+         --  (and short-circuit) operator.\n+\n+         if Generate_SCO and then Comes_From_Source (N) then\n+            Set_SCO_Logical_Operator (N);\n+         end if;\n+\n          if Nkind (N) = N_Op_And then\n             Rewrite (N,\n               Make_And_Then (Sloc (N),"}]}