{"sha": "7b765bedc0573a2e33457416857f1f279ffe7a11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I3NjViZWRjMDU3M2EyZTMzNDU3NDE2ODU3ZjFmMjc5ZmZlN2ExMQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-08-19T23:23:29Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-08-19T23:23:29Z"}, "message": "Fix PR 32772 Fix PR 32716 Fix PR 32328 Fix PR 32303\n\n2007-08-19  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR 32772\n\tFix PR 32716\n\tFix PR 32328\n\tFix PR 32303\n\n\t* tree-flow.h (struct stmt_ann_d): Remove makes_clobbering_call.\n\t* tree-ssa-alias.c (init_transitive_clobber_worklist): Add\n\ton_worklist argument and avoid adding things to worklist multiple\n\ttimes.\n\t(add_to_worklist): Ditto.\n\t(mark_aliases_call_clobbered): Mark entire structure clobbered if\n\tsingle SFT is clobbered.\n\t(set_initial_properties): Ditto.\n\t(compute_call_clobbered): Update for changes to function\n\targuments.\n\t(create_overlap_variables_for): Always create SFT for offset 0.\n\t(create_structure_vars): Handle PHI's, since we are in SSA form at\n\tthis point.\n\t* tree-ssa-loop-ivopts.c (get_ref_tag): Don't return subvars.\n\t* tree-ssa-operands.c (access_can_touch_variable): Don't handle\n\tTARGET_MEM_REF.\n\t(add_vars_for_offset): Figure out aliases from access + points-to.\n\t(add_virtual_operand): Use add_vars-for_offset.\n\t(get_tmr_operands): Update for NMT changes, rewrite to be correct.\n\t(add_call_clobber_ops): Remove makes_clobbering_call set.\n\t(get_expr_operands): Always pass through the INDIRECT_REF\n\treference.\n\t* tree-ssa-structalias.c (struct constraint_graph): Remove\n\tvariables member.\n\tAdd pe, pe_rep, pointer_label, loc_label, pointed_by, points_to,\n\taddress_taken, pt_used, number_incoming.\n\t(FIRST_ADDR_NODE): Removed.\n\t(merge_graph_nodes): Remove broken code for the moment.\n\t(init_graph): New function.\n\t(build_pred_graph): Remove code to init_graph.\n\tAdd location equivalence support.\n\t(struct scc_info): Rename roots to deleted.\n\t(scc_visit): Ditto.\n\t(init_scc_info): Ditto\n\t(init_topo_info): Use graph->size.\n\t(compute_topo_order): Ditto.\n\t(do_da_constraint): Removed.\n\t(do_sd_constraint): Remove calls to find().\n\tset_union_with_increment should always get 0 as last arg here.\n\t(do_complex_constraint): Replace do_da_constraint with assert.\n\tStop calling find.\n\t(struct equiv_class_label): New.\n\t(pointer_equiv_class_table): Ditto.\n\t(location_equiv_class_table): Ditto.\n\t(equiv_class_label_hash): Ditto.\n\t(equiv_class_label_eq): Ditto\n\t(equiv_class_lookup): Ditto.\n\t(equiv_class_ladd): Ditto.\n\t(pointer_equiv_class): Ditto.\n\t(location_equiv_class): Ditto.\n\t(condense_visit): Rename and rewrite from label_visit to do only\n\tSCC related stuff for HU.\n\t(label_visit): Do HU work for HU.\n\t(perform_var_substitution): Update to do HU and location\n\tequivalence.\n\t(free_var_substitution_info): Update to free HU and location\n\tequivalence structures.  */\n\t(find_equivalent_node): Update for pointer but not location\n\tequivalence.\n\t(unite_pointer_equivalences): New function.\n\t(move_complex_constraints): Rewrite to only do moving.\n\t(rewrite_constraints): Split out of move_complex_constraints.\n\t(solve_graph): Use graph->size.\n\t(process_constraint_1): Add from_call argument, use it.\n\tSplit *a = &b into two constraints.\n\t(process_constraint): Use new process_constraint_1.\n\t(get_constraint_for_component_ref): Handle bitmaxsize == -1 case.\n\t(get_constraint_for): Handle non-pointer integers properly.\n\tRemove code that used to handle structures.\n\t(handle_ptr_arith): Fix a few bugs in pointer arithmetic handling\n\twith unknown addends.\n\t(handle_rhs_call): New function.\n\t(find_func_aliases): Use handle_rhs_call.\n\t(set_uids_in_ptset): Add an assert.\n\t(set_used_smts): Fix bug in not considering unified vars.\n\t(compute_tbaa_pruning): Stop initing useless iteration_obstack.\n\t(compute_points_to_sets): Update for other function changes.\n\t(delete_points_to_sets): Ditto.\n\t(ipa_pta_execute): Ditto.\n\t(pass_ipa_pta): We need to update SSA after ipa_pta.\n\nFrom-SVN: r127629", "tree": {"sha": "baa8e18c063d5687f098c1d8745169221e56ef6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baa8e18c063d5687f098c1d8745169221e56ef6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b765bedc0573a2e33457416857f1f279ffe7a11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b765bedc0573a2e33457416857f1f279ffe7a11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b765bedc0573a2e33457416857f1f279ffe7a11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b765bedc0573a2e33457416857f1f279ffe7a11/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "73f486583f4cc523c01e2c39c1a003a4599a9eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73f486583f4cc523c01e2c39c1a003a4599a9eaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73f486583f4cc523c01e2c39c1a003a4599a9eaf"}], "stats": {"total": 1446, "additions": 1007, "deletions": 439}, "files": [{"sha": "6fd288498b8219b53d405e7633c51bf116631d72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b765bedc0573a2e33457416857f1f279ffe7a11", "patch": "@@ -1,3 +1,91 @@\n+2007-08-19  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR 32772\n+\tFix PR 32716\n+\tFix PR 32328\n+\tFix PR 32303\n+\n+\t* tree-flow.h (struct stmt_ann_d): Remove makes_clobbering_call.\n+\t* tree-ssa-alias.c (init_transitive_clobber_worklist): Add\n+\ton_worklist argument and avoid adding things to worklist multiple\n+\ttimes.\n+\t(add_to_worklist): Ditto.\n+\t(mark_aliases_call_clobbered): Mark entire structure clobbered if\n+\tsingle SFT is clobbered.\n+\t(set_initial_properties): Ditto.\n+\t(compute_call_clobbered): Update for changes to function\n+\targuments.\n+\t(create_overlap_variables_for): Always create SFT for offset 0.\n+\t(create_structure_vars): Handle PHI's, since we are in SSA form at\n+\tthis point.\n+\t* tree-ssa-loop-ivopts.c (get_ref_tag): Don't return subvars.\n+\t* tree-ssa-operands.c (access_can_touch_variable): Don't handle\n+\tTARGET_MEM_REF.\n+\t(add_vars_for_offset): Figure out aliases from access + points-to.\n+\t(add_virtual_operand): Use add_vars-for_offset.\n+\t(get_tmr_operands): Update for NMT changes, rewrite to be correct.\n+\t(add_call_clobber_ops): Remove makes_clobbering_call set.\n+\t(get_expr_operands): Always pass through the INDIRECT_REF\n+\treference.\n+\t* tree-ssa-structalias.c (struct constraint_graph): Remove\n+\tvariables member.\n+\tAdd pe, pe_rep, pointer_label, loc_label, pointed_by, points_to,\n+\taddress_taken, pt_used, number_incoming.\n+\t(FIRST_ADDR_NODE): Removed.\n+\t(merge_graph_nodes): Remove broken code for the moment.\n+\t(init_graph): New function.\n+\t(build_pred_graph): Remove code to init_graph.\n+\tAdd location equivalence support.\n+\t(struct scc_info): Rename roots to deleted.\n+\t(scc_visit): Ditto.\n+\t(init_scc_info): Ditto\n+\t(init_topo_info): Use graph->size.\n+\t(compute_topo_order): Ditto.\n+\t(do_da_constraint): Removed.\n+\t(do_sd_constraint): Remove calls to find().\n+\tset_union_with_increment should always get 0 as last arg here.\n+\t(do_complex_constraint): Replace do_da_constraint with assert.\n+\tStop calling find.\n+\t(struct equiv_class_label): New.\n+\t(pointer_equiv_class_table): Ditto.\n+\t(location_equiv_class_table): Ditto.\n+\t(equiv_class_label_hash): Ditto.\n+\t(equiv_class_label_eq): Ditto\n+\t(equiv_class_lookup): Ditto.\n+\t(equiv_class_ladd): Ditto.\n+\t(pointer_equiv_class): Ditto.\n+\t(location_equiv_class): Ditto.\n+\t(condense_visit): Rename and rewrite from label_visit to do only\n+\tSCC related stuff for HU.\n+\t(label_visit): Do HU work for HU.\n+\t(perform_var_substitution): Update to do HU and location\n+\tequivalence.\n+\t(free_var_substitution_info): Update to free HU and location\n+\tequivalence structures.  */\n+\t(find_equivalent_node): Update for pointer but not location\n+\tequivalence.\n+\t(unite_pointer_equivalences): New function.\n+\t(move_complex_constraints): Rewrite to only do moving.\n+\t(rewrite_constraints): Split out of move_complex_constraints.\n+\t(solve_graph): Use graph->size.\n+\t(process_constraint_1): Add from_call argument, use it.\n+\tSplit *a = &b into two constraints.\n+\t(process_constraint): Use new process_constraint_1.\n+\t(get_constraint_for_component_ref): Handle bitmaxsize == -1 case.\n+\t(get_constraint_for): Handle non-pointer integers properly.\n+\tRemove code that used to handle structures.\n+\t(handle_ptr_arith): Fix a few bugs in pointer arithmetic handling\n+\twith unknown addends.\n+\t(handle_rhs_call): New function.\n+\t(find_func_aliases): Use handle_rhs_call.\n+\t(set_uids_in_ptset): Add an assert.\n+\t(set_used_smts): Fix bug in not considering unified vars.\n+\t(compute_tbaa_pruning): Stop initing useless iteration_obstack.\n+\t(compute_points_to_sets): Update for other function changes.\n+\t(delete_points_to_sets): Ditto.\n+\t(ipa_pta_execute): Ditto.\n+\t(pass_ipa_pta): We need to update SSA after ipa_pta.\n+\t\n 2007-08-19  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md: Replace \"rim\" and \"mri\" constraints by \"g\"."}, {"sha": "339baeba3494a0e16a502a8d09d794b48c0a524b", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=7b765bedc0573a2e33457416857f1f279ffe7a11", "patch": "@@ -498,10 +498,6 @@ struct stmt_ann_d GTY(())\n \n   /* Nonzero if the statement makes references to volatile storage.  */\n   unsigned has_volatile_ops : 1;\n-\n-  /* Nonzero if the statement makes a function call that may clobber global\n-     and local addressable variables.  */\n-  unsigned makes_clobbering_call : 1;\n };\n \n union tree_ann_d GTY((desc (\"ann_type ((tree_ann_t)&%h)\")))"}, {"sha": "103a0231fb3e61506b77ef5fc38776010953a31f", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 84, "deletions": 23, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=7b765bedc0573a2e33457416857f1f279ffe7a11", "patch": "@@ -322,7 +322,8 @@ sort_tags_by_id (const void *pa, const void *pb)\n \n static void\n init_transitive_clobber_worklist (VEC (tree, heap) **worklist,\n-\t\t\t\t  VEC (int, heap) **worklist2)\n+\t\t\t\t  VEC (int, heap) **worklist2,\n+\t\t\t\t  bitmap on_worklist)\n {\n   referenced_var_iterator rvi;\n   tree curr;\n@@ -332,7 +333,9 @@ init_transitive_clobber_worklist (VEC (tree, heap) **worklist,\n       if (MTAG_P (curr) && is_call_clobbered (curr))\n \t{\n \t  VEC_safe_push (tree, heap, *worklist, curr);\n-\t  VEC_safe_push (int, heap, *worklist2, var_ann (curr)->escape_mask);\n+\t  VEC_safe_push (int, heap, *worklist2,\n+\t\t\t var_ann (curr)->escape_mask);\n+\t  bitmap_set_bit (on_worklist, DECL_UID (curr));\n \t}\n     }\n }\n@@ -343,13 +346,15 @@ init_transitive_clobber_worklist (VEC (tree, heap) **worklist,\n \n static void\n add_to_worklist (tree alias, VEC (tree, heap) **worklist,\n-\t\t VEC (int, heap) **worklist2,\n-\t\t int reason)\n+\t\t VEC (int, heap) **worklist2, int reason,\n+\t\t bitmap on_worklist)\n {\n-  if (MTAG_P (alias) && !is_call_clobbered (alias))\n+  if (MTAG_P (alias) && !is_call_clobbered (alias)\n+      && !bitmap_bit_p (on_worklist, DECL_UID (alias)))\n     {\n       VEC_safe_push (tree, heap, *worklist, alias);\n       VEC_safe_push (int, heap, *worklist2, reason);\n+      bitmap_set_bit (on_worklist, DECL_UID (alias));\n     }\n }\n \n@@ -358,7 +363,8 @@ add_to_worklist (tree alias, VEC (tree, heap) **worklist,\n \n static void\n mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n-\t\t\t     VEC (int, heap) **worklist2)\n+\t\t\t     VEC (int, heap) **worklist2,\n+\t\t\t     bitmap on_worklist)\n {\n   bitmap aliases;\n   bitmap_iterator bi;\n@@ -375,9 +381,23 @@ mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n   EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n     {\n       entry = referenced_var (i);\n-      if (!unmodifiable_var_p (entry))\n+      /* If you clobber one part of a structure, you\n+\t clobber the entire thing.  While this does not make\n+\t the world a particularly nice place, it is necessary\n+\t in order to allow C/C++ tricks that involve\n+\t pointer arithmetic to work.  */\n+      if (TREE_CODE (entry) == STRUCT_FIELD_TAG)\n \t{\n-\t  add_to_worklist (entry, worklist, worklist2, ta->escape_mask);\n+\t  subvar_t svars;\n+\t  svars = get_subvars_for_var (SFT_PARENT_VAR (entry));\n+\t  for (; svars; svars = svars->next)\n+\t    if (!unmodifiable_var_p (entry))\n+\t      mark_call_clobbered (svars->var, ta->escape_mask);\n+\t}\n+      else if (!unmodifiable_var_p (entry))\n+\t{\n+\t  add_to_worklist (entry, worklist, worklist2, ta->escape_mask,\n+\t\t\t   on_worklist);\n \t  mark_call_clobbered (entry, ta->escape_mask);\n \t}\n     }\n@@ -528,8 +548,25 @@ set_initial_properties (struct alias_info *ai)\n \t      bitmap_iterator bi;\n \t      unsigned int j;\t      \n \t      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, j, bi)\n-\t\tif (!unmodifiable_var_p (referenced_var (j)))\n-\t\t  mark_call_clobbered (referenced_var (j), pi->escape_mask);\n+\t\t{\n+\t\t  tree alias = referenced_var (j);\n+\n+\t\t  /* If you clobber one part of a structure, you\n+\t\t     clobber the entire thing.  While this does not make\n+\t\t     the world a particularly nice place, it is necessary\n+\t\t     in order to allow C/C++ tricks that involve\n+\t\t     pointer arithmetic to work.  */\n+\t\t  if (TREE_CODE (alias) == STRUCT_FIELD_TAG)\n+\t\t    {\n+\t\t      subvar_t svars;\n+\t\t      svars = get_subvars_for_var (SFT_PARENT_VAR (alias));\n+\t\t      for (; svars; svars = svars->next)\n+\t\t\tif (!unmodifiable_var_p (alias))\n+\t\t\t  mark_call_clobbered (svars->var, pi->escape_mask);\n+\t\t    }\n+\t\t  else if (!unmodifiable_var_p (alias))\n+\t\t    mark_call_clobbered (alias, pi->escape_mask);\n+\t\t}\n \t    }\n \t}\n \n@@ -573,21 +610,27 @@ static void\n compute_call_clobbered (struct alias_info *ai)\n {\n   VEC (tree, heap) *worklist = NULL;\n-  VEC(int,heap) *worklist2 = NULL;\n-  \n+  VEC (int,heap) *worklist2 = NULL;\n+  bitmap on_worklist;\n+\n   timevar_push (TV_CALL_CLOBBER);\n+  on_worklist = BITMAP_ALLOC (NULL);\n+    \n   set_initial_properties (ai);\n-  init_transitive_clobber_worklist (&worklist, &worklist2);\n+  init_transitive_clobber_worklist (&worklist, &worklist2, on_worklist);\n   while (VEC_length (tree, worklist) != 0)\n     {\n       tree curr = VEC_pop (tree, worklist);\n       int reason = VEC_pop (int, worklist2);\n-      \n+\n+      bitmap_clear_bit (on_worklist, DECL_UID (curr));\n       mark_call_clobbered (curr, reason);\n-      mark_aliases_call_clobbered (curr, &worklist, &worklist2);\n+      mark_aliases_call_clobbered (curr, &worklist, &worklist2,\n+\t\t\t\t   on_worklist);\n     }\n   VEC_free (tree, heap, worklist);\n   VEC_free (int, heap, worklist2);\n+  BITMAP_FREE (on_worklist);\n   compute_tag_properties ();\n   timevar_pop (TV_CALL_CLOBBER);\n }\n@@ -3783,11 +3826,14 @@ create_overlap_variables_for (tree var)\n \n \t  /* If this field isn't in the used portion,\n \t     or it has the exact same offset and size as the last\n-\t     field, skip it.  */\n-\n-\t  if (((fo->offset <= up->minused\n-\t\t&& fo->offset + fosize <= up->minused)\n-\t       || fo->offset >= up->maxused)\n+\t     field, skip it.  Note that we always need the field at\n+\t     offset 0 so we can properly handle pointers to the\n+\t     structure.  */\n+\n+\t  if ((fo->offset != 0\n+\t       && ((fo->offset <= up->minused\n+\t\t    && fo->offset + fosize <= up->minused)\n+\t\t   || fo->offset >= up->maxused))\n \t      || (fo->offset == lastfooffset\n \t\t  && fosize == lastfosize\n \t\t  && currfotype == lastfotype))\n@@ -3975,6 +4021,21 @@ create_structure_vars (void)\n   FOR_EACH_BB (bb)\n     {\n       block_stmt_iterator bsi;\n+      tree phi;\n+      \n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\t{\n+\t  use_operand_p use;\n+\t  ssa_op_iter iter;\n+\n+\t  FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n+\t    {\n+\t      tree op = USE_FROM_PTR (use);\n+\t      walk_tree_without_duplicates (&op, find_used_portions,\n+\t\t\t\t\t    NULL);\n+\t    }\n+\t}\n+\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  walk_tree_without_duplicates (bsi_stmt_ptr (bsi), \n@@ -4013,7 +4074,7 @@ create_structure_vars (void)\n \t\t  tree sym = referenced_var_lookup (i);\n \t\t  if (get_subvars_for_var (sym))\n \t\t    {\n-\t\t      update=true;\n+\t\t      update = true;\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -4024,7 +4085,7 @@ create_structure_vars (void)\n \t\t  tree sym = referenced_var_lookup (i);\n \t\t  if (get_subvars_for_var (sym))\n \t\t    {\n-\t\t      update=true;\n+\t\t      update = true;\n \t\t      break;\n \t\t    }\n \t\t}\n@@ -4036,7 +4097,7 @@ create_structure_vars (void)\n \t\t  tree sym = referenced_var_lookup (i);\n \t\t  if (get_subvars_for_var (sym))\n \t\t    {\n-\t\t      update=true;\n+\t\t      update = true;\n \t\t      break;\n \t\t    }\n \t\t}"}, {"sha": "edc45867cfb49a3a98f586b63bdb86e08bbe584b", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=7b765bedc0573a2e33457416857f1f279ffe7a11", "patch": "@@ -5020,7 +5020,7 @@ get_ref_tag (tree ref, tree orig)\n     }\n \n   if (aref && SSA_VAR_P (aref) && get_subvars_for_var (aref))\n-    return unshare_expr (sv);\n+    return aref;\n \n   if (!var)\n     return NULL_TREE;"}, {"sha": "7217b554ff0c6bc1aa4c4fcb4e0063d2dd9d1744", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 120, "deletions": 48, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=7b765bedc0573a2e33457416857f1f279ffe7a11", "patch": "@@ -1181,7 +1181,9 @@ append_vuse (tree var)\n /* REF is a tree that contains the entire pointer dereference\n    expression, if available, or NULL otherwise.  ALIAS is the variable\n    we are asking if REF can access.  OFFSET and SIZE come from the\n-   memory access expression that generated this virtual operand.  */\n+   memory access expression that generated this virtual operand.\n+\n+   XXX: We should handle the NO_ALIAS attributes here.  */\n \n static bool\n access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n@@ -1197,6 +1199,11 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   if (alias == gimple_global_var (cfun))\n     return true;\n \n+  /* If ref is a TARGET_MEM_REF, just return true, as we can't really\n+     disambiguate them right now.  */\n+  if (ref && TREE_CODE (ref) == TARGET_MEM_REF)\n+    return true;\n+  \n   /* If ALIAS is an SFT, it can't be touched if the offset     \n      and size of the access is not overlapping with the SFT offset and\n      size.  This is only true if we are accessing through a pointer\n@@ -1290,6 +1297,7 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n \t   && flag_strict_aliasing\n \t   && TREE_CODE (ref) != INDIRECT_REF\n \t   && !MTAG_P (alias)\n+\t   && base\n \t   && (TREE_CODE (base) != INDIRECT_REF\n \t       || TREE_CODE (TREE_TYPE (base)) != UNION_TYPE)\n \t   && !AGGREGATE_TYPE_P (TREE_TYPE (alias))\n@@ -1335,6 +1343,106 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   return true;\n }\n \n+/* Add the actual variables FULL_REF can access, given a member of\n+   full_ref's points-to set VAR, where FULL_REF is an access of SIZE at\n+   OFFSET from var. IS_CALL_SITE is true if this is a call, and IS_DEF\n+   is true if this is supposed to be a vdef, and false if this should\n+   be a VUSE.\n+\n+   The real purpose of this function is to take a points-to set for a\n+   pointer to a structure, say\n+\n+   struct s {\n+     int a;\n+     int b;\n+   } foo, *foop = &foo;\n+\n+   and discover which variables an access, such as foop->b, can alias.\n+   \n+   This is necessary because foop only actually points to foo's first\n+   member, so that is all the points-to set contains.  However, an access\n+   to foop->a may be touching some single SFT if we have created some\n+   SFT's for a structure.  */\n+\n+static bool\n+add_vars_for_offset (tree full_ref, tree var, HOST_WIDE_INT offset,\n+\t\t     HOST_WIDE_INT size, bool is_call_site, bool is_def)\n+{\n+  /* Call-clobbered tags may have non-call-clobbered\n+     symbols in their alias sets.  Ignore them if we are\n+     adding VOPs for a call site.  */\n+  if (is_call_site && !is_call_clobbered (var))\n+    return false;\n+\n+  /* For offset 0, we already have the right variable.  If there is no\n+     full_ref, this is not a place we care about (All component\n+     related accesses that go through pointers will have full_ref not\n+     NULL).\n+     Any var for which we didn't create SFT's can't be\n+     distinguished.  */\n+  if (!full_ref || (offset == 0 && size != -1)\n+      || (TREE_CODE (var) != STRUCT_FIELD_TAG\n+\t  && (!var_can_have_subvars (var) || !get_subvars_for_var (var))))\n+    {\n+      if (!access_can_touch_variable (full_ref, var, offset, size))\n+\treturn false;\n+\n+      if (is_def)\n+\tappend_vdef (var);\n+      else\n+\tappend_vuse (var);\n+      return true;\n+    }\n+  else if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n+    {      \n+      if (size == -1)\n+\t{\n+\t  bool added = false;\n+\t  subvar_t sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n+\t  for (; sv; sv = sv->next)\n+\t    {\n+\t      if (overlap_subvar (SFT_OFFSET (var) + offset, size,\n+\t\t\t\t  sv->var, NULL)\n+\t\t  && access_can_touch_variable (full_ref, sv->var,\n+\t\t\t\t\t\toffset, size))\n+\t\t{\n+\t\t  added = true;\n+\t\t  if (is_def)\n+\t\t    append_vdef (sv->var);\n+\t\t  else\n+\t\t    append_vuse (sv->var);\n+\t\t}\n+\t    }\n+\t  return added;\n+\t}\n+      else\n+\t{\n+\t  bool added = false;\n+\t  subvar_t sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n+\t  for (; sv; sv = sv->next)\n+\t    {\n+\t      /* Once we hit the end of the parts that could touch,\n+\t\t stop looking.  */\n+\t      if (SFT_OFFSET (var) + offset + size <= SFT_OFFSET (sv->var))\n+\t\tbreak;\n+\t      if (overlap_subvar (SFT_OFFSET (var) + offset, size,\n+\t\t\t\t  sv->var, NULL)\n+\t\t  && access_can_touch_variable (full_ref, sv->var, offset, \n+\t\t\t\t\t\tsize))\n+\t\t{\n+\t\t  added = true;\n+\t\t  if (is_def)\n+\t\t    append_vdef (sv->var);\n+\t\t  else\n+\t\t    append_vuse (sv->var);\n+\t\t}\n+\t    }\n+\t  return added;\n+\t}\n+    }\n+  \n+  return false;\n+}\n \n /* Add VAR to the virtual operands array.  FLAGS is as in\n    get_expr_operands.  FULL_REF is a tree that contains the entire\n@@ -1343,7 +1451,7 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n    generated this virtual operand.  IS_CALL_SITE is true if the\n    affected statement is a call site.  */\n \n-static void \n+static void\n add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t\t     tree full_ref, HOST_WIDE_INT offset,\n \t\t     HOST_WIDE_INT size, bool is_call_site)\n@@ -1416,17 +1524,8 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t    {\n \t      al = referenced_var (i);\n-\t      if (!access_can_touch_variable (full_ref, al, offset, size))\n-\t\tcontinue;\n-\n-\t      /* Call-clobbered tags may have non-call-clobbered\n-\t\t symbols in their alias sets.  Ignore them if we are\n-\t\t adding VOPs for a call site.  */\n-\t      if (is_call_site && !is_call_clobbered (al))\n-\t\tcontinue;\n-\n-\t      none_added = false;\n-\t      append_vdef (al);\n+\t      none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n+\t\t\t\t\t\t  is_call_site, true);\n \t    }\n \n \t  /* If the variable is also an alias tag, add a virtual\n@@ -1443,27 +1542,17 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t  if (none_added\n \t      || (TREE_CODE (var) == SYMBOL_MEMORY_TAG\n \t\t  && is_call_site))\n-\t    {\n-\t      append_vdef (var);\n-\t    }\n+\t    append_vdef (var);\n \t}\n       else\n \t{\n \t  bool none_added = true;\n \t  EXECUTE_IF_SET_IN_BITMAP (aliases, 0, i, bi)\n \t    {\n \t      al = referenced_var (i);\n-\t      if (!access_can_touch_variable (full_ref, al, offset, size))\n-\t\tcontinue;\n-\n-\t      /* Call-clobbered tags may have non-call-clobbered\n-\t\t symbols in their alias sets.  Ignore them if we are\n-\t\t adding VOPs for a call site.  */\n-\t      if (is_call_site && !is_call_clobbered (al))\n-\t\tcontinue;\n-\n-\t      none_added = false;\n-\t      append_vuse (al);\n+\t      none_added &= !add_vars_for_offset (full_ref, al, offset, size,\n+\t\t\t\t\t\t  is_call_site, false);\n+\t      \n \t    }\n \t  \n \t  /* Even if no aliases have been added, we still need to\n@@ -1620,9 +1709,7 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags,\n static void\n get_tmr_operands (tree stmt, tree expr, int flags)\n {\n-  tree tag, ref;\n-  HOST_WIDE_INT offset, size, maxsize;\n-  subvar_t svars, sv;\n+  tree tag;\n   stmt_ann_t s_ann = stmt_ann (stmt);\n \n   /* This statement references memory.  */\n@@ -1642,23 +1729,13 @@ get_tmr_operands (tree stmt, tree expr, int flags)\n       s_ann->has_volatile_ops = true;\n       return;\n     }\n-\n-  if (DECL_P (tag))\n+  if (!MTAG_P (tag))\n     {\n       get_expr_operands (stmt, &tag, flags);\n       return;\n     }\n \n-  ref = get_ref_base_and_extent (tag, &offset, &size, &maxsize);\n-  gcc_assert (ref != NULL_TREE);\n-  svars = get_subvars_for_var (ref);\n-  for (sv = svars; sv; sv = sv->next)\n-    {\n-      bool exact;\t\t\n-\n-      if (overlap_subvar (offset, maxsize, sv->var, &exact))\n-\tadd_stmt_operand (&sv->var, s_ann, flags);\n-    }\n+  add_virtual_operand (tag, s_ann, flags, expr, 0, -1, false);\n }\n \n \n@@ -1673,11 +1750,6 @@ add_call_clobber_ops (tree stmt, tree callee)\n   stmt_ann_t s_ann = stmt_ann (stmt);\n   bitmap not_read_b, not_written_b;\n   \n-  /* Functions that are not const, pure or never return may clobber\n-     call-clobbered variables.  */\n-  if (s_ann)\n-    s_ann->makes_clobbering_call = true;\n-\n   /* If we created .GLOBAL_VAR earlier, just use it.  */\n   if (gimple_global_var (cfun))\n     {\n@@ -2032,7 +2104,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \n     case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n-      get_indirect_ref_operands (stmt, expr, flags, NULL_TREE, 0, -1, true);\n+      get_indirect_ref_operands (stmt, expr, flags, expr, 0, -1, true);\n       return;\n \n     case TARGET_MEM_REF:"}, {"sha": "d894351a539ac612471e1785e4a613b9baa8206f", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 714, "deletions": 363, "changes": 1077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b765bedc0573a2e33457416857f1f279ffe7a11/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=7b765bedc0573a2e33457416857f1f279ffe7a11", "patch": "@@ -259,9 +259,6 @@ struct variable_info\n   /* Old points-to set for this variable.  */\n   bitmap oldsolution;\n \n-  /* Variable ids represented by this node.  */\n-  bitmap variables;\n-\n   /* Variable id this was collapsed to due to type unsafety.  This\n      should be unused completely after build_succ_graph, or something\n      is broken.  */\n@@ -460,17 +457,55 @@ struct constraint_graph\n      been unified. */\n   unsigned int *rep;\n \n-  /* Equivalence class representative for a node.  This is used for\n+  /* Equivalence class representative for a label.  This is used for\n      variable substitution.  */\n   int *eq_rep;\n \n-  /* Label for each node, used during variable substitution.  */\n-  unsigned int *label;\n+  /* Pointer equivalence node for a node.  if pe[a] != a, then node a\n+     can be united with node pe[a] after initial constraint building.  */\n+  unsigned int *pe;\n+\n+  /* Pointer equivalence representative for a label.  This is used to\n+     handle nodes that are pointer equivalent but not location\n+     equivalent.  We can unite these once the addressof constraints\n+     are transformed into initial points-to sets.  */\n+  int *pe_rep;\n+\n+  /* Pointer equivalence label for each node, used during variable\n+     substitution.  */\n+  unsigned int *pointer_label;\n+\n+  /* Location equivalence label for each node, used during location\n+     equivalence finding.  */\n+  unsigned int *loc_label;\n+\n+  /* Pointed-by set for each node, used during location equivalence\n+     finding.  This is pointed-by rather than pointed-to, because it\n+     is constructed using the predecessor graph.  */\n+  bitmap *pointed_by;\n+\n+  /* Points to sets for pointer equivalence.  This is *not* the actual\n+     points-to sets for nodes.  */\n+  bitmap *points_to;\n \n   /* Bitmap of nodes where the bit is set if the node is a direct\n      node.  Used for variable substitution.  */\n   sbitmap direct_nodes;\n \n+  /* Bitmap of nodes where the bit is set if the node is address\n+     taken.  Used for variable substitution.  */\n+  bitmap address_taken;\n+\n+  /* True if points_to bitmap for this node is stored in the hash\n+     table.  */\n+  sbitmap pt_used;\n+\n+  /* Number of incoming edges remaining to be processed by pointer\n+     equivalence.\n+     Used for variable substitution.  */\n+  unsigned int *number_incoming;\n+\n+\n   /* Vector of complex constraints for each graph node.  Complex\n      constraints are those involving dereferences or offsets that are\n      not 0.  */\n@@ -485,7 +520,6 @@ static constraint_graph_t graph;\n    end.  */\n #define FIRST_REF_NODE (VEC_length (varinfo_t, varmap))\n #define LAST_REF_NODE (FIRST_REF_NODE + (FIRST_REF_NODE - 1))\n-#define FIRST_ADDR_NODE (LAST_REF_NODE + 1)\n \n /* Return the representative node for NODE, if NODE has been unioned\n    with another NODE.\n@@ -832,17 +866,7 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n \t are in a cycle with, since we know they are in a cycle with\n \t each other.  */\n       if (graph->indirect_cycles[to] == -1)\n-\t{\n-\t  graph->indirect_cycles[to] = graph->indirect_cycles[from];\n-\t}\n-      else\n-\t{\n-\t  unsigned int tonode = find (graph->indirect_cycles[to]);\n-\t  unsigned int fromnode = find (graph->indirect_cycles[from]);\n-\n-\t  if (unite (tonode, fromnode))\n-\t    unify_nodes (graph, tonode, fromnode, true);\n-\t}\n+\tgraph->indirect_cycles[to] = graph->indirect_cycles[from];\n     }\n \n   /* Merge all the successor edges.  */\n@@ -932,6 +956,31 @@ valid_graph_edge (constraint_graph_t graph, unsigned int src,\n \t  && bitmap_bit_p (graph->succs[dest], src));\n }\n \n+/* Initialize the constraint graph structure to contain SIZE nodes.  */\n+\n+static void\n+init_graph (unsigned int size)\n+{\n+  unsigned int j;\n+\n+  graph = XCNEW (struct constraint_graph);\n+  graph->size = size;\n+  graph->succs = XCNEWVEC (bitmap, graph->size);\n+  graph->indirect_cycles = XNEWVEC (int, graph->size);\n+  graph->rep = XNEWVEC (unsigned int, graph->size);\n+  graph->complex = XCNEWVEC (VEC(constraint_t, heap) *, size);\n+  graph->pe = XNEWVEC (unsigned int, graph->size);\n+  graph->pe_rep = XNEWVEC (int, graph->size);\n+\n+  for (j = 0; j < graph->size; j++)\n+    {\n+      graph->rep[j] = j;\n+      graph->pe[j] = j;\n+      graph->pe_rep[j] = -1;\n+      graph->indirect_cycles[j] = -1;\n+    }\n+}\n+\n /* Build the constraint graph, adding only predecessor edges right now.  */\n \n static void\n@@ -941,19 +990,19 @@ build_pred_graph (void)\n   constraint_t c;\n   unsigned int j;\n \n-  graph = XNEW (struct constraint_graph);\n-  graph->size = (VEC_length (varinfo_t, varmap)) * 3;\n-  graph->succs = XCNEWVEC (bitmap, graph->size);\n   graph->implicit_preds = XCNEWVEC (bitmap, graph->size);\n   graph->preds = XCNEWVEC (bitmap, graph->size);\n-  graph->indirect_cycles = XNEWVEC (int, VEC_length (varinfo_t, varmap));\n-  graph->label = XCNEWVEC (unsigned int, graph->size);\n-  graph->rep = XNEWVEC (unsigned int, graph->size);\n+  graph->pointer_label = XCNEWVEC (unsigned int, graph->size);\n+  graph->loc_label = XCNEWVEC (unsigned int, graph->size);\n+  graph->pointed_by = XCNEWVEC (bitmap, graph->size);\n+  graph->points_to = XCNEWVEC (bitmap, graph->size);\n   graph->eq_rep = XNEWVEC (int, graph->size);\n-  graph->complex = XCNEWVEC (VEC(constraint_t, heap) *,\n-\t\t\t     VEC_length (varinfo_t, varmap));\n   graph->direct_nodes = sbitmap_alloc (graph->size);\n+  graph->pt_used = sbitmap_alloc (graph->size);\n+  graph->address_taken = BITMAP_ALLOC (&predbitmap_obstack);\n+  graph->number_incoming = XCNEWVEC (unsigned int, graph->size);\n   sbitmap_zero (graph->direct_nodes);\n+  sbitmap_zero (graph->pt_used);\n \n   for (j = 0; j < FIRST_REF_NODE; j++)\n     {\n@@ -962,10 +1011,7 @@ build_pred_graph (void)\n     }\n \n   for (j = 0; j < graph->size; j++)\n-    {\n-      graph->rep[j] = j;\n-      graph->eq_rep[j] = -1;\n-    }\n+    graph->eq_rep[j] = -1;\n \n   for (j = 0; j < VEC_length (varinfo_t, varmap); j++)\n     graph->indirect_cycles[j] = -1;\n@@ -982,8 +1028,6 @@ build_pred_graph (void)\n \t  /* *x = y.  */\n \t  if (rhs.offset == 0 && lhs.offset == 0 && rhs.type == SCALAR)\n \t    add_pred_graph_edge (graph, FIRST_REF_NODE + lhsvar, rhsvar);\n-\t  if (rhs.type == ADDRESSOF)\n-\t    RESET_BIT (graph->direct_nodes, rhsvar);\n \t}\n       else if (rhs.type == DEREF)\n \t{\n@@ -996,11 +1040,19 @@ build_pred_graph (void)\n       else if (rhs.type == ADDRESSOF)\n \t{\n \t  /* x = &y */\n-\t  add_pred_graph_edge (graph, lhsvar, FIRST_ADDR_NODE + rhsvar);\n+\t  if (graph->points_to[lhsvar] == NULL)\n+\t    graph->points_to[lhsvar] = BITMAP_ALLOC (&predbitmap_obstack);\n+\t  bitmap_set_bit (graph->points_to[lhsvar], rhsvar);\n+\n+\t  if (graph->pointed_by[rhsvar] == NULL)\n+\t    graph->pointed_by[rhsvar] = BITMAP_ALLOC (&predbitmap_obstack);\n+\t  bitmap_set_bit (graph->pointed_by[rhsvar], lhsvar);\n+\n \t  /* Implicitly, *x = y */\n \t  add_implicit_graph_edge (graph, FIRST_REF_NODE + lhsvar, rhsvar);\n \n \t  RESET_BIT (graph->direct_nodes, rhsvar);\n+\t  bitmap_set_bit (graph->address_taken, rhsvar);\n \t}\n       else if (lhsvar > anything_id\n \t       && lhsvar != rhsvar && lhs.offset == 0 && rhs.offset == 0)\n@@ -1015,7 +1067,7 @@ build_pred_graph (void)\n \t{\n \t  if (rhs.offset != 0)\n \t    RESET_BIT (graph->direct_nodes, lhs.var);\n-\t  if (lhs.offset != 0)\n+\t  else if (lhs.offset != 0)\n \t    RESET_BIT (graph->direct_nodes, rhs.var);\n \t}\n     }\n@@ -1083,7 +1135,7 @@ DEF_VEC_ALLOC_I(unsigned,heap);\n struct scc_info\n {\n   sbitmap visited;\n-  sbitmap roots;\n+  sbitmap deleted;\n   unsigned int *dfs;\n   unsigned int *node_mapping;\n   int current_index;\n@@ -1122,7 +1174,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \tbreak;\n \n       w = find (i);\n-      if (TEST_BIT (si->roots, w))\n+      if (TEST_BIT (si->deleted, w))\n \tcontinue;\n \n       if (!TEST_BIT (si->visited, w))\n@@ -1162,11 +1214,13 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \n \t  lowest_node = bitmap_first_set_bit (scc);\n \t  gcc_assert (lowest_node < FIRST_REF_NODE);\n+\n+\t  /* Collapse the SCC nodes into a single node, and mark the\n+\t     indirect cycles.  */\n \t  EXECUTE_IF_SET_IN_BITMAP (scc, 0, i, bi)\n \t    {\n \t      if (i < FIRST_REF_NODE)\n \t\t{\n-\t\t  /* Mark this node for collapsing.  */\n \t\t  if (unite (lowest_node, i))\n \t\t    unify_nodes (graph, lowest_node, i, false);\n \t\t}\n@@ -1177,7 +1231,7 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \t\t}\n \t    }\n \t}\n-      SET_BIT (si->roots, n);\n+      SET_BIT (si->deleted, n);\n     }\n   else\n     VEC_safe_push (unsigned, heap, si->scc_stack, n);\n@@ -1208,6 +1262,9 @@ unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n   if (get_varinfo (from)->no_tbaa_pruning)\n     get_varinfo (to)->no_tbaa_pruning = true;\n \n+  /* Mark TO as changed if FROM was changed. If TO was already marked\n+     as changed, decrease the changed count.  */\n+\n   if (update_changed && TEST_BIT (changed, from))\n     {\n       RESET_BIT (changed, from);\n@@ -1265,7 +1322,7 @@ struct topo_info\n static struct topo_info *\n init_topo_info (void)\n {\n-  size_t size = VEC_length (varinfo_t, varmap);\n+  size_t size = graph->size;\n   struct topo_info *ti = XNEW (struct topo_info);\n   ti->visited = sbitmap_alloc (size);\n   sbitmap_zero (ti->visited);\n@@ -1326,57 +1383,14 @@ type_safe (unsigned int n, unsigned HOST_WIDE_INT *offset)\n   return (get_varinfo (n)->offset + *offset) < get_varinfo (n)->fullsize;\n }\n \n-/* Process a constraint C that represents *x = &y.  */\n-\n-static void\n-do_da_constraint (constraint_graph_t graph ATTRIBUTE_UNUSED,\n-\t\t  constraint_t c, bitmap delta)\n-{\n-  unsigned int rhs = c->rhs.var;\n-  unsigned int j;\n-  bitmap_iterator bi;\n-\n-  /* For each member j of Delta (Sol(x)), add x to Sol(j)  */\n-  EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n-    {\n-      unsigned HOST_WIDE_INT offset = c->lhs.offset;\n-      if (type_safe (j, &offset) && !(get_varinfo (j)->is_special_var))\n-\t{\n-\t/* *x != NULL && *x != ANYTHING*/\n-\t  varinfo_t v;\n-\t  unsigned int t;\n-\t  bitmap sol;\n-\t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + offset;\n-\n-\t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n-\t  if (!v)\n-\t    continue;\n-\t  t = find (v->id);\n-\t  sol = get_varinfo (t)->solution;\n-\t  if (!bitmap_bit_p (sol, rhs))\n-\t    {\n-\t      bitmap_set_bit (sol, rhs);\n-\t      if (!TEST_BIT (changed, t))\n-\t\t{\n-\t\t  SET_BIT (changed, t);\n-\t\t  changed_count++;\n-\t\t}\n-\t    }\n-\t}\n-      else if (0 && dump_file && !(get_varinfo (j)->is_special_var))\n-\tfprintf (dump_file, \"Untypesafe usage in do_da_constraint.\\n\");\n-\n-    }\n-}\n-\n /* Process a constraint C that represents x = *y, using DELTA as the\n    starting solution.  */\n \n static void\n do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t\t  bitmap delta)\n {\n-  unsigned int lhs = find (c->lhs.var);\n+  unsigned int lhs = c->lhs.var;\n   bool flag = false;\n   bitmap sol = get_varinfo (lhs)->solution;\n   unsigned int j;\n@@ -1435,8 +1449,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n static void\n do_ds_constraint (constraint_t c, bitmap delta)\n {\n-  unsigned int rhs = find (c->rhs.var);\n-  unsigned HOST_WIDE_INT roff = c->rhs.offset;\n+  unsigned int rhs = c->rhs.var;\n   bitmap sol = get_varinfo (rhs)->solution;\n   unsigned int j;\n   bitmap_iterator bi;\n@@ -1487,7 +1500,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  t = find (v->id);\n \t  tmp = get_varinfo (t)->solution;\n \n-\t  if (set_union_with_increment (tmp, sol, roff))\n+\t  if (set_union_with_increment (tmp, sol, 0))\n \t    {\n \t      get_varinfo (t)->solution = tmp;\n \t      if (t == rhs)\n@@ -1514,8 +1527,7 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n     {\n       if (c->rhs.type == ADDRESSOF)\n \t{\n-\t  /* *x = &y */\n-\t  do_da_constraint (graph, c, delta);\n+\t  gcc_unreachable();\n \t}\n       else\n \t{\n@@ -1534,22 +1546,19 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       bitmap tmp;\n       bitmap solution;\n       bool flag = false;\n-      unsigned int t;\n \n       gcc_assert (c->rhs.type == SCALAR && c->lhs.type == SCALAR);\n-      t = find (c->rhs.var);\n-      solution = get_varinfo (t)->solution;\n-      t = find (c->lhs.var);\n-      tmp = get_varinfo (t)->solution;\n+      solution = get_varinfo (c->rhs.var)->solution;\n+      tmp = get_varinfo (c->lhs.var)->solution;\n \n       flag = set_union_with_increment (tmp, solution, c->rhs.offset);\n \n       if (flag)\n \t{\n-\t  get_varinfo (t)->solution = tmp;\n-\t  if (!TEST_BIT (changed, t))\n+\t  get_varinfo (c->lhs.var)->solution = tmp;\n+\t  if (!TEST_BIT (changed, c->lhs.var))\n \t    {\n-\t      SET_BIT (changed, t);\n+\t      SET_BIT (changed, c->lhs.var);\n \t      changed_count++;\n \t    }\n \t}\n@@ -1567,8 +1576,8 @@ init_scc_info (size_t size)\n   si->current_index = 0;\n   si->visited = sbitmap_alloc (size);\n   sbitmap_zero (si->visited);\n-  si->roots = sbitmap_alloc (size);\n-  sbitmap_zero (si->roots);\n+  si->deleted = sbitmap_alloc (size);\n+  sbitmap_zero (si->deleted);\n   si->node_mapping = XNEWVEC (unsigned int, size);\n   si->dfs = XCNEWVEC (unsigned int, size);\n \n@@ -1585,7 +1594,7 @@ static void\n free_scc_info (struct scc_info *si)\n {\n   sbitmap_free (si->visited);\n-  sbitmap_free (si->roots);\n+  sbitmap_free (si->deleted);\n   free (si->node_mapping);\n   free (si->dfs);\n   VEC_free (unsigned, heap, si->scc_stack);\n@@ -1622,62 +1631,145 @@ compute_topo_order (constraint_graph_t graph,\n \t\t    struct topo_info *ti)\n {\n   unsigned int i;\n-  unsigned int size = VEC_length (varinfo_t, varmap);\n+  unsigned int size = graph->size;\n \n   for (i = 0; i != size; ++i)\n     if (!TEST_BIT (ti->visited, i) && find (i) == i)\n       topo_visit (graph, ti, i);\n }\n \n-/* Perform offline variable substitution.\n+/* Structure used to for hash value numbering of pointer equivalence\n+   classes.  */\n+\n+typedef struct equiv_class_label\n+{\n+  unsigned int equivalence_class;\n+  bitmap labels;\n+  hashval_t hashcode;\n+} *equiv_class_label_t;\n+\n+/* A hashtable for mapping a bitmap of labels->pointer equivalence\n+   classes.  */\n+static htab_t pointer_equiv_class_table;\n+\n+/* A hashtable for mapping a bitmap of labels->location equivalence\n+   classes.  */\n+static htab_t location_equiv_class_table;\n+\n+/* Hash function for a equiv_class_label_t */\n+\n+static hashval_t\n+equiv_class_label_hash (const void *p)\n+{\n+  const equiv_class_label_t ecl = (equiv_class_label_t) p;\n+  return ecl->hashcode;\n+}\n+\n+/* Equality function for two equiv_class_label_t's.  */\n+\n+static int\n+equiv_class_label_eq (const void *p1, const void *p2)\n+{\n+  const equiv_class_label_t eql1 = (equiv_class_label_t) p1;\n+  const equiv_class_label_t eql2 = (equiv_class_label_t) p2;\n+  return bitmap_equal_p (eql1->labels, eql2->labels);\n+}\n+\n+/* Lookup a equivalence class in TABLE by the bitmap of LABELS it\n+   contains.  */\n+\n+static unsigned int\n+equiv_class_lookup (htab_t table, bitmap labels)\n+{\n+  void **slot;\n+  struct equiv_class_label ecl;\n+\n+  ecl.labels = labels;\n+  ecl.hashcode = bitmap_hash (labels);\n \n-   This is a linear time way of identifying variables that must have\n-   equivalent points-to sets, including those caused by static cycles,\n-   and single entry subgraphs, in the constraint graph.\n+  slot = htab_find_slot_with_hash (table, &ecl,\n+\t\t\t\t   ecl.hashcode, NO_INSERT);\n+  if (!slot)\n+    return 0;\n+  else\n+    return ((equiv_class_label_t) *slot)->equivalence_class;\n+}\n+\n+\n+/* Add an equivalence class named EQUIVALENCE_CLASS with labels LABELS\n+   to TABLE.  */\n+\n+static void\n+equiv_class_add (htab_t table, unsigned int equivalence_class,\n+\t\t bitmap labels)\n+{\n+  void **slot;\n+  equiv_class_label_t ecl = XNEW (struct equiv_class_label);\n+\n+  ecl->labels = labels;\n+  ecl->equivalence_class = equivalence_class;\n+  ecl->hashcode = bitmap_hash (labels);\n+\n+  slot = htab_find_slot_with_hash (table, ecl,\n+\t\t\t\t   ecl->hashcode, INSERT);\n+  gcc_assert (!*slot);\n+  *slot = (void *) ecl;\n+}\n+\n+/* Perform offline variable substitution.\n \n-   The technique is described in \"Off-line variable substitution for\n-   scaling points-to analysis\" by Atanas Rountev and Satish Chandra,\n-   in \"ACM SIGPLAN Notices\" volume 35, number 5, pages 47-56.\n+   This is a worst case quadratic time way of identifying variables\n+   that must have equivalent points-to sets, including those caused by\n+   static cycles, and single entry subgraphs, in the constraint graph.\n \n-   There is an optimal way to do this involving hash based value\n-   numbering, once the technique is published i will implement it\n-   here.  \n+   The technique is described in \"Exploiting Pointer and Location\n+   Equivalence to Optimize Pointer Analysis. In the 14th International\n+   Static Analysis Symposium (SAS), August 2007.\"  It is known as the\n+   \"HU\" algorithm, and is equivalent to value numbering the collapsed\n+   constraint graph including evaluating unions.\n \n    The general method of finding equivalence classes is as follows:\n    Add fake nodes (REF nodes) and edges for *a = b and a = *b constraints.\n-   Add fake nodes (ADDRESS nodes) and edges for a = &b constraints.\n-   Initialize all non-REF/ADDRESS nodes to be direct nodes\n-   For each SCC in the predecessor graph:\n-      for each member (x) of the SCC\n-         if x is not a direct node:\n-\t   set rootnode(SCC) to be not a direct node\n-\t collapse node x into rootnode(SCC).\n-      if rootnode(SCC) is not a direct node:\n-        label rootnode(SCC) with a new equivalence class\n-      else:\n-        if all labeled predecessors of rootnode(SCC) have the same\n-\tlabel:\n-\t  label rootnode(SCC) with this label\n-\telse:\n-\t  label rootnode(SCC) with a new equivalence class\n+   Initialize all non-REF nodes to be direct nodes.\n+   For each constraint a = a U {b}, we set pts(a) = pts(a) u {fresh\n+   variable}\n+   For each constraint containing the dereference, we also do the same\n+   thing.\n+\n+   We then compute SCC's in the graph and unify nodes in the same SCC,\n+   including pts sets.\n+\n+   For each non-collapsed node x:\n+    Visit all unvisited explicit incoming edges.\n+    Ignoring all non-pointers, set pts(x) = Union of pts(a) for y\n+    where y->x.\n+    Lookup the equivalence class for pts(x).\n+     If we found one, equivalence_class(x) = found class.\n+     Otherwise, equivalence_class(x) = new class, and new_class is\n+    added to the lookup table.\n \n    All direct nodes with the same equivalence class can be replaced\n    with a single representative node.\n    All unlabeled nodes (label == 0) are not pointers and all edges\n    involving them can be eliminated.\n-   We perform these optimizations during move_complex_constraints.\n-*/\n+   We perform these optimizations during rewrite_constraints\n+\n+   In addition to pointer equivalence class finding, we also perform\n+   location equivalence class finding.  This is the set of variables\n+   that always appear together in points-to sets.  We use this to\n+   compress the size of the points-to sets.  */\n+\n+/* Current maximum pointer equivalence class id.  */\n+static int pointer_equiv_class;\n \n-static int equivalence_class;\n+/* Current maximum location equivalence class id.  */\n+static int location_equiv_class;\n \n /* Recursive routine to find strongly connected components in GRAPH,\n-   and label it's nodes with equivalence classes.\n-   This is used during variable substitution to find cycles involving\n-   the regular or implicit predecessors, and label them as equivalent.\n-   The SCC finding algorithm used is the same as that for scc_visit.  */\n+   and label it's nodes with DFS numbers.  */\n \n static void\n-label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n+condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n {\n   unsigned int i;\n   bitmap_iterator bi;\n@@ -1693,11 +1785,11 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n     {\n       unsigned int w = si->node_mapping[i];\n \n-      if (TEST_BIT (si->roots, w))\n+      if (TEST_BIT (si->deleted, w))\n \tcontinue;\n \n       if (!TEST_BIT (si->visited, w))\n-\tlabel_visit (graph, si, w);\n+\tcondense_visit (graph, si, w);\n       {\n \tunsigned int t = si->node_mapping[w];\n \tunsigned int nnode = si->node_mapping[n];\n@@ -1713,11 +1805,11 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n     {\n       unsigned int w = si->node_mapping[i];\n \n-      if (TEST_BIT (si->roots, w))\n+      if (TEST_BIT (si->deleted, w))\n \tcontinue;\n \n       if (!TEST_BIT (si->visited, w))\n-\tlabel_visit (graph, si, w);\n+\tcondense_visit (graph, si, w);\n       {\n \tunsigned int t = si->node_mapping[w];\n \tunsigned int nnode = si->node_mapping[n];\n@@ -1739,46 +1831,96 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \n \t  if (!TEST_BIT (graph->direct_nodes, w))\n \t    RESET_BIT (graph->direct_nodes, n);\n-\t}\n-      SET_BIT (si->roots, n);\n-\n-      if (!TEST_BIT (graph->direct_nodes, n))\n-\t{\n-\t  graph->label[n] = equivalence_class++;\n-\t}\n-      else\n-\t{\n-\t  unsigned int size = 0;\n-\t  unsigned int firstlabel = ~0;\n \n+\t  /* Unify our nodes.  */\n+\t  if (graph->preds[w])\n+\t    {\n+\t      if (!graph->preds[n])\n+\t\tgraph->preds[n] = BITMAP_ALLOC (&predbitmap_obstack);\n+\t      bitmap_ior_into (graph->preds[n], graph->preds[w]);\n+\t    }\n+\t  if (graph->implicit_preds[w])\n+\t    {\n+\t      if (!graph->implicit_preds[n])\n+\t\tgraph->implicit_preds[n] = BITMAP_ALLOC (&predbitmap_obstack);\n+\t      bitmap_ior_into (graph->implicit_preds[n],\n+\t\t\t       graph->implicit_preds[w]);\n+\t    }\n+\t  if (graph->points_to[w])\n+\t    {\n+\t      if (!graph->points_to[n])\n+\t\tgraph->points_to[n] = BITMAP_ALLOC (&predbitmap_obstack);\n+\t      bitmap_ior_into (graph->points_to[n],\n+\t\t\t       graph->points_to[w]);\n+\t    }\n \t  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[n], 0, i, bi)\n \t    {\n-\t      unsigned int j = si->node_mapping[i];\n-\n-\t      if (j == n || graph->label[j] == 0)\n-\t\tcontinue;\n-\n-\t      if (firstlabel == (unsigned int)~0)\n-\t\t{\n-\t\t  firstlabel = graph->label[j];\n-\t\t  size++;\n-\t\t}\n-\t      else if (graph->label[j] != firstlabel)\n-\t\tsize++;\n+\t      unsigned int rep = si->node_mapping[i];\n+\t      graph->number_incoming[rep]++;\n \t    }\n-\n-\t  if (size == 0)\n-\t    graph->label[n] = 0;\n-\t  else if (size == 1)\n-\t    graph->label[n] = firstlabel;\n-\t  else\n-\t    graph->label[n] = equivalence_class++;\n \t}\n+      SET_BIT (si->deleted, n);\n     }\n   else\n     VEC_safe_push (unsigned, heap, si->scc_stack, n);\n }\n \n+/* Label pointer equivalences.  */\n+\n+static void\n+label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n+{\n+  unsigned int i;\n+  bitmap_iterator bi;\n+  SET_BIT (si->visited, n);\n+\n+  if (!graph->points_to[n])\n+    graph->points_to[n] = BITMAP_ALLOC (&predbitmap_obstack);\n+\n+  /* Label and union our incoming edges's points to sets.  */\n+  EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[n], 0, i, bi)\n+    {\n+      unsigned int w = si->node_mapping[i];\n+      if (!TEST_BIT (si->visited, w))\n+\tlabel_visit (graph, si, w);\n+\n+      /* Skip unused edges  */\n+      if (w == n || graph->pointer_label[w] == 0)\n+\t{\n+\t  graph->number_incoming[w]--;\n+\t  continue;\n+\t}\n+      if (graph->points_to[w])\n+\tbitmap_ior_into(graph->points_to[n], graph->points_to[w]);\n+\n+      /* If all incoming edges to w have been processed and\n+\t graph->points_to[w] was not stored in the hash table, we can\n+\t free it.  */\n+      graph->number_incoming[w]--;\n+      if (!graph->number_incoming[w] && !TEST_BIT (graph->pt_used, w))\n+\t{\n+\t  BITMAP_FREE (graph->points_to[w]);\n+\t}\n+    }\n+  /* Indirect nodes get fresh variables.  */\n+  if (!TEST_BIT (graph->direct_nodes, n))\n+    bitmap_set_bit (graph->points_to[n], FIRST_REF_NODE + n);\n+\n+  if (!bitmap_empty_p (graph->points_to[n]))\n+    {\n+      unsigned int label = equiv_class_lookup (pointer_equiv_class_table,\n+\t\t\t\t\t       graph->points_to[n]);\n+      if (!label)\n+\t{\n+\t  SET_BIT (graph->pt_used, n);\n+\t  label = pointer_equiv_class++;\n+\t  equiv_class_add (pointer_equiv_class_table,\n+\t\t\t   label, graph->points_to[n]);\n+\t}\n+      graph->pointer_label[n] = label;\n+    }\n+}\n+\n /* Perform offline variable substitution, discovering equivalence\n    classes, and eliminating non-pointer variables.  */\n \n@@ -1790,24 +1932,79 @@ perform_var_substitution (constraint_graph_t graph)\n   struct scc_info *si = init_scc_info (size);\n \n   bitmap_obstack_initialize (&iteration_obstack);\n-  equivalence_class = 0;\n+  pointer_equiv_class_table = htab_create (511, equiv_class_label_hash,\n+\t\t\t\t\t   equiv_class_label_eq, free);\n+  location_equiv_class_table = htab_create (511, equiv_class_label_hash,\n+\t\t\t\t\t    equiv_class_label_eq, free);\n+  pointer_equiv_class = 1;\n+  location_equiv_class = 1;\n+\n+  /* Condense the nodes, which means to find SCC's, count incoming\n+     predecessors, and unite nodes in SCC's.  */\n+  for (i = 0; i < LAST_REF_NODE; i++)\n+    if (!TEST_BIT (si->visited, si->node_mapping[i]))\n+      condense_visit (graph, si, si->node_mapping[i]);\n \n-  /* We only need to visit the non-address nodes for labeling\n-     purposes, as the address nodes will never have any predecessors,\n-     because &x never appears on the LHS of a constraint.  */\n+  sbitmap_zero (si->visited);\n+  /* Actually the label the nodes for pointer equivalences  */\n   for (i = 0; i < LAST_REF_NODE; i++)\n     if (!TEST_BIT (si->visited, si->node_mapping[i]))\n       label_visit (graph, si, si->node_mapping[i]);\n \n+  /* Calculate location equivalence labels.  */\n+  for (i = 0; i < FIRST_REF_NODE; i++)\n+    {\n+      bitmap pointed_by;\n+      bitmap_iterator bi;\n+      unsigned int j;\n+      unsigned int label;\n+\n+      if (!graph->pointed_by[i])\n+\tcontinue;\n+      pointed_by = BITMAP_ALLOC (&iteration_obstack);\n+\n+      /* Translate the pointed-by mapping for pointer equivalence\n+\t labels.  */\n+      EXECUTE_IF_SET_IN_BITMAP (graph->pointed_by[i], 0, j, bi)\n+\t{\n+\t  bitmap_set_bit (pointed_by,\n+\t\t\t  graph->pointer_label[si->node_mapping[j]]);\n+\t}\n+      /* The original pointed_by is now dead.  */\n+      BITMAP_FREE (graph->pointed_by[i]);\n+\n+      /* Look up the location equivalence label if one exists, or make\n+\t one otherwise.  */\n+      label = equiv_class_lookup (location_equiv_class_table,\n+\t\t\t\t  pointed_by);\n+      if (label == 0)\n+\t{\n+\t  label = location_equiv_class++;\n+\t  equiv_class_add (location_equiv_class_table,\n+\t\t\t   label, pointed_by);\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Found location equivalence for node %s\\n\",\n+\t\t     get_varinfo (i)->name);\n+\t  BITMAP_FREE (pointed_by);\n+\t}\n+      graph->loc_label[i] = label;\n+\n+    }\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     for (i = 0; i < FIRST_REF_NODE; i++)\n       {\n \tbool direct_node = TEST_BIT (graph->direct_nodes, i);\n \tfprintf (dump_file,\n-\t\t \"Equivalence class for %s node id %d:%s is %d\\n\",\n+\t\t \"Equivalence classes for %s node id %d:%s are pointer: %d\"\n+\t\t \", location:%d\\n\",\n \t\t direct_node ? \"Direct node\" : \"Indirect node\", i,\n \t\t get_varinfo (i)->name,\n-\t\t graph->label[si->node_mapping[i]]);\n+\t\t graph->pointer_label[si->node_mapping[i]],\n+\t\t graph->loc_label[si->node_mapping[i]]);\n       }\n \n   /* Quickly eliminate our non-pointer variables.  */\n@@ -1816,7 +2013,8 @@ perform_var_substitution (constraint_graph_t graph)\n     {\n       unsigned int node = si->node_mapping[i];\n \n-      if (graph->label[node] == 0 && TEST_BIT (graph->direct_nodes, node))\n+      if (graph->pointer_label[node] == 0\n+\t  && TEST_BIT (graph->direct_nodes, node))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -1826,6 +2024,7 @@ perform_var_substitution (constraint_graph_t graph)\n \t  clear_edges_for_node (graph, node);\n \t}\n     }\n+\n   return si;\n }\n \n@@ -1836,9 +2035,16 @@ static void\n free_var_substitution_info (struct scc_info *si)\n {\n   free_scc_info (si);\n-  free (graph->label);\n+  free (graph->pointer_label);\n+  free (graph->loc_label);\n+  free (graph->pointed_by);\n+  free (graph->points_to);\n+  free (graph->number_incoming);\n   free (graph->eq_rep);\n   sbitmap_free (graph->direct_nodes);\n+  sbitmap_free (graph->pt_used);\n+  htab_delete (pointer_equiv_class_table);\n+  htab_delete (location_equiv_class_table);\n   bitmap_obstack_release (&iteration_obstack);\n }\n \n@@ -1852,9 +2058,9 @@ find_equivalent_node (constraint_graph_t graph,\n   /* If the address version of this variable is unused, we can\n      substitute it for anything else with the same label.\n      Otherwise, we know the pointers are equivalent, but not the\n-     locations.  */\n+     locations, and we can unite them later.  */\n \n-  if (graph->label[FIRST_ADDR_NODE + node] == 0)\n+  if (!bitmap_bit_p (graph->address_taken, node))\n     {\n       gcc_assert (label < graph->size);\n \n@@ -1868,19 +2074,82 @@ find_equivalent_node (constraint_graph_t graph,\n       else\n \t{\n \t  graph->eq_rep[label] = node;\n+\t  graph->pe_rep[label] = node;\n \t}\n     }\n+  else\n+    {\n+      gcc_assert (label < graph->size);\n+      graph->pe[node] = label;\n+      if (graph->pe_rep[label] == -1)\n+\tgraph->pe_rep[label] = node;\n+    }\n+\n   return node;\n }\n \n-/* Move complex constraints to the appropriate nodes, and collapse\n-   variables we've discovered are equivalent during variable\n-   substitution.  SI is the SCC_INFO that is the result of\n-   perform_variable_substitution.  */\n+/* Unite pointer equivalent but not location equivalent nodes in\n+   GRAPH.  This may only be performed once variable substitution is\n+   finished.  */\n+\n+static void\n+unite_pointer_equivalences (constraint_graph_t graph)\n+{\n+  unsigned int i;\n+\n+  /* Go through the pointer equivalences and unite them to their\n+     representative, if they aren't already.  */\n+  for (i = 0; i < graph->size; i++)\n+    {\n+      unsigned int label = graph->pe[i];\n+      int label_rep = graph->pe_rep[label];\n+\n+      if (label != i && unite (label_rep, i))\n+\tunify_nodes (graph, label_rep, i, false);\n+    }\n+}\n+\n+/* Move complex constraints to the GRAPH nodes they belong to.  */\n \n static void\n-move_complex_constraints (constraint_graph_t graph,\n-\t\t\t  struct scc_info *si)\n+move_complex_constraints (constraint_graph_t graph)\n+{\n+  int i;\n+  constraint_t c;\n+\n+  for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n+    {\n+      if (c)\n+\t{\n+\t  struct constraint_expr lhs = c->lhs;\n+\t  struct constraint_expr rhs = c->rhs;\n+\n+\t  if (lhs.type == DEREF)\n+\t    {\n+\t      insert_into_complex (graph, lhs.var, c);\n+\t    }\n+\t  else if (rhs.type == DEREF)\n+\t    {\n+\t      if (!(get_varinfo (lhs.var)->is_special_var))\n+\t\tinsert_into_complex (graph, rhs.var, c);\n+\t    }\n+\t  else if (rhs.type != ADDRESSOF && lhs.var > anything_id\n+\t\t   && (lhs.offset != 0 || rhs.offset != 0))\n+\t    {\n+\t      insert_into_complex (graph, rhs.var, c);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Optimize and rewrite complex constraints while performing\n+   collapsing of equivalent nodes.  SI is the SCC_INFO that is the\n+   result of perform_variable_substitution.  */\n+\n+static void\n+rewrite_constraints (constraint_graph_t graph,\n+\t\t     struct scc_info *si)\n {\n   int i;\n   unsigned int j;\n@@ -1900,15 +2169,15 @@ move_complex_constraints (constraint_graph_t graph,\n \n       lhsnode = si->node_mapping[lhsvar];\n       rhsnode = si->node_mapping[rhsvar];\n-      lhslabel = graph->label[lhsnode];\n-      rhslabel = graph->label[rhsnode];\n+      lhslabel = graph->pointer_label[lhsnode];\n+      rhslabel = graph->pointer_label[rhsnode];\n \n       /* See if it is really a non-pointer variable, and if so, ignore\n \t the constraint.  */\n       if (lhslabel == 0)\n \t{\n \t  if (!TEST_BIT (graph->direct_nodes, lhsnode))\n-\t    lhslabel = graph->label[lhsnode] = equivalence_class++;\n+\t    lhslabel = graph->pointer_label[lhsnode] = pointer_equiv_class++;\n \t  else\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1927,7 +2196,7 @@ move_complex_constraints (constraint_graph_t graph,\n       if (rhslabel == 0)\n \t{\n \t  if (!TEST_BIT (graph->direct_nodes, rhsnode))\n-\t    rhslabel = graph->label[rhsnode] = equivalence_class++;\n+\t    rhslabel = graph->pointer_label[rhsnode] = pointer_equiv_class++;\n \t  else\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1948,22 +2217,6 @@ move_complex_constraints (constraint_graph_t graph,\n       c->lhs.var = lhsvar;\n       c->rhs.var = rhsvar;\n \n-      if (lhs.type == DEREF)\n-\t{\n-\t  if (rhs.type == ADDRESSOF || rhsvar > anything_id)\n-\t    insert_into_complex (graph, lhsvar, c);\n-\t}\n-      else if (rhs.type == DEREF)\n-\t{\n-\t  if (!(get_varinfo (lhsvar)->is_special_var))\n-\t    insert_into_complex (graph, rhsvar, c);\n-\t}\n-      else if (rhs.type != ADDRESSOF && lhsvar > anything_id\n-\t       && (lhs.offset != 0 || rhs.offset != 0))\n-\t{\n-\t  insert_into_complex (graph, rhsvar, c);\n-\t}\n-\n     }\n }\n \n@@ -2017,7 +2270,7 @@ eliminate_indirect_cycles (unsigned int node)\n static void\n solve_graph (constraint_graph_t graph)\n {\n-  unsigned int size = VEC_length (varinfo_t, varmap);\n+  unsigned int size = graph->size;\n   unsigned int i;\n   bitmap pts;\n \n@@ -2093,6 +2346,13 @@ solve_graph (constraint_graph_t graph)\n \t      /* Process the complex constraints */\n \t      for (j = 0; VEC_iterate (constraint_t, complex, j, c); j++)\n \t\t{\n+\t\t  /* XXX: This is going to unsort the constraints in\n+\t\t     some cases, which will occasionally add duplicate\n+\t\t     constraints during unification.  This does not\n+\t\t     affect correctness.  */\n+\t\t  c->lhs.var = find (c->lhs.var);\n+\t\t  c->rhs.var = find (c->rhs.var);\n+\n \t\t  /* The only complex constraint that can change our\n \t\t     solution to non-empty, given an empty solution,\n \t\t     is a constraint where the lhs side is receiving\n@@ -2253,21 +2513,26 @@ get_constraint_exp_from_ssa_var (tree t)\n }\n \n /* Process a completed constraint T, and add it to the constraint\n-   list.  */\n+   list.  FROM_CALL is true if this is a constraint coming from a\n+   call, which means any DEREFs we see are \"may-deref's\", not\n+   \"must-deref\"'s.  */\n \n static void\n-process_constraint (constraint_t t)\n+process_constraint_1 (constraint_t t, bool from_call)\n {\n   struct constraint_expr rhs = t->rhs;\n   struct constraint_expr lhs = t->lhs;\n \n   gcc_assert (rhs.var < VEC_length (varinfo_t, varmap));\n   gcc_assert (lhs.var < VEC_length (varinfo_t, varmap));\n \n-  if (lhs.type == DEREF)\n-    get_varinfo (lhs.var)->directly_dereferenced = true;\n-  if (rhs.type == DEREF)\n-    get_varinfo (rhs.var)->directly_dereferenced = true;\n+  if (!from_call)\n+    {\n+      if (lhs.type == DEREF)\n+\tget_varinfo (lhs.var)->directly_dereferenced = true;\n+      if (rhs.type == DEREF)\n+\tget_varinfo (rhs.var)->directly_dereferenced = true;\n+    }\n \n   if (!use_field_sensitive)\n     {\n@@ -2285,7 +2550,7 @@ process_constraint (constraint_t t)\n       rhs = t->lhs;\n       t->lhs = t->rhs;\n       t->rhs = rhs;\n-      process_constraint (t);\n+      process_constraint_1 (t, from_call);\n     }\n   /* This can happen in our IR with things like n->a = *p */\n   else if (rhs.type == DEREF && lhs.type == DEREF && rhs.var != anything_id)\n@@ -2303,8 +2568,19 @@ process_constraint (constraint_t t)\n       gcc_assert (!AGGREGATE_TYPE_P (pointedtotype)\n \t\t  || get_varinfo (rhs.var)->is_unknown_size_var);\n \n-      process_constraint (new_constraint (tmplhs, rhs));\n-      process_constraint (new_constraint (lhs, tmplhs));\n+      process_constraint_1 (new_constraint (tmplhs, rhs), from_call);\n+      process_constraint_1 (new_constraint (lhs, tmplhs), from_call);\n+    }\n+  else if (rhs.type == ADDRESSOF && lhs.type == DEREF)\n+    {\n+      /* Split into tmp = &rhs, *lhs = tmp */\n+      tree rhsdecl = get_varinfo (rhs.var)->decl;\n+      tree pointertype = TREE_TYPE (rhsdecl);\n+      tree tmpvar = create_tmp_var_raw (pointertype, \"derefaddrtmp\");\n+      struct constraint_expr tmplhs = get_constraint_exp_from_ssa_var (tmpvar);\n+\n+      process_constraint_1 (new_constraint (tmplhs, rhs), from_call);\n+      process_constraint_1 (new_constraint (lhs, tmplhs), from_call);\n     }\n   else\n     {\n@@ -2313,6 +2589,16 @@ process_constraint (constraint_t t)\n     }\n }\n \n+\n+/* Process constraint T, performing various simplifications and then\n+   adding it to our list of overall constraints.  */\n+\n+static void\n+process_constraint (constraint_t t)\n+{\n+  process_constraint_1 (t, false);\n+}\n+\n /* Return true if T is a variable of a type that could contain\n    pointers.  */\n \n@@ -2453,6 +2739,13 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results)\n \n       result->offset = 0;\n     }\n+  else if (bitmaxsize == -1)\n+    {\n+      /* We can't handle DEREF constraints with unknown size, we'll\n+\t get the wrong answer.  Punt and return anything.  */\n+      result->var = anything_id;\n+      result->offset = 0;\n+    }\n }\n \n \n@@ -2502,16 +2795,7 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n      when it is the NULL pointer, and then we just say it points to\n      NULL.  */\n   if (TREE_CODE (t) == INTEGER_CST\n-      && !POINTER_TYPE_P (TREE_TYPE (t)))\n-    {\n-      temp.var = integer_id;\n-      temp.type = SCALAR;\n-      temp.offset = 0;\n-      VEC_safe_push (ce_s, heap, *results, &temp);\n-      return;\n-    }\n-  else if (TREE_CODE (t) == INTEGER_CST\n-\t   && integer_zerop (t))\n+      && integer_zerop (t))\n     {\n       temp.var = nothing_id;\n       temp.type = ADDRESSOF;\n@@ -2536,33 +2820,12 @@ get_constraint_for (tree t, VEC (ce_s, heap) **results)\n \n \t      get_constraint_for (exp, results);\n \n-\t      /* Make sure we capture constraints to all elements\n-\t\t of an array.  */\n-\t      if ((handled_component_p (exp)\n-\t\t   && ref_contains_array_ref (exp))\n-\t\t  || TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)\n-\t\t{\n-\t\t  struct constraint_expr *origrhs;\n-\t\t  varinfo_t origvar;\n-\t\t  struct constraint_expr tmp;\n-\n-\t\t  if (VEC_length (ce_s, *results) == 0)\n-\t\t    return;\n \n-\t\t  gcc_assert (VEC_length (ce_s, *results) == 1);\n-\t\t  origrhs = VEC_last (ce_s, *results);\n-\t\t  tmp = *origrhs;\n-\t\t  VEC_pop (ce_s, *results);\n-\t\t  origvar = get_varinfo (origrhs->var);\n-\t\t  for (; origvar; origvar = origvar->next)\n-\t\t    {\n-\t\t      tmp.var = origvar->id;\n-\t\t      VEC_safe_push (ce_s, heap, *results, &tmp);\n-\t\t    }\n-\t\t}\n-\t      else if (VEC_length (ce_s, *results) == 1\n-\t\t       && (AGGREGATE_TYPE_P (pttype)\n-\t\t\t   || TREE_CODE (pttype) == COMPLEX_TYPE))\n+\t      /* Complex types are special. Taking the address of one\n+\t\t allows you to access either part of it through that\n+\t\t pointer.  */\n+\t      if (VEC_length (ce_s, *results) == 1 &&\n+\t\t  TREE_CODE (pttype) == COMPLEX_TYPE)\n \t\t{\n \t\t  struct constraint_expr *origrhs;\n \t\t  varinfo_t origvar;\n@@ -3181,7 +3444,7 @@ update_alias_info (tree stmt, struct alias_info *ai)\n \t  /* Update the frequency estimate for all the dereferences of\n \t     pointer OP.  */\n \t  update_mem_sym_stats_from_stmt (op, stmt, num_loads, num_stores);\n-\t  \n+\n \t  /* Indicate that STMT contains pointer dereferences.  */\n \t  stmt_dereferences_ptr_p = true;\n \t}\n@@ -3290,7 +3553,8 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n   unsigned int i = 0;\n   unsigned int j = 0;\n   VEC (ce_s, heap) *temp = NULL;\n-  unsigned HOST_WIDE_INT rhsoffset = 0;\n+  unsigned int rhsoffset = 0;\n+  bool unknown_addend = false;\n \n   if (TREE_CODE (expr) != POINTER_PLUS_EXPR)\n     return false;\n@@ -3301,15 +3565,11 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n \n   get_constraint_for (op0, &temp);\n \n-  /* We can only handle positive offsets that do not overflow\n-     if we multiply it by BITS_PER_UNIT.  */\n-  if (host_integerp (op1, 1))\n-    {\n-      rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n-\n-      if (rhsoffset / BITS_PER_UNIT != TREE_INT_CST_LOW (op1))\n-\treturn false;\n-    }\n+  /* Handle non-constants by making constraints from integer.  */\n+  if (TREE_CODE (op1) == INTEGER_CST)\n+    rhsoffset = TREE_INT_CST_LOW (op1) * BITS_PER_UNIT;\n+  else\n+    unknown_addend = true;\n \n   for (i = 0; VEC_iterate (ce_s, lhsc, i, c); i++)\n     for (j = 0; VEC_iterate (ce_s, temp, j, c2); j++)\n@@ -3326,6 +3586,30 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n \t    c2->var = temp->id;\n \t    c2->offset = 0;\n \t  }\n+\telse if (unknown_addend)\n+\t  {\n+\t    /* Can't handle *a + integer where integer is unknown.  */\n+\t    if (c2->type != SCALAR)\n+\t      {\n+\t\tstruct constraint_expr intc;\n+\t\tintc.var = integer_id;\n+\t\tintc.offset = 0;\n+\t\tintc.type = SCALAR;\n+\t\tprocess_constraint (new_constraint (*c, intc));\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* We known it lives somewhere within c2->var.  */\n+\t\tvarinfo_t tmp = get_varinfo (c2->var);\n+\t\tfor (; tmp; tmp = tmp->next)\n+\t\t  {\n+\t\t    struct constraint_expr tmpc = *c2;\n+\t\t    c2->var = tmp->id;\n+\t\t    c2->offset = 0;\n+\t\t    process_constraint (new_constraint (*c, tmpc));\n+\t\t  }\n+\t      }\n+\t  }\n \telse\n \t  c2->offset = rhsoffset;\n \tprocess_constraint (new_constraint (*c, *c2));\n@@ -3336,6 +3620,39 @@ handle_ptr_arith (VEC (ce_s, heap) *lhsc, tree expr)\n   return true;\n }\n \n+/* For non-IPA mode, generate constraints necessary for a call on the\n+   RHS.  */\n+\n+static void\n+handle_rhs_call  (tree rhs)\n+{\n+  tree arg;\n+  call_expr_arg_iterator iter;\n+  struct constraint_expr rhsc;\n+\n+  rhsc.var = anything_id;\n+  rhsc.offset = 0;\n+  rhsc.type = ADDRESSOF;\n+\n+  FOR_EACH_CALL_EXPR_ARG (arg, iter, rhs)\n+    {\n+      VEC(ce_s, heap) *lhsc = NULL;\n+\n+      /* Find those pointers being passed, and make sure they end up\n+\t pointing to anything.  */\n+      if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+\t{\n+\t  unsigned int j;\n+\t  struct constraint_expr *lhsp;\n+\n+\t  get_constraint_for (arg, &lhsc);\n+\t  do_deref (&lhsc);\n+\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t    process_constraint_1 (new_constraint (*lhsp, rhsc), true);\n+\t  VEC_free (ce_s, heap, lhsc);\n+\t}\n+    }\n+}\n \n /* Walk statement T setting up aliasing constraints according to the\n    references found in T.  This function is the main part of the\n@@ -3393,100 +3710,112 @@ find_func_aliases (tree origt)\n   /* In IPA mode, we need to generate constraints to pass call\n      arguments through their calls.   There are two cases, either a\n      GIMPLE_MODIFY_STMT when we are returning a value, or just a plain\n-     CALL_EXPR when we are not.   */\n-  else if (in_ipa_mode\n-\t   && ((TREE_CODE (t) == GIMPLE_MODIFY_STMT\n-\t\t&& TREE_CODE (GIMPLE_STMT_OPERAND (t, 1)) == CALL_EXPR\n-\t       && !(call_expr_flags (GIMPLE_STMT_OPERAND (t, 1))\n-\t\t    & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-\t       || (TREE_CODE (t) == CALL_EXPR\n-\t\t   && !(call_expr_flags (t)\n-\t\t\t& (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))))\n+     CALL_EXPR when we are not.\n+\n+     In non-ipa mode, we need to generate constraints for each\n+     pointer passed by address.  */\n+  else if (((TREE_CODE (t) == GIMPLE_MODIFY_STMT\n+\t     && TREE_CODE (GIMPLE_STMT_OPERAND (t, 1)) == CALL_EXPR\n+\t     && !(call_expr_flags (GIMPLE_STMT_OPERAND (t, 1))\n+\t\t  & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n+\t    || (TREE_CODE (t) == CALL_EXPR\n+\t\t&& !(call_expr_flags (t)\n+\t\t     & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))))\n     {\n-      tree lhsop;\n-      tree rhsop;\n-      tree arg;\n-      call_expr_arg_iterator iter;\n-      varinfo_t fi;\n-      int i = 1;\n-      tree decl;\n-      if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+      if (!in_ipa_mode)\n \t{\n-\t  lhsop = GIMPLE_STMT_OPERAND (t, 0);\n-\t  rhsop = GIMPLE_STMT_OPERAND (t, 1);\n-\t}\n-      else\n-\t{\n-\t  lhsop = NULL;\n-\t  rhsop = t;\n-\t}\n-      decl = get_callee_fndecl (rhsop);\n-\n-      /* If we can directly resolve the function being called, do so.\n-\t Otherwise, it must be some sort of indirect expression that\n-\t we should still be able to handle.  */\n-      if (decl)\n-\t{\n-\t  fi = get_vi_for_tree (decl);\n+\t  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n+\t    handle_rhs_call (GIMPLE_STMT_OPERAND (t, 1));\n+\t  else\n+\t    handle_rhs_call (t);\n \t}\n       else\n \t{\n-\t  decl = CALL_EXPR_FN (rhsop);\n-\t  fi = get_vi_for_tree (decl);\n-\t}\n-\n-      /* Assign all the passed arguments to the appropriate incoming\n-\t parameters of the function.  */\n-\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, rhsop)\n- \t{\n-\t  struct constraint_expr lhs ;\n-\t  struct constraint_expr *rhsp;\n-\n-\t  get_constraint_for (arg, &rhsc);\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t  tree lhsop;\n+\t  tree rhsop;\n+\t  tree arg;\n+\t  call_expr_arg_iterator iter;\n+\t  varinfo_t fi;\n+\t  int i = 1;\n+\t  tree decl;\n+\t  if (TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n \t    {\n-\t      lhs.type = DEREF;\n-\t      lhs.var = fi->id;\n-\t      lhs.offset = i;\n+\t      lhsop = GIMPLE_STMT_OPERAND (t, 0);\n+\t      rhsop = GIMPLE_STMT_OPERAND (t, 1);\n \t    }\n \t  else\n \t    {\n-\t      lhs.type = SCALAR;\n-\t      lhs.var = first_vi_for_offset (fi, i)->id;\n-\t      lhs.offset = 0;\n+\t      lhsop = NULL;\n+\t      rhsop = t;\n \t    }\n-\t  while (VEC_length (ce_s, rhsc) != 0)\n+\t  decl = get_callee_fndecl (rhsop);\n+\n+\t  /* If we can directly resolve the function being called, do so.\n+\t     Otherwise, it must be some sort of indirect expression that\n+\t     we should still be able to handle.  */\n+\t  if (decl)\n \t    {\n-\t      rhsp = VEC_last (ce_s, rhsc);\n-\t      process_constraint (new_constraint (lhs, *rhsp));\n-\t      VEC_pop (ce_s, rhsc);\n+\t      fi = get_vi_for_tree (decl);\n+\t    }\n+\t  else\n+\t    {\n+\t      decl = CALL_EXPR_FN (rhsop);\n+\t      fi = get_vi_for_tree (decl);\n \t    }\n-\t  i++;\n-\t}\n \n-      /* If we are returning a value, assign it to the result.  */\n-      if (lhsop)\n-\t{\n-\t  struct constraint_expr rhs;\n-\t  struct constraint_expr *lhsp;\n-\t  unsigned int j = 0;\n+\t  /* Assign all the passed arguments to the appropriate incoming\n+\t     parameters of the function.  */\n \n-\t  get_constraint_for (lhsop, &lhsc);\n-\t  if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, rhsop)\n \t    {\n-\t      rhs.type = DEREF;\n-\t      rhs.var = fi->id;\n-\t      rhs.offset = i;\n+\t      struct constraint_expr lhs ;\n+\t      struct constraint_expr *rhsp;\n+\n+\t      get_constraint_for (arg, &rhsc);\n+\t      if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t\t{\n+\t\t  lhs.type = DEREF;\n+\t\t  lhs.var = fi->id;\n+\t\t  lhs.offset = i;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  lhs.type = SCALAR;\n+\t\t  lhs.var = first_vi_for_offset (fi, i)->id;\n+\t\t  lhs.offset = 0;\n+\t\t}\n+\t      while (VEC_length (ce_s, rhsc) != 0)\n+\t\t{\n+\t\t  rhsp = VEC_last (ce_s, rhsc);\n+\t\t  process_constraint (new_constraint (lhs, *rhsp));\n+\t\t  VEC_pop (ce_s, rhsc);\n+\t\t}\n+\t      i++;\n \t    }\n-\t  else\n+\n+\t  /* If we are returning a value, assign it to the result.  */\n+\t  if (lhsop)\n \t    {\n-\t      rhs.type = SCALAR;\n-\t      rhs.var = first_vi_for_offset (fi, i)->id;\n-\t      rhs.offset = 0;\n+\t      struct constraint_expr rhs;\n+\t      struct constraint_expr *lhsp;\n+\t      unsigned int j = 0;\n+\n+\t      get_constraint_for (lhsop, &lhsc);\n+\t      if (TREE_CODE (decl) != FUNCTION_DECL)\n+\t\t{\n+\t\t  rhs.type = DEREF;\n+\t\t  rhs.var = fi->id;\n+\t\t  rhs.offset = i;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rhs.type = SCALAR;\n+\t\t  rhs.var = first_vi_for_offset (fi, i)->id;\n+\t\t  rhs.offset = 0;\n+\t\t}\n+\t      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n+\t\tprocess_constraint (new_constraint (*lhsp, rhs));\n \t    }\n-\t  for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\t    process_constraint (new_constraint (*lhsp, rhs));\n \t}\n     }\n   /* Otherwise, just a regular assignment statement.  */\n@@ -4299,7 +4628,7 @@ shared_bitmap_lookup (bitmap pt_vars)\n \n   sbi.pt_vars = pt_vars;\n   sbi.hashcode = bitmap_hash (pt_vars);\n-  \n+\n   slot = htab_find_slot_with_hash (shared_bitmap_table, &sbi,\n \t\t\t\t   sbi.hashcode, NO_INSERT);\n   if (!slot)\n@@ -4316,10 +4645,10 @@ shared_bitmap_add (bitmap pt_vars)\n {\n   void **slot;\n   shared_bitmap_info_t sbi = XNEW (struct shared_bitmap_info);\n-  \n+\n   sbi->pt_vars = pt_vars;\n   sbi->hashcode = bitmap_hash (pt_vars);\n-  \n+\n   slot = htab_find_slot_with_hash (shared_bitmap_table, sbi,\n \t\t\t\t   sbi->hashcode, INSERT);\n   gcc_assert (!*slot);\n@@ -4372,6 +4701,7 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n \t      /* If VI->DECL is an aggregate for which we created\n \t\t SFTs, add the SFT corresponding to VI->OFFSET.  */\n \t      tree sft = get_subvar_at (vi->decl, vi->offset);\n+\t      gcc_assert (sft);\n \t      if (sft)\n \t\t{\n \t\t  var_alias_set = get_alias_set (sft);\n@@ -4424,6 +4754,7 @@ set_used_smts (void)\n   for (i = 0; VEC_iterate (varinfo_t, varmap, i, vi); i++)\n     {\n       tree var = vi->decl;\n+      varinfo_t withsolution = get_varinfo (find (i));\n       tree smt;\n       var_ann_t va;\n       struct ptr_info_def *pi = NULL;\n@@ -4436,9 +4767,8 @@ set_used_smts (void)\n       else if (TREE_CODE (var) == SSA_NAME)\n \tpi = SSA_NAME_PTR_INFO (var);\n \n-      /* Skip the special variables and those without their own\n-\t solution set.  */\n-      if (vi->is_special_var || find (vi->id) != vi->id\n+      /* Skip the special variables and those that can't be aliased.  */\n+      if (vi->is_special_var\n \t  || !SSA_VAR_P (var)\n \t  || (pi && !pi->is_dereferenced)\n \t  || (TREE_CODE (var) == VAR_DECL && !may_be_aliased (var))\n@@ -4453,7 +4783,7 @@ set_used_smts (void)\n \tcontinue;\n \n       smt = va->symbol_mem_tag;\n-      if (smt && bitmap_bit_p (vi->solution, anything_id))\n+      if (smt && bitmap_bit_p (withsolution->solution, anything_id))\n \tbitmap_set_bit (used_smts, DECL_UID (smt));\n     }\n }\n@@ -4494,14 +4824,14 @@ merge_smts_into (tree p, bitmap solution)\n \n       aliases = MTAG_ALIASES (smt);\n       if (aliases)\n-        bitmap_ior_into (solution, aliases);\n+\tbitmap_ior_into (solution, aliases);\n     }\n }\n \n /* Given a pointer variable P, fill in its points-to set, or return\n    false if we can't.\n    Rather than return false for variables that point-to anything, we\n-   instead find the corresponding SMT, and merge in it's aliases.  In\n+   instead find the corresponding SMT, and merge in its aliases.  In\n    addition to these aliases, we also set the bits for the SMT's\n    themselves and their subsets, as SMT's are still in use by\n    non-SSA_NAME's, and pruning may eliminate every one of their\n@@ -4549,7 +4879,7 @@ find_what_p_points_to (tree p)\n \t  bool was_pt_anything = false;\n \t  bitmap finished_solution;\n \t  bitmap result;\n-\t  \n+\n \t  if (!pi->is_dereferenced)\n \t    return false;\n \n@@ -4582,10 +4912,10 @@ find_what_p_points_to (tree p)\n \t    }\n \n \t  /* Share the final set of variables when possible.  */\n-\t  \n+\n \t  finished_solution = BITMAP_GGC_ALLOC ();\n \t  stats.points_to_sets_created++;\n-\t  \n+\n \t  /* Instead of using pt_anything, we merge in the SMT aliases\n \t     for the underlying SMT.  In addition, if they could have\n \t     pointed to anything, they could point to global memory.\n@@ -4602,7 +4932,7 @@ find_what_p_points_to (tree p)\n \t      merge_smts_into (p, finished_solution);\n \t      pi->pt_global_mem = 1;\n \t    }\n-\t  \n+\n \t  set_uids_in_ptset (vi->decl, finished_solution, vi->solution,\n \t\t\t     vi->directly_dereferenced,\n \t\t\t     vi->no_tbaa_pruning);\n@@ -4867,8 +5197,6 @@ compute_tbaa_pruning (void)\n       struct topo_info *ti = init_topo_info ();\n       ++stats.iterations;\n \n-      bitmap_obstack_initialize (&iteration_obstack);\n-\n       compute_topo_order (graph, ti);\n \n       while (VEC_length (unsigned, ti->topo_order) != 0)\n@@ -4935,7 +5263,6 @@ compute_tbaa_pruning (void)\n \t}\n \n       free_topo_info (ti);\n-      bitmap_obstack_release (&iteration_obstack);\n     }\n \n   sbitmap_free (changed);\n@@ -5034,21 +5361,43 @@ compute_points_to_sets (struct alias_info *ai)\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\nCollapsing static cycles and doing variable \"\n-\t     \"substitution:\\n\");\n+\t     \"substitution\\n\");\n+\n+  init_graph (VEC_length (varinfo_t, varmap) * 2);\n+  \n+  if (dump_file)\n+    fprintf (dump_file, \"Building predecessor graph\\n\");\n   build_pred_graph ();\n+  \n+  if (dump_file)\n+    fprintf (dump_file, \"Detecting pointer and location \"\n+\t     \"equivalences\\n\");\n   si = perform_var_substitution (graph);\n-  move_complex_constraints (graph, si);\n+  \n+  if (dump_file)\n+    fprintf (dump_file, \"Rewriting constraints and unifying \"\n+\t     \"variables\\n\");\n+  rewrite_constraints (graph, si);\n   free_var_substitution_info (si);\n \n   build_succ_graph ();\n+  move_complex_constraints (graph);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Uniting pointer but not location equivalent \"\n+\t     \"variables\\n\");\n+  unite_pointer_equivalences (graph);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Finding indirect cycles\\n\");\n   find_indirect_cycles (graph);\n \n   /* Implicit nodes and predecessors are no longer necessary at this\n      point. */\n   remove_preds_and_fake_succs (graph);\n \n   if (dump_file)\n-    fprintf (dump_file, \"\\nSolving graph:\\n\");\n+    fprintf (dump_file, \"Solving graph\\n\");\n \n   solve_graph (graph);\n \n@@ -5068,8 +5417,7 @@ compute_points_to_sets (struct alias_info *ai)\n void\n delete_points_to_sets (void)\n {\n-  varinfo_t v;\n-  int i;\n+  unsigned int i;\n \n   htab_delete (shared_bitmap_table);\n   if (dump_file && (dump_flags & TDF_STATS))\n@@ -5080,12 +5428,14 @@ delete_points_to_sets (void)\n   bitmap_obstack_release (&pta_obstack);\n   VEC_free (constraint_t, heap, constraints);\n \n-  for (i = 0; VEC_iterate (varinfo_t, varmap, i, v); i++)\n+  for (i = 0; i < graph->size; i++)\n     VEC_free (constraint_t, heap, graph->complex[i]);\n   free (graph->complex);\n \n   free (graph->rep);\n   free (graph->succs);\n+  free (graph->pe);\n+  free (graph->pe_rep);\n   free (graph->indirect_cycles);\n   free (graph);\n \n@@ -5174,8 +5524,6 @@ ipa_pta_execute (void)\n \t}\n     }\n \n-\n-\n   if (dump_file)\n     {\n       fprintf (dump_file, \"Points-to analysis\\n\\nConstraints:\\n\\n\");\n@@ -5187,20 +5535,23 @@ ipa_pta_execute (void)\n \t     \"\\nCollapsing static cycles and doing variable \"\n \t     \"substitution:\\n\");\n \n+  init_graph (VEC_length (varinfo_t, varmap) * 2);\n   build_pred_graph ();\n   si = perform_var_substitution (graph);\n-  move_complex_constraints (graph, si);\n+  rewrite_constraints (graph, si);\n   free_var_substitution_info (si);\n \n   build_succ_graph ();\n+  move_complex_constraints (graph);\n+  unite_pointer_equivalences (graph);\n   find_indirect_cycles (graph);\n \n   /* Implicit nodes and predecessors are no longer necessary at this\n      point. */\n   remove_preds_and_fake_succs (graph);\n \n   if (dump_file)\n-    fprintf (dump_file, \"\\nSolving graph:\\n\");\n+    fprintf (dump_file, \"\\nSolving graph\\n\");\n \n   solve_graph (graph);\n \n@@ -5226,7 +5577,7 @@ struct tree_opt_pass pass_ipa_pta =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  0,                                    /* todo_flags_finish */\n+  TODO_update_ssa,                      /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n "}]}