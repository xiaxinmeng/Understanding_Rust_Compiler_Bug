{"sha": "b7dfc2074c78415d451eb34d1608016c80b1c41a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjdkZmMyMDc0Yzc4NDE1ZDQ1MWViMzRkMTYwODAxNmM4MGIxYzQxYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-14T18:22:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-15T15:43:23Z"}, "message": "c++: module mapper\n\nTo avoid always requiring an active mapper to connect to, we provide a\ndefault in-process mapper with similar functionality to the sample\nserver.  This is that code.  Also included is the client-side\nconnection mechanism, which determines what server to use and how to\nconnect to it.\n\n\tgcc/cp/\n\t* Make-lang.in (CXX_AND_OBJCXX_OBJS): Add mapper-client &\n\tmapper-resolver.\n\t* mapper-client.h: New.\n\t* mapper-client.cc: New.\n\t* mapper-resolver.cc: New.", "tree": {"sha": "b9b348252e31d5fbe40e37f4e24879bea1da0df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9b348252e31d5fbe40e37f4e24879bea1da0df5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7dfc2074c78415d451eb34d1608016c80b1c41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7dfc2074c78415d451eb34d1608016c80b1c41a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7dfc2074c78415d451eb34d1608016c80b1c41a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7dfc2074c78415d451eb34d1608016c80b1c41a/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2efd8b1ffd0301c97575db4997257079744daf58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2efd8b1ffd0301c97575db4997257079744daf58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2efd8b1ffd0301c97575db4997257079744daf58"}], "stats": {"total": 449, "additions": 448, "deletions": 1}, "files": [{"sha": "49272464409dbe70864002e4e21893685e70bcd5", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=b7dfc2074c78415d451eb34d1608016c80b1c41a", "patch": "@@ -94,7 +94,8 @@ CXX_AND_OBJCXX_OBJS = \\\n \tcp/error.o cp/except.o cp/expr.o \\\n \tcp/friend.o cp/init.o \\\n \tcp/lambda.o cp/lex.o cp/logic.o \\\n-\tcp/mangle.o cp/method.o cp/module.o \\\n+\tcp/mangle.o cp/mapper-client.o cp/mapper-resolver.o \\\n+\tcp/method.o cp/module.o \\\n \tcp/name-lookup.o cp/optimize.o \\\n \tcp/parser.o cp/pt.o cp/ptree.o \\\n \tcp/rtti.o \\"}, {"sha": "acec591296a62b07ea413e2c5eb71e24d6519722", "filename": "gcc/cp/mapper-client.cc", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2Fmapper-client.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2Fmapper-client.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmapper-client.cc?ref=b7dfc2074c78415d451eb34d1608016c80b1c41a", "patch": "@@ -0,0 +1,356 @@\n+/* C++ modules.  Experimental!\n+   Copyright (C) 2017-2020 Free Software Foundation, Inc.\n+   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"line-map.h\"\n+#include \"diagnostic-core.h\"\n+#include \"mapper-client.h\"\n+#include \"intl.h\"\n+\n+#include \"../../c++tools/resolver.h\"\n+\n+module_client::module_client (pex_obj *p, int fd_from, int fd_to)\n+  : Client (fd_from, fd_to), pex (p)\n+{\n+}\n+\n+static module_client *\n+spawn_mapper_program (char const **errmsg, std::string &name,\n+\t\t      char const *full_program_name)\n+{\n+  /* Split writable at white-space.  No space-containing args for\n+     you!  */\n+  // At most every other char could be an argument\n+  char **argv = new char *[name.size () / 2 + 2];\n+  unsigned arg_no = 0;\n+  char *str = new char[name.size ()];\n+  memcpy (str, name.c_str () + 1, name.size ());\n+\n+  for (auto ptr = str; ; ++ptr)\n+    {\n+      while (*ptr == ' ')\n+\tptr++;\n+      if (!*ptr)\n+\tbreak;\n+\n+      if (!arg_no)\n+\t{\n+\t  /* @name means look in the compiler's install dir.  */\n+\t  if (ptr[0] == '@')\n+\t    ptr++;\n+\t  else\n+\t    full_program_name = nullptr;\n+\t}\n+\n+      argv[arg_no++] = ptr;\n+      while (*ptr && *ptr != ' ')\n+\tptr++;\n+      if (!*ptr)\n+\tbreak;\n+      *ptr = 0;\n+    }\n+  argv[arg_no] = nullptr;\n+\n+  auto *pex = pex_init (PEX_USE_PIPES, progname, NULL);\n+  FILE *to = pex_input_pipe (pex, false);\n+  name = argv[0];\n+  if (!to)\n+    *errmsg = \"connecting input\";\n+  else\n+    {\n+      int flags = PEX_SEARCH;\n+\n+      if (full_program_name)\n+\t{\n+\t  /* Prepend the invoking path, if the mapper is a simple\n+\t     file name.  */\n+\t  size_t dir_len = progname - full_program_name;\n+\t  std::string argv0;\n+\t  argv0.reserve (dir_len + name.size ());\n+\t  argv0.append (full_program_name, dir_len).append (name);\n+\t  name = std::move (argv0);\n+\t  argv[0] = const_cast <char *> (name.c_str ());\n+\t  flags = 0;\n+\t}\n+      int err;\n+      *errmsg = pex_run (pex, flags, argv[0], argv, NULL, NULL, &err);\n+    }\n+  delete[] str;\n+  delete[] argv;\n+\n+  int fd_from = -1, fd_to = -1;\n+  if (!*errmsg)\n+    {\n+      FILE *from = pex_read_output (pex, false);\n+      if (from && (fd_to = dup (fileno (to))) >= 0)\n+\tfd_from = fileno (from);\n+      else\n+\t*errmsg = \"connecting output\";\n+      fclose (to);\n+    }\n+\n+  if (*errmsg)\n+    {\n+      pex_free (pex);\n+      return nullptr;\n+    }\n+\n+  return new module_client (pex, fd_from, fd_to);\n+}\n+\n+module_client *\n+module_client::open_module_client (location_t loc, const char *o,\n+\t\t\t\t   void (*set_repo) (const char *),\n+\t\t\t\t   char const *full_program_name)\n+{\n+  module_client *c = nullptr;\n+  std::string ident;\n+  std::string name;\n+  char const *errmsg = nullptr;\n+  unsigned line = 0;\n+\n+  if (o && o[0])\n+    {\n+      /* Maybe a local or ipv6 address.  */\n+      name = o;\n+      auto last = name.find_last_of ('?');\n+      if (last != name.npos)\n+\t{\n+\t  ident = name.substr (last + 1);\n+\t  name.erase (last);\n+\t}\n+\n+      if (name.size ())\n+\t{\n+\t  switch (name[0])\n+\t    {\n+\t    case '<':\n+\t      // <from>to or <>fromto, or <>\n+\t      {\n+\t\tsize_t pos = name.find ('>', 1);\n+\t\tif (pos == std::string::npos)\n+\t\t  pos = name.size ();\n+\t\tstd::string from (name, 1, pos - 1);\n+\t\tstd::string to;\n+\t\tif (pos != name.size ())\n+\t\t  to.append (name, pos + 1, std::string::npos);\n+\n+\t\tint fd_from = -1, fd_to = -1;\n+\t\tif (from.empty () && to.empty ())\n+\t\t  {\n+\t\t    fd_from = fileno (stdin);\n+\t\t    fd_to = fileno (stdout);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (!from.empty ())\n+\t\t      {\n+\t\t\tfd_from = std::stoul (from, &pos, 10);\n+\t\t\tif (pos != from.size ())\n+\t\t\t  {\n+\t\t\t    int dir = to.empty ()\n+\t\t\t      ? O_RDWR | O_CLOEXEC : O_RDONLY | O_CLOEXEC;\n+\t\t\t    fd_from = open (from.c_str (), dir);\n+\t\t\t  }\n+\t\t\tif (to.empty ())\n+\t\t\t  fd_to = fd_from;\n+\t\t      }\n+\n+\t\t    if (!from.empty () && fd_from < 0)\n+\t\t      ;\n+\t\t    else if (to.empty ())\n+\t\t      ;\n+\t\t    else\n+\t\t      {\n+\t\t\tfd_to = std::stoul (to, &pos, 10);\n+\t\t\tif (pos != to.size ())\n+\t\t\t  {\n+\t\t\t    int dir = from.empty ()\n+\t\t\t      ? O_RDWR | O_CLOEXEC : O_WRONLY | O_CLOEXEC;\n+\t\t\t    fd_to = open (to.c_str (), dir);\n+\t\t\t    if (fd_to < 0)\n+\t\t\t      close (fd_from);\n+\t\t\t  }\n+\t\t\tif (from.empty ())\n+\t\t\t  fd_from = fd_to;\n+\t\t      }\n+\t\t  }\n+\n+\t\tif (fd_from < 0 || fd_to < 0)\n+\t\t  errmsg = \"opening\";\n+\t\telse\n+\t\t  c = new module_client (fd_from, fd_to);\n+\t      }\n+\t      break;\n+\n+\t    case '=':\n+\t      // =localsocket\n+\t      {\n+\t\tint fd = -1;\n+#if CODY_NETWORKING\n+\t\tfd = Cody::OpenLocal (&errmsg, name.c_str () + 1);\n+#endif\n+\t\tif (fd >= 0)\n+\t\t  c = new module_client (fd, fd);\n+\t      }\n+\t      break;\n+\n+\t    case '|':\n+\t      // |program and args\n+\t      c = spawn_mapper_program (&errmsg, name, full_program_name);\n+\t      break;\n+\n+\t    default:\n+\t      // file or hostname:port\n+\t      {\n+\t\tauto colon = name.find_last_of (':');\n+\t\tif (colon != name.npos)\n+\t\t  {\n+\t\t    char const *cptr = name.c_str () + colon;\n+\t\t    char *endp;\n+\t\t    unsigned port = strtoul (cptr + 1, &endp, 10);\n+\n+\t\t    if (port && endp != cptr + 1 && !*endp)\n+\t\t      {\n+\t\t\tname[colon] = 0;\n+\t\t\tint fd = 01;\n+#if CODY_NETWORKING\n+\t\t\tfd = Cody::OpenInet6 (&errmsg, name.c_str (), port);\n+#endif\n+\t\t\tname[colon] = ':';\n+\n+\t\t\tif (fd >= 0)\n+\t\t\t  c = new module_client (fd, fd);\n+\t\t      }\n+\t\t  }\n+\t\t\n+\t      }\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (!c)\n+    {\n+      // Make a default in-process client\n+      bool file = !errmsg && !name.empty ();\n+      auto r = new module_resolver (!file, true);\n+\n+      if (file)\n+\t{\n+\tint fd = open (name.c_str (), O_RDONLY | O_CLOEXEC);\n+\tif (fd < 0)\n+\t  errmsg = \"opening\";\n+\telse\n+\t  {\n+\t    if (int l = r->read_tuple_file (fd, ident, false))\n+\t      {\n+\t\tif (l > 0)\n+\t\t  line = l;\n+\t\terrmsg = \"reading\";\n+\t      }\n+\t      \n+\t    close (fd);\n+\t  }\n+\t}\n+      else\n+\tr->set_repo (\"gcm.cache\");\n+\n+      auto *s = new Cody::Server (r);\n+      c = new module_client (s);\n+    }\n+\n+#ifdef SIGPIPE\n+  if (!c->IsDirect ())\n+    /* We need to ignore sig pipe for a while.  */\n+    c->sigpipe = signal (SIGPIPE, SIG_IGN);\n+#endif\n+\n+  if (errmsg)\n+    error_at (loc, line ? G_(\"failed %s mapper %qs line %u\")\n+\t      : G_(\"failed %s mapper %qs\"), errmsg, name.c_str (), line);\n+\n+  // now wave hello!\n+  c->Cork ();\n+  c->Connect (std::string (\"GCC\"), ident);\n+  c->ModuleRepo ();\n+  auto packets = c->Uncork ();\n+\n+  auto &connect = packets[0];\n+  if (connect.GetCode () == Cody::Client::PC_CONNECT)\n+    c->flags = Cody::Flags (connect.GetInteger ());\n+  else if (connect.GetCode () == Cody::Client::PC_ERROR)\n+    error_at (loc, \"failed mapper handshake %s\", connect.GetString ().c_str ());\n+\n+  auto &repo = packets[1];\n+  if (repo.GetCode () == Cody::Client::PC_PATHNAME)\n+    set_repo (repo.GetString ().c_str ());\n+\n+  return c;\n+}\n+\n+void\n+module_client::close_module_client (location_t loc, module_client *mapper)\n+{\n+  if (mapper->IsDirect ())\n+    {\n+      auto *s = mapper->GetServer ();\n+      auto *r = s->GetResolver ();\n+      delete s;\n+      delete r;\n+    }\n+  else\n+    {\n+      if (mapper->pex)\n+\t{\n+\t  int fd_write = mapper->GetFDWrite ();\n+\t  if (fd_write >= 0)\n+\t    close (fd_write);\n+\n+\t  int status;\n+\t  pex_get_status (mapper->pex, 1, &status);\n+\n+\t  pex_free (mapper->pex);\n+\t  mapper->pex = NULL;\n+\n+\t  if (WIFSIGNALED (status))\n+\t    error_at (loc, \"mapper died by signal %s\",\n+\t\t      strsignal (WTERMSIG (status)));\n+\t  else if (WIFEXITED (status) && WEXITSTATUS (status) != 0)\n+\t    error_at (loc, \"mapper exit status %d\",\n+\t\t      WEXITSTATUS (status));\n+\t}\n+      else\n+\t{\n+\t  int fd_read = mapper->GetFDRead ();\n+\t  close (fd_read);\n+\t}\n+\n+#ifdef SIGPIPE\n+      // Restore sigpipe\n+      if (mapper->sigpipe != SIG_IGN)\n+\tsignal (SIGPIPE, mapper->sigpipe);\n+#endif\n+    }\n+\n+  delete mapper;\n+}"}, {"sha": "ca1a0aa5509f7fd2992ef9d7ed8227b8e05e0c44", "filename": "gcc/cp/mapper-client.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2Fmapper-client.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2Fmapper-client.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmapper-client.h?ref=b7dfc2074c78415d451eb34d1608016c80b1c41a", "patch": "@@ -0,0 +1,63 @@\n+/* C++ modules.  Experimental!\t-*- c++ -*-\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Forward to the header in c++tools.  */\n+\n+#ifndef MAPPER_CLIENT_H\n+#define MAPPER_CLIENT_H 1\n+\n+#include \"cody.hh\"\n+\n+#ifndef HAVE_SIGHANDLER_T\n+typedef void (*sighandler_t) (int);\n+#endif\n+\n+class module_client : public Cody::Client\n+{\n+  pex_obj *pex = nullptr;\n+  sighandler_t sigpipe = SIG_IGN;\n+  Cody::Flags flags = Cody::Flags::None;\n+\n+public:\n+  module_client (Cody::Server *s)\n+    : Client (s)\n+  {\n+  }\n+  module_client (pex_obj *pex, int fd_from, int fd_to);\n+\n+  module_client (int fd_from, int fd_to)\n+    : Client (fd_from, fd_to)\n+  {\n+  }\n+\n+public:\n+  Cody::Flags get_flags () const\n+  {\n+    return flags;\n+  }\n+\n+public:\n+  static module_client *open_module_client (location_t loc, const char *option,\n+\t\t\t\t\t    void (*set_repo) (const char *),\n+\t\t\t\t\t    char const *);\n+  static void close_module_client (location_t loc, module_client *);\n+};\n+\n+#endif"}, {"sha": "02ec48c61eabdc07e2309f3c912df2aea1d498ab", "filename": "gcc/cp/mapper-resolver.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2Fmapper-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7dfc2074c78415d451eb34d1608016c80b1c41a/gcc%2Fcp%2Fmapper-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmapper-resolver.cc?ref=b7dfc2074c78415d451eb34d1608016c80b1c41a", "patch": "@@ -0,0 +1,27 @@\n+/* C++ modules.  Experimental!\t-*- c++ -*-\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Written by Nathan Sidwell <nathan@acm.org> while at FaceBook\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Forward to the resolver in c++tools.  */\n+\n+#include \"config.h\"\n+#define INCLUDE_ALGORITHM\n+#include \"system.h\"\n+\n+#include \"../../c++tools/resolver.cc\""}]}