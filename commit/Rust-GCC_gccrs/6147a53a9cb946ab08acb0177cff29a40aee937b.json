{"sha": "6147a53a9cb946ab08acb0177cff29a40aee937b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE0N2E1M2E5Y2I5NDZhYjA4YWNiMDE3N2NmZjI5YTQwYWVlOTM3Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-06-27T02:59:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-06-27T02:59:38Z"}, "message": "PR c++/80290 - memory-hog with std::pair.\n\n\t* pt.c (fn_type_unification): Add convs parameter.\n\t(check_non_deducible_conversion): Remember conversion.\n\t(check_non_deducible_conversions): New.  Do checks here.\n\t(type_unification_real): Not here.  Remove flags parm.\n\t* call.c (add_function_candidate): Make convs a parameter.\n\tDon't recalculate the conversion if it's already set.\n\t(add_template_candidate_real): Allocate convs here.\n\t(good_conversion, conv_flags): New.\n\nWhen the std::pair constructors got more complex to handle, it aggravated a\npreexisting algorithmic problem in template overload resolution:\n\nAs part of template argument deduction in a call, once we've deduced all\nthe template arguments we can but before we substitute them to form an\nactual declaration, for any function parameters that don't involve template\nparameters we need to check that it's possible to convert the argument to\nthe parameter type (wg21.link/cwg1391).\n\nAs a result, we end up calculating the conversion twice: once here, and\nthen again in add_function_candidate as part of normal overload resolution.\nNormally this isn't a big deal, but when the argument is a multiply-nested\ninitializer list, doubling the conversion processing at each level leads to\ncombinatorial explosion.\n\nThe patch for trunk avoids the duplication by remembering the conversion we\ncalculate at deduction time and then reusing it in overload resolution\nrather than calculating it again.\n\nFrom-SVN: r262172", "tree": {"sha": "059a3a0d5a3e138552dc289f6a8a57827ababb92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/059a3a0d5a3e138552dc289f6a8a57827ababb92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6147a53a9cb946ab08acb0177cff29a40aee937b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6147a53a9cb946ab08acb0177cff29a40aee937b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6147a53a9cb946ab08acb0177cff29a40aee937b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6147a53a9cb946ab08acb0177cff29a40aee937b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b8d636f00d94a8f04a3cc32025c9263450705e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d636f00d94a8f04a3cc32025c9263450705e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d636f00d94a8f04a3cc32025c9263450705e9d"}], "stats": {"total": 268, "additions": 167, "deletions": 101}, "files": [{"sha": "3043165a1e6e65112590cdfa39c1e19b52907640", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6147a53a9cb946ab08acb0177cff29a40aee937b", "patch": "@@ -1,3 +1,15 @@\n+2018-06-26  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/80290 - memory-hog with std::pair.\n+\t* pt.c (fn_type_unification): Add convs parameter.\n+\t(check_non_deducible_conversion): Remember conversion.\n+\t(check_non_deducible_conversions): New.  Do checks here.\n+\t(type_unification_real): Not here.  Remove flags parm.\n+\t* call.c (add_function_candidate): Make convs a parameter.\n+\tDon't recalculate the conversion if it's already set.\n+\t(add_template_candidate_real): Allocate convs here.\n+\t(good_conversion, conv_flags): New.\n+\n 2018-06-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/86291"}, {"sha": "209c1fd2f0e810b56ad7875471fff21977bcb7be", "filename": "gcc/cp/call.c", "status": "modified", "additions": 68, "deletions": 34, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6147a53a9cb946ab08acb0177cff29a40aee937b", "patch": "@@ -192,7 +192,7 @@ static struct z_candidate *add_conv_candidate\n \t tree, tsubst_flags_t);\n static struct z_candidate *add_function_candidate\n \t(struct z_candidate **, tree, tree, tree, const vec<tree, va_gc> *, tree,\n-\t tree, int, tsubst_flags_t);\n+\t tree, int, conversion**, tsubst_flags_t);\n static conversion *implicit_conversion (tree, tree, tree, bool, int,\n \t\t\t\t\ttsubst_flags_t);\n static conversion *reference_binding (tree, tree, tree, bool, int,\n@@ -1929,6 +1929,23 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   return NULL;\n }\n \n+/* Like implicit_conversion, but return NULL if the conversion is bad.\n+\n+   This is not static so that check_non_deducible_conversion can call it within\n+   add_template_candidate_real as part of overload resolution; it should not be\n+   called outside of overload resolution.  */\n+\n+conversion *\n+good_conversion (tree to, tree from, tree expr,\n+\t\t int flags, tsubst_flags_t complain)\n+{\n+  conversion *c = implicit_conversion (to, from, expr, /*cast*/false,\n+\t\t\t\t       flags, complain);\n+  if (c && c->bad_p)\n+    c = NULL;\n+  return c;\n+}\n+\n /* Add a new entry to the list of candidates.  Used by the add_*_candidate\n    functions.  ARGS will not be changed until a single candidate is\n    selected.  */\n@@ -1975,6 +1992,37 @@ remaining_arguments (tree arg)\n   return n;\n }\n \n+/* [over.match.copy]: When initializing a temporary object (12.2) to be bound\n+   to the first parameter of a constructor where the parameter is of type\n+   \"reference to possibly cv-qualified T\" and the constructor is called with a\n+   single argument in the context of direct-initialization of an object of type\n+   \"cv2 T\", explicit conversion functions are also considered.\n+\n+   So set LOOKUP_COPY_PARM to let reference_binding know that\n+   it's being called in that context.  */\n+\n+int\n+conv_flags (int i, int nargs, tree fn, tree arg, int flags)\n+{\n+  int lflags = flags;\n+  tree t;\n+  if (i == 0 && nargs == 1 && DECL_CONSTRUCTOR_P (fn)\n+      && (t = FUNCTION_FIRST_USER_PARMTYPE (fn))\n+      && (same_type_ignoring_top_level_qualifiers_p\n+\t  (non_reference (TREE_VALUE (t)), DECL_CONTEXT (fn))))\n+    {\n+      if (!(flags & LOOKUP_ONLYCONVERTING))\n+\tlflags |= LOOKUP_COPY_PARM;\n+      if ((flags & LOOKUP_LIST_INIT_CTOR)\n+\t  && BRACE_ENCLOSED_INITIALIZER_P (arg))\n+\tlflags |= LOOKUP_NO_CONVERSION;\n+    }\n+  else\n+    lflags |= LOOKUP_ONLYCONVERTING;\n+\n+  return lflags;\n+}\n+\n /* Create an overload candidate for the function or method FN called\n    with the argument list FIRST_ARG/ARGS and add it to CANDIDATES.\n    FLAGS is passed on to implicit_conversion.\n@@ -1989,11 +2037,11 @@ add_function_candidate (struct z_candidate **candidates,\n \t\t\ttree fn, tree ctype, tree first_arg,\n \t\t\tconst vec<tree, va_gc> *args, tree access_path,\n \t\t\ttree conversion_path, int flags,\n+\t\t\tconversion **convs,\n \t\t\ttsubst_flags_t complain)\n {\n   tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n   int i, len;\n-  conversion **convs;\n   tree parmnode;\n   tree orig_first_arg = first_arg;\n   int skip;\n@@ -2025,7 +2073,8 @@ add_function_candidate (struct z_candidate **candidates,\n     skip = 0;\n \n   len = vec_safe_length (args) - skip + (first_arg != NULL_TREE ? 1 : 0);\n-  convs = alloc_conversions (len);\n+  if (!convs)\n+    convs = alloc_conversions (len);\n \n   /* 13.3.2 - Viable functions [over.match.viable]\n      First, to be a viable function, a candidate function shall have enough\n@@ -2122,6 +2171,13 @@ add_function_candidate (struct z_candidate **candidates,\n       if (parmnode == void_list_node)\n \tbreak;\n \n+      if (convs[i])\n+\t{\n+\t  /* Already set during deduction.  */\n+\t  parmnode = TREE_CHAIN (parmnode);\n+\t  continue;\n+\t}\n+\n       if (i == 0 && first_arg != NULL_TREE)\n \targ = first_arg;\n       else\n@@ -2135,7 +2191,6 @@ add_function_candidate (struct z_candidate **candidates,\n       if (parmnode)\n \t{\n \t  tree parmtype = TREE_VALUE (parmnode);\n-\t  int lflags = flags;\n \n \t  parmnode = TREE_CHAIN (parmnode);\n \n@@ -2173,32 +2228,7 @@ add_function_candidate (struct z_candidate **candidates,\n \t\t}\n \t    }\n \n-\t  /* Core issue 899: When [copy-]initializing a temporary to be bound\n-\t     to the first parameter of a copy constructor (12.8) called with\n-\t     a single argument in the context of direct-initialization,\n-\t     explicit conversion functions are also considered.\n-\n-\t     So set LOOKUP_COPY_PARM to let reference_binding know that\n-\t     it's being called in that context.  We generalize the above\n-\t     to handle move constructors and template constructors as well;\n-\t     the standardese should soon be updated similarly.  */\n-\t  if (ctype && i == 0 && (len-skip == 1)\n-\t      && DECL_CONSTRUCTOR_P (fn)\n-\t      && parmtype != error_mark_node\n-\t      && (same_type_ignoring_top_level_qualifiers_p\n-\t\t  (non_reference (parmtype), ctype)))\n-\t    {\n-\t      if (!(flags & LOOKUP_ONLYCONVERTING))\n-\t\tlflags |= LOOKUP_COPY_PARM;\n-\t      /* We allow user-defined conversions within init-lists, but\n-\t\t don't list-initialize the copy parm, as that would mean\n-\t\t using two levels of braces for the same type.  */\n-\t      if ((flags & LOOKUP_LIST_INIT_CTOR)\n-\t\t  && BRACE_ENCLOSED_INITIALIZER_P (arg))\n-\t\tlflags |= LOOKUP_NO_CONVERSION;\n-\t    }\n-\t  else\n-\t    lflags |= LOOKUP_ONLYCONVERTING;\n+\t  int lflags = conv_flags (i, len-skip, fn, arg, flags);\n \n \t  t = implicit_conversion (parmtype, argtype, arg,\n \t\t\t\t   /*c_cast_p=*/false, lflags, complain);\n@@ -3102,6 +3132,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   tree fn;\n   struct rejection_reason *reason = NULL;\n   int errs;\n+  conversion **convs = NULL;\n \n   /* We don't do deduction on the in-charge parameter, the VTT\n      parameter or 'this'.  */\n@@ -3176,11 +3207,13 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   gcc_assert (ia == nargs_without_in_chrg);\n \n   errs = errorcount+sorrycount;\n+  if (!obj)\n+    convs = alloc_conversions (nargs);\n   fn = fn_type_unification (tmpl, explicit_targs, targs,\n \t\t\t    args_without_in_chrg,\n \t\t\t    nargs_without_in_chrg,\n-\t\t\t    return_type, strict, flags, false,\n-\t\t\t    complain & tf_decltype);\n+\t\t\t    return_type, strict, flags, convs,\n+\t\t\t    false, complain & tf_decltype);\n \n   if (fn == error_mark_node)\n     {\n@@ -3216,7 +3249,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   else\n     cand = add_function_candidate (candidates, fn, ctype,\n \t\t\t\t   first_arg, arglist, access_path,\n-\t\t\t\t   conversion_path, flags, complain);\n+\t\t\t\t   conversion_path, flags, convs, complain);\n   if (DECL_TI_TEMPLATE (fn) != tmpl)\n     /* This situation can occur if a member template of a template\n        class is specialized.  Then, instantiate_template might return\n@@ -3541,7 +3574,7 @@ print_z_candidate (location_t loc, const char *msgstr,\n \t\t\t       r->u.template_unification.return_type,\n \t\t\t       r->u.template_unification.strict,\n \t\t\t       r->u.template_unification.flags,\n-\t\t\t       true, false);\n+\t\t\t       NULL, true, false);\n \t  break;\n \tcase rr_invalid_copy:\n \t  inform (cloc,\n@@ -5517,6 +5550,7 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t\t\t\taccess_path,\n \t\t\t\tconversion_path,\n \t\t\t\tflags,\n+\t\t\t\tNULL,\n \t\t\t\tcomplain);\n     }\n }"}, {"sha": "8d8339c9951f66530fd2af3cc5ea5a3d3af35906", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6147a53a9cb946ab08acb0177cff29a40aee937b", "patch": "@@ -7816,7 +7816,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  instantiation = fn_type_unification (fn, explicit_targs, targs, args,\n \t\t\t\t\t       nargs, ret,\n \t\t\t\t\t      DEDUCE_EXACT, LOOKUP_NORMAL,\n-\t\t\t\t\t       false, false);\n+\t\t\t\t\t       NULL, false, false);\n \t  if (instantiation == error_mark_node)\n \t    /* Instantiation failed.  */\n \t    continue;"}, {"sha": "0fac7e9892f198742b664e7eb62149a306a6c509", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6147a53a9cb946ab08acb0177cff29a40aee937b", "patch": "@@ -6041,6 +6041,8 @@ extern bool can_convert_arg\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern bool can_convert_arg_bad\t\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern int conv_flags\t\t\t\t(int, int, tree, tree, int);\n+extern struct conversion * good_conversion\t(tree, tree, tree, int, tsubst_flags_t);\n extern location_t get_fndecl_argument_location  (tree, int);\n \n \n@@ -6607,6 +6609,7 @@ extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n extern tree fn_type_unification\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t const tree *, unsigned int,\n \t\t\t\t\t\t tree, unification_kind_t, int,\n+\t\t\t\t\t\t struct conversion **,\n \t\t\t\t\t\t bool, bool);\n extern void mark_decl_instantiated\t\t(tree, int);\n extern int more_specialized_fn\t\t\t(tree, tree, int);"}, {"sha": "3780f3492aa1b7fec32e3152210a140e62eb61db", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 83, "deletions": 66, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6147a53a9cb946ab08acb0177cff29a40aee937b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6147a53a9cb946ab08acb0177cff29a40aee937b", "patch": "@@ -155,10 +155,12 @@ static void tsubst_enum\t(tree, tree, tree);\n static tree add_to_template_args (tree, tree);\n static tree add_outermost_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n+static int check_non_deducible_conversion (tree, tree, int, int,\n+\t\t\t\t\t   struct conversion **, bool);\n static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*,\n \t\t\t\t\t     tree);\n static int type_unification_real (tree, tree, tree, const tree *,\n-\t\t\t\t  unsigned int, int, unification_kind_t, int,\n+\t\t\t\t  unsigned int, int, unification_kind_t,\n \t\t\t\t  vec<deferred_access_check, va_gc> **,\n \t\t\t\t  bool);\n static void note_template_header (int);\n@@ -19358,6 +19360,58 @@ pack_deducible_p (tree parm, tree fn)\n   return true;\n }\n \n+/* Subroutine of fn_type_unification: check non-dependent parms for\n+   convertibility.  */\n+\n+static int\n+check_non_deducible_conversions (tree parms, const tree *args, unsigned nargs,\n+\t\t\t\t tree fn, unification_kind_t strict, int flags,\n+\t\t\t\t struct conversion **convs, bool explain_p)\n+{\n+  /* Non-constructor methods need to leave a conversion for 'this', which\n+     isn't included in nargs here.  */\n+  unsigned offset = (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n+\t\t     && !DECL_CONSTRUCTOR_P (fn));\n+\n+  for (unsigned ia = 0;\n+       parms && parms != void_list_node && ia < nargs; )\n+    {\n+      tree parm = TREE_VALUE (parms);\n+\n+      if (TREE_CODE (parm) == TYPE_PACK_EXPANSION\n+\t  && (!TREE_CHAIN (parms)\n+\t      || TREE_CHAIN (parms) == void_list_node))\n+\t/* For a function parameter pack that occurs at the end of the\n+\t   parameter-declaration-list, the type A of each remaining\n+\t   argument of the call is compared with the type P of the\n+\t   declarator-id of the function parameter pack.  */\n+\tbreak;\n+\n+      parms = TREE_CHAIN (parms);\n+\n+      if (TREE_CODE (parm) == TYPE_PACK_EXPANSION)\n+\t/* For a function parameter pack that does not occur at the\n+\t   end of the parameter-declaration-list, the type of the\n+\t   parameter pack is a non-deduced context.  */\n+\tcontinue;\n+\n+      if (!uses_template_parms (parm))\n+\t{\n+\t  tree arg = args[ia];\n+\t  conversion **conv_p = convs ? &convs[ia+offset] : NULL;\n+\t  int lflags = conv_flags (ia, nargs, fn, arg, flags);\n+\n+\t  if (check_non_deducible_conversion (parm, arg, strict, lflags,\n+\t\t\t\t\t      conv_p, explain_p))\n+\t    return 1;\n+\t}\n+\n+      ++ia;\n+    }\n+\n+  return 0;\n+}\n+\n /* The FN is a TEMPLATE_DECL for a function.  ARGS is an array with\n    NARGS elements of the arguments that are being used when calling\n    it.  TARGS is a vector into which the deduced template arguments\n@@ -19400,6 +19454,7 @@ fn_type_unification (tree fn,\n \t\t     tree return_type,\n \t\t     unification_kind_t strict,\n \t\t     int flags,\n+\t\t     struct conversion **convs,\n \t\t     bool explain_p,\n \t\t     bool decltype_p)\n {\n@@ -19604,7 +19659,7 @@ fn_type_unification (tree fn,\n \n   ok = !type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n \t\t\t       full_targs, parms, args, nargs, /*subr=*/0,\n-\t\t\t       strict, flags, &checks, explain_p);\n+\t\t\t       strict, &checks, explain_p);\n   if (!explain_p)\n     pop_tinst_level ();\n   if (!ok)\n@@ -19638,6 +19693,12 @@ fn_type_unification (tree fn,\n       goto fail;\n     }\n \n+  /* DR 1391: All parameters have args, now check non-dependent parms for\n+     convertibility.  */\n+  if (check_non_deducible_conversions (parms, args, nargs, fn, strict, flags,\n+\t\t\t\t       convs, explain_p))\n+    goto fail;\n+\n   /* All is well so far.  Now, check:\n \n      [temp.deduct]\n@@ -19826,14 +19887,15 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n   return result;\n }\n \n-/* Subroutine of unify_one_argument.  PARM is a function parameter of a\n-   template which does contain any deducible template parameters; check if\n+/* Subroutine of fn_type_unification.  PARM is a function parameter of a\n+   template which doesn't contain any deducible template parameters; check if\n    ARG is a suitable match for it.  STRICT, FLAGS and EXPLAIN_P are as in\n    unify_one_argument.  */\n \n static int\n check_non_deducible_conversion (tree parm, tree arg, int strict,\n-\t\t\t\tint flags, bool explain_p)\n+\t\t\t\tint flags, struct conversion **conv_p,\n+\t\t\t\tbool explain_p)\n {\n   tree type;\n \n@@ -19845,17 +19907,23 @@ check_non_deducible_conversion (tree parm, tree arg, int strict,\n   if (same_type_p (parm, type))\n     return unify_success (explain_p);\n \n+  tsubst_flags_t complain = (explain_p ? tf_warning_or_error : tf_none);\n   if (strict == DEDUCE_CONV)\n     {\n-      if (can_convert_arg (type, parm, NULL_TREE, flags,\n-\t\t\t   explain_p ? tf_warning_or_error : tf_none))\n+      if (can_convert_arg (type, parm, NULL_TREE, flags, complain))\n \treturn unify_success (explain_p);\n     }\n   else if (strict != DEDUCE_EXACT)\n     {\n-      if (can_convert_arg (parm, type,\n-\t\t\t   TYPE_P (arg) ? NULL_TREE : arg,\n-\t\t\t   flags, explain_p ? tf_warning_or_error : tf_none))\n+      bool ok = false;\n+      tree conv_arg = TYPE_P (arg) ? NULL_TREE : arg;\n+      if (conv_p)\n+\t/* Avoid recalculating this in add_function_candidate.  */\n+\tok = (*conv_p\n+\t      = good_conversion (parm, type, conv_arg, flags, complain));\n+      else\n+\tok = can_convert_arg (parm, type, conv_arg, flags, complain);\n+      if (ok)\n \treturn unify_success (explain_p);\n     }\n \n@@ -20157,7 +20225,6 @@ type_unification_real (tree tparms,\n \t\t       unsigned int xnargs,\n \t\t       int subr,\n \t\t       unification_kind_t strict,\n-\t\t       int flags,\n \t\t       vec<deferred_access_check, va_gc> **checks,\n \t\t       bool explain_p)\n {\n@@ -20345,57 +20412,6 @@ type_unification_real (tree tparms,\n \t  return unify_parameter_deduction_failure (explain_p, tparm);\n \t}\n \n-      /* DR 1391: All parameters have args, now check non-dependent parms for\n-\t convertibility.  */\n-      if (saw_undeduced < 2)\n-\tfor (ia = 0, parms = xparms, args = xargs, nargs = xnargs;\n-\t     parms && parms != void_list_node && ia < nargs; )\n-\t  {\n-\t    parm = TREE_VALUE (parms);\n-\n-\t    if (TREE_CODE (parm) == TYPE_PACK_EXPANSION\n-\t\t&& (!TREE_CHAIN (parms)\n-\t\t    || TREE_CHAIN (parms) == void_list_node))\n-\t      /* For a function parameter pack that occurs at the end of the\n-\t\t parameter-declaration-list, the type A of each remaining\n-\t\t argument of the call is compared with the type P of the\n-\t\t declarator-id of the function parameter pack.  */\n-\t      break;\n-\n-\t    parms = TREE_CHAIN (parms);\n-\n-\t    if (TREE_CODE (parm) == TYPE_PACK_EXPANSION)\n-\t      /* For a function parameter pack that does not occur at the\n-\t\t end of the parameter-declaration-list, the type of the\n-\t\t parameter pack is a non-deduced context.  */\n-\t      continue;\n-\n-\t    arg = args[ia];\n-\t    ++ia;\n-\n-\t    if (uses_template_parms (parm))\n-\t      continue;\n-\t    if (check_non_deducible_conversion (parm, arg, strict, flags,\n-\t\t\t\t\t\texplain_p))\n-\t      return 1;\n-\n-\t    if (BRACE_ENCLOSED_INITIALIZER_P (arg)\n-\t\t&& (TREE_CODE (parm) == ARRAY_TYPE || is_std_init_list (parm)))\n-\t      {\n-\t\ttree elt, elttype;\n-\t\tunsigned int i;\n-\n-\t\tif (TREE_CODE (parm) == ARRAY_TYPE)\n-\t\t  elttype = TREE_TYPE (parm);\n-\t\telse\n-\t\t  elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (parm), 0);\n-\t\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (arg), i, elt)\n-\t\t  if (check_non_deducible_conversion (elttype, elt, strict,\n-\t\t\t\t\t\t      flags, explain_p))\n-\t\t    return 1;\n-\t      }\n-\t  }\n-\n       /* Now substitute into the default template arguments.  */\n       for (i = 0; i < ntparms; i++)\n \t{\n@@ -22019,7 +22035,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n \tif (type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n \t\t\t\t   args, nargs, 1, DEDUCE_EXACT,\n-\t\t\t\t   LOOKUP_NORMAL, NULL, explain_p))\n+\t\t\t\t   NULL, explain_p))\n \t  return 1;\n \n \tif (flag_noexcept_type)\n@@ -22663,7 +22679,8 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n \t\t\t   args, ix,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t\t\t    ? TREE_TYPE (decl_type) : NULL_TREE),\n-\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL, /*explain_p=*/false,\n+\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL, NULL,\n+\t\t\t   /*explain_p=*/false,\n \t\t\t   /*decltype*/false)\n       == error_mark_node)\n     return NULL_TREE;\n@@ -26799,7 +26816,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \n       targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n       int val = type_unification_real (tparms, targs, parms, &init, 1, 0,\n-\t\t\t\t       DEDUCE_CALL, LOOKUP_NORMAL,\n+\t\t\t\t       DEDUCE_CALL,\n \t\t\t\t       NULL, /*explain_p=*/false);\n       if (val > 0)\n \t{\n@@ -26818,7 +26835,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \t      else\n \t\terror (\"unable to deduce %qT from %qE\", type, init);\n \t      type_unification_real (tparms, targs, parms, &init, 1, 0,\n-\t\t\t\t     DEDUCE_CALL, LOOKUP_NORMAL,\n+\t\t\t\t     DEDUCE_CALL,\n \t\t\t\t     NULL, /*explain_p=*/true);\n \t    }\n \t  return error_mark_node;"}]}