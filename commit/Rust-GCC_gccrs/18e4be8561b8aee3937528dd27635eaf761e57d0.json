{"sha": "18e4be8561b8aee3937528dd27635eaf761e57d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlNGJlODU2MWI4YWVlMzkzNzUyOGRkMjc2MzVlYWY3NjFlNTdkMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-18T17:21:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-18T17:21:36Z"}, "message": "cp-tree.h (UNIQUELY_DERIVED_FROM_P): Adjust lookup_base call.\n\ncp:\n\t* cp-tree.h (UNIQUELY_DERIVED_FROM_P): Adjust lookup_base call.\n\t(ACCESSIBLY_UNIQUELY_DERIVED_P): Remove.\n\t(PUBLICLY_UNIQUELY_DERIVED_P): Adjust lookup_base call.\n\t(enum base_access): Reorganize.\n\t(accessible_base_p, accessible_p): Add consider_local_p parameter.\n\t* call.c (standard_conversion): Update comment about\n\tDERIVED_FROM_P.\n\t(enforce_access): Adjust accessible_p call.\n\t(build_over_call): Adjust accessible_base_p call.\n\t* class.c (convert_to_base): Adjust lookup_base call.\n\t(build_vtbl_ref_1): Likewise.\n\t(warn_about_ambiguous_bases): Likewise. Add early exit.\n\t* cvt.c (convert_to_pointer_force) Adjust lookup_base call.\n\t* search.c (accessible_base_p): Add consider_local_p parameter.\n\t(lookup_base): Pass consider_local_p to accessible_base_p call.\n\t(friend_accessible_p): Check whether scope is a class member.\n\tRemove unnecessary class template check.\n\t(accessible_p): Add consider_local_p parameter. Use it.\n\t(adjust_result_of_qualified_name_lookup): Adjust lookup_base call.\n\t* tree.c (maybe_dummy_object): Likewise.\n\t* typeck.c (comp_except_type): Use PUBLICLY_UNIQUELY_DERIVED_P.\n\t(build_class_member_access_expr): Adjust lookup_base call.\n\t* typeck2.c (binfo_or_else): Likewise.\n\t* rtti.c (build_dynamic_cast_1): Access can consider friendship\n\tand current scope.\ntestsuite:\n\t* g++.dg/eh/shadow1.C: New.\n\nFrom-SVN: r89232", "tree": {"sha": "236c7f936b34023b8a9d3dac4bda50d439059160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/236c7f936b34023b8a9d3dac4bda50d439059160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18e4be8561b8aee3937528dd27635eaf761e57d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e4be8561b8aee3937528dd27635eaf761e57d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e4be8561b8aee3937528dd27635eaf761e57d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e4be8561b8aee3937528dd27635eaf761e57d0/comments", "author": null, "committer": null, "parents": [{"sha": "b499264121070eb0876ab645d34bea38493c1821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b499264121070eb0876ab645d34bea38493c1821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b499264121070eb0876ab645d34bea38493c1821"}], "stats": {"total": 201, "additions": 131, "deletions": 70}, "files": [{"sha": "fa85757b919c4af009403ea9d5e99793984f4d26", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -1,3 +1,31 @@\n+2004-10-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (UNIQUELY_DERIVED_FROM_P): Adjust lookup_base call.\n+\t(ACCESSIBLY_UNIQUELY_DERIVED_P): Remove.\n+\t(PUBLICLY_UNIQUELY_DERIVED_P): Adjust lookup_base call.\n+\t(enum base_access): Reorganize.\n+\t(accessible_base_p, accessible_p): Add consider_local_p parameter.\n+\t* call.c (standard_conversion): Update comment about\n+\tDERIVED_FROM_P.\n+\t(enforce_access): Adjust accessible_p call.\n+\t(build_over_call): Adjust accessible_base_p call.\n+\t* class.c (convert_to_base): Adjust lookup_base call.\n+\t(build_vtbl_ref_1): Likewise.\n+\t(warn_about_ambiguous_bases): Likewise. Add early exit.\n+\t* cvt.c (convert_to_pointer_force) Adjust lookup_base call.\n+\t* search.c (accessible_base_p): Add consider_local_p parameter.\n+\t(lookup_base): Pass consider_local_p to accessible_base_p call.\n+\t(friend_accessible_p): Check whether scope is a class member.\n+\tRemove unnecessary class template check.\n+\t(accessible_p): Add consider_local_p parameter. Use it.\n+\t(adjust_result_of_qualified_name_lookup): Adjust lookup_base call.\n+\t* tree.c (maybe_dummy_object): Likewise.\n+\t* typeck.c (comp_except_type): Use PUBLICLY_UNIQUELY_DERIVED_P.\n+\t(build_class_member_access_expr): Adjust lookup_base call.\n+\t* typeck2.c (binfo_or_else): Likewise.\n+\t* rtti.c (build_dynamic_cast_1): Access can consider friendship\n+\tand current scope.\n+\n 2004-10-17  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/17743"}, {"sha": "f15fd2ccb4a8aa436ef5a837ff4ec5d3175d0f62", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -711,9 +711,9 @@ standard_conversion (tree to, tree from, tree expr)\n \t\t  _class.derived_) of D.  If B is an inaccessible\n \t\t  (clause _class.access_) or ambiguous\n \t\t  (_class.member.lookup_) base class of D, a program\n-\t\t  that necessitates this conversion is ill-formed.  */\n-\t       /* Therefore, we use DERIVED_FROM_P, and not\n-\t\t  ACCESSIBLY_UNIQUELY_DERIVED_FROM_P, in this test.  */\n+\t\t  that necessitates this conversion is ill-formed.\n+\t          Therefore, we use DERIVED_FROM_P, and do not check\n+\t          access or uniqueness.  */\n \t       && DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n \t{\n \t  from = \n@@ -4051,7 +4051,7 @@ enforce_access (tree basetype_path, tree decl)\n {\n   gcc_assert (TREE_CODE (basetype_path) == TREE_BINFO);\n   \n-  if (!accessible_p (basetype_path, decl))\n+  if (!accessible_p (basetype_path, decl, true))\n     {\n       if (TREE_PRIVATE (decl))\n \tcp_error_at (\"%q+#D is private\", decl);\n@@ -4670,15 +4670,15 @@ build_over_call (struct z_candidate *cand, int flags)\n \t\t\t\t       1);\n       /* Check that the base class is accessible.  */\n       if (!accessible_base_p (TREE_TYPE (argtype), \n-\t\t\t      BINFO_TYPE (cand->conversion_path)))\n+\t\t\t      BINFO_TYPE (cand->conversion_path), true))\n \terror (\"%qT is not an accessible base of %qT\",\n \t       BINFO_TYPE (cand->conversion_path),\n \t       TREE_TYPE (argtype));\n       /* If fn was found by a using declaration, the conversion path\n          will be to the derived class, not the base declaring fn. We\n          must convert from derived to base.  */\n       base_binfo = lookup_base (TREE_TYPE (TREE_TYPE (converted_arg)),\n-\t\t\t\tTREE_TYPE (parmtype), ba_ignore, NULL);\n+\t\t\t\tTREE_TYPE (parmtype), ba_unique, NULL);\n       converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n \t\t\t\t       base_binfo, 1);\n       "}, {"sha": "a0a2ed48bce11628dc1add33d83183f7f9aa9079", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -436,7 +436,7 @@ convert_to_base (tree object, tree type, bool check_access)\n   tree binfo;\n \n   binfo = lookup_base (TREE_TYPE (object), type, \n-\t\t       check_access ? ba_check : ba_ignore, \n+\t\t       check_access ? ba_check : ba_unique, \n \t\t       NULL);\n   if (!binfo || binfo == error_mark_node)\n     return error_mark_node;\n@@ -526,7 +526,7 @@ build_vtbl_ref_1 (tree instance, tree idx)\n   if (fixed_type && !cdtorp)\n     {\n       tree binfo = lookup_base (fixed_type, basetype,\n-\t\t\t\tba_ignore|ba_quiet, NULL);\n+\t\t\t\tba_unique | ba_quiet, NULL);\n       if (binfo)\n \tvtbl = unshare_expr (BINFO_VTABLE (binfo));\n     }\n@@ -4392,13 +4392,17 @@ warn_about_ambiguous_bases (tree t)\n   tree binfo;\n   tree base_binfo;\n \n+  /* If there are no repeated bases, nothing can be ambiguous.  */\n+  if (!CLASSTYPE_REPEATED_BASE_P (t))\n+    return;\n+  \n   /* Check direct bases.  */\n   for (binfo = TYPE_BINFO (t), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n       basetype = BINFO_TYPE (base_binfo);\n \n-      if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n+      if (!lookup_base (t, basetype, ba_unique | ba_quiet, NULL))\n \twarning (\"direct base %qT inaccessible in %qT due to ambiguity\",\n \t\t basetype, t);\n     }\n@@ -4410,7 +4414,7 @@ warn_about_ambiguous_bases (tree t)\n       {\n \tbasetype = BINFO_TYPE (binfo);\n \t\n-\tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n+\tif (!lookup_base (t, basetype, ba_unique | ba_quiet, NULL))\n \t  warning (\"virtual base %qT inaccessible in %qT due to ambiguity\",\n \t\t   basetype, t);\n       }"}, {"sha": "b6c976baaa8c6d7262f3ec9c25543a6416659ad2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -924,15 +924,11 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* Nonzero iff TYPE is uniquely derived from PARENT. Ignores\n    accessibility.  */\n #define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) \\\n-  (lookup_base ((TYPE), (PARENT), ba_ignore | ba_quiet, NULL) != NULL_TREE)\n-/* Nonzero iff TYPE is accessible in the current scope and uniquely\n-   derived from PARENT.  */\n-#define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n-  (lookup_base ((TYPE), (PARENT), ba_check | ba_quiet, NULL) != NULL_TREE)\n+  (lookup_base ((TYPE), (PARENT), ba_unique | ba_quiet, NULL) != NULL_TREE)\n /* Nonzero iff TYPE is publicly & uniquely derived from PARENT.  */\n #define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) \\\n-  (lookup_base ((TYPE), (PARENT),  ba_not_special | ba_quiet, NULL) \\\n-   != NULL_TREE)\n+  (lookup_base ((TYPE), (PARENT), ba_ignore_scope | ba_check | ba_quiet, \\\n+   \t\tNULL) != NULL_TREE)\n \n /* Gives the visibility specification for a class type.  */\n #define CLASSTYPE_VISIBILITY(TYPE)\t\t\\\n@@ -2972,13 +2968,13 @@ typedef enum tsubst_flags_t {\n \n /* The kind of checking we can do looking in a class hierarchy.  */\n typedef enum base_access {\n-  ba_any = 0,      /* Do not check access, allow an ambiguous base,\n+  ba_any = 0,  /* Do not check access, allow an ambiguous base,\n \t\t      prefer a non-virtual base */\n-  ba_ignore = 1,   /* Do not check access */\n-  ba_check = 2,    /* Check access */\n-  ba_not_special = 3, /* Do not consider special privilege\n-\t\t         current_class_type might give.  */\n-  ba_quiet = 4     /* Do not issue error messages (bit mask).  */\n+  ba_unique = 1 << 0,  /* Must be a unique base.  */\n+  ba_check_bit = 1 << 1,   /* Check access.  */\n+  ba_check = ba_unique | ba_check_bit,\n+  ba_ignore_scope = 1 << 2, /* Ignore access allowed by local scope.  */\n+  ba_quiet = 1 << 3     /* Do not issue error messages.  */\n } base_access;\n \n /* The various kinds of access check during parsing.  */\n@@ -3999,10 +3995,10 @@ extern void emit_support_tinfos (void);\n extern bool emit_tinfo_decl (tree);\n \n /* in search.c */\n-extern bool accessible_base_p (tree, tree);\n+extern bool accessible_base_p (tree, tree, bool);\n extern tree lookup_base (tree, tree, base_access, base_kind *);\n extern tree dcast_base_hint                     (tree, tree);\n-extern int accessible_p                         (tree, tree);\n+extern int accessible_p                         (tree, tree, bool);\n extern tree lookup_field_1                      (tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n extern int lookup_fnfields_1                    (tree, tree);"}, {"sha": "8e9cb9571558d926438e111e1623d8f3c6b022d5", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -327,11 +327,11 @@ convert_to_pointer_force (tree type, tree expr)\n \t  tree binfo;\n \n \t  binfo = lookup_base (TREE_TYPE (intype), TREE_TYPE (type),\n-\t\t\t       ba_ignore, NULL);\n+\t\t\t       ba_unique, NULL);\n \t  if (!binfo)\n \t    {\n \t      binfo = lookup_base (TREE_TYPE (type), TREE_TYPE (intype),\n-\t\t\t\t   ba_ignore, NULL);\n+\t\t\t\t   ba_unique, NULL);\n \t      code = MINUS_EXPR;\n \t    }\n \t  if (binfo == error_mark_node)"}, {"sha": "9bb2c364bbff41accfd541d1aad6ab1f34adddc1", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -524,7 +524,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n     tree binfo;\n \n     binfo = lookup_base (TREE_TYPE (exprtype), TREE_TYPE (type),\n-\t\t\t ba_not_special, NULL);\n+\t\t\t ba_check, NULL);\n \n     if (binfo)\n       {"}, {"sha": "5b060da5b2806faebb281face27efb4bb878a05a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -150,10 +150,12 @@ dfs_lookup_base (tree binfo, void *data_)\n }\n \n /* Returns true if type BASE is accessible in T.  (BASE is known to be\n-   a (possibly non-proper) base class of T.)  */\n+   a (possibly non-proper) base class of T.)  If CONSIDER_LOCAL_P is\n+   true, consider any special access of the current scope, or access\n+   bestowed by friendship.  */\n \n bool\n-accessible_base_p (tree t, tree base)\n+accessible_base_p (tree t, tree base, bool consider_local_p)\n {\n   tree decl;\n \n@@ -173,7 +175,7 @@ accessible_base_p (tree t, tree base)\n     decl = TREE_CHAIN (decl);\n   while (ANON_AGGR_TYPE_P (t))\n     t = TYPE_CONTEXT (t);\n-  return accessible_p (t, decl);\n+  return accessible_p (t, decl, consider_local_p);\n }\n \n /* Lookup BASE in the hierarchy dominated by T.  Do access checking as\n@@ -259,15 +261,15 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n \tbreak;\n \n       default:\n-\tif ((access & ~ba_quiet) != ba_ignore\n+\tif ((access & ba_check_bit)\n \t    /* If BASE is incomplete, then BASE and TYPE are probably\n \t       the same, in which case BASE is accessible.  If they\n \t       are not the same, then TYPE is invalid.  In that case,\n \t       there's no need to issue another error here, and\n \t       there's no implicit typedef to use in the code that\n \t       follows, so we skip the check.  */\n \t    && COMPLETE_TYPE_P (base)\n-\t    && !accessible_base_p (t, base))\n+\t    && !accessible_base_p (t, base, !(access & ba_ignore_scope)))\n \t  {\n \t    if (!(access & ba_quiet))\n \t      {\n@@ -806,7 +808,7 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n     {\n       /* Perhaps this SCOPE is a member of a class which is a \n \t friend.  */ \n-      if (DECL_CLASS_SCOPE_P (decl)\n+      if (DECL_CLASS_SCOPE_P (scope)\n \t  && friend_accessible_p (DECL_CONTEXT (scope), decl, binfo))\n \treturn 1;\n \n@@ -822,16 +824,6 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n \t  return ret;\n \t}\n     }\n-  else if (CLASSTYPE_TEMPLATE_INFO (scope))\n-    {\n-      int ret;\n-      /* Increment processing_template_decl to make sure that\n-\t dependent_type_p works correctly.  */\n-      ++processing_template_decl;\n-      ret = friend_accessible_p (CLASSTYPE_TI_TEMPLATE (scope), decl, binfo);\n-      --processing_template_decl;\n-      return ret;\n-    }\n \n   return 0;\n }\n@@ -852,13 +844,14 @@ dfs_accessible_post (tree binfo, void *data ATTRIBUTE_UNUSED)\n    class used to name DECL.  Return nonzero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,\n    then we can tell in what context the access is occurring by looking\n-   at the most derived class along the path indicated by BINFO.  */\n+   at the most derived class along the path indicated by BINFO.  If\n+   CONSIDER_LOCAL is true, do consider special access the current\n+   scope or friendship thereof we might have.   */\n \n int \n-accessible_p (tree type, tree decl)\n+accessible_p (tree type, tree decl, bool consider_local_p)\n {\n   tree binfo;\n-  tree t;\n   tree scope;\n   access_kind access;\n \n@@ -910,15 +903,19 @@ accessible_p (tree type, tree decl)\n \n     We walk the base class hierarchy, checking these conditions.  */\n \n-  /* Figure out where the reference is occurring.  Check to see if\n-     DECL is private or protected in this scope, since that will\n-     determine whether protected access is allowed.  */\n-  if (current_class_type)\n-    protected_ok = protected_accessible_p (decl, current_class_type, binfo);\n+  if (consider_local_p)\n+    {\n+      /* Figure out where the reference is occurring.  Check to see if\n+\t DECL is private or protected in this scope, since that will\n+\t determine whether protected access is allowed.  */\n+      if (current_class_type)\n+\tprotected_ok = protected_accessible_p (decl,\n+\t\t\t\t\t       current_class_type, binfo);\n \n-  /* Now, loop through the classes of which we are a friend.  */\n-  if (!protected_ok)\n-    protected_ok = friend_accessible_p (scope, decl, binfo);\n+      /* Now, loop through the classes of which we are a friend.  */\n+      if (!protected_ok)\n+\tprotected_ok = friend_accessible_p (scope, decl, binfo);\n+    }\n \n   /* Standardize the binfo that access_in_type will use.  We don't\n      need to know what path was chosen from this point onwards.  */\n@@ -930,15 +927,15 @@ accessible_p (tree type, tree decl)\n   if (access == ak_public\n       || (access == ak_protected && protected_ok))\n     return 1;\n-  else\n-    {\n-      /* Walk the hierarchy again, looking for a base class that allows\n-\t access.  */\n-      t = dfs_walk_once_accessible (binfo, /*friends=*/true,\n-\t\t\t\t    NULL, dfs_accessible_post, NULL);\n-      \n-      return t != NULL_TREE;\n-    }\n+  \n+  if (!consider_local_p)\n+    return 0;\n+  \n+  /* Walk the hierarchy again, looking for a base class that allows\n+     access.  */\n+  return dfs_walk_once_accessible (binfo, /*friends=*/true,\n+\t\t\t\t   NULL, dfs_accessible_post, NULL)\n+    != NULL_TREE;\n }\n \n struct lookup_field_info {\n@@ -1486,13 +1483,13 @@ adjust_result_of_qualified_name_lookup (tree decl,\n \t or ambiguity -- in either case, the choice of a static member\n \t function might make the usage valid.  */\n       base = lookup_base (context_class, qualifying_scope,\n-\t\t\t  ba_ignore | ba_quiet, NULL);\n+\t\t\t  ba_unique | ba_quiet, NULL);\n       if (base)\n \t{\n \t  BASELINK_ACCESS_BINFO (decl) = base;\n \t  BASELINK_BINFO (decl) \n \t    = lookup_base (base, BINFO_TYPE (BASELINK_BINFO (decl)),\n-\t\t\t   ba_ignore | ba_quiet,\n+\t\t\t   ba_unique | ba_quiet,\n \t\t\t   NULL);\n \t}\n     }"}, {"sha": "afe42e23730cb8cf8c2dc17333b12d671d6d72cc", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -1661,7 +1661,7 @@ maybe_dummy_object (tree type, tree* binfop)\n \n   if (current_class_type\n       && (binfo = lookup_base (current_class_type, type,\n-\t\t\t       ba_ignore | ba_quiet, NULL)))\n+\t\t\t       ba_unique | ba_quiet, NULL)))\n     context = current_class_type;\n   else\n     {"}, {"sha": "cb5a2548d8b5ea56b36f97c79cafceabb8581cd4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -797,7 +797,7 @@ comp_except_types (tree a, tree b, bool exact)\n           || TREE_CODE (b) != RECORD_TYPE)\n         return false;\n       \n-      if (ACCESSIBLY_UNIQUELY_DERIVED_P (a, b))\n+      if (PUBLICLY_UNIQUELY_DERIVED_P (a, b))\n         return true;\n     }\n   return false;\n@@ -1689,7 +1689,7 @@ build_class_member_access_expr (tree object, tree member,\n \t  base_kind kind;\n \n \t  binfo = lookup_base (access_path ? access_path : object_type,\n-\t\t\t       member_scope, ba_ignore,  &kind);\n+\t\t\t       member_scope, ba_unique,  &kind);\n \t  if (binfo == error_mark_node)\n \t    return error_mark_node;\n "}, {"sha": "d28949c55bfd23caa8a63745028d6544d81984d3", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -56,7 +56,7 @@ error_not_base_type (tree basetype, tree type)\n tree\n binfo_or_else (tree base, tree type)\n {\n-  tree binfo = lookup_base (type, base, ba_ignore, NULL);\n+  tree binfo = lookup_base (type, base, ba_unique, NULL);\n \n   if (binfo == error_mark_node)\n     return NULL_TREE;"}, {"sha": "146312b98b204f3da74b58cbf9e9892c2017c6ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -1,3 +1,7 @@\n+2004-10-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/eh/shadow1.C: New.\n+\n 2004-10-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/compile/20041018-1.c: New test."}, {"sha": "15f666a2cfe27201c85cbdc0bec206900ccf4d03", "filename": "gcc/testsuite/g++.dg/eh/shadow1.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fshadow1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e4be8561b8aee3937528dd27635eaf761e57d0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fshadow1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fshadow1.C?ref=18e4be8561b8aee3937528dd27635eaf761e57d0", "patch": "@@ -0,0 +1,32 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 15 Oct 2004 <nathan@codesourcery.com>\n+\n+// We forgot to ignore current context and friends when determing\n+// which exceptions shadowed eachother.\n+\n+struct E;\n+\n+struct B {};\n+\n+struct D : private B\n+{\n+  friend class E;\n+  \n+  static B *baz (D *);\n+  virtual void V () throw (B);  // { dg-error \"overriding\" \"\" }\n+};\n+\n+struct E : public D\n+{\n+  virtual void V () throw (D); // { dg-error \"looser throw\" \"\" }\n+};\n+\n+B* foo (D *);\n+\n+B *D::baz (D *p)\n+{\n+  try {foo (p);}\n+  catch (B const &b) {}\n+  catch (D const &d) {}\n+  return p;\n+}"}]}