{"sha": "dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwMzIzOWMyZDg2MDdhMGY1Y2RiMTNhMjIwYmNmMGM3ZjhlZDdjZA==", "commit": {"author": {"name": "Henry Linjam\u00e4ki", "email": "henry.linjamaki@parmance.com", "date": "2017-11-16T17:20:45Z"}, "committer": {"name": "Pekka J\u00e4\u00e4skel\u00e4inen", "email": "visit0r@gcc.gnu.org", "date": "2017-11-16T17:20:45Z"}, "message": "[BRIGFE] Reduce the number of type conversions due to\nthe untyped HSAIL regs.\n\nInstead of always representing the HSAIL's untyped registers as\nunsigned int, the gccbrig now pre-analyzes the BRIG code and\nbuilds the register variables as a type used the most when storing\nor reading data to/from each register. This reduces the total\nconversions which cannot be always optimized away.\n\nFrom-SVN: r254837", "tree": {"sha": "f2316102f532f913f50ba2931a318058c4bc88e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2316102f532f913f50ba2931a318058c4bc88e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/comments", "author": null, "committer": null, "parents": [{"sha": "35a282e0bc285f2b62dd29220a6ef3a3ed87a0b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35a282e0bc285f2b62dd29220a6ef3a3ed87a0b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35a282e0bc285f2b62dd29220a6ef3a3ed87a0b3"}], "stats": {"total": 732, "additions": 573, "deletions": 159}, "files": [{"sha": "17cc3bc1c42eb76c66272c31446e463f61cfb597", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -1,3 +1,27 @@\n+2017-11-16  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n+\n+\tChange internal representation of HSA registers. Instead\n+\trepresenting HSA's untyped registers as unsigned int the gccbrig\n+\tanalyzes brig code and builds the register variables as a type\n+\tused in tree expressions at most. This gives better chance to\n+\toptimize CONVERT_VIEW_EXPRs away.\n+\t* brigfrontend/brig-code-entry-handler.cc: Add analysis method for\n+\tregister type usage. Handle any-typed register variables.\n+\t* brigfrontend/brig-code-entry-handler.h: New declarations for the\n+\tabove.\n+\t* brigfrontend/brig-copy-move-inst-handler.cc: Handle any-typed\n+\tregister variables.\n+\t* brigfrontend/brig-cvt-inst-handler.cc: Likewise.\n+\t* brigfrontend/brig-function.cc: Build register variables as a\n+\ttype based on results of analysis phase.\n+\t* brigfrontend/brig-function.h: Move HSA register count defines to\n+\tbrig-utils.h.\n+\t* brigfrontend/brig-to-generic.cc: New analysis handler. Analyze\n+\tHSA register usage.\n+\t* brigfrontend/brig-to-generic.h: New declarations.\n+\t* brigfrontend/brig-util.cc: New utility functions.\n+\t* brigfrontend/brig-util.h: New declarations for the above.\n+\n 2017-11-16  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* gccbrig.texi: Added some documentation."}, {"sha": "ad5a41001ad0f3aea694c4473108963d6d6888c2", "filename": "gcc/brig/brigfrontend/brig-basic-inst-handler.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-basic-inst-handler.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -184,15 +184,16 @@ brig_basic_inst_handler::build_unpack (tree_stl_vec &operands)\n   tree and_mask_vec = build_constructor (vec_type, and_mask_vals);\n \n   tree perm = build3 (VEC_PERM_EXPR, vec_type,\n-\t\t      build_reinterpret_cast (vec_type, operands[0]),\n-\t\t      build_reinterpret_cast (vec_type, operands[0]), mask_vec);\n+\t\t      build_resize_convert_view (vec_type, operands[0]),\n+\t\t      build_resize_convert_view (vec_type, operands[0]),\n+\t\t      mask_vec);\n \n   tree cleared = build2 (BIT_AND_EXPR, vec_type, perm, and_mask_vec);\n \n   size_t s = int_size_in_bytes (TREE_TYPE (cleared)) * BITS_PER_UNIT;\n   tree raw_type = build_nonstandard_integer_type (s, true);\n \n-  tree as_int = build_reinterpret_cast (raw_type, cleared);\n+  tree as_int = build_resize_convert_view (raw_type, cleared);\n \n   if (int_size_in_bytes (src_element_type) < 4)\n     {\n@@ -217,7 +218,7 @@ brig_basic_inst_handler::build_pack (tree_stl_vec &operands)\n   size_t vecsize = int_size_in_bytes (TREE_TYPE (operands[0])) * BITS_PER_UNIT;\n   tree wide_type = build_nonstandard_integer_type (vecsize, 1);\n \n-  tree src_vect = build_reinterpret_cast (wide_type, operands[0]);\n+  tree src_vect = build_resize_convert_view (wide_type, operands[0]);\n   src_vect = add_temp_var (\"src_vect\", src_vect);\n \n   tree scalar = operands[1];\n@@ -650,10 +651,10 @@ brig_basic_inst_handler::operator () (const BrigBase *base)\n \n       if (is_fp16_operation)\n \told_value = build_h2f_conversion\n-\t  (build_reinterpret_cast (half_storage_type, operands[0]));\n+\t  (build_resize_convert_view (half_storage_type, operands[0]));\n       else\n \told_value\n-\t  = build_reinterpret_cast (TREE_TYPE (instr_expr), operands[0]);\n+\t  = build_resize_convert_view (TREE_TYPE (instr_expr), operands[0]);\n \n       size_t esize = is_fp16_operation ? 32 : element_size_bits;\n "}, {"sha": "923a4541e0b38e5d7859d5dbd82f7812518a2687", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.cc", "status": "modified", "additions": 68, "deletions": 58, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -137,14 +137,7 @@ brig_code_entry_handler::build_tree_operand (const BrigInstBase &brig_inst,\n \t       correct size here so we don't need a separate unpack/pack for it.\n \t       fp16-fp32 conversion is done in build_operands ().  */\n \t    if (is_input && TREE_TYPE (element) != operand_type)\n-\t      {\n-\t\tif (int_size_in_bytes (TREE_TYPE (element))\n-\t\t    == int_size_in_bytes (operand_type)\n-\t\t    && !INTEGRAL_TYPE_P (operand_type))\n-\t\t  element = build1 (VIEW_CONVERT_EXPR, operand_type, element);\n-\t\telse\n-\t\t  element = convert (operand_type, element);\n-\t      }\n+\t      element = build_resize_convert_view (operand_type, element);\n \n \t    CONSTRUCTOR_APPEND_ELT (constructor_vals, NULL_TREE, element);\n \t    ++operand_ptr;\n@@ -368,7 +361,7 @@ brig_code_entry_handler::build_address_operand\n \t\t to the array object.  */\n \n \t      if (POINTER_TYPE_P (TREE_TYPE (arg_var_decl)))\n-\t\tsymbol_base = build_reinterpret_cast (ptype, arg_var_decl);\n+\t\tsymbol_base = build_resize_convert_view (ptype, arg_var_decl);\n \t      else\n \t\t{\n \t\t  /* In case we are referring to an array (the argument in\n@@ -436,7 +429,8 @@ brig_code_entry_handler::build_address_operand\n \t= (const BrigOperandRegister *) m_parent.get_brig_operand_entry\n \t(addr_operand.reg);\n       tree base_reg_var = m_parent.m_cf->get_m_var_declfor_reg (mem_base_reg);\n-      var_offset = convert_to_pointer (ptr_type_node, base_reg_var);\n+      tree as_uint = build_reinterpret_to_uint (base_reg_var);\n+      var_offset = convert_to_pointer (ptr_type_node, as_uint);\n \n       gcc_assert (var_offset != NULL_TREE);\n     }\n@@ -527,7 +521,10 @@ brig_code_entry_handler::build_tree_operand_from_brig\n     = ((const uint32_t *) &operand_entries->bytes)[operand_index];\n   const BrigBase *operand_data\n     = m_parent.get_brig_operand_entry (operand_offset);\n-  return build_tree_operand (*brig_inst, *operand_data, operand_type);\n+\n+  bool inputp = !gccbrig_hsa_opcode_op_output_p (brig_inst->opcode,\n+\t\t\t\t\t\t operand_index);\n+  return build_tree_operand (*brig_inst, *operand_data, operand_type, inputp);\n }\n \n /* Builds a single (scalar) constant initialized element of type\n@@ -991,8 +988,8 @@ brig_code_entry_handler::expand_or_call_builtin (BrigOpcode16_t brig_opcode,\n   call_operands.resize (4, NULL_TREE);\n   operand_types.resize (4, NULL_TREE);\n   for (size_t i = 0; i < operand_count; ++i)\n-    call_operands.at (i) = build_reinterpret_cast (operand_types.at (i),\n-\t\t\t\t\t\t   call_operands.at (i));\n+    call_operands.at (i) = build_resize_convert_view (operand_types.at (i),\n+\t\t\t\t\t\t      call_operands.at (i));\n \n   tree fnptr = build_fold_addr_expr (built_in);\n   return build_call_array (TREE_TYPE (TREE_TYPE (built_in)), fnptr,\n@@ -1140,6 +1137,28 @@ brig_code_entry_handler::build_h2f_conversion (tree source)\n \n tree_stl_vec\n brig_code_entry_handler::build_operands (const BrigInstBase &brig_inst)\n+{\n+  return build_or_analyze_operands (brig_inst, false);\n+}\n+\n+void\n+brig_code_entry_handler::analyze_operands (const BrigInstBase &brig_inst)\n+{\n+  build_or_analyze_operands (brig_inst, true);\n+}\n+\n+/* Implements both the build_operands () and analyze_operands () call\n+   so changes go in tandem.  Performs build_operands () when ANALYZE\n+   is false.  Otherwise, only analyze operands and return empty\n+   list.\n+\n+   If analyzing record each HSA register operand with the\n+   corresponding resolved operand tree type to\n+   brig_to_generic::m_fn_regs_use_index.  */\n+\n+tree_stl_vec\n+brig_code_entry_handler::\n+build_or_analyze_operands (const BrigInstBase &brig_inst, bool analyze)\n {\n   /* Flush to zero.  */\n   bool ftz = false;\n@@ -1308,9 +1327,19 @@ brig_code_entry_handler::build_operands (const BrigInstBase &brig_inst)\n \t/* Treat the operands as the storage type at this point.  */\n \toperand_type = half_storage_type;\n \n+      if (analyze)\n+\t{\n+\t  if (operand_data->kind == BRIG_KIND_OPERAND_REGISTER)\n+\t    {\n+\t      const BrigOperandRegister &brig_reg\n+\t\t= (const BrigOperandRegister &) *operand_data;\n+\t      m_parent.add_reg_used_as_type (brig_reg, operand_type);\n+\t    }\n+\t  continue;\n+\t}\n+\n       tree operand = build_tree_operand (brig_inst, *operand_data, operand_type,\n \t\t\t\t\t !is_output);\n-\n       gcc_assert (operand);\n \n       /* Cast/convert the inputs to correct types as expected by the GENERIC\n@@ -1319,36 +1348,17 @@ brig_code_entry_handler::build_operands (const BrigInstBase &brig_inst)\n \t{\n \t  if (half_to_float)\n \t    operand = build_h2f_conversion\n-\t      (build_reinterpret_cast (half_storage_type, operand));\n+\t      (build_resize_convert_view (half_storage_type, operand));\n \t  else if (TREE_CODE (operand) != LABEL_DECL\n \t\t   && TREE_CODE (operand) != TREE_VEC\n \t\t   && operand_data->kind != BRIG_KIND_OPERAND_ADDRESS\n-\t\t   && !VECTOR_TYPE_P (TREE_TYPE (operand)))\n+\t\t   && operand_data->kind != BRIG_KIND_OPERAND_OPERAND_LIST)\n \t    {\n-\t      size_t reg_width = int_size_in_bytes (TREE_TYPE (operand));\n-\t      size_t instr_width = int_size_in_bytes (operand_type);\n-\t      if (reg_width == instr_width)\n-\t\toperand = build_reinterpret_cast (operand_type, operand);\n-\t      else if (reg_width > instr_width)\n-\t\t{\n-\t\t  /* Clip the operand because the instruction's bitwidth\n-\t\t     is smaller than the HSAIL reg width.  */\n-\t\t  if (INTEGRAL_TYPE_P (operand_type))\n-\t\t    operand\n-\t\t      = convert_to_integer (signed_or_unsigned_type_for\n-\t\t\t\t\t    (TYPE_UNSIGNED (operand_type),\n-\t\t\t\t\t     operand_type), operand);\n-\t\t  else\n-\t\t    operand = build_reinterpret_cast (operand_type, operand);\n-\t\t}\n-\t      else if (reg_width < instr_width)\n-\t\t/* At least shift amount operands can be read from smaller\n-\t\t   registers than the data operands.  */\n-\t\toperand = convert (operand_type, operand);\n+\t      operand = build_resize_convert_view (operand_type, operand);\n \t    }\n \t  else if (brig_inst.opcode == BRIG_OPCODE_SHUFFLE)\n \t    /* Force the operand type to be treated as the raw type.  */\n-\t    operand = build_reinterpret_cast (operand_type, operand);\n+\t    operand = build_resize_convert_view (operand_type, operand);\n \n \t  if (brig_inst.opcode == BRIG_OPCODE_CMOV && i == 1)\n \t    {\n@@ -1379,8 +1389,9 @@ tree\n brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n \t\t\t\t\t\t  tree output, tree inst_expr)\n {\n-  /* The destination type might be different from the output register\n-     variable type (which is always an unsigned integer type).  */\n+  /* The result/input type might be different from the output register\n+     variable type (can be any type; see get_m_var_declfor_reg @\n+     brig-function.cc).  */\n   tree output_type = TREE_TYPE (output);\n   tree input_type = TREE_TYPE (inst_expr);\n   bool is_fp16 = (brig_inst.type & BRIG_TYPE_BASE_MASK) == BRIG_TYPE_F16\n@@ -1421,12 +1432,12 @@ brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n     {\n       inst_expr = add_temp_var (\"before_f2h\", inst_expr);\n       tree f2h_output = build_f2h_conversion (inst_expr);\n-      tree conv_int = convert_to_integer (output_type, f2h_output);\n-      tree assign = build2 (MODIFY_EXPR, output_type, output, conv_int);\n+      tree conv = build_resize_convert_view (output_type, f2h_output);\n+      tree assign = build2 (MODIFY_EXPR, output_type, output, conv);\n       m_parent.m_cf->append_statement (assign);\n       return assign;\n     }\n-  else if (VECTOR_TYPE_P (TREE_TYPE (output)))\n+  else if (VECTOR_TYPE_P (output_type) && TREE_CODE (output) == CONSTRUCTOR)\n     {\n       /* Expand/unpack the input value to the given vector elements.  */\n       size_t i;\n@@ -1454,22 +1465,21 @@ brig_code_entry_handler::build_output_assignment (const BrigInstBase &brig_inst,\n \t bitwidths.  */\n       size_t src_width = int_size_in_bytes (input_type);\n       size_t dst_width = int_size_in_bytes (output_type);\n-\n-      if (src_width == dst_width)\n-\t{\n-\t  /* A simple bitcast should do.  */\n-\t  tree bitcast = build_reinterpret_cast (output_type, inst_expr);\n-\t  tree assign = build2 (MODIFY_EXPR, output_type, output, bitcast);\n-\t  m_parent.m_cf->append_statement (assign);\n-\t  return assign;\n-\t}\n-      else\n+      tree input = inst_expr;\n+      /* Integer results are extended to the target register width, using\n+\t the same sign as the inst_expr.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (input)) && src_width != dst_width)\n \t{\n-\t  tree conv_int = convert_to_integer (output_type, inst_expr);\n-\t  tree assign = build2 (MODIFY_EXPR, output_type, output, conv_int);\n-\t  m_parent.m_cf->append_statement (assign);\n-\t  return assign;\n+\t  bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (input));\n+\t  tree resized_type\n+\t    = build_nonstandard_integer_type (dst_width * BITS_PER_UNIT,\n+\t\t\t\t\t      unsigned_p);\n+\t  input = convert_to_integer (resized_type, input);\n \t}\n+      input = build_resize_convert_view (output_type, input);\n+      tree assign = build2 (MODIFY_EXPR, output_type, output, input);\n+      m_parent.m_cf->append_statement (assign);\n+      return assign;\n     }\n   return NULL_TREE;\n }\n@@ -1672,7 +1682,7 @@ float_to_half::visit_element (brig_code_entry_handler &caller, tree operand)\n {\n   tree built_in = builtin_decl_explicit (BUILT_IN_HSAIL_F32_TO_F16);\n \n-  tree casted_operand = build_reinterpret_cast (uint32_type_node, operand);\n+  tree casted_operand = build_resize_convert_view (uint32_type_node, operand);\n \n   tree call = call_builtin (built_in, 1, uint16_type_node, uint32_type_node,\n \t\t\t    casted_operand);\n@@ -1701,7 +1711,7 @@ half_to_float::visit_element (brig_code_entry_handler &caller, tree operand)\n \n   tree output = create_tmp_var (const_fp32_type, \"fp32out\");\n   tree casted_result\n-    = build_reinterpret_cast (brig_to_generic::s_fp32_type, call);\n+    = build_resize_convert_view (brig_to_generic::s_fp32_type, call);\n \n   tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_result);\n "}, {"sha": "ef9668a09ec074dd4901c0f50bf64f37e2847146", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.h?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -89,6 +89,7 @@ class brig_code_entry_handler : public brig_entry_handler\n   tree build_h2f_conversion (tree source);\n \n   tree_stl_vec build_operands (const BrigInstBase &brig_inst);\n+  void analyze_operands (const BrigInstBase &brig_inst);\n   tree build_output_assignment (const BrigInstBase &brig_inst, tree output,\n \t\t\t\ttree inst_expr);\n \n@@ -102,6 +103,11 @@ class brig_code_entry_handler : public brig_entry_handler\n   /* HSAIL-specific builtin functions not yet integrated to gcc.  */\n \n   static builtin_map s_custom_builtins;\n+\n+private:\n+\n+  tree_stl_vec build_or_analyze_operands (const BrigInstBase &brig_inst,\n+\t\t\t\t\t  bool analyze);\n };\n \n /* Implement the Visitor software pattern for performing various actions on"}, {"sha": "ce84599bbd135a030641730b464dfc3bd4ad8b0d", "filename": "gcc/brig/brigfrontend/brig-copy-move-inst-handler.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-copy-move-inst-handler.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -53,12 +53,12 @@ brig_copy_move_inst_handler::operator () (const BrigBase *base)\n \n   tree input = build_tree_operand_from_brig (brig_inst, source_type, 1);\n   tree output = build_tree_operand_from_brig (brig_inst, dest_type, 0);\n+\n   if (brig_inst->opcode == BRIG_OPCODE_COMBINE)\n     {\n       /* For combine, a simple reinterpret cast from the array constructor\n \t works.  */\n-\n-      tree casted = build_reinterpret_cast (dest_type, input);\n+      tree casted = build_resize_convert_view (TREE_TYPE (output), input);\n       tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted);\n       m_parent.m_cf->append_statement (assign);\n     }"}, {"sha": "18850a1fb8d83b9dd4d4820af6fa7175daed440d", "filename": "gcc/brig/brigfrontend/brig-cvt-inst-handler.cc", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-cvt-inst-handler.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -116,7 +116,7 @@ brig_cvt_inst_handler::generate (const BrigBase *base)\n   /* Flush the float operand to zero if indicated with 'ftz'.  */\n   if (FTZ && SCALAR_FLOAT_TYPE_P (src_type))\n     {\n-      tree casted_input = build_reinterpret_cast (src_type, input);\n+      tree casted_input = build_resize_convert_view (src_type, input);\n       input = flush_to_zero (src_is_fp16) (*this, casted_input);\n     }\n \n@@ -158,7 +158,8 @@ brig_cvt_inst_handler::generate (const BrigBase *base)\n \t    }\n \t  else\n \t    gcc_unreachable ();\n-\t  tree casted_input = build_reinterpret_cast (unsigned_int_type, input);\n+\t  tree casted_input = build_resize_convert_view (unsigned_int_type,\n+\t\t\t\t\t\t\t input);\n \t  tree masked_input\n \t    = build2 (BIT_AND_EXPR, unsigned_int_type, casted_input, and_mask);\n \t  conversion_result\n@@ -172,7 +173,7 @@ brig_cvt_inst_handler::generate (const BrigBase *base)\n     }\n   else if (dest_is_fp16)\n     {\n-      tree casted_input = build_reinterpret_cast (src_type, input);\n+      tree casted_input = build_resize_convert_view (src_type, input);\n       conversion_result\n \t= convert_to_real (brig_to_generic::s_fp32_type, casted_input);\n       if (FTZ)\n@@ -181,7 +182,7 @@ brig_cvt_inst_handler::generate (const BrigBase *base)\n     }\n   else if (SCALAR_FLOAT_TYPE_P (dest_type))\n     {\n-      tree casted_input = build_reinterpret_cast (src_type, input);\n+      tree casted_input = build_resize_convert_view (src_type, input);\n       conversion_result = convert_to_real (dest_type, casted_input);\n     }\n   else if (INTEGRAL_TYPE_P (dest_type) && INTEGRAL_TYPE_P (src_type))\n@@ -214,46 +215,47 @@ brig_cvt_inst_handler::generate (const BrigBase *base)\n #include \"brig-builtins.def\"\n \t    gcc_unreachable ();\n \n-\t  tree casted_input = build_reinterpret_cast (src_type, input);\n+\t  tree casted_input = build_resize_convert_view (src_type, input);\n \t  conversion_result\n \t    = call_builtin (builtin, 1, dest_type, src_type, casted_input);\n \t}\n       else\n \t{\n-\t  tree casted_input = build_reinterpret_cast (src_type, input);\n+\t  tree casted_input = build_resize_convert_view (src_type, input);\n \n-\t  /* Perform the int to float conversion.  */\n+\t  /* Perform the float to int conversion.  */\n \t  conversion_result = convert_to_integer (dest_type, casted_input);\n \t}\n-      /* The converted result is finally extended to the target register\n-\t width, using the same sign as the destination.  */\n-      conversion_result\n-\t= convert_to_integer (TREE_TYPE (output), conversion_result);\n     }\n   else\n     {\n       /* Just use CONVERT_EXPR and hope for the best.  */\n-      tree casted_input = build_reinterpret_cast (dest_type, input);\n+      tree casted_input = build_resize_convert_view (dest_type, input);\n       conversion_result = build1 (CONVERT_EXPR, dest_type, casted_input);\n     }\n \n   size_t dst_reg_size = int_size_in_bytes (TREE_TYPE (output));\n \n-  tree assign = NULL_TREE;\n   /* The output register can be of different type&size than the\n-     conversion output size.  Cast it to the register variable type.  */\n-  if (dst_reg_size > conv_dst_size)\n-    {\n-      tree casted_output\n-\t= build1 (CONVERT_EXPR, TREE_TYPE (output), conversion_result);\n-      assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_output);\n-    }\n-  else\n+     conversion output size. Only need to handle signed integers, rest\n+     is handled by reinterpret_cast.  */\n+  tree casted_output = conversion_result;\n+  if (dst_reg_size > conv_dst_size &&\n+      INTEGRAL_TYPE_P (TREE_TYPE (casted_output)))\n     {\n-      tree casted_output\n-\t= build_reinterpret_cast (TREE_TYPE (output), conversion_result);\n-      assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_output);\n+      gcc_assert (!VECTOR_TYPE_P (casted_output));\n+\n+      bool unsignedp = TYPE_UNSIGNED (TREE_TYPE (casted_output));\n+      tree resized_int_type\n+        = build_nonstandard_integer_type (dst_reg_size * BITS_PER_UNIT,\n+\t\t\t\t\t  unsignedp);\n+      casted_output = build1 (CONVERT_EXPR, resized_int_type, casted_output);\n     }\n+\n+  casted_output\n+    = build_resize_convert_view (TREE_TYPE (output), casted_output);\n+  tree assign = build2 (MODIFY_EXPR, TREE_TYPE (output), output, casted_output);\n+\n   m_parent.m_cf->append_statement (assign);\n \n   return base->byteCount;"}, {"sha": "7f627deb7a4cd4cdbbe462fc49729abf5d578faa", "filename": "gcc/brig/brigfrontend/brig-function.cc", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -272,40 +272,67 @@ brig_function::add_local_variable (std::string name, tree type)\n   return variable;\n }\n \n+/* Return tree type for an HSA register.\n+\n+   The tree type can be anything (scalar, vector, int, float, etc.)\n+   but its size is guaranteed to match the HSA register size.\n+\n+   HSA registers are untyped but we select a type based on their use\n+   to reduce (sometimes unoptimizable) VIEW_CONVERT_EXPR nodes (seems\n+   to occur when use or def reaches over current BB).  */\n+\n+tree\n+brig_function::get_tree_type_for_hsa_reg (const BrigOperandRegister *reg) const\n+{\n+  size_t reg_size = gccbrig_reg_size (reg);\n+\n+  /* The default type.  */\n+  tree type = build_nonstandard_integer_type (reg_size, true);\n+\n+  if (m_parent->m_fn_regs_use_index.count (m_name) == 0)\n+    return type;\n+\n+  const regs_use_index &index = m_parent->m_fn_regs_use_index[m_name];\n+  size_t reg_id = gccbrig_hsa_reg_id (*reg);\n+  if (index.count (reg_id) == 0)\n+    return type;\n+\n+  const reg_use_info &info = index.find (reg_id)->second;\n+  std::vector<std::pair<tree, size_t> >::const_iterator it\n+    = info.m_type_refs.begin ();\n+  std::vector<std::pair<tree, size_t> >::const_iterator it_end\n+    = info.m_type_refs.end ();\n+  size_t max_refs_as_type_count = 0;\n+  for (; it != it_end; it++)\n+    {\n+      size_t type_bit_size = int_size_in_bytes (it->first) * BITS_PER_UNIT;\n+      if (type_bit_size != reg_size) continue;\n+      if (it->second > max_refs_as_type_count)\n+\t{\n+\t  type = it->first;\n+\t  max_refs_as_type_count = it->second;\n+\t}\n+    }\n+\n+  return type;\n+}\n+\n /* Returns a DECL_VAR for the given HSAIL operand register.\n    If it has not been created yet for the function being generated,\n-   creates it as an unsigned int variable.  */\n+   creates it as a type determined by analysis phase.  */\n \n tree\n brig_function::get_m_var_declfor_reg (const BrigOperandRegister *reg)\n {\n-  size_t offset = reg->regNum;\n-  switch (reg->regKind)\n-    {\n-    case BRIG_REGISTER_KIND_QUAD:\n-      offset\n-\t+= BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT +\n-\tBRIG_2_TREE_HSAIL_C_REG_COUNT;\n-      break;\n-    case BRIG_REGISTER_KIND_DOUBLE:\n-      offset += BRIG_2_TREE_HSAIL_S_REG_COUNT + BRIG_2_TREE_HSAIL_C_REG_COUNT;\n-      break;\n-    case BRIG_REGISTER_KIND_SINGLE:\n-      offset += BRIG_2_TREE_HSAIL_C_REG_COUNT;\n-    case BRIG_REGISTER_KIND_CONTROL:\n-      break;\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n+  size_t offset = gccbrig_hsa_reg_id (*reg);\n \n   reg_decl_index_entry *regEntry = m_regs[offset];\n   if (regEntry == NULL)\n     {\n       size_t reg_size = gccbrig_reg_size (reg);\n       tree type;\n       if (reg_size > 1)\n-\ttype = build_nonstandard_integer_type (reg_size, true);\n+\ttype = get_tree_type_for_hsa_reg (reg);\n       else\n \ttype = boolean_type_node;\n "}, {"sha": "3ed58cdc67a7fa870ee4a70a22c8afe5c161ff24", "filename": "gcc/brig/brigfrontend/brig-function.h", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -45,15 +45,6 @@ typedef std::map<std::string, tree> label_index;\n typedef std::map<const BrigDirectiveVariable *, tree> variable_index;\n typedef std::vector<tree> tree_stl_vec;\n \n-/* There are 128 c regs and 2048 s/d/q regs each in the HSAIL.  */\n-#define BRIG_2_TREE_HSAIL_C_REG_COUNT (128)\n-#define BRIG_2_TREE_HSAIL_S_REG_COUNT (2048)\n-#define BRIG_2_TREE_HSAIL_D_REG_COUNT (2048)\n-#define BRIG_2_TREE_HSAIL_Q_REG_COUNT (2048)\n-#define BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT\t\t\t\t       \\\n-  (BRIG_2_TREE_HSAIL_C_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT\t       \\\n-   + BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_Q_REG_COUNT)\n-\n /* Holds data for the currently built GENERIC function.  */\n \n class brig_function\n@@ -222,6 +213,9 @@ class brig_function\n   phsa_descriptor m_descriptor;\n \n private:\n+\n+  tree get_tree_type_for_hsa_reg (const BrigOperandRegister *reg) const;\n+\n   /* Bookkeeping for the different HSA registers and their tree declarations\n      for the currently generated function.  */\n   reg_decl_index_entry *m_regs[BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT];"}, {"sha": "fea3059edd9bd4d02ec0a3f719d30ff1d15045b8", "filename": "gcc/brig/brigfrontend/brig-mem-inst-handler.cc", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-mem-inst-handler.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -41,7 +41,11 @@ brig_mem_inst_handler::build_mem_access (const BrigInstBase *brig_inst,\n \n   tree instr_type = gccbrig_tree_type_for_hsa_type (brig_inst->type);\n \n-  if (VECTOR_TYPE_P (TREE_TYPE (data)))\n+  /* In case of {ld,st}_v{2,4}. Note: since 'register' variables may\n+     be any type, even a vector type, we distinguish the registers\n+     from operand lists by checking for constructor nodes (which\n+     operand lists are represented as).  */\n+  if (VECTOR_TYPE_P (TREE_TYPE (data)) && TREE_CODE (data) == CONSTRUCTOR)\n     instr_type = TREE_TYPE (data);\n \n   tree ptype = build_pointer_type (instr_type);\n@@ -151,14 +155,7 @@ brig_mem_inst_handler::operator () (const BrigBase *base)\n \t\t\t\t address_base, ptr_offset);\n \n \t  if (is_store && TREE_TYPE (data) != instr_type)\n-\t    {\n-\t      if (int_size_in_bytes (TREE_TYPE (data))\n-\t\t    == int_size_in_bytes (instr_type)\n-\t\t  && !INTEGRAL_TYPE_P (instr_type))\n-\t\tdata = build1 (VIEW_CONVERT_EXPR, instr_type, data);\n-\t      else\n-\t\tdata = convert (instr_type, data);\n-\t    }\n+\t    data = build_resize_convert_view (instr_type, data);\n \n \t  build_mem_access (brig_inst, address, data);\n "}, {"sha": "9077e76364e38a9bedd67f78d4a4061ecb2875d9", "filename": "gcc/brig/brigfrontend/brig-to-generic.cc", "status": "modified", "additions": 87, "deletions": 14, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -124,6 +124,24 @@ class skipped_entry_handler : public brig_code_entry_handler\n   }\n };\n \n+class brig_reg_use_analyzer : public brig_code_entry_handler\n+{\n+public:\n+  brig_reg_use_analyzer (brig_to_generic &parent)\n+    : brig_code_entry_handler (parent)\n+  {\n+  }\n+\n+  size_t\n+  operator () (const BrigBase *base)\n+  {\n+    const BrigInstBase *brig_inst = (const BrigInstBase *) base;\n+    analyze_operands (*brig_inst);\n+    return base->byteCount;\n+  }\n+\n+};\n+\n /* Helper struct for pairing a BrigKind and a BrigCodeEntryHandler that\n    should handle its data.  */\n \n@@ -210,6 +228,7 @@ brig_to_generic::analyze (const char *brig_blob)\n   brig_directive_variable_handler var_handler (*this);\n   brig_directive_fbarrier_handler fbar_handler (*this);\n   brig_directive_function_handler func_handler (*this);\n+  brig_reg_use_analyzer reg_use_analyzer (*this);\n \n   /* Need this for grabbing the module names for mangling the\n      group variable names.  */\n@@ -219,7 +238,21 @@ brig_to_generic::analyze (const char *brig_blob)\n   const BrigSectionHeader *csection_header = (const BrigSectionHeader *) m_code;\n \n   code_entry_handler_info handlers[]\n-    = {{BRIG_KIND_DIRECTIVE_VARIABLE, &var_handler},\n+    = {{BRIG_KIND_INST_BASIC, &reg_use_analyzer},\n+       {BRIG_KIND_INST_MOD, &reg_use_analyzer},\n+       {BRIG_KIND_INST_CMP, &reg_use_analyzer},\n+       {BRIG_KIND_INST_MEM, &reg_use_analyzer},\n+       {BRIG_KIND_INST_CVT, &reg_use_analyzer},\n+       {BRIG_KIND_INST_SEG_CVT, &reg_use_analyzer},\n+       {BRIG_KIND_INST_SEG, &reg_use_analyzer},\n+       {BRIG_KIND_INST_ADDR, &reg_use_analyzer},\n+       {BRIG_KIND_INST_SOURCE_TYPE, &reg_use_analyzer},\n+       {BRIG_KIND_INST_ATOMIC, &reg_use_analyzer},\n+       {BRIG_KIND_INST_SIGNAL, &reg_use_analyzer},\n+       {BRIG_KIND_INST_BR, &reg_use_analyzer},\n+       {BRIG_KIND_INST_LANE, &reg_use_analyzer},\n+       {BRIG_KIND_INST_QUEUE, &reg_use_analyzer},\n+       {BRIG_KIND_DIRECTIVE_VARIABLE, &var_handler},\n        {BRIG_KIND_DIRECTIVE_FBARRIER, &fbar_handler},\n        {BRIG_KIND_DIRECTIVE_KERNEL, &func_handler},\n        {BRIG_KIND_DIRECTIVE_MODULE, &module_handler},\n@@ -555,10 +588,14 @@ build_stmt (enum tree_code code, ...)\n    than the created reg var type in order to select correct instruction type\n    later on.  This function creates the necessary reinterpret type cast from\n    a source variable to the destination type.  In case no cast is needed to\n-   the same type, SOURCE is returned directly.  */\n+   the same type, SOURCE is returned directly.\n+\n+   In case of mismatched type sizes, casting:\n+   - to narrower type the upper bits are clipped and\n+   - to wider type the source value is zero extended.  */\n \n tree\n-build_reinterpret_cast (tree destination_type, tree source)\n+build_resize_convert_view (tree destination_type, tree source)\n {\n \n   gcc_assert (source && destination_type && TREE_TYPE (source) != NULL_TREE\n@@ -578,23 +615,30 @@ build_reinterpret_cast (tree destination_type, tree source)\n   size_t dst_size = int_size_in_bytes (destination_type);\n   if (src_size == dst_size)\n     return build1 (VIEW_CONVERT_EXPR, destination_type, source);\n-  else if (src_size < dst_size)\n+  else /* src_size != dst_size  */\n     {\n       /* The src_size can be smaller at least with f16 scalars which are\n \t stored to 32b register variables.  First convert to an equivalent\n \t size unsigned type, then extend to an unsigned type of the\n \t target width, after which VIEW_CONVERT_EXPR can be used to\n \t force to the target type.  */\n-      tree unsigned_temp = build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t   get_unsigned_int_type (source_type),\n-\t\t\t\t   source);\n-      return build1 (VIEW_CONVERT_EXPR, destination_type,\n-\t\t     convert (get_unsigned_int_type (destination_type),\n-\t\t\t      unsigned_temp));\n+      tree resized = convert (get_scalar_unsigned_int_type (destination_type),\n+\t\t\t      build_reinterpret_to_uint (source));\n+      gcc_assert ((size_t)int_size_in_bytes (TREE_TYPE (resized)) == dst_size);\n+      return build_resize_convert_view (destination_type, resized);\n     }\n-  else\n-    gcc_unreachable ();\n-  return NULL_TREE;\n+}\n+\n+/* Reinterprets SOURCE as a scalar unsigned int with the size\n+   corresponding to the orignal.  */\n+\n+tree build_reinterpret_to_uint (tree source)\n+{\n+  tree src_type = TREE_TYPE (source);\n+  if (INTEGRAL_TYPE_P (src_type) && TYPE_UNSIGNED (src_type))\n+    return source;\n+  tree dest_type = get_scalar_unsigned_int_type (src_type);\n+  return build1 (VIEW_CONVERT_EXPR, dest_type, source);\n }\n \n /* Returns the finished brig_function for the given generic FUNC_DECL,\n@@ -775,7 +819,7 @@ call_builtin (tree pdecl, int nargs, tree rettype, ...)\n     {\n       types[i] = va_arg (ap, tree);\n       tree arg = va_arg (ap, tree);\n-      args[i] = build_reinterpret_cast (types[i], arg);\n+      args[i] = build_resize_convert_view (types[i], arg);\n       if (types[i] == error_mark_node || args[i] == error_mark_node)\n \t{\n \t  delete[] types;\n@@ -879,6 +923,16 @@ get_unsigned_int_type (tree original_type)\n \t\t\t\t\t   true);\n }\n \n+/* Returns a type with unsigned int corresponding to the size\n+   ORIGINAL_TYPE.  */\n+\n+tree\n+get_scalar_unsigned_int_type (tree original_type)\n+{\n+  return build_nonstandard_integer_type (int_size_in_bytes (original_type)\n+\t\t\t\t\t * BITS_PER_UNIT, true);\n+}\n+\n void\n dump_function (FILE *dump_file, brig_function *f)\n {\n@@ -893,3 +947,22 @@ dump_function (FILE *dump_file, brig_function *f)\n       fprintf (dump_file, \"\\n\");\n     }\n }\n+\n+/* Records use of the BRIG_REG as a TYPE in the current function.  */\n+\n+void\n+brig_to_generic::add_reg_used_as_type (const BrigOperandRegister &brig_reg,\n+\t\t\t\t       tree type)\n+{\n+  gcc_assert (m_cf);\n+  reg_use_info &info\n+    = m_fn_regs_use_index[m_cf->m_name][gccbrig_hsa_reg_id (brig_reg)];\n+\n+  if (info.m_type_refs_lookup.count (type))\n+    info.m_type_refs[info.m_type_refs_lookup[type]].second++;\n+  else\n+    {\n+      info.m_type_refs.push_back (std::make_pair (type, 1));\n+      info.m_type_refs_lookup[type] = info.m_type_refs.size () - 1;\n+    }\n+}"}, {"sha": "59eb5b49188460fa9435a8e6a7f339eaa990dbf5", "filename": "gcc/brig/brigfrontend/brig-to-generic.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -106,6 +106,9 @@ class brig_to_generic\n   void add_group_variable (const std::string &name, size_t size,\n \t\t\t   size_t alignment, bool function_scope);\n \n+  void add_reg_used_as_type (const BrigOperandRegister &brig_reg,\n+\t\t\t     tree operand_type);\n+\n   static tree s_fp16_type;\n   static tree s_fp32_type;\n   static tree s_fp64_type;\n@@ -129,6 +132,9 @@ class brig_to_generic\n   /* Accumulates the total group segment usage.  */\n   size_t m_total_group_segment_usage;\n \n+  /* Statistics about register uses per function.  */\n+  std::map<std::string, regs_use_index> m_fn_regs_use_index;\n+\n private:\n \n   void find_brig_sections ();\n@@ -212,12 +218,15 @@ class brig_entry_handler\n \n tree call_builtin (tree pdecl, int nargs, tree rettype, ...);\n \n-tree build_reinterpret_cast (tree destination_type, tree source);\n+tree build_resize_convert_view (tree destination_type, tree source);\n+tree build_reinterpret_to_uint (tree source);\n \n tree build_stmt (enum tree_code code, ...);\n \n tree get_unsigned_int_type (tree type);\n \n+tree get_scalar_unsigned_int_type (tree type);\n+\n void dump_function (FILE *dump_file, brig_function *f);\n \n #endif"}, {"sha": "ca93247e7ff3138f4f17a6c69cb11d86bebb2bcb", "filename": "gcc/brig/brigfrontend/brig-util.cc", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"brig-util.h\"\n #include \"errors.h\"\n #include \"diagnostic-core.h\"\n+#include \"print-tree.h\"\n \n bool\n group_variable_offset_index::has_variable (const std::string &name) const\n@@ -473,3 +474,91 @@ gccbrig_tree_type_for_hsa_type (BrigType16_t brig_type)\n   /* Drop const qualifiers.  */\n   return tree_type;\n }\n+\n+/* Calculates numeric identifier for the HSA register REG.\n+\n+   Returned value is bound to [0, BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT].  */\n+\n+size_t\n+gccbrig_hsa_reg_id (const BrigOperandRegister &reg)\n+{\n+  size_t offset = reg.regNum;\n+  switch (reg.regKind)\n+    {\n+    case BRIG_REGISTER_KIND_QUAD:\n+      offset\n+\t+= BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT\n+\t+ BRIG_2_TREE_HSAIL_C_REG_COUNT;\n+      break;\n+    case BRIG_REGISTER_KIND_DOUBLE:\n+      offset += BRIG_2_TREE_HSAIL_S_REG_COUNT + BRIG_2_TREE_HSAIL_C_REG_COUNT;\n+      break;\n+    case BRIG_REGISTER_KIND_SINGLE:\n+      offset += BRIG_2_TREE_HSAIL_C_REG_COUNT;\n+    case BRIG_REGISTER_KIND_CONTROL:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+  return offset;\n+}\n+\n+std::string\n+gccbrig_hsa_reg_name_from_id (size_t reg_hash)\n+{\n+  char reg_name[32];\n+  if (reg_hash < BRIG_2_TREE_HSAIL_C_REG_COUNT)\n+    {\n+      sprintf (reg_name, \"$c%lu\", reg_hash);\n+      return reg_name;\n+    }\n+\n+  reg_hash -= BRIG_2_TREE_HSAIL_C_REG_COUNT;\n+  if (reg_hash < BRIG_2_TREE_HSAIL_S_REG_COUNT)\n+    {\n+      sprintf (reg_name, \"$s%lu\", reg_hash);\n+      return reg_name;\n+    }\n+\n+  reg_hash -= BRIG_2_TREE_HSAIL_S_REG_COUNT;\n+  if (reg_hash < BRIG_2_TREE_HSAIL_D_REG_COUNT)\n+    {\n+      sprintf (reg_name, \"$d%lu\", reg_hash);\n+      return reg_name;\n+    }\n+\n+   reg_hash -= BRIG_2_TREE_HSAIL_D_REG_COUNT;\n+   if (reg_hash < BRIG_2_TREE_HSAIL_Q_REG_COUNT)\n+    {\n+      sprintf (reg_name, \"$q%lu\", reg_hash);\n+      return reg_name;\n+    }\n+\n+  gcc_unreachable ();\n+  return \"$??\";\n+}\n+\n+/* Prints statistics of register usage to stdout.  */\n+\n+void\n+gccbrig_print_reg_use_info (FILE *dump, const regs_use_index &info)\n+{\n+  regs_use_index::const_iterator begin_it = info.begin ();\n+  regs_use_index::const_iterator end_it = info.end ();\n+  for (regs_use_index::const_iterator it = begin_it; it != end_it; it++)\n+    {\n+      std::string hsa_reg = gccbrig_hsa_reg_name_from_id (it->first);\n+      printf (\"%s:\\n\", hsa_reg.c_str ());\n+      const reg_use_info &info = it->second;\n+      typedef std::vector<std::pair<tree, size_t> >::const_iterator reg_use_it;\n+      reg_use_it begin_it2 = info.m_type_refs.begin ();\n+      reg_use_it end_it2 = info.m_type_refs.end ();\n+      for (reg_use_it it2 = begin_it2; it2 != end_it2; it2++)\n+\t{\n+\t  fprintf (dump, \"(%lu) \", it2->second);\n+\t  print_node_brief (dump, \"\", it2->first, 0);\n+\t  fprintf (dump, \"\\n\");\n+\t}\n+    }\n+}"}, {"sha": "d47470f0c4032a2a4d3c9bbecf4134128605d1f5", "filename": "gcc/brig/brigfrontend/brig-util.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_BRIG_UTIL_H\n \n #include <map>\n+#include <vector>\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -31,6 +32,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"opts.h\"\n #include \"tree.h\"\n \n+/* There are 128 c regs and 2048 s/d/q regs each in the HSAIL.  */\n+#define BRIG_2_TREE_HSAIL_C_REG_COUNT (128)\n+#define BRIG_2_TREE_HSAIL_S_REG_COUNT (2048)\n+#define BRIG_2_TREE_HSAIL_D_REG_COUNT (2048)\n+#define BRIG_2_TREE_HSAIL_Q_REG_COUNT (2048)\n+#define BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT\t\t\t\t\\\n+  (BRIG_2_TREE_HSAIL_C_REG_COUNT + BRIG_2_TREE_HSAIL_S_REG_COUNT\t\\\n+   + BRIG_2_TREE_HSAIL_D_REG_COUNT + BRIG_2_TREE_HSAIL_Q_REG_COUNT)\n+\n /* Helper class for keeping book of group variable offsets.  */\n \n class group_variable_offset_index\n@@ -76,4 +86,25 @@ bool gccbrig_might_be_host_defined_var_p (const BrigDirectiveVariable *brigVar);\n /* From hsa.h.  */\n bool hsa_type_packed_p (BrigType16_t type);\n \n+struct reg_use_info\n+{\n+  /* This vector keeps count of the times an HSAIL register is used as\n+     a tree type in generic expressions.  The count is used to select\n+     type for 'register' variables to reduce emission of\n+     VIEW_CONVERT_EXPR nodes.  The data is kept in vector (insertion\n+     order) for determinism, in a case there is a tie with the\n+     counts.  */\n+  std::vector<std::pair<tree, size_t> > m_type_refs;\n+  /* Tree to index.  Lookup for the above vector.  */\n+  std::map<tree, size_t> m_type_refs_lookup;\n+};\n+\n+/* key = hsa register entry generated by gccbrig_hsa_reg_id ().  */\n+typedef std::map<size_t, reg_use_info> regs_use_index;\n+\n+size_t gccbrig_hsa_reg_id (const BrigOperandRegister &reg);\n+std::string gccbrig_hsa_reg_name_from_id (size_t reg_hash);\n+\n+void gccbrig_print_reg_use_info (FILE *dump, const regs_use_index &info);\n+\n #endif"}, {"sha": "4b2bb8b225738f39042ebb1ade21f51ab4aba385", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -1,3 +1,10 @@\n+2017-11-16  Henry Linjam\u00e4ki  <henry.linjamaki@parmance.com>\n+\n+\t* brig.dg/test/gimple/vector.hsail: Update for HSA registers' tree\n+\trepresentation changes in brig1.\n+\t* brig.dg/test/gimple/packed.hsail: Likewise.\n+\t* brig.dg/test/gimple/internal-reg-var-casts.hsail: New.\n+\n 2017-11-16  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/ipa/ipcp-2.c: Lower threshold."}, {"sha": "52673c9e65a0c51bc5f6ff73cbc36243d5dc7c5d", "filename": "gcc/testsuite/brig.dg/test/gimple/internal-casts.hsail", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Finternal-casts.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Finternal-casts.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Finternal-casts.hsail?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -0,0 +1,146 @@\n+module &module:1:0:$full:$large:$default;\n+\n+/* Test for casting from/to representation of HSA registers.          */\n+\n+/* HSA registers are untyped but in gccbrig they are presented as     */\n+/* variables with a type selected by analysis.  Currently, each       */\n+/* register variable, per function, has a type as it is used at       */\n+/* most.  Therefore, register variable can be nearly any type.  The   */\n+/* tests makes sure the generic/tree expressions have the right casts */\n+/* from/to the register variables.                                    */\n+\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-original\" } */\n+\n+prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n+{\n+        private_u64 %foo;\n+        private_u64 %bar;\n+        private_b128 %baz;\n+\n+        ld_kernarg_u64 $d0, [%input_ptr];\n+        ld_global_u32 $s0, [$d0];\n+\n+        /* Trick gccbrig to set wanted type for the registers.  */\n+\n+/* $s0 is selected as float... */\n+/* { dg-final { scan-tree-dump \"<float:32> s0;\" \"original\"} } */\n+/* ..., therefore, there should not be any casts.  */\n+/* { dg-final { scan-tree-dump \"s10 = s0 \\\\\\+ s0;\" \"original\"} } */\n+\n+        add_f32 $s10, $s0, $s0;\n+        add_f32 $s10, $s0, $s0;\n+        add_f32 $s10, $s0, $s0;\n+        add_f32 $s10, $s0, $s0;\n+        add_f32 $s10, $s0, $s0;\n+\n+/* Expression with other type, a cast is needed.  */\n+/* { dg-final { scan-tree-dump \"s1 = VIEW_CONVERT_EXPR<unsigned int>.s0. \\\\\\+ 123;\" \"original\"} } */\n+\n+        add_u32 $s1, $s0, 123;\n+\n+/* { dg-final { scan-tree-dump \"unsigned int s1;\" \"original\"} } */\n+\n+        add_u32 $s10, $s1, 0;\n+        add_u32 $s10, $s1, 0;\n+        add_u32 $s10, $s1, 0;\n+        add_u32 $s10, $s1, 0;\n+        add_u32 $s10, $s1, 0;\n+\n+/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<<float:32>>.s1.;\" \"original\"} } */\n+\n+        mov_b32 $s0, $s1;\n+\n+/* Rig the election for $d0 to be double.  */\n+/* { dg-final { scan-tree-dump \"<float:64> d0;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"d10 = d0 \\\\\\+ d0;\" \"original\"} } */\n+\n+        add_f64 $d10, $d0, $d0;\n+        add_f64 $d10, $d0, $d0;\n+        add_f64 $d10, $d0, $d0;\n+        add_f64 $d10, $d0, $d0;\n+        add_f64 $d10, $d0, $d0;\n+\n+/* Make $s2 to be vector type.  */\n+/* { dg-final { scan-tree-dump \"vector.4. unsigned char s2;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(s1\\\\\\) \\\\\\+ VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(s1\\\\\\);\" \"original\"} } */\n+\n+        add_pp_u8x4 $s2, $s1, $s1;\n+\n+/* { dg-final { scan-tree-dump \"s20 = s2 \\\\\\+ s2;\" \"original\"} } */\n+\n+        add_pp_u8x4 $s20, $s2, $s2;\n+        add_pp_u8x4 $s20, $s2, $s2;\n+        add_pp_u8x4 $s20, $s2, $s2;\n+        add_pp_u8x4 $s20, $s2, $s2;\n+\n+/* { dg-final { scan-tree-dump \"d0 = VIEW_CONVERT_EXPR<<float:64>>.{VIEW_CONVERT_EXPR<unsigned int>.s0., VIEW_CONVERT_EXPR<unsigned int>.s2.}.;\" \"original\"} } */\n+\n+        combine_v2_b64_b32 $d0, ($s0, $s2);\n+\n+/* { dg-final { scan-tree-dump \"s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>.BIT_FIELD_REF <d0, 32, 0>.;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"s1 = BIT_FIELD_REF <d0, 32, 32>;\" \"original\"} } */\n+\n+        expand_v2_b32_b64 ($s2, $s1), $d0;\n+\n+/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(.*VIEW_CONVERT_EXPR<unsigned int>.s0\\[\\)\\]*;\" \"original\"} } */\n+\n+        cvt_s16_s8 $s0, $s0;\n+\n+/* { dg-final { scan-tree-dump \"c0 = .*VIEW_CONVERT_EXPR<<float:32>>.s2..* != 0;\" \"original\"} } */\n+\n+        cvt_b1_f32 $c0, $s2;\n+\n+/* { dg-final { scan-tree-dump \".*__private_base_addr.* = .*\\\\\\(unsigned char\\\\\\) VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s0\\\\\\)\\[\\)\\]*;\" \"original\"} } */\n+\n+        st_private_u8 $s0, [%foo];\n+\n+/* { dg-final { scan-tree-dump \".*__private_base_addr.* = .*\\\\\\(unsigned short\\\\\\) VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s2\\\\\\)\\[\\)\\]*;\" \"original\"} } */\n+\n+        st_private_u16 $s2, [%bar];\n+\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed char \\\\\\*\\\\\\) \\\\\\(__private_base_addr .*\\\\\\);\\[ \\n\\]*s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n+\n+        ld_private_s8 $s2, [%foo];\n+\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr .*\\\\\\);\\[ \\n\\]*s0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n+\n+        ld_private_s16 $s0, [%bar];\n+\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 0 = s0;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 4 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s1\\\\\\);\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"\\\\\\*\\\\\\(<float:32> \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 8 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(s2\\\\\\);\" \"original\"} } */\n+\n+        st_v3_private_f32 ($s0, $s1, $s2), [%baz];\n+\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 0;\\[ \\n\\]*s0 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 2;\\[ \\n\\]*s1 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\]* = \\\\\\*\\\\\\(signed short \\\\\\*\\\\\\) \\\\\\(__private_base_addr.*\\\\\\) \\\\\\+ 4;\\[ \\n\\]*s2 = VIEW_CONVERT_EXPR<vector.4. unsigned char>\\\\\\(\\\\\\(signed int\\\\\\) mem_read.\\[0-9\\]*\\\\\\);\" \"original\"} } */\n+\n+        ld_v3_private_s16 ($s0, $s1, $s2), [%baz];\n+\n+/* { dg-final { scan-tree-dump \"s5 = .*VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s0\\\\\\) == VIEW_CONVERT_EXPR<unsigned int>\\\\\\(s2\\\\\\)\\\\\\) .*;\" \"original\"} } */\n+\n+        cmp_eq_s32_u32 $s5, $s0, $s2;\n+\n+/* { dg-final { scan-tree-dump \"s6 = VIEW_CONVERT_EXPR<<float:32>>\\\\\\(.*VIEW_CONVERT_EXPR<vector\\\\\\(2\\\\\\) unsigned short>\\\\\\(s0\\\\\\).*VIEW_CONVERT_EXPR<vector\\\\\\(2\\\\\\) unsigned short>\\\\\\(s2\\\\\\).*;\" \"original\"} } */\n+\n+        cmp_eq_pp_u16x2_u16x2 $s6, $s0, $s2;\n+\n+/* { dg-final { scan-tree-dump \"<float:32> s60;\" \"original\"} } */\n+\n+        add_f32 $s60, $s6, $s6;\n+        add_f32 $s60, $s6, $s6;\n+        add_f32 $s60, $s6, $s6;\n+        add_f32 $s60, $s6, $s6;\n+\n+        ld_kernarg_u64 $d0, [%output_ptr];\n+        st_global_u32 $s0, [$d0];\n+\n+        ret;\n+};\n+\n+\n+\n+"}, {"sha": "4cba5fcbba0ec4ae180f1b5c0fac9b8c0aeaac18", "filename": "gcc/testsuite/brig.dg/test/gimple/packed.hsail", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fpacked.hsail?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -42,7 +42,7 @@ prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n         ret;\n };\n \n-/* The b128 load is done using uint128_t*.\n+/* The b128 load is done using uint128_t*. */\n /* { dg-final { scan-tree-dump \"q0 = VIEW_CONVERT_EXPR<uint128_t>\\\\\\(mem_read.\\[0-9\\]+\\\\\\);\" \"original\"} } */\n \n /* Before arithmetics, the uint128_t is casted to a vector datatype. */\n@@ -52,27 +52,25 @@ prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n /* in comparison to the HSAIL syntax. */\n /* { dg-final { scan-tree-dump \"\\\\\\+ { 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }\" \"original\"} } */\n \n-/* After arithmetics, the vector DT is casted back to a uint128_t. */\n-/* { dg-final { scan-tree-dump \"q1 = VIEW_CONVERT_EXPR<uint128_t>\" \"original\"} } */\n-\n /* Broadcasted the constant vector's lowest element and summed it up in the next line. */\n-/* { dg-final { scan-tree-dump \"= { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };\\[\\n \\]+_\\[0-9\\]+ = _\\[0-9\\]+ \\\\\\+ _\\[0-9\\]+;\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"= { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };\\[\\n \\]+\\[a-z0-9_\\]+ = \\[a-z0-9_\\]+ \\\\\\+ \\[a-z0-9_\\]+;\" \"gimple\"} } */\n \n /* Broadcasted the registers lowest element via a VEC_PERM_EXPR that has an all-zeros mask. */\n-/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR <_\\[0-9\\]+, _\\[0-9\\]+, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }>;\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"VEC_PERM_EXPR <\\[a-z0-9_\\]+, \\[a-z0-9_\\]+, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }>;\" \"gimple\" } } */\n \n /* For the add_ss we assume performing the computation over the whole vector is cheaper than */\n /* extracting the scalar and performing a scalar operation. This aims to stay in the vector\n /* datapath as long as possible. */\n-/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = VIEW_CONVERT_EXPR<vector\\\\\\(16\\\\\\) unsigned char>\\\\\\(q2\\\\\\);\\[\\n \\]+_\\[0-9\\]+ = VIEW_CONVERT_EXPR<vector\\\\\\(16\\\\\\) unsigned char>\\\\\\(q3\\\\\\);\\[\\n \\]+_\\[0-9\\]+ = _\\[0-9\\]+ \\\\\\+ _\\[0-9\\]+;\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = q2 \\\\\\+ q3;\" \"gimple\" } } */\n \n /* Insert the lowest element of the result to the lowest element of the result register. */\n-/* { dg-final { scan-tree-dump \"= VEC_PERM_EXPR <_\\[0-9\\]+, new_output.\\[0-9\\]+_\\[0-9\\]+, { 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }>;\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"= VEC_PERM_EXPR <\\[a-z0-9_\\]+, new_output.\\[0-9\\]+_\\[0-9\\]+, { 16, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }>;\" \"gimple\" } } */\n \n-/* { dg-final { scan-tree-dump \"q4 = VIEW_CONVERT_EXPR<uint128_t>\\\\\\(s_output.\\[0-9\\]+_\\[0-9\\]+\\\\\\);\" \"gimple\" } } */\n+/* FIXME */\n+/* { dg-final { scan-tree-dump \"q4 = \\(VIEW_CONVERT_EXPR<uint128_t>\\\\\\()?s_output.\\[0-9\\]+\\(_\\[0-9\\]+\\)*\\\\\\)?;\" \"gimple\" } } */\n \n /* The saturating arithmetics are (curently) implemented using scalar builtin calls. */\n /* { dg-final { scan-tree-dump-times \"= __builtin___hsail_sat_add_u8\" 64 \"gimple\" } } */\n \n /* A single operand vector instr (neg.) */\n-/* { dg-final { scan-tree-dump \" = VIEW_CONVERT_EXPR<vector\\\\\\(8\\\\\\) signed short>\\\\\\(q8\\\\\\);\\[\\n \\]+_\\[0-9\\]+ = -_\\[0-9\\]+;\\[\\n \\]+\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"= VIEW_CONVERT_EXPR<vector\\\\\\(8\\\\\\) signed short>\\\\\\(\\(s_output.\\[0-9\\]+_\\[0-9\\]+|q8\\)\\\\\\);\\[\\n \\]+q9 = -_\\[0-9\\]+;\\[\\n \\]+\" \"gimple\" } } */"}, {"sha": "752933395429f22e0fe225a618dee8f5d622b5fd", "filename": "gcc/testsuite/brig.dg/test/gimple/vector.hsail", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvector.hsail?ref=dc03239c2d8607a0f5cdb13a220bcf0c7f8ed7cd", "patch": "@@ -32,18 +32,18 @@ prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n /* { dg-final { scan-tree-dump \" = MEM\\\\\\[\\\\\\(vector\\\\\\(2\\\\\\) <float:32> \\\\\\*\\\\\\)\" \"original\"} } */\n \n /* The v3 load is scalarized (at the moment) due to gcc requiring 2's exponent wide vectors. */\n-/* { dg-final { scan-tree-dump \"s0 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 0>\\\\\\);\\[\\n ]+s1 = VIEW_CONVERT_EXPR<unsigned int>\\\\\\(BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 32>\\\\\\);\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"s0 = .*BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 0>\\\\\\)?;\\[\\n ]+s1 = .*BIT_FIELD_REF <mem_read.\\[0-9\\]+, 32, 32>\\\\\\)?;\" \"original\"} } */\n \n /* The v4 load is done via casting to a vector datatype ptr. */\n /* { dg-final { scan-tree-dump \" = MEM\\\\\\[\\\\\\(vector\\\\\\(4\\\\\\) <float:32> \\\\\\*\\\\\\)\" \"original\"} } */\n \n /* The combines are generated to vector constructors. */\n-/* { dg-final { scan-tree-dump \"{s1, s0}\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"{s2, s3}\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"{.*s1\\\\\\)?, .*s0\\\\\\)?}\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"{.*s2\\\\\\)?, .*s3\\\\\\)?}\" \"original\"} } */\n \n /* Expands to BIT_FIELD_REFs. */\n-/* { dg-final { scan-tree-dump \"s0 = BIT_FIELD_REF <d4, 32, 0>;\" \"original\"} } */\n-/* { dg-final { scan-tree-dump \"s3 = BIT_FIELD_REF <d4, 32, 32>;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"s0 = \\(VIEW_CONVERT_EXPR.*\\\\\\(\\)?BIT_FIELD_REF <d4, 32, 0>\\\\\\)?;\" \"original\"} } */\n+/* { dg-final { scan-tree-dump \"s3 = \\(VIEW_CONVERT_EXPR.*\\\\\\(\\)?BIT_FIELD_REF <d4, 32, 32>\\\\\\)?;\" \"original\"} } */\n \n /* The v1 store is done via casting to a vector datatype ptr and constructing a vector from the inputs. */\n /* { dg-final { scan-tree-dump \"MEM\\\\\\[\\\\\\(vector\\\\\\(2\\\\\\) <float:32> \\\\\\*\\\\\\)\\\\\\(<float:32> \\\\\\*\\\\\\) d1\\\\\\] = \" \"original\"} } */"}]}