{"sha": "c83c42d9a87921d377f82e8588e6d86d61162247", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgzYzQyZDlhODc5MjFkMzc3ZjgyZTg1ODhlNmQ4NmQ2MTE2MjI0Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-09T17:28:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-09-09T17:28:38Z"}, "message": "Initial revision\n\nFrom-SVN: r8049", "tree": {"sha": "1d5343d1c1296359e9030b49efd686f6b16bf079", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5343d1c1296359e9030b49efd686f6b16bf079"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c83c42d9a87921d377f82e8588e6d86d61162247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83c42d9a87921d377f82e8588e6d86d61162247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c83c42d9a87921d377f82e8588e6d86d61162247", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83c42d9a87921d377f82e8588e6d86d61162247/comments", "author": null, "committer": null, "parents": [{"sha": "6ecbf3001a087e0b12b4361260a6949d77361316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ecbf3001a087e0b12b4361260a6949d77361316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ecbf3001a087e0b12b4361260a6949d77361316"}], "stats": {"total": 2226, "additions": 2226, "deletions": 0}, "files": [{"sha": "08e86537e1e50710776cf3a9904a17cfde86f4d3", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "added", "additions": 2226, "deletions": 0, "changes": 2226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c83c42d9a87921d377f82e8588e6d86d61162247/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c83c42d9a87921d377f82e8588e6d86d61162247/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=c83c42d9a87921d377f82e8588e6d86d61162247", "patch": "@@ -0,0 +1,2226 @@\n+/* Subroutines for assembler code output on the DSP1610.\n+   Copyright (C) 1994 Free Software Foundation, Inc.\n+   Contributed by Michael Collison (collison@world.std.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Some output-actions in dsp1600.md need these.  */\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+\n+char *text_seg_name;\n+char *rsect_text;\n+char *data_seg_name;\n+char *rsect_data;\n+char *bss_seg_name;\n+char *rsect_bss;\n+char *const_seg_name;\n+char *rsect_const;\n+\n+char *chip_name;\n+char *save_chip_name;\n+\n+/* Save the operands of a compare. The 16xx has not lt or gt, so\n+   in these cases we swap the operands and reverse the condition */\n+\n+rtx dsp16xx_compare_op0;\n+rtx dsp16xx_compare_op1;\n+struct rtx_def *(*dsp16xx_compare_gen)();\n+\n+static char *fp;\n+static char *sp;\n+static char *rr;\n+static char *a1h;\n+\n+struct dsp16xx_frame_info current_frame_info;\n+struct dsp16xx_frame_info zero_frame_info;\n+\n+rtx dsp16xx_addhf3_libcall = (rtx) 0;\n+rtx dsp16xx_subhf3_libcall = (rtx) 0;\n+rtx dsp16xx_mulhf3_libcall = (rtx) 0;\n+rtx dsp16xx_divhf3_libcall = (rtx) 0;\n+rtx dsp16xx_cmphf3_libcall = (rtx) 0;\n+rtx dsp16xx_fixhfhi2_libcall = (rtx) 0;\n+rtx dsp16xx_floathihf2_libcall = (rtx) 0;\n+rtx dsp16xx_neghf2_libcall = (rtx) 0;\n+\n+rtx dsp16xx_mulhi3_libcall = (rtx) 0;\n+rtx dsp16xx_udivqi3_libcall = (rtx) 0;\n+rtx dsp16xx_udivhi3_libcall = (rtx) 0;\n+rtx dsp16xx_divqi3_libcall = (rtx) 0;\n+rtx dsp16xx_divhi3_libcall = (rtx) 0;\n+rtx dsp16xx_modqi3_libcall = (rtx) 0;\n+rtx dsp16xx_modhi3_libcall = (rtx) 0;\n+rtx dsp16xx_umodqi3_libcall = (rtx) 0;\n+rtx dsp16xx_umodhi3_libcall = (rtx) 0;\n+rtx dsp16xx_ashrhi3_libcall = (rtx) 0;\n+rtx dsp16xx_ashlhi3_libcall = (rtx) 0;\n+rtx dsp16xx_ucmphi2_libcall = (rtx) 0;\n+rtx dsp16xx_lshrhi3_libcall = (rtx) 0;\n+\n+char *himode_reg_name[] = HIMODE_REGISTER_NAMES;\n+\n+#define SHIFT_INDEX_1   0\n+#define SHIFT_INDEX_4   1\n+#define SHIFT_INDEX_8   2\n+#define SHIFT_INDEX_16  3\n+\n+static char *ashift_right_asm[] = \n+{\n+  \"%0=%0>>1\",\n+  \"%0=%0>>4\",\n+  \"%0=%0>>8\",\n+  \"%0=%0>>16\"\n+};\n+\n+static char *ashift_right_asm_first[] = \n+{\n+  \"%0=%1>>1\",\n+  \"%0=%1>>4\",\n+  \"%0=%1>>8\",\n+  \"%0=%1>>16\"\n+};\n+\n+static char *ashift_left_asm[] = \n+{\n+  \"%0=%0<<1\",\n+  \"%0=%0<<4\",\n+  \"%0=%0<<8\",\n+  \"%0=%0<<16\"\n+};\n+\n+static char *ashift_left_asm_first[] = \n+{\n+  \"%0=%1<<1\",\n+  \"%0=%1<<4\",\n+  \"%0=%1<<8\",\n+  \"%0=%1<<16\"\n+};\n+\n+static char *lshift_right_asm[] = \n+{\n+  \"%0=%0>>1\\n\\t%0=%b0&0x7fff\",\n+  \"%0=%0>>4\\n\\t%0=%b0&0x0fff\",\n+  \"%0=%0>>8\\n\\t%0=%b0&0x00ff\",\n+  \"%0=%0>>16\\n\\t%0=%b0&0x0000\"\n+};\n+\n+static char *lshift_right_asm_first[] = \n+{\n+  \"%0=%1>>1\\n\\t%0=%b0&0x7fff\",\n+  \"%0=%1>>4\\n\\t%0=%b0&0x0fff\",\n+  \"%0=%1>>8\\n\\t%0=%b0&0x00ff\",\n+  \"%0=%1>>16\\n\\t%0=%b0&0x0000\"\n+};\n+\n+int \n+hard_regno_mode_ok (regno, mode)\n+int regno;\n+enum machine_mode mode;\n+{\n+  switch ((int) mode)\n+    {\n+    case VOIDmode:\n+      return 1;\n+      \n+      /* \n+\tWe can't use the c0-c2 for QImode, since they are only\n+\t8 bits in length */\n+\n+    case QImode:\n+      if (regno != REG_C0 && regno != REG_C1 && regno != REG_C2)\n+\treturn 1;\n+      else\n+\treturn 0;\n+      \n+      /* We only allow a0, a1, y, and p to be allocated for 32-bit modes.\n+         Additionally we allow the virtual ybase registers to be used for 32-bit\n+\t modes. */\n+      \n+    case HFmode:\n+    case SFmode:\n+    case DFmode:\n+    case XFmode:\n+    case HImode:\n+    case SImode:\n+    case DImode:\n+      if (regno == REG_A0 || regno == REG_A1 || regno == REG_Y || regno == REG_PROD\n+\t  || (IS_YBASE_REGISTER_WINDOW(regno) && ((regno & 1) == 0)))\n+\treturn 1;\n+      else\n+\treturn 0;\n+      \n+    default:\n+      return 0;\n+    }\n+}\n+\n+enum reg_class\n+dsp16xx_reg_class_from_letter (c)\n+int c;\n+{\n+  switch (c)\n+    {\n+    case 'A':\n+      return ACCUM_REGS;\n+      \n+    case 'h':\n+      return ACCUM_HIGH_REGS;\n+      \n+    case 'j':\n+      return A0H_REG;\n+      \n+    case 'k':\n+      return A0L_REG;\n+      \n+    case 'q':\n+      return A1H_REG;\n+      \n+    case 'u':\n+      return A1L_REG;\n+      \n+    case 'x':\n+      return X_REG;\n+\n+    case 'y':\n+      return YH_REG;\n+\n+    case 'z':\n+      return YL_REG;\n+\n+    case 't':\n+      return P_REG;\n+\n+    case 'Z':\n+      return Y_OR_P_REGS;\n+\n+    case 'd':\n+      return ACCUM_Y_OR_P_REGS;\n+\n+    case 'C':\n+      return NO_FRAME_Y_ADDR_REGS;\n+\n+    case 'a':\n+      return Y_ADDR_REGS;\n+\n+    case 'B':\n+      return (TARGET_BMU ? BMU_REGS : NO_REGS);\n+\n+    case 'Y':\n+      return YBASE_VIRT_REGS;\n+\n+    case 'v':\n+      return PH_REG;\n+\n+    case 'w':\n+      return PL_REG;\n+\n+    case 'W':\n+      return J_REG;\n+\n+    case 'e':\n+      return YBASE_ELIGIBLE_REGS;\n+\n+    case 'b':\n+      return ACCUM_LOW_REGS;\n+\n+    case 'c':\n+      return NON_YBASE_REGS;\n+\n+    case 'f':\n+      return Y_REG;\n+\n+    case 'D':\n+      return SLOW_MEM_LOAD_REGS;\n+\n+    default:\n+      fatal (\"Illegal register class letter %c\", c);\n+      return NO_REGS;\n+    }\n+}\n+/* Return the class number of the smallest class containing\n+   reg number REGNO. */\n+\n+int \n+regno_reg_class(regno)\n+int regno;\n+{\n+  switch (regno)\n+    {\n+    case REG_A0L:\n+      return (int) A0L_REG;\n+    case REG_A1L:\n+      return (int) A1L_REG;\n+      \n+    case REG_A0:\n+      return (int) A0H_REG;\n+    case REG_A1:\n+      return (int) A1H_REG;\n+      \n+    case REG_X:\n+      return (int) X_REG;\n+      \n+    case REG_Y:\n+      return (int) YH_REG;\n+    case REG_YL:\n+      return (int) YL_REG;\n+      \n+    case REG_PROD:\n+      return (int) PH_REG;\n+    case REG_PRODL:\n+      return (int) PL_REG;\n+      \n+    case REG_R0: case REG_R1: case REG_R2: case REG_R3:\n+      return (int) Y_ADDR_REGS;\n+      \n+    case REG_J:\n+      return (int) J_REG;\n+    case REG_K:\n+      return (int) GENERAL_REGS;\n+      \n+    case REG_YBASE:\n+      return (int) GENERAL_REGS;\n+      \n+    case REG_PT:\n+      return (int) GENERAL_REGS;\n+      \n+    case REG_AR0: case REG_AR1: case REG_AR2: case REG_AR3:\n+      return (int) BMU_REGS;\n+      \n+    case REG_C0: case REG_C1: case REG_C2:\n+      return (int) GENERAL_REGS;\n+      \n+    case REG_PR:\n+      return (int) GENERAL_REGS;\n+      \n+    case REG_RB:\n+      return (int) GENERAL_REGS;\n+      \n+    case REG_YBASE0: case REG_YBASE1: case REG_YBASE2: case REG_YBASE3:\n+    case REG_YBASE4: case REG_YBASE5: case REG_YBASE6: case REG_YBASE7:\n+    case REG_YBASE8: case REG_YBASE9: case REG_YBASE10: case REG_YBASE11:\n+    case REG_YBASE12: case REG_YBASE13: case REG_YBASE14: case REG_YBASE15:\n+    case REG_YBASE16: case REG_YBASE17: case REG_YBASE18: case REG_YBASE19:\n+    case REG_YBASE20: case REG_YBASE21: case REG_YBASE22: case REG_YBASE23:\n+    case REG_YBASE24: case REG_YBASE25: case REG_YBASE26: case REG_YBASE27:\n+    case REG_YBASE28: case REG_YBASE29: case REG_YBASE30: case REG_YBASE31:\n+      return (int) YBASE_VIRT_REGS;\n+      \n+    default:\n+      return (int) NO_REGS;\n+    }\n+}\n+\n+/* A C expression for the maximum number of consecutive registers of class CLASS\n+   needed to hold a value of mode MODE */\n+\n+int\n+class_max_nregs(class, mode)\n+enum reg_class class;\n+enum machine_mode mode;\n+{\n+    return (GET_MODE_SIZE(mode));\n+}\n+\n+enum reg_class\n+limit_reload_class (mode, class)\n+enum machine_mode mode;\n+enum reg_class class;\n+{\n+  switch ((int) class)\n+    {\n+    case NO_REGS:\n+    case A0H_REG:\n+    case A0L_REG:\n+    case A0_REG:\n+    case A1H_REG:\n+      return class;\n+\n+    case ACCUM_HIGH_REGS:\n+      fatal (\"ACCUM_HIGH_REGS class in limit_reload_class\");\n+\n+    case A1L_REG:\n+    case ACCUM_LOW_REGS:\n+    case A1_REG:\n+      return class;\n+\n+    case ACCUM_REGS:\n+      if (GET_MODE_SIZE(mode) == 1)\n+\treturn ACCUM_LOW_REGS;\n+      else\n+\treturn class;\n+\n+    case X_REG:\n+    case X_OR_ACCUM_LOW_REGS:\n+      return class;\n+\n+    case X_OR_ACCUM_REGS:\n+      if (GET_MODE_SIZE(mode) == 1)\n+\treturn X_OR_ACCUM_LOW_REGS;\n+      else\n+\treturn class;\n+\n+    case YH_REG:\n+      return class;\n+\n+    case YH_OR_ACCUM_HIGH_REGS:\n+      fatal (\"YH_OR_ACCUM_HIGH_REGS found in limit_reload_class\");\n+\n+    case X_OR_YH_REGS:\n+      return class;\n+\n+    case YL_REG:\n+      /* Register 'yl' is illegal for QImode, so we should never\n+\t see it. */\n+\n+      fatal (\"YL found in limit_reload_class\");\n+\n+    case YL_OR_ACCUM_LOW_REGS:\n+    case X_OR_YL_REGS:\n+      return class;\n+\n+    case Y_REG:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn YH_REG;\n+\n+    case ACCUM_OR_Y_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn YL_OR_ACCUM_LOW_REGS;\n+\n+    case PH_REG:\n+    case X_OR_PH_REGS:\n+    case PL_REG:\n+    case PL_OR_ACCUM_LOW_REGS:\n+    case X_OR_PL_REGS:\n+      return class;\n+\n+    case P_REG:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn PL_REG;\n+\n+    case ACCUM_OR_P_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn PL_OR_ACCUM_LOW_REGS;\n+\n+    case YL_OR_P_REGS:\n+    case ACCUM_LOW_OR_YL_OR_P_REGS:\n+      return class;\n+\n+    case Y_OR_P_REGS:\n+      return class;\n+\n+    case ACCUM_Y_OR_P_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn ACCUM_LOW_OR_YL_OR_P_REGS;\n+\n+    case NO_FRAME_Y_ADDR_REGS:\n+    case Y_ADDR_REGS: \n+    case ACCUM_LOW_OR_Y_ADDR_REGS:\n+      return class;\n+\n+    case ACCUM_OR_Y_ADDR_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn ACCUM_REGS;\n+      else\n+\treturn ACCUM_LOW_OR_Y_ADDR_REGS;\n+\n+    case X_OR_Y_ADDR_REGS:\n+      return class;\n+\n+    case Y_OR_Y_ADDR_REGS:\n+    case P_OR_Y_ADDR_REGS:\n+    case NON_HIGH_YBASE_ELIGIBLE_REGS:\n+\n+    case J_REG:\n+      return class;\n+\n+    case YBASE_ELIGIBLE_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn ACCUM_Y_P_OR_YBASE_REGS;\n+      else\n+\treturn NON_HIGH_YBASE_ELIGIBLE_REGS;\n+\n+    case J_OR_DAU_16_BIT_REGS:\n+      if (GET_MODE_SIZE(mode) == 1)\n+\treturn J_REG;\n+      else\n+\treturn class;\n+\n+    case BMU_REGS:\n+    case NOHIGH_NON_ADDR_REGS:\n+      return class;\n+\n+    case NON_ADDR_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn NOHIGH_NON_ADDR_REGS;\n+\n+    case NOHIGH_NON_YBASE_REGS:\n+      return class;\n+\n+    case NON_YBASE_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn NOHIGH_NON_YBASE_REGS;\n+\n+    case YBASE_VIRT_REGS:\n+    case ACCUM_LOW_OR_YBASE_REGS:\n+      return class;\n+      \n+    case ACCUM_OR_YBASE_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn ACCUM_LOW_OR_YBASE_REGS;\n+\n+    case X_OR_YBASE_REGS:\n+      return class;\n+\n+    case Y_OR_YBASE_REGS:\n+    case ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n+    case P_OR_YBASE_REGS:\n+      return class;\n+\n+    case ACCUM_Y_P_OR_YBASE_REGS:\n+      return ACCUM_LOW_YL_PL_OR_YBASE_REGS;\n+\n+    case Y_ADDR_OR_YBASE_REGS:\n+    case YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n+      return class;\n+\n+    case YBASE_OR_YBASE_ELIGIBLE_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS;\n+\n+    case NO_HIGH_ALL_REGS:\n+      return class;\n+\n+    case ALL_REGS:\n+      if (GET_MODE_SIZE(mode) > 1)\n+\treturn class;\n+      else\n+\treturn NO_HIGH_ALL_REGS;\n+\n+    default:\n+      return class;\n+    }\n+}\n+\n+int\n+dsp16xx_register_move_cost (from, to)\n+enum reg_class from, to;\n+{\n+#if 0\n+  if (from == NO_REGS || to == NO_REGS || (from == to))\n+    return 2;\n+#endif\n+\n+  if (from == A0H_REG || from == A0L_REG || from == A0_REG ||\n+      from == A1H_REG || from == ACCUM_HIGH_REGS || from == A1L_REG ||\n+      from == ACCUM_LOW_REGS || from == A1_REG || from == ACCUM_REGS)\n+    {\n+      if (to == Y_REG || to == P_REG)\n+\treturn 4;\n+      else\n+\treturn 2;\n+    }\n+\n+  if (to == A0H_REG || to == A0L_REG || to == A0_REG ||\n+      to == A1H_REG || to == ACCUM_HIGH_REGS || to == A1L_REG ||\n+      to == ACCUM_LOW_REGS || to == A1_REG || to == ACCUM_REGS)\n+    {\n+      return 2;\n+    }\n+\n+#if 0\n+  if (from == YBASE_VIRT_REGS)\n+    {\n+      if (to == X_REG || to == YH_REG || to == YL_REG ||\n+\t  to == Y_REG || to == PL_REG || to == PH_REG ||\n+\t  to == P_REG || to == Y_ADDR_REGS || to == YBASE_ELIGIBLE_REGS ||\n+\t  to == Y_OR_P_REGS)\n+\t{\n+\t  return 2;\n+\t}\n+      else\n+\treturn 4;\n+    }\n+\n+  if (to == YBASE_VIRT_REGS)\n+    {\n+      if (from == X_REG || from == YH_REG || from == YL_REG ||\n+\t  from == Y_REG || from == PL_REG || from == PH_REG ||\n+\t  from == P_REG || from == Y_ADDR_REGS || from == YBASE_ELIGIBLE_REGS ||\n+\t  from == Y_OR_P_REGS)\n+\t{\n+\t  return 2;\n+\t}\n+      else\n+\treturn 4;\n+    }\n+#endif\n+  return 4;\n+}\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+   Also, we must ensure that a PLUS is reloaded either\n+   into an accumulator or an address register.  */\n+\n+enum reg_class\n+preferred_reload_class (x, class)\n+     rtx x;\n+     enum reg_class class;\n+{\n+  /* The ybase registers cannot have constants copied directly\n+     to them. */\n+\n+  if (CONSTANT_P (x))\n+    {\n+      if (class == ALL_REGS)\n+\treturn NON_YBASE_REGS;\n+    }\n+\n+  if (class == ALL_REGS && REG_P (x) && !TARGET_RESERVE_YBASE\n+      && IS_YBASE_REGISTER_WINDOW (REGNO(x)))\n+    return YBASE_ELIGIBLE_REGS;\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      if (GET_MODE (x) == QImode\n+\t  && REG_P (XEXP (x,0))\n+\t  && (XEXP (x,0) == frame_pointer_rtx\n+\t      || XEXP (x,0) == stack_pointer_rtx)\n+\t  && (GET_CODE (XEXP (x,1)) == CONST_INT))\n+\t{\n+\t  if (class == ACCUM_HIGH_REGS)\n+\t    return class;\n+\n+\t  if (reg_class_subset_p (ACCUM_HIGH_REGS, class))\n+\t    return ACCUM_HIGH_REGS;\n+\n+\t  /* We will use accumulator 'a1l' for reloading a\n+\t     PLUS. We can only use one accumulator because\n+\t     'reload_inqi' only allows one alternative to be\n+\t     used. */\n+\n+\t  else if (class == ACCUM_LOW_REGS)\n+\t    return A1L_REG;\n+\t  else if (class == A0L_REG)\n+\t    return NO_REGS;\n+\t  else\n+\t    return class;\n+\t}\n+\n+      if (class == NON_YBASE_REGS || class == YBASE_ELIGIBLE_REGS)\n+\treturn Y_ADDR_REGS;\n+      else\n+\treturn class;\n+    }\n+  else if (GET_CODE (x) == MEM)\n+    {\n+      if (class == ALL_REGS)\n+\t{\n+#if 0\n+\t  if (GET_MODE(x) == HImode)\n+\t    return NO_ACCUM_NON_YBASE_REGS;\n+\t  else\n+#endif\n+\t    return NON_YBASE_REGS;\n+\t}\n+      else\n+\treturn class;\n+    }\n+  else\n+    return class;\n+}\n+\t\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx in;\n+{\n+  int regno = -1;\n+\n+  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n+    regno = true_regnum (in);\n+\n+  if (class == ACCUM_HIGH_REGS \n+      || class == ACCUM_LOW_REGS\n+      || class == A1L_REG\n+      || class == A0L_REG\n+      || class == A1H_REG\n+      || class == A0H_REG)\n+    {\n+      if (GET_CODE (in) == PLUS && mode == QImode)\n+\t{\n+\t  rtx addr0 = XEXP (in, 0);\n+\t  rtx addr1 = XEXP (in, 1);\n+\t  \n+\t  /* If we are reloading a plus (reg:QI) (reg:QI)\n+\t     we need an additional register. */ \n+\t  if (REG_P (addr0) && REG_P (addr1))\n+\t    return NO_REGS;\n+\t}\n+    }\n+\n+  /* We can place anything into ACCUM_REGS and can put ACCUM_REGS\n+     into anything.  */\n+\n+  if ((class == ACCUM_REGS || class == ACCUM_HIGH_REGS ||\n+       class == ACCUM_LOW_REGS || class == A0H_REG || class == A0L_REG ||\n+       class == A1H_REG || class == A1_REG) || \n+      (regno >= REG_A0 && regno < REG_A1L + 1))\n+    return NO_REGS;\n+\n+  /* We can copy the ybase registers into:\n+     r0-r3, a0-a1, y, p, & x or the union of\n+     any of these. */\n+\n+  if (!TARGET_RESERVE_YBASE && IS_YBASE_REGISTER_WINDOW(regno))\n+    {\n+      switch ((int) class)\n+\t{\n+\tcase (int) X_REG:\n+\tcase (int) X_OR_ACCUM_LOW_REGS:\n+\tcase (int) X_OR_ACCUM_REGS:\n+\tcase (int) YH_REG:\n+\tcase (int) YH_OR_ACCUM_HIGH_REGS:\n+\tcase (int) X_OR_YH_REGS:\n+\tcase (int) YL_REG:\n+\tcase (int) YL_OR_ACCUM_LOW_REGS:\n+\tcase (int) X_OR_Y_REGS:\n+\tcase (int) X_OR_YL_REGS:\n+\tcase (int) Y_REG:\n+\tcase (int) ACCUM_OR_Y_REGS:\n+\tcase (int) PH_REG:\n+\tcase (int) X_OR_PH_REGS:\n+\tcase (int) PL_REG:\n+\tcase (int) PL_OR_ACCUM_LOW_REGS:\n+\tcase (int) X_OR_PL_REGS:\n+\tcase (int) YL_OR_PL_OR_ACCUM_LOW_REGS:\n+\tcase (int) P_REG:\n+\tcase (int) ACCUM_OR_P_REGS:\n+\tcase (int) YL_OR_P_REGS:\n+\tcase (int) ACCUM_LOW_OR_YL_OR_P_REGS:\n+\tcase (int) Y_OR_P_REGS:\n+\tcase (int) ACCUM_Y_OR_P_REGS:\n+\tcase (int) Y_ADDR_REGS:\n+\tcase (int) ACCUM_LOW_OR_Y_ADDR_REGS:\n+\tcase (int) ACCUM_OR_Y_ADDR_REGS:\n+\tcase (int) X_OR_Y_ADDR_REGS:\n+\tcase (int) Y_OR_Y_ADDR_REGS:\n+\tcase (int) P_OR_Y_ADDR_REGS:\n+\tcase (int) YBASE_ELIGIBLE_REGS:\n+\t  return NO_REGS;\n+\n+\tdefault:\n+\t  return ACCUM_HIGH_REGS;\n+\t}\n+    }\n+\n+  /* We can copy r0-r3, a0-a1, y, & p\n+     directly to the ybase registers. In addition\n+     we can use any of the ybase virtual registers\n+     as the secondary reload registers when copying\n+     between any of these registers. */\n+\n+  if (!TARGET_RESERVE_YBASE && regno != -1)\n+    {\n+      switch (regno)\n+\t{\n+\tcase REG_A0:\n+\tcase REG_A0L:\n+\tcase REG_A1:\n+\tcase REG_A1L:\n+\tcase REG_X:\n+\tcase REG_Y:\n+\tcase REG_YL:\n+\tcase REG_PROD:\n+\tcase REG_PRODL:\n+\tcase REG_R0:\n+\tcase REG_R1:\n+\tcase REG_R2:\n+\tcase REG_R3:\n+\t  if (class == YBASE_VIRT_REGS)\n+\t    return NO_REGS;\n+\t  else\n+\t    {\n+\t      switch ((int) class)\n+\t\t{\n+\t\tcase (int) X_REG:\n+\t\tcase (int) X_OR_ACCUM_LOW_REGS:\n+\t\tcase (int) X_OR_ACCUM_REGS:\n+\t\tcase (int) YH_REG:\n+\t\tcase (int) YH_OR_ACCUM_HIGH_REGS:\n+\t\tcase (int) X_OR_YH_REGS:\n+\t\tcase (int) YL_REG:\n+\t\tcase (int) YL_OR_ACCUM_LOW_REGS:\n+\t\tcase (int) X_OR_Y_REGS:\n+\t\tcase (int) X_OR_YL_REGS:\n+\t\tcase (int) Y_REG:\n+\t\tcase (int) ACCUM_OR_Y_REGS:\n+\t\tcase (int) PH_REG:\n+\t\tcase (int) X_OR_PH_REGS:\n+\t\tcase (int) PL_REG:\n+\t\tcase (int) PL_OR_ACCUM_LOW_REGS:\n+\t\tcase (int) X_OR_PL_REGS:\n+\t\tcase (int) YL_OR_PL_OR_ACCUM_LOW_REGS:\n+\t\tcase (int) P_REG:\n+\t\tcase (int) ACCUM_OR_P_REGS:\n+\t\tcase (int) YL_OR_P_REGS:\n+\t\tcase (int) ACCUM_LOW_OR_YL_OR_P_REGS:\n+\t\tcase (int) Y_OR_P_REGS:\n+\t\tcase (int) ACCUM_Y_OR_P_REGS:\n+\t\tcase (int) Y_ADDR_REGS:\n+\t\tcase (int) ACCUM_LOW_OR_Y_ADDR_REGS:\n+\t\tcase (int) ACCUM_OR_Y_ADDR_REGS:\n+\t\tcase (int) X_OR_Y_ADDR_REGS:\n+\t\tcase (int) Y_OR_Y_ADDR_REGS:\n+\t\tcase (int) P_OR_Y_ADDR_REGS:\n+\t\tcase (int) YBASE_ELIGIBLE_REGS:\n+\t\t  return YBASE_VIRT_REGS;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  /* Memory or constants can be moved from or to any register\n+     except the ybase virtual registers */\n+  if (regno == -1 && GET_CODE(in) != PLUS)\n+    {\n+      if (class == YBASE_VIRT_REGS)\n+\treturn NON_YBASE_REGS;\n+      else\n+        return NO_REGS;\n+    }\n+\n+  if (GET_CODE (in) == PLUS && mode == QImode)\n+    {\n+      rtx addr0 = XEXP (in, 0);\n+      rtx addr1 = XEXP (in, 1);\n+\n+      /* If we are reloading a plus (reg:QI) (reg:QI)\n+\t we need a low accumulator, not a high one. */\n+      if (REG_P (addr0) && REG_P (addr1))\n+\treturn ACCUM_LOW_REGS;\n+    }\n+\n+#if 0\n+  if (REG_P(in))\n+    return ACCUM_REGS;\n+#endif\n+\n+  /* Otherwise, we need a high accumulator(s).  */\n+  return ACCUM_HIGH_REGS;\n+}\n+\n+int\n+symbolic_address_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+    return (symbolic_address_p (op));\n+\n+}\n+\n+int symbolic_address_p (op)\n+rtx op;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+              && INTVAL (XEXP (op,1)) < 0x20);\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* For a Y address space operand we allow only *rn, *rn++, *rn--.\n+   This routine only recognizes *rn, the '<>' constraints recognize\n+   *rn++, *rn-- */\n+\n+int\n+Y_address_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+   return (memory_address_p (mode, op) && !symbolic_address_p (op));\n+}\t     \n+\n+int\n+sp_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+    return (GET_CODE (op) == PLUS\n+\t    && (XEXP (op, 0) == stack_pointer_rtx\n+\t\t|| XEXP (op, 0) == frame_pointer_rtx)\n+\t    && GET_CODE (XEXP (op,1)) == CONST_INT);\n+}\n+\n+int\n+sp_operand2 (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+  if ((GET_CODE (op) == PLUS \n+       && (XEXP (op, 0) == stack_pointer_rtx\n+\t   || XEXP (op, 0) == frame_pointer_rtx)\n+       && (REG_P (XEXP (op,1))\n+\t   && IS_ADDRESS_REGISTER (REGNO (XEXP(op, 1))))))\n+    return 1;\n+  else if ((GET_CODE (op) == PLUS\n+       && (XEXP (op, 1) == stack_pointer_rtx\n+\t   || XEXP (op, 1) == frame_pointer_rtx)\n+       && (REG_P (XEXP (op,0))\n+\t   && IS_ADDRESS_REGISTER (REGNO (XEXP(op, 1))))))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+int\n+nonmemory_arith_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+  return (immediate_operand (op, mode) || arith_reg_operand (op, mode));\n+}\n+\n+int\n+arith_reg_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+  return (register_operand (op, mode)\n+\t  && (GET_CODE (op) != REG\n+\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || (!(IS_YBASE_REGISTER_WINDOW (REGNO (op)))\n+\t\t  && REGNO (op) != FRAME_POINTER_REGNUM)));\n+}\n+\n+int\n+call_address_operand (op, mode)\n+rtx op;\n+enum machine_mode mode;\n+{\n+    if (symbolic_address_p (op) || REG_P(op))\n+    {\n+\treturn 1;\n+    }\n+\n+    return 0;\n+}\n+\n+int\n+dsp16xx_comparison_operator (op, mode)\n+    register rtx op;\n+    enum machine_mode mode;\n+{\n+  return ((mode == VOIDmode || GET_MODE (op) == mode)\n+\t  && GET_RTX_CLASS (GET_CODE (op)) == '<'\n+\t  && (GET_CODE(op) != GE && GET_CODE (op) != LT &&\n+\t      GET_CODE (op) != GEU && GET_CODE (op) != LTU));\n+}\n+\n+void\n+notice_update_cc(exp)\n+rtx exp;\n+{\n+    if (GET_CODE (exp) == SET)\n+    {\n+\t/* Jumps do not alter the cc's.  */\n+\n+\tif (SET_DEST (exp) == pc_rtx)\n+\t    return;\n+\n+\t/* Moving register or memory into a register:\n+\t   it doesn't alter the cc's, but it might invalidate\n+\t   the RTX's which we remember the cc's came from.\n+\t   (Note that moving a constant 0 or 1 MAY set the cc's).  */\n+\tif (REG_P (SET_DEST (exp))\n+\t    && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM))\n+\t{\n+\t    if (cc_status.value1\n+\t\t&& reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n+\t\tcc_status.value1 = 0;\n+\t    if (cc_status.value2\n+\t\t&& reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))\n+\t\tcc_status.value2 = 0;\n+\t    return;\n+\t}\n+\t/* Moving register into memory doesn't alter the cc's.\n+\t   It may invalidate the RTX's which we remember the cc's came from.  */\n+\tif (GET_CODE (SET_DEST (exp)) == MEM && REG_P (SET_SRC (exp)))\n+\t{\n+\t    if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM)\n+\t\tcc_status.value1 = 0;\n+\t    if (cc_status.value2 && GET_CODE (cc_status.value2) == MEM)\n+\t\tcc_status.value2 = 0;\n+\t    return;\n+\t}\n+\t/* Function calls clobber the cc's.  */\n+\telse if (GET_CODE (SET_SRC (exp)) == CALL)\n+\t{\n+\t    CC_STATUS_INIT;\n+\t    return;\n+\t}\n+\t/* Tests and compares set the cc's in predictable ways.  */\n+\telse if (SET_DEST (exp) == cc0_rtx)\n+\t{\n+\t    CC_STATUS_INIT;\n+\t    cc_status.value1 = SET_SRC (exp);\n+\t    return;\n+\t}\n+\t/* Certain instructions effect the condition codes. */\n+\telse if (GET_MODE_CLASS (GET_MODE (SET_SRC (exp))) == MODE_INT)\n+\t    switch( GET_CODE (SET_SRC (exp)) )\n+\t    {\n+\t    case PLUS: \n+\t    case MINUS:\n+\t      if (REG_P (SET_DEST (exp)))\n+\t\t{\n+\t\t  /* Address registers don't set the condition codes */\n+\t\t  if (IS_ADDRESS_REGISTER (REGNO (SET_DEST (exp))))\n+\t\t    {\n+\t\t      CC_STATUS_INIT;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    case ASHIFTRT: \n+\t    case LSHIFTRT:\n+\t    case ASHIFT: \n+\t    case LSHIFT:\n+\t    case AND: \n+\t    case IOR: \n+\t    case XOR:\n+\t    case MULT:\n+\t    case NEG:\n+\t    case NOT:\n+\t      cc_status.value1 = SET_SRC (exp);\n+\t      cc_status.value2 = SET_DEST (exp);\n+\t      break;\n+\t      \n+\t    default:\n+\t      CC_STATUS_INIT;\n+\t    }\n+\telse\n+\t{\n+\t    CC_STATUS_INIT;\n+\t}\n+    }\n+    else if (GET_CODE (exp) == PARALLEL\n+\t     && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n+    {\n+\tif (SET_DEST (XVECEXP (exp, 0, 0)) == pc_rtx)\n+\t    return;\n+\n+\tif (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n+\t{\n+\t    CC_STATUS_INIT;\n+\t    cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n+\t    return;\n+\t}\n+\n+\tCC_STATUS_INIT;\n+    }\n+    else\n+    {\n+\tCC_STATUS_INIT;\n+    }\n+}\n+\n+int\n+dsp16xx_makes_calls ()\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = next_insn (insn))\n+    if (GET_CODE (insn) == CALL_INSN)\n+      return (1);\n+\n+  return 0;\n+}\n+\n+long compute_frame_size (size)\n+int size;\n+{\n+  long total_size;\n+  long var_size;\n+  long args_size;\n+  long extra_size;\n+  long reg_size;\n+\n+  reg_size = 0;\n+  extra_size = 0;\n+  var_size = size;\n+  args_size = current_function_outgoing_args_size;\n+  reg_size = reg_save_size ();  \n+\n+  total_size = var_size + args_size + extra_size + reg_size;\n+\n+\n+  /* Save other computed information.  */\n+  current_frame_info.total_size  = total_size;\n+  current_frame_info.var_size    = var_size;\n+  current_frame_info.args_size   = args_size;\n+  current_frame_info.extra_size  = extra_size;\n+  current_frame_info.reg_size    = reg_size;\n+  current_frame_info.initialized = reload_completed;\n+  current_frame_info.reg_size\t = reg_size / UNITS_PER_WORD;\n+  current_frame_info.function_makes_calls = dsp16xx_makes_calls ();\n+\n+  if (reg_size)\n+    {\n+      unsigned long offset = args_size + var_size + reg_size;\n+      current_frame_info.sp_save_offset = offset;\n+      current_frame_info.fp_save_offset = offset - total_size;\n+    }\n+\n+  return total_size;\n+}\n+\n+int\n+dsp16xx_call_saved_register (regno)\n+int regno;\n+{\n+  return (regs_ever_live[regno] && !call_used_regs[regno] &&\n+\t  !IS_YBASE_REGISTER_WINDOW(regno));\n+\n+}\n+\n+int\n+ybase_regs_ever_used ()\n+{\n+  int regno;\n+  int live = 0;\n+\n+  for (regno = REG_YBASE0; regno <= REG_YBASE31; regno++)\n+    if (regs_ever_live[regno])\n+      {\n+\tlive = 1;\n+\tbreak;\n+      }\n+\n+  return live;\n+}\n+\n+void \n+function_prologue (file, size)\n+FILE *file;\n+int  size;\n+{\n+  int regno;\n+  long total_size;\n+  fp = reg_names[FRAME_POINTER_REGNUM];\n+  sp = reg_names[STACK_POINTER_REGNUM];\n+  rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n+  a1h = reg_names[REG_A1];\n+  \n+  total_size = compute_frame_size (size);\n+  \n+  fprintf( file, \"\\t/* FUNCTION PROLOGUE: */\\n\" );\n+  fprintf (file, \"\\t/* total=%d, vars= %d, regs= %d, args=%d, extra= %d */\\n\",\n+\t   current_frame_info.total_size,\n+\t   current_frame_info.var_size,\n+\t   current_frame_info.reg_size,\n+\t   current_function_outgoing_args_size,\n+\t   current_frame_info.extra_size);\n+  \n+  fprintf (file, \"\\t/* fp save offset= %d, sp save_offset= %d */\\n\\n\",\n+\t   current_frame_info.fp_save_offset,\n+\t   current_frame_info.sp_save_offset);\n+  /* Set up the 'ybase' register window. */\n+  \n+  if (ybase_regs_ever_used())\n+    {\n+      fprintf (file, \"\\t%s=%s\\n\", a1h, reg_names[REG_YBASE]);\n+      if (TARGET_YBASE_HIGH)\n+\tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n+      else\n+\tfprintf (file, \"\\t%s=%sh+32\\n\", reg_names[REG_A1], a1h);\n+      fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n+    }\n+  \n+#if 0\n+  if (current_frame_info.function_makes_calls)\n+    fprintf( file, \"\\t*%s++=%s\\n\", sp, rr );   /* Push return address */\n+#endif\n+  \n+  \n+  if (current_frame_info.var_size)\n+    {\n+      if (current_frame_info.var_size == 1)\n+\tfprintf (file, \"\\t*%s++\\n\", sp);\n+      else\n+        {\n+\t  if(SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n+\t    fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.var_size, sp, reg_names[REG_J]);\n+\t  else\n+\t    fatal (\"Stack size > 32k\");\n+\t}\n+    }\n+  \n+  /* Save any registers this function uses, unless they are\n+   * used in a call, in which case we don't need to\n+   */\n+  \n+  for( regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno )\n+    if (dsp16xx_call_saved_register (regno)) \n+      {\n+#if OLD_REGISTER_SAVE\n+\tfprintf( file, \"\\t*%s++=%s\\n\", sp, reg_names[regno] );\n+#else\n+\tfprintf( file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno] );\n+#endif\n+      }\n+  \n+  if (current_frame_info.args_size)\n+    {\n+      if (current_frame_info.args_size == 1)\n+\tfprintf (file, \"\\t*%s++\\n\", sp);\n+      else\n+        {\n+\t  if(SMALL_INTVAL(current_frame_info.args_size) && ((current_frame_info.args_size & 0x8000) == 0))\n+\t    fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.args_size, sp, reg_names[REG_J]);\n+\t  else\n+\t    fatal (\"Stack size > 32k\");\n+\t}\n+    }\n+  \n+  if (frame_pointer_needed)\n+    {\n+      fprintf( file, \"\\t%s=%s\\n\", a1h, sp );\n+      fprintf( file, \"\\t%s=%s\\n\", fp, a1h );  /* Establish new base frame */\n+      fprintf( file, \"\\t%s=%d\\n\", reg_names[REG_J], -total_size);\n+      fprintf( file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n+    }\n+  \n+  fprintf( file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\" );\n+}\n+\n+void\n+init_emulation_routines ()\n+{\n+ dsp16xx_addhf3_libcall = (rtx) 0;\n+ dsp16xx_subhf3_libcall = (rtx) 0;\n+ dsp16xx_mulhf3_libcall = (rtx) 0;\n+ dsp16xx_divhf3_libcall = (rtx) 0;\n+ dsp16xx_cmphf3_libcall = (rtx) 0;\n+ dsp16xx_fixhfhi2_libcall = (rtx) 0;\n+ dsp16xx_floathihf2_libcall = (rtx) 0;\n+ dsp16xx_neghf2_libcall = (rtx) 0;\n+\n+ dsp16xx_mulhi3_libcall = (rtx) 0;\n+ dsp16xx_udivqi3_libcall = (rtx) 0;\n+ dsp16xx_udivhi3_libcall = (rtx) 0;\n+ dsp16xx_divqi3_libcall = (rtx) 0;\n+ dsp16xx_divhi3_libcall = (rtx) 0;\n+ dsp16xx_modqi3_libcall = (rtx) 0;\n+ dsp16xx_modhi3_libcall = (rtx) 0;\n+ dsp16xx_umodqi3_libcall = (rtx) 0;\n+ dsp16xx_umodhi3_libcall = (rtx) 0;\n+ dsp16xx_ashrhi3_libcall = (rtx) 0;\n+ dsp16xx_ashlhi3_libcall = (rtx) 0;\n+ dsp16xx_ucmphi2_libcall = (rtx) 0;\n+ dsp16xx_lshrhi3_libcall = (rtx) 0;\n+\n+}\n+void\n+function_epilogue (file, size)\n+FILE *file;\n+int   size;\n+{\n+  int regno;\n+  int initial_stack_dec = 0;\n+  \n+  fp = reg_names[FRAME_POINTER_REGNUM];\n+  sp = reg_names[STACK_POINTER_REGNUM];\n+  rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n+  a1h = reg_names[REG_A1];\n+  \n+  fprintf( file, \"\\n\\t/* FUNCTION EPILOGUE: */\\n\" );\n+  \n+  if (current_frame_info.args_size)\n+    {\n+      if (current_frame_info.args_size == 1)\n+\tfprintf (file, \"\\t*%s--\\n\", sp);\n+      else\n+\t{\n+\t  fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", \n+\t\t   reg_names[REG_J], -current_frame_info.args_size, sp, reg_names[REG_J]);\n+\t}\n+    }\n+  \n+  if (ybase_regs_ever_used())\n+    {\n+      fprintf (file, \"\\t%s=%s\\n\", a1h, reg_names[REG_YBASE]);\n+      if (TARGET_YBASE_HIGH)\n+\tfprintf (file, \"\\t%s=%sh+32\\n\", reg_names[REG_A1], a1h);\n+      else\n+\tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n+      fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n+    }\n+  \n+  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n+    if (dsp16xx_call_saved_register(regno))\n+      {\n+#if OLD_REGISTER_SAVE\n+\tif (!initial_stack_dec)\n+\t  {\n+\t    initial_stack_dec = 1;\n+\t    fprintf (file, \"\\t*%s--\\n\", sp);\n+\t  }\n+#endif\n+\n+#if OLD_REGISTER_SAVE\n+\tfprintf( file, \"\\t%s=*%s--\\n\", reg_names[regno], sp );\n+#else\n+\tfprintf( file, \"\\t%s=pop(*%s)\\n\", reg_names[regno], sp );\n+#endif\n+      }\n+  \n+  /* If we restored any registers we have to account for the\n+     initial pre-decrement. But only if we had any local variables\n+     or spills. */\n+#if OLD_REGISTER_SAVE  \n+  if (initial_stack_dec) \n+    fprintf (file, \"\\t*%s++\\n\", sp);\n+#endif\n+  \n+  if (current_frame_info.var_size)\n+    {\n+      if (current_frame_info.var_size == 1)\n+\tfprintf (file, \"\\t*%s--\\n\", sp);\n+      else\n+\t{\n+\t  fprintf (file, \"\\t%s=%d\\n\\t*%s++%s\\n\", \n+\t\t   reg_names[REG_J], -current_frame_info.var_size, sp, reg_names[REG_J]);\n+\t}\n+    }\n+  \n+  fprintf (file, \"\\treturn\\n\");\n+  /* Reset the frame info for the next function */\n+  current_frame_info = zero_frame_info;\n+  init_emulation_routines ();\n+}\n+\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.  */\n+\n+int\n+emit_move_sequence (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  register rtx operand0 = operands[0];\n+  register rtx operand1 = operands[1];\n+\n+  /* We can only store registers to memory.  */\n+\n+  if (GET_CODE (operand0) == MEM && GET_CODE (operand1) != REG)\n+    operands[1] = force_reg (mode, operand1);\n+\n+  return 0;\n+}\n+\n+void\n+double_reg_from_memory (operands)\n+rtx operands[];\n+{\n+    rtx xoperands[4];\n+\n+    if (GET_CODE(XEXP(operands[1],0)) == POST_INC)\n+    {\n+\toutput_asm_insn (\"%u0=%1\", operands);\n+\toutput_asm_insn (\"%w0=%1\", operands);\n+    }\n+    else if (GET_CODE(XEXP(operands[1],0)) == POST_DEC)\n+    {\n+\txoperands[1] = XEXP (XEXP (operands[1], 0), 0);\n+\txoperands[0] = operands[0];\n+\t\n+\t/* We can't use j anymore since the compiler can allocate it. */\n+/*\toutput_asm_insn (\"j=-3\\n\\t%u0=*%1++\\n\\t%w0=*%1++j\", xoperands); */\n+\toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\\n\\t*%1--\\n\\t*%1--\", xoperands);\n+    }\n+    else if (GET_CODE(XEXP(operands[1],0)) == PLUS)\n+    {\n+      rtx addr;\n+      rtx base;\n+      int offset;\n+\n+      output_asm_insn (\"%u0=%1\", operands);\n+\n+\n+      /* In order to print out the least significant word we must\n+\t use 'offset + 1'.  */\n+      addr = XEXP (operands[1], 0);\n+      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n+\toffset = INTVAL(XEXP(addr,0)) + 1;\n+      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n+\toffset = INTVAL(XEXP(addr,1)) + 1;\n+\n+      fprintf (asm_out_file, \"\\t%s=*(%d)\\n\", reg_names[REGNO(operands[0]) + 1], offset + 31);\n+    }\n+    else\n+    {\n+\txoperands[1] = XEXP(operands[1],0);\n+\txoperands[0] = operands[0];\n+\n+\toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\", xoperands);\n+    }\n+}\n+\n+\n+void\n+double_reg_to_memory (operands)\n+rtx operands[];\n+{\n+    rtx xoperands[4];\n+\n+    if (GET_CODE(XEXP(operands[0],0)) == POST_INC)\n+    {\n+\toutput_asm_insn (\"%0=%u1\", operands);\n+\toutput_asm_insn (\"%0=%w1\", operands);\n+    }\n+    else if (GET_CODE(XEXP(operands[0],0)) == POST_DEC)\n+    {\n+\txoperands[0] = XEXP (XEXP (operands[0], 0), 0);\n+\txoperands[1] = operands[1];\n+\t\n+\t/* We can't use j anymore since the compiler can allocate it. */\n+\n+/*\toutput_asm_insn (\"j=-3\\n\\t*%0++=%u1\\n\\t*%0++j=%w1\", xoperands); */\n+\toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\\n\\t*%0--\\n\\t*%0--\", xoperands);\n+\n+    }\n+    else if (GET_CODE(XEXP(operands[0],0)) == PLUS)\n+    {\n+      rtx addr;\n+      int offset;\n+\n+      output_asm_insn (\"%0=%u1\", operands);\n+\n+      /* In order to print out the least significant word we must\n+\t use 'offset + 1'.  */\n+      addr = XEXP (operands[0], 0);\n+      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n+\toffset = INTVAL(XEXP(addr,0)) + 1;\n+      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n+\toffset = INTVAL(XEXP(addr,1)) + 1;\n+      else\n+\tfatal (\"Illegal addressing mode\");\n+\n+      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31, reg_names[REGNO(operands[1]) + 1]);\n+    }\n+    else\n+    {\n+\txoperands[0] = XEXP(operands[0],0);\n+\txoperands[1] = operands[1];\n+\n+\toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\", xoperands);\n+    }\n+}\n+\n+void\n+override_options ()\n+{\n+  if (chip_name == (char *) 0)\n+    chip_name = DEFAULT_CHIP_NAME;\n+\n+  if (text_seg_name == (char *) 0)\n+    text_seg_name = DEFAULT_TEXT_SEG_NAME;\n+  \n+  if (data_seg_name == (char *) 0)\n+    data_seg_name = DEFAULT_DATA_SEG_NAME;\n+  \n+  if (bss_seg_name == (char *) 0)\n+    bss_seg_name = DEFAULT_BSS_SEG_NAME;\n+  \n+  if (const_seg_name == (char *) 0)\n+    const_seg_name = DEFAULT_CONST_SEG_NAME;\n+  \n+  save_chip_name = (char *) xmalloc (strlen(chip_name) + 1);\n+  strcpy (save_chip_name, chip_name);\n+\n+  rsect_text = (char *) xmalloc (strlen(\".rsect \") + \n+\t\t\t\t strlen(text_seg_name) + 3);\n+  rsect_data = (char *) xmalloc (strlen(\".rsect \") + \n+\t\t\t\t strlen(data_seg_name) + 3);\n+  rsect_bss = (char *) xmalloc (strlen(\".rsect \") + \n+\t\t\t\tstrlen(bss_seg_name) + 3);\n+  rsect_const = (char *) xmalloc (strlen(\".rsect \") + \n+\t\t\t\t  strlen(const_seg_name) + 3);\n+  \n+  sprintf (rsect_text, \".rsect \\\"%s\\\"\", text_seg_name);\n+  sprintf (rsect_data, \".rsect \\\"%s\\\"\", data_seg_name);\n+  sprintf (rsect_bss,  \".rsect \\\"%s\\\"\", bss_seg_name);\n+  sprintf (rsect_const, \".rsect \\\"%s\\\"\", const_seg_name);\n+  \n+  if (optimize)\n+    {\n+      if (TARGET_OPTIMIZE_SPEED)\n+\t{\n+\t  flag_unroll_loops = 1;\n+\t  flag_inline_functions = 1;\n+\t}\n+    }\n+}\n+\n+enum rtx_code save_next_cc_user_code;\n+\n+enum rtx_code\n+next_cc_user_code (insn)\n+rtx insn;\n+{\n+  if ( !(insn = next_cc0_user (insn)))\n+    abort ();\n+  else if (GET_CODE (insn) == JUMP_INSN\n+\t   && GET_CODE (PATTERN (insn)) == SET\n+\t   && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n+    return GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 0));\n+  else if (GET_CODE (insn) == INSN\n+\t   && GET_CODE (PATTERN (insn)) == SET\n+\t   && comparison_operator (SET_SRC (PATTERN (insn)), VOIDmode))\n+    return GET_CODE (SET_SRC (PATTERN (insn)));\n+  else\n+    abort ();\n+}\n+\n+void\n+print_operand(file, op, letter)\n+FILE *file;\n+rtx op;\n+int letter;\n+{\n+    enum rtx_code code;\n+\n+    code = GET_CODE(op);\n+\n+    switch (letter)\n+    {\n+       case 'I':\n+\t  code = reverse_condition (code);\n+\t  /* Fallthrough */\n+\n+       case 'C':\n+          if (code == EQ) \n+          { \n+\t      fputs (\"eq\", file); \n+\t      return; \n+\t  }\n+          else if (code == NE)  \n+\t  { \n+\t      fputs (\"ne\", file); \n+\t      return; \n+\t  }\n+          else if (code == GT || code == GTU)  \n+\t  { \n+\t      fputs (\"gt\", file); \n+\t      return; \n+\t  }\n+          else if (code == LT || code == LTU)  \n+\t  { \n+\t      fputs (\"mi\", file); \n+\t      return; \n+\t  }\n+          else if (code == GE || code == GEU)  \n+\t  {\n+\t      fputs (\"pl\", file); \n+\t      return; \n+\t  }\n+          else if (code == LE || code == LEU)  \n+\t  { \n+\t      fputs (\"le\", file); \n+\t      return; \n+\t  }\n+          else \n+\t      abort ();\n+\t  break;\n+\n+       default:\n+          break;  \n+    }\n+\n+    if( code == REG )\n+    {\n+\t/* Print the low half of a 32-bit register pair */\n+        if (letter == 'w')\n+           fprintf( file, \"%s\", reg_names[REGNO(op)+1] );\n+        else if (letter == 'u' || !letter)\n+           fprintf( file, \"%s\", reg_names[REGNO(op)]);\n+\telse if (letter == 'b')\n+\t    fprintf ( file, \"%sh\", reg_names[REGNO(op)]);\n+\telse if (letter == 'm')\n+\t  fprintf (file, \"%s\", himode_reg_name[REGNO(op)]);\n+        else\n+           fatal(\"Bad register extension code\");\n+    }\n+    else if( code == MEM )\n+        output_address( XEXP(op,0) );\n+    else if( code == CONST_INT )\n+    { \n+        if( letter == 'H' )\n+            fprintf( file, \"0x%x\", (INTVAL(op) & 0xffff) );\n+\telse if (letter == 'h')\n+            fprintf( file, \"%d\", INTVAL (op) );\n+        else if( letter == 'U' )\n+            fprintf( file, \"0x%x\", ((INTVAL(op) & 0xffff0000) >> 16) & 0xffff );\n+        else\n+           output_addr_const( file, op );\n+    }\n+    else if( code == CONST_DOUBLE && GET_MODE(op) != DImode )\n+    {\n+\t  union { double d; int i[2]; } u;\n+\t  union { float f; int i; } u1;\n+\t  u.i[0] = CONST_DOUBLE_LOW (op);\n+\t  u.i[1] = CONST_DOUBLE_HIGH (op);\n+\t  u1.f = u.d;\n+          fprintf( file, \"0x%x\", u1.i );\n+    }\n+    else output_addr_const( file, op);\n+}\n+\n+\n+void\n+print_operand_address(file, addr)\n+FILE *file;\n+rtx addr;\n+{\n+  rtx base;\n+  int offset;\n+  \n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fprintf (file, \"*%s\", reg_names[REGNO (addr)]);\n+      break;\n+    case POST_DEC:\n+      fprintf (file, \"*%s--\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+    case POST_INC:\n+      fprintf (file, \"*%s++\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+    case PLUS:\n+      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n+\toffset = INTVAL(XEXP(addr,0)), base = XEXP(addr,1);\n+      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n+\toffset = INTVAL(XEXP(addr,1)), base = XEXP(addr,0);\n+      if (GET_CODE (base) == REG && REGNO(base) == STACK_POINTER_REGNUM)\n+\t{\n+\t  if (offset >= -31 && offset <= 0)\n+\t    offset = 31 + offset;\n+\t  else\n+\t    fatal (\"Illegal offset in ybase addressing\");\n+\t}\n+      else\n+\tfatal (\"Illegal register in ybase addresing\");\n+      \n+      fprintf (file, \"*(%d)\", offset);\n+      break;\n+      \n+    default:\n+      if( FITS_5_BITS( addr ) )\n+\tfprintf( file, \"*(0x%x)\", (INTVAL(addr) & 0x20) );\n+      else\n+\toutput_addr_const(file, addr);\n+    }\n+}\n+\n+void\n+output_dsp16xx_float_const(operands)\n+rtx *operands;\n+{\n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+  \n+#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+  REAL_VALUE_TYPE d;\n+  long value;\n+  \n+  REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n+  REAL_VALUE_TO_TARGET_SINGLE (d, value);\n+  \n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, value);\n+  output_asm_insn (\"%u0=%U1\\n\\t%w0=%H1\", operands);\n+#else\n+  fatal (\"inline float constants not supported on this host\");\n+#endif\n+}\n+\n+int\n+reg_save_size ()\n+{\n+  int reg_save_size = 0;\n+ int regno;\n+ \n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (dsp16xx_call_saved_register (regno))\n+      {\n+\treg_save_size += UNITS_PER_WORD;\n+      }\n+\n+  return (reg_save_size);\n+}\n+\n+int\n+dsp16xx_starting_frame_offset()\n+{\n+  int reg_save_size = 0;\n+ int regno;\n+ \n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (dsp16xx_call_saved_register (regno))\n+      {\n+\treg_save_size += UNITS_PER_WORD;\n+      }\n+\n+  return (reg_save_size);\n+}\n+\n+int\n+initial_frame_pointer_offset()\n+{\n+  int frame_size;\n+  int regno;\n+  int offset = 0;\n+  \n+  offset = compute_frame_size (get_frame_size());\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+  return (offset);\n+#else\n+  return (-offset);\n+#endif\n+}\n+\n+/* Generate the minimum number of 1600 core shift instructions\n+   to shift by 'shift_amount'. */\n+\n+#if 0\n+void\n+emit_1600_core_shift (shift_op, operands, shift_amount, mode)\n+enum rtx_code shift_op;\n+rtx *operands;\n+int shift_amount;\n+enum machine_mode mode;\n+{\n+  int quotient;\n+  int i;\n+  int first_shift_emitted = 0;\n+  \n+  while (shift_amount != 0)\n+    {\n+      if (shift_amount/16)\n+\t{\n+\t  quotient = shift_amount/16;\n+\t  shift_amount = shift_amount - (quotient * 16);\n+\t  for (i = 0; i < quotient; i++)\n+\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\tgen_rtx (shift_op, mode, \n+\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n+\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode, 16))));\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/8)\n+\t{\n+\t  quotient = shift_amount/8;\n+\t  shift_amount = shift_amount - (quotient * 8);\n+\t  for (i = 0; i < quotient; i++)\n+\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\tgen_rtx (shift_op, mode, \n+\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n+\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode, 8))));\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/4)\n+\t{\n+\t  quotient = shift_amount/4;\n+\t  shift_amount = shift_amount - (quotient * 4);\n+\t  for (i = 0; i < quotient; i++)\n+\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\tgen_rtx (shift_op, mode, \n+\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n+\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode, 4))));\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/1)\n+\t{\n+\t  quotient = shift_amount/1;\n+\t  shift_amount = shift_amount - (quotient * 1);\n+\t  for (i = 0; i < quotient; i++)\n+\t    emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t\tgen_rtx (shift_op, mode, \n+\t\t\t\t\t first_shift_emitted ? operands[0] : operands[1],\n+\t\t\t\t\t gen_rtx (CONST_INT, VOIDmode, 1))));\n+\t  first_shift_emitted = 1;\n+\t}\n+    }\n+}\n+#else\n+void\n+emit_1600_core_shift (shift_op, operands, shift_amount)\n+enum rtx_code shift_op;\n+rtx *operands;\n+int shift_amount;\n+{\n+  int quotient;\n+  int i;\n+  int first_shift_emitted = 0;\n+  char **shift_asm_ptr;\n+  char **shift_asm_ptr_first;\n+\n+  if (shift_op == ASHIFT)\n+    {\n+      shift_asm_ptr = ashift_left_asm;\n+      shift_asm_ptr_first = ashift_left_asm_first;\n+    }\n+  else if (shift_op == ASHIFTRT)\n+    {\n+      shift_asm_ptr = ashift_right_asm;\n+      shift_asm_ptr_first = ashift_right_asm_first;\n+    }\n+  else if (shift_op == LSHIFTRT)\n+    {\n+      shift_asm_ptr = lshift_right_asm;\n+      shift_asm_ptr_first = lshift_right_asm_first;\n+    }\n+  else\n+    fatal (\"Illegal shift operator in emit_1600_core_shift\");\n+\n+  while (shift_amount != 0)\n+    {\n+      if (shift_amount/16)\n+\t{\n+\t  quotient = shift_amount/16;\n+\t  shift_amount = shift_amount - (quotient * 16);\n+\t  for (i = 0; i < quotient; i++)\n+\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_16]\n+\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_16]), operands);\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/8)\n+\t{\n+\t  quotient = shift_amount/8;\n+\t  shift_amount = shift_amount - (quotient * 8);\n+\t  for (i = 0; i < quotient; i++)\n+\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_8]\n+\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_8]), operands);\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/4)\n+\t{\n+\t  quotient = shift_amount/4;\n+\t  shift_amount = shift_amount - (quotient * 4);\n+\t  for (i = 0; i < quotient; i++)\n+\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_4]\n+\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_4]), operands);\n+\t  first_shift_emitted = 1;\n+\t}\n+      else if (shift_amount/1)\n+\t{\n+\t  quotient = shift_amount/1;\n+\t  shift_amount = shift_amount - (quotient * 1);\n+\t  for (i = 0; i < quotient; i++)\n+\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_1]\n+\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_1]), operands);\n+\t  first_shift_emitted = 1;\n+\t}\n+    }\n+}\n+#endif\n+void\n+  asm_output_common(file, name, size, rounded)\n+FILE *file;\n+char *name;\n+int size;\n+int rounded;\n+{\n+    bss_section ();\n+    ASM_GLOBALIZE_LABEL (file, name);\n+    assemble_name (file, name);\n+    fputs (\":\", file);\n+    if (rounded > 1)\n+\tfprintf (file, \"%d * int\\n\", rounded);\n+    else\n+\tfprintf (file, \"int\\n\");\n+}\n+\n+void\n+asm_output_local(file, name, size, rounded)\n+FILE *file;\n+char *name;\n+int size;\n+int rounded;\n+{\n+    bss_section ();\n+    assemble_name (file, name);\n+    fputs (\":\", file);\n+    if (rounded > 1)\n+\tfprintf (file, \"%d * int\\n\", rounded);\n+    else\n+\tfprintf (file, \"int\\n\");\n+}\n+\n+void\n+asm_output_float (file, fp_const)\n+FILE *file;\n+double fp_const;\n+{\n+#if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n+      REAL_VALUE_TYPE d = fp_const;\n+      long value;\n+\n+      REAL_VALUE_TO_TARGET_SINGLE (d, value);\n+      fputs (\"\\tint \", file);\n+#ifdef WORDS_BIG_ENDIAN\n+      fprintf (file, \"0x%-4.4x, 0x%-4.4x\", (value >> 16) & 0xffff, (value & 0xffff));\n+#else\n+      fprintf (file, \"0x%-4.4x, 0x%-4.4x\", (value & 0xffff), (value >> 16) & 0xffff);\n+#endif\n+      fputs (\"\\n\", file);\n+#else\n+      fatal (\"inline float constants not supported on this host\");\n+#endif\n+}\n+\n+void\n+asm_output_long (file, value)\n+FILE *file;\n+long value;\n+{\n+      fputs (\"\\tint \", file);\n+#ifdef WORDS_BIG_ENDIAN\n+      fprintf (file, \"0x%-4.4x, 0x%-4.4x\", (value >> 16) & 0xffff, (value & 0xffff));\n+#else\n+      fprintf (file, \"0x%-4.4x, 0x%-4.4x\", (value & 0xffff), (value >> 16) & 0xffff);\n+#endif\n+      fputs (\"\\n\", file);\n+}\n+\n+int\n+dsp16xx_address_cost (addr)\n+rtx addr;\n+{\n+    switch (GET_CODE (addr))\n+    {\n+\t  default:\n+\t     break;\n+\n+\t  case REG:\n+\t     return 1;\n+\n+\t  case CONST:\n+\t     {\n+\t        rtx offset = const0_rtx;\n+\t        addr = eliminate_constant_term (addr, &offset);\n+\n+\t        if (GET_CODE (addr) == LABEL_REF)\n+\t            return 2;\n+\n+\t        if (GET_CODE (addr) != SYMBOL_REF)\n+\t            return 4;\n+\n+\t        if (INTVAL (offset) == 0)\n+\t            return 2;\n+             }\n+\t     /* fall through */\n+\n+\t  case POST_INC: case POST_DEC:\n+\t     return (GET_MODE (addr) == QImode ? 1 : 2);\n+\n+\t  case SYMBOL_REF: case LABEL_REF:\n+\t     return 2;\n+\n+\t  case PLUS:\n+\t  {\n+\t     register rtx plus0 = XEXP (addr, 0);\n+\t     register rtx plus1 = XEXP (addr, 1);\n+\t     \n+\t     if (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\n+\t     {\n+\t\t plus0 = XEXP (addr, 1);\n+\t\t plus1 = XEXP (addr, 0);\n+\t     }\n+\t     \n+\t     if (GET_CODE (plus0) != REG)\n+\t\t break;\n+\t     \n+\t     switch (GET_CODE (plus1))\n+\t     {\n+\t\t   default:\n+\t\t      break;\n+\t\t \n+\t\t   case CONST_INT:\n+\t\t      return 4;\n+\n+\t\t   case CONST:\n+\t\t   case SYMBOL_REF:\n+\t\t   case LABEL_REF:\n+\t\t      return dsp16xx_address_cost (plus1) + 1;\n+\t     }\n+\t  }\n+     }\n+\t     \n+     return 4;\n+}\n+\n+\f\n+/* Determine whether a function argument is passed in a register, and\n+   which register.\n+\n+   The arguments are CUM, which summarizes all the previous\n+   arguments; MODE, the machine mode of the argument; TYPE,\n+   the data type of the argument as a tree node or 0 if that is not known\n+   (which happens for C support library functions); and NAMED,\n+   which is 1 for an ordinary argument and 0 for nameless arguments that\n+   correspond to `...' in the called function's prototype.\n+\n+   The value of the expression should either be a `reg' RTX for the\n+   hard register in which to pass the argument, or zero to pass the\n+   argument on the stack.\n+\n+   On the dsp1610 the first four words of args are normally in registers\n+   and the rest are pushed. If we a long or on float mode, the argument\n+   must begin on a even register boundary\n+\n+   Note that FUNCTION_ARG and FUNCTION_INCOMING_ARG were different.\n+   For structures that are passed in memory, but could have been\n+   passed in registers, we first load the structure into the\n+   register, and then when the last argument is passed, we store\n+   the registers into the stack locations.  This fixes some bugs\n+   where GCC did not expect to have register arguments, followed */\n+\n+\n+struct rtx_def *\n+dsp16xx_function_arg (args_so_far, mode, type, named)\n+     CUMULATIVE_ARGS args_so_far;\n+     enum machine_mode mode;\n+     tree type;\n+     int named;\n+{\n+  if (TARGET_REGPARM)\n+    {\n+      if ((args_so_far & 1) != 0\n+\t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n+\targs_so_far++;\n+\n+      if (named && args_so_far < 4 && !MUST_PASS_IN_STACK (mode,type))\n+\treturn gen_rtx (REG, mode, args_so_far + FIRST_REG_FOR_FUNCTION_ARG);\n+      else\n+\treturn (struct rtx_def *) 0;\n+    }\n+  else\n+    return (struct rtx_def *) 0;\n+}\n+\n+/* Advance the argument to the next argument position.  */\n+\n+void\n+dsp16xx_function_arg_advance (cum, mode, type, named)\n+     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     enum machine_mode mode;\t/* current arg mode */\n+     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+     int named;\t\t\t/* whether or not the argument was named */\n+{\n+  if (TARGET_REGPARM)\n+    {\n+      if ((*cum & 1) != 0\n+\t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n+\t*cum += 1;\n+\n+      if (mode != BLKmode)\n+\t*cum += GET_MODE_SIZE (mode);\n+      else\n+\t*cum += int_size_in_bytes (type);\n+    }\n+}\n+\n+void\n+dsp16xx_file_start ()\n+{\n+  fprintf (asm_out_file, \"#include <%s.h>\\n\", save_chip_name);\n+#if 0\n+\tif (TARGET_BMU)\n+\t\tfprintf (asm_out_file, \"#include <1610.h>\\n\");\n+#endif\n+}\n+\n+rtx\n+gen_tst_reg (x)\n+     rtx x;\n+{\n+  enum machine_mode mode;\n+\n+  mode = GET_MODE (x);\n+\n+  if (mode == QImode)\n+    {\n+\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\tgen_rtvec (2,\n+\t\t\t\t   gen_rtx (SET, VOIDmode, cc0_rtx, x),\n+\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)))));\n+\t}\n+  else if (mode == HImode)\n+    emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, x));\n+  else\n+    fatal (\"Illegal mode for gen_tst_reg\");\n+\n+  return cc0_rtx;\n+}\n+\n+rtx\n+gen_compare_reg (code, x, y)\n+     enum rtx_code code;\n+     rtx x, y;\n+{\n+  enum machine_mode mode;\n+\n+  mode = GET_MODE (x);\n+  /* For floating point compare insns, a call is generated so don't\n+     do anything here. */\n+\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return cc0_rtx;\n+\n+  if (mode == QImode)\n+    {\n+      if (code == GTU || code == GEU ||\n+\t  code == LTU || code == LEU)\n+\t{\n+\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\tgen_rtvec (3,\n+\t\t\t\t   gen_rtx (SET, VOIDmode, cc0_rtx,\n+\t\t\t\t\t    gen_rtx (COMPARE, mode, x, y)),\n+\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)),\n+\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)))));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_rtx (PARALLEL, VOIDmode,\n+\t\t\tgen_rtvec (3,\n+\t\t\t\t   gen_rtx (SET, VOIDmode, cc0_rtx,\n+\t\t\t\t\t    gen_rtx (COMPARE, mode, x, y)),\n+\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)),\n+\t\t\t\t   gen_rtx (CLOBBER, VOIDmode,\n+\t\t\t\t\t    gen_rtx (SCRATCH, QImode, 0)))));\n+\t}\n+    }\n+  else if (mode == HImode)\n+    {\n+      if (code == GTU || code == GEU ||\n+\t  code == LTU || code == LEU)\n+\t{\n+#if 1\n+\t  emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (5,\n+\t\t\t     gen_rtx (SET, VOIDmode, cc0_rtx, gen_rtx (COMPARE, VOIDmode, x, y)),\n+\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)),\n+\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)),\n+\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)),\n+\t\t             gen_rtx (CLOBBER, VOIDmode, gen_rtx (SCRATCH, QImode, 0)))));\n+#else\n+\t  if (!dsp16xx_ucmphi2_libcall)\n+\t    dsp16xx_ucmphi2_libcall = gen_rtx (SYMBOL_REF, Pmode, UCMPHI2_LIBCALL);\n+\t  emit_library_call (dsp16xx_ucmphi2_libcall, 1, HImode, 2,\n+\t\t\t     x, HImode, y, HImode);\n+\t  emit_insn (gen_tsthi_1 (copy_to_reg(hard_libcall_value (HImode))));\n+#endif\n+\t}\n+      else\n+\temit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,\n+\t\t\t    gen_rtx (COMPARE, VOIDmode, force_reg(HImode, x), \n+\t\t\t\t     force_reg(HImode,y))));\n+    }\n+  else\n+    fatal (\"Illegal mode for integer comparison in gen_compare_reg\");\n+\n+  return cc0_rtx;\n+}\n+\n+char *\n+output_block_move (operands)\n+     rtx operands[];\n+{\n+  int loop_count = INTVAL(operands[2]);\n+  rtx xoperands[4];\n+\n+  fprintf (asm_out_file, \"\\tdo %d {\\n\", loop_count);\n+  xoperands[0] = operands[4];\n+  xoperands[1] = operands[1];\n+  output_asm_insn (\"%0=*%1++\", xoperands);\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = operands[4];\n+  output_asm_insn (\"*%0++=%1\", xoperands);\n+\n+  fprintf (asm_out_file, \"\\t}\\n\");\n+  return \"\";\n+}"}]}