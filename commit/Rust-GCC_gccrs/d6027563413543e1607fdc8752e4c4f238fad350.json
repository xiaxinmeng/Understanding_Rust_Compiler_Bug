{"sha": "d6027563413543e1607fdc8752e4c4f238fad350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwMjc1NjM0MTM1NDNlMTYwN2ZkYzg3NTJlNGM0ZjIzOGZhZDM1MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-10-02T21:45:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-10-02T21:45:01Z"}, "message": "re PR c++/35722 ([C++0x] Variadic templates expansion into non-variadic class template)\n\n\tPR c++/35722\n\tImplement N2555 (expanding pack expansion to fixed parm list)\n\t* pt.c (coerce_template_parms): Allow expanding a pack expansion\n\tto a fixed-length argument list.\n\t(unify_pack_expansion): Handle explicit args properly.\n\t(unify) [TREE_VEC]: Handle pack expansions here.\n\t[TYPE_ARGUMENT_PACK]: Not here.\n\t(tsubst_pack_expansion): Don't try to do partial substitution.\n\t(pack_deducible_p): New.\n\t(fn_type_unification): Use it.\n\t(find_parameter_packs_r): Take the TYPE_MAIN_VARIANT\n\tof a type parameter.\n\t(check_non_deducible_conversion): Split from type_unification_real.\n\t(unify_one_argument): Split from type_unification_real...\n\t(unify_pack_expansion): ...and here.  Drop call_args_p parm.\n\t(type_unification_real, unify, more_specialized_fn): Adjust.\n\nFrom-SVN: r179436", "tree": {"sha": "b61148189571cf1915a392bca2875a7a41bc9a61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b61148189571cf1915a392bca2875a7a41bc9a61"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6027563413543e1607fdc8752e4c4f238fad350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6027563413543e1607fdc8752e4c4f238fad350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6027563413543e1607fdc8752e4c4f238fad350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6027563413543e1607fdc8752e4c4f238fad350/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f10eaa2dcc0081c7abbc326b500b84e03f777d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f10eaa2dcc0081c7abbc326b500b84e03f777d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f10eaa2dcc0081c7abbc326b500b84e03f777d05"}], "stats": {"total": 709, "additions": 379, "deletions": 330}, "files": [{"sha": "9bcec3274e02cc1d55731b54bf5b026f21a6284d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -1,5 +1,22 @@\n 2011-10-02  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/35722\n+\tImplement N2555 (expanding pack expansion to fixed parm list)\n+\t* pt.c (coerce_template_parms): Allow expanding a pack expansion\n+\tto a fixed-length argument list.\n+\t(unify_pack_expansion): Handle explicit args properly.\n+\t(unify) [TREE_VEC]: Handle pack expansions here.\n+\t[TYPE_ARGUMENT_PACK]: Not here.\n+\t(tsubst_pack_expansion): Don't try to do partial substitution.\n+\t(pack_deducible_p): New.\n+\t(fn_type_unification): Use it.\n+\t(find_parameter_packs_r): Take the TYPE_MAIN_VARIANT\n+\tof a type parameter.\n+\t(check_non_deducible_conversion): Split from type_unification_real.\n+\t(unify_one_argument): Split from type_unification_real...\n+\t(unify_pack_expansion): ...and here.  Drop call_args_p parm.\n+\t(type_unification_real, unify, more_specialized_fn): Adjust.\n+\n \t* class.c (fixed_type_or_null): Handle NSDMI.\n \t* method.c (walk_field_subobs): Disable NSDMI noexcept checking\n \tfor now."}, {"sha": "015ee3777070cb6b65f3a7e07c59bbc44a4fd0a2", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 289, "deletions": 317, "changes": 606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -165,7 +165,7 @@ static int template_decl_level (tree);\n static int check_cv_quals_for_unify (int, tree, tree);\n static void template_parm_level_and_index (tree, int*, int*);\n static int unify_pack_expansion (tree, tree, tree,\n-\t\t\t\t tree, int, bool, bool, bool);\n+\t\t\t\t tree, unification_kind_t, bool, bool);\n static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n@@ -2961,6 +2961,7 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n+      t = TYPE_MAIN_VARIANT (t);\n     case TEMPLATE_TEMPLATE_PARM:\n       if (TEMPLATE_TYPE_PARAMETER_PACK (t))\n         parameter_pack_p = true;\n@@ -6741,22 +6742,10 @@ coerce_template_parms (tree parms,\n \t{\n           if (PACK_EXPANSION_P (arg))\n             {\n-\t      if (complain & tf_error)\n-\t\t{\n-\t\t  /* FIXME this restriction was removed by N2555; see\n-\t\t     bug 35722.  */\n-\t\t  /* If ARG is a pack expansion, but PARM is not a\n-\t\t     template parameter pack (if it were, we would have\n-\t\t     handled it above), we're trying to expand into a\n-\t\t     fixed-length argument list.  */\n-\t\t  if (TREE_CODE (arg) == EXPR_PACK_EXPANSION)\n-\t\t    sorry (\"cannot expand %<%E%> into a fixed-length \"\n-\t\t\t   \"argument list\", arg);\n-\t\t  else\n-\t\t    sorry (\"cannot expand %<%T%> into a fixed-length \"\n-\t\t\t   \"argument list\", arg);\n-\t\t}\n-\t      ++lost;\n+              /* We don't know how many args we have yet, just\n+                 use the unconverted ones for now.  */\n+              new_inner_args = args;\n+              break;\n             }\n         }\n       else if (require_all_args)\n@@ -9116,7 +9105,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n   tree pack, packs = NULL_TREE, unsubstituted_packs = NULL_TREE;\n   int i, len = -1;\n   tree result;\n-  int incomplete = 0;\n   htab_t saved_local_specializations = NULL;\n \n   gcc_assert (PACK_EXPANSION_P (t));\n@@ -9189,21 +9177,15 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n           int my_len = \n             TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg_pack));\n \n-          /* It's all-or-nothing with incomplete argument packs.  */\n-          if (incomplete && !ARGUMENT_PACK_INCOMPLETE_P (arg_pack))\n-            return error_mark_node;\n-          \n+\t  /* Don't bother trying to do a partial substitution with\n+\t     incomplete packs; we'll try again after deduction.  */\n           if (ARGUMENT_PACK_INCOMPLETE_P (arg_pack))\n-            incomplete = 1;\n+            return t;\n \n           if (len < 0)\n \t    len = my_len;\n           else if (len != my_len)\n             {\n-\t      if (incomplete)\n-\t\t/* We got explicit args for some packs but not others;\n-\t\t   do nothing now and try again after deduction.  */\n-\t\treturn t;\n               if (TREE_CODE (t) == TYPE_PACK_EXPANSION)\n                 error (\"mismatched argument pack lengths while expanding \"\n                        \"%<%T%>\",\n@@ -9261,8 +9243,8 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \n   /* For each argument in each argument pack, substitute into the\n      pattern.  */\n-  result = make_tree_vec (len + incomplete);\n-  for (i = 0; i < len + incomplete; ++i)\n+  result = make_tree_vec (len);\n+  for (i = 0; i < len; ++i)\n     {\n       /* For parameter pack, change the substitution of the parameter\n          pack to the ith argument in its argument pack, then expand\n@@ -9307,13 +9289,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       else\n         TREE_VEC_ELT (result, i) = tsubst (pattern, args, complain, in_decl);\n \n-      if (i == len)\n-        /* When we have incomplete argument packs, the last \"expanded\"\n-           result is itself a pack expansion, which allows us\n-           to deduce more arguments.  */\n-        TREE_VEC_ELT (result, i) = \n-          make_pack_expansion (TREE_VEC_ELT (result, i));\n-\n       if (TREE_VEC_ELT (result, i) == error_mark_node)\n \t{\n \t  result = error_mark_node;\n@@ -14289,6 +14264,40 @@ pop_deduction_access_scope (tree tmpl)\n     pop_deferring_access_checks ();\n }\n \n+/* PARM is a template parameter pack for FN.  Returns true iff\n+   PARM is used in a deducible way in the argument list of FN.  */\n+\n+static bool\n+pack_deducible_p (tree parm, tree fn)\n+{\n+  tree t = FUNCTION_FIRST_USER_PARMTYPE (fn);\n+  for (; t; t = TREE_CHAIN (t))\n+    {\n+      tree type = TREE_VALUE (t);\n+      tree packs;\n+      if (!PACK_EXPANSION_P (type))\n+\tcontinue;\n+      for (packs = PACK_EXPANSION_PARAMETER_PACKS (type);\n+\t   packs; packs = TREE_CHAIN (packs))\n+\tif (TREE_VALUE (packs) == parm)\n+\t  {\n+\t    /* The template parameter pack is used in a function parameter\n+\t       pack.  If this is the end of the parameter list, the\n+\t       template parameter pack is deducible.  */\n+\t    if (TREE_CHAIN (t) == void_list_node)\n+\t      return true;\n+\t    else\n+\t      /* Otherwise, not.  Well, it could be deduced from\n+\t\t a non-pack parameter, but doing so would end up with\n+\t\t a deduction mismatch, so don't bother.  */\n+\t      return false;\n+\t  }\n+    }\n+  /* The template parameter pack isn't used in any function parameter\n+     packs, but it might be used deeper, e.g. tuple<Args...>.  */\n+  return true;\n+}\n+\n /* The FN is a TEMPLATE_DECL for a function.  ARGS is an array with\n    NARGS elements of the arguments that are being used when calling\n    it.  TARGS is a vector into which the deduced template arguments\n@@ -14334,7 +14343,6 @@ fn_type_unification (tree fn,\n   tree parms;\n   tree fntype;\n   int result;\n-  bool incomplete_argument_packs_p = false;\n \n   gcc_assert (TREE_CODE (fn) == TEMPLATE_DECL);\n \n@@ -14386,6 +14394,7 @@ fn_type_unification (tree fn,\n         {\n           tree parm = TREE_VALUE (TREE_VEC_ELT (tparms, i));\n           bool parameter_pack = false;\n+\t  tree targ = TREE_VEC_ELT (converted_args, i);\n \n           /* Dig out the actual parm.  */\n           if (TREE_CODE (parm) == TYPE_DECL\n@@ -14400,16 +14409,15 @@ fn_type_unification (tree fn,\n               parameter_pack = TEMPLATE_PARM_PARAMETER_PACK (parm);\n             }\n \n-          if (parameter_pack)\n-            {\n-              int level, idx;\n-              tree targ;\n-              template_parm_level_and_index (parm, &level, &idx);\n+\t  if (!parameter_pack && targ == NULL_TREE)\n+\t    /* No explicit argument for this template parameter.  */\n+\t    incomplete = true;\n \n+          if (parameter_pack && pack_deducible_p (parm, fn))\n+            {\n               /* Mark the argument pack as \"incomplete\". We could\n                  still deduce more arguments during unification.\n \t         We remove this mark in type_unification_real.  */\n-              targ = TMPL_ARG (converted_args, level, idx);\n               if (targ)\n                 {\n                   ARGUMENT_PACK_INCOMPLETE_P(targ) = 1;\n@@ -14418,18 +14426,10 @@ fn_type_unification (tree fn,\n                 }\n \n               /* We have some incomplete argument packs.  */\n-              incomplete_argument_packs_p = true;\n+              incomplete = true;\n             }\n         }\n \n-      if (incomplete_argument_packs_p)\n-        /* Any substitution is guaranteed to be incomplete if there\n-           are incomplete argument packs, because we can still deduce\n-           more arguments.  */\n-        incomplete = 1;\n-      else\n-        incomplete = NUM_TMPL_ARGS (explicit_targs) != NUM_TMPL_ARGS (targs);\n-\n       processing_template_decl += incomplete;\n       fntype = deduction_tsubst_fntype (fn, converted_args,\n \t\t\t\t\t(explain_p\n@@ -14643,6 +14643,134 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n   return result;\n }\n \n+/* Subroutine of unify_one_argument.  PARM is a function parameter of a\n+   template which does contain any deducible template parameters; check if\n+   ARG is a suitable match for it.  STRICT, FLAGS and EXPLAIN_P are as in\n+   unify_one_argument.  */\n+\n+static int\n+check_non_deducible_conversion (tree parm, tree arg, int strict,\n+\t\t\t\tint flags, bool explain_p)\n+{\n+  tree type;\n+\n+  if (!TYPE_P (arg))\n+    type = TREE_TYPE (arg);\n+  else\n+    type = arg;\n+\n+  if (same_type_p (parm, type))\n+    return unify_success (explain_p);\n+\n+  if (strict == DEDUCE_CONV)\n+    {\n+      if (can_convert_arg (type, parm, NULL_TREE, flags))\n+\treturn unify_success (explain_p);\n+    }\n+  else if (strict != DEDUCE_EXACT)\n+    {\n+      if (can_convert_arg (parm, type,\n+\t\t\t   TYPE_P (arg) ? NULL_TREE : arg,\n+\t\t\t   flags))\n+\treturn unify_success (explain_p);\n+    }\n+\n+  if (strict == DEDUCE_EXACT)\n+    return unify_type_mismatch (explain_p, parm, arg);\n+  else\n+    return unify_arg_conversion (explain_p, parm, type, arg);\n+}\n+\n+/* Subroutine of type_unification_real and unify_pack_expansion to\n+   handle unification of a single P/A pair.  Parameters are as\n+   for those functions.  */\n+\n+static int\n+unify_one_argument (tree tparms, tree targs, tree parm, tree arg,\n+\t\t    int subr, unification_kind_t strict, int flags,\n+\t\t    bool explain_p)\n+{\n+  tree arg_expr = NULL_TREE;\n+  int arg_strict;\n+\n+  if (arg == error_mark_node || parm == error_mark_node)\n+    return unify_invalid (explain_p);\n+  if (arg == unknown_type_node)\n+    /* We can't deduce anything from this, but we might get all the\n+       template args from other function args.  */\n+    return unify_success (explain_p);\n+\n+  /* FIXME uses_deducible_template_parms */\n+  if (TYPE_P (parm) && !uses_template_parms (parm))\n+    return check_non_deducible_conversion (parm, arg, strict, flags,\n+\t\t\t\t\t   explain_p);\n+\n+  switch (strict)\n+    {\n+    case DEDUCE_CALL:\n+      arg_strict = (UNIFY_ALLOW_OUTER_LEVEL\n+\t\t    | UNIFY_ALLOW_MORE_CV_QUAL\n+\t\t    | UNIFY_ALLOW_DERIVED);\n+      break;\n+\n+    case DEDUCE_CONV:\n+      arg_strict = UNIFY_ALLOW_LESS_CV_QUAL;\n+      break;\n+\n+    case DEDUCE_EXACT:\n+      arg_strict = UNIFY_ALLOW_NONE;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* We only do these transformations if this is the top-level\n+     parameter_type_list in a call or declaration matching; in other\n+     situations (nested function declarators, template argument lists) we\n+     won't be comparing a type to an expression, and we don't do any type\n+     adjustments.  */\n+  if (!subr)\n+    {\n+      if (!TYPE_P (arg))\n+\t{\n+\t  gcc_assert (TREE_TYPE (arg) != NULL_TREE);\n+\t  if (type_unknown_p (arg))\n+\t    {\n+\t      /* [temp.deduct.type] A template-argument can be\n+\t\t deduced from a pointer to function or pointer\n+\t\t to member function argument if the set of\n+\t\t overloaded functions does not contain function\n+\t\t templates and at most one of a set of\n+\t\t overloaded functions provides a unique\n+\t\t match.  */\n+\n+\t      if (resolve_overloaded_unification\n+\t\t  (tparms, targs, parm, arg, strict,\n+\t\t   arg_strict, explain_p))\n+\t\treturn unify_success (explain_p);\n+\t      return unify_overload_resolution_failure (explain_p, arg);\n+\t    }\n+\n+\t  arg_expr = arg;\n+\t  arg = unlowered_expr_type (arg);\n+\t  if (arg == error_mark_node)\n+\t    return unify_invalid (explain_p);\n+\t}\n+\n+      arg_strict |=\n+\tmaybe_adjust_types_for_deduction (strict, &parm, &arg, arg_expr);\n+    }\n+  else\n+    gcc_assert ((TYPE_P (parm) || TREE_CODE (parm) == TEMPLATE_DECL)\n+\t\t== (TYPE_P (arg) || TREE_CODE (arg) == TEMPLATE_DECL));\n+\n+  /* For deduction from an init-list we need the actual list.  */\n+  if (arg_expr && BRACE_ENCLOSED_INITIALIZER_P (arg_expr))\n+    arg = arg_expr;\n+  return unify (tparms, targs, parm, arg, arg_strict, explain_p);\n+}\n+\n /* Most parms like fn_type_unification.\n \n    If SUBR is 1, we're being called recursively (to unify the\n@@ -14660,10 +14788,9 @@ type_unification_real (tree tparms,\n \t\t       int flags,\n \t\t       bool explain_p)\n {\n-  tree parm, arg, arg_expr;\n+  tree parm, arg;\n   int i;\n   int ntparms = TREE_VEC_LENGTH (tparms);\n-  int sub_strict;\n   int saw_undeduced = 0;\n   tree parms;\n   const tree *args;\n@@ -14678,25 +14805,6 @@ type_unification_real (tree tparms,\n      in TARGS.  */\n   NON_DEFAULT_TEMPLATE_ARGS_COUNT (targs) = NULL_TREE;\n \n-  switch (strict)\n-    {\n-    case DEDUCE_CALL:\n-      sub_strict = (UNIFY_ALLOW_OUTER_LEVEL | UNIFY_ALLOW_MORE_CV_QUAL\n-\t\t    | UNIFY_ALLOW_DERIVED);\n-      break;\n-\n-    case DEDUCE_CONV:\n-      sub_strict = UNIFY_ALLOW_LESS_CV_QUAL;\n-      break;\n-\n-    case DEDUCE_EXACT:\n-      sub_strict = UNIFY_ALLOW_NONE;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n  again:\n   parms = xparms;\n   args = xargs;\n@@ -14726,90 +14834,12 @@ type_unification_real (tree tparms,\n \n       arg = args[ia];\n       ++ia;\n-      arg_expr = NULL;\n-\n-      if (arg == error_mark_node)\n-\treturn unify_invalid (explain_p);\n-      if (arg == unknown_type_node)\n-\t/* We can't deduce anything from this, but we might get all the\n-\t   template args from other function args.  */\n-\tcontinue;\n-\n-      /* Conversions will be performed on a function argument that\n-\t corresponds with a function parameter that contains only\n-\t non-deducible template parameters and explicitly specified\n-\t template parameters.  */\n-      if (!uses_template_parms (parm))\n-\t{\n-\t  tree type;\n \n-\t  if (!TYPE_P (arg))\n-\t    type = TREE_TYPE (arg);\n-\t  else\n-\t    type = arg;\n-\n-\t  if (same_type_p (parm, type))\n-\t    continue;\n-\t  if (strict == DEDUCE_CONV)\n-\t    {\n-\t      if (can_convert_arg (type, parm, NULL_TREE, flags))\n-\t\tcontinue;\n-\t    }\n-\t  else if (strict != DEDUCE_EXACT)\n-\t    {\n-\t      if (can_convert_arg (parm, type,\n-\t\t\t\t   TYPE_P (arg) ? NULL_TREE : arg,\n-\t\t\t\t   flags))\n-\t\tcontinue;\n-\t    }\n-\n-\t  if (strict == DEDUCE_EXACT)\n-\t    return unify_type_mismatch (explain_p, parm, arg);\n-\t  else\n-\t    return unify_arg_conversion (explain_p, parm, type, arg);\n-\t}\n-\n-      if (!TYPE_P (arg))\n-\t{\n-\t  gcc_assert (TREE_TYPE (arg) != NULL_TREE);\n-\t  if (type_unknown_p (arg))\n-\t    {\n-\t      /* [temp.deduct.type] \n-\n-\t         A template-argument can be deduced from a pointer to\n-\t\t function or pointer to member function argument if\n-\t\t the set of overloaded functions does not contain\n-\t\t function templates and at most one of a set of\n-\t\t overloaded functions provides a unique match.  */\n-\t      if (resolve_overloaded_unification\n-\t\t  (tparms, targs, parm, arg, strict, sub_strict, explain_p))\n-\t\tcontinue;\n-\n-\t      return unify_overload_resolution_failure (explain_p, arg);\n-\t    }\n-\t  arg_expr = arg;\n-\t  arg = unlowered_expr_type (arg);\n-\t  if (arg == error_mark_node)\n-\t    return unify_invalid (explain_p);\n-\t}\n-\n-      {\n-\tint arg_strict = sub_strict;\n-\n-\tif (!subr)\n-\t  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg,\n-\t\t\t\t\t\t\t  arg_expr);\n-\n-\tif (arg == init_list_type_node && arg_expr)\n-\t  arg = arg_expr;\n-\tif (unify (tparms, targs, parm, arg, arg_strict, explain_p))\n-\t  /* If unification failed, the recursive call will have updated\n-\t     UI appropriately.  */\n-\t  return 1;\n-      }\n+      if (unify_one_argument (tparms, targs, parm, arg, subr, strict,\n+\t\t\t      flags, explain_p))\n+\treturn 1;\n     }\n \n-\n   if (parms \n       && parms != void_list_node\n       && TREE_CODE (TREE_VALUE (parms)) == TYPE_PACK_EXPANSION)\n@@ -14826,7 +14856,7 @@ type_unification_real (tree tparms,\n       /* Copy the parameter into parmvec.  */\n       TREE_VEC_ELT (parmvec, 0) = TREE_VALUE (parms);\n       if (unify_pack_expansion (tparms, targs, parmvec, argvec, strict,\n-                                /*call_args_p=*/true, /*subr=*/subr, explain_p))\n+                                /*subr=*/subr, explain_p))\n         return 1;\n \n       /* Advance to the end of the list of parameters.  */\n@@ -15461,10 +15491,12 @@ template_parm_level_and_index (tree parm, int* level, int* index)\n    unify. CALL_ARGS_P is true iff PACKED_ARGS is actually a function\n    call argument list. We'll need to adjust the arguments to make them\n    types. SUBR tells us if this is from a recursive call to\n-   type_unification_real.  */\n+   type_unification_real, or for comparing two template argument\n+   lists. */\n+\n static int\n unify_pack_expansion (tree tparms, tree targs, tree packed_parms, \n-                      tree packed_args, int strict, bool call_args_p,\n+                      tree packed_args, unification_kind_t strict,\n                       bool subr, bool explain_p)\n {\n   tree parm \n@@ -15495,92 +15527,56 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n      unified and unify each with the pattern.  */\n   for (i = start; i < len; i++)\n     {\n-      tree parm = pattern;\n+      tree parm;\n+      bool any_explicit = false;\n+      tree arg = TREE_VEC_ELT (packed_args, i);\n \n-      /* For each parameter pack, clear out the deduced value so that\n-         we can deduce it again.  */\n+      /* For each parameter pack, set its TMPL_ARG to either NULL_TREE\n+\t or the element of its argument pack at the current index if\n+\t this argument was explicitly specified.  */\n       for (pack = packs; pack; pack = TREE_CHAIN (pack))\n         {\n           int idx, level;\n+          tree arg, pargs;\n           template_parm_level_and_index (TREE_PURPOSE (pack), &level, &idx);\n \n-          TMPL_ARG (targs, level, idx) = NULL_TREE;\n+          arg = NULL_TREE;\n+          if (TREE_VALUE (pack)\n+              && (pargs = ARGUMENT_PACK_EXPLICIT_ARGS (TREE_VALUE (pack)))\n+              && (i < TREE_VEC_LENGTH (pargs)))\n+            {\n+              any_explicit = true;\n+              arg = TREE_VEC_ELT (pargs, i);\n+            }\n+          TMPL_ARG (targs, level, idx) = arg;\n         }\n \n-      /* Unify the pattern with the current argument.  */\n-      {\n-        tree arg = TREE_VEC_ELT (packed_args, i);\n-\ttree arg_expr = NULL_TREE;\n-        int arg_strict = strict;\n-\n-        if (call_args_p)\n-          {\n-            int sub_strict;\n-\n-            /* This mirrors what we do in type_unification_real.  */\n-            switch (strict)\n-              {\n-              case DEDUCE_CALL:\n-                sub_strict = (UNIFY_ALLOW_OUTER_LEVEL \n-                              | UNIFY_ALLOW_MORE_CV_QUAL\n-                              | UNIFY_ALLOW_DERIVED);\n-                break;\n-                \n-              case DEDUCE_CONV:\n-                sub_strict = UNIFY_ALLOW_LESS_CV_QUAL;\n-                break;\n-                \n-              case DEDUCE_EXACT:\n-                sub_strict = UNIFY_ALLOW_NONE;\n-                break;\n-                \n-              default:\n-                gcc_unreachable ();\n-              }\n-\n-            if (!TYPE_P (arg))\n-              {\n-                gcc_assert (TREE_TYPE (arg) != NULL_TREE);\n-                if (type_unknown_p (arg))\n-                  {\n-                    /* [temp.deduct.type] A template-argument can be\n-                       deduced from a pointer to function or pointer\n-                       to member function argument if the set of\n-                       overloaded functions does not contain function\n-                       templates and at most one of a set of\n-                       overloaded functions provides a unique\n-                       match.  */\n-\n-                    if (resolve_overloaded_unification\n-                        (tparms, targs, parm, arg,\n-\t\t\t (unification_kind_t) strict,\n-\t\t\t sub_strict, explain_p))\n-\t\t      goto unified;\n-\t\t    return unify_overload_resolution_failure (explain_p, arg);\n-                  }\n-\n-\t\targ_expr = arg;\n-\t\targ = unlowered_expr_type (arg);\n-\t\tif (arg == error_mark_node)\n-\t\t  return unify_invalid (explain_p);\n-              }\n-      \n-            arg_strict = sub_strict;\n-\n-            if (!subr)\n-              arg_strict |= \n-                maybe_adjust_types_for_deduction ((unification_kind_t) strict,\n-\t\t\t\t\t\t  &parm, &arg, arg_expr);\n-          }\n+      /* If we had explicit template arguments, substitute them into the\n+\t pattern before deduction.  */\n+      if (any_explicit)\n+\t{\n+\t  /* Some arguments might still be unspecified or dependent.  */\n+\t  bool dependent;\n+\t  ++processing_template_decl;\n+\t  dependent = any_dependent_template_arguments_p (targs);\n+\t  if (!dependent)\n+\t    --processing_template_decl;\n+\t  parm = tsubst (pattern, targs,\n+\t\t\t explain_p ? tf_warning_or_error : tf_none,\n+\t\t\t NULL_TREE);\n+\t  if (dependent)\n+\t    --processing_template_decl;\n+\t  if (parm == error_mark_node)\n+\t    return 1;\n+\t}\n+      else\n+\tparm = pattern;\n \n-\t/* For deduction from an init-list we need the actual list.  */\n-\tif (arg_expr && BRACE_ENCLOSED_INITIALIZER_P (arg_expr))\n-\t  arg = arg_expr;\n-\tRECUR_AND_CHECK_FAILURE (tparms, targs, parm, arg, arg_strict,\n-\t\t\t\t explain_p);\n-      }\n+      /* Unify the pattern with the current argument.  */\n+      if (unify_one_argument (tparms, targs, parm, arg, subr, strict,\n+\t\t\t      LOOKUP_IMPLICIT, explain_p))\n+\treturn 1;\n \n-    unified:\n       /* For each parameter pack, collect the deduced value.  */\n       for (pack = packs; pack; pack = TREE_CHAIN (pack))\n         {\n@@ -15619,21 +15615,12 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \n       if (old_pack && ARGUMENT_PACK_INCOMPLETE_P (old_pack))\n         {\n-          /* Prepend the explicit arguments onto NEW_ARGS.  */\n+          /* If we had fewer function args than explicit template args,\n+             just use the explicits.  */\n           tree explicit_args = ARGUMENT_PACK_EXPLICIT_ARGS (old_pack);\n-          tree old_args = new_args;\n-          int i, explicit_len = TREE_VEC_LENGTH (explicit_args);\n-          int len = explicit_len + TREE_VEC_LENGTH (old_args);\n-\n-          /* Copy the explicit arguments.  */\n-          new_args = make_tree_vec (len);\n-          for (i = 0; i < explicit_len; i++)\n-            TREE_VEC_ELT (new_args, i) = TREE_VEC_ELT (explicit_args, i);\n-\n-          /* Copy the deduced arguments.  */\n-          for (; i < len; i++)\n-            TREE_VEC_ELT (new_args, i) =\n-              TREE_VEC_ELT (old_args, i - explicit_len);\n+          int explicit_len = TREE_VEC_LENGTH (explicit_args);\n+          if (len < explicit_len)\n+            new_args = explicit_args;\n         }\n \n       if (!old_pack)\n@@ -15961,9 +15948,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t    if (parm_variadic_p\n \t\t&& unify_pack_expansion (tparms, targs,\n \t\t\t\t\t parmvec, argvec,\n-\t\t\t\t\t UNIFY_ALLOW_NONE,\n-\t\t\t\t\t /*call_args_p=*/false,\n-\t\t\t\t\t /*subr=*/false, explain_p))\n+\t\t\t\t\t DEDUCE_EXACT,\n+\t\t\t\t\t /*subr=*/true, explain_p))\n \t      return 1;\n \t  }\n \t  arg = TYPE_TI_TEMPLATE (arg);\n@@ -16253,17 +16239,55 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n     case TREE_VEC:\n       {\n-\tint i;\n+\tint i, len, argslen;\n+\tint parm_variadic_p = 0;\n+\n \tif (TREE_CODE (arg) != TREE_VEC)\n \t  return unify_template_argument_mismatch (explain_p, parm, arg);\n-\tif (TREE_VEC_LENGTH (parm) != TREE_VEC_LENGTH (arg))\n-\t  return unify_arity (explain_p, TREE_VEC_LENGTH (arg),\n-\t\t\t      TREE_VEC_LENGTH (parm));\n-\tfor (i = 0; i < TREE_VEC_LENGTH (parm); ++i)\n-\t  RECUR_AND_CHECK_FAILURE (tparms, targs,\n-\t\t\t\t   TREE_VEC_ELT (parm, i),\n-\t\t\t\t   TREE_VEC_ELT (arg, i),\n-\t\t\t\t   UNIFY_ALLOW_NONE, explain_p);\n+\n+\tlen = TREE_VEC_LENGTH (parm);\n+\targslen = TREE_VEC_LENGTH (arg);\n+\n+\t/* Check for pack expansions in the parameters.  */\n+\tfor (i = 0; i < len; ++i)\n+\t  {\n+\t    if (PACK_EXPANSION_P (TREE_VEC_ELT (parm, i)))\n+\t      {\n+\t\tif (i == len - 1)\n+\t\t  /* We can unify against something with a trailing\n+\t\t     parameter pack.  */\n+\t\t  parm_variadic_p = 1;\n+\t\telse\n+\t\t  /* [temp.deduct.type]/9: If the template argument list of\n+\t\t     P contains a pack expansion that is not the last\n+\t\t     template argument, the entire template argument list\n+\t\t     is a non-deduced context.  */\n+\t\t  return unify_success (explain_p);\n+\t      }\n+\t  }\n+\n+        /* If we don't have enough arguments to satisfy the parameters\n+           (not counting the pack expression at the end), or we have\n+           too many arguments for a parameter list that doesn't end in\n+           a pack expression, we can't unify.  */\n+\tif (parm_variadic_p\n+\t    ? argslen < len - parm_variadic_p\n+\t    : argslen != len)\n+\t  return unify_arity (explain_p, TREE_VEC_LENGTH (arg), len);\n+\n+\t/* Unify all of the parameters that precede the (optional)\n+\t   pack expression.  */\n+\tfor (i = 0; i < len - parm_variadic_p; ++i)\n+\t  {\n+\t    RECUR_AND_CHECK_FAILURE (tparms, targs,\n+\t\t\t\t     TREE_VEC_ELT (parm, i),\n+\t\t\t\t     TREE_VEC_ELT (arg, i),\n+\t\t\t\t     UNIFY_ALLOW_NONE, explain_p);\n+\t  }\n+\tif (parm_variadic_p)\n+\t  return unify_pack_expansion (tparms, targs, parm, arg,\n+\t\t\t\t       DEDUCE_EXACT,\n+\t\t\t\t       /*subr=*/true, explain_p);\n \treturn unify_success (explain_p);\n       }\n \n@@ -16425,58 +16449,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \n     case TYPE_ARGUMENT_PACK:\n     case NONTYPE_ARGUMENT_PACK:\n-      {\n-        tree packed_parms = ARGUMENT_PACK_ARGS (parm);\n-        tree packed_args = ARGUMENT_PACK_ARGS (arg);\n-        int i, len = TREE_VEC_LENGTH (packed_parms);\n-        int argslen = TREE_VEC_LENGTH (packed_args);\n-        int parm_variadic_p = 0;\n-\n-\tfor (i = 0; i < len; ++i)\n-\t  {\n-\t    if (PACK_EXPANSION_P (TREE_VEC_ELT (packed_parms, i)))\n-\t      {\n-\t\tif (i == len - 1)\n-\t\t  /* We can unify against something with a trailing\n-\t\t     parameter pack.  */\n-\t\t  parm_variadic_p = 1;\n-\t\telse\n-\t\t  /* Since there is something following the pack\n-\t\t     expansion, we cannot unify this template argument\n-\t\t     list.  */\n-\t\t  return unify_success (explain_p);\n-\t      }\n-\t  }\n-\t  \n-\n-        /* If we don't have enough arguments to satisfy the parameters\n-           (not counting the pack expression at the end), or we have\n-           too many arguments for a parameter list that doesn't end in\n-           a pack expression, we can't unify.  */\n-        if (argslen < (len - parm_variadic_p))\n-\t  return unify_too_few_arguments (explain_p, argslen, len);\n-\tif (argslen > len && !parm_variadic_p)\n-\t  return unify_too_many_arguments (explain_p, argslen, len);\n-\n-        /* Unify all of the parameters that precede the (optional)\n-           pack expression.  */\n-        for (i = 0; i < len - parm_variadic_p; ++i)\n-          {\n-\t    RECUR_AND_CHECK_FAILURE (tparms, targs,\n-\t\t\t\t     TREE_VEC_ELT (packed_parms, i),\n-\t\t\t\t     TREE_VEC_ELT (packed_args, i),\n-\t\t\t\t     strict, explain_p);\n-          }\n-\n-        if (parm_variadic_p)\n-          return unify_pack_expansion (tparms, targs, \n-                                       packed_parms, packed_args,\n-                                       strict, /*call_args_p=*/false,\n-                                       /*subr=*/false, explain_p);\n-        return unify_success (explain_p);\n-      }\n-\n-      break;\n+      return unify (tparms, targs, ARGUMENT_PACK_ARGS (parm),\n+\t\t    ARGUMENT_PACK_ARGS (arg), strict, explain_p);\n \n     case TYPEOF_TYPE:\n     case DECLTYPE_TYPE:\n@@ -16785,9 +16759,8 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n             TREE_VEC_ELT (argvec, i) = TREE_VALUE (ta);\n \n           deduce1 = (unify_pack_expansion (tparms1, targs1, parmvec,\n-\t\t\t\t\t   argvec, UNIFY_ALLOW_NONE, \n-                                           /*call_args_p=*/false, \n-\t\t\t\t\t   /*subr=*/0, /*explain_p=*/false)\n+\t\t\t\t\t   argvec, DEDUCE_EXACT,\n+\t\t\t\t\t   /*subr=*/true, /*explain_p=*/false)\n \t\t     == 0);\n \n           /* We cannot deduce in the other direction, because ARG1 is\n@@ -16810,9 +16783,8 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n             TREE_VEC_ELT (argvec, i) = TREE_VALUE (ta);\n \n           deduce2 = (unify_pack_expansion (tparms2, targs2, parmvec,\n-\t\t\t\t\t   argvec, UNIFY_ALLOW_NONE, \n-                                           /*call_args_p=*/false, \n-\t\t\t\t\t   /*subr=*/0, /*explain_p=*/false)\n+\t\t\t\t\t   argvec, DEDUCE_EXACT,\n+\t\t\t\t\t   /*subr=*/true, /*explain_p=*/false)\n \t\t     == 0);\n \n           /* We cannot deduce in the other direction, because ARG2 is"}, {"sha": "275b9b340409e39d381095100d62ef7fcc5264f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -1,5 +1,10 @@\n 2011-10-02  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/cpp0x/variadic65.C: Remove xfails.\n+\t* g++.dg/cpp0x/variadic82.C: Remove xfails.\n+\t* g++.dg/cpp0x/variadic83.C: Remove xfails.\n+\t* g++.dg/cpp0x/variadic105.C: Remove xfails.\n+\n \t* g++.dg/cpp0x/nsdmi5.C: New.\n \n 2011-10-02  Richard Sandiford  <rdsandiford@googlemail.com>"}, {"sha": "a097f43d2183e182e3e2e33b7ac64ec4a775ced1", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-explicit1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-explicit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-explicit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-explicit1.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++0x }\n+\n+template<class T, class U> struct A { };\n+template<class... T, class ... U> void f( A<T,U>... p);\n+\n+void g() {\n+    f<int>(\n+        A<int,unsigned>(),\n+        A<short,unsigned short>()\n+        );\n+}"}, {"sha": "a64d7971c6ecbc3e83befdf5e84db2e386e1b2b2", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic-nondeduce1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-nondeduce1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-nondeduce1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic-nondeduce1.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++0x }\n+\n+template <class... T>\n+void f(T..., int, T...) { }\n+\n+int main()\n+{\n+  f(0);\n+  f<int>(0,0,0);\n+  f<int,int>(0,0,0,0,0);\n+  f(0,0,0);\t\t\t// { dg-error \"\" }\n+}"}, {"sha": "66d24a7efe3216d7ab6ab5b4e350f13f34f9a223", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic105.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic105.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic105.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic105.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -20,6 +20,6 @@ struct call_sum {\n \n int main() {\n   // This shouldn't be an error; this is bug 35722.\n-  reverse<call_sum>(1,2);\t// { dg-bogus \"no match\" \"\" { xfail *-*-* } }\n-  // { dg-bogus \"sorry, unimplemented\" \"candidate explanation\" { xfail *-*-* } 6 }\n+  reverse<call_sum>(1,2);\t// { dg-bogus \"no match\" \"\" }\n+  // { dg-bogus \"sorry, unimplemented\" \"candidate explanation\" { target *-*-* } 6 }\n }"}, {"sha": "22f2fc5ae2dd295992408ddd43d84452110c0ae6", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic117.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic117.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic117.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic117.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++0x }\n+\n+template <class T> struct A { typedef T type; };\n+\n+template <template <class...> class T, class... U>\n+void f(typename T<U...>::type);\n+\n+int main()\n+{\n+  f<A,int>(42);\n+}"}, {"sha": "43bf9bab21327d9636e9470e7c4971e544e8df59", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic118.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic118.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic118.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic118.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -0,0 +1,11 @@\n+// This should fail deduction, before it produces a candidate.\n+// { dg-options -std=c++0x }\n+\n+template <class... T>\n+void f(T... ts);\t\t// { dg-message \"deduction\" }\n+\n+struct B { };\n+int main()\n+{\n+  f<int>(B(), 1);\t\t// { dg-error \"\" }\n+}"}, {"sha": "666a1f5d039caa88878d9deb97bb06d19ec55a90", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic35.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic35.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -5,6 +5,5 @@ void get_ith(const Args&... args); // { dg-message \"note\" }\n void f()\n {\n   get_ith<1, float>(1, 2.0, 'x');\n-  get_ith<1, int, double, char, int>(1, 2.0, 'x'); // { dg-error \"no matching function\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 8 }\n+  get_ith<1, int, double, char, int>(1, 2.0, 'x'); // { dg-error \"too few arguments\" }\n }"}, {"sha": "77be10676aef2111473f167d087863a5b7224b50", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic65.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic65.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic65.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic65.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -5,4 +5,9 @@ template<typename T1 = unused, typename T2 = unused, typename T3 = unused,\n struct tuple {};\n \n template<typename... Args>\n-void foo(tuple<Args...>) { } // { dg-bogus \"cannot expand\" \"\" { xfail *-*-* } }\n+tuple<Args...> foo() { } // { dg-bogus \"cannot expand\" \"\" }\n+\n+int main()\n+{\n+  foo<int,int,int,int,int,int>();\n+}"}, {"sha": "03aec80211d5e032492b7da9ef38c662f3a0afa9", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic82.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic82.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic82.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic82.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -3,9 +3,9 @@\n \n template<typename> struct A;\n \n-template<typename... T> struct A<T*...> // { dg-bogus \"cannot expand\" \"\" { xfail *-*-* } }\n+template<typename... T> struct A<T*...> // { dg-bogus \"cannot expand\" \"\" }\n {\n   struct B;\n };\n \n-A<void*> a; // { dg-bogus \"incomplete type\" \"\" { xfail *-*-* } }\n+A<void*> a; // { dg-bogus \"incomplete type\" \"\" }"}, {"sha": "c446e69742033c8b4b3b5e7e757eda6615e401bc", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic83.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic83.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic83.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic83.C?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -3,6 +3,6 @@\n \n template<typename> struct A;\n \n-template<typename... T> struct A<T...> { }; // { dg-bogus \"cannot expand\" \"\" { xfail *-*-* } }\n+template<typename... T> struct A<T...> { }; // { dg-bogus \"cannot expand\" \"\" }\n \n-A<int> a; // { dg-bogus \"incomplete type\" \"\" { xfail *-*-* } }\n+A<int> a; // { dg-bogus \"incomplete type\" \"\" }"}, {"sha": "449f606f1be97616d98660d6c3a13d87df6c29b2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -1,3 +1,8 @@\n+2011-09-29  Jason Merrill  <jason@redhat.com>\n+\n+\t* testsuite/util/testsuite_tr1.h (test_property): Avoid\n+\tambguity.\n+\n 2011-10-01  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/debug/vector (vector<>::erase(iterator, iterator): Check"}, {"sha": "f0638960b27164d17e46f2f85707d58eac7b9278", "filename": "libstdc++-v3/testsuite/util/testsuite_tr1.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6027563413543e1607fdc8752e4c4f238fad350/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6027563413543e1607fdc8752e4c4f238fad350/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h?ref=d6027563413543e1607fdc8752e4c4f238fad350", "patch": "@@ -68,13 +68,14 @@ namespace __gnu_test\n     }\n \n #ifdef __GXX_EXPERIMENTAL_CXX0X__\n-  template<template<typename...> class Property, typename... Types>\n+  template<template<typename...> class Property,\n+\t   typename Type1, typename... Types>\n     bool\n-    test_property(typename Property<Types...>::value_type value)\n+    test_property(typename Property<Type1, Types...>::value_type value)\n     {\n       bool ret = true;\n-      ret &= Property<Types...>::value == value;\n-      ret &= Property<Types...>::type::value == value;\n+      ret &= Property<Type1, Types...>::value == value;\n+      ret &= Property<Type1, Types...>::type::value == value;\n       return ret;\n     }\n #endif"}]}