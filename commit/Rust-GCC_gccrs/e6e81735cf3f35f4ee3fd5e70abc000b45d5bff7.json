{"sha": "e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZlODE3MzVjZjNmMzVmNGVlM2ZkNWU3MGFiYzAwMGI0NWQ1YmZmNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-01-28T11:16:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-01-28T11:16:32Z"}, "message": "i386.c (ix86_carry_flag_operator): New predicate.\n\n \t* i386.c (ix86_carry_flag_operator):  New predicate.\n \t(fcmov_operator): Fix whitespace.\n \t(ix86_expand_carry_flag_compare):  Deal with floating point.\n \t(ix86_expand_int_movcc): Deal with fp; update insn expansion\n \t(ix86_expand_int_addcc): Likewise.\n \t(ix86_expand_strlensi_unroll_1): likewsie.\n \t* i386.h (PREDICATE_CODES): Add ix86_carry_flag_operator.\n \t* i386.md (add?i_carry_rex64): Use new predicate.\n \t(sub?i3_carry_rex64): Likewise.\n \t(x86_mov?icc_0_m1*): Likewise.\n\nFrom-SVN: r61963", "tree": {"sha": "2b203c85c739db94e04b28ee8e7b5766c397d0e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b203c85c739db94e04b28ee8e7b5766c397d0e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/comments", "author": null, "committer": null, "parents": [{"sha": "32214c325397831e1845013cb5234fce4eec8545", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32214c325397831e1845013cb5234fce4eec8545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32214c325397831e1845013cb5234fce4eec8545"}], "stats": {"total": 196, "additions": 167, "deletions": 29}, "files": [{"sha": "24d5cd1bfffbe35d20507ce9cd6af97ccf036c36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "patch": "@@ -1,3 +1,16 @@\n+Tue Jan 28 12:15:13 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+ \t* i386.c (ix86_carry_flag_operator):  New predicate.\n+ \t(fcmov_operator): Fix whitespace.\n+ \t(ix86_expand_carry_flag_compare):  Deal with floating point.\n+ \t(ix86_expand_int_movcc): Deal with fp; update insn expansion\n+ \t(ix86_expand_int_addcc): Likewise.\n+ \t(ix86_expand_strlensi_unroll_1): likewsie.\n+ \t* i386.h (PREDICATE_CODES): Add ix86_carry_flag_operator.\n+ \t* i386.md (add?i_carry_rex64): Use new predicate.\n+ \t(sub?i3_carry_rex64): Likewise.\n+ \t(x86_mov?icc_0_m1*): Likewise.\n+\n 2003-01-28  Andreas Schwab  <schwab@suse.de>\n \n \t* cfgloopmanip.c (create_preheader): Initialize src to avoid"}, {"sha": "bb8091dfcb4b2ddeaa3bfb196491ba0c8ad3b01c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 139, "deletions": 16, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "patch": "@@ -3797,6 +3797,40 @@ ix86_comparison_operator (op, mode)\n     }\n }\n \n+/* Return 1 if OP is a valid comparison operator testing carry flag\n+   to be set.  */\n+int\n+ix86_carry_flag_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum machine_mode inmode;\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+  if (GET_RTX_CLASS (code) != '<')\n+    return 0;\n+  inmode = GET_MODE (XEXP (op, 0));\n+  if (GET_CODE (XEXP (op, 0)) != REG\n+      || REGNO (XEXP (op, 0)) != 17\n+      || XEXP (op, 1) != const0_rtx)\n+    return 0;\n+\n+  if (inmode == CCFPmode || inmode == CCFPUmode)\n+    {\n+      enum rtx_code second_code, bypass_code;\n+\n+      ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n+      if (bypass_code != NIL || second_code != NIL)\n+\treturn 0;\n+      code = ix86_fp_compare_code_to_integer (code);\n+    }\n+  else if (inmode != CCmode)\n+    return 0;\n+  return code == LTU;\n+}\n+\n /* Return 1 if OP is a comparison operator that can be issued by fcmov.  */\n \n int\n@@ -3806,6 +3840,7 @@ fcmov_comparison_operator (op, mode)\n {\n   enum machine_mode inmode;\n   enum rtx_code code = GET_CODE (op);\n+\n   if (mode != VOIDmode && GET_MODE (op) != mode)\n     return 0;\n   if (GET_RTX_CLASS (code) != '<')\n@@ -3814,6 +3849,7 @@ fcmov_comparison_operator (op, mode)\n   if (inmode == CCFPmode || inmode == CCFPUmode)\n     {\n       enum rtx_code second_code, bypass_code;\n+\n       ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n       if (bypass_code != NIL || second_code != NIL)\n \treturn 0;\n@@ -9316,7 +9352,51 @@ ix86_expand_carry_flag_compare (code, op0, op1, pop)\n \n   /* Do not handle DImode compares that go trought special path.  Also we can't\n      deal with FP compares yet.  This is possible to add.   */\n-  if ((mode == DImode && !TARGET_64BIT) || !INTEGRAL_MODE_P (mode))\n+  if ((mode == DImode && !TARGET_64BIT))\n+    return false;\n+  if (FLOAT_MODE_P (mode))\n+    {\n+      rtx second_test = NULL, bypass_test = NULL;\n+      rtx compare_op, compare_seq;\n+\n+      /* Shortcut:  following common codes never translate into carry flag compares.  */\n+      if (code == EQ || code == NE || code == UNEQ || code == LTGT\n+\t  || code == ORDERED || code == UNORDERED)\n+\treturn false;\n+\n+      /* These comparisons require zero flag; swap operands so they won't.  */\n+      if ((code == GT || code == UNLE || code == LE || code == UNGT)\n+\t  && !TARGET_IEEE_FP)\n+\t{\n+\t  rtx tmp = op0;\n+\t  op0 = op1;\n+\t  op1 = tmp;\n+\t  code = swap_condition (code);\n+\t}\n+\n+      /* Try to expand the comparsion and verify that we end up with carry flag\n+\t based comparsion.  This is fails to be true only when we decide to expand\n+\t comparsion using arithmetic that is not too common scenario.  */\n+      start_sequence ();\n+      compare_op = ix86_expand_fp_compare (code, op0, op1, NULL_RTX,\n+\t\t\t\t\t   &second_test, &bypass_test);\n+      compare_seq = get_insns ();\n+      end_sequence ();\n+\n+      if (second_test || bypass_test)\n+\treturn false;\n+      if (GET_MODE (XEXP (compare_op, 0)) == CCFPmode\n+\t  || GET_MODE (XEXP (compare_op, 0)) == CCFPUmode)\n+        code = ix86_fp_compare_code_to_integer (GET_CODE (compare_op));\n+      else\n+\tcode = GET_CODE (compare_op);\n+      if (code != LTU && code != GEU)\n+\treturn false;\n+      emit_insn (compare_seq);\n+      *pop = compare_op;\n+      return true;\n+    }\n+  if (!INTEGRAL_MODE_P (mode))\n     return false;\n   switch (code)\n     {\n@@ -9428,8 +9508,17 @@ ix86_expand_int_movcc (operands)\n \n           if (!sign_bit_compare_p)\n \t    {\n+\t      bool fpcmp = false;\n+\n \t      compare_code = GET_CODE (compare_op);\n \n+\t      if (GET_MODE (XEXP (compare_op, 0)) == CCFPmode\n+\t\t  || GET_MODE (XEXP (compare_op, 0)) == CCFPUmode)\n+\t\t{\n+\t\t  fpcmp = true;\n+\t\t  compare_code = ix86_fp_compare_code_to_integer (compare_code);\n+\t\t}\n+\n \t      /* To simplify rest of code, restrict to the GEU case.  */\n \t      if (compare_code == LTU)\n \t\t{\n@@ -9439,16 +9528,25 @@ ix86_expand_int_movcc (operands)\n \t\t  compare_code = reverse_condition (compare_code);\n \t\t  code = reverse_condition (code);\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  if (fpcmp)\n+\t\t    PUT_CODE (compare_op,\n+\t\t\t      reverse_condition_maybe_unordered\n+\t\t\t        (GET_CODE (compare_op)));\n+\t\t  else\n+\t\t    PUT_CODE (compare_op, reverse_condition (GET_CODE (compare_op)));\n+\t\t}\n \t      diff = ct - cf;\n \n \t      if (reg_overlap_mentioned_p (out, ix86_compare_op0)\n \t\t  || reg_overlap_mentioned_p (out, ix86_compare_op1))\n \t\ttmp = gen_reg_rtx (mode);\n \n \t      if (mode == DImode)\n-\t\temit_insn (gen_x86_movdicc_0_m1_rex64 (tmp));\n+\t\temit_insn (gen_x86_movdicc_0_m1_rex64 (tmp, compare_op));\n \t      else\n-\t\temit_insn (gen_x86_movsicc_0_m1 (gen_lowpart (SImode, tmp)));\n+\t\temit_insn (gen_x86_movsicc_0_m1 (gen_lowpart (SImode, tmp), compare_op));\n \t    }\n \t  else\n \t    {\n@@ -10051,30 +10149,53 @@ ix86_expand_int_addcc (operands)\n   enum rtx_code code = GET_CODE (operands[1]);\n   rtx compare_op;\n   rtx val = const0_rtx;\n+  bool fpcmp = false;\n+  rtx pat, clob;\n+  enum machine_mode mode = GET_MODE (operands[0]);\n \n   if (operands[3] != const1_rtx\n       && operands[3] != constm1_rtx)\n     return 0;\n   if (!ix86_expand_carry_flag_compare (code, ix86_compare_op0,\n \t\t\t\t       ix86_compare_op1, &compare_op))\n      return 0;\n-  if (GET_CODE (compare_op) != LTU)\n-    val = constm1_rtx;\n-  if ((GET_CODE (compare_op) == LTU) == (operands[3] == constm1_rtx))\n+  code = GET_CODE (compare_op);\n+\n+  if (GET_MODE (XEXP (compare_op, 0)) == CCFPmode\n+      || GET_MODE (XEXP (compare_op, 0)) == CCFPUmode)\n+    {\n+      fpcmp = true;\n+      code = ix86_fp_compare_code_to_integer (code);\n+    }\n+\n+  if (code != LTU)\n+    {\n+      val = constm1_rtx;\n+      if (fpcmp)\n+\tPUT_CODE (compare_op,\n+\t\t  reverse_condition_maybe_unordered\n+\t\t    (GET_CODE (compare_op)));\n+      else\n+\tPUT_CODE (compare_op, reverse_condition (GET_CODE (compare_op)));\n+    }\n+  PUT_MODE (compare_op, mode);\n+\n+  /* Construct either adc or sbb insn.  */\n+  if ((code == LTU) == (operands[3] == constm1_rtx))\n     {\n       switch (GET_MODE (operands[0]))\n \t{\n \t  case QImode:\n-            emit_insn (gen_subqi3_carry (operands[0], operands[2], val));\n+            emit_insn (gen_subqi3_carry (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  case HImode:\n-            emit_insn (gen_subhi3_carry (operands[0], operands[2], val));\n+            emit_insn (gen_subhi3_carry (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  case SImode:\n-            emit_insn (gen_subsi3_carry (operands[0], operands[2], val));\n+            emit_insn (gen_subsi3_carry (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  case DImode:\n-            emit_insn (gen_subdi3_carry_rex64 (operands[0], operands[2], val));\n+            emit_insn (gen_subdi3_carry_rex64 (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  default:\n \t    abort ();\n@@ -10085,16 +10206,16 @@ ix86_expand_int_addcc (operands)\n       switch (GET_MODE (operands[0]))\n \t{\n \t  case QImode:\n-            emit_insn (gen_addqi3_carry (operands[0], operands[2], val));\n+            emit_insn (gen_addqi3_carry (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  case HImode:\n-            emit_insn (gen_addhi3_carry (operands[0], operands[2], val));\n+            emit_insn (gen_addhi3_carry (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  case SImode:\n-            emit_insn (gen_addsi3_carry (operands[0], operands[2], val));\n+            emit_insn (gen_addsi3_carry (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  case DImode:\n-            emit_insn (gen_adddi3_carry_rex64 (operands[0], operands[2], val));\n+            emit_insn (gen_adddi3_carry_rex64 (operands[0], operands[2], val, compare_op));\n \t    break;\n \t  default:\n \t    abort ();\n@@ -11181,6 +11302,7 @@ ix86_expand_strlensi_unroll_1 (out, align_rtx)\n   rtx mem;\n   rtx tmpreg = gen_reg_rtx (SImode);\n   rtx scratch = gen_reg_rtx (SImode);\n+  rtx cmp;\n \n   align = 0;\n   if (GET_CODE (align_rtx) == CONST_INT)\n@@ -11339,10 +11461,11 @@ ix86_expand_strlensi_unroll_1 (out, align_rtx)\n   /* Avoid branch in fixing the byte.  */\n   tmpreg = gen_lowpart (QImode, tmpreg);\n   emit_insn (gen_addqi3_cc (tmpreg, tmpreg, tmpreg));\n+  cmp = gen_rtx_LTU (Pmode, gen_rtx_REG (CCmode, 17), const0_rtx);\n   if (TARGET_64BIT)\n-    emit_insn (gen_subdi3_carry_rex64 (out, out, GEN_INT (3)));\n+    emit_insn (gen_subdi3_carry_rex64 (out, out, GEN_INT (3), cmp));\n   else\n-    emit_insn (gen_subsi3_carry (out, out, GEN_INT (3)));\n+    emit_insn (gen_subsi3_carry (out, out, GEN_INT (3), cmp));\n \n   emit_label (end_0_label);\n }"}, {"sha": "6543ab018a49e76a880b922603739b42984e673b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "patch": "@@ -3048,6 +3048,8 @@ do {\t\t\t\t\t\t\\\n   {\"ix86_comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU,\t\\\n \t\t\t       GTU, UNORDERED, ORDERED, UNLE, UNLT,\t\\\n \t\t\t       UNGE, UNGT, LTGT, UNEQ }},\t\t\\\n+  {\"ix86_carry_flag_operator\", {LTU, LT, UNLT, GT, UNGT, LE, UNLE,\t\\\n+\t\t\t\t GE, UNGE, LTGT, UNEQ}},\t\t\\\n   {\"cmp_fp_expander_operand\", {CONST_DOUBLE, SUBREG, REG, MEM}},\t\\\n   {\"ext_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"binary_fp_operator\", {PLUS, MINUS, MULT, DIV}},\t\t\t\\"}, {"sha": "e58f3e07d342b037af5d6085c75e63902a85d093", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e6e81735cf3f35f4ee3fd5e70abc000b45d5bff7", "patch": "@@ -4969,7 +4969,7 @@\n \n (define_insn \"adddi3_carry_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t  (plus:DI (plus:DI (ltu:DI (reg:CC 17) (const_int 0))\n+\t  (plus:DI (plus:DI (match_operand:DI 3 \"ix86_carry_flag_operator\" \"\")\n \t\t\t    (match_operand:DI 1 \"nonimmediate_operand\" \"%0,0\"))\n \t\t   (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\")))\n    (clobber (reg:CC 17))]\n@@ -4994,7 +4994,7 @@\n \n (define_insn \"addqi3_carry\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t  (plus:QI (plus:QI (ltu:QI (reg:CC 17) (const_int 0))\n+\t  (plus:QI (plus:QI (match_operand:QI 3 \"ix86_carry_flag_operator\" \"\")\n \t\t\t    (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0\"))\n \t\t   (match_operand:QI 2 \"general_operand\" \"ri,rm\")))\n    (clobber (reg:CC 17))]\n@@ -5007,7 +5007,7 @@\n \n (define_insn \"addhi3_carry\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t  (plus:HI (plus:HI (ltu:HI (reg:CC 17) (const_int 0))\n+\t  (plus:HI (plus:HI (match_operand:HI 3 \"ix86_carry_flag_operator\" \"\")\n \t\t\t    (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\"))\n \t\t   (match_operand:HI 2 \"general_operand\" \"ri,rm\")))\n    (clobber (reg:CC 17))]\n@@ -5020,7 +5020,7 @@\n \n (define_insn \"addsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n-\t  (plus:SI (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n+\t  (plus:SI (plus:SI (match_operand:SI 3 \"ix86_carry_flag_operator\" \"\")\n \t\t\t    (match_operand:SI 1 \"nonimmediate_operand\" \"%0,0\"))\n \t\t   (match_operand:SI 2 \"general_operand\" \"ri,rm\")))\n    (clobber (reg:CC 17))]\n@@ -5034,7 +5034,7 @@\n (define_insn \"*addsi3_carry_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t  (zero_extend:DI \n-\t    (plus:SI (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n+\t    (plus:SI (plus:SI (match_operand:SI 3 \"ix86_carry_flag_operator\" \"\")\n \t\t\t      (match_operand:SI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t     (match_operand:SI 2 \"general_operand\" \"rim\"))))\n    (clobber (reg:CC 17))]\n@@ -6649,7 +6649,7 @@\n (define_insn \"subdi3_carry_rex64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (minus:DI (match_operand:DI 1 \"nonimmediate_operand\" \"0,0\")\n-\t    (plus:DI (ltu:DI (reg:CC 17) (const_int 0))\n+\t    (plus:DI (match_operand:SI 3 \"ix86_carry_flag_operator\" \"\")\n \t       (match_operand:DI 2 \"x86_64_general_operand\" \"re,rm\"))))\n    (clobber (reg:CC 17))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, DImode, operands)\"\n@@ -6698,7 +6698,7 @@\n (define_insn \"subqi3_carry\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (minus:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")\n-\t    (plus:QI (ltu:QI (reg:CC 17) (const_int 0))\n+\t    (plus:QI (match_operand:QI 3 \"ix86_carry_flag_operator\" \"\")\n \t       (match_operand:QI 2 \"general_operand\" \"ri,rm\"))))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (MINUS, QImode, operands)\"\n@@ -6711,7 +6711,7 @@\n (define_insn \"subhi3_carry\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (minus:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0,0\")\n-\t    (plus:HI (ltu:HI (reg:CC 17) (const_int 0))\n+\t    (plus:HI (match_operand:HI 3 \"ix86_carry_flag_operator\" \"\")\n \t       (match_operand:HI 2 \"general_operand\" \"ri,rm\"))))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (MINUS, HImode, operands)\"\n@@ -6724,7 +6724,7 @@\n (define_insn \"subsi3_carry\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm,r\")\n \t  (minus:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0,0\")\n-\t    (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n+\t    (plus:SI (match_operand:SI 3 \"ix86_carry_flag_operator\" \"\")\n \t       (match_operand:SI 2 \"general_operand\" \"ri,rm\"))))\n    (clobber (reg:CC 17))]\n   \"ix86_binary_operator_ok (MINUS, SImode, operands)\"\n@@ -6738,7 +6738,7 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=rm,r\")\n \t  (zero_extend:DI\n \t    (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t      (plus:SI (ltu:SI (reg:CC 17) (const_int 0))\n+\t      (plus:SI (match_operand:SI 3 \"ix86_carry_flag_operator\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"ri,rm\")))))\n    (clobber (reg:CC 17))]\n   \"TARGET_64BIT && ix86_binary_operator_ok (MINUS, SImode, operands)\"\n@@ -16289,7 +16289,7 @@\n \n (define_insn \"x86_movdicc_0_m1_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(if_then_else:DI (ltu (reg:CC 17) (const_int 0))\n+\t(if_then_else:DI (match_operand 1 \"ix86_carry_flag_operator\" \"\")\n \t  (const_int -1)\n \t  (const_int 0)))\n    (clobber (reg:CC 17))]\n@@ -16304,7 +16304,7 @@\n    (set_attr \"mode\" \"DI\")\n    (set_attr \"length_immediate\" \"0\")])\n \n-(define_insn \"*movdicc_c_rex64\"\n+(define_insn \"movdicc_c_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n \t(if_then_else:DI (match_operator 1 \"ix86_comparison_operator\" \n \t\t\t\t[(reg 17) (const_int 0)])\n@@ -16332,7 +16332,7 @@\n \n (define_insn \"x86_movsicc_0_m1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(if_then_else:SI (ltu (reg:CC 17) (const_int 0))\n+\t(if_then_else:SI (match_operand 1 \"ix86_carry_flag_operator\" \"\")\n \t  (const_int -1)\n \t  (const_int 0)))\n    (clobber (reg:CC 17))]"}]}