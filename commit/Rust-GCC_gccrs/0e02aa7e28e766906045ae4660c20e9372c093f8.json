{"sha": "0e02aa7e28e766906045ae4660c20e9372c093f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUwMmFhN2UyOGU3NjY5MDYwNDVhZTQ2NjBjMjBlOTM3MmMwOTNmOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-21T22:14:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-21T22:14:38Z"}, "message": "(location_or_const_value_attribute): Fixed to use DECL_INCOMING_RTL for PARM_DECLs only when DECL_RTL isn't usable...\n\n(location_or_const_value_attribute): Fixed to use DECL_INCOMING_RTL\nfor PARM_DECLs only when DECL_RTL isn't usable, and even then, only\nwhen it actually points to the right place.\n\nFrom-SVN: r4189", "tree": {"sha": "3c8889663d962d1e31a6f30e6e1f1733d4c71d8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c8889663d962d1e31a6f30e6e1f1733d4c71d8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e02aa7e28e766906045ae4660c20e9372c093f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e02aa7e28e766906045ae4660c20e9372c093f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e02aa7e28e766906045ae4660c20e9372c093f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e02aa7e28e766906045ae4660c20e9372c093f8/comments", "author": null, "committer": null, "parents": [{"sha": "a76386d8e5a18762398aa75fe9d35d38792cfe42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a76386d8e5a18762398aa75fe9d35d38792cfe42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a76386d8e5a18762398aa75fe9d35d38792cfe42"}], "stats": {"total": 157, "additions": 99, "deletions": 58}, "files": [{"sha": "39fe99b0ee6e7ae4e50dde44a0f0f36d714fa087", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 99, "deletions": 58, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e02aa7e28e766906045ae4660c20e9372c093f8/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e02aa7e28e766906045ae4660c20e9372c093f8/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=0e02aa7e28e766906045ae4660c20e9372c093f8", "patch": "@@ -2100,68 +2100,109 @@ location_or_const_value_attribute (decl)\n     return;\n \n   if ((TREE_CODE (decl) != VAR_DECL) && (TREE_CODE (decl) != PARM_DECL))\n-    abort ();\n+    {\n+      /* Should never happen.  */\n+      abort ();\n+      return;\n+    }\n \n-  /* Existing Dwarf debuggers need and expect the location descriptors for\n-     formal parameters to reflect either the place where the parameters get\n-     passed (if they are passed on the stack and in memory) or else the\n-     (preserved) registers which the parameters get copied to during the\n-     function prologue.\n-\n-     At least this is the way things are for most common CISC machines\n-     (e.g. x86 and m68k) where parameters are passed in the stack, and for\n-     most common RISC machines (e.g. i860 and m88k) where parameters are\n-     passed in registers.\n-\n-     The rules for Sparc are a little weird for some reason.  The DWARF\n-     generated by the USL C compiler for the Sparc/svr4 reference port says\n-     that the parameters are passed in the stack.  I haven't figured out\n-     how to duplicate that behavior here (for the Sparc) yet, or even if\n-     I really need to.\n-\n-     Note that none of this is clearly spelled out in the current Dwarf\n-     version 1 specification, but it's obvious if you look at the output of\n-     the CI5 compiler, or if you try to use the svr4 SDB debugger.  Hopefully,\n-     a later version of the Dwarf specification will clarify this.  For now,\n-     we just need to generate the right thing.  Note that Dwarf version 2\n-     will provide us with a means to describe *all* of the locations in which\n-     a given variable or parameter resides (and the PC ranges over which it\n-     occupies each one), but for now we can only describe one \"location\"\n-     for each formal parameter passed, and so we just try to mimic existing\n-     practice as much as possible.\n+  /* Here we have to decide where we are going to say the parameter \"lives\"\n+     (as far as the debugger is concerned).  We only have a couple of choices.\n+     GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.  DECL_RTL\n+     normally indicates where the parameter lives during most of the activa-\n+     tion of the function.  If optimization is enabled however, this could\n+     be either NULL or else a pseudo-reg.  Both of those cases indicate that\n+     the parameter doesn't really live anywhere (as far as the code generation\n+     parts of GCC are concerned) during most of the function's activation.\n+     That will happen (for example) if the parameter is never referenced\n+     within the function.\n+\n+     We could just generate a location descriptor here for all non-NULL\n+     non-pseudo values of DECL_RTL and ignore all of the rest, but we can\n+     be a little nicer than that if we also consider DECL_INCOMING_RTL in\n+     cases where DECL_RTL is NULL or is a pseudo-reg.\n+\n+     Note however that we can only get away with using DECL_INCOMING_RTL as\n+     a backup substitute for DECL_RTL in certain limited cases.  In cases\n+     where DECL_ARG_TYPE(decl) indicates the same type as TREE_TYPE(decl)\n+     we can be sure that the parameter was passed using the same type as it\n+     is declared to have within the function, and that its DECL_INCOMING_RTL\n+     points us to a place where a value of that type is passed.  In cases\n+     where DECL_ARG_TYPE(decl) and TREE_TYPE(decl) are different types\n+     however, we cannot (in general) use DECL_INCOMING_RTL as a backup\n+     substitute for DECL_RTL because in these cases, DECL_INCOMING_RTL\n+     points us to a value of some type which is *different* from the type\n+     of the parameter itself.  Thus, if we tried to use DECL_INCOMING_RTL\n+     to generate a location attribute in such cases, the debugger would\n+     end up (for example) trying to fetch a `float' from a place which\n+     actually contains the first part of a `double'.  That would lead to\n+     really incorrect and confusing output at debug-time, and we don't\n+     want that now do we?\n+\n+     So in general, we DO NOT use DECL_INCOMING_RTL as a backup for DECL_RTL\n+     in cases where DECL_ARG_TYPE(decl) != TREE_TYPE(decl).  There are a\n+     couple of cute exceptions however.  On little-endian machines we can\n+     get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE(decl) is\n+     not the same as TREE_TYPE(decl) but only when DECL_ARG_TYPE(decl) is\n+     an integral type which is smaller than TREE_TYPE(decl).  These cases\n+     arise when (on a little-endian machine) a non-prototyped function has\n+     a parameter declared to be of type `short' or `char'.  In such cases,\n+     TREE_TYPE(decl) will be `short' or `char', DECL_ARG_TYPE(decl) will be\n+     `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the\n+     passed `int' value.  If the debugger then uses that address to fetch a\n+     `short' or a `char' (on a little-endian machine) the result will be the\n+     correct data, so we allow for such exceptional cases below.\n+\n+     Note that our goal here is to describe the place where the given formal\n+     parameter lives during most of the function's activation (i.e. between\n+     the end of the prologue and the start of the epilogue).  We'll do that\n+     as best as we can.  Note however that if the given formal parameter is\n+     modified sometime during the execution of the function, then a stack\n+     backtrace (at debug-time) will show the function as having been called\n+     with the *new* value rather than the value which was originally passed\n+     in.  This happens rarely enough that it is not a major problem, but it\n+     *is* a problem, and I'd like to fix it.  A future version of dwarfout.c\n+     may generate two additional attributes for any given TAG_formal_parameter\n+     DIE which will describe the \"passed type\" and the \"passed location\" for\n+     the given formal parameter in addition to the attributes we now generate\n+     to indicate the \"declared type\" and the \"active location\" for each\n+     parameter.  This additional set of attributes could be used by debuggers\n+     for stack backtraces.\n+\n+     Separately, note that sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL\n+     can be NULL also.  This happens (for example) for inlined-instances of\n+     inline function formal parameters which are never referenced.  This really\n+     shouldn't be happening.  All PARM_DECL nodes should get valid non-NULL\n+     DECL_INCOMING_RTL values, but integrate.c doesn't currently generate\n+     these values for inlined instances of inline function parameters, so\n+     when we see such cases, we are just SOL (shit-out-of-luck) for the time\n+     being (until integrate.c gets fixed).\n   */\n \n-  if (TREE_CODE (decl) != PARM_DECL)\n-    /*  If this decl is not a formal parameter, just use DECL_RTL.  */\n-    rtl = DECL_RTL (decl);\n-  else\n-    {\n-      if (GET_CODE (DECL_INCOMING_RTL (decl)) == MEM)\n-        /* Parameter was passed in memory, so say that's where it lives.  */\n-\trtl = DECL_INCOMING_RTL (decl);\n-      else\n-\t{\n-          /* Parameter was passed in a register, so say it lives in the\n-\t     register it will be copied to during the prologue.  */\n-          rtl = DECL_RTL (decl);\n-\n-\t  /* Note that in cases where the formal parameter is never used\n-\t     and where this compilation is done with -O, the copying of\n-\t     of an incoming register parameter to another register (in\n-\t     the prologue) can be totally optimized away.  (In such cases\n-\t     the DECL_RTL will indicate a pseudo-register.)  We could just\n-\t     use the DECL_RTL (as we normally do for register parameters)\n-\t     in these cases, but if we did that, we would end up generating\n-\t     a null location descriptor.  (See `location_attribute' above.)\n-\t     That would be acceptable (according to the DWARF spec) but it\n-\t     is probably more useful to say that the formal resides where\n-\t     it was passed instead of saying that it resides nowhere.  */\n-\t  if (is_pseudo_reg (rtl))\n-\t    rtl = DECL_INCOMING_RTL (decl);\n-\t}\n-    }\n+  /* Use DECL_RTL as the \"location\" unless we find something better.  */\n+  rtl = DECL_RTL (decl);\n+\n+  if (TREE_CODE (decl) == PARM_DECL)\n+    if (rtl == NULL_RTX || is_pseudo_reg (rtl))\n+      {\n+\t/* This decl represents a formal parameter which was optimized out.  */\n+        register tree declared_type = TYPE_MAIN_VARIANT (TREE_TYPE (decl));\n+        register tree passed_type = TYPE_MAIN_VARIANT (DECL_ARG_TYPE (decl));\n+\n+\t/* Note that DECL_INCOMING_RTL may be NULL in here, but we handle\n+\t   *all* cases where (rtl == NULL_RTX) just below.  */\n+\n+\tif (declared_type == passed_type)\n+\t  rtl = DECL_INCOMING_RTL (decl);\n+#if (BYTES_BIG_ENDIAN == 0)\n+\telse\n+\t  if (TREE_CODE (declared_type) == INTEGER_TYPE)\n+\t    if (TYPE_SIZE (declared_type) <= TYPE_SIZE (passed_type))\n+\t      rtl = DECL_INCOMING_RTL (decl);\n+#endif /* (BYTES_BIG_ENDIAN == 0) */\n+      }\n \n-  if (rtl == NULL)\n+  if (rtl == NULL_RTX)\n     return;\n \n   switch (GET_CODE (rtl))"}]}