{"sha": "e9ad457396dc3779f36332630b5b02755f611cb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlhZDQ1NzM5NmRjMzc3OWYzNjMzMjYzMGI1YjAyNzU1ZjYxMWNiOA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-10-24T19:18:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-24T19:18:29Z"}, "message": "mn10300.c (symbolic_operand, [...]): New functions.\n\n        * mn10300.c (symbolic_operand, legitimize_address): New functions.\n        * mn10300.h (LEGITIMIZE_ADDRESS): Call legitimize_address.\n        (GO_IF_LEGITIMATE_ADDRESS): Don't allow base + symbolic.\n\nFrom-SVN: r16158", "tree": {"sha": "6e425b652d9ccf93be2d52a87725410a1a5664c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e425b652d9ccf93be2d52a87725410a1a5664c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9ad457396dc3779f36332630b5b02755f611cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ad457396dc3779f36332630b5b02755f611cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9ad457396dc3779f36332630b5b02755f611cb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ad457396dc3779f36332630b5b02755f611cb8/comments", "author": null, "committer": null, "parents": [{"sha": "66724f0abd68a9737dc3b3be789eb5aafcce154e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66724f0abd68a9737dc3b3be789eb5aafcce154e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66724f0abd68a9737dc3b3be789eb5aafcce154e"}], "stats": {"total": 85, "additions": 83, "deletions": 2}, "files": [{"sha": "f4b287557a587668247d081a8368103e67b775e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ad457396dc3779f36332630b5b02755f611cb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ad457396dc3779f36332630b5b02755f611cb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9ad457396dc3779f36332630b5b02755f611cb8", "patch": "@@ -1,3 +1,9 @@\n+Fri Oct 24 13:19:40 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* mn10300.c (symbolic_operand, legitimize_address): New functions.\n+\t* mn10300.h (LEGITIMIZE_ADDRESS): Call legitimize_address.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Don't allow base + symbolic.\n+\n Thu Oct 23 09:35:12 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "8bb5371ad738ca288c51741437b84d287940cfc9", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ad457396dc3779f36332630b5b02755f611cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ad457396dc3779f36332630b5b02755f611cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=e9ad457396dc3779f36332630b5b02755f611cb8", "patch": "@@ -989,3 +989,72 @@ impossible_plus_operand (op, mode)\n \n   return 0;\n }\n+\n+/* Return 1 if X contains a symbolic expression.  We know these\n+   expressions will have one of a few well defined forms, so\n+   we need only check those forms.  */\n+int\n+symbolic_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 1;\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+               || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+              && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Try machine dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   Normally it is always safe for this macro to do nothing.  It exists to\n+   recognize opportunities to optimize the output.\n+\n+   But on a few ports with segmented architectures and indexed addressing\n+   (mn10300, hppa) it is used to rewrite certain problematical addresses.  */\n+rtx\n+legitimize_address (x, oldx, mode)\n+     rtx x;\n+     rtx oldx;\n+     enum machine_mode mode;\n+{\n+  /* Uh-oh.  We might have an address for x[n-100000].  This needs\n+     special handling to avoid creating an indexed memory address\n+     with x-100000 as the base.  */\n+  if (GET_CODE (x) == PLUS\n+      && symbolic_operand (XEXP (x, 1), VOIDmode))\n+    {\n+      /* Ugly.  We modify things here so that the address offset specified\n+         by the index expression is computed first, then added to x to form\n+         the entire address.  */\n+\n+      rtx regx1, regx2, regy1, regy2, y;\n+\n+      /* Strip off any CONST.  */\n+      y = XEXP (x, 1);\n+      if (GET_CODE (y) == CONST)\n+        y = XEXP (y, 0);\n+\n+      regx1 = force_reg (Pmode, force_operand (XEXP (x, 0), 0));\n+      regy1 = force_reg (Pmode, force_operand (XEXP (y, 0), 0));\n+      regy2 = force_reg (Pmode, force_operand (XEXP (y, 1), 0));\n+      regx1 = force_reg (Pmode, gen_rtx (GET_CODE (y), Pmode, regx1, regy2));\n+      return force_reg (Pmode, gen_rtx (PLUS, Pmode, regx1, regy1));\n+    }\n+}"}, {"sha": "32016067b2e455cd33b12a09ac6050c4954e25af", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ad457396dc3779f36332630b5b02755f611cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ad457396dc3779f36332630b5b02755f611cb8/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=e9ad457396dc3779f36332630b5b02755f611cb8", "patch": "@@ -661,7 +661,7 @@ extern struct rtx_def *mn10300_builtin_saveregs ();\n \tbase = XEXP (X, 1), index = XEXP (X, 0);\t\\\n       if (base != 0 && index != 0)\t\t\t\\\n \t{\t\t\t\t\t\t\\\n-\t  if (CONSTANT_ADDRESS_P (index))\t\t\\\n+\t  if (GET_CODE (index) == CONST_INT)\t\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n \t  if (REG_P (index)\t\t\t\t\\\n \t      && REG_OK_FOR_INDEX_P (index)\t\t\\\n@@ -685,7 +685,12 @@ extern struct rtx_def *mn10300_builtin_saveregs ();\n    It is always safe for this macro to do nothing.  It exists to recognize\n    opportunities to optimize the output.   */\n \n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+extern struct rtx_def *legitimize_address ();\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  \\\n+{ rtx orig_x = (X);\t\t\t\t\\\n+  (X) = legitimize_address (X, OLDX, MODE);\t\\\n+  if ((X) != orig_x && memory_address_p (MODE, X)) \\\n+    goto WIN; }\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n@@ -998,3 +1003,4 @@ extern int impossible_plus_operand ();\n extern enum reg_class secondary_reload_class ();\n extern int initial_offset ();\n extern char *output_tst ();\n+int symbolic_operand ();"}]}