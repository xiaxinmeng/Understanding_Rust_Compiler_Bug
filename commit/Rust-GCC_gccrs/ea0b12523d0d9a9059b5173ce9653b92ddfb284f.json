{"sha": "ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWEwYjEyNTIzZDBkOWE5MDU5YjUxNzNjZTk2NTNiOTJkZGZiMjg0Zg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-02-18T13:28:22Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-02-18T13:28:22Z"}, "message": "Introduce -fprofile-reproducibility and support it with TOP N.\n\n\tPR ipa/92924\n\t* common.opt: Add -fprofile-reproducibility.\n\t* doc/invoke.texi: Document it.\n\t* value-prof.c (dump_histogram_value):\n\tDocument and support behavior for counters[0]\n\tbeing a negative value.\n\t(get_nth_most_common_value): Handle negative\n\tcounters[0] in respect to flag_profile_reproducible.\n\tPR ipa/92924\n\t* libgcov-merge.c (merge_topn_values_set): Record\n\twhen a TOP N counter becomes invalid.  When merging\n\tremove a smallest value if the space is needed.", "tree": {"sha": "76bb545094dd99e705bce5e82aa1456d7bcdd26e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76bb545094dd99e705bce5e82aa1456d7bcdd26e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl5L5nYACgkQTcGC3A+n\nN4W1MggAtdZv1znT4K6qxhelbQG8Btrj9FFBGzCE9keIGfh1RfzhtkJKXgX1RquP\nwjay1/KiKsfTZIxMmetVTfBBB1M3ys9am9cQ1IKUUh71smxDmUagnXp8BG3PZk2S\nUEhKm5kPWHPEUdP9JIjmGqWga5t98CKeOZ+EliXVmYl0VDISw1zqJEB9dQ956yhA\nifT33f7y0+QnUDEfpurQ+b02h3JaeXUkoniG7EuQCzCXdt5L3kU8kgjnO8VtqUgU\n3aVHeDC7p5QK0wu8x1zsmX0tYt+aYT5x4y0HbbknFRkWtsQeTZD7Ju1pw0oEuSH/\nxcl0hszorahzYjH6QfMouIrfXJRA9Q==\n=R3bG\n-----END PGP SIGNATURE-----", "payload": "tree 76bb545094dd99e705bce5e82aa1456d7bcdd26e\nparent 0b2b45a68f48817e2310b12db3e03e648d4d2005\nauthor Martin Liska <mliska@suse.cz> 1582032502 +0100\ncommitter Martin Liska <mliska@suse.cz> 1582032502 +0100\n\nIntroduce -fprofile-reproducibility and support it with TOP N.\n\n\tPR ipa/92924\n\t* common.opt: Add -fprofile-reproducibility.\n\t* doc/invoke.texi: Document it.\n\t* value-prof.c (dump_histogram_value):\n\tDocument and support behavior for counters[0]\n\tbeing a negative value.\n\t(get_nth_most_common_value): Handle negative\n\tcounters[0] in respect to flag_profile_reproducible.\n\tPR ipa/92924\n\t* libgcov-merge.c (merge_topn_values_set): Record\n\twhen a TOP N counter becomes invalid.  When merging\n\tremove a smallest value if the space is needed.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b2b45a68f48817e2310b12db3e03e648d4d2005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b2b45a68f48817e2310b12db3e03e648d4d2005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b2b45a68f48817e2310b12db3e03e648d4d2005"}], "stats": {"total": 151, "additions": 128, "deletions": 23}, "files": [{"sha": "db6740a500662488666bd942c3bb1338590fa22b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -1,3 +1,14 @@\n+2020-02-18  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/92924\n+\t* common.opt: Add -fprofile-reproducibility.\n+\t* doc/invoke.texi: Document it.\n+\t* value-prof.c (dump_histogram_value):\n+\tDocument and support behavior for counters[0]\n+\tbeing a negative value.\n+\t(get_nth_most_common_value): Handle negative\n+\tcounters[0] in respect to flag_profile_reproducible.\n+\n 2020-02-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR ipa/93797"}, {"sha": "fa9da505fc2766794e731312ef6394f75a940d82", "filename": "gcc/common.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -2168,6 +2168,22 @@ fprofile-exclude-files=\n Common Joined RejectNegative Var(flag_profile_exclude_files)\n Instrument only functions from files where names do not match all the regular expressions (separated by a semi-colon).\n \n+Enum\n+Name(profile_reproducibility) Type(enum profile_reproducibility) UnknownError(unknown profile reproducibility method %qs)\n+\n+EnumValue\n+Enum(profile_reproducibility) String(serial) Value(PROFILE_REPRODUCIBILITY_SERIAL)\n+\n+EnumValue\n+Enum(profile_reproducibility) String(parallel-runs) Value(PROFILE_REPRODUCIBILITY_PARALLEL_RUNS)\n+\n+EnumValue\n+Enum(profile_reproducibility) String(multithreaded) Value(PROFILE_REPRODUCIBILITY_MULTITHREADED)\n+\n+fprofile-reproducible\n+Common Joined RejectNegative Var(flag_profile_reproducible) Enum(profile_reproducibility) Init(PROFILE_REPRODUCIBILITY_SERIAL)\n+-fprofile-reproducible=[serial|parallel-runs|multithreaded] Control level of reproducibility of profile gathered by -fprofile-generate.\n+\n Enum\n Name(profile_update) Type(enum profile_update) UnknownError(unknown profile update method %qs)\n "}, {"sha": "cda22697cc39debc0a6be793a2bf6f2b104dd2d3", "filename": "gcc/coretypes.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -212,6 +212,13 @@ enum profile_update {\n   PROFILE_UPDATE_PREFER_ATOMIC\n };\n \n+/* Type of profile reproducibility methods.  */\n+enum profile_reproducibility {\n+    PROFILE_REPRODUCIBILITY_SERIAL,\n+    PROFILE_REPRODUCIBILITY_PARALLEL_RUNS,\n+    PROFILE_REPRODUCIBILITY_MULTITHREADED\n+};\n+\n /* Types of unwind/exception handling info that can be generated.  */\n \n enum unwind_info_type"}, {"sha": "ba2b7e42520f2cbbd5c534f393cfe2329ebbdb29", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -562,7 +562,7 @@ Objective-C and Objective-C++ Dialects}.\n -fprofile-abs-path @gol\n -fprofile-dir=@var{path}  -fprofile-generate  -fprofile-generate=@var{path} @gol\n -fprofile-note=@var{path}  -fprofile-update=@var{method} @gol\n--fprofile-filter-files=@var{regex}  -fprofile-exclude-files=@var{regex} @gol\n+-fprofile-filter-files=@var{regex}  -fprofile-exclude-files=@var{regex} -fprofile-reproducibility @gol\n -fsanitize=@var{style}  -fsanitize-recover  -fsanitize-recover=@var{style} @gol\n -fasan-shadow-offset=@var{number}  -fsanitize-sections=@var{s1},@var{s2},... @gol\n -fsanitize-undefined-trap-on-error  -fbounds-check @gol\n@@ -13360,6 +13360,35 @@ all the regular expressions (separated by a semi-colon).\n For example, @option{-fprofile-exclude-files=/usr/*} will prevent instrumentation\n of all files that are located in @file{/usr/} folder.\n \n+@item -fprofile-reproducible\n+@opindex fprofile-reproducible\n+Control level of reproducibility of profile gathered by\n+@code{-fprofile-generate}.  This makes it possible to rebuild program\n+with same outcome which is useful, for example, for distribution\n+packages.\n+\n+With @option{-fprofile-reproducibility=serial} the profile gathered by\n+@option{-fprofile-generate} is reproducible provided the trained program\n+behaves the same at each invocation of the train run, it is not\n+multi-threaded and profile data streaming is always done in the same\n+order.  Note that profile streaming happens at the end of program run but\n+also before @code{fork} function is invoked.\n+\n+Note that it is quite common that execution counts of some part of\n+programs depends, for example, on length of temporary file names or\n+memory space randomization (that may affect hash-table collision rate).\n+Such non-reproducible part of programs may be annotated by\n+@code{no_instrument_function} function attribute. @code{gcov-dump} with\n+@option{-l} can be used to dump gathered data and verify that they are\n+indeed reproducible.\n+\n+With @option{-fprofile-reproducibility=parallel-runs} collected profile\n+stays reproducible regardless the order of streaming of the data into\n+gcda files.  This setting makes it possible to run multiple instances of\n+instrumented program in parallel (such as with @code{make -j}). This\n+reduces quality of gathered data, in particular of indirect call\n+profiling.\n+\n @item -fsanitize=address\n @opindex fsanitize=address\n Enable AddressSanitizer, a fast memory error detector."}, {"sha": "5f940f40399058c288a55c387632519c72f907ad", "filename": "gcc/value-prof.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -265,8 +265,10 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)\n \t\t    ? \"Top N value counter\" : \"Indirect call counter\"));\n \t  if (hist->hvalue.counters)\n \t    {\n-\t      fprintf (dump_file, \" all: %\" PRId64 \", values: \",\n-\t\t       (int64_t) hist->hvalue.counters[0]);\n+\t      fprintf (dump_file, \" all: %\" PRId64 \"%s, values: \",\n+\t\t       abs ((int64_t) hist->hvalue.counters[0]),\n+\t\t       hist->hvalue.counters[0] < 0\n+\t\t       ? \" (values missing)\": \"\");\n \t      for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n \t\t{\n \t\t  fprintf (dump_file, \"[%\" PRId64 \":%\" PRId64 \"]\",\n@@ -719,26 +721,39 @@ gimple_divmod_fixed_value (gassign *stmt, tree value, profile_probability prob,\n \n /* Return the n-th value count of TOPN_VALUE histogram.  If\n    there's a value, return true and set VALUE and COUNT\n-   arguments.  */\n+   arguments.\n+\n+   Counters have the following meaning.\n+\n+   abs (counters[0]) is the number of executions\n+   for i in 0 ... TOPN-1\n+     counters[2 * i + 1] is target\n+     abs (counters[2 * i + 2]) is corresponding hitrate counter.\n+\n+   Value of counters[0] negative when counter became\n+   full during merging and some values are lost.  */\n \n bool\n get_nth_most_common_value (gimple *stmt, const char *counter_type,\n \t\t\t   histogram_value hist, gcov_type *value,\n \t\t\t   gcov_type *count, gcov_type *all, unsigned n)\n {\n-  if (hist->hvalue.counters[2] == -1)\n-    return false;\n-\n   gcc_assert (n < GCOV_TOPN_VALUES);\n \n   *count = 0;\n   *value = 0;\n \n-  gcov_type read_all = hist->hvalue.counters[0];\n+  gcov_type read_all = abs (hist->hvalue.counters[0]);\n \n   gcov_type v = hist->hvalue.counters[2 * n + 1];\n   gcov_type c = hist->hvalue.counters[2 * n + 2];\n \n+  if (hist->hvalue.counters[0] < 0\n+      && (flag_profile_reproducible == PROFILE_REPRODUCIBILITY_PARALLEL_RUNS\n+\t  || (flag_profile_reproducible\n+\t      == PROFILE_REPRODUCIBILITY_MULTITHREADED)))\n+    return false;\n+\n   /* Indirect calls can't be verified.  */\n   if (stmt\n       && check_counter (stmt, counter_type, &c, &read_all,"}, {"sha": "dedc308b3bcfad159c154f50e7804108f216029d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -1,3 +1,10 @@\n+2020-02-18  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/92924\n+\t* libgcov-merge.c (merge_topn_values_set): Record\n+\twhen a TOP N counter becomes invalid.  When merging\n+\tremove a smallest value if the space is needed.\n+\n 2020-02-12  Sandra Loosemore  <sandra@codesourcery.com>\n \n \tPR libstdc++/79193"}, {"sha": "c0785b0bf10d55c587e78393479db3af480984d8", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea0b12523d0d9a9059b5173ce9653b92ddfb284f/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=ea0b12523d0d9a9059b5173ce9653b92ddfb284f", "patch": "@@ -86,36 +86,47 @@ __gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n \n #ifdef L_gcov_merge_topn\n \n+/* To merging of TOPN profiles.\n+   counters[0] is the number of executions\n+   for i in 0 ... TOPN-1\n+     counters[2 * i + 1] is target\n+     counters[2 * i + 2] is corresponding hitrate counter.\n+\n+   Because we prune counters only those with probability >= 1/TOPN are\n+   present now.\n+\n+   We use sign of counters[0] to track whether the number of different\n+   targets exceeds TOPN.  */\n+\n static void\n merge_topn_values_set (gcov_type *counters)\n {\n   /* First value is number of total executions of the profiler.  */\n-  gcov_type all = gcov_get_counter_ignore_scaling (-1);\n-  counters[0] += all;\n+  gcov_type all = gcov_get_counter ();\n+  gcov_type *total = &counters[0];\n   ++counters;\n \n+  /* Negative value means that counter is missing some of values.  */\n+  if (all < 0)\n+    *total = -(*total);\n+\n+  *total += all;\n+\n   /* Read all part values.  */\n   gcov_type read_counters[2 * GCOV_TOPN_VALUES];\n-\n   for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n     {\n       read_counters[2 * i] = gcov_get_counter_target ();\n       read_counters[2 * i + 1] = gcov_get_counter_ignore_scaling (-1);\n     }\n \n-  if (read_counters[1] == -1)\n-    {\n-      counters[1] = -1;\n-      return;\n-    }\n-\n   for (unsigned i = 0; i < GCOV_TOPN_VALUES; i++)\n     {\n       if (read_counters[2 * i + 1] == 0)\n \tcontinue;\n \n       unsigned j;\n-      int slot = -1;\n+      int slot = 0;\n \n       for (j = 0; j < GCOV_TOPN_VALUES; j++)\n \t{\n@@ -124,23 +135,32 @@ merge_topn_values_set (gcov_type *counters)\n \t      counters[2 * j + 1] += read_counters[2 * i + 1];\n \t      break;\n \t    }\n-\t  else if (counters[2 * j + 1] == 0)\n+\t  else if (counters[2 * j + 1] < counters[2 * slot + 1])\n \t    slot = j;\n \t}\n \n       if (j == GCOV_TOPN_VALUES)\n \t{\n-\t  if (slot > 0)\n+\t  gcov_type slot_count = counters[2 * slot + 1];\n+\t  /* We found an empty slot.  */\n+\t  if (slot_count == 0)\n \t    {\n \t      /* If we found empty slot, add the value.  */\n \t      counters[2 * slot] = read_counters[2 * i];\n \t      counters[2 * slot + 1] = read_counters[2 * i + 1];\n \t    }\n \t  else\n \t    {\n-\t      /* We haven't found a slot, bail out.  */\n-\t      counters[1] = -1;\n-\t      return;\n+\t      /* Here we are loosing some values.  */\n+\t      if (*total >= 0)\n+\t\t*total = -(*total);\n+\t      if (read_counters[2 * i + 1] > slot_count)\n+\t\t{\n+\t\t  counters[2 * slot] = read_counters[2 * i];\n+\t\t  counters[2 * slot + 1] = read_counters[2 * i + 1];\n+\t\t}\n+\t      else\n+\t\tcounters[2 * slot + 1] -= read_counters[2 * i + 1];\n \t    }\n \t}\n     }"}]}