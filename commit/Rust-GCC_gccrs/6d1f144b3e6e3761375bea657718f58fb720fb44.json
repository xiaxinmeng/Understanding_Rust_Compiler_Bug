{"sha": "6d1f144b3e6e3761375bea657718f58fb720fb44", "node_id": "C_kwDOANBUbNoAKDZkMWYxNDRiM2U2ZTM3NjEzNzViZWE2NTc3MThmNThmYjcyMGZiNDQ", "commit": {"author": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2022-08-24T11:07:57Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2022-08-24T13:25:18Z"}, "message": "bpf: facilitate constant propagation of function addresses\n\neBPF effectively supports two kind of call instructions:\n\n- The so called pseudo-calls (\"bpf to bpf\").\n- External calls (\"bpf to kernel\").\n\nThe BPF call instruction always gets an immediate argument, whose\ninterpretation varies depending on the purpose of the instruction:\n\n- For pseudo-calls, the immediate argument is interpreted as a\n  32-bit PC-relative displacement measured in number of 64-bit words\n  minus one.\n\n- For external calls, the immediate argument is interpreted as the\n  identification of a kernel helper.\n\nIn order to differenciate both flavors of CALL instructions the SRC\nfield of the instruction (otherwise unused) is abused as an opcode;\nif the field holds 0 the instruction is an external call, if it holds\nBPF_PSEUDO_CALL the instruction is a pseudo-call.\n\nC-to-BPF toolchains, including the GNU toolchain, use the following\npractical heuristic at assembly time in order to determine what kind\nof CALL instruction to generate: call instructions requiring a fixup\nat assembly time are interpreted as pseudo-calls.  This means that in\npractice a call instruction involving symbols at assembly time (such\nas `call foo') is assembled into a pseudo-call instruction, whereas\nsomething like `call 12' is assembled into an external call\ninstruction.\n\nIn both cases, the argument of CALL is an immediate: at the time of\nwriting eBPF lacks support for indirect calls, i.e. there is no\ncall-to-register instruction.\n\nThis is the reason why BPF programs, in practice, rely on certain\noptimizations to happen in order to generate calls to immediates.\nThis is a typical example involving a kernel helper:\n\n  static void * (*bpf_map_lookup_elem)(void *map, const void *key)\n    = (void *) 1;\n\n  int foo (...)\n  {\n    char *ret;\n\n    ret = bpf_map_lookup_elem (args...);\n    if (ret)\n      return 1;\n    return 0;\n  }\n\nNote how the code above relies on the compiler to do constant\npropagation so the call to bpf_map_lookup_elem can be compiled to a\n`call 1' instruction.\n\nWhile GCC provides a kernel_helper function declaration attribute that\ncan be used in a robust way to tell GCC to generate an external call\ndespite of optimization level and any other consideration, the Linux\nkernel bpf_helpers.h file relies on tricks like the above.\n\nThis patch modifies the BPF backend to avoid SSA sparse constant\npropagation to be \"undone\" by the expander loading the function\naddress into a register.  A new test is also added.\n\nTested in bpf-unknown-linux-gnu.\nNo regressions.\n\ngcc/ChangeLog:\n\n\tPR target/106733\n\t* config/bpf/bpf.cc (bpf_legitimate_address_p): Recognize integer\n\tconstants as legitimate addresses for functions.\n\t(bpf_small_register_classes_for_mode_p): Define target hook.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/106733\n\t* gcc.target/bpf/constant-calls.c: Rename to ...\n\t* gcc.target/bpf/constant-calls-1.c: and modify to not expect\n\tfailure anymore.\n\t* gcc.target/bpf/constant-calls-2.c: New test.", "tree": {"sha": "0eb2dd8800ffde34e12da51ecb02537eb806cbf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0eb2dd8800ffde34e12da51ecb02537eb806cbf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d1f144b3e6e3761375bea657718f58fb720fb44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1f144b3e6e3761375bea657718f58fb720fb44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1f144b3e6e3761375bea657718f58fb720fb44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1f144b3e6e3761375bea657718f58fb720fb44/comments", "author": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f04e1dffea609cb74ac0b488385401ed7e15a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f04e1dffea609cb74ac0b488385401ed7e15a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0f04e1dffea609cb74ac0b488385401ed7e15a3"}], "stats": {"total": 38, "additions": 36, "deletions": 2}, "files": [{"sha": "7e37e080808e71b7c245987c0cea612f557eb27d", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1f144b3e6e3761375bea657718f58fb720fb44/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1f144b3e6e3761375bea657718f58fb720fb44/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=6d1f144b3e6e3761375bea657718f58fb720fb44", "patch": "@@ -659,12 +659,15 @@ bpf_address_base_p (rtx x, bool strict)\n    target machine for a memory operand of mode MODE.  */\n \n static bool\n-bpf_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,\n+bpf_legitimate_address_p (machine_mode mode,\n \t\t\t  rtx x,\n \t\t\t  bool strict)\n {\n   switch (GET_CODE (x))\n     {\n+    case CONST_INT:\n+      return (mode == FUNCTION_MODE);\n+\n     case REG:\n       return bpf_address_base_p (x, strict);\n \n@@ -1311,6 +1314,22 @@ bpf_core_walk (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+/* Implement target hook small_register_classes_for_mode_p.  */\n+\n+static bool\n+bpf_small_register_classes_for_mode_p (machine_mode mode)\n+{\n+  if (TARGET_XBPF)\n+    return 1;\n+  else\n+    /* Avoid putting function addresses in registers, as calling these\n+       is not supported in eBPF.  */\n+    return (mode != FUNCTION_MODE);\n+}\n+\n+#undef TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P\n+#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P \\\n+  bpf_small_register_classes_for_mode_p\n \n /* Implement TARGET_RESOLVE_OVERLOADED_BUILTIN (see gccint manual section\n    Target Macros::Misc.)."}, {"sha": "6effc7dfdd479e62fed6a549cc1350d0de3d4c65", "filename": "gcc/testsuite/gcc.target/bpf/constant-calls-1.c", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1f144b3e6e3761375bea657718f58fb720fb44/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fconstant-calls-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1f144b3e6e3761375bea657718f58fb720fb44/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fconstant-calls-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fconstant-calls-1.c?ref=6d1f144b3e6e3761375bea657718f58fb720fb44", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do compile } */\n-/* { dg-xfail-if \"\" { bpf-*-* } } */\n \n typedef void  *(*T)(void);\n f1 ()", "previous_filename": "gcc/testsuite/gcc.target/bpf/constant-calls.c"}, {"sha": "836ab67a1fdfab94f8516218c25dbb0094789a58", "filename": "gcc/testsuite/gcc.target/bpf/constant-calls-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d1f144b3e6e3761375bea657718f58fb720fb44/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fconstant-calls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d1f144b3e6e3761375bea657718f58fb720fb44/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fconstant-calls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fbpf%2Fconstant-calls-2.c?ref=6d1f144b3e6e3761375bea657718f58fb720fb44", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c89 -O2\" } */\n+\n+static void * (*bpf_map_lookup_elem)(void *map, const void *key) = (void *) 666;\n+\n+int foo ()\n+{\n+  char *ret;\n+\n+  ret = bpf_map_lookup_elem (ret, ret);\n+  if (ret)\n+    return 0;\n+  return 1;\n+}\n+\n+/* { dg-final { scan-assembler \"call\\t666\" } } */"}]}