{"sha": "60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBmYTY2NjBkOGM5MDk5YzhlNGI1ZjFjYjA4Y2MwMTkwOTUyY2E0ZQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2003-04-17T01:07:12Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2003-04-17T01:07:12Z"}, "message": "reload1.c (reload_cse_noop_set_p): Return false if mode of SET_DEST is not the same as that returned by...\n\n* reload1.c (reload_cse_noop_set_p): Return false if mode of\nSET_DEST is not the same as that returned by...\n* cselib.h (cselib_reg_set_mode): ... new function.\n* cselib.c (cselib_reg_set_mode): Define it.\n(REG_VALUES): Document semantics of first element as set mode.\n(cselib_subst_to_values): Skip first element if ELT is NULL.\n(cselib_lookup): Likewise.  Insert past the first element.\n(cselib_invalidate_regno): NULLify first element.\n(cselib_record_set): Set first element.\n\nFrom-SVN: r65713", "tree": {"sha": "734df64947b1d93b8aba3d34f7bad616eb0950ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/734df64947b1d93b8aba3d34f7bad616eb0950ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/comments", "author": null, "committer": null, "parents": [{"sha": "e34d367d2d352f944ef2df4beea0e39e5ede02ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e34d367d2d352f944ef2df4beea0e39e5ede02ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e34d367d2d352f944ef2df4beea0e39e5ede02ce"}], "stats": {"total": 104, "additions": 88, "deletions": 16}, "files": [{"sha": "a34da4061a7572545932ec8e2a63484ce806a32b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "patch": "@@ -1,3 +1,15 @@\n+2003-04-16  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* reload1.c (reload_cse_noop_set_p): Return false if mode of\n+\tSET_DEST is not the same as that returned by...\n+\t* cselib.h (cselib_reg_set_mode): ... new function.\n+\t* cselib.c (cselib_reg_set_mode): Define it.\n+\t(REG_VALUES): Document semantics of first element as set mode.\n+\t(cselib_subst_to_values): Skip first element if ELT is NULL.\n+\t(cselib_lookup): Likewise.  Insert past the first element.\n+\t(cselib_invalidate_regno): NULLify first element.\n+\t(cselib_record_set): Set first element.\n+\n 2003-04-16  Olivier Hainque <hainque@act-europe.fr>\n \n         * tree.c (skip_simple_arithmetics_at, saved_expr_p): New functions."}, {"sha": "cf3394f237a290249133de5b1d2db5a92dc4d85b", "filename": "gcc/cselib.c", "status": "modified", "additions": 71, "deletions": 15, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination library for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -99,9 +99,13 @@ static int n_useless_values;\n /* Number of useless values before we remove them from the hash table.  */\n #define MAX_USELESS_VALUES 32\n \n-/* This table maps from register number to values.  It does not contain\n-   pointers to cselib_val structures, but rather elt_lists.  The purpose is\n-   to be able to refer to the same register in different modes.  */\n+/* This table maps from register number to values.  It does not\n+   contain pointers to cselib_val structures, but rather elt_lists.\n+   The purpose is to be able to refer to the same register in\n+   different modes.  The first element of the list defines the mode in\n+   which the register was set; if the mode is unknown or the value is\n+   no longer valid in that mode, ELT will be NULL for the first\n+   element.  */\n static GTY(()) varray_type reg_values;\n static GTY((deletable (\"\"))) varray_type reg_values_old;\n #define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n@@ -402,6 +406,25 @@ remove_useless_values ()\n     abort ();\n }\n \n+/* Return the mode in which a register was last set.  If X is not a\n+   register, return its mode.  If the mode in which the register was\n+   set is not known, or the value was already clobbered, return\n+   VOIDmode.  */\n+\n+enum machine_mode\n+cselib_reg_set_mode (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) != REG)\n+    return GET_MODE (x);\n+\n+  if (REG_VALUES (REGNO (x)) == NULL\n+      || REG_VALUES (REGNO (x))->elt == NULL)\n+    return VOIDmode;\n+\n+  return GET_MODE (REG_VALUES (REGNO (x))->elt->u.val_rtx);\n+}\n+\n /* Return nonzero if we can prove that X and Y contain the same value, taking\n    our gathered information into account.  */\n \n@@ -812,7 +835,10 @@ cselib_subst_to_values (x)\n   switch (code)\n     {\n     case REG:\n-      for (l = REG_VALUES (REGNO (x)); l; l = l->next)\n+      l = REG_VALUES (REGNO (x));\n+      if (l && l->elt == NULL)\n+\tl = l->next;\n+      for (; l; l = l->next)\n \tif (GET_MODE (l->elt->u.val_rtx) == GET_MODE (x))\n \t  return l->elt->u.val_rtx;\n \n@@ -909,7 +935,10 @@ cselib_lookup (x, mode, create)\n       struct elt_list *l;\n       unsigned int i = REGNO (x);\n \n-      for (l = REG_VALUES (i); l; l = l->next)\n+      l = REG_VALUES (i);\n+      if (l && l->elt == NULL)\n+\tl = l->next;\n+      for (; l; l = l->next)\n \tif (mode == GET_MODE (l->elt->u.val_rtx))\n \t  return l->elt;\n \n@@ -927,8 +956,14 @@ cselib_lookup (x, mode, create)\n       e = new_cselib_val (++next_unknown_value, GET_MODE (x));\n       e->locs = new_elt_loc_list (e->locs, x);\n       if (REG_VALUES (i) == 0)\n-        VARRAY_PUSH_UINT (used_regs, i);\n-      REG_VALUES (i) = new_elt_list (REG_VALUES (i), e);\n+\t{\n+\t  /* Maintain the invariant that the first entry of\n+\t     REG_VALUES, if present, must be the value used to set the\n+\t     register, or NULL.  */\n+\t  VARRAY_PUSH_UINT (used_regs, i);\n+\t  REG_VALUES (i) = new_elt_list (REG_VALUES (i), NULL);\n+\t}\n+      REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n       slot = htab_find_slot_with_hash (hash_table, x, e->value, INSERT);\n       *slot = e;\n       return e;\n@@ -1011,17 +1046,28 @@ cselib_invalidate_regno (regno, mode)\n \t  struct elt_loc_list **p;\n \t  unsigned int this_last = i;\n \n-\t  if (i < FIRST_PSEUDO_REGISTER)\n+\t  if (i < FIRST_PSEUDO_REGISTER && v != NULL)\n \t    this_last += HARD_REGNO_NREGS (i, GET_MODE (v->u.val_rtx)) - 1;\n \n-\t  if (this_last < regno)\n+\t  if (this_last < regno || v == NULL)\n \t    {\n \t      l = &(*l)->next;\n \t      continue;\n \t    }\n \n \t  /* We have an overlap.  */\n-\t  unchain_one_elt_list (l);\n+\t  if (*l == REG_VALUES (i))\n+\t    {\n+\t      /* Maintain the invariant that the first entry of\n+\t\t REG_VALUES, if present, must be the value used to set\n+\t\t the register, or NULL.  This is also nice because\n+\t\t then we won't push the same regno onto user_regs\n+\t\t multiple times.  */\n+\t      (*l)->elt = NULL;\n+\t      l = &(*l)->next;\n+\t    }\n+\t  else\n+\t    unchain_one_elt_list (l);\n \n \t  /* Now, we clear the mapping from value to reg.  It must exist, so\n \t     this code will crash intentionally if it doesn't.  */\n@@ -1213,9 +1259,6 @@ cselib_record_set (dest, src_elt, dest_addr_elt)\n \n   if (dreg >= 0)\n     {\n-      if (REG_VALUES (dreg) == 0)\n-        VARRAY_PUSH_UINT (used_regs, dreg);\n-\n       if (dreg < FIRST_PSEUDO_REGISTER)\n \t{\n \t  unsigned int n = HARD_REGNO_NREGS (dreg, GET_MODE (dest));\n@@ -1224,7 +1267,20 @@ cselib_record_set (dest, src_elt, dest_addr_elt)\n \t    max_value_regs = n;\n \t}\n \n-      REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n+      if (REG_VALUES (dreg) == 0)\n+\t{\n+\t  VARRAY_PUSH_UINT (used_regs, dreg);\n+\t  REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n+\t}\n+      else\n+\t{\n+\t  if (REG_VALUES (dreg)->elt == 0)\n+\t    REG_VALUES (dreg)->elt = src_elt;\n+\t  else\n+\t    /* The register should have been invalidated.  */\n+\t    abort ();\n+\t}\n+\n       if (src_elt->locs == 0)\n \tn_useless_values--;\n       src_elt->locs = new_elt_loc_list (src_elt->locs, dest);"}, {"sha": "073384d85ab4640727bee52738d0f794abea397c", "filename": "gcc/cselib.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999 Free Software Foundation, Inc.\n+   1999, 2003 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -67,6 +67,7 @@ extern void cselib_update_varray_sizes\tPARAMS ((void));\n extern void cselib_init\t\t\tPARAMS ((void));\n extern void cselib_finish\t\tPARAMS ((void));\n extern void cselib_process_insn\t\tPARAMS ((rtx));\n+extern enum machine_mode cselib_reg_set_mode PARAMS ((rtx));\n extern int rtx_equal_for_cselib_p\tPARAMS ((rtx, rtx));\n extern int references_value_p\t\tPARAMS ((rtx, int));\n extern rtx cselib_subst_to_values\tPARAMS ((rtx));"}, {"sha": "54d163ee00ce0cbb9e66e2f7427fe1200f043311", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=60fa6660d8c9099c8e4b5f1cb08cc0190952ca4e", "patch": "@@ -8025,6 +8025,9 @@ static int\n reload_cse_noop_set_p (set)\n      rtx set;\n {\n+  if (cselib_reg_set_mode (SET_DEST (set)) != GET_MODE (SET_DEST (set)))\n+    return 0;\n+\n   return rtx_equal_for_cselib_p (SET_DEST (set), SET_SRC (set));\n }\n "}]}