{"sha": "d151d6a357e5336c4a3dd16c440b1d54eaab3639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1MWQ2YTM1N2U1MzM2YzRhM2RkMTZjNDQwYjFkNTRlYWFiMzYzOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T09:30:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-09-09T09:30:25Z"}, "message": "[multiple changes]\n\n2010-09-09  Robert Dewar  <dewar@adacore.com>\n\n\t* prj-env.adb: Minor code reorganization.\n\t* par-ch3.adb: Minor reformatting.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\n2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch9.adb (Build_Activation_Chain_Entity): The construct enclosing\n\ta task declaration can be an entry body.\n\n2010-09-09  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb (Make_DT): Decorate as \"static\" variables containing\n\ttags of library level tagged types.\n\t(Make_Tags): Disable backend optimizations about aliasing for\n\tdeclarations of access to dispatch tables.\n\n2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Reset_Entity): If the entity is an itype created as a\n\tsubtype for a null-excluding access type, recover the original\n\tsubtype_mark to get the proper visibility on the original name.\n\n2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch3.adb (Build_Untagged_Equality): For Ada2012, new procedure to\n\tcreate the primitive equality operation for an untagged record. The\n\toperation is the predefined equality if no record component has a\n\tuser-defined equality, or if there is a user-defined equality for the\n\ttype as a whole, or when the type is derived and it has an inherited\n\tequality. Otherwise the body of the operations is built as for tagged\n\ttypes.\n\t(Expand_Freeze_Record_Type): Call Build_Untagged_Equality when needed.\n\t(Make_Eq_Body): New function to create the expanded body of the equality\n\toperation for tagged and untagged records.  In both cases the operation\n\tcomposes, and the primitive operation of each record component is used\n\tto generate the equality function for the type.\n\t* exp_ch4.adb (Expand_Composite_Equality): In Ada2012, if a component\n\thas an abstract equality defined, replace its call with a\n\tRaise_Program_Error.\n\t* sem_ch6.adb (New_Overloaded_Entity): if Ada2012, verify that a\n\tuser-defined equality operator for an untagged record type does not\n\thappen after type is frozen, and appears in the visible part if partial\n\tview of type is not limited.\n\n2010-09-09  Tristan Gingold  <gingold@adacore.com>\n\n\t* gnatlbr.adb: Make Create_Directory more portable: use __gnat_mkdir.\n\n2010-09-09  Bob Duff  <duff@adacore.com>\n\n\t* gnat_ugn.texi: Remove incorrect statement about -E being the default.\n\nFrom-SVN: r164055", "tree": {"sha": "03c02110dc23c5d5b1ba8f33d7893b76d1b19134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03c02110dc23c5d5b1ba8f33d7893b76d1b19134"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d151d6a357e5336c4a3dd16c440b1d54eaab3639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d151d6a357e5336c4a3dd16c440b1d54eaab3639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d151d6a357e5336c4a3dd16c440b1d54eaab3639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d151d6a357e5336c4a3dd16c440b1d54eaab3639/comments", "author": null, "committer": null, "parents": [{"sha": "3a207e62b364d4f09efda25e9bb4bb1b4845710c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a207e62b364d4f09efda25e9bb4bb1b4845710c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a207e62b364d4f09efda25e9bb4bb1b4845710c"}], "stats": {"total": 548, "additions": 433, "deletions": 115}, "files": [{"sha": "cf4023d485392d4cce68f872eb771cceb645b664", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -1,3 +1,57 @@\n+2010-09-09  Robert Dewar  <dewar@adacore.com>\n+\n+\t* prj-env.adb: Minor code reorganization.\n+\t* par-ch3.adb: Minor reformatting.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch9.adb (Build_Activation_Chain_Entity): The construct enclosing\n+\ta task declaration can be an entry body.\n+\n+2010-09-09  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb (Make_DT): Decorate as \"static\" variables containing\n+\ttags of library level tagged types.\n+\t(Make_Tags): Disable backend optimizations about aliasing for\n+\tdeclarations of access to dispatch tables.\n+\n+2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Reset_Entity): If the entity is an itype created as a\n+\tsubtype for a null-excluding access type, recover the original\n+\tsubtype_mark to get the proper visibility on the original name.\n+\n+2010-09-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Untagged_Equality): For Ada2012, new procedure to\n+\tcreate the primitive equality operation for an untagged record. The\n+\toperation is the predefined equality if no record component has a\n+\tuser-defined equality, or if there is a user-defined equality for the\n+\ttype as a whole, or when the type is derived and it has an inherited\n+\tequality. Otherwise the body of the operations is built as for tagged\n+\ttypes.\n+\t(Expand_Freeze_Record_Type): Call Build_Untagged_Equality when needed.\n+\t(Make_Eq_Body): New function to create the expanded body of the equality\n+\toperation for tagged and untagged records.  In both cases the operation\n+\tcomposes, and the primitive operation of each record component is used\n+\tto generate the equality function for the type.\n+\t* exp_ch4.adb (Expand_Composite_Equality): In Ada2012, if a component\n+\thas an abstract equality defined, replace its call with a\n+\tRaise_Program_Error.\n+\t* sem_ch6.adb (New_Overloaded_Entity): if Ada2012, verify that a\n+\tuser-defined equality operator for an untagged record type does not\n+\thappen after type is frozen, and appears in the visible part if partial\n+\tview of type is not limited.\n+\n+2010-09-09  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* gnatlbr.adb: Make Create_Directory more portable: use __gnat_mkdir.\n+\n+2010-09-09  Bob Duff  <duff@adacore.com>\n+\n+\t* gnat_ugn.texi: Remove incorrect statement about -E being the default.\n+\n 2010-09-09  Pascal Obry  <obry@adacore.com>\n \n \t* gnat_ugn.texi: Update doc on windows related topics."}, {"sha": "8fc874cd91c51d26e127e41eb2d2e8e57aae4c9b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 238, "deletions": 63, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -141,6 +141,12 @@ package body Exp_Ch3 is\n    --  the code expansion for controlled components (when control actions\n    --  are active) can lead to very large blocks that GCC3 handles poorly.\n \n+   procedure Build_Untagged_Equality (Typ : Entity_Id);\n+   --  AI05-0123: equality on untagged records composes. This procedure\n+   --  build the equality routine for an untagged record that has components\n+   --  of a record type that have user-defined primitive equality operations.\n+   --  The resulting operation is a TSS subprogram.\n+\n    procedure Build_Variant_Record_Equality (Typ  : Entity_Id);\n    --  Create An Equality function for the non-tagged variant record 'Typ'\n    --  and attach it to the TSS list\n@@ -220,6 +226,13 @@ package body Exp_Ch3 is\n    function Is_Variable_Size_Record (E : Entity_Id) return Boolean;\n    --  Returns true if E has variable size components\n \n+   function Make_Eq_Body\n+     (Typ     : Entity_Id;\n+      Eq_Name : Name_Id) return Node_Id;\n+   --  Build the body of a primitive equality operation for a tagged record\n+   --  type, or in Ada2012 for any record type that has components with a\n+   --  user-defined equality. Factored out of Predefined_Primitive_Bodies.\n+\n    function Make_Eq_Case\n      (E     : Entity_Id;\n       CL    : Node_Id;\n@@ -3745,6 +3758,147 @@ package body Exp_Ch3 is\n       Set_Is_Pure (Proc_Name);\n    end Build_Slice_Assignment;\n \n+   -----------------------------\n+   -- Build_Untagged_Equality --\n+   -----------------------------\n+\n+   procedure Build_Untagged_Equality (Typ : Entity_Id) is\n+      Build_Eq : Boolean;\n+      Comp     : Entity_Id;\n+      Decl     : Node_Id;\n+      Op       : Entity_Id;\n+      Prim     : Elmt_Id;\n+      Eq_Op    : Entity_Id;\n+\n+      function User_Defined_Eq (T : Entity_Id) return Entity_Id;\n+      --  Check whether the type T has a user-defined primitive\n+      --  equality. If true for a component of Typ, we have to\n+      --  build the primitive equality for it.\n+\n+      ---------------------\n+      -- User_Defined_Eq --\n+      ---------------------\n+\n+      function User_Defined_Eq (T : Entity_Id) return Entity_Id is\n+         Prim : Elmt_Id;\n+         Op   : Entity_Id;\n+\n+      begin\n+         Op := TSS (T, TSS_Composite_Equality);\n+\n+         if Present (Op) then\n+            return Op;\n+         end if;\n+\n+         Prim := First_Elmt (Collect_Primitive_Operations (T));\n+         while Present (Prim) loop\n+            Op := Node (Prim);\n+\n+            if Chars (Op) = Name_Op_Eq\n+              and then Etype (Op) = Standard_Boolean\n+              and then Etype (First_Formal (Op)) = T\n+              and then Etype (Next_Formal (First_Formal (Op))) = T\n+            then\n+               return Op;\n+            end if;\n+\n+            Next_Elmt (Prim);\n+         end loop;\n+\n+         return Empty;\n+      end User_Defined_Eq;\n+\n+   --  Start of processing for Build_Untagged_Equality\n+\n+   begin\n+      --  If a record component has a primitive equality operation, we must\n+      --  builde the corresponding one for the current type.\n+\n+      Build_Eq := False;\n+      Comp := First_Component (Typ);\n+      while Present (Comp) loop\n+         if Is_Record_Type (Etype (Comp))\n+           and then Present (User_Defined_Eq (Etype (Comp)))\n+         then\n+            Build_Eq := True;\n+         end if;\n+\n+         Next_Component (Comp);\n+      end loop;\n+\n+      --  If there is a user-defined equality for the type, we do not create\n+      --  the implicit one.\n+\n+      Prim := First_Elmt (Collect_Primitive_Operations (Typ));\n+      Eq_Op := Empty;\n+      while Present (Prim) loop\n+         if Chars (Node (Prim)) = Name_Op_Eq\n+           and then Comes_From_Source (Node (Prim))\n+         then\n+            Eq_Op := Node (Prim);\n+            Build_Eq := False;\n+            exit;\n+         end if;\n+\n+         Next_Elmt (Prim);\n+      end loop;\n+\n+      --  If the type is derived, inherit the operation, if present, from the\n+      --  parent type. It may have been declared after the type derivation.\n+      --  If the parent type itself is derived, it may have inherited an\n+      --  operation that has itself been overridden, so update its alias\n+      --  and related flags. Ditto for inequality.\n+\n+      if No (Eq_Op) and then Is_Derived_Type (Typ) then\n+         Prim := First_Elmt (Collect_Primitive_Operations (Etype (Typ)));\n+         while Present (Prim) loop\n+            if Chars (Node (Prim)) = Name_Op_Eq then\n+               Copy_TSS (Node (Prim), Typ);\n+               Build_Eq := False;\n+\n+               declare\n+                  Op    : constant Entity_Id := User_Defined_Eq (Typ);\n+                  Eq_Op : constant Entity_Id := Node (Prim);\n+                  NE_Op : constant Entity_Id := Next_Entity (Eq_Op);\n+\n+               begin\n+                  if Present (Op) then\n+                     Set_Alias (Op, Eq_Op);\n+                     Set_Is_Abstract_Subprogram\n+                       (Op, Is_Abstract_Subprogram (Eq_Op));\n+\n+                     if Chars (Next_Entity (Op)) = Name_Op_Ne then\n+                        Set_Alias (Next_Entity (Op), NE_Op);\n+                        Set_Is_Abstract_Subprogram\n+                          (Next_Entity (Op), Is_Abstract_Subprogram (NE_Op));\n+                     end if;\n+                  end if;\n+               end;\n+\n+               exit;\n+            end if;\n+\n+            Next_Elmt (Prim);\n+         end loop;\n+      end if;\n+\n+      --  If not inherited and not user-defined, build body as for a type\n+      --  with tagged components.\n+\n+      if Build_Eq then\n+         Decl :=\n+           Make_Eq_Body\n+             (Typ, Make_TSS_Name (Typ, TSS_Composite_Equality));\n+         Op := Defining_Entity (Decl);\n+         Set_TSS (Typ, Op);\n+         Set_Is_Pure (Op);\n+\n+         if Is_Library_Level_Entity (Typ) then\n+            Set_Is_Public (Op);\n+         end if;\n+      end if;\n+   end Build_Untagged_Equality;\n+\n    ------------------------------------\n    -- Build_Variant_Record_Equality --\n    ------------------------------------\n@@ -6026,8 +6180,10 @@ package body Exp_Ch3 is\n             end if;\n          end if;\n \n-      --  In the non-tagged case, an equality function is provided only for\n-      --  variant records (that are not unchecked unions).\n+      --  In the non-tagged case, ever since Ada83 an equality function must\n+      --  be  provided for variant records that are not unchecked unions.\n+      --  In Ada2012 the equality function composes, and thus must be built\n+      --  explicitly just as for tagged records.\n \n       elsif Has_Discriminants (Def_Id)\n         and then not Is_Limited_Type (Def_Id)\n@@ -6043,6 +6199,12 @@ package body Exp_Ch3 is\n                Build_Variant_Record_Equality (Def_Id);\n             end if;\n          end;\n+\n+      elsif Ada_Version >= Ada_12\n+        and then Comes_From_Source (Def_Id)\n+        and then Convention (Def_Id) = Convention_Ada\n+      then\n+         Build_Untagged_Equality (Def_Id);\n       end if;\n \n       --  Before building the record initialization procedure, if we are\n@@ -7638,6 +7800,79 @@ package body Exp_Ch3 is\n       end loop;\n    end Make_Controlling_Function_Wrappers;\n \n+   -------------------\n+   --  Make_Eq_Body --\n+   -------------------\n+\n+   function Make_Eq_Body\n+     (Typ     : Entity_Id;\n+      Eq_Name : Name_Id) return Node_Id\n+   is\n+      Loc          : constant Source_Ptr := Sloc (Parent (Typ));\n+      Decl         : Node_Id;\n+      Def          : constant Node_Id := Parent (Typ);\n+      Stmts        : constant List_Id := New_List;\n+      Variant_Case : Boolean := Has_Discriminants (Typ);\n+      Comps        : Node_Id := Empty;\n+      Typ_Def      : Node_Id := Type_Definition (Def);\n+\n+   begin\n+      Decl :=\n+        Predef_Spec_Or_Body (Loc,\n+          Tag_Typ => Typ,\n+          Name    => Eq_Name,\n+          Profile => New_List (\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier =>\n+                Make_Defining_Identifier (Loc, Name_X),\n+              Parameter_Type      => New_Reference_To (Typ, Loc)),\n+\n+            Make_Parameter_Specification (Loc,\n+              Defining_Identifier =>\n+                Make_Defining_Identifier (Loc, Name_Y),\n+              Parameter_Type      => New_Reference_To (Typ, Loc))),\n+\n+          Ret_Type => Standard_Boolean,\n+          For_Body => True);\n+\n+      if Variant_Case then\n+         if Nkind (Typ_Def) = N_Derived_Type_Definition then\n+            Typ_Def := Record_Extension_Part (Typ_Def);\n+         end if;\n+\n+         if Present (Typ_Def) then\n+            Comps := Component_List (Typ_Def);\n+         end if;\n+\n+         Variant_Case := Present (Comps)\n+           and then Present (Variant_Part (Comps));\n+      end if;\n+\n+      if Variant_Case then\n+         Append_To (Stmts,\n+           Make_Eq_If (Typ, Discriminant_Specifications (Def)));\n+         Append_List_To (Stmts, Make_Eq_Case (Typ, Comps));\n+         Append_To (Stmts,\n+           Make_Simple_Return_Statement (Loc,\n+             Expression => New_Reference_To (Standard_True, Loc)));\n+\n+      else\n+         Append_To (Stmts,\n+           Make_Simple_Return_Statement (Loc,\n+             Expression =>\n+               Expand_Record_Equality\n+                 (Typ,\n+                  Typ    => Typ,\n+                  Lhs    => Make_Identifier (Loc, Name_X),\n+                  Rhs    => Make_Identifier (Loc, Name_Y),\n+                  Bodies => Declarations (Decl))));\n+      end if;\n+\n+      Set_Handled_Statement_Sequence\n+        (Decl, Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+      return Decl;\n+   end Make_Eq_Body;\n+\n    ------------------\n    -- Make_Eq_Case --\n    ------------------\n@@ -8667,67 +8902,7 @@ package body Exp_Ch3 is\n          --  Body for equality\n \n          if Eq_Needed then\n-            Decl :=\n-              Predef_Spec_Or_Body (Loc,\n-                Tag_Typ => Tag_Typ,\n-                Name    => Eq_Name,\n-                Profile => New_List (\n-                  Make_Parameter_Specification (Loc,\n-                    Defining_Identifier =>\n-                      Make_Defining_Identifier (Loc, Name_X),\n-                    Parameter_Type      => New_Reference_To (Tag_Typ, Loc)),\n-\n-                  Make_Parameter_Specification (Loc,\n-                    Defining_Identifier =>\n-                      Make_Defining_Identifier (Loc, Name_Y),\n-                    Parameter_Type      => New_Reference_To (Tag_Typ, Loc))),\n-\n-                Ret_Type => Standard_Boolean,\n-                For_Body => True);\n-\n-            declare\n-               Def          : constant Node_Id := Parent (Tag_Typ);\n-               Stmts        : constant List_Id := New_List;\n-               Variant_Case : Boolean := Has_Discriminants (Tag_Typ);\n-               Comps        : Node_Id := Empty;\n-               Typ_Def      : Node_Id := Type_Definition (Def);\n-\n-            begin\n-               if Variant_Case then\n-                  if Nkind (Typ_Def) = N_Derived_Type_Definition then\n-                     Typ_Def := Record_Extension_Part (Typ_Def);\n-                  end if;\n-\n-                  if Present (Typ_Def) then\n-                     Comps := Component_List (Typ_Def);\n-                  end if;\n-\n-                  Variant_Case := Present (Comps)\n-                    and then Present (Variant_Part (Comps));\n-               end if;\n-\n-               if Variant_Case then\n-                  Append_To (Stmts,\n-                    Make_Eq_If (Tag_Typ, Discriminant_Specifications (Def)));\n-                  Append_List_To (Stmts, Make_Eq_Case (Tag_Typ, Comps));\n-                  Append_To (Stmts,\n-                    Make_Simple_Return_Statement (Loc,\n-                      Expression => New_Reference_To (Standard_True, Loc)));\n-\n-               else\n-                  Append_To (Stmts,\n-                    Make_Simple_Return_Statement (Loc,\n-                      Expression =>\n-                        Expand_Record_Equality (Tag_Typ,\n-                          Typ => Tag_Typ,\n-                          Lhs => Make_Identifier (Loc, Name_X),\n-                          Rhs => Make_Identifier (Loc, Name_Y),\n-                          Bodies => Declarations (Decl))));\n-               end if;\n-\n-               Set_Handled_Statement_Sequence (Decl,\n-                 Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n-            end;\n+            Decl := Make_Eq_Body (Tag_Typ, Eq_Name);\n             Append_To (Res, Decl);\n          end if;\n "}, {"sha": "fe403c8b75b2f5d642b92b328a3e94f4f484f8c3", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -2170,22 +2170,54 @@ package body Exp_Ch4 is\n                            Lhs_Discr_Val,\n                            Rhs_Discr_Val));\n                   end;\n+\n+               else\n+                  return\n+                    Make_Function_Call (Loc,\n+                      Name                   => New_Reference_To (Eq_Op, Loc),\n+                      Parameter_Associations => New_List (Lhs, Rhs));\n                end if;\n+            end if;\n \n-               --  Shouldn't this be an else, we can't fall through the above\n-               --  IF, right???\n+         elsif Ada_Version >= Ada_12 then\n \n-               return\n-                 Make_Function_Call (Loc,\n-                   Name => New_Reference_To (Eq_Op, Loc),\n-                   Parameter_Associations => New_List (Lhs, Rhs));\n-            end if;\n+            --  if no TSS has been created for the type, check whether there is\n+            --  a primitive equality declared for it. If it is abstract replace\n+            --  the call with an explicit raise.\n+\n+            declare\n+               Prim : Elmt_Id;\n+\n+            begin\n+               Prim := First_Elmt (Collect_Primitive_Operations (Full_Type));\n+               while Present (Prim) loop\n+                  if Chars (Node (Prim)) = Name_Op_Eq then\n+                     if Is_Abstract_Subprogram (Node (Prim)) then\n+                        return\n+                          Make_Raise_Program_Error (Loc,\n+                            Reason => PE_Explicit_Raise);\n+                     else\n+                        return\n+                          Make_Function_Call (Loc,\n+                            Name => New_Reference_To (Node (Prim), Loc),\n+                            Parameter_Associations => New_List (Lhs, Rhs));\n+                     end if;\n+                  end if;\n+\n+                  Next_Elmt (Prim);\n+               end loop;\n+            end;\n+\n+            --  Predfined equality applies iff no user-defined primitive exists\n+\n+            return Make_Op_Eq (Loc, Lhs, Rhs);\n \n          else\n             return Expand_Record_Equality (Nod, Full_Type, Lhs, Rhs, Bodies);\n          end if;\n \n       else\n+\n          --  It can be a simple record or the full view of a scalar private\n \n          return Make_Op_Eq (Loc, Left_Opnd => Lhs, Right_Opnd => Rhs);"}, {"sha": "192c996bb9f6c449f8db27e178d5a6680800fc58", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -829,10 +829,12 @@ package body Exp_Ch9 is\n \n    begin\n       --  Loop to find enclosing construct containing activation chain variable\n+      --  The construct is a body, a block, or an extended return.\n \n       P := Parent (N);\n \n       while not Nkind_In (P, N_Subprogram_Body,\n+                             N_Entry_Body,\n                              N_Package_Declaration,\n                              N_Package_Body,\n                              N_Block_Statement,"}, {"sha": "336715a760b210852e568b1511b9b83886d81042", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -4489,6 +4489,9 @@ package body Exp_Disp is\n                             (RTE_Record_Component (RE_NDT_Prims_Ptr), Loc)),\n                       Attribute_Name => Name_Address))));\n \n+            Set_Is_Statically_Allocated (DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n+\n             --  Generate the SCIL node for the previous object declaration\n             --  because it has a tag initialization.\n \n@@ -4554,6 +4557,9 @@ package body Exp_Disp is\n                             (RTE_Record_Component (RE_Prims_Ptr), Loc)),\n                       Attribute_Name => Name_Address))));\n \n+            Set_Is_Statically_Allocated (DT_Ptr,\n+              Is_Library_Level_Tagged_Type (Typ));\n+\n             --  Generate the SCIL node for the previous object declaration\n             --  because it has a tag initialization.\n \n@@ -6639,6 +6645,13 @@ package body Exp_Disp is\n             Analyze_List (Result);\n             Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n \n+            --  Disable backend optimizations based on assumptions about the\n+            --  aliasing status of objects designated by the access to the\n+            --  dispatch table. Required to handle dispatch tables imported\n+            --  from C++.\n+\n+            Set_No_Strict_Aliasing (Base_Type (DT_Prims_Acc));\n+\n             --  Add the freezing nodes of these declarations; required to avoid\n             --  generating these freezing nodes in wrong scopes (for example in\n             --  the IC routine of a derivation of Typ)."}, {"sha": "8e6a0e00d87b5029b27c5f6e93ec0f80a0d99d91", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -1684,14 +1684,15 @@ ada/exp_atag.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n    ada/casing.ads ada/csets.ads ada/debug.ads ada/einfo.ads ada/einfo.adb \\\n    ada/elists.ads ada/elists.adb ada/err_vars.ads ada/errout.ads \\\n-   ada/erroutc.ads ada/exp_atag.ads ada/exp_atag.adb ada/exp_dist.ads \\\n-   ada/exp_tss.ads ada/exp_util.ads ada/fname.ads ada/fname-uf.ads \\\n-   ada/gnat.ads ada/g-htable.ads ada/hostparm.ads ada/lib.ads \\\n-   ada/lib-load.ads ada/namet.ads ada/nlists.ads ada/nlists.adb \\\n-   ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads ada/restrict.ads \\\n-   ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb ada/sem.ads \\\n-   ada/sem_aux.ads ada/sem_ch7.ads ada/sem_dist.ads ada/sem_util.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/erroutc.ads ada/exp_atag.ads ada/exp_atag.adb ada/exp_disp.ads \\\n+   ada/exp_dist.ads ada/exp_tss.ads ada/exp_util.ads ada/fname.ads \\\n+   ada/fname-uf.ads ada/gnat.ads ada/g-htable.ads ada/hostparm.ads \\\n+   ada/lib.ads ada/lib-load.ads ada/namet.ads ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb \\\n+   ada/sem.ads ada/sem_aux.ads ada/sem_aux.adb ada/sem_ch7.ads \\\n+   ada/sem_disp.ads ada/sem_dist.ads ada/sem_util.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n    ada/stringt.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n    ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n    ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n@@ -3476,27 +3477,27 @@ ada/sem_ch12.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n ada/sem_ch13.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n    ada/casing.ads ada/checks.ads ada/csets.ads ada/debug.ads ada/einfo.ads \\\n-   ada/einfo.adb ada/elists.ads ada/err_vars.ads ada/errout.ads \\\n-   ada/erroutc.ads ada/exp_dist.ads ada/exp_tss.ads ada/exp_util.ads \\\n-   ada/fname.ads ada/fname-uf.ads ada/get_targ.ads ada/gnat.ads \\\n-   ada/g-hesorg.ads ada/g-hesorg.adb ada/g-htable.ads ada/hostparm.ads \\\n-   ada/lib.ads ada/lib.adb ada/lib-list.adb ada/lib-load.ads \\\n-   ada/lib-sort.adb ada/lib-xref.ads ada/namet.ads ada/nlists.ads \\\n-   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n-   ada/restrict.ads ada/rident.ads ada/rtsfind.ads ada/rtsfind.adb \\\n-   ada/sem.ads ada/sem_aux.ads ada/sem_ch13.ads ada/sem_ch13.adb \\\n-   ada/sem_ch3.ads ada/sem_ch7.ads ada/sem_ch8.ads ada/sem_dist.ads \\\n-   ada/sem_eval.ads ada/sem_res.ads ada/sem_type.ads ada/sem_util.ads \\\n-   ada/sem_warn.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n-   ada/snames.ads ada/stand.ads ada/stringt.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \n+   ada/einfo.adb ada/elists.ads ada/elists.adb ada/err_vars.ads \\\n+   ada/errout.ads ada/erroutc.ads ada/exp_disp.ads ada/exp_dist.ads \\\n+   ada/exp_tss.ads ada/exp_util.ads ada/fname.ads ada/fname-uf.ads \\\n+   ada/get_targ.ads ada/gnat.ads ada/g-hesorg.ads ada/g-hesorg.adb \\\n+   ada/g-htable.ads ada/hostparm.ads ada/lib.ads ada/lib.adb \\\n+   ada/lib-list.adb ada/lib-load.ads ada/lib-sort.adb ada/lib-xref.ads \\\n+   ada/namet.ads ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n+   ada/opt.ads ada/output.ads ada/restrict.ads ada/rident.ads \\\n+   ada/rtsfind.ads ada/rtsfind.adb ada/sem.ads ada/sem_aux.ads \\\n+   ada/sem_ch13.ads ada/sem_ch13.adb ada/sem_ch3.ads ada/sem_ch7.ads \\\n+   ada/sem_ch8.ads ada/sem_dist.ads ada/sem_eval.ads ada/sem_res.ads \\\n+   ada/sem_type.ads ada/sem_util.ads ada/sem_warn.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/stand.ads \\\n+   ada/stringt.ads ada/system.ads ada/s-exctab.ads ada/s-htable.ads \\\n+   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n+   ada/s-rident.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/targparm.ads ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads \\\n+   ada/ttypes.ads ada/types.ads ada/uintp.ads ada/uintp.adb ada/uname.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/urealp.adb \n \n ada/sem_ch2.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\"}, {"sha": "ca67ed2924e40d60a70da0ab0478a5b7ce82bb8c", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -8130,7 +8130,6 @@ Output complete list of elaboration-order dependencies.\n @item ^-E^/STORE_TRACEBACKS^\n @cindex @option{^-E^/STORE_TRACEBACKS^} (@command{gnatbind})\n Store tracebacks in exception occurrences when the target supports it.\n-This is the default with the zero cost exception mechanism.\n @ignore\n @c The following may get moved to an appendix\n This option is currently supported on the following targets:"}, {"sha": "38526bdd34e32d6f6cad1a01d600e5f01a6b1388", "filename": "gcc/ada/gnatlbr.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fgnatlbr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fgnatlbr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlbr.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1997-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,8 +59,8 @@ procedure GnatLbr is\n    Make      : constant String := \"make\";\n    Make_Path : String_Access;\n \n-   procedure Create_Directory (Name : System.Address; Mode : Integer);\n-   pragma Import (C, Create_Directory, \"decc$mkdir\");\n+   procedure Create_Directory (Name : System.Address);\n+   pragma Import (C, Create_Directory, \"__gnat_mkdir\");\n \n begin\n    if Argument_Count = 0 then\n@@ -171,7 +171,7 @@ begin\n             --  Create the new top level library directory\n \n             if not Is_Directory (Lib_Dir.all) then\n-               Create_Directory (C_Lib_Dir'Address, 8#755#);\n+               Create_Directory (C_Lib_Dir'Address);\n             end if;\n \n             full_name (C_ADC_File'Address, F_ADC_File'Address);"}, {"sha": "ae1ba6643e833a9f4298f48481f826c0af10d82c", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -2250,7 +2250,6 @@ package body Ch3 is\n \n    function P_Defining_Character_Literal return Node_Id is\n       Literal_Node : Node_Id;\n-\n    begin\n       Literal_Node := Token_Node;\n       Change_Character_Literal_To_Defining_Character_Literal (Literal_Node);"}, {"sha": "0f719c232119d5e881804755bf83c0f32a3aaf42", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -1582,7 +1582,7 @@ package body Prj.Env is\n       --  For the object path, we make a distinction depending on\n       --  Including_Libraries.\n \n-      if Objects_Path and then Including_Libraries then\n+      if Objects_Path and Including_Libraries then\n          if Project.Objects_Path_File_With_Libs = No_Path then\n             Object_Path_Table.Init (Object_Paths);\n             Process_Object_Dirs := True;\n@@ -1602,7 +1602,7 @@ package body Prj.Env is\n       --  If there is something to do, set Seen to False for all projects,\n       --  then call the recursive procedure Add for Project.\n \n-      if Process_Source_Dirs or else Process_Object_Dirs then\n+      if Process_Source_Dirs or Process_Object_Dirs then\n          For_All_Projects (Project, Dummy);\n       end if;\n "}, {"sha": "8eb0cd28e448648c43bf6056d0e7f935a2237581", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -11720,15 +11720,29 @@ package body Sem_Ch12 is\n          N2 := Get_Associated_Node (N);\n          E := Entity (N2);\n \n+         --  If the entity is an itype created as a subtype of an access type\n+         --  with a null exclusion restore source entity for proper visibility.\n+         --  The itype will be created anew in the instance.\n+\n          if Present (E) then\n+            if Is_Itype (E)\n+              and then Ekind (E) = E_Access_Subtype\n+              and then Is_Entity_Name (N)\n+              and then Chars (Etype (E)) = Chars (N)\n+            then\n+               E := Etype (E);\n+               Set_Entity (N2, E);\n+               Set_Etype  (N2, E);\n+            end if;\n+\n             if Is_Global (E) then\n                Set_Global_Type (N, N2);\n \n             elsif Nkind (N) = N_Op_Concat\n               and then Is_Generic_Type (Etype (N2))\n-              and then\n-               (Base_Type (Etype (Right_Opnd (N2))) = Etype (N2)\n-                  or else Base_Type (Etype (Left_Opnd (N2))) = Etype (N2))\n+              and then (Base_Type (Etype (Right_Opnd (N2))) = Etype (N2)\n+                         or else\n+                        Base_Type (Etype (Left_Opnd (N2)))  = Etype (N2))\n               and then Is_Intrinsic_Subprogram (E)\n             then\n                null;\n@@ -11971,11 +11985,11 @@ package body Sem_Ch12 is\n            and then Is_Generic_Unit (Scope (Gen_Id))\n            and then In_Open_Scopes (Scope (Gen_Id))\n          then\n-            --  This is an instantiation of a child unit within a sibling,\n-            --  so that the generic parent is in scope. An eventual instance\n-            --  must occur within the scope of an instance of the parent.\n-            --  Make name in instance into an expanded name, to preserve the\n-            --  identifier of the parent, so it can be resolved subsequently.\n+            --  This is an instantiation of a child unit within a sibling, so\n+            --  that the generic parent is in scope. An eventual instance must\n+            --  occur within the scope of an instance of the parent. Make name\n+            --  in instance into an expanded name, to preserve the identifier\n+            --  of the parent, so it can be resolved subsequently.\n \n             Rewrite (Name (N2),\n               Make_Expanded_Name (Loc,"}, {"sha": "9a67243a432b499b6a2e99c31e2daecd9444f4e7", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d151d6a357e5336c4a3dd16c440b1d54eaab3639/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d151d6a357e5336c4a3dd16c440b1d54eaab3639", "patch": "@@ -7974,6 +7974,35 @@ package body Sem_Ch6 is\n            and then not Is_Dispatching_Operation (S)\n          then\n             Make_Inequality_Operator (S);\n+\n+            --  In Ada 2012, a primitive equality operator on a record type\n+            --  must appear before the type is frozen, and have the same\n+            --  visibility as the type.\n+\n+            declare\n+               Typ  : constant Entity_Id := Etype (First_Formal (S));\n+               Decl : constant Node_Id   := Unit_Declaration_Node (S);\n+\n+            begin\n+               if Ada_Version >= Ada_12\n+                 and then Nkind (Decl) = N_Subprogram_Declaration\n+                 and then Is_Record_Type (Typ)\n+               then\n+                  if Is_Frozen (Typ) then\n+                     Error_Msg_NE\n+                       (\"equality operator must be declared \"\n+                         & \"before type& is frozen\", S, Typ);\n+\n+                  elsif List_Containing (Parent (Typ))\n+                          /=\n+                        List_Containing (Decl)\n+                    and then not Is_Limited_Type (Typ)\n+                  then\n+                     Error_Msg_N\n+                       (\"equality operator appears too late\", S);\n+                  end if;\n+               end if;\n+            end;\n          end if;\n    end New_Overloaded_Entity;\n "}]}