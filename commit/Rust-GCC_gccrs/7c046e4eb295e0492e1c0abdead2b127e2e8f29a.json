{"sha": "7c046e4eb295e0492e1c0abdead2b127e2e8f29a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MwNDZlNGViMjk1ZTA0OTJlMWMwYWJkZWFkMmIxMjdlMmU4ZjI5YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-17T11:35:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-17T11:35:04Z"}, "message": "(struct undo, struct undo_int): Replace non-portable usage with some unions.\n\n(SUBST, SUBST_INT, undo_all, gen_rtx_combine): Make consistent with\nnew definitions.\n\nFrom-SVN: r1870", "tree": {"sha": "2471c47f0e5369b91c3e5574730090dcb7aaf9a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2471c47f0e5369b91c3e5574730090dcb7aaf9a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c046e4eb295e0492e1c0abdead2b127e2e8f29a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c046e4eb295e0492e1c0abdead2b127e2e8f29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c046e4eb295e0492e1c0abdead2b127e2e8f29a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c046e4eb295e0492e1c0abdead2b127e2e8f29a/comments", "author": null, "committer": null, "parents": [{"sha": "2c414fba8efe097c221d1f643404ae1b753720ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c414fba8efe097c221d1f643404ae1b753720ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c414fba8efe097c221d1f643404ae1b753720ac"}], "stats": {"total": 43, "additions": 20, "deletions": 23}, "files": [{"sha": "e55b33d55dd11629746d9cfebb5e76b2be95b6e9", "filename": "gcc/combine.c", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c046e4eb295e0492e1c0abdead2b127e2e8f29a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c046e4eb295e0492e1c0abdead2b127e2e8f29a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=7c046e4eb295e0492e1c0abdead2b127e2e8f29a", "patch": "@@ -274,16 +274,9 @@ static int significant_valid;\n \n struct undo\n {\n-  rtx *where;\n-  rtx old_contents;\n-  int is_int;\n-};\n-\n-struct undo_int\n-{\n-  int *where;\n-  int old_contents;\n   int is_int;\n+  union {rtx rtx; int i;} old_contents;\n+  union {rtx *rtx; int *i;} where;\n };\n \n /* Record a bunch of changes to be undone, up to MAX_UNDO of them.\n@@ -317,11 +310,11 @@ static struct undobuf undobuf;\n  do { rtx _new = (NEWVAL);\t\t\t\t\t\t\\\n       if (undobuf.num_undo < MAX_UNDO)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].where = &INTO;\t\t\t\\\n-\t  undobuf.undo[undobuf.num_undo].old_contents = INTO;\t\t\\\n \t  undobuf.undo[undobuf.num_undo].is_int = 0;\t\t\t\\\n+\t  undobuf.undo[undobuf.num_undo].where.rtx = &INTO;\t\t\\\n+\t  undobuf.undo[undobuf.num_undo].old_contents.rtx = INTO;\t\\\n \t  INTO = _new;\t\t\t\t\t\t\t\\\n-\t  if (undobuf.undo[undobuf.num_undo].old_contents != INTO)\t\\\n+\t  if (undobuf.undo[undobuf.num_undo].old_contents.rtx != INTO)\t\\\n \t    undobuf.num_undo++; \t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     } while (0)\n@@ -333,13 +326,11 @@ static struct undobuf undobuf;\n #define SUBST_INT(INTO, NEWVAL)  \\\n  do { if (undobuf.num_undo < MAX_UNDO)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-\t  struct undo_int *u\t\t\t\t\t\t\\\n-\t    = (struct undo_int *)&undobuf.undo[undobuf.num_undo];\t\\\n-\t  u->where = (int *) &INTO;\t\t\t\t\t\\\n-\t  u->old_contents = INTO;\t\t\t\t\t\\\n-\t  u->is_int = 1;\t\t\t\t\t\t\\\n+\t  undobuf.undo[undobuf.num_undo].is_int = 1;\t\t\t\\\n+\t  undobuf.undo[undobuf.num_undo].where.i = (int *) &INTO;\t\\\n+\t  undobuf.undo[undobuf.num_undo].old_contents.i = INTO;\t\t\\\n \t  INTO = NEWVAL;\t\t\t\t\t\t\\\n-\t  if (u->old_contents != INTO)\t\t\t\t\t\\\n+\t  if (undobuf.undo[undobuf.num_undo].old_contents.i != INTO)\t\\\n \t    undobuf.num_undo++;\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n      } while (0)\n@@ -2056,7 +2047,13 @@ undo_all ()\n   if (undobuf.num_undo > MAX_UNDO)\n     undobuf.num_undo = MAX_UNDO;\n   for (i = undobuf.num_undo - 1; i >= 0; i--)\n-    *undobuf.undo[i].where = undobuf.undo[i].old_contents;\n+    {\n+      if (undobuf.undo[i].is_int)\n+\t*undobuf.undo[i].where.i = undobuf.undo[i].old_contents.i;\n+      else\n+\t*undobuf.undo[i].where.rtx = undobuf.undo[i].old_contents.rtx;\n+      \n+    }\n \n   obfree (undobuf.storage);\n   undobuf.num_undo = 0;\n@@ -6989,15 +6986,15 @@ gen_rtx_combine (va_alist)\n \n   for (i = previous_num_undos; i < undobuf.num_undo; i++)\n     if (!undobuf.undo[i].is_int\n-\t&& GET_CODE (undobuf.undo[i].old_contents) == code\n-\t&& GET_MODE (undobuf.undo[i].old_contents) == mode)\n+\t&& GET_CODE (undobuf.undo[i].old_contents.rtx) == code\n+\t&& GET_MODE (undobuf.undo[i].old_contents.rtx) == mode)\n       {\n \tfor (j = 0; j < n_args; j++)\n-\t  if (XEXP (undobuf.undo[i].old_contents, j) != args[j])\n+\t  if (XEXP (undobuf.undo[i].old_contents.rtx, j) != args[j])\n \t    break;\n \n \tif (j == n_args)\n-\t  return undobuf.undo[i].old_contents;\n+\t  return undobuf.undo[i].old_contents.rtx;\n       }\n \n   /* Otherwise make a new rtx.  We know we have 1, 2, or 3 args."}]}