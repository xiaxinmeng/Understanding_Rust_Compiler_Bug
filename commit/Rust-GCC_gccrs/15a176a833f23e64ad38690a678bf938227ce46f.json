{"sha": "15a176a833f23e64ad38690a678bf938227ce46f", "node_id": "C_kwDOANBUbNoAKDE1YTE3NmE4MzNmMjNlNjRhZDM4NjkwYTY3OGJmOTM4MjI3Y2U0NmY", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2022-04-17T19:58:28Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2022-04-28T12:51:44Z"}, "message": "c++, coroutines: Make sure our temporaries are in a bind expr [PR105287]\n\nThere are a few cases where we can generate a temporary that does not need\nto be added to the coroutine frame (i.e. these are genuinely ephemeral).  The\nintent was that unnamed temporaries should not be 'promoted' to coroutine\nframe entries.  However there was a thinko and these were not actually ever\nadded to the bind expressions being generated for the expanded awaits.  This\nmeant that they were showing in the global namspace, leading to an empty\nDECL_CONTEXT and the ICE reported.\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\n\tPR c++/105287\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (maybe_promote_temps): Ensure generated temporaries\n\tare added to the bind expr.\n\t(add_var_to_bind): Fix local var naming to use portable punctuation.\n\t(register_local_var_uses): Do not add synthetic names to unnamed\n\ttemporaries.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/coroutines/pr105287.C: New test.", "tree": {"sha": "837b6b0e44a19471835a43413837cb00fb0d98f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/837b6b0e44a19471835a43413837cb00fb0d98f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15a176a833f23e64ad38690a678bf938227ce46f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a176a833f23e64ad38690a678bf938227ce46f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15a176a833f23e64ad38690a678bf938227ce46f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a176a833f23e64ad38690a678bf938227ce46f/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cb1f565a91e2dd57098c43593954b57c065a19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb1f565a91e2dd57098c43593954b57c065a19b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cb1f565a91e2dd57098c43593954b57c065a19b"}], "stats": {"total": 66, "additions": 57, "deletions": 9}, "files": [{"sha": "9b651b845b7ca188bde33603e357e37fc4e8042d", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a176a833f23e64ad38690a678bf938227ce46f/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a176a833f23e64ad38690a678bf938227ce46f/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=15a176a833f23e64ad38690a678bf938227ce46f", "patch": "@@ -3110,7 +3110,7 @@ maybe_promote_temps (tree *stmt, void *d)\n \t If the initializer is a conditional expression, we need to collect\n \t and declare any promoted variables nested within it.  DTORs for such\n \t variables must be run conditionally too.  */\n-      if (t->var && DECL_NAME (t->var))\n+      if (t->var)\n \t{\n \t  tree var = t->var;\n \t  DECL_CHAIN (var) = vlist;\n@@ -3311,7 +3311,7 @@ add_var_to_bind (tree& bind, tree var_type,\n   tree b_vars = BIND_EXPR_VARS (bind);\n   /* Build a variable to hold the condition, this will be included in the\n      frame as a local var.  */\n-  char *nam = xasprintf (\"%s.%d\", nam_root, nam_vers);\n+  char *nam = xasprintf (\"__%s_%d\", nam_root, nam_vers);\n   tree newvar = build_lang_decl (VAR_DECL, get_identifier (nam), var_type);\n   free (nam);\n   DECL_CHAIN (newvar) = b_vars;\n@@ -3956,7 +3956,7 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t     scopes with identically named locals and still be able to\n \t     identify them in the coroutine frame.  */\n \t  tree lvname = DECL_NAME (lvar);\n-\t  char *buf;\n+\t  char *buf = NULL;\n \n \t  /* The outermost bind scope contains the artificial variables that\n \t     we inject to implement the coro state machine.  We want to be able\n@@ -3966,14 +3966,14 @@ register_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  else if (lvname != NULL_TREE)\n \t    buf = xasprintf (\"%s_%u_%u\", IDENTIFIER_POINTER (lvname),\n \t\t\t     lvd->nest_depth, lvd->bind_indx);\n-\t  else\n-\t    buf = xasprintf (\"_D%u_%u_%u\", DECL_UID (lvar), lvd->nest_depth,\n-\t\t\t     lvd->bind_indx);\n \t  /* TODO: Figure out if we should build a local type that has any\n \t     excess alignment or size from the original decl.  */\n-\t  local_var.field_id\n-\t    = coro_make_frame_entry (lvd->field_list, buf, lvtype, lvd->loc);\n-\t  free (buf);\n+\t  if (buf)\n+\t    {\n+\t      local_var.field_id = coro_make_frame_entry (lvd->field_list, buf,\n+\t\t\t\t\t\t\t  lvtype, lvd->loc);\n+\t      free (buf);\n+\t    }\n \t  /* We don't walk any of the local var sub-trees, they won't contain\n \t     any bind exprs.  */\n \t}"}, {"sha": "9790945287da54cdf0ea1cb6e2752d98352a693f", "filename": "gcc/testsuite/g++.dg/coroutines/pr105287.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a176a833f23e64ad38690a678bf938227ce46f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr105287.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a176a833f23e64ad38690a678bf938227ce46f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr105287.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr105287.C?ref=15a176a833f23e64ad38690a678bf938227ce46f", "patch": "@@ -0,0 +1,48 @@\n+// { dg-additional-options \"-fanalyzer\" }\n+// { dg-excess-errors \"lots of analyzer output, but no ICE\" }\n+namespace std {\n+template <typename _Result> struct coroutine_traits : _Result {};\n+template <typename = void> struct coroutine_handle {\n+  operator coroutine_handle<>();\n+};\n+}\n+struct coro1 {\n+  using handle_type = std::coroutine_handle<>;\n+  coro1(handle_type);\n+  struct suspend_always_prt {\n+    bool await_ready() noexcept;\n+    void await_suspend(handle_type) noexcept;\n+    void await_resume() noexcept;\n+  };\n+  struct promise_type {\n+    std::coroutine_handle<> ch_;\n+    auto get_return_object() { return ch_; }\n+    auto initial_suspend() { return suspend_always_prt{}; }\n+    auto final_suspend() noexcept { return suspend_always_prt{}; }\n+    void unhandled_exception();\n+  };\n+};\n+struct BoolAwaiter {\n+  BoolAwaiter(bool);\n+  bool await_ready();\n+  void await_suspend(std::coroutine_handle<>);\n+  bool await_resume();\n+};\n+struct IntAwaiter {\n+  IntAwaiter(int);\n+  bool await_ready();\n+  void await_suspend(std::coroutine_handle<>);\n+  int await_resume();\n+};\n+coro1 my_coro() {\n+ int a = 1;\n+ if (a == 0) {\n+   int b = 5;\n+   \n+ }\n+ {\n+   int c = 10;\n+ }\n+ co_await BoolAwaiter(true) && co_await IntAwaiter(a); \n+ \n+ }"}]}