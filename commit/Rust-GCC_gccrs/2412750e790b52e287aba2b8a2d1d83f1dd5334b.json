{"sha": "2412750e790b52e287aba2b8a2d1d83f1dd5334b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxMjc1MGU3OTBiNTJlMjg3YWJhMmI4YTJkMWQ4M2YxZGQ1MzM0Yg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-01-02T13:25:10Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2018-01-02T13:25:10Z"}, "message": "PR libgfortran/83649 Chunk large reads and writes\n\nIt turns out that Linux never reads or writes more than 2147479552\nbytes in a single syscall. For writes this is not a problem as\nlibgfortran already contains a loop around write() to handle short\nwrites. But for reads we cannot do this, since then read will hang if\nwe have a short read when reading from the terminal.  Also, there are\nreports that macOS fails I/O's larger than 2 GB.  Thus, to work around\nthese issues do large reads/writes in chunks.\n\nThe testcase from the PR\n\nprogram largewr\n  integer(kind=1) :: a(2_8**31+1)\n  a = 0\n  a(size(a, kind=8)) = 1\n  open(10, file=\"largewr.dat\", access=\"stream\", form=\"unformatted\")\n  write (10) a\n  close(10)\n  a(size(a, kind=8)) = 2\n  open(10, file=\"largewr.dat\", access=\"stream\", form=\"unformatted\")\n  read (10) a\n  if (a(size(a, kind=8)) == 1) then\n    print *, \"All is well\"\n  else\n    print *, \"Oh no\"\n  end if\nend program largewr\n\nfails on trunk but works with the patch.\n\nRegtested on x86_64-pc-linux-gnu, committed to trunk.\n\nlibgfortran/ChangeLog:\n\n2018-01-02  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libgfortran/83649\n\t* io/unix.c (MAX_CHUNK): New define.\n\t(raw_read): For reads larger than MAX_CHUNK, loop.\n\t(raw_write): Write no more than MAX_CHUNK bytes per iteration.\n\nFrom-SVN: r256074", "tree": {"sha": "6b7cdd6ee7fe044bcfc528125182dac1a43f868a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b7cdd6ee7fe044bcfc528125182dac1a43f868a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2412750e790b52e287aba2b8a2d1d83f1dd5334b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2412750e790b52e287aba2b8a2d1d83f1dd5334b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2412750e790b52e287aba2b8a2d1d83f1dd5334b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2412750e790b52e287aba2b8a2d1d83f1dd5334b/comments", "author": null, "committer": null, "parents": [{"sha": "d555138e648961fdc572d8afdb234b52978828f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d555138e648961fdc572d8afdb234b52978828f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d555138e648961fdc572d8afdb234b52978828f9"}], "stats": {"total": 57, "additions": 49, "deletions": 8}, "files": [{"sha": "f014f005557a3a0c97c495411179aaa798ecd26b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2412750e790b52e287aba2b8a2d1d83f1dd5334b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2412750e790b52e287aba2b8a2d1d83f1dd5334b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2412750e790b52e287aba2b8a2d1d83f1dd5334b", "patch": "@@ -1,3 +1,10 @@\n+2018-01-02  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libgfortran/83649\n+\t* io/unix.c (MAX_CHUNK): New define.\n+\t(raw_read): For reads larger than MAX_CHUNK, loop.\n+\t(raw_write): Write no more than MAX_CHUNK bytes per iteration.\n+\n 2017-12-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/83613"}, {"sha": "7a982b38554b20c41f1c5366aed2fa3e6f07af80", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2412750e790b52e287aba2b8a2d1d83f1dd5334b/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2412750e790b52e287aba2b8a2d1d83f1dd5334b/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=2412750e790b52e287aba2b8a2d1d83f1dd5334b", "patch": "@@ -292,18 +292,49 @@ raw_flush (unix_stream *s  __attribute__ ((unused)))\n   return 0;\n }\n \n+/* Write/read at most 2 GB - 4k chunks at a time. Linux never reads or\n+   writes more than this, and there are reports that macOS fails for\n+   larger than 2 GB as well.  */\n+#define MAX_CHUNK 2147479552\n+\n static ssize_t\n raw_read (unix_stream *s, void *buf, ssize_t nbyte)\n {\n   /* For read we can't do I/O in a loop like raw_write does, because\n      that will break applications that wait for interactive I/O.  We\n-     still can loop around EINTR, though.  */\n-  while (true)\n+     still can loop around EINTR, though.  This however causes a\n+     problem for large reads which must be chunked, see comment above.\n+     So assume that if the size is larger than the chunk size, we're\n+     reading from a file and not the terminal.  */\n+  if (nbyte <= MAX_CHUNK)\n     {\n-      ssize_t trans = read (s->fd, buf, nbyte);\n-      if (trans == -1 && errno == EINTR)\n-\tcontinue;\n-      return trans;\n+      while (true)\n+\t{\n+\t  ssize_t trans = read (s->fd, buf, nbyte);\n+\t  if (trans == -1 && errno == EINTR)\n+\t    continue;\n+\t  return trans;\n+\t}\n+    }\n+  else\n+    {\n+      ssize_t bytes_left = nbyte;\n+      char *buf_st = buf;\n+      while (bytes_left > 0)\n+\t{\n+\t  ssize_t to_read = bytes_left < MAX_CHUNK ? bytes_left: MAX_CHUNK;\n+\t  ssize_t trans = read (s->fd, buf_st, to_read);\n+\t  if (trans == -1)\n+\t    {\n+\t      if (errno == EINTR)\n+\t\tcontinue;\n+\t      else\n+\t\treturn trans;\n+\t    }\n+\t  buf_st += trans;\n+\t  bytes_left -= trans;\n+\t}\n+      return nbyte - bytes_left;\n     }\n }\n \n@@ -317,10 +348,13 @@ raw_write (unix_stream *s, const void *buf, ssize_t nbyte)\n   buf_st = (char *) buf;\n \n   /* We must write in a loop since some systems don't restart system\n-     calls in case of a signal.  */\n+     calls in case of a signal.  Also some systems might fail outright\n+     if we try to write more than 2 GB in a single syscall, so chunk\n+     up large writes.  */\n   while (bytes_left > 0)\n     {\n-      trans = write (s->fd, buf_st, bytes_left);\n+      ssize_t to_write = bytes_left < MAX_CHUNK ? bytes_left: MAX_CHUNK;\n+      trans = write (s->fd, buf_st, to_write);\n       if (trans == -1)\n \t{\n \t  if (errno == EINTR)"}]}