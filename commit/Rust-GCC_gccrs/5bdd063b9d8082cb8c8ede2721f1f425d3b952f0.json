{"sha": "5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkZDA2M2I5ZDgwODJjYjhjOGVkZTI3MjFmMWY0MjVkM2I5NTJmMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-23T16:02:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-06-23T16:35:46Z"}, "message": "Streamline implementation of renaming in gigi\n\nThe main changes are 1) the bulk of the implementation is put back entirely\nin gnat_to_gnu_entity and 2) the handling of lvalues is unified, i.e. it no\nlonger depends on the Materialize_Entity flag being present on the entity.\n\ngcc/ada/ChangeLog:\n\t* gcc-interface/ada-tree.h (DECL_RENAMED_OBJECT): Delete.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Variable>: Always use\n\tthe stabilized reference directly for renaming and create a variable\n\tpointing to it separately if requested.\n\t* gcc-interface/misc.c (gnat_print_decl): Adjust for deletion.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Likewise.\n\t(gnat_to_gnu) <N_Object_Renaming_Declaration>:\n\tDo not deal with side-effects here.\n\t<N_Exception_Renaming_Declaration>: Likewise.", "tree": {"sha": "ac5e1dccfac67272224c2b532db82f4c076a4162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac5e1dccfac67272224c2b532db82f4c076a4162"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/comments", "author": null, "committer": null, "parents": [{"sha": "cd42cdc225a905cb1eb38dfad453e654261a659e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd42cdc225a905cb1eb38dfad453e654261a659e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd42cdc225a905cb1eb38dfad453e654261a659e"}], "stats": {"total": 185, "additions": 66, "deletions": 119}, "files": [{"sha": "461fa2b598c8054a5d45ce81d0bcf153bc00b8ec", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "patch": "@@ -525,13 +525,6 @@ do {\t\t\t\t\t\t   \\\n #define SET_DECL_INDUCTION_VAR(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n \n-/* In a VAR_DECL without the DECL_LOOP_PARM_P flag set and that is a renaming\n-   pointer, points to the object being renamed, if any.  */\n-#define DECL_RENAMED_OBJECT(NODE) \\\n-  GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n-#define SET_DECL_RENAMED_OBJECT(NODE, X) \\\n-  SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n-\n /* In a TYPE_DECL, points to the parallel type if any, otherwise 0.  */\n #define DECL_PARALLEL_TYPE(NODE) \\\n   GET_DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))"}, {"sha": "270710b11d574aa46ef0e0e823f20c0bb798d542", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 52, "deletions": 74, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "patch": "@@ -714,7 +714,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tbool mutable_p = false;\n \tbool used_by_ref = false;\n \ttree gnu_ext_name = NULL_TREE;\n-\ttree gnu_renamed_obj = NULL_TREE;\n \ttree gnu_ada_size = NULL_TREE;\n \n \t/* We need to translate the renamed object even though we are only\n@@ -1041,13 +1040,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    else if (type_is_padding_self_referential (TREE_TYPE (gnu_expr)))\n \t      gnu_type = TREE_TYPE (gnu_expr);\n \n-\t    /* Case 1: if this is a constant renaming stemming from a function\n-\t       call, treat it as a normal object whose initial value is what\n-\t       is being renamed.  RM 3.3 says that the result of evaluating a\n-\t       function call is a constant object.  Therefore, it can be the\n-\t       inner object of a constant renaming and the renaming must be\n-\t       fully instantiated, i.e. it cannot be a reference to (part of)\n-\t       an existing object.  And treat other rvalues the same way.  */\n+\t    /* If this is a constant renaming stemming from a function call,\n+\t       treat it as a normal object whose initial value is what is being\n+\t       renamed.  RM 3.3 says that the result of evaluating a function\n+\t       call is a constant object.  Therefore, it can be the inner\n+\t       object of a constant renaming and the renaming must be fully\n+\t       instantiated, i.e. it cannot be a reference to (part of) an\n+\t       existing object.  And treat other rvalues the same way.  */\n \t    tree inner = gnu_expr;\n \t    while (handled_component_p (inner) || CONVERT_EXPR_P (inner))\n \t      inner = TREE_OPERAND (inner, 0);\n@@ -1089,92 +1088,75 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t    && DECL_RETURN_VALUE_P (inner)))\n \t      ;\n \n-\t    /* Case 2: if the renaming entity need not be materialized, use\n-\t       the elaborated renamed expression for the renaming.  But this\n-\t       means that the caller is responsible for evaluating the address\n-\t       of the renaming in the correct place for the definition case to\n-\t       instantiate the SAVE_EXPRs.  But we cannot use this mechanism if\n-\t       the renamed object is an N_Expression_With_Actions because this\n-\t       would fail the assertion below.  */\n-\t    else if (!Materialize_Entity (gnat_entity)\n-\t\t     && Nkind (gnat_renamed_obj) != N_Expression_With_Actions)\n+\t    /* Otherwise, this is an lvalue being renamed, so it needs to be\n+\t       elaborated as a reference and substituted for the entity.  But\n+\t       this means that we must evaluate the address of the renaming\n+\t       in the definition case to instantiate the SAVE_EXPRs.  */\n+\t    else\n \t      {\n-\t\ttree init = NULL_TREE;\n+\t\ttree gnu_init = NULL_TREE;\n \n-\t\tgnu_decl\n-\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition,\n-\t\t\t\t\t &init);\n+\t\tif (type_annotate_only && TREE_CODE (gnu_expr) == ERROR_MARK)\n+\t\t  break;\n \n-\t\t/* We cannot evaluate the first arm of a COMPOUND_EXPR in the\n-\t\t   correct place for this case.  */\n-\t\tgcc_assert (!init);\n+\t\tgnu_expr\n+\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition,\n+\t\t\t\t\t &gnu_init);\n \n-\t\t/* No DECL_EXPR will be created so the expression needs to be\n+\t\t/* No DECL_EXPR might be created so the expression needs to be\n \t\t   marked manually because it will likely be shared.  */\n \t\tif (global_bindings_p ())\n-\t\t  MARK_VISITED (gnu_decl);\n+\t\t  MARK_VISITED (gnu_expr);\n \n \t\t/* This assertion will fail if the renamed object isn't aligned\n \t\t   enough as to make it possible to honor the alignment set on\n \t\t   the renaming.  */\n \t\tif (align)\n \t\t  {\n-\t\t    unsigned int ralign = DECL_P (gnu_decl)\n-\t\t\t\t\t  ? DECL_ALIGN (gnu_decl)\n-\t\t\t\t\t  : TYPE_ALIGN (TREE_TYPE (gnu_decl));\n+\t\t    const unsigned int ralign\n+\t\t      = DECL_P (gnu_expr)\n+\t\t\t? DECL_ALIGN (gnu_expr)\n+\t\t\t: TYPE_ALIGN (TREE_TYPE (gnu_expr));\n \t\t    gcc_assert (ralign >= align);\n \t\t  }\n \n \t\t/* The expression might not be a DECL so save it manually.  */\n+\t\tgnu_decl = gnu_expr;\n \t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n \t\tsaved = true;\n \t\tannotate_object (gnat_entity, gnu_type, NULL_TREE, false);\n-\t\tbreak;\n-\t      }\n \n-\t    /* Case 3: otherwise, make a constant pointer to the object we\n-\t       are renaming and attach the object to the pointer after it is\n-\t       elaborated.  The object will be referenced directly instead\n-\t       of indirectly via the pointer to avoid aliasing problems with\n-\t       non-addressable entities.  The pointer is called a \"renaming\"\n-\t       pointer in this case.  Note that we also need to preserve the\n-\t       volatility of the renamed object through the indirection.  */\n-\t    else\n-\t      {\n-\t\ttree init = NULL_TREE;\n+\t\t/* If this is only a reference to the entity, we are done.  */\n+\t\tif (!definition)\n+\t\t  break;\n \n-\t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n-\t\t  gnu_type\n-\t\t    = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n-\t\tgnu_type = build_reference_type (gnu_type);\n-\t\tused_by_ref = true;\n-\t\tconst_flag = true;\n-\t\tvolatile_flag = false;\n-\t\tinner_const_flag = TREE_READONLY (gnu_expr);\n-\t\tgnu_size = NULL_TREE;\n+\t\t/* Otherwise, emit the initialization statement, if any.  */\n+\t\tif (gnu_init)\n+\t\t  add_stmt (gnu_init);\n \n-\t\tgnu_renamed_obj\n-\t\t  = elaborate_reference (gnu_expr, gnat_entity, definition,\n-\t\t\t\t\t &init);\n+\t\t/* If it needs to be materialized for debugging purposes, build\n+\t\t   the entity as indirect reference to the renamed object.  */\n+\t\tif (Materialize_Entity (gnat_entity))\n+\t\t  {\n+\t\t    gnu_type = build_reference_type (gnu_type);\n+\t\t    const_flag = true;\n+\t\t    volatile_flag = false;\n \n-\t\t/* The expression needs to be marked manually because it will\n-\t\t   likely be shared, even for a definition since the ADDR_EXPR\n-\t\t   built below can cause the first few nodes to be folded.  */\n-\t\tif (global_bindings_p ())\n-\t\t  MARK_VISITED (gnu_renamed_obj);\n+\t\t    gnu_expr = build_unary_op (ADDR_EXPR, gnu_type, gnu_expr);\n \n-\t\tif (type_annotate_only\n-\t\t    && TREE_CODE (gnu_renamed_obj) == ERROR_MARK)\n-\t\t  gnu_expr = NULL_TREE;\n-\t\telse\n-\t\t  {\n-\t\t    gnu_expr\n-\t\t      = build_unary_op (ADDR_EXPR, gnu_type, gnu_renamed_obj);\n-\t\t    if (init)\n-\t\t      gnu_expr\n-\t\t\t= build_compound_expr (TREE_TYPE (gnu_expr), init,\n-\t\t\t\t\t       gnu_expr);\n+\t\t    create_var_decl (gnu_entity_name, gnu_ext_name,\n+\t\t\t\t     TREE_TYPE (gnu_expr), gnu_expr,\n+\t\t\t\t     const_flag, Is_Public (gnat_entity),\n+\t\t\t\t     imported_p, static_flag, volatile_flag,\n+\t\t\t\t     artificial_p, debug_info_p, attr_list,\n+\t\t\t\t     gnat_entity, false);\n \t\t  }\n+\n+\t\t/* Otherwise, instantiate the SAVE_EXPRs if needed.  */\n+\t\telse if (TREE_SIDE_EFFECTS (gnu_expr))\n+\t\t  add_stmt (build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr));\n+\n+\t\tbreak;\n \t      }\n \t  }\n \n@@ -1538,7 +1520,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t     imported_p || !definition, static_flag,\n \t\t\t     volatile_flag, artificial_p,\n \t\t\t     debug_info_p && definition, attr_list,\n-\t\t\t     gnat_entity, !gnu_renamed_obj);\n+\t\t\t     gnat_entity, true);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -1566,10 +1548,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \telse if (kind == E_Loop_Parameter)\n \t  DECL_LOOP_PARM_P (gnu_decl) = 1;\n \n-\t/* If this is a renaming pointer, attach the renamed object to it.  */\n-\tif (gnu_renamed_obj)\n-\t  SET_DECL_RENAMED_OBJECT (gnu_decl, gnu_renamed_obj);\n-\n \t/* If this is a constant and we are defining it or it generates a real\n \t   symbol at the object level and we are referencing it, we may want\n \t   or need to have a true variable to represent it:"}, {"sha": "3999f9cc2be503bb0bf2fae51f0ec68ba061c2f1", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "patch": "@@ -467,9 +467,6 @@ gnat_print_decl (FILE *file, tree node, int indent)\n       if (DECL_LOOP_PARM_P (node))\n \tprint_node (file, \"induction var\", DECL_INDUCTION_VAR (node),\n \t\t    indent + 4);\n-      else\n-\tprint_node (file, \"renamed object\", DECL_RENAMED_OBJECT (node),\n-\t\t    indent + 4);\n       break;\n \n     default:"}, {"sha": "c32bdb96a5e44b7ed3f4c07b93e3e3fe3b2d90af", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdd063b9d8082cb8c8ede2721f1f425d3b952f0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=5bdd063b9d8082cb8c8ede2721f1f425d3b952f0", "patch": "@@ -1249,25 +1249,16 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t\t\t  true)))\n \tgnu_result = DECL_INITIAL (gnu_result);\n \n-      /* If it's a renaming pointer, get to the renamed object.  */\n-      if (TREE_CODE (gnu_result) == VAR_DECL\n-          && !DECL_LOOP_PARM_P (gnu_result)\n-\t  && DECL_RENAMED_OBJECT (gnu_result))\n-\tgnu_result = DECL_RENAMED_OBJECT (gnu_result);\n-\n-      /* Otherwise, do the final dereference.  */\n-      else\n-\t{\n-\t  gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n+      /* Do the final dereference.  */\n+      gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n-\t  if ((TREE_CODE (gnu_result) == INDIRECT_REF\n-\t       || TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF)\n-\t      && No (Address_Clause (gnat_entity)))\n-\t    TREE_THIS_NOTRAP (gnu_result) = 1;\n+      if ((TREE_CODE (gnu_result) == INDIRECT_REF\n+\t   || TREE_CODE (gnu_result) == UNCONSTRAINED_ARRAY_REF)\n+\t  && No (Address_Clause (gnat_entity)))\n+\tTREE_THIS_NOTRAP (gnu_result) = 1;\n \n-\t  if (read_only)\n-\t    TREE_READONLY (gnu_result) = 1;\n-\t}\n+      if (read_only)\n+\tTREE_READONLY (gnu_result) = 1;\n     }\n \n   /* If we have a constant declaration and its initializer, try to return the\n@@ -6543,31 +6534,19 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t&& (Is_Array_Type (Etype (gnat_temp))\n \t\t    || Is_Record_Type (Etype (gnat_temp))\n \t\t    || Is_Concurrent_Type (Etype (gnat_temp)))))\n-\t{\n-\t  tree gnu_temp\n-\t    = gnat_to_gnu_entity (gnat_temp,\n-\t\t\t\t  gnat_to_gnu (Renamed_Object (gnat_temp)),\n-\t\t\t\t  true);\n-\t  /* See case 2 of renaming in gnat_to_gnu_entity.  */\n-\t  if (TREE_SIDE_EFFECTS (gnu_temp))\n-\t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n-\t}\n+\tgnat_to_gnu_entity (gnat_temp,\n+\t\t\t    gnat_to_gnu (Renamed_Object (gnat_temp)),\n+\t\t\t    true);\n       break;\n \n     case N_Exception_Renaming_Declaration:\n       gnat_temp = Defining_Entity (gnat_node);\n       gnu_result = alloc_stmt_list ();\n \n-      /* See the above case for the rationale.  */\n       if (Present (Renamed_Entity (gnat_temp)))\n-\t{\n-\t  tree gnu_temp\n-\t    = gnat_to_gnu_entity (gnat_temp,\n-\t\t\t\t  gnat_to_gnu (Renamed_Entity (gnat_temp)),\n-\t\t\t\t  true);\n-\t  if (TREE_SIDE_EFFECTS (gnu_temp))\n-\t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n-\t}\n+\tgnat_to_gnu_entity (gnat_temp,\n+\t\t\t    gnat_to_gnu (Renamed_Entity (gnat_temp)),\n+\t\t\t    true);\n       break;\n \n     case N_Subprogram_Renaming_Declaration:"}]}