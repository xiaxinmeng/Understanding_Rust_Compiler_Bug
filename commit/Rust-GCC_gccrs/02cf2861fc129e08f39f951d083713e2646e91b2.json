{"sha": "02cf2861fc129e08f39f951d083713e2646e91b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJjZjI4NjFmYzEyOWUwOGYzOWY5NTFkMDgzNzEzZTI2NDZlOTFiMg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2016-04-08T02:11:52Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2016-04-08T02:11:52Z"}, "message": "PR70117, ppc long double isinf\n\ngcc/\n\tPR target/70117\n\t* builtins.c (fold_builtin_classify): For IBM extended precision,\n\tlook at just the high-order double to test for NaN.\n\t(fold_builtin_interclass_mathfn): Similarly for Inf.  For isnormal\n\ttest just the high double for Inf but both doubles for subnormal\n\tlimit.\ngcc/testsuite/\n\t* gcc.target/powerpc/pr70117.c: New.\n\nFrom-SVN: r234821", "tree": {"sha": "0b388abae31ee926c4acf1f22caf2d032c9e84cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b388abae31ee926c4acf1f22caf2d032c9e84cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02cf2861fc129e08f39f951d083713e2646e91b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02cf2861fc129e08f39f951d083713e2646e91b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02cf2861fc129e08f39f951d083713e2646e91b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02cf2861fc129e08f39f951d083713e2646e91b2/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1f3955796c066142e3f796353b0e1b4688b38597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f3955796c066142e3f796353b0e1b4688b38597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f3955796c066142e3f796353b0e1b4688b38597"}], "stats": {"total": 205, "additions": 194, "deletions": 11}, "files": [{"sha": "980ae252bc126345e615af7c671774b63e85eecd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02cf2861fc129e08f39f951d083713e2646e91b2", "patch": "@@ -1,3 +1,12 @@\n+2016-04-08  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/70117\n+\t* builtins.c (fold_builtin_classify): For IBM extended precision,\n+\tlook at just the high-order double to test for NaN.\n+\t(fold_builtin_interclass_mathfn): Similarly for Inf.  For isnormal\n+\ttest just the high double for Inf but both doubles for subnormal\n+\tlimit.\n+\n 2016-04-07  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cgraph.h (struct cgraph_simd_clone): Add mask_mode field."}, {"sha": "3d89bafe34a99c8042b7f85a50e6be0b9b4684d3", "filename": "gcc/builtins.c", "status": "modified", "additions": 89, "deletions": 11, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=02cf2861fc129e08f39f951d083713e2646e91b2", "patch": "@@ -7529,6 +7529,8 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n \n   mode = TYPE_MODE (TREE_TYPE (arg));\n \n+  bool is_ibm_extended = MODE_COMPOSITE_P (mode);\n+\n   /* If there is no optab, try generic code.  */\n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n@@ -7538,10 +7540,18 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n       {\n \t/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */\n \ttree const isgr_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n-\ttree const type = TREE_TYPE (arg);\n+\ttree type = TREE_TYPE (arg);\n \tREAL_VALUE_TYPE r;\n \tchar buf[128];\n \n+\tif (is_ibm_extended)\n+\t  {\n+\t    /* NaN and Inf are encoded in the high-order double value\n+\t       only.  The low-order value is not significant.  */\n+\t    type = double_type_node;\n+\t    mode = DFmode;\n+\t    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);\n+\t  }\n \tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n \treal_from_string (&r, buf);\n \tresult = build_call_expr (isgr_fn, 2,\n@@ -7554,10 +7564,18 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n       {\n \t/* isfinite(x) -> islessequal(fabs(x),DBL_MAX).  */\n \ttree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n-\ttree const type = TREE_TYPE (arg);\n+\ttree type = TREE_TYPE (arg);\n \tREAL_VALUE_TYPE r;\n \tchar buf[128];\n \n+\tif (is_ibm_extended)\n+\t  {\n+\t    /* NaN and Inf are encoded in the high-order double value\n+\t       only.  The low-order value is not significant.  */\n+\t    type = double_type_node;\n+\t    mode = DFmode;\n+\t    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);\n+\t  }\n \tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n \treal_from_string (&r, buf);\n \tresult = build_call_expr (isle_fn, 2,\n@@ -7577,21 +7595,72 @@ fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n \t/* isnormal(x) -> isgreaterequal(fabs(x),DBL_MIN) &\n \t   islessequal(fabs(x),DBL_MAX).  */\n \ttree const isle_fn = builtin_decl_explicit (BUILT_IN_ISLESSEQUAL);\n-\ttree const isge_fn = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);\n-\ttree const type = TREE_TYPE (arg);\n+\ttree type = TREE_TYPE (arg);\n+\ttree orig_arg, max_exp, min_exp;\n+\tmachine_mode orig_mode = mode;\n \tREAL_VALUE_TYPE rmax, rmin;\n \tchar buf[128];\n \n+\torig_arg = arg = builtin_save_expr (arg);\n+\tif (is_ibm_extended)\n+\t  {\n+\t    /* Use double to test the normal range of IBM extended\n+\t       precision.  Emin for IBM extended precision is\n+\t       different to emin for IEEE double, being 53 higher\n+\t       since the low double exponent is at least 53 lower\n+\t       than the high double exponent.  */\n+\t    type = double_type_node;\n+\t    mode = DFmode;\n+\t    arg = fold_build1_loc (loc, NOP_EXPR, type, arg);\n+\t  }\n+\targ = fold_build1_loc (loc, ABS_EXPR, type, arg);\n+\n \tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n \treal_from_string (&rmax, buf);\n-\tsprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (mode)->emin - 1);\n+\tsprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (orig_mode)->emin - 1);\n \treal_from_string (&rmin, buf);\n-\targ = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));\n-\tresult = build_call_expr (isle_fn, 2, arg,\n-\t\t\t\t  build_real (type, rmax));\n-\tresult = fold_build2 (BIT_AND_EXPR, integer_type_node, result,\n-\t\t\t      build_call_expr (isge_fn, 2, arg,\n-\t\t\t\t\t       build_real (type, rmin)));\n+\tmax_exp = build_real (type, rmax);\n+\tmin_exp = build_real (type, rmin);\n+\n+\tmax_exp = build_call_expr (isle_fn, 2, arg, max_exp);\n+\tif (is_ibm_extended)\n+\t  {\n+\t    /* Testing the high end of the range is done just using\n+\t       the high double, using the same test as isfinite().\n+\t       For the subnormal end of the range we first test the\n+\t       high double, then if its magnitude is equal to the\n+\t       limit of 0x1p-969, we test whether the low double is\n+\t       non-zero and opposite sign to the high double.  */\n+\t    tree const islt_fn = builtin_decl_explicit (BUILT_IN_ISLESS);\n+\t    tree const isgt_fn = builtin_decl_explicit (BUILT_IN_ISGREATER);\n+\t    tree gt_min = build_call_expr (isgt_fn, 2, arg, min_exp);\n+\t    tree eq_min = fold_build2 (EQ_EXPR, integer_type_node,\n+\t\t\t\t       arg, min_exp);\n+\t    tree as_complex = build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t      complex_double_type_node, orig_arg);\n+\t    tree hi_dbl = build1 (REALPART_EXPR, type, as_complex);\n+\t    tree lo_dbl = build1 (IMAGPART_EXPR, type, as_complex);\n+\t    tree zero = build_real (type, dconst0);\n+\t    tree hilt = build_call_expr (islt_fn, 2, hi_dbl, zero);\n+\t    tree lolt = build_call_expr (islt_fn, 2, lo_dbl, zero);\n+\t    tree logt = build_call_expr (isgt_fn, 2, lo_dbl, zero);\n+\t    tree ok_lo = fold_build1 (TRUTH_NOT_EXPR, integer_type_node,\n+\t\t\t\t      fold_build3 (COND_EXPR,\n+\t\t\t\t\t\t   integer_type_node,\n+\t\t\t\t\t\t   hilt, logt, lolt));\n+\t    eq_min = fold_build2 (TRUTH_ANDIF_EXPR, integer_type_node,\n+\t\t\t\t  eq_min, ok_lo);\n+\t    min_exp = fold_build2 (TRUTH_ORIF_EXPR, integer_type_node,\n+\t\t\t\t   gt_min, eq_min);\n+\t  }\n+\telse\n+\t  {\n+\t    tree const isge_fn\n+\t      = builtin_decl_explicit (BUILT_IN_ISGREATEREQUAL);\n+\t    min_exp = build_call_expr (isge_fn, 2, arg, min_exp);\n+\t  }\n+\tresult = fold_build2 (BIT_AND_EXPR, integer_type_node,\n+\t\t\t      max_exp, min_exp);\n \treturn result;\n       }\n     default:\n@@ -7664,6 +7733,15 @@ fold_builtin_classify (location_t loc, tree fndecl, tree arg, int builtin_index)\n       if (!HONOR_NANS (arg))\n \treturn omit_one_operand_loc (loc, type, integer_zero_node, arg);\n \n+      {\n+\tbool is_ibm_extended = MODE_COMPOSITE_P (TYPE_MODE (TREE_TYPE (arg)));\n+\tif (is_ibm_extended)\n+\t  {\n+\t    /* NaN and Inf are encoded in the high-order double value\n+\t       only.  The low-order value is not significant.  */\n+\t    arg = fold_build1_loc (loc, NOP_EXPR, double_type_node, arg);\n+\t  }\n+      }\n       arg = builtin_save_expr (arg);\n       return fold_build2_loc (loc, UNORDERED_EXPR, type, arg, arg);\n "}, {"sha": "7c3af0dea1c3c257e995dd1c941a9bfe76784394", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02cf2861fc129e08f39f951d083713e2646e91b2", "patch": "@@ -1,3 +1,7 @@\n+2016-04-08  Alan Modra  <amodra@gmail.com>\n+\n+\t* gcc.target/powerpc/pr70117.c: New.\n+\n 2016-04-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR testsuite/70581"}, {"sha": "f1fdedb6c59389092d752d5e55e0029348bf5f1f", "filename": "gcc/testsuite/gcc.target/powerpc/pr70117.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02cf2861fc129e08f39f951d083713e2646e91b2/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr70117.c?ref=02cf2861fc129e08f39f951d083713e2646e91b2", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do run { target { powerpc*-*-linux* powerpc*-*-darwin* powerpc*-*-aix* rs6000-*-* } } } */\n+/* { dg-options \"-std=c99 -mlong-double-128 -O2\" } */\n+\n+#include <float.h>\n+\n+union gl_long_double_union\n+{\n+  struct { double hi; double lo; } dd;\n+  long double ld;\n+};\n+\n+/* This is gnulib's LDBL_MAX which, being 107 bits in precision, is\n+   slightly larger than gcc's 106 bit precision LDBL_MAX.  */\n+volatile union gl_long_double_union gl_LDBL_MAX =\n+  { { DBL_MAX, DBL_MAX / (double)134217728UL / (double)134217728UL } };\n+\n+volatile double min_denorm = 0x1p-1074;\n+volatile double ld_low = 0x1p-969;\n+volatile double dinf = 1.0/0.0;\n+volatile double dnan = 0.0/0.0;\n+\n+int\n+main (void)\n+{\n+  long double ld;\n+\n+  ld = gl_LDBL_MAX.ld;\n+  if (__builtin_isinfl (ld))\n+    __builtin_abort ();\n+  ld = -gl_LDBL_MAX.ld;\n+  if (__builtin_isinfl (ld))\n+    __builtin_abort ();\n+\n+  ld = gl_LDBL_MAX.ld;\n+  if (!__builtin_isfinite (ld))\n+    __builtin_abort ();\n+  ld = -gl_LDBL_MAX.ld;\n+  if (!__builtin_isfinite (ld))\n+    __builtin_abort ();\n+\n+  ld = ld_low;\n+  if (!__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = -ld_low;\n+  if (!__builtin_isnormal (ld))\n+    __builtin_abort ();\n+\n+  ld = -min_denorm;\n+  ld += ld_low;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = min_denorm;\n+  ld -= ld_low;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+\n+  ld = 0.0;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = -0.0;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+\n+  ld = LDBL_MAX;\n+  if (!__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = -LDBL_MAX;\n+  if (!__builtin_isnormal (ld))\n+    __builtin_abort ();\n+\n+  ld = gl_LDBL_MAX.ld;\n+  if (!__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = -gl_LDBL_MAX.ld;\n+  if (!__builtin_isnormal (ld))\n+    __builtin_abort ();\n+\n+  ld = dinf;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = -dinf;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+\n+  ld = dnan;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  ld = -dnan;\n+  if (__builtin_isnormal (ld))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}