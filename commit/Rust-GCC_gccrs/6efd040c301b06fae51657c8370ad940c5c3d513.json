{"sha": "6efd040c301b06fae51657c8370ad940c5c3d513", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVmZDA0MGMzMDFiMDZmYWU1MTY1N2M4MzcwYWQ5NDBjNWMzZDUxMw==", "commit": {"author": {"name": "LevyHsu", "email": "admin@levyhsu.com", "date": "2021-04-29T05:42:04Z"}, "committer": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2021-04-30T00:55:54Z"}, "message": "RISC-V: Add patterns for builtin overflow.\n\n\tgcc/\n\t* config/riscv/riscv.c (riscv_min_arithmetic_precision): New.\n\t* config/riscv/riscv.h (TARGET_MIN_ARITHMETIC_PRECISION): New.\n\t* config/riscv/riscv.md (addv<mode>4, uaddv<mode>4): New.\n\t(subv<mode>4, usubv<mode>4, mulv<mode>4, umulv<mode>4): New.", "tree": {"sha": "9631275e58e22905ef15bc1935547cd5adf41d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9631275e58e22905ef15bc1935547cd5adf41d24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6efd040c301b06fae51657c8370ad940c5c3d513", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6efd040c301b06fae51657c8370ad940c5c3d513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6efd040c301b06fae51657c8370ad940c5c3d513", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6efd040c301b06fae51657c8370ad940c5c3d513/comments", "author": {"login": "LevyHsu", "id": 18082840, "node_id": "MDQ6VXNlcjE4MDgyODQw", "avatar_url": "https://avatars.githubusercontent.com/u/18082840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LevyHsu", "html_url": "https://github.com/LevyHsu", "followers_url": "https://api.github.com/users/LevyHsu/followers", "following_url": "https://api.github.com/users/LevyHsu/following{/other_user}", "gists_url": "https://api.github.com/users/LevyHsu/gists{/gist_id}", "starred_url": "https://api.github.com/users/LevyHsu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LevyHsu/subscriptions", "organizations_url": "https://api.github.com/users/LevyHsu/orgs", "repos_url": "https://api.github.com/users/LevyHsu/repos", "events_url": "https://api.github.com/users/LevyHsu/events{/privacy}", "received_events_url": "https://api.github.com/users/LevyHsu/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c8e539dcfd955b24af44b95a1a900dc0a5dc4c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8e539dcfd955b24af44b95a1a900dc0a5dc4c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8e539dcfd955b24af44b95a1a900dc0a5dc4c9"}], "stats": {"total": 257, "additions": 257, "deletions": 0}, "files": [{"sha": "e1064e374eb06c67aef0d33ef176e1dd90e29905", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6efd040c301b06fae51657c8370ad940c5c3d513/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6efd040c301b06fae51657c8370ad940c5c3d513/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=6efd040c301b06fae51657c8370ad940c5c3d513", "patch": "@@ -351,6 +351,14 @@ static const struct riscv_tune_info riscv_tune_info_table[] = {\n   { \"size\", generic, &optimize_size_tune_info },\n };\n \n+/* Implement TARGET_MIN_ARITHMETIC_PRECISION.  */\n+\n+static unsigned int\n+riscv_min_arithmetic_precision (void)\n+{\n+  return 32;\n+}\n+\n /* Return the riscv_tune_info entry for the given name string.  */\n \n static const struct riscv_tune_info *"}, {"sha": "f3e85723c85d59d776a0c0b0780f67ca00dd0ca4", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6efd040c301b06fae51657c8370ad940c5c3d513/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6efd040c301b06fae51657c8370ad940c5c3d513/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=6efd040c301b06fae51657c8370ad940c5c3d513", "patch": "@@ -146,6 +146,10 @@ ASM_MISA_SPEC\n #define MIN_UNITS_PER_WORD 4\n #endif\n \n+/* Allows SImode op in builtin overflow pattern, see internal-fn.c.  */\n+#undef TARGET_MIN_ARITHMETIC_PRECISION\n+#define TARGET_MIN_ARITHMETIC_PRECISION riscv_min_arithmetic_precision\n+\n /* The `Q' extension is not yet supported.  */\n #define UNITS_PER_FP_REG (TARGET_DOUBLE_FLOAT ? 8 : 4)\n "}, {"sha": "0e35960fefaa826b7687fe82f28580d45ead75fc", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6efd040c301b06fae51657c8370ad940c5c3d513/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6efd040c301b06fae51657c8370ad940c5c3d513/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=6efd040c301b06fae51657c8370ad940c5c3d513", "patch": "@@ -467,6 +467,81 @@\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_expand \"addv<mode>4\"\n+  [(set (match_operand:GPR           0 \"register_operand\" \"=r,r\")\n+\t(plus:GPR (match_operand:GPR 1 \"register_operand\" \" r,r\")\n+\t\t  (match_operand:GPR 2 \"arith_operand\"    \" r,I\")))\n+   (label_ref (match_operand 3 \"\" \"\"))]\n+  \"\"\n+{\n+  if (TARGET_64BIT && <MODE>mode == SImode)\n+    {\n+      rtx t3 = gen_reg_rtx (DImode);\n+      rtx t4 = gen_reg_rtx (DImode);\n+      rtx t5 = gen_reg_rtx (DImode);\n+      rtx t6 = gen_reg_rtx (DImode);\n+\n+      emit_insn (gen_addsi3 (operands[0], operands[1], operands[2]));\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t4, operands[1], DImode, SImode, 0));\n+      else\n+\tt4 = operands[1];\n+      if (GET_CODE (operands[2]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t5, operands[2], DImode, SImode, 0));\n+      else\n+\tt5 = operands[2];\n+      emit_insn (gen_adddi3 (t3, t4, t5));\n+      emit_insn (gen_extend_insn (t6, operands[0], DImode, SImode, 0));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, t6, t3);\n+    }\n+  else\n+    {\n+      rtx t3 = gen_reg_rtx (<MODE>mode);\n+      rtx t4 = gen_reg_rtx (<MODE>mode);\n+\n+      emit_insn (gen_add3_insn (operands[0], operands[1], operands[2]));\n+      rtx cmp1 = gen_rtx_LT (<MODE>mode, operands[2], const0_rtx);\n+      emit_insn (gen_cstore<mode>4 (t3, cmp1, operands[2], const0_rtx));\n+      rtx cmp2 = gen_rtx_LT (<MODE>mode, operands[0], operands[1]);\n+\n+      emit_insn (gen_cstore<mode>4 (t4, cmp2, operands[0], operands[1]));\n+      riscv_expand_conditional_branch (operands[3], NE, t3, t4);\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"uaddv<mode>4\"\n+  [(set (match_operand:GPR           0 \"register_operand\" \"=r,r\")\n+\t(plus:GPR (match_operand:GPR 1 \"register_operand\" \" r,r\")\n+\t\t  (match_operand:GPR 2 \"arith_operand\"    \" r,I\")))\n+   (label_ref (match_operand 3 \"\" \"\"))]\n+  \"\"\n+{\n+  if (TARGET_64BIT && <MODE>mode == SImode)\n+    {\n+      rtx t3 = gen_reg_rtx (DImode);\n+      rtx t4 = gen_reg_rtx (DImode);\n+\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t3, operands[1], DImode, SImode, 0));\n+      else\n+\tt3 = operands[1];\n+      emit_insn (gen_addsi3 (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_extend_insn (t4, operands[0], DImode, SImode, 0));\n+\n+      riscv_expand_conditional_branch (operands[3], LTU, t4, t3);\n+    }\n+  else\n+    {\n+      emit_insn (gen_add3_insn (operands[0], operands[1], operands[2]));\n+      riscv_expand_conditional_branch (operands[3], LTU, operands[0],\n+\t\t\t\t       operands[1]);\n+    }\n+\n+  DONE;\n+})\n+\n (define_insn \"*addsi3_extended\"\n   [(set (match_operand:DI               0 \"register_operand\" \"=r,r\")\n \t(sign_extend:DI\n@@ -523,6 +598,85 @@\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_expand \"subv<mode>4\"\n+  [(set (match_operand:GPR            0 \"register_operand\" \"= r\")\n+\t(minus:GPR (match_operand:GPR 1 \"reg_or_0_operand\" \" rJ\")\n+\t\t   (match_operand:GPR 2 \"register_operand\" \"  r\")))\n+   (label_ref (match_operand 3 \"\" \"\"))]\n+  \"\"\n+{\n+  if (TARGET_64BIT && <MODE>mode == SImode)\n+    {\n+      rtx t3 = gen_reg_rtx (DImode);\n+      rtx t4 = gen_reg_rtx (DImode);\n+      rtx t5 = gen_reg_rtx (DImode);\n+      rtx t6 = gen_reg_rtx (DImode);\n+\n+      emit_insn (gen_subsi3 (operands[0], operands[1], operands[2]));\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t4, operands[1], DImode, SImode, 0));\n+      else\n+\tt4 = operands[1];\n+      if (GET_CODE (operands[2]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t5, operands[2], DImode, SImode, 0));\n+      else\n+\tt5 = operands[2];\n+      emit_insn (gen_subdi3 (t3, t4, t5));\n+      emit_insn (gen_extend_insn (t6, operands[0], DImode, SImode, 0));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, t6, t3);\n+    }\n+  else\n+    {\n+      rtx t3 = gen_reg_rtx (<MODE>mode);\n+      rtx t4 = gen_reg_rtx (<MODE>mode);\n+\n+      emit_insn (gen_sub3_insn (operands[0], operands[1], operands[2]));\n+\n+      rtx cmp1 = gen_rtx_LT (<MODE>mode, operands[2], const0_rtx);\n+      emit_insn (gen_cstore<mode>4 (t3, cmp1, operands[2], const0_rtx));\n+\n+      rtx cmp2 = gen_rtx_LT (<MODE>mode, operands[1], operands[0]);\n+      emit_insn (gen_cstore<mode>4 (t4, cmp2, operands[1], operands[0]));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, t3, t4);\n+    }\n+\n+  DONE;\n+})\n+\n+(define_expand \"usubv<mode>4\"\n+  [(set (match_operand:GPR            0 \"register_operand\" \"= r\")\n+\t(minus:GPR (match_operand:GPR 1 \"reg_or_0_operand\" \" rJ\")\n+\t\t   (match_operand:GPR 2 \"register_operand\" \"  r\")))\n+   (label_ref (match_operand 3 \"\" \"\"))]\n+  \"\"\n+{\n+  if (TARGET_64BIT && <MODE>mode == SImode)\n+    {\n+      rtx t3 = gen_reg_rtx (DImode);\n+      rtx t4 = gen_reg_rtx (DImode);\n+\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t3, operands[1], DImode, SImode, 0));\n+      else\n+\tt3 = operands[1];\n+      emit_insn (gen_subsi3 (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_extend_insn (t4, operands[0], DImode, SImode, 0));\n+\n+      riscv_expand_conditional_branch (operands[3], LTU, t3, t4);\n+    }\n+  else\n+    {\n+      emit_insn (gen_sub3_insn (operands[0], operands[1], operands[2]));\n+      riscv_expand_conditional_branch (operands[3], LTU, operands[1],\n+\t\t\t\t       operands[0]);\n+    }\n+\n+  DONE;\n+})\n+\n+\n (define_insn \"*subsi3_extended\"\n   [(set (match_operand:DI               0 \"register_operand\" \"= r\")\n \t(sign_extend:DI\n@@ -614,6 +768,97 @@\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_expand \"mulv<mode>4\"\n+  [(set (match_operand:GPR           0 \"register_operand\" \"=r\")\n+\t(mult:GPR (match_operand:GPR 1 \"register_operand\" \" r\")\n+\t\t  (match_operand:GPR 2 \"register_operand\" \" r\")))\n+   (label_ref (match_operand 3 \"\" \"\"))]\n+  \"TARGET_MUL\"\n+{\n+  if (TARGET_64BIT && <MODE>mode == SImode)\n+    {\n+      rtx t3 = gen_reg_rtx (DImode);\n+      rtx t4 = gen_reg_rtx (DImode);\n+      rtx t5 = gen_reg_rtx (DImode);\n+      rtx t6 = gen_reg_rtx (DImode);\n+\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t4, operands[1], DImode, SImode, 0));\n+      else\n+\tt4 = operands[1];\n+      if (GET_CODE (operands[2]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t5, operands[2], DImode, SImode, 0));\n+      else\n+\tt5 = operands[2];\n+      emit_insn (gen_muldi3 (t3, t4, t5));\n+\n+      emit_move_insn (operands[0], gen_lowpart (SImode, t3));\n+      emit_insn (gen_extend_insn (t6, operands[0], DImode, SImode, 0));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, t6, t3);\n+    }\n+  else\n+    {\n+      rtx hp = gen_reg_rtx (<MODE>mode);\n+      rtx lp = gen_reg_rtx (<MODE>mode);\n+\n+      emit_insn (gen_mul<mode>3_highpart (hp, operands[1], operands[2]));\n+      emit_insn (gen_mul<mode>3 (operands[0], operands[1], operands[2]));\n+      emit_insn (gen_ashr<mode>3 (lp, operands[0],\n+\t\t\t\t  GEN_INT (BITS_PER_WORD - 1)));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, hp, lp);\n+    }\n+\n+  DONE;\n+})\n+\n+(define_expand \"umulv<mode>4\"\n+  [(set (match_operand:GPR           0 \"register_operand\" \"=r\")\n+\t(mult:GPR (match_operand:GPR 1 \"register_operand\" \" r\")\n+\t\t  (match_operand:GPR 2 \"register_operand\" \" r\")))\n+   (label_ref (match_operand 3 \"\" \"\"))]\n+  \"TARGET_MUL\"\n+{\n+  if (TARGET_64BIT && <MODE>mode == SImode)\n+    {\n+      rtx t3 = gen_reg_rtx (DImode);\n+      rtx t4 = gen_reg_rtx (DImode);\n+      rtx t5 = gen_reg_rtx (DImode);\n+      rtx t6 = gen_reg_rtx (DImode);\n+      rtx t7 = gen_reg_rtx (DImode);\n+      rtx t8 = gen_reg_rtx (DImode);\n+\n+      if (GET_CODE (operands[1]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t3, operands[1], DImode, SImode, 0));\n+      else\n+\tt3 = operands[1];\n+      if (GET_CODE (operands[2]) != CONST_INT)\n+\temit_insn (gen_extend_insn (t4, operands[2], DImode, SImode, 0));\n+      else\n+\tt4 = operands[2];\n+\n+      emit_insn (gen_ashldi3 (t5, t3, GEN_INT (32)));\n+      emit_insn (gen_ashldi3 (t6, t4, GEN_INT (32)));\n+      emit_insn (gen_umuldi3_highpart (t7, t5, t6));\n+      emit_move_insn (operands[0], gen_lowpart (SImode, t7));\n+      emit_insn (gen_lshrdi3 (t8, t7, GEN_INT (32)));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, t8, const0_rtx);\n+    }\n+  else\n+    {\n+      rtx hp = gen_reg_rtx (<MODE>mode);\n+\n+      emit_insn (gen_umul<mode>3_highpart (hp, operands[1], operands[2]));\n+      emit_insn (gen_mul<mode>3 (operands[0], operands[1], operands[2]));\n+\n+      riscv_expand_conditional_branch (operands[3], NE, hp, const0_rtx);\n+    }\n+\n+  DONE;\n+})\n+\n (define_insn \"*mulsi3_extended\"\n   [(set (match_operand:DI              0 \"register_operand\" \"=r\")\n \t(sign_extend:DI"}]}