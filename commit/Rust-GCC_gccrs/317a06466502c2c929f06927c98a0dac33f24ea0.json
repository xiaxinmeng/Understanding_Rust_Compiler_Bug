{"sha": "317a06466502c2c929f06927c98a0dac33f24ea0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE3YTA2NDY2NTAyYzJjOTI5ZjA2OTI3Yzk4YTBkYWMzM2YyNGVhMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-13T15:34:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-06-13T15:34:59Z"}, "message": "ipa-inline.c (reset_edge_caches): Walk aliases.\n\n\n\t* ipa-inline.c (reset_edge_caches): Walk aliases.\n\t(update_caller_keys): Do not test inlinability of aliases.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Look through alias.\n\t(do_estimate_growth): Fix typo.\n\nFrom-SVN: r174992", "tree": {"sha": "b2fac6bd71eacc96cf52f96f89927df2e6cabe36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2fac6bd71eacc96cf52f96f89927df2e6cabe36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/317a06466502c2c929f06927c98a0dac33f24ea0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/317a06466502c2c929f06927c98a0dac33f24ea0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/317a06466502c2c929f06927c98a0dac33f24ea0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/317a06466502c2c929f06927c98a0dac33f24ea0/comments", "author": null, "committer": null, "parents": [{"sha": "8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8775a18b96762a8db2c63d9fe4fe02f6d0139fad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8775a18b96762a8db2c63d9fe4fe02f6d0139fad"}], "stats": {"total": 11, "additions": 8, "deletions": 3}, "files": [{"sha": "b008f05c97207ebe9df9ca5c632c0817694ca0fb", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/317a06466502c2c929f06927c98a0dac33f24ea0/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/317a06466502c2c929f06927c98a0dac33f24ea0/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=317a06466502c2c929f06927c98a0dac33f24ea0", "patch": "@@ -2079,7 +2079,7 @@ do_estimate_edge_time (struct cgraph_edge *edge)\n   struct inline_edge_summary *es = inline_edge_summary (edge);\n \n   gcc_checking_assert (edge->inline_failed);\n-  estimate_node_size_and_time (edge->callee,\n+  estimate_node_size_and_time (cgraph_function_or_thunk_node (edge->callee, NULL),\n \t\t\t       evaluate_conditions_for_edge (edge, true),\n \t\t\t       &size, &time);\n \n@@ -2226,7 +2226,7 @@ do_estimate_growth (struct cgraph_node *node)\n   else\n     {\n       if (!DECL_EXTERNAL (node->decl)\n-\t  && !cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n+\t  && cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units since they\n \t come from various template instantiations.  Take this into account.  */"}, {"sha": "c9328c91053d0903872113a6cc36418de37403cb", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/317a06466502c2c929f06927c98a0dac33f24ea0/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/317a06466502c2c929f06927c98a0dac33f24ea0/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=317a06466502c2c929f06927c98a0dac33f24ea0", "patch": "@@ -929,6 +929,8 @@ reset_edge_caches (struct cgraph_node *node)\n   struct cgraph_edge *edge;\n   struct cgraph_edge *e = node->callees;\n   struct cgraph_node *where = node;\n+  int i;\n+  struct ipa_ref *ref;\n \n   if (where->global.inlined_to)\n     where = where->global.inlined_to;\n@@ -939,6 +941,9 @@ reset_edge_caches (struct cgraph_node *node)\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n+  for (i = 0; ipa_ref_list_refering_iterate (&where->ref_list, i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      reset_edge_caches (ipa_ref_refering_node (ref));\n \n   if (!e)\n     return;\n@@ -980,7 +985,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   int i;\n   struct ipa_ref *ref;\n \n-  if (!inline_summary (node)->inlinable\n+  if ((!node->alias && !inline_summary (node)->inlinable)\n       || cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE\n       || node->global.inlined_to)\n     return;"}]}