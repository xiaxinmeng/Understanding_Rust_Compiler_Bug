{"sha": "d3d43aabbd50deea95b18f395c43b6ff9a9fc19f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNkNDNhYWJiZDUwZGVlYTk1YjE4ZjM5NWM0M2I2ZmY5YTlmYzE5Zg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-10-04T12:22:03Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-10-04T12:22:03Z"}, "message": "* doc/cppinternals.texi: Update.\n\nFrom-SVN: r46009", "tree": {"sha": "44d61c624fd878f128ed6e720dbed8f253ec4f4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44d61c624fd878f128ed6e720dbed8f253ec4f4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f/comments", "author": null, "committer": null, "parents": [{"sha": "3054eeed1ddb62a0fd7fcef6bee287c7cbe4b121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3054eeed1ddb62a0fd7fcef6bee287c7cbe4b121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3054eeed1ddb62a0fd7fcef6bee287c7cbe4b121"}], "stats": {"total": 429, "additions": 312, "deletions": 117}, "files": [{"sha": "cc9e2e93b12be184dc5e4e0e6a30be3ed3a57b4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3d43aabbd50deea95b18f395c43b6ff9a9fc19f", "patch": "@@ -1,3 +1,7 @@\n+2001-10-04  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* doc/cppinternals.texi: Update.\n+\n 2001-10-04  Eric Christopher  <echristo@redhat.com>\n \n \t* config/mips/mips.c (init_cumulative_args): Remember to set"}, {"sha": "9e4760c958eeccef30205dba0b3d9c69cea3ba47", "filename": "gcc/doc/cppinternals.texi", "status": "modified", "additions": 308, "deletions": 117, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f/gcc%2Fdoc%2Fcppinternals.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3d43aabbd50deea95b18f395c43b6ff9a9fc19f/gcc%2Fdoc%2Fcppinternals.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcppinternals.texi?ref=d3d43aabbd50deea95b18f395c43b6ff9a9fc19f", "patch": "@@ -66,7 +66,8 @@ into another language, under the above conditions for modified versions.\n @contents\n @page\n \n-@node Top, Conventions,, (DIR)\n+@node Top\n+@top\n @chapter Cpplib---the core of the GNU C Preprocessor\n \n The GNU C preprocessor in GCC 3.x has been completely rewritten.  It is\n@@ -87,16 +88,18 @@ tricky issues encountered.  It also describes certain behaviour we would\n like to preserve, such as the format and spacing of its output.\n \n @menu\n-* Conventions::\t    Conventions used in the code.\n-* Lexer::\t    The combined C, C++ and Objective-C Lexer.\n-* Whitespace::      Input and output newlines and whitespace.\n-* Hash Nodes::      All identifiers are hashed.\n-* Macro Expansion:: Macro expansion algorithm.\n-* Files::\t    File handling.\n-* Index::           Index.\n+* Conventions::         Conventions used in the code.\n+* Lexer::               The combined C, C++ and Objective-C Lexer.\n+* Hash Nodes::          All identifiers are entered into a hash table.\n+* Macro Expansion::     Macro expansion algorithm.\n+* Token Spacing::       Spacing and paste avoidance issues.\n+* Line Numbering::      Tracking location within files.\n+* Guard Macros::        Optimizing header files with guard macros.\n+* Files::               File handling.\n+* Index::               Index.\n @end menu\n \n-@node Conventions, Lexer, Top, Top\n+@node Conventions\n @unnumbered Conventions\n @cindex interface\n @cindex header files\n@@ -118,9 +121,11 @@ change internals in the future without worrying whether library clients\n are perhaps relying on some kind of undocumented implementation-specific\n behaviour.\n \n-@node Lexer, Whitespace, Conventions, Top\n+@node Lexer\n @unnumbered The Lexer\n @cindex lexer\n+@cindex newlines\n+@cindex escaped newlines\n \n @section Overview\n The lexer is contained in the file @file{cpplex.c}.  It is a hand-coded\n@@ -143,7 +148,7 @@ output.\n @section Lexing a token\n Lexing of an individual token is handled by @code{_cpp_lex_direct} and\n its subroutines.  In its current form the code is quite complicated,\n-with read ahead characters and suchlike, since it strives to not step\n+with read ahead characters and such-like, since it strives to not step\n back in the character stream in preparation for handling non-ASCII file\n encodings.  The current plan is to convert any such files to UTF-8\n before processing them.  This complexity is therefore unnecessary and\n@@ -175,7 +180,7 @@ using the line map code.\n The first token on a logical, i.e.@: unescaped, line has the flag\n @code{BOL} set for beginning-of-line.  This flag is intended for\n internal use, both to distinguish a @samp{#} that begins a directive\n-from one that doesn't, and to generate a callback to clients that want\n+from one that doesn't, and to generate a call-back to clients that want\n to be notified about the start of every non-directive line with tokens\n on it.  Clients cannot reliably determine this for themselves: the first\n token might be a macro, and the tokens of a macro expansion do not have\n@@ -219,9 +224,28 @@ foo\n @end smallexample\n \n This is a good example of the subtlety of getting token spacing correct\n-in the preprocessor; there are plenty of tests in the testsuite for\n+in the preprocessor; there are plenty of tests in the test-suite for\n corner cases like this.\n \n+The lexer is written to treat each of @samp{\\r}, @samp{\\n}, @samp{\\r\\n}\n+and @samp{\\n\\r} as a single new line indicator.  This allows it to\n+transparently preprocess MS-DOS, Macintosh and Unix files without their\n+needing to pass through a special filter beforehand.\n+\n+We also decided to treat a backslash, either @samp{\\} or the trigraph\n+@samp{??/}, separated from one of the above newline indicators by\n+non-comment whitespace only, as intending to escape the newline.  It\n+tends to be a typing mistake, and cannot reasonably be mistaken for\n+anything else in any of the C-family grammars.  Since handling it this\n+way is not strictly conforming to the ISO standard, the library issues a\n+warning wherever it encounters it.\n+\n+Handling newlines like this is made simpler by doing it in one place\n+only.  The function @code{handle_newline} takes care of all newline\n+characters, and @code{skip_escaped_newlines} takes care of arbitrarily\n+long sequences of escaped newlines, deferring to @code{handle_newline}\n+to handle the newlines themselves.\n+\n The most painful aspect of lexing ISO-standard C and C++ is handling\n trigraphs and backlash-escaped newlines.  Trigraphs are processed before\n any interpretation of the meaning of a character is made, and unfortunately\n@@ -255,6 +279,7 @@ should be done even within C-style comments; they can appear in the\n middle of a line, and we want to report diagnostics in the correct\n position for text appearing after the end of the comment.\n \n+@anchor{Invalid identifiers}\n Some identifiers, such as @code{__VA_ARGS__} and poisoned identifiers,\n may be invalid and require a diagnostic.  However, if they appear in a\n macro expansion we don't want to complain with each use of the macro.\n@@ -282,107 +307,113 @@ two separate @samp{:} tokens and almost certainly a syntax error.  Such\n cases are handled by @code{_cpp_lex_direct} based upon command-line\n flags stored in the @code{cpp_options} structure.\n \n+Once a token has been lexed, it leads an independent existence.  The\n+spelling of numbers, identifiers and strings is copied to permanent\n+storage from the original input buffer, so a token remains valid and\n+correct even if its source buffer is freed with @code{_cpp_pop_buffer}.\n+The storage holding the spellings of such tokens remains until the\n+client program calls cpp_destroy, probably at the end of the translation\n+unit.\n+\n @anchor{Lexing a line}\n @section Lexing a line\n-\n-@node Whitespace, Hash Nodes, Lexer, Top\n-@unnumbered Whitespace\n-@cindex whitespace\n-@cindex newlines\n-@cindex escaped newlines\n-@cindex paste avoidance\n-@cindex line numbers\n-\n-The lexer has been written to treat each of @samp{\\r}, @samp{\\n},\n-@samp{\\r\\n} and @samp{\\n\\r} as a single new line indicator.  This allows\n-it to transparently preprocess MS-DOS, Macintosh and Unix files without\n-their needing to pass through a special filter beforehand.\n-\n-We also decided to treat a backslash, either @samp{\\} or the trigraph\n-@samp{??/}, separated from one of the above newline indicators by\n-non-comment whitespace only, as intending to escape the newline.  It\n-tends to be a typing mistake, and cannot reasonably be mistaken for\n-anything else in any of the C-family grammars.  Since handling it this\n-way is not strictly conforming to the ISO standard, the library issues a\n-warning wherever it encounters it.\n-\n-Handling newlines like this is made simpler by doing it in one place\n-only.  The function @samp{handle_newline} takes care of all newline\n-characters, and @samp{skip_escaped_newlines} takes care of arbitrarily\n-long sequences of escaped newlines, deferring to @samp{handle_newline}\n-to handle the newlines themselves.\n-\n-Another whitespace issue only concerns the stand-alone preprocessor: we\n-want to guarantee that re-reading the preprocessed output results in an\n-identical token stream.  Without taking special measures, this might not\n-be the case because of macro substitution.  We could simply insert a\n-space between adjacent tokens, but ideally we would like to keep this to\n-a minimum, both for aesthetic reasons and because it causes problems for\n-people who still try to abuse the preprocessor for things like Fortran\n-source and Makefiles.\n-\n-The token structure contains a flags byte, and two flags are of interest\n-here: @samp{PREV_WHITE} and @samp{AVOID_LPASTE}.  @samp{PREV_WHITE}\n-indicates that the token was preceded by whitespace; if this is the case\n-we need not worry about it incorrectly pasting with its predecessor.\n-The @samp{AVOID_LPASTE} flag is set by the macro expansion routines, and\n-indicates that paste avoidance by insertion of a space to the left of\n-the token may be necessary.  Recursively, the first token of a macro\n-substitution, the first token after a macro substitution, the first\n-token of a substituted argument, and the first token after a substituted\n-argument are all flagged @samp{AVOID_LPASTE} by the macro expander.\n-\n-If a token flagged in this way does not have a @samp{PREV_WHITE} flag,\n-and the routine @code{cpp_avoid_paste} determines that it might be\n-misinterpreted by the lexer if a space is not inserted between it and\n-the immediately preceding token, then stand-alone CPP's output routines\n-will insert a space between them.  To avoid excessive spacing,\n-@code{cpp_avoid_paste} tries hard to only request a space if one is\n-likely to be necessary, but for reasons of efficiency it is slightly\n-conservative and might recommend a space where one is not strictly\n-needed.\n-\n-Finally, the preprocessor takes great care to ensure it keeps track of\n-both the position of a token in the source file, for diagnostic\n-purposes, and where it should appear in the output file, because using\n-CPP for other languages like assembler requires this.  The two positions\n-may differ for the following reasons:\n-\n-@itemize @bullet\n-@item\n-Escaped newlines are deleted, so lines spliced in this way are joined to\n-form a single logical line.\n-\n-@item\n-A macro expansion replaces the tokens that form its invocation, but any\n-newlines appearing in the macro's arguments are interpreted as a single\n-space, with the result that the macro's replacement appears in full on\n-the same line that the macro name appeared in the source file.  This is\n-particularly important for stringification of arguments---newlines\n-embedded in the arguments must appear in the string as spaces.\n-@end itemize\n-\n-The source file location is maintained in the @code{lineno} member of the\n-@code{cpp_buffer} structure, and the column number inferred from the\n-current position in the buffer relative to the @code{line_base} buffer\n-variable, which is updated with every newline whether escaped or not.\n-\n-TODO: Finish this.\n-\n-@node Hash Nodes, Macro Expansion, Whitespace, Top\n+@cindex token run\n+\n+When the preprocessor was changed to return pointers to tokens, one\n+feature I wanted was some sort of guarantee regarding how long a\n+returned pointer remains valid.  This is important to the stand-alone\n+preprocessor, the future direction of the C family front ends, and even\n+to cpplib itself internally.\n+\n+Occasionally the preprocessor wants to be able to peek ahead in the\n+token stream.  For example, after the name of a function-like macro, it\n+wants to check the next token to see if it is an opening parenthesis.\n+Another example is that, after reading the first few tokens of a\n+@code{#pragma} directive and not recognising it as a registered pragma,\n+it wants to backtrack and allow the user-defined handler for unknown\n+pragmas to access the full @code{#pragma} token stream.  The stand-alone\n+preprocessor wants to be able to test the current token with the\n+previous one to see if a space needs to be inserted to preserve their\n+separate tokenization upon re-lexing (paste avoidance), so it needs to\n+be sure the pointer to the previous token is still valid.  The\n+recursive-descent C++ parser wants to be able to perform tentative\n+parsing arbitrarily far ahead in the token stream, and then to be able\n+to jump back to a prior position in that stream if necessary.\n+\n+The rule I chose, which is fairly natural, is to arrange that the\n+preprocessor lex all tokens on a line consecutively into a token buffer,\n+which I call a @dfn{token run}, and when meeting an unescaped new line\n+(newlines within comments do not count either), to start lexing back at\n+the beginning of the run.  Note that we do @emph{not} lex a line of\n+tokens at once; if we did that @code{parse_identifier} would not have\n+state flags available to warn about invalid identifiers (@pxref{Invalid\n+identifiers}).\n+\n+In other words, accessing tokens that appeared earlier in the current\n+line is valid, but since each logical line overwrites the tokens of the\n+previous line, tokens from prior lines are unavailable.  In particular,\n+since a directive only occupies a single logical line, this means that\n+the directive handlers like the @code{#pragma} handler can jump around\n+in the directive's tokens if necessary.\n+\n+Two issues remain: what about tokens that arise from macro expansions,\n+and what happens when we have a long line that overflows the token run?\n+\n+Since we promise clients that we preserve the validity of pointers that\n+we have already returned for tokens that appeared earlier in the line,\n+we cannot reallocate the run.  Instead, on overflow it is expanded by\n+chaining a new token run on to the end of the existing one.\n+\n+The tokens forming a macro's replacement list are collected by the\n+@code{#define} handler, and placed in storage that is only freed by\n+@code{cpp_destroy}.  So if a macro is expanded in our line of tokens,\n+the pointers to the tokens of its expansion that we return will always\n+remain valid.  However, macros are a little trickier than that, since\n+they give rise to three sources of fresh tokens.  They are the built-in\n+macros like @code{__LINE__}, and the @samp{#} and @samp{##} operators\n+for stringifcation and token pasting.  I handled this by allocating\n+space for these tokens from the lexer's token run chain.  This means\n+they automatically receive the same lifetime guarantees as lexed tokens,\n+and we don't need to concern ourselves with freeing them.\n+\n+Lexing into a line of tokens solves some of the token memory management\n+issues, but not all.  The opening parenthesis after a function-like\n+macro name might lie on a different line, and the front ends definitely\n+want the ability to look ahead past the end of the current line.  So\n+cpplib only moves back to the start of the token run at the end of a\n+line if the variable @code{keep_tokens} is zero.  Line-buffering is\n+quite natural for the preprocessor, and as a result the only time cpplib\n+needs to increment this variable is whilst looking for the opening\n+parenthesis to, and reading the arguments of, a function-like macro.  In\n+the near future cpplib will export an interface to increment and\n+decrement this variable, so that clients can share full control over the\n+lifetime of token pointers too.\n+\n+The routine @code{_cpp_lex_token} handles moving to new token runs,\n+calling @code{_cpp_lex_direct} to lex new tokens, or returning\n+previously-lexed tokens if we stepped back in the token stream.  It also\n+checks each token for the @code{BOL} flag, which might indicate a\n+directive that needs to be handled, or require a start-of-line call-back\n+to be made.  @code{_cpp_lex_token} also handles skipping over tokens in\n+failed conditional blocks, and invalidates the control macro of the\n+multiple-include optimization if a token was successfully lexed outside\n+a directive.  In other words, its callers do not need to concern\n+themselves with such issues.\n+\n+@node Hash Nodes\n @unnumbered Hash Nodes\n @cindex hash table\n @cindex identifiers\n @cindex macros\n @cindex assertions\n @cindex named operators\n \n-When cpplib encounters an ``identifier'', it generates a hash code for it\n-and stores it in the hash table.  By ``identifier'' we mean tokens with\n-type @samp{CPP_NAME}; this includes identifiers in the usual C sense, as\n-well as keywords, directive names, macro names and so on.  For example,\n-all of @samp{pragma}, @samp{int}, @samp{foo} and @samp{__GNUC__} are identifiers and hashed\n-when lexed.\n+When cpplib encounters an ``identifier'', it generates a hash code for\n+it and stores it in the hash table.  By ``identifier'' we mean tokens\n+with type @code{CPP_NAME}; this includes identifiers in the usual C\n+sense, as well as keywords, directive names, macro names and so on.  For\n+example, all of @code{pragma}, @code{int}, @code{foo} and\n+@code{__GNUC__} are identifiers and hashed when lexed.\n \n Each node in the hash table contain various information about the\n identifier it represents.  For example, its length and type.  At any one\n@@ -392,12 +423,12 @@ time, each identifier falls into exactly one of three categories:\n @item Macros\n \n These have been declared to be macros, either on the command line or\n-with @code{#define}.  A few, such as @samp{__TIME__} are builtins\n+with @code{#define}.  A few, such as @code{__TIME__} are built-ins\n entered in the hash table during initialisation.  The hash node for a\n normal macro points to a structure with more information about the\n macro, such as whether it is function-like, how many arguments it takes,\n-and its expansion.  Builtin macros are flagged as special, and instead\n-contain an enum indicating which of the various builtin macros it is.\n+and its expansion.  Built-in macros are flagged as special, and instead\n+contain an enum indicating which of the various built-in macros it is.\n \n @item Assertions\n \n@@ -413,7 +444,7 @@ currently a macro, or a macro that has since been undefined with\n @code{#undef}.\n \n When preprocessing C++, this category also includes the named operators,\n-such as @samp{xor}.  In expressions these behave like the operators they\n+such as @code{xor}.  In expressions these behave like the operators they\n represent, but in contexts where the spelling of a token matters they\n are spelt differently.  This spelling distinction is relevant when they\n are operands of the stringizing and pasting macro operators @code{#} and\n@@ -429,13 +460,173 @@ hash node with the index of that argument.  This makes duplicated\n argument checking an O(1) operation for each argument.  Similarly, for\n each identifier in the macro's expansion, lookup to see if it is an\n argument, and which argument it is, is also an O(1) operation.  Further,\n-each directive name, such as @samp{endif}, has an associated directive\n+each directive name, such as @code{endif}, has an associated directive\n enum stored in its hash node, so that directive lookup is also O(1).\n \n-@node Macro Expansion, Files, Hash Nodes, Top\n+@node Macro Expansion\n @unnumbered Macro Expansion Algorithm\n \n-@node Files, Index, Macro Expansion, Top\n+@c TODO\n+\n+@node Token Spacing\n+@unnumbered Token Spacing\n+@cindex paste avoidance\n+@cindex spacing\n+@cindex token spacing\n+\n+First, let's look at an issue that only concerns the stand-alone\n+preprocessor: we want to guarantee that re-reading its preprocessed\n+output results in an identical token stream.  Without taking special\n+measures, this might not be the case because of macro substitution.  For\n+example:\n+\n+@smallexample\n+#define PLUS +\n+#define EMPTY\n+#define f(x) =x=\n++PLUS -EMPTY- PLUS+ f(=)\n+        @expansion{} + + - - + + = = =\n+@emph{not}\n+        @expansion{} ++ -- ++ ===\n+@end smallexample\n+\n+One solution would be to simply insert a space between all adjacent\n+tokens.  However, we would like to keep space insertion to a minimum,\n+both for aesthetic reasons and because it causes problems for people who\n+still try to abuse the preprocessor for things like Fortran source and\n+Makefiles.\n+\n+For now, just notice that the only places we need to be careful about\n+@dfn{paste avoidance} are when tokens are added (or removed) from the\n+original token stream.  This only occurs because of macro expansion, but\n+care is needed in many places: before @strong{and} after each macro\n+replacement, each argument replacement, and additionally each token\n+created by the @samp{#} and @samp{##} operators.\n+\n+Let's look at how the preprocessor gets whitespace output correct\n+normally.  The @code{cpp_token} structure contains a flags byte, and one\n+of those flags is @code{PREV_WHITE}.  This is flagged by the lexer, and\n+indicates that the token was preceded by whitespace of some form other\n+than a new line.  The stand-alone preprocessor can use this flag to\n+decide whether to insert a space between tokens in the output.\n+\n+Now consider the following:\n+\n+@smallexample\n+#define add(x, y, z) x + y +z;\n+sum = add (1,2, 3);\n+        @expansion{} sum = 1 + 2 +3;\n+@end smallexample\n+\n+The interesting thing here is that the tokens @samp{1} and @samp{2} are\n+output with a preceding space, and @samp{3} is output without a\n+preceding space, but when lexed none of these tokens had that property.\n+Careful consideration reveals that @samp{1} gets its preceding\n+whitespace from the space preceding @samp{add} in the macro\n+@emph{invocation}, @samp{2} gets its whitespace from the space preceding\n+the parameter @samp{y} in the macro @emph{replacement list}, and\n+@samp{3} has no preceding space because parameter @samp{z} has none in\n+the replacement list.\n+\n+Once lexed, tokens are effectively fixed and cannot be altered, since\n+pointers to them might be held in many places, in particular by\n+in-progress macro expansions.  So instead of modifying the two tokens\n+above, the preprocessor inserts a special token, which I call a\n+@dfn{padding token}, into the token stream in front of every macro\n+expansion and expanded macro argument, to indicate that the subsequent\n+token should assume its @code{PREV_WHITE} flag from a different\n+@dfn{source token}.  In the above example, the source tokens are\n+@samp{add} in the macro invocation, and @samp{y} and @samp{z} in the\n+macro replacement list, respectively.\n+\n+It is quite easy to get multiple padding tokens in a row, for example if\n+a macro's first replacement token expands straight into another macro.\n+\n+@smallexample\n+#define foo bar\n+#define bar baz\n+[foo]\n+        @expansion{} [baz]\n+@end smallexample\n+\n+Here, two padding tokens with sources @samp{foo} between the brackets,\n+and @samp{bar} from foo's replacement list, are generated.  Clearly the\n+first padding token is the one that matters.  But what if we happen to\n+leave a macro expansion?  Adjusting the above example slightly:\n+\n+@smallexample\n+#define foo bar\n+#define bar EMPTY baz\n+#define EMPTY\n+[foo] EMPTY;\n+        @expansion{} [ baz] ;\n+@end smallexample\n+\n+As shown, now there should be a space before baz and the semicolon.  Our\n+initial algorithm fails for the former, because we would see three\n+padding tokens, one per macro invocation, followed by @samp{baz}, which\n+would have inherit its spacing from the original source, @samp{foo},\n+which has no leading space.  Note that it is vital that cpplib get\n+spacing correct in these examples, since any of these macro expansions\n+could be stringified, where spacing matters.\n+\n+So, I have demonstrated that not just entering macro and argument\n+expansions, but leaving them requires special handling too.  So cpplib\n+inserts a padding token with a @code{NULL} source token when leaving\n+macro expansions and after each replaced argument in a macro's\n+replacement list.  It also inserts appropriate padding tokens on either\n+side of tokens created by the @samp{#} and @samp{##} operators.\n+\n+Now we can see the relationship with paste avoidance: we have to be\n+careful about paste avoidance in exactly the same locations we take care\n+to get white space correct.  This makes implementation of paste\n+avoidance easy: wherever the stand-alone preprocessor is fixing up\n+spacing because of padding tokens, and it turns out that no space is\n+needed, it has to take the extra step to check that a space is not\n+needed after all to avoid an accidental paste.  The function\n+@code{cpp_avoid_paste} advises whether a space is required between two\n+consecutive tokens.  To avoid excessive spacing, it tries hard to only\n+require a space if one is likely to be necessary, but for reasons of\n+efficiency it is slightly conservative and might recommend a space where\n+one is not strictly needed.\n+\n+@node Line Numbering\n+@unnumbered Line numbering\n+@cindex line numbers\n+\n+The preprocessor takes great care to ensure it keeps track of both the\n+position of a token in the source file, for diagnostic purposes, and\n+where it should appear in the output file, because using CPP for other\n+languages like assembler requires this.  The two positions may differ\n+for the following reasons:\n+\n+@itemize @bullet\n+@item\n+Escaped newlines are deleted, so lines spliced in this way are joined to\n+form a single logical line.\n+\n+@item\n+A macro expansion replaces the tokens that form its invocation, but any\n+newlines appearing in the macro's arguments are interpreted as a single\n+space, with the result that the macro's replacement appears in full on\n+the same line that the macro name appeared in the source file.  This is\n+particularly important for stringification of arguments---newlines\n+embedded in the arguments must appear in the string as spaces.\n+@end itemize\n+\n+The source file location is maintained in the @code{lineno} member of the\n+@code{cpp_buffer} structure, and the column number inferred from the\n+current position in the buffer relative to the @code{line_base} buffer\n+variable, which is updated with every newline whether escaped or not.\n+\n+@c FINISH THIS\n+\n+@node Guard Macros\n+@unnumbered The Multiple-Include Optimization\n+\n+@c TODO\n+\n+@node Files\n @unnumbered File Handling\n @cindex files\n \n@@ -459,10 +650,10 @@ filesystem queries whilst searching for the correct file.\n For each file we try to open, we store the constructed path in a splay\n tree.  This path first undergoes simplification by the function\n @code{_cpp_simplify_pathname}.  For example,\n-@samp{/usr/include/bits/../foo.h} is simplified to\n-@samp{/usr/include/foo.h} before we enter it in the splay tree and try\n+@file{/usr/include/bits/../foo.h} is simplified to\n+@file{/usr/include/foo.h} before we enter it in the splay tree and try\n to @code{open ()} the file.  CPP will then find subsequent uses of\n-@samp{foo.h}, even as @samp{/usr/include/foo.h}, in the splay tree and\n+@file{foo.h}, even as @file{/usr/include/foo.h}, in the splay tree and\n save system calls.\n \n Further, it is likely the file contents have also been cached, saving a\n@@ -486,7 +677,7 @@ directory on a per-file basis is handled by the function\n \n Note that a header included with a directory component, such as\n @code{#include \"mydir/foo.h\"} and opened as\n-@samp{/usr/local/include/mydir/foo.h}, will have the complete path minus\n+@file{/usr/local/include/mydir/foo.h}, will have the complete path minus\n the basename @samp{foo.h} as the current directory.\n \n Enough information is stored in the splay tree that CPP can immediately\n@@ -503,7 +694,7 @@ command line (or system) include directories to which the mapping\n applies.  This may be higher up the directory tree than the full path to\n the file minus the base name.\n \n-@node Index,, Files, Top\n+@node Index\n @unnumbered Index\n @printindex cp\n "}]}