{"sha": "cb20f7e8750c4d765bd3d88718e17a624409722a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IyMGY3ZTg3NTBjNGQ3NjViZDNkODg3MThlMTdhNjI0NDA5NzIyYQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-12-15T23:30:46Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-12-15T23:30:46Z"}, "message": "Commit part of Zdenek's larger loop-invariant.c patch.\n\n\t* loop-invariant.c (df): New global variable.\n\t(find_defs, check_dependencies, find_invariant_insn, record_uses,\n\tfind_invariants_bb, find_invariants_body, find_invariants,\n\tfind_invariants_to_move, move_invariants, free_inv_motion_data,\n\tmove_single_loop_invariants, move_loop_invariants): Do not pass df in\n\targuments.\n\nCo-Authored-By: Steven Bosscher <stevenb@suse.de>\n\nFrom-SVN: r108605", "tree": {"sha": "d6345f86a0a5a1dd252a995594547dd51c75d252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6345f86a0a5a1dd252a995594547dd51c75d252"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb20f7e8750c4d765bd3d88718e17a624409722a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb20f7e8750c4d765bd3d88718e17a624409722a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb20f7e8750c4d765bd3d88718e17a624409722a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb20f7e8750c4d765bd3d88718e17a624409722a/comments", "author": null, "committer": null, "parents": [{"sha": "0a942feac9601eb56861a3b6b7774119d32f95d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a942feac9601eb56861a3b6b7774119d32f95d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a942feac9601eb56861a3b6b7774119d32f95d1"}], "stats": {"total": 132, "additions": 69, "deletions": 63}, "files": [{"sha": "a3f97a1d30348655d60a4a679209824760faba46", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb20f7e8750c4d765bd3d88718e17a624409722a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb20f7e8750c4d765bd3d88718e17a624409722a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb20f7e8750c4d765bd3d88718e17a624409722a", "patch": "@@ -1,3 +1,13 @@\n+2005-12-15  Zdenek Dvorak <dvorakz@suse.cz>\n+\t    Steven Bosscher <stevenb@suse.de>\n+\n+\t* loop-invariant.c (df): New global variable.\n+\t(find_defs, check_dependencies, find_invariant_insn, record_uses,\n+\tfind_invariants_bb, find_invariants_body, find_invariants,\n+\tfind_invariants_to_move, move_invariants, free_inv_motion_data,\n+\tmove_single_loop_invariants, move_loop_invariants): Do not pass df in\n+\targuments.\n+\n 2005-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* varasm.c (default_unique_section_1): Use special section"}, {"sha": "8358f01c886dd46a1816b2203d68f2a3bf4028e2", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 59, "deletions": 63, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb20f7e8750c4d765bd3d88718e17a624409722a/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb20f7e8750c4d765bd3d88718e17a624409722a/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=cb20f7e8750c4d765bd3d88718e17a624409722a", "patch": "@@ -1,28 +1,28 @@\n-/* Rtl-level loop invariant motion.\n+/* RTL-level loop invariant motion.\n    Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n-   \n+\n This file is part of GCC.\n-   \n+\n GCC is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n Free Software Foundation; either version 2, or (at your option) any\n later version.\n-   \n+\n GCC is distributed in the hope that it will be useful, but WITHOUT\n ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n for more details.\n-   \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n /* This implements the loop invariant motion pass.  It is very simple\n-   (no calls, libcalls, etc.).  This should be sufficient to cleanup things like\n-   address arithmetics -- other more complicated invariants should be\n+   (no calls, libcalls, etc.).  This should be sufficient to cleanup things\n+   like address arithmetics -- other more complicated invariants should be\n    eliminated on tree level either in tree-ssa-loop-im.c or in tree-ssa-pre.c.\n-   \n+\n    We proceed loop by loop -- it is simpler than trying to handle things\n    globally and should not lose much.  First we inspect all sets inside loop\n    and create a dependency graph on insns (saying \"to move this insn, you must\n@@ -31,7 +31,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    We then need to determine what to move.  We estimate the number of registers\n    used and move as many invariants as possible while we still have enough free\n    registers.  We prefer the expensive invariants.\n-   \n+\n    Then we move the selected invariants out of the loop, creating a new\n    temporaries for them if necessary.  */\n \n@@ -103,7 +103,7 @@ struct invariant\n   /* Whether to move the invariant.  */\n   bool move;\n \n-  /* Cost if the invariant.  */\n+  /* Cost of the invariant.  */\n   unsigned cost;\n \n   /* The invariants it depends on.  */\n@@ -128,6 +128,10 @@ DEF_VEC_ALLOC_P(invariant_p, heap);\n \n static VEC(invariant_p,heap) *invariants;\n \n+/* The dataflow object.  */\n+\n+static struct df *df;\n+\n /* Test for possibility of invariantness of X.  */\n \n static bool\n@@ -259,7 +263,7 @@ find_exits (struct loop *loop, basic_block *body,\n \t    }\n \t  continue;\n \t}\n-     \n+\n       /* Use the data stored for the subloop to decide whether we may exit\n \t through it.  It is sufficient to do this for header of the loop,\n \t as other basic blocks inside it must be dominated by it.  */\n@@ -298,11 +302,11 @@ may_assign_reg_p (rtx x)\n \t      || REGNO_REG_CLASS (REGNO (x)) != NO_REGS));\n }\n \n-/* Finds definitions that may correspond to invariants in LOOP with body BODY.\n-   DF is the dataflow object.  */\n+/* Finds definitions that may correspond to invariants in LOOP with body\n+   BODY.  */\n \n static void\n-find_defs (struct loop *loop, basic_block *body, struct df *df)\n+find_defs (struct loop *loop, basic_block *body)\n {\n   unsigned i;\n   bitmap blocks = BITMAP_ALLOC (NULL);\n@@ -374,10 +378,10 @@ record_use (struct def *def, rtx *use, rtx insn)\n }\n \n /* Finds the invariants INSN depends on and store them to the DEPENDS_ON\n-   bitmap.  DF is the dataflow object.  */\n+   bitmap.  */\n \n static bool\n-check_dependencies (rtx insn, struct df *df, bitmap depends_on)\n+check_dependencies (rtx insn, bitmap depends_on)\n {\n   struct df_link *uses, *defs;\n   struct ref *use, *def;\n@@ -412,12 +416,10 @@ check_dependencies (rtx insn, struct df *df, bitmap depends_on)\n \n /* Finds invariant in INSN.  ALWAYS_REACHED is true if the insn is always\n    executed.  ALWAYS_EXECUTED is true if the insn is always executed,\n-   unless the program ends due to a function call.  DF is the dataflow\n-   object.  */\n+   unless the program ends due to a function call.  */\n \n static void\n-find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n-\t\t     struct df *df)\n+find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n {\n   struct ref *ref;\n   struct def *def;\n@@ -430,7 +432,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n       || find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n       || find_reg_note (insn, REG_NO_CONFLICT, NULL_RTX))\n     return;\n-      \n+ \n   set = single_set (insn);\n   if (!set)\n     return;\n@@ -456,7 +458,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n     }\n \n   depends_on = BITMAP_ALLOC (NULL);\n-  if (!check_dependencies (insn, df, depends_on))\n+  if (!check_dependencies (insn, depends_on))\n     {\n       BITMAP_FREE (depends_on);\n       return;\n@@ -474,11 +476,10 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n   create_new_invariant (def, insn, depends_on, always_executed);\n }\n \n-/* Record registers used in INSN that have a unique invariant definition.\n-   DF is the dataflow object.  */\n+/* Record registers used in INSN that have a unique invariant definition.  */\n \n static void\n-record_uses (rtx insn, struct df *df)\n+record_uses (rtx insn)\n {\n   struct df_link *uses, *defs;\n   struct ref *use, *def;\n@@ -505,25 +506,22 @@ record_uses (rtx insn, struct df *df)\n \n /* Finds invariants in INSN.  ALWAYS_REACHED is true if the insn is always\n    executed.  ALWAYS_EXECUTED is true if the insn is always executed,\n-   unless the program ends due to a function call.  DF is the dataflow\n-   object.  */\n+   unless the program ends due to a function call.  */\n \n static void\n-find_invariants_insn (rtx insn, bool always_reached, bool always_executed,\n-\t\t      struct df *df)\n+find_invariants_insn (rtx insn, bool always_reached, bool always_executed)\n {\n-  find_invariant_insn (insn, always_reached, always_executed, df);\n-  record_uses (insn, df);\n+  find_invariant_insn (insn, always_reached, always_executed);\n+  record_uses (insn);\n }\n \n /* Finds invariants in basic block BB.  ALWAYS_REACHED is true if the\n    basic block is always executed.  ALWAYS_EXECUTED is true if the basic\n    block is always executed, unless the program ends due to a function\n-   call.  DF is the dataflow object.  */\n+   call.  */\n \n static void\n-find_invariants_bb (basic_block bb, bool always_reached, bool always_executed,\n-\t\t    struct df *df)\n+find_invariants_bb (basic_block bb, bool always_reached, bool always_executed)\n {\n   rtx insn;\n \n@@ -532,7 +530,7 @@ find_invariants_bb (basic_block bb, bool always_reached, bool always_executed,\n       if (!INSN_P (insn))\n \tcontinue;\n \n-      find_invariants_insn (insn, always_reached, always_executed, df);\n+      find_invariants_insn (insn, always_reached, always_executed);\n \n       if (always_reached\n \t  && CALL_P (insn)\n@@ -544,26 +542,24 @@ find_invariants_bb (basic_block bb, bool always_reached, bool always_executed,\n /* Finds invariants in LOOP with body BODY.  ALWAYS_REACHED is the bitmap of\n    basic blocks in BODY that are always executed.  ALWAYS_EXECUTED is the\n    bitmap of basic blocks in BODY that are always executed unless the program\n-   ends due to a function call.  DF is the dataflow object.  */\n+   ends due to a function call.  */\n \n static void\n find_invariants_body (struct loop *loop, basic_block *body,\n-\t\t      bitmap always_reached, bitmap always_executed,\n-\t\t      struct df *df)\n+\t\t      bitmap always_reached, bitmap always_executed)\n {\n   unsigned i;\n \n   for (i = 0; i < loop->num_nodes; i++)\n     find_invariants_bb (body[i],\n \t\t\tbitmap_bit_p (always_reached, i),\n-\t\t\tbitmap_bit_p (always_executed, i),\n-\t\t\tdf);\n+\t\t\tbitmap_bit_p (always_executed, i));\n }\n \n-/* Finds invariants in LOOP.  DF is the dataflow object.  */\n+/* Finds invariants in LOOP.  */\n \n static void\n-find_invariants (struct loop *loop, struct df *df)\n+find_invariants (struct loop *loop)\n {\n   bitmap may_exit = BITMAP_ALLOC (NULL);\n   bitmap always_reached = BITMAP_ALLOC (NULL);\n@@ -575,8 +571,8 @@ find_invariants (struct loop *loop, struct df *df)\n   compute_always_reached (loop, body, may_exit, always_reached);\n   compute_always_reached (loop, body, has_exit, always_executed);\n \n-  find_defs (loop, body, df);\n-  find_invariants_body (loop, body, always_reached, always_executed, df);\n+  find_defs (loop, body);\n+  find_invariants_body (loop, body, always_reached, always_executed);\n \n   BITMAP_FREE (always_reached);\n   BITMAP_FREE (always_executed);\n@@ -721,10 +717,10 @@ set_move_mark (unsigned invno)\n     }\n }\n \n-/* Determines which invariants to move.  DF is the dataflow object.  */\n+/* Determines which invariants to move.  */\n \n static void\n-find_invariants_to_move (struct df *df)\n+find_invariants_to_move (void)\n {\n   unsigned i, regs_used, n_inv_uses, regs_needed = 0, new_regs;\n   struct invariant *inv = NULL;\n@@ -764,10 +760,10 @@ find_invariants_to_move (struct df *df)\n     }\n }\n \n-/* Move invariant INVNO out of the LOOP.  DF is the dataflow object.  */\n+/* Move invariant INVNO out of the LOOP.  */\n \n static void\n-move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n+move_invariant_reg (struct loop *loop, unsigned invno)\n {\n   struct invariant *inv = VEC_index (invariant_p, invariants, invno);\n   unsigned i;\n@@ -784,7 +780,7 @@ move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n     {\n       EXECUTE_IF_SET_IN_BITMAP (inv->depends_on, 0, i, bi)\n \t{\n-\t  move_invariant_reg (loop, i, df);\n+\t  move_invariant_reg (loop, i);\n \t}\n     }\n \n@@ -828,18 +824,18 @@ move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n }\n \n /* Move selected invariant out of the LOOP.  Newly created regs are marked\n-   in TEMPORARY_REGS.  DF is the dataflow object.  */\n+   in TEMPORARY_REGS.  */\n \n static void\n-move_invariants (struct loop *loop, struct df *df)\n+move_invariants (struct loop *loop)\n {\n   struct invariant *inv;\n   unsigned i;\n \n   for (i = 0; VEC_iterate (invariant_p, invariants, i, inv); i++)\n     {\n       if (inv->move)\n-\tmove_invariant_reg (loop, i, df);\n+\tmove_invariant_reg (loop, i);\n     }\n }\n \n@@ -853,11 +849,10 @@ init_inv_motion_data (void)\n   invariants = VEC_alloc (invariant_p, heap, 100);\n }\n \n-/* Frees the data allocated by invariant motion.  DF is the dataflow\n-   object.  */\n+/* Frees the data allocated by invariant motion.  */\n \n static void\n-free_inv_motion_data (struct df *df)\n+free_inv_motion_data (void)\n {\n   unsigned i;\n   struct def *def;\n@@ -885,18 +880,18 @@ free_inv_motion_data (struct df *df)\n   VEC_free (invariant_p, heap, invariants);\n }\n \n-/* Move the invariants out of the LOOP.  DF is the dataflow object.  */\n+/* Move the invariants out of the LOOP.  */\n \n static void\n-move_single_loop_invariants (struct loop *loop, struct df *df)\n+move_single_loop_invariants (struct loop *loop)\n {\n   init_inv_motion_data ();\n \n-  find_invariants (loop, df);\n-  find_invariants_to_move (df);\n-  move_invariants (loop, df);\n+  find_invariants (loop);\n+  find_invariants_to_move ();\n+  move_invariants (loop);\n \n-  free_inv_motion_data (df);\n+  free_inv_motion_data ();\n }\n \n /* Releases the auxiliary data for LOOP.  */\n@@ -917,7 +912,8 @@ move_loop_invariants (struct loops *loops)\n {\n   struct loop *loop;\n   unsigned i;\n-  struct df *df = df_init ();\n+\n+  df = df_init ();\n \n   /* Process the loops, innermost first.  */\n   loop = loops->tree_root;\n@@ -926,7 +922,7 @@ move_loop_invariants (struct loops *loops)\n \n   while (loop != loops->tree_root)\n     {\n-      move_single_loop_invariants (loop, df);\n+      move_single_loop_invariants (loop);\n \n       if (loop->next)\n \t{"}]}