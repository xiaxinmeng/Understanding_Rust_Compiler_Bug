{"sha": "277fe616911ac1ce91e9f1178d648303b4a26940", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3ZmU2MTY5MTFhYzFjZTkxZTlmMTE3OGQ2NDgzMDNiNGEyNjk0MA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-11-13T01:54:41Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-11-13T01:54:41Z"}, "message": "Implement Levenshtein distance; use in C FE for misspelled field names\n\nThis is the combination of:\n  [PATCH 1/2] Implement Levenshtein distance\n  [PATCH 2/2] C FE: suggest corrections for misspelled field names\nplus some nit fixes in spellcheck.c.\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add spellcheck.o.\n\t* spellcheck.c: New file.\n\t* spellcheck.h: New file.\n\ngcc/c/ChangeLog:\n\t* c-typeck.c: Include spellcheck.h.\n\t(lookup_field_fuzzy_find_candidates): New function.\n\t(lookup_field_fuzzy): New function.\n\t(build_component_ref): If the field was not found, try using\n\tlookup_field_fuzzy and potentially offer a suggestion.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/plugin/levenshtein-test-1.c: New file.\n\t* gcc.dg/plugin/levenshtein_plugin.c: New file.\n\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add\n\tlevenshtein_plugin.c.\n\t* gcc.dg/spellcheck-fields.c: New file.\n\nFrom-SVN: r230284", "tree": {"sha": "574b1272f86df52172c56c614532ff5032b6f73d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/574b1272f86df52172c56c614532ff5032b6f73d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/277fe616911ac1ce91e9f1178d648303b4a26940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277fe616911ac1ce91e9f1178d648303b4a26940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/277fe616911ac1ce91e9f1178d648303b4a26940", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/277fe616911ac1ce91e9f1178d648303b4a26940/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d82151f8c08d123eaab63409cd8ba6f85d0539c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d82151f8c08d123eaab63409cd8ba6f85d0539c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d82151f8c08d123eaab63409cd8ba6f85d0539c"}], "stats": {"total": 402, "additions": 401, "deletions": 1}, "files": [{"sha": "1febdcf6febd9413369d7221c4b1ef0f2407e258", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -1,3 +1,9 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add spellcheck.o.\n+\t* spellcheck.c: New file.\n+\t* spellcheck.h: New file.\n+\n 2015-11-13  James Bowman  <james.bowman@ftdichip.com>\n \n         * config/ft32/ft32.md (*sne): New insn pattern."}, {"sha": "f17234d78708ac65555c3bec1a4ec3c20e955f4e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -1403,6 +1403,7 @@ OBJS = \\\n \tshrink-wrap.o \\\n \tsimplify-rtx.o \\\n \tsparseset.o \\\n+\tspellcheck.o \\\n \tsreal.o \\\n \tstack-ptr-mod.o \\\n \tstatistics.o \\"}, {"sha": "9b1fdc9343d3a117fad4d75df72f5192f37c64c1", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -1,3 +1,11 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-typeck.c: Include spellcheck.h.\n+\t(lookup_field_fuzzy_find_candidates): New function.\n+\t(lookup_field_fuzzy): New function.\n+\t(build_component_ref): If the field was not found, try using\n+\tlookup_field_fuzzy and potentially offer a suggestion.\n+\n 2015-11-12  James Norris  <jnorris@codesourcery.com>\n \t    Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "eb4e1fccc446c6a77cfdf4e237a87ea00122cc88", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ubsan.h\"\n #include \"cilk.h\"\n #include \"gomp-constants.h\"\n+#include \"spellcheck.h\"\n \n /* Possible cases of implicit bad conversions.  Used to select\n    diagnostic messages in convert_for_assignment.  */\n@@ -2242,6 +2243,72 @@ lookup_field (tree type, tree component)\n   return tree_cons (NULL_TREE, field, NULL_TREE);\n }\n \n+/* Recursively append candidate IDENTIFIER_NODEs to CANDIDATES.  */\n+\n+static void\n+lookup_field_fuzzy_find_candidates (tree type, tree component,\n+\t\t\t\t    vec<tree> *candidates)\n+{\n+  tree field;\n+  for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n+    {\n+      if (DECL_NAME (field) == NULL_TREE\n+\t  && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n+\t      || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n+\t{\n+\t  lookup_field_fuzzy_find_candidates (TREE_TYPE (field),\n+\t\t\t\t\t      component,\n+\t\t\t\t\t      candidates);\n+\t}\n+\n+      if (DECL_NAME (field))\n+\tcandidates->safe_push (DECL_NAME (field));\n+    }\n+}\n+\n+/* Like \"lookup_field\", but find the closest matching IDENTIFIER_NODE,\n+   rather than returning a TREE_LIST for an exact match.  */\n+\n+static tree\n+lookup_field_fuzzy (tree type, tree component)\n+{\n+  gcc_assert (TREE_CODE (component) == IDENTIFIER_NODE);\n+\n+  /* First, gather a list of candidates.  */\n+  auto_vec <tree> candidates;\n+\n+  lookup_field_fuzzy_find_candidates (type, component,\n+\t\t\t\t      &candidates);\n+\n+  /* Now determine which is closest.  */\n+  int i;\n+  tree identifier;\n+  tree best_identifier = NULL;\n+  edit_distance_t best_distance = MAX_EDIT_DISTANCE;\n+  FOR_EACH_VEC_ELT (candidates, i, identifier)\n+    {\n+      gcc_assert (TREE_CODE (identifier) == IDENTIFIER_NODE);\n+      edit_distance_t dist = levenshtein_distance (component, identifier);\n+      if (dist < best_distance)\n+\t{\n+\t  best_distance = dist;\n+\t  best_identifier = identifier;\n+\t}\n+    }\n+\n+  /* If more than half of the letters were misspelled, the suggestion is\n+     likely to be meaningless.  */\n+  if (best_identifier)\n+    {\n+      unsigned int cutoff = MAX (IDENTIFIER_LENGTH (component),\n+\t\t\t\t IDENTIFIER_LENGTH (best_identifier)) / 2;\n+      if (best_distance > cutoff)\n+\treturn NULL;\n+    }\n+\n+  return best_identifier;\n+}\n+\n /* Make an expression to refer to the COMPONENT field of structure or\n    union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  LOC is the\n    location of the COMPONENT_REF.  */\n@@ -2277,7 +2344,12 @@ build_component_ref (location_t loc, tree datum, tree component)\n \n       if (!field)\n \t{\n-\t  error_at (loc, \"%qT has no member named %qE\", type, component);\n+\t  tree guessed_id = lookup_field_fuzzy (type, component);\n+\t  if (guessed_id)\n+\t    error_at (loc, \"%qT has no member named %qE; did you mean %qE?\",\n+\t\t      type, component, guessed_id);\n+\t  else\n+\t    error_at (loc, \"%qT has no member named %qE\", type, component);\n \t  return error_mark_node;\n \t}\n "}, {"sha": "31ce32245461fed3772caa0dce6dd944479e4b0b", "filename": "gcc/spellcheck.c", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fspellcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fspellcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.c?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -0,0 +1,136 @@\n+/* Find near-matches for strings and identifiers.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"spellcheck.h\"\n+\n+/* The Levenshtein distance is an \"edit-distance\": the minimal\n+   number of one-character insertions, removals or substitutions\n+   that are needed to change one string into another.\n+\n+   This implementation uses the Wagner-Fischer algorithm.  */\n+\n+static edit_distance_t\n+levenshtein_distance (const char *s, int len_s,\n+\t\t      const char *t, int len_t)\n+{\n+  const bool debug = false;\n+\n+  if (debug)\n+    {\n+      printf (\"s: \\\"%s\\\" (len_s=%i)\\n\", s, len_s);\n+      printf (\"t: \\\"%s\\\" (len_t=%i)\\n\", t, len_t);\n+    }\n+\n+  if (len_s == 0)\n+    return len_t;\n+  if (len_t == 0)\n+    return len_s;\n+\n+  /* We effectively build a matrix where each (i, j) contains the\n+     Levenshtein distance between the prefix strings s[0:j]\n+     and t[0:i].\n+     Rather than actually build an (len_t + 1) * (len_s + 1) matrix,\n+     we simply keep track of the last row, v0 and a new row, v1,\n+     which avoids an (len_t + 1) * (len_s + 1) allocation and memory accesses\n+     in favor of two (len_s + 1) allocations.  These could potentially be\n+     statically-allocated if we impose a maximum length on the\n+     strings of interest.  */\n+  edit_distance_t *v0 = new edit_distance_t[len_s + 1];\n+  edit_distance_t *v1 = new edit_distance_t[len_s + 1];\n+\n+  /* The first row is for the case of an empty target string, which\n+     we can reach by deleting every character in the source string.  */\n+  for (int i = 0; i < len_s + 1; i++)\n+    v0[i] = i;\n+\n+  /* Build successive rows.  */\n+  for (int i = 0; i < len_t; i++)\n+    {\n+      if (debug)\n+\t{\n+\t  printf (\"i:%i v0 = \", i);\n+\t  for (int j = 0; j < len_s + 1; j++)\n+\t    printf (\"%i \", v0[j]);\n+\t  printf (\"\\n\");\n+\t}\n+\n+      /* The initial column is for the case of an empty source string; we\n+\t can reach prefixes of the target string of length i\n+\t by inserting i characters.  */\n+      v1[0] = i + 1;\n+\n+      /* Build the rest of the row by considering neighbours to\n+\t the north, west and northwest.  */\n+      for (int j = 0; j < len_s; j++)\n+\t{\n+\t  edit_distance_t cost = (s[j] == t[i] ? 0 : 1);\n+\t  edit_distance_t deletion     = v1[j] + 1;\n+\t  edit_distance_t insertion    = v0[j + 1] + 1;\n+\t  edit_distance_t substitution = v0[j] + cost;\n+\t  edit_distance_t cheapest = MIN (deletion, insertion);\n+\t  cheapest = MIN (cheapest, substitution);\n+\t  v1[j + 1] = cheapest;\n+\t}\n+\n+      /* Prepare to move on to next row.  */\n+      for (int j = 0; j < len_s + 1; j++)\n+\tv0[j] = v1[j];\n+    }\n+\n+  if (debug)\n+    {\n+      printf (\"final v1 = \");\n+      for (int j = 0; j < len_s + 1; j++)\n+\tprintf (\"%i \", v1[j]);\n+      printf (\"\\n\");\n+    }\n+\n+  edit_distance_t result = v1[len_s];\n+  delete[] v0;\n+  delete[] v1;\n+  return result;\n+}\n+\n+/* Calculate Levenshtein distance between two nil-terminated strings.\n+   This exists purely for the unit tests.  */\n+\n+edit_distance_t\n+levenshtein_distance (const char *s, const char *t)\n+{\n+  return levenshtein_distance (s, strlen (s), t, strlen (t));\n+}\n+\n+/* Calculate Levenshtein distance between two identifiers.  */\n+\n+edit_distance_t\n+levenshtein_distance (tree ident_s, tree ident_t)\n+{\n+  gcc_assert (TREE_CODE (ident_s) == IDENTIFIER_NODE);\n+  gcc_assert (TREE_CODE (ident_t) == IDENTIFIER_NODE);\n+\n+  return levenshtein_distance (IDENTIFIER_POINTER (ident_s),\n+\t\t\t       IDENTIFIER_LENGTH (ident_s),\n+\t\t\t       IDENTIFIER_POINTER (ident_t),\n+\t\t\t       IDENTIFIER_LENGTH (ident_t));\n+}"}, {"sha": "58355d60e92166188963f57ddbe2cec0eef19e28", "filename": "gcc/spellcheck.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fspellcheck.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Fspellcheck.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fspellcheck.h?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -0,0 +1,32 @@\n+/* Find near-matches for strings and identifiers.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SPELLCHECK_H\n+#define GCC_SPELLCHECK_H\n+\n+typedef unsigned int edit_distance_t;\n+const edit_distance_t MAX_EDIT_DISTANCE = UINT_MAX;\n+\n+extern edit_distance_t\n+levenshtein_distance (const char *s, const char *t);\n+\n+extern edit_distance_t\n+levenshtein_distance (tree ident_s, tree ident_t);\n+\n+#endif  /* GCC_SPELLCHECK_H  */"}, {"sha": "67299e015cdad0e0f035df228c66fd4ba931b72f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -1,3 +1,11 @@\n+2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/plugin/levenshtein-test-1.c: New file.\n+\t* gcc.dg/plugin/levenshtein_plugin.c: New file.\n+\t* gcc.dg/plugin/plugin.exp (plugin_test_list): Add\n+\tlevenshtein_plugin.c.\n+\t* gcc.dg/spellcheck-fields.c: New file.\n+\n 2015-11-12  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68318"}, {"sha": "ac49992780d2fcb4562823ef7441b081cacf8e7b", "filename": "gcc/testsuite/gcc.dg/plugin/levenshtein-test-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein-test-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein-test-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein-test-1.c?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -0,0 +1,9 @@\n+/* Placeholder C source file for unit-testing gcc/spellcheck.c.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  return 0;\n+}"}, {"sha": "3e7dc7889305a422eddd6de8760fd1dc0499a2e3", "filename": "gcc/testsuite/gcc.dg/plugin/levenshtein_plugin.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Flevenshtein_plugin.c?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -0,0 +1,64 @@\n+/* Plugin for unittesting gcc/spellcheck.h.  */\n+\n+#include \"config.h\"\n+#include \"gcc-plugin.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"spellcheck.h\"\n+#include \"diagnostic.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+static void\n+levenshtein_distance_unit_test_oneway (const char *a, const char *b,\n+\t\t\t\t       edit_distance_t expected)\n+{\n+  edit_distance_t actual = levenshtein_distance (a, b);\n+  if (actual != expected)\n+    error (\"levenshtein_distance (\\\"%s\\\", \\\"%s\\\") : expected: %i got %i\",\n+\t   a, b, expected, actual);\n+}\n+\n+\n+static void\n+levenshtein_distance_unit_test (const char *a, const char *b,\n+\t\t\t\tedit_distance_t expected)\n+{\n+  /* Run every test both ways to ensure it's symmetric.  */\n+  levenshtein_distance_unit_test_oneway (a, b, expected);\n+  levenshtein_distance_unit_test_oneway (b, a, expected);\n+}\n+\n+/* Callback handler for the PLUGIN_FINISH event; run\n+   levenshtein_distance unit tests here.  */\n+\n+static void\n+on_finish (void */*gcc_data*/, void */*user_data*/)\n+{\n+  levenshtein_distance_unit_test (\"\", \"nonempty\", strlen (\"nonempty\"));\n+  levenshtein_distance_unit_test (\"saturday\", \"sunday\", 3);\n+  levenshtein_distance_unit_test (\"foo\", \"m_foo\", 2);\n+  levenshtein_distance_unit_test (\"hello_world\", \"HelloWorld\", 3);\n+  levenshtein_distance_unit_test\n+    (\"the quick brown fox jumps over the lazy dog\", \"dog\", 40);\n+  levenshtein_distance_unit_test\n+    (\"the quick brown fox jumps over the lazy dog\",\n+     \"the quick brown dog jumps over the lazy fox\",\n+     4);\n+  levenshtein_distance_unit_test\n+    (\"Lorem ipsum dolor sit amet, consectetur adipiscing elit,\",\n+     \"All your base are belong to us\",\n+     44);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version */*version*/)\n+{\n+  register_callback (plugin_info->base_name,\n+\t\t     PLUGIN_FINISH,\n+\t\t     on_finish,\n+\t\t     NULL); /* void *user_data */\n+\n+  return 0;\n+}"}, {"sha": "ce0a18d0a983e463b7ee77ade52a07a56c191311", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -66,6 +66,7 @@ set plugin_test_list [list \\\n     { diagnostic_plugin_test_show_locus.c \\\n \t  diagnostic-test-show-locus-bw.c \\\n \t  diagnostic-test-show-locus-color.c } \\\n+    { levenshtein_plugin.c levenshtein-test-1.c } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}, {"sha": "01be5508dc53c4c4172c24d4f1d88266a2b53681", "filename": "gcc/testsuite/gcc.dg/spellcheck-fields.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-fields.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/277fe616911ac1ce91e9f1178d648303b4a26940/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-fields.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fspellcheck-fields.c?ref=277fe616911ac1ce91e9f1178d648303b4a26940", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+\n+struct foo\n+{\n+  int foo;\n+  int bar;\n+  int baz;\n+};\n+\n+int test (struct foo *ptr)\n+{\n+  return ptr->m_bar; /* { dg-error \"'struct foo' has no member named 'm_bar'; did you mean 'bar'?\" } */\n+}\n+\n+int test2 (void)\n+{\n+  struct foo instance = {0, 0, 0};\n+  return instance.m_bar; /* { dg-error \"'struct foo' has no member named 'm_bar'; did you mean 'bar'?\" } */\n+}\n+\n+struct s {\n+    struct j { int aa; } kk;\n+    int ab;\n+};\n+\n+void test3 (struct s x)\n+{\n+  x.ac;  /* { dg-error \"'struct s' has no member named 'ac'; did you mean 'ab'?\" } */\n+}\n+\n+int test4 (struct foo *ptr)\n+{\n+  return sizeof (ptr->foa); /* { dg-error \"'struct foo' has no member named 'foa'; did you mean 'foo'?\" } */\n+}\n+\n+/* Verify that we don't offer nonsensical suggestions.  */\n+\n+int test5 (struct foo *ptr)\n+{\n+  return ptr->this_is_unlike_any_of_the_fields;   /* { dg-bogus \"did you mean\" } */\n+  /* { dg-error \"has no member named\" \"\" { target *-*-* } 40 } */\n+}\n+\n+union u\n+{\n+  int color;\n+  int shape;\n+};\n+\n+int test6 (union u *ptr)\n+{\n+  return ptr->colour; /* { dg-error \"'union u' has no member named 'colour'; did you mean 'color'?\" } */\n+}\n+\n+struct has_anon\n+{\n+  struct { int color; } s;\n+};\n+\n+int test7 (struct has_anon *ptr)\n+{\n+  return ptr->s.colour; /* { dg-error \"'struct <anonymous>' has no member named 'colour'; did you mean 'color'?\" } */\n+}"}]}