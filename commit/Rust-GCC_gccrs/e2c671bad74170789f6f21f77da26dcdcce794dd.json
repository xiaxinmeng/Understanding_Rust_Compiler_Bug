{"sha": "e2c671bad74170789f6f21f77da26dcdcce794dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjNjcxYmFkNzQxNzA3ODlmNmYyMWY3N2RhMjZkY2RjY2U3OTRkZA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-23T16:02:41Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-23T16:02:41Z"}, "message": "include tree.h\n\ninclude tree.h\n(const_ok_for_arm): Add fast return for 0 or just a single non-zero bit.\n(const_ok_for_op): New function.\n(arm_split_constant): New function.\n(arm_rtx_costs): New function.\n(reg_or_int_operand): New function.\n(shift_operator): Accept ROTATERT.\n(multi_register_push): New function.\n(shift_op): Don't abort if a constant is outside the acceptable range, but\nconvert the whole shift expression into something legal.  If the shift is\nzero, then return NULL.\n(output_return_instruction): Output a call to abort if the function is\nvolatile.\n(arm_volatile_func): New function.\n(get_prologue_size): Remove all adjustments for insns that are now output as\nrtx.\n(output_func_prologue): Remove all code that outputs instructions, just print\na few comments.\n(output_func_epilogue): Output a call to abort if a volatile function tries\nto return.\n(emit_multi_reg_push): New function.\n(arm_expand_prologue): New function.  Don't bother to push call-saved regs\nif we will never return.\n(arm_print_operand, case 'S'): If shift_op returns NULL, then no shift is\nrequired.\n\nFrom-SVN: r7537", "tree": {"sha": "3b26673421ad05c64b06014a4296ff3dd80df3cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b26673421ad05c64b06014a4296ff3dd80df3cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2c671bad74170789f6f21f77da26dcdcce794dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c671bad74170789f6f21f77da26dcdcce794dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c671bad74170789f6f21f77da26dcdcce794dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c671bad74170789f6f21f77da26dcdcce794dd/comments", "author": null, "committer": null, "parents": [{"sha": "3967692c7e1b466fc94ae3ec40827abde0e5c73c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3967692c7e1b466fc94ae3ec40827abde0e5c73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3967692c7e1b466fc94ae3ec40827abde0e5c73c"}], "stats": {"total": 1091, "additions": 981, "deletions": 110}, "files": [{"sha": "b17d9431a2a06ef2e308a2ea7060ce3b9f9d4d11", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 981, "deletions": 110, "changes": 1091, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2c671bad74170789f6f21f77da26dcdcce794dd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2c671bad74170789f6f21f77da26dcdcce794dd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e2c671bad74170789f6f21f77da26dcdcce794dd", "patch": "@@ -35,6 +35,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"reload.h\"\n+#include \"tree.h\"\n \n /* The maximum number of insns skipped which will be conditionalised if\n    possible.  */\n@@ -135,6 +136,10 @@ const_ok_for_arm (i)\n {\n   unsigned HOST_WIDE_INT mask = ~0xFF;\n \n+  /* Fast return for 0 and powers of 2 */\n+  if ((i & (i - 1)) == 0)\n+    return TRUE;\n+\n   do\n     {\n       if ((i & mask & (unsigned HOST_WIDE_INT) 0xffffffff) == 0)\n@@ -147,6 +152,734 @@ const_ok_for_arm (i)\n   return FALSE;\n }\n \n+/* Return true if I is a valid constant for the operation CODE. */\n+int\n+const_ok_for_op (i, code, mode)\n+     HOST_WIDE_INT i;\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+{\n+  if (const_ok_for_arm (i))\n+    return 1;\n+\n+  switch (code)\n+    {\n+    case PLUS:\n+      return const_ok_for_arm (ARM_SIGN_EXTEND (-i));\n+\n+    case MINUS:\t\t/* Should only occur with (MINUS I reg) => rsb */\n+    case XOR:\n+    case IOR:\n+      return 0;\n+\n+    case AND:\n+      return const_ok_for_arm (ARM_SIGN_EXTEND (~i));\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Emit a sequence of insns to handle a large constant.\n+   CODE is the code of the operation required, it can be any of SET, PLUS,\n+   IOR, AND, XOR, MINUS;\n+   MODE is the mode in which the operation is being performed;\n+   VAL is the integer to operate on;\n+   SOURCE is the other operand (a register, or a null-pointer for SET);\n+   SUBTARGETS means it is safe to create scratch registers if that will\n+   either produce a simpler sequence, or we will want to cse the values. */\n+\n+int\n+arm_split_constant (code, mode, val, target, source, subtargets)\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+     HOST_WIDE_INT val;\n+     rtx target;\n+     rtx source;\n+     int subtargets;\n+{\n+  int can_add = 0;\n+  int can_invert = 0;\n+  int can_negate = 0;\n+  int can_negate_initial = 0;\n+  int can_shift = 0;\n+  int i;\n+  int num_bits_set = 0;\n+  int set_sign_bit_copies = 0;\n+  int clear_sign_bit_copies = 0;\n+  int clear_zero_bit_copies = 0;\n+  int set_zero_bit_copies = 0;\n+  int insns = 0;\n+  rtx new_src;\n+  unsigned HOST_WIDE_INT temp1, temp2;\n+  unsigned HOST_WIDE_INT remainder = val & 0xffffffff;\n+\n+  /* find out which operations are safe for a given CODE.  Also do a quick\n+     check for degenerate cases; these can occur when DImode operations\n+     are split.  */\n+  switch (code)\n+    {\n+    case SET:\n+      can_invert = 1;\n+      can_shift = 1;\n+      can_negate = 1;\n+      break;\n+\n+    case PLUS:\n+      can_negate = 1;\n+      can_negate_initial = 1;\n+      break;\n+\n+    case IOR:\n+      if (remainder == 0xffffffff)\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t      GEN_INT (ARM_SIGN_EXTEND (val))));\n+\t  return 1;\n+\t}\n+      if (remainder == 0)\n+\t{\n+\t  if (reload_completed && rtx_equal_p (target, source))\n+\t    return 0;\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target, source));\n+\t  return 1;\n+\t}\n+      break;\n+\n+    case AND:\n+      if (remainder == 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target, const0_rtx));\n+\t  return 1;\n+\t}\n+      if (remainder == 0xffffffff)\n+\t{\n+\t  if (reload_completed && rtx_equal_p (target, source))\n+\t    return 0;\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target, source));\n+\t  return 1;\n+\t}\n+      can_invert = 1;\n+      break;\n+\n+    case XOR:\n+      if (remainder == 0)\n+\t{\n+\t  if (reload_completed && rtx_equal_p (target, source))\n+\t    return 0;\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target, source));\n+\t  return 1;\n+\t}\n+      if (remainder == 0xffffffff)\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t      gen_rtx (NOT, mode, source)));\n+\t  return 1;\n+\t}\n+\n+      /* We don't know how to handle this yet below.  */\n+      abort ();\n+\n+    case MINUS:\n+      /* We treat MINUS as (val - source), since (source - val) is always\n+\t passed as (source + (-val)).  */\n+      if (remainder == 0)\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t      gen_rtx (NEG, mode, source)));\n+\t  return 1;\n+\t}\n+      if (const_ok_for_arm (val))\n+\t{\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target, \n+\t\t\t      gen_rtx (MINUS, mode, GEN_INT (val), source)));\n+\t  return 1;\n+\t}\n+      can_negate = 1;\n+\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* If we can do it in one insn get out quickly */\n+  if (const_ok_for_arm (val)\n+      || (can_negate_initial && const_ok_for_arm (-val))\n+      || (can_invert && const_ok_for_arm (~val)))\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t  (source ? gen_rtx (code, mode, source,\n+\t\t\t\t\t     GEN_INT (val)) : GEN_INT (val))));\n+      return 1;\n+    }\n+\n+\n+  /* Calculate a few attributes that may be useful for specific\n+     optimizations. */\n+\n+  for (i = 31; i >= 0; i--)\n+    {\n+      if ((remainder & (1 << i)) == 0)\n+\tclear_sign_bit_copies++;\n+      else\n+\tbreak;\n+    }\n+\n+  for (i = 31; i >= 0; i--)\n+    {\n+      if ((remainder & (1 << i)) != 0)\n+\tset_sign_bit_copies++;\n+      else\n+\tbreak;\n+    }\n+\n+  for (i = 0; i <= 31; i++)\n+    {\n+      if ((remainder & (1 << i)) == 0)\n+\tclear_zero_bit_copies++;\n+      else\n+\tbreak;\n+    }\n+\n+  for (i = 0; i <= 31; i++)\n+    {\n+      if ((remainder & (1 << i)) != 0)\n+\tset_zero_bit_copies++;\n+      else\n+\tbreak;\n+    }\n+\n+  switch (code)\n+    {\n+    case SET:\n+      /* See if we can do this by sign_extending a constant that is known\n+\t to be negative.  This is a good, way of doing it, since the shift\n+\t may well merge into a subsequent insn.  */\n+      if (set_sign_bit_copies > 1)\n+\t{\n+\t  if (const_ok_for_arm\n+\t      (temp1 = ARM_SIGN_EXTEND (remainder \n+\t\t\t\t\t<< (set_sign_bit_copies - 1))))\n+\t    {\n+\t      new_src = subtargets ? gen_reg_rtx (mode) : target;\n+\t      emit_insn (gen_rtx (SET, VOIDmode, new_src, GEN_INT (temp1)));\n+\t      emit_insn (gen_ashrsi3 (target, new_src, \n+\t\t\t\t      GEN_INT (set_sign_bit_copies - 1)));\n+\t      return 2;\n+\t    }\n+\t  /* For an inverted constant, we will need to set the low bits,\n+\t     these will be shifted out of harm's way.  */\n+\t  temp1 |= (1 << (set_sign_bit_copies - 1)) - 1;\n+\t  if (const_ok_for_arm (~temp1))\n+\t    {\n+\t      new_src = subtargets ? gen_reg_rtx (mode) : target;\n+\t      emit_insn (gen_rtx (SET, VOIDmode, new_src, GEN_INT (temp1)));\n+\t      emit_insn (gen_ashrsi3 (target, new_src, \n+\t\t\t\t      GEN_INT (set_sign_bit_copies - 1)));\n+\t      return 2;\n+\t    }\n+\t}\n+\n+      /* See if we can generate this by setting the bottom (or the top)\n+\t 16 bits, and then shifting these into the other half of the\n+\t word.  We only look for the simplest cases, to do more would cost\n+\t too much.  Be careful, however, not to generate this when the\n+\t alternative would take fewer insns.  */\n+      if (val & 0xffff0000)\n+\t{\n+\t  temp1 = remainder & 0xffff0000;\n+\t  temp2 = remainder & 0x0000ffff;\n+\n+\t  /* Overlaps outside this range are best done using other methods. */\n+\t  for (i = 9; i < 24; i++)\n+\t    {\n+\t      if ((((temp2 | (temp2 << i)) & 0xffffffff) == remainder)\n+\t\t  && ! const_ok_for_arm (temp2))\n+\t\t{\n+\t\t  insns\n+\t\t    = arm_split_constant (code, mode, temp2,\n+\t\t\t\t\t  (new_src\n+\t\t\t\t\t   = subtargets ? gen_reg_rtx (mode)\n+\t\t\t\t\t   : target),\n+\t\t\t\t\t  source, subtargets);\n+\t\t  source = new_src;\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t\t      gen_rtx (IOR, mode,\n+\t\t\t\t\t       gen_rtx (ASHIFT, mode, source,\n+\t\t\t\t\t\t\tGEN_INT (i)),\n+\t\t\t\t\t       source)));\n+\t\t  return insns + 1;\n+\t\t}\n+\t    }\n+\n+\t  /* Don't duplicate cases already considered. */\n+\t  for (i = 17; i < 24; i++)\n+\t    {\n+\t      if (((temp1 | (temp1 >> i)) == remainder)\n+\t\t  && ! const_ok_for_arm (temp1))\n+\t\t{\n+\t\t  insns\n+\t\t    = arm_split_constant (code, mode, temp1,\n+\t\t\t\t\t  (new_src\n+\t\t\t\t\t   = subtargets ? gen_reg_rtx (mode)\n+\t\t\t\t\t   : target),\n+\t\t\t\t\t  source, subtargets);\n+\t\t  source = new_src;\n+\t\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t\t      gen_rtx (IOR, mode,\n+\t\t\t\t\t       gen_rtx (LSHIFTRT, mode, source,\n+\t\t\t\t\t\t\tGEN_INT (i)),\n+\t\t\t\t\t       source)));\n+\t\t  return insns + 1;\n+\t\t}\n+\t    }\n+\t}\n+      break;\n+\n+    case IOR:\n+    case XOR:\n+      /* If we have IOR or XOR, and the inverse of the constant can be loaded\n+\t in a single instruction, and we can find a temporary to put it in,\n+\t then this can be done in two instructions instead of 3-4.  */\n+      if (subtargets\n+\t  || (reload_completed && ! reg_mentioned_p (target, source)))\n+\t{\n+\t  if (const_ok_for_arm (ARM_SIGN_EXTEND (~ val)))\n+\t    {\n+\t      rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n+\n+\t      emit_insn (gen_rtx (SET, VOIDmode, sub,\n+\t\t\t\t  GEN_INT (ARM_SIGN_EXTEND (~ val))));\n+\t      emit_insn (gen_rtx (SET, VOIDmode, target, \n+\t\t\t\t  gen_rtx (code, mode, source, sub)));\n+\t      return 2;\n+\t    }\n+\t}\n+\n+      if (code == XOR)\n+\tbreak;\n+\n+      if (set_sign_bit_copies > 8\n+\t  && (val & (-1 << (32 - set_sign_bit_copies))) == val)\n+\t{\n+\t  rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n+\t  rtx shift = GEN_INT (set_sign_bit_copies);\n+\n+\t  emit_insn (gen_rtx (SET, VOIDmode, sub,\n+\t\t\t      gen_rtx (NOT, mode, \n+\t\t\t\t       gen_rtx (ASHIFT, mode, source, \n+\t\t\t\t\t\tshift))));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t      gen_rtx (NOT, mode,\n+\t\t\t\t       gen_rtx (LSHIFTRT, mode, sub,\n+\t\t\t\t\t\tshift))));\n+\t  return 2;\n+\t}\n+\n+      if (set_zero_bit_copies > 8\n+\t  && (remainder & ((1 << set_zero_bit_copies) - 1)) == remainder)\n+\t{\n+\t  rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n+\t  rtx shift = GEN_INT (set_zero_bit_copies);\n+\t  \n+\t  emit_insn (gen_rtx (SET, VOIDmode, sub,\n+\t\t\t      gen_rtx (NOT, mode,\n+\t\t\t\t       gen_rtx (LSHIFTRT, mode, source,\n+\t\t\t\t\t\tshift))));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t      gen_rtx (NOT, mode,\n+\t\t\t\t       gen_rtx (ASHIFT, mode, sub,\n+\t\t\t\t\t\tshift))));\n+\t  return 2;\n+\t}\n+\n+      if (const_ok_for_arm (temp1 = ARM_SIGN_EXTEND (~ val)))\n+\t{\n+\t  rtx sub = subtargets ? gen_reg_rtx (mode) : target;\n+\t  emit_insn (gen_rtx (SET, VOIDmode, sub,\n+\t\t\t      gen_rtx (NOT, mode, source)));\n+\t  source = sub;\n+\t  if (subtargets)\n+\t    sub = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx (SET, VOIDmode, sub,\n+\t\t\t      gen_rtx (AND, mode, source, GEN_INT (temp1))));\n+\t  emit_insn (gen_rtx (SET, VOIDmode, target,\n+\t\t\t      gen_rtx (NOT, mode, sub)));\n+\t  return 3;\n+\t}\n+      break;\n+\n+    case AND:\n+      /* See if two shifts will do 2 or more insn's worth of work.  */\n+      if (clear_sign_bit_copies >= 16 && clear_sign_bit_copies < 24)\n+\t{\n+\t  HOST_WIDE_INT shift_mask = ((0xffffffff \n+\t\t\t\t       << (32 - clear_sign_bit_copies))\n+\t\t\t\t      & 0xffffffff);\n+\t  rtx new_source;\n+\t  rtx shift = GEN_INT (clear_sign_bit_copies);\n+\n+\t  if ((remainder | shift_mask) != 0xffffffff)\n+\t    {\n+\t      new_source = subtargets ? gen_reg_rtx (mode) : target;\n+\t      insns = arm_split_constant (AND, mode, remainder | shift_mask,\n+\t\t\t\t\t  new_source, source, subtargets);\n+\t      source = new_source;\n+\t    }\n+\n+\t  new_source = subtargets ? gen_reg_rtx (mode) : target;\n+\t  emit_insn (gen_ashlsi3 (new_source, source, shift));\n+\t  emit_insn (gen_lshrsi3 (target, new_source, shift));\n+\t  return insns + 2;\n+\t}\n+\n+      if (clear_zero_bit_copies >= 16 && clear_zero_bit_copies < 24)\n+\t{\n+\t  HOST_WIDE_INT shift_mask = (1 << clear_zero_bit_copies) - 1;\n+\t  rtx new_source;\n+\t  rtx shift = GEN_INT (clear_zero_bit_copies);\n+\t  \n+\t  if ((remainder | shift_mask) != 0xffffffff)\n+\t    {\n+\t      new_source = subtargets ? gen_reg_rtx (mode) : target;\n+\t      insns = arm_split_constant (AND, mode, remainder | shift_mask,\n+\t\t\t\t\t  new_source, source, subtargets);\n+\t      source = new_source;\n+\t    }\n+\n+\t  new_source = subtargets ? gen_reg_rtx (mode) : target;\n+\t  emit_insn (gen_lshrsi3 (new_source, source, shift));\n+\t  emit_insn (gen_ashlsi3 (target, new_source, shift));\n+\t  return insns + 2;\n+\t}\n+\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = 0; i < 32; i++)\n+    if (remainder & (1 << i))\n+      num_bits_set++;\n+\n+  if (code == AND || (can_invert && num_bits_set > 16))\n+    remainder = (~remainder) & 0xffffffff;\n+  else if (code == PLUS && num_bits_set > 16)\n+    remainder = (-remainder) & 0xffffffff;\n+  else\n+    {\n+      can_invert = 0;\n+      can_negate = 0;\n+    }\n+\n+  /* Now try and find a way of doing the job in either two or three\n+     instructions.\n+     We start by looking for the largest block of zeros that are aligned on\n+     a 2-bit boundary, we then fill up the temps, wrapping around to the\n+     top of the word when we drop off the bottom.\n+     In the worst case this code should produce no more than four insns. */\n+  {\n+    int best_start = 0;\n+    int best_consecutive_zeros = 0;\n+\n+    for (i = 0; i < 32; i += 2)\n+      {\n+\tint consecutive_zeros = 0;\n+\n+\tif (! (remainder & (3 << i)))\n+\t  {\n+\t    while ((i < 32) && ! (remainder & (3 << i)))\n+\t      {\n+\t\tconsecutive_zeros += 2;\n+\t\ti += 2;\n+\t      }\n+\t    if (consecutive_zeros > best_consecutive_zeros)\n+\t      {\n+\t\tbest_consecutive_zeros = consecutive_zeros;\n+\t\tbest_start = i - consecutive_zeros;\n+\t      }\n+\t    i -= 2;\n+\t  }\n+      }\n+\n+    /* Now start emitting the insns, starting with the one with the highest\n+       bit set: we do this so that the smallest number will be emitted last;\n+       this is more likely to be combinable with addressing insns. */\n+    i = best_start;\n+    do\n+      {\n+\tint end;\n+\n+\tif (i <= 0)\n+\t  i += 32;\n+\tif (remainder & (3 << (i - 2)))\n+\t  {\n+\t    end = i - 8;\n+\t    if (end < 0)\n+\t      end += 32;\n+\t    temp1 = remainder & ((0x0ff << end)\n+\t\t\t\t | ((i < end) ? (0xff >> (32 - end)) : 0));\n+\t    remainder &= ~temp1;\n+\n+\t    if (code == SET)\n+\t      {\n+\t\temit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t    new_src = (subtargets ? gen_reg_rtx (mode)\n+\t\t\t\t\t       : target),\n+\t\t\t\t    GEN_INT (can_invert ? ~temp1 : temp1)));\n+\t\tcan_invert = 0;\n+\t\tcode = PLUS;\n+\t      }\n+\t    else if (code == MINUS)\n+\t      {\n+\t\temit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t    new_src = (subtargets ? gen_reg_rtx (mode)\n+\t\t\t\t\t       : target),\n+\t\t\t\t    gen_rtx (code, mode, GEN_INT (temp1),\n+\t\t\t\t\t     source)));\n+\t\tcode = PLUS;\n+\t      }\n+\t    else\n+\t      {\n+\t\temit_insn (gen_rtx (SET, VOIDmode,\n+\t\t\t\t    new_src = remainder ? (subtargets\n+\t\t\t\t\t\t\t   ? gen_reg_rtx (mode)\n+\t\t\t\t\t\t\t   : target) : target,\n+\t\t\t\t    gen_rtx (code, mode, source,\n+\t\t\t\t\t     GEN_INT (can_invert ? ~temp1\n+\t\t\t\t\t\t      : (can_negate\n+\t\t\t\t\t\t\t ? -temp1 : temp1)))));\n+\t      }\n+\n+\t    insns++;\n+\t    source = new_src;\n+\t    i -= 6;\n+\t  }\n+\ti -= 2;\n+      } while (remainder);\n+  }\n+  return insns;\n+}\n+\n+#define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\\n+  (GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == SUBREG && GET_CODE (SUBREG_REG (X)) == REG))\n+\n+#define REG_OR_SUBREG_RTX(X)\t\t\t\\\n+   (GET_CODE (X) == REG ? (X) : SUBREG_REG (X))\n+\n+#define ARM_FRAME_RTX(X)\t\t\t\t\\\n+  ((X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n+   || (X) == arg_pointer_rtx)\n+\n+int\n+arm_rtx_costs (x, code, outer_code)\n+     rtx x;\n+     enum rtx_code code, outer_code;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  enum rtx_code subcode;\n+  int extra_cost;\n+\n+  switch (code)\n+    {\n+    case MEM:\n+      /* Memory costs quite a lot for the first word, but subsequent words\n+\t load at the equivalent of a single insn each.  */\n+      return (10 + 4 * ((GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD)\n+\t      + (CONSTANT_POOL_ADDRESS_P (x) ? 4 : 0));\n+\n+    case DIV:\n+    case MOD:\n+      return 100;\n+\n+    case ROTATE:\n+      if (mode == SImode && GET_CODE (XEXP (x, 1)) == REG)\n+\treturn 4;\n+      /* Fall through */\n+    case ROTATERT:\n+      if (mode != SImode)\n+\treturn 8;\n+      /* Fall through */\n+    case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n+      if (mode == DImode)\n+\treturn (8 + (GET_CODE (XEXP (x, 1)) == CONST_INT ? 0 : 8)\n+\t\t+ ((GET_CODE (XEXP (x, 0)) == REG \n+\t\t    || (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t\t\t&& GET_CODE (SUBREG_REG (XEXP (x, 0))) == REG))\n+\t\t   ? 0 : 8));\n+      return (1 + ((GET_CODE (XEXP (x, 0)) == REG\n+\t\t    || (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t\t\t&& GET_CODE (SUBREG_REG (XEXP (x, 0))) == REG))\n+\t\t   ? 0 : 4)\n+\t      + ((GET_CODE (XEXP (x, 1)) == REG\n+\t\t  || (GET_CODE (XEXP (x, 1)) == SUBREG\n+\t\t      && GET_CODE (SUBREG_REG (XEXP (x, 1))) == REG)\n+\t\t  || (GET_CODE (XEXP (x, 1)) == CONST_INT))\n+\t\t ? 0 : 4));\n+\n+    case MINUS:\n+      if (mode == DImode)\n+\treturn (4 + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 8)\n+\t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 0))\n+\t\t    || (GET_CODE (XEXP (x, 0)) == CONST_INT\n+\t\t       && const_ok_for_arm (INTVAL (XEXP (x, 0)))))\n+\t\t   ? 0 : 8));\n+\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\treturn (2 + ((REG_OR_SUBREG_REG (XEXP (x, 1))\n+\t\t      || (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n+\t\t\t  && const_double_rtx_ok_for_fpu (XEXP (x, 1))))\n+\t\t     ? 0 : 8)\n+\t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 0))\n+\t\t    || (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE\n+\t\t\t&& const_double_rtx_ok_for_fpu (XEXP (x, 0))))\n+\t\t   ? 0 : 8));\n+\n+      if (((GET_CODE (XEXP (x, 0)) == CONST_INT\n+\t    && const_ok_for_arm (INTVAL (XEXP (x, 0)))\n+\t    && REG_OR_SUBREG_REG (XEXP (x, 1))))\n+\t  || (((subcode = GET_CODE (XEXP (x, 1))) == ASHIFT\n+\t       || subcode == ASHIFTRT || subcode == LSHIFTRT\n+\t       || subcode == ROTATE || subcode == ROTATERT\n+\t       || (subcode == MULT\n+\t\t   && GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT\n+\t\t   && ((INTVAL (XEXP (XEXP (x, 1), 1)) &\n+\t\t\t(INTVAL (XEXP (XEXP (x, 1), 1)) - 1)) == 0)))\n+\t      && REG_OR_SUBREG_REG (XEXP (XEXP (x, 1), 0))\n+\t      && (REG_OR_SUBREG_REG (XEXP (XEXP (x, 1), 1))\n+\t\t  || GET_CODE (XEXP (XEXP (x, 1), 1)) == CONST_INT)\n+\t      && REG_OR_SUBREG_REG (XEXP (x, 0))))\n+\treturn 1;\n+      /* Fall through */\n+\n+    case PLUS: \n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\treturn (2 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 8)\n+\t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 1))\n+\t\t    || (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n+\t\t\t&& const_double_rtx_ok_for_fpu (XEXP (x, 1))))\n+\t\t   ? 0 : 8));\n+\n+      /* Fall through */\n+    case AND: case XOR: case IOR: \n+      extra_cost = 0;\n+\n+      /* Normally the frame registers will be spilt into reg+const during\n+\t reload, so it is a bad idea to combine them with other instructions,\n+\t since then they might not be moved outside of loops.  As a compromise\n+\t we allow integration with ops that have a constant as their second\n+\t operand.  */\n+      if ((REG_OR_SUBREG_REG (XEXP (x, 0))\n+\t   && ARM_FRAME_RTX (REG_OR_SUBREG_RTX (XEXP (x, 0)))\n+\t   && GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t  || (REG_OR_SUBREG_REG (XEXP (x, 0))\n+\t      && ARM_FRAME_RTX (REG_OR_SUBREG_RTX (XEXP (x, 0)))))\n+\textra_cost = 4;\n+\n+      if (mode == DImode)\n+\treturn (4 + extra_cost + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 8)\n+\t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 1))\n+\t\t    || (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t\t&& const_ok_for_op (INTVAL (XEXP (x, 1)), code, mode)))\n+\t\t   ? 0 : 8));\n+\n+      if (REG_OR_SUBREG_REG (XEXP (x, 0)))\n+\treturn (1 + (GET_CODE (XEXP (x, 1)) == CONST_INT ? 0 : extra_cost)\n+\t\t+ ((REG_OR_SUBREG_REG (XEXP (x, 1))\n+\t\t    || (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t\t&& const_ok_for_op (INTVAL (XEXP (x, 1)), code, mode)))\n+\t\t   ? 0 : 4));\n+\n+      else if (REG_OR_SUBREG_REG (XEXP (x, 1)))\n+\treturn (1 + extra_cost\n+\t\t+ ((((subcode = GET_CODE (XEXP (x, 0))) == ASHIFT\n+\t\t     || subcode == LSHIFTRT || subcode == ASHIFTRT\n+\t\t     || subcode == ROTATE || subcode == ROTATERT\n+\t\t     || (subcode == MULT\n+\t\t\t && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t\t\t && ((INTVAL (XEXP (XEXP (x, 0), 1)) &\n+\t\t\t      (INTVAL (XEXP (XEXP (x, 0), 1)) - 1)) == 0))\n+\t\t    && (REG_OR_SUBREG_REG (XEXP (XEXP (x, 0), 0)))\n+\t\t    && ((REG_OR_SUBREG_REG (XEXP (XEXP (x, 0), 1)))\n+\t\t\t|| GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+\t\t   ? 0 : 4));\n+\n+      return 8;\n+\n+    case MULT:\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  || mode == DImode)\n+\treturn 30;\n+\n+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT i = INTVAL (XEXP (x, 1)) & 0xffffffff;\n+\t  int add_cost = const_ok_for_arm (i) ? 4 : 8;\n+\t  int j;\n+\t  \n+\t  /* This will need adjusting for ARM's with fast multiplies */\n+\t  for (j = 0; i && j < 32; j += 2)\n+\t    {\n+\t      i &= ~(3 << j);\n+\t      add_cost += 2;\n+\t    }\n+\n+\t  return add_cost;\n+\t}\n+\n+      return (30 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n+\t      + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4));\n+\n+    case NEG:\n+      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\treturn 4 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 6);\n+      /* Fall through */\n+    case NOT:\n+      if (mode == DImode)\n+\treturn 4 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4);\n+\n+      return 1 + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4);\n+\n+    case IF_THEN_ELSE:\n+      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)\n+\treturn 14;\n+      return 2;\n+\n+    case COMPARE:\n+      return 1;\n+\n+    case ABS:\n+      return 4 + (mode == DImode ? 4 : 0);\n+\n+    case SIGN_EXTEND:\n+      if (GET_MODE (XEXP (x, 0)) == QImode)\n+\treturn (4 + (mode == DImode ? 4 : 0)\n+\t\t+ (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+      /* Fall through */\n+    case ZERO_EXTEND:\n+      switch (GET_MODE (XEXP (x, 0)))\n+\t{\n+\tcase QImode:\n+\t  return (1 + (mode == DImode ? 4 : 0)\n+\t\t  + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+\n+\tcase HImode:\n+\t  return (4 + (mode == DImode ? 4 : 0)\n+\t\t  + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+\n+\tcase SImode:\n+\t  return (1 + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n+\t}\n+      abort ();\n+\n+    default:\n+      return 99;\n+    }\n+}\n+     \n /* This code has been fixed for cross compilation. */\n \n static int fpa_consts_inited = 0;\n@@ -249,6 +982,29 @@ s_register_operand (op, mode)\n \t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n }\n \n+/* Only accept reg, subreg(reg), const_int.  */\n+\n+int\n+reg_or_int_operand (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return 1;\n+\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+}\n+\n /* Return 1 if OP is an item in memory, given that we are in reload.  */\n \n int\n@@ -445,7 +1201,8 @@ shift_operator (x, mode)\n       if (code == MULT)\n \treturn power_of_two_operand (XEXP (x, 1));\n \n-      return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT);\n+      return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT\n+\t      || code == ROTATERT);\n     }\n }\n \n@@ -684,6 +1441,21 @@ store_multiple_operation (op, mode)\n \n   return 1;\n }\n+\n+int\n+multi_register_push (op, mode)\n+  rtx op;\n+  enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != PARALLEL\n+      || (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+      || (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC)\n+      || (XINT (SET_SRC (XVECEXP (op, 0, 0)), 1) != 2))\n+    return 0;\n+\n+  return 1;\n+}\n+\n \f\n /* Routines for use with attributes */\n \n@@ -1398,9 +2170,8 @@ shift_op (op, amountp)\n      rtx op;\n      HOST_WIDE_INT *amountp;\n {\n-  int min_shift = 0;\n-  int max_shift = 31;\n   char *mnem;\n+  enum rtx_code code = GET_CODE (op);\n \n   if (GET_CODE (XEXP (op, 1)) == REG || GET_CODE (XEXP (op, 1)) == SUBREG)\n     *amountp = -1;\n@@ -1409,28 +2180,27 @@ shift_op (op, amountp)\n   else\n     abort ();\n \n-  switch (GET_CODE (op))\n+  switch (code)\n     {\n     case ASHIFT:\n       mnem = \"asl\";\n       break;\n \n     case ASHIFTRT:\n       mnem = \"asr\";\n-      max_shift = 32;\n       break;\n \n     case LSHIFTRT:\n       mnem = \"lsr\";\n-      max_shift = 32;\n       break;\n \n     case ROTATERT:\n       mnem = \"ror\";\n-      max_shift = 31;\n       break;\n \n     case MULT:\n+      /* We never have to worry about the amount being other than a\n+\t power of 2, since this case can never be reloaded from a reg.  */\n       if (*amountp != -1)\n \t*amountp = int_log2 (*amountp);\n       else\n@@ -1441,9 +2211,29 @@ shift_op (op, amountp)\n       abort ();\n     }\n \n-  if (*amountp != -1\n-      && (*amountp < min_shift || *amountp > max_shift))\n-    abort ();\n+  if (*amountp != -1)\n+    {\n+      /* This is not 100% correct, but follows from the desire to merge\n+\t multiplication by a power of 2 with the recognizer for a\n+\t shift.  >=32 is not a valid shift for \"asl\", so we must try and\n+\t output a shift that produces the correct arithmetical result.\n+\t Using lsr #32 is idendical except for the fact that the carry bit\n+\t is not set correctly if we set the flags; but we never use the \n+\t carry bit from such an operation, so we can ignore that.  */\n+      if (code == ROTATERT)\n+\t*amountp &= 31;\t\t/* Rotate is just modulo 32 */\n+      else if (*amountp != (*amountp & 31))\n+\t{\n+\t  if (code == ASHIFT)\n+\t    mnem = \"lsr\";\n+\t  *amountp = 32;\n+\t}\n+\n+      /* Shifts of 0 are no-ops.  */\n+      if (*amountp == 0)\n+\treturn NULL;\n+    }\t  \n+\n   return mnem;\n }\n \n@@ -1666,7 +2456,26 @@ output_return_instruction (operand, really_return)\n {\n   char instr[100];\n   int reg, live_regs = 0;\n+  int volatile_func = (optimize > 0 \n+\t\t       && TREE_THIS_VOLATILE (current_function_decl));\n+\n+  return_used_this_function = 1;\n \n+  if (volatile_func)\n+    {\n+      rtx ops[2];\n+      /* If this function was declared non-returning, and we have found a tail \n+\t call, then we have to trust that the called function won't return. */\n+      if (! really_return)\n+\treturn \"\";\n+\n+      /* Otherwise, trap an attempted return by aborting. */\n+      ops[0] = operand;\n+      ops[1] = gen_rtx (SYMBOL_REF, Pmode, \"abort\");\n+      output_asm_insn (\"bl%d0\\t%a1\", ops);\n+      return \"\";\n+    }\n+      \n   if (current_function_calls_alloca && ! really_return)\n     abort();\n     \n@@ -1725,51 +2534,22 @@ output_return_instruction (operand, really_return)\n       output_asm_insn (instr, &operand);\n     }\n \n-  return_used_this_function = 1;\n   return \"\";\n }\n \n+int\n+arm_volatile_func ()\n+{\n+  return (optimize > 0 && TREE_THIS_VOLATILE (current_function_decl));\n+}\n+\n /* Return the size of the prologue.  It's not too bad if we slightly \n    over-estimate.  */\n \n static int\n get_prologue_size ()\n {\n-  int amount = 0;\n-  int regno;\n-\n-  /* Until we know which registers are really used return the maximum.  */\n-  if (! reload_completed)\n-    return 24;\n-\n-  /* Look for integer regs that have to be saved. */\n-  for (regno = 0; regno < 15; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n-      {\n-\tamount = 4;\n-\tbreak;\n-      }\n-\n-  /* Clobbering lr when none of the other regs have been saved also requires\n-     a save.  */\n-  if (regs_ever_live[14])\n-    amount = 4;\n-\n-  /* If we need to push a stack frame then there is an extra instruction to\n-     preserve the current value of the stack pointer. */\n-  if (frame_pointer_needed)\n-    amount = 8;\n-\n-  /* Now look for floating-point regs that need saving.  We need an \n-     instruction per register.  */\n-  for (regno = 16; regno < 24; regno++)\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\n-      amount += 4;\n-\n-  if (current_function_anonymous_args && current_function_pretend_args_size)\n-    amount += 4;\n-\n-  return amount;\n+  return profile_flag ? 12 : 0;\n }\n \n /* The amount of stack adjustment that happens here, in output_return and in\n@@ -1788,6 +2568,8 @@ output_func_prologue (f, frame_size)\n {\n   int reg, live_regs_mask = 0;\n   rtx operands[3];\n+  int volatile_func = (optimize > 0\n+\t\t       && TREE_THIS_VOLATILE (current_function_decl));\n \n   /* Nonzero if we must stuff some register arguments onto the stack as if\n      they were passed there.  */\n@@ -1806,6 +2588,9 @@ output_func_prologue (f, frame_size)\n \t   ARM_COMMENT_CHAR, frame_pointer_needed,\n \t   current_function_anonymous_args);\n \n+  if (volatile_func)\n+    fprintf (f, \"\\t%c Volatile function.\\n\", ARM_COMMENT_CHAR);\n+\n   if (current_function_anonymous_args && current_function_pretend_args_size)\n     store_arg_regs = 1;\n \n@@ -1814,47 +2599,16 @@ output_func_prologue (f, frame_size)\n       live_regs_mask |= (1 << reg);\n \n   if (frame_pointer_needed)\n-    {\n-      live_regs_mask |= 0xD800;\n-      fprintf (f, \"\\tmov\\t%sip, %ssp\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX);\n-    }\n+    live_regs_mask |= 0xD800;\n   else if (regs_ever_live[14])\n     {\n       if (! current_function_args_size\n \t  && ! function_really_clobbers_lr (get_insns ()))\n-\t{\n-\t  fprintf (f,\"\\t%c I don't think this function clobbers lr\\n\",\n-\t\t   ARM_COMMENT_CHAR);\n-\t  lr_save_eliminated = 1;\n-        }\n+\tlr_save_eliminated = 1;\n       else\n         live_regs_mask |= 0x4000;\n     }\n \n-  /* If CURRENT_FUNCTION_PRETEND_ARGS_SIZE, adjust the stack pointer to make\n-     room.  If also STORE_ARG_REGS store the argument registers involved in\n-     the created slot (this is for stdarg and varargs).  */\n-  if (current_function_pretend_args_size)\n-    {\n-      if (store_arg_regs)\n-\t{\n-\t  int arg_size, mask = 0;\n-\n-\t  assert (current_function_pretend_args_size <= 16);\n-\t  for (reg = 3, arg_size = current_function_pretend_args_size;\n-\t       arg_size > 0; reg--, arg_size -= 4)\n-\t    mask |= (1 << reg);\n-\t  print_multi_reg (f, \"stmfd\\t%ssp!\", mask, FALSE);\n-\t}\n-      else\n-\t{\n-\t  operands[0] = operands[1] = stack_pointer_rtx;\n-\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t -current_function_pretend_args_size);\n-\t  output_add_immediate (operands);\n-\t}\n-    }\n-\n   if (live_regs_mask)\n     {\n       /* if a di mode load/store multiple is used, and the base register\n@@ -1865,31 +2619,11 @@ output_func_prologue (f, frame_size)\n       live_regs_mask |= 0x4000;\n       lr_save_eliminated = 0;\n \n-      /* Now push all the call-saved regs onto the stack */\n-      print_multi_reg (f, \"stmfd\\t%ssp!\", live_regs_mask, FALSE);\n     }\n \n-  for (reg = 23; reg > 15; reg--)\n-    if (regs_ever_live[reg] && !call_used_regs[reg])\n-      fprintf (f, \"\\tstfe\\t%s%s, [%ssp, #-12]!\\n\", ARM_REG_PREFIX,\n-\t       reg_names[reg], ARM_REG_PREFIX);\n-\n-  if (frame_pointer_needed)\n-    {\n-      /* Make `fp' point to saved value of `pc'. */\n-\n-      operands[0] = gen_rtx (REG, SImode, HARD_FRAME_POINTER_REGNUM);\n-      operands[1] = gen_rtx (REG, SImode, 12);\n-      operands[2] = GEN_INT ( - (4 + current_function_pretend_args_size));\n-      output_add_immediate (operands);\n-    }\n-\n-  if (frame_size)\n-    {\n-      operands[0] = operands[1] = stack_pointer_rtx;\n-      operands[2] = GEN_INT (-frame_size);\n-      output_add_immediate (operands);\n-    }\n+  if (lr_save_eliminated)\n+    fprintf (f,\"\\t%c I don't think this function clobbers lr\\n\",\n+\t     ARM_COMMENT_CHAR);\n }\n \n \n@@ -1902,6 +2636,8 @@ output_func_epilogue (f, frame_size)\n   /* If we need this then it will always be at lesat this much */\n   int floats_offset = 24;\n   rtx operands[3];\n+  int volatile_func = (optimize > 0\n+\t\t       && TREE_THIS_VOLATILE (current_function_decl));\n \n   if (use_return_insn() && return_used_this_function)\n     {\n@@ -1912,6 +2648,15 @@ output_func_epilogue (f, frame_size)\n       goto epilogue_done;\n     }\n \n+  /* A volatile function should never return.  Call abort.  */\n+  if (volatile_func)\n+    {\n+      rtx op = gen_rtx (SYMBOL_REF, Pmode, \"abort\");\n+      output_asm_insn (\"bl\\t%a0\", &op);\n+      code_size = 4;\n+      goto epilogue_done;\n+    }\n+\n   for (reg = 0; reg <= 10; reg++)\n     if (regs_ever_live[reg] && ! call_used_regs[reg])\n       {\n@@ -1991,6 +2736,128 @@ output_func_epilogue (f, frame_size)\n \n   current_function_anonymous_args = 0;\n }\n+\n+static void\n+emit_multi_reg_push (mask)\n+     int mask;\n+{\n+  int num_regs = 0;\n+  int i, j;\n+  rtx par;\n+\n+  for (i = 0; i < 16; i++)\n+    if (mask & (1 << i))\n+      num_regs++;\n+\n+  if (num_regs == 0 || num_regs > 16)\n+    abort ();\n+\n+  par = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (num_regs));\n+\n+  for (i = 0; i < 16; i++)\n+    {\n+      if (mask & (1 << i))\n+\t{\n+\t  XVECEXP (par, 0, 0)\n+\t    = gen_rtx (SET, VOIDmode, gen_rtx (MEM, BLKmode,\n+\t\t\t\t\t       gen_rtx (PRE_DEC, BLKmode,\n+\t\t\t\t\t\t\tstack_pointer_rtx)),\n+\t\t       gen_rtx (UNSPEC, BLKmode,\n+\t\t\t\tgen_rtvec (1, gen_rtx (REG, SImode, i)),\n+\t\t\t\t2));\n+\t  break;\n+\t}\n+    }\n+\n+  for (j = 1, i++; j < num_regs; i++)\n+    {\n+      if (mask & (1 << i))\n+\t{\n+\t  XVECEXP (par, 0, j)\n+\t    = gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, i));\n+\t  j++;\n+\t}\n+    }\n+  emit_insn (par);\n+}\n+\n+void\n+arm_expand_prologue ()\n+{\n+  int reg;\n+  rtx amount = GEN_INT (- get_frame_size ());\n+  rtx push_insn;\n+  int num_regs;\n+  int live_regs_mask = 0;\n+  int store_arg_regs = 0;\n+  int volatile_func = (optimize > 0\n+\t\t       && TREE_THIS_VOLATILE (current_function_decl));\n+\n+  if (current_function_anonymous_args && current_function_pretend_args_size)\n+    store_arg_regs = 1;\n+\n+  if (! volatile_func)\n+    for (reg = 0; reg <= 10; reg++)\n+      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\tlive_regs_mask |= 1 << reg;\n+\n+  if (! volatile_func && regs_ever_live[14])\n+    live_regs_mask |= 0x4000;\n+\n+  if (frame_pointer_needed)\n+    {\n+      live_regs_mask |= 0xD800;\n+      emit_insn (gen_movsi (gen_rtx (REG, SImode, 12),\n+\t\t\t    stack_pointer_rtx));\n+    }\n+\n+  if (current_function_pretend_args_size)\n+    {\n+      if (store_arg_regs)\n+\temit_multi_reg_push ((0xf0 >> (current_function_pretend_args_size / 4))\n+\t\t\t     & 0xf);\n+      else\n+\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, \n+\t\t\t       GEN_INT (-current_function_pretend_args_size)));\n+    }\n+\n+  if (live_regs_mask)\n+    {\n+      /* If we have to push any regs, then we must push lr as well, or\n+\t we won't get a propper return.  */\n+      live_regs_mask |= 0x4000;\n+      emit_multi_reg_push (live_regs_mask);\n+    }\n+      \n+  /* For now the integer regs are still pushed in output_func_epilogue ().  */\n+\n+  if (! volatile_func)\n+    for (reg = 23; reg > 15; reg--)\n+      if (regs_ever_live[reg] && ! call_used_regs[reg])\n+\temit_insn (gen_rtx (SET, VOIDmode, \n+\t\t\t    gen_rtx (MEM, XFmode, \n+\t\t\t\t     gen_rtx (PRE_DEC, XFmode,\n+\t\t\t\t\t      stack_pointer_rtx)),\n+\t\t\t    gen_rtx (REG, XFmode, reg)));\n+\n+  if (frame_pointer_needed)\n+    emit_insn (gen_addsi3 (hard_frame_pointer_rtx, gen_rtx (REG, SImode, 12),\n+\t\t\t   (GEN_INT\n+\t\t\t    (-(4 + current_function_pretend_args_size)))));\n+\n+  if (amount != const0_rtx)\n+    {\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, amount));\n+      emit_insn (gen_rtx (CLOBBER, VOIDmode, \n+\t\t\t  gen_rtx (MEM, BLKmode, stack_pointer_rtx)));\n+    }\n+\n+  /* If we are profiling, make sure no instructions are scheduled before\n+     the call to mcount.  */\n+  if (profile_flag || profile_block_flag)\n+    emit_insn (gen_blockage ());\n+}\n+  \n \f\n /* If CODE is 'd', then the X is a condition operand and the instruction\n    should only be executed if the condition is true.\n@@ -2063,18 +2930,22 @@ arm_print_operand (stream, x, code)\n     case 'S':\n       {\n \tHOST_WIDE_INT val;\n+\tchar *shift = shift_op (x, &val);\n \n-\tfprintf (stream, \"%s \", shift_op (x, &val));\n-\tif (val == -1)\n-\t  arm_print_operand (stream, XEXP (x, 1), 0);\n-\telse\n-\t  fprintf (stream,\n+\tif (shift)\n+\t  {\n+\t    fprintf (stream, \", %s \", shift_op (x, &val));\n+\t    if (val == -1)\n+\t      arm_print_operand (stream, XEXP (x, 1), 0);\n+\t    else\n+\t      fprintf (stream,\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t   \"#%d\",\n+\t\t       \"#%d\",\n #else\n-\t\t   \"#%ld\",\n+\t\t       \"#%ld\",\n #endif\n-\t\t   val);\n+\t\t       val);\n+\t  }\n       }\n       return;\n "}]}