{"sha": "ffe2e220bdb8fee858045b645601923656864cc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZlMmUyMjBiZGI4ZmVlODU4MDQ1YjY0NTYwMTkyMzY1Njg2NGNjNQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2004-09-25T22:21:51Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2004-09-25T22:21:51Z"}, "message": "[multiple changes]\n\n2004-09-25  Mark Wielaard  <mark@klomp.org>\n\n        * Makefile.am (core_java_source_files): Add VMTimeZone.java.\n        (nat_source_files): Rename natTimeZone.cc to natVMTimeZone.cc.\n        * Makefile.in: Regenerated.\n\n        * gcj/javaprims.h: Regenerated.\n\n        * java/util/TimeZone.java (defaultZone): Use VMTimeZone.\n        (getDefaultTimeZone): Make package private. Check that GMToffset\n        contains at least one digit.\n        (getDefaultTimeZoneId, readTimeZoneFile, readtzFile): (Re)Moved to\n        VMTimeZone.\n        * util/VMTimeZone.java: New file with above methods.\n\n        * java/util/natTimeZone.cc: Removed (renamed).\n        * java/util/natVMTimeZone.cc: Added (renamed).\n\n2004-09-25  Jeroen Frijters  <jeroen@frijters.net>\n\n        * java/util/TimeZone.java\n        (getDefaultTimeZone): Fixed test to distinguish between hours and\n        minutes in specified timezone.\n\nFrom-SVN: r88112", "tree": {"sha": "779a74ff4399dbdd698b3bf251c09830159ad055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/779a74ff4399dbdd698b3bf251c09830159ad055"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffe2e220bdb8fee858045b645601923656864cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe2e220bdb8fee858045b645601923656864cc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffe2e220bdb8fee858045b645601923656864cc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffe2e220bdb8fee858045b645601923656864cc5/comments", "author": null, "committer": null, "parents": [{"sha": "bfe0d06bba399fa140d681ffb1b2f3e58d6a838c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe0d06bba399fa140d681ffb1b2f3e58d6a838c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe0d06bba399fa140d681ffb1b2f3e58d6a838c"}], "stats": {"total": 698, "additions": 404, "deletions": 294}, "files": [{"sha": "4e1c6879907555aeff54b52e6c2b5b36d0b5672d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -1,3 +1,27 @@\n+2004-09-25  Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.am (core_java_source_files): Add VMTimeZone.java.\n+\t(nat_source_files): Rename natTimeZone.cc to natVMTimeZone.cc.\n+\t* Makefile.in: Regenerated.\n+\n+\t* gcj/javaprims.h: Regenerated.\n+\n+\t* java/util/TimeZone.java (defaultZone): Use VMTimeZone.\n+\t(getDefaultTimeZone): Make package private. Check that GMToffset\n+\tcontains at least one digit.\n+\t(getDefaultTimeZoneId, readTimeZoneFile, readtzFile): (Re)Moved to\n+\tVMTimeZone.\n+\t* util/VMTimeZone.java: New file with above methods.\n+\n+\t* java/util/natTimeZone.cc: Removed (renamed).\n+\t* java/util/natVMTimeZone.cc: Added (renamed).\n+\n+2004-09-25  Jeroen Frijters  <jeroen@frijters.net>\n+\n+\t* java/util/TimeZone.java\n+\t(getDefaultTimeZone): Fixed test to distinguish between hours and\n+\tminutes in specified timezone.\n+\n 2004-09-25  Jeroen Frijters  <jeroen@frijters.net>\n \n \t* java/lang/reflect/Proxy.java (getPackage, ClassFactory): Fixed"}, {"sha": "543b48879f5922b8fc55a0482e3b8d3a689a18f4", "filename": "libjava/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -2424,6 +2424,7 @@ java/util/TreeMap.java \\\n java/util/TreeSet.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n+java/util/VMTimeZone.java\t\\\n java/util/WeakHashMap.java \\\n java/util/logging/ConsoleHandler.java \\\n java/util/logging/ErrorManager.java \\\n@@ -3191,7 +3192,7 @@ java/nio/channels/natChannels.cc \\\n java/nio/natDirectByteBufferImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natResourceBundle.cc \\\n-java/util/natTimeZone.cc \\\n+java/util/natVMTimeZone.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n "}, {"sha": "bd831fea3e598d591f0219783b868a20b952d2dd", "filename": "libjava/Makefile.in", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -410,7 +410,7 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tjava/lang/reflect/natProxy.cc java/net/natNetworkInterface.cc \\\n \tjava/net/natInetAddress.cc java/nio/channels/natChannels.cc \\\n \tjava/nio/natDirectByteBufferImpl.cc java/text/natCollator.cc \\\n-\tjava/util/natResourceBundle.cc java/util/natTimeZone.cc \\\n+\tjava/util/natResourceBundle.cc java/util/natVMTimeZone.cc \\\n \tjava/util/zip/natDeflater.cc java/util/zip/natInflater.cc \\\n \tjava/lang/dtoa.c java/lang/k_rem_pio2.c java/lang/s_tan.c \\\n \tjava/lang/e_acos.c java/lang/k_sin.c java/lang/strtod.c \\\n@@ -562,7 +562,7 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tjava/util/TimerTask.java java/util/TreeMap.java \\\n \tjava/util/TreeSet.java \\\n \tjava/util/TooManyListenersException.java java/util/Vector.java \\\n-\tjava/util/WeakHashMap.java \\\n+\tjava/util/VMTimeZone.java java/util/WeakHashMap.java \\\n \tjava/util/logging/ConsoleHandler.java \\\n \tjava/util/logging/ErrorManager.java \\\n \tjava/util/logging/FileHandler.java \\\n@@ -2299,7 +2299,7 @@ am__objects_6 = gnu/gcj/natCore.lo \\\n \tjava/lang/reflect/natProxy.lo java/net/natNetworkInterface.lo \\\n \tjava/net/natInetAddress.lo java/nio/channels/natChannels.lo \\\n \tjava/nio/natDirectByteBufferImpl.lo java/text/natCollator.lo \\\n-\tjava/util/natResourceBundle.lo java/util/natTimeZone.lo \\\n+\tjava/util/natResourceBundle.lo java/util/natVMTimeZone.lo \\\n \tjava/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n am__objects_7 = java/lang/dtoa.lo java/lang/k_rem_pio2.lo \\\n \tjava/lang/s_tan.lo java/lang/e_acos.lo java/lang/k_sin.lo \\\n@@ -2440,8 +2440,8 @@ am__objects_9 = java/lang/AbstractMethodError.lo \\\n \tjava/util/TimeZone.lo java/util/Timer.lo \\\n \tjava/util/TimerTask.lo java/util/TreeMap.lo \\\n \tjava/util/TreeSet.lo java/util/TooManyListenersException.lo \\\n-\tjava/util/Vector.lo java/util/WeakHashMap.lo \\\n-\tjava/util/logging/ConsoleHandler.lo \\\n+\tjava/util/Vector.lo java/util/VMTimeZone.lo \\\n+\tjava/util/WeakHashMap.lo java/util/logging/ConsoleHandler.lo \\\n \tjava/util/logging/ErrorManager.lo \\\n \tjava/util/logging/FileHandler.lo java/util/logging/Filter.lo \\\n \tjava/util/logging/Formatter.lo java/util/logging/Handler.lo \\\n@@ -6235,6 +6235,7 @@ java/util/TreeMap.java \\\n java/util/TreeSet.java \\\n java/util/TooManyListenersException.java \\\n java/util/Vector.java \\\n+java/util/VMTimeZone.java\t\\\n java/util/WeakHashMap.java \\\n java/util/logging/ConsoleHandler.java \\\n java/util/logging/ErrorManager.java \\\n@@ -6991,7 +6992,7 @@ java/nio/channels/natChannels.cc \\\n java/nio/natDirectByteBufferImpl.cc \\\n java/text/natCollator.cc \\\n java/util/natResourceBundle.cc \\\n-java/util/natTimeZone.cc \\\n+java/util/natVMTimeZone.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n@@ -8012,7 +8013,7 @@ java/util/$(DEPDIR)/$(am__dirstamp):\n \t@: > java/util/$(DEPDIR)/$(am__dirstamp)\n java/util/natResourceBundle.lo: java/util/$(am__dirstamp) \\\n \tjava/util/$(DEPDIR)/$(am__dirstamp)\n-java/util/natTimeZone.lo: java/util/$(am__dirstamp) \\\n+java/util/natVMTimeZone.lo: java/util/$(am__dirstamp) \\\n \tjava/util/$(DEPDIR)/$(am__dirstamp)\n java/util/zip/$(am__dirstamp):\n \t@$(mkdir_p) java/util/zip\n@@ -8536,6 +8537,8 @@ java/util/TooManyListenersException.lo: java/util/$(am__dirstamp) \\\n \tjava/util/$(DEPDIR)/$(am__dirstamp)\n java/util/Vector.lo: java/util/$(am__dirstamp) \\\n \tjava/util/$(DEPDIR)/$(am__dirstamp)\n+java/util/VMTimeZone.lo: java/util/$(am__dirstamp) \\\n+\tjava/util/$(DEPDIR)/$(am__dirstamp)\n java/util/WeakHashMap.lo: java/util/$(am__dirstamp) \\\n \tjava/util/$(DEPDIR)/$(am__dirstamp)\n java/util/logging/$(am__dirstamp):\n@@ -17139,6 +17142,8 @@ mostlyclean-compile:\n \t-rm -f java/util/TreeMap.lo\n \t-rm -f java/util/TreeSet.$(OBJEXT)\n \t-rm -f java/util/TreeSet.lo\n+\t-rm -f java/util/VMTimeZone.$(OBJEXT)\n+\t-rm -f java/util/VMTimeZone.lo\n \t-rm -f java/util/Vector.$(OBJEXT)\n \t-rm -f java/util/Vector.lo\n \t-rm -f java/util/WeakHashMap.$(OBJEXT)\n@@ -17191,8 +17196,8 @@ mostlyclean-compile:\n \t-rm -f java/util/logging/XMLFormatter.lo\n \t-rm -f java/util/natResourceBundle.$(OBJEXT)\n \t-rm -f java/util/natResourceBundle.lo\n-\t-rm -f java/util/natTimeZone.$(OBJEXT)\n-\t-rm -f java/util/natTimeZone.lo\n+\t-rm -f java/util/natVMTimeZone.$(OBJEXT)\n+\t-rm -f java/util/natVMTimeZone.lo\n \t-rm -f java/util/prefs/AbstractPreferences.$(OBJEXT)\n \t-rm -f java/util/prefs/AbstractPreferences.lo\n \t-rm -f java/util/prefs/BackingStoreException.$(OBJEXT)\n@@ -20538,10 +20543,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/TooManyListenersException.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/TreeMap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/TreeSet.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/VMTimeZone.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/Vector.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/WeakHashMap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/natResourceBundle.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/natTimeZone.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/util/$(DEPDIR)/natVMTimeZone.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/jar/$(DEPDIR)/Attributes.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/jar/$(DEPDIR)/JarEntry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/util/jar/$(DEPDIR)/JarException.Plo@am__quote@"}, {"sha": "3120184650fd1033f7c9077b8554191a8142e3fe", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -151,6 +151,7 @@ extern \"Java\"\n       class Comparable;\n       class Compiler;\n       class ConcreteProcess;\n+      class ConcreteProcess$EOFInputStream;\n       class ConcreteProcess$ProcessManager;\n       class Double;\n       class Error;\n@@ -359,6 +360,7 @@ extern \"Java\"\n       class TreeMap$SubMap;\n       class TreeMap$TreeIterator;\n       class TreeSet;\n+      class VMTimeZone;\n       class Vector;\n       class WeakHashMap;\n       class WeakHashMap$WeakBucket;"}, {"sha": "1e06e535611bc12ec2ce1b6ec036c90d39ffbbdd", "filename": "libjava/java/util/TimeZone.java", "status": "modified", "additions": 12, "deletions": 280, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fjava%2Futil%2FTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fjava%2Futil%2FTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimeZone.java?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -38,9 +38,7 @@\n \n \n package java.util;\n-import gnu.classpath.Configuration;\n \n-import java.io.*;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n import java.text.DateFormatSymbols;\n@@ -90,14 +88,9 @@ public abstract class TimeZone implements java.io.Serializable, Cloneable\n   /**\n    * Tries to get the default TimeZone for this system if not already\n    * set.  It will call <code>getDefaultTimeZone(String)</code> with\n-   * the result of\n-   * <code>System.getProperty(\"user.timezone\")</code>,\n-   * <code>System.getenv(\"TZ\")</code>,\n-   * <code>readTimeZoneFile(\"/etc/timezone\")</code>,\n-   * <code>readtzFile(\"/etc/localtime\")</code> and\n-   * <code>getDefaultTimeZoneId()</code>\n-   * till a supported TimeZone is found.\n-   * If every method fails GMT is returned.\n+   * the result of <code>System.getProperty(\"user.timezone\")</code>.\n+   * If that fails it calls <code>VMTimeZone.getDefaultTimeZoneId()</code>.\n+   * If that also fails GMT is returned.\n    */\n   private static synchronized TimeZone defaultZone()\n   {\n@@ -109,49 +102,16 @@ private static synchronized TimeZone defaultZone()\n \t    {\n \t      public Object run()\n \t      {\n-\t\tif (Configuration.INIT_LOAD_LIBRARY)\n-\t\t  {\n-\t\t    System.loadLibrary(\"javautil\");\n-\t\t  }\n-\t\t\n \t\tTimeZone zone = null;\n \t\t\n \t\t// Prefer System property user.timezone.\n \t\tString tzid = System.getProperty(\"user.timezone\");\n \t\tif (tzid != null && !tzid.equals(\"\"))\n \t\t  zone = getDefaultTimeZone(tzid);\n \t\t\n-\t\t// See if TZ environment variable is set and accessible.\n-\t\tif (zone == null)\n-\t\t  {\n-\t\t    tzid = System.getenv(\"TZ\");\n-\t\t    if (tzid != null && !tzid.equals(\"\"))\n-\t\t      zone = getDefaultTimeZone(tzid);\n-\t\t  }\n-\t\t\n-\t\t// Try to parse /etc/timezone.\n+\t\t// Try platfom specific way.\n \t\tif (zone == null)\n-\t\t  {\n-\t\t    tzid = readTimeZoneFile(\"/etc/timezone\");\n-\t\t    if (tzid != null && !tzid.equals(\"\"))\n-\t\t      zone = getDefaultTimeZone(tzid);\n-\t\t  }\n-\t\t\n-\t\t// Try to parse /etc/localtime\n-\t\tif (zone == null)\n-\t\t  {\n-\t\t    tzid = readtzFile(\"/etc/localtime\");\n-\t\t    if (tzid != null && !tzid.equals(\"\"))\n-\t\t      zone = getDefaultTimeZone(tzid);\n-\t\t  }\n-\t\t\n-\t\t// Try some system specific way\n-\t\tif (zone == null)\n-\t\t  {\n-\t\t    tzid = getDefaultTimeZoneId();\n-\t\t    if (tzid != null && !tzid.equals(\"\"))\n-\t\t      zone = getDefaultTimeZone(tzid);\n-\t\t  }\n+\t\t  zone = VMTimeZone.getDefaultTimeZoneId();\n \t\t\n \t\t// Fall back on GMT.\n \t\tif (zone == null)\n@@ -842,238 +802,6 @@ private static synchronized HashMap timezones()\n     return timezones0;\n   }\n \n-  /**\n-   * This method returns a time zone id string which is in the form\n-   * (standard zone name) or (standard zone name)(GMT offset) or\n-   * (standard zone name)(GMT offset)(daylight time zone name).  The\n-   * GMT offset can be in seconds, or where it is evenly divisible by\n-   * 3600, then it can be in hours.  The offset must be the time to\n-   * add to the local time to get GMT.  If a offset is given and the\n-   * time zone observes daylight saving then the (daylight time zone\n-   * name) must also be given (otherwise it is assumed the time zone\n-   * does not observe any daylight savings).\n-   * <p>\n-   * The result of this method is given to getDefaultTimeZone(String)\n-   * which tries to map the time zone id to a known TimeZone.  See\n-   * that method on how the returned String is mapped to a real\n-   * TimeZone object.\n-   */\n-  private static native String getDefaultTimeZoneId();\n-\n-  /**\n-   * Tries to read the time zone name from a file. Only the first\n-   * consecutive letters, digits, slashes, dashes and underscores are\n-   * read from the file. If the file cannot be read or an IOException\n-   * occurs null is returned.\n-   * <p>\n-   * The /etc/timezone file is not standard, but a lot of systems have\n-   * it. If it exist the first line always contains a string\n-   * describing the timezone of the host of domain. Some systems\n-   * contain a /etc/TIMEZONE file which is used to set the TZ\n-   * environment variable (which is checked before /etc/timezone is\n-   * read).\n-   */\n-  private static String readTimeZoneFile(String file)\n-  {\n-    File f = new File(file);\n-    if (!f.exists())\n-      return null;\n-\n-    InputStreamReader isr = null;\n-    try\n-      {\n-\tFileInputStream fis = new FileInputStream(f);\n-\tBufferedInputStream bis = new BufferedInputStream(fis);\n-\tisr = new InputStreamReader(bis);\n-\t\n-\tStringBuffer sb = new StringBuffer();\n-\tint i = isr.read();\n-\twhile (i != -1)\n-\t  {\n-\t    char c = (char) i;\n-\t    if (Character.isLetter(c) || Character.isDigit(c)\n-\t\t|| c == '/' || c == '-' || c == '_')\n-\t      {\n-\t\tsb.append(c);\n-\t\ti = isr.read();\n-\t      }\n-\t    else\n-\t      break;\n-\t  }\n-\treturn sb.toString();\n-      }\n-    catch (IOException ioe)\n-      {\n-\t// Parse error, not a proper tzfile.\n-\treturn null;\n-      }\n-    finally\n-      {\n-\ttry\n-\t  {\n-\t    if (isr != null)\n-\t      isr.close();\n-\t  }\n-\tcatch (IOException ioe)\n-\t  {\n-\t    // Error while close, nothing we can do.\n-\t  }\n-      }\n-  }\n-\n-  /**\n-   * Tries to read a file as a \"standard\" tzfile and return a time\n-   * zone id string as expected by <code>getDefaultTimeZone(String)</code>.\n-   * If the file doesn't exist, an IOException occurs or it isn't a tzfile\n-   * that can be parsed null is returned.\n-   * <p>\n-   * The tzfile structure (as also used by glibc) is described in the Olson\n-   * tz database archive as can be found at\n-   * <code>ftp://elsie.nci.nih.gov/pub/</code>.\n-   * <p>\n-   * At least the following platforms support the tzdata file format\n-   * and /etc/localtime (GNU/Linux, Darwin, Solaris and FreeBSD at\n-   * least). Some systems (like Darwin) don't start the file with the\n-   * required magic bytes 'TZif', this implementation can handle\n-   * that).\n-   */\n-  private static String readtzFile(String file)\n-  {\n-    File f = new File(file);\n-    if (!f.exists())\n-      return null;\n-    \n-    DataInputStream dis = null;\n-    try\n-      {\n-        FileInputStream fis = new FileInputStream(f);\n-        BufferedInputStream bis = new BufferedInputStream(fis);\n-        dis = new DataInputStream(bis);\n-\t\n-        // Make sure we are reading a tzfile.\n-        byte[] tzif = new byte[4];\n-        dis.readFully(tzif);\n-        if (tzif[0] == 'T' && tzif[1] == 'Z'\n-            && tzif[2] == 'i' && tzif[3] == 'f')\n-\t  // Reserved bytes, ttisgmtcnt, ttisstdcnt and leapcnt\n-\t  skipFully(dis, 16 + 3 * 4);\n-\telse\n-\t  // Darwin has tzdata files that don't start with the TZif marker\n-\t  skipFully(dis, 16 + 3 * 4 - 4);\n-\t\n-\tint timecnt = dis.readInt();\n-\tint typecnt = dis.readInt();\n-\tif (typecnt > 0)\n-\t  {\n-\t    int charcnt = dis.readInt();\n-\t    // Transition times plus indexed transition times.\n-\t    skipFully(dis, timecnt * (4 + 1));\n-\t    \n-\t    // Get last gmt_offset and dst/non-dst time zone names.\n-\t    int abbrind = -1;\n-\t    int dst_abbrind = -1;\n-\t    int gmt_offset = 0;\n-\t    while (typecnt-- > 0)\n-\t      {\n-\t\t// gmtoff\n-\t\tint offset = dis.readInt();\n-\t\tint dst = dis.readByte();\n-\t\tif (dst == 0)\n-\t\t  {\n-\t\t    abbrind = dis.readByte();\n-\t\t    gmt_offset = offset;\n-\t\t  }\n-\t\telse\n-\t\t  dst_abbrind = dis.readByte();\n-\t      }\n-\t    \n-\t    // gmt_offset is the offset you must add to UTC/GMT to\n-\t    // get the local time, we need the offset to add to\n-\t    // the local time to get UTC/GMT.\n-\t    gmt_offset *= -1;\n-\t    \n-\t    // Turn into hours if possible.\n-\t    if (gmt_offset % 3600 == 0)\n-\t      gmt_offset /= 3600;\n-\t    \n-\t    if (abbrind >= 0)\n-\t      {\n-\t\tbyte[] names = new byte[charcnt];\n-\t\tdis.readFully(names);\n-\t\tint j = abbrind;\n-\t\twhile (j < charcnt && names[j] != 0)\n-\t\t  j++;\n-\t\t\n-\t\tString zonename = new String(names, abbrind, j - abbrind,\n-\t\t\t\t\t     \"ASCII\");\n-\t\t\n-\t\tString dst_zonename;\n-\t\tif (dst_abbrind >= 0)\n-\t\t  {\n-\t\t    j = dst_abbrind;\n-\t\t    while (j < charcnt && names[j] != 0)\n-\t\t      j++;\n-\t\t    dst_zonename = new String(names, dst_abbrind,\n-\t\t\t\t\t      j - dst_abbrind, \"ASCII\");\n-\t\t  }\n-\t\telse\n-\t\t  dst_zonename = \"\";\n-\t\t\n-\t\t// Only use gmt offset when necessary.\n-\t\t// Also special case GMT+/- timezones.\n-\t\tString offset_string;\n-\t\tif (\"\".equals(dst_zonename)\n-\t\t    && (gmt_offset == 0\n-\t\t\t|| zonename.startsWith(\"GMT+\")\n-\t\t\t|| zonename.startsWith(\"GMT-\")))\n-\t\t  offset_string = \"\";\n-\t\telse\n-\t\t  offset_string = Integer.toString(gmt_offset);\n-\t\t\n-\t\tString id = zonename + offset_string + dst_zonename;\n-\t\t\n-\t\treturn id;\n-\t      }\n-\t  }\n-\t\n-\t// Something didn't match while reading the file.\n-\treturn null;\n-      }\n-    catch (IOException ioe)\n-      {\n-\t// Parse error, not a proper tzfile.\n-\treturn null;\n-      }\n-    finally\n-      {\n-\ttry\n-\t  {\n-\t    if (dis != null)\n-\t      dis.close();\n-\t  }\n-\tcatch(IOException ioe)\n-\t  {\n-\t    // Error while close, nothing we can do.\n-\t  }\n-      }\n-  }\n-  \n-  /**\n-   * Skips the requested number of bytes in the given InputStream.\n-   * Throws EOFException if not enough bytes could be skipped.\n-   * Negative numbers of bytes to skip are ignored.\n-   */\n-  private static void skipFully(InputStream is, long l) throws IOException\n-  {\n-    while (l > 0)\n-      {\n-        long k = is.skip(l);\n-        if (k <= 0)\n-          throw new EOFException();\n-        l -= k;\n-      }\n-  }\n-  \n   /**\n    * Maps a time zone name (with optional GMT offset and daylight time\n    * zone name) to one of the known time zones.  This method called\n@@ -1111,15 +839,19 @@ private static void skipFully(InputStream is, long l) throws IOException\n    * The standard time zone name for The Netherlands is \"Europe/Amsterdam\",\n    * but can also be given as \"CET-1CEST\".\n    */\n-  private static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n+  static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n   {\n     // First find start of GMT offset info and any Daylight zone name.\n     int startGMToffset = 0;\n     int sysTimeZoneIdLength = sysTimeZoneId.length();\n     for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)\n       {\n \tchar c = sysTimeZoneId.charAt(i);\n-\tif (c == '+' || c == '-' || Character.isDigit(c))\n+\tif (Character.isDigit(c))\n+\t  startGMToffset = i;\n+\telse if ((c == '+' || c == '-')\n+\t\t && i + 1 < sysTimeZoneIdLength\n+\t\t && Character.isDigit(sysTimeZoneId.charAt(i + 1)))\n \t  startGMToffset = i;\n       }\n     \n@@ -1152,7 +884,7 @@ private static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n \t// Offset could be in hours or seconds.  Convert to millis.\n \t// The offset is given as the time to add to local time to get GMT\n \t// we need the time to add to GMT to get localtime.\n-\tif (gmtOffset < 24)\n+\tif (Math.abs(gmtOffset) < 24)\n \t  gmtOffset *= 60 * 60;\n \tgmtOffset *= -1000;\n       }"}, {"sha": "77c055b2a64018c6b26a8e4fd111c65e9c5c800d", "filename": "libjava/java/util/VMTimeZone.java", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fjava%2Futil%2FVMTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fjava%2Futil%2FVMTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FVMTimeZone.java?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -0,0 +1,345 @@\n+/* java.util.VMTimeZone\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.util;\n+\n+import gnu.classpath.Configuration;\n+\n+import java.io.*;\n+\n+/**\n+ *\n+ */\n+final class VMTimeZone\n+{\n+  static\n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary(\"javautil\");\n+      }\n+  }\n+\t\t\n+  /**\n+   * This method returns a time zone id string which is in the form\n+   * (standard zone name) or (standard zone name)(GMT offset) or\n+   * (standard zone name)(GMT offset)(daylight time zone name).  The\n+   * GMT offset can be in seconds, or where it is evenly divisible by\n+   * 3600, then it can be in hours.  The offset must be the time to\n+   * add to the local time to get GMT.  If a offset is given and the\n+   * time zone observes daylight saving then the (daylight time zone\n+   * name) must also be given (otherwise it is assumed the time zone\n+   * does not observe any daylight savings).\n+   * <p>\n+   * The result of this method is given to the method\n+   * TimeZone.getDefaultTimeZone(String) which tries to map the time\n+   * zone id to a known TimeZone.  See that method on how the returned\n+   * String is mapped to a real TimeZone object.\n+   * <p>\n+   * The reference implementation which is made for GNU/Posix like\n+   * systems calls <code>System.getenv(\"TZ\")</code>,\n+   * <code>readTimeZoneFile(\"/etc/timezone\")</code>,\n+   * <code>readtzFile(\"/etc/localtime\")</code> and finally\n+   * <code>getSystemTimeZoneId()</code> till a supported TimeZone is\n+   * found through <code>TimeZone.getDefaultTimeZone(String)</code>.\n+   * If every method fails <code>null</code> is returned (which means\n+   * the TimeZone code will fall back on GMT as default time zone).\n+   * <p>\n+   * Note that this method is called inside a\n+   * <code>AccessController.doPrivileged()</code> block and runs with\n+   * the priviliges of the java.util system classes.  It will only be\n+   * called when the default time zone is not yet set, the system\n+   * property user.timezone isn't set and it is requested for the\n+   * first time.\n+   */\n+  static TimeZone getDefaultTimeZoneId()\n+  {\n+    TimeZone zone = null;\n+\n+    // See if TZ environment variable is set and accessible.\n+    String tzid = System.getenv(\"TZ\");\n+    if (tzid != null && !tzid.equals(\"\"))\n+      zone = TimeZone.getDefaultTimeZone(tzid);\n+\n+    // Try to parse /etc/timezone.\n+    if (zone == null)\n+      {\n+\ttzid = readTimeZoneFile(\"/etc/timezone\");\n+\tif (tzid != null && !tzid.equals(\"\"))\n+\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+      }\n+    \n+    // Try to parse /etc/localtime\n+    if (zone == null)\n+      {\n+\ttzid = readtzFile(\"/etc/localtime\");\n+\tif (tzid != null && !tzid.equals(\"\"))\n+\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+      }\n+\n+    // Try some system specific way\n+    if (zone == null)\n+      {\n+\ttzid = getSystemTimeZoneId();\n+\tif (tzid != null && !tzid.equals(\"\"))\n+\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+      }\n+\n+    return zone;\n+  }\n+\n+  /**\n+   * Tries to read the time zone name from a file. Only the first\n+   * consecutive letters, digits, slashes, dashes and underscores are\n+   * read from the file. If the file cannot be read or an IOException\n+   * occurs null is returned.\n+   * <p>\n+   * The /etc/timezone file is not standard, but a lot of systems have\n+   * it. If it exist the first line always contains a string\n+   * describing the timezone of the host of domain. Some systems\n+   * contain a /etc/TIMEZONE file which is used to set the TZ\n+   * environment variable (which is checked before /etc/timezone is\n+   * read).\n+   */\n+  private static String readTimeZoneFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      return null;\n+\n+    InputStreamReader isr = null;\n+    try\n+      {\n+\tFileInputStream fis = new FileInputStream(f);\n+\tBufferedInputStream bis = new BufferedInputStream(fis);\n+\tisr = new InputStreamReader(bis);\n+\t\n+\tStringBuffer sb = new StringBuffer();\n+\tint i = isr.read();\n+\twhile (i != -1)\n+\t  {\n+\t    char c = (char) i;\n+\t    if (Character.isLetter(c) || Character.isDigit(c)\n+\t\t|| c == '/' || c == '-' || c == '_')\n+\t      {\n+\t\tsb.append(c);\n+\t\ti = isr.read();\n+\t      }\n+\t    else\n+\t      break;\n+\t  }\n+\treturn sb.toString();\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (isr != null)\n+\t      isr.close();\n+\t  }\n+\tcatch (IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Tries to read a file as a \"standard\" tzfile and return a time\n+   * zone id string as expected by <code>getDefaultTimeZone(String)</code>.\n+   * If the file doesn't exist, an IOException occurs or it isn't a tzfile\n+   * that can be parsed null is returned.\n+   * <p>\n+   * The tzfile structure (as also used by glibc) is described in the Olson\n+   * tz database archive as can be found at\n+   * <code>ftp://elsie.nci.nih.gov/pub/</code>.\n+   * <p>\n+   * At least the following platforms support the tzdata file format\n+   * and /etc/localtime (GNU/Linux, Darwin, Solaris and FreeBSD at\n+   * least). Some systems (like Darwin) don't start the file with the\n+   * required magic bytes 'TZif', this implementation can handle\n+   * that).\n+   */\n+  private static String readtzFile(String file)\n+  {\n+    File f = new File(file);\n+    if (!f.exists())\n+      return null;\n+    \n+    DataInputStream dis = null;\n+    try\n+      {\n+        FileInputStream fis = new FileInputStream(f);\n+        BufferedInputStream bis = new BufferedInputStream(fis);\n+        dis = new DataInputStream(bis);\n+\t\n+        // Make sure we are reading a tzfile.\n+        byte[] tzif = new byte[4];\n+        dis.readFully(tzif);\n+        if (tzif[0] == 'T' && tzif[1] == 'Z'\n+            && tzif[2] == 'i' && tzif[3] == 'f')\n+\t  // Reserved bytes, ttisgmtcnt, ttisstdcnt and leapcnt\n+\t  skipFully(dis, 16 + 3 * 4);\n+\telse\n+\t  // Darwin has tzdata files that don't start with the TZif marker\n+\t  skipFully(dis, 16 + 3 * 4 - 4);\n+\t\n+\tint timecnt = dis.readInt();\n+\tint typecnt = dis.readInt();\n+\tif (typecnt > 0)\n+\t  {\n+\t    int charcnt = dis.readInt();\n+\t    // Transition times plus indexed transition times.\n+\t    skipFully(dis, timecnt * (4 + 1));\n+\t    \n+\t    // Get last gmt_offset and dst/non-dst time zone names.\n+\t    int abbrind = -1;\n+\t    int dst_abbrind = -1;\n+\t    int gmt_offset = 0;\n+\t    while (typecnt-- > 0)\n+\t      {\n+\t\t// gmtoff\n+\t\tint offset = dis.readInt();\n+\t\tint dst = dis.readByte();\n+\t\tif (dst == 0)\n+\t\t  {\n+\t\t    abbrind = dis.readByte();\n+\t\t    gmt_offset = offset;\n+\t\t  }\n+\t\telse\n+\t\t  dst_abbrind = dis.readByte();\n+\t      }\n+\t    \n+\t    // gmt_offset is the offset you must add to UTC/GMT to\n+\t    // get the local time, we need the offset to add to\n+\t    // the local time to get UTC/GMT.\n+\t    gmt_offset *= -1;\n+\t    \n+\t    // Turn into hours if possible.\n+\t    if (gmt_offset % 3600 == 0)\n+\t      gmt_offset /= 3600;\n+\t    \n+\t    if (abbrind >= 0)\n+\t      {\n+\t\tbyte[] names = new byte[charcnt];\n+\t\tdis.readFully(names);\n+\t\tint j = abbrind;\n+\t\twhile (j < charcnt && names[j] != 0)\n+\t\t  j++;\n+\t\t\n+\t\tString zonename = new String(names, abbrind, j - abbrind,\n+\t\t\t\t\t     \"ASCII\");\n+\t\t\n+\t\tString dst_zonename;\n+\t\tif (dst_abbrind >= 0)\n+\t\t  {\n+\t\t    j = dst_abbrind;\n+\t\t    while (j < charcnt && names[j] != 0)\n+\t\t      j++;\n+\t\t    dst_zonename = new String(names, dst_abbrind,\n+\t\t\t\t\t      j - dst_abbrind, \"ASCII\");\n+\t\t  }\n+\t\telse\n+\t\t  dst_zonename = \"\";\n+\t\t\n+\t\t// Only use gmt offset when necessary.\n+\t\t// Also special case GMT+/- timezones.\n+\t\tString offset_string;\n+\t\tif (\"\".equals(dst_zonename)\n+\t\t    && (gmt_offset == 0\n+\t\t\t|| zonename.startsWith(\"GMT+\")\n+\t\t\t|| zonename.startsWith(\"GMT-\")))\n+\t\t  offset_string = \"\";\n+\t\telse\n+\t\t  offset_string = Integer.toString(gmt_offset);\n+\t\t\n+\t\tString id = zonename + offset_string + dst_zonename;\n+\t\t\n+\t\treturn id;\n+\t      }\n+\t  }\n+\t\n+\t// Something didn't match while reading the file.\n+\treturn null;\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (dis != null)\n+\t      dis.close();\n+\t  }\n+\tcatch(IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+  \n+  /**\n+   * Skips the requested number of bytes in the given InputStream.\n+   * Throws EOFException if not enough bytes could be skipped.\n+   * Negative numbers of bytes to skip are ignored.\n+   */\n+  private static void skipFully(InputStream is, long l) throws IOException\n+  {\n+    while (l > 0)\n+      {\n+        long k = is.skip(l);\n+        if (k <= 0)\n+          throw new EOFException();\n+        l -= k;\n+      }\n+  }\n+\n+  /**\n+   * Tries to get the system time zone id through native code.\n+   */\n+  private static native String getSystemTimeZoneId();\n+}"}, {"sha": "a6d701642f6c8dbbcd3d4c4def7958177face159", "filename": "libjava/java/util/natVMTimeZone.cc", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fjava%2Futil%2FnatVMTimeZone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffe2e220bdb8fee858045b645601923656864cc5/libjava%2Fjava%2Futil%2FnatVMTimeZone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatVMTimeZone.cc?ref=ffe2e220bdb8fee858045b645601923656864cc5", "patch": "@@ -1,4 +1,4 @@\n-// natTimeZone.cc -- Native side of TimeZone class.\n+// natVMTimeZone.cc -- Native side of VMTimeZone class.\n \n /* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation\n@@ -15,7 +15,7 @@ details.  */\n #include <gcj/cni.h>\n #include <jvm.h>\n \n-#include <java/util/TimeZone.h>\n+#include <java/util/VMTimeZone.h>\n #include <java/lang/Character.h>\n #include <java/lang/Integer.h>\n \n@@ -51,7 +51,7 @@ details.  */\n  * TimeZone object.\n  */\n jstring\n-java::util::TimeZone::getDefaultTimeZoneId ()\n+java::util::VMTimeZone::getSystemTimeZoneId()\n {\n   struct tm tim;\n #ifndef HAVE_LOCALTIME_R", "previous_filename": "libjava/java/util/natTimeZone.cc"}]}