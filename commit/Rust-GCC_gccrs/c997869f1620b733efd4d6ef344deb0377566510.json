{"sha": "c997869f1620b733efd4d6ef344deb0377566510", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk5Nzg2OWYxNjIwYjczM2VmZDRkNmVmMzQ0ZGViMDM3NzU2NjUxMA==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-10-12T15:32:23Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-10-12T15:32:23Z"}, "message": "shrink-wrap: Shrink-wrapping for separate components\n\nThis is the main substance of this patch series.\n\nInstead of doing all of the prologue and epilogue in one spot, it often\nis better to do components of it at different places, so that they are\nexecuted less frequently.\n\nWhat exactly is a component is completely up to the target; this code\ntreats it all abstractly, and uses hooks for the target to handle the\nmore concrete things.  Commonly there is one component for each callee-\nsaved register, for example.\n\nComponents can be executed more than once per function execution.  This\npass makes sure that a component's epilogue is not called more often\nthan the corresponding prologue has been, at any point in time; that the\nprologue is called more often, wherever the prologue's effect is needed;\nand that the epilogue is called as often as the prologue has been, when\nthe function exits.  It does this by first deciding which blocks need\nwhich components active, and then placing prologue and epilogue\ncomponents to make that exactly true.\n\nDeciding what blocks should run with a certain component active so that\nthe total cost of executing the prologues (and epilogues) is optimal, is\nnot a computationally feasible problem.  Instead, for each basic block,\nwe estimate the cost of putting a prologue right before the block, and\nif that is cheaper than the total cost of putting prologues optimally\n(according to the estimated cost) in the dominator subtrees strictly\ndominated by this first block, place it at the first block instead.\nThis simple procedure places the components optimally for any dominator\nsub tree where the root node's cost does not depend on anything outside\nits subtree.\n\nThe cost is the execution frequency of all edges into the block coming\nfrom blocks that do not have this component active.  The estimated cost\nis the execution frequency of the block, minus the execution frequency\nof any backedges (which by definition are coming from subtrees, so if\nthe \"head\" block gets a prologue, the source block of any backedge has\nthat component active as well).\n\nCurrently, the epilogues are placed as late as possible, given the\nconstraints.  This does not matter for execution cost, but we could\nsave a little bit of code size by placing the epilogues in a smarter\nway.  This is a possible future optimisation.\n\nNow all that is left is inserting prologues and epilogues on all edges\nthat jump into resp. out of the \"active\" set of blocks.  Often we need\nto insert some components' prologues (or epilogues) on all edges into\n(or out of) a block.  In theory cross-jumping can unify all such, but\nin practice that often fails; besides, that is a lot of work.  So in\nthis case we insert the prologue and epilogue components at the \"head\"\nor \"tail\" of a block, instead.\n\nAs a final optimisation, if a block needs a prologue and its immediate\ndominator has the block as a post-dominator, that immediate dominator\ngets the prologue as well.\n\n\n\t* function.c (thread_prologue_and_epilogue_insns): Call\n\ttry_shrink_wrapping_separate.  Compute the prologue_seq afterwards,\n\tif it has possibly changed.  Compute the split_prologue_seq and\n\tepilogue_seq later, too.\n\t* shrink-wrap.c: #include cfgbuild.h and insn-config.h.\n\t(dump_components): New function.\n\t(struct sw): New struct.\n\t(SW): New function.\n\t(init_separate_shrink_wrap): New function.\n\t(fini_separate_shrink_wrap): New function.\n\t(place_prologue_for_one_component): New function.\n\t(spread_components): New function.\n\t(disqualify_problematic_components): New function.\n\t(emit_common_heads_for_components): New function.\n\t(emit_common_tails_for_components): New function.\n\t(insert_prologue_epilogue_for_components): New function.\n\t(try_shrink_wrapping_separate): New function.\n\t* shrink-wrap.h: Declare try_shrink_wrapping_separate.\n\nFrom-SVN: r241063", "tree": {"sha": "31bb1faabbe6d3a28ad60b265c72a3f49970f6c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31bb1faabbe6d3a28ad60b265c72a3f49970f6c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c997869f1620b733efd4d6ef344deb0377566510", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c997869f1620b733efd4d6ef344deb0377566510", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c997869f1620b733efd4d6ef344deb0377566510", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c997869f1620b733efd4d6ef344deb0377566510/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e7722f110626223efb2d2d63e15bb4960c4f574b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7722f110626223efb2d2d63e15bb4960c4f574b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7722f110626223efb2d2d63e15bb4960c4f574b"}], "stats": {"total": 778, "additions": 775, "deletions": 3}, "files": [{"sha": "ca20d79b5ef6a99fda62e8402fbdda2f3519ba8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c997869f1620b733efd4d6ef344deb0377566510/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c997869f1620b733efd4d6ef344deb0377566510/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c997869f1620b733efd4d6ef344deb0377566510", "patch": "@@ -1,3 +1,24 @@\n+2016-10-12  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* function.c (thread_prologue_and_epilogue_insns): Call\n+\ttry_shrink_wrapping_separate.  Compute the prologue_seq afterwards,\n+\tif it has possibly changed.  Compute the split_prologue_seq and\n+\tepilogue_seq later, too.\n+\t* shrink-wrap.c: #include cfgbuild.h and insn-config.h.\n+\t(dump_components): New function.\n+\t(struct sw): New struct.\n+\t(SW): New function.\n+\t(init_separate_shrink_wrap): New function.\n+\t(fini_separate_shrink_wrap): New function.\n+\t(place_prologue_for_one_component): New function.\n+\t(spread_components): New function.\n+\t(disqualify_problematic_components): New function.\n+\t(emit_common_heads_for_components): New function.\n+\t(emit_common_tails_for_components): New function.\n+\t(insert_prologue_epilogue_for_components): New function.\n+\t(try_shrink_wrapping_separate): New function.\n+\t* shrink-wrap.h: Declare try_shrink_wrapping_separate.\n+\n 2016-10-12  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* regrename.c (build_def_use): Invalidate chains that have a"}, {"sha": "5dafb8ce35ba1a59fbc097de00541ad0364365d1", "filename": "gcc/function.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c997869f1620b733efd4d6ef344deb0377566510/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c997869f1620b733efd4d6ef344deb0377566510/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c997869f1620b733efd4d6ef344deb0377566510", "patch": "@@ -5919,16 +5919,25 @@ thread_prologue_and_epilogue_insns (void)\n   edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   edge orig_entry_edge = entry_edge;\n \n-  rtx_insn *split_prologue_seq = make_split_prologue_seq ();\n   rtx_insn *prologue_seq = make_prologue_seq ();\n-  rtx_insn *epilogue_seq = make_epilogue_seq ();\n \n   /* Try to perform a kind of shrink-wrapping, making sure the\n      prologue/epilogue is emitted only around those parts of the\n      function that require it.  */\n-\n   try_shrink_wrapping (&entry_edge, prologue_seq);\n \n+  /* If the target can handle splitting the prologue/epilogue into separate\n+     components, try to shrink-wrap these components separately.  */\n+  try_shrink_wrapping_separate (entry_edge->dest);\n+\n+  /* If that did anything for any component we now need the generate the\n+     \"main\" prologue again.  If that does not work for some target then\n+     that target should not enable separate shrink-wrapping.  */\n+  if (crtl->shrink_wrapped_separate)\n+    prologue_seq = make_prologue_seq ();\n+\n+  rtx_insn *split_prologue_seq = make_split_prologue_seq ();\n+  rtx_insn *epilogue_seq = make_epilogue_seq ();\n \n   rtl_profile_for_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n "}, {"sha": "7285775e5e000198817456c84c235af8094ed349", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 741, "deletions": 0, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c997869f1620b733efd4d6ef344deb0377566510/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c997869f1620b733efd4d6ef344deb0377566510/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=c997869f1620b733efd4d6ef344deb0377566510", "patch": "@@ -30,10 +30,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"df.h\"\n #include \"tm_p.h\"\n #include \"regs.h\"\n+#include \"insn-config.h\"\n #include \"emit-rtl.h\"\n #include \"output.h\"\n #include \"tree-pass.h\"\n #include \"cfgrtl.h\"\n+#include \"cfgbuild.h\"\n #include \"params.h\"\n #include \"bb-reorder.h\"\n #include \"shrink-wrap.h\"\n@@ -1006,3 +1008,742 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n   BITMAP_FREE (bb_with);\n   free_dominance_info (CDI_DOMINATORS);\n }\n+\f\n+/* Separate shrink-wrapping\n+\n+   Instead of putting all of the prologue and epilogue in one spot, we\n+   can put parts of it in places where those components are executed less\n+   frequently.  The following code does this, for prologue and epilogue\n+   components that can be put in more than one location, and where those\n+   components can be executed more than once (the epilogue component will\n+   always be executed before the prologue component is executed a second\n+   time).\n+\n+   What exactly is a component is target-dependent.  The more usual\n+   components are simple saves/restores to/from the frame of callee-saved\n+   registers.  This code treats components abstractly (as an sbitmap),\n+   letting the target handle all details.\n+\n+   Prologue components are placed in such a way that for every component\n+   the prologue is executed as infrequently as possible.  We do this by\n+   walking the dominator tree, comparing the cost of placing a prologue\n+   component before a block to the sum of costs determined for all subtrees\n+   of that block.\n+\n+   From this placement, we then determine for each component all blocks\n+   where at least one of this block's dominators (including itself) will\n+   get a prologue inserted.  That then is how the components are placed.\n+   We could place the epilogue components a bit smarter (we can save a\n+   bit of code size sometimes); this is a possible future improvement.\n+\n+   Prologues and epilogues are preferably placed into a block, either at\n+   the beginning or end of it, if it is needed for all predecessor resp.\n+   successor edges; or placed on the edge otherwise.\n+\n+   If the placement of any prologue/epilogue leads to a situation we cannot\n+   handle (for example, an abnormal edge would need to be split, or some\n+   targets want to use some specific registers that may not be available\n+   where we want to put them), separate shrink-wrapping for the components\n+   in that prologue/epilogue is aborted.  */\n+\n+\n+/* Print the sbitmap COMPONENTS to the DUMP_FILE if not empty, with the\n+   label LABEL.  */\n+static void\n+dump_components (const char *label, sbitmap components)\n+{\n+  if (bitmap_empty_p (components))\n+    return;\n+\n+  fprintf (dump_file, \" [%s\", label);\n+\n+  for (unsigned int j = 0; j < components->n_bits; j++)\n+    if (bitmap_bit_p (components, j))\n+      fprintf (dump_file, \" %u\", j);\n+\n+  fprintf (dump_file, \"]\");\n+}\n+\n+/* The data we collect for each bb.  */\n+struct sw {\n+  /* What components does this BB need?  */\n+  sbitmap needs_components;\n+\n+  /* What components does this BB have?  This is the main decision this\n+     pass makes.  */\n+  sbitmap has_components;\n+\n+  /* The components for which we placed code at the start of the BB (instead\n+     of on all incoming edges).  */\n+  sbitmap head_components;\n+\n+  /* The components for which we placed code at the end of the BB (instead\n+     of on all outgoing edges).  */\n+  sbitmap tail_components;\n+\n+  /* The frequency of executing the prologue for this BB, if a prologue is\n+     placed on this BB.  This is a pessimistic estimate (no prologue is\n+     needed for edges from blocks that have the component under consideration\n+     active already).  */\n+  gcov_type own_cost;\n+\n+  /* The frequency of executing the prologue for this BB and all BBs\n+     dominated by it.  */\n+  gcov_type total_cost;\n+};\n+\n+/* A helper function for accessing the pass-specific info.  */\n+static inline struct sw *\n+SW (basic_block bb)\n+{\n+  gcc_assert (bb->aux);\n+  return (struct sw *) bb->aux;\n+}\n+\n+/* Create the pass-specific data structures for separately shrink-wrapping\n+   with components COMPONENTS.  */\n+static void\n+init_separate_shrink_wrap (sbitmap components)\n+{\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    {\n+      bb->aux = xcalloc (1, sizeof (struct sw));\n+\n+      SW (bb)->needs_components = targetm.shrink_wrap.components_for_bb (bb);\n+\n+      /* Mark all basic blocks without successor as needing all components.\n+\t This avoids problems in at least cfgcleanup, sel-sched, and\n+\t regrename (largely to do with all paths to such a block still\n+\t needing the same dwarf CFI info).  */\n+      if (EDGE_COUNT (bb->succs) == 0)\n+\tbitmap_copy (SW (bb)->needs_components, components);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"bb %d components:\", bb->index);\n+\t  dump_components (\"has\", SW (bb)->needs_components);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      SW (bb)->has_components = sbitmap_alloc (SBITMAP_SIZE (components));\n+      SW (bb)->head_components = sbitmap_alloc (SBITMAP_SIZE (components));\n+      SW (bb)->tail_components = sbitmap_alloc (SBITMAP_SIZE (components));\n+      bitmap_clear (SW (bb)->has_components);\n+      bitmap_clear (SW (bb)->head_components);\n+      bitmap_clear (SW (bb)->tail_components);\n+    }\n+}\n+\n+/* Destroy the pass-specific data.  */\n+static void\n+fini_separate_shrink_wrap (void)\n+{\n+  basic_block bb;\n+  FOR_ALL_BB_FN (bb, cfun)\n+    if (bb->aux)\n+      {\n+\tsbitmap_free (SW (bb)->needs_components);\n+\tsbitmap_free (SW (bb)->has_components);\n+\tsbitmap_free (SW (bb)->head_components);\n+\tsbitmap_free (SW (bb)->tail_components);\n+\tfree (bb->aux);\n+\tbb->aux = 0;\n+      }\n+}\n+\n+/* Place the prologue for component WHICH, in the basic blocks dominated\n+   by HEAD.  Do a DFS over the dominator tree, and set bit WHICH in the\n+   HAS_COMPONENTS of a block if either the block has that bit set in\n+   NEEDS_COMPONENTS, or it is cheaper to place the prologue here than in all\n+   dominator subtrees separately.  */\n+static void\n+place_prologue_for_one_component (unsigned int which, basic_block head)\n+{\n+  /* The block we are currently dealing with.  */\n+  basic_block bb = head;\n+  /* Is this the first time we visit this block, i.e. have we just gone\n+     down the tree.  */\n+  bool first_visit = true;\n+\n+  /* Walk the dominator tree, visit one block per iteration of this loop.\n+     Each basic block is visited twice: once before visiting any children\n+     of the block, and once after visiting all of them (leaf nodes are\n+     visited only once).  As an optimization, we do not visit subtrees\n+     that can no longer influence the prologue placement.  */\n+  for (;;)\n+    {\n+      /* First visit of a block: set the (children) cost accumulator to zero;\n+\t if the block does not have the component itself, walk down.  */\n+      if (first_visit)\n+\t{\n+\t  /* Initialize the cost.  The cost is the block execution frequency\n+\t     that does not come from backedges.  Calculating this by simply\n+\t     adding the cost of all edges that aren't backedges does not\n+\t     work: this does not always add up to the block frequency at\n+\t     all, and even if it does, rounding error makes for bad\n+\t     decisions.  */\n+\t  SW (bb)->own_cost = bb->frequency;\n+\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n+\t    if (dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+\t      {\n+\t\tif (SW (bb)->own_cost > EDGE_FREQUENCY (e))\n+\t\t  SW (bb)->own_cost -= EDGE_FREQUENCY (e);\n+\t\telse\n+\t\t  SW (bb)->own_cost = 0;\n+\t      }\n+\n+\t  SW (bb)->total_cost = 0;\n+\n+\t  if (!bitmap_bit_p (SW (bb)->needs_components, which)\n+\t      && first_dom_son (CDI_DOMINATORS, bb))\n+\t    {\n+\t      bb = first_dom_son (CDI_DOMINATORS, bb);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      /* If this block does need the component itself, or it is cheaper to\n+\t put the prologue here than in all the descendants that need it,\n+\t mark it so.  If this block's immediate post-dominator is dominated\n+\t by this block, and that needs the prologue, we can put it on this\n+\t block as well (earlier is better).  */\n+      if (bitmap_bit_p (SW (bb)->needs_components, which)\n+\t  || SW (bb)->total_cost > SW (bb)->own_cost)\n+\t{\n+\t  SW (bb)->total_cost = SW (bb)->own_cost;\n+\t  bitmap_set_bit (SW (bb)->has_components, which);\n+\t}\n+      else\n+\t{\n+\t  basic_block kid = get_immediate_dominator (CDI_POST_DOMINATORS, bb);\n+\t  if (dominated_by_p (CDI_DOMINATORS, kid, bb)\n+\t      && bitmap_bit_p (SW (kid)->has_components, which))\n+\t    {\n+\t      SW (bb)->total_cost = SW (bb)->own_cost;\n+\t      bitmap_set_bit (SW (bb)->has_components, which);\n+\t    }\n+\t}\n+\n+      /* We are back where we started, so we are done now.  */\n+      if (bb == head)\n+\treturn;\n+\n+      /* We now know the cost of the subtree rooted at the current block.\n+\t Accumulate this cost in the parent.  */\n+      basic_block parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      SW (parent)->total_cost += SW (bb)->total_cost;\n+\n+      /* Don't walk the tree down unless necessary.  */\n+      if (next_dom_son (CDI_DOMINATORS, bb)\n+          && SW (parent)->total_cost <= SW (parent)->own_cost)\n+\t{\n+\t  bb = next_dom_son (CDI_DOMINATORS, bb);\n+\t  first_visit = true;\n+\t}\n+      else\n+\t{\n+\t  bb = parent;\n+\t  first_visit = false;\n+\t}\n+    }\n+}\n+\n+/* Mark HAS_COMPONENTS for every block dominated by at least one block with\n+   HAS_COMPONENTS set for the respective components, starting at HEAD.  */\n+static void\n+spread_components (basic_block head)\n+{\n+  basic_block bb = head;\n+  bool first_visit = true;\n+  /* This keeps a tally of all components active.  */\n+  sbitmap components = SW (head)->has_components;\n+\n+  for (;;)\n+    {\n+      if (first_visit)\n+\t{\n+\t  bitmap_ior (SW (bb)->has_components, SW (bb)->has_components,\n+\t\t      components);\n+\n+\t  if (first_dom_son (CDI_DOMINATORS, bb))\n+\t    {\n+\t      components = SW (bb)->has_components;\n+\t      bb = first_dom_son (CDI_DOMINATORS, bb);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      components = SW (bb)->has_components;\n+\n+      if (next_dom_son (CDI_DOMINATORS, bb))\n+\t{\n+\t  bb = next_dom_son (CDI_DOMINATORS, bb);\n+\t  basic_block parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t  components = SW (parent)->has_components;\n+\t  first_visit = true;\n+\t}\n+      else\n+\t{\n+\t  if (bb == head)\n+\t    return;\n+\t  bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t  first_visit = false;\n+\t}\n+    }\n+}\n+\n+/* If we cannot handle placing some component's prologues or epilogues where\n+   we decided we should place them, unmark that component in COMPONENTS so\n+   that it is not wrapped separately.  */\n+static void\n+disqualify_problematic_components (sbitmap components)\n+{\n+  sbitmap pro = sbitmap_alloc (SBITMAP_SIZE (components));\n+  sbitmap epi = sbitmap_alloc (SBITMAP_SIZE (components));\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  /* Find which components we want pro/epilogues for here.  */\n+\t  bitmap_and_compl (epi, SW (e->src)->has_components,\n+\t\t\t    SW (e->dest)->has_components);\n+\t  bitmap_and_compl (pro, SW (e->dest)->has_components,\n+\t\t\t    SW (e->src)->has_components);\n+\n+\t  /* Ask the target what it thinks about things.  */\n+\t  if (!bitmap_empty_p (epi))\n+\t    targetm.shrink_wrap.disqualify_components (components, e, epi,\n+\t\t\t\t\t\t       false);\n+\t  if (!bitmap_empty_p (pro))\n+\t    targetm.shrink_wrap.disqualify_components (components, e, pro,\n+\t\t\t\t\t\t       true);\n+\n+\t  /* If this edge doesn't need splitting, we're fine.  */\n+\t  if (single_pred_p (e->dest)\n+\t      && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t    continue;\n+\n+\t  /* If the edge can be split, that is fine too.  */\n+\t  if ((e->flags & EDGE_ABNORMAL) == 0)\n+\t    continue;\n+\n+\t  /* We also can handle sibcalls.  */\n+\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t    {\n+\t      gcc_assert (e->flags & EDGE_SIBCALL);\n+\t      continue;\n+\t    }\n+\n+\t  /* Remove from consideration those components we would need\n+\t     pro/epilogues for on edges where we cannot insert them.  */\n+\t  bitmap_and_compl (components, components, epi);\n+\t  bitmap_and_compl (components, components, pro);\n+\n+\t  if (dump_file && !bitmap_subset_p (epi, components))\n+\t    {\n+\t      fprintf (dump_file, \"  BAD epi %d->%d\", e->src->index,\n+\t\t       e->dest->index);\n+\t      if (e->flags & EDGE_EH)\n+\t\tfprintf (dump_file, \" for EH\");\n+\t      dump_components (\"epi\", epi);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\n+\t  if (dump_file && !bitmap_subset_p (pro, components))\n+\t    {\n+\t      fprintf (dump_file, \"  BAD pro %d->%d\", e->src->index,\n+\t\t       e->dest->index);\n+\t      if (e->flags & EDGE_EH)\n+\t\tfprintf (dump_file, \" for EH\");\n+\t      dump_components (\"pro\", pro);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t}\n+    }\n+\n+  sbitmap_free (pro);\n+  sbitmap_free (epi);\n+}\n+\n+/* Place code for prologues and epilogues for COMPONENTS where we can put\n+   that code at the start of basic blocks.  */\n+static void\n+emit_common_heads_for_components (sbitmap components)\n+{\n+  sbitmap pro = sbitmap_alloc (SBITMAP_SIZE (components));\n+  sbitmap epi = sbitmap_alloc (SBITMAP_SIZE (components));\n+  sbitmap tmp = sbitmap_alloc (SBITMAP_SIZE (components));\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      /* Find which prologue resp. epilogue components are needed for all\n+\t predecessor edges to this block.  */\n+\n+      /* First, select all possible components.  */\n+      bitmap_copy (epi, components);\n+      bitmap_copy (pro, components);\n+\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\t{\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    {\n+\t      bitmap_clear (epi);\n+\t      bitmap_clear (pro);\n+\t      break;\n+\t    }\n+\n+\t  /* Deselect those epilogue components that should not be inserted\n+\t     for this edge.  */\n+\t  bitmap_and_compl (tmp, SW (e->src)->has_components,\n+\t\t\t    SW (e->dest)->has_components);\n+\t  bitmap_and (epi, epi, tmp);\n+\n+\t  /* Similar, for the prologue.  */\n+\t  bitmap_and_compl (tmp, SW (e->dest)->has_components,\n+\t\t\t    SW (e->src)->has_components);\n+\t  bitmap_and (pro, pro, tmp);\n+\t}\n+\n+      if (dump_file && !(bitmap_empty_p (epi) && bitmap_empty_p (pro)))\n+\tfprintf (dump_file, \"  bb %d\", bb->index);\n+\n+      if (dump_file && !bitmap_empty_p (epi))\n+\tdump_components (\"epi\", epi);\n+      if (dump_file && !bitmap_empty_p (pro))\n+\tdump_components (\"pro\", pro);\n+\n+      if (dump_file && !(bitmap_empty_p (epi) && bitmap_empty_p (pro)))\n+\tfprintf (dump_file, \"\\n\");\n+\n+      /* Place code after the BB note.  */\n+      if (!bitmap_empty_p (pro))\n+\t{\n+\t  start_sequence ();\n+\t  targetm.shrink_wrap.emit_prologue_components (pro);\n+\t  rtx_insn *seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  emit_insn_after (seq, bb_note (bb));\n+\n+\t  bitmap_ior (SW (bb)->head_components, SW (bb)->head_components, pro);\n+\t}\n+\n+      if (!bitmap_empty_p (epi))\n+\t{\n+\t  start_sequence ();\n+\t  targetm.shrink_wrap.emit_epilogue_components (epi);\n+\t  rtx_insn *seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  emit_insn_after (seq, bb_note (bb));\n+\n+\t  bitmap_ior (SW (bb)->head_components, SW (bb)->head_components, epi);\n+\t}\n+    }\n+\n+  sbitmap_free (pro);\n+  sbitmap_free (epi);\n+  sbitmap_free (tmp);\n+}\n+\n+/* Place code for prologues and epilogues for COMPONENTS where we can put\n+   that code at the end of basic blocks.  */\n+static void\n+emit_common_tails_for_components (sbitmap components)\n+{\n+  sbitmap pro = sbitmap_alloc (SBITMAP_SIZE (components));\n+  sbitmap epi = sbitmap_alloc (SBITMAP_SIZE (components));\n+  sbitmap tmp = sbitmap_alloc (SBITMAP_SIZE (components));\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      /* Find which prologue resp. epilogue components are needed for all\n+\t successor edges from this block.  */\n+      if (EDGE_COUNT (bb->succs) == 0)\n+\tcontinue;\n+\n+      /* First, select all possible components.  */\n+      bitmap_copy (epi, components);\n+      bitmap_copy (pro, components);\n+\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    {\n+\t      bitmap_clear (epi);\n+\t      bitmap_clear (pro);\n+\t      break;\n+\t    }\n+\n+\t  /* Deselect those epilogue components that should not be inserted\n+\t     for this edge, and also those that are already put at the head\n+\t     of the successor block.  */\n+\t  bitmap_and_compl (tmp, SW (e->src)->has_components,\n+\t\t\t    SW (e->dest)->has_components);\n+\t  bitmap_and_compl (tmp, tmp, SW (e->dest)->head_components);\n+\t  bitmap_and (epi, epi, tmp);\n+\n+\t  /* Similarly, for the prologue.  */\n+\t  bitmap_and_compl (tmp, SW (e->dest)->has_components,\n+\t\t\t    SW (e->src)->has_components);\n+\t  bitmap_and_compl (tmp, tmp, SW (e->dest)->head_components);\n+\t  bitmap_and (pro, pro, tmp);\n+\t}\n+\n+      /* If the last insn of this block is a control flow insn we cannot\n+\t put anything after it.  We can put our code before it instead,\n+\t but only if that jump insn is a simple jump.  */\n+      rtx_insn *last_insn = BB_END (bb);\n+      if (control_flow_insn_p (last_insn) && !simplejump_p (last_insn))\n+\t{\n+\t  bitmap_clear (epi);\n+\t  bitmap_clear (pro);\n+\t}\n+\n+      if (dump_file && !(bitmap_empty_p (epi) && bitmap_empty_p (pro)))\n+\tfprintf (dump_file, \"  bb %d\", bb->index);\n+\n+      if (dump_file && !bitmap_empty_p (epi))\n+\tdump_components (\"epi\", epi);\n+      if (dump_file && !bitmap_empty_p (pro))\n+\tdump_components (\"pro\", pro);\n+\n+      if (dump_file && !(bitmap_empty_p (epi) && bitmap_empty_p (pro)))\n+\tfprintf (dump_file, \"\\n\");\n+\n+      /* Put the code at the end of the BB, but before any final jump.  */\n+      if (!bitmap_empty_p (epi))\n+\t{\n+\t  start_sequence ();\n+\t  targetm.shrink_wrap.emit_epilogue_components (epi);\n+\t  rtx_insn *seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  if (control_flow_insn_p (last_insn))\n+\t    emit_insn_before (seq, last_insn);\n+\t  else\n+\t    emit_insn_after (seq, last_insn);\n+\n+\t  bitmap_ior (SW (bb)->tail_components, SW (bb)->tail_components, epi);\n+\t}\n+\n+      if (!bitmap_empty_p (pro))\n+\t{\n+\t  start_sequence ();\n+\t  targetm.shrink_wrap.emit_prologue_components (pro);\n+\t  rtx_insn *seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  if (control_flow_insn_p (last_insn))\n+\t    emit_insn_before (seq, last_insn);\n+\t  else\n+\t    emit_insn_after (seq, last_insn);\n+\n+\t  bitmap_ior (SW (bb)->tail_components, SW (bb)->tail_components, pro);\n+\t}\n+    }\n+\n+  sbitmap_free (pro);\n+  sbitmap_free (epi);\n+  sbitmap_free (tmp);\n+}\n+\n+/* Place prologues and epilogues for COMPONENTS on edges, if we haven't already\n+   placed them inside blocks directly.  */\n+static void\n+insert_prologue_epilogue_for_components (sbitmap components)\n+{\n+  sbitmap pro = sbitmap_alloc (SBITMAP_SIZE (components));\n+  sbitmap epi = sbitmap_alloc (SBITMAP_SIZE (components));\n+\n+  basic_block bb;\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      if (!bb->aux)\n+\tcontinue;\n+\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  /* Find which pro/epilogue components are needed on this edge.  */\n+\t  bitmap_and_compl (epi, SW (e->src)->has_components,\n+\t\t\t    SW (e->dest)->has_components);\n+\t  bitmap_and_compl (pro, SW (e->dest)->has_components,\n+\t\t\t    SW (e->src)->has_components);\n+\t  bitmap_and (epi, epi, components);\n+\t  bitmap_and (pro, pro, components);\n+\n+\t  /* Deselect those we already have put at the head or tail of the\n+\t     edge's dest resp. src.  */\n+\t  bitmap_and_compl (epi, epi, SW (e->dest)->head_components);\n+\t  bitmap_and_compl (pro, pro, SW (e->dest)->head_components);\n+\t  bitmap_and_compl (epi, epi, SW (e->src)->tail_components);\n+\t  bitmap_and_compl (pro, pro, SW (e->src)->tail_components);\n+\n+\t  if (!bitmap_empty_p (epi) || !bitmap_empty_p (pro))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"  %d->%d\", e->src->index,\n+\t\t\t   e->dest->index);\n+\t\t  dump_components (\"epi\", epi);\n+\t\t  dump_components (\"pro\", pro);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\n+\t      /* Put the epilogue components in place.  */\n+\t      start_sequence ();\n+\t      targetm.shrink_wrap.emit_epilogue_components (epi);\n+\t      rtx_insn *seq = get_insns ();\n+\t      end_sequence ();\n+\n+\t      if (e->flags & EDGE_SIBCALL)\n+\t\t{\n+\t\t  gcc_assert (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun));\n+\n+\t\t  rtx_insn *insn = BB_END (e->src);\n+\t\t  gcc_assert (CALL_P (insn) && SIBLING_CALL_P (insn));\n+\t\t  emit_insn_before (seq, insn);\n+\t\t}\n+\t      else if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\t{\n+\t\t  gcc_assert (e->flags & EDGE_FALLTHRU);\n+\t\t  basic_block new_bb = split_edge (e);\n+\t\t  emit_insn_after (seq, BB_END (new_bb));\n+\t\t}\n+\t      else\n+\t\tinsert_insn_on_edge (seq, e);\n+\n+\t      /* Put the prologue components in place.  */\n+\t      start_sequence ();\n+\t      targetm.shrink_wrap.emit_prologue_components (pro);\n+\t      seq = get_insns ();\n+\t      end_sequence ();\n+\n+\t      insert_insn_on_edge (seq, e);\n+\t    }\n+\t}\n+    }\n+\n+  sbitmap_free (pro);\n+  sbitmap_free (epi);\n+\n+  commit_edge_insertions ();\n+}\n+\n+/* The main entry point to this subpass.  FIRST_BB is where the prologue\n+   would be normally put.  */\n+void\n+try_shrink_wrapping_separate (basic_block first_bb)\n+{\n+  if (HAVE_cc0)\n+    return;\n+\n+  if (!(SHRINK_WRAPPING_ENABLED\n+\t&& flag_shrink_wrap_separate\n+\t&& optimize_function_for_speed_p (cfun)\n+\t&& targetm.shrink_wrap.get_separate_components))\n+    return;\n+\n+  /* We don't handle \"strange\" functions.  */\n+  if (cfun->calls_alloca\n+      || cfun->calls_setjmp\n+      || cfun->can_throw_non_call_exceptions\n+      || crtl->calls_eh_return\n+      || crtl->has_nonlocal_goto\n+      || crtl->saves_all_registers)\n+    return;\n+\n+  /* Ask the target what components there are.  If it returns NULL, don't\n+     do anything.  */\n+  sbitmap components = targetm.shrink_wrap.get_separate_components ();\n+  if (!components)\n+    return;\n+\n+  /* We need LIVE info.  */\n+  df_live_add_problem ();\n+  df_live_set_all_dirty ();\n+  df_analyze ();\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n+  init_separate_shrink_wrap (components);\n+\n+  sbitmap_iterator sbi;\n+  unsigned int j;\n+  EXECUTE_IF_SET_IN_BITMAP (components, 0, j, sbi)\n+    place_prologue_for_one_component (j, first_bb);\n+\n+  spread_components (first_bb);\n+\n+  disqualify_problematic_components (components);\n+\n+  /* Don't separately shrink-wrap anything where the \"main\" prologue will\n+     go; the target code can often optimize things if it is presented with\n+     all components together (say, if it generates store-multiple insns).  */\n+  bitmap_and_compl (components, components, SW (first_bb)->has_components);\n+\n+  if (bitmap_empty_p (components))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not wrapping anything separately.\\n\");\n+    }\n+  else\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"The components we wrap separately are\");\n+\t  dump_components (\"sep\", components);\n+\t  fprintf (dump_file, \"\\n\");\n+\n+\t  fprintf (dump_file, \"... Inserting common heads...\\n\");\n+\t}\n+\n+      emit_common_heads_for_components (components);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"... Inserting common tails...\\n\");\n+\n+      emit_common_tails_for_components (components);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"... Inserting the more difficult ones...\\n\");\n+\n+      insert_prologue_epilogue_for_components (components);\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"... Done.\\n\");\n+\n+      targetm.shrink_wrap.set_handled_components (components);\n+\n+      crtl->shrink_wrapped_separate = true;\n+    }\n+\n+  fini_separate_shrink_wrap ();\n+\n+  sbitmap_free (components);\n+  free_dominance_info (CDI_DOMINATORS);\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  if (crtl->shrink_wrapped_separate)\n+    {\n+      df_live_set_all_dirty ();\n+      df_analyze ();\n+    }\n+}"}, {"sha": "05fcb41277a79e51ca40e79dcbc734c909cad915", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c997869f1620b733efd4d6ef344deb0377566510/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c997869f1620b733efd4d6ef344deb0377566510/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=c997869f1620b733efd4d6ef344deb0377566510", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n /* In shrink-wrap.c.  */\n extern bool requires_stack_frame_p (rtx_insn *, HARD_REG_SET, HARD_REG_SET);\n extern void try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq);\n+extern void try_shrink_wrapping_separate (basic_block first_bb);\n #define SHRINK_WRAPPING_ENABLED \\\n   (flag_shrink_wrap && targetm.have_simple_return ())\n "}]}