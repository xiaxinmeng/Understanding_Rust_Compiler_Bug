{"sha": "f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmY2Y2MmI2YWI2MzVkNjQ2NGZkMzhhNTdlMWExM2QxZDM4NTM5ZQ==", "commit": {"author": {"name": "Jeffrey Oldham", "email": "oldham@codesourcery.com", "date": "2000-08-05T04:17:23Z"}, "committer": {"name": "Jeffrey D. Oldham", "email": "oldham@gcc.gnu.org", "date": "2000-08-05T04:17:23Z"}, "message": "cxxabi.h (__pbase_type_info): Changed member names to match specifications.\n\n2000-08-04  Jeffrey D. Oldham  <oldham@codesourcery.com>\n\n\t* inc/cxxabi.h (__pbase_type_info): Changed member names to match\n\tspecifications.\n\t(__pointer_to_member_type_info): Likewise.\n\t(__base_class_info): Likewise.\n\t(__class_type_info): Likewise.\n\t(__si_class_type_info): Likewise.\n\t(__vmi_class_type_info): Likewise.\n\t* tinfo.cc (__si_class_type_info::__do_find_public_src):\n\tChanged member names to match specifications.\n\t(__vmi_class_type_info::__do_find_public_src): Likewise.\n\t(__si_class_type_info::__do_dyncast): Likewise.\n\t(__vmi_class_type_info::__do_dyncast): Likewise.\n\t(__si_class_type_info::__do_upcast): Likewise.\n\t(__vmi_class_type_info::__do_upcast): Likewise.\n\t* tinfo2.cc (__pbase_type_info::__do_catch): Likewise.\n\t(__pbase_type_info::__pointer_catch): Likewise.\n\t(__pointer_type_info::__pointer_catch): Likewise.\n\t(__pointer_to_member_type_info::__pointer_catch): Likewise.\n\nFrom-SVN: r35503", "tree": {"sha": "c98608f0960c535a4b9214b9b9f7301c2e0b2fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c98608f0960c535a4b9214b9b9f7301c2e0b2fb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/comments", "author": null, "committer": null, "parents": [{"sha": "8cab40f72e6434f3c724492caaf86716c2083c87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cab40f72e6434f3c724492caaf86716c2083c87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cab40f72e6434f3c724492caaf86716c2083c87"}], "stats": {"total": 158, "additions": 90, "deletions": 68}, "files": [{"sha": "6d52df92934eba896442ae1e7ad008600ea6e01d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "patch": "@@ -1,3 +1,25 @@\n+2000-08-04  Jeffrey Oldham  <oldham@codesourcery.com>\n+\n+\t* inc/cxxabi.h (__pbase_type_info): Changed member names to match\n+\tspecifications.\n+\t(__pointer_to_member_type_info): Likewise.\n+\t(__base_class_info): Likewise.\n+\t(__class_type_info): Likewise.\n+\t(__si_class_type_info): Likewise.\n+\t(__vmi_class_type_info): Likewise.\n+\t* tinfo.cc (__si_class_type_info::__do_find_public_src):\n+\tChanged member names to match specifications.\n+\t(__vmi_class_type_info::__do_find_public_src): Likewise.\n+\t(__si_class_type_info::__do_dyncast): Likewise.\n+\t(__vmi_class_type_info::__do_dyncast): Likewise.\n+\t(__si_class_type_info::__do_upcast): Likewise.\n+\t(__vmi_class_type_info::__do_upcast): Likewise.\n+\t* tinfo2.cc (__pbase_type_info::__do_catch): Likewise.\n+\t(__pbase_type_info::__pointer_catch): Likewise.\n+\t(__pointer_type_info::__pointer_catch): Likewise.\n+\t(__pointer_to_member_type_info::__pointer_catch): Likewise.\n+\n+\n 2000-08-04  Zack Weinberg  <zack@wolery.cumb.org>\n \n         * Make-lang.in (cc1plus): Depend on $(BACKEND), not stamp-objlist."}, {"sha": "6e645530b0f87befc04e1bb37b5315884e5e0d00", "filename": "gcc/cp/inc/cxxabi.h", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "patch": "@@ -122,8 +122,8 @@ class __pbase_type_info\n {\n /* abi defined member variables */\n public:\n-  int quals;                    /* qualification of the target object */\n-  const std::type_info *type;   /* type of pointed to object */\n+  unsigned int __qualifier_flags; /* qualification of the target object */\n+  const std::type_info *__pointee;   /* type of pointed to object */\n \n /* abi defined member functions */\n public:\n@@ -132,17 +132,17 @@ class __pbase_type_info\n   explicit __pbase_type_info (const char *__n,\n                                 int __quals,\n                                 const std::type_info *__type)\n-    : std::type_info (__n), quals (__quals), type (__type)\n+    : std::type_info (__n), __qualifier_flags (__quals), __pointee (__type)\n     { }\n \n /* implementation defined types */\n public:\n-  enum quals_masks {\n-    const_mask = 0x1,\n-    volatile_mask = 0x2,\n-    restrict_mask = 0x4,\n-    incomplete_mask = 0x8,\n-    incomplete_class_mask = 0x10\n+  enum __qualifier_masks {\n+    __const_mask = 0x1,\n+    __volatile_mask = 0x2,\n+    __restrict_mask = 0x4,\n+    __incomplete_mask = 0x8,\n+    __incomplete_class_mask = 0x10\n   };\n \n /* implementation defined member functions */\n@@ -186,7 +186,7 @@ class __pointer_to_member_type_info\n {\n /* abi defined member variables */\n public:\n-  const __class_type_info *klass;   /* class of the member */\n+  __class_type_info *__context_class;   /* class of the member */\n \n /* abi defined member functions */\n public:\n@@ -195,8 +195,8 @@ class __pointer_to_member_type_info\n   explicit __pointer_to_member_type_info (const char *__n,\n                                           int __quals,\n                                           const std::type_info *__type,\n-                                          const __class_type_info *__klass)\n-    : __pbase_type_info (__n, __quals, __type), klass (__klass)\n+                                          __class_type_info *__klass)\n+    : __pbase_type_info (__n, __quals, __type), __context_class (__klass)\n     { }\n \n /* implementation defined member functions */\n@@ -213,29 +213,29 @@ class __base_class_info\n {\n /* abi defined member variables */\n public:\n-  const __class_type_info *base;    /* base class type */\n-  long vmi_offset_flags;            /* offset and info */\n+  const __class_type_info *__base;    /* base class type */\n+  long __offset_flags;            /* offset and info */\n \n /* implementation defined types */\n public:\n-  enum vmi_masks {\n-    virtual_mask = 0x1,\n-    public_mask = 0x2,\n+  enum __offset_flags_masks {\n+    __virtual_mask = 0x1,\n+    __public_mask = 0x2,\n     hwm_bit = 2,\n     offset_shift = 8          /* bits to shift offset by */\n   };\n   \n /* implementation defined member functions */\n public:\n   bool __is_virtual_p () const\n-    { return vmi_offset_flags & virtual_mask; }\n+    { return __offset_flags & __virtual_mask; }\n   bool __is_public_p () const\n-    { return vmi_offset_flags & public_mask; }\n+    { return __offset_flags & __public_mask; }\n   __PTRDIFF_TYPE__ __offset () const\n     { \n       // This shift, being of a signed type, is implementation defined. GCC\n       // implements such shifts as arithmetic, which is what we want.\n-      return static_cast<__PTRDIFF_TYPE__> (vmi_offset_flags) >> offset_shift;\n+      return static_cast<__PTRDIFF_TYPE__> (__offset_flags) >> offset_shift;\n     }\n };\n \n@@ -264,8 +264,8 @@ class __class_type_info\n                                 /* publicly) */\n     __contained_ambig,          /* contained ambiguously */\n     \n-    __contained_virtual_mask = __base_class_info::virtual_mask, /* via a virtual path */\n-    __contained_public_mask = __base_class_info::public_mask,   /* via a public path */\n+    __contained_virtual_mask = __base_class_info::__virtual_mask, /* via a virtual path */\n+    __contained_public_mask = __base_class_info::__public_mask,   /* via a public path */\n     __contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n     \n     __contained_private = __contained_mask,\n@@ -334,16 +334,16 @@ class __si_class_type_info\n   : public __class_type_info\n {\n /* abi defined member variables */\n-protected:\n-  const __class_type_info *base;    /* base type */\n+public:\n+  const __class_type_info *__base_type;\n \n /* abi defined member functions */\n public:\n   virtual ~__si_class_type_info ();\n public:\n   explicit __si_class_type_info (const char *__n,\n                                  const __class_type_info *__base)\n-    : __class_type_info (__n), base (__base)\n+    : __class_type_info (__n), __base_type (__base)\n     { }\n \n /* implementation defined member functions */\n@@ -368,9 +368,9 @@ class __si_class_type_info\n class __vmi_class_type_info : public __class_type_info {\n /* abi defined member variables */\n public:\n-  int vmi_flags;                  /* details about the class heirarchy */\n-  int vmi_base_count;             /* number of direct bases */\n-  __base_class_info vmi_bases[1]; /* array of bases */\n+  unsigned int __flags;         /* details about the class heirarchy */\n+  unsigned int __base_count;    /* number of direct bases */\n+  __base_class_info const __base_info[1]; /* array of bases */\n   /* The array of bases uses the trailing array struct hack\n      so this class is not constructable with a normal constructor. It is\n      internally generated by the compiler. */\n@@ -380,15 +380,15 @@ class __vmi_class_type_info : public __class_type_info {\n   virtual ~__vmi_class_type_info ();\n public:\n   explicit __vmi_class_type_info (const char *__n,\n-                                  int __flags)\n-    : __class_type_info (__n), vmi_flags (__flags), vmi_base_count (0)\n+                                  int ___flags)\n+    : __class_type_info (__n), __flags (___flags), __base_count (0)\n     { }\n \n /* implementation defined types */\n public:\n-  enum vmi_flags_masks {\n-    non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n-    diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n+  enum __flags_masks {\n+    __non_diamond_repeat_mask = 0x1,   /* distinct instance of repeated base */\n+    __diamond_shaped_mask = 0x2,       /* diamond shaped multiple inheritance */\n     non_public_base_mask = 0x4,      /* has non-public direct or indirect base */\n     public_base_mask = 0x8,          /* has public base (direct) */\n     "}, {"sha": "bb57bf8a50cb53542fa9b8d764daae7eb703cdc5", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "patch": "@@ -755,7 +755,7 @@ __do_find_public_src (ptrdiff_t src2dst,\n {\n   if (src_ptr == obj_ptr && *this == *src_type)\n     return __contained_public;\n-  return base->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+  return __base_type->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n }\n \n __class_type_info::__sub_kind __vmi_class_type_info::\n@@ -767,14 +767,14 @@ __do_find_public_src (ptrdiff_t src2dst,\n   if (obj_ptr == src_ptr && *this == *src_type)\n     return __contained_public;\n   \n-  for (size_t i = vmi_base_count; i--;)\n+  for (size_t i = __base_count; i--;)\n     {\n-      if (!vmi_bases[i].__is_public_p ())\n+      if (!__base_info[i].__is_public_p ())\n         continue; // Not public, can't be here.\n       \n       const void *base = obj_ptr;\n-      ptrdiff_t offset = vmi_bases[i].__offset ();\n-      bool is_virtual = vmi_bases[i].__is_virtual_p ();\n+      ptrdiff_t offset = __base_info[i].__offset ();\n+      bool is_virtual = __base_info[i].__is_virtual_p ();\n       \n       if (is_virtual)\n         {\n@@ -783,7 +783,7 @@ __do_find_public_src (ptrdiff_t src2dst,\n         }\n       base = convert_to_base (base, is_virtual, offset);\n       \n-      __sub_kind base_kind = vmi_bases[i].base->__do_find_public_src\n+      __sub_kind base_kind = __base_info[i].__base->__do_find_public_src\n                               (src2dst, base, src_type, src_ptr);\n       if (contained_p (base_kind))\n         {\n@@ -849,7 +849,7 @@ __do_dyncast (ptrdiff_t src2dst,\n       result.whole2src = access_path;\n       return false;\n     }\n-  return base->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n+  return __base_type->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n                              src_type, src_ptr, result);\n }\n \n@@ -872,7 +872,7 @@ __do_dyncast (ptrdiff_t src2dst,\n               __dyncast_result &__restrict result) const\n {\n   if (result.whole_details & __flags_unknown_mask)\n-    result.whole_details = vmi_flags;\n+    result.whole_details = __flags;\n   \n   if (obj_ptr == src_ptr && *this == *src_type)\n     {\n@@ -894,23 +894,23 @@ __do_dyncast (ptrdiff_t src2dst,\n     }\n \n   bool result_ambig = false;\n-  for (size_t i = vmi_base_count; i--;)\n+  for (size_t i = __base_count; i--;)\n     {\n       __dyncast_result result2 (result.whole_details);\n       void const *base = obj_ptr;\n       __sub_kind base_access = access_path;\n-      ptrdiff_t offset = vmi_bases[i].__offset ();\n-      bool is_virtual = vmi_bases[i].__is_virtual_p ();\n+      ptrdiff_t offset = __base_info[i].__offset ();\n+      bool is_virtual = __base_info[i].__is_virtual_p ();\n       \n       if (is_virtual)\n         base_access = __sub_kind (base_access | __contained_virtual_mask);\n       base = convert_to_base (base, is_virtual, offset);\n \n-      if (!vmi_bases[i].__is_public_p ())\n+      if (!__base_info[i].__is_public_p ())\n         {\n           if (src2dst == -2 &&\n               !(result.whole_details\n-                & (non_diamond_repeat_mask | diamond_shaped_mask)))\n+                & (__non_diamond_repeat_mask | __diamond_shaped_mask)))\n             // The hierarchy has no duplicate bases (which might ambiguate\n             // things) and where we started is not a public base of what we\n             // want (so it cannot be a downcast). There is nothing of interest\n@@ -920,7 +920,7 @@ __do_dyncast (ptrdiff_t src2dst,\n         }\n       \n       bool result2_ambig\n-          = vmi_bases[i].base->__do_dyncast (src2dst, base_access,\n+          = __base_info[i].__base->__do_dyncast (src2dst, base_access,\n                                              dst_type, base,\n                                              src_type, src_ptr, result2);\n       result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n@@ -942,7 +942,7 @@ __do_dyncast (ptrdiff_t src2dst,\n           result.whole2dst = result2.whole2dst;\n           result_ambig = result2_ambig;\n           if (result.dst_ptr && result.whole2src != __unknown\n-              && !(vmi_flags & non_diamond_repeat_mask))\n+              && !(__flags & __non_diamond_repeat_mask))\n             // Found dst and src and we don't have repeated bases.\n             return result_ambig;\n         }\n@@ -969,7 +969,7 @@ __do_dyncast (ptrdiff_t src2dst,\n           \n           if (contained_p (result.whole2src)\n               && (!virtual_p (result.whole2src)\n-                  || !(result.whole_details & diamond_shaped_mask)))\n+                  || !(result.whole_details & __diamond_shaped_mask)))\n             {\n               // We already found SRC_PTR as a base of most derived, and\n               // either it was non-virtual, or the whole heirarchy is\n@@ -986,7 +986,7 @@ __do_dyncast (ptrdiff_t src2dst,\n                 ;// already calculated\n               else if (contained_p (new_sub_kind)\n                        && (!virtual_p (new_sub_kind)\n-                           || !(vmi_flags & diamond_shaped_mask)))\n+                           || !(__flags & __diamond_shaped_mask)))\n                 // Already found inside the other choice, and it was\n                 // non-virtual or we are not diamond shaped.\n                 old_sub_kind = __not_contained;\n@@ -998,7 +998,7 @@ __do_dyncast (ptrdiff_t src2dst,\n                 ;// already calculated\n               else if (contained_p (old_sub_kind)\n                        && (!virtual_p (old_sub_kind)\n-                           || !(vmi_flags & diamond_shaped_mask)))\n+                           || !(__flags & __diamond_shaped_mask)))\n                 // Already found inside the other choice, and it was\n                 // non-virtual or we are not diamond shaped.\n                 new_sub_kind = __not_contained;\n@@ -1075,7 +1075,7 @@ __do_upcast (const __class_type_info *dst, const void *obj_ptr,\n   if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n     return true;\n   \n-  return base->__do_upcast (dst, obj_ptr, result);\n+  return __base_type->__do_upcast (dst, obj_ptr, result);\n }\n \n bool __vmi_class_type_info::\n@@ -1087,27 +1087,27 @@ __do_upcast (const __class_type_info *dst, const void *obj_ptr,\n   \n   int src_details = result.src_details;\n   if (src_details & __flags_unknown_mask)\n-    src_details = vmi_flags;\n+    src_details = __flags;\n   \n-  for (size_t i = vmi_base_count; i--;)\n+  for (size_t i = __base_count; i--;)\n     {\n       __upcast_result result2 (src_details);\n       const void *base = obj_ptr;\n-      ptrdiff_t offset = vmi_bases[i].__offset ();\n-      bool is_virtual = vmi_bases[i].__is_virtual_p ();\n-      bool is_public = vmi_bases[i].__is_public_p ();\n+      ptrdiff_t offset = __base_info[i].__offset ();\n+      bool is_virtual = __base_info[i].__is_virtual_p ();\n+      bool is_public = __base_info[i].__is_public_p ();\n       \n-      if (!is_public && !(src_details & non_diamond_repeat_mask))\n+      if (!is_public && !(src_details & __non_diamond_repeat_mask))\n         // original cannot have an ambiguous base, so skip private bases\n         continue;\n \n       if (base)\n         base = convert_to_base (base, is_virtual, offset);\n       \n-      if (vmi_bases[i].base->__do_upcast (dst, base, result2))\n+      if (__base_info[i].__base->__do_upcast (dst, base, result2))\n         {\n           if (result2.base_type == nonvirtual_base_type && is_virtual)\n-            result2.base_type = vmi_bases[i].base;\n+            result2.base_type = __base_info[i].__base;\n           if (contained_p (result2.part2dst) && !is_public)\n             result2.part2dst = __sub_kind (result2.part2dst & ~__contained_public_mask);\n           \n@@ -1119,14 +1119,14 @@ __do_upcast (const __class_type_info *dst, const void *obj_ptr,\n               \n               if (result.part2dst & __contained_public_mask)\n                 {\n-                  if (!(vmi_flags & non_diamond_repeat_mask))\n+                  if (!(__flags & __non_diamond_repeat_mask))\n                     return true;  // cannot have an ambiguous other base\n                 }\n               else\n                 {\n                   if (!virtual_p (result.part2dst))\n                     return true; // cannot have another path\n-                  if (!(vmi_flags & diamond_shaped_mask))\n+                  if (!(__flags & __diamond_shaped_mask))\n                     return true; // cannot have a more accessible path\n                 }\n             }"}, {"sha": "7c9a764134c305ef38363295a5844b1a2269832b", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9fcf62b6ab635d6464fd38a57e1a13d1d38539e/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=f9fcf62b6ab635d6464fd38a57e1a13d1d38539e", "patch": "@@ -166,11 +166,11 @@ __do_catch (const type_info *thr_type,\n   const __pbase_type_info *thrown_type =\n     static_cast <const __pbase_type_info *> (thr_type);\n   \n-  if (thrown_type->quals & ~quals)\n+  if (thrown_type->__qualifier_flags & ~__qualifier_flags)\n     // We're less qualified.\n     return false;\n   \n-  if (!(quals & const_mask))\n+  if (!(__qualifier_flags & __const_mask))\n     outer &= ~1;\n   \n   return __pointer_catch (thrown_type, thr_obj, outer);\n@@ -181,18 +181,18 @@ __pointer_catch (const __pbase_type_info *thrown_type,\n                  void **thr_obj,\n                  unsigned outer) const\n {\n-  return type->__do_catch (thrown_type->type, thr_obj, outer + 2);\n+  return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);\n }\n \n bool __pointer_type_info::\n __pointer_catch (const __pbase_type_info *thrown_type,\n                  void **thr_obj,\n                  unsigned outer) const\n {\n-  if (outer < 2 && *type == typeid (void))\n+  if (outer < 2 && *__pointee == typeid (void))\n     {\n       // conversion to void\n-      return !thrown_type->type->__is_function_p ();\n+      return !thrown_type->__pointee->__is_function_p ();\n     }\n   \n   return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);\n@@ -208,7 +208,7 @@ __pointer_catch (const __pbase_type_info *thr_type,\n   const __pointer_to_member_type_info *thrown_type =\n     static_cast <const __pointer_to_member_type_info *> (thr_type);\n   \n-  if (*klass != *thrown_type->klass)\n+  if (*__context_class != *thrown_type->__context_class)\n     return false;     // not pointers to member of same class\n   \n   return __pbase_type_info::__pointer_catch (thrown_type, thr_obj, outer);"}]}