{"sha": "6d4ede5fc2e335a76d7544cc068c05e733f97d9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0ZWRlNWZjMmUzMzVhNzZkNzU0NGNjMDY4YzA1ZTczM2Y5N2Q5YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-08-18T07:55:23Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-08-18T07:55:23Z"}, "message": "* config/mips/mips.md: Renumber unspecs.  Clean up comments.\n\nFrom-SVN: r70533", "tree": {"sha": "c11dea281f38e9cb8853bf83981323d335c79c18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c11dea281f38e9cb8853bf83981323d335c79c18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d4ede5fc2e335a76d7544cc068c05e733f97d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4ede5fc2e335a76d7544cc068c05e733f97d9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4ede5fc2e335a76d7544cc068c05e733f97d9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4ede5fc2e335a76d7544cc068c05e733f97d9a/comments", "author": null, "committer": null, "parents": [{"sha": "aba1f3707b2ef30f15175f7f2b9eb58cba386655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aba1f3707b2ef30f15175f7f2b9eb58cba386655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aba1f3707b2ef30f15175f7f2b9eb58cba386655"}], "stats": {"total": 240, "additions": 90, "deletions": 150}, "files": [{"sha": "84382a7026caebf03695b7589f45c69ba7c1da23", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4ede5fc2e335a76d7544cc068c05e733f97d9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4ede5fc2e335a76d7544cc068c05e733f97d9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d4ede5fc2e335a76d7544cc068c05e733f97d9a", "patch": "@@ -1,3 +1,7 @@\n+2003-08-18  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.md: Renumber unspecs.  Clean up comments.\n+\n 2003-08-17  Roger Sayle  <roger@eyesopen.com>\n \n \t* simplify-rtx.c (associative_constant_p): New function to test"}, {"sha": "5a770b82ae169ce578aa2e288fdae2328399a9aa", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 86, "deletions": 150, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d4ede5fc2e335a76d7544cc068c05e733f97d9a/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d4ede5fc2e335a76d7544cc068c05e733f97d9a/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=6d4ede5fc2e335a76d7544cc068c05e733f97d9a", "patch": "@@ -30,29 +30,29 @@\n   [(UNSPEC_LOAD_DF_LOW\t\t 0)\n    (UNSPEC_LOAD_DF_HIGH\t\t 1)\n    (UNSPEC_STORE_DF_HIGH\t 2)\n-   (UNSPEC_GET_FNADDR\t\t 4)\n-   (UNSPEC_BLOCKAGE\t\t 6)\n-   (UNSPEC_CPRESTORE\t\t 8)\n-   (UNSPEC_EH_RECEIVER\t\t10)\n-   (UNSPEC_EH_RETURN\t\t11)\n-   (UNSPEC_CONSTTABLE_QI\t12)\n-   (UNSPEC_CONSTTABLE_HI\t13)\n-   (UNSPEC_CONSTTABLE_SI\t14)\n-   (UNSPEC_CONSTTABLE_DI\t15)\n-   (UNSPEC_CONSTTABLE_SF\t16)\n-   (UNSPEC_CONSTTABLE_DF\t17)\n-   (UNSPEC_ALIGN_2\t\t18)\n-   (UNSPEC_ALIGN_4\t\t19)\n-   (UNSPEC_ALIGN_8\t\t20)\n-   (UNSPEC_HIGH\t\t\t22)\n-   (UNSPEC_LWL\t\t\t23)\n-   (UNSPEC_LWR\t\t\t24)\n-   (UNSPEC_SWL\t\t\t25)\n-   (UNSPEC_SWR\t\t\t26)\n-   (UNSPEC_LDL\t\t\t27)\n-   (UNSPEC_LDR\t\t\t28)\n-   (UNSPEC_SDL\t\t\t29)\n-   (UNSPEC_SDR\t\t\t30)\n+   (UNSPEC_GET_FNADDR\t\t 3)\n+   (UNSPEC_BLOCKAGE\t\t 4)\n+   (UNSPEC_CPRESTORE\t\t 5)\n+   (UNSPEC_EH_RECEIVER\t\t 6)\n+   (UNSPEC_EH_RETURN\t\t 7)\n+   (UNSPEC_CONSTTABLE_QI\t 8)\n+   (UNSPEC_CONSTTABLE_HI\t 9)\n+   (UNSPEC_CONSTTABLE_SI\t10)\n+   (UNSPEC_CONSTTABLE_DI\t11)\n+   (UNSPEC_CONSTTABLE_SF\t12)\n+   (UNSPEC_CONSTTABLE_DF\t13)\n+   (UNSPEC_ALIGN_2\t\t14)\n+   (UNSPEC_ALIGN_4\t\t15)\n+   (UNSPEC_ALIGN_8\t\t16)\n+   (UNSPEC_HIGH\t\t\t17)\n+   (UNSPEC_LWL\t\t\t18)\n+   (UNSPEC_LWR\t\t\t19)\n+   (UNSPEC_SWL\t\t\t20)\n+   (UNSPEC_SWR\t\t\t21)\n+   (UNSPEC_LDL\t\t\t22)\n+   (UNSPEC_LDR\t\t\t23)\n+   (UNSPEC_SDL\t\t\t24)\n+   (UNSPEC_SDR\t\t\t25)\n \n    ;; Constants used in relocation unspecs.  RELOC_GOT_PAGE and RELOC_GOT_DISP\n    ;; are really only available for n32 and n64.  However, it is convenient\n@@ -69,7 +69,6 @@\n    (RELOC_LOADGP_HI\t\t108)\n    (RELOC_LOADGP_LO\t\t109)])\n \f\n-\n ;; ....................\n ;;\n ;;\tAttributes\n@@ -81,10 +80,12 @@\n (define_attr \"jal\" \"unset,direct,indirect\"\n   (const_string \"unset\"))\n \n-;; True for multi-instruction jal macros.  jal is always a macro\n-;; in SVR4 PIC since it includes an instruction to restore $gp.\n-;; Direct jals are also macros in NewABI PIC since they load the\n-;; target address into $25.\n+;; This attribute is YES if the instruction is a jal macro (not a\n+;; real jal instruction).\n+;;\n+;; jal is always a macro in SVR4 PIC since it includes an instruction to\n+;; restore $gp.  Direct jals are also macros in NewABI PIC since they\n+;; load the target address into $25.\n (define_attr \"jal_macro\" \"no,yes\"\n   (cond [(eq_attr \"jal\" \"direct\")\n \t (symbol_ref \"TARGET_ABICALLS != 0\")\n@@ -129,37 +130,62 @@\n \t(const_string \"unknown\")))\n \n ;; Main data type used by the insn\n-(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF,FPSW\" (const_string \"unknown\"))\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,SF,DF,FPSW\"\n+  (const_string \"unknown\"))\n \n ;; Is this an extended instruction in mips16 mode?\n (define_attr \"extended_mips16\" \"no,yes\"\n   (const_string \"no\"))\n \n-;; Length (in # of bytes).  A conditional branch is allowed only to a\n-;; location within a signed 18-bit offset of the delay slot.  If that\n-;; provides too smal a range, we use the `j' instruction.  This\n-;; instruction takes a 28-bit value, but that value is not an offset.\n-;; Instead, it's bitwise-ored with the high-order four bits of the\n-;; instruction in the delay slot, which means it cannot be used to\n-;; cross a 256MB boundary.  We could fall back back on the jr,\n-;; instruction which allows full access to the entire address space,\n-;; but we do not do so at present.\n-\n+;; Length of instruction in bytes.\n (define_attr \"length\" \"\"\n-   (cond [(eq_attr \"type\" \"branch\")\n+   (cond [;; Direct branch instructions have a range of [-0x40000,0x3fffc].\n+\t  ;; If a branch is outside this range, we have a choice of two\n+\t  ;; sequences.  For PIC, an out-of-range branch like:\n+\t  ;;\n+\t  ;;\tbne\tr1,r2,target\n+\t  ;;\tdslot\n+\t  ;;\n+\t  ;; becomes the equivalent of:\n+\t  ;;\n+\t  ;;\tbeq\tr1,r2,1f\n+\t  ;;\tdslot\n+\t  ;;\tla\t$at,target\n+\t  ;;\tjr\t$at\n+\t  ;;\tnop\n+\t  ;; 1:\n+\t  ;;\n+\t  ;; where the load address can be up to three instructions long\n+\t  ;; (lw, nop, addiu).\n+\t  ;;\n+\t  ;; The non-PIC case is similar except that we use a direct\n+\t  ;; jump instead of an la/jr pair.  Since the target of this\n+\t  ;; jump is an absolute 28-bit bit address (the other bits\n+\t  ;; coming from the address of the delay slot) this form cannot\n+\t  ;; cross a 256MB boundary.  We could provide the option of\n+\t  ;; using la/jr in this case too, but we do not do so at\n+\t  ;; present.\n+\t  ;;\n+\t  ;; Note that this value does not account for the delay slot\n+\t  ;; instruction, whose length is added separately.  If the RTL\n+\t  ;; pattern has no explicit delay slot, mips_adjust_insn_length\n+\t  ;; will add the length of the implicit nop.\n+\t  (eq_attr \"type\" \"branch\")\n           (cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 4))))\n                      (const_int 131072))\n                  (const_int 4)\n \t\t (ne (symbol_ref \"flag_pic && ! TARGET_EMBEDDED_PIC\")\n \t\t     (const_int 0))\n \t\t (const_int 24)\n \t\t ] (const_int 12))\n+\n \t  (eq_attr \"type\" \"const\")\n \t  (symbol_ref \"mips_const_insns (operands[1]) * 4\")\n \t  (eq_attr \"type\" \"load\")\n \t  (symbol_ref \"mips_fetch_insns (operands[1]) * 4\")\n \t  (eq_attr \"type\" \"store\")\n \t  (symbol_ref \"mips_fetch_insns (operands[0]) * 4\")\n+\n \t  ;; In the worst case, a call macro will take 8 instructions:\n \t  ;;\n \t  ;;\t lui $25,%call_hi(FOO)\n@@ -172,9 +198,11 @@\n \t  ;;\t nop\n \t  (eq_attr \"jal_macro\" \"yes\")\n \t  (const_int 32)\n+\n \t  (and (eq_attr \"extended_mips16\" \"yes\")\n \t       (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n \t  (const_int 8)\n+\n \t  (and (eq_attr \"type\" \"idiv\")\n \t       (ne (symbol_ref \"TARGET_CHECK_ZERO_DIV\") (const_int 0)))\n \t  (cond [(ne (symbol_ref \"TARGET_MIPS16\") (const_int 0))\n@@ -184,16 +212,6 @@\n \n ;; Attribute describing the processor.  This attribute must match exactly\n ;; with the processor_type enumeration in mips.h.\n-\n-;; Attribute describing the processor\n-;; (define_attr \"cpu\" \"default,r3000,r6000,r4000\"\n-;;   (const\n-;;    (cond [(eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R3000\"))   (const_string \"r3000\")\n-;;           (eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R4000\"))   (const_string \"r4000\")\n-;;           (eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R6000\"))   (const_string \"r6000\")]\n-;;          (const_string \"default\"))))\n-\n-;; ??? Fix everything that tests this attribute.\n (define_attr \"cpu\"\n   \"default,4kc,5kc,20kc,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sr71000\"\n   (const (symbol_ref \"mips_tune\")))\n@@ -239,23 +257,19 @@\n \t\t(const_string \"no\")))\n \n ;; Attribute defining whether or not we can use the branch-likely instructions\n-\n (define_attr \"branch_likely\" \"no,yes\"\n   (const\n    (if_then_else (ne (symbol_ref \"GENERATE_BRANCHLIKELY\") (const_int 0))\n \t\t (const_string \"yes\")\n \t\t (const_string \"no\"))))\n \n-\n ;; Describe a user's asm statement.\n (define_asm_attributes\n   [(set_attr \"type\" \"multi\")])\n-\n \f\n-\n ;; .........................\n ;;\n-;;\tDelay slots, can't describe load/fcmp/xfer delay slots here\n+;;\tBranch, call and jump delay slots\n ;;\n ;; .........................\n \n@@ -276,9 +290,7 @@\n   [(eq_attr \"can_delay\" \"yes\")\n    (nil)\n    (nil)])\n-\n \f\n-\n ;; .........................\n ;;\n ;;\tFunctional units\n@@ -593,41 +605,14 @@\n        (and (eq_attr \"mode\" \"DF\") (eq_attr \"cpu\" \"r4300\")))\n   58 58)\n \f\n-;; The following functional units do not use the cpu type, and use\n-;; much less memory in genattrtab.c.\n-\n-;; (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"load\")                                3 0)\n-;; (define_function_unit \"memory\"   1 0 (eq_attr \"type\" \"store\")                               1 0)\n-;;\n-;; (define_function_unit \"fp_comp\"  1 0 (eq_attr \"type\" \"fcmp\")                                2 0)\n-;;\n-;; (define_function_unit \"transfer\" 1 0 (eq_attr \"type\" \"xfer\")                                2 0)\n-;; (define_function_unit \"transfer\" 1 0 (eq_attr \"type\" \"hilo\")                                3 0)\n-;;\n-;; (define_function_unit \"imuldiv\"  1 1 (eq_attr \"type\" \"imul\")                               17 0)\n-;; (define_function_unit \"imuldiv\"  1 1 (eq_attr \"type\" \"idiv\")                               38 0)\n-;;\n-;; (define_function_unit \"adder\"    1 1 (eq_attr \"type\" \"fadd\")                                4 0)\n-;; (define_function_unit \"adder\"    1 1 (eq_attr \"type\" \"fabs,fneg\")                           2 0)\n-;;\n-;; (define_function_unit \"mult\"     1 1 (and (eq_attr \"type\" \"fmul\") (eq_attr \"mode\" \"SF\"))    7 0)\n-;; (define_function_unit \"mult\"     1 1 (and (eq_attr \"type\" \"fmul\") (eq_attr \"mode\" \"DF\"))    8 0)\n-;;\n-;; (define_function_unit \"divide\"   1 1 (and (eq_attr \"type\" \"fdiv\") (eq_attr \"mode\" \"SF\"))   23 0)\n-;; (define_function_unit \"divide\"   1 1 (and (eq_attr \"type\" \"fdiv\") (eq_attr \"mode\" \"DF\"))   36 0)\n-;;\n-;; (define_function_unit \"sqrt\"     1 1 (and (eq_attr \"type\" \"fsqrt\") (eq_attr \"mode\" \"SF\"))  54 0)\n-;; (define_function_unit \"sqrt\"     1 1 (and (eq_attr \"type\" \"fsqrt\") (eq_attr \"mode\" \"DF\")) 112 0)\n-\f\n ;; Include scheduling descriptions.\n \n (include \"5400.md\")\n (include \"5500.md\")\n (include \"7000.md\")\n (include \"9000.md\")\n (include \"sr71k.md\")\n-\n-\n+\f\n ;;\n ;;  ....................\n ;;\n@@ -661,10 +646,6 @@\n   DONE;\n }\")\n \n-;; Match a TRAP_IF with 2nd arg of 0.  The div_trap_* insns match a\n-;; 2nd arg of any CONST_INT, so this insn must appear first.\n-;; gen_div_trap always generates TRAP_IF with 2nd arg of 6 or 7.\n-\n (define_insn \"\"\n   [(trap_if (match_operator 0 \"trap_cmp_op\"\n                             [(match_operand:SI 1 \"reg_or_0_operand\" \"d\")\n@@ -1224,7 +1205,6 @@\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))\n \t\t (const_int 4)])])\n-\n \f\n ;;\n ;;  ....................\n@@ -2504,6 +2484,7 @@\n   { return mips_output_division (\"ddivu\\\\t$0,%1,%2\", operands); }\n   [(set_attr \"type\"\t\"idiv\")\n    (set_attr \"mode\"\t\"DI\")])\n+\f\n ;;\n ;;  ....................\n ;;\n@@ -2544,7 +2525,6 @@\n   \"rsqrt.s\\\\t%0,%2\"\n   [(set_attr \"type\"\t\"frsqrt\")\n    (set_attr \"mode\"\t\"SF\")])\n-\n \f\n ;;\n ;;  ....................\n@@ -2616,7 +2596,6 @@\n   \"abs.s\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fabs\")\n    (set_attr \"mode\"\t\"SF\")])\n-\n \f\n ;;\n ;;  ....................\n@@ -2693,9 +2672,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set_attr \"type\"\t\"multi\")\n    (set_attr \"mode\"\t\"DI\")\n    (set_attr \"length\"\t\"28\")])\n-\n \f\n-\n ;;\n ;;  ...................\n ;;\n@@ -2719,7 +2696,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"dclz\\\\t%0,%1\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"mode\" \"DI\")])\n-\n+\f\n ;;\n ;;  ....................\n ;;\n@@ -2834,7 +2811,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;  ....................\n ;;\n \n-;; Many of these instructions uses trivial define_expands, because we\n+;; Many of these instructions use trivial define_expands, because we\n ;; want to use a different set of constraints when TARGET_MIPS16.\n \n (define_expand \"andsi3\"\n@@ -3216,7 +3193,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"andi\\\\t%0,%1,0xff\"\n   [(set_attr \"type\"     \"darith\")\n    (set_attr \"mode\"     \"HI\")])\n-\n \f\n ;;\n ;;  ....................\n@@ -3657,9 +3633,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"cvt.d.s\\\\t%0,%1\"\n   [(set_attr \"type\"\t\"fcvt\")\n    (set_attr \"mode\"\t\"DF\")])\n-\n \f\n-\n ;;\n ;;  ....................\n ;;\n@@ -3737,14 +3711,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"36\")])\n \n-;;; ??? trunc.l.d is mentioned in the appendix of the 1993 r4000/r4600 manuals\n-;;; but not in the chapter that describes the FPU.  It is not mentioned at all\n-;;; in the 1991 manuals.  The r4000 at Cygnus does not have this instruction.\n-\n-;;; Deleting this means that we now need two libgcc2.a libraries.  One for\n-;;; the 32 bit calling convention and one for the 64 bit calling convention.\n-\n-;;; If this is disabled, then fixuns_truncdfdi2 must be disabled also.\n \n (define_insn \"fix_truncdfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n@@ -3756,9 +3722,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"length\"\t\"4\")])\n \n \n-;;; ??? trunc.l.s is mentioned in the appendix of the 1993 r4000/r4600 manuals\n-;;; but not in the chapter that describes the FPU.  It is not mentioned at all\n-;;; in the 1991 manuals.  The r4000 at Cygnus does not have this instruction.\n (define_insn \"fix_truncsfdi2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=f\")\n \t(fix:DI (match_operand:SF 1 \"register_operand\" \"f\")))]\n@@ -3991,7 +3954,6 @@ move\\\\t%0,%z4\\\\n\\\\\n       DONE;\n     }\n }\")\n-\n \f\n ;;\n ;;  ....................\n@@ -4659,7 +4621,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; Unlike most other insns, the move insns can't be split with\n ;; different predicates, because register spilling and other parts of\n ;; the compiler, have memoized the insn number already.\n-;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n+;; Unsigned loads are used because LOAD_EXTEND_OP returns ZERO_EXTEND.\n \n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n@@ -4680,9 +4642,6 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-;; The difference between these two is whether or not ints are allowed\n-;; in FP registers (off by default, use -mdebugh to enable).\n-\n (define_insn \"movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x,*d\")\n \t(match_operand:HI 1 \"general_operand\"       \"d,IK,m,dJ,*f,*d,*f,*d,*x\"))]\n@@ -4784,7 +4743,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; Unlike most other insns, the move insns can't be split with\n ;; different predicates, because register spilling and other parts of\n ;; the compiler, have memoized the insn number already.\n-;; Unsigned loads are used because BYTE_LOADS_ZERO_EXTEND is defined\n+;; Unsigned loads are used because LOAD_EXTEND_OP returns ZERO_EXTEND.\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n@@ -4805,9 +4764,6 @@ move\\\\t%0,%z4\\\\n\\\\\n     }\n }\")\n \n-;; The difference between these two is whether or not ints are allowed\n-;; in FP registers (off by default, use -mdebugh to enable).\n-\n (define_insn \"movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x,*d\")\n \t(match_operand:QI 1 \"general_operand\"       \"d,IK,m,dJ,*f,*d,*f,*d,*x\"))]\n@@ -5105,7 +5061,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\n ;;  ....................\n \n-;; Many of these instructions uses trivial define_expands, because we\n+;; Many of these instructions use trivial define_expands, because we\n ;; want to use a different set of constraints when TARGET_MIPS16.\n \n (define_expand \"ashlsi3\"\n@@ -6257,7 +6213,6 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   operands[2] = GEN_INT (INTVAL (operands[2]) - 8);\n }\")\n-\n \f\n ;;\n ;;  ....................\n@@ -6277,7 +6232,7 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;\tDifferent CC modes are used, based on what type of branch is\n ;;\tdone, so that we can constrain things appropriately.  There\n ;;\tare assumptions in the rest of GCC that break if we fold the\n-;;\toperands into the branchs for integer operations, and use cc0\n+;;\toperands into the branches for integer operations, and use cc0\n ;;\tfor floating point, so we use the fp status register instead.\n ;;\tIf needed, an appropriate temporary is created to hold the\n ;;\tof the integer compare.\n@@ -6375,7 +6330,6 @@ move\\\\t%0,%z4\\\\n\\\\\n       DONE;\n     }\n }\")\n-\n \f\n ;;\n ;;  ....................\n@@ -6939,7 +6893,6 @@ move\\\\t%0,%z4\\\\n\\\\\n       DONE;\n     }\n }\")\n-\n \f\n ;;\n ;;  ....................\n@@ -7826,7 +7779,6 @@ move\\\\t%0,%z4\\\\n\\\\\n \t(xor:DI (match_dup 0)\n \t\t(const_int 1)))]\n   \"\")\n-\n \f\n ;;\n ;;  ....................\n@@ -7996,7 +7948,6 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"c.le.s\\t%Z0%2,%1\"\n   [(set_attr \"type\" \"fcmp\")\n    (set_attr \"mode\" \"FPSW\")])\n-\n \f\n ;;\n ;;  ....................\n@@ -8292,8 +8243,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n     DONE;\n   })\n \n-;; Restore the gp that we saved above.  Despite the comment, it seems that\n-;; older code did recalculate the gp from $25.  Continue to jump through\n+;; Restore the gp that we saved above.  Despite the earlier comment, it seems\n+;; that older code did recalculate the gp from $25.  Continue to jump through\n ;; $25 for compatibility (we lose nothing by doing so).\n \n (define_expand \"builtin_longjmp\"\n@@ -8375,7 +8326,8 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n })\n \n ;; Trivial return.  Make it look like a normal return insn as that\n-;; allows jump optimizations to work better .\n+;; allows jump optimizations to work better.\n+\n (define_insn \"return\"\n   [(return)]\n   \"mips_can_use_return_insn ()\"\n@@ -8466,11 +8418,12 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n ;;\n ;;  ....................\n \n-;; Sibling calls.  All these patterns use direct jumps.\n+;; Sibling calls.  All these patterns use jump instructions.\n \n-;; call_insn_operand will only accepts constant addresses if a direct\n-;; jump is acceptable.  Since the 'S' constraint is defined in terms of\n-;; call_insn_operand, the same is true of the constraints.\n+;; If TARGET_SIBCALLS, call_insn_operand will only accept constant\n+;; addresses if a direct jump is acceptable.  Since the 'S' constraint\n+;; is defined in terms of call_insn_operand, the same is true of the\n+;; constraints.\n \n ;; When we use an indirect jump, we need a register that will be\n ;; preserved by the epilogue.  Since TARGET_ABICALLS forces us to\n@@ -8737,24 +8690,7 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2%/\"\n       return \"#nop\";\n   }\n   [(set_attr \"type\"\t\"arith\")])\n-\n-;; The MIPS chip does not seem to require stack probes.\n-;;\n-;; (define_expand \"probe\"\n-;;   [(set (match_dup 0)\n-;; \t(match_dup 1))]\n-;;   \"\"\n-;;   \"\n-;; {\n-;;   operands[0] = gen_reg_rtx (SImode);\n-;;   operands[1] = gen_rtx_MEM (SImode, stack_pointer_rtx);\n-;;   MEM_VOLATILE_P (operands[1]) = TRUE;\n-;;\n-;;   /* fall through and generate default code */\n-;; }\")\n-;;\n \f\n-;;\n ;; MIPS4 Conditional move instructions.\n \n (define_insn \"\""}]}