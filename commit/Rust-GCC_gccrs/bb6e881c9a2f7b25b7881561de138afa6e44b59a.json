{"sha": "bb6e881c9a2f7b25b7881561de138afa6e44b59a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI2ZTg4MWM5YTJmN2IyNWI3ODgxNTYxZGUxMzhhZmE2ZTQ0YjU5YQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-02T12:20:36Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-02T12:20:36Z"}, "message": "Optimize: `return (a ? b : c)' as: `if (a) return b; else return c;'.\n\na\n\tOptimize: `return (a ? b : c)' as: `if (a) return b; else return c;'.\n\t* jcf-write.c (generate_bytecode_return):  New function.\n\t(generate_bytecode_insns):  Use it, for RETURN_EXPR.\n\t* jcf-write.c (generate_bytecode_insns):  For REAL_CST that is 0 or 1,\n\tgenerate special [fd]const_[01] instructions.\n\t* jcf-parse.c (yyparse):  Don't emit_register_classes if -fsyntax-only.\n\t* verify.c (verify_jvm_instructions):  Do INVALIDATE_PC after\n\thandling OPCODE_lookupswitch or OPCODE_tableswitch.\n\nFrom-SVN: r24971", "tree": {"sha": "c3a911fc75011cc37aa74034b4ae5ec82c54c0bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3a911fc75011cc37aa74034b4ae5ec82c54c0bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb6e881c9a2f7b25b7881561de138afa6e44b59a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6e881c9a2f7b25b7881561de138afa6e44b59a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6e881c9a2f7b25b7881561de138afa6e44b59a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6e881c9a2f7b25b7881561de138afa6e44b59a/comments", "author": null, "committer": null, "parents": [{"sha": "bb31662fadb407a0b9ed2d44a8171d830a060b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb31662fadb407a0b9ed2d44a8171d830a060b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb31662fadb407a0b9ed2d44a8171d830a060b05"}], "stats": {"total": 139, "additions": 93, "deletions": 46}, "files": [{"sha": "b8aad7ebca8baea2f548d1956a66cca73b05fc7e", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 93, "deletions": 46, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6e881c9a2f7b25b7881561de138afa6e44b59a/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6e881c9a2f7b25b7881561de138afa6e44b59a/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=bb6e881c9a2f7b25b7881561de138afa6e44b59a", "patch": "@@ -1268,6 +1268,72 @@ call_cleanups (limit, state)\n     }\n }\n \n+void\n+generate_bytecode_return (exp, state)\n+     tree exp;\n+     struct jcf_partial *state;\n+{\n+  tree return_type = TREE_TYPE (TREE_TYPE (state->current_method));\n+  int returns_void = TREE_CODE (return_type) == VOID_TYPE;\n+  int op;\n+ again:\n+  if (exp != NULL)\n+    {\n+      switch (TREE_CODE (exp))\n+\t{\n+ \tcase COMPOUND_EXPR:\t\n+\t  generate_bytecode_insns (TREE_OPERAND (exp, 0), IGNORE_TARGET,\n+\t\t\t\t   state);\n+\t  exp = TREE_OPERAND (exp, 1);\n+\t  goto again;\n+\tcase COND_EXPR:\n+\t  {\n+\t    struct jcf_block *then_label = gen_jcf_label (state);\n+\t    struct jcf_block *else_label = gen_jcf_label (state);\n+\t    generate_bytecode_conditional (TREE_OPERAND (exp, 0),\n+\t\t\t\t\t   then_label, else_label, 1, state);\n+\t    define_jcf_label (then_label, state);\n+\t    generate_bytecode_return (TREE_OPERAND (exp, 1), state);\n+\t    define_jcf_label (else_label, state);\n+\t    generate_bytecode_return (TREE_OPERAND (exp, 2), state);\n+\t  }\n+\t  return;\n+\tdefault:\n+\t  generate_bytecode_insns (exp,\n+\t\t\t\t   returns_void ? IGNORE_TARGET\n+\t\t\t\t   : STACK_TARGET, state);\n+\t}\n+    }\n+  if (returns_void)\n+    {\n+      op = OPCODE_return;\n+      call_cleanups (NULL_TREE, state);\n+    }\n+  else\n+    {\n+      op = OPCODE_ireturn + adjust_typed_op (return_type, 4);\n+      if (state->num_finalizers > 0)\n+\t{\n+\t  if (state->return_value_decl == NULL_TREE)\n+\t    {\n+\t      state->return_value_decl\n+\t\t= build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n+\t      localvar_alloc (state->return_value_decl, state);\n+\t    }\n+\t  emit_store (state->return_value_decl, state);\n+\t  call_cleanups (NULL_TREE, state);\n+\t  emit_load (state->return_value_decl, state);\n+\t  /* If we call localvar_free (state->return_value_decl, state),\n+\t     then we risk the save decl erroneously re-used in the\n+\t     finalizer.  Instead, we keep the state->return_value_decl\n+\t     allocated through the rest of the method.  This is not\n+\t     the greatest solution, but it is at least simple and safe. */\n+\t}\n+    }\n+  RESERVE (1);\n+  OP1 (op);\n+}\n+\n /* Generate bytecode for sub-expression EXP of METHOD.\n    TARGET is one of STACK_TARGET or IGNORE_TARGET. */\n \n@@ -1362,20 +1428,26 @@ generate_bytecode_insns (exp, target, state)\n \t}\n       break;\n     case REAL_CST:\n-      offset = find_constant_index (exp, state);\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32:\n-\t  push_constant1 (offset, state);\n-\t  NOTE_PUSH (1);\n-\t  break;\n-\tcase 64:\n-\t  push_constant2 (offset, state);\n-\t  NOTE_PUSH (2);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n+      {\n+\tint prec = TYPE_PRECISION (type) >> 5;\n+\tRESERVE(1);\n+\tif (real_zerop (exp))\n+\t  OP1 (prec == 1 ? OPCODE_fconst_0 : OPCODE_dconst_0);\n+\telse if (real_onep (exp))\n+\t  OP1 (prec == 1 ? OPCODE_fconst_1 : OPCODE_dconst_1);\n+\t/* FIXME Should also use fconst_2 for 2.0f.\n+\t   Also, should use iconst_2/ldc followed by i2f/i2d\n+\t   for other float/double when the value is a small integer. */\n+\telse\n+\t  {\n+\t    offset = find_constant_index (exp, state);\n+\t    if (prec == 1)\n+\t      push_constant1 (offset, state);\n+\t    else\n+\t      push_constant2 (offset, state);\n+\t  }\n+\tNOTE_PUSH (prec);\n+      }\n       break;\n     case STRING_CST:\n       push_constant1 (find_string_constant (&state->cpool, exp), state);\n@@ -1651,39 +1723,14 @@ generate_bytecode_insns (exp, target, state)\n       }\n \n     case RETURN_EXPR:\n-      if (!TREE_OPERAND (exp, 0))\n-\t{\n-\t  op = OPCODE_return;\n-\t  call_cleanups (NULL_TREE, state);\n-\t}\n+      exp = TREE_OPERAND (exp, 0);\n+      if (exp == NULL_TREE)\n+\texp = empty_stmt_node;\n+      else if (TREE_CODE (exp) != MODIFY_EXPR) \n+\tabort ();\n       else\n-\t{\n-\t  exp = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE (exp) != MODIFY_EXPR)\n-\t    abort ();\n-\t  exp = TREE_OPERAND (exp, 1);\n-\t  op = OPCODE_ireturn + adjust_typed_op (TREE_TYPE (exp), 4);\n-\t  generate_bytecode_insns (exp, STACK_TARGET, state);\n-\t  if (state->num_finalizers > 0)\n-\t    {\n-\t      if (state->return_value_decl == NULL_TREE)\n-\t\t{\n-\t\t  state->return_value_decl\n-\t\t    = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (exp));\n-\t\t  localvar_alloc (state->return_value_decl, state);\n-\t\t}\n-\t      emit_store (state->return_value_decl, state);\n-\t      call_cleanups (NULL_TREE, state);\n-\t      emit_load (state->return_value_decl, state);\n-\t      /* If we call localvar_free (state->return_value_decl, state),\n-\t\t then we risk the save decl erroneously re-used in the\n-\t\t finalizer.  Instead, we keep the state->return_value_decl\n-\t\t allocated through the rest of the method.  This is not\n-\t\t the greatest solution, but it is at least simple and safe. */\n-\t    }\n-\t}\n-      RESERVE (1);\n-      OP1 (op);\n+\texp = TREE_OPERAND (exp, 1);\n+      generate_bytecode_return (exp, state);\n       break;\n     case LABELED_BLOCK_EXPR:\n       {"}]}