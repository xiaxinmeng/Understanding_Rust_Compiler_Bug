{"sha": "e7f2301855b432e057acd267e5df455fee60abef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdmMjMwMTg1NWI0MzJlMDU3YWNkMjY3ZTVkZjQ1NWZlZTYwYWJlZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-04-16T09:13:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-04-16T09:13:08Z"}, "message": "cgraphbuild.c: Include ipa-inline.h.\n\n\n\t* cgraphbuild.c: Include ipa-inline.h.\n\t(reset_inline_failed): Use initialize_inline_failed.\n\t* cgraph.c: Include ipa-inline.h.\n\t(cgraph_create_node_1): Do not initialize estimated_growth.\n\t(initialize_inline_failed): More to ipa-inline-analysis.c\n\t(dump_cgraph_node): Do not dump inline flags.\n\t* cgraph.h (cgraph_local_info): Remove inlineable, versionable\n\tand disregard_inline_limits flags.\n\t(cgrpah_global_info): Remove estimated_stack_size, stack_frame_offset,\n\ttime, size, estimated_growth.\n\t* ipa-cp.c (ipcp_versionable_function_p, ipcp_generate_summary): Update.\n\t* cgraphunit.c (cgraph_decide_is_function_needed): Use\n\tDECL_DISREGARD_INLINE_LIMITS.\n\t(cgraph_analyze_function): Do not initialize\n\tnode->local.disregard_inline_limits.\n\t* lto-cgraph.c (lto_output_node, input_overwrite_node): Do not stream\n\tinlinable, versionable and disregard_inline_limits.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes, cgraph_mark_inline_edge,\n\tcgraph_check_inline_limits, cgraph_default_inline_p, cgraph_edge_badness,\n\tupdate_caller_keys, update_callee_keys, add_new_edges_to_heap): Update.\n\t(cgraph_decide_inlining_of_small_function): Update; set CIF_FUNCTION_NOT_INLINABLE\n\tfor uninlinable functions.\n\t(cgraph_decide_inlining, cgraph_edge_early_inlinable_p,\n\tcgraph_decide_inlining_incrementally): Update.\n\t* ipa-inline.h (inline_summary): Add inlinable, versionable, disregard_inline_limits,\n\testimated_stack_size, stack_frame_offset, time, size and estimated_growth\n\tparameters.\n\t(estimate_edge_growth): Update.\n\t(initialize_inline_failed): Declare.\n\t* ipa-split.c: Include ipa-inline.h\n\t(execute_split_functions): Update.\n\t* ipa.c (cgraph_postorder): Use DECL_DISREGARD_INLINE_LIMITS.\n\t(cgraph_remove_unreachable_nodes): Do not clear inlinable flag.\n\t(record_cdtor_fn): Use DECL_DISREGARD_INLINE_LIMITS.\n\t* ipa-inline-analysis.c (inline_node_removal_hook): Update; set\n\testimated_growth to INT_MIN.\n\t(inline_node_duplication_hook): Likewise.\n\t(dump_inline_summary): Dump new fields.\n\t(compute_inline_parameters): Update.\n\t(estimate_edge_time, estimate_time_after_inlining,\n\testimate_size_after_inlining, estimate_growth, inline_read_summary,\n\tinline_write_summary):\n\t(initialize_inline_failed): Move here from cgraph.c.\n\t* tree-sra.c: Include ipa-inline.h.\n\t(ipa_sra_preliminary_function_checks): Update.\n\t* lto/lto.c (lto_balanced_map): Update.\n\tUpdate.\n\t* Makefile.in: (cgraph.o, cgraphbuild.o): Add dependency on\n\tipa-inline.h\n\nFrom-SVN: r172581", "tree": {"sha": "bc526e252532d488b8afaaa3574faf2363fc5fde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc526e252532d488b8afaaa3574faf2363fc5fde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7f2301855b432e057acd267e5df455fee60abef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f2301855b432e057acd267e5df455fee60abef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7f2301855b432e057acd267e5df455fee60abef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7f2301855b432e057acd267e5df455fee60abef/comments", "author": null, "committer": null, "parents": [{"sha": "e81b856471b18de439f9157932ee8aa0fa190928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81b856471b18de439f9157932ee8aa0fa190928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e81b856471b18de439f9157932ee8aa0fa190928"}], "stats": {"total": 485, "additions": 288, "deletions": 197}, "files": [{"sha": "237f2fda1ce8a82bb5bd130fcc70f630e649fe07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -1,3 +1,53 @@\n+2011-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c: Include ipa-inline.h.\n+\t(reset_inline_failed): Use initialize_inline_failed.\n+\t* cgraph.c: Include ipa-inline.h.\n+\t(cgraph_create_node_1): Do not initialize estimated_growth.\n+\t(initialize_inline_failed): More to ipa-inline-analysis.c\n+\t(dump_cgraph_node): Do not dump inline flags.\n+\t* cgraph.h (cgraph_local_info): Remove inlineable, versionable\n+\tand disregard_inline_limits flags.\n+\t(cgrpah_global_info): Remove estimated_stack_size, stack_frame_offset,\n+\ttime, size, estimated_growth.\n+\t* ipa-cp.c (ipcp_versionable_function_p, ipcp_generate_summary): Update.\n+\t* cgraphunit.c (cgraph_decide_is_function_needed): Use\n+\tDECL_DISREGARD_INLINE_LIMITS.\n+\t(cgraph_analyze_function): Do not initialize\n+\tnode->local.disregard_inline_limits.\n+\t* lto-cgraph.c (lto_output_node, input_overwrite_node): Do not stream\n+\tinlinable, versionable and disregard_inline_limits.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes, cgraph_mark_inline_edge,\n+\tcgraph_check_inline_limits, cgraph_default_inline_p, cgraph_edge_badness,\n+\tupdate_caller_keys, update_callee_keys, add_new_edges_to_heap): Update.\n+\t(cgraph_decide_inlining_of_small_function): Update; set CIF_FUNCTION_NOT_INLINABLE\n+\tfor uninlinable functions.\n+\t(cgraph_decide_inlining, cgraph_edge_early_inlinable_p,\n+\tcgraph_decide_inlining_incrementally): Update.\n+\t* ipa-inline.h (inline_summary): Add inlinable, versionable, disregard_inline_limits,\n+\testimated_stack_size, stack_frame_offset, time, size and estimated_growth\n+\tparameters.\n+\t(estimate_edge_growth): Update.\n+\t(initialize_inline_failed): Declare.\n+\t* ipa-split.c: Include ipa-inline.h\n+\t(execute_split_functions): Update.\n+\t* ipa.c (cgraph_postorder): Use DECL_DISREGARD_INLINE_LIMITS.\n+\t(cgraph_remove_unreachable_nodes): Do not clear inlinable flag.\n+\t(record_cdtor_fn): Use DECL_DISREGARD_INLINE_LIMITS.\n+\t* ipa-inline-analysis.c (inline_node_removal_hook): Update; set\n+\testimated_growth to INT_MIN.\n+\t(inline_node_duplication_hook): Likewise.\n+\t(dump_inline_summary): Dump new fields.\n+\t(compute_inline_parameters): Update.\n+\t(estimate_edge_time, estimate_time_after_inlining,\n+\testimate_size_after_inlining, estimate_growth, inline_read_summary,\n+\tinline_write_summary):\n+\t(initialize_inline_failed): Move here from cgraph.c.\n+\t* tree-sra.c: Include ipa-inline.h.\n+\t(ipa_sra_preliminary_function_checks): Update.\n+\t* Makefile.in: (cgraph.o, cgraphbuild.o): Add dependency on\n+\tipa-inline.h\n+\n 2011-04-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (V16): New mode iterator."}, {"sha": "f88d61d7bbcf7afde0e0c8a724d5e3012b0f257c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -2983,7 +2983,8 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    langhooks.h toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n    $(TREE_INLINE_H) $(TREE_DUMP_H) $(TREE_FLOW_H) cif-code.def \\\n-   value-prof.h $(EXCEPT_H) $(IPA_UTILS_H) $(DIAGNOSTIC_CORE_H)\n+   value-prof.h $(EXCEPT_H) $(IPA_UTILS_H) $(DIAGNOSTIC_CORE_H) \\\n+   ipa-inline.h\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n@@ -2993,7 +2994,8 @@ cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    tree-pretty-print.h gimple-pretty-print.h\n cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \\\n-   $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H)\n+   $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H) \\\n+   ipa-inline.h\n varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(CGRAPH_H) langhooks.h $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) \\\n    $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \\"}, {"sha": "31c5b59960a5e9f8f6e6be8dc5653ba57e3fa6b0", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -98,6 +98,7 @@ The callgraph:\n #include \"rtl.h\"\n #include \"ipa-utils.h\"\n #include \"lto-streamer.h\"\n+#include \"ipa-inline.h\"\n \n const char * const ld_plugin_symbol_resolution_names[]=\n {\n@@ -476,7 +477,6 @@ cgraph_create_node_1 (void)\n   if (cgraph_nodes)\n     cgraph_nodes->previous = node;\n   node->previous = NULL;\n-  node->global.estimated_growth = INT_MIN;\n   node->frequency = NODE_FREQUENCY_NORMAL;\n   node->count_materialization_scale = REG_BR_PROB_BASE;\n   ipa_empty_ref_list (&node->ref_list);\n@@ -970,28 +970,6 @@ cgraph_create_edge_including_clones (struct cgraph_node *orig,\n       }\n }\n \n-/* Give initial reasons why inlining would fail on EDGE.  This gets either\n-   nullified or usually overwritten by more precise reasons later.  */\n-\n-static void\n-initialize_inline_failed (struct cgraph_edge *e)\n-{\n-  struct cgraph_node *callee = e->callee;\n-\n-  if (e->indirect_unknown_callee)\n-    e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n-  else if (!callee->analyzed)\n-    e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n-  else if (callee->local.redefined_extern_inline)\n-    e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n-  else if (!callee->local.inlinable)\n-    e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n-  else if (e->call_stmt && gimple_call_cannot_inline_p (e->call_stmt))\n-    e->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n-  else\n-    e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n-}\n-\n /* Allocate a cgraph_edge structure and fill it with data according to the\n    parameters of which only CALLEE can be NULL (when creating an indirect call\n    edge).  */\n@@ -1899,12 +1877,6 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n  \t     ld_plugin_symbol_resolution_names[(int)node->resolution]);\n   if (node->local.finalized)\n     fprintf (f, \" finalized\");\n-  if (node->local.disregard_inline_limits)\n-    fprintf (f, \" always_inline\");\n-  else if (node->local.inlinable)\n-    fprintf (f, \" inlinable\");\n-  else if (node->local.versionable)\n-    fprintf (f, \" versionable\");\n   if (node->local.redefined_extern_inline)\n     fprintf (f, \" redefined_extern_inline\");\n   if (TREE_ASM_WRITTEN (node->decl))"}, {"sha": "199349b3991ca33ae70cc4de4b5e5d033d295705", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -88,20 +88,10 @@ struct GTY(()) cgraph_local_info {\n   /* Set once it has been finalized so we consider it to be output.  */\n   unsigned finalized : 1;\n \n-  /* False when there something makes inlining impossible (such as va_arg).  */\n-  unsigned inlinable : 1;\n-\n-  /* False when there something makes versioning impossible.\n-     Currently computed and used only by ipa-cp.  */\n-  unsigned versionable : 1;\n-\n   /* False when function calling convention and signature can not be changed.\n      This is the case when __builtin_apply_args is used.  */\n   unsigned can_change_signature : 1;\n \n-  /* True when function should be inlined independently on its size.  */\n-  unsigned disregard_inline_limits : 1;\n-\n   /* True when the function has been originally extern inline, but it is\n      redefined now.  */\n   unsigned redefined_extern_inline : 1;\n@@ -115,21 +105,9 @@ struct GTY(()) cgraph_local_info {\n    once compilation is finished.  Available only with -funit-at-a-time.  */\n \n struct GTY(()) cgraph_global_info {\n-  /* Estimated stack frame consumption by the function.  */\n-  HOST_WIDE_INT estimated_stack_size;\n-  /* Expected offset of the stack frame of inlined function.  */\n-  HOST_WIDE_INT stack_frame_offset;\n-\n   /* For inline clones this points to the function they will be\n      inlined into.  */\n   struct cgraph_node *inlined_to;\n-\n-  /* Estimated size of the function after inlining.  */\n-  int time;\n-  int size;\n-\n-  /* Estimated growth after inlining.  INT_MIN if not computed.  */\n-  int estimated_growth;\n };\n \n /* Information about the function that is propagated by the RTL backend."}, {"sha": "3a2cb676679ca47ff6fa1e1fbf066cb585e7420e", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"ipa-utils.h\"\n #include \"except.h\"\n+#include \"ipa-inline.h\"\n \n /* Context of record_reference.  */\n struct record_reference_ctx\n@@ -207,16 +208,7 @@ reset_inline_failed (struct cgraph_node *node)\n   for (e = node->callers; e; e = e->next_caller)\n     {\n       e->callee->global.inlined_to = NULL;\n-      if (!node->analyzed)\n-\te->inline_failed = CIF_BODY_NOT_AVAILABLE;\n-      else if (node->local.redefined_extern_inline)\n-\te->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n-      else if (!node->local.inlinable)\n-\te->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n-      else if (e->call_stmt_cannot_inline_p)\n-\te->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n-      else\n-\te->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n+      initialize_inline_failed (e);\n     }\n }\n "}, {"sha": "6b3ddb5562f145757b0d3453d5a889c69ea5ecf3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -172,7 +172,7 @@ cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n   if (flag_keep_inline_functions\n       && DECL_DECLARED_INLINE_P (decl)\n       && !DECL_EXTERNAL (decl)\n-      && !lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (decl)))\n+      && !DECL_DISREGARD_INLINE_LIMITS (decl))\n      return true;\n \n   /* If we decided it was needed before, but at the time we didn't have\n@@ -191,7 +191,7 @@ cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n      to change the behavior here.  */\n   if (((TREE_PUBLIC (decl)\n \t|| (!optimize\n-\t    && !node->local.disregard_inline_limits\n+\t    && !DECL_DISREGARD_INLINE_LIMITS (decl)\n \t    && !DECL_DECLARED_INLINE_P (decl)\n \t    && !(DECL_CONTEXT (decl)\n \t\t && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)))\n@@ -783,11 +783,6 @@ cgraph_analyze_function (struct cgraph_node *node)\n \n   assign_assembler_name_if_neeeded (node->decl);\n \n-  /* disregard_inline_limits affects topological order of the early optimization,\n-     so we need to compute it ahead of rest of inline parameters.  */\n-  node->local.disregard_inline_limits\n-    = DECL_DISREGARD_INLINE_LIMITS (node->decl);\n-\n   /* Make sure to gimplify bodies only once.  During analyzing a\n      function we lower it, which will require gimplified nested\n      functions, so we can end up here with an already gimplified"}, {"sha": "5ec0b2c7acaa431ff91b698eea20a383bec3c097", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -424,7 +424,7 @@ ipcp_versionable_function_p (struct cgraph_node *node)\n   /* There are a number of generic reasons functions cannot be versioned.  We\n      also cannot remove parameters if there are type attributes such as fnspec\n      present.  */\n-  if (!node->local.versionable\n+  if (!inline_summary (node)->versionable\n       || TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n     return false;\n \n@@ -1577,7 +1577,7 @@ ipcp_generate_summary (void)\n \t/* Unreachable nodes should have been eliminated before ipcp.  */\n \tgcc_assert (node->needed || node->reachable);\n \n-\tnode->local.versionable = tree_versionable_function_p (node->decl);\n+\tinline_summary (node)->versionable = tree_versionable_function_p (node->decl);\n \tipa_analyze_node (node);\n       }\n }"}, {"sha": "6ab3e4733f73fbdc86bf6ac05c7ae2481fec1a76", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 85, "deletions": 30, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -100,11 +100,13 @@ inline_summary_alloc (void)\n static void\n inline_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n+  struct inline_summary *info;\n   if (VEC_length (inline_summary_t, inline_summary_vec)\n       <= (unsigned)node->uid)\n     return;\n-  memset (inline_summary (node),\n-\t  0, sizeof (inline_summary_t));\n+  info = inline_summary (node);\n+  info->estimated_growth = INT_MIN;\n+  memset (info, 0, sizeof (inline_summary_t));\n }\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n@@ -113,9 +115,12 @@ static void\n inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\t\t      ATTRIBUTE_UNUSED void *data)\n {\n+  struct inline_summary *info;\n   inline_summary_alloc ();\n-  memcpy (inline_summary (dst), inline_summary (src),\n+  info = inline_summary (dst);\n+  memcpy (info, inline_summary (src),\n \t  sizeof (struct inline_summary));\n+  info->estimated_growth = INT_MIN;\n }\n \n static void\n@@ -124,18 +129,24 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n   if (node->analyzed)\n     {\n       struct inline_summary *s = inline_summary (node);\n-      fprintf (f, \"Inline summary for %s/%i\\n\", cgraph_node_name (node),\n+      fprintf (f, \"Inline summary for %s/%i\", cgraph_node_name (node),\n \t       node->uid);\n-      fprintf (f, \"  self time:       %i, benefit: %i\\n\",\n+      if (s->disregard_inline_limits)\n+\tfprintf (f, \" always_inline\");\n+      if (s->inlinable)\n+\tfprintf (f, \" inlinable\");\n+      if (s->versionable)\n+\tfprintf (f, \" versionable\");\n+      fprintf (f, \"\\n  self time:       %i, benefit: %i\\n\",\n       \t       s->self_time, s->time_inlining_benefit);\n-      fprintf (f, \"  global time:     %i\\n\", node->global.time);\n+      fprintf (f, \"  global time:     %i\\n\", s->time);\n       fprintf (f, \"  self size:       %i, benefit: %i\\n\",\n \t       s->self_size, s->size_inlining_benefit);\n-      fprintf (f, \"  global size:     %i\", node->global.size);\n+      fprintf (f, \"  global size:     %i\", s->size);\n       fprintf (f, \"  self stack:      %i\\n\",\n \t       (int)s->estimated_self_stack_size);\n       fprintf (f, \"  global stack:    %i\\n\\n\",\n-\t       (int)node->global.estimated_stack_size);\n+\t       (int)s->estimated_stack_size);\n     }\n }\n \n@@ -155,6 +166,26 @@ dump_inline_summaries (FILE *f)\n       dump_inline_summary (f, node);\n }\n \n+/* Give initial reasons why inlining would fail on EDGE.  This gets either\n+   nullified or usually overwritten by more precise reasons later.  */\n+\n+void\n+initialize_inline_failed (struct cgraph_edge *e)\n+{\n+  struct cgraph_node *callee = e->callee;\n+\n+  if (e->indirect_unknown_callee)\n+    e->inline_failed = CIF_INDIRECT_UNKNOWN_CALL;\n+  else if (!callee->analyzed)\n+    e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n+  else if (callee->local.redefined_extern_inline)\n+    e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n+  else if (e->call_stmt && gimple_call_cannot_inline_p (e->call_stmt))\n+    e->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+  else\n+    e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n+}\n+\n /* See if statement might disappear after inlining.\n    0 - means not eliminated\n    1 - half of statements goes away\n@@ -317,24 +348,27 @@ compute_inline_parameters (struct cgraph_node *node)\n {\n   HOST_WIDE_INT self_stack_size;\n   struct cgraph_edge *e;\n+  struct inline_summary *info;\n \n   gcc_assert (!node->global.inlined_to);\n \n   inline_summary_alloc ();\n \n+  info = inline_summary (node);\n+\n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n-  inline_summary (node)->estimated_self_stack_size = self_stack_size;\n-  node->global.estimated_stack_size = self_stack_size;\n-  node->global.stack_frame_offset = 0;\n+  info->estimated_self_stack_size = self_stack_size;\n+  info->estimated_stack_size = self_stack_size;\n+  info->stack_frame_offset = 0;\n \n   /* Can this function be inlined at all?  */\n-  node->local.inlinable = tree_inlinable_function_p (node->decl);\n-  if (!node->local.inlinable)\n-    node->local.disregard_inline_limits = 0;\n+  info->inlinable = tree_inlinable_function_p (node->decl);\n+  if (!info->inlinable)\n+    info->disregard_inline_limits = 0;\n \n   /* Inlinable functions always can change signature.  */\n-  if (node->local.inlinable)\n+  if (info->inlinable)\n     node->local.can_change_signature = true;\n   else\n     {\n@@ -349,8 +383,13 @@ compute_inline_parameters (struct cgraph_node *node)\n   estimate_function_body_sizes (node);\n \n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n-  node->global.time = inline_summary (node)->self_time;\n-  node->global.size = inline_summary (node)->self_size;\n+  info->time = info->self_time;\n+  info->size = info->self_size;\n+  info->estimated_growth = INT_MIN;\n+  info->stack_frame_offset = 0;\n+  info->estimated_stack_size = info->estimated_self_stack_size;\n+  info->disregard_inline_limits\n+    = DECL_DISREGARD_INLINE_LIMITS (node->decl);\n }\n \n \n@@ -390,10 +429,12 @@ static inline int\n estimate_edge_time (struct cgraph_edge *edge)\n {\n   int call_stmt_time;\n+  struct inline_summary *info = inline_summary (edge->callee);\n+\n   call_stmt_time = edge->call_stmt_time;\n   gcc_checking_assert (call_stmt_time);\n-  return (((gcov_type)edge->callee->global.time\n-\t   - inline_summary (edge->callee)->time_inlining_benefit\n+  return (((gcov_type)info->time\n+\t   - info->time_inlining_benefit\n \t   - call_stmt_time) * edge->frequency\n \t  + CGRAPH_FREQ_BASE / 2) / CGRAPH_FREQ_BASE;\n }\n@@ -405,7 +446,7 @@ int\n estimate_time_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  gcov_type time = node->global.time + estimate_edge_time (edge);\n+  gcov_type time = inline_summary (node)->time + estimate_edge_time (edge);\n   if (time < 0)\n     time = 0;\n   if (time > MAX_TIME)\n@@ -421,7 +462,7 @@ int\n estimate_size_after_inlining (struct cgraph_node *node,\n \t\t\t      struct cgraph_edge *edge)\n {\n-  int size = node->global.size + estimate_edge_growth (edge);\n+  int size = inline_summary (node)->size + estimate_edge_growth (edge);\n   gcc_assert (size >= 0);\n   return size;\n }\n@@ -435,9 +476,10 @@ estimate_growth (struct cgraph_node *node)\n   int growth = 0;\n   struct cgraph_edge *e;\n   bool self_recursive = false;\n+  struct inline_summary *info = inline_summary (node);\n \n-  if (node->global.estimated_growth != INT_MIN)\n-    return node->global.estimated_growth;\n+  if (info->estimated_growth != INT_MIN)\n+    return info->estimated_growth;\n \n   for (e = node->callers; e; e = e->next_caller)\n     {\n@@ -453,15 +495,15 @@ estimate_growth (struct cgraph_node *node)\n      some inlining.  */\n   if (cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n       && !DECL_EXTERNAL (node->decl) && !self_recursive)\n-    growth -= node->global.size;\n+    growth -= info->size;\n   /* COMDAT functions are very often not shared across multiple units since they\n      come from various template instantiations.  Take this into account.  */\n   else  if (DECL_COMDAT (node->decl) && !self_recursive\n \t    && cgraph_can_remove_if_no_direct_calls_p (node))\n-    growth -= (node->global.size\n+    growth -= (info->size\n \t       * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY)) + 50) / 100;\n \n-  node->global.estimated_growth = growth;\n+  info->estimated_growth = growth;\n   return growth;\n }\n \n@@ -561,19 +603,25 @@ inline_read_summary (void)\n \t      struct cgraph_node *node;\n \t      struct inline_summary *info;\n \t      lto_cgraph_encoder_t encoder;\n+\t      struct bitpack_d bp;\n \n \t      index = lto_input_uleb128 (ib);\n \t      encoder = file_data->cgraph_node_encoder;\n \t      node = lto_cgraph_encoder_deref (encoder, index);\n \t      info = inline_summary (node);\n \n-\t      node->global.estimated_stack_size\n+\t      info->estimated_stack_size\n \t        = info->estimated_self_stack_size = lto_input_uleb128 (ib);\n-\t      node->global.time = info->self_time = lto_input_uleb128 (ib);\n+\t      info->time = info->self_time = lto_input_uleb128 (ib);\n \t      info->time_inlining_benefit = lto_input_uleb128 (ib);\n-\t      node->global.size = info->self_size = lto_input_uleb128 (ib);\n+\t      info->size = info->self_size = lto_input_uleb128 (ib);\n \t      info->size_inlining_benefit = lto_input_uleb128 (ib);\n-\t      node->global.estimated_growth = INT_MIN;\n+\t      info->estimated_growth = INT_MIN;\n+\n+\t      bp = lto_input_bitpack (ib);\n+\t      info->inlinable = bp_unpack_value (&bp, 1);\n+\t      info->versionable = bp_unpack_value (&bp, 1);\n+\t      info->disregard_inline_limits = bp_unpack_value (&bp, 1);\n \t    }\n \n \t  lto_destroy_simple_input_block (file_data,\n@@ -623,6 +671,8 @@ inline_write_summary (cgraph_node_set set,\n       if (node->analyzed)\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n+\t  struct bitpack_d bp;\n+\n \t  lto_output_uleb128_stream (ob->main_stream,\n \t\t\t\t     lto_cgraph_encoder_encode (encoder, node));\n \t  lto_output_sleb128_stream (ob->main_stream,\n@@ -635,6 +685,11 @@ inline_write_summary (cgraph_node_set set,\n \t\t\t\t     info->self_time);\n \t  lto_output_sleb128_stream (ob->main_stream,\n \t\t\t\t     info->time_inlining_benefit);\n+\t  bp = bitpack_create (ob->main_stream);\n+\t  bp_pack_value (&bp, info->inlinable, 1);\n+\t  bp_pack_value (&bp, info->versionable, 1);\n+\t  bp_pack_value (&bp, info->disregard_inline_limits, 1);\n+\t  lto_output_bitpack (&bp);\n \t}\n     }\n   lto_destroy_simple_output_block (ob);"}, {"sha": "c605eaed937d650d37c6d2cec53b9dbb9f8da132", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 99, "deletions": 75, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -156,6 +156,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t\t\t    bool update_original)\n {\n   HOST_WIDE_INT peak;\n+  struct inline_summary *caller_info, *callee_info;\n \n   if (duplicate)\n     {\n@@ -184,7 +185,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  gcc_assert (!e->callee->global.inlined_to);\n \t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n \t    {\n-\t      overall_size -= e->callee->global.size;\n+\t      overall_size -= inline_summary (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n@@ -201,17 +202,20 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t}\n     }\n \n+  callee_info = inline_summary (e->callee);\n+  caller_info = inline_summary (e->caller);\n+\n   if (e->caller->global.inlined_to)\n     e->callee->global.inlined_to = e->caller->global.inlined_to;\n   else\n     e->callee->global.inlined_to = e->caller;\n-  e->callee->global.stack_frame_offset\n-    = e->caller->global.stack_frame_offset\n-      + inline_summary (e->caller)->estimated_self_stack_size;\n-  peak = e->callee->global.stack_frame_offset\n-      + inline_summary (e->callee)->estimated_self_stack_size;\n-  if (e->callee->global.inlined_to->global.estimated_stack_size < peak)\n-    e->callee->global.inlined_to->global.estimated_stack_size = peak;\n+  callee_info->stack_frame_offset\n+    = caller_info->stack_frame_offset\n+      + caller_info->estimated_self_stack_size;\n+  peak = callee_info->stack_frame_offset\n+      + callee_info->estimated_self_stack_size;\n+  if (inline_summary (e->callee->global.inlined_to)->estimated_stack_size < peak)\n+    inline_summary (e->callee->global.inlined_to)->estimated_stack_size = peak;\n   cgraph_propagate_frequency (e->callee);\n \n   /* Recursively clone all bodies.  */\n@@ -233,6 +237,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   int old_size = 0, new_size = 0;\n   struct cgraph_node *to = NULL;\n   struct cgraph_edge *curr = e;\n+  struct inline_summary *info;\n \n   /* Don't inline inlined edges.  */\n   gcc_assert (e->inline_failed);\n@@ -248,10 +253,11 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   for (;e && !e->inline_failed; e = e->caller->callers)\n     {\n       to = e->caller;\n-      old_size = e->caller->global.size;\n+      info = inline_summary (to);\n+      old_size = info->size;\n       new_size = estimate_size_after_inlining (to, curr);\n-      to->global.size = new_size;\n-      to->global.time = estimate_time_after_inlining (to, curr);\n+      info->size = new_size;\n+      info->time = estimate_time_after_inlining (to, curr);\n     }\n   gcc_assert (curr->callee->global.inlined_to == to);\n   if (new_size > old_size)\n@@ -280,23 +286,27 @@ cgraph_check_inline_limits (struct cgraph_edge *e,\n   int newsize;\n   int limit;\n   HOST_WIDE_INT stack_size_limit, inlined_stack;\n+  struct inline_summary *info, *what_info;\n \n   if (to->global.inlined_to)\n     to = to->global.inlined_to;\n \n+  info = inline_summary (to);\n+  what_info = inline_summary (what);\n+\n   /* When inlining large function body called once into small function,\n      take the inlined function as base for limiting the growth.  */\n-  if (inline_summary (to)->self_size > inline_summary(what)->self_size)\n-    limit = inline_summary (to)->self_size;\n+  if (info->self_size > what_info->self_size)\n+    limit = info->self_size;\n   else\n-    limit = inline_summary (what)->self_size;\n+    limit = what_info->self_size;\n \n   limit += limit * PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH) / 100;\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n   newsize = estimate_size_after_inlining (to, e);\n-  if (newsize >= to->global.size\n+  if (newsize >= info->size\n       && newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n       && newsize > limit)\n     {\n@@ -305,13 +315,13 @@ cgraph_check_inline_limits (struct cgraph_edge *e,\n       return false;\n     }\n \n-  stack_size_limit = inline_summary (to)->estimated_self_stack_size;\n+  stack_size_limit = info->estimated_self_stack_size;\n \n   stack_size_limit += stack_size_limit * PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) / 100;\n \n-  inlined_stack = (to->global.stack_frame_offset\n-\t\t   + inline_summary (to)->estimated_self_stack_size\n-\t\t   + what->global.estimated_stack_size);\n+  inlined_stack = (info->stack_frame_offset\n+\t\t   + info->estimated_self_stack_size\n+\t\t   + what_info->estimated_stack_size);\n   if (inlined_stack  > stack_size_limit\n       && inlined_stack > PARAM_VALUE (PARAM_LARGE_STACK_FRAME))\n     {\n@@ -328,8 +338,9 @@ static bool\n cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n {\n   tree decl = n->decl;\n+  struct inline_summary *info = inline_summary (n);\n \n-  if (n->local.disregard_inline_limits)\n+  if (info->disregard_inline_limits)\n     return true;\n \n   if (!flag_inline_small_functions && !DECL_DECLARED_INLINE_P (decl))\n@@ -354,7 +365,7 @@ cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n \n   if (DECL_DECLARED_INLINE_P (decl))\n     {\n-      if (n->global.size >= MAX_INLINE_INSNS_SINGLE)\n+      if (info->size >= MAX_INLINE_INSNS_SINGLE)\n \t{\n \t  if (reason)\n \t    *reason = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n@@ -363,7 +374,7 @@ cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n     }\n   else\n     {\n-      if (n->global.size >= MAX_INLINE_INSNS_AUTO)\n+      if (info->size >= MAX_INLINE_INSNS_AUTO)\n \t{\n \t  if (reason)\n \t    *reason = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -385,8 +396,9 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n {\n   gcov_type badness;\n   int growth;\n+  struct inline_summary *callee_info = inline_summary (edge->callee);\n \n-  if (edge->callee->local.disregard_inline_limits)\n+  if (callee_info->disregard_inline_limits)\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n@@ -398,11 +410,11 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n \t       cgraph_node_name (edge->callee));\n       fprintf (dump_file, \"      growth %i, time %i-%i, size %i-%i\\n\",\n \t       growth,\n-\t       edge->callee->global.time,\n-\t       inline_summary (edge->callee)->time_inlining_benefit\n+\t       callee_info->time,\n+\t       callee_info->time_inlining_benefit\n \t       + edge->call_stmt_time,\n-\t       edge->callee->global.size,\n-\t       inline_summary (edge->callee)->size_inlining_benefit\n+\t       callee_info->size,\n+\t       callee_info->size_inlining_benefit\n \t       + edge->call_stmt_size);\n     }\n \n@@ -422,7 +434,7 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n       badness =\n \t((int)\n \t ((double) edge->count * INT_MIN / max_count / (max_benefit + 1)) *\n-\t (inline_summary (edge->callee)->time_inlining_benefit\n+\t (callee_info->time_inlining_benefit\n \t  + edge->call_stmt_time + 1)) / growth;\n       if (dump)\n \t{\n@@ -453,9 +465,9 @@ cgraph_edge_badness (struct cgraph_edge *edge, bool dump)\n       int growth_for_all;\n       badness = growth * 10000;\n       benefitperc =\n-\t100 * (inline_summary (edge->callee)->time_inlining_benefit\n+\t100 * (callee_info->time_inlining_benefit\n \t       + edge->call_stmt_time)\n-\t    / (edge->callee->global.time + 1) + 1;\n+\t    / (callee_info->time + 1) + 1;\n       benefitperc = MIN (benefitperc, 100);\n       div *= benefitperc;\n \n@@ -543,13 +555,13 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   struct cgraph_edge *edge;\n   cgraph_inline_failed_t failed_reason;\n \n-  if (!node->local.inlinable\n+  if (!inline_summary (node)->inlinable\n       || cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE\n       || node->global.inlined_to)\n     return;\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n-  node->global.estimated_growth = INT_MIN;\n+  inline_summary (node)->estimated_growth = INT_MIN;\n \n   /* See if there is something to do.  */\n   for (edge = node->callers; edge; edge = edge->next_caller)\n@@ -586,7 +598,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t    bitmap updated_nodes)\n {\n   struct cgraph_edge *e = node->callees;\n-  node->global.estimated_growth = INT_MIN;\n+  inline_summary (node)->estimated_growth = INT_MIN;\n \n   if (!e)\n     return;\n@@ -596,11 +608,11 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n     else\n       {\n \tif (e->inline_failed\n-\t    && e->callee->local.inlinable\n+\t    && inline_summary (e->callee)->inlinable\n \t    && cgraph_function_body_availability (e->callee) >= AVAIL_AVAILABLE\n \t    && !bitmap_bit_p (updated_nodes, e->callee->uid))\n \t  {\n-\t    node->global.estimated_growth = INT_MIN;\n+\t    inline_summary (node)->estimated_growth = INT_MIN;\n \t    /* If function becomes uninlinable, we need to remove it from the heap.  */\n \t    if (!cgraph_default_inline_p (e->callee, &e->inline_failed))\n \t      update_caller_keys (heap, e->callee, updated_nodes);\n@@ -632,7 +644,7 @@ update_all_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t\tbitmap updated_nodes)\n {\n   struct cgraph_edge *e = node->callees;\n-  node->global.estimated_growth = INT_MIN;\n+  inline_summary (node)->estimated_growth = INT_MIN;\n \n   if (!e)\n     return;\n@@ -709,7 +721,7 @@ cgraph_decide_recursive_inlining (struct cgraph_edge *edge,\n \n   /* It does not make sense to recursively inline always-inline functions\n      as we are going to sorry() on the remaining calls anyway.  */\n-  if (node->local.disregard_inline_limits\n+  if (inline_summary (node)->disregard_inline_limits\n       && lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (node->decl)))\n     return false;\n \n@@ -811,8 +823,8 @@ cgraph_decide_recursive_inlining (struct cgraph_edge *edge,\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"\\n   Inlined %i times, body grown from size %i to %i, time %i to %i\\n\", n,\n-\t     master_clone->global.size, node->global.size,\n-\t     master_clone->global.time, node->global.time);\n+\t     inline_summary (master_clone)->size, inline_summary (node)->size,\n+\t     inline_summary (master_clone)->time, inline_summary (node)->time);\n \n   /* Remove master clone we used for inlining.  We rely that clones inlined\n      into master clone gets queued just before master clone so we don't\n@@ -870,7 +882,7 @@ add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n       struct cgraph_edge *edge = VEC_pop (cgraph_edge_p, new_edges);\n \n       gcc_assert (!edge->aux);\n-      if (edge->callee->local.inlinable\n+      if (inline_summary (edge->callee)->inlinable\n \t  && edge->inline_failed\n \t  && cgraph_default_inline_p (edge->callee, &edge->inline_failed))\n         edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n@@ -905,26 +917,37 @@ cgraph_decide_inlining_of_small_functions (void)\n   /* Put all inline candidates into the heap.  */\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      if (!node->local.inlinable || !node->callers)\n-\tcontinue;\n-      if (dump_file)\n-\tfprintf (dump_file, \"Considering inline candidate %s.\\n\", cgraph_node_name (node));\n+    if (node->analyzed)\n+      {\n+\tstruct inline_summary *info = inline_summary (node);\n \n-      node->global.estimated_growth = INT_MIN;\n-      if (!cgraph_default_inline_p (node, &failed_reason))\n-\t{\n-\t  cgraph_set_inline_failed (node, failed_reason);\n-\t  continue;\n-\t}\n+\tif (!info->inlinable || !node->callers)\n+\t  {\n+\t    struct cgraph_edge *e;\n+\t    for (e = node->callers; e; e = e->next_caller)\n+\t      {\n+\t\tgcc_assert (e->inline_failed);\n+\t\te->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n+\t      }\n+\t    continue;\n+\t  }\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"Considering inline candidate %s.\\n\", cgraph_node_name (node));\n \n-      for (edge = node->callers; edge; edge = edge->next_caller)\n-\tif (edge->inline_failed)\n+\tinfo->estimated_growth = INT_MIN;\n+\tif (!cgraph_default_inline_p (node, &failed_reason))\n \t  {\n-\t    gcc_assert (!edge->aux);\n-\t    edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n+\t    cgraph_set_inline_failed (node, failed_reason);\n+\t    continue;\n \t  }\n-    }\n+\n+\tfor (edge = node->callers; edge; edge = edge->next_caller)\n+\t  if (edge->inline_failed)\n+\t    {\n+\t      gcc_assert (!edge->aux);\n+\t      edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n+\t    }\n+      }\n \n   max_size = compute_max_insns (overall_size);\n   min_size = overall_size;\n@@ -963,7 +986,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nConsidering %s with %i size\\n\",\n \t\t   cgraph_node_name (edge->callee),\n-\t\t   edge->callee->global.size);\n+\t\t   inline_summary (edge->callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" to be inlined into %s in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all callees is %+i insns.\\n\"\n@@ -1007,15 +1030,15 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  if (where->global.inlined_to)\n \t    {\n \t      edge->inline_failed\n-\t\t= (edge->callee->local.disregard_inline_limits\n+\t\t= (inline_summary (edge->callee)->disregard_inline_limits\n \t\t   ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" inline_failed:Recursive inlining performed only for function itself.\\n\");\n \t      continue;\n \t    }\n \t}\n \n-      if (edge->callee->local.disregard_inline_limits)\n+      if (inline_summary (edge->callee)->disregard_inline_limits)\n \t;\n       else if (!cgraph_maybe_hot_edge_p (edge))\n  \tnot_good = CIF_UNLIKELY_CALL;\n@@ -1112,8 +1135,8 @@ cgraph_decide_inlining_of_small_functions (void)\n \t\t   \" Inlined into %s which now has time %i and size %i,\"\n \t\t   \"net change of %+i.\\n\",\n \t\t   cgraph_node_name (edge->caller),\n-\t\t   edge->caller->global.time,\n-\t\t   edge->caller->global.size,\n+\t\t   inline_summary (edge->caller)->time,\n+\t\t   inline_summary (edge->caller)->size,\n \t\t   overall_size - old_size);\n \t}\n       if (min_size > overall_size)\n@@ -1142,7 +1165,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  fprintf (dump_file,\n \t\t   \"\\nSkipping %s with %i size\\n\",\n \t\t   cgraph_node_name (edge->callee),\n-\t\t   edge->callee->global.size);\n+\t\t   inline_summary (edge->callee)->size);\n \t  fprintf (dump_file,\n \t\t   \" called by %s in %s:%i\\n\"\n \t\t   \" Estimated growth after inlined into all callees is %+i insns.\\n\"\n@@ -1159,7 +1182,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  if (dump_flags & TDF_DETAILS)\n \t    cgraph_edge_badness (edge, true);\n \t}\n-      if (!edge->callee->local.disregard_inline_limits && edge->inline_failed)\n+      if (!inline_summary (edge->callee)->disregard_inline_limits && edge->inline_failed)\n \tedge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n     }\n \n@@ -1287,13 +1310,14 @@ cgraph_decide_inlining (void)\n     if (node->analyzed)\n       {\n \tstruct cgraph_edge *e;\n+\tstruct inline_summary *info = inline_summary (node);\n \n-\tgcc_assert (inline_summary (node)->self_size == node->global.size);\n+\tgcc_assert (info->self_size == info->size);\n \tif (!DECL_EXTERNAL (node->decl))\n-\t  initial_size += node->global.size;\n+\t  initial_size += info->size;\n \tfor (e = node->callees; e; e = e->next_callee)\n \t  {\n-\t    int benefit = (inline_summary (node)->time_inlining_benefit\n+\t    int benefit = (info->time_inlining_benefit\n \t\t\t   + e->call_stmt_time);\n \t    if (max_count < e->count)\n \t      max_count = e->count;\n@@ -1362,7 +1386,7 @@ cgraph_decide_inlining (void)\n \t      && !node->callers->next_caller\n \t      && !node->global.inlined_to\n \t      && cgraph_will_be_removed_from_program_if_no_direct_calls (node)\n-\t      && node->local.inlinable\n+\t      && inline_summary (node)->inlinable\n \t      && cgraph_function_body_availability (node) >= AVAIL_AVAILABLE\n \t      && node->callers->inline_failed\n \t      && node->callers->caller != node\n@@ -1377,11 +1401,11 @@ cgraph_decide_inlining (void)\n \t\t{\n \t\t  fprintf (dump_file,\n \t\t\t   \"\\nConsidering %s size %i.\\n\",\n-\t\t\t   cgraph_node_name (node), node->global.size);\n+\t\t\t   cgraph_node_name (node), inline_summary (node)->size);\n \t\t  fprintf (dump_file,\n \t\t\t   \" Called once from %s %i insns.\\n\",\n \t\t\t   cgraph_node_name (node->callers->caller),\n-\t\t\t   node->callers->caller->global.size);\n+\t\t\t   inline_summary (node->callers->caller)->size);\n \t\t}\n \n \t      if (cgraph_check_inline_limits (node->callers, &reason))\n@@ -1393,7 +1417,7 @@ cgraph_decide_inlining (void)\n \t\t\t     \" Inlined into %s which now has %i size\"\n \t\t\t     \" for a net change of %+i size.\\n\",\n \t\t\t     cgraph_node_name (caller),\n-\t\t\t     caller->global.size,\n+\t\t\t     inline_summary (caller)->size,\n \t\t\t     overall_size - old_size);\n \t\t}\n \t      else\n@@ -1442,7 +1466,7 @@ leaf_node_p (struct cgraph_node *n)\n static bool\n cgraph_edge_early_inlinable_p (struct cgraph_edge *e, FILE *file)\n {\n-  if (!e->callee->local.inlinable)\n+  if (!inline_summary (e->callee)->inlinable)\n     {\n       if (file)\n \tfprintf (file, \"Not inlining: Function not inlinable.\\n\");\n@@ -1482,7 +1506,7 @@ cgraph_perform_always_inlining (struct cgraph_node *node)\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n-      if (!e->callee->local.disregard_inline_limits)\n+      if (!inline_summary (e->callee)->disregard_inline_limits)\n \tcontinue;\n \n       if (dump_file)\n@@ -1524,16 +1548,16 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n \n   /* Never inline regular functions into always-inline functions\n      during incremental inlining.  */\n-  if (node->local.disregard_inline_limits)\n+  if (inline_summary (node)->disregard_inline_limits)\n     return false;\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n       int allowed_growth = 0;\n \n-      if (!e->callee->local.inlinable\n+      if (!inline_summary (e->callee)->inlinable\n \t  || !e->inline_failed\n-\t  || e->callee->local.disregard_inline_limits)\n+\t  || inline_summary (e->callee)->disregard_inline_limits)\n \tcontinue;\n \n       /* Do not consider functions not declared inline.  */"}, {"sha": "58bcdd968b94de9afc3ff7f509fdc40ff381ce2d", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -23,9 +23,10 @@ along with GCC; see the file COPYING3.  If not see\n \n struct inline_summary\n {\n+  /* Information about the function body itself.  */\n+\n   /* Estimated stack frame consumption by the function.  */\n   HOST_WIDE_INT estimated_self_stack_size;\n-\n   /* Size of the function body.  */\n   int self_size;\n   /* How many instructions are likely going to disappear after inlining.  */\n@@ -34,6 +35,29 @@ struct inline_summary\n   int self_time;\n   /* How much time is going to be saved by inlining.  */\n   int time_inlining_benefit;\n+\n+  /* False when there something makes inlining impossible (such as va_arg).  */\n+  unsigned inlinable : 1;\n+  /* False when there something makes versioning impossible.\n+     Currently computed and used only by ipa-cp.  */\n+  unsigned versionable : 1;\n+  /* True when function should be inlined independently on its size.  */\n+  unsigned disregard_inline_limits : 1;\n+\n+  /* Information about function that will result after applying all the\n+     inline decisions present in the callgraph.  Generally kept up to\n+     date only for functions that are not inline clones. */\n+\n+  /* Estimated stack frame consumption by the function.  */\n+  HOST_WIDE_INT estimated_stack_size;\n+  /* Expected offset of the stack frame of inlined function.  */\n+  HOST_WIDE_INT stack_frame_offset;\n+  /* Estimated size of the function after inlining.  */\n+  int time;\n+  int size;\n+  /* Cached estimated growth after inlining.\n+     INT_MIN if not computed.  */\n+  int estimated_growth;\n };\n \n typedef struct inline_summary inline_summary_t;\n@@ -47,6 +71,7 @@ void inline_generate_summary (void);\n void inline_read_summary (void);\n void inline_write_summary (cgraph_node_set, varpool_node_set);\n void inline_free_summary (void);\n+void initialize_inline_failed (struct cgraph_edge *);\n int estimate_time_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_size_after_inlining (struct cgraph_node *, struct cgraph_edge *);\n int estimate_growth (struct cgraph_node *);\n@@ -63,10 +88,10 @@ static inline int\n estimate_edge_growth (struct cgraph_edge *edge)\n {\n   int call_stmt_size;\n+  struct inline_summary *info = inline_summary (edge->callee);\n   call_stmt_size = edge->call_stmt_size;\n   gcc_checking_assert (call_stmt_size);\n-  return (edge->callee->global.size\n-\t  - inline_summary (edge->callee)->size_inlining_benefit\n+  return (info->size\n+\t  - info->size_inlining_benefit\n \t  - call_stmt_size);\n }\n-"}, {"sha": "47109abf37ee782fbd5ac99d40c283a45780c303", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -92,6 +92,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fibheap.h\"\n #include \"params.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"ipa-inline.h\"\n \n /* Per basic block info.  */\n \n@@ -1281,13 +1282,13 @@ execute_split_functions (void)\n     }\n   /* This can be relaxed; function might become inlinable after splitting\n      away the uninlinable part.  */\n-  if (!node->local.inlinable)\n+  if (!inline_summary (node)->inlinable)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");\n       return 0;\n     }\n-  if (node->local.disregard_inline_limits)\n+  if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: disregarding inline limits.\\n\");"}, {"sha": "e58fb23b256c50a5c4da87b31e8d83b97cf193ca", "filename": "gcc/ipa.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -78,8 +78,8 @@ cgraph_postorder (struct cgraph_node **order)\n \t\t  /* Break possible cycles involving always-inline\n \t\t     functions by ignoring edges from always-inline\n \t\t     functions to non-always-inline functions.  */\n-\t\t  if (edge->caller->local.disregard_inline_limits\n-\t\t      && !edge->callee->local.disregard_inline_limits)\n+\t\t  if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->decl)\n+\t\t      && !DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl))\n \t\t    continue;\n \t\t  if (!edge->caller->aux)\n \t\t    {\n@@ -380,7 +380,6 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  cgraph_node_remove_callees (node);\n \t  ipa_remove_all_references (&node->ref_list);\n \t  node->analyzed = false;\n-\t  node->local.inlinable = false;\n \t}\n       if (!node->aux)\n \t{\n@@ -421,7 +420,6 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t  if (!clone)\n \t\t    {\n \t\t      cgraph_release_function_body (node);\n-\t\t      node->local.inlinable = false;\n \t\t      if (node->prev_sibling_clone)\n \t\t\tnode->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n \t\t      else if (node->clone_of)\n@@ -1629,7 +1627,7 @@ record_cdtor_fn (struct cgraph_node *node)\n   if (DECL_STATIC_DESTRUCTOR (node->decl))\n     VEC_safe_push (tree, heap, static_dtors, node->decl);\n   node = cgraph_get_node (node->decl);\n-  node->local.disregard_inline_limits = 1;\n+  DECL_DISREGARD_INLINE_LIMITS (node->decl) = 1;\n }\n \n /* Define global constructors/destructor functions for the CDTORS, of"}, {"sha": "861a37b55a1fb8c50fcadb8c728028b3a08654b1", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -489,10 +489,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->local.local, 1);\n   bp_pack_value (&bp, node->local.externally_visible, 1);\n   bp_pack_value (&bp, node->local.finalized, 1);\n-  bp_pack_value (&bp, node->local.inlinable, 1);\n-  bp_pack_value (&bp, node->local.versionable, 1);\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n-  bp_pack_value (&bp, node->local.disregard_inline_limits, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n   bp_pack_value (&bp, node->local.vtable_method, 1);\n   bp_pack_value (&bp, node->needed, 1);\n@@ -928,10 +925,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->local.local = bp_unpack_value (bp, 1);\n   node->local.externally_visible = bp_unpack_value (bp, 1);\n   node->local.finalized = bp_unpack_value (bp, 1);\n-  node->local.inlinable = bp_unpack_value (bp, 1);\n-  node->local.versionable = bp_unpack_value (bp, 1);\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n-  node->local.disregard_inline_limits = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n   node->local.vtable_method = bp_unpack_value (bp, 1);\n   node->needed = bp_unpack_value (bp, 1);"}, {"sha": "6c87a38f9ae51ff73a3e934e15fb13867a57d48e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -1,3 +1,7 @@\n+2011-04-16  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_balanced_map): Update.\n+\n 2011-04-14  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c: Include ipa-inline.h"}, {"sha": "f515aaac94f6f48dfee79443b096a44cf3681f11", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -1030,7 +1030,7 @@ lto_balanced_map (void)\n       if (partition_cgraph_node_p (node))\n \t{\n \t  order[n_nodes++] = node;\n-          total_size += node->global.size;\n+          total_size += inline_summary (node)->size;\n \t}\n     }\n   free (postorder);\n@@ -1049,7 +1049,7 @@ lto_balanced_map (void)\n     {\n       if (!order[i]->aux)\n         add_cgraph_node_to_partition (partition, order[i]);\n-      total_size -= order[i]->global.size;\n+      total_size -= inline_summary (order[i])->size;\n \n       /* Once we added a new node to the partition, we also want to add\n          all referenced variables unless they was already added into some"}, {"sha": "56a93462d33cc8c809a73428755f4cb3b7c4c454", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7f2301855b432e057acd267e5df455fee60abef/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=e7f2301855b432e057acd267e5df455fee60abef", "patch": "@@ -91,6 +91,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"tree-inline.h\"\n #include \"gimple-pretty-print.h\"\n+#include \"ipa-inline.h\"\n \n /* Enumeration of all aggregate reductions we can do.  */\n enum sra_mode { SRA_MODE_EARLY_IPA,   /* early call regularization */\n@@ -4469,7 +4470,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n     }\n \n   if ((DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n-      && node->global.size >= MAX_INLINE_INSNS_AUTO)\n+      && inline_summary(node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function too big to be made truly local.\\n\");"}]}