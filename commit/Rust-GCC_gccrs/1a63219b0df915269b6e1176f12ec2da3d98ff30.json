{"sha": "1a63219b0df915269b6e1176f12ec2da3d98ff30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2MzIxOWIwZGY5MTUyNjliNmUxMTc2ZjEyZWMyZGEzZDk4ZmYzMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-08T23:09:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-08T23:09:52Z"}, "message": "h8300.c: Fix formatting.\n\n        * h8300.c: Fix formatting.\n        * h8300.h: Likewise.\n        * h8300.md: Likewise.\n        (movsi_h8300hs): Fix formatting of the resulting assembly code.\n\nFrom-SVN: r35575", "tree": {"sha": "b9010b672831563ddb98702299e9731a6f42e273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9010b672831563ddb98702299e9731a6f42e273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a63219b0df915269b6e1176f12ec2da3d98ff30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a63219b0df915269b6e1176f12ec2da3d98ff30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a63219b0df915269b6e1176f12ec2da3d98ff30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a63219b0df915269b6e1176f12ec2da3d98ff30/comments", "author": null, "committer": null, "parents": [{"sha": "1d7254c5a75b3a687d2139a0c02faa13920077eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7254c5a75b3a687d2139a0c02faa13920077eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d7254c5a75b3a687d2139a0c02faa13920077eb"}], "stats": {"total": 152, "additions": 79, "deletions": 73}, "files": [{"sha": "730fce0636544b3e63ae322091df3614d1502ade", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a63219b0df915269b6e1176f12ec2da3d98ff30", "patch": "@@ -1,5 +1,10 @@\n 2000-08-08  Kazu Hirata  <kazu@hxi.com>\n \n+\t* h8300.c: Fix formatting.\n+\t* h8300.h: Likewise.\n+\t* h8300.md: Likewise.\n+\t(movsi_h8300hs): Fix formatting of the resulting assembly code.\n+\n \t* reload1.c: Fix formatting.\n \n 2000-08-08  Rodney Brown  <RodneyBrown@mynd.com>"}, {"sha": "48f94ec5e5b1c3a8362ce71e201f5dfc52204a9d", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=1a63219b0df915269b6e1176f12ec2da3d98ff30", "patch": "@@ -167,7 +167,7 @@ dosize (file, op, size)\n \t   amount > 0;\n \t   amount /= 2)\n \t{\n-\t  for(; size >= amount; size -= amount)\n+\t  for (; size >= amount; size -= amount)\n \t    fprintf (file, \"\\t%ss\\t#%d,sp\\n\", op, amount);\n \t}\n     }\n@@ -612,7 +612,7 @@ split_adds_subs (mode, operands)\n        amount > 0;\n        amount /= 2)\n     {\n-      for(; val >= amount; val -= amount)\n+      for (; val >= amount; val -= amount)\n \t{\n \t  rtx tmp = gen_rtx_PLUS (mode, reg, GEN_INT (sign * amount));\n \t  emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n@@ -1773,16 +1773,16 @@ enum shift_alg\n /* Symbols of the various shifts which can be used as indices.  */\n \n enum shift_type\n-  {\n-    SHIFT_ASHIFT, SHIFT_LSHIFTRT, SHIFT_ASHIFTRT\n-  };\n+{\n+  SHIFT_ASHIFT, SHIFT_LSHIFTRT, SHIFT_ASHIFTRT\n+};\n \n /* Symbols of the various modes which can be used as indices.  */\n \n enum shift_mode\n-  {\n-    QIshift, HIshift, SIshift\n-  };\n+{\n+  QIshift, HIshift, SIshift\n+};\n \n /* For single bit shift insns, record assembler and what bits of the\n    condition code are valid afterwards (represented as various CC_FOO\n@@ -2680,7 +2680,8 @@ fix_bit_operand (operands, what, type)\n       if (CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), what))\n \t{\n \t  /* Ok to have a memory dest.  */\n-\t  if (GET_CODE (operands[0]) == MEM && !EXTRA_CONSTRAINT (operands[0], 'U'))\n+\t  if (GET_CODE (operands[0]) == MEM\n+\t      && !EXTRA_CONSTRAINT (operands[0], 'U'))\n \t    {\n \t      rtx mem = gen_rtx_MEM (GET_MODE (operands[0]),\n \t\t\t\t     copy_to_mode_reg (Pmode,\n@@ -2689,7 +2690,8 @@ fix_bit_operand (operands, what, type)\n \t      operands[0] = mem;\n \t    }\n \n-\t  if (GET_CODE (operands[1]) == MEM && !EXTRA_CONSTRAINT (operands[1], 'U'))\n+\t  if (GET_CODE (operands[1]) == MEM\n+\t      && !EXTRA_CONSTRAINT (operands[1], 'U'))\n \t    {\n \t      rtx mem = gen_rtx_MEM (GET_MODE (operands[1]),\n \t\t\t\t     copy_to_mode_reg (Pmode,"}, {"sha": "17015a1326381133a5da3a88c8f557a1be7d9a22", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=1a63219b0df915269b6e1176f12ec2da3d98ff30", "patch": "@@ -410,35 +410,35 @@ enum reg_class {\n #define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n #define CONST_OK_FOR_J(VALUE) ((unsigned HOST_WIDE_INT) (VALUE) < 256)\n #define CONST_OK_FOR_K(VALUE) ((VALUE) == 1 || (VALUE) == 2)\n-#define CONST_OK_FOR_L(VALUE) \\\n-  (TARGET_H8300H || TARGET_H8300S \\\n-   ? (VALUE) == 1 || (VALUE) == 2 || (VALUE) == 4 \\\n+#define CONST_OK_FOR_L(VALUE)\t\t\t\t\\\n+  (TARGET_H8300H || TARGET_H8300S\t\t\t\\\n+   ? (VALUE) == 1 || (VALUE) == 2 || (VALUE) == 4\t\\\n    : (VALUE) == 1 || (VALUE) == 2)\n #define CONST_OK_FOR_M(VALUE) ((VALUE) == 3 || (VALUE) == 4)\n-#define CONST_OK_FOR_N(VALUE) \\\n-  (TARGET_H8300H || TARGET_H8300S \\\n-   ? (VALUE) == -1 || (VALUE) == -2 || (VALUE) == -4 \\\n+#define CONST_OK_FOR_N(VALUE)\t\t\t\t\\\n+  (TARGET_H8300H || TARGET_H8300S\t\t\t\\\n+   ? (VALUE) == -1 || (VALUE) == -2 || (VALUE) == -4\t\\\n    : (VALUE) == -1 || (VALUE) == -2)\n #define CONST_OK_FOR_O(VALUE) (ok_for_bclr (VALUE))\n #define CONST_OK_FOR_P(VALUE) (small_power_of_two (VALUE))\n \n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n-   (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n-   (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n-   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n-   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : \\\n-   (C) == 'N' ? CONST_OK_FOR_N (VALUE) : \\\n-   (C) == 'O' ? CONST_OK_FOR_O (VALUE) : \\\n-   (C) == 'P' ? CONST_OK_FOR_P (VALUE) : \\\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n+  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) :\t\\\n+   (C) == 'J' ? CONST_OK_FOR_J (VALUE) :\t\\\n+   (C) == 'K' ? CONST_OK_FOR_K (VALUE) :\t\\\n+   (C) == 'L' ? CONST_OK_FOR_L (VALUE) :\t\\\n+   (C) == 'M' ? CONST_OK_FOR_M (VALUE) :\t\\\n+   (C) == 'N' ? CONST_OK_FOR_N (VALUE) :\t\\\n+   (C) == 'O' ? CONST_OK_FOR_O (VALUE) :\t\\\n+   (C) == 'P' ? CONST_OK_FOR_P (VALUE) :\t\\\n    0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n    Here VALUE is the CONST_DOUBLE rtx itself. \n      \n   `G' is a floating-point zero.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n   ((C) == 'G' ? (VALUE) == CONST0_RTX (DFmode)\t\\\n    : 0)\n \n@@ -629,8 +629,8 @@ struct cum_arg\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\\\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+ ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\t\t\\\n   ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD\t\\\n   : (int_size_in_bytes (TYPE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD))\n \n@@ -734,7 +734,7 @@ struct cum_arg\n     else\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tfprintf (FILE, \"\\tmov.l\t#0x12345678,er3\\n\");\t\\\n-\tfprintf (FILE, \"\\tjmp\t@0x123456\\n\");\t\\\n+\tfprintf (FILE, \"\\tjmp\t@0x123456\\n\");\t\t\\\n       }\t\t\t\t\t\t\t\\\n   } while (0)\n \n@@ -783,7 +783,7 @@ struct cum_arg\n \n /* 1 if X is an rtx for a constant that is a valid address.  */\n \n-#define CONSTANT_ADDRESS_P(X)   \\\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\\\n   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n    || (GET_CODE (X) == CONST_INT\t\t\t\t\\\n        /* We handle signed and unsigned offsets here.  */\t\\\n@@ -1021,18 +1021,18 @@ h8300_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    switch on CODE.  */\n /* ??? Shifts need to have a *much* higher cost than this.  */\n \n-#define RTX_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case MOD:\t\t\\\n-  case DIV:\t\t\\\n-    return 60;\t\t\\\n-  case MULT:\t\t\\\n-    return 20;\t\t\\\n-  case ASHIFT:\t\t\\\n-  case ASHIFTRT:\t\\\n-  case LSHIFTRT:\t\\\n-  case ROTATE:\t\t\\\n-  case ROTATERT:\t\\\n-    if (GET_MODE (RTX) == HImode) return 2; \\\n+#define RTX_COSTS(RTX,CODE,OUTER_CODE)\t\t\\\n+  case MOD:\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\\\n+    return 60;\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\\\n+    return 20;\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\\\n+  case ROTATE:\t\t\t\t\t\\\n+  case ROTATERT:\t\t\t\t\\\n+    if (GET_MODE (RTX) == HImode) return 2;\t\\\n     return 8;\n \n /* Tell final.c how to eliminate redundant test instructions.  */\n@@ -1336,14 +1336,14 @@ do { char dstr[30];\t\t\t\t\t\\\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */\n \n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\\\n+  if ((LOG) != 0)\t\t\t\t\\\n     fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n \n /* This is how to output an assembler line\n    that says to advance the location counter by SIZE bytes.  */\n \n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+#define ASM_OUTPUT_IDENT(FILE, NAME)\t\t\t\\\n   fprintf(FILE, \"%s\\t \\\"%s\\\"\\n\", IDENT_ASM_OP, NAME)\n \n #define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n@@ -1352,16 +1352,16 @@ do { char dstr[30];\t\t\t\t\t\\\n /* This says how to output an assembler line\n    to define a global common symbol.  */\n \n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \\\n-( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n+( fputs (\"\\t.comm \", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n   fprintf ((FILE), \",%d\\n\", (SIZE)))\n \n /* This says how to output the assembler to define a global\n    uninitialized but not common symbol.\n    Try to use asm_output_bss to implement this macro.  */\n \n-#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED) \\\n+#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED)\t\t\\\n   asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED))\n \n /* This says how to output an assembler line\n@@ -1437,18 +1437,18 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* Perform target dependent optabs initialization.  */\n \n-#define INIT_TARGET_OPTABS \\\n-  do { \\\n-    smul_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (MULHI3_LIBCALL);\t\t\\\n-    sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (DIVHI3_LIBCALL);\t\t\\\n-    udiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (UDIVHI3_LIBCALL);\t\t\\\n-    smod_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (MODHI3_LIBCALL);\t\t\\\n-    umod_optab->handlers[(int) HImode].libfunc\t\t\\\n-      = init_one_libfunc (UMODHI3_LIBCALL);\t\t\\\n+#define INIT_TARGET_OPTABS\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    smul_optab->handlers[(int) HImode].libfunc\t\\\n+      = init_one_libfunc (MULHI3_LIBCALL);\t\\\n+    sdiv_optab->handlers[(int) HImode].libfunc\t\\\n+      = init_one_libfunc (DIVHI3_LIBCALL);\t\\\n+    udiv_optab->handlers[(int) HImode].libfunc\t\\\n+      = init_one_libfunc (UDIVHI3_LIBCALL);\t\\\n+    smod_optab->handlers[(int) HImode].libfunc\t\\\n+      = init_one_libfunc (MODHI3_LIBCALL);\t\\\n+    umod_optab->handlers[(int) HImode].libfunc\t\\\n+      = init_one_libfunc (UMODHI3_LIBCALL);\t\\\n   } while (0)\n \n #define MOVE_RATIO 3"}, {"sha": "b8731f895f53cf5491ccedf4a9ef933e7d51c5ae", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a63219b0df915269b6e1176f12ec2da3d98ff30/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=1a63219b0df915269b6e1176f12ec2da3d98ff30", "patch": "@@ -144,11 +144,11 @@\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n-  if (!register_operand(operand0, QImode)\n-      && !register_operand(operand1, QImode))\n+  /* One of the ops has to be in a register.  */\n+  if (!register_operand (operand0, QImode)\n+      && !register_operand (operand1, QImode))\n     {\n-      operands[1] = copy_to_mode_reg(QImode, operand1);\n+      operands[1] = copy_to_mode_reg (QImode, operand1);\n     }\n }\")\n \n@@ -208,11 +208,11 @@\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n-  if (!register_operand(operand1, HImode)\n-      && !register_operand(operand0, HImode))\n+  /* One of the ops has to be in a register.  */\n+  if (!register_operand (operand1, HImode)\n+      && !register_operand (operand0, HImode))\n     {\n-      operands[1] = copy_to_mode_reg(HImode, operand1);\n+      operands[1] = copy_to_mode_reg (HImode, operand1);\n     }\n }\")\n \n@@ -426,21 +426,21 @@\n \t  if (val == (val & 0xff))\n \t    {\n \t      operands[1] = GEN_INT ((char) val & 0xff);\n-\t      return \\\"sub.l %S0,%S0\\;add.b %1,%w0\\\";\n+\t      return \\\"sub.l\\\\t%S0,%S0\\;add.b\\\\t%1,%w0\\\";\n \t    }\n \n \t  if (val == (val & 0xff00))\n \t    {\n \t      operands[1] = GEN_INT ((char) (val >> 8) & 0xff);\n-\t      return \\\"sub.l %S0,%S0\\;add.b %1,%x0\\\";\n+\t      return \\\"sub.l\\\\t%S0,%S0\\;add.b\\\\t%1,%x0\\\";\n \t    }\n \n \t  /* Now look for small negative numbers.  We can subtract them\n \t     from zero to get the desired constant.  */\n \t  if (val == -4 || val == -2 || val == -1)\n \t    {\n \t      operands[1] = GEN_INT (-INTVAL (operands[1]));\n-\t      return \\\"sub.l %S0,%S0\\;subs %1,%S0\\\";\n+\t      return \\\"sub.l\\\\t%S0,%S0\\;subs\\\\t%1,%S0\\\";\n \t    }\n \t}\n     }\n@@ -2257,4 +2257,3 @@\n   \"mov.w\t%T0,@-%T1\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_znv\")])\n-"}]}