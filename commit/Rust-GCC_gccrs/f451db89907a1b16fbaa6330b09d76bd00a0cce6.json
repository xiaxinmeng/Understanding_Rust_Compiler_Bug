{"sha": "f451db89907a1b16fbaa6330b09d76bd00a0cce6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ1MWRiODk5MDdhMWIxNmZiYWE2MzMwYjA5ZDc2YmQwMGEwY2NlNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-11T12:46:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-11T12:46:36Z"}, "message": "cse.c (set_nonvarying_address_components): New function.\n\n\t* cse.c (set_nonvarying_address_components): New function.\n\t(invalidate): Use set_nonvarying_address_components instead of\n\tcomputing them.\n\t(refers_to_mem_p): Likewise.  Simplify checks for conflicting\n\tmemory accesses.  Make static.\n\nFrom-SVN: r3703", "tree": {"sha": "c22daeb7b877bbfaf32975cb04bf4faeaf70ef75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c22daeb7b877bbfaf32975cb04bf4faeaf70ef75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f451db89907a1b16fbaa6330b09d76bd00a0cce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f451db89907a1b16fbaa6330b09d76bd00a0cce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f451db89907a1b16fbaa6330b09d76bd00a0cce6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f451db89907a1b16fbaa6330b09d76bd00a0cce6/comments", "author": null, "committer": null, "parents": [{"sha": "6f9c49e07d99e920512097bd07e3f5c1c00911d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9c49e07d99e920512097bd07e3f5c1c00911d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9c49e07d99e920512097bd07e3f5c1c00911d8"}], "stats": {"total": 198, "additions": 88, "deletions": 110}, "files": [{"sha": "979df3fa2f62eb150a39edde8b7b24a4e9a45086", "filename": "gcc/cse.c", "status": "modified", "additions": 88, "deletions": 110, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f451db89907a1b16fbaa6330b09d76bd00a0cce6/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f451db89907a1b16fbaa6330b09d76bd00a0cce6/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f451db89907a1b16fbaa6330b09d76bd00a0cce6", "patch": "@@ -603,8 +603,10 @@ static rtx use_related_value\tPROTO((rtx, struct table_elt *));\n static int canon_hash\t\tPROTO((rtx, enum machine_mode));\n static int safe_hash\t\tPROTO((rtx, enum machine_mode));\n static int exp_equiv_p\t\tPROTO((rtx, rtx, int, int));\n+static void set_nonvarying_address_components PROTO((rtx, int, rtx *,\n+\t\t\t\t\t\t     int *, int *));\n static int refers_to_p\t\tPROTO((rtx, rtx));\n-int refers_to_mem_p\t\tPROTO((rtx, rtx, HOST_WIDE_INT,\n+static int refers_to_mem_p\tPROTO((rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT));\n static int cse_rtx_addr_varies_p PROTO((rtx));\n static rtx canon_reg\t\tPROTO((rtx, rtx));\n@@ -1451,8 +1453,8 @@ invalidate (x)\n {\n   register int i;\n   register struct table_elt *p;\n-  register rtx base;\n-  register HOST_WIDE_INT start, end;\n+  rtx base;\n+  HOST_WIDE_INT start, end;\n \n   /* If X is a register, dependencies on its contents\n      are recorded through the qty number mechanism.\n@@ -1531,38 +1533,10 @@ invalidate (x)\n \n   if (GET_CODE (x) != MEM)\n     abort ();\n-  base = XEXP (x, 0);\n-  start = 0;\n \n-  /* Registers with nonvarying addresses usually have constant equivalents;\n-     but the frame pointer register is also possible.  */\n-  if (GET_CODE (base) == REG\n-      && REGNO_QTY_VALID_P (REGNO (base))\n-      && qty_mode[reg_qty[REGNO (base)]] == GET_MODE (base)\n-      && qty_const[reg_qty[REGNO (base)]] != 0)\n-    base = qty_const[reg_qty[REGNO (base)]];\n-  else if (GET_CODE (base) == PLUS\n-\t   && GET_CODE (XEXP (base, 1)) == CONST_INT\n-\t   && GET_CODE (XEXP (base, 0)) == REG\n-\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n-\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 0))]]\n-\t       == GET_MODE (XEXP (base, 0)))\n-\t   && qty_const[reg_qty[REGNO (XEXP (base, 0))]])\n-    {\n-      start = INTVAL (XEXP (base, 1));\n-      base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n-    }\n-\n-  if (GET_CODE (base) == CONST)\n-    base = XEXP (base, 0);\n-  if (GET_CODE (base) == PLUS\n-      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n-    {\n-      start += INTVAL (XEXP (base, 1));\n-      base = XEXP (base, 0);\n-    }\n+  set_nonvarying_address_components (XEXP (x, 0), GET_MODE_SIZE (GET_MODE (x)),\n+\t\t\t\t     &base, &start, &end);\n \n-  end = start + GET_MODE_SIZE (GET_MODE (x));\n   for (i = 0; i < NBUCKETS; i++)\n     {\n       register struct table_elt *next;\n@@ -2212,20 +2186,87 @@ refers_to_p (x, y)\n   return 0;\n }\n \f\n+/* Given ADDR and SIZE (a memory address, and the size of the memory reference),\n+   set PBASE, PSTART, and PEND which correspond to the base of the address,\n+   the starting offset, and ending offset respectively.\n+\n+   ADDR is known to be a nonvarying address. \n+\n+   cse_address_varies_p returns zero for nonvarying addresses.  */\n+\n+static void\n+set_nonvarying_address_components (addr, size, pbase, pstart, pend)\n+     rtx addr;\n+     int size;\n+     rtx *pbase;\n+     int *pstart, *pend;\n+{\n+  rtx base;\n+  int start, end;\n+\n+  base = addr;\n+  start = 0;\n+  end = 0;\n+\n+  /* Registers with nonvarying addresses usually have constant equivalents;\n+     but the frame pointer register is also possible.  */\n+  if (GET_CODE (base) == REG\n+      && qty_const != 0\n+      && REGNO_QTY_VALID_P (REGNO (base))\n+      && qty_mode[reg_qty[REGNO (base)]] == GET_MODE (base)\n+      && qty_const[reg_qty[REGNO (base)]] != 0)\n+    base = qty_const[reg_qty[REGNO (base)]];\n+  else if (GET_CODE (base) == PLUS\n+\t   && GET_CODE (XEXP (base, 1)) == CONST_INT\n+\t   && GET_CODE (XEXP (base, 0)) == REG\n+\t   && qty_const != 0\n+\t   && REGNO_QTY_VALID_P (REGNO (XEXP (base, 0)))\n+\t   && (qty_mode[reg_qty[REGNO (XEXP (base, 0))]]\n+\t       == GET_MODE (XEXP (base, 0)))\n+\t   && qty_const[reg_qty[REGNO (XEXP (base, 0))]])\n+    {\n+      start = INTVAL (XEXP (base, 1));\n+      base = qty_const[reg_qty[REGNO (XEXP (base, 0))]];\n+    }\n+\n+  /* By definition, operand1 of a LO_SUM is the associated constant\n+     address.  Use the associated constant address as the base instead.  */\n+  if (GET_CODE (base) == LO_SUM)\n+    base = XEXP (base, 1);\n+\n+  /* Strip off CONST.  */\n+  if (GET_CODE (base) == CONST)\n+    base = XEXP (base, 0);\n+\n+  if (GET_CODE (base) == PLUS\n+      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n+    {\n+      start += INTVAL (XEXP (base, 1));\n+      base = XEXP (base, 0);\n+    }\n+\n+  end = start + size;\n+\n+  /* Set the return values.  */\n+  *pbase = base;\n+  *pstart = start;\n+  *pend = end;\n+}\n+\n /* Return 1 iff any subexpression of X refers to memory\n    at an address of BASE plus some offset\n    such that any of the bytes' offsets fall between START (inclusive)\n    and END (exclusive).\n \n-   The value is undefined if X is a varying address.\n-   This function is not used in such cases.\n+   The value is undefined if X is a varying address (as determined by\n+   cse_rtx_addr_varies_p).  This function is not used in such cases.\n \n    When used in the cse pass, `qty_const' is nonzero, and it is used\n    to treat an address that is a register with a known constant value\n    as if it were that constant value.\n    In the loop pass, `qty_const' is zero, so this is not done.  */\n \n-int\n+static int\n refers_to_mem_p (x, base, start, end)\n      rtx x, base;\n      HOST_WIDE_INT start, end;\n@@ -2249,83 +2290,20 @@ refers_to_mem_p (x, base, start, end)\n   if (code == MEM)\n     {\n       register rtx addr = XEXP (x, 0);\t/* Get the address.  */\n-      int myend;\n-\n-      i = 0;\n-      if (GET_CODE (addr) == REG\n-\t  /* qty_const is 0 when outside the cse pass;\n-\t     at such times, this info is not available.  */\n-\t  && qty_const != 0\n-\t  && REGNO_QTY_VALID_P (REGNO (addr))\n-\t  && GET_MODE (addr) == qty_mode[reg_qty[REGNO (addr)]]\n-\t  && qty_const[reg_qty[REGNO (addr)]] != 0)\n-\taddr = qty_const[reg_qty[REGNO (addr)]];\n-      else if (GET_CODE (addr) == PLUS\n-\t       && GET_CODE (XEXP (addr, 1)) == CONST_INT\n-\t       && GET_CODE (XEXP (addr, 0)) == REG\n-\t       && qty_const != 0\n-\t       && REGNO_QTY_VALID_P (REGNO (XEXP (addr, 0)))\n-\t       && (GET_MODE (XEXP (addr, 0))\n-\t\t   == qty_mode[reg_qty[REGNO (XEXP (addr, 0))]])\n-\t       && qty_const[reg_qty[REGNO (XEXP (addr, 0))]])\n-\t{\n-\t  i = INTVAL (XEXP (addr, 1));\n-\t  addr = qty_const[reg_qty[REGNO (XEXP (addr, 0))]];\n-\t}\n+      rtx mybase;\n+      int mystart, myend;\n \n-    check_addr:\n-      if (GET_CODE (addr) == CONST)\n-\taddr = XEXP (addr, 0);\n-\n-      /* If ADDR is BASE, or BASE plus an integer, put\n-\t the integer in I.  */\n-      if (GET_CODE (addr) == PLUS\n-\t  && XEXP (addr, 0) == base\n-\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-\ti += INTVAL (XEXP (addr, 1));\n-      else if (GET_CODE (addr) == LO_SUM)\n-\t{\n-\t  if (GET_CODE (base) != LO_SUM)\n-\t    return 1;\n-\t  /* The REG component of the LO_SUM is known by the\n-\t     const value in the XEXP part.  */\n-\t  addr = XEXP (addr, 1);\n-\t  base = XEXP (base, 1);\n-\t  i = 0;\n-\t  if (GET_CODE (base) == CONST)\n-\t    base = XEXP (base, 0);\n-\t  if (GET_CODE (base) == PLUS\n-\t      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n-\t    {\n-\t      HOST_WIDE_INT tem = INTVAL (XEXP (base, 1));\n-\t      start += tem;\n-\t      end += tem;\n-\t      base = XEXP (base, 0);\n-\t    }\n-\t  goto check_addr;\n-\t}\n-      else if (GET_CODE (base) == LO_SUM)\n-\t{\n-\t  base = XEXP (base, 1);\n-\t  if (GET_CODE (base) == CONST)\n-\t    base = XEXP (base, 0);\n-\t  if (GET_CODE (base) == PLUS\n-\t      && GET_CODE (XEXP (base, 1)) == CONST_INT)\n-\t    {\n-\t      HOST_WIDE_INT tem = INTVAL (XEXP (base, 1));\n-\t      start += tem;\n-\t      end += tem;\n-\t      base = XEXP (base, 0);\n-\t    }\n-\t  goto check_addr;\t  \n-\t}\n-      else if (GET_CODE (addr) == CONST_INT && base == const0_rtx)\n-\ti = INTVAL (addr);\n-      else if (addr != base)\n+      set_nonvarying_address_components (addr, GET_MODE_SIZE (GET_MODE (x)),\n+\t\t\t\t\t &mybase, &mystart, &myend);\n+\n+\n+      /* refers_to_mem_p is never called with varying addresses. \n+\t If the base addresses are not equal, there is no chance\n+\t of the memory addresses conflicting.  */\n+      if (mybase != base)\n \treturn 0;\n \n-      myend = i + GET_MODE_SIZE (GET_MODE (x));\n-      return myend > start && i < end;\n+      return myend > start && mystart < end;\n     }\n \n   /* X does not match, so try its subexpressions.  */"}]}