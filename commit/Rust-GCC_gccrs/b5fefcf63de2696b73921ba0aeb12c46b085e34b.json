{"sha": "b5fefcf63de2696b73921ba0aeb12c46b085e34b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjVmZWZjZjYzZGUyNjk2YjczOTIxYmEwYWViMTJjNDZiMDg1ZTM0Yg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-17T21:16:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-17T21:16:07Z"}, "message": "tree-ssa-dom.c (const_and_copies_stack): New.\n\n\n\t* tree-ssa-dom.c (const_and_copies_stack): New.\n\t(dom_walk_block_data): Remove const_and_copies field.\n\t(record_const_or_copy): No longer need to pass in varray_type *.\n\tUse CONST_AND_COPIES_STACK rather than passed in block local stack.\n\tCallers updated.\n\t(record_equality): Similarly.\n\t(restore_vars_to_original_value): Similarly.  Revamp to use new\n\tsingle global stack rather than per-block stacks.\n\t(tree_ssa_dominator_optimize): Initialize the CONST_AND_COPIES_STACK.\n\t(thread_across_edge): Remove now unused parameters.\n\t(dom_opt_initialize_block_local_data): No longer test the block\n\tlocal CONST_AND_COPIES.\n\t(dom_opt_initialize_block): Push a marker on CONST_AND_COPIES_STACK.\n\nFrom-SVN: r87670", "tree": {"sha": "e3c0ee1dcd23be9842f0916b2f6e6b1a2652f157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3c0ee1dcd23be9842f0916b2f6e6b1a2652f157"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5fefcf63de2696b73921ba0aeb12c46b085e34b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5fefcf63de2696b73921ba0aeb12c46b085e34b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5fefcf63de2696b73921ba0aeb12c46b085e34b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5fefcf63de2696b73921ba0aeb12c46b085e34b/comments", "author": null, "committer": null, "parents": [{"sha": "2c459e748715afd82c0687bb4070b4006444348d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c459e748715afd82c0687bb4070b4006444348d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c459e748715afd82c0687bb4070b4006444348d"}], "stats": {"total": 110, "additions": 56, "deletions": 54}, "files": [{"sha": "70a193ca095c27559ac020ad66876ca13e6596ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5fefcf63de2696b73921ba0aeb12c46b085e34b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5fefcf63de2696b73921ba0aeb12c46b085e34b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5fefcf63de2696b73921ba0aeb12c46b085e34b", "patch": "@@ -1,3 +1,19 @@\n+2004-09-17 Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (const_and_copies_stack): New.\n+\t(dom_walk_block_data): Remove const_and_copies field.\n+\t(record_const_or_copy): No longer need to pass in varray_type *.\n+\tUse CONST_AND_COPIES_STACK rather than passed in block local stack.\n+\tCallers updated.\n+\t(record_equality): Similarly.\n+\t(restore_vars_to_original_value): Similarly.  Revamp to use new\n+\tsingle global stack rather than per-block stacks.\n+\t(tree_ssa_dominator_optimize): Initialize the CONST_AND_COPIES_STACK.\n+\t(thread_across_edge): Remove now unused parameters.\n+\t(dom_opt_initialize_block_local_data): No longer test the block\n+\tlocal CONST_AND_COPIES.\n+\t(dom_opt_initialize_block): Push a marker on CONST_AND_COPIES_STACK.\n+\n 2004-09-17  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/17509"}, {"sha": "e0e0b46a9db99d9eb1c49a62e7d627784c48fbe4", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5fefcf63de2696b73921ba0aeb12c46b085e34b/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5fefcf63de2696b73921ba0aeb12c46b085e34b/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=b5fefcf63de2696b73921ba0aeb12c46b085e34b", "patch": "@@ -119,6 +119,12 @@ struct expr_hash_elt\n    propagation).  */\n static varray_type const_and_copies;\n \n+/* Stack of dest,src pairs that need to be restored during finalization.\n+\n+   A NULL entry is used to mark the end of pairs which need to be\n+   restored during finalization of this block.  */\n+static varray_type const_and_copies_stack;\n+\n /* Bitmap of SSA_NAMEs known to have a nonzero value, even if we do not\n    know their exact value.  */\n static bitmap nonzero_vars;\n@@ -201,10 +207,6 @@ static varray_type vrp_data;\n \n struct dom_walk_block_data\n {\n-  /* Array of dest, src pairs that need to be restored during finalization\n-     into the global const/copies table during finalization.  */\n-  varray_type const_and_copies;\n-\n   /* Similarly for the nonzero state of variables that needs to be\n      restored during finalization.  */\n   varray_type nonzero_vars;\n@@ -236,8 +238,8 @@ static int avail_expr_eq (const void *, const void *);\n static void htab_statistics (FILE *, htab_t);\n static void record_cond (tree, tree);\n static void record_dominating_conditions (tree);\n-static void record_const_or_copy (tree, tree, varray_type *);\n-static void record_equality (tree, tree, varray_type *);\n+static void record_const_or_copy (tree, tree);\n+static void record_equality (tree, tree);\n static tree update_rhs_and_lookup_avail_expr (tree, tree, bool);\n static tree simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *,\n \t\t\t\t\t\ttree, int);\n@@ -260,9 +262,7 @@ static void dom_opt_initialize_block_local_data (struct dom_walk_data *,\n static void dom_opt_initialize_block (struct dom_walk_data *, basic_block);\n static void cprop_into_phis (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n-static void restore_vars_to_original_value (varray_type locals,\n-\t\t\t\t\t    unsigned limit, \n-\t\t\t\t\t    varray_type table);\n+static void restore_vars_to_original_value (void);\n static void restore_currdefs_to_original_value (void);\n static void register_definitions_for_stmt (tree);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n@@ -323,6 +323,7 @@ tree_ssa_dominator_optimize (void)\n   VARRAY_TREE_INIT (avail_exprs_stack, 20, \"Available expression stack\");\n   VARRAY_TREE_INIT (block_defs_stack, 20, \"Block DEFS stack\");\n   VARRAY_TREE_INIT (const_and_copies, num_ssa_names, \"const_and_copies\");\n+  VARRAY_TREE_INIT (const_and_copies_stack, 20, \"Block const_and_copies stack\");\n   nonzero_vars = BITMAP_XMALLOC ();\n   VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n   need_eh_cleanup = BITMAP_XMALLOC ();\n@@ -457,8 +458,6 @@ struct tree_opt_pass pass_dominator =\n static void\n thread_across_edge (struct dom_walk_data *walk_data, edge e)\n {\n-  struct dom_walk_block_data *bd\n-    = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n   block_stmt_iterator bsi;\n   tree stmt = NULL;\n   tree phi;\n@@ -468,7 +467,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n     {\n       tree src = PHI_ARG_DEF_FROM_EDGE (phi, e);\n       tree dst = PHI_RESULT (phi);\n-      record_const_or_copy (dst, src, &bd->const_and_copies);\n+      record_const_or_copy (dst, src);\n       register_new_def (dst, &block_defs_stack);\n     }\n \n@@ -583,7 +582,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t We want to record an equivalence lhs = cache_lhs so that if\n \t the result of this statement is used later we can copy propagate\n \t suitably.  */\n-      record_const_or_copy (lhs, cached_lhs, &bd->const_and_copies);\n+      record_const_or_copy (lhs, cached_lhs);\n       register_new_def (lhs, &block_defs_stack);\n     }\n \n@@ -737,8 +736,6 @@ dom_opt_initialize_block_local_data (struct dom_walk_data *walk_data ATTRIBUTE_U\n      make sure we clear them before using them!  */\n   if (recycled)\n     {\n-      gcc_assert (!bd->const_and_copies\n-\t\t  || VARRAY_ACTIVE_SIZE (bd->const_and_copies) == 0);\n       gcc_assert (!bd->nonzero_vars\n \t\t  || VARRAY_ACTIVE_SIZE (bd->nonzero_vars) == 0);\n       gcc_assert (!bd->vrp_variables\n@@ -760,6 +757,7 @@ dom_opt_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n      far to unwind when we finalize this block.  */\n   VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n   VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n+  VARRAY_PUSH_TREE (const_and_copies_stack, NULL_TREE);\n \n   record_equivalences_from_incoming_edge (walk_data, bb);\n \n@@ -849,27 +847,27 @@ restore_nonzero_vars_to_original_value (varray_type locals,\n     }\n }\n \n-/* Use the source/dest pairs in LOCALS to restore TABLE to its original\n-   state, stopping when there are LIMIT entries left in LOCALs.  */\n+/* Use the source/dest pairs in CONST_AND_COPIES_STACK to restore\n+   CONST_AND_COPIES to its original state, stopping when we hit a\n+   NULL marker.  */\n \n static void\n-restore_vars_to_original_value (varray_type locals,\n-\t\t\t\tunsigned limit,\n-\t\t\t\tvarray_type table)\n+restore_vars_to_original_value (void)\n {\n-  if (! locals)\n-    return;\n-\n-  while (VARRAY_ACTIVE_SIZE (locals) > limit)\n+  while (VARRAY_ACTIVE_SIZE (const_and_copies_stack) > 0)\n     {\n       tree prev_value, dest;\n \n-      prev_value = VARRAY_TOP_TREE (locals);\n-      VARRAY_POP (locals);\n-      dest = VARRAY_TOP_TREE (locals);\n-      VARRAY_POP (locals);\n+      dest = VARRAY_TOP_TREE (const_and_copies_stack);\n+      VARRAY_POP (const_and_copies_stack);\n \n-      set_value_for (dest, prev_value, table);\n+      if (dest == NULL)\n+\tbreak;\n+\n+      prev_value = VARRAY_TOP_TREE (const_and_copies_stack);\n+      VARRAY_POP (const_and_copies_stack);\n+\n+      set_value_for (dest, prev_value, const_and_copies);\n     }\n }\n \n@@ -959,16 +957,12 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n       if (get_immediate_dominator (CDI_DOMINATORS, true_edge->dest) != bb\n \t  || phi_nodes (true_edge->dest))\n \t{\n-\t  unsigned const_and_copies_limit;\n-\n-\t  const_and_copies_limit\n-\t    = bd->const_and_copies ? VARRAY_ACTIVE_SIZE (bd->const_and_copies)\n-\t\t\t\t   : 0;\n \t  /* Push a marker onto the available expression stack so that we\n \t     unwind any expressions related to the TRUE arm before processing\n \t     the false arm below.  */\n \t  VARRAY_PUSH_TREE (avail_exprs_stack, NULL_TREE);\n \t  VARRAY_PUSH_TREE (block_defs_stack, NULL_TREE);\n+\t  VARRAY_PUSH_TREE (const_and_copies_stack, NULL_TREE);\n \n \t  /* Record any equivalences created by following this edge.  */\n \t  if (TREE_CODE_CLASS (cond_code) == '<')\n@@ -978,18 +972,15 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t      record_cond (inverted, boolean_false_node);\n \t    }\n \t  else if (cond_code == SSA_NAME)\n-\t    record_const_or_copy (cond, boolean_true_node,\n-\t\t\t\t  &bd->const_and_copies);\n+\t    record_const_or_copy (cond, boolean_true_node);\n \n \t  /* Now thread the edge.  */\n \t  thread_across_edge (walk_data, true_edge);\n \n \t  /* And restore the various tables to their state before\n \t     we threaded this edge.  */\n \t  remove_local_expressions_from_table ();\n-\t  restore_vars_to_original_value (bd->const_and_copies,\n-\t\t\t\t\t  const_and_copies_limit,\n-\t\t\t\t\t  const_and_copies);\n+\t  restore_vars_to_original_value ();\n \t  restore_currdefs_to_original_value ();\n \t}\n \n@@ -1005,8 +996,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t      record_dominating_conditions (inverted);\n \t    }\n \t  else if (cond_code == SSA_NAME)\n-\t    record_const_or_copy (cond, boolean_false_node,\n-\t\t\t\t  &bd->const_and_copies);\n+\t    record_const_or_copy (cond, boolean_false_node);\n \n \t  thread_across_edge (walk_data, false_edge);\n \n@@ -1018,7 +1008,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \n   remove_local_expressions_from_table ();\n   restore_nonzero_vars_to_original_value (bd->nonzero_vars, 0, nonzero_vars);\n-  restore_vars_to_original_value (bd->const_and_copies, 0, const_and_copies);\n+  restore_vars_to_original_value ();\n   restore_currdefs_to_original_value ();\n \n   /* Remove VRP records associated with this basic block.  They are no\n@@ -1282,8 +1272,7 @@ record_equivalences_from_incoming_edge (struct dom_walk_data *walk_data,\n      new value for VAR, so that occurrences of VAR can be replaced with\n      VALUE while re-writing the THEN arm of a COND_EXPR.  */\n   if (eq_expr_value.src && eq_expr_value.dst)\n-    record_equality (eq_expr_value.dst, eq_expr_value.src,\n-\t\t     &bd->const_and_copies);\n+    record_equality (eq_expr_value.dst, eq_expr_value.src);\n }\n \n /* Dump SSA statistics on FILE.  */\n@@ -1527,22 +1516,19 @@ record_dominating_conditions (tree cond)\n    Do the work of recording the value and undo info.  */\n \n static void\n-record_const_or_copy_1 (tree x, tree y, tree prev_x,\n-\t\t\tvarray_type *block_const_and_copies_p)\n+record_const_or_copy_1 (tree x, tree y, tree prev_x)\n {\n   set_value_for (x, y, const_and_copies);\n \n-  if (!*block_const_and_copies_p)\n-    VARRAY_TREE_INIT (*block_const_and_copies_p, 2, \"block_const_and_copies\");\n-  VARRAY_PUSH_TREE (*block_const_and_copies_p, x);\n-  VARRAY_PUSH_TREE (*block_const_and_copies_p, prev_x);\n+  VARRAY_PUSH_TREE (const_and_copies_stack, prev_x);\n+  VARRAY_PUSH_TREE (const_and_copies_stack, x);\n }\n \n /* Record that X is equal to Y in const_and_copies.  Record undo\n    information in the block-local varray.  */\n \n static void\n-record_const_or_copy (tree x, tree y, varray_type *block_const_and_copies_p)\n+record_const_or_copy (tree x, tree y)\n {\n   tree prev_x = get_value_for (x, const_and_copies);\n \n@@ -1553,14 +1539,14 @@ record_const_or_copy (tree x, tree y, varray_type *block_const_and_copies_p)\n \ty = tmp;\n     }\n \n-  record_const_or_copy_1 (x, y, prev_x, block_const_and_copies_p);\n+  record_const_or_copy_1 (x, y, prev_x);\n }\n \n /* Similarly, but assume that X and Y are the two operands of an EQ_EXPR.\n    This constrains the cases in which we may treat this as assignment.  */\n \n static void\n-record_equality (tree x, tree y, varray_type *block_const_and_copies_p)\n+record_equality (tree x, tree y)\n {\n   tree prev_x = NULL, prev_y = NULL;\n \n@@ -1594,7 +1580,7 @@ record_equality (tree x, tree y, varray_type *block_const_and_copies_p)\n \t  || REAL_VALUES_EQUAL (dconst0, TREE_REAL_CST (y))))\n     return;\n \n-  record_const_or_copy_1 (x, y, prev_x, block_const_and_copies_p);\n+  record_const_or_copy_1 (x, y, prev_x);\n }\n \n /* STMT is a MODIFY_EXPR for which we were unable to find RHS in the"}]}