{"sha": "7107ea6fb933f1e928593c7e92edfd64ccf0df63", "node_id": "C_kwDOANBUbNoAKDcxMDdlYTZmYjkzM2YxZTkyODU5M2M3ZTkyZWRmZDY0Y2NmMGRmNjM", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-16T15:10:43Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-09-16T15:10:43Z"}, "message": "c++: 'mutable' member within constexpr [PR92505]\n\nThis patch permits accessing 'mutable' members of local objects during\nconstexpr evaluation, while continuing to reject it for global objects\n(as in the last line of cpp0x/constexpr-mutable1.C).  To distinguish\nbetween the two cases, it looks like it suffices to just check\nCONSTRUCTOR_MUTABLE_POSION in cxx_eval_component_reference before\ndeciding to reject a DECL_MUTABLE_P member access.\n\n\tPR c++/92505\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (cxx_eval_component_reference): Check non_constant_p\n\tsooner.  In C++14 or later, reject a DECL_MUTABLE_P member access\n\tonly if CONSTRUCTOR_MUTABLE_POISION is also set.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/constexpr-mutable3.C: New test.\n\t* g++.dg/cpp1y/constexpr-mutable1.C: New test.", "tree": {"sha": "44af7a855317b9a75d2fd9d6aaf7436c1f88ea31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44af7a855317b9a75d2fd9d6aaf7436c1f88ea31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7107ea6fb933f1e928593c7e92edfd64ccf0df63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7107ea6fb933f1e928593c7e92edfd64ccf0df63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7107ea6fb933f1e928593c7e92edfd64ccf0df63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7107ea6fb933f1e928593c7e92edfd64ccf0df63/comments", "author": null, "committer": null, "parents": [{"sha": "b6adc6255f527edd50c08c4aacb4ee21df1c349c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6adc6255f527edd50c08c4aacb4ee21df1c349c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6adc6255f527edd50c08c4aacb4ee21df1c349c"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "10639876d9cfc45694f8cecd84213e9a5c8abd5c", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7107ea6fb933f1e928593c7e92edfd64ccf0df63/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7107ea6fb933f1e928593c7e92edfd64ccf0df63/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=7107ea6fb933f1e928593c7e92edfd64ccf0df63", "patch": "@@ -4088,6 +4088,8 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     lval,\n \t\t\t\t\t     non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n   if (INDIRECT_REF_P (whole)\n       && integer_zerop (TREE_OPERAND (whole, 0)))\n     {\n@@ -4108,20 +4110,21 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n \t\t\twhole, part, NULL_TREE);\n   /* Don't VERIFY_CONSTANT here; we only want to check that we got a\n      CONSTRUCTOR.  */\n-  if (!*non_constant_p && TREE_CODE (whole) != CONSTRUCTOR)\n+  if (TREE_CODE (whole) != CONSTRUCTOR)\n     {\n       if (!ctx->quiet)\n \terror (\"%qE is not a constant expression\", orig_whole);\n       *non_constant_p = true;\n+      return t;\n     }\n-  if (DECL_MUTABLE_P (part))\n+  if ((cxx_dialect < cxx14 || CONSTRUCTOR_MUTABLE_POISON (whole))\n+      && DECL_MUTABLE_P (part))\n     {\n       if (!ctx->quiet)\n \terror (\"mutable %qD is not usable in a constant expression\", part);\n       *non_constant_p = true;\n+      return t;\n     }\n-  if (*non_constant_p)\n-    return t;\n   bool pmf = TYPE_PTRMEMFUNC_P (TREE_TYPE (whole));\n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)\n     {"}, {"sha": "51499fac520184a931f054dc5b2aed624523c788", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-mutable3.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7107ea6fb933f1e928593c7e92edfd64ccf0df63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-mutable3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7107ea6fb933f1e928593c7e92edfd64ccf0df63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-mutable3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-mutable3.C?ref=7107ea6fb933f1e928593c7e92edfd64ccf0df63", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/92505\n+// { dg-do compile { target c++11 } }\n+\n+struct A { mutable int m; };\n+\n+constexpr int f(A a) { return a.m; }\n+\n+static_assert(f({42}) == 42, \"\");\n+// { dg-error \"non-constant|mutable\" \"\" { target c++11_only } .-1 }"}, {"sha": "6c47988c01a02ad5aa11f8356899641e18b9d6c1", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-mutable1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7107ea6fb933f1e928593c7e92edfd64ccf0df63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-mutable1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7107ea6fb933f1e928593c7e92edfd64ccf0df63/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-mutable1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-mutable1.C?ref=7107ea6fb933f1e928593c7e92edfd64ccf0df63", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/92505\n+// { dg-do compile { target c++14 } }\n+\n+struct S { mutable int m; };\n+\n+static_assert(S{42}.m == 42, \"\");\n+\n+constexpr int f() {\n+  S s = {40};\n+  s.m++;\n+  const auto& cs = s;\n+  ++cs.m;\n+  return cs.m;\n+}\n+\n+static_assert(f() == 42, \"\");"}]}