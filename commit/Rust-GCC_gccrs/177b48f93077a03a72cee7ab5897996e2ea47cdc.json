{"sha": "177b48f93077a03a72cee7ab5897996e2ea47cdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc3YjQ4ZjkzMDc3YTAzYTcyY2VlN2FiNTg5Nzk5NmUyZWE0N2NkYw==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-09-27T19:22:13Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-09-27T19:22:13Z"}, "message": "In gcc/: 2010-09-27 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * doc/objc.texi (Type encoding): Added the new 'long double' (D)\n        code.  Added byref, which was missing in the list of codes.\n        Explain that enumeration values are encoded as the integer type\n        that the compiler uses to store them.  Explain and make examples\n        of how 'const' interacts with pointers, and the complication of\n        the encoding of 'const char *'.\n        (Legacy type encoding): New subsection, explaining that GCC emits\n        incorrect type encodings for the NeXT runtime for compatibility\n        reasons.\n        (@@encode): New subsection, explaining @encode and particularly\n        that protocol qualifiers are not recognized inside an @encode()\n        expression.\n        (Method signatures): New subsection, explaining how method\n        signatures are encoded.\n\nIn gcc/objc/:\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        PR objc/45763\n        PR objc/25450\n        PR objc/25464\n        * objc-act.c: Improved comments for encoding functions.\n        (encode_aggregate_within): For the GNU runtime, rewritten some\n        obsfuscated code to clarify the various cases.\n        (encode_aggregate): Function removed.\n        (encode_array): Generate an error if asked to encode an incomplete\n        array as part of generating instance variables.  Else, when\n        encoding an incomplete array inside a structure, encode it as an\n        array of zero size.\n        (encode_pointer): For the GNU runtime, fixed encoding 'BOOL *' as\n        '^c' instead of '*'.\n        (encode_gnu_bitfield): Encode enumerated types exactly in the same\n        type as integer types instead of using a hardcoded 'i'.  If asked\n        to encode a non-integer type as a bitfield, do not abort\n        compilation immediately; instead generate an error, then skip the\n        type.\n        (encode_type): Use a 'switch' instead of a sequence of 'if's.\n        Added a 'default' clause that gets executed if the type can not be\n        matched, and that encodes it as '?' (unknown) and produces a\n        warning.  For the GNU runtime, encode enumerated types exactly in\n        the same way as integer types instead of using a hardcoded 'i'.\n        Encode long double as 'D'.  Encode 128-bit integers as 'T' or 't'.\n        Encode C++ reference types as pointers.  Call encode_vector to\n        encode vectors.\n        (encode_vector): New function.\n\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Merge from 'apple/trunk' branch on FSF servers.  I modified the\n        changes to be used only when compiling for the NeXT runtime.\n\n        2005-10-10  Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4301047\n\n        * objc-act.c (encode_type): Remove the hack.\n\n        2005-07-20  Ziemowit Laski  <zlaski@apple.com>\n\n        Radar 4136935\n        * objc-act.c (pointee_is_readonly): New function.\n        (encode_pointer, encode_aggregate_within, encode_type):\n        Attempt to emulate GCC 3.3 when generating type encodings.\n\nIn gcc/testsuite/:\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        PR objc/25464\n        * objc.dg/type-size-3.m: New test.\n\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        PR objc/45763\n        * objc.dg/encode-1.m: Execute the test with the GNU runtime as\n        well.\n\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        PR objc/25450\n        * objc.dg/encode-3.m: Updated for fix of encoding of enums.\n        * objc.dg/type-size-2.m: Same change.\n        * obj-c++.dg/encode-5.mm: Same change.\n\n2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Merge from 'apple/trunk' branch on FSF servers.  The original\n        Changelogs are below.\n\n        * objc.dg/encode-6.m: Execute the test only with the GNU runtime.\n        * objc.dg/encode-6-next.m: New file (from encode-6.m in the\n        branch).\n        * objc.dg/encode-7-next.m: New file (from encode-7.m in the\n        branch).\n        * objc.dg/encode-7-next-64bit.m: New file (from encode-7-64bit.m\n        in the branch).\n        * objc.dg/proto-qual-1.m: Test the 3.3 ABI on NeXT (from\n        proto-qual-1.m in the branch) and the normal ABI on GNU.\n        * objc.dg/threedotthree-abi-1.m: New file (from the branch).  Run\n        the test only with the NeXT runtime.\n        * obj-c++/encode-1.mm: Execute the test only with the GNU runtime.\n        * obj-c++/encode-1-next.mm: New file (from encode-1.mm in the\n        branch).\n        * obj-c++.dg/threedotthree-abi-1.mm: New file (from the branch).\n        Run the test only with the NeXT runtime.\n\n        2006-03-30 Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4492973\n        * objc.dg/encode-7-64bit.m: New.\n        * objc.dg/encode-7.m: Skip if -m64.\n\n        2005-10-19  Fariborz Jahanian <fjahanian@apple.com>\n\n        Radar 4301047\n        * objc.dg/proto-qual-1.m: Fix test to match 3.3 ABI\n        * obj-c++.dg/threedotthree-abi-1.mm: New\n        * objc.dg/threedotthree-abi-1.m: New\n\n        2005-07-20  Ziemowit Laski  <zlaski@apple.com>\n\n        Radar 4136935\n        * obj-c++.dg/encode-1.mm: Tweak encodings to match fix.\n        * objc.dg/encode-6.m: Likewise.\n        * objc.dg/encode-7.m: New test case.\n\nIn libobjc/:\n2010-09-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * encoding.c (objc_sizeof_type): Added support for vector type and\n        for double long types.\n        (objc_alignof_type): Same change.\n        (objc_skip_typespec): Same change.\n        * objc/encoding.h (_C_GCINVISIBLE): Use '|' for _C_GCINVISIBLE\n        instead of '!' since '!' is already used for _C_VECTOR.\n        * objc/objc-api.h (_C_LNG_DBL): Added.\n\nFrom-SVN: r164659", "tree": {"sha": "251b23a8c4eafe1915cb28c5bfe7d86fc70d2045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/251b23a8c4eafe1915cb28c5bfe7d86fc70d2045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/177b48f93077a03a72cee7ab5897996e2ea47cdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/177b48f93077a03a72cee7ab5897996e2ea47cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/177b48f93077a03a72cee7ab5897996e2ea47cdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/177b48f93077a03a72cee7ab5897996e2ea47cdc/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "16562d86a761da90ead2fe637366b6e53043167b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16562d86a761da90ead2fe637366b6e53043167b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16562d86a761da90ead2fe637366b6e53043167b"}], "stats": {"total": 1658, "additions": 1537, "deletions": 121}, "files": [{"sha": "68dd7e9f8b41400676436cfc446e3ce26eeb5a9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -1,3 +1,20 @@\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* doc/objc.texi (Type encoding): Added the new 'long double' (D)\n+\tcode.  Added byref, which was missing in the list of codes.\n+\tExplain that enumeration values are encoded as the integer type\n+\tthat the compiler uses to store them.  Explain and make examples\n+\tof how 'const' interacts with pointers, and the complication of\n+\tthe encoding of 'const char *'.\n+\t(Legacy type encoding): New subsection, explaining that GCC emits\n+\tincorrect type encodings for the NeXT runtime for compatibility\n+\treasons.\n+\t(@@encode): New subsection, explaining @encode and particularly\n+\tthat protocol qualifiers are not recognized inside an @encode()\n+\texpression.\n+\t(Method signatures): New subsection, explaining how method\n+\tsignatures are encoded.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.  Removed small"}, {"sha": "bf328797c72678121e987bf04a3d38ef32735f44", "filename": "gcc/doc/objc.texi", "status": "modified", "additions": 170, "deletions": 12, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Fdoc%2Fobjc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Fdoc%2Fobjc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fobjc.texi?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -170,9 +170,13 @@ above apply to classes defined in bundle.\n @node Type encoding\n @section Type encoding\n \n-The Objective-C compiler generates type encodings for all the\n-types.  These type encodings are used at runtime to find out information\n-about selectors and methods and about objects and classes.\n+This is an advanced section.  Type encodings are used extensively by\n+the compiler and by the runtime, but you generally do not need to know\n+about them to use Objective-C.\n+\n+The Objective-C compiler generates type encodings for all the types.\n+These type encodings are used at runtime to find out information about\n+selectors and methods and about objects and classes.\n \n The types are encoded in the following way:\n \n@@ -205,6 +209,8 @@ The types are encoded in the following way:\n @tab @code{f}\n @item @code{double}\n @tab @code{d}\n+@item @code{long double}\n+@tab @code{D}\n @item @code{void}\n @tab @code{v}\n @item @code{id}\n@@ -215,6 +221,9 @@ The types are encoded in the following way:\n @tab @code{:}\n @item @code{char*}\n @tab @code{*}\n+@item @code{enum}\n+@tab an @code{enum} is encoded exactly as the integer type that the compiler uses for it, which depends on the enumeration\n+values.  Often the compiler users @code{unsigned int}, which is then encoded as @code{I}.\n @item unknown type\n @tab @code{?}\n @item Complex types\n@@ -225,15 +234,16 @@ The types are encoded in the following way:\n \n @c @sp 1\n \n-The encoding of bit-fields has changed to allow bit-fields to be properly\n-handled by the runtime functions that compute sizes and alignments of\n-types that contain bit-fields.  The previous encoding contained only the\n-size of the bit-field.  Using only this information it is not possible to\n-reliably compute the size occupied by the bit-field.  This is very\n-important in the presence of the Boehm's garbage collector because the\n-objects are allocated using the typed memory facility available in this\n-collector.  The typed memory allocation requires information about where\n-the pointers are located inside the object.\n+The encoding of bit-fields has changed to allow bit-fields to be\n+properly handled by the runtime functions that compute sizes and\n+alignments of types that contain bit-fields.  The previous encoding\n+contained only the size of the bit-field.  Using only this information\n+it is not possible to reliably compute the size occupied by the\n+bit-field.  This is very important in the presence of the Boehm's\n+garbage collector because the objects are allocated using the typed\n+memory facility available in this collector.  The typed memory\n+allocation requires information about where the pointers are located\n+inside the object.\n \n The position in the bit-field is the position, counting in bits, of the\n bit closest to the beginning of the structure.\n@@ -251,6 +261,8 @@ The non-atomic types are encoded as follows:\n @tab @samp{@{} followed by the name of the structure (or @samp{?} if the structure is unnamed), the @samp{=} sign, the type of the members and by @samp{@}}\n @item unions\n @tab @samp{(} followed by the name of the structure (or @samp{?} if the union is unnamed), the @samp{=} sign, the type of the members followed by @samp{)}\n+@item vectors\n+@tab @samp{![} followed by the vector_size (the number of bytes composing the vector) followed by a comma, followed by the alignment (in bytes) of the vector, followed by the type of the elements followed by @samp{]}\n @end multitable\n \n Here are some types and their encodings, as they are generated by the\n@@ -277,6 +289,11 @@ struct @{\n @}\n @end smallexample\n @tab @code{@{?=i[3f]b128i3b131i2c@}}\n+@item\n+@smallexample\n+int a __attribute__ ((vector_size (16)));\n+@end smallexample\n+@tab @code{![16,16i]} (alignment would depend on the machine)\n @end multitable\n \n @sp 1\n@@ -300,6 +317,8 @@ Objective-C type specifiers:\n @tab @code{o}\n @item @code{bycopy}\n @tab @code{O}\n+@item @code{byref}\n+@tab @code{R}\n @item @code{oneway}\n @tab @code{V}\n @end multitable\n@@ -310,6 +329,145 @@ The type specifiers are encoded just before the type.  Unlike types\n however, the type specifiers are only encoded when they appear in method\n argument types.\n \n+Note how @code{const} interacts with pointers:\n+\n+@sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item Objective-C type\n+@tab Compiler encoding\n+@item\n+@smallexample\n+const int\n+@end smallexample\n+@tab @code{ri}\n+@item\n+@smallexample\n+const int*\n+@end smallexample\n+@tab @code{^ri}\n+@item\n+@smallexample\n+int *const\n+@end smallexample\n+@tab @code{r^i}\n+@end multitable\n+\n+@sp 1\n+\n+@code{const int*} is a pointer to a @code{const int}, and so is\n+encoded as @code{^ri}.  @code{int* const}, instead, is a @code{const}\n+pointer to an @code{int}, and so is encoded as @code{r^i}.\n+\n+Finally, there is a complication when encoding @code{const char *}\n+versus @code{char * const}.  Because @code{char *} is encoded as\n+@code{*} and not as @code{^c}, there is no way to express the fact\n+that @code{r} applies to the pointer or to the pointee.\n+\n+Hence, it is assumed as a convention that @code{r*} means @code{const\n+char *} (since it is what is most often meant), and there is no way to\n+encode @code{char *const}.  @code{char *const} would simply be encoded\n+as @code{*}, and the @code{const} is lost.\n+\n+@menu\n+* Legacy type encoding::\n+* @@encode::\n+* Method signatures::\n+@end menu\n+\n+@node Legacy type encoding\n+@subsection Legacy type encoding\n+\n+Unfortunately, historically GCC used to have a number of bugs in its\n+encoding code.  The NeXT runtime expects GCC to emit type encodings in\n+this historical format (compatible with GCC-3.3), so when using the\n+NeXT runtime, GCC will introduce on purpose a number of incorrect\n+encodings:\n+\n+@itemize @bullet\n+\n+@item\n+the read-only qualifier of the pointee gets emitted before the '^'.\n+The read-only qualifier of the pointer itself gets ignored, unless it\n+is a typedef.  Also, the 'r' is only emitted for the outermost type.\n+\n+@item\n+32-bit longs are encoded as 'l' or 'L', but not always.  For typedefs,\n+the compiler uses 'i' or 'I' instead if encoding a struct field or a\n+pointer.\n+\n+@item\n+@code{enum}s are always encoded as 'i' (int) even if they are actually\n+unsigned or long.\n+\n+@end itemize\n+\n+In addition to that, the NeXT runtime uses a different encoding for\n+bitfields.  It encodes them as @code{b} followed by the size, without\n+a bit offset or the underlying field type.\n+\n+@node @@encode\n+@subsection @@encode\n+\n+GNU Objective-C supports the @code{@@encode} syntax that allows you to\n+create a type encoding from a C/Objective-C type.  For example,\n+@code{@@encode(int)} is compiled by the compiler into @code{\"i\"}.\n+\n+@code{@@encode} does not support type qualifiers other than\n+@code{const}.  For example, @code{@@encode(const char*)} is valid and\n+is compiled into @code{\"r*\"}, while @code{@@encode(bycopy char *)} is\n+invalid and will cause a compilation error.\n+\n+@node Method signatures\n+@subsection Method signatures\n+\n+This section documents the encoding of method types, which is rarely\n+needed to use Objective-C.  You should skip it at a first reading; the\n+runtime provides functions that will work on methods and can walk\n+through the list of parameters and interpret them for you.  These\n+functions are part of the public ``API'' and are the preferred way to\n+interact with method signatures from user code.\n+\n+But if you need to debug a problem with method signatures and need to\n+know how they are implemented (ie, the ``ABI''), read on.\n+\n+Methods have their ``signature'' encoded and made available to the\n+runtime.  The ``signature'' encodes all the information required to\n+dynamically build invocations of the method at runtime: return type\n+and arguments.\n+\n+The ``signature'' is a null-terminated string, composed of the following:\n+\n+@itemize @bullet\n+\n+@item\n+The return type, including type qualifiers.  For example, a method\n+returning @code{int} would have @code{i} here.\n+\n+@item\n+The total size (in bytes) required to pass all the parameters.  This\n+includes the two hidden parameters (the object @code{self} and the\n+method selector @code{_cmd}).\n+\n+@item\n+Each argument, with the type encoding, followed by the offset (in\n+bytes) of the argument in the list of parameters.\n+\n+@end itemize\n+\n+For example, a method with no arguments and returning @code{int} would\n+have the signature @code{i8@@0:4} if the size of a pointer is 4.  The\n+signature is interpreted as follows: the @code{i} is the return type\n+(an @code{int}), the @code{8} is the total size of the parameters in\n+bytes (two pointers each of size 4), the @code{@@0} is the first\n+parameter (an object at byte offset @code{0}) and @code{:4} is the\n+second parameter (a @code{SEL} at byte offset @code{4}).\n+\n+You can easily find more examples by running the ``strings'' program\n+on an Objective-C object file compiled by GCC.  You'll see a lot of\n+strings that look very much like @code{i8@@0:4}.  They are signatures\n+of Objective-C methods.\n+\n \n @node Garbage Collection\n @section Garbage Collection"}, {"sha": "b1fb7bc2a5f863196bcdd10cfc0a83262438da78", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -1,3 +1,51 @@\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR objc/45763\n+\tPR objc/25450\n+\tPR objc/25464\n+\t* objc-act.c: Improved comments for encoding functions.\n+\t(encode_aggregate_within): For the GNU runtime, rewritten some\n+\tobsfuscated code to clarify the various cases.\n+\t(encode_aggregate): Function removed.\n+\t(encode_array): Generate an error if asked to encode an incomplete\n+\tarray as part of generating instance variables.  Else, when\n+\tencoding an incomplete array inside a structure, encode it as an\n+\tarray of zero size.\n+\t(encode_pointer): For the GNU runtime, fixed encoding 'BOOL *' as\n+\t'^c' instead of '*'.\n+\t(encode_gnu_bitfield): Encode enumerated types exactly in the same\n+\ttype as integer types instead of using a hardcoded 'i'.  If asked\n+\tto encode a non-integer type as a bitfield, do not abort\n+\tcompilation immediately; instead generate an error, then skip the\n+\ttype.\n+\t(encode_type): Use a 'switch' instead of a sequence of 'if's.\n+\tAdded a 'default' clause that gets executed if the type can not be\n+\tmatched, and that encodes it as '?' (unknown) and produces a\n+\twarning.  For the GNU runtime, encode enumerated types exactly in\n+\tthe same way as integer types instead of using a hardcoded 'i'.\n+\tEncode long double as 'D'.  Encode 128-bit integers as 'T' or 't'.\n+\tEncode C++ reference types as pointers.  Call encode_vector to\n+\tencode vectors.\n+\t(encode_vector): New function.\n+\t\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tMerge from 'apple/trunk' branch on FSF servers.  I modified the\n+\tchanges to be used only when compiling for the NeXT runtime.\n+\n+\t2005-10-10  Fariborz Jahanian <fjahanian@apple.com>\n+\n+        Radar 4301047\n+\n+\t* objc-act.c (encode_type): Remove the hack.\n+\t\n+\t2005-07-20  Ziemowit Laski  <zlaski@apple.com>\n+\n+\tRadar 4136935\n+\t* objc-act.c (pointee_is_readonly): New function.\n+\t(encode_pointer, encode_aggregate_within, encode_type):\n+\tAttempt to emulate GCC 3.3 when generating type encodings.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers."}, {"sha": "101f9fce0c932347b753ab67e0efa7520a823b2b", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 349, "deletions": 98, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -4434,6 +4434,11 @@ objc_encoded_type_size (tree type)\n   return sz;\n }\n \n+/* Encode a method prototype.\n+\n+   The format is described in gcc/doc/objc.texi, section 'Method\n+   signatures'.\n+ */\n static tree\n encode_method_prototype (tree method_decl)\n {\n@@ -6796,6 +6801,8 @@ objc_build_selector_expr (location_t loc, tree selnamelist)\n     return build_selector_reference (loc, selname);\n }\n \n+/* This is used to implement @encode().  See gcc/doc/objc.texi,\n+   section '@encode'.  */\n tree\n objc_build_encode_expr (tree type)\n {\n@@ -7931,7 +7938,34 @@ start_protocol (enum tree_code code, tree name, tree list)\n \n \f\n /* \"Encode\" a data type into a string, which grows in util_obstack.\n-   ??? What is the FORMAT?  Someone please document this!  */\n+\n+   The format is described in gcc/doc/objc.texi, section 'Type\n+   encoding'.\n+\n+   Most of the encode_xxx functions have a 'type' argument, which is\n+   the type to encode, and an integer 'curtype' argument, which is the\n+   index in the encoding string of the beginning of the encoding of\n+   the current type, and allows you to find what characters have\n+   already been written for the current type (they are the ones in the\n+   current encoding string starting from 'curtype').\n+\n+   For example, if we are encoding a method which returns 'int' and\n+   takes a 'char **' argument, then when we get to the point of\n+   encoding the 'char **' argument, the encoded string already\n+   contains 'i12@0:4' (assuming a pointer size of 4 bytes).  So,\n+   'curtype' will be set to 7 when starting to encode 'char **'.\n+   During the whole of the encoding of 'char **', 'curtype' will be\n+   fixed at 7, so the routine encoding the second pointer can find out\n+   that it's actually encoding a pointer to a pointer by looking\n+   backwards at what has already been encoded for the current type,\n+   and seeing there is a \"^\" (meaning a pointer) in there.\n+*/\n+\n+\n+/* Encode type qualifiers encodes one of the \"PQ\" Objective-C\n+   keywords, ie 'in', 'out', 'inout', 'bycopy', 'byref', 'oneway'.\n+   'const', instead, is encoded directly as part of the type.\n+ */\n \n static void\n encode_type_qualifiers (tree declspecs)\n@@ -7940,6 +7974,7 @@ encode_type_qualifiers (tree declspecs)\n \n   for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n     {\n+      /* FIXME: Shouldn't we use token->keyword here ? */\n       if (ridpointers[(int) RID_IN] == TREE_VALUE (spec))\n \tobstack_1grow (&util_obstack, 'n');\n       else if (ridpointers[(int) RID_INOUT] == TREE_VALUE (spec))\n@@ -7955,13 +7990,41 @@ encode_type_qualifiers (tree declspecs)\n     }\n }\n \n+/* Determine if a pointee is marked read-only.  Only used by the NeXT\n+   runtime to be compatible with gcc-3.3.  */\n+\n+static bool\n+pointee_is_readonly (tree pointee)\n+{\n+  while (POINTER_TYPE_P (pointee))\n+    pointee = TREE_TYPE (pointee);\n+\n+  return TYPE_READONLY (pointee);\n+}\n+\n /* Encode a pointer type.  */\n \n static void\n encode_pointer (tree type, int curtype, int format)\n {\n   tree pointer_to = TREE_TYPE (type);\n \n+  if (flag_next_runtime)\n+    {\n+      /* This code is used to be compatible with gcc-3.3.  */\n+      /* For historical/compatibility reasons, the read-only qualifier\n+\t of the pointee gets emitted _before_ the '^'.  The read-only\n+\t qualifier of the pointer itself gets ignored, _unless_ we are\n+\t looking at a typedef!  Also, do not emit the 'r' for anything\n+\t but the outermost type!  */\n+      if (!generating_instance_variables\n+\t  && (obstack_object_size (&util_obstack) - curtype <= 1)\n+\t  && (TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t      ? TYPE_READONLY (type)\n+\t      : pointee_is_readonly (pointer_to)))\n+\tobstack_1grow (&util_obstack, 'r');\n+    }\n+\n   if (TREE_CODE (pointer_to) == RECORD_TYPE)\n     {\n       if (OBJC_TYPE_NAME (pointer_to)\n@@ -8010,21 +8073,28 @@ encode_pointer (tree type, int curtype, int format)\n \t          ? OBJC_TYPE_NAME (pointer_to)\n \t          : DECL_NAME (OBJC_TYPE_NAME (pointer_to));\n \n-      if (!flag_next_runtime || strcmp (IDENTIFIER_POINTER (pname), \"BOOL\"))\n+      /* (BOOL *) are an exception and are encoded as ^c, while all\n+\t other pointers to char are encoded as *.   */\n+      if (strcmp (IDENTIFIER_POINTER (pname), \"BOOL\"))\n \t{\n-\t  /* It appears that \"r*\" means \"const char *\" rather than\n-\t     \"char *const\".  */\n-\t  if (TYPE_READONLY (pointer_to))\n-\t    obstack_1grow (&util_obstack, 'r');\n+\t  if (!flag_next_runtime)\n+\t    {\n+\t      /* The NeXT runtime adds the 'r' before getting here.  */\n+\n+\t      /* It appears that \"r*\" means \"const char *\" rather than\n+\t\t \"char *const\".  \"char *const\" is encoded as \"*\",\n+\t\t which is identical to \"char *\", so the \"const\" is\n+\t\t unfortunately lost.  */\t\t \n+\t      if (TYPE_READONLY (pointer_to))\n+\t\tobstack_1grow (&util_obstack, 'r');\n+\t    }\n \n \t  obstack_1grow (&util_obstack, '*');\n \t  return;\n \t}\n     }\n \n-  /* We have a type that does not get special treatment.  */\n-\n-  /* NeXT extension */\n+  /* We have a normal pointer type that does not get special treatment.  */\n   obstack_1grow (&util_obstack, '^');\n   encode_type (pointer_to, curtype, format);\n }\n@@ -8036,14 +8106,51 @@ encode_array (tree type, int curtype, int format)\n   tree array_of = TREE_TYPE (type);\n   char buffer[40];\n \n-  /* An incomplete array is treated like a pointer.  */\n   if (an_int_cst == NULL)\n     {\n-      encode_pointer (type, curtype, format);\n-      return;\n-    }\n+      /* We are trying to encode an incomplete array.  An incomplete\n+\t array is forbidden as part of an instance variable.  */\n+      if (generating_instance_variables)\n+\t{\n+\t  /* TODO: Detect this error earlier.  */\n+\t  error (\"instance variable has unknown size\");\n+\t  return;\n+\t}\n+\n+      /* So the only case in which an incomplete array could occur is\n+\t if we are encoding the arguments or return value of a method.\n+\t In that case, an incomplete array argument or return value\n+\t (eg, -(void)display: (char[])string) is treated like a\n+\t pointer because that is how the compiler does the function\n+\t call.  A special, more complicated case, is when the\n+\t incomplete array is the last member of a struct (eg, if we\n+\t are encoding \"struct { unsigned long int a;double b[];}\"),\n+\t which is again part of a method argument/return value.  In\n+\t that case, we really need to communicate to the runtime that\n+\t there is an incomplete array (not a pointer!) there.  So, we\n+\t detect that special case and encode it as a zero-length\n+\t array.\n+\n+\t Try to detect that we are part of a struct.  We do this by\n+\t searching for '=' in the type encoding for the current type.\n+\t NB: This hack assumes that you can't use '=' as part of a C\n+\t identifier.\n+      */\n+      char *enc = obstack_base (&util_obstack) + curtype;\n+      if (memchr (enc, '=', \n+\t\t  obstack_object_size (&util_obstack) - curtype) == NULL)\n+\t{\n+\t  /* We are not inside a struct.  Encode the array as a\n+\t     pointer.  */\n+\t  encode_pointer (type, curtype, format);\n+\t  return;\n+\t}\n \n-  if (TREE_INT_CST_LOW (TYPE_SIZE (array_of)) == 0)\n+      /* Else, we are in a struct, and we encode it as a zero-length\n+\t array.  */\n+      sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n+    }\n+  else if (TREE_INT_CST_LOW (TYPE_SIZE (array_of)) == 0)\n    sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)0);\n   else\n     sprintf (buffer, \"[\" HOST_WIDE_INT_PRINT_DEC,\n@@ -8055,6 +8162,37 @@ encode_array (tree type, int curtype, int format)\n   obstack_1grow (&util_obstack, ']');\n   return;\n }\n+\n+/* Encode a vector.  The vector type is a GCC extension to C.  */\n+static void\n+encode_vector (tree type, int curtype, int format)\n+{\n+  tree vector_of = TREE_TYPE (type);\n+  char buffer[40];\n+\n+  /* Vectors are like simple fixed-size arrays.  */\n+\n+  /* Output ![xx,yy,<code>] where xx is the vector_size, yy is the\n+     alignment of the vector, and <code> is the base type.  Eg, int\n+     __attribute__ ((vector_size (16))) gets encoded as ![16,32,i]\n+     assuming that the alignment is 32 bytes.  We include size and\n+     alignment in bytes so that the runtime does not have to have any\n+     knowledge of the actual types.\n+  */\n+  sprintf (buffer, \"![\" HOST_WIDE_INT_PRINT_DEC \",%d\",\n+\t   /* We want to compute the equivalent of sizeof (<vector>).\n+\t      Code inspired by c_sizeof_or_alignof_type.  */\n+\t   ((TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type)) \n+\t     / (TYPE_PRECISION (char_type_node) / BITS_PER_UNIT))),\n+\t   /* We want to compute the equivalent of __alignof__\n+\t      (<vector>).  Code inspired by\n+\t      c_sizeof_or_alignof_type.  */\n+\t   TYPE_ALIGN_UNIT (type));\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+  encode_type (vector_of, curtype, format);\n+  obstack_1grow (&util_obstack, ']');\n+  return;\n+}\n \f\n static void\n encode_aggregate_fields (tree type, int pointed_to, int curtype, int format)\n@@ -8105,12 +8243,64 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n   /* NB: aggregates that are pointed to have slightly different encoding\n      rules in that you never encode the names of instance variables.  */\n   int ob_size = obstack_object_size (&util_obstack);\n-  char c1 = ob_size > 1 ? *(obstack_next_free (&util_obstack) - 2) : 0;\n-  char c0 = ob_size > 0 ? *(obstack_next_free (&util_obstack) - 1) : 0;\n-  int pointed_to = (c0 == '^' || (c1 == '^' && c0 == 'r'));\n-  int inline_contents\n-   = ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n-      && (!pointed_to || ob_size - curtype == (c1 == 'r' ? 2 : 1)));\n+  bool inline_contents = false;\n+  bool pointed_to = false;\n+\n+  if (flag_next_runtime)\n+    {\n+      pointed_to = (ob_size > 0\n+\t\t    ? *(obstack_next_free (&util_obstack) - 1) == '^'\n+\t\t    : 0);\n+      inline_contents = ((format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n+\t\t\t && (!pointed_to\n+\t\t\t     || ob_size - curtype == 1\n+\t\t\t     || (ob_size - curtype == 2\n+\t\t\t\t && *(obstack_next_free (&util_obstack) - 2) == 'r')));      \n+    }\n+  else\n+    {\n+      /* c0 and c1 are the last two characters in the encoding of the\n+\t current type; if the last two characters were '^' or '^r',\n+\t then we are encoding an aggregate that is \"pointed to\".  The\n+\t comment above applies: in that case we should avoid encoding\n+\t the names of instance variables.\n+      */\n+      char c1 = ob_size > 1 ? *(obstack_next_free (&util_obstack) - 2) : 0;\n+      char c0 = ob_size > 0 ? *(obstack_next_free (&util_obstack) - 1) : 0;\n+      \n+      if (c0 == '^' || (c1 == '^' && c0 == 'r'))\n+\tpointed_to = true;\n+      \n+      if (format == OBJC_ENCODE_INLINE_DEFS || generating_instance_variables)\n+\t{\n+\t  if (!pointed_to)\n+\t    inline_contents = true;\n+\t  else\n+\t    {\n+\t      /* FIXME: It's hard to understand what the following\n+\t\t code is meant to be doing.  It seems that it will\n+\t\t inline contents even if we are encoding a pointed\n+\t\t structure and the last characters were 'r^' or just\n+\t\t '^'.\n+\n+\t\t So it seems that in the end the only case where we\n+\t\t don't inline contents is '^r', which is a pointer to\n+\t\t a 'const' structure!  If that is the case, the whole\n+\t\t blob of code could be rewritten in a simpler way.\n+\t      */\n+\t      if (c1 == 'r')\n+\t\t{\n+\t\t  if (ob_size - curtype == 2)\n+\t\t    inline_contents = true;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (ob_size - curtype == 1)\n+\t\t    inline_contents = true;    \n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   /* Traverse struct aliases; it is important to get the\n      original struct and its tag name (if any).  */\n@@ -8150,33 +8340,6 @@ encode_aggregate_within (tree type, int curtype, int format, int left,\n   obstack_1grow (&util_obstack, right);\n }\n \n-static void\n-encode_aggregate (tree type, int curtype, int format)\n-{\n-  enum tree_code code = TREE_CODE (type);\n-\n-  switch (code)\n-    {\n-    case RECORD_TYPE:\n-      {\n-\tencode_aggregate_within (type, curtype, format, '{', '}');\n-\tbreak;\n-      }\n-    case UNION_TYPE:\n-      {\n-\tencode_aggregate_within (type, curtype, format, '(', ')');\n-\tbreak;\n-      }\n-\n-    case ENUMERAL_TYPE:\n-      obstack_1grow (&util_obstack, 'i');\n-      break;\n-\n-    default:\n-      break;\n-    }\n-}\n-\n /* Encode a bitfield NeXT-style (i.e., without a bit offset or the underlying\n    field type.  */\n \n@@ -8188,74 +8351,159 @@ encode_next_bitfield (int width)\n   obstack_grow (&util_obstack, buffer, strlen (buffer));\n }\n \f\n-/* FORMAT will be OBJC_ENCODE_INLINE_DEFS or OBJC_ENCODE_DONT_INLINE_DEFS.  */\n+\n+/* Encodes 'type', ignoring type qualifiers (which you should encode\n+   beforehand if needed) with the exception of 'const', which is\n+   encoded by encode_type.  See above for the explanation of\n+   'curtype'.  'format' can be OBJC_ENCODE_INLINE_DEFS or\n+   OBJC_ENCODE_DONT_INLINE_DEFS.\n+*/\n static void\n encode_type (tree type, int curtype, int format)\n {\n   enum tree_code code = TREE_CODE (type);\n   char c;\n \n+  /* Ignore type qualifiers other than 'const' when encoding a\n+     type.  */\n+\n   if (type == error_mark_node)\n     return;\n \n   if (TYPE_READONLY (type))\n     obstack_1grow (&util_obstack, 'r');\n \n-  if (code == INTEGER_TYPE)\n+  switch (code)\n     {\n-      switch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+    case ENUMERAL_TYPE:\n+      if (flag_next_runtime)\n \t{\n-\tcase 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n-\tcase 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n-\tcase 32:\n-\t  if (type == long_unsigned_type_node\n-\t      || type == long_integer_type_node)\n-\t         c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n-\t  else\n-\t         c = TYPE_UNSIGNED (type) ? 'I' : 'i';\n+\t  /* Kludge for backwards-compatibility with gcc-3.3: enums\n+\t     are always encoded as 'i' no matter what type they\n+\t     actually are (!).  */\n+\t  c = 'i';\n \t  break;\n-\tcase 64: c = TYPE_UNSIGNED (type) ? 'Q' : 'q'; break;\n-\tdefault: abort ();\n \t}\n-      obstack_1grow (&util_obstack, c);\n-    }\n-\n-  else if (code == REAL_TYPE)\n-    {\n-      /* Floating point types.  */\n-      switch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n-\t{\n-\tcase 32:  c = 'f'; break;\n-\tcase 64:\n-\tcase 96:\n-\tcase 128: c = 'd'; break;\n-\tdefault: abort ();\n-\t}\n-      obstack_1grow (&util_obstack, c);\n-    }\n+      /* Else, they are encoded exactly like the integer type that is\n+\t used by the compiler to store them.  */\n+    case INTEGER_TYPE:\n+      {\n+\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t  {\n+\t  case 8:  c = TYPE_UNSIGNED (type) ? 'C' : 'c'; break;\n+\t  case 16: c = TYPE_UNSIGNED (type) ? 'S' : 's'; break;\n+\t  case 32:\n+\t    if (flag_next_runtime)\n+\t      {\n+\t\ttree int_type;\n+\t\t/* Another legacy kludge for compatiblity with\n+\t\t   gcc-3.3: 32-bit longs are encoded as 'l' or 'L',\n+\t\t   but not always.  For typedefs, we need to use 'i'\n+\t\t   or 'I' instead if encoding a struct field, or a\n+\t\t   pointer!  */\n+\t\tint_type =  ((!generating_instance_variables\n+\t\t\t      && (obstack_object_size (&util_obstack)\n+\t\t\t\t  == (unsigned) curtype))\n+\t\t\t     ? TYPE_MAIN_VARIANT (type)\n+\t\t\t     : type);\n+\t\t\n+\t\tif (int_type == long_unsigned_type_node\n+\t\t    || int_type == long_integer_type_node)\n+\t\t  c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n+\t\telse\n+\t\t  c = TYPE_UNSIGNED (type) ? 'I' : 'i';\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (type == long_unsigned_type_node\n+\t\t    || type == long_integer_type_node)\n+\t\t  c = TYPE_UNSIGNED (type) ? 'L' : 'l';\n+\t\telse\n+\t\t  c = TYPE_UNSIGNED (type) ? 'I' : 'i';\n+\t      }\n+\t    break;\n+\t  case 64:  c = TYPE_UNSIGNED (type) ? 'Q' : 'q'; break;\n+\t  case 128: c = TYPE_UNSIGNED (type) ? 'T' : 't'; break;\n+\t  default: abort ();\n+\t  }\n+\tobstack_1grow (&util_obstack, c);\n+\tbreak;\n+      }\n+    case REAL_TYPE:\n+      {\n+\t/* Floating point types.  */\n+\tswitch (GET_MODE_BITSIZE (TYPE_MODE (type)))\n+\t  {\n+\t  case 32:  c = 'f'; break;\n+\t  case 64:  c = 'd'; break;\n+\t  case 96:\n+\t  case 128: c = 'D'; break;\n+\t  default: abort ();\n+\t  }\n+\tobstack_1grow (&util_obstack, c);\n+\tbreak;\n+      }\n+    case VOID_TYPE:\n+      obstack_1grow (&util_obstack, 'v');\n+      break;\n \n-  else if (code == VOID_TYPE)\n-    obstack_1grow (&util_obstack, 'v');\n+    case BOOLEAN_TYPE:\n+      obstack_1grow (&util_obstack, 'B');\n+      break;\n \n-  else if (code == BOOLEAN_TYPE)\n-    obstack_1grow (&util_obstack, 'B');\n+    case ARRAY_TYPE:\n+      encode_array (type, curtype, format);\n+      break;\n \n-  else if (code == ARRAY_TYPE)\n-    encode_array (type, curtype, format);\n+    case POINTER_TYPE:\n+#ifdef OBJCPLUS\n+    case REFERENCE_TYPE:\n+#endif\n+      encode_pointer (type, curtype, format);\n+      break;\n \n-  else if (code == POINTER_TYPE)\n-    encode_pointer (type, curtype, format);\n+    case RECORD_TYPE:\n+      encode_aggregate_within (type, curtype, format, '{', '}');\n+      break;\n \n-  else if (code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)\n-    encode_aggregate (type, curtype, format);\n+    case UNION_TYPE:\n+      encode_aggregate_within (type, curtype, format, '(', ')');\n+      break;\n \n-  else if (code == FUNCTION_TYPE) /* '?' */\n-    obstack_1grow (&util_obstack, '?');\n+    case FUNCTION_TYPE: /* '?' means an unknown type.  */\n+      obstack_1grow (&util_obstack, '?');\n+      break;\n \n-  else if (code == COMPLEX_TYPE)\n-    {\n+    case COMPLEX_TYPE:\n+      /* A complex is encoded as 'j' followed by the inner type (eg,\n+\t \"_Complex int\" is encoded as 'ji').  */\n       obstack_1grow (&util_obstack, 'j');\n       encode_type (TREE_TYPE (type), curtype, format);\n+      break;\n+\n+    case VECTOR_TYPE:\n+      encode_vector (type, curtype, format);\n+      break;\n+\n+    default:\n+      warning (0, \"unknown type %s found during Objective-C encoding\",\n+\t       gen_type_name (type));\n+      obstack_1grow (&util_obstack, '?');\n+      break;\n+    }\n+  \n+  if (flag_next_runtime)\n+    {\n+      /* Super-kludge.  Some ObjC qualifier and type combinations need\n+\t to be rearranged for compatibility with gcc-3.3.  */\n+      if (code == POINTER_TYPE && obstack_object_size (&util_obstack) >= 3)\n+\t{\n+\t  char *enc = obstack_base (&util_obstack) + curtype;\n+\t  \n+\t  /* Rewrite \"in const\" from \"nr\" to \"rn\".  */\n+\t  if (curtype >= 1 && !strncmp (enc - 1, \"nr\", 2))\n+\t    strncpy (enc - 1, \"rn\", 2);\n+\t}\n     }\n }\n \n@@ -8266,12 +8514,14 @@ encode_gnu_bitfield (int position, tree type, int size)\n   char buffer[40];\n   char charType = '?';\n \n-  if (code == INTEGER_TYPE)\n+  /* This code is only executed for the GNU runtime, so we can ignore\n+     the NeXT runtime kludge of always encoding enums as 'i' no matter\n+     what integers they actually are.  */\n+  if (code == INTEGER_TYPE  ||  code == ENUMERAL_TYPE)\n     {\n       if (integer_zerop (TYPE_MIN_VALUE (type)))\n+\t/* Unsigned integer types.  */\n \t{\n-\t  /* Unsigned integer types.  */\n-\n \t  if (TYPE_MODE (type) == QImode)\n \t    charType = 'C';\n \t  else if (TYPE_MODE (type) == HImode)\n@@ -8286,7 +8536,6 @@ encode_gnu_bitfield (int position, tree type, int size)\n \t  else if (TYPE_MODE (type) == DImode)\n \t    charType = 'Q';\n \t}\n-\n       else\n \t/* Signed integer types.  */\n \t{\n@@ -8306,10 +8555,12 @@ encode_gnu_bitfield (int position, tree type, int size)\n \t    charType = 'q';\n \t}\n     }\n-  else if (code == ENUMERAL_TYPE)\n-    charType = 'i';\n   else\n-    abort ();\n+    {\n+      /* Do not do any encoding, produce an error and keep going.  */\n+      error (\"trying to encode non-integer type as a bitfield\");\n+      return;\n+    }\n \n   sprintf (buffer, \"b%d%c%d\", position, charType, size);\n   obstack_grow (&util_obstack, buffer, strlen (buffer));\n@@ -8335,7 +8586,7 @@ encode_field_decl (tree field_decl, int curtype, int format)\n \tencode_next_bitfield (size);\n       else\n \tencode_gnu_bitfield (int_bit_position (field_decl),\n-\t\t\t\t  DECL_BIT_FIELD_TYPE (field_decl), size);\n+\t\t\t     DECL_BIT_FIELD_TYPE (field_decl), size);\n     }\n   else\n     encode_type (TREE_TYPE (field_decl), curtype, format);"}, {"sha": "150dac4e4b88d0c7dc1807d33862453f5804f12e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -1,3 +1,63 @@\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR objc/25464\n+\t* objc.dg/type-size-3.m: New test.\n+\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tPR objc/45763\n+\t* objc.dg/encode-1.m: Execute the test with the GNU runtime as\n+\twell.\n+\t\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\t\n+\n+\tPR objc/25450\n+\t* objc.dg/encode-3.m: Updated for fix of encoding of enums.\n+\t* objc.dg/type-size-2.m: Same change.\n+\t* obj-c++.dg/encode-5.mm: Same change.\n+\n+2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tMerge from 'apple/trunk' branch on FSF servers.  The original\n+\tChangelogs are below.\n+\n+\t* objc.dg/encode-6.m: Execute the test only with the GNU runtime.\n+\t* objc.dg/encode-6-next.m: New file (from encode-6.m in the\n+\tbranch).\n+\t* objc.dg/encode-7-next.m: New file (from encode-7.m in the\n+\tbranch).\n+\t* objc.dg/encode-7-next-64bit.m: New file (from encode-7-64bit.m\n+\tin the branch).\t\n+\t* objc.dg/proto-qual-1.m: Test the 3.3 ABI on NeXT (from\n+\tproto-qual-1.m in the branch) and the normal ABI on GNU.\n+\t* objc.dg/threedotthree-abi-1.m: New file (from the branch).  Run\n+\tthe test only with the NeXT runtime.\n+\t* obj-c++/encode-1.mm: Execute the test only with the GNU runtime.\n+\t* obj-c++/encode-1-next.mm: New file (from encode-1.mm in the\n+\tbranch).\n+\t* obj-c++.dg/threedotthree-abi-1.mm: New file (from the branch).\n+\tRun the test only with the NeXT runtime.\n+\t\n+\t2006-03-30 Fariborz Jahanian <fjahanian@apple.com>\n+\n+\tRadar 4492973\n+\t* objc.dg/encode-7-64bit.m: New.\n+\t* objc.dg/encode-7.m: Skip if -m64.\n+\t\n+\t2005-10-19  Fariborz Jahanian <fjahanian@apple.com>\n+\n+\tRadar 4301047\n+\t* objc.dg/proto-qual-1.m: Fix test to match 3.3 ABI\n+\t* obj-c++.dg/threedotthree-abi-1.mm: New\n+\t* objc.dg/threedotthree-abi-1.m: New\n+\n+\t2005-07-20  Ziemowit Laski  <zlaski@apple.com>\n+\n+\tRadar 4136935\n+\t* obj-c++.dg/encode-1.mm: Tweak encodings to match fix.\n+\t* objc.dg/encode-6.m: Likewise.\n+\t* objc.dg/encode-7.m: New test case.\n+\n 2010-09-27  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers.  Renamed"}, {"sha": "47673f20cb20cfe37fb152ca2a35cc01483d8500", "filename": "gcc/testsuite/obj-c++.dg/encode-1-next.mm", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-1-next.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-1-next.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-1-next.mm?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,26 @@\n+/* This file tests that things are encoded using the gcc-3.3 ABI which is only\n+   used by the NeXT runtime.  */\n+/* Test for graceful encoding of const-qualified fields and parameters.  */\n+/* Author: Ziemowit Laski  <zlaski@apple.com>  */\n+\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+\n+struct Cxx {\n+  const struct Cxx *next;\n+};\n+\n+@interface ObjC {\n+  const struct Cxx *obj;\n+}\n+- (ObjC *)initWithCxx: (struct Cxx *const)c and: (const struct Cxx *)d;\n+@end\n+\n+@implementation ObjC\n+- (ObjC *)initWithCxx: (struct Cxx *const)c and: (const struct Cxx *)d {\n+  obj = d;\n+  return self;\n+}\n+@end \n+\n+/* { dg-final { scan-assembler \"@\\[0-9\\]+@0:\\[0-9\\]+\\\\^{Cxx=\\\\^{Cxx}}\\[0-9\\]+r\\\\^{Cxx=\\\\^{Cxx}}\" } } */"}, {"sha": "5f5ba20139efef1618e1970d90adaa4f01444ef6", "filename": "gcc/testsuite/obj-c++.dg/encode-1.mm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-1.mm?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -2,6 +2,7 @@\n /* Author: Ziemowit Laski  <zlaski@apple.com>  */\n \n /* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n \n struct Cxx {\n   const struct Cxx *next;"}, {"sha": "18db3f3dd8c6e6470d9a5d3476c63847fcfed5a8", "filename": "gcc/testsuite/obj-c++.dg/encode-5.mm", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-5.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-5.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fencode-5.mm?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -70,7 +70,21 @@ int main(void) {\n   CHECK_IF(offs3 == offs2 + sizeof(XXRect) && offs4 == offs3 + sizeof(int));\n   CHECK_IF(totsize == offs4 + sizeof(int));\n   meth = [proto descriptionForClassMethod: @selector(getEnum:enum:bool:)];\n-  scan_initial(\"^i%u@%u:%u^{?=ff(__XXAngle=II)}%ui%uc%u\");\n+  /* Here we have the complication that 'enum Enum' could be encoded\n+     as 'i' on __NEXT_RUNTIME_, and (most likely) as 'I' on the GNU\n+     runtime.  So we get the @encode(enum Enum), then put it into the\n+     string in place of the traditional 'i'.\n+  */\n+  /* scan_initial(\"^i%u@%u:%u^{?=ff(__XXAngle=II)}%ui%uc%u\"); */\n+  {\n+    char pattern[1024];\n+\n+    sprintf (pattern, \"^%s%%u@%%u:%%u^{?=ff(__XXAngle=II)}%%u%s%%uc%%u\",\n+            @encode(enum Enum), @encode(enum Enum));\n+    scan_initial(pattern);\n+  }\n+\n+\n   CHECK_IF(offs3 == offs2 + sizeof(XXPoint *) && offs4 == offs3 + sizeof(enum Enum));\n   CHECK_IF(totsize == offs4 + sizeof(int));  /* 'ObjCBool' is really 'char' */\n   meth = [proto descriptionForClassMethod: @selector(getBool:)];         "}, {"sha": "56fa701c86f2148fae34c6f1c94b566d20e81492", "filename": "gcc/testsuite/obj-c++.dg/threedotthree-abi-1.mm", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fthreedotthree-abi-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fthreedotthree-abi-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fthreedotthree-abi-1.mm?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,71 @@\n+/* This file tests that things are encoded using the gcc-3.3 ABI which is only\n+   used by the NeXT runtime.  */\n+/* { dg-do run { target *-*-darwin* } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+#include <stdio.h>\n+#include <string.h>\n+#include \"../objc-obj-c++-shared/Protocol1.h\"\n+#ifndef __NEXT_RUNTIME__\n+#include <objc/objc-api.h>\n+#endif\n+\n+extern \"C\" void abort();\n+\n+\n+@protocol CommonProtocol\n+\n+-(oneway void)methodCall_On:(in bycopy id)someValue_On;\n+-(oneway void)methodCall_nO:(bycopy in id)someValue_nO;\n+\n+-(oneway void)methodCall_Oo:(out bycopy id)someValue_Oo;\n+-(oneway void)methodCall_oO:(bycopy out id)someValue_oO;\n+\n+-(oneway void)methodCall_rn:(in const id)someValue_rn;\n+\n+-(oneway void)methodCall_oOn:(in bycopy out id)someValue_oOn;\n+\n+@end\n+\n+@interface ObjCClass <CommonProtocol>\n+{\n+\n+}\n+\n+@end\n+\n+@implementation ObjCClass\n+-(oneway void)methodCall_On:(in bycopy id)someValue_On { }\n+-(oneway void)methodCall_nO:(bycopy in id)someValue_nO { }\n+\n+-(oneway void)methodCall_Oo:(out bycopy id)someValue_Oo { }\n+-(oneway void)methodCall_oO:(bycopy out id)someValue_oO { }\n+\n+-(oneway void)methodCall_rn:(in const id)someValue_rn { }\n+-(oneway void)methodCall_oOn:(in bycopy out id)someValue_oOn { }\n+@end\n+\n+Protocol *proto = @protocol(CommonProtocol);\n+struct objc_method_description *meth;\n+\n+int main()\n+{\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_On:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4On@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_nO:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4nO@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_Oo:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4Oo@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_oO:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4oO@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_rn:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4rn@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_oOn:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4oOn@8\"))\n+\t  abort();\n+\treturn 0;\n+}"}, {"sha": "09cb6af19c2b7ed9848c79208ed58d4b6a8c6304", "filename": "gcc/testsuite/objc.dg/encode-1.m", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-1.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -4,7 +4,6 @@\n    where we have 'typedef char BOOL'.  */\n /* Contributed by Ziemowit Laski <zlaski@apple.com>.  */\n /* { dg-do run } */\n-/* { dg-options \"-fnext-runtime\" } */\n #include <string.h>           \n #include <stdlib.h>\n #include <objc/objc.h>"}, {"sha": "432245337abd44bf4277152732ab95e74d3798d7", "filename": "gcc/testsuite/objc.dg/encode-3.m", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-3.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -44,7 +44,7 @@ + (ProtoBool **)getBool:(ObjCBool **)b;\n static void scan_initial(const char *pattern) {\n   totsize = offs0 = offs1 = offs2 = offs3 = offs4 = offs5 = offs6 = offs7 = (unsigned)-1;\n   sscanf(meth->types, pattern, &totsize, &offs0, &offs1, &offs2, &offs3,\n-      &offs4, &offs5, &offs6, &offs7);\n+\t &offs4, &offs5, &offs6, &offs7);\n   CHECK_IF(!offs0 && offs1 == sizeof(id) && offs2 == offs1 + sizeof(SEL) && totsize >= offs2);\n }\n \n@@ -65,7 +65,21 @@ int main(void) {\n   CHECK_IF(offs3 == offs2 + sizeof(XXRect) && offs4 == offs3 + sizeof(int));\n   CHECK_IF(totsize == offs4 + sizeof(int));\n   meth = [proto descriptionForClassMethod: @selector(getEnum:enum:bool:)];\n-  scan_initial(\"^i%u@%u:%u^{?=ff(__XXAngle=II)}%ui%uc%u\");\n+\n+  /* Here we have the complication that 'enum Enum' could be encoded\n+     as 'i' on __NEXT_RUNTIME_, and (most likely) as 'I' on the GNU\n+     runtime.  So we get the @encode(enum Enum), then put it into the\n+     string in place of the traditional 'i'.\n+  */\n+  /* scan_initial(\"^i%u@%u:%u^{?=ff(__XXAngle=II)}%ui%uc%u\"); */\n+  {\n+    char pattern[1024];\n+\n+    sprintf (pattern, \"^%s%%u@%%u:%%u^{?=ff(__XXAngle=II)}%%u%s%%uc%%u\",\n+\t     @encode(enum Enum), @encode(enum Enum));\n+    scan_initial(pattern);\n+  }\n+\n   CHECK_IF(offs3 == offs2 + sizeof(XXPoint *) && offs4 == offs3 + sizeof(enum Enum));\n   CHECK_IF(totsize == offs4 + sizeof(int));  /* 'ObjCBool' is really 'char' */\n   meth = [proto descriptionForClassMethod: @selector(getBool:)];         "}, {"sha": "c3d922659aa8d4aaf904adeed2d6aa3db0030f48", "filename": "gcc/testsuite/objc.dg/encode-6-next.m", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-6-next.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-6-next.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-6-next.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,23 @@\n+/* Test for graceful encoding of const-qualified fields and parameters.  */\n+/* Author: Ziemowit Laski  <zlaski@apple.com>  */\n+/* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+\n+struct Cxx {\n+  const struct Cxx *next;\n+};\n+\n+@interface ObjC {\n+  const struct Cxx *obj;\n+}\n+- (ObjC *)initWithCxx: (struct Cxx *const)c and: (const struct Cxx *)d;\n+@end\n+\n+@implementation ObjC\n+- (ObjC *)initWithCxx: (struct Cxx *const)c and: (const struct Cxx *)d {\n+  obj = d;\n+  return self;\n+}\n+@end \n+\n+/* { dg-final { scan-assembler \"@\\[0-9\\]+@0:\\[0-9\\]+\\\\^{Cxx=\\\\^{Cxx}}\\[0-9\\]+r\\\\^{Cxx=\\\\^{Cxx}}\" } } */"}, {"sha": "291a41e96a0a783f1055ab8a502aa5c21c360bdb", "filename": "gcc/testsuite/objc.dg/encode-6.m", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-6.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-6.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-6.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -1,6 +1,7 @@\n /* Test for graceful encoding of const-qualified fields and parameters.  */\n /* Author: Ziemowit Laski  <zlaski@apple.com>  */\n /* { dg-do compile } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n \n struct Cxx {\n   const struct Cxx *next;"}, {"sha": "2a064d8816c4e9f4edddeb8b403d6ab4ca6dd453", "filename": "gcc/testsuite/objc.dg/encode-7-next-64bit.m", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next-64bit.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next-64bit.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next-64bit.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,266 @@\n+/* Additional testing for the NeXT runtime. Encoding in -m64 mode  */\n+\n+/* { dg-do run { target *-*-darwin* } } */\n+/* { dg-options \"-m64\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+\n+#include <objc/Object.h>\n+#include <stdbool.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#define CHECK_IF(E) if (!(E)) abort ()\n+\n+@class NSDictionary, NSFont, NSError, _NSATSTypesetterGuts, NSString, NSMenu, NSArray;\n+\n+typedef unsigned char UInt8;\n+typedef const signed long OSStatus;\n+typedef unsigned long CFIndex;\n+typedef unsigned int UInt32;\n+typedef UInt32 FourCharCode;\n+typedef FourCharCode OSType;\n+\n+struct FSRef {\n+  UInt8 hidden[80];\n+};\n+typedef struct FSRef FSRef;\n+\n+typedef struct _NSPoint {\n+    float x;\n+    float y;\n+} NSPoint;\n+\n+typedef struct _NSSize {\n+    float width;\n+    float height;\n+} NSSize;\n+\n+typedef struct _NSRect {\n+    NSPoint origin;\n+    NSSize size;\n+} NSRect;\n+\n+typedef struct _NSRange {\n+    unsigned int location;\n+    unsigned int length;\n+} NSRange;\n+\n+typedef const char *NXAtom;\n+\n+typedef struct {\n+  NSDictionary *_attributes;\n+  NSFont *_font;\n+  CFIndex _characterLength;\n+  CFIndex _nominalGlyphLocation;\n+  const CFIndex *p;\n+  float _defaultLineHeight;\n+  float _defaultBaselineOffset;\n+  float _horizExpansion;\n+  float _baselineDelta;\n+  NSRect _attachmentBBox;\n+  long ll, *llp;\n+  unsigned long ull, *ullp;\n+  id a;\n+  const id a1;\n+  const struct objc_object *a2;\n+  SEL b;\n+  const SEL b1;\n+  const struct objc_selector *b2;\n+  const char *str1;\n+  char *str2;\n+  char *const str3;\n+  const char *const str4;\n+  struct {\n+    unsigned int _isAttachmentRun:1;\n+    unsigned int _hasPositionalStake:1;\n+    unsigned int _isDefaultFace:1;\n+    unsigned int _hasCombiningMarks:1;\n+    unsigned int _isScreenFont:1;\n+    unsigned int _reserved:27;\n+  } _rFlags;\n+} NSATSGlyphStorageRun;\n+\n+typedef struct __CFSet *CFMutableSetRef;\n+typedef const struct __CTLine * CTLineRef;\n+typedef const struct __NSAppleEventManagerSuspension* NSAppleEventManagerSuspensionID;\n+\n+struct ComponentInstanceRecord {\n+  long data[1];\n+};\n+typedef struct ComponentInstanceRecord  ComponentInstanceRecord;\n+typedef ComponentInstanceRecord *ComponentInstance;\n+\n+typedef NSString *(*NSErrorUserInfoFormatterFunc)(id objToBeDisplayed, NSError *err, char modifier);\n+typedef struct {\n+  NSErrorUserInfoFormatterFunc formatterFunc;\n+  NSString *userInfoKey;\n+  unsigned int parameterMask;\n+} NSErrorUserInfoFormatter;\n+\n+typedef Object MyObj;\n+typedef Object *MyPtr;\n+\n+@interface Foo: Object {\n+  NSATSGlyphStorageRun r;\n+}\n+- (NSError *)_errorWithOSStatus:(OSStatus)inOSStatus ref1:(const FSRef *)inRef1 ref2:(const struct FSRef *)inRef2\n+  reading:(BOOL)inReadingNotWriting;\n+- (const NSATSGlyphStorageRun *)_attributeRunForCharacterAtIndex:(const CFIndex)charIndex;\n+- (const _NSATSTypesetterGuts *)_getATSTypesetterGuts:(const struct objc_selector *)sel;\n+- (void)resumeWithSuspensionID:(NSAppleEventManagerSuspensionID)suspensionID and:(const CFIndex *)status;\n+- (const id)anotherMeth:(const SEL)sel and:(const Foo *)foo and:(const struct objc_object *)obj;\n+- (id)str1:(const char *)str1 str2:(char *)str2 str3:(char *const)str3 str4:(const char *const)str4;\n+- (oneway void)foo1:(Foo *)foo1 foo2:(const Foo *)foo2 foo3:(Foo *const)foo3 foo4:(const Foo *const)foo4;\n+- (in const char *)sel1:(const SEL)sel1 id1:(const id)id1;\n+- (inout id)obj1:(const MyPtr)obj1 obj2:(Object *const)obj2 obj3:(MyObj *const)obj3;\n++ (ComponentInstance)_defaultScriptingComponent;\n+- (NSString *)_formatCocoaErrorString:(NSString *)formatString parameters:(const char *)parameters \n+  applicableFormatters:(NSErrorUserInfoFormatter **)formatters count:(int)numFormatters;\n+- (NSErrorUserInfoFormatter *)formatter_func:(id)obj run:(const NSATSGlyphStorageRun **)run;\n+- (BOOL)_forgetWord:(bycopy in NSString *)word inDictionary:(bycopy in NSString *)language;\n+- (void)_registerServicesMenu:(NSMenu *)servicesMenu withSendTypes:(const NXAtom *)sendTypes \n+  andReturnTypes:(const NXAtom *)returnTypes addToList:(BOOL)addToList;\n++ (CFMutableSetRef *)_proxySharePointer;\n+- (NSRange)_checkGrammarInString:(in NSString *)stringToCheck language:(bycopy in NSString *)language details:(bycopy out NSArray **)details;\n+- (bool)_resolvePositionalStakeGlyphsForLineFragment:(CTLineRef)line lineFragmentRect:(NSRect)lineFragmentRect\n+  minPosition:(float)minPosition maxPosition:(float)maxPosition maxLineFragmentWidth:(float)maxLineFragmentWidth\n+  breakHint:(CFIndex *)charIndex;\n++ (BOOL)findVoiceByIdentifier:(NSString *)identifier returningCreator:(OSType *)returnedCreator returningID:(OSType *)returnedID;\n+@end\n+\n+NSRange globalRange;\n+\n+@implementation Foo\n+- (NSError *)_errorWithOSStatus:(OSStatus)inOSStatus ref1:(const FSRef *)inRef1 ref2:(const struct FSRef *)inRef2\n+  reading:(BOOL)inReadingNotWriting {\n+  return (NSError *)self;\n+}\n+- (const NSATSGlyphStorageRun *)_attributeRunForCharacterAtIndex:(CFIndex)charIndex {\n+  return (const NSATSGlyphStorageRun *)self;\n+}\n+- (const _NSATSTypesetterGuts *)_getATSTypesetterGuts:(const struct objc_selector *)sel {\n+  return (const _NSATSTypesetterGuts *)self;\n+}\n+- (void)resumeWithSuspensionID:(NSAppleEventManagerSuspensionID)suspensionID and:(const CFIndex *)status {\n+}\n+- (const id)anotherMeth:(const SEL)sel and:(const Foo *)foo and:(const struct objc_object *)obj {\n+  return (const id)self;\n+}\n+- (id)str1:(const char *)str1 str2:(char *)str2 str3:(char *const)str3 str4:(const char *const)str4 {\n+  return self;\n+}\n+- (oneway void)foo1:(Foo *)foo1 foo2:(const Foo *)foo2 foo3:(Foo *const)foo3 foo4:(const Foo *const)foo4 {\n+}\n+- (in const char *)sel1:(const SEL)sel1 id1:(const id)id1 {\n+  return \"Hello\";\n+}  \n+- (inout id)obj1:(const MyPtr)obj1 obj2:(Object *const)obj2 obj3:(MyObj *const)obj3 {\n+  return self;\n+}\n++ (ComponentInstance)_defaultScriptingComponent {\n+  return (ComponentInstance)0;\n+}\n+- (NSString *)_formatCocoaErrorString:(NSString *)formatString parameters:(const char *)parameters \n+  applicableFormatters:(NSErrorUserInfoFormatter **)formatters count:(int)numFormatters {\n+  return (NSString *)self;\n+}\n+- (NSErrorUserInfoFormatter *)formatter_func:(id)obj run:(const NSATSGlyphStorageRun **)run {\n+  return (NSErrorUserInfoFormatter *)0;\n+}\n+- (BOOL)_forgetWord:(bycopy in NSString *)word inDictionary:(bycopy in NSString *)language {\n+  return YES;\n+}\n+- (void)_registerServicesMenu:(NSMenu *)servicesMenu withSendTypes:(const NXAtom *)sendTypes \n+  andReturnTypes:(const NXAtom *)returnTypes addToList:(BOOL)addToList {\n+}\n++ (CFMutableSetRef *)_proxySharePointer {\n+  return (CFMutableSetRef *)0;\n+}\n+- (NSRange)_checkGrammarInString:(in NSString *)stringToCheck language:(bycopy in NSString *)language details:(bycopy out NSArray **)details {\n+  return globalRange;\n+}\n+- (bool)_resolvePositionalStakeGlyphsForLineFragment:(CTLineRef)line lineFragmentRect:(NSRect)lineFragmentRect \n+  minPosition:(float)minPosition maxPosition:(float)maxPosition maxLineFragmentWidth:(float)maxLineFragmentWidth \n+  breakHint:(CFIndex *)charIndex {\n+  return false;\n+}\n++ (BOOL)findVoiceByIdentifier:(NSString *)identifier returningCreator:(OSType *)returnedCreator returningID:(OSType *)returnedID {\n+  return NO;\n+}\n+@end\n+\n+int main(void) {\n+  Class fooClass = objc_getClass (\"Foo\");\n+  Method meth;\n+  struct objc_ivar_list *ivars;\n+  struct objc_ivar *ivar;\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_errorWithOSStatus:ref1:ref2:reading:));\n+  CHECK_IF (!strcmp (meth->method_types, \"@44@0:8q16r^{FSRef=[80C]}24r^{FSRef=[80C]}32c40\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_attributeRunForCharacterAtIndex:));\n+  CHECK_IF (!strcmp (meth->method_types, \"r^{?=@@QQ^Qffff{_NSRect={_NSPoint=ff}{_NSSize=ff}}q^qQ^Q@@@:::****{?=b1b1b1b1b1b27}}24@0:8Q16\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_getATSTypesetterGuts:));\n+  CHECK_IF (!strcmp (meth->method_types, \"r@24@0:8r:16\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(resumeWithSuspensionID:and:));\n+  CHECK_IF (!strcmp (meth->method_types, \"v32@0:8^{__NSAppleEventManagerSuspension=}16r^Q24\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(anotherMeth:and:and:));\n+  CHECK_IF (!strcmp (meth->method_types, \"r@40@0:8r:16r@24r@32\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(str1:str2:str3:str4:));\n+  CHECK_IF (!strcmp (meth->method_types, \"@48@0:8r*16*24*32r*40\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(foo1:foo2:foo3:foo4:));\n+  CHECK_IF (!strcmp (meth->method_types, \"Vv48@0:8@16r@24@32r@40\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(sel1:id1:));\n+  CHECK_IF (!strcmp (meth->method_types, \"rn*32@0:8r:16r@24\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(obj1:obj2:obj3:));\n+  CHECK_IF (!strcmp (meth->method_types, \"N@40@0:8r@16@24^{Object=#}32\"));\n+\n+  meth = class_getClassMethod (fooClass, @selector(_defaultScriptingComponent));\n+  CHECK_IF (!strcmp (meth->method_types, \"^{ComponentInstanceRecord=[1q]}16@0:8\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_formatCocoaErrorString:parameters:applicableFormatters:count:));\n+  CHECK_IF (!strcmp (meth->method_types, \"@44@0:8@16r*24^^{?}32i40\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(formatter_func:run:));\n+  CHECK_IF (!strcmp (meth->method_types, \"^{?=^?@I}32@0:8@16r^^{?}24\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_forgetWord:inDictionary:));\n+  CHECK_IF (!strcmp (meth->method_types, \"c32@0:8nO@16nO@24\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_registerServicesMenu:withSendTypes:andReturnTypes:addToList:));\n+  CHECK_IF (!strcmp (meth->method_types, \"v44@0:8@16r^*24r^*32c40\"));\n+\n+  meth = class_getClassMethod (fooClass, @selector(_proxySharePointer));\n+  CHECK_IF (!strcmp (meth->method_types, \"^^{__CFSet}16@0:8\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_checkGrammarInString:language:details:));\n+  CHECK_IF (!strcmp (meth->method_types, \"{_NSRange=II}40@0:8n@16nO@24oO^@32\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_resolvePositionalStakeGlyphsForLineFragment:lineFragmentRect:minPosition:maxPosition:maxLineFragmentWidth:breakHint:));\n+  CHECK_IF (!strcmp (meth->method_types, \"B60@0:8^{__CTLine=}16{_NSRect={_NSPoint=ff}{_NSSize=ff}}24f40f44f48^Q52\"));\n+\n+  meth = class_getClassMethod (fooClass, @selector(findVoiceByIdentifier:returningCreator:returningID:));\n+  CHECK_IF (!strcmp (meth->method_types, \"c40@0:8@16^I24^I32\"));\n+\n+  ivars = fooClass->ivars;\n+  CHECK_IF (ivars->ivar_count == 1);\n+\n+  ivar = ivars->ivar_list;\n+  CHECK_IF (!strcmp (ivar->ivar_name, \"r\"));\n+  CHECK_IF (!strcmp (ivar->ivar_type,\n+   \"{?=\\\"_attributes\\\"@\\\"NSDictionary\\\"\\\"_font\\\"@\\\"NSFont\\\"\\\"_characterLength\\\"\"\n+    \"Q\\\"_nominalGlyphLocation\\\"Q\\\"p\\\"^Q\\\"_defaultLineHeight\\\"f\\\"_defaultBaselineOffset\\\"\"\n+    \"f\\\"_horizExpansion\\\"f\\\"_baselineDelta\\\"f\\\"_attachmentBBox\\\"{_NSRect=\\\"origin\\\"\"\n+    \"{_NSPoint=\\\"x\\\"f\\\"y\\\"f}\\\"size\\\"{_NSSize=\\\"width\\\"f\\\"height\\\"f}}\\\"ll\\\"q\\\"llp\\\"^q\\\"ull\\\"\"\n+    \"Q\\\"ullp\\\"^Q\\\"a\\\"@\\\"a1\\\"@\\\"a2\\\"@\\\"b\\\":\\\"b1\\\":\\\"b2\\\":\\\"str1\\\"*\\\"str2\\\"*\\\"str3\\\"*\\\"str4\\\"\"\n+    \"*\\\"_rFlags\\\"{?=\\\"_isAttachmentRun\\\"b1\\\"_hasPositionalStake\\\"b1\\\"_isDefaultFace\\\"\"\n+    \"b1\\\"_hasCombiningMarks\\\"b1\\\"_isScreenFont\\\"b1\\\"_reserved\\\"b27}}\"));\n+\n+  return 0;\n+}"}, {"sha": "60db23675ebf974a186c30e7c56ecfd5581d4423", "filename": "gcc/testsuite/objc.dg/encode-7-next.m", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fencode-7-next.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,267 @@\n+/* Additional testing for the NeXT runtime.  */\n+/* Author: Ziemowit Laski  <zlaski@apple.com>  */\n+\n+/* { dg-do run { target *-*-darwin* } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"-m64\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+\n+#include \"../objc-obj-c++-shared/Object1.h\"\n+#include <stdbool.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#define CHECK_IF(E) if (!(E)) abort ()\n+\n+@class NSDictionary, NSFont, NSError, _NSATSTypesetterGuts, NSString, NSMenu, NSArray;\n+\n+typedef unsigned char UInt8;\n+typedef const signed long OSStatus;\n+typedef unsigned long CFIndex;\n+typedef unsigned int UInt32;\n+typedef UInt32 FourCharCode;\n+typedef FourCharCode OSType;\n+\n+struct FSRef {\n+  UInt8 hidden[80];\n+};\n+typedef struct FSRef FSRef;\n+\n+typedef struct _NSPoint {\n+    float x;\n+    float y;\n+} NSPoint;\n+\n+typedef struct _NSSize {\n+    float width;\n+    float height;\n+} NSSize;\n+\n+typedef struct _NSRect {\n+    NSPoint origin;\n+    NSSize size;\n+} NSRect;\n+\n+typedef struct _NSRange {\n+    unsigned int location;\n+    unsigned int length;\n+} NSRange;\n+\n+typedef const char *NXAtom;\n+\n+typedef struct {\n+  NSDictionary *_attributes;\n+  NSFont *_font;\n+  CFIndex _characterLength;\n+  CFIndex _nominalGlyphLocation;\n+  const CFIndex *p;\n+  float _defaultLineHeight;\n+  float _defaultBaselineOffset;\n+  float _horizExpansion;\n+  float _baselineDelta;\n+  NSRect _attachmentBBox;\n+  long ll, *llp;\n+  unsigned long ull, *ullp;\n+  id a;\n+  const id a1;\n+  const struct objc_object *a2;\n+  SEL b;\n+  const SEL b1;\n+  const struct objc_selector *b2;\n+  const char *str1;\n+  char *str2;\n+  char *const str3;\n+  const char *const str4;\n+  struct {\n+    unsigned int _isAttachmentRun:1;\n+    unsigned int _hasPositionalStake:1;\n+    unsigned int _isDefaultFace:1;\n+    unsigned int _hasCombiningMarks:1;\n+    unsigned int _isScreenFont:1;\n+    unsigned int _reserved:27;\n+  } _rFlags;\n+} NSATSGlyphStorageRun;\n+\n+typedef struct __CFSet *CFMutableSetRef;\n+typedef const struct __CTLine * CTLineRef;\n+typedef const struct __NSAppleEventManagerSuspension* NSAppleEventManagerSuspensionID;\n+\n+struct ComponentInstanceRecord {\n+  long data[1];\n+};\n+typedef struct ComponentInstanceRecord  ComponentInstanceRecord;\n+typedef ComponentInstanceRecord *ComponentInstance;\n+\n+typedef NSString *(*NSErrorUserInfoFormatterFunc)(id objToBeDisplayed, NSError *err, char modifier);\n+typedef struct {\n+  NSErrorUserInfoFormatterFunc formatterFunc;\n+  NSString *userInfoKey;\n+  unsigned int parameterMask;\n+} NSErrorUserInfoFormatter;\n+\n+typedef Object MyObj;\n+typedef Object *MyPtr;\n+\n+@interface Foo: Object {\n+  NSATSGlyphStorageRun r;\n+}\n+- (NSError *)_errorWithOSStatus:(OSStatus)inOSStatus ref1:(const FSRef *)inRef1 ref2:(const struct FSRef *)inRef2\n+  reading:(BOOL)inReadingNotWriting;\n+- (const NSATSGlyphStorageRun *)_attributeRunForCharacterAtIndex:(const CFIndex)charIndex;\n+- (const _NSATSTypesetterGuts *)_getATSTypesetterGuts:(const struct objc_selector *)sel;\n+- (void)resumeWithSuspensionID:(NSAppleEventManagerSuspensionID)suspensionID and:(const CFIndex *)status;\n+- (const id)anotherMeth:(const SEL)sel and:(const Foo *)foo and:(const struct objc_object *)obj;\n+- (id)str1:(const char *)str1 str2:(char *)str2 str3:(char *const)str3 str4:(const char *const)str4;\n+- (oneway void)foo1:(Foo *)foo1 foo2:(const Foo *)foo2 foo3:(Foo *const)foo3 foo4:(const Foo *const)foo4;\n+- (in const char *)sel1:(const SEL)sel1 id1:(const id)id1;\n+- (inout id)obj1:(const MyPtr)obj1 obj2:(Object *const)obj2 obj3:(MyObj *const)obj3;\n++ (ComponentInstance)_defaultScriptingComponent;\n+- (NSString *)_formatCocoaErrorString:(NSString *)formatString parameters:(const char *)parameters \n+  applicableFormatters:(NSErrorUserInfoFormatter **)formatters count:(int)numFormatters;\n+- (NSErrorUserInfoFormatter *)formatter_func:(id)obj run:(const NSATSGlyphStorageRun **)run;\n+- (BOOL)_forgetWord:(bycopy in NSString *)word inDictionary:(bycopy in NSString *)language;\n+- (void)_registerServicesMenu:(NSMenu *)servicesMenu withSendTypes:(const NXAtom *)sendTypes \n+  andReturnTypes:(const NXAtom *)returnTypes addToList:(BOOL)addToList;\n++ (CFMutableSetRef *)_proxySharePointer;\n+- (NSRange)_checkGrammarInString:(in NSString *)stringToCheck language:(bycopy in NSString *)language details:(bycopy out NSArray **)details;\n+- (bool)_resolvePositionalStakeGlyphsForLineFragment:(CTLineRef)line lineFragmentRect:(NSRect)lineFragmentRect\n+  minPosition:(float)minPosition maxPosition:(float)maxPosition maxLineFragmentWidth:(float)maxLineFragmentWidth\n+  breakHint:(CFIndex *)charIndex;\n++ (BOOL)findVoiceByIdentifier:(NSString *)identifier returningCreator:(OSType *)returnedCreator returningID:(OSType *)returnedID;\n+@end\n+\n+NSRange globalRange;\n+\n+@implementation Foo\n+- (NSError *)_errorWithOSStatus:(OSStatus)inOSStatus ref1:(const FSRef *)inRef1 ref2:(const struct FSRef *)inRef2\n+  reading:(BOOL)inReadingNotWriting {\n+  return (NSError *)self;\n+}\n+- (const NSATSGlyphStorageRun *)_attributeRunForCharacterAtIndex:(CFIndex)charIndex {\n+  return (const NSATSGlyphStorageRun *)self;\n+}\n+- (const _NSATSTypesetterGuts *)_getATSTypesetterGuts:(const struct objc_selector *)sel {\n+  return (const _NSATSTypesetterGuts *)self;\n+}\n+- (void)resumeWithSuspensionID:(NSAppleEventManagerSuspensionID)suspensionID and:(const CFIndex *)status {\n+}\n+- (const id)anotherMeth:(const SEL)sel and:(const Foo *)foo and:(const struct objc_object *)obj {\n+  return (const id)self;\n+}\n+- (id)str1:(const char *)str1 str2:(char *)str2 str3:(char *const)str3 str4:(const char *const)str4 {\n+  return self;\n+}\n+- (oneway void)foo1:(Foo *)foo1 foo2:(const Foo *)foo2 foo3:(Foo *const)foo3 foo4:(const Foo *const)foo4 {\n+}\n+- (in const char *)sel1:(const SEL)sel1 id1:(const id)id1 {\n+  return \"Hello\";\n+}  \n+- (inout id)obj1:(const MyPtr)obj1 obj2:(Object *const)obj2 obj3:(MyObj *const)obj3 {\n+  return self;\n+}\n++ (ComponentInstance)_defaultScriptingComponent {\n+  return (ComponentInstance)0;\n+}\n+- (NSString *)_formatCocoaErrorString:(NSString *)formatString parameters:(const char *)parameters \n+  applicableFormatters:(NSErrorUserInfoFormatter **)formatters count:(int)numFormatters {\n+  return (NSString *)self;\n+}\n+- (NSErrorUserInfoFormatter *)formatter_func:(id)obj run:(const NSATSGlyphStorageRun **)run {\n+  return (NSErrorUserInfoFormatter *)0;\n+}\n+- (BOOL)_forgetWord:(bycopy in NSString *)word inDictionary:(bycopy in NSString *)language {\n+  return YES;\n+}\n+- (void)_registerServicesMenu:(NSMenu *)servicesMenu withSendTypes:(const NXAtom *)sendTypes \n+  andReturnTypes:(const NXAtom *)returnTypes addToList:(BOOL)addToList {\n+}\n++ (CFMutableSetRef *)_proxySharePointer {\n+  return (CFMutableSetRef *)0;\n+}\n+- (NSRange)_checkGrammarInString:(in NSString *)stringToCheck language:(bycopy in NSString *)language details:(bycopy out NSArray **)details {\n+  return globalRange;\n+}\n+- (bool)_resolvePositionalStakeGlyphsForLineFragment:(CTLineRef)line lineFragmentRect:(NSRect)lineFragmentRect \n+  minPosition:(float)minPosition maxPosition:(float)maxPosition maxLineFragmentWidth:(float)maxLineFragmentWidth \n+  breakHint:(CFIndex *)charIndex {\n+  return false;\n+}\n++ (BOOL)findVoiceByIdentifier:(NSString *)identifier returningCreator:(OSType *)returnedCreator returningID:(OSType *)returnedID {\n+  return NO;\n+}\n+@end\n+\n+int main(void) {\n+  Class fooClass = objc_getClass (\"Foo\");\n+  Method meth;\n+  struct objc_ivar_list *ivars;\n+  struct objc_ivar *ivar;\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_errorWithOSStatus:ref1:ref2:reading:));\n+  CHECK_IF (!strcmp (meth->method_types, \"@24@0:4l8r^{FSRef=[80C]}12r^{FSRef=[80C]}16c20\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_attributeRunForCharacterAtIndex:));\n+  CHECK_IF (!strcmp (meth->method_types, \"r^{?=@@II^Iffff{_NSRect={_NSPoint=ff}{_NSSize=ff}}l^lL^L@@@:::****{?=b1b1b1b1b1b27}}12@0:4L8\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_getATSTypesetterGuts:));\n+  CHECK_IF (!strcmp (meth->method_types, \"r@12@0:4r:8\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(resumeWithSuspensionID:and:));\n+  CHECK_IF (!strcmp (meth->method_types, \"v16@0:4^{__NSAppleEventManagerSuspension=}8r^I12\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(anotherMeth:and:and:));\n+  CHECK_IF (!strcmp (meth->method_types, \"r@20@0:4r:8r@12r@16\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(str1:str2:str3:str4:));\n+  CHECK_IF (!strcmp (meth->method_types, \"@24@0:4r*8*12*16r*20\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(foo1:foo2:foo3:foo4:));\n+  CHECK_IF (!strcmp (meth->method_types, \"Vv24@0:4@8r@12@16r@20\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(sel1:id1:));\n+  CHECK_IF (!strcmp (meth->method_types, \"rn*16@0:4r:8r@12\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(obj1:obj2:obj3:));\n+  CHECK_IF (!strcmp (meth->method_types, \"N@20@0:4r@8@12^{Object=#}16\"));\n+\n+  meth = class_getClassMethod (fooClass, @selector(_defaultScriptingComponent));\n+  CHECK_IF (!strcmp (meth->method_types, \"^{ComponentInstanceRecord=[1l]}8@0:4\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_formatCocoaErrorString:parameters:applicableFormatters:count:));\n+  CHECK_IF (!strcmp (meth->method_types, \"@24@0:4@8r*12^^{?}16i20\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(formatter_func:run:));\n+  CHECK_IF (!strcmp (meth->method_types, \"^{?=^?@I}16@0:4@8r^^{?}12\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_forgetWord:inDictionary:));\n+  CHECK_IF (!strcmp (meth->method_types, \"c16@0:4nO@8nO@12\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_registerServicesMenu:withSendTypes:andReturnTypes:addToList:));\n+  CHECK_IF (!strcmp (meth->method_types, \"v24@0:4@8r^*12r^*16c20\"));\n+\n+  meth = class_getClassMethod (fooClass, @selector(_proxySharePointer));\n+  CHECK_IF (!strcmp (meth->method_types, \"^^{__CFSet}8@0:4\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_checkGrammarInString:language:details:));\n+  CHECK_IF (!strcmp (meth->method_types, \"{_NSRange=II}20@0:4n@8nO@12oO^@16\"));\n+\n+  meth = class_getInstanceMethod (fooClass, @selector(_resolvePositionalStakeGlyphsForLineFragment:lineFragmentRect:minPosition:maxPosition:maxLineFragmentWidth:breakHint:));\n+  CHECK_IF (!strcmp (meth->method_types, \"B44@0:4^{__CTLine=}8{_NSRect={_NSPoint=ff}{_NSSize=ff}}12f28f32f36^I40\"));\n+\n+  meth = class_getClassMethod (fooClass, @selector(findVoiceByIdentifier:returningCreator:returningID:));\n+  CHECK_IF (!strcmp (meth->method_types, \"c20@0:4@8^I12^I16\"));\n+\n+  ivars = fooClass->ivars;\n+  CHECK_IF (ivars->ivar_count == 1);\n+\n+  ivar = ivars->ivar_list;\n+  CHECK_IF (!strcmp (ivar->ivar_name, \"r\"));\n+  CHECK_IF (!strcmp (ivar->ivar_type,\n+    \"{?=\\\"_attributes\\\"@\\\"NSDictionary\\\"\\\"_font\\\"@\\\"NSFont\\\"\\\"_characterLength\\\"\"\n+    \"I\\\"_nominalGlyphLocation\\\"I\\\"p\\\"^I\\\"_defaultLineHeight\\\"f\\\"_defaultBaselineOffset\\\"\"\n+    \"f\\\"_horizExpansion\\\"f\\\"_baselineDelta\\\"f\\\"_attachmentBBox\\\"{_NSRect=\\\"origin\\\"\"\n+    \"{_NSPoint=\\\"x\\\"f\\\"y\\\"f}\\\"size\\\"{_NSSize=\\\"width\\\"f\\\"height\\\"f}}\\\"ll\\\"l\\\"llp\\\"^l\\\"ull\\\"\"\n+    \"L\\\"ullp\\\"^L\\\"a\\\"@\\\"a1\\\"@\\\"a2\\\"@\\\"b\\\":\\\"b1\\\":\\\"b2\\\":\\\"str1\\\"*\\\"str2\\\"*\\\"str3\\\"*\\\"str4\\\"\"\n+    \"*\\\"_rFlags\\\"{?=\\\"_isAttachmentRun\\\"b1\\\"_hasPositionalStake\\\"b1\\\"_isDefaultFace\\\"\"\n+    \"b1\\\"_hasCombiningMarks\\\"b1\\\"_isScreenFont\\\"b1\\\"_reserved\\\"b27}}\"));\n+\n+  return 0;\n+}"}, {"sha": "ac650aa25a784e874fcb02f1ae84f60bca5176d0", "filename": "gcc/testsuite/objc.dg/proto-qual-1.m", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fproto-qual-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fproto-qual-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproto-qual-1.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -44,10 +44,20 @@ static void scan_initial(const char *pattern) {\n \n int main(void) {\n   meth = [proto descriptionForInstanceMethod: @selector(address:with:)];\n+#ifndef __NEXT_RUNTIME__\n   scan_initial(\"O@%u@%u:%uRN@%uo^^S%u\");\n+#else\n+  /* The NEXT runtime tries to be compatible with gcc-3.3  */\n+  scan_initial(\"O@%u@%u:%uNR@%uo^^S%u\");\n+#endif\n   CHECK_IF(offs3 == offs2 + aligned_sizeof(id) && totsize == offs3 + aligned_sizeof(unsigned));\n   meth = [proto descriptionForClassMethod: @selector(retainArgument:with:)];\n+#ifndef __NEXT_RUNTIME__\n   scan_initial(\"Vv%u@%u:%uoO@%un^*%u\");\n+#else\n+  /* The NEXT runtime tries to be compatible with gcc-3.3  */\n+  scan_initial(\"Vv%u@%u:%uOo@%un^*%u\");\n+#endif\n   CHECK_IF(offs3 == offs2 + aligned_sizeof(id) && totsize == offs3 + aligned_sizeof(char **));\n   return 0;\n }"}, {"sha": "8e4f2bed1740bcdbc1b43f376ba395be05f087fc", "filename": "gcc/testsuite/objc.dg/threedotthree-abi-1.m", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fthreedotthree-abi-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Fthreedotthree-abi-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fthreedotthree-abi-1.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,68 @@\n+/* This file tests that things are encoded using the gcc-3.3 ABI which is only\n+   used by the NeXT runtime.  */\n+/* { dg-do run { target *-*-darwin* } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fgnu-runtime\" } { \"\" } } */\n+#include <stdio.h>\n+#include <string.h>\n+#include \"../objc-obj-c++-shared/Protocol1.h\"\n+\n+extern void abort();\n+\n+\n+@protocol CommonProtocol\n+\n+-(oneway void)methodCall_On:(in bycopy id)someValue_On;\n+-(oneway void)methodCall_nO:(bycopy in id)someValue_nO;\n+\n+-(oneway void)methodCall_Oo:(out bycopy id)someValue_Oo;\n+-(oneway void)methodCall_oO:(bycopy out id)someValue_oO;\n+\n+-(oneway void)methodCall_rn:(in const id)someValue_rn;\n+\n+-(oneway void)methodCall_oOn:(in bycopy out id)someValue_oOn;\n+\n+@end\n+\n+@interface ObjCClass <CommonProtocol>\n+{\n+\n+}\n+\n+@end\n+\n+@implementation ObjCClass\n+-(oneway void)methodCall_On:(in bycopy id)someValue_On { }\n+-(oneway void)methodCall_nO:(bycopy in id)someValue_nO { }\n+\n+-(oneway void)methodCall_Oo:(out bycopy id)someValue_Oo { }\n+-(oneway void)methodCall_oO:(bycopy out id)someValue_oO { }\n+\n+-(oneway void)methodCall_rn:(in const id)someValue_rn { }\n+-(oneway void)methodCall_oOn:(in bycopy out id)someValue_oOn { }\n+@end\n+\n+Protocol *proto = @protocol(CommonProtocol);\n+struct objc_method_description *meth;\n+\n+int main()\n+{\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_On:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4On@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_nO:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4nO@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_Oo:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4Oo@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_oO:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4oO@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_rn:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4rn@8\"))\n+\t  abort();\n+        meth = [proto descriptionForInstanceMethod: @selector(methodCall_oOn:)];\n+\tif (strcmp (meth->types, \"Vv12@0:4oOn@8\"))\n+\t  abort();\n+\treturn 0;\n+}"}, {"sha": "499f0831dd25cbe955759aa2977acdcf0503122d", "filename": "gcc/testsuite/objc.dg/type-size-2.m", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-size-2.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-size-2.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-size-2.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -48,7 +48,20 @@ int main(void) {\n   cls = objc_get_class(\"ArrayTest\");\n \n   meth = class_get_instance_method(cls, @selector(str:with:and:));\n-  scan_initial(\"r*%u@%u:%u*%u*%u[4i]%u\");\n+\n+  /* Here we have the complication that 'enum Enum' could be encoded\n+     as 'i' on __NEXT_RUNTIME_, and (most likely) as 'I' on the GNU\n+     runtime.  So we get the @encode(enum Enum), then put it into the\n+     string in place of the traditional 'i'.\n+  */\n+  /* scan_initial(\"r*%u@%u:%u*%u*%u[4i]%u\"); */\n+  {\n+    char pattern[1024];\n+\n+    sprintf (pattern, \"r*%%u@%%u:%%u*%%u*%%u[4%s]%%u\", @encode(enum Enum));\n+    scan_initial(pattern);\n+  }\n+\n   CHECK_IF(offs3 == offs2 + sizeof(signed char *) && offs4 == offs3 + sizeof(unsigned char *));\n   CHECK_IF(totsize == offs4 + sizeof(enum Enum *));\n   meth = class_get_instance_method(cls, @selector(meth1:with:with:));"}, {"sha": "9486658853c9f0613fe2cbf3ec8776fd22710571", "filename": "gcc/testsuite/objc.dg/type-size-3.m", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-size-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-size-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-size-3.m?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -0,0 +1,18 @@\n+/* Reject ivars with an unknown size.  */\n+/* Contributed by Nicola Pero  <nicola.pero@meta-innovation.com> */\n+/* { dg-do compile } */\n+\n+typedef struct\n+{\n+  unsigned long int a;\n+  double b[];\n+} test_type;\n+\n+@interface Test\n+{\n+  test_type c;\n+}\n+@end\n+\n+@implementation Test\n+@end /* { dg-error \"instance variable has unknown size\" } */"}, {"sha": "029b0a31ad8184236cedfc7891a4ce45ad893761", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -1,3 +1,13 @@\n+2010-09-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* encoding.c (objc_sizeof_type): Added support for vector type and\n+\tfor double long types.\t\n+\t(objc_alignof_type): Same change.\n+\t(objc_skip_typespec): Same change.\n+\t* objc/encoding.h (_C_GCINVISIBLE): Use '|' for _C_GCINVISIBLE\n+\tinstead of '!' since '!' is already used for _C_VECTOR.\n+\t* objc/objc-api.h (_C_LNG_DBL): Added.\n+\t\n 2010-09-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* libobjc_entry.c: File removed."}, {"sha": "d417b87396eff13bba01cd40f957c2e03a89debc", "filename": "libobjc/encoding.c", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -148,6 +148,8 @@ objc_sizeof_type (const char *type)\n   /* Skip the variable name if any */\n   if (*type == '\"')\n     {\n+      /* FIXME: How do we know we won't read beyond the end of the\n+\t string.  Here and in the rest of the file!  */\n       for (type++; *type++ != '\"';)\n \t/* do nothing */;\n     }\n@@ -217,6 +219,10 @@ objc_sizeof_type (const char *type)\n     return sizeof (double);\n     break;\n \n+  case _C_LNG_DBL:\n+    return sizeof (long double);\n+    break;\n+\n   case _C_VOID:\n     return sizeof (void);\n     break;\n@@ -236,6 +242,19 @@ objc_sizeof_type (const char *type)\n     }\n     break;\n \n+  case _C_VECTOR:\n+    {\n+      /* Skip the '!'.  */\n+      type++;\n+      /* Skip the '['.  */\n+      type++;\n+\n+      /* The size in bytes is the following number.  */\n+      int size = atoi (type);\n+      return size;\n+    }\n+    break;\n+\n   case _C_BFLD:\n     {\n       /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n@@ -318,6 +337,10 @@ objc_sizeof_type (const char *type)\n \t    case _C_DBL:\n \t      return sizeof (_Complex double);\n \t      break;\n+\n+\t    case _C_LNG_DBL:\n+\t      return sizeof (_Complex long double);\n+\t      break;\n \t    \n \t    default:\n \t      {\n@@ -418,6 +441,10 @@ objc_alignof_type (const char *type)\n     return __alignof__ (double);\n     break;\n \n+  case _C_LNG_DBL:\n+    return __alignof__ (long double);\n+    break;\n+\n   case _C_PTR:\n   case _C_ATOM:\n   case _C_CHARPTR:\n@@ -429,6 +456,23 @@ objc_alignof_type (const char *type)\n       /* do nothing */;\n     return objc_alignof_type (type);\n \n+  case _C_VECTOR:\n+    {   \n+      /* Skip the '!'.  */\n+      type++;\n+      /* Skip the '['.  */\n+      type++;\n+      \n+      /* Skip the size.  */\n+      while (isdigit ((unsigned char)*type))\n+\ttype++;\n+      \n+      /* Skip the ','.  */\n+      type++;\n+      \n+      /* The alignment in bytes is the following number.  */\n+      return atoi (type);\n+    }\n   case _C_STRUCT_B:\n   case _C_UNION_B:\n     {\n@@ -496,6 +540,10 @@ objc_alignof_type (const char *type)\n \t    case _C_DBL:\n \t      return __alignof__ (_Complex double);\n \t      break;\n+\n+\t    case _C_LNG_DBL:\n+\t      return __alignof__ (_Complex long double);\n+\t      break;\n \t    \n \t    default:\n \t      {\n@@ -631,6 +679,7 @@ objc_skip_typespec (const char *type)\n   case _C_ULNG_LNG:\n   case _C_FLT:\n   case _C_DBL:\n+  case _C_LNG_DBL:\n   case _C_VOID:\n   case _C_UNDEF:\n     return ++type;\n@@ -642,7 +691,6 @@ objc_skip_typespec (const char *type)\n \n   case _C_ARY_B:\n     /* skip digits, typespec and closing ']' */\n-\n     while (isdigit ((unsigned char)*++type))\n       ;\n     type = objc_skip_typespec (type);\n@@ -654,6 +702,30 @@ objc_skip_typespec (const char *type)\n \treturn 0;\n       }\n \n+  case _C_VECTOR:\n+    /* Skip '!' */\n+    type++;\n+    /* Skip '[' */\n+    type++;\n+    /* Skip digits (size) */\n+    while (isdigit ((unsigned char)*type))\n+      type++;\n+    /* Skip ',' */\n+    type++;\n+    /* Skip digits (alignment) */\n+    while (isdigit ((unsigned char)*type))\n+      type++;\n+    /* Skip typespec.  */\n+    type = objc_skip_typespec (type);\n+    /* Skip closing ']'.  */\n+    if (*type == _C_ARY_E)\n+      return ++type;\n+    else\n+      {\n+\t_objc_abort (\"bad vector type %s\\n\", type);\n+\treturn 0;\n+      }\n+\n   case _C_BFLD:\n     /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n     while (isdigit ((unsigned char)*++type))\n@@ -700,6 +772,8 @@ objc_skip_typespec (const char *type)\n /*\n   Skip an offset as part of a method encoding.  This is prepended by a\n   '+' if the argument is passed in registers.\n+\n+  FIXME: The compiler never generates '+'.\n */\n const char *\n objc_skip_offset (const char *type)\n@@ -883,7 +957,7 @@ objc_get_type_qualifiers (const char *type)\n   the presence of bitfields inside the structure. */\n void\n objc_layout_structure (const char *type,\n-                           struct objc_struct_layout *layout)\n+\t\t       struct objc_struct_layout *layout)\n {\n   const char *ntype;\n \n@@ -979,6 +1053,7 @@ objc_layout_structure_next_member (struct objc_struct_layout *layout)\n       bfld_field_size = atoi (objc_skip_typespec (bfld_type));\n     }\n \n+  /* The following won't work for vectors.  */\n #ifdef BIGGEST_FIELD_ALIGNMENT\n   desired_align = MIN (desired_align, BIGGEST_FIELD_ALIGNMENT);\n #endif"}, {"sha": "177ef726a00e2a20c6758c2b484268284b814188", "filename": "libobjc/objc/encoding.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2Fobjc%2Fencoding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2Fobjc%2Fencoding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fencoding.h?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -42,7 +42,7 @@ extern \"C\" {\n #define _C_BYCOPY\t'O'\n #define _C_BYREF\t'R'\n #define _C_ONEWAY\t'V'\n-#define _C_GCINVISIBLE\t'!'\n+#define _C_GCINVISIBLE\t'|'\n \n #define _F_CONST\t0x01\n #define _F_IN\t\t0x01"}, {"sha": "be433cb9a0515aac0b5541c92de89ff0b4e0fa7c", "filename": "libobjc/objc/objc-api.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/177b48f93077a03a72cee7ab5897996e2ea47cdc/libobjc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fobjc-api.h?ref=177b48f93077a03a72cee7ab5897996e2ea47cdc", "patch": "@@ -68,21 +68,27 @@ struct objc_method_description\n #define _C_ULNG_LNG 'Q'\n #define _C_FLT      'f'\n #define _C_DBL      'd'\n+#define _C_LNG_DBL  'D'\n #define _C_BFLD     'b'\n-#define _C_BOOL\t    'B'\n+#define _C_BOOL     'B'\n #define _C_VOID     'v'\n #define _C_UNDEF    '?'\n #define _C_PTR      '^'\n #define _C_CHARPTR  '*'\n-#define _C_ATOM     '%'\n #define _C_ARY_B    '['\n #define _C_ARY_E    ']'\n #define _C_UNION_B  '('\n #define _C_UNION_E  ')'\n #define _C_STRUCT_B '{'\n #define _C_STRUCT_E '}'\n #define _C_VECTOR   '!'\n-#define _C_COMPLEX   'j'\n+#define _C_COMPLEX  'j'\n+\n+/* The following one is never generated by the compiler.  You can\n+   treat it as equivalent to \"*\".\n+*/\n+#define _C_ATOM     '%'\n+\n \n #include \"deprecated/objc_error.h\"\n "}]}