{"sha": "9abe5d07d9d68c49971af2b93a4f83608a363284", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFiZTVkMDdkOWQ2OGM0OTk3MWFmMmI5M2E0ZjgzNjA4YTM2MzI4NA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2004-05-25T19:15:07Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2004-05-25T19:15:07Z"}, "message": "global.c (global_alloc): Call make_accurate_live_analysis.\n\n2004-05-25  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* global.c (global_alloc): Call make_accurate_live_analysis.\n\t(record_one_conflict): Remove dead code.\n\t(mark_reg_clobber): Remove ATTRIBUTE_UNUSED for parameter data.\n\t(bb_info): New structure.\n\t(BB_INFO, BB_INFO_BY_INDEX): New macros.\n\t(allocate_bb_info, free_bb_info, mark_reg_change,\n\tcalculate_local_reg_bb_info, set_up_bb_rts_numbers, rpost_cmp,\n\tmodify_bb_reg_pav, calculate_reg_pav,\n\tmake_accurate_live_analysis): New functions.\n\nFrom-SVN: r82254", "tree": {"sha": "edbdc57c93f3a3b85242a1df2c9b0a8e661c26df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edbdc57c93f3a3b85242a1df2c9b0a8e661c26df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9abe5d07d9d68c49971af2b93a4f83608a363284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abe5d07d9d68c49971af2b93a4f83608a363284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9abe5d07d9d68c49971af2b93a4f83608a363284", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9abe5d07d9d68c49971af2b93a4f83608a363284/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "435317e25c1f3571a72d97d089ca085ffd0bf20b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435317e25c1f3571a72d97d089ca085ffd0bf20b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/435317e25c1f3571a72d97d089ca085ffd0bf20b"}], "stats": {"total": 301, "additions": 288, "deletions": 13}, "files": [{"sha": "bcda29762a7624d0f6c4be350e5804d1ae3e1356", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5d07d9d68c49971af2b93a4f83608a363284/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5d07d9d68c49971af2b93a4f83608a363284/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9abe5d07d9d68c49971af2b93a4f83608a363284", "patch": "@@ -1,3 +1,15 @@\n+2004-05-25  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* global.c (global_alloc): Call make_accurate_live_analysis.\n+\t(record_one_conflict): Remove dead code.\n+\t(mark_reg_clobber): Remove ATTRIBUTE_UNUSED for parameter data.\n+\t(bb_info): New structure.\n+\t(BB_INFO, BB_INFO_BY_INDEX): New macros.\n+\t(allocate_bb_info, free_bb_info, mark_reg_change,\n+\tcalculate_local_reg_bb_info, set_up_bb_rts_numbers, rpost_cmp,\n+\tmodify_bb_reg_pav, calculate_reg_pav,\n+\tmake_accurate_live_analysis): New functions.\n+\t\n 2004-05-25  Devang Patel  <dpatel@apple.com>\n \n \t* alias.c (init_alias_analysis): Use ggc_calloc instead of"}, {"sha": "25b129eb46e056496ed312ad59572804718a4342", "filename": "gcc/global.c", "status": "modified", "additions": 276, "deletions": 13, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9abe5d07d9d68c49971af2b93a4f83608a363284/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9abe5d07d9d68c49971af2b93a4f83608a363284/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=9abe5d07d9d68c49971af2b93a4f83608a363284", "patch": "@@ -306,7 +306,18 @@ static void set_preference (rtx, rtx);\n static void dump_conflicts (FILE *);\n static void reg_becomes_live (rtx, rtx, void *);\n static void reg_dies (int, enum machine_mode, struct insn_chain *);\n+\n+static void allocate_bb_info (void);\n+static void free_bb_info (void);\n+static void calculate_local_reg_bb_info (void);\n+static void set_up_bb_rts_numbers (void);\n+static int rpost_cmp (const void *, const void *);\n+static bool modify_bb_reg_pav (basic_block, basic_block, bool);\n+static void calculate_reg_pav (void);\n+static void make_accurate_live_analysis (void);\n+\n \f\n+\n /* Perform allocation of pseudo-registers not allocated by local_alloc.\n    FILE is a file to output debugging information on,\n    or zero if such output is not desired.\n@@ -329,6 +340,8 @@ global_alloc (FILE *file)\n   size_t i;\n   rtx x;\n \n+  make_accurate_live_analysis ();\n+\n   max_allocno = 0;\n \n   /* A machine may have certain hard registers that\n@@ -1377,18 +1390,7 @@ record_one_conflict (int regno)\n \n       IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, hard_regs_live);\n       for (j = allocno_row_words - 1; j >= 0; j--)\n-\t{\n-#if 0\n-\t  int k;\n-\t  for (k = 0; k < n_no_conflict_pairs; k++)\n-\t    if (! ((j == no_conflict_pairs[k].allocno1\n-\t\t    && ialloc == no_conflict_pairs[k].allocno2)\n-\t\t   ||\n-\t\t   (j == no_conflict_pairs[k].allocno2\n-\t\t    && ialloc == no_conflict_pairs[k].allocno1)))\n-#endif /* 0 */\n-\t      conflicts[ialloc_prod + j] |= allocnos_live[j];\n-\t}\n+\tconflicts[ialloc_prod + j] |= allocnos_live[j];\n     }\n }\n \n@@ -1503,7 +1505,7 @@ mark_reg_store (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n /* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */\n \n static void\n-mark_reg_clobber (rtx reg, rtx setter, void *data ATTRIBUTE_UNUSED)\n+mark_reg_clobber (rtx reg, rtx setter, void *data)\n {\n   if (GET_CODE (setter) == CLOBBER)\n     mark_reg_store (reg, setter, data);\n@@ -1973,3 +1975,264 @@ dump_global_regs (FILE *file)\n       fprintf (file, \" %d\", i);\n   fprintf (file, \"\\n\\n\");\n }\n+\n+\f\n+\n+/* This page contains code to make live information more accurate.\n+   The accurate register liveness at program point P means:\n+     o there is a path from P to usage of the register and the\n+       register is not redefined or killed on the path.\n+     o register at P is partially available, i.e. there is a path from\n+       a register definition to the point P and the register is not\n+       killed (clobbered) on the path\n+\n+   The standard GCC live information means only the first condition.\n+   Without the partial availability, there will be more register\n+   conflicts and as a consequence worse register allocation.  The\n+   typical example where the information can be different is a\n+   register initialized in the loop at the basic block preceding the\n+   loop in CFG. */\n+\n+/* The following structure contains basic block data flow information\n+   used to calculate partial availability of registers.  */\n+\n+struct bb_info\n+{\n+  /* The basic block reverse post-order number.  */\n+  int rts_number;\n+  /* Registers correspondingly killed (clobbered) and defined but not\n+     killed afterward in the basic block.  */\n+  bitmap killed, avloc;\n+  /* Registers partially available correspondingly at the start and\n+     end of the basic block.  */\n+  bitmap pavin, pavout;\n+};\n+\n+/* Macros for accessing data flow information of basic blocks.  */\n+\n+#define BB_INFO(BB) ((struct bb_info *) (BB)->aux)\n+#define BB_INFO_BY_INDEX(N) BB_INFO (BASIC_BLOCK(N))\n+\n+/* The function allocates the info structures of each basic block.  It\n+   also initialized PAVIN and PAVOUT as if all hard registers were\n+   partially available.  */\n+\n+static void\n+allocate_bb_info (void)\n+{\n+  int i;\n+  basic_block bb;\n+  struct bb_info *bb_info;\n+  bitmap init;\n+\n+  alloc_aux_for_blocks (sizeof (struct bb_info));\n+  init = BITMAP_XMALLOC ();\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    bitmap_set_bit (init, i);\n+  FOR_EACH_BB (bb)\n+    {\n+      bb_info = bb->aux;\n+      bb_info->avloc = BITMAP_XMALLOC ();\n+      bb_info->killed = BITMAP_XMALLOC ();\n+      bb_info->pavin = BITMAP_XMALLOC ();\n+      bb_info->pavout = BITMAP_XMALLOC ();\n+      bitmap_copy (bb_info->pavin, init);\n+      bitmap_copy (bb_info->pavout, init);\n+    }\n+  BITMAP_XFREE (init);\n+}\n+\n+/* The function frees the allocated info of all basic blocks.  */\n+\n+static void\n+free_bb_info (void)\n+{\n+  basic_block bb;\n+  struct bb_info *bb_info;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bb_info = BB_INFO (bb);\n+      BITMAP_XFREE (bb_info->pavout);\n+      BITMAP_XFREE (bb_info->pavin);\n+      BITMAP_XFREE (bb_info->killed);\n+      BITMAP_XFREE (bb_info->avloc);\n+    }\n+  free_aux_for_blocks ();\n+}\n+\n+/* The function modifies local info for register REG being changed in\n+   SETTER.  DATA is used to pass the current basic block info.  */\n+\n+static void\n+mark_reg_change (rtx reg, rtx setter, void *data)\n+{\n+  int regno;\n+  basic_block bb = data;\n+  struct bb_info *bb_info = BB_INFO (bb);\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+\n+  regno = REGNO (reg);\n+  bitmap_set_bit (bb_info->killed, regno);\n+  \n+  if (GET_CODE (setter) != CLOBBER)\n+    bitmap_set_bit (bb_info->avloc, regno);\n+  else\n+    bitmap_clear_bit (bb_info->avloc, regno);\n+}\n+\n+/* The function calculates local info for each basic block.  */\n+\n+static void\n+calculate_local_reg_bb_info (void)\n+{\n+  basic_block bb;\n+  rtx insn, bound;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      bound = NEXT_INSN (BB_END (bb));\n+      for (insn = BB_HEAD (bb); insn != bound; insn = NEXT_INSN (insn))\n+\tif (INSN_P (insn))\n+\t  note_stores (PATTERN (insn), mark_reg_change, bb);\n+    }\n+}\n+\n+/* The function sets up reverse post-order number of each basic\n+   block.  */\n+\n+static void\n+set_up_bb_rts_numbers (void)\n+{\n+  int i;\n+  int *rts_order;\n+  \n+  rts_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  flow_reverse_top_sort_order_compute (rts_order);\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BB_INFO_BY_INDEX (rts_order [i])->rts_number = i;\n+  free (rts_order);\n+}\n+\n+/* Compare function for sorting blocks in reverse postorder.  */\n+\n+static int\n+rpost_cmp (const void *bb1, const void *bb2)\n+{\n+  basic_block b1 = *(basic_block *) bb1, b2 = *(basic_block *) bb2;\n+\n+  return BB_INFO (b2)->rts_number - BB_INFO (b1)->rts_number;\n+}\n+\n+/* The function calculates partial availability of registers.  The\n+   function calculates partial availability at the end of basic block\n+   BB by propagating partial availability at end of predecessor basic\n+   block PRED.  The function returns true if the partial availability\n+   at the end of BB has been changed or if CHANGED_P.  We have the\n+   following equations:\n+\n+     bb.pavin = empty for entry block | union (pavout of predecessors)\n+     bb.pavout = union (bb.pavin - b.killed, bb.avloc)  */\n+\n+static bool\n+modify_bb_reg_pav (basic_block bb, basic_block pred, bool changed_p)\n+{\n+  struct bb_info *bb_info;\n+  bitmap bb_pavin, bb_pavout;\n+\n+  bb_info = BB_INFO (bb);\n+  bb_pavin = bb_info->pavin;\n+  bb_pavout = bb_info->pavout;\n+  if (pred->index != ENTRY_BLOCK)\n+    bitmap_a_or_b (bb_pavin, bb_pavin, BB_INFO (pred)->pavout);\n+  changed_p |= bitmap_union_of_diff (bb_pavout, bb_info->avloc,\n+\t\t\t\t     bb_pavin, bb_info->killed);\n+  return changed_p;\n+}\n+\n+/* The function calculates partial register availability.  */\n+\n+static void\n+calculate_reg_pav (void)\n+{\n+  basic_block bb, succ;\n+  edge e;\n+  bool changed_p;\n+  int i, nel;\n+  varray_type bbs, new_bbs, temp;\n+  basic_block *bb_array;\n+  sbitmap wset;\n+\n+  VARRAY_BB_INIT (bbs, n_basic_blocks, \"basic blocks\");\n+  VARRAY_BB_INIT (new_bbs, n_basic_blocks, \"basic blocks for the next iter.\");\n+  FOR_EACH_BB (bb)\n+    {\n+      VARRAY_PUSH_BB (bbs, bb);\n+    }\n+  wset = sbitmap_alloc (n_basic_blocks + 1);\n+  while (VARRAY_ACTIVE_SIZE (bbs))\n+    {\n+      bb_array = &VARRAY_BB (bbs, 0);\n+      nel = VARRAY_ACTIVE_SIZE (bbs);\n+      qsort (bb_array, nel, sizeof (basic_block), rpost_cmp);\n+      sbitmap_zero (wset);\n+      for (i = 0; i < nel; i++)\n+\t{\n+\t  bb = bb_array [i];\n+\t  changed_p = 0;\n+\t  for (e = bb->pred; e; e = e->pred_next)\n+\t    changed_p = modify_bb_reg_pav (bb, e->src, changed_p);\n+\t  if (changed_p)\n+\t    for (e = bb->succ; e; e = e->succ_next)\n+\t      {\n+\t\tsucc = e->dest;\n+\t\tif (succ->index != EXIT_BLOCK && !TEST_BIT (wset, succ->index))\n+\t\t  {\n+\t\t    SET_BIT (wset, succ->index);\n+\t\t    VARRAY_PUSH_BB (new_bbs, succ);\n+\t\t  }\n+\t      }\n+\t}\n+      temp = bbs;\n+      bbs = new_bbs;\n+      new_bbs = temp;\n+      VARRAY_POP_ALL (new_bbs);\n+    }\n+  sbitmap_free (wset);\n+}\n+\n+/* The following function makes live information more accurate by\n+   modifying global_live_at_start and global_live_at_end of basic\n+   blocks.  After the function call a register lives at a program\n+   point only if it is initialized on a path from CFG entry to the\n+   program point.  The standard GCC life analysis permits registers to\n+   live uninitialized. */\n+\n+static void\n+make_accurate_live_analysis (void)\n+{\n+  basic_block bb;\n+  struct bb_info *bb_info;\n+\n+  max_regno = max_reg_num ();\n+  compact_blocks ();\n+  allocate_bb_info ();\n+  calculate_local_reg_bb_info ();\n+  set_up_bb_rts_numbers ();\n+  calculate_reg_pav ();\n+  FOR_EACH_BB (bb)\n+    {\n+      bb_info = BB_INFO (bb);\n+      \n+      bitmap_a_and_b (bb->global_live_at_start, bb->global_live_at_start,\n+\t\t      bb_info->pavin);\n+      bitmap_a_and_b (bb->global_live_at_end, bb->global_live_at_end,\n+\t\t      bb_info->pavout);\n+    }\n+  free_bb_info ();\n+}"}]}