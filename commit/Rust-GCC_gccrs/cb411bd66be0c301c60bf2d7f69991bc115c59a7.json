{"sha": "cb411bd66be0c301c60bf2d7f69991bc115c59a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I0MTFiZDY2YmUwYzMwMWM2MGJmMmQ3ZjY5OTkxYmMxMTVjNTlhNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-26T03:49:17Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-26T03:49:17Z"}, "message": "Add prototypes for most functions declared here.\n\nFrom-SVN: r3536", "tree": {"sha": "9721027d208061a8917edb5bf432ecaa50649409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9721027d208061a8917edb5bf432ecaa50649409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb411bd66be0c301c60bf2d7f69991bc115c59a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb411bd66be0c301c60bf2d7f69991bc115c59a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb411bd66be0c301c60bf2d7f69991bc115c59a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb411bd66be0c301c60bf2d7f69991bc115c59a7/comments", "author": null, "committer": null, "parents": [{"sha": "de0e881806f526b91a09344c7ea68f242339e4e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0e881806f526b91a09344c7ea68f242339e4e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de0e881806f526b91a09344c7ea68f242339e4e9"}], "stats": {"total": 218, "additions": 131, "deletions": 87}, "files": [{"sha": "eb24683abcbebd5b9fd7e462f32953c47436b4d5", "filename": "gcc/expr.h", "status": "modified", "additions": 131, "deletions": 87, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb411bd66be0c301c60bf2d7f69991bc115c59a7/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb411bd66be0c301c60bf2d7f69991bc115c59a7/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=cb411bd66be0c301c60bf2d7f69991bc115c59a7", "patch": "@@ -447,76 +447,74 @@ extern rtxfun bcc_gen_fctn[NUM_RTX_CODE];\n extern enum insn_code setcc_gen_code[NUM_RTX_CODE];\n \n /* Expand a binary operation given optab and rtx operands.  */\n-extern rtx expand_binop ();\n+extern rtx expand_binop PROTO((enum machine_mode, optab, rtx, rtx, rtx, int, enum optab_methods));\n \n /* Expand a binary operation with both signed and unsigned forms.  */\n-extern rtx sign_expand_binop ();\n+extern rtx sign_expand_binop PROTO((enum machine_mode, optab, optab, rtx, rtx, rtx, int, enum optab_methods));\n \n /* Expand a unary arithmetic operation given optab rtx operand.  */\n-extern rtx expand_unop ();\n+extern rtx expand_unop PROTO((enum machine_mode, optab, rtx, rtx, int));\n \n /* Expand the complex absolute value operation.  */\n-extern rtx expand_complex_abs ();\n+extern rtx expand_complex_abs PROTO((enum machine_mode, rtx, rtx, int));\n \n /* Arguments MODE, RTX: return an rtx for the negation of that value.\n    May emit insns.  */\n-extern rtx negate_rtx ();\n+extern rtx negate_rtx PROTO((enum machine_mode, rtx));\n \n /* Expand a logical AND operation.  */\n-extern rtx expand_and ();\n+extern rtx expand_and PROTO((rtx, rtx, rtx));\n \n /* Emit a store-flag operation.  */\n-extern rtx emit_store_flag ();\n+extern rtx emit_store_flag PROTO((rtx, enum rtx_code, rtx, rtx, enum machine_mode, int, int));\n \n-/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n-extern rtx label_rtx ();\n \n /* Given a JUMP_INSN, return a description of the test being made.  */\n-extern rtx get_condition ();\n+extern rtx get_condition PROTO((rtx, rtx *));\n \n /* Return the INSN_CODE to use for an extend operation.  */\n-extern enum insn_code can_extend_p ();\n+extern enum insn_code can_extend_p PROTO((enum machine_mode, enum machine_mode, int));\n \n /* Initialize the tables that control conversion between fixed and\n    floating values.  */\n-extern void init_fixtab ();\n-extern void init_floattab ();\n+extern void init_fixtab PROTO((void));\n+extern void init_floattab PROTO((void));\n \n /* Generate code for a FIX_EXPR.  */\n-extern void expand_fix ();\n+extern void expand_fix PROTO((rtx, rtx, int));\n \n /* Generate code for a FLOAT_EXPR.  */\n-extern void expand_float ();\n+extern void expand_float PROTO((rtx, rtx, int));\n \n /* Create but don't emit one rtl instruction to add one rtx into another.\n    Modes must match; operands must meet the operation's predicates.\n    Likewise for subtraction and for just copying.\n    These do not call protect_from_queue; caller must do so.  */\n-extern rtx gen_add2_insn ();\n-extern rtx gen_sub2_insn ();\n-extern rtx gen_move_insn ();\n+extern rtx gen_add2_insn PROTO((rtx, rtx));\n+extern rtx gen_sub2_insn PROTO((rtx, rtx));\n+extern rtx gen_move_insn PROTO((rtx, rtx));\n \n /* Emit one rtl instruction to store zero in specified rtx.  */\n-extern void emit_clr_insn ();\n+extern void emit_clr_insn PROTO((rtx));\n \n /* Emit one rtl insn to store 1 in specified rtx assuming it contains 0.  */\n-extern void emit_0_to_1_insn ();\n+extern void emit_0_to_1_insn PROTO((rtx));\n \n /* Emit one rtl insn to compare two rtx's.  */\n-extern void emit_cmp_insn ();\n-\n-/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n-extern rtx compare_from_rtx ();\n+extern void emit_cmp_insn PROTO((rtx, rtx, enum rtx_code, rtx, enum machine_mode, int, int));\n \n /* Emit insns to set X from Y, with no frills.  */\n-extern rtx emit_move_insn_1 ();\n+extern rtx emit_move_insn_1 PROTO ((rtx, rtx));\n+\n+/* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n+extern rtx compare_from_rtx PROTO((rtx, rtx, enum rtx_code, int, enum machine_mode, rtx, int));\n \n /* Emit some rtl insns to move data between rtx's, converting machine modes.\n    Both modes must be floating or both fixed.  */\n-extern void convert_move ();\n+extern void convert_move PROTO((rtx, rtx, int));\n \n /* Convert an rtx to specified machine mode and return the result.  */\n-extern rtx convert_to_mode ();\n+extern rtx convert_to_mode PROTO((enum machine_mode, rtx, int));\n \n /* Emit code to push some arguments and call a library routine,\n    storing the value in a specified place.  Calling sequence is\n@@ -526,154 +524,200 @@ extern void emit_library_call ();\n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value.\n    Useful after calling expand_expr with 1 as sum_ok.  */\n-extern rtx force_operand ();\n+extern rtx force_operand PROTO((rtx, rtx));\n \n+#ifdef TREE_CODE\n+/* rtl.h and tree.h were included.  */\n+/* Return an rtx for the size in bytes of the value of an expr.  */\n+extern rtx expr_size PROTO((tree));\n+\n+extern rtx lookup_static_chain PROTO((tree));\n+\n+/* Convert a stack slot address ADDR valid in function FNDECL\n+   into an address valid in this function (using a static chain).  */\n+extern rtx fix_lexical_addr PROTO((rtx, tree));\n+\n+/* Return the address of the trampoline for entering nested fn FUNCTION.  */\n+extern rtx trampoline_address PROTO((tree));\n+\n+/* Return an rtx that refers to the value returned by a function\n+   in its original home.  This becomes invalid if any more code is emitted.  */\n+extern rtx hard_function_value PROTO((tree, tree));\n+\n+/* Generate code for computing expression EXP,\n+   and storing the value into TARGET.\n+   If SUGGEST_REG is nonzero, copy the value through a register\n+   and return that register, if that is possible.  */\n+extern rtx store_expr PROTO((tree, rtx, int));\n+\n+extern rtx prepare_call_address PROTO((rtx, tree, rtx*));\n+\n+extern rtx expand_call PROTO((tree, rtx, int));\n+extern void emit_call_1 PROTO((rtx, tree, int, int, rtx, rtx, int, rtx, int));\n+\n+extern void emit_push_insn PROTO((rtx, enum machine_mode, tree, rtx, int, int, rtx, int, rtx, rtx));\n+extern rtx expand_shift PROTO((enum tree_code, enum machine_mode, rtx, tree, rtx, int));\n+extern rtx expand_divmod PROTO((int, enum tree_code, enum machine_mode, rtx, rtx, rtx, int));\n+extern void jumpif PROTO((tree, rtx));\n+extern void do_jump PROTO((tree, rtx, rtx));\n+extern void locate_and_pad_parm PROTO((enum machine_mode, tree, int, tree, struct args_size *, struct args_size *, struct args_size *));\n+extern rtx expand_inline_function PROTO((tree, tree, rtx, int, tree, rtx));\n+/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n+extern rtx label_rtx PROTO((tree));\n+#else\n /* Return an rtx for the size in bytes of the value of an expr.  */\n extern rtx expr_size ();\n \n extern rtx lookup_static_chain ();\n \n+/* Convert a stack slot address ADDR valid in function FNDECL\n+   into an address valid in this function (using a static chain).  */\n+extern rtx fix_lexical_addr ();\n+\n+/* Return the address of the trampoline for entering nested fn FUNCTION.  */\n+extern rtx trampoline_address ();\n+\n+/* Return an rtx that refers to the value returned by a function\n+   in its original home.  This becomes invalid if any more code is emitted.  */\n+extern rtx hard_function_value ();\n+\n+/* Generate code for computing expression EXP,\n+   and storing the value into TARGET.\n+   If SUGGEST_REG is nonzero, copy the value through a register\n+   and return that register, if that is possible.  */\n+extern rtx store_expr ();\n+\n+extern rtx prepare_call_address ();\n+extern rtx expand_call ();\n+extern void emit_call_1 ();\n+extern void emit_push_insn ();\n+extern rtx expand_shift ();\n+extern rtx expand_divmod ();\n+extern void jumpif ();\n+extern void do_jump ();\n+extern void locate_and_pad_parm ();\n+extern rtx expand_inline_function ();\n+\n+/* Return the CODE_LABEL rtx for a LABEL_DECL, creating it if necessary.  */\n+extern rtx label_rtx ();\n+#endif\n+\n+\n /* Indicate how an input argument register was promoted.  */\n extern rtx promoted_input_arg ();\n \n /* Return an rtx like arg but sans any constant terms.\n    Returns the original rtx if it has no constant terms.\n    The constant terms are added and stored via a second arg.  */\n-extern rtx eliminate_constant_term ();\n+extern rtx eliminate_constant_term PROTO((rtx, rtx *));\n \n /* Convert arg to a valid memory address for specified machine mode,\n    by emitting insns to perform arithmetic if nec.  */\n-extern rtx memory_address ();\n+extern rtx memory_address PROTO((enum machine_mode, rtx));\n \n /* Like `memory_address' but pretent `flag_force_addr' is 0.  */\n-extern rtx memory_address_noforce ();\n+extern rtx memory_address_noforce PROTO((enum machine_mode, rtx));\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n    NULL for ADDR means don't change the address.)  */\n-extern rtx change_address ();\n+extern rtx change_address PROTO((rtx, enum machine_mode, rtx));\n \n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n \n-extern rtx validize_mem ();\n+extern rtx validize_mem PROTO((rtx));\n \n /* Convert a stack slot address ADDR valid in function FNDECL\n    into an address valid in this function (using a static chain).  */\n extern rtx fix_lexical_addr ();\n \n-/* Return the address of the trampoline for entering nested fn FUNCTION.  */\n-extern rtx trampoline_address ();\n-\n /* Assemble the static constant template for function entry trampolines.  */\n-extern rtx assemble_trampoline_template ();\n+extern rtx assemble_trampoline_template PROTO((void));\n \n /* Return 1 if two rtx's are equivalent in structure and elements.  */\n-extern int rtx_equal_p ();\n+extern int rtx_equal_p PROTO((rtx, rtx));\n \n /* Given rtx, return new rtx whose address won't be affected by\n    any side effects.  It has been copied to a new temporary reg.  */\n-extern rtx stabilize ();\n+extern rtx stabilize PROTO((rtx));\n \n /* Given an rtx, copy all regs it refers to into new temps\n    and return a modified copy that refers to the new temps.  */\n-extern rtx copy_all_regs ();\n+extern rtx copy_all_regs PROTO((rtx));\n \n /* Copy given rtx to a new temp reg and return that.  */\n-extern rtx copy_to_reg ();\n+extern rtx copy_to_reg PROTO((rtx));\n \n /* Like copy_to_reg but always make the reg Pmode.  */\n-extern rtx copy_addr_to_reg ();\n+extern rtx copy_addr_to_reg PROTO((rtx));\n \n /* Like copy_to_reg but always make the reg the specified mode MODE.  */\n-extern rtx copy_to_mode_reg ();\n+extern rtx copy_to_mode_reg PROTO((enum machine_mode, rtx));\n \n /* Copy given rtx to given temp reg and return that.  */\n-extern rtx copy_to_suggested_reg ();\n+extern rtx copy_to_suggested_reg PROTO((rtx, rtx, enum machine_mode));\n \n /* Copy a value to a register if it isn't already a register.\n    Args are mode (in case value is a constant) and the value.  */\n-extern rtx force_reg ();\n+extern rtx force_reg PROTO((enum machine_mode, rtx));\n \n /* Return given rtx, copied into a new temp reg if it was in memory.  */\n-extern rtx force_not_mem ();\n+extern rtx force_not_mem PROTO((rtx));\n \n /* Remove some bytes from the stack.  An rtx says how many.  */\n-extern void adjust_stack ();\n+extern void adjust_stack PROTO((rtx));\n \n /* Add some bytes to the stack.  An rtx says how many.  */\n-extern void anti_adjust_stack ();\n+extern void anti_adjust_stack PROTO((rtx));\n \n /* This enum is used for the following two functions.  */\n enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n \n /* Save the stack pointer at the specified level.  */\n-extern void emit_stack_save ();\n+extern void emit_stack_save PROTO((enum save_level, rtx *, rtx));\n \n /* Restore the stack pointer from a save area of the specified level.  */\n-extern void emit_stack_restore ();\n+extern void emit_stack_restore PROTO((enum save_level, rtx, rtx));\n \n /* Allocate some space on the stack dynamically and return its address.  An rtx\n    says how many bytes.  */\n-extern rtx allocate_dynamic_stack_space ();\n+extern rtx allocate_dynamic_stack_space PROTO((rtx, rtx, int));\n \n /* Emit code to copy function value to a new temp reg and return that reg.  */\n extern rtx function_value ();\n \n-/* Return an rtx that refers to the value returned by a function\n-   in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_function_value ();\n-\n /* Return an rtx that refers to the value returned by a library call\n    in its original home.  This becomes invalid if any more code is emitted.  */\n-extern rtx hard_libcall_value ();\n+extern rtx hard_libcall_value PROTO((enum machine_mode));\n \n /* Emit code to copy function value to a specified place.  */\n extern void copy_function_value ();\n \n /* Given an rtx, return an rtx for a value rounded up to a multiple\n    of STACK_BOUNDARY / BITS_PER_UNIT.  */\n-extern rtx round_push ();\n+extern rtx round_push PROTO((rtx));\n \n /* Push a block of length SIZE (perhaps variable)\n    and return an rtx to address the beginning of the block.  */\n-extern rtx push_block ();\n+extern rtx push_block PROTO((rtx, int, int));\n \n-/* Generate code for computing expression EXP,\n-   and storing the value into TARGET.\n-   If SUGGEST_REG is nonzero, copy the value through a register\n-   and return that register, if that is possible.  */\n-extern rtx store_expr ();\n-\n-extern rtx prepare_call_address ();\n-extern rtx expand_call ();\n-extern void emit_call_1 ();\n+extern void emit_block_move PROTO((rtx, rtx, rtx, int));\n+extern void use_regs PROTO((int, int));\n+extern void move_block_to_reg PROTO((int, rtx, int, enum machine_mode));\n \n-extern void emit_block_move ();\n-extern void emit_push_insn ();\n-extern void use_regs ();\n-extern void move_block_to_reg ();\n-\n-extern rtx store_bit_field ();\n-extern rtx extract_bit_field ();\n-extern rtx expand_shift ();\n-extern rtx expand_mult ();\n-extern rtx expand_divmod ();\n-extern rtx expand_mult_add ();\n+extern rtx store_bit_field PROTO((rtx, int, int, enum machine_mode, rtx, int, int));\n+extern rtx extract_bit_field PROTO((rtx, int, int, int, rtx, enum machine_mode, enum machine_mode, int, int));\n+extern rtx expand_mult PROTO((enum machine_mode, rtx, rtx, rtx, int));\n+extern rtx expand_mult_add PROTO((rtx, rtx, rtx, rtx,enum machine_mode, int));\n extern rtx expand_stmt_expr ();\n-extern rtx emit_no_conflict_block ();\n-extern void emit_libcall_block ();\n+extern rtx emit_no_conflict_block PROTO((rtx, rtx, rtx, rtx, rtx));\n+extern void emit_libcall_block PROTO((rtx, rtx, rtx, rtx));\n \n extern void jumpifnot ();\n-extern void jumpif ();\n-extern void do_jump ();\n-\n-extern rtx assemble_static_space ();\n \n-extern void locate_and_pad_parm ();\n-\n-extern rtx expand_inline_function ();\n+extern rtx assemble_static_space PROTO((int));\n \n /* Hook called by expand_expr for language-specific tree codes.\n    It is up to the language front end to install a hook"}]}