{"sha": "9005477f2552a411974c12299f627f80473e17d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAwNTQ3N2YyNTUyYTQxMTk3NGMxMjI5OWY2MjdmODA0NzNlMTdkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-13T18:00:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-13T18:00:59Z"}, "message": "Rework the legitimize_address_displacement hook\n\nThis patch:\n\n- tweaks the handling of legitimize_address_displacement\n  so that it gets called before rather than after the address has\n  been expanded.  This means that we're no longer at the mercy\n  of LRA being able to interpret the expanded instructions.\n\n- passes the original offset to legitimize_address_displacement.\n\n- adds SVE support to the AArch64 implementation of\n  legitimize_address_displacement.\n\n2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (legitimize_address_displacement): Take the original\n\toffset as a poly_int.\n\t* targhooks.h (default_legitimize_address_displacement): Update\n\taccordingly.\n\t* targhooks.c (default_legitimize_address_displacement): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* lra-constraints.c (base_plus_disp_to_reg): Take the displacement\n\tas an argument, moving assert of ad->disp == ad->disp_term to...\n\t(process_address_1): ...here.  Update calls to base_plus_disp_to_reg.\n\tTry calling targetm.legitimize_address_displacement before expanding\n\tthe address rather than afterwards, and adjust for the new interface.\n\t* config/aarch64/aarch64.c (aarch64_legitimize_address_displacement):\n\tMatch the new hook interface.  Handle SVE addresses.\n\t* config/sh/sh.c (sh_legitimize_address_displacement): Make the\n\tnew hook interface.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256637", "tree": {"sha": "923ea4cad9f4eac45c16ec2f88e594968f305011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/923ea4cad9f4eac45c16ec2f88e594968f305011"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9005477f2552a411974c12299f627f80473e17d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9005477f2552a411974c12299f627f80473e17d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9005477f2552a411974c12299f627f80473e17d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9005477f2552a411974c12299f627f80473e17d9/comments", "author": null, "committer": null, "parents": [{"sha": "5cce817119cd31d18fbfc1c8245519d86b5e9480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cce817119cd31d18fbfc1c8245519d86b5e9480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cce817119cd31d18fbfc1c8245519d86b5e9480"}], "stats": {"total": 210, "additions": 138, "deletions": 72}, "files": [{"sha": "d855951151a5d7082306a47ece8d21ba6c15b6b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -1,3 +1,23 @@\n+2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (legitimize_address_displacement): Take the original\n+\toffset as a poly_int.\n+\t* targhooks.h (default_legitimize_address_displacement): Update\n+\taccordingly.\n+\t* targhooks.c (default_legitimize_address_displacement): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* lra-constraints.c (base_plus_disp_to_reg): Take the displacement\n+\tas an argument, moving assert of ad->disp == ad->disp_term to...\n+\t(process_address_1): ...here.  Update calls to base_plus_disp_to_reg.\n+\tTry calling targetm.legitimize_address_displacement before expanding\n+\tthe address rather than afterwards, and adjust for the new interface.\n+\t* config/aarch64/aarch64.c (aarch64_legitimize_address_displacement):\n+\tMatch the new hook interface.  Handle SVE addresses.\n+\t* config/sh/sh.c (sh_legitimize_address_displacement): Make the\n+\tnew hook interface.\n+\n 2018-01-13  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* Makefile.in (OBJS): Add early-remat.o."}, {"sha": "2e70f3a2237aeed33560da0d0f38fe5634620517", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -5820,32 +5820,78 @@ aarch64_legitimate_address_p (machine_mode mode, rtx x, bool strict_p,\n   return aarch64_classify_address (&addr, x, mode, strict_p, type);\n }\n \n-/* Split an out-of-range address displacement into a base and offset.\n-   Use 4KB range for 1- and 2-byte accesses and a 16KB range otherwise\n-   to increase opportunities for sharing the base address of different sizes.\n-   Unaligned accesses use the signed 9-bit range, TImode/TFmode use\n-   the intersection of signed scaled 7-bit and signed 9-bit offset.  */\n+/* Implement TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT.  */\n+\n static bool\n-aarch64_legitimize_address_displacement (rtx *disp, rtx *off, machine_mode mode)\n+aarch64_legitimize_address_displacement (rtx *offset1, rtx *offset2,\n+\t\t\t\t\t poly_int64 orig_offset,\n+\t\t\t\t\t machine_mode mode)\n {\n   HOST_WIDE_INT size;\n   if (GET_MODE_SIZE (mode).is_constant (&size))\n     {\n-      HOST_WIDE_INT offset = INTVAL (*disp);\n-      HOST_WIDE_INT base;\n+      HOST_WIDE_INT const_offset, second_offset;\n+\n+      /* A general SVE offset is A * VQ + B.  Remove the A component from\n+\t coefficient 0 in order to get the constant B.  */\n+      const_offset = orig_offset.coeffs[0] - orig_offset.coeffs[1];\n \n+      /* Split an out-of-range address displacement into a base and\n+\t offset.  Use 4KB range for 1- and 2-byte accesses and a 16KB\n+\t range otherwise to increase opportunities for sharing the base\n+\t address of different sizes.  Unaligned accesses use the signed\n+\t 9-bit range, TImode/TFmode use the intersection of signed\n+\t scaled 7-bit and signed 9-bit offset.  */\n       if (mode == TImode || mode == TFmode)\n-\tbase = (offset + 0x100) & ~0x1f8;\n-      else if ((offset & (size - 1)) != 0)\n-\tbase = (offset + 0x100) & ~0x1ff;\n+\tsecond_offset = ((const_offset + 0x100) & 0x1f8) - 0x100;\n+      else if ((const_offset & (size - 1)) != 0)\n+\tsecond_offset = ((const_offset + 0x100) & 0x1ff) - 0x100;\n       else\n-\tbase = offset & ~(size < 4 ? 0xfff : 0x3ffc);\n+\tsecond_offset = const_offset & (size < 4 ? 0xfff : 0x3ffc);\n \n-      *off = GEN_INT (base);\n-      *disp = GEN_INT (offset - base);\n+      if (second_offset == 0 || known_eq (orig_offset, second_offset))\n+\treturn false;\n+\n+      /* Split the offset into second_offset and the rest.  */\n+      *offset1 = gen_int_mode (orig_offset - second_offset, Pmode);\n+      *offset2 = gen_int_mode (second_offset, Pmode);\n+      return true;\n+    }\n+  else\n+    {\n+      /* Get the mode we should use as the basis of the range.  For structure\n+\t modes this is the mode of one vector.  */\n+      unsigned int vec_flags = aarch64_classify_vector_mode (mode);\n+      machine_mode step_mode\n+\t= (vec_flags & VEC_STRUCT) != 0 ? SVE_BYTE_MODE : mode;\n+\n+      /* Get the \"mul vl\" multiplier we'd like to use.  */\n+      HOST_WIDE_INT factor = GET_MODE_SIZE (step_mode).coeffs[1];\n+      HOST_WIDE_INT vnum = orig_offset.coeffs[1] / factor;\n+      if (vec_flags & VEC_SVE_DATA)\n+\t/* LDR supports a 9-bit range, but the move patterns for\n+\t   structure modes require all vectors to be in range of the\n+\t   same base.  The simplest way of accomodating that while still\n+\t   promoting reuse of anchor points between different modes is\n+\t   to use an 8-bit range unconditionally.  */\n+\tvnum = ((vnum + 128) & 255) - 128;\n+      else\n+\t/* Predicates are only handled singly, so we might as well use\n+\t   the full range.  */\n+\tvnum = ((vnum + 256) & 511) - 256;\n+      if (vnum == 0)\n+\treturn false;\n+\n+      /* Convert the \"mul vl\" multiplier into a byte offset.  */\n+      poly_int64 second_offset = GET_MODE_SIZE (step_mode) * vnum;\n+      if (known_eq (second_offset, orig_offset))\n+\treturn false;\n+\n+      /* Split the offset into second_offset and the rest.  */\n+      *offset1 = gen_int_mode (orig_offset - second_offset, Pmode);\n+      *offset2 = gen_int_mode (second_offset, Pmode);\n       return true;\n     }\n-  return false;\n }\n \n /* Return the binary representation of floating point constant VALUE in INTVAL."}, {"sha": "48e99a3cadf1d5cf2dbc47f2bd633fbd3d5b6af8", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -269,7 +269,8 @@ static bool sh_legitimate_address_p (machine_mode, rtx, bool);\n static rtx sh_legitimize_address (rtx, rtx, machine_mode);\n static rtx sh_delegitimize_address (rtx);\n static bool sh_cannot_substitute_mem_equiv_p (rtx);\n-static bool sh_legitimize_address_displacement (rtx *, rtx *, machine_mode);\n+static bool sh_legitimize_address_displacement (rtx *, rtx *,\n+\t\t\t\t\t\tpoly_int64, machine_mode);\n static int scavenge_reg (HARD_REG_SET *s);\n \n static rtx sh_struct_value_rtx (tree, int);\n@@ -11395,20 +11396,21 @@ sh_cannot_substitute_mem_equiv_p (rtx)\n   return true;\n }\n \n-/* Return true if DISP can be legitimized.  */\n+/* Implement TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT.  */\n static bool\n-sh_legitimize_address_displacement (rtx *disp, rtx *offs,\n+sh_legitimize_address_displacement (rtx *offset1, rtx *offset2,\n+\t\t\t\t    poly_int64 orig_offset,\n \t\t\t\t    machine_mode mode)\n {\n   if ((TARGET_FPU_DOUBLE && mode == DFmode)\n       || (TARGET_SH2E && mode == SFmode))\n     return false;\n \n-  struct disp_adjust adj = sh_find_mov_disp_adjust (mode, INTVAL (*disp));\n+  struct disp_adjust adj = sh_find_mov_disp_adjust (mode, orig_offset);\n   if (adj.offset_adjust != NULL_RTX && adj.mov_disp != NULL_RTX)\n     {\n-      *disp = adj.mov_disp;\n-      *offs = adj.offset_adjust;\n+      *offset1 = adj.offset_adjust;\n+      *offset2 = adj.mov_disp;\n       return true;\n     }\n  "}, {"sha": "7f02b0d17087ab4cdb34380612ca600fe15874dd", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -2894,13 +2894,16 @@ machines with non orthogonal register usage for addressing, such\n as SH, this hook can be used to avoid excessive spilling.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT (rtx *@var{disp}, rtx *@var{offset}, machine_mode @var{mode})\n-A target hook which returns @code{true} if *@var{disp} is\n-legitimezed to valid address displacement with subtracting *@var{offset}\n-at memory mode @var{mode}.\n-The default version of this target hook returns @code{false}.\n-This hook will benefit machines with limited base plus displacement\n-addressing.\n+@deftypefn {Target Hook} bool TARGET_LEGITIMIZE_ADDRESS_DISPLACEMENT (rtx *@var{offset1}, rtx *@var{offset2}, poly_int64 @var{orig_offset}, machine_mode @var{mode})\n+This hook tries to split address offset @var{orig_offset} into\n+two parts: one that should be added to the base address to create\n+a local anchor point, and an additional offset that can be applied\n+to the anchor to address a value of mode @var{mode}.  The idea is that\n+the local anchor could be shared by other accesses to nearby locations.\n+\n+The hook returns true if it succeeds, storing the offset of the\n+anchor from the base in @var{offset1} and the offset of the final address\n+from the anchor in @var{offset2}.  The default implementation returns false.\n @end deftypefn\n \n @deftypefn {Target Hook} reg_class_t TARGET_SPILL_CLASS (reg_class_t, @var{machine_mode})"}, {"sha": "97a71030775640227033e17a5278e42bd54ecbf9", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -3058,19 +3058,19 @@ base_to_reg (struct address_info *ad)\n   return new_inner;\n }\n \n-/* Make reload base reg + disp from address AD.  Return the new pseudo.  */\n+/* Make reload base reg + DISP from address AD.  Return the new pseudo.  */\n static rtx\n-base_plus_disp_to_reg (struct address_info *ad)\n+base_plus_disp_to_reg (struct address_info *ad, rtx disp)\n {\n   enum reg_class cl;\n   rtx new_reg;\n \n-  lra_assert (ad->base == ad->base_term && ad->disp == ad->disp_term);\n+  lra_assert (ad->base == ad->base_term);\n   cl = base_reg_class (ad->mode, ad->as, ad->base_outer_code,\n \t\t       get_index_code (ad));\n   new_reg = lra_create_new_reg (GET_MODE (*ad->base_term), NULL_RTX,\n \t\t\t\tcl, \"base + disp\");\n-  lra_emit_add (new_reg, *ad->base_term, *ad->disp_term);\n+  lra_emit_add (new_reg, *ad->base_term, disp);\n   return new_reg;\n }\n \n@@ -3421,12 +3421,30 @@ process_address_1 (int nop, bool check_only_p,\n \t displacements, so reloading into an index register would\n \t not necessarily be a win.  */\n       if (new_reg == NULL_RTX)\n-        new_reg = base_plus_disp_to_reg (&ad);\n+\t{\n+\t  /* See if the target can split the displacement into a\n+\t     legitimate new displacement from a local anchor.  */\n+\t  gcc_assert (ad.disp == ad.disp_term);\n+\t  poly_int64 orig_offset;\n+\t  rtx offset1, offset2;\n+\t  if (poly_int_rtx_p (*ad.disp, &orig_offset)\n+\t      && targetm.legitimize_address_displacement (&offset1, &offset2,\n+\t\t\t\t\t\t\t  orig_offset,\n+\t\t\t\t\t\t\t  ad.mode))\n+\t    {\n+\t      new_reg = base_plus_disp_to_reg (&ad, offset1);\n+\t      new_reg = gen_rtx_PLUS (GET_MODE (new_reg), new_reg, offset2);\n+\t    }\n+\t  else\n+\t    new_reg = base_plus_disp_to_reg (&ad, *ad.disp);\n+\t}\n       insns = get_insns ();\n       last_insn = get_last_insn ();\n       /* If we generated at least two insns, try last insn source as\n \t an address.  If we succeed, we generate one less insn.  */\n-      if (last_insn != insns && (set = single_set (last_insn)) != NULL_RTX\n+      if (REG_P (new_reg)\n+\t  && last_insn != insns\n+\t  && (set = single_set (last_insn)) != NULL_RTX\n \t  && GET_CODE (SET_SRC (set)) == PLUS\n \t  && REG_P (XEXP (SET_SRC (set), 0))\n \t  && CONSTANT_P (XEXP (SET_SRC (set), 1)))\n@@ -3446,32 +3464,6 @@ process_address_1 (int nop, bool check_only_p,\n \t      delete_insns_since (PREV_INSN (last_insn));\n \t    }\n \t}\n-      /* Try if target can split displacement into legitimite new disp\n-\t and offset.  If it's the case, we replace the last insn with\n-\t insns for base + offset => new_reg and set new_reg + new disp\n-\t to *ad.inner.  */\n-      last_insn = get_last_insn ();\n-      if ((set = single_set (last_insn)) != NULL_RTX\n-\t  && GET_CODE (SET_SRC (set)) == PLUS\n-\t  && REG_P (XEXP (SET_SRC (set), 0))\n-\t  && REGNO (XEXP (SET_SRC (set), 0)) < FIRST_PSEUDO_REGISTER\n-\t  && CONST_INT_P (XEXP (SET_SRC (set), 1)))\n-\t{\n-\t  rtx addend, disp = XEXP (SET_SRC (set), 1);\n-\t  if (targetm.legitimize_address_displacement (&disp, &addend,\n-\t\t\t\t\t\t       ad.mode))\n-\t    {\n-\t      rtx_insn *new_insns;\n-\t      start_sequence ();\n-\t      lra_emit_add (new_reg, XEXP (SET_SRC (set), 0), addend);\n-\t      new_insns = get_insns ();\n-\t      end_sequence ();\n-\t      new_reg = gen_rtx_PLUS (Pmode, new_reg, disp);\n-\t      delete_insns_since (PREV_INSN (last_insn));\n-\t      add_insn (new_insns);\n-\t      insns = get_insns ();\n-\t    }\n-\t}\n       end_sequence ();\n       emit_insn (insns);\n       *ad.inner = new_reg;\n@@ -3480,7 +3472,8 @@ process_address_1 (int nop, bool check_only_p,\n     {\n       /* base + scale * index + disp => new base + scale * index,\n \t case (1) above.  */\n-      new_reg = base_plus_disp_to_reg (&ad);\n+      gcc_assert (ad.disp == ad.disp_term);\n+      new_reg = base_plus_disp_to_reg (&ad, *ad.disp);\n       *ad.inner = simplify_gen_binary (PLUS, GET_MODE (new_reg),\n \t\t\t\t       new_reg, *ad.index);\n     }"}, {"sha": "aeb41df1945460aa5d3ac53c322e9146875b5068", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -5657,13 +5657,16 @@ as SH, this hook can be used to avoid excessive spilling.\",\n    displacement addressing.  */\n DEFHOOK\n (legitimize_address_displacement,\n- \"A target hook which returns @code{true} if *@var{disp} is\\n\\\n-legitimezed to valid address displacement with subtracting *@var{offset}\\n\\\n-at memory mode @var{mode}.\\n\\\n-The default version of this target hook returns @code{false}.\\n\\\n-This hook will benefit machines with limited base plus displacement\\n\\\n-addressing.\",\n- bool, (rtx *disp, rtx *offset, machine_mode mode),\n+ \"This hook tries to split address offset @var{orig_offset} into\\n\\\n+two parts: one that should be added to the base address to create\\n\\\n+a local anchor point, and an additional offset that can be applied\\n\\\n+to the anchor to address a value of mode @var{mode}.  The idea is that\\n\\\n+the local anchor could be shared by other accesses to nearby locations.\\n\\\n+\\n\\\n+The hook returns true if it succeeds, storing the offset of the\\n\\\n+anchor from the base in @var{offset1} and the offset of the final address\\n\\\n+from the anchor in @var{offset2}.  The default implementation returns false.\",\n+ bool, (rtx *offset1, rtx *offset2, poly_int64 orig_offset, machine_mode mode),\n  default_legitimize_address_displacement)\n \n /* This target hook allows the backend to perform additional"}, {"sha": "fafcc6c5196640edea8b89e55ec16d28254eb323", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -171,9 +171,8 @@ default_legitimize_address (rtx x, rtx orig_x ATTRIBUTE_UNUSED,\n }\n \n bool\n-default_legitimize_address_displacement (rtx *disp ATTRIBUTE_UNUSED,\n-\t\t\t\t\t rtx *offset ATTRIBUTE_UNUSED,\n-\t\t\t\t\t machine_mode mode ATTRIBUTE_UNUSED)\n+default_legitimize_address_displacement (rtx *, rtx *, poly_int64,\n+\t\t\t\t\t machine_mode)\n {\n   return false;\n }"}, {"sha": "8a4393f2ba40b8de7bd4d70b34d01fbf2ecd3687", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9005477f2552a411974c12299f627f80473e17d9/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9005477f2552a411974c12299f627f80473e17d9/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=9005477f2552a411974c12299f627f80473e17d9", "patch": "@@ -25,7 +25,7 @@ extern bool default_legitimate_address_p (machine_mode, rtx, bool);\n extern void default_external_libcall (rtx);\n extern rtx default_legitimize_address (rtx, rtx, machine_mode);\n extern bool default_legitimize_address_displacement (rtx *, rtx *,\n-\t\t\t\t\t\t     machine_mode);\n+\t\t\t\t\t\t     poly_int64, machine_mode);\n extern bool default_const_not_ok_for_debug_p (rtx);\n \n extern int default_unspec_may_trap_p (const_rtx, unsigned);"}]}