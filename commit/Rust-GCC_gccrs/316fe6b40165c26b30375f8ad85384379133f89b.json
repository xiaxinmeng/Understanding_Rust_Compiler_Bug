{"sha": "316fe6b40165c26b30375f8ad85384379133f89b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE2ZmU2YjQwMTY1YzI2YjMwMzc1ZjhhZDg1Mzg0Mzc5MTMzZjg5Yg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-29T17:01:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-05-29T17:01:50Z"}, "message": "libgfortran: Export forgotten _gfortran_{,m,s}findloc{0,1}_c10 [PR95390]\n\nI have noticed we don't export these 6 symbols and thus the testcase\nbelow fails to link.\n\n2020-05-29  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libfortran/95390\n\t* gfortran.dg/findloc_8.f90: New test.\n\n\t* Makefile.am (i_findloc0_c): Add findloc0_i10.c.\n\t(i_findloc1_c): Add findloc1_i10.c.\n\t* gfortran.map (GFORTRAN_10.2): New symbol version, export\n\t_gfortran_{,m,s}findloc{0,1}_c10 symbols.\n\t* Makefile.in: Regenerated.\n\t* generated/findloc0_c10.c: Generated.\n\t* generated/findloc1_c10.c: Generated.", "tree": {"sha": "a3fa58aaccae1522834b6f52573366c5d440213f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3fa58aaccae1522834b6f52573366c5d440213f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/316fe6b40165c26b30375f8ad85384379133f89b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316fe6b40165c26b30375f8ad85384379133f89b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/316fe6b40165c26b30375f8ad85384379133f89b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/316fe6b40165c26b30375f8ad85384379133f89b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f32d5294f51614f5637d81c522fccacc124f141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f32d5294f51614f5637d81c522fccacc124f141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f32d5294f51614f5637d81c522fccacc124f141"}], "stats": {"total": 961, "additions": 959, "deletions": 2}, "files": [{"sha": "dffb36d61e5a3543dbf7791c68a623d903fd8072", "filename": "gcc/testsuite/gfortran.dg/findloc_8.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316fe6b40165c26b30375f8ad85384379133f89b/gcc%2Ftestsuite%2Fgfortran.dg%2Ffindloc_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316fe6b40165c26b30375f8ad85384379133f89b/gcc%2Ftestsuite%2Fgfortran.dg%2Ffindloc_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffindloc_8.f90?ref=316fe6b40165c26b30375f8ad85384379133f89b", "patch": "@@ -0,0 +1,29 @@\n+! PR libfortran/95390\n+! { dg-do run { target fortran_real_10 } }\n+\n+  complex(kind=10) :: a(6), b, d(2,2)\n+  logical :: m(6), n, o(2,2)\n+  integer :: c(1), e(2)\n+  a = (/ 1., 2., 17., 2., 2., 6. /)\n+  b = 17.\n+  c = findloc (a, b)\n+  if (c(1) /= 3) stop 1\n+  m = (/ .true., .false., .true., .true., .true., .true. /)\n+  n = .true.\n+  b = 2.\n+  c = findloc (a, b, m)\n+  if (c(1) /= 4) stop 2\n+  c = findloc (a, b, n)\n+  if (c(1) /= 2) stop 3\n+  d = reshape((/ 1., 2., 2., 3. /), (/ 2, 2 /))\n+  e = findloc (d, b, 1)\n+  if (e(1) /= 2 .or. e(2) /= 1) stop 4\n+  o = reshape((/ .true., .false., .true., .true. /), (/ 2, 2 /))\n+  e = findloc (d, b, 1, o)\n+  if (e(1) /= 0 .or. e(2) /= 1) stop 5\n+  e = findloc (d, b, 1, n)\n+  if (e(1) /= 2 .or. e(2) /= 1) stop 6\n+  n = .false.\n+  e = findloc (d, b, 1, n)\n+  if (e(1) /= 0 .or. e(2) /= 0) stop 7\n+end"}, {"sha": "a8a2191acc30cf108ef8ea15ab6f55b25fb0b2b6", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=316fe6b40165c26b30375f8ad85384379133f89b", "patch": "@@ -283,6 +283,7 @@ $(srcdir)/generated/findloc0_r10.c \\\n $(srcdir)/generated/findloc0_r16.c \\\n $(srcdir)/generated/findloc0_c4.c \\\n $(srcdir)/generated/findloc0_c8.c \\\n+$(srcdir)/generated/findloc0_c10.c \\\n $(srcdir)/generated/findloc0_c16.c\n \n i_findloc0s_c= \\\n@@ -301,6 +302,7 @@ $(srcdir)/generated/findloc1_r10.c \\\n $(srcdir)/generated/findloc1_r16.c \\\n $(srcdir)/generated/findloc1_c4.c \\\n $(srcdir)/generated/findloc1_c8.c \\\n+$(srcdir)/generated/findloc1_c10.c \\\n $(srcdir)/generated/findloc1_c16.c\n \n i_findloc1s_c= \\"}, {"sha": "312a682b45dce8f180f1c9ac55f98a96a02a6512", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=316fe6b40165c26b30375f8ad85384379133f89b", "patch": "@@ -373,12 +373,12 @@ am__objects_46 = minval1_s1.lo minval1_s4.lo\n am__objects_47 = findloc0_i1.lo findloc0_i2.lo findloc0_i4.lo \\\n \tfindloc0_i8.lo findloc0_i16.lo findloc0_r4.lo findloc0_r8.lo \\\n \tfindloc0_r10.lo findloc0_r16.lo findloc0_c4.lo findloc0_c8.lo \\\n-\tfindloc0_c16.lo\n+\tfindloc0_c10.lo findloc0_c16.lo\n am__objects_48 = findloc0_s1.lo findloc0_s4.lo\n am__objects_49 = findloc1_i1.lo findloc1_i2.lo findloc1_i4.lo \\\n \tfindloc1_i8.lo findloc1_i16.lo findloc1_r4.lo findloc1_r8.lo \\\n \tfindloc1_r10.lo findloc1_r16.lo findloc1_c4.lo findloc1_c8.lo \\\n-\tfindloc1_c16.lo\n+\tfindloc1_c10.lo findloc1_c16.lo\n am__objects_50 = findloc1_s1.lo findloc1_s4.lo\n am__objects_51 = findloc2_s1.lo findloc2_s4.lo\n am__objects_52 = ISO_Fortran_binding.lo\n@@ -844,6 +844,7 @@ $(srcdir)/generated/findloc0_r10.c \\\n $(srcdir)/generated/findloc0_r16.c \\\n $(srcdir)/generated/findloc0_c4.c \\\n $(srcdir)/generated/findloc0_c8.c \\\n+$(srcdir)/generated/findloc0_c10.c \\\n $(srcdir)/generated/findloc0_c16.c\n \n i_findloc0s_c = \\\n@@ -862,6 +863,7 @@ $(srcdir)/generated/findloc1_r10.c \\\n $(srcdir)/generated/findloc1_r16.c \\\n $(srcdir)/generated/findloc1_c4.c \\\n $(srcdir)/generated/findloc1_c8.c \\\n+$(srcdir)/generated/findloc1_c10.c \\\n $(srcdir)/generated/findloc1_c16.c\n \n i_findloc1s_c = \\\n@@ -1822,6 +1824,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/extends_type_of.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fbuf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file_pos.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_c8.Plo@am__quote@\n@@ -1836,6 +1839,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_s1.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc0_s4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c10.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findloc1_c8.Plo@am__quote@\n@@ -5986,6 +5990,13 @@ findloc0_c8.lo: $(srcdir)/generated/findloc0_c8.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_c8.lo `test -f '$(srcdir)/generated/findloc0_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c8.c\n \n+findloc0_c10.lo: $(srcdir)/generated/findloc0_c10.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_c10.lo -MD -MP -MF $(DEPDIR)/findloc0_c10.Tpo -c -o findloc0_c10.lo `test -f '$(srcdir)/generated/findloc0_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c10.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/findloc0_c10.Tpo $(DEPDIR)/findloc0_c10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$(srcdir)/generated/findloc0_c10.c' object='findloc0_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc0_c10.lo `test -f '$(srcdir)/generated/findloc0_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c10.c\n+\n findloc0_c16.lo: $(srcdir)/generated/findloc0_c16.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc0_c16.lo -MD -MP -MF $(DEPDIR)/findloc0_c16.Tpo -c -o findloc0_c16.lo `test -f '$(srcdir)/generated/findloc0_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc0_c16.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/findloc0_c16.Tpo $(DEPDIR)/findloc0_c16.Plo\n@@ -6084,6 +6095,13 @@ findloc1_c8.lo: $(srcdir)/generated/findloc1_c8.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_c8.lo `test -f '$(srcdir)/generated/findloc1_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c8.c\n \n+findloc1_c10.lo: $(srcdir)/generated/findloc1_c10.c\n+@am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_c10.lo -MD -MP -MF $(DEPDIR)/findloc1_c10.Tpo -c -o findloc1_c10.lo `test -f '$(srcdir)/generated/findloc1_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c10.c\n+@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/findloc1_c10.Tpo $(DEPDIR)/findloc1_c10.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$(srcdir)/generated/findloc1_c10.c' object='findloc1_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o findloc1_c10.lo `test -f '$(srcdir)/generated/findloc1_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c10.c\n+\n findloc1_c16.lo: $(srcdir)/generated/findloc1_c16.c\n @am__fastdepCC_TRUE@\t$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT findloc1_c16.lo -MD -MP -MF $(DEPDIR)/findloc1_c16.Tpo -c -o findloc1_c16.lo `test -f '$(srcdir)/generated/findloc1_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/findloc1_c16.c\n @am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/findloc1_c16.Tpo $(DEPDIR)/findloc1_c16.Plo"}, {"sha": "0936dec54f8eda7923cbc29b7ece420ca7ddd754", "filename": "libgfortran/generated/findloc0_c10.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2Fgenerated%2Ffindloc0_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2Fgenerated%2Ffindloc0_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_c10.c?ref=316fe6b40165c26b30375f8ad85384379133f89b", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+extern void findloc0_c10 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_c10);\n+\n+void\n+findloc0_c10 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_10 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_c10 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_c10);\n+\n+void\n+mfindloc0_c10 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_COMPLEX_10 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_c10 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_c10);\n+\n+void\n+sfindloc0_c10 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc0_c10 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "7b41b7d7687e45134cc2c12e9a25b7b9409f193a", "filename": "libgfortran/generated/findloc1_c10.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2Fgenerated%2Ffindloc1_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2Fgenerated%2Ffindloc1_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_c10.c?ref=316fe6b40165c26b30375f8ad85384379133f89b", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+extern void findloc1_c10 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_c10);\n+\n+extern void\n+findloc1_c10 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_10 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_10 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_c10 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_c10);\n+\n+extern void\n+mfindloc1_c10 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_COMPLEX_10 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_COMPLEX_10 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_c10 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_c10);\n+\n+extern void\n+sfindloc1_c10 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_c10 * const restrict array, GFC_COMPLEX_10 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc1_c10 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}, {"sha": "f74436fd338fae2fc34ca356bf50e0e2b0988cc4", "filename": "libgfortran/gfortran.map", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2Fgfortran.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/316fe6b40165c26b30375f8ad85384379133f89b/libgfortran%2Fgfortran.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgfortran.map?ref=316fe6b40165c26b30375f8ad85384379133f89b", "patch": "@@ -1619,3 +1619,13 @@ GFORTRAN_10 {\n   _gfortran_tand_r10;\n   _gfortran_tand_r16;\n } GFORTRAN_9.2;\n+\n+GFORTRAN_10.2 {\n+  global:\n+  _gfortran_findloc0_c10;\n+  _gfortran_mfindloc0_c10;\n+  _gfortran_sfindloc0_c10;\n+  _gfortran_findloc1_c10;\n+  _gfortran_mfindloc1_c10;\n+  _gfortran_sfindloc1_c10;\n+} GFORTRAN_10;"}]}